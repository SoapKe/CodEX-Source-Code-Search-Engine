{"author": "django", "code": "from django.conf import settings\nfrom django.db import connection, models\nfrom django.test import SimpleTestCase, skipUnlessDBFeature\nfrom django.test.utils import isolate_apps\n\nfrom .models import Book, ChildModel1, ChildModel2\n\n\nclass IndexesTests(SimpleTestCase):\n\n    def test_suffix(self):\n        self.assertEqual(models.Index.suffix, 'idx')\n\n    def test_repr(self):\n        index = models.Index(fields=['title'])\n        multi_col_index = models.Index(fields=['title', 'author'])\n        self.assertEqual(repr(index), \"<Index: fields='title'>\")\n        self.assertEqual(repr(multi_col_index), \"<Index: fields='title, author'>\")\n\n    def test_eq(self):\n        index = models.Index(fields=['title'])\n        same_index = models.Index(fields=['title'])\n        another_index = models.Index(fields=['title', 'author'])\n        index.model = Book\n        same_index.model = Book\n        another_index.model = Book\n        self.assertEqual(index, same_index)\n        self.assertNotEqual(index, another_index)\n\n    def test_index_fields_type(self):\n        with self.assertRaisesMessage(ValueError, 'Index.fields must be a list or tuple.'):\n            models.Index(fields='title')\n\n    def test_fields_tuple(self):\n        self.assertEqual(models.Index(fields=('title',)).fields, ['title'])\n\n    def test_raises_error_without_field(self):\n        msg = 'At least one field is required to define an index.'\n        with self.assertRaisesMessage(ValueError, msg):\n            models.Index()\n\n    def test_max_name_length(self):\n        msg = 'Index names cannot be longer than 30 characters.'\n        with self.assertRaisesMessage(ValueError, msg):\n            models.Index(fields=['title'], name='looooooooooooong_index_name_idx')\n\n    def test_name_constraints(self):\n        msg = 'Index names cannot start with an underscore (_).'\n        with self.assertRaisesMessage(ValueError, msg):\n            models.Index(fields=['title'], name='_name_starting_with_underscore')\n\n        msg = 'Index names cannot start with a number (0-9).'\n        with self.assertRaisesMessage(ValueError, msg):\n            models.Index(fields=['title'], name='5name_starting_with_number')\n\n    def test_name_auto_generation(self):\n        index = models.Index(fields=['author'])\n        index.set_name_with_model(Book)\n        self.assertEqual(index.name, 'model_index_author_0f5565_idx')\n\n        \n        index = models.Index(fields=['-author'])\n        index.set_name_with_model(Book)\n        self.assertEqual(index.name, 'model_index_author_708765_idx')\n\n        \n        long_field_index = models.Index(fields=['pages'])\n        long_field_index.set_name_with_model(Book)\n        self.assertEqual(long_field_index.name, 'model_index_page_co_69235a_idx')\n\n        \n        long_field_index.suffix = 'suff'\n        msg = 'Index too long for multiple database support. Is self.suffix longer than 3 characters?'\n        with self.assertRaisesMessage(AssertionError, msg):\n            long_field_index.set_name_with_model(Book)\n\n    @isolate_apps('model_indexes')\n    def test_name_auto_generation_with_quoted_db_table(self):\n        class QuotedDbTable(models.Model):\n            name = models.CharField(max_length=50)\n\n            class Meta:\n                db_table = '\"t_quoted\"'\n\n        index = models.Index(fields=['name'])\n        index.set_name_with_model(QuotedDbTable)\n        self.assertEqual(index.name, 't_quoted_name_e4ed1b_idx')\n\n    def test_deconstruction(self):\n        index = models.Index(fields=['title'], db_tablespace='idx_tbls')\n        index.set_name_with_model(Book)\n        path, args, kwargs = index.deconstruct()\n        self.assertEqual(path, 'django.db.models.Index')\n        self.assertEqual(args, ())\n        self.assertEqual(\n            kwargs,\n            {'fields': ['title'], 'name': 'model_index_title_196f42_idx', 'db_tablespace': 'idx_tbls'}\n        )\n\n    def test_clone(self):\n        index = models.Index(fields=['title'])\n        new_index = index.clone()\n        self.assertIsNot(index, new_index)\n        self.assertEqual(index.fields, new_index.fields)\n\n    def test_name_set(self):\n        index_names = [index.name for index in Book._meta.indexes]\n        self.assertCountEqual(index_names, ['model_index_title_196f42_idx', 'model_index_isbn_34f975_idx'])\n\n    def test_abstract_children(self):\n        index_names = [index.name for index in ChildModel1._meta.indexes]\n        self.assertEqual(index_names, ['model_index_name_440998_idx'])\n        index_names = [index.name for index in ChildModel2._meta.indexes]\n        self.assertEqual(index_names, ['model_index_name_b6c374_idx'])\n\n    @skipUnlessDBFeature('supports_tablespaces')\n    def test_db_tablespace(self):\n        with connection.schema_editor() as editor:\n            \n            for fields in [\n                \n                ['shortcut'],\n                \n                ['author'],\n                \n                ['shortcut', 'isbn'],\n                \n                ['title', 'author'],\n            ]:\n                with self.subTest(fields=fields):\n                    index = models.Index(fields=fields, db_tablespace='idx_tbls2')\n                    self.assertIn('\"idx_tbls2\"', str(index.create_sql(Book, editor)).lower())\n            \n            for fields in [['author'], ['shortcut', 'isbn'], ['title', 'author']]:\n                with self.subTest(fields=fields):\n                    index = models.Index(fields=fields)\n                    \n                    \n                    \n                    if settings.DEFAULT_INDEX_TABLESPACE:\n                        self.assertIn(\n                            '\"%s\"' % settings.DEFAULT_INDEX_TABLESPACE,\n                            str(index.create_sql(Book, editor)).lower()\n                        )\n                    else:\n                        self.assertNotIn('TABLESPACE', str(index.create_sql(Book, editor)))\n            \n            \n            index = models.Index(fields=['shortcut'])\n            self.assertIn('\"idx_tbls\"', str(index.create_sql(Book, editor)).lower())\n", "comments": "'-' desc columns accounted index name fields may truncated name db_column used naming suffix can't longer 3 characters index db_tablespace attribute field db_tablespace specified model field without db_tablespace specified model multi-column db_tablespaces specified model multi-column without db_tablespace specified model indexes without db_tablespace attribute the default_index_tablespace setting can't tested evaluated model class defined as consequence @override_settings work field db_tablespace specified model index without db_tablespace", "content": "from django.conf import settings\nfrom django.db import connection, models\nfrom django.test import SimpleTestCase, skipUnlessDBFeature\nfrom django.test.utils import isolate_apps\n\nfrom .models import Book, ChildModel1, ChildModel2\n\n\nclass IndexesTests(SimpleTestCase):\n\n    def test_suffix(self):\n        self.assertEqual(models.Index.suffix, 'idx')\n\n    def test_repr(self):\n        index = models.Index(fields=['title'])\n        multi_col_index = models.Index(fields=['title', 'author'])\n        self.assertEqual(repr(index), \"<Index: fields='title'>\")\n        self.assertEqual(repr(multi_col_index), \"<Index: fields='title, author'>\")\n\n    def test_eq(self):\n        index = models.Index(fields=['title'])\n        same_index = models.Index(fields=['title'])\n        another_index = models.Index(fields=['title', 'author'])\n        index.model = Book\n        same_index.model = Book\n        another_index.model = Book\n        self.assertEqual(index, same_index)\n        self.assertNotEqual(index, another_index)\n\n    def test_index_fields_type(self):\n        with self.assertRaisesMessage(ValueError, 'Index.fields must be a list or tuple.'):\n            models.Index(fields='title')\n\n    def test_fields_tuple(self):\n        self.assertEqual(models.Index(fields=('title',)).fields, ['title'])\n\n    def test_raises_error_without_field(self):\n        msg = 'At least one field is required to define an index.'\n        with self.assertRaisesMessage(ValueError, msg):\n            models.Index()\n\n    def test_max_name_length(self):\n        msg = 'Index names cannot be longer than 30 characters.'\n        with self.assertRaisesMessage(ValueError, msg):\n            models.Index(fields=['title'], name='looooooooooooong_index_name_idx')\n\n    def test_name_constraints(self):\n        msg = 'Index names cannot start with an underscore (_).'\n        with self.assertRaisesMessage(ValueError, msg):\n            models.Index(fields=['title'], name='_name_starting_with_underscore')\n\n        msg = 'Index names cannot start with a number (0-9).'\n        with self.assertRaisesMessage(ValueError, msg):\n            models.Index(fields=['title'], name='5name_starting_with_number')\n\n    def test_name_auto_generation(self):\n        index = models.Index(fields=['author'])\n        index.set_name_with_model(Book)\n        self.assertEqual(index.name, 'model_index_author_0f5565_idx')\n\n        # '-' for DESC columns should be accounted for in the index name.\n        index = models.Index(fields=['-author'])\n        index.set_name_with_model(Book)\n        self.assertEqual(index.name, 'model_index_author_708765_idx')\n\n        # fields may be truncated in the name. db_column is used for naming.\n        long_field_index = models.Index(fields=['pages'])\n        long_field_index.set_name_with_model(Book)\n        self.assertEqual(long_field_index.name, 'model_index_page_co_69235a_idx')\n\n        # suffix can't be longer than 3 characters.\n        long_field_index.suffix = 'suff'\n        msg = 'Index too long for multiple database support. Is self.suffix longer than 3 characters?'\n        with self.assertRaisesMessage(AssertionError, msg):\n            long_field_index.set_name_with_model(Book)\n\n    @isolate_apps('model_indexes')\n    def test_name_auto_generation_with_quoted_db_table(self):\n        class QuotedDbTable(models.Model):\n            name = models.CharField(max_length=50)\n\n            class Meta:\n                db_table = '\"t_quoted\"'\n\n        index = models.Index(fields=['name'])\n        index.set_name_with_model(QuotedDbTable)\n        self.assertEqual(index.name, 't_quoted_name_e4ed1b_idx')\n\n    def test_deconstruction(self):\n        index = models.Index(fields=['title'], db_tablespace='idx_tbls')\n        index.set_name_with_model(Book)\n        path, args, kwargs = index.deconstruct()\n        self.assertEqual(path, 'django.db.models.Index')\n        self.assertEqual(args, ())\n        self.assertEqual(\n            kwargs,\n            {'fields': ['title'], 'name': 'model_index_title_196f42_idx', 'db_tablespace': 'idx_tbls'}\n        )\n\n    def test_clone(self):\n        index = models.Index(fields=['title'])\n        new_index = index.clone()\n        self.assertIsNot(index, new_index)\n        self.assertEqual(index.fields, new_index.fields)\n\n    def test_name_set(self):\n        index_names = [index.name for index in Book._meta.indexes]\n        self.assertCountEqual(index_names, ['model_index_title_196f42_idx', 'model_index_isbn_34f975_idx'])\n\n    def test_abstract_children(self):\n        index_names = [index.name for index in ChildModel1._meta.indexes]\n        self.assertEqual(index_names, ['model_index_name_440998_idx'])\n        index_names = [index.name for index in ChildModel2._meta.indexes]\n        self.assertEqual(index_names, ['model_index_name_b6c374_idx'])\n\n    @skipUnlessDBFeature('supports_tablespaces')\n    def test_db_tablespace(self):\n        with connection.schema_editor() as editor:\n            # Index with db_tablespace attribute.\n            for fields in [\n                # Field with db_tablespace specified on model.\n                ['shortcut'],\n                # Field without db_tablespace specified on model.\n                ['author'],\n                # Multi-column with db_tablespaces specified on model.\n                ['shortcut', 'isbn'],\n                # Multi-column without db_tablespace specified on model.\n                ['title', 'author'],\n            ]:\n                with self.subTest(fields=fields):\n                    index = models.Index(fields=fields, db_tablespace='idx_tbls2')\n                    self.assertIn('\"idx_tbls2\"', str(index.create_sql(Book, editor)).lower())\n            # Indexes without db_tablespace attribute.\n            for fields in [['author'], ['shortcut', 'isbn'], ['title', 'author']]:\n                with self.subTest(fields=fields):\n                    index = models.Index(fields=fields)\n                    # The DEFAULT_INDEX_TABLESPACE setting can't be tested\n                    # because it's evaluated when the model class is defined.\n                    # As a consequence, @override_settings doesn't work.\n                    if settings.DEFAULT_INDEX_TABLESPACE:\n                        self.assertIn(\n                            '\"%s\"' % settings.DEFAULT_INDEX_TABLESPACE,\n                            str(index.create_sql(Book, editor)).lower()\n                        )\n                    else:\n                        self.assertNotIn('TABLESPACE', str(index.create_sql(Book, editor)))\n            # Field with db_tablespace specified on the model and an index\n            # without db_tablespace.\n            index = models.Index(fields=['shortcut'])\n            self.assertIn('\"idx_tbls\"', str(index.create_sql(Book, editor)).lower())\n", "description": "The Web framework for perfectionists with deadlines.", "file_name": "tests.py", "id": "00079a30e483b79acf981b9ad69e38cc", "language": "Python", "project_name": "django", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/django-django/django-django-acfc650/tests/model_indexes/tests.py", "save_time": "", "source": "", "update_at": "2018-03-14T02:00:36Z", "url": "https://github.com/django/django", "wiki": false}