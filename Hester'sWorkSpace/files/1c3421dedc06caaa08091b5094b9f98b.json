{"author": "USArmyResearchLab", "code": "import dshell\nimport dpkt\nimport socket\nfrom dnsdecoder import DNSDecoder\n\n\nclass DshellDecoder(DNSDecoder):\n\n    def __init__(self):\n        DNSDecoder.__init__(self,\n                            name='dns-asn',\n                            description='identify AS of DNS A/AAAA record responses',\n                            filter='(port 53)',\n                            author='bg',\n                            cleanupinterval=10,\n                            maxblobs=2,\n                            )\n\n    def decode_q(self, dns):\n        queried = \"\"\n        if dns.qd[0].type == dpkt.dns.DNS_A:\n            queried = queried + \"A? %s\" % (dns.qd[0].name)\n        if dns.qd[0].type == dpkt.dns.DNS_AAAA:\n            queried = queried + \"AAAA? %s\" % (dns.qd[0].name)\n        return queried\n\n    def DNSHandler(self, conn, request, response, **kwargs):\n        anstext = ''\n        queried = ''\n        id = None\n        for dns in request, response:\n            if dns is None:\n                continue\n            id = dns.id\n            \n            if dns.qr == dpkt.dns.DNS_Q:\n                conn.info(query=self.decode_q(dns))\n\n            \n            elif (dns.qr == dpkt.dns.DNS_A and dns.rcode == dpkt.dns.DNS_RCODE_NOERR and len(dns.an) > 0):\n\n                queried = self.decode_q(dns)\n\n                answers = []\n                for an in dns.an:\n                    if an.type == dpkt.dns.DNS_A:\n                        try:\n                            cc = self.getASN(socket.inet_ntoa(an.ip))\n                            answers.append(\n                                'A: %s (%s) (ttl %s)' % (socket.inet_ntoa(an.ip), cc, an.ttl))\n                        except:\n                            continue\n                    elif an.type == dpkt.dns.DNS_AAAA:\n                        try:\n                            cc = self.getASN(\n                                socket.inet_ntop(socket.AF_INET6, an.ip6))\n                            answers.append('AAAA: %s (%s) (ttl %s)' % (\n                                socket.inet_ntop(socket.AF_INET6, an.ip6), cc, an.ttl))\n                        except:\n                            continue\n                    else:\n                        \n                        continue\n                if queried != '':\n                    anstext = \", \".join(answers)\n\n        if anstext:  ?\n            self.alert(\n                str(id) + ' ' + queried + ' / ' + anstext, **conn.info(response=anstext))\n\n\nif __name__ == '__main__':\n    dObj = DshellDecoder()\n    print dObj\nelse:\n    dObj = DshellDecoder()\n", "comments": "  dns question  update connection info query    dns answer data errors    un handled type    get answer  ", "content": "import dshell\nimport dpkt\nimport socket\nfrom dnsdecoder import DNSDecoder\n\n\nclass DshellDecoder(DNSDecoder):\n\n    def __init__(self):\n        DNSDecoder.__init__(self,\n                            name='dns-asn',\n                            description='identify AS of DNS A/AAAA record responses',\n                            filter='(port 53)',\n                            author='bg',\n                            cleanupinterval=10,\n                            maxblobs=2,\n                            )\n\n    def decode_q(self, dns):\n        queried = \"\"\n        if dns.qd[0].type == dpkt.dns.DNS_A:\n            queried = queried + \"A? %s\" % (dns.qd[0].name)\n        if dns.qd[0].type == dpkt.dns.DNS_AAAA:\n            queried = queried + \"AAAA? %s\" % (dns.qd[0].name)\n        return queried\n\n    def DNSHandler(self, conn, request, response, **kwargs):\n        anstext = ''\n        queried = ''\n        id = None\n        for dns in request, response:\n            if dns is None:\n                continue\n            id = dns.id\n            # DNS Question, update connection info with query\n            if dns.qr == dpkt.dns.DNS_Q:\n                conn.info(query=self.decode_q(dns))\n\n            # DNS Answer with data and no errors\n            elif (dns.qr == dpkt.dns.DNS_A and dns.rcode == dpkt.dns.DNS_RCODE_NOERR and len(dns.an) > 0):\n\n                queried = self.decode_q(dns)\n\n                answers = []\n                for an in dns.an:\n                    if an.type == dpkt.dns.DNS_A:\n                        try:\n                            cc = self.getASN(socket.inet_ntoa(an.ip))\n                            answers.append(\n                                'A: %s (%s) (ttl %s)' % (socket.inet_ntoa(an.ip), cc, an.ttl))\n                        except:\n                            continue\n                    elif an.type == dpkt.dns.DNS_AAAA:\n                        try:\n                            cc = self.getASN(\n                                socket.inet_ntop(socket.AF_INET6, an.ip6))\n                            answers.append('AAAA: %s (%s) (ttl %s)' % (\n                                socket.inet_ntop(socket.AF_INET6, an.ip6), cc, an.ttl))\n                        except:\n                            continue\n                    else:\n                        # un-handled type\n                        continue\n                if queried != '':\n                    anstext = \", \".join(answers)\n\n        if anstext:  # did we get an answer?\n            self.alert(\n                str(id) + ' ' + queried + ' / ' + anstext, **conn.info(response=anstext))\n\n\nif __name__ == '__main__':\n    dObj = DshellDecoder()\n    print dObj\nelse:\n    dObj = DshellDecoder()\n", "description": "Dshell is a network forensic analysis framework.", "file_name": "dns-asn.py", "id": "1c3421dedc06caaa08091b5094b9f98b", "language": "Python", "project_name": "Dshell", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/USArmyResearchLab-Dshell/USArmyResearchLab-Dshell-5850adf/decoders/dns/dns-asn.py", "save_time": "", "source": "", "update_at": "2018-03-18T10:01:29Z", "url": "https://github.com/USArmyResearchLab/Dshell", "wiki": true}