{"author": "ansible", "code": "\n -*- coding: utf-8 -*-\n\n (C) 2017 Red Hat Inc.\n Copyright (C) 2017 Lenovo.\n\n GNU General Public License v3.0+\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n Module to Collect facts from Lenovo Switches running Lenovo ENOS commands\n Lenovo Networking\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = '''\n---\nmodule: enos_facts\nversion_added: \"2.5\"\nauthor: \"Anil Kumar Muraleedharan (@amuraleedhar)\"\nshort_description: Collect facts from remote devices running Lenovo ENOS\ndescription:\n  - Collects a base set of device facts from a remote Lenovo device\n    running on ENOS.  This module prepends all of the\n    base network fact keys with C(ansible_net_<fact>).  The facts\n    module will always collect a base set of facts from the device\n    and can enable or disable collection of additional facts.\nextends_documentation_fragment: enos\nnotes:\n  - Tested against ENOS 8.4.1.68\noptions:\n  gather_subset:\n    description:\n      - When supplied, this argument will restrict the facts collected\n        to a given subset.  Possible values for this argument include\n        all, hardware, config, and interfaces.  Can specify a list of\n        values to include a larger subset.  Values can also be used\n        with an initial C(M(!)) to specify that a specific subset should\n        not be collected.\n    required: false\n    default: '!config'\n'''\nEXAMPLES = '''\nTasks: The following are examples of using the module enos_facts.\n---\n- name: Test Enos Facts\n  enos_facts:\n    provider={{ cli }}\n\n  vars:\n    cli:\n      host: \"{{ inventory_hostname }}\"\n      port: 22\n      username: admin\n      password: admin\n      transport: cli\n      timeout: 30\n      authorize: True\n      auth_pass:\n\n---\n Collect all facts from the device\n- enos_facts:\n    gather_subset: all\n    provider: \"{{ cli }}\"\n\n Collect only the config and default facts\n- enos_facts:\n    gather_subset:\n      - config\n    provider: \"{{ cli }}\"\n\n Do not collect hardware facts\n- enos_facts:\n    gather_subset:\n      - \"!hardware\"\n    provider: \"{{ cli }}\"\n\n'''\nRETURN = '''\n  ansible_net_gather_subset:\n    description: The list of fact subsets collected from the device\n    returned: always\n    type: list\n default\n  ansible_net_model:\n    description: The model name returned from the Lenovo ENOS device\n    returned: always\n    type: str\n  ansible_net_serialnum:\n    description: The serial number of the Lenovo ENOS device\n    returned: always\n    type: str\n  ansible_net_version:\n    description: The ENOS operating system version running on the remote device\n    returned: always\n    type: str\n  ansible_net_hostname:\n    description: The configured hostname of the device\n    returned: always\n    type: string\n  ansible_net_image:\n    description: Indicates the active image for the device\n    returned: always\n    type: string\n hardware\n  ansible_net_memfree_mb:\n    description: The available free memory on the remote device in MB\n    returned: when hardware is configured\n    type: int\n config\n  ansible_net_config:\n    description: The current active config from the device\n    returned: when config is configured\n    type: str\n interfaces\n  ansible_net_all_ipv4_addresses:\n    description: All IPv4 addresses configured on the device\n    returned: when interfaces is configured\n    type: list\n  ansible_net_all_ipv6_addresses:\n    description: All IPv6 addresses configured on the device\n    returned: when interfaces is configured\n    type: list\n  ansible_net_interfaces:\n    description: A hash of all interfaces running on the system.\n      This gives information on description, mac address, mtu, speed,\n      duplex and operstatus\n    returned: when interfaces is configured\n    type: dict\n  ansible_net_neighbors:\n    description: The list of LLDP neighbors from the remote device\n    returned: when interfaces is configured\n    type: dict\n'''\n\nimport re\n\nfrom ansible.module_utils.network.enos.enos import run_commands, enos_argument_spec, check_args\nfrom ansible.module_utils._text import to_text\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.six import iteritems\nfrom ansible.module_utils.six.moves import zip\n\n\nclass FactsBase(object):\n\n    COMMANDS = list()\n\n    def __init__(self, module):\n        self.module = module\n        self.facts = dict()\n        self.responses = None\n        self.PERSISTENT_COMMAND_TIMEOUT = 60\n\n    def populate(self):\n        self.responses = run_commands(self.module, self.COMMANDS,\n                                      check_rc=False)\n\n    def run(self, cmd):\n        return run_commands(self.module, cmd, check_rc=False)\n\n\nclass Default(FactsBase):\n\n    COMMANDS = ['show version', 'show run']\n\n    def populate(self):\n        super(Default, self).populate()\n        data = self.responses[0]\n        data_run = self.responses[1]\n        if data:\n            self.facts['version'] = self.parse_version(data)\n            self.facts['serialnum'] = self.parse_serialnum(data)\n            self.facts['model'] = self.parse_model(data)\n            self.facts['image'] = self.parse_image(data)\n        if data_run:\n            self.facts['hostname'] = self.parse_hostname(data_run)\n\n    def parse_version(self, data):\n        match = re.search(r'^Software Version (.*?) ', data, re.M | re.I)\n        if match:\n            return match.group(1)\n\n    def parse_hostname(self, data_run):\n        for line in data_run.split('\\n'):\n            line = line.strip()\n            match = re.match(r'hostname (.*?)', line, re.M | re.I)\n            if match:\n                hosts = line.split()\n                hostname = hosts[1].strip('\\\"')\n                return hostname\n        return \"NA\"\n\n    def parse_model(self, data):\n        match = re.search(r'^Lenovo RackSwitch (\\S+)', data, re.M | re.I)\n        if match:\n            return match.group(1)\n\n    def parse_image(self, data):\n        match = re.search(r'(.*) image1(.*)', data, re.M | re.I)\n        if match:\n            return \"Image1\"\n        else:\n            return \"Image2\"\n\n    def parse_serialnum(self, data):\n        match = re.search(r'^Switch Serial No:  (\\S+)', data, re.M | re.I)\n        if match:\n            return match.group(1)\n\n\nclass Hardware(FactsBase):\n\n    COMMANDS = [\n        'show system memory'\n    ]\n\n    def populate(self):\n        super(Hardware, self).populate()\n        data = self.run(['show system memory'])\n        data = to_text(data, errors='surrogate_or_strict').strip()\n        data = data.replace(r\"\\n\", \"\\n\")\n        if data:\n            self.facts['memtotal_mb'] = self.parse_memtotal(data)\n            self.facts['memfree_mb'] = self.parse_memfree(data)\n\n    def parse_memtotal(self, data):\n        match = re.search(r'^MemTotal:\\s*(.*) kB', data, re.M | re.I)\n        if match:\n            return int(match.group(1)) / 1024\n\n    def parse_memfree(self, data):\n        match = re.search(r'^MemFree:\\s*(.*) kB', data, re.M | re.I)\n        if match:\n            return int(match.group(1)) / 1024\n\n\nclass Config(FactsBase):\n\n    COMMANDS = ['show running-config']\n\n    def populate(self):\n        super(Config, self).populate()\n        data = self.responses[0]\n        if data:\n            self.facts['config'] = data\n\n\nclass Interfaces(FactsBase):\n\n    COMMANDS = ['show interface status']\n\n    def populate(self):\n        super(Interfaces, self).populate()\n\n        self.facts['all_ipv4_addresses'] = list()\n        self.facts['all_ipv6_addresses'] = list()\n\n        data1 = self.run(['show interface status'])\n        data1 = to_text(data1, errors='surrogate_or_strict').strip()\n        data1 = data1.replace(r\"\\n\", \"\\n\")\n        data2 = self.run(['show lldp port'])\n        data2 = to_text(data2, errors='surrogate_or_strict').strip()\n        data2 = data2.replace(r\"\\n\", \"\\n\")\n        lines1 = None\n        lines2 = None\n        if data1:\n            lines1 = self.parse_interfaces(data1)\n        if data2:\n            lines2 = self.parse_interfaces(data2)\n        if lines1 is not None and lines2 is not None:\n            self.facts['interfaces'] = self.populate_interfaces(lines1, lines2)\n        data3 = self.run(['show lldp remote-device port'])\n        data3 = to_text(data3, errors='surrogate_or_strict').strip()\n        data3 = data3.replace(r\"\\n\", \"\\n\")\n\n        lines3 = None\n        if data3:\n            lines3 = self.parse_neighbors(data3)\n        if lines3 is not None:\n            self.facts['neighbors'] = self.populate_neighbors(lines3)\n\n        data4 = self.run(['show interface ip'])\n        data4 = data4[0].split('\\n')\n        lines4 = None\n        if data4:\n            lines4 = self.parse_ipaddresses(data4)\n            ipv4_interfaces = self.set_ipv4_interfaces(lines4)\n            self.facts['all_ipv4_addresses'] = ipv4_interfaces\n            ipv6_interfaces = self.set_ipv6_interfaces(lines4)\n            self.facts['all_ipv6_addresses'] = ipv6_interfaces\n\n    def parse_ipaddresses(self, data4):\n        parsed = list()\n        for line in data4:\n            if len(line) == 0:\n                continue\n            else:\n                line = line.strip()\n                if len(line) == 0:\n                    continue\n                match = re.search(r'IP4', line, re.M | re.I)\n                if match:\n                    key = match.group()\n                    parsed.append(line)\n                match = re.search(r'IP6', line, re.M | re.I)\n                if match:\n                    key = match.group()\n                    parsed.append(line)\n        return parsed\n\n    def set_ipv4_interfaces(self, line4):\n        ipv4_addresses = list()\n        for line in line4:\n            ipv4Split = line.split()\n            if ipv4Split[1] == \"IP4\":\n                ipv4_addresses.append(ipv4Split[2])\n        return ipv4_addresses\n\n    def set_ipv6_interfaces(self, line4):\n        ipv6_addresses = list()\n        for line in line4:\n            ipv6Split = line.split()\n            if ipv6Split[1] == \"IP6\":\n                ipv6_addresses.append(ipv6Split[2])\n        return ipv6_addresses\n\n    def populate_neighbors(self, lines3):\n        neighbors = dict()\n        for line in lines3:\n            neighborSplit = line.split(\"|\")\n            innerData = dict()\n            innerData['Remote Chassis ID'] = neighborSplit[2].strip()\n            innerData['Remote Port'] = neighborSplit[3].strip()\n            sysName = neighborSplit[4].strip()\n            if sysName is not None:\n                innerData['Remote System Name'] = neighborSplit[4].strip()\n            else:\n                innerData['Remote System Name'] = \"NA\"\n            neighbors[neighborSplit[0].strip()] = innerData\n        return neighbors\n\n    def populate_interfaces(self, lines1, lines2):\n        interfaces = dict()\n        for line1, line2 in zip(lines1, lines2):\n            line = line1 + \"  \" + line2\n            intfSplit = line.split()\n            innerData = dict()\n            innerData['description'] = intfSplit[6].strip()\n            innerData['macaddress'] = intfSplit[8].strip()\n            innerData['mtu'] = intfSplit[9].strip()\n            innerData['speed'] = intfSplit[1].strip()\n            innerData['duplex'] = intfSplit[2].strip()\n            innerData['operstatus'] = intfSplit[5].strip()\n            if(\"up\" not in intfSplit[5].strip()) and (\"down\" not in intfSplit[5].strip()):\n                innerData['description'] = intfSplit[7].strip()\n                innerData['macaddress'] = intfSplit[9].strip()\n                innerData['mtu'] = intfSplit[10].strip()\n                innerData['operstatus'] = intfSplit[6].strip()\n            interfaces[intfSplit[0].strip()] = innerData\n        return interfaces\n\n    def parse_neighbors(self, neighbors):\n        parsed = list()\n        for line in neighbors.split('\\n'):\n            if len(line) == 0:\n                continue\n            else:\n                line = line.strip()\n                match = re.match(r'^([0-9]+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed.append(line)\n                match = re.match(r'^(INT+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed.append(line)\n                match = re.match(r'^(EXT+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed.append(line)\n                match = re.match(r'^(MGT+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed.append(line)\n        return parsed\n\n    def parse_interfaces(self, data):\n        parsed = list()\n        for line in data.split('\\n'):\n            if len(line) == 0:\n                continue\n            else:\n                line = line.strip()\n                match = re.match(r'^([0-9]+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed.append(line)\n                match = re.match(r'^(INT+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed.append(line)\n                match = re.match(r'^(EXT+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed.append(line)\n                match = re.match(r'^(MGT+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed.append(line)\n        return parsed\n\nFACT_SUBSETS = dict(\n    default=Default,\n    hardware=Hardware,\n    interfaces=Interfaces,\n    config=Config,\n)\n\nVALID_SUBSETS = frozenset(FACT_SUBSETS.keys())\n\nPERSISTENT_COMMAND_TIMEOUT = 60\n\n\ndef main():\n    \n    argument_spec = dict(\n        gather_subset=dict(default=['!config'], type='list')\n    )\n\n    argument_spec.update(enos_argument_spec)\n\n    module = AnsibleModule(argument_spec=argument_spec,\n                           supports_check_mode=True)\n\n    gather_subset = module.params['gather_subset']\n\n    runable_subsets = set()\n    exclude_subsets = set()\n\n    for subset in gather_subset:\n        if subset == 'all':\n            runable_subsets.update(VALID_SUBSETS)\n            continue\n\n        if subset.startswith('!'):\n            subset = subset[1:]\n            if subset == 'all':\n                exclude_subsets.update(VALID_SUBSETS)\n                continue\n            exclude = True\n        else:\n            exclude = False\n\n        if subset not in VALID_SUBSETS:\n            module.fail_json(msg='Bad subset')\n\n        if exclude:\n            exclude_subsets.add(subset)\n        else:\n            runable_subsets.add(subset)\n\n    if not runable_subsets:\n        runable_subsets.update(VALID_SUBSETS)\n\n    runable_subsets.difference_update(exclude_subsets)\n    runable_subsets.add('default')\n\n    facts = dict()\n    facts['gather_subset'] = list(runable_subsets)\n\n    instances = list()\n    for key in runable_subsets:\n        instances.append(FACT_SUBSETS[key](module))\n\n    for inst in instances:\n        inst.populate()\n        facts.update(inst.facts)\n\n    ansible_facts = dict()\n    for key, value in iteritems(facts):\n        key = 'ansible_net_%s' % key\n        ansible_facts[key] = value\n\n    warnings = list()\n    check_args(module, warnings)\n\n    module.exit_json(ansible_facts=ansible_facts, warnings=warnings)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "   main entry point module execution                  module  enos facts version added   2 5  author   anil kumar muraleedharan ( amuraleedhar)  short description  collect facts remote devices running lenovo enos description      collects base set device facts remote lenovo device     running enos   this module prepends     base network fact keys c(ansible net  fact )   the facts     module always collect base set facts device     enable disable collection additional facts  extends documentation fragment  enos notes      tested enos 8 4 1 68 options    gather subset      description          when supplied  argument restrict facts collected         given subset   possible values argument include          hardware  config  interfaces   can specify list         values include larger subset   values also used         initial c(m( )) specify specific subset         collected      required  false     default    config      examples       tasks  the following examples using module enos facts        name  test enos facts   enos facts      provider    cli       vars      cli        host      inventory hostname           port  22       username  admin       password  admin       transport  cli       timeout  30       authorize  true       auth pass         collect facts device   enos facts      gather subset      provider      cli        collect config default facts   enos facts      gather subset          config     provider      cli        do collect hardware facts   enos facts      gather subset            hardware      provider      cli          return         ansible net gather subset      description  the list fact subsets collected device     returned  always     type  list   default   ansible net model      description  the model name returned lenovo enos device     returned  always     type  str   ansible net serialnum      description  the serial number lenovo enos device     returned  always     type  str   ansible net version      description  the enos operating system version running remote device     returned  always     type  str   ansible net hostname      description  the configured hostname device     returned  always     type  string   ansible net image      description  indicates active image device     returned  always     type  string   hardware   ansible net memfree mb      description  the available free memory remote device mb     returned  hardware configured     type  int   config   ansible net config      description  the current active config device     returned  config configured     type  str   interfaces   ansible net ipv4 addresses      description  all ipv4 addresses configured device     returned  interfaces configured     type  list   ansible net ipv6 addresses      description  all ipv6 addresses configured device     returned  interfaces configured     type  list   ansible net interfaces      description  a hash interfaces running system        this gives information description  mac address  mtu  speed        duplex operstatus     returned  interfaces configured     type  dict   ansible net neighbors      description  the list lldp neighbors remote device     returned  interfaces configured     type  dict         usr bin python        coding  utf 8           (c) 2017 red hat inc     copyright (c) 2017 lenovo        gnu general public license v3 0        this program distributed hope useful     without any warranty  without even implied warranty    merchantability fitness for a particular purpose   see    gnu general public license details        (see copying https   www gnu org licenses gpl 3 0 txt)    module collect facts lenovo switches running lenovo enos commands    lenovo networking       collect facts device    collect config default facts    do collect hardware facts    default    hardware    config    interfaces ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n#\n# (C) 2017 Red Hat Inc.\n# Copyright (C) 2017 Lenovo.\n#\n# GNU General Public License v3.0+\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n# Module to Collect facts from Lenovo Switches running Lenovo ENOS commands\n# Lenovo Networking\n#\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = '''\n---\nmodule: enos_facts\nversion_added: \"2.5\"\nauthor: \"Anil Kumar Muraleedharan (@amuraleedhar)\"\nshort_description: Collect facts from remote devices running Lenovo ENOS\ndescription:\n  - Collects a base set of device facts from a remote Lenovo device\n    running on ENOS.  This module prepends all of the\n    base network fact keys with C(ansible_net_<fact>).  The facts\n    module will always collect a base set of facts from the device\n    and can enable or disable collection of additional facts.\nextends_documentation_fragment: enos\nnotes:\n  - Tested against ENOS 8.4.1.68\noptions:\n  gather_subset:\n    description:\n      - When supplied, this argument will restrict the facts collected\n        to a given subset.  Possible values for this argument include\n        all, hardware, config, and interfaces.  Can specify a list of\n        values to include a larger subset.  Values can also be used\n        with an initial C(M(!)) to specify that a specific subset should\n        not be collected.\n    required: false\n    default: '!config'\n'''\nEXAMPLES = '''\nTasks: The following are examples of using the module enos_facts.\n---\n- name: Test Enos Facts\n  enos_facts:\n    provider={{ cli }}\n\n  vars:\n    cli:\n      host: \"{{ inventory_hostname }}\"\n      port: 22\n      username: admin\n      password: admin\n      transport: cli\n      timeout: 30\n      authorize: True\n      auth_pass:\n\n---\n# Collect all facts from the device\n- enos_facts:\n    gather_subset: all\n    provider: \"{{ cli }}\"\n\n# Collect only the config and default facts\n- enos_facts:\n    gather_subset:\n      - config\n    provider: \"{{ cli }}\"\n\n# Do not collect hardware facts\n- enos_facts:\n    gather_subset:\n      - \"!hardware\"\n    provider: \"{{ cli }}\"\n\n'''\nRETURN = '''\n  ansible_net_gather_subset:\n    description: The list of fact subsets collected from the device\n    returned: always\n    type: list\n# default\n  ansible_net_model:\n    description: The model name returned from the Lenovo ENOS device\n    returned: always\n    type: str\n  ansible_net_serialnum:\n    description: The serial number of the Lenovo ENOS device\n    returned: always\n    type: str\n  ansible_net_version:\n    description: The ENOS operating system version running on the remote device\n    returned: always\n    type: str\n  ansible_net_hostname:\n    description: The configured hostname of the device\n    returned: always\n    type: string\n  ansible_net_image:\n    description: Indicates the active image for the device\n    returned: always\n    type: string\n# hardware\n  ansible_net_memfree_mb:\n    description: The available free memory on the remote device in MB\n    returned: when hardware is configured\n    type: int\n# config\n  ansible_net_config:\n    description: The current active config from the device\n    returned: when config is configured\n    type: str\n# interfaces\n  ansible_net_all_ipv4_addresses:\n    description: All IPv4 addresses configured on the device\n    returned: when interfaces is configured\n    type: list\n  ansible_net_all_ipv6_addresses:\n    description: All IPv6 addresses configured on the device\n    returned: when interfaces is configured\n    type: list\n  ansible_net_interfaces:\n    description: A hash of all interfaces running on the system.\n      This gives information on description, mac address, mtu, speed,\n      duplex and operstatus\n    returned: when interfaces is configured\n    type: dict\n  ansible_net_neighbors:\n    description: The list of LLDP neighbors from the remote device\n    returned: when interfaces is configured\n    type: dict\n'''\n\nimport re\n\nfrom ansible.module_utils.network.enos.enos import run_commands, enos_argument_spec, check_args\nfrom ansible.module_utils._text import to_text\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.six import iteritems\nfrom ansible.module_utils.six.moves import zip\n\n\nclass FactsBase(object):\n\n    COMMANDS = list()\n\n    def __init__(self, module):\n        self.module = module\n        self.facts = dict()\n        self.responses = None\n        self.PERSISTENT_COMMAND_TIMEOUT = 60\n\n    def populate(self):\n        self.responses = run_commands(self.module, self.COMMANDS,\n                                      check_rc=False)\n\n    def run(self, cmd):\n        return run_commands(self.module, cmd, check_rc=False)\n\n\nclass Default(FactsBase):\n\n    COMMANDS = ['show version', 'show run']\n\n    def populate(self):\n        super(Default, self).populate()\n        data = self.responses[0]\n        data_run = self.responses[1]\n        if data:\n            self.facts['version'] = self.parse_version(data)\n            self.facts['serialnum'] = self.parse_serialnum(data)\n            self.facts['model'] = self.parse_model(data)\n            self.facts['image'] = self.parse_image(data)\n        if data_run:\n            self.facts['hostname'] = self.parse_hostname(data_run)\n\n    def parse_version(self, data):\n        match = re.search(r'^Software Version (.*?) ', data, re.M | re.I)\n        if match:\n            return match.group(1)\n\n    def parse_hostname(self, data_run):\n        for line in data_run.split('\\n'):\n            line = line.strip()\n            match = re.match(r'hostname (.*?)', line, re.M | re.I)\n            if match:\n                hosts = line.split()\n                hostname = hosts[1].strip('\\\"')\n                return hostname\n        return \"NA\"\n\n    def parse_model(self, data):\n        match = re.search(r'^Lenovo RackSwitch (\\S+)', data, re.M | re.I)\n        if match:\n            return match.group(1)\n\n    def parse_image(self, data):\n        match = re.search(r'(.*) image1(.*)', data, re.M | re.I)\n        if match:\n            return \"Image1\"\n        else:\n            return \"Image2\"\n\n    def parse_serialnum(self, data):\n        match = re.search(r'^Switch Serial No:  (\\S+)', data, re.M | re.I)\n        if match:\n            return match.group(1)\n\n\nclass Hardware(FactsBase):\n\n    COMMANDS = [\n        'show system memory'\n    ]\n\n    def populate(self):\n        super(Hardware, self).populate()\n        data = self.run(['show system memory'])\n        data = to_text(data, errors='surrogate_or_strict').strip()\n        data = data.replace(r\"\\n\", \"\\n\")\n        if data:\n            self.facts['memtotal_mb'] = self.parse_memtotal(data)\n            self.facts['memfree_mb'] = self.parse_memfree(data)\n\n    def parse_memtotal(self, data):\n        match = re.search(r'^MemTotal:\\s*(.*) kB', data, re.M | re.I)\n        if match:\n            return int(match.group(1)) / 1024\n\n    def parse_memfree(self, data):\n        match = re.search(r'^MemFree:\\s*(.*) kB', data, re.M | re.I)\n        if match:\n            return int(match.group(1)) / 1024\n\n\nclass Config(FactsBase):\n\n    COMMANDS = ['show running-config']\n\n    def populate(self):\n        super(Config, self).populate()\n        data = self.responses[0]\n        if data:\n            self.facts['config'] = data\n\n\nclass Interfaces(FactsBase):\n\n    COMMANDS = ['show interface status']\n\n    def populate(self):\n        super(Interfaces, self).populate()\n\n        self.facts['all_ipv4_addresses'] = list()\n        self.facts['all_ipv6_addresses'] = list()\n\n        data1 = self.run(['show interface status'])\n        data1 = to_text(data1, errors='surrogate_or_strict').strip()\n        data1 = data1.replace(r\"\\n\", \"\\n\")\n        data2 = self.run(['show lldp port'])\n        data2 = to_text(data2, errors='surrogate_or_strict').strip()\n        data2 = data2.replace(r\"\\n\", \"\\n\")\n        lines1 = None\n        lines2 = None\n        if data1:\n            lines1 = self.parse_interfaces(data1)\n        if data2:\n            lines2 = self.parse_interfaces(data2)\n        if lines1 is not None and lines2 is not None:\n            self.facts['interfaces'] = self.populate_interfaces(lines1, lines2)\n        data3 = self.run(['show lldp remote-device port'])\n        data3 = to_text(data3, errors='surrogate_or_strict').strip()\n        data3 = data3.replace(r\"\\n\", \"\\n\")\n\n        lines3 = None\n        if data3:\n            lines3 = self.parse_neighbors(data3)\n        if lines3 is not None:\n            self.facts['neighbors'] = self.populate_neighbors(lines3)\n\n        data4 = self.run(['show interface ip'])\n        data4 = data4[0].split('\\n')\n        lines4 = None\n        if data4:\n            lines4 = self.parse_ipaddresses(data4)\n            ipv4_interfaces = self.set_ipv4_interfaces(lines4)\n            self.facts['all_ipv4_addresses'] = ipv4_interfaces\n            ipv6_interfaces = self.set_ipv6_interfaces(lines4)\n            self.facts['all_ipv6_addresses'] = ipv6_interfaces\n\n    def parse_ipaddresses(self, data4):\n        parsed = list()\n        for line in data4:\n            if len(line) == 0:\n                continue\n            else:\n                line = line.strip()\n                if len(line) == 0:\n                    continue\n                match = re.search(r'IP4', line, re.M | re.I)\n                if match:\n                    key = match.group()\n                    parsed.append(line)\n                match = re.search(r'IP6', line, re.M | re.I)\n                if match:\n                    key = match.group()\n                    parsed.append(line)\n        return parsed\n\n    def set_ipv4_interfaces(self, line4):\n        ipv4_addresses = list()\n        for line in line4:\n            ipv4Split = line.split()\n            if ipv4Split[1] == \"IP4\":\n                ipv4_addresses.append(ipv4Split[2])\n        return ipv4_addresses\n\n    def set_ipv6_interfaces(self, line4):\n        ipv6_addresses = list()\n        for line in line4:\n            ipv6Split = line.split()\n            if ipv6Split[1] == \"IP6\":\n                ipv6_addresses.append(ipv6Split[2])\n        return ipv6_addresses\n\n    def populate_neighbors(self, lines3):\n        neighbors = dict()\n        for line in lines3:\n            neighborSplit = line.split(\"|\")\n            innerData = dict()\n            innerData['Remote Chassis ID'] = neighborSplit[2].strip()\n            innerData['Remote Port'] = neighborSplit[3].strip()\n            sysName = neighborSplit[4].strip()\n            if sysName is not None:\n                innerData['Remote System Name'] = neighborSplit[4].strip()\n            else:\n                innerData['Remote System Name'] = \"NA\"\n            neighbors[neighborSplit[0].strip()] = innerData\n        return neighbors\n\n    def populate_interfaces(self, lines1, lines2):\n        interfaces = dict()\n        for line1, line2 in zip(lines1, lines2):\n            line = line1 + \"  \" + line2\n            intfSplit = line.split()\n            innerData = dict()\n            innerData['description'] = intfSplit[6].strip()\n            innerData['macaddress'] = intfSplit[8].strip()\n            innerData['mtu'] = intfSplit[9].strip()\n            innerData['speed'] = intfSplit[1].strip()\n            innerData['duplex'] = intfSplit[2].strip()\n            innerData['operstatus'] = intfSplit[5].strip()\n            if(\"up\" not in intfSplit[5].strip()) and (\"down\" not in intfSplit[5].strip()):\n                innerData['description'] = intfSplit[7].strip()\n                innerData['macaddress'] = intfSplit[9].strip()\n                innerData['mtu'] = intfSplit[10].strip()\n                innerData['operstatus'] = intfSplit[6].strip()\n            interfaces[intfSplit[0].strip()] = innerData\n        return interfaces\n\n    def parse_neighbors(self, neighbors):\n        parsed = list()\n        for line in neighbors.split('\\n'):\n            if len(line) == 0:\n                continue\n            else:\n                line = line.strip()\n                match = re.match(r'^([0-9]+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed.append(line)\n                match = re.match(r'^(INT+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed.append(line)\n                match = re.match(r'^(EXT+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed.append(line)\n                match = re.match(r'^(MGT+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed.append(line)\n        return parsed\n\n    def parse_interfaces(self, data):\n        parsed = list()\n        for line in data.split('\\n'):\n            if len(line) == 0:\n                continue\n            else:\n                line = line.strip()\n                match = re.match(r'^([0-9]+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed.append(line)\n                match = re.match(r'^(INT+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed.append(line)\n                match = re.match(r'^(EXT+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed.append(line)\n                match = re.match(r'^(MGT+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed.append(line)\n        return parsed\n\nFACT_SUBSETS = dict(\n    default=Default,\n    hardware=Hardware,\n    interfaces=Interfaces,\n    config=Config,\n)\n\nVALID_SUBSETS = frozenset(FACT_SUBSETS.keys())\n\nPERSISTENT_COMMAND_TIMEOUT = 60\n\n\ndef main():\n    \"\"\"main entry point for module execution\n    \"\"\"\n    argument_spec = dict(\n        gather_subset=dict(default=['!config'], type='list')\n    )\n\n    argument_spec.update(enos_argument_spec)\n\n    module = AnsibleModule(argument_spec=argument_spec,\n                           supports_check_mode=True)\n\n    gather_subset = module.params['gather_subset']\n\n    runable_subsets = set()\n    exclude_subsets = set()\n\n    for subset in gather_subset:\n        if subset == 'all':\n            runable_subsets.update(VALID_SUBSETS)\n            continue\n\n        if subset.startswith('!'):\n            subset = subset[1:]\n            if subset == 'all':\n                exclude_subsets.update(VALID_SUBSETS)\n                continue\n            exclude = True\n        else:\n            exclude = False\n\n        if subset not in VALID_SUBSETS:\n            module.fail_json(msg='Bad subset')\n\n        if exclude:\n            exclude_subsets.add(subset)\n        else:\n            runable_subsets.add(subset)\n\n    if not runable_subsets:\n        runable_subsets.update(VALID_SUBSETS)\n\n    runable_subsets.difference_update(exclude_subsets)\n    runable_subsets.add('default')\n\n    facts = dict()\n    facts['gather_subset'] = list(runable_subsets)\n\n    instances = list()\n    for key in runable_subsets:\n        instances.append(FACT_SUBSETS[key](module))\n\n    for inst in instances:\n        inst.populate()\n        facts.update(inst.facts)\n\n    ansible_facts = dict()\n    for key, value in iteritems(facts):\n        key = 'ansible_net_%s' % key\n        ansible_facts[key] = value\n\n    warnings = list()\n    check_args(module, warnings)\n\n    module.exit_json(ansible_facts=ansible_facts, warnings=warnings)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "enos_facts.py", "id": "b46414a69df5c499912420f7bcbf80ce", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/network/enos/enos_facts.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}