{"author": "tgalal", "code": "from yowsup.structs import ProtocolTreeNode\nimport math\nimport binascii\nimport sys\nclass ReadDecoder:\n    def __init__(self, tokenDictionary):\n        self.streamStarted = False;\n        self.tokenDictionary = tokenDictionary\n\n    def reset(self):\n        self.streamStarted = False\n\n    def getProtocolTreeNode(self, data):\n        if not self.streamStarted:\n            return self.streamStart(data)\n        return self.nextTreeInternal(data)\n\n    def getToken(self, index, data):\n        token = self.tokenDictionary.getToken(index)\n        if not token:\n            index = self.readInt8(data)\n            token = self.tokenDictionary.getToken(index, True)\n            if not token:\n                raise ValueError(\"Invalid token %s\" % token)\n\n        return token\n\n    def getTokenDouble(self, n, n2):\n        pos = n2 + n * 256\n        token = self.tokenDictionary.getToken(pos, True)\n        if not token:\n            raise ValueError(\"Invalid token %s\" % pos)\n\n        return token\n\n    def streamStart(self, data):\n        self.streamStarted = True\n        tag = data.pop(0)\n        size = self.readListSize(tag, data)\n        tag = data.pop(0)\n\n        if tag != 1:\n            if tag == 236:\n                tag = data.pop(0) + 237\n            token = self.getToken(tag, data)#self.tokenDictionary.getToken(tag)\n            raise Exception(\"expecting STREAM_START in streamStart, instead got token: %s\" % token)\n        attribCount = (size - 2 + size % 2) / 2\n        self.readAttributes(attribCount, data)\n\n    def readNibble(self, data):\n        _byte = self.readInt8(data)\n        ignoreLastNibble = bool(_byte & 0x80)\n        size = (_byte & 0x7f)\n        nrOfNibbles = size * 2 - int(ignoreLastNibble)\n        dataArr = self.readArray(size, data)\n        string = ''\n        for i in range(0, nrOfNibbles):\n            _byte = dataArr[int(math.floor(i/2))]\n            _shift = 4 * (1 - i % 2)\n            dec = (_byte & (15 << _shift)) >> _shift\n\n            if dec in (0,1,2,3,4,5,6,7,8,9):\n                string += str(dec)\n            elif dec in (10, 11):\n                string += chr(dec - 10 + 45)\n            else:\n                raise Exception(\"Bad nibble %s\" % dec)\n        return string\n\n    def readPacked8(self, n, data):\n        size = self.readInt8(data)\n        remove = 0\n        if (size & 0x80) != 0 and n == 251:\n            remove = 1\n        size = size & 0x7F\n        text = bytearray(self.readArray(size, data))\n        hexData = binascii.hexlify(str(text) if sys.version_info < (2,7) else text).upper()\n        dataSize = len(hexData)\n        out = []\n        if remove == 0:\n            for i in range(0, dataSize):\n                char = chr(hexData[i]) if type(hexData[i]) is int else hexData[i] \n                val = ord(binascii.unhexlify(\"0%s\" % char))\n                if i == (dataSize - 1) and val > 11 and n != 251: continue\n                out.append(self.unpackByte(n, val))\n        else:\n            out =  map(ord, list(hexData[0: -remove])) if sys.version_info < (3,0) else list(hexData[0: -remove])\n\n        return out\n\n    def unpackByte(self, n, n2):\n        if n == 251:\n            return self.unpackHex(n2)\n        if n == 255:\n            return self.unpackNibble(n2)\n        raise ValueError(\"bad packed type %s\" % n)\n\n    def unpackHex(self, n):\n        if n in range(0, 10):\n            return n + 48\n        if n in range(10, 16):\n            return 65 + (n - 10)\n\n        raise ValueError(\"bad hex %s\" % n)\n\n    def unpackNibble(self, n):\n        if n in range(0, 10):\n            return n + 48\n        if n in (10, 11):\n            return 45 + (n - 10)\n        raise ValueError(\"bad nibble %s\" % n)\n\n\n    def readHeader(self, data, offset = 0):\n        ret = 0\n        if len(data) >= (3 + offset):\n            b0 = data[offset]\n            b1 = data[offset + 1]\n            b2 = data[offset + 2]\n            ret = b0 + (b1 << 16) + (b2 << 8)\n\n        return ret\n\n    def readInt8(self, data):\n        return data.pop(0);\n\n    def readInt16(self, data):\n        intTop = data.pop(0)\n        intBot = data.pop(0)\n        value = (intTop << 8) + intBot\n        if value is not None:\n            return value\n        else:\n            return \"\"\n\n    def readInt20(self, data):\n         int1 = data.pop(0)\n         int2 = data.pop(0)\n         int3 = data.pop(0)\n         return ((int1 & 0xF) << 16) | (int2 << 8) | int3\n\n    def readInt24(self, data):\n        int1 = data.pop(0)\n        int2 = data.pop(0)\n        int3 = data.pop(0)\n        value = (int1 << 16) + (int2 << 8) + (int3 << 0)\n        return value\n\n    def readInt31(self, data):\n        data.pop(0)\n        int1 = data.pop(0)\n        int2 = data.pop(0)\n        int3 = data.pop(0)\n        return (int1 << 24) | (int1 << 16) | int2 << 8 | int3\n\n    def readListSize(self,token, data):\n        size = 0\n        if token == 0:\n            size = 0\n        else:\n            if token == 248:\n                size = self.readInt8(data)\n            else:\n                if token == 249:\n                    size = self.readInt16(data)\n                else:\n                    raise Exception(\"invalid list size in readListSize: token \" + str(token))\n        return size\n\n    def readAttributes(self, attribCount, data):\n        attribs = {}\n        for i in range(0, int(attribCount)):\n            key = self.readString(self.readInt8(data), data)\n            value = self.readString(self.readInt8(data), data)\n            attribs[key]=value\n        return attribs\n\n    def readString(self,token, data):\n        if token == -1:\n            raise Exception(\"-1 token in readString\")\n\n        if 2 < token < 236:\n            return self.getToken(token, data)\n\n        if token == 0:\n            return None\n\n        if token in (236, 237, 238, 239):\n            return self.getTokenDouble(token - 236, self.readInt8(data))\n\n        if token == 250:\n            user = self.readString(data.pop(0), data)\n            server = self.readString(data.pop(0), data)\n            if user is not None and server is not None:\n                return user + \"@\" + server\n            if server is not None:\n                return server\n            raise Exception(\"readString couldn't reconstruct jid\")\n\n        if token in (251, 255):\n            return \"\".join(map(chr, self.readPacked8(token, data)))\n\n        if token == 252:\n            size8 = self.readInt8(data)\n            buf8 = self.readArray(size8, data)\n            return \"\".join(map(chr, buf8))\n\n        if token == 253:\n            size20 = self.readInt20(data)\n            buf20 = self.readArray(size20, data)\n            return \"\".join(map(chr, buf20))\n\n        if token == 254:\n            size31 = self.readInt31()\n            buf31 = self.readArray(size31, data)\n            return \"\".join(map(chr, buf31))\n\n\n        raise Exception(\"readString couldn't match token \"+str(token))\n\n    def readArray(self, length, data):\n        out = []\n        for i in range(0, length):\n            out.append(data.pop(0))\n\n        return out\n\n    def nextTreeInternal(self, data):\n        size = self.readListSize(self.readInt8(data), data)\n        token = self.readInt8(data)\n        if token == 1:\n            token = self.readInt8(data)\n\n        if token == 2:\n            return None\n\n        tag = self.readString(token, data)\n\n        if size == 0 or tag is None:\n            raise ValueError(\"nextTree sees 0 list or null tag\")\n\n        attribCount = (size - 2 + size % 2)/2\n        attribs = self.readAttributes(attribCount, data)\n        if size % 2 ==1:\n            return ProtocolTreeNode(tag, attribs)\n\n        read2 = self.readInt8(data)\n\n        nodeData = None\n        nodeChildren = None\n        if self.isListTag(read2):\n            nodeChildren = self.readList(read2, data)\n        elif read2 == 252:\n            size = self.readInt8(data)\n            nodeData = self.readArray(size, data)\n        elif read2 == 253:\n            size = self.readInt20(data)\n            nodeData = self.readArray(size, data)\n        elif read2 == 254:\n            size = self.readInt31(data)\n            nodeData = self.readArray(size, data)\n        elif read2 in (255, 251):\n            nodeData = self.readPacked8(read2, data)\n        else:\n            nodeData = self.readString(read2, data)\n\n        if nodeData and type(nodeData) is not str:\n            nodeData = \"\".join(map(chr, nodeData))\n\n        return ProtocolTreeNode(tag, attribs, nodeChildren, nodeData)\n\n    def readList(self,token, data):\n        size = self.readListSize(token, data)\n        listx = []\n        for i in range(0,size):\n            listx.append(self.nextTreeInternal(data))\n\n        return listx;\n\n    def isListTag(self, b):\n        return b in (248, 0, 249)\n", "comments": " self tokendictionary gettoken(tag)   python2 3 compat ", "content": "from yowsup.structs import ProtocolTreeNode\nimport math\nimport binascii\nimport sys\nclass ReadDecoder:\n    def __init__(self, tokenDictionary):\n        self.streamStarted = False;\n        self.tokenDictionary = tokenDictionary\n\n    def reset(self):\n        self.streamStarted = False\n\n    def getProtocolTreeNode(self, data):\n        if not self.streamStarted:\n            return self.streamStart(data)\n        return self.nextTreeInternal(data)\n\n    def getToken(self, index, data):\n        token = self.tokenDictionary.getToken(index)\n        if not token:\n            index = self.readInt8(data)\n            token = self.tokenDictionary.getToken(index, True)\n            if not token:\n                raise ValueError(\"Invalid token %s\" % token)\n\n        return token\n\n    def getTokenDouble(self, n, n2):\n        pos = n2 + n * 256\n        token = self.tokenDictionary.getToken(pos, True)\n        if not token:\n            raise ValueError(\"Invalid token %s\" % pos)\n\n        return token\n\n    def streamStart(self, data):\n        self.streamStarted = True\n        tag = data.pop(0)\n        size = self.readListSize(tag, data)\n        tag = data.pop(0)\n\n        if tag != 1:\n            if tag == 236:\n                tag = data.pop(0) + 237\n            token = self.getToken(tag, data)#self.tokenDictionary.getToken(tag)\n            raise Exception(\"expecting STREAM_START in streamStart, instead got token: %s\" % token)\n        attribCount = (size - 2 + size % 2) / 2\n        self.readAttributes(attribCount, data)\n\n    def readNibble(self, data):\n        _byte = self.readInt8(data)\n        ignoreLastNibble = bool(_byte & 0x80)\n        size = (_byte & 0x7f)\n        nrOfNibbles = size * 2 - int(ignoreLastNibble)\n        dataArr = self.readArray(size, data)\n        string = ''\n        for i in range(0, nrOfNibbles):\n            _byte = dataArr[int(math.floor(i/2))]\n            _shift = 4 * (1 - i % 2)\n            dec = (_byte & (15 << _shift)) >> _shift\n\n            if dec in (0,1,2,3,4,5,6,7,8,9):\n                string += str(dec)\n            elif dec in (10, 11):\n                string += chr(dec - 10 + 45)\n            else:\n                raise Exception(\"Bad nibble %s\" % dec)\n        return string\n\n    def readPacked8(self, n, data):\n        size = self.readInt8(data)\n        remove = 0\n        if (size & 0x80) != 0 and n == 251:\n            remove = 1\n        size = size & 0x7F\n        text = bytearray(self.readArray(size, data))\n        hexData = binascii.hexlify(str(text) if sys.version_info < (2,7) else text).upper()\n        dataSize = len(hexData)\n        out = []\n        if remove == 0:\n            for i in range(0, dataSize):\n                char = chr(hexData[i]) if type(hexData[i]) is int else hexData[i] #python2/3 compat\n                val = ord(binascii.unhexlify(\"0%s\" % char))\n                if i == (dataSize - 1) and val > 11 and n != 251: continue\n                out.append(self.unpackByte(n, val))\n        else:\n            out =  map(ord, list(hexData[0: -remove])) if sys.version_info < (3,0) else list(hexData[0: -remove])\n\n        return out\n\n    def unpackByte(self, n, n2):\n        if n == 251:\n            return self.unpackHex(n2)\n        if n == 255:\n            return self.unpackNibble(n2)\n        raise ValueError(\"bad packed type %s\" % n)\n\n    def unpackHex(self, n):\n        if n in range(0, 10):\n            return n + 48\n        if n in range(10, 16):\n            return 65 + (n - 10)\n\n        raise ValueError(\"bad hex %s\" % n)\n\n    def unpackNibble(self, n):\n        if n in range(0, 10):\n            return n + 48\n        if n in (10, 11):\n            return 45 + (n - 10)\n        raise ValueError(\"bad nibble %s\" % n)\n\n\n    def readHeader(self, data, offset = 0):\n        ret = 0\n        if len(data) >= (3 + offset):\n            b0 = data[offset]\n            b1 = data[offset + 1]\n            b2 = data[offset + 2]\n            ret = b0 + (b1 << 16) + (b2 << 8)\n\n        return ret\n\n    def readInt8(self, data):\n        return data.pop(0);\n\n    def readInt16(self, data):\n        intTop = data.pop(0)\n        intBot = data.pop(0)\n        value = (intTop << 8) + intBot\n        if value is not None:\n            return value\n        else:\n            return \"\"\n\n    def readInt20(self, data):\n         int1 = data.pop(0)\n         int2 = data.pop(0)\n         int3 = data.pop(0)\n         return ((int1 & 0xF) << 16) | (int2 << 8) | int3\n\n    def readInt24(self, data):\n        int1 = data.pop(0)\n        int2 = data.pop(0)\n        int3 = data.pop(0)\n        value = (int1 << 16) + (int2 << 8) + (int3 << 0)\n        return value\n\n    def readInt31(self, data):\n        data.pop(0)\n        int1 = data.pop(0)\n        int2 = data.pop(0)\n        int3 = data.pop(0)\n        return (int1 << 24) | (int1 << 16) | int2 << 8 | int3\n\n    def readListSize(self,token, data):\n        size = 0\n        if token == 0:\n            size = 0\n        else:\n            if token == 248:\n                size = self.readInt8(data)\n            else:\n                if token == 249:\n                    size = self.readInt16(data)\n                else:\n                    raise Exception(\"invalid list size in readListSize: token \" + str(token))\n        return size\n\n    def readAttributes(self, attribCount, data):\n        attribs = {}\n        for i in range(0, int(attribCount)):\n            key = self.readString(self.readInt8(data), data)\n            value = self.readString(self.readInt8(data), data)\n            attribs[key]=value\n        return attribs\n\n    def readString(self,token, data):\n        if token == -1:\n            raise Exception(\"-1 token in readString\")\n\n        if 2 < token < 236:\n            return self.getToken(token, data)\n\n        if token == 0:\n            return None\n\n        if token in (236, 237, 238, 239):\n            return self.getTokenDouble(token - 236, self.readInt8(data))\n\n        if token == 250:\n            user = self.readString(data.pop(0), data)\n            server = self.readString(data.pop(0), data)\n            if user is not None and server is not None:\n                return user + \"@\" + server\n            if server is not None:\n                return server\n            raise Exception(\"readString couldn't reconstruct jid\")\n\n        if token in (251, 255):\n            return \"\".join(map(chr, self.readPacked8(token, data)))\n\n        if token == 252:\n            size8 = self.readInt8(data)\n            buf8 = self.readArray(size8, data)\n            return \"\".join(map(chr, buf8))\n\n        if token == 253:\n            size20 = self.readInt20(data)\n            buf20 = self.readArray(size20, data)\n            return \"\".join(map(chr, buf20))\n\n        if token == 254:\n            size31 = self.readInt31()\n            buf31 = self.readArray(size31, data)\n            return \"\".join(map(chr, buf31))\n\n\n        raise Exception(\"readString couldn't match token \"+str(token))\n\n    def readArray(self, length, data):\n        out = []\n        for i in range(0, length):\n            out.append(data.pop(0))\n\n        return out\n\n    def nextTreeInternal(self, data):\n        size = self.readListSize(self.readInt8(data), data)\n        token = self.readInt8(data)\n        if token == 1:\n            token = self.readInt8(data)\n\n        if token == 2:\n            return None\n\n        tag = self.readString(token, data)\n\n        if size == 0 or tag is None:\n            raise ValueError(\"nextTree sees 0 list or null tag\")\n\n        attribCount = (size - 2 + size % 2)/2\n        attribs = self.readAttributes(attribCount, data)\n        if size % 2 ==1:\n            return ProtocolTreeNode(tag, attribs)\n\n        read2 = self.readInt8(data)\n\n        nodeData = None\n        nodeChildren = None\n        if self.isListTag(read2):\n            nodeChildren = self.readList(read2, data)\n        elif read2 == 252:\n            size = self.readInt8(data)\n            nodeData = self.readArray(size, data)\n        elif read2 == 253:\n            size = self.readInt20(data)\n            nodeData = self.readArray(size, data)\n        elif read2 == 254:\n            size = self.readInt31(data)\n            nodeData = self.readArray(size, data)\n        elif read2 in (255, 251):\n            nodeData = self.readPacked8(read2, data)\n        else:\n            nodeData = self.readString(read2, data)\n\n        if nodeData and type(nodeData) is not str:\n            nodeData = \"\".join(map(chr, nodeData))\n\n        return ProtocolTreeNode(tag, attribs, nodeChildren, nodeData)\n\n    def readList(self,token, data):\n        size = self.readListSize(token, data)\n        listx = []\n        for i in range(0,size):\n            listx.append(self.nextTreeInternal(data))\n\n        return listx;\n\n    def isListTag(self, b):\n        return b in (248, 0, 249)\n", "description": "The python WhatsApp library", "file_name": "decoder.py", "id": "37af878b07bcb292e3b2780c94171849", "language": "Python", "project_name": "yowsup", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tgalal-yowsup/tgalal-yowsup-03795cc/yowsup/layers/coder/decoder.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:01:40Z", "url": "https://github.com/tgalal/yowsup", "wiki": true}