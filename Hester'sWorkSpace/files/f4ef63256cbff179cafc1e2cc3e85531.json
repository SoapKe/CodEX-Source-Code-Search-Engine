{"author": "mwaskom", "code": "from __future__ import division\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LinearSegmentedColormap\n\n\ntry:\n    from ipywidgets import interact, FloatSlider, IntSlider\nexcept ImportError:\n    import warnings\n    \n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        try:\n            from IPython.html.widgets import interact, FloatSlider, IntSlider\n        except ImportError:\n            try:\n                from IPython.html.widgets import (interact,\n                                                  FloatSliderWidget,\n                                                  IntSliderWidget)\n                FloatSlider = FloatSliderWidget\n                IntSlider = IntSliderWidget\n            except ImportError:\n                pass\n\n\nfrom .miscplot import palplot\nfrom .palettes import (color_palette, dark_palette, light_palette,\n                       diverging_palette, cubehelix_palette)\n\n\n__all__ = [\"choose_colorbrewer_palette\", \"choose_cubehelix_palette\",\n           \"choose_dark_palette\", \"choose_light_palette\",\n           \"choose_diverging_palette\"]\n\n\ndef _init_mutable_colormap():\n    \"\"\"Create a matplotlib colormap that will be updated by the widgets.\"\"\"\n    greys = color_palette(\"Greys\", 256)\n    cmap = LinearSegmentedColormap.from_list(\"interactive\", greys)\n    cmap._init()\n    cmap._set_extremes()\n    return cmap\n\n\ndef _update_lut(cmap, colors):\n    \"\"\"Change the LUT values in a matplotlib colormap in-place.\"\"\"\n    cmap._lut[:256] = colors\n    cmap._set_extremes()\n\n\ndef _show_cmap(cmap):\n    \"\"\"Show a continuous matplotlib colormap.\"\"\"\n    from .rcmod import axes_style  \n    with axes_style(\"white\"):\n        f, ax = plt.subplots(figsize=(8.25, .75))\n    ax.set(xticks=[], yticks=[])\n    x = np.linspace(0, 1, 256)[np.newaxis, :]\n    ax.pcolormesh(x, cmap=cmap)\n\n\ndef choose_colorbrewer_palette(data_type, as_cmap=False):\n    \"\"\"Select a palette from the ColorBrewer set.\n\n    These palettes are built into matplotlib and can be used by name in\n    many seaborn functions, or by passing the object returned by this function.\n\n    Parameters\n    ----------\n    data_type : {'sequential', 'diverging', 'qualitative'}\n        This describes the kind of data you want to visualize. See the seaborn\n        color palette docs for more information about how to choose this value.\n        Note that you can pass substrings (e.g. 'q' for 'qualitative.\n\n    as_cmap : bool\n        If True, the return value is a matplotlib colormap rather than a\n        list of discrete colors.\n\n    Returns\n    -------\n    pal or cmap : list of colors or matplotlib colormap\n        Object that can be passed to plotting functions.\n\n    See Also\n    --------\n    dark_palette : Create a sequential palette with dark low values.\n    light_palette : Create a sequential palette with bright low values.\n    diverging_palette : Create a diverging palette from selected colors.\n    cubehelix_palette : Create a sequential palette or colormap using the\n                        cubehelix system.\n\n\n    \"\"\"\n    if data_type.startswith(\"q\") and as_cmap:\n        raise ValueError(\"Qualitative palettes cannot be colormaps.\")\n\n    pal = []\n    if as_cmap:\n        cmap = _init_mutable_colormap()\n\n    if data_type.startswith(\"s\"):\n        opts = [\"Greys\", \"Reds\", \"Greens\", \"Blues\", \"Oranges\", \"Purples\",\n                \"BuGn\", \"BuPu\", \"GnBu\", \"OrRd\", \"PuBu\", \"PuRd\", \"RdPu\", \"YlGn\",\n                \"PuBuGn\", \"YlGnBu\", \"YlOrBr\", \"YlOrRd\"]\n        variants = [\"regular\", \"reverse\", \"dark\"]\n\n        @interact\n        def choose_sequential(name=opts, n=(2, 18),\n                              desat=FloatSlider(min=0, max=1, value=1),\n                              variant=variants):\n            if variant == \"reverse\":\n                name += \"_r\"\n            elif variant == \"dark\":\n                name += \"_d\"\n\n            if as_cmap:\n                colors = color_palette(name, 256, desat)\n                _update_lut(cmap, np.c_[colors, np.ones(256)])\n                _show_cmap(cmap)\n            else:\n                pal[:] = color_palette(name, n, desat)\n                palplot(pal)\n\n    elif data_type.startswith(\"d\"):\n        opts = [\"RdBu\", \"RdGy\", \"PRGn\", \"PiYG\", \"BrBG\",\n                \"RdYlBu\", \"RdYlGn\", \"Spectral\"]\n        variants = [\"regular\", \"reverse\"]\n\n        @interact\n        def choose_diverging(name=opts, n=(2, 16),\n                             desat=FloatSlider(min=0, max=1, value=1),\n                             variant=variants):\n            if variant == \"reverse\":\n                name += \"_r\"\n            if as_cmap:\n                colors = color_palette(name, 256, desat)\n                _update_lut(cmap, np.c_[colors, np.ones(256)])\n                _show_cmap(cmap)\n            else:\n                pal[:] = color_palette(name, n, desat)\n                palplot(pal)\n\n    elif data_type.startswith(\"q\"):\n        opts = [\"Set1\", \"Set2\", \"Set3\", \"Paired\", \"Accent\",\n                \"Pastel1\", \"Pastel2\", \"Dark2\"]\n\n        @interact\n        def choose_qualitative(name=opts, n=(2, 16),\n                               desat=FloatSlider(min=0, max=1, value=1)):\n            pal[:] = color_palette(name, n, desat)\n            palplot(pal)\n\n    if as_cmap:\n        return cmap\n    return pal\n\n\ndef choose_dark_palette(input=\"husl\", as_cmap=False):\n    \"\"\"Launch an interactive widget to create a dark sequential palette.\n\n    This corresponds with the :func:`dark_palette` function. This kind\n    of palette is good for data that range between relatively uninteresting\n    low values and interesting high values.\n\n    Requires IPython 2+ and must be used in the notebook.\n\n    Parameters\n    ----------\n    input : {'husl', 'hls', 'rgb'}\n        Color space for defining the seed value. Note that the default is\n        different than the default input for :func:`dark_palette`.\n    as_cmap : bool\n        If True, the return value is a matplotlib colormap rather than a\n        list of discrete colors.\n\n    Returns\n    -------\n    pal or cmap : list of colors or matplotlib colormap\n        Object that can be passed to plotting functions.\n\n    See Also\n    --------\n    dark_palette : Create a sequential palette with dark low values.\n    light_palette : Create a sequential palette with bright low values.\n    cubehelix_palette : Create a sequential palette or colormap using the\n                        cubehelix system.\n\n    \"\"\"\n    pal = []\n    if as_cmap:\n        cmap = _init_mutable_colormap()\n\n    if input == \"rgb\":\n        @interact\n        def choose_dark_palette_rgb(r=(0., 1.),\n                                    g=(0., 1.),\n                                    b=(0., 1.),\n                                    n=(3, 17)):\n            color = r, g, b\n            if as_cmap:\n                colors = dark_palette(color, 256, input=\"rgb\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = dark_palette(color, n, input=\"rgb\")\n                palplot(pal)\n\n    elif input == \"hls\":\n        @interact\n        def choose_dark_palette_hls(h=(0., 1.),\n                                    l=(0., 1.),\n                                    s=(0., 1.),\n                                    n=(3, 17)):\n            color = h, l, s\n            if as_cmap:\n                colors = dark_palette(color, 256, input=\"hls\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = dark_palette(color, n, input=\"hls\")\n                palplot(pal)\n\n    elif input == \"husl\":\n        @interact\n        def choose_dark_palette_husl(h=(0, 359),\n                                     s=(0, 99),\n                                     l=(0, 99),\n                                     n=(3, 17)):\n            color = h, s, l\n            if as_cmap:\n                colors = dark_palette(color, 256, input=\"husl\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = dark_palette(color, n, input=\"husl\")\n                palplot(pal)\n\n    if as_cmap:\n        return cmap\n    return pal\n\n\ndef choose_light_palette(input=\"husl\", as_cmap=False):\n    \"\"\"Launch an interactive widget to create a light sequential palette.\n\n    This corresponds with the :func:`light_palette` function. This kind\n    of palette is good for data that range between relatively uninteresting\n    low values and interesting high values.\n\n    Requires IPython 2+ and must be used in the notebook.\n\n    Parameters\n    ----------\n    input : {'husl', 'hls', 'rgb'}\n        Color space for defining the seed value. Note that the default is\n        different than the default input for :func:`light_palette`.\n    as_cmap : bool\n        If True, the return value is a matplotlib colormap rather than a\n        list of discrete colors.\n\n    Returns\n    -------\n    pal or cmap : list of colors or matplotlib colormap\n        Object that can be passed to plotting functions.\n\n    See Also\n    --------\n    light_palette : Create a sequential palette with bright low values.\n    dark_palette : Create a sequential palette with dark low values.\n    cubehelix_palette : Create a sequential palette or colormap using the\n                        cubehelix system.\n\n    \"\"\"\n    pal = []\n    if as_cmap:\n        cmap = _init_mutable_colormap()\n\n    if input == \"rgb\":\n        @interact\n        def choose_light_palette_rgb(r=(0., 1.),\n                                     g=(0., 1.),\n                                     b=(0., 1.),\n                                     n=(3, 17)):\n            color = r, g, b\n            if as_cmap:\n                colors = light_palette(color, 256, input=\"rgb\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = light_palette(color, n, input=\"rgb\")\n                palplot(pal)\n\n    elif input == \"hls\":\n        @interact\n        def choose_light_palette_hls(h=(0., 1.),\n                                     l=(0., 1.),\n                                     s=(0., 1.),\n                                     n=(3, 17)):\n            color = h, l, s\n            if as_cmap:\n                colors = light_palette(color, 256, input=\"hls\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = light_palette(color, n, input=\"hls\")\n                palplot(pal)\n\n    elif input == \"husl\":\n        @interact\n        def choose_light_palette_husl(h=(0, 359),\n                                      s=(0, 99),\n                                      l=(0, 99),\n                                      n=(3, 17)):\n            color = h, s, l\n            if as_cmap:\n                colors = light_palette(color, 256, input=\"husl\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = light_palette(color, n, input=\"husl\")\n                palplot(pal)\n\n    if as_cmap:\n        return cmap\n    return pal\n\n\ndef choose_diverging_palette(as_cmap=False):\n    \"\"\"Launch an interactive widget to choose a diverging color palette.\n\n    This corresponds with the :func:`diverging_palette` function. This kind\n    of palette is good for data that range between interesting low values\n    and interesting high values with a meaningful midpoint. (For example,\n    change scores relative to some baseline value).\n\n    Requires IPython 2+ and must be used in the notebook.\n\n    Parameters\n    ----------\n    as_cmap : bool\n        If True, the return value is a matplotlib colormap rather than a\n        list of discrete colors.\n\n    Returns\n    -------\n    pal or cmap : list of colors or matplotlib colormap\n        Object that can be passed to plotting functions.\n\n    See Also\n    --------\n    diverging_palette : Create a diverging color palette or colormap.\n    choose_colorbrewer_palette : Interactively choose palettes from the\n                                 colorbrewer set, including diverging palettes.\n\n    \"\"\"\n    pal = []\n    if as_cmap:\n        cmap = _init_mutable_colormap()\n\n    @interact\n    def choose_diverging_palette(h_neg=IntSlider(min=0,\n                                                 max=359,\n                                                 value=220),\n                                 h_pos=IntSlider(min=0,\n                                                 max=359,\n                                                 value=10),\n                                 s=IntSlider(min=0, max=99, value=74),\n                                 l=IntSlider(min=0, max=99, value=50),\n                                 sep=IntSlider(min=1, max=50, value=10),\n                                 n=(2, 16),\n                                 center=[\"light\", \"dark\"]):\n        if as_cmap:\n            colors = diverging_palette(h_neg, h_pos, s, l, sep, 256, center)\n            _update_lut(cmap, colors)\n            _show_cmap(cmap)\n        else:\n            pal[:] = diverging_palette(h_neg, h_pos, s, l, sep, n, center)\n            palplot(pal)\n\n    if as_cmap:\n        return cmap\n    return pal\n\n\ndef choose_cubehelix_palette(as_cmap=False):\n    \"\"\"Launch an interactive widget to create a sequential cubehelix palette.\n\n    This corresponds with the :func:`cubehelix_palette` function. This kind\n    of palette is good for data that range between relatively uninteresting\n    low values and interesting high values. The cubehelix system allows the\n    palette to have more hue variance across the range, which can be helpful\n    for distinguishing a wider range of values.\n\n    Requires IPython 2+ and must be used in the notebook.\n\n    Parameters\n    ----------\n    as_cmap : bool\n        If True, the return value is a matplotlib colormap rather than a\n        list of discrete colors.\n\n    Returns\n    -------\n    pal or cmap : list of colors or matplotlib colormap\n        Object that can be passed to plotting functions.\n\n    See Also\n    --------\n    cubehelix_palette : Create a sequential palette or colormap using the\n                        cubehelix system.\n\n    \"\"\"\n    pal = []\n    if as_cmap:\n        cmap = _init_mutable_colormap()\n\n    @interact\n    def choose_cubehelix(n_colors=IntSlider(min=2, max=16, value=9),\n                         start=FloatSlider(min=0, max=3, value=0),\n                         rot=FloatSlider(min=-1, max=1, value=.4),\n                         gamma=FloatSlider(min=0, max=5, value=1),\n                         hue=FloatSlider(min=0, max=1, value=.8),\n                         light=FloatSlider(min=0, max=1, value=.85),\n                         dark=FloatSlider(min=0, max=1, value=.15),\n                         reverse=False):\n\n        if as_cmap:\n            colors = cubehelix_palette(256, start, rot, gamma,\n                                       hue, light, dark, reverse)\n            _update_lut(cmap, np.c_[colors, np.ones(256)])\n            _show_cmap(cmap)\n        else:\n            pal[:] = cubehelix_palette(n_colors, start, rot, gamma,\n                                       hue, light, dark, reverse)\n            palplot(pal)\n\n    if as_cmap:\n        return cmap\n    return pal\n", "comments": "   create matplotlib colormap updated widgets         greys   color palette( greys   256)     cmap   linearsegmentedcolormap list( interactive   greys)     cmap  init()     cmap  set extremes()     return cmap   def  update lut(cmap  colors)         change lut values matplotlib colormap place         cmap  lut  256    colors     cmap  set extremes()   def  show cmap(cmap)         show continuous matplotlib colormap          rcmod import axes style    avoid circular import     axes style( white )          f  ax   plt subplots(figsize (8 25   75))     ax set(xticks     yticks   )     x   np linspace(0  1  256) np newaxis         ax pcolormesh(x  cmap cmap)   def choose colorbrewer palette(data type  cmap false)         select palette colorbrewer set       these palettes built matplotlib used name     many seaborn functions  passing object returned function       parameters                    data type     sequential    diverging    qualitative           this describes kind data want visualize  see seaborn         color palette docs information choose value          note pass substrings (e g   q   qualitative       cmap   bool         if true  return value matplotlib colormap rather         list discrete colors       returns                 pal cmap   list colors matplotlib colormap         object passed plotting functions       see also                  dark palette   create sequential palette dark low values      light palette   create sequential palette bright low values      diverging palette   create diverging palette selected colors      cubehelix palette   create sequential palette colormap using                         cubehelix system                data type startswith( q ) cmap          raise valueerror( qualitative palettes cannot colormaps  )      pal          cmap          cmap    init mutable colormap()      data type startswith( )          opts     greys    reds    greens    blues    oranges    purples                    bugn    bupu    gnbu    orrd    pubu    purd    rdpu    ylgn                    pubugn    ylgnbu    ylorbr    ylorrd           variants     regular    reverse    dark             interact         def choose sequential(name opts  n (2  18)                                desat floatslider(min 0  max 1  value 1)                                variant variants)              variant     reverse                   name      r              elif variant     dark                   name                    cmap                  colors   color palette(name  256  desat)                  update lut(cmap  np c  colors  np ones(256) )                  show cmap(cmap)             else                  pal      color palette(name  n  desat)                 palplot(pal)      elif data type startswith( )          opts     rdbu    rdgy    prgn    piyg    brbg                    rdylbu    rdylgn    spectral           variants     regular    reverse             interact         def choose diverging(name opts  n (2  16)                               desat floatslider(min 0  max 1  value 1)                               variant variants)              variant     reverse                   name      r              cmap                  colors   color palette(name  256  desat)                  update lut(cmap  np c  colors  np ones(256) )                  show cmap(cmap)             else                  pal      color palette(name  n  desat)                 palplot(pal)      elif data type startswith( q )          opts     set1    set2    set3    paired    accent                    pastel1    pastel2    dark2             interact         def choose qualitative(name opts  n (2  16)                                 desat floatslider(min 0  max 1  value 1))              pal      color palette(name  n  desat)             palplot(pal)      cmap          return cmap     return pal   def choose dark palette(input  husl   cmap false)         launch interactive widget create dark sequential palette       this corresponds  func  dark palette  function  this kind     palette good data range relatively uninteresting     low values interesting high values       requires ipython 2  must used notebook       parameters                    input     husl    hls    rgb           color space defining seed value  note default         different default input  func  dark palette       cmap   bool         if true  return value matplotlib colormap rather         list discrete colors       returns                 pal cmap   list colors matplotlib colormap         object passed plotting functions       see also                  dark palette   create sequential palette dark low values      light palette   create sequential palette bright low values      cubehelix palette   create sequential palette colormap using                         cubehelix system               pal          cmap          cmap    init mutable colormap()      input     rgb            interact         def choose dark palette rgb(r (0   1 )                                      g (0   1 )                                      b (0   1 )                                      n (3  17))              color   r  g  b             cmap                  colors   dark palette(color  256  input  rgb )                  update lut(cmap  colors)                  show cmap(cmap)             else                  pal      dark palette(color  n  input  rgb )                 palplot(pal)      elif input     hls            interact         def choose dark palette hls(h (0   1 )                                      l (0   1 )                                      (0   1 )                                      n (3  17))              color   h  l              cmap                  colors   dark palette(color  256  input  hls )                  update lut(cmap  colors)                  show cmap(cmap)             else                  pal      dark palette(color  n  input  hls )                 palplot(pal)      elif input     husl            interact         def choose dark palette husl(h (0  359)                                       (0  99)                                       l (0  99)                                       n (3  17))              color   h   l             cmap                  colors   dark palette(color  256  input  husl )                  update lut(cmap  colors)                  show cmap(cmap)             else                  pal      dark palette(color  n  input  husl )                 palplot(pal)      cmap          return cmap     return pal   def choose light palette(input  husl   cmap false)         launch interactive widget create light sequential palette       this corresponds  func  light palette  function  this kind     palette good data range relatively uninteresting     low values interesting high values       requires ipython 2  must used notebook       parameters                    input     husl    hls    rgb           color space defining seed value  note default         different default input  func  light palette       cmap   bool         if true  return value matplotlib colormap rather         list discrete colors       returns                 pal cmap   list colors matplotlib colormap         object passed plotting functions       see also                  light palette   create sequential palette bright low values      dark palette   create sequential palette dark low values      cubehelix palette   create sequential palette colormap using                         cubehelix system               pal          cmap          cmap    init mutable colormap()      input     rgb            interact         def choose light palette rgb(r (0   1 )                                       g (0   1 )                                       b (0   1 )                                       n (3  17))              color   r  g  b             cmap                  colors   light palette(color  256  input  rgb )                  update lut(cmap  colors)                  show cmap(cmap)             else                  pal      light palette(color  n  input  rgb )                 palplot(pal)      elif input     hls            interact         def choose light palette hls(h (0   1 )                                       l (0   1 )                                       (0   1 )                                       n (3  17))              color   h  l              cmap                  colors   light palette(color  256  input  hls )                  update lut(cmap  colors)                  show cmap(cmap)             else                  pal      light palette(color  n  input  hls )                 palplot(pal)      elif input     husl            interact         def choose light palette husl(h (0  359)                                        (0  99)                                        l (0  99)                                        n (3  17))              color   h   l             cmap                  colors   light palette(color  256  input  husl )                  update lut(cmap  colors)                  show cmap(cmap)             else                  pal      light palette(color  n  input  husl )                 palplot(pal)      cmap          return cmap     return pal   def choose diverging palette(as cmap false)         launch interactive widget choose diverging color palette       this corresponds  func  diverging palette  function  this kind     palette good data range interesting low values     interesting high values meaningful midpoint  (for example      change scores relative baseline value)       requires ipython 2  must used notebook       parameters                    cmap   bool         if true  return value matplotlib colormap rather         list discrete colors       returns                 pal cmap   list colors matplotlib colormap         object passed plotting functions       see also                  diverging palette   create diverging color palette colormap      choose colorbrewer palette   interactively choose palettes                                  colorbrewer set  including diverging palettes               pal          cmap          cmap    init mutable colormap()       interact     def choose diverging palette(h neg intslider(min 0                                                   max 359                                                   value 220)                                   h pos intslider(min 0                                                   max 359                                                   value 10)                                   intslider(min 0  max 99  value 74)                                   l intslider(min 0  max 99  value 50)                                   sep intslider(min 1  max 50  value 10)                                   n (2  16)                                   center   light    dark  )          cmap              colors   diverging palette(h neg  h pos   l  sep  256  center)              update lut(cmap  colors)              show cmap(cmap)         else              pal      diverging palette(h neg  h pos   l  sep  n  center)             palplot(pal)      cmap          return cmap     return pal   def choose cubehelix palette(as cmap false)         launch interactive widget create sequential cubehelix palette       this corresponds  func  cubehelix palette  function  this kind     palette good data range relatively uninteresting     low values interesting high values  the cubehelix system allows     palette hue variance across range  helpful     distinguishing wider range values       requires ipython 2  must used notebook       parameters                    cmap   bool         if true  return value matplotlib colormap rather         list discrete colors       returns                 pal cmap   list colors matplotlib colormap         object passed plotting functions       see also                  cubehelix palette   create sequential palette colormap using                         cubehelix system              lots different places widgets could come       ignore shimwarning raised ipython  see gh  892    avoid circular import ", "content": "from __future__ import division\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LinearSegmentedColormap\n\n# Lots of different places that widgets could come from...\ntry:\n    from ipywidgets import interact, FloatSlider, IntSlider\nexcept ImportError:\n    import warnings\n    # ignore ShimWarning raised by IPython, see GH #892\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        try:\n            from IPython.html.widgets import interact, FloatSlider, IntSlider\n        except ImportError:\n            try:\n                from IPython.html.widgets import (interact,\n                                                  FloatSliderWidget,\n                                                  IntSliderWidget)\n                FloatSlider = FloatSliderWidget\n                IntSlider = IntSliderWidget\n            except ImportError:\n                pass\n\n\nfrom .miscplot import palplot\nfrom .palettes import (color_palette, dark_palette, light_palette,\n                       diverging_palette, cubehelix_palette)\n\n\n__all__ = [\"choose_colorbrewer_palette\", \"choose_cubehelix_palette\",\n           \"choose_dark_palette\", \"choose_light_palette\",\n           \"choose_diverging_palette\"]\n\n\ndef _init_mutable_colormap():\n    \"\"\"Create a matplotlib colormap that will be updated by the widgets.\"\"\"\n    greys = color_palette(\"Greys\", 256)\n    cmap = LinearSegmentedColormap.from_list(\"interactive\", greys)\n    cmap._init()\n    cmap._set_extremes()\n    return cmap\n\n\ndef _update_lut(cmap, colors):\n    \"\"\"Change the LUT values in a matplotlib colormap in-place.\"\"\"\n    cmap._lut[:256] = colors\n    cmap._set_extremes()\n\n\ndef _show_cmap(cmap):\n    \"\"\"Show a continuous matplotlib colormap.\"\"\"\n    from .rcmod import axes_style  # Avoid circular import\n    with axes_style(\"white\"):\n        f, ax = plt.subplots(figsize=(8.25, .75))\n    ax.set(xticks=[], yticks=[])\n    x = np.linspace(0, 1, 256)[np.newaxis, :]\n    ax.pcolormesh(x, cmap=cmap)\n\n\ndef choose_colorbrewer_palette(data_type, as_cmap=False):\n    \"\"\"Select a palette from the ColorBrewer set.\n\n    These palettes are built into matplotlib and can be used by name in\n    many seaborn functions, or by passing the object returned by this function.\n\n    Parameters\n    ----------\n    data_type : {'sequential', 'diverging', 'qualitative'}\n        This describes the kind of data you want to visualize. See the seaborn\n        color palette docs for more information about how to choose this value.\n        Note that you can pass substrings (e.g. 'q' for 'qualitative.\n\n    as_cmap : bool\n        If True, the return value is a matplotlib colormap rather than a\n        list of discrete colors.\n\n    Returns\n    -------\n    pal or cmap : list of colors or matplotlib colormap\n        Object that can be passed to plotting functions.\n\n    See Also\n    --------\n    dark_palette : Create a sequential palette with dark low values.\n    light_palette : Create a sequential palette with bright low values.\n    diverging_palette : Create a diverging palette from selected colors.\n    cubehelix_palette : Create a sequential palette or colormap using the\n                        cubehelix system.\n\n\n    \"\"\"\n    if data_type.startswith(\"q\") and as_cmap:\n        raise ValueError(\"Qualitative palettes cannot be colormaps.\")\n\n    pal = []\n    if as_cmap:\n        cmap = _init_mutable_colormap()\n\n    if data_type.startswith(\"s\"):\n        opts = [\"Greys\", \"Reds\", \"Greens\", \"Blues\", \"Oranges\", \"Purples\",\n                \"BuGn\", \"BuPu\", \"GnBu\", \"OrRd\", \"PuBu\", \"PuRd\", \"RdPu\", \"YlGn\",\n                \"PuBuGn\", \"YlGnBu\", \"YlOrBr\", \"YlOrRd\"]\n        variants = [\"regular\", \"reverse\", \"dark\"]\n\n        @interact\n        def choose_sequential(name=opts, n=(2, 18),\n                              desat=FloatSlider(min=0, max=1, value=1),\n                              variant=variants):\n            if variant == \"reverse\":\n                name += \"_r\"\n            elif variant == \"dark\":\n                name += \"_d\"\n\n            if as_cmap:\n                colors = color_palette(name, 256, desat)\n                _update_lut(cmap, np.c_[colors, np.ones(256)])\n                _show_cmap(cmap)\n            else:\n                pal[:] = color_palette(name, n, desat)\n                palplot(pal)\n\n    elif data_type.startswith(\"d\"):\n        opts = [\"RdBu\", \"RdGy\", \"PRGn\", \"PiYG\", \"BrBG\",\n                \"RdYlBu\", \"RdYlGn\", \"Spectral\"]\n        variants = [\"regular\", \"reverse\"]\n\n        @interact\n        def choose_diverging(name=opts, n=(2, 16),\n                             desat=FloatSlider(min=0, max=1, value=1),\n                             variant=variants):\n            if variant == \"reverse\":\n                name += \"_r\"\n            if as_cmap:\n                colors = color_palette(name, 256, desat)\n                _update_lut(cmap, np.c_[colors, np.ones(256)])\n                _show_cmap(cmap)\n            else:\n                pal[:] = color_palette(name, n, desat)\n                palplot(pal)\n\n    elif data_type.startswith(\"q\"):\n        opts = [\"Set1\", \"Set2\", \"Set3\", \"Paired\", \"Accent\",\n                \"Pastel1\", \"Pastel2\", \"Dark2\"]\n\n        @interact\n        def choose_qualitative(name=opts, n=(2, 16),\n                               desat=FloatSlider(min=0, max=1, value=1)):\n            pal[:] = color_palette(name, n, desat)\n            palplot(pal)\n\n    if as_cmap:\n        return cmap\n    return pal\n\n\ndef choose_dark_palette(input=\"husl\", as_cmap=False):\n    \"\"\"Launch an interactive widget to create a dark sequential palette.\n\n    This corresponds with the :func:`dark_palette` function. This kind\n    of palette is good for data that range between relatively uninteresting\n    low values and interesting high values.\n\n    Requires IPython 2+ and must be used in the notebook.\n\n    Parameters\n    ----------\n    input : {'husl', 'hls', 'rgb'}\n        Color space for defining the seed value. Note that the default is\n        different than the default input for :func:`dark_palette`.\n    as_cmap : bool\n        If True, the return value is a matplotlib colormap rather than a\n        list of discrete colors.\n\n    Returns\n    -------\n    pal or cmap : list of colors or matplotlib colormap\n        Object that can be passed to plotting functions.\n\n    See Also\n    --------\n    dark_palette : Create a sequential palette with dark low values.\n    light_palette : Create a sequential palette with bright low values.\n    cubehelix_palette : Create a sequential palette or colormap using the\n                        cubehelix system.\n\n    \"\"\"\n    pal = []\n    if as_cmap:\n        cmap = _init_mutable_colormap()\n\n    if input == \"rgb\":\n        @interact\n        def choose_dark_palette_rgb(r=(0., 1.),\n                                    g=(0., 1.),\n                                    b=(0., 1.),\n                                    n=(3, 17)):\n            color = r, g, b\n            if as_cmap:\n                colors = dark_palette(color, 256, input=\"rgb\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = dark_palette(color, n, input=\"rgb\")\n                palplot(pal)\n\n    elif input == \"hls\":\n        @interact\n        def choose_dark_palette_hls(h=(0., 1.),\n                                    l=(0., 1.),\n                                    s=(0., 1.),\n                                    n=(3, 17)):\n            color = h, l, s\n            if as_cmap:\n                colors = dark_palette(color, 256, input=\"hls\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = dark_palette(color, n, input=\"hls\")\n                palplot(pal)\n\n    elif input == \"husl\":\n        @interact\n        def choose_dark_palette_husl(h=(0, 359),\n                                     s=(0, 99),\n                                     l=(0, 99),\n                                     n=(3, 17)):\n            color = h, s, l\n            if as_cmap:\n                colors = dark_palette(color, 256, input=\"husl\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = dark_palette(color, n, input=\"husl\")\n                palplot(pal)\n\n    if as_cmap:\n        return cmap\n    return pal\n\n\ndef choose_light_palette(input=\"husl\", as_cmap=False):\n    \"\"\"Launch an interactive widget to create a light sequential palette.\n\n    This corresponds with the :func:`light_palette` function. This kind\n    of palette is good for data that range between relatively uninteresting\n    low values and interesting high values.\n\n    Requires IPython 2+ and must be used in the notebook.\n\n    Parameters\n    ----------\n    input : {'husl', 'hls', 'rgb'}\n        Color space for defining the seed value. Note that the default is\n        different than the default input for :func:`light_palette`.\n    as_cmap : bool\n        If True, the return value is a matplotlib colormap rather than a\n        list of discrete colors.\n\n    Returns\n    -------\n    pal or cmap : list of colors or matplotlib colormap\n        Object that can be passed to plotting functions.\n\n    See Also\n    --------\n    light_palette : Create a sequential palette with bright low values.\n    dark_palette : Create a sequential palette with dark low values.\n    cubehelix_palette : Create a sequential palette or colormap using the\n                        cubehelix system.\n\n    \"\"\"\n    pal = []\n    if as_cmap:\n        cmap = _init_mutable_colormap()\n\n    if input == \"rgb\":\n        @interact\n        def choose_light_palette_rgb(r=(0., 1.),\n                                     g=(0., 1.),\n                                     b=(0., 1.),\n                                     n=(3, 17)):\n            color = r, g, b\n            if as_cmap:\n                colors = light_palette(color, 256, input=\"rgb\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = light_palette(color, n, input=\"rgb\")\n                palplot(pal)\n\n    elif input == \"hls\":\n        @interact\n        def choose_light_palette_hls(h=(0., 1.),\n                                     l=(0., 1.),\n                                     s=(0., 1.),\n                                     n=(3, 17)):\n            color = h, l, s\n            if as_cmap:\n                colors = light_palette(color, 256, input=\"hls\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = light_palette(color, n, input=\"hls\")\n                palplot(pal)\n\n    elif input == \"husl\":\n        @interact\n        def choose_light_palette_husl(h=(0, 359),\n                                      s=(0, 99),\n                                      l=(0, 99),\n                                      n=(3, 17)):\n            color = h, s, l\n            if as_cmap:\n                colors = light_palette(color, 256, input=\"husl\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = light_palette(color, n, input=\"husl\")\n                palplot(pal)\n\n    if as_cmap:\n        return cmap\n    return pal\n\n\ndef choose_diverging_palette(as_cmap=False):\n    \"\"\"Launch an interactive widget to choose a diverging color palette.\n\n    This corresponds with the :func:`diverging_palette` function. This kind\n    of palette is good for data that range between interesting low values\n    and interesting high values with a meaningful midpoint. (For example,\n    change scores relative to some baseline value).\n\n    Requires IPython 2+ and must be used in the notebook.\n\n    Parameters\n    ----------\n    as_cmap : bool\n        If True, the return value is a matplotlib colormap rather than a\n        list of discrete colors.\n\n    Returns\n    -------\n    pal or cmap : list of colors or matplotlib colormap\n        Object that can be passed to plotting functions.\n\n    See Also\n    --------\n    diverging_palette : Create a diverging color palette or colormap.\n    choose_colorbrewer_palette : Interactively choose palettes from the\n                                 colorbrewer set, including diverging palettes.\n\n    \"\"\"\n    pal = []\n    if as_cmap:\n        cmap = _init_mutable_colormap()\n\n    @interact\n    def choose_diverging_palette(h_neg=IntSlider(min=0,\n                                                 max=359,\n                                                 value=220),\n                                 h_pos=IntSlider(min=0,\n                                                 max=359,\n                                                 value=10),\n                                 s=IntSlider(min=0, max=99, value=74),\n                                 l=IntSlider(min=0, max=99, value=50),\n                                 sep=IntSlider(min=1, max=50, value=10),\n                                 n=(2, 16),\n                                 center=[\"light\", \"dark\"]):\n        if as_cmap:\n            colors = diverging_palette(h_neg, h_pos, s, l, sep, 256, center)\n            _update_lut(cmap, colors)\n            _show_cmap(cmap)\n        else:\n            pal[:] = diverging_palette(h_neg, h_pos, s, l, sep, n, center)\n            palplot(pal)\n\n    if as_cmap:\n        return cmap\n    return pal\n\n\ndef choose_cubehelix_palette(as_cmap=False):\n    \"\"\"Launch an interactive widget to create a sequential cubehelix palette.\n\n    This corresponds with the :func:`cubehelix_palette` function. This kind\n    of palette is good for data that range between relatively uninteresting\n    low values and interesting high values. The cubehelix system allows the\n    palette to have more hue variance across the range, which can be helpful\n    for distinguishing a wider range of values.\n\n    Requires IPython 2+ and must be used in the notebook.\n\n    Parameters\n    ----------\n    as_cmap : bool\n        If True, the return value is a matplotlib colormap rather than a\n        list of discrete colors.\n\n    Returns\n    -------\n    pal or cmap : list of colors or matplotlib colormap\n        Object that can be passed to plotting functions.\n\n    See Also\n    --------\n    cubehelix_palette : Create a sequential palette or colormap using the\n                        cubehelix system.\n\n    \"\"\"\n    pal = []\n    if as_cmap:\n        cmap = _init_mutable_colormap()\n\n    @interact\n    def choose_cubehelix(n_colors=IntSlider(min=2, max=16, value=9),\n                         start=FloatSlider(min=0, max=3, value=0),\n                         rot=FloatSlider(min=-1, max=1, value=.4),\n                         gamma=FloatSlider(min=0, max=5, value=1),\n                         hue=FloatSlider(min=0, max=1, value=.8),\n                         light=FloatSlider(min=0, max=1, value=.85),\n                         dark=FloatSlider(min=0, max=1, value=.15),\n                         reverse=False):\n\n        if as_cmap:\n            colors = cubehelix_palette(256, start, rot, gamma,\n                                       hue, light, dark, reverse)\n            _update_lut(cmap, np.c_[colors, np.ones(256)])\n            _show_cmap(cmap)\n        else:\n            pal[:] = cubehelix_palette(n_colors, start, rot, gamma,\n                                       hue, light, dark, reverse)\n            palplot(pal)\n\n    if as_cmap:\n        return cmap\n    return pal\n", "description": "Statistical data visualization using matplotlib", "file_name": "widgets.py", "id": "f4ef63256cbff179cafc1e2cc3e85531", "language": "Python", "project_name": "seaborn", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mwaskom-seaborn/mwaskom-seaborn-71a807b/seaborn/widgets.py", "save_time": "", "source": "", "update_at": "2018-03-18T02:14:24Z", "url": "https://github.com/mwaskom/seaborn", "wiki": false}