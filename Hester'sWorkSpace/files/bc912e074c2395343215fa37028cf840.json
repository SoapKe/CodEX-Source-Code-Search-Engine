{"author": "HelloZeroNet", "code": "\n This file is part of pyasn1 software.\n\n Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>\n License: http://pyasn1.sf.net/license.html\n\nfrom pyasn1.type import univ\nfrom pyasn1.codec.cer import decoder\n\n__all__ = ['decode']\n\n\nclass BitStringDecoder(decoder.BitStringDecoder):\n    supportConstructedForm = False\n\n\nclass OctetStringDecoder(decoder.OctetStringDecoder):\n    supportConstructedForm = False\n\n TODO: prohibit non-canonical encoding\nRealDecoder = decoder.RealDecoder\n\ntagMap = decoder.tagMap.copy()\ntagMap.update(\n    {univ.BitString.tagSet: BitStringDecoder(),\n     univ.OctetString.tagSet: OctetStringDecoder(),\n     univ.Real.tagSet: RealDecoder()}\n)\n\ntypeMap = decoder.typeMap.copy()\n\n Put in non-ambiguous types for faster codec lookup\nfor typeDecoder in tagMap.values():\n    typeId = typeDecoder.protoComponent.__class__.typeId\n    if typeId is not None and typeId not in typeMap:\n        typeMap[typeId] = typeDecoder\n\n\nclass Decoder(decoder.Decoder):\n    supportIndefLength = False\n\n\n: Turns DER octet stream into an ASN.1 object.\n:\n: Takes DER octetstream and decode it into an ASN.1 object\n: (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which\n: may be a scalar or an arbitrary nested structure.\n:\n: Parameters\n: ----------\n: substrate: :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n:     DER octetstream\n:\n: asn1Spec: any pyasn1 type object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n:     A pyasn1 type object to act as a template guiding the decoder. Depending on the ASN.1 structure\n:     being decoded, *asn1Spec* may or may not be required. Most common reason for\n:     it to require is that ASN.1 structure is encoded in *IMPLICIT* tagging mode.\n:\n: Returns\n: -------\n: : :py:class:`tuple`\n:     A tuple of pyasn1 object recovered from DER substrate (:py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n:     and the unprocessed trailing portion of the *substrate* (may be empty)\n:\n: Raises\n: ------\n: : :py:class:`pyasn1.error.PyAsn1Error`\n:     On decoding errors\ndecode = Decoder(tagMap, typeMap)\n", "comments": "     this file part pyasn1 software        copyright (c) 2005 2017  ilya etingof  etingof gmail com     license  http   pyasn1 sf net license html       todo  prohibit non canonical encoding    put non ambiguous types faster codec lookup     turns der octet stream asn 1 object          takes der octetstream decode asn 1 object     (e g   py class   pyasn1 type base pyasn1item  derivative)     may scalar arbitrary nested structure          parameters                    substrate   py class  bytes  (python 3)  py class  str  (python 2)         der octetstream         asn1spec  pyasn1 type object e g   py class   pyasn1 type base pyasn1item  derivative         a pyasn1 type object act template guiding decoder  depending asn 1 structure         decoded   asn1spec  may may required  most common reason         require asn 1 structure encoded  implicit  tagging mode          returns                    py class  tuple          a tuple pyasn1 object recovered der substrate ( py class   pyasn1 type base pyasn1item  derivative)         unprocessed trailing portion  substrate  (may empty)         raises                   py class  pyasn1 error pyasn1error          on decoding errors ", "content": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>\n# License: http://pyasn1.sf.net/license.html\n#\nfrom pyasn1.type import univ\nfrom pyasn1.codec.cer import decoder\n\n__all__ = ['decode']\n\n\nclass BitStringDecoder(decoder.BitStringDecoder):\n    supportConstructedForm = False\n\n\nclass OctetStringDecoder(decoder.OctetStringDecoder):\n    supportConstructedForm = False\n\n# TODO: prohibit non-canonical encoding\nRealDecoder = decoder.RealDecoder\n\ntagMap = decoder.tagMap.copy()\ntagMap.update(\n    {univ.BitString.tagSet: BitStringDecoder(),\n     univ.OctetString.tagSet: OctetStringDecoder(),\n     univ.Real.tagSet: RealDecoder()}\n)\n\ntypeMap = decoder.typeMap.copy()\n\n# Put in non-ambiguous types for faster codec lookup\nfor typeDecoder in tagMap.values():\n    typeId = typeDecoder.protoComponent.__class__.typeId\n    if typeId is not None and typeId not in typeMap:\n        typeMap[typeId] = typeDecoder\n\n\nclass Decoder(decoder.Decoder):\n    supportIndefLength = False\n\n\n#: Turns DER octet stream into an ASN.1 object.\n#:\n#: Takes DER octetstream and decode it into an ASN.1 object\n#: (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which\n#: may be a scalar or an arbitrary nested structure.\n#:\n#: Parameters\n#: ----------\n#: substrate: :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n#:     DER octetstream\n#:\n#: asn1Spec: any pyasn1 type object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:     A pyasn1 type object to act as a template guiding the decoder. Depending on the ASN.1 structure\n#:     being decoded, *asn1Spec* may or may not be required. Most common reason for\n#:     it to require is that ASN.1 structure is encoded in *IMPLICIT* tagging mode.\n#:\n#: Returns\n#: -------\n#: : :py:class:`tuple`\n#:     A tuple of pyasn1 object recovered from DER substrate (:py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     and the unprocessed trailing portion of the *substrate* (may be empty)\n#:\n#: Raises\n#: ------\n#: : :py:class:`pyasn1.error.PyAsn1Error`\n#:     On decoding errors\ndecode = Decoder(tagMap, typeMap)\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "decoder.py", "id": "bc912e074c2395343215fa37028cf840", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/lib/pyasn1/codec/der/decoder.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}