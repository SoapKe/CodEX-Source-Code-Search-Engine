{"author": "pallets", "code": "\n\n    \n    \n    \n    class metaclass(type):\n        def __new__(cls, name, this_bases, d):\n            return meta(name, bases, d)\n    return type.__new__(metaclass, 'temporary_class', (), {})\n\n\n\n\n\n\n\n\n\n\n\n\n\nBROKEN_PYPY_CTXMGR_EXIT = False\nif hasattr(sys, 'pypy_version_info'):\n    class _Mgr(object):\n        def __enter__(self):\n            return self\n        def __exit__(self, *args):\n            if hasattr(sys, 'exc_clear'):\n                \n                sys.exc_clear()\n    try:\n        try:\n            with _Mgr():\n                raise AssertionError()\n        except:\n            raise\n    except TypeError:\n        BROKEN_PYPY_CTXMGR_EXIT = True\n    except AssertionError:\n        pass\n", "comments": "\n    flask._compat\n    ~~~~~~~~~~~~~\n\n    Some py2/py3 compatibility support based on a stripped down\n    version of six so we don't have to depend on a specific version\n    of it.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport sys\n\nPY2 = sys.version_info[0] == 2\n_identity = lambda x: x\n\n\nif not PY2:\n    text_type = str\n    string_types = (str,)\n    integer_types = (int,)\n\n    iterkeys = lambda d: iter(d.keys())\n    itervalues = lambda d: iter(d.values())\n    iteritems = lambda d: iter(d.items())\n\n    from inspect import getfullargspec as getargspec\n    from io import StringIO\n\n    def reraise(tp, value, tb=None):\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n\n    implements_to_string = _identity\n\nelse:\n    text_type = unicode\n    string_types = (str, unicode)\n    integer_types = (int, long)\n\n    iterkeys = lambda d: d.iterkeys()\n    itervalues = lambda d: d.itervalues()\n    iteritems = lambda d: d.iteritems()\n\n    from inspect import getargspec\n    from cStringIO import StringIO\n\n    exec('def reraise(tp, value, tb=None):\\n raise tp, value, tb')\n\n    def implements_to_string(cls):\n        cls.__unicode__ = cls.__str__\n        cls.__str__ = lambda x: x.__unicode__().encode('utf-8')\n        return cls\n\n\ndef with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\n.\n# -*- coding: utf-8 -*-\n# This requires a bit of explanation: the basic idea is to make a\n# dummy metaclass for one level of class instantiation that replaces\n# itself with the actual metaclass.\n# Certain versions of pypy have a bug where clearing the exception stack\n# breaks the __exit__ function in a very peculiar way.  The second level of\n# exception blocks is necessary because pypy seems to forget to check if an\n# exception happened until the next bytecode instruction?\n#\n# Relevant PyPy bugfix commit:\n# https://bitbucket.org/pypy/pypy/commits/77ecf91c635a287e88e60d8ddb0f4e9df4003301\n# According to ronan on #pypy IRC, it is released in PyPy2 2.3 and later\n# versions.\n#\n# Ubuntu 14.04 has PyPy 2.2.1, which does exhibit this bug.\n# Python 3 (PyPy3) doesn't have exc_clear\n", "content": "# -*- coding: utf-8 -*-\n\"\"\"\n    flask._compat\n    ~~~~~~~~~~~~~\n\n    Some py2/py3 compatibility support based on a stripped down\n    version of six so we don't have to depend on a specific version\n    of it.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport sys\n\nPY2 = sys.version_info[0] == 2\n_identity = lambda x: x\n\n\nif not PY2:\n    text_type = str\n    string_types = (str,)\n    integer_types = (int,)\n\n    iterkeys = lambda d: iter(d.keys())\n    itervalues = lambda d: iter(d.values())\n    iteritems = lambda d: iter(d.items())\n\n    from inspect import getfullargspec as getargspec\n    from io import StringIO\n\n    def reraise(tp, value, tb=None):\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n\n    implements_to_string = _identity\n\nelse:\n    text_type = unicode\n    string_types = (str, unicode)\n    integer_types = (int, long)\n\n    iterkeys = lambda d: d.iterkeys()\n    itervalues = lambda d: d.itervalues()\n    iteritems = lambda d: d.iteritems()\n\n    from inspect import getargspec\n    from cStringIO import StringIO\n\n    exec('def reraise(tp, value, tb=None):\\n raise tp, value, tb')\n\n    def implements_to_string(cls):\n        cls.__unicode__ = cls.__str__\n        cls.__str__ = lambda x: x.__unicode__().encode('utf-8')\n        return cls\n\n\ndef with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n    # This requires a bit of explanation: the basic idea is to make a\n    # dummy metaclass for one level of class instantiation that replaces\n    # itself with the actual metaclass.\n    class metaclass(type):\n        def __new__(cls, name, this_bases, d):\n            return meta(name, bases, d)\n    return type.__new__(metaclass, 'temporary_class', (), {})\n\n\n# Certain versions of pypy have a bug where clearing the exception stack\n# breaks the __exit__ function in a very peculiar way.  The second level of\n# exception blocks is necessary because pypy seems to forget to check if an\n# exception happened until the next bytecode instruction?\n#\n# Relevant PyPy bugfix commit:\n# https://bitbucket.org/pypy/pypy/commits/77ecf91c635a287e88e60d8ddb0f4e9df4003301\n# According to ronan on #pypy IRC, it is released in PyPy2 2.3 and later\n# versions.\n#\n# Ubuntu 14.04 has PyPy 2.2.1, which does exhibit this bug.\nBROKEN_PYPY_CTXMGR_EXIT = False\nif hasattr(sys, 'pypy_version_info'):\n    class _Mgr(object):\n        def __enter__(self):\n            return self\n        def __exit__(self, *args):\n            if hasattr(sys, 'exc_clear'):\n                # Python 3 (PyPy3) doesn't have exc_clear\n                sys.exc_clear()\n    try:\n        try:\n            with _Mgr():\n                raise AssertionError()\n        except:\n            raise\n    except TypeError:\n        BROKEN_PYPY_CTXMGR_EXIT = True\n    except AssertionError:\n        pass\n", "description": "The Python micro framework for building web applications.", "file_name": "_compat.py", "language": "Python", "project_name": "flask", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/pallets_flask/pallets-flask-a2ea186/flask/_compat.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:52:03Z", "url": "https://github.com/pallets/flask", "wiki": false}