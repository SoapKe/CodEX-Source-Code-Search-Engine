{"author": "littlecodersh", "code": "import logging, copy, pickle\nfrom weakref import ref\n\nfrom ..returnvalues import ReturnValue\nfrom ..utils import update_info_dict\n\nlogger = logging.getLogger('itchat')\n\nclass AttributeDict(dict):\n    def __getattr__(self, value):\n        keyName = value[0].upper() + value[1:]\n        try:\n            return self[keyName]\n        except KeyError:\n            raise AttributeError(\"'%s' object has no attribute '%s'\" % (\n                self.__class__.__name__.split('.')[-1], value))\n    def get(self, v, d=None):\n        try:\n            return self[v]\n        except KeyError:\n            return d\n\nclass UnInitializedItchat(object):\n    def _raise_error(self, *args, **kwargs):\n        logger.warning('An itchat instance is called before initialized')\n    def __getattr__(self, value):\n        return self._raise_error\n\nclass ContactList(list):\n    \n    def __init__(self, *args, **kwargs):\n        super(ContactList, self).__init__(*args, **kwargs)\n        self.__setstate__(None)\n    @property\n    def core(self):\n        return getattr(self, '_core', lambda: fakeItchat)() or fakeItchat\n    @core.setter\n    def core(self, value):\n        self._core = ref(value)\n    def set_default_value(self, initFunction=None, contactClass=None):\n        if hasattr(initFunction, '__call__'):\n            self.contactInitFn = initFunction\n        if hasattr(contactClass, '__call__'):\n            self.contactClass = contactClass\n    def append(self, value):\n        contact = self.contactClass(value)\n        contact.core = self.core\n        if self.contactInitFn is not None:\n            contact = self.contactInitFn(self, contact) or contact\n        super(ContactList, self).append(contact)\n    def __deepcopy__(self, memo):\n        r = self.__class__([copy.deepcopy(v) for v in self])\n        r.contactInitFn = self.contactInitFn\n        r.contactClass = self.contactClass\n        r.core = self.core\n        return r\n    def __getstate__(self):\n        return 1\n    def __setstate__(self, state):\n        self.contactInitFn = None\n        self.contactClass = User\n    def __str__(self):\n        return '[%s]' % ', '.join([repr(v) for v in self])\n    def __repr__(self):\n        return '<%s: %s>' % (self.__class__.__name__.split('.')[-1],\n            self.__str__())\n\nclass AbstractUserDict(AttributeDict):\n    def __init__(self, *args, **kwargs):\n        super(AbstractUserDict, self).__init__(*args, **kwargs)\n    @property\n    def core(self):\n        return getattr(self, '_core', lambda: fakeItchat)() or fakeItchat\n    @core.setter\n    def core(self, value):\n        self._core = ref(value)\n    def update(self):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not be updated' % \\\n                self.__class__.__name__, }, })\n    def set_alias(self, alias):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not set alias' % \\\n                self.__class__.__name__, }, })\n    def set_pinned(self, isPinned=True):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not be pinned' % \\\n                self.__class__.__name__, }, })\n    def verify(self):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s do not need verify' % \\\n                self.__class__.__name__, }, })\n    def get_head_image(self, imageDir=None):\n        return self.core.get_head_img(self.userName, picDir=imageDir)\n    def delete_member(self, userName):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not delete member' % \\\n                self.__class__.__name__, }, })\n    def add_member(self, userName):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not add member' % \\\n                self.__class__.__name__, }, })\n    def send_raw_msg(self, msgType, content):\n        return self.core.send_raw_msg(msgType, content, self.userName)\n    def send_msg(self, msg='Test Message'):\n        return self.core.send_msg(msg, self.userName)\n    def send_file(self, fileDir, mediaId=None):\n        return self.core.send_file(fileDir, self.userName, mediaId)\n    def send_image(self, fileDir, mediaId=None):\n        return self.core.send_image(fileDir, self.userName, mediaId)\n    def send_video(self, fileDir=None, mediaId=None):\n        return self.core.send_video(fileDir, self.userName, mediaId)\n    def send(self, msg, mediaId=None):\n        return self.core.send(msg, self.userName, mediaId)\n    def search_member(self, name=None, userName=None, remarkName=None, nickName=None,\n            wechatAccount=None):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s do not have members' % \\\n                self.__class__.__name__, }, })\n    def __deepcopy__(self, memo):\n        r = self.__class__()\n        for k, v in self.items():\n            r[copy.deepcopy(k)] = copy.deepcopy(v)\n        r.core = self.core\n        return r\n    def __str__(self):\n        return '{%s}' % ', '.join(\n            ['%s: %s' % (repr(k),repr(v)) for k,v in self.items()])\n    def __repr__(self):\n        return '<%s: %s>' % (self.__class__.__name__.split('.')[-1],\n            self.__str__())\n    def __getstate__(self):\n        return 1\n    def __setstate__(self, state):\n        pass\n        \nclass User(AbstractUserDict):\n    def __init__(self, *args, **kwargs):\n        super(User, self).__init__(*args, **kwargs)\n        self.__setstate__(None)\n    def update(self):\n        r = self.core.update_friend(self.userName)\n        if r:\n            update_info_dict(self, r)\n        return r\n    def set_alias(self, alias):\n        return self.core.set_alias(self.userName, alias)\n    def set_pinned(self, isPinned=True):\n        return self.core.set_pinned(self.userName, isPinned)\n    def verify(self):\n        return self.core.add_friend(**self.verifyDict)\n    def __deepcopy__(self, memo):\n        r = super(User, self).__deepcopy__(memo)\n        r.verifyDict = copy.deepcopy(self.verifyDict)\n        return r\n    def __setstate__(self, state):\n        super(User, self).__setstate__(state)\n        self.verifyDict = {}\n        self['MemberList'] = fakeContactList\n\nclass MassivePlatform(AbstractUserDict):\n    def __init__(self, *args, **kwargs):\n        super(MassivePlatform, self).__init__(*args, **kwargs)\n        self.__setstate__(None)\n    def __setstate__(self, state):\n        super(MassivePlatform, self).__setstate__(state)\n        self['MemberList'] = fakeContactList\n\nclass Chatroom(AbstractUserDict):\n    def __init__(self, *args, **kwargs):\n        super(Chatroom, self).__init__(*args, **kwargs)\n        memberList = ContactList()\n        userName = self.get('UserName', '')\n        refSelf = ref(self)\n        def init_fn(parentList, d):\n            d.chatroom = refSelf() or \\\n                parentList.core.search_chatrooms(userName=userName)\n        memberList.set_default_value(init_fn, ChatroomMember)\n        if 'MemberList' in self:\n            for member in self.memberList:\n                memberList.append(member)\n        self['MemberList'] = memberList\n    @property\n    def core(self):\n        return getattr(self, '_core', lambda: fakeItchat)() or fakeItchat\n    @core.setter\n    def core(self, value):\n        self._core = ref(value)\n        self.memberList.core = value\n        for member in self.memberList:\n            member.core = value\n    def update(self, detailedMember=False):\n        r = self.core.update_chatroom(self.userName, detailedMember)\n        if r:\n            update_info_dict(self, r)\n            self['MemberList'] = r['MemberList']\n        return r\n    def set_alias(self, alias):\n        return self.core.set_chatroom_name(self.userName, alias)\n    def set_pinned(self, isPinned=True):\n        return self.core.set_pinned(self.userName, isPinned)\n    def delete_member(self, userName):\n        return self.core.delete_member_from_chatroom(self.userName, userName)\n    def add_member(self, userName):\n        return self.core.add_member_into_chatroom(self.userName, userName)\n    def search_member(self, name=None, userName=None, remarkName=None, nickName=None,\n            wechatAccount=None):\n        with self.core.storageClass.updateLock:\n            if (name or userName or remarkName or nickName or wechatAccount) is None:\n                return None\n            elif userName: \n                for m in self.memberList:\n                    if m.userName == userName:\n                        return copy.deepcopy(m)\n            else:\n                matchDict = {\n                    'RemarkName' : remarkName,\n                    'NickName'   : nickName,\n                    'Alias'      : wechatAccount, }\n                for k in ('RemarkName', 'NickName', 'Alias'):\n                    if matchDict[k] is None:\n                        del matchDict[k]\n                if name: \n                    contact = []\n                    for m in self.memberList:\n                        if any([m.get(k) == name for k in ('RemarkName', 'NickName', 'Alias')]):\n                            contact.append(m)\n                else:\n                    contact = self.memberList[:]\n                if matchDict: \n                    friendList = []\n                    for m in contact:\n                        if all([m.get(k) == v for k, v in matchDict.items()]):\n                            friendList.append(m)\n                    return copy.deepcopy(friendList)\n                else:\n                    return copy.deepcopy(contact)\n    def __setstate__(self, state):\n        super(Chatroom, self).__setstate__(state)\n        if not 'MemberList' in self:\n            self['MemberList'] = fakeContactList\n\nclass ChatroomMember(AbstractUserDict):\n    def __init__(self, *args, **kwargs):\n        super(AbstractUserDict, self).__init__(*args, **kwargs)\n        self.__setstate__(None)\n    @property\n    def chatroom(self):\n        r = getattr(self, '_chatroom', lambda: fakeChatroom)()\n        if r is None:\n            userName = getattr(self, '_chatroomUserName', '')\n            r = self.core.search_chatrooms(userName=userName)\n            if isinstance(r, dict):\n                self.chatroom = r\n        return r or fakeChatroom\n    @chatroom.setter\n    def chatroom(self, value):\n        if isinstance(value, dict) and 'UserName' in value:\n            self._chatroom = ref(value)\n            self._chatroomUserName = value['UserName']\n    def get_head_image(self, imageDir=None):\n        return self.core.get_head_img(self.userName, self.chatroom.userName, picDir=imageDir)\n    def delete_member(self, userName):\n        return self.core.delete_member_from_chatroom(self.chatroom.userName, self.userName)\n    def send_raw_msg(self, msgType, content):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not send message directly' % \\\n                self.__class__.__name__, }, })\n    def send_msg(self, msg='Test Message'):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not send message directly' % \\\n                self.__class__.__name__, }, })\n    def send_file(self, fileDir, mediaId=None):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not send message directly' % \\\n                self.__class__.__name__, }, })\n    def send_image(self, fileDir, mediaId=None):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not send message directly' % \\\n                self.__class__.__name__, }, })\n    def send_video(self, fileDir=None, mediaId=None):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not send message directly' % \\\n                self.__class__.__name__, }, })\n    def send(self, msg, mediaId=None):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not send message directly' % \\\n                self.__class__.__name__, }, })\n    def __setstate__(self, state):\n        super(ChatroomMember, self).__setstate__(state)\n        self['MemberList'] = fakeContactList\n\ndef wrap_user_dict(d):\n    userName = d.get('UserName')\n    if '@@' in userName:\n        r = Chatroom(d)\n    elif d.get('VerifyFlag', 8) & 8 == 0:\n        r = User(d)\n    else:\n        r = MassivePlatform(d)\n    return r\n\nfakeItchat = UnInitializedItchat()\nfakeContactList = ContactList()\nfakeChatroom = Chatroom()\n", "comments": "    dict append  init function called format dict        return username match    select based name    select based matchdict ", "content": "import logging, copy, pickle\nfrom weakref import ref\n\nfrom ..returnvalues import ReturnValue\nfrom ..utils import update_info_dict\n\nlogger = logging.getLogger('itchat')\n\nclass AttributeDict(dict):\n    def __getattr__(self, value):\n        keyName = value[0].upper() + value[1:]\n        try:\n            return self[keyName]\n        except KeyError:\n            raise AttributeError(\"'%s' object has no attribute '%s'\" % (\n                self.__class__.__name__.split('.')[-1], value))\n    def get(self, v, d=None):\n        try:\n            return self[v]\n        except KeyError:\n            return d\n\nclass UnInitializedItchat(object):\n    def _raise_error(self, *args, **kwargs):\n        logger.warning('An itchat instance is called before initialized')\n    def __getattr__(self, value):\n        return self._raise_error\n\nclass ContactList(list):\n    ''' when a dict is append, init function will be called to format that dict '''\n    def __init__(self, *args, **kwargs):\n        super(ContactList, self).__init__(*args, **kwargs)\n        self.__setstate__(None)\n    @property\n    def core(self):\n        return getattr(self, '_core', lambda: fakeItchat)() or fakeItchat\n    @core.setter\n    def core(self, value):\n        self._core = ref(value)\n    def set_default_value(self, initFunction=None, contactClass=None):\n        if hasattr(initFunction, '__call__'):\n            self.contactInitFn = initFunction\n        if hasattr(contactClass, '__call__'):\n            self.contactClass = contactClass\n    def append(self, value):\n        contact = self.contactClass(value)\n        contact.core = self.core\n        if self.contactInitFn is not None:\n            contact = self.contactInitFn(self, contact) or contact\n        super(ContactList, self).append(contact)\n    def __deepcopy__(self, memo):\n        r = self.__class__([copy.deepcopy(v) for v in self])\n        r.contactInitFn = self.contactInitFn\n        r.contactClass = self.contactClass\n        r.core = self.core\n        return r\n    def __getstate__(self):\n        return 1\n    def __setstate__(self, state):\n        self.contactInitFn = None\n        self.contactClass = User\n    def __str__(self):\n        return '[%s]' % ', '.join([repr(v) for v in self])\n    def __repr__(self):\n        return '<%s: %s>' % (self.__class__.__name__.split('.')[-1],\n            self.__str__())\n\nclass AbstractUserDict(AttributeDict):\n    def __init__(self, *args, **kwargs):\n        super(AbstractUserDict, self).__init__(*args, **kwargs)\n    @property\n    def core(self):\n        return getattr(self, '_core', lambda: fakeItchat)() or fakeItchat\n    @core.setter\n    def core(self, value):\n        self._core = ref(value)\n    def update(self):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not be updated' % \\\n                self.__class__.__name__, }, })\n    def set_alias(self, alias):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not set alias' % \\\n                self.__class__.__name__, }, })\n    def set_pinned(self, isPinned=True):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not be pinned' % \\\n                self.__class__.__name__, }, })\n    def verify(self):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s do not need verify' % \\\n                self.__class__.__name__, }, })\n    def get_head_image(self, imageDir=None):\n        return self.core.get_head_img(self.userName, picDir=imageDir)\n    def delete_member(self, userName):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not delete member' % \\\n                self.__class__.__name__, }, })\n    def add_member(self, userName):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not add member' % \\\n                self.__class__.__name__, }, })\n    def send_raw_msg(self, msgType, content):\n        return self.core.send_raw_msg(msgType, content, self.userName)\n    def send_msg(self, msg='Test Message'):\n        return self.core.send_msg(msg, self.userName)\n    def send_file(self, fileDir, mediaId=None):\n        return self.core.send_file(fileDir, self.userName, mediaId)\n    def send_image(self, fileDir, mediaId=None):\n        return self.core.send_image(fileDir, self.userName, mediaId)\n    def send_video(self, fileDir=None, mediaId=None):\n        return self.core.send_video(fileDir, self.userName, mediaId)\n    def send(self, msg, mediaId=None):\n        return self.core.send(msg, self.userName, mediaId)\n    def search_member(self, name=None, userName=None, remarkName=None, nickName=None,\n            wechatAccount=None):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s do not have members' % \\\n                self.__class__.__name__, }, })\n    def __deepcopy__(self, memo):\n        r = self.__class__()\n        for k, v in self.items():\n            r[copy.deepcopy(k)] = copy.deepcopy(v)\n        r.core = self.core\n        return r\n    def __str__(self):\n        return '{%s}' % ', '.join(\n            ['%s: %s' % (repr(k),repr(v)) for k,v in self.items()])\n    def __repr__(self):\n        return '<%s: %s>' % (self.__class__.__name__.split('.')[-1],\n            self.__str__())\n    def __getstate__(self):\n        return 1\n    def __setstate__(self, state):\n        pass\n        \nclass User(AbstractUserDict):\n    def __init__(self, *args, **kwargs):\n        super(User, self).__init__(*args, **kwargs)\n        self.__setstate__(None)\n    def update(self):\n        r = self.core.update_friend(self.userName)\n        if r:\n            update_info_dict(self, r)\n        return r\n    def set_alias(self, alias):\n        return self.core.set_alias(self.userName, alias)\n    def set_pinned(self, isPinned=True):\n        return self.core.set_pinned(self.userName, isPinned)\n    def verify(self):\n        return self.core.add_friend(**self.verifyDict)\n    def __deepcopy__(self, memo):\n        r = super(User, self).__deepcopy__(memo)\n        r.verifyDict = copy.deepcopy(self.verifyDict)\n        return r\n    def __setstate__(self, state):\n        super(User, self).__setstate__(state)\n        self.verifyDict = {}\n        self['MemberList'] = fakeContactList\n\nclass MassivePlatform(AbstractUserDict):\n    def __init__(self, *args, **kwargs):\n        super(MassivePlatform, self).__init__(*args, **kwargs)\n        self.__setstate__(None)\n    def __setstate__(self, state):\n        super(MassivePlatform, self).__setstate__(state)\n        self['MemberList'] = fakeContactList\n\nclass Chatroom(AbstractUserDict):\n    def __init__(self, *args, **kwargs):\n        super(Chatroom, self).__init__(*args, **kwargs)\n        memberList = ContactList()\n        userName = self.get('UserName', '')\n        refSelf = ref(self)\n        def init_fn(parentList, d):\n            d.chatroom = refSelf() or \\\n                parentList.core.search_chatrooms(userName=userName)\n        memberList.set_default_value(init_fn, ChatroomMember)\n        if 'MemberList' in self:\n            for member in self.memberList:\n                memberList.append(member)\n        self['MemberList'] = memberList\n    @property\n    def core(self):\n        return getattr(self, '_core', lambda: fakeItchat)() or fakeItchat\n    @core.setter\n    def core(self, value):\n        self._core = ref(value)\n        self.memberList.core = value\n        for member in self.memberList:\n            member.core = value\n    def update(self, detailedMember=False):\n        r = self.core.update_chatroom(self.userName, detailedMember)\n        if r:\n            update_info_dict(self, r)\n            self['MemberList'] = r['MemberList']\n        return r\n    def set_alias(self, alias):\n        return self.core.set_chatroom_name(self.userName, alias)\n    def set_pinned(self, isPinned=True):\n        return self.core.set_pinned(self.userName, isPinned)\n    def delete_member(self, userName):\n        return self.core.delete_member_from_chatroom(self.userName, userName)\n    def add_member(self, userName):\n        return self.core.add_member_into_chatroom(self.userName, userName)\n    def search_member(self, name=None, userName=None, remarkName=None, nickName=None,\n            wechatAccount=None):\n        with self.core.storageClass.updateLock:\n            if (name or userName or remarkName or nickName or wechatAccount) is None:\n                return None\n            elif userName: # return the only userName match\n                for m in self.memberList:\n                    if m.userName == userName:\n                        return copy.deepcopy(m)\n            else:\n                matchDict = {\n                    'RemarkName' : remarkName,\n                    'NickName'   : nickName,\n                    'Alias'      : wechatAccount, }\n                for k in ('RemarkName', 'NickName', 'Alias'):\n                    if matchDict[k] is None:\n                        del matchDict[k]\n                if name: # select based on name\n                    contact = []\n                    for m in self.memberList:\n                        if any([m.get(k) == name for k in ('RemarkName', 'NickName', 'Alias')]):\n                            contact.append(m)\n                else:\n                    contact = self.memberList[:]\n                if matchDict: # select again based on matchDict\n                    friendList = []\n                    for m in contact:\n                        if all([m.get(k) == v for k, v in matchDict.items()]):\n                            friendList.append(m)\n                    return copy.deepcopy(friendList)\n                else:\n                    return copy.deepcopy(contact)\n    def __setstate__(self, state):\n        super(Chatroom, self).__setstate__(state)\n        if not 'MemberList' in self:\n            self['MemberList'] = fakeContactList\n\nclass ChatroomMember(AbstractUserDict):\n    def __init__(self, *args, **kwargs):\n        super(AbstractUserDict, self).__init__(*args, **kwargs)\n        self.__setstate__(None)\n    @property\n    def chatroom(self):\n        r = getattr(self, '_chatroom', lambda: fakeChatroom)()\n        if r is None:\n            userName = getattr(self, '_chatroomUserName', '')\n            r = self.core.search_chatrooms(userName=userName)\n            if isinstance(r, dict):\n                self.chatroom = r\n        return r or fakeChatroom\n    @chatroom.setter\n    def chatroom(self, value):\n        if isinstance(value, dict) and 'UserName' in value:\n            self._chatroom = ref(value)\n            self._chatroomUserName = value['UserName']\n    def get_head_image(self, imageDir=None):\n        return self.core.get_head_img(self.userName, self.chatroom.userName, picDir=imageDir)\n    def delete_member(self, userName):\n        return self.core.delete_member_from_chatroom(self.chatroom.userName, self.userName)\n    def send_raw_msg(self, msgType, content):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not send message directly' % \\\n                self.__class__.__name__, }, })\n    def send_msg(self, msg='Test Message'):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not send message directly' % \\\n                self.__class__.__name__, }, })\n    def send_file(self, fileDir, mediaId=None):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not send message directly' % \\\n                self.__class__.__name__, }, })\n    def send_image(self, fileDir, mediaId=None):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not send message directly' % \\\n                self.__class__.__name__, }, })\n    def send_video(self, fileDir=None, mediaId=None):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not send message directly' % \\\n                self.__class__.__name__, }, })\n    def send(self, msg, mediaId=None):\n        return ReturnValue({'BaseResponse': {\n            'Ret': -1006,\n            'ErrMsg': '%s can not send message directly' % \\\n                self.__class__.__name__, }, })\n    def __setstate__(self, state):\n        super(ChatroomMember, self).__setstate__(state)\n        self['MemberList'] = fakeContactList\n\ndef wrap_user_dict(d):\n    userName = d.get('UserName')\n    if '@@' in userName:\n        r = Chatroom(d)\n    elif d.get('VerifyFlag', 8) & 8 == 0:\n        r = User(d)\n    else:\n        r = MassivePlatform(d)\n    return r\n\nfakeItchat = UnInitializedItchat()\nfakeContactList = ContactList()\nfakeChatroom = Chatroom()\n", "description": "A complete and graceful API for Wechat. \u5fae\u4fe1\u4e2a\u4eba\u53f7\u63a5\u53e3\u3001\u5fae\u4fe1\u673a\u5668\u4eba\u53ca\u547d\u4ee4\u884c\u5fae\u4fe1\uff0c\u4e09\u5341\u884c\u5373\u53ef\u81ea\u5b9a\u4e49\u4e2a\u4eba\u53f7\u673a\u5668\u4eba\u3002", "file_name": "templates.py", "id": "711da914dad3bfd1939ab45c9747c135", "language": "Python", "project_name": "ItChat", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/littlecodersh-ItChat/littlecodersh-ItChat-8622c3c/itchat/storage/templates.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:54:42Z", "url": "https://github.com/littlecodersh/ItChat", "wiki": true}