{"author": "tensorflow", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================\n\nr\"\"\"Implements loading and rendering of meshes. Contains 2 classes:\n  Shape: Class that exposes high level functions for loading and manipulating\n    shapes. This currently is bound to assimp\n    (https://github.com/assimp/assimp). If you want to interface to a different\n    library, reimplement this class with bindings to your mesh loading library.\n\n  SwiftshaderRenderer: Class that renders Shapes. Currently this uses python\n    bindings to OpenGL (EGL), bindings to an alternate renderer may be implemented\n    here. \n\"\"\"\n\nimport numpy as np, os\nimport cv2, ctypes, logging, os, numpy as np\nimport pyassimp as assimp\nfrom OpenGL.GLES2 import *\nfrom OpenGL.EGL import *\nimport src.rotation_utils as ru \n\n__version__ = 'swiftshader_renderer'\n\ndef get_shaders(modalities):\n  rgb_shader = 'rgb_flat_color' if 'rgb' in modalities else None\n  d_shader = 'depth_rgb_encoded' if 'depth' in modalities else None\n  return rgb_shader, d_shader\n\ndef sample_points_on_faces(vs, fs, rng, n_samples_per_face):\n  idx = np.repeat(np.arange(fs.shape[0]), n_samples_per_face)\n  \n  r = rng.rand(idx.size, 2)\n  r1 = r[:,:1]; r2 = r[:,1:]; sqrt_r1 = np.sqrt(r1);\n  \n  v1 = vs[fs[idx, 0], :]; v2 = vs[fs[idx, 1], :]; v3 = vs[fs[idx, 2], :];\n  pts = (1-sqrt_r1)*v1 + sqrt_r1*(1-r2)*v2 + sqrt_r1*r2*v3\n  \n  v1 = vs[fs[:,0], :]; v2 = vs[fs[:, 1], :]; v3 = vs[fs[:, 2], :];\n  ar = 0.5*np.sqrt(np.sum(np.cross(v1-v3, v2-v3)**2, 1))\n  \n  return pts, ar, idx\n\nclass Shape():\n  def get_pyassimp_load_options(self):\n    load_flags = assimp.postprocess.aiProcess_Triangulate;\n    load_flags = load_flags | assimp.postprocess.aiProcess_SortByPType;\n    load_flags = load_flags | assimp.postprocess.aiProcess_OptimizeMeshes;\n    load_flags = load_flags | assimp.postprocess.aiProcess_RemoveRedundantMaterials;\n    load_flags = load_flags | assimp.postprocess.aiProcess_FindDegenerates;\n    load_flags = load_flags | assimp.postprocess.aiProcess_GenSmoothNormals;\n    load_flags = load_flags | assimp.postprocess.aiProcess_JoinIdenticalVertices;\n    load_flags = load_flags | assimp.postprocess.aiProcess_ImproveCacheLocality;\n    load_flags = load_flags | assimp.postprocess.aiProcess_GenUVCoords;\n    load_flags = load_flags | assimp.postprocess.aiProcess_FindInvalidData;\n    return load_flags\n\n  def __init__(self, obj_file, material_file=None, load_materials=True,\n               name_prefix='', name_suffix=''):\n    if material_file is not None:\n      logging.error('Ignoring material file input, reading them off obj file.')\n    load_flags = self.get_pyassimp_load_options()\n    scene = assimp.load(obj_file, processing=load_flags)\n    filter_ind = self._filter_triangles(scene.meshes)\n    self.meshes = [scene.meshes[i] for i in filter_ind]\n    for m in self.meshes:\n      m.name = name_prefix + m.name + name_suffix\n\n    dir_name = os.path.dirname(obj_file)\n     Load materials\n    materials = None\n    if load_materials:\n      materials = []\n      for m in self.meshes:\n        file_name = os.path.join(dir_name, m.material.properties[('file', 1)])\n        assert(os.path.exists(file_name)), \\\n            'Texture file {:s} foes not exist.'.format(file_name)\n        img_rgb = cv2.imread(file_name)[::-1,:,::-1]\n        if img_rgb.shape[0] != img_rgb.shape[1]:\n          logging.warn('Texture image not square.')\n          sz = np.maximum(img_rgb.shape[0], img_rgb.shape[1])\n          sz = int(np.power(2., np.ceil(np.log2(sz))))\n          img_rgb = cv2.resize(img_rgb, (sz,sz), interpolation=cv2.INTER_LINEAR)\n        else:\n          sz = img_rgb.shape[0]\n          sz_ = int(np.power(2., np.ceil(np.log2(sz))))\n          if sz != sz_:\n            logging.warn('Texture image not square of power of 2 size. ' +\n                         'Changing size from %d to %d.', sz, sz_)\n            sz = sz_\n            img_rgb = cv2.resize(img_rgb, (sz,sz), interpolation=cv2.INTER_LINEAR)\n        materials.append(img_rgb)\n    self.scene = scene\n    self.materials = materials\n\n  def _filter_triangles(self, meshes):\n    select = []\n    for i in range(len(meshes)):\n      if meshes[i].primitivetypes == 4:\n        select.append(i)\n    return select\n\n  def flip_shape(self):\n    for m in self.meshes:\n      m.vertices[:,1] = -m.vertices[:,1]\n      bb = m.faces*1\n      bb[:,1] = m.faces[:,2]\n      bb[:,2] = m.faces[:,1]\n      m.faces = bb\n       m.vertices[:,[0,1]] = m.vertices[:,[1,0]]\n\n  def get_vertices(self):\n    vs = []\n    for m in self.meshes:\n      vs.append(m.vertices)\n    vss = np.concatenate(vs, axis=0)\n    return vss, vs\n\n  def get_faces(self):\n    vs = []\n    for m in self.meshes:\n      v = m.faces\n      vs.append(v)\n    return vs\n\n  def get_number_of_meshes(self):\n    return len(self.meshes)\n\n  def scale(self, sx=1., sy=1., sz=1.):\n    pass\n\n  def sample_points_on_face_of_shape(self, i, n_samples_per_face, sc):\n    v = self.meshes[i].vertices*sc\n    f = self.meshes[i].faces\n    p, face_areas, face_idx = sample_points_on_faces(\n        v, f, np.random.RandomState(0), n_samples_per_face)\n    return p, face_areas, face_idx\n  \n  def __del__(self):\n    scene = self.scene\n    assimp.release(scene)\n\nclass SwiftshaderRenderer():\n  def __init__(self):\n    self.entities = {}\n\n  def init_display(self, width, height, fov, z_near, z_far, rgb_shader,\n                   d_shader):\n    self.init_renderer_egl(width, height)\n    dir_path = os.path.dirname(os.path.realpath(__file__))\n    if d_shader is not None and rgb_shader is not None:\n      logging.fatal('Does not support setting both rgb_shader and d_shader.')\n    \n    if d_shader is not None:\n      assert rgb_shader is None\n      shader = d_shader\n      self.modality = 'depth'\n    \n    if rgb_shader is not None:\n      assert d_shader is None\n      shader = rgb_shader\n      self.modality = 'rgb'\n    \n    self.create_shaders(os.path.join(dir_path, shader+'.vp'),\n                        os.path.join(dir_path, shader + '.fp'))\n    aspect = width*1./(height*1.)\n    self.set_camera(fov, z_near, z_far, aspect)\n\n  def init_renderer_egl(self, width, height):\n    major,minor = ctypes.c_long(),ctypes.c_long()\n    logging.info('init_renderer_egl: EGL_DEFAULT_DISPLAY: %s', EGL_DEFAULT_DISPLAY)\n\n    egl_display = eglGetDisplay(EGL_DEFAULT_DISPLAY)\n    logging.info('init_renderer_egl: egl_display: %s', egl_display)\n\n    eglInitialize(egl_display, major, minor)\n    logging.info('init_renderer_egl: EGL_OPENGL_API, EGL_OPENGL_ES_API: %s, %s',\n                 EGL_OPENGL_API, EGL_OPENGL_ES_API)\n    eglBindAPI(EGL_OPENGL_ES_API)\n\n    num_configs = ctypes.c_long()\n    configs = (EGLConfig*1)()\n    local_attributes = [EGL_RED_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_BLUE_SIZE, 8,\n                        EGL_DEPTH_SIZE, 16, EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,\n                        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT, EGL_NONE,]\n    logging.error('init_renderer_egl: local attributes: %s', local_attributes)\n    local_attributes = arrays.GLintArray.asArray(local_attributes)\n    success = eglChooseConfig(egl_display, local_attributes, configs, 1, num_configs)\n    logging.error('init_renderer_egl: eglChooseConfig success, num_configs: %d, %d', success, num_configs.value)\n    egl_config = configs[0]\n\n\n    context_attributes = [EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE]\n    context_attributes = arrays.GLintArray.asArray(context_attributes)\n    egl_context = eglCreateContext(egl_display, egl_config, EGL_NO_CONTEXT, context_attributes)\n\n    buffer_attributes = [EGL_WIDTH, width, EGL_HEIGHT, height, EGL_NONE]\n    buffer_attributes = arrays.GLintArray.asArray(buffer_attributes)\n    egl_surface = eglCreatePbufferSurface(egl_display, egl_config, buffer_attributes)\n\n\n    eglMakeCurrent(egl_display, egl_surface, egl_surface, egl_context)\n    logging.error(\"init_renderer_egl: egl_display: %s egl_surface: %s, egl_config: %s\", egl_display, egl_surface, egl_context)\n\n    glViewport(0, 0, width, height);\n\n    self.egl_display = egl_display\n    self.egl_surface = egl_surface\n    self.egl_config =  egl_config\n    self.egl_mapping = {}\n    self.render_timer = None\n    self.load_timer = None\n    self.height = height\n    self.width = width\n\n  def create_shaders(self, v_shader_file, f_shader_file):\n    v_shader = glCreateShader(GL_VERTEX_SHADER)\n    with open(v_shader_file, 'r') as f:\n      ls = ''\n      for l in f:\n        ls = ls + l\n    glShaderSource(v_shader, ls)\n    glCompileShader(v_shader);\n    assert(glGetShaderiv(v_shader, GL_COMPILE_STATUS) == 1)\n\n    f_shader = glCreateShader(GL_FRAGMENT_SHADER)\n    with open(f_shader_file, 'r') as f:\n      ls = ''\n      for l in f:\n        ls = ls + l\n    glShaderSource(f_shader, ls)\n    glCompileShader(f_shader);\n    assert(glGetShaderiv(f_shader, GL_COMPILE_STATUS) == 1)\n\n    egl_program = glCreateProgram();\n    assert(egl_program)\n    glAttachShader(egl_program, v_shader)\n    glAttachShader(egl_program, f_shader)\n    glLinkProgram(egl_program);\n    assert(glGetProgramiv(egl_program, GL_LINK_STATUS) == 1)\n    glUseProgram(egl_program)\n\n    glBindAttribLocation(egl_program, 0, \"aPosition\")\n    glBindAttribLocation(egl_program, 1, \"aColor\")\n    glBindAttribLocation(egl_program, 2, \"aTextureCoord\")\n\n    self.egl_program = egl_program\n    self.egl_mapping['vertexs'] = 0\n    self.egl_mapping['vertexs_color'] = 1\n    self.egl_mapping['vertexs_tc'] = 2\n    \n    glClearColor(0.0, 0.0, 0.0, 1.0);\n     glEnable(GL_CULL_FACE); glCullFace(GL_BACK);\n    glEnable(GL_DEPTH_TEST);\n    \n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n\n  def set_camera(self, fov_vertical, z_near, z_far, aspect):\n    width = 2*np.tan(np.deg2rad(fov_vertical)/2.0)*z_near*aspect;\n    height = 2*np.tan(np.deg2rad(fov_vertical)/2.0)*z_near;\n    egl_program = self.egl_program\n    c = np.eye(4, dtype=np.float32)\n    c[3,3] = 0\n    c[3,2] = -1\n    c[2,2] = -(z_near+z_far)/(z_far-z_near)\n    c[2,3] = -2.0*(z_near*z_far)/(z_far-z_near)\n    c[0,0] = 2.0*z_near/width\n    c[1,1] = 2.0*z_near/height\n    c = c.T\n    \n    projection_matrix_o = glGetUniformLocation(egl_program, 'uProjectionMatrix')\n    projection_matrix = np.eye(4, dtype=np.float32)\n    projection_matrix[...] = c\n    projection_matrix = np.reshape(projection_matrix, (-1))\n    glUniformMatrix4fv(projection_matrix_o, 1, GL_FALSE, projection_matrix)\n    \n\n  def load_default_object(self):\n    v = np.array([[0.0, 0.5, 0.0, 1.0, 1.0, 0.0, 1.0],\n                  [-0.5, -0.5, 0.0, 1.0, 0.0, 1.0, 1.0],\n                  [0.5, -0.5, 0.0, 1.0, 1.0, 1.0, 1.0]], dtype=np.float32)\n    v = np.concatenate((v,v+0.1), axis=0)\n    v = np.ascontiguousarray(v, dtype=np.float32)\n\n    vbo = glGenBuffers(1)\n    glBindBuffer (GL_ARRAY_BUFFER, vbo)\n    glBufferData (GL_ARRAY_BUFFER, v.dtype.itemsize*v.size, v, GL_STATIC_DRAW)\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 28, ctypes.c_void_p(0))\n    glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 28, ctypes.c_void_p(12))\n    glEnableVertexAttribArray(0);\n    glEnableVertexAttribArray(1);\n\n    self.num_to_render = 6;\n\n  def _actual_render(self):\n    for entity_id, entity in self.entities.iteritems():\n      if entity['visible']:\n        vbo = entity['vbo']\n        tbo = entity['tbo']\n        num = entity['num']\n\n        glBindBuffer(GL_ARRAY_BUFFER, vbo)\n        glVertexAttribPointer(self.egl_mapping['vertexs'], 3, GL_FLOAT, GL_FALSE,\n                              20, ctypes.c_void_p(0))\n        glVertexAttribPointer(self.egl_mapping['vertexs_tc'], 2, GL_FLOAT,\n                              GL_FALSE, 20, ctypes.c_void_p(12))\n        glEnableVertexAttribArray(self.egl_mapping['vertexs']);\n        glEnableVertexAttribArray(self.egl_mapping['vertexs_tc']);\n\n        glBindTexture(GL_TEXTURE_2D, tbo)\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n        glDrawArrays(GL_TRIANGLES, 0, num)\n\n  def render(self, take_screenshot=False, output_type=0):\n     self.render_timer.tic()\n    self._actual_render()\n     self.render_timer.toc(log_at=1000, log_str='render timer', type='time')\n\n    np_rgb_img = None\n    np_d_img = None\n    c = 1000.\n    if take_screenshot:\n      if self.modality == 'rgb':\n        screenshot_rgba = np.zeros((self.height, self.width, 4), dtype=np.uint8)\n        glReadPixels(0, 0, self.width, self.height, GL_RGBA, GL_UNSIGNED_BYTE, screenshot_rgba)\n        np_rgb_img = screenshot_rgba[::-1,:,:3];\n\n      if self.modality == 'depth': \n        screenshot_d = np.zeros((self.height, self.width, 4), dtype=np.uint8)\n        glReadPixels(0, 0, self.width, self.height, GL_RGBA, GL_UNSIGNED_BYTE, screenshot_d)\n        np_d_img = screenshot_d[::-1,:,:3];\n        np_d_img = np_d_img[:,:,2]*(255.*255./c) + np_d_img[:,:,1]*(255./c) + np_d_img[:,:,0]*(1./c)\n        np_d_img = np_d_img.astype(np.float32)\n        np_d_img[np_d_img == 0] = np.NaN\n        np_d_img = np_d_img[:,:,np.newaxis]\n\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n    return np_rgb_img, np_d_img\n\n  def _load_mesh_into_gl(self, mesh, material):\n    vvt = np.concatenate((mesh.vertices, mesh.texturecoords[0,:,:2]), axis=1)\n    vvt = np.ascontiguousarray(vvt[mesh.faces.reshape((-1)),:], dtype=np.float32)\n    num = vvt.shape[0]\n    vvt = np.reshape(vvt, (-1))\n\n    vbo = glGenBuffers(1)\n    glBindBuffer(GL_ARRAY_BUFFER, vbo)\n    glBufferData(GL_ARRAY_BUFFER, vvt.dtype.itemsize*vvt.size, vvt, GL_STATIC_DRAW)\n\n    tbo = glGenTextures(1)\n    glBindTexture(GL_TEXTURE_2D, tbo)\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, material.shape[1],\n                 material.shape[0], 0, GL_RGB, GL_UNSIGNED_BYTE,\n                 np.reshape(material, (-1)))\n    return num, vbo, tbo\n\n  def load_shapes(self, shapes):\n    entities = self.entities\n    entity_ids = []\n    for i, shape in enumerate(shapes):\n      for j in range(len(shape.meshes)):\n        name = shape.meshes[j].name\n        assert name not in entities, '{:s} entity already exists.'.format(name)\n        num, vbo, tbo = self._load_mesh_into_gl(shape.meshes[j], shape.materials[j])\n        entities[name] = {'num': num, 'vbo': vbo, 'tbo': tbo, 'visible': False}\n        entity_ids.append(name)\n    return entity_ids\n\n  def set_entity_visible(self, entity_ids, visibility):\n    for entity_id in entity_ids:\n      self.entities[entity_id]['visible'] = visibility\n\n  def position_camera(self, camera_xyz, lookat_xyz, up):\n    camera_xyz = np.array(camera_xyz)\n    lookat_xyz = np.array(lookat_xyz)\n    up = np.array(up)\n    lookat_to = lookat_xyz - camera_xyz\n    lookat_from = np.array([0, 1., 0.])\n    up_from = np.array([0, 0., 1.])\n    up_to = up * 1.\n     np.set_printoptions(precision=2, suppress=True)\n     print up_from, lookat_from, up_to, lookat_to\n    r = ru.rotate_camera_to_point_at(up_from, lookat_from, up_to, lookat_to)\n    R = np.eye(4, dtype=np.float32)\n    R[:3,:3] = r\n\n    t = np.eye(4, dtype=np.float32)\n    t[:3,3] = -camera_xyz\n\n    view_matrix = np.dot(R.T, t)\n    flip_yz = np.eye(4, dtype=np.float32)\n    flip_yz[1,1] = 0; flip_yz[2,2] = 0; flip_yz[1,2] = 1; flip_yz[2,1] = -1;\n    view_matrix = np.dot(flip_yz, view_matrix)\n    view_matrix = view_matrix.T\n     print np.concatenate((R, t, view_matrix), axis=1)\n    view_matrix = np.reshape(view_matrix, (-1))\n    view_matrix_o = glGetUniformLocation(self.egl_program, 'uViewMatrix')\n    glUniformMatrix4fv(view_matrix_o, 1, GL_FALSE, view_matrix)\n    return None, None camera_xyz, q\n\n  def clear_scene(self):\n    keys = self.entities.keys()\n    for entity_id in keys:\n      entity = self.entities.pop(entity_id, None)\n      vbo = entity['vbo']\n      tbo = entity['tbo']\n      num = entity['num']\n      glDeleteBuffers(1, [vbo])\n      glDeleteTextures(1, [tbo])\n\n  def __del__(self):\n    self.clear_scene()\n    eglMakeCurrent(self.egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT)\n    eglDestroySurface(self.egl_display, self.egl_surface)\n    eglTerminate(self.egl_display)\n", "comments": "   implements loading rendering meshes  contains 2 classes    shape  class exposes high level functions loading manipulating     shapes  this currently bound assimp     (https   github com assimp assimp)  if want interface different     library  reimplement class bindings mesh loading library     swiftshaderrenderer  class renders shapes  currently uses python     bindings opengl (egl)  bindings alternate renderer may implemented              copyright 2016 the tensorflow authors all rights reserved        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license           http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license                                                                                       load materials    vertices    0 1     vertices    1 0      glenable(gl cull face)  glcullface(gl back)     self render timer tic()    self render timer toc(log 1000  log str  render timer   type  time )    np set printoptions(precision 2  suppress true)    print  lookat   lookat    print np concatenate((r   view matrix)  axis 1)   camera xyz  q ", "content": "# Copyright 2016 The TensorFlow Authors All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\nr\"\"\"Implements loading and rendering of meshes. Contains 2 classes:\n  Shape: Class that exposes high level functions for loading and manipulating\n    shapes. This currently is bound to assimp\n    (https://github.com/assimp/assimp). If you want to interface to a different\n    library, reimplement this class with bindings to your mesh loading library.\n\n  SwiftshaderRenderer: Class that renders Shapes. Currently this uses python\n    bindings to OpenGL (EGL), bindings to an alternate renderer may be implemented\n    here. \n\"\"\"\n\nimport numpy as np, os\nimport cv2, ctypes, logging, os, numpy as np\nimport pyassimp as assimp\nfrom OpenGL.GLES2 import *\nfrom OpenGL.EGL import *\nimport src.rotation_utils as ru \n\n__version__ = 'swiftshader_renderer'\n\ndef get_shaders(modalities):\n  rgb_shader = 'rgb_flat_color' if 'rgb' in modalities else None\n  d_shader = 'depth_rgb_encoded' if 'depth' in modalities else None\n  return rgb_shader, d_shader\n\ndef sample_points_on_faces(vs, fs, rng, n_samples_per_face):\n  idx = np.repeat(np.arange(fs.shape[0]), n_samples_per_face)\n  \n  r = rng.rand(idx.size, 2)\n  r1 = r[:,:1]; r2 = r[:,1:]; sqrt_r1 = np.sqrt(r1);\n  \n  v1 = vs[fs[idx, 0], :]; v2 = vs[fs[idx, 1], :]; v3 = vs[fs[idx, 2], :];\n  pts = (1-sqrt_r1)*v1 + sqrt_r1*(1-r2)*v2 + sqrt_r1*r2*v3\n  \n  v1 = vs[fs[:,0], :]; v2 = vs[fs[:, 1], :]; v3 = vs[fs[:, 2], :];\n  ar = 0.5*np.sqrt(np.sum(np.cross(v1-v3, v2-v3)**2, 1))\n  \n  return pts, ar, idx\n\nclass Shape():\n  def get_pyassimp_load_options(self):\n    load_flags = assimp.postprocess.aiProcess_Triangulate;\n    load_flags = load_flags | assimp.postprocess.aiProcess_SortByPType;\n    load_flags = load_flags | assimp.postprocess.aiProcess_OptimizeMeshes;\n    load_flags = load_flags | assimp.postprocess.aiProcess_RemoveRedundantMaterials;\n    load_flags = load_flags | assimp.postprocess.aiProcess_FindDegenerates;\n    load_flags = load_flags | assimp.postprocess.aiProcess_GenSmoothNormals;\n    load_flags = load_flags | assimp.postprocess.aiProcess_JoinIdenticalVertices;\n    load_flags = load_flags | assimp.postprocess.aiProcess_ImproveCacheLocality;\n    load_flags = load_flags | assimp.postprocess.aiProcess_GenUVCoords;\n    load_flags = load_flags | assimp.postprocess.aiProcess_FindInvalidData;\n    return load_flags\n\n  def __init__(self, obj_file, material_file=None, load_materials=True,\n               name_prefix='', name_suffix=''):\n    if material_file is not None:\n      logging.error('Ignoring material file input, reading them off obj file.')\n    load_flags = self.get_pyassimp_load_options()\n    scene = assimp.load(obj_file, processing=load_flags)\n    filter_ind = self._filter_triangles(scene.meshes)\n    self.meshes = [scene.meshes[i] for i in filter_ind]\n    for m in self.meshes:\n      m.name = name_prefix + m.name + name_suffix\n\n    dir_name = os.path.dirname(obj_file)\n    # Load materials\n    materials = None\n    if load_materials:\n      materials = []\n      for m in self.meshes:\n        file_name = os.path.join(dir_name, m.material.properties[('file', 1)])\n        assert(os.path.exists(file_name)), \\\n            'Texture file {:s} foes not exist.'.format(file_name)\n        img_rgb = cv2.imread(file_name)[::-1,:,::-1]\n        if img_rgb.shape[0] != img_rgb.shape[1]:\n          logging.warn('Texture image not square.')\n          sz = np.maximum(img_rgb.shape[0], img_rgb.shape[1])\n          sz = int(np.power(2., np.ceil(np.log2(sz))))\n          img_rgb = cv2.resize(img_rgb, (sz,sz), interpolation=cv2.INTER_LINEAR)\n        else:\n          sz = img_rgb.shape[0]\n          sz_ = int(np.power(2., np.ceil(np.log2(sz))))\n          if sz != sz_:\n            logging.warn('Texture image not square of power of 2 size. ' +\n                         'Changing size from %d to %d.', sz, sz_)\n            sz = sz_\n            img_rgb = cv2.resize(img_rgb, (sz,sz), interpolation=cv2.INTER_LINEAR)\n        materials.append(img_rgb)\n    self.scene = scene\n    self.materials = materials\n\n  def _filter_triangles(self, meshes):\n    select = []\n    for i in range(len(meshes)):\n      if meshes[i].primitivetypes == 4:\n        select.append(i)\n    return select\n\n  def flip_shape(self):\n    for m in self.meshes:\n      m.vertices[:,1] = -m.vertices[:,1]\n      bb = m.faces*1\n      bb[:,1] = m.faces[:,2]\n      bb[:,2] = m.faces[:,1]\n      m.faces = bb\n      # m.vertices[:,[0,1]] = m.vertices[:,[1,0]]\n\n  def get_vertices(self):\n    vs = []\n    for m in self.meshes:\n      vs.append(m.vertices)\n    vss = np.concatenate(vs, axis=0)\n    return vss, vs\n\n  def get_faces(self):\n    vs = []\n    for m in self.meshes:\n      v = m.faces\n      vs.append(v)\n    return vs\n\n  def get_number_of_meshes(self):\n    return len(self.meshes)\n\n  def scale(self, sx=1., sy=1., sz=1.):\n    pass\n\n  def sample_points_on_face_of_shape(self, i, n_samples_per_face, sc):\n    v = self.meshes[i].vertices*sc\n    f = self.meshes[i].faces\n    p, face_areas, face_idx = sample_points_on_faces(\n        v, f, np.random.RandomState(0), n_samples_per_face)\n    return p, face_areas, face_idx\n  \n  def __del__(self):\n    scene = self.scene\n    assimp.release(scene)\n\nclass SwiftshaderRenderer():\n  def __init__(self):\n    self.entities = {}\n\n  def init_display(self, width, height, fov, z_near, z_far, rgb_shader,\n                   d_shader):\n    self.init_renderer_egl(width, height)\n    dir_path = os.path.dirname(os.path.realpath(__file__))\n    if d_shader is not None and rgb_shader is not None:\n      logging.fatal('Does not support setting both rgb_shader and d_shader.')\n    \n    if d_shader is not None:\n      assert rgb_shader is None\n      shader = d_shader\n      self.modality = 'depth'\n    \n    if rgb_shader is not None:\n      assert d_shader is None\n      shader = rgb_shader\n      self.modality = 'rgb'\n    \n    self.create_shaders(os.path.join(dir_path, shader+'.vp'),\n                        os.path.join(dir_path, shader + '.fp'))\n    aspect = width*1./(height*1.)\n    self.set_camera(fov, z_near, z_far, aspect)\n\n  def init_renderer_egl(self, width, height):\n    major,minor = ctypes.c_long(),ctypes.c_long()\n    logging.info('init_renderer_egl: EGL_DEFAULT_DISPLAY: %s', EGL_DEFAULT_DISPLAY)\n\n    egl_display = eglGetDisplay(EGL_DEFAULT_DISPLAY)\n    logging.info('init_renderer_egl: egl_display: %s', egl_display)\n\n    eglInitialize(egl_display, major, minor)\n    logging.info('init_renderer_egl: EGL_OPENGL_API, EGL_OPENGL_ES_API: %s, %s',\n                 EGL_OPENGL_API, EGL_OPENGL_ES_API)\n    eglBindAPI(EGL_OPENGL_ES_API)\n\n    num_configs = ctypes.c_long()\n    configs = (EGLConfig*1)()\n    local_attributes = [EGL_RED_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_BLUE_SIZE, 8,\n                        EGL_DEPTH_SIZE, 16, EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,\n                        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT, EGL_NONE,]\n    logging.error('init_renderer_egl: local attributes: %s', local_attributes)\n    local_attributes = arrays.GLintArray.asArray(local_attributes)\n    success = eglChooseConfig(egl_display, local_attributes, configs, 1, num_configs)\n    logging.error('init_renderer_egl: eglChooseConfig success, num_configs: %d, %d', success, num_configs.value)\n    egl_config = configs[0]\n\n\n    context_attributes = [EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE]\n    context_attributes = arrays.GLintArray.asArray(context_attributes)\n    egl_context = eglCreateContext(egl_display, egl_config, EGL_NO_CONTEXT, context_attributes)\n\n    buffer_attributes = [EGL_WIDTH, width, EGL_HEIGHT, height, EGL_NONE]\n    buffer_attributes = arrays.GLintArray.asArray(buffer_attributes)\n    egl_surface = eglCreatePbufferSurface(egl_display, egl_config, buffer_attributes)\n\n\n    eglMakeCurrent(egl_display, egl_surface, egl_surface, egl_context)\n    logging.error(\"init_renderer_egl: egl_display: %s egl_surface: %s, egl_config: %s\", egl_display, egl_surface, egl_context)\n\n    glViewport(0, 0, width, height);\n\n    self.egl_display = egl_display\n    self.egl_surface = egl_surface\n    self.egl_config =  egl_config\n    self.egl_mapping = {}\n    self.render_timer = None\n    self.load_timer = None\n    self.height = height\n    self.width = width\n\n  def create_shaders(self, v_shader_file, f_shader_file):\n    v_shader = glCreateShader(GL_VERTEX_SHADER)\n    with open(v_shader_file, 'r') as f:\n      ls = ''\n      for l in f:\n        ls = ls + l\n    glShaderSource(v_shader, ls)\n    glCompileShader(v_shader);\n    assert(glGetShaderiv(v_shader, GL_COMPILE_STATUS) == 1)\n\n    f_shader = glCreateShader(GL_FRAGMENT_SHADER)\n    with open(f_shader_file, 'r') as f:\n      ls = ''\n      for l in f:\n        ls = ls + l\n    glShaderSource(f_shader, ls)\n    glCompileShader(f_shader);\n    assert(glGetShaderiv(f_shader, GL_COMPILE_STATUS) == 1)\n\n    egl_program = glCreateProgram();\n    assert(egl_program)\n    glAttachShader(egl_program, v_shader)\n    glAttachShader(egl_program, f_shader)\n    glLinkProgram(egl_program);\n    assert(glGetProgramiv(egl_program, GL_LINK_STATUS) == 1)\n    glUseProgram(egl_program)\n\n    glBindAttribLocation(egl_program, 0, \"aPosition\")\n    glBindAttribLocation(egl_program, 1, \"aColor\")\n    glBindAttribLocation(egl_program, 2, \"aTextureCoord\")\n\n    self.egl_program = egl_program\n    self.egl_mapping['vertexs'] = 0\n    self.egl_mapping['vertexs_color'] = 1\n    self.egl_mapping['vertexs_tc'] = 2\n    \n    glClearColor(0.0, 0.0, 0.0, 1.0);\n    # glEnable(GL_CULL_FACE); glCullFace(GL_BACK);\n    glEnable(GL_DEPTH_TEST);\n    \n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n\n  def set_camera(self, fov_vertical, z_near, z_far, aspect):\n    width = 2*np.tan(np.deg2rad(fov_vertical)/2.0)*z_near*aspect;\n    height = 2*np.tan(np.deg2rad(fov_vertical)/2.0)*z_near;\n    egl_program = self.egl_program\n    c = np.eye(4, dtype=np.float32)\n    c[3,3] = 0\n    c[3,2] = -1\n    c[2,2] = -(z_near+z_far)/(z_far-z_near)\n    c[2,3] = -2.0*(z_near*z_far)/(z_far-z_near)\n    c[0,0] = 2.0*z_near/width\n    c[1,1] = 2.0*z_near/height\n    c = c.T\n    \n    projection_matrix_o = glGetUniformLocation(egl_program, 'uProjectionMatrix')\n    projection_matrix = np.eye(4, dtype=np.float32)\n    projection_matrix[...] = c\n    projection_matrix = np.reshape(projection_matrix, (-1))\n    glUniformMatrix4fv(projection_matrix_o, 1, GL_FALSE, projection_matrix)\n    \n\n  def load_default_object(self):\n    v = np.array([[0.0, 0.5, 0.0, 1.0, 1.0, 0.0, 1.0],\n                  [-0.5, -0.5, 0.0, 1.0, 0.0, 1.0, 1.0],\n                  [0.5, -0.5, 0.0, 1.0, 1.0, 1.0, 1.0]], dtype=np.float32)\n    v = np.concatenate((v,v+0.1), axis=0)\n    v = np.ascontiguousarray(v, dtype=np.float32)\n\n    vbo = glGenBuffers(1)\n    glBindBuffer (GL_ARRAY_BUFFER, vbo)\n    glBufferData (GL_ARRAY_BUFFER, v.dtype.itemsize*v.size, v, GL_STATIC_DRAW)\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 28, ctypes.c_void_p(0))\n    glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 28, ctypes.c_void_p(12))\n    glEnableVertexAttribArray(0);\n    glEnableVertexAttribArray(1);\n\n    self.num_to_render = 6;\n\n  def _actual_render(self):\n    for entity_id, entity in self.entities.iteritems():\n      if entity['visible']:\n        vbo = entity['vbo']\n        tbo = entity['tbo']\n        num = entity['num']\n\n        glBindBuffer(GL_ARRAY_BUFFER, vbo)\n        glVertexAttribPointer(self.egl_mapping['vertexs'], 3, GL_FLOAT, GL_FALSE,\n                              20, ctypes.c_void_p(0))\n        glVertexAttribPointer(self.egl_mapping['vertexs_tc'], 2, GL_FLOAT,\n                              GL_FALSE, 20, ctypes.c_void_p(12))\n        glEnableVertexAttribArray(self.egl_mapping['vertexs']);\n        glEnableVertexAttribArray(self.egl_mapping['vertexs_tc']);\n\n        glBindTexture(GL_TEXTURE_2D, tbo)\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n        glDrawArrays(GL_TRIANGLES, 0, num)\n\n  def render(self, take_screenshot=False, output_type=0):\n    # self.render_timer.tic()\n    self._actual_render()\n    # self.render_timer.toc(log_at=1000, log_str='render timer', type='time')\n\n    np_rgb_img = None\n    np_d_img = None\n    c = 1000.\n    if take_screenshot:\n      if self.modality == 'rgb':\n        screenshot_rgba = np.zeros((self.height, self.width, 4), dtype=np.uint8)\n        glReadPixels(0, 0, self.width, self.height, GL_RGBA, GL_UNSIGNED_BYTE, screenshot_rgba)\n        np_rgb_img = screenshot_rgba[::-1,:,:3];\n\n      if self.modality == 'depth': \n        screenshot_d = np.zeros((self.height, self.width, 4), dtype=np.uint8)\n        glReadPixels(0, 0, self.width, self.height, GL_RGBA, GL_UNSIGNED_BYTE, screenshot_d)\n        np_d_img = screenshot_d[::-1,:,:3];\n        np_d_img = np_d_img[:,:,2]*(255.*255./c) + np_d_img[:,:,1]*(255./c) + np_d_img[:,:,0]*(1./c)\n        np_d_img = np_d_img.astype(np.float32)\n        np_d_img[np_d_img == 0] = np.NaN\n        np_d_img = np_d_img[:,:,np.newaxis]\n\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n    return np_rgb_img, np_d_img\n\n  def _load_mesh_into_gl(self, mesh, material):\n    vvt = np.concatenate((mesh.vertices, mesh.texturecoords[0,:,:2]), axis=1)\n    vvt = np.ascontiguousarray(vvt[mesh.faces.reshape((-1)),:], dtype=np.float32)\n    num = vvt.shape[0]\n    vvt = np.reshape(vvt, (-1))\n\n    vbo = glGenBuffers(1)\n    glBindBuffer(GL_ARRAY_BUFFER, vbo)\n    glBufferData(GL_ARRAY_BUFFER, vvt.dtype.itemsize*vvt.size, vvt, GL_STATIC_DRAW)\n\n    tbo = glGenTextures(1)\n    glBindTexture(GL_TEXTURE_2D, tbo)\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, material.shape[1],\n                 material.shape[0], 0, GL_RGB, GL_UNSIGNED_BYTE,\n                 np.reshape(material, (-1)))\n    return num, vbo, tbo\n\n  def load_shapes(self, shapes):\n    entities = self.entities\n    entity_ids = []\n    for i, shape in enumerate(shapes):\n      for j in range(len(shape.meshes)):\n        name = shape.meshes[j].name\n        assert name not in entities, '{:s} entity already exists.'.format(name)\n        num, vbo, tbo = self._load_mesh_into_gl(shape.meshes[j], shape.materials[j])\n        entities[name] = {'num': num, 'vbo': vbo, 'tbo': tbo, 'visible': False}\n        entity_ids.append(name)\n    return entity_ids\n\n  def set_entity_visible(self, entity_ids, visibility):\n    for entity_id in entity_ids:\n      self.entities[entity_id]['visible'] = visibility\n\n  def position_camera(self, camera_xyz, lookat_xyz, up):\n    camera_xyz = np.array(camera_xyz)\n    lookat_xyz = np.array(lookat_xyz)\n    up = np.array(up)\n    lookat_to = lookat_xyz - camera_xyz\n    lookat_from = np.array([0, 1., 0.])\n    up_from = np.array([0, 0., 1.])\n    up_to = up * 1.\n    # np.set_printoptions(precision=2, suppress=True)\n    # print up_from, lookat_from, up_to, lookat_to\n    r = ru.rotate_camera_to_point_at(up_from, lookat_from, up_to, lookat_to)\n    R = np.eye(4, dtype=np.float32)\n    R[:3,:3] = r\n\n    t = np.eye(4, dtype=np.float32)\n    t[:3,3] = -camera_xyz\n\n    view_matrix = np.dot(R.T, t)\n    flip_yz = np.eye(4, dtype=np.float32)\n    flip_yz[1,1] = 0; flip_yz[2,2] = 0; flip_yz[1,2] = 1; flip_yz[2,1] = -1;\n    view_matrix = np.dot(flip_yz, view_matrix)\n    view_matrix = view_matrix.T\n    # print np.concatenate((R, t, view_matrix), axis=1)\n    view_matrix = np.reshape(view_matrix, (-1))\n    view_matrix_o = glGetUniformLocation(self.egl_program, 'uViewMatrix')\n    glUniformMatrix4fv(view_matrix_o, 1, GL_FALSE, view_matrix)\n    return None, None #camera_xyz, q\n\n  def clear_scene(self):\n    keys = self.entities.keys()\n    for entity_id in keys:\n      entity = self.entities.pop(entity_id, None)\n      vbo = entity['vbo']\n      tbo = entity['tbo']\n      num = entity['num']\n      glDeleteBuffers(1, [vbo])\n      glDeleteTextures(1, [tbo])\n\n  def __del__(self):\n    self.clear_scene()\n    eglMakeCurrent(self.egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT)\n    eglDestroySurface(self.egl_display, self.egl_surface)\n    eglTerminate(self.egl_display)\n", "description": "Models and examples built with TensorFlow", "file_name": "swiftshader_renderer.py", "id": "06a4999f97d1cf132d65ccbcccddfc1c", "language": "Python", "project_name": "models", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/tensorflow-models/tensorflow-models-086d914/research/cognitive_mapping_and_planning/render/swiftshader_renderer.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:59:19Z", "url": "https://github.com/tensorflow/models", "wiki": true}