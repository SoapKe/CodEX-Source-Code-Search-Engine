{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom collections import defaultdict\n\nfrom odoo import api, fields, models, tools, _\nfrom odoo.addons import decimal_precision as dp\nfrom odoo.addons.stock_landed_costs.models import product\nfrom odoo.exceptions import UserError\n\n\nclass StockMove(models.Model):\n    _inherit = 'stock.move'\n\n    landed_cost_value = fields.Float('Landed Cost')\n\n\nclass LandedCost(models.Model):\n    _name = 'stock.landed.cost'\n    _description = 'Stock Landed Cost'\n    _inherit = 'mail.thread'\n\n    name = fields.Char(\n        'Name', default=lambda self: _('New'),\n        copy=False, readonly=True, track_visibility='always')\n    date = fields.Date(\n        'Date', default=fields.Date.context_today,\n        copy=False, required=True, states={'done': [('readonly', True)]}, track_visibility='onchange')\n    picking_ids = fields.Many2many(\n        'stock.picking', string='Pickings',\n        copy=False, states={'done': [('readonly', True)]})\n    cost_lines = fields.One2many(\n        'stock.landed.cost.lines', 'cost_id', 'Cost Lines',\n        copy=True, states={'done': [('readonly', True)]})\n    valuation_adjustment_lines = fields.One2many(\n        'stock.valuation.adjustment.lines', 'cost_id', 'Valuation Adjustments',\n        states={'done': [('readonly', True)]})\n    description = fields.Text(\n        'Item Description', states={'done': [('readonly', True)]})\n    amount_total = fields.Float(\n        'Total', compute='_compute_total_amount',\n        digits=0, store=True, track_visibility='always')\n    state = fields.Selection([\n        ('draft', 'Draft'),\n        ('done', 'Posted'),\n        ('cancel', 'Cancelled')], 'State', default='draft',\n        copy=False, readonly=True, track_visibility='onchange')\n    account_move_id = fields.Many2one(\n        'account.move', 'Journal Entry',\n        copy=False, readonly=True)\n    account_journal_id = fields.Many2one(\n        'account.journal', 'Account Journal',\n        required=True, states={'done': [('readonly', True)]})\n\n    @api.one\n    @api.depends('cost_lines.price_unit')\n    def _compute_total_amount(self):\n        self.amount_total = sum(line.price_unit for line in self.cost_lines)\n\n    @api.model\n    def create(self, vals):\n        if vals.get('name', _('New')) == _('New'):\n            vals['name'] = self.env['ir.sequence'].next_by_code('stock.landed.cost')\n        return super(LandedCost, self).create(vals)\n\n    @api.multi\n    def unlink(self):\n        self.button_cancel()\n        return super(LandedCost, self).unlink()\n\n    @api.multi\n    def _track_subtype(self, init_values):\n        if 'state' in init_values and self.state == 'done':\n            return 'stock_landed_costs.mt_stock_landed_cost_open'\n        return super(LandedCost, self)._track_subtype(init_values)\n\n    @api.multi\n    def button_cancel(self):\n        if any(cost.state == 'done' for cost in self):\n            raise UserError(\n                _('Validated landed costs cannot be cancelled, but you could create negative landed costs to reverse them'))\n        return self.write({'state': 'cancel'})\n\n    @api.multi\n    def button_validate(self):\n        if any(cost.state != 'draft' for cost in self):\n            raise UserError(_('Only draft landed costs can be validated'))\n        if any(not cost.valuation_adjustment_lines for cost in self):\n            raise UserError(_('No valuation adjustments lines. You should maybe recompute the landed costs.'))\n        if not self._check_sum():\n            raise UserError(_('Cost and adjustments lines do not match. You should maybe recompute the landed costs.'))\n\n        for cost in self:\n            move = self.env['account.move'].create({\n                'journal_id': cost.account_journal_id.id,\n                'date': cost.date,\n                'ref': cost.name\n            })\n            for line in cost.valuation_adjustment_lines.filtered(lambda line: line.move_id):\n                \n                cost_to_add = (line.move_id.remaining_qty / line.move_id.product_qty) * line.additional_landed_cost\n\n                new_landed_cost_value = line.move_id.landed_cost_value + line.additional_landed_cost\n                line.move_id.write({\n                    'landed_cost_value': new_landed_cost_value,\n                    'remaining_value': line.move_id.remaining_value + cost_to_add,\n                    'price_unit': (line.move_id.value + new_landed_cost_value) / line.move_id.product_qty,\n                })\n                \n                \n                qty_out = 0\n                if line.move_id._is_in():\n                    qty_out = line.move_id.product_qty - line.move_id.remaining_qty\n                elif line.move_id._is_out():\n                    qty_out = line.move_id.product_qty\n                line._create_accounting_entries(move, qty_out)\n                \n            move.assert_balanced()\n            cost.write({'state': 'done', 'account_move_id': move.id})\n            move.post()\n        return True\n\n    def _check_sum(self):\n        \"\"\" Check if each cost line its valuation lines sum to the correct amount\n        and if the overall total amount is correct also \"\"\"\n        prec_digits = self.env['decimal.precision'].precision_get('Account')\n        for landed_cost in self:\n            total_amount = sum(landed_cost.valuation_adjustment_lines.mapped('additional_landed_cost'))\n            if not tools.float_compare(total_amount, landed_cost.amount_total, precision_digits=prec_digits) == 0:\n                return False\n\n            val_to_cost_lines = defaultdict(lambda: 0.0)\n            for val_line in landed_cost.valuation_adjustment_lines:\n                val_to_cost_lines[val_line.cost_line_id] += val_line.additional_landed_cost\n            if any(tools.float_compare(cost_line.price_unit, val_amount, precision_digits=prec_digits) != 0\n                   for cost_line, val_amount in val_to_cost_lines.items()):\n                return False\n        return True\n\n    def get_valuation_lines(self):\n        lines = []\n\n        for move in self.mapped('picking_ids').mapped('move_lines'):\n            \n            if move.product_id.valuation != 'real_time' or move.product_id.cost_method != 'fifo':\n                continue\n            vals = {\n                'product_id': move.product_id.id,\n                'move_id': move.id,\n                'quantity': move.product_qty,\n                'former_cost': move.value,\n                'weight': move.product_id.weight * move.product_qty,\n                'volume': move.product_id.volume * move.product_qty\n            }\n            lines.append(vals)\n\n        if not lines and self.mapped('picking_ids'):\n            raise UserError(_('The selected picking does not contain any move that would be impacted by landed costs. Landed costs are only possible for products configured in real time valuation with real price costing method. Please make sure it is the case, or you selected the correct picking'))\n        return lines\n\n    @api.multi\n    def compute_landed_cost(self):\n        AdjustementLines = self.env['stock.valuation.adjustment.lines']\n        AdjustementLines.search([('cost_id', 'in', self.ids)]).unlink()\n\n        digits = dp.get_precision('Product Price')(self._cr)\n        towrite_dict = {}\n        for cost in self.filtered(lambda cost: cost.picking_ids):\n            total_qty = 0.0\n            total_cost = 0.0\n            total_weight = 0.0\n            total_volume = 0.0\n            total_line = 0.0\n            all_val_line_values = cost.get_valuation_lines()\n            for val_line_values in all_val_line_values:\n                for cost_line in cost.cost_lines:\n                    val_line_values.update({'cost_id': cost.id, 'cost_line_id': cost_line.id})\n                    self.env['stock.valuation.adjustment.lines'].create(val_line_values)\n                total_qty += val_line_values.get('quantity', 0.0)\n                total_weight += val_line_values.get('weight', 0.0)\n                total_volume += val_line_values.get('volume', 0.0)\n\n                former_cost = val_line_values.get('former_cost', 0.0)\n                \n                total_cost += tools.float_round(former_cost, precision_digits=digits[1]) if digits else former_cost\n\n                total_line += 1\n\n            for line in cost.cost_lines:\n                value_split = 0.0\n                for valuation in cost.valuation_adjustment_lines:\n                    value = 0.0\n                    if valuation.cost_line_id and valuation.cost_line_id.id == line.id:\n                        if line.split_method == 'by_quantity' and total_qty:\n                            per_unit = (line.price_unit / total_qty)\n                            value = valuation.quantity * per_unit\n                        elif line.split_method == 'by_weight' and total_weight:\n                            per_unit = (line.price_unit / total_weight)\n                            value = valuation.weight * per_unit\n                        elif line.split_method == 'by_volume' and total_volume:\n                            per_unit = (line.price_unit / total_volume)\n                            value = valuation.volume * per_unit\n                        elif line.split_method == 'equal':\n                            value = (line.price_unit / total_line)\n                        elif line.split_method == 'by_current_cost_price' and total_cost:\n                            per_unit = (line.price_unit / total_cost)\n                            value = valuation.former_cost * per_unit\n                        else:\n                            value = (line.price_unit / total_line)\n\n                        if digits:\n                            value = tools.float_round(value, precision_digits=digits[1], rounding_method='UP')\n                            fnc = min if line.price_unit > 0 else max\n                            value = fnc(value, line.price_unit - value_split)\n                            value_split += value\n\n                        if valuation.id not in towrite_dict:\n                            towrite_dict[valuation.id] = value\n                        else:\n                            towrite_dict[valuation.id] += value\n        for key, value in towrite_dict.items():\n            AdjustementLines.browse(key).write({'additional_landed_cost': value})\n        return True\n\n\nclass LandedCostLine(models.Model):\n    _name = 'stock.landed.cost.lines'\n    _description = 'Stock Landed Cost Lines'\n\n    name = fields.Char('Description')\n    cost_id = fields.Many2one(\n        'stock.landed.cost', 'Landed Cost',\n        required=True, ondelete='cascade')\n    product_id = fields.Many2one('product.product', 'Product', required=True)\n    price_unit = fields.Float('Cost', digits=dp.get_precision('Product Price'), required=True)\n    split_method = fields.Selection(product.SPLIT_METHOD, string='Split Method', required=True)\n    account_id = fields.Many2one('account.account', 'Account', domain=[('deprecated', '=', False)])\n\n    @api.onchange('product_id')\n    def onchange_product_id(self):\n        if not self.product_id:\n            self.quantity = 0.0\n        self.name = self.product_id.name or ''\n        self.split_method = self.product_id.split_method or 'equal'\n        self.price_unit = self.product_id.standard_price or 0.0\n        self.account_id = self.product_id.property_account_expense_id.id or self.product_id.categ_id.property_account_expense_categ_id.id\n\n\nclass AdjustmentLines(models.Model):\n    _name = 'stock.valuation.adjustment.lines'\n    _description = 'Stock Valuation Adjustment Lines'\n\n    name = fields.Char(\n        'Description', compute='_compute_name', store=True)\n    cost_id = fields.Many2one(\n        'stock.landed.cost', 'Landed Cost',\n        ondelete='cascade', required=True)\n    cost_line_id = fields.Many2one(\n        'stock.landed.cost.lines', 'Cost Line', readonly=True)\n    move_id = fields.Many2one('stock.move', 'Stock Move', readonly=True)\n    product_id = fields.Many2one('product.product', 'Product', required=True)\n    quantity = fields.Float(\n        'Quantity', default=1.0,\n        digits=dp.get_precision('Product Unit of Measure'), required=True)\n    weight = fields.Float(\n        'Weight', default=1.0,\n        digits=dp.get_precision('Product Unit of Measure'))\n    volume = fields.Float(\n        'Volume', default=1.0,\n        digits=dp.get_precision('Product Unit of Measure'))\n    former_cost = fields.Float(\n        'Former Cost', digits=dp.get_precision('Product Price'))\n    former_cost_per_unit = fields.Float(\n        'Former Cost(Per Unit)', compute='_compute_former_cost_per_unit',\n        digits=0, store=True)\n    additional_landed_cost = fields.Float(\n        'Additional Landed Cost',\n        digits=dp.get_precision('Product Price'))\n    final_cost = fields.Float(\n        'Final Cost', compute='_compute_final_cost',\n        digits=0, store=True)\n\n    @api.one\n    @api.depends('cost_line_id.name', 'product_id.code', 'product_id.name')\n    def _compute_name(self):\n        name = '%s - ' % (self.cost_line_id.name if self.cost_line_id else '')\n        self.name = name + (self.product_id.code or self.product_id.name or '')\n\n    @api.one\n    @api.depends('former_cost', 'quantity')\n    def _compute_former_cost_per_unit(self):\n        self.former_cost_per_unit = self.former_cost / (self.quantity or 1.0)\n\n    @api.one\n    @api.depends('former_cost', 'additional_landed_cost')\n    def _compute_final_cost(self):\n        self.final_cost = self.former_cost + self.additional_landed_cost\n\n    def _create_accounting_entries(self, move, qty_out):\n        ?\n        cost_product = self.cost_line_id.product_id\n        if not cost_product:\n            return False\n        accounts = self.product_id.product_tmpl_id.get_product_accounts()\n        debit_account_id = accounts.get('stock_valuation') and accounts['stock_valuation'].id or False\n        already_out_account_id = accounts['stock_output'].id\n        credit_account_id = self.cost_line_id.account_id.id or cost_product.property_account_expense_id.id or cost_product.categ_id.property_account_expense_categ_id.id\n\n        if not credit_account_id:\n            raise UserError(_('Please configure Stock Expense Account for product: %s.') % (cost_product.name))\n\n        return self._create_account_move_line(move, credit_account_id, debit_account_id, qty_out, already_out_account_id)\n\n    def _create_account_move_line(self, move, credit_account_id, debit_account_id, qty_out, already_out_account_id):\n        \"\"\"\n        Generate the account.move.line values to track the landed cost.\n        Afterwards, for the goods that are already out of stock, we should create the out moves\n        \"\"\"\n        AccountMoveLine = self.env['account.move.line'].with_context(check_move_validity=False, recompute=False)\n\n        base_line = {\n            'name': self.name,\n            'move_id': move.id,\n            'product_id': self.product_id.id,\n            'quantity': self.quantity,\n        }\n        debit_line = dict(base_line, account_id=debit_account_id)\n        credit_line = dict(base_line, account_id=credit_account_id)\n        diff = self.additional_landed_cost\n        if diff > 0:\n            debit_line['debit'] = diff\n            credit_line['credit'] = diff\n        else:\n            \n            debit_line['credit'] = -diff\n            credit_line['debit'] = -diff\n        AccountMoveLine.create(debit_line)\n        AccountMoveLine.create(credit_line)\n\n        \n        if qty_out > 0:\n            debit_line = dict(base_line,\n                              name=(self.name + \": \" + str(qty_out) + _(' already out')),\n                              quantity=qty_out,\n                              account_id=already_out_account_id)\n            credit_line = dict(base_line,\n                               name=(self.name + \": \" + str(qty_out) + _(' already out')),\n                               quantity=qty_out,\n                               account_id=debit_account_id)\n            diff = diff * qty_out / self.quantity\n            if diff > 0:\n                debit_line['debit'] = diff\n                credit_line['credit'] = diff\n            else:\n                \n                debit_line['credit'] = -diff\n                credit_line['debit'] = -diff\n            AccountMoveLine.create(debit_line)\n            AccountMoveLine.create(credit_line)\n\n            \n            if self.env.user.company_id.anglo_saxon_accounting:\n                debit_line = dict(base_line,\n                                  name=(self.name + \": \" + str(qty_out) + _(' already out')),\n                                  quantity=qty_out,\n                                  account_id=credit_account_id)\n                credit_line = dict(base_line,\n                                   name=(self.name + \": \" + str(qty_out) + _(' already out')),\n                                   quantity=qty_out,\n                                   account_id=already_out_account_id)\n\n                if diff > 0:\n                    debit_line['debit'] = diff\n                    credit_line['credit'] = diff\n                else:\n                    \n                    debit_line['credit'] = -diff\n                    credit_line['debit'] = -diff\n                AccountMoveLine.create(debit_line)\n                AccountMoveLine.create(credit_line)\n\n        return True\n", "comments": "    check cost line valuation lines sum correct amount         overall total amount correct also             prec digits   self env  decimal precision   precision get( account )         landed cost self              total amount   sum(landed cost valuation adjustment lines mapped( additional landed cost ))             tools float compare(total amount  landed cost amount total  precision digits prec digits)    0                  return false              val cost lines   defaultdict(lambda  0 0)             val line landed cost valuation adjustment lines                  val cost lines val line cost line id     val line additional landed cost             any(tools float compare(cost line price unit  val amount  precision digits prec digits)    0                    cost line  val amount val cost lines items())                  return false         return true      def get valuation lines(self)          lines               move self mapped( picking ids ) mapped( move lines )                make sense make landed cost product set valuated real time real cost             move product id valuation     real time  move product id cost method     fifo                   continue             vals                      product id   move product id id                   move id   move id                   quantity   move product qty                   former cost   move value                   weight   move product id weight   move product qty                   volume   move product id volume   move product qty                           lines append(vals)          lines self mapped( picking ids )              raise usererror( ( the selected picking contain move would impacted landed costs  landed costs possible products configured real time valuation real price costing method  please make sure case  selected correct picking ))         return lines       api multi     def compute landed cost(self)          adjustementlines   self env  stock valuation adjustment lines           adjustementlines search( ( cost id      self ids) ) unlink()          digits   dp get precision( product price )(self  cr)         towrite dict              cost self filtered(lambda cost  cost picking ids)              total qty   0 0             total cost   0 0             total weight   0 0             total volume   0 0             total line   0 0             val line values   cost get valuation lines()             val line values val line values                  cost line cost cost lines                      val line values update(  cost id   cost id   cost line id   cost line id )                     self env  stock valuation adjustment lines   create(val line values)                 total qty    val line values get( quantity   0 0)                 total weight    val line values get( weight   0 0)                 total volume    val line values get( volume   0 0)                  former cost   val line values get( former cost   0 0)                   round former cost valuation lines also rounded                 total cost    tools float round(former cost  precision digits digits 1 ) digits else former cost                  total line    1              line cost cost lines                  value split   0 0                 valuation cost valuation adjustment lines                      value   0 0                     valuation cost line id valuation cost line id id    line id                          line split method     quantity  total qty                              per unit   (line price unit   total qty)                             value   valuation quantity   per unit                         elif line split method     weight  total weight                              per unit   (line price unit   total weight)                             value   valuation weight   per unit                         elif line split method     volume  total volume                              per unit   (line price unit   total volume)                             value   valuation volume   per unit                         elif line split method     equal                               value   (line price unit   total line)                         elif line split method     current cost price  total cost                              per unit   (line price unit   total cost)                             value   valuation former cost   per unit                         else                              value   (line price unit   total line)                          digits                              value   tools float round(value  precision digits digits 1   rounding method  up )                             fnc   min line price unit   0 else max                             value   fnc(value  line price unit   value split)                             value split    value                          valuation id towrite dict                              towrite dict valuation id    value                         else                              towrite dict valuation id     value         key  value towrite dict items()              adjustementlines browse(key) write(  additional landed cost   value )         return true   class landedcostline(models model)       name    stock landed cost lines       description    stock landed cost lines       name   fields char( description )     cost id   fields many2one(          stock landed cost    landed cost           required true  ondelete  cascade )     product id   fields many2one( product product    product   required true)     price unit   fields float( cost   digits dp get precision( product price )  required true)     split method   fields selection(product split method  string  split method   required true)     account id   fields many2one( account account    account   domain  ( deprecated        false) )       api onchange( product id )     def onchange product id(self)          self product id              self quantity   0 0         self name   self product id name            self split method   self product id split method  equal          self price unit   self product id standard price 0 0         self account id   self product id property account expense id id self product id categ id property account expense categ id id   class adjustmentlines(models model)       name    stock valuation adjustment lines       description    stock valuation adjustment lines       name   fields char(          description   compute   compute name   store true)     cost id   fields many2one(          stock landed cost    landed cost           ondelete  cascade   required true)     cost line id   fields many2one(          stock landed cost lines    cost line   readonly true)     move id   fields many2one( stock move    stock move   readonly true)     product id   fields many2one( product product    product   required true)     quantity   fields float(          quantity   default 1 0          digits dp get precision( product unit measure )  required true)     weight   fields float(          weight   default 1 0          digits dp get precision( product unit measure ))     volume   fields float(          volume   default 1 0          digits dp get precision( product unit measure ))     former cost   fields float(          former cost   digits dp get precision( product price ))     former cost per unit   fields float(          former cost(per unit)   compute   compute former cost per unit           digits 0  store true)     additional landed cost   fields float(          additional landed cost           digits dp get precision( product price ))     final cost   fields float(          final cost   compute   compute final cost           digits 0  store true)       api one      api depends( cost line id name    product id code    product id name )     def  compute name(self)          name           (self cost line id name self cost line id else   )         self name   name   (self product id code self product id name   )       api one      api depends( former cost    quantity )     def  compute former cost per unit(self)          self former cost per unit   self former cost   (self quantity 1 0)       api one      api depends( former cost    additional landed cost )     def  compute final cost(self)          self final cost   self former cost   self additional landed cost      def  create accounting entries(self  move  qty out)            tde cleanme  product chosen computation           cost product   self cost line id product id         cost product              return false         accounts   self product id product tmpl id get product accounts()         debit account id   accounts get( stock valuation ) accounts  stock valuation   id false         already account id   accounts  stock output   id         credit account id   self cost line id account id id cost product property account expense id id cost product categ id property account expense categ id id          credit account id              raise usererror( ( please configure stock expense account product    )   (cost product name))          return self  create account move line(move  credit account id  debit account id  qty  already account id)      def  create account move line(self  move  credit account id  debit account id  qty  already account id)                      generate account move line values track landed cost          afterwards  goods already stock  create moves                    coding  utf 8        part odoo  see license file full copyright licensing details     prorate value still stock     remaining qty  negative move delivered proudcts    stock     make sense make landed cost product set valuated real time real cost    round former cost valuation lines also rounded    tde cleanme  product chosen computation      negative cost  reverse entry    create account move lines quants already stock    negative cost  reverse entry    tde fixme  oh dear    negative cost  reverse entry ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom collections import defaultdict\n\nfrom odoo import api, fields, models, tools, _\nfrom odoo.addons import decimal_precision as dp\nfrom odoo.addons.stock_landed_costs.models import product\nfrom odoo.exceptions import UserError\n\n\nclass StockMove(models.Model):\n    _inherit = 'stock.move'\n\n    landed_cost_value = fields.Float('Landed Cost')\n\n\nclass LandedCost(models.Model):\n    _name = 'stock.landed.cost'\n    _description = 'Stock Landed Cost'\n    _inherit = 'mail.thread'\n\n    name = fields.Char(\n        'Name', default=lambda self: _('New'),\n        copy=False, readonly=True, track_visibility='always')\n    date = fields.Date(\n        'Date', default=fields.Date.context_today,\n        copy=False, required=True, states={'done': [('readonly', True)]}, track_visibility='onchange')\n    picking_ids = fields.Many2many(\n        'stock.picking', string='Pickings',\n        copy=False, states={'done': [('readonly', True)]})\n    cost_lines = fields.One2many(\n        'stock.landed.cost.lines', 'cost_id', 'Cost Lines',\n        copy=True, states={'done': [('readonly', True)]})\n    valuation_adjustment_lines = fields.One2many(\n        'stock.valuation.adjustment.lines', 'cost_id', 'Valuation Adjustments',\n        states={'done': [('readonly', True)]})\n    description = fields.Text(\n        'Item Description', states={'done': [('readonly', True)]})\n    amount_total = fields.Float(\n        'Total', compute='_compute_total_amount',\n        digits=0, store=True, track_visibility='always')\n    state = fields.Selection([\n        ('draft', 'Draft'),\n        ('done', 'Posted'),\n        ('cancel', 'Cancelled')], 'State', default='draft',\n        copy=False, readonly=True, track_visibility='onchange')\n    account_move_id = fields.Many2one(\n        'account.move', 'Journal Entry',\n        copy=False, readonly=True)\n    account_journal_id = fields.Many2one(\n        'account.journal', 'Account Journal',\n        required=True, states={'done': [('readonly', True)]})\n\n    @api.one\n    @api.depends('cost_lines.price_unit')\n    def _compute_total_amount(self):\n        self.amount_total = sum(line.price_unit for line in self.cost_lines)\n\n    @api.model\n    def create(self, vals):\n        if vals.get('name', _('New')) == _('New'):\n            vals['name'] = self.env['ir.sequence'].next_by_code('stock.landed.cost')\n        return super(LandedCost, self).create(vals)\n\n    @api.multi\n    def unlink(self):\n        self.button_cancel()\n        return super(LandedCost, self).unlink()\n\n    @api.multi\n    def _track_subtype(self, init_values):\n        if 'state' in init_values and self.state == 'done':\n            return 'stock_landed_costs.mt_stock_landed_cost_open'\n        return super(LandedCost, self)._track_subtype(init_values)\n\n    @api.multi\n    def button_cancel(self):\n        if any(cost.state == 'done' for cost in self):\n            raise UserError(\n                _('Validated landed costs cannot be cancelled, but you could create negative landed costs to reverse them'))\n        return self.write({'state': 'cancel'})\n\n    @api.multi\n    def button_validate(self):\n        if any(cost.state != 'draft' for cost in self):\n            raise UserError(_('Only draft landed costs can be validated'))\n        if any(not cost.valuation_adjustment_lines for cost in self):\n            raise UserError(_('No valuation adjustments lines. You should maybe recompute the landed costs.'))\n        if not self._check_sum():\n            raise UserError(_('Cost and adjustments lines do not match. You should maybe recompute the landed costs.'))\n\n        for cost in self:\n            move = self.env['account.move'].create({\n                'journal_id': cost.account_journal_id.id,\n                'date': cost.date,\n                'ref': cost.name\n            })\n            for line in cost.valuation_adjustment_lines.filtered(lambda line: line.move_id):\n                # Prorate the value at what's still in stock\n                cost_to_add = (line.move_id.remaining_qty / line.move_id.product_qty) * line.additional_landed_cost\n\n                new_landed_cost_value = line.move_id.landed_cost_value + line.additional_landed_cost\n                line.move_id.write({\n                    'landed_cost_value': new_landed_cost_value,\n                    'remaining_value': line.move_id.remaining_value + cost_to_add,\n                    'price_unit': (line.move_id.value + new_landed_cost_value) / line.move_id.product_qty,\n                })\n                # `remaining_qty` is negative if the move is out and delivered proudcts that were not\n                # in stock.\n                qty_out = 0\n                if line.move_id._is_in():\n                    qty_out = line.move_id.product_qty - line.move_id.remaining_qty\n                elif line.move_id._is_out():\n                    qty_out = line.move_id.product_qty\n                line._create_accounting_entries(move, qty_out)\n                \n            move.assert_balanced()\n            cost.write({'state': 'done', 'account_move_id': move.id})\n            move.post()\n        return True\n\n    def _check_sum(self):\n        \"\"\" Check if each cost line its valuation lines sum to the correct amount\n        and if the overall total amount is correct also \"\"\"\n        prec_digits = self.env['decimal.precision'].precision_get('Account')\n        for landed_cost in self:\n            total_amount = sum(landed_cost.valuation_adjustment_lines.mapped('additional_landed_cost'))\n            if not tools.float_compare(total_amount, landed_cost.amount_total, precision_digits=prec_digits) == 0:\n                return False\n\n            val_to_cost_lines = defaultdict(lambda: 0.0)\n            for val_line in landed_cost.valuation_adjustment_lines:\n                val_to_cost_lines[val_line.cost_line_id] += val_line.additional_landed_cost\n            if any(tools.float_compare(cost_line.price_unit, val_amount, precision_digits=prec_digits) != 0\n                   for cost_line, val_amount in val_to_cost_lines.items()):\n                return False\n        return True\n\n    def get_valuation_lines(self):\n        lines = []\n\n        for move in self.mapped('picking_ids').mapped('move_lines'):\n            # it doesn't make sense to make a landed cost for a product that isn't set as being valuated in real time at real cost\n            if move.product_id.valuation != 'real_time' or move.product_id.cost_method != 'fifo':\n                continue\n            vals = {\n                'product_id': move.product_id.id,\n                'move_id': move.id,\n                'quantity': move.product_qty,\n                'former_cost': move.value,\n                'weight': move.product_id.weight * move.product_qty,\n                'volume': move.product_id.volume * move.product_qty\n            }\n            lines.append(vals)\n\n        if not lines and self.mapped('picking_ids'):\n            raise UserError(_('The selected picking does not contain any move that would be impacted by landed costs. Landed costs are only possible for products configured in real time valuation with real price costing method. Please make sure it is the case, or you selected the correct picking'))\n        return lines\n\n    @api.multi\n    def compute_landed_cost(self):\n        AdjustementLines = self.env['stock.valuation.adjustment.lines']\n        AdjustementLines.search([('cost_id', 'in', self.ids)]).unlink()\n\n        digits = dp.get_precision('Product Price')(self._cr)\n        towrite_dict = {}\n        for cost in self.filtered(lambda cost: cost.picking_ids):\n            total_qty = 0.0\n            total_cost = 0.0\n            total_weight = 0.0\n            total_volume = 0.0\n            total_line = 0.0\n            all_val_line_values = cost.get_valuation_lines()\n            for val_line_values in all_val_line_values:\n                for cost_line in cost.cost_lines:\n                    val_line_values.update({'cost_id': cost.id, 'cost_line_id': cost_line.id})\n                    self.env['stock.valuation.adjustment.lines'].create(val_line_values)\n                total_qty += val_line_values.get('quantity', 0.0)\n                total_weight += val_line_values.get('weight', 0.0)\n                total_volume += val_line_values.get('volume', 0.0)\n\n                former_cost = val_line_values.get('former_cost', 0.0)\n                # round this because former_cost on the valuation lines is also rounded\n                total_cost += tools.float_round(former_cost, precision_digits=digits[1]) if digits else former_cost\n\n                total_line += 1\n\n            for line in cost.cost_lines:\n                value_split = 0.0\n                for valuation in cost.valuation_adjustment_lines:\n                    value = 0.0\n                    if valuation.cost_line_id and valuation.cost_line_id.id == line.id:\n                        if line.split_method == 'by_quantity' and total_qty:\n                            per_unit = (line.price_unit / total_qty)\n                            value = valuation.quantity * per_unit\n                        elif line.split_method == 'by_weight' and total_weight:\n                            per_unit = (line.price_unit / total_weight)\n                            value = valuation.weight * per_unit\n                        elif line.split_method == 'by_volume' and total_volume:\n                            per_unit = (line.price_unit / total_volume)\n                            value = valuation.volume * per_unit\n                        elif line.split_method == 'equal':\n                            value = (line.price_unit / total_line)\n                        elif line.split_method == 'by_current_cost_price' and total_cost:\n                            per_unit = (line.price_unit / total_cost)\n                            value = valuation.former_cost * per_unit\n                        else:\n                            value = (line.price_unit / total_line)\n\n                        if digits:\n                            value = tools.float_round(value, precision_digits=digits[1], rounding_method='UP')\n                            fnc = min if line.price_unit > 0 else max\n                            value = fnc(value, line.price_unit - value_split)\n                            value_split += value\n\n                        if valuation.id not in towrite_dict:\n                            towrite_dict[valuation.id] = value\n                        else:\n                            towrite_dict[valuation.id] += value\n        for key, value in towrite_dict.items():\n            AdjustementLines.browse(key).write({'additional_landed_cost': value})\n        return True\n\n\nclass LandedCostLine(models.Model):\n    _name = 'stock.landed.cost.lines'\n    _description = 'Stock Landed Cost Lines'\n\n    name = fields.Char('Description')\n    cost_id = fields.Many2one(\n        'stock.landed.cost', 'Landed Cost',\n        required=True, ondelete='cascade')\n    product_id = fields.Many2one('product.product', 'Product', required=True)\n    price_unit = fields.Float('Cost', digits=dp.get_precision('Product Price'), required=True)\n    split_method = fields.Selection(product.SPLIT_METHOD, string='Split Method', required=True)\n    account_id = fields.Many2one('account.account', 'Account', domain=[('deprecated', '=', False)])\n\n    @api.onchange('product_id')\n    def onchange_product_id(self):\n        if not self.product_id:\n            self.quantity = 0.0\n        self.name = self.product_id.name or ''\n        self.split_method = self.product_id.split_method or 'equal'\n        self.price_unit = self.product_id.standard_price or 0.0\n        self.account_id = self.product_id.property_account_expense_id.id or self.product_id.categ_id.property_account_expense_categ_id.id\n\n\nclass AdjustmentLines(models.Model):\n    _name = 'stock.valuation.adjustment.lines'\n    _description = 'Stock Valuation Adjustment Lines'\n\n    name = fields.Char(\n        'Description', compute='_compute_name', store=True)\n    cost_id = fields.Many2one(\n        'stock.landed.cost', 'Landed Cost',\n        ondelete='cascade', required=True)\n    cost_line_id = fields.Many2one(\n        'stock.landed.cost.lines', 'Cost Line', readonly=True)\n    move_id = fields.Many2one('stock.move', 'Stock Move', readonly=True)\n    product_id = fields.Many2one('product.product', 'Product', required=True)\n    quantity = fields.Float(\n        'Quantity', default=1.0,\n        digits=dp.get_precision('Product Unit of Measure'), required=True)\n    weight = fields.Float(\n        'Weight', default=1.0,\n        digits=dp.get_precision('Product Unit of Measure'))\n    volume = fields.Float(\n        'Volume', default=1.0,\n        digits=dp.get_precision('Product Unit of Measure'))\n    former_cost = fields.Float(\n        'Former Cost', digits=dp.get_precision('Product Price'))\n    former_cost_per_unit = fields.Float(\n        'Former Cost(Per Unit)', compute='_compute_former_cost_per_unit',\n        digits=0, store=True)\n    additional_landed_cost = fields.Float(\n        'Additional Landed Cost',\n        digits=dp.get_precision('Product Price'))\n    final_cost = fields.Float(\n        'Final Cost', compute='_compute_final_cost',\n        digits=0, store=True)\n\n    @api.one\n    @api.depends('cost_line_id.name', 'product_id.code', 'product_id.name')\n    def _compute_name(self):\n        name = '%s - ' % (self.cost_line_id.name if self.cost_line_id else '')\n        self.name = name + (self.product_id.code or self.product_id.name or '')\n\n    @api.one\n    @api.depends('former_cost', 'quantity')\n    def _compute_former_cost_per_unit(self):\n        self.former_cost_per_unit = self.former_cost / (self.quantity or 1.0)\n\n    @api.one\n    @api.depends('former_cost', 'additional_landed_cost')\n    def _compute_final_cost(self):\n        self.final_cost = self.former_cost + self.additional_landed_cost\n\n    def _create_accounting_entries(self, move, qty_out):\n        # TDE CLEANME: product chosen for computation ?\n        cost_product = self.cost_line_id.product_id\n        if not cost_product:\n            return False\n        accounts = self.product_id.product_tmpl_id.get_product_accounts()\n        debit_account_id = accounts.get('stock_valuation') and accounts['stock_valuation'].id or False\n        already_out_account_id = accounts['stock_output'].id\n        credit_account_id = self.cost_line_id.account_id.id or cost_product.property_account_expense_id.id or cost_product.categ_id.property_account_expense_categ_id.id\n\n        if not credit_account_id:\n            raise UserError(_('Please configure Stock Expense Account for product: %s.') % (cost_product.name))\n\n        return self._create_account_move_line(move, credit_account_id, debit_account_id, qty_out, already_out_account_id)\n\n    def _create_account_move_line(self, move, credit_account_id, debit_account_id, qty_out, already_out_account_id):\n        \"\"\"\n        Generate the account.move.line values to track the landed cost.\n        Afterwards, for the goods that are already out of stock, we should create the out moves\n        \"\"\"\n        AccountMoveLine = self.env['account.move.line'].with_context(check_move_validity=False, recompute=False)\n\n        base_line = {\n            'name': self.name,\n            'move_id': move.id,\n            'product_id': self.product_id.id,\n            'quantity': self.quantity,\n        }\n        debit_line = dict(base_line, account_id=debit_account_id)\n        credit_line = dict(base_line, account_id=credit_account_id)\n        diff = self.additional_landed_cost\n        if diff > 0:\n            debit_line['debit'] = diff\n            credit_line['credit'] = diff\n        else:\n            # negative cost, reverse the entry\n            debit_line['credit'] = -diff\n            credit_line['debit'] = -diff\n        AccountMoveLine.create(debit_line)\n        AccountMoveLine.create(credit_line)\n\n        # Create account move lines for quants already out of stock\n        if qty_out > 0:\n            debit_line = dict(base_line,\n                              name=(self.name + \": \" + str(qty_out) + _(' already out')),\n                              quantity=qty_out,\n                              account_id=already_out_account_id)\n            credit_line = dict(base_line,\n                               name=(self.name + \": \" + str(qty_out) + _(' already out')),\n                               quantity=qty_out,\n                               account_id=debit_account_id)\n            diff = diff * qty_out / self.quantity\n            if diff > 0:\n                debit_line['debit'] = diff\n                credit_line['credit'] = diff\n            else:\n                # negative cost, reverse the entry\n                debit_line['credit'] = -diff\n                credit_line['debit'] = -diff\n            AccountMoveLine.create(debit_line)\n            AccountMoveLine.create(credit_line)\n\n            # TDE FIXME: oh dear\n            if self.env.user.company_id.anglo_saxon_accounting:\n                debit_line = dict(base_line,\n                                  name=(self.name + \": \" + str(qty_out) + _(' already out')),\n                                  quantity=qty_out,\n                                  account_id=credit_account_id)\n                credit_line = dict(base_line,\n                                   name=(self.name + \": \" + str(qty_out) + _(' already out')),\n                                   quantity=qty_out,\n                                   account_id=already_out_account_id)\n\n                if diff > 0:\n                    debit_line['debit'] = diff\n                    credit_line['credit'] = diff\n                else:\n                    # negative cost, reverse the entry\n                    debit_line['credit'] = -diff\n                    credit_line['debit'] = -diff\n                AccountMoveLine.create(debit_line)\n                AccountMoveLine.create(credit_line)\n\n        return True\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "stock_landed_cost.py", "id": "79706b839941ed52d843031562d3e101", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/stock_landed_costs/models/stock_landed_cost.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}