{"author": "openai", "code": "import numpy as np\nimport pytest\nfrom gym import spaces\nfrom gym.envs.tests.spec_list import spec_list\n\n@pytest.mark.parametrize(\"spec\", spec_list)\ndef test_env(spec):\n\n    \n    \n    \n    spaces.seed(0)\n\n    env1 = spec.make()\n    env1.seed(0)\n    action_samples1 = [env1.action_space.sample() for i in range(4)]\n    initial_observation1 = env1.reset()\n    step_responses1 = [env1.step(action) for action in action_samples1]\n    env1.close()\n\n    spaces.seed(0)\n\n    env2 = spec.make()\n    env2.seed(0)\n    action_samples2 = [env2.action_space.sample() for i in range(4)]\n    initial_observation2 = env2.reset()\n    step_responses2 = [env2.step(action) for action in action_samples2]\n    env2.close()\n\n    for i, (action_sample1, action_sample2) in enumerate(zip(action_samples1, action_samples2)):\n        try:\n            assert_equals(action_sample1, action_sample2)\n        except AssertionError:\n            print('env1.action_space=', env1.action_space)\n            print('env2.action_space=', env2.action_space)\n            print('action_samples1=', action_samples1)\n            print('action_samples2=', action_samples2)\n            print('[{}] action_sample1: {}, action_sample2: {}'.format(i, action_sample1, action_sample2))\n            raise\n\n    \n    \n    if spec.nondeterministic:\n        return\n\n    assert_equals(initial_observation1, initial_observation2)\n\n    for i, ((o1, r1, d1, i1), (o2, r2, d2, i2)) in enumerate(zip(step_responses1, step_responses2)):\n        assert_equals(o1, o2, '[{}] '.format(i))\n        assert r1 == r2, '[{}] r1: {}, r2: {}'.format(i, r1, r2)\n        assert d1 == d2, '[{}] d1: {}, d2: {}'.format(i, d1, d2)\n\n        \n        \n        \n        if spec.id not in ['Go9x9-v0', 'Go19x19-v0']:\n            assert_equals(i1, i2, '[{}] '.format(i))\n\ndef assert_equals(a, b, prefix=None):\n    assert type(a) == type(b), \"{}Differing types: {} and {}\".format(prefix, a, b)\n    if isinstance(a, dict):\n        assert list(a.keys()) == list(b.keys()), \"{}Key sets differ: {} and {}\".format(prefix, a, b)\n\n        for k in a.keys():\n            v_a = a[k]\n            v_b = b[k]\n            assert_equals(v_a, v_b)\n    elif isinstance(a, np.ndarray):\n        np.testing.assert_array_equal(a, b)\n    elif isinstance(a, tuple):\n        for elem_from_a, elem_from_b in zip(a, b):\n            assert_equals(elem_from_a, elem_from_b)\n    else:\n        assert a == b\n", "comments": "  note precludes running test multiple    threads  however  probably already multithreading    due environments     don check rollout equality nondeterministic    environment     go returns pachi game board info     properly check equality  for  hack around    skipping go  ", "content": "import numpy as np\nimport pytest\nfrom gym import spaces\nfrom gym.envs.tests.spec_list import spec_list\n\n@pytest.mark.parametrize(\"spec\", spec_list)\ndef test_env(spec):\n\n    # Note that this precludes running this test in multiple\n    # threads. However, we probably already can't do multithreading\n    # due to some environments.\n    spaces.seed(0)\n\n    env1 = spec.make()\n    env1.seed(0)\n    action_samples1 = [env1.action_space.sample() for i in range(4)]\n    initial_observation1 = env1.reset()\n    step_responses1 = [env1.step(action) for action in action_samples1]\n    env1.close()\n\n    spaces.seed(0)\n\n    env2 = spec.make()\n    env2.seed(0)\n    action_samples2 = [env2.action_space.sample() for i in range(4)]\n    initial_observation2 = env2.reset()\n    step_responses2 = [env2.step(action) for action in action_samples2]\n    env2.close()\n\n    for i, (action_sample1, action_sample2) in enumerate(zip(action_samples1, action_samples2)):\n        try:\n            assert_equals(action_sample1, action_sample2)\n        except AssertionError:\n            print('env1.action_space=', env1.action_space)\n            print('env2.action_space=', env2.action_space)\n            print('action_samples1=', action_samples1)\n            print('action_samples2=', action_samples2)\n            print('[{}] action_sample1: {}, action_sample2: {}'.format(i, action_sample1, action_sample2))\n            raise\n\n    # Don't check rollout equality if it's a a nondeterministic\n    # environment.\n    if spec.nondeterministic:\n        return\n\n    assert_equals(initial_observation1, initial_observation2)\n\n    for i, ((o1, r1, d1, i1), (o2, r2, d2, i2)) in enumerate(zip(step_responses1, step_responses2)):\n        assert_equals(o1, o2, '[{}] '.format(i))\n        assert r1 == r2, '[{}] r1: {}, r2: {}'.format(i, r1, r2)\n        assert d1 == d2, '[{}] d1: {}, d2: {}'.format(i, d1, d2)\n\n        # Go returns a Pachi game board in info, which doesn't\n        # properly check equality. For now, we hack around this by\n        # just skipping Go.\n        if spec.id not in ['Go9x9-v0', 'Go19x19-v0']:\n            assert_equals(i1, i2, '[{}] '.format(i))\n\ndef assert_equals(a, b, prefix=None):\n    assert type(a) == type(b), \"{}Differing types: {} and {}\".format(prefix, a, b)\n    if isinstance(a, dict):\n        assert list(a.keys()) == list(b.keys()), \"{}Key sets differ: {} and {}\".format(prefix, a, b)\n\n        for k in a.keys():\n            v_a = a[k]\n            v_b = b[k]\n            assert_equals(v_a, v_b)\n    elif isinstance(a, np.ndarray):\n        np.testing.assert_array_equal(a, b)\n    elif isinstance(a, tuple):\n        for elem_from_a, elem_from_b in zip(a, b):\n            assert_equals(elem_from_a, elem_from_b)\n    else:\n        assert a == b\n", "description": "A toolkit for developing and comparing reinforcement learning algorithms.", "file_name": "test_determinism.py", "id": "13445787a5ba619f4624f9b7f7776957", "language": "Python", "project_name": "gym", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/openai-gym/openai-gym-6160181/gym/envs/tests/test_determinism.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:30:35Z", "url": "https://github.com/openai/gym", "wiki": true}