{"author": "jakubroztocil", "code": "import os\nfrom tempfile import gettempdir\n\nimport pytest\n\nfrom utils import MockEnvironment, http, HTTP_OK, COLOR, CRLF\nfrom httpie import ExitStatus\nfrom httpie.compat import urlopen\nfrom httpie.output.formatters.colors import get_lexer\n\n\n@pytest.mark.parametrize('stdout_isatty', [True, False])\ndef test_output_option(httpbin, stdout_isatty):\n    output_filename = os.path.join(gettempdir(), test_output_option.__name__)\n    url = httpbin + '/robots.txt'\n\n    r = http('--output', output_filename, url,\n             env=MockEnvironment(stdout_isatty=stdout_isatty))\n    assert r == ''\n\n    expected_body = urlopen(url).read().decode()\n    with open(output_filename, 'r') as f:\n        actual_body = f.read()\n\n    assert actual_body == expected_body\n\n\nclass TestVerboseFlag:\n    def test_verbose(self, httpbin):\n        r = http('--verbose',\n                 'GET', httpbin.url + '/get', 'test-header:__test__')\n        assert HTTP_OK in r\n        assert r.count('__test__') == 2\n\n    def test_verbose_form(self, httpbin):\n        \n        r = http('--verbose', '--form', 'POST', httpbin.url + '/post',\n                 'A=B', 'C=D')\n        assert HTTP_OK in r\n        assert 'A=B&C=D' in r\n\n    def test_verbose_json(self, httpbin):\n        r = http('--verbose',\n                 'POST', httpbin.url + '/post', 'foo=bar', 'baz=bar')\n        assert HTTP_OK in r\n        assert '\"baz\": \"bar\"' in r\n\n    def test_verbose_implies_all(self, httpbin):\n        r = http('--verbose', '--follow', httpbin + '/redirect/1')\n        assert 'GET /redirect/1 HTTP/1.1' in r\n        assert 'HTTP/1.1 302 FOUND' in r\n        assert 'GET /get HTTP/1.1' in r\n        assert HTTP_OK in r\n\n\nclass TestColors:\n\n    @pytest.mark.parametrize(\n        argnames=['mime', 'explicit_json', 'body', 'expected_lexer_name'],\n        argvalues=[\n            ('application/json',     False, None, 'JSON'),\n            ('application/json+foo', False, None, 'JSON'),\n            ('application/foo+json', False, None, 'JSON'),\n            ('application/json-foo', False, None, 'JSON'),\n            ('application/x-json',   False, None, 'JSON'),\n            ('foo/json',             False, None, 'JSON'),\n            ('foo/json+bar',         False, None, 'JSON'),\n            ('foo/bar+json',         False, None, 'JSON'),\n            ('foo/json-foo',         False, None, 'JSON'),\n            ('foo/x-json',           False, None, 'JSON'),\n            ('application/vnd.comverge.grid+hal+json', False, None, 'JSON'),\n            ('text/plain',           True, '{}', 'JSON'),\n            ('text/plain',           True, 'foo', 'Text only'),\n        ]\n    )\n    def test_get_lexer(self, mime, explicit_json, body, expected_lexer_name):\n        lexer = get_lexer(mime, body=body, explicit_json=explicit_json)\n        assert lexer is not None\n        assert lexer.name == expected_lexer_name\n\n    def test_get_lexer_not_found(self):\n        assert get_lexer('xxx/yyy') is None\n\n\nclass TestPrettyOptions:\n    \"\"\"Test the --pretty flag handling.\"\"\"\n\n    def test_pretty_enabled_by_default(self, httpbin):\n        env = MockEnvironment(colors=256)\n        r = http('GET', httpbin.url + '/get', env=env)\n        assert COLOR in r\n\n    def test_pretty_enabled_by_default_unless_stdout_redirected(self, httpbin):\n        r = http('GET', httpbin.url + '/get')\n        assert COLOR not in r\n\n    def test_force_pretty(self, httpbin):\n        env = MockEnvironment(stdout_isatty=False, colors=256)\n        r = http('--pretty=all', 'GET', httpbin.url + '/get', env=env, )\n        assert COLOR in r\n\n    def test_force_ugly(self, httpbin):\n        r = http('--pretty=none', 'GET', httpbin.url + '/get')\n        assert COLOR not in r\n\n    def test_subtype_based_pygments_lexer_match(self, httpbin):\n        \"\"\"Test that media subtype is used if type/subtype doesn't\n        match any lexer.\n\n        \"\"\"\n        env = MockEnvironment(colors=256)\n        r = http('--print=B', '--pretty=all', httpbin.url + '/post',\n                 'Content-Type:text/foo+json', 'a=b', env=env)\n        assert COLOR in r\n\n    def test_colors_option(self, httpbin):\n        env = MockEnvironment(colors=256)\n        r = http('--print=B', '--pretty=colors',\n                 'GET', httpbin.url + '/get', 'a=b',\n                 env=env)\n        \n        assert not r.strip().count('\\n')\n        assert COLOR in r\n\n    def test_format_option(self, httpbin):\n        env = MockEnvironment(colors=256)\n        r = http('--print=B', '--pretty=format',\n                 'GET', httpbin.url + '/get', 'a=b',\n                 env=env)\n        \n        assert r.strip().count('\\n') == 2\n        assert COLOR not in r\n\n\nclass TestLineEndings:\n    \"\"\"\n    Test that CRLF is properly used in headers\n    and as the headers/body separator.\n\n    \"\"\"\n    def _validate_crlf(self, msg):\n        lines = iter(msg.splitlines(True))\n        for header in lines:\n            if header == CRLF:\n                break\n            assert header.endswith(CRLF), repr(header)\n        else:\n            assert 0, 'CRLF between headers and body not found in %r' % msg\n        body = ''.join(lines)\n        assert CRLF not in body\n        return body\n\n    def test_CRLF_headers_only(self, httpbin):\n        r = http('--headers', 'GET', httpbin.url + '/get')\n        body = self._validate_crlf(r)\n        assert not body, 'Garbage after headers: %r' % r\n\n    def test_CRLF_ugly_response(self, httpbin):\n        r = http('--pretty=none', 'GET', httpbin.url + '/get')\n        self._validate_crlf(r)\n\n    def test_CRLF_formatted_response(self, httpbin):\n        r = http('--pretty=format', 'GET', httpbin.url + '/get')\n        assert r.exit_status == ExitStatus.OK\n        self._validate_crlf(r)\n\n    def test_CRLF_ugly_request(self, httpbin):\n        r = http('--pretty=none', '--print=HB', 'GET', httpbin.url + '/get')\n        self._validate_crlf(r)\n\n    def test_CRLF_formatted_request(self, httpbin):\n        r = http('--pretty=format', '--print=HB', 'GET', httpbin.url + '/get')\n        self._validate_crlf(r)\n", "comments": "   test   pretty flag handling          def test pretty enabled default(self  httpbin)          env   mockenvironment(colors 256)         r   http( get   httpbin url     get   env env)         assert color r      def test pretty enabled default unless stdout redirected(self  httpbin)          r   http( get   httpbin url     get )         assert color r      def test force pretty(self  httpbin)          env   mockenvironment(stdout isatty false  colors 256)         r   http(   pretty    get   httpbin url     get   env env  )         assert color r      def test force ugly(self  httpbin)          r   http(   pretty none    get   httpbin url     get )         assert color r      def test subtype based pygments lexer match(self  httpbin)             test media subtype used type subtype         match lexer                       env   mockenvironment(colors 256)         r   http(   print b      pretty   httpbin url     post                     content type text foo json    b   env env)         assert color r      def test colors option(self  httpbin)          env   mockenvironment(colors 256)         r   http(   print b      pretty colors                     get   httpbin url     get    b                    env env)           tests json data formatted          assert r strip() count(  n )         assert color r      def test format option(self  httpbin)          env   mockenvironment(colors 256)         r   http(   print b      pretty format                     get   httpbin url     get    b                    env env)           tests json data formatted          assert r strip() count(  n )    2         assert color r   class testlineendings              test crlf properly used headers     headers body separator              https   github com jakubroztocil httpie issues 53    tests json data formatted     tests json data formatted  ", "content": "import os\nfrom tempfile import gettempdir\n\nimport pytest\n\nfrom utils import MockEnvironment, http, HTTP_OK, COLOR, CRLF\nfrom httpie import ExitStatus\nfrom httpie.compat import urlopen\nfrom httpie.output.formatters.colors import get_lexer\n\n\n@pytest.mark.parametrize('stdout_isatty', [True, False])\ndef test_output_option(httpbin, stdout_isatty):\n    output_filename = os.path.join(gettempdir(), test_output_option.__name__)\n    url = httpbin + '/robots.txt'\n\n    r = http('--output', output_filename, url,\n             env=MockEnvironment(stdout_isatty=stdout_isatty))\n    assert r == ''\n\n    expected_body = urlopen(url).read().decode()\n    with open(output_filename, 'r') as f:\n        actual_body = f.read()\n\n    assert actual_body == expected_body\n\n\nclass TestVerboseFlag:\n    def test_verbose(self, httpbin):\n        r = http('--verbose',\n                 'GET', httpbin.url + '/get', 'test-header:__test__')\n        assert HTTP_OK in r\n        assert r.count('__test__') == 2\n\n    def test_verbose_form(self, httpbin):\n        # https://github.com/jakubroztocil/httpie/issues/53\n        r = http('--verbose', '--form', 'POST', httpbin.url + '/post',\n                 'A=B', 'C=D')\n        assert HTTP_OK in r\n        assert 'A=B&C=D' in r\n\n    def test_verbose_json(self, httpbin):\n        r = http('--verbose',\n                 'POST', httpbin.url + '/post', 'foo=bar', 'baz=bar')\n        assert HTTP_OK in r\n        assert '\"baz\": \"bar\"' in r\n\n    def test_verbose_implies_all(self, httpbin):\n        r = http('--verbose', '--follow', httpbin + '/redirect/1')\n        assert 'GET /redirect/1 HTTP/1.1' in r\n        assert 'HTTP/1.1 302 FOUND' in r\n        assert 'GET /get HTTP/1.1' in r\n        assert HTTP_OK in r\n\n\nclass TestColors:\n\n    @pytest.mark.parametrize(\n        argnames=['mime', 'explicit_json', 'body', 'expected_lexer_name'],\n        argvalues=[\n            ('application/json',     False, None, 'JSON'),\n            ('application/json+foo', False, None, 'JSON'),\n            ('application/foo+json', False, None, 'JSON'),\n            ('application/json-foo', False, None, 'JSON'),\n            ('application/x-json',   False, None, 'JSON'),\n            ('foo/json',             False, None, 'JSON'),\n            ('foo/json+bar',         False, None, 'JSON'),\n            ('foo/bar+json',         False, None, 'JSON'),\n            ('foo/json-foo',         False, None, 'JSON'),\n            ('foo/x-json',           False, None, 'JSON'),\n            ('application/vnd.comverge.grid+hal+json', False, None, 'JSON'),\n            ('text/plain',           True, '{}', 'JSON'),\n            ('text/plain',           True, 'foo', 'Text only'),\n        ]\n    )\n    def test_get_lexer(self, mime, explicit_json, body, expected_lexer_name):\n        lexer = get_lexer(mime, body=body, explicit_json=explicit_json)\n        assert lexer is not None\n        assert lexer.name == expected_lexer_name\n\n    def test_get_lexer_not_found(self):\n        assert get_lexer('xxx/yyy') is None\n\n\nclass TestPrettyOptions:\n    \"\"\"Test the --pretty flag handling.\"\"\"\n\n    def test_pretty_enabled_by_default(self, httpbin):\n        env = MockEnvironment(colors=256)\n        r = http('GET', httpbin.url + '/get', env=env)\n        assert COLOR in r\n\n    def test_pretty_enabled_by_default_unless_stdout_redirected(self, httpbin):\n        r = http('GET', httpbin.url + '/get')\n        assert COLOR not in r\n\n    def test_force_pretty(self, httpbin):\n        env = MockEnvironment(stdout_isatty=False, colors=256)\n        r = http('--pretty=all', 'GET', httpbin.url + '/get', env=env, )\n        assert COLOR in r\n\n    def test_force_ugly(self, httpbin):\n        r = http('--pretty=none', 'GET', httpbin.url + '/get')\n        assert COLOR not in r\n\n    def test_subtype_based_pygments_lexer_match(self, httpbin):\n        \"\"\"Test that media subtype is used if type/subtype doesn't\n        match any lexer.\n\n        \"\"\"\n        env = MockEnvironment(colors=256)\n        r = http('--print=B', '--pretty=all', httpbin.url + '/post',\n                 'Content-Type:text/foo+json', 'a=b', env=env)\n        assert COLOR in r\n\n    def test_colors_option(self, httpbin):\n        env = MockEnvironment(colors=256)\n        r = http('--print=B', '--pretty=colors',\n                 'GET', httpbin.url + '/get', 'a=b',\n                 env=env)\n        # Tests that the JSON data isn't formatted.\n        assert not r.strip().count('\\n')\n        assert COLOR in r\n\n    def test_format_option(self, httpbin):\n        env = MockEnvironment(colors=256)\n        r = http('--print=B', '--pretty=format',\n                 'GET', httpbin.url + '/get', 'a=b',\n                 env=env)\n        # Tests that the JSON data is formatted.\n        assert r.strip().count('\\n') == 2\n        assert COLOR not in r\n\n\nclass TestLineEndings:\n    \"\"\"\n    Test that CRLF is properly used in headers\n    and as the headers/body separator.\n\n    \"\"\"\n    def _validate_crlf(self, msg):\n        lines = iter(msg.splitlines(True))\n        for header in lines:\n            if header == CRLF:\n                break\n            assert header.endswith(CRLF), repr(header)\n        else:\n            assert 0, 'CRLF between headers and body not found in %r' % msg\n        body = ''.join(lines)\n        assert CRLF not in body\n        return body\n\n    def test_CRLF_headers_only(self, httpbin):\n        r = http('--headers', 'GET', httpbin.url + '/get')\n        body = self._validate_crlf(r)\n        assert not body, 'Garbage after headers: %r' % r\n\n    def test_CRLF_ugly_response(self, httpbin):\n        r = http('--pretty=none', 'GET', httpbin.url + '/get')\n        self._validate_crlf(r)\n\n    def test_CRLF_formatted_response(self, httpbin):\n        r = http('--pretty=format', 'GET', httpbin.url + '/get')\n        assert r.exit_status == ExitStatus.OK\n        self._validate_crlf(r)\n\n    def test_CRLF_ugly_request(self, httpbin):\n        r = http('--pretty=none', '--print=HB', 'GET', httpbin.url + '/get')\n        self._validate_crlf(r)\n\n    def test_CRLF_formatted_request(self, httpbin):\n        r = http('--pretty=format', '--print=HB', 'GET', httpbin.url + '/get')\n        self._validate_crlf(r)\n", "description": "Modern command line HTTP client \u2013 user-friendly curl alternative with intuitive UI, JSON support, syntax highlighting, wget-like downloads, extensions, etc.  https://httpie.org", "file_name": "test_output.py", "id": "358a028c7db1c359ade152162bee2dbc", "language": "Python", "project_name": "httpie", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/jakubroztocil-httpie/jakubroztocil-httpie-0f4dce9/tests/test_output.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:39:35Z", "url": "https://github.com/jakubroztocil/httpie", "wiki": false}