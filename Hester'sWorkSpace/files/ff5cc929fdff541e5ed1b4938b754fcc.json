{"author": "keon", "code": "\"\"\"\nNumbers can be regarded as product of its factors. For example,\n8 = 2 x 2 x 2;\n  = 2 x 4.\n\n\nWrite a function that takes an integer n and return all possible combinations\nof its factors.Numbers can be regarded as product of its factors. For example,\n8 = 2 x 2 x 2;\n  = 2 x 4.\n\nExamples:\ninput: 1\noutput:\n[]\n\n\ninput: 37\noutput:\n[]\n\ninput: 32\noutput:\n[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],\n\"\"\"\n\n\ndef get_factors(n):\n    def factor(n, i, combi, res):\n        while i * i <= n:\n            if n % i == 0:\n                res += combi + [i, int(n/i)],\n                factor(n/i, i, combi+[i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])\n\n\ndef get_factors_iterative1(self, n):\n    todo, res = [(n, 2, [])], []\n    while todo:\n        n, i, combi = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                res += combi + [i, n/i],\n                todo += (n/i, i, combi+[i]),\n            i += 1\n    return res\n\n\ndef get_factors_iterative2(n):\n    ans, stack, x = [], [], 2\n    while True:\n        if x > n / x:\n            if not stack:\n                return ans\n            ans.append(stack + [n])\n            x = stack.pop()\n            n *= x\n            x += 1\n        elif n % x == 0:\n            stack.append(x)\n            n /= x\n        else:\n            x += 1\n\n\nif __name__ == \"__main__\":\n    print(get_factors(32))\n", "comments": "    numbers regarded product factors  for example  8   2 x 2 x 2      2 x 4    write function takes integer n return possible combinations factors numbers regarded product factors  for example  8   2 x 2 x 2      2 x 4   examples  input  1 output       input  37 output      input  32 output       2  16      2  2  8      2  2  2  4      2  2  2  2  2       ", "content": "\"\"\"\nNumbers can be regarded as product of its factors. For example,\n8 = 2 x 2 x 2;\n  = 2 x 4.\n\n\nWrite a function that takes an integer n and return all possible combinations\nof its factors.Numbers can be regarded as product of its factors. For example,\n8 = 2 x 2 x 2;\n  = 2 x 4.\n\nExamples:\ninput: 1\noutput:\n[]\n\n\ninput: 37\noutput:\n[]\n\ninput: 32\noutput:\n[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],\n\"\"\"\n\n\ndef get_factors(n):\n    def factor(n, i, combi, res):\n        while i * i <= n:\n            if n % i == 0:\n                res += combi + [i, int(n/i)],\n                factor(n/i, i, combi+[i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])\n\n\ndef get_factors_iterative1(self, n):\n    todo, res = [(n, 2, [])], []\n    while todo:\n        n, i, combi = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                res += combi + [i, n/i],\n                todo += (n/i, i, combi+[i]),\n            i += 1\n    return res\n\n\ndef get_factors_iterative2(n):\n    ans, stack, x = [], [], 2\n    while True:\n        if x > n / x:\n            if not stack:\n                return ans\n            ans.append(stack + [n])\n            x = stack.pop()\n            n *= x\n            x += 1\n        elif n % x == 0:\n            stack.append(x)\n            n /= x\n        else:\n            x += 1\n\n\nif __name__ == \"__main__\":\n    print(get_factors(32))\n", "description": "Minimal examples of data structures and algorithms in Python", "file_name": "all_factors.py", "id": "ff5cc929fdff541e5ed1b4938b754fcc", "language": "Python", "project_name": "algorithms", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/keon-algorithms/keon-algorithms-ea43887/dfs/all_factors.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:53:29Z", "url": "https://github.com/keon/algorithms", "wiki": true}