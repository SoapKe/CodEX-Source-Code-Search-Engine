{"author": "jazzband", "code": "\"\"\"\nDebug Toolbar middleware\n\"\"\"\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport re\nimport threading\n\nfrom django.conf import settings\nfrom django.utils import six\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.utils.encoding import force_text\nfrom django.utils.lru_cache import lru_cache\nfrom django.utils.module_loading import import_string\n\nfrom debug_toolbar import settings as dt_settings\nfrom debug_toolbar.toolbar import DebugToolbar\n\n_HTML_TYPES = ('text/html', 'application/xhtml+xml')\n\n\ndef show_toolbar(request):\n    \"\"\"\n    Default function to determine whether to show the toolbar on a given page.\n    \"\"\"\n    if request.META.get('REMOTE_ADDR', None) not in settings.INTERNAL_IPS:\n        return False\n\n    return bool(settings.DEBUG)\n\n\n@lru_cache()\ndef get_show_toolbar():\n    \n    \n    func_or_path = dt_settings.get_config()['SHOW_TOOLBAR_CALLBACK']\n    if isinstance(func_or_path, six.string_types):\n        return import_string(func_or_path)\n    else:\n        return func_or_path\n\n\nclass DebugToolbarMiddleware(MiddlewareMixin):\n    \"\"\"\n    Middleware to set up Debug Toolbar on incoming request and render toolbar\n    on outgoing response.\n    \"\"\"\n    debug_toolbars = {}\n\n    def process_request(self, request):\n        \n        show_toolbar = get_show_toolbar()\n        if not show_toolbar(request):\n            return\n\n        \n        if request.is_ajax():\n            return\n\n        toolbar = DebugToolbar(request)\n        self.__class__.debug_toolbars[threading.current_thread().ident] = toolbar\n\n        \n        for panel in toolbar.enabled_panels:\n            panel.enable_instrumentation()\n\n        \n        response = None\n        for panel in toolbar.enabled_panels:\n            response = panel.process_request(request)\n            if response:\n                break\n        return response\n\n    def process_view(self, request, view_func, view_args, view_kwargs):\n        toolbar = self.__class__.debug_toolbars.get(threading.current_thread().ident)\n        if not toolbar:\n            return\n\n        \n        response = None\n        for panel in toolbar.enabled_panels:\n            response = panel.process_view(request, view_func, view_args, view_kwargs)\n            if response:\n                break\n        return response\n\n    def process_response(self, request, response):\n        toolbar = self.__class__.debug_toolbars.pop(threading.current_thread().ident, None)\n        if not toolbar:\n            return response\n\n        \n        for panel in reversed(toolbar.enabled_panels):\n            new_response = panel.process_response(request, response)\n            if new_response:\n                response = new_response\n\n        \n        \n        # (NB: Django's model for middleware doesn't guarantee anything.)\n        for panel in reversed(toolbar.enabled_panels):\n            panel.disable_instrumentation()\n\n        \n        content_encoding = response.get('Content-Encoding', '')\n        content_type = response.get('Content-Type', '').split(';')[0]\n        if any((getattr(response, 'streaming', False),\n                'gzip' in content_encoding,\n                content_type not in _HTML_TYPES)):\n            return response\n\n        \n        if toolbar.config['SHOW_COLLAPSED'] and 'djdt' not in request.COOKIES:\n            response.set_cookie('djdt', 'hide', 864000)\n\n        \n        content = force_text(response.content, encoding=response.charset)\n        insert_before = dt_settings.get_config()['INSERT_BEFORE']\n        pattern = re.escape(insert_before)\n        bits = re.split(pattern, content, flags=re.IGNORECASE)\n        if len(bits) > 1:\n            \n            for panel in reversed(toolbar.enabled_panels):\n                panel.generate_stats(request, response)\n\n            bits[-2] += toolbar.render_toolbar()\n            response.content = insert_before.join(bits)\n            if response.get('Content-Length', None):\n                response['Content-Length'] = len(response.content)\n        return response\n", "comments": "    debug toolbar middleware        future   import absolute import  unicode literals  import import threading  django conf import settings django utils import six django utils deprecation import middlewaremixin django utils encoding import force text django utils lru cache import lru cache django utils module loading import import string  debug toolbar import settings dt settings debug toolbar toolbar import debugtoolbar   html types   ( text html    application xhtml xml )   def show toolbar(request)              default function determine whether show toolbar given page              request meta get( remote addr   none) settings internal ips          return false      return bool(settings debug)    lru cache() def get show toolbar()        if show toolbar callback string  recommended       setup  resolve corresponding callable      func path   dt settings get config()  show toolbar callback       isinstance(func path  six string types)          return import string(func path)     else          return func path   class debugtoolbarmiddleware(middlewaremixin)              middleware set debug toolbar incoming request render toolbar     outgoing response             if show toolbar callback string  recommended    setup  resolve corresponding callable     decide whether toolbar active request     don render toolbar ajax requests     activate instrumentation ie  monkey patch     run process request methods panels like django middleware     run process view methods panels like django middleware     run process response methods panels like django middleware     deactivate instrumentation ie  monkey unpatch  this must run    regardless response  keep  return  clauses     (nb  django model middleware guarantee anything )    check responses toolbar inserted     collapse toolbar default show collapsed set     insert toolbar response     when toolbar inserted sure  generate stats  ", "content": "\"\"\"\nDebug Toolbar middleware\n\"\"\"\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport re\nimport threading\n\nfrom django.conf import settings\nfrom django.utils import six\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.utils.encoding import force_text\nfrom django.utils.lru_cache import lru_cache\nfrom django.utils.module_loading import import_string\n\nfrom debug_toolbar import settings as dt_settings\nfrom debug_toolbar.toolbar import DebugToolbar\n\n_HTML_TYPES = ('text/html', 'application/xhtml+xml')\n\n\ndef show_toolbar(request):\n    \"\"\"\n    Default function to determine whether to show the toolbar on a given page.\n    \"\"\"\n    if request.META.get('REMOTE_ADDR', None) not in settings.INTERNAL_IPS:\n        return False\n\n    return bool(settings.DEBUG)\n\n\n@lru_cache()\ndef get_show_toolbar():\n    # If SHOW_TOOLBAR_CALLBACK is a string, which is the recommended\n    # setup, resolve it to the corresponding callable.\n    func_or_path = dt_settings.get_config()['SHOW_TOOLBAR_CALLBACK']\n    if isinstance(func_or_path, six.string_types):\n        return import_string(func_or_path)\n    else:\n        return func_or_path\n\n\nclass DebugToolbarMiddleware(MiddlewareMixin):\n    \"\"\"\n    Middleware to set up Debug Toolbar on incoming request and render toolbar\n    on outgoing response.\n    \"\"\"\n    debug_toolbars = {}\n\n    def process_request(self, request):\n        # Decide whether the toolbar is active for this request.\n        show_toolbar = get_show_toolbar()\n        if not show_toolbar(request):\n            return\n\n        # Don't render the toolbar during AJAX requests.\n        if request.is_ajax():\n            return\n\n        toolbar = DebugToolbar(request)\n        self.__class__.debug_toolbars[threading.current_thread().ident] = toolbar\n\n        # Activate instrumentation ie. monkey-patch.\n        for panel in toolbar.enabled_panels:\n            panel.enable_instrumentation()\n\n        # Run process_request methods of panels like Django middleware.\n        response = None\n        for panel in toolbar.enabled_panels:\n            response = panel.process_request(request)\n            if response:\n                break\n        return response\n\n    def process_view(self, request, view_func, view_args, view_kwargs):\n        toolbar = self.__class__.debug_toolbars.get(threading.current_thread().ident)\n        if not toolbar:\n            return\n\n        # Run process_view methods of panels like Django middleware.\n        response = None\n        for panel in toolbar.enabled_panels:\n            response = panel.process_view(request, view_func, view_args, view_kwargs)\n            if response:\n                break\n        return response\n\n    def process_response(self, request, response):\n        toolbar = self.__class__.debug_toolbars.pop(threading.current_thread().ident, None)\n        if not toolbar:\n            return response\n\n        # Run process_response methods of panels like Django middleware.\n        for panel in reversed(toolbar.enabled_panels):\n            new_response = panel.process_response(request, response)\n            if new_response:\n                response = new_response\n\n        # Deactivate instrumentation ie. monkey-unpatch. This must run\n        # regardless of the response. Keep 'return' clauses below.\n        # (NB: Django's model for middleware doesn't guarantee anything.)\n        for panel in reversed(toolbar.enabled_panels):\n            panel.disable_instrumentation()\n\n        # Check for responses where the toolbar can't be inserted.\n        content_encoding = response.get('Content-Encoding', '')\n        content_type = response.get('Content-Type', '').split(';')[0]\n        if any((getattr(response, 'streaming', False),\n                'gzip' in content_encoding,\n                content_type not in _HTML_TYPES)):\n            return response\n\n        # Collapse the toolbar by default if SHOW_COLLAPSED is set.\n        if toolbar.config['SHOW_COLLAPSED'] and 'djdt' not in request.COOKIES:\n            response.set_cookie('djdt', 'hide', 864000)\n\n        # Insert the toolbar in the response.\n        content = force_text(response.content, encoding=response.charset)\n        insert_before = dt_settings.get_config()['INSERT_BEFORE']\n        pattern = re.escape(insert_before)\n        bits = re.split(pattern, content, flags=re.IGNORECASE)\n        if len(bits) > 1:\n            # When the toolbar will be inserted for sure, generate the stats.\n            for panel in reversed(toolbar.enabled_panels):\n                panel.generate_stats(request, response)\n\n            bits[-2] += toolbar.render_toolbar()\n            response.content = insert_before.join(bits)\n            if response.get('Content-Length', None):\n                response['Content-Length'] = len(response.content)\n        return response\n", "description": "A configurable set of panels that display various debug information about the current request/response.", "file_name": "middleware.py", "id": "021d091d955030c11ab304622ec1a3cf", "language": "Python", "project_name": "django-debug-toolbar", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/jazzband-django-debug-toolbar/jazzband-django-debug-toolbar-459e978/debug_toolbar/middleware.py", "save_time": "", "source": "", "update_at": "2018-03-18T09:15:08Z", "url": "https://github.com/jazzband/django-debug-toolbar", "wiki": true}