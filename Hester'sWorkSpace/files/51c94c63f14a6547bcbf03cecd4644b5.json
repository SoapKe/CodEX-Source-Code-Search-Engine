{"author": "ansible", "code": "\n -*- coding: utf-8 -*-\n\n (c) 2012, Afterburn <http://github.com/afterburn>\n (c) 2013, Aaron Bull Schaefer <aaron@elasticdog.com>\n (c) 2015, Jonathan Lestrelin <jonathan.lestrelin@gmail.com>\n\n GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: pear\nshort_description: Manage pear/pecl packages\ndescription:\n    - Manage PHP packages with the pear package manager.\nversion_added: 2.0\nauthor:\n    - \"'jonathan.lestrelin' <jonathan.lestrelin@gmail.com>\"\noptions:\n    name:\n        description:\n            - Name of the package to install, upgrade, or remove.\n        required: true\n\n    state:\n        description:\n            - Desired state of the package.\n        default: \"present\"\n        choices: [\"present\", \"absent\", \"latest\"]\n    executable:\n      description:\n        - Path to the pear executable\n      version_added: \"2.4\"\n'''\n\nEXAMPLES = '''\n Install pear package\n- pear:\n    name: Net_URL2\n    state: present\n\n Install pecl package\n- pear:\n    name: pecl/json_post\n    state: present\n\n Upgrade package\n- pear:\n    name: Net_URL2\n    state: latest\n\n Remove packages\n- pear:\n    name: Net_URL2,pecl/json_post\n    state: absent\n'''\n\nimport os\n\nfrom ansible.module_utils.basic import AnsibleModule\n\n\ndef get_local_version(pear_output):\n    \"\"\"Take pear remoteinfo output and get the installed version\"\"\"\n    lines = pear_output.split('\\n')\n    for line in lines:\n        if 'Installed ' in line:\n            installed = line.rsplit(None, 1)[-1].strip()\n            if installed == '-':\n                continue\n            return installed\n    return None\n\n\ndef _get_pear_path(module):\n    if module.params['executable'] and os.path.isfile(module.params['executable']):\n        result = module.params['executable']\n    else:\n        result = module.get_bin_path('pear', True, [module.params['executable']])\n    return result\n\n\ndef get_repository_version(pear_output):\n    \"\"\"Take pear remote-info output and get the latest version\"\"\"\n    lines = pear_output.split('\\n')\n    for line in lines:\n        if 'Latest ' in line:\n            return line.rsplit(None, 1)[-1].strip()\n    return None\n\n\ndef query_package(module, name, state=\"present\"):\n    \"\"\"Query the package status in both the local system and the repository.\n    Returns a boolean to indicate if the package is installed,\n    and a second boolean to indicate if the package is up-to-date.\"\"\"\n    if state == \"present\":\n        lcmd = \"%s info %s\" % (_get_pear_path(module), name)\n        lrc, lstdout, lstderr = module.run_command(lcmd, check_rc=False)\n        if lrc != 0:\n             package is not installed locally\n            return False, False\n\n        rcmd = \"%s remote-info %s\" % (_get_pear_path(module), name)\n        rrc, rstdout, rstderr = module.run_command(rcmd, check_rc=False)\n\n         get the version installed locally (if any)\n        lversion = get_local_version(rstdout)\n\n         get the version in the repository\n        rversion = get_repository_version(rstdout)\n\n        if rrc == 0:\n             Return True to indicate that the package is installed locally,\n             and the result of the version number comparison\n             to determine if the package is up-to-date.\n            return True, (lversion == rversion)\n\n        return False, False\n\n\ndef remove_packages(module, packages):\n    remove_c = 0\n     Using a for loop in case of error, we can report the package that failed\n    for package in packages:\n         Query the package first, to see if we even need to remove\n        installed, updated = query_package(module, package)\n        if not installed:\n            continue\n\n        cmd = \"%s uninstall %s\" % (_get_pear_path(module), package)\n        rc, stdout, stderr = module.run_command(cmd, check_rc=False)\n\n        if rc != 0:\n            module.fail_json(msg=\"failed to remove %s\" % (package))\n\n        remove_c += 1\n\n    if remove_c > 0:\n\n        module.exit_json(changed=True, msg=\"removed %s package(s)\" % remove_c)\n\n    module.exit_json(changed=False, msg=\"package(s) already absent\")\n\n\ndef install_packages(module, state, packages):\n    install_c = 0\n\n    for i, package in enumerate(packages):\n         if the package is installed and state == present\n         or state == latest and is up-to-date then skip\n        installed, updated = query_package(module, package)\n        if installed and (state == 'present' or (state == 'latest' and updated)):\n            continue\n\n        if state == 'present':\n            command = 'install'\n\n        if state == 'latest':\n            command = 'upgrade'\n\n        cmd = \"%s %s %s\" % (_get_pear_path(module), command, package)\n        rc, stdout, stderr = module.run_command(cmd, check_rc=False)\n\n        if rc != 0:\n            module.fail_json(msg=\"failed to install %s\" % (package))\n\n        install_c += 1\n\n    if install_c > 0:\n        module.exit_json(changed=True, msg=\"installed %s package(s)\" % (install_c))\n\n    module.exit_json(changed=False, msg=\"package(s) already installed\")\n\n\ndef check_packages(module, packages, state):\n    would_be_changed = []\n    for package in packages:\n        installed, updated = query_package(module, package)\n        if ((state in [\"present\", \"latest\"] and not installed) or\n                (state == \"absent\" and installed) or\n                (state == \"latest\" and not updated)):\n            would_be_changed.append(package)\n    if would_be_changed:\n        if state == \"absent\":\n            state = \"removed\"\n        module.exit_json(changed=True, msg=\"%s package(s) would be %s\" % (\n            len(would_be_changed), state))\n    else:\n        module.exit_json(change=False, msg=\"package(s) already %s\" % state)\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            name=dict(aliases=['pkg']),\n            state=dict(default='present', choices=['present', 'installed', \"latest\", 'absent', 'removed']),\n            executable=dict(default=None, required=False, type='path')),\n        required_one_of=[['name']],\n        supports_check_mode=True)\n\n    p = module.params\n\n     normalize the state parameter\n    if p['state'] in ['present', 'installed']:\n        p['state'] = 'present'\n    elif p['state'] in ['absent', 'removed']:\n        p['state'] = 'absent'\n\n    if p['name']:\n        pkgs = p['name'].split(',')\n\n        pkg_files = []\n        for i, pkg in enumerate(pkgs):\n            pkg_files.append(None)\n\n        if module.check_mode:\n            check_packages(module, pkgs, p['state'])\n\n        if p['state'] in ['present', 'latest']:\n            install_packages(module, p['state'], pkgs)\n        elif p['state'] == 'absent':\n            remove_packages(module, pkgs)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "   take pear remoteinfo output get installed version        lines   pear output split(  n )     line lines           installed   line              installed   line rsplit(none  1)  1  strip()             installed                         continue             return installed     return none   def  get pear path(module)      module params  executable   os path isfile(module params  executable  )          result   module params  executable       else          result   module get bin path( pear   true   module params  executable   )     return result   def get repository version(pear output)         take pear remote info output get latest version        lines   pear output split(  n )     line lines           latest   line              return line rsplit(none  1)  1  strip()     return none   def query package(module  name  state  present )         query package status local system repository      returns boolean indicate package installed      second boolean indicate package date              module  pear short description  manage pear pecl packages description        manage php packages pear package manager  version added  2 0 author          jonathan lestrelin   jonathan lestrelin gmail com   options      name          description                name package install  upgrade  remove          required  true      state          description                desired state package          default   present          choices    present    absent    latest       executable        description            path pear executable       version added   2 4       examples         install pear package   pear      name  net url2     state  present    install pecl package   pear      name  pecl json post     state  present    upgrade package   pear      name  net url2     state  latest    remove packages   pear      name  net url2 pecl json post     state  absent         usr bin python  tt        coding  utf 8        (c) 2012  afterburn  http   github com afterburn     (c) 2013  aaron bull schaefer  aaron elasticdog com     (c) 2015  jonathan lestrelin  jonathan lestrelin gmail com        gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    install pear package    install pecl package    upgrade package    remove packages    package installed locally    get version installed locally (if any)    get version repository    return true indicate package installed locally     result version number comparison    determine package date     using loop case error  report package failed    query package first  see even need remove    package installed state    present    state    latest date skip    normalize state parameter ", "content": "#!/usr/bin/python -tt\n# -*- coding: utf-8 -*-\n\n# (c) 2012, Afterburn <http://github.com/afterburn>\n# (c) 2013, Aaron Bull Schaefer <aaron@elasticdog.com>\n# (c) 2015, Jonathan Lestrelin <jonathan.lestrelin@gmail.com>\n#\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: pear\nshort_description: Manage pear/pecl packages\ndescription:\n    - Manage PHP packages with the pear package manager.\nversion_added: 2.0\nauthor:\n    - \"'jonathan.lestrelin' <jonathan.lestrelin@gmail.com>\"\noptions:\n    name:\n        description:\n            - Name of the package to install, upgrade, or remove.\n        required: true\n\n    state:\n        description:\n            - Desired state of the package.\n        default: \"present\"\n        choices: [\"present\", \"absent\", \"latest\"]\n    executable:\n      description:\n        - Path to the pear executable\n      version_added: \"2.4\"\n'''\n\nEXAMPLES = '''\n# Install pear package\n- pear:\n    name: Net_URL2\n    state: present\n\n# Install pecl package\n- pear:\n    name: pecl/json_post\n    state: present\n\n# Upgrade package\n- pear:\n    name: Net_URL2\n    state: latest\n\n# Remove packages\n- pear:\n    name: Net_URL2,pecl/json_post\n    state: absent\n'''\n\nimport os\n\nfrom ansible.module_utils.basic import AnsibleModule\n\n\ndef get_local_version(pear_output):\n    \"\"\"Take pear remoteinfo output and get the installed version\"\"\"\n    lines = pear_output.split('\\n')\n    for line in lines:\n        if 'Installed ' in line:\n            installed = line.rsplit(None, 1)[-1].strip()\n            if installed == '-':\n                continue\n            return installed\n    return None\n\n\ndef _get_pear_path(module):\n    if module.params['executable'] and os.path.isfile(module.params['executable']):\n        result = module.params['executable']\n    else:\n        result = module.get_bin_path('pear', True, [module.params['executable']])\n    return result\n\n\ndef get_repository_version(pear_output):\n    \"\"\"Take pear remote-info output and get the latest version\"\"\"\n    lines = pear_output.split('\\n')\n    for line in lines:\n        if 'Latest ' in line:\n            return line.rsplit(None, 1)[-1].strip()\n    return None\n\n\ndef query_package(module, name, state=\"present\"):\n    \"\"\"Query the package status in both the local system and the repository.\n    Returns a boolean to indicate if the package is installed,\n    and a second boolean to indicate if the package is up-to-date.\"\"\"\n    if state == \"present\":\n        lcmd = \"%s info %s\" % (_get_pear_path(module), name)\n        lrc, lstdout, lstderr = module.run_command(lcmd, check_rc=False)\n        if lrc != 0:\n            # package is not installed locally\n            return False, False\n\n        rcmd = \"%s remote-info %s\" % (_get_pear_path(module), name)\n        rrc, rstdout, rstderr = module.run_command(rcmd, check_rc=False)\n\n        # get the version installed locally (if any)\n        lversion = get_local_version(rstdout)\n\n        # get the version in the repository\n        rversion = get_repository_version(rstdout)\n\n        if rrc == 0:\n            # Return True to indicate that the package is installed locally,\n            # and the result of the version number comparison\n            # to determine if the package is up-to-date.\n            return True, (lversion == rversion)\n\n        return False, False\n\n\ndef remove_packages(module, packages):\n    remove_c = 0\n    # Using a for loop in case of error, we can report the package that failed\n    for package in packages:\n        # Query the package first, to see if we even need to remove\n        installed, updated = query_package(module, package)\n        if not installed:\n            continue\n\n        cmd = \"%s uninstall %s\" % (_get_pear_path(module), package)\n        rc, stdout, stderr = module.run_command(cmd, check_rc=False)\n\n        if rc != 0:\n            module.fail_json(msg=\"failed to remove %s\" % (package))\n\n        remove_c += 1\n\n    if remove_c > 0:\n\n        module.exit_json(changed=True, msg=\"removed %s package(s)\" % remove_c)\n\n    module.exit_json(changed=False, msg=\"package(s) already absent\")\n\n\ndef install_packages(module, state, packages):\n    install_c = 0\n\n    for i, package in enumerate(packages):\n        # if the package is installed and state == present\n        # or state == latest and is up-to-date then skip\n        installed, updated = query_package(module, package)\n        if installed and (state == 'present' or (state == 'latest' and updated)):\n            continue\n\n        if state == 'present':\n            command = 'install'\n\n        if state == 'latest':\n            command = 'upgrade'\n\n        cmd = \"%s %s %s\" % (_get_pear_path(module), command, package)\n        rc, stdout, stderr = module.run_command(cmd, check_rc=False)\n\n        if rc != 0:\n            module.fail_json(msg=\"failed to install %s\" % (package))\n\n        install_c += 1\n\n    if install_c > 0:\n        module.exit_json(changed=True, msg=\"installed %s package(s)\" % (install_c))\n\n    module.exit_json(changed=False, msg=\"package(s) already installed\")\n\n\ndef check_packages(module, packages, state):\n    would_be_changed = []\n    for package in packages:\n        installed, updated = query_package(module, package)\n        if ((state in [\"present\", \"latest\"] and not installed) or\n                (state == \"absent\" and installed) or\n                (state == \"latest\" and not updated)):\n            would_be_changed.append(package)\n    if would_be_changed:\n        if state == \"absent\":\n            state = \"removed\"\n        module.exit_json(changed=True, msg=\"%s package(s) would be %s\" % (\n            len(would_be_changed), state))\n    else:\n        module.exit_json(change=False, msg=\"package(s) already %s\" % state)\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            name=dict(aliases=['pkg']),\n            state=dict(default='present', choices=['present', 'installed', \"latest\", 'absent', 'removed']),\n            executable=dict(default=None, required=False, type='path')),\n        required_one_of=[['name']],\n        supports_check_mode=True)\n\n    p = module.params\n\n    # normalize the state parameter\n    if p['state'] in ['present', 'installed']:\n        p['state'] = 'present'\n    elif p['state'] in ['absent', 'removed']:\n        p['state'] = 'absent'\n\n    if p['name']:\n        pkgs = p['name'].split(',')\n\n        pkg_files = []\n        for i, pkg in enumerate(pkgs):\n            pkg_files.append(None)\n\n        if module.check_mode:\n            check_packages(module, pkgs, p['state'])\n\n        if p['state'] in ['present', 'latest']:\n            install_packages(module, p['state'], pkgs)\n        elif p['state'] == 'absent':\n            remove_packages(module, pkgs)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "pear.py", "id": "51c94c63f14a6547bcbf03cecd4644b5", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/packaging/language/pear.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}