{"author": "sympy", "code": "from sympy import (\n    Float, Idx, IndexedBase, Integer, Matrix, MatrixSymbol, Range, sin, symbols, Tuple\n)\nfrom sympy.core.relational import Relational\nfrom sympy.utilities.pytest import raises\n\n\nfrom sympy.codegen.ast import (\n    Assignment, aug_assign, CodeBlock, For, Type, Variable, Pointer, Declaration,\n    AddAugmentedAssignment, SubAugmentedAssignment, MulAugmentedAssignment,\n    DivAugmentedAssignment, ModAugmentedAssignment, value_const, pointer_const,\n    integer, real, complex_, int8, uint8, float16 as f16, float32 as f32,\n    float64 as f64, float80 as f80, float128 as f128, complex64 as c64, complex128 as c128\n)\n\nx, y, z, t, x0 = symbols(\"x, y, z, t, x0\")\nn = symbols(\"n\", integer=True)\nA = MatrixSymbol('A', 3, 1)\nmat = Matrix([1, 2, 3])\nB = IndexedBase('B')\ni = Idx(\"i\", n)\n\n\ndef test_Assignment():\n    x, y = symbols(\"x, y\")\n    A = MatrixSymbol('A', 3, 1)\n    mat = Matrix([1, 2, 3])\n    B = IndexedBase('B')\n    n = symbols(\"n\", integer=True)\n    i = Idx(\"i\", n)\n    \n    Assignment(x, y)\n    Assignment(x, 0)\n    Assignment(A, mat)\n    Assignment(A[1,0], 0)\n    Assignment(A[1,0], x)\n    Assignment(B[i], x)\n    Assignment(B[i], 0)\n    a = Assignment(x, y)\n    assert a.func(*a.args) == a\n    \n    \n    raises(ValueError, lambda: Assignment(B[i], A))\n    raises(ValueError, lambda: Assignment(B[i], mat))\n    raises(ValueError, lambda: Assignment(x, mat))\n    raises(ValueError, lambda: Assignment(x, A))\n    raises(ValueError, lambda: Assignment(A[1,0], mat))\n    \n    raises(ValueError, lambda: Assignment(A, x))\n    raises(ValueError, lambda: Assignment(A, 0))\n    \n    raises(TypeError, lambda: Assignment(mat, A))\n    raises(TypeError, lambda: Assignment(0, x))\n    raises(TypeError, lambda: Assignment(x*x, 1))\n    raises(TypeError, lambda: Assignment(A + A, mat))\n    raises(TypeError, lambda: Assignment(B, 0))\n\n    assert Relational(x, y, ':=') == Assignment(x, y)\n\ndef test_AugAssign():\n    \n    aug_assign(x, '+', y)\n    aug_assign(x, '+', 0)\n    aug_assign(A, '+', mat)\n    aug_assign(A[1, 0], '+', 0)\n    aug_assign(A[1, 0], '+', x)\n    aug_assign(B[i], '+', x)\n    aug_assign(B[i], '+', 0)\n\n    a = aug_assign(x, '+', y)\n    b = AddAugmentedAssignment(x, y)\n    assert a.func(*a.args) == a == b\n\n    a = aug_assign(x, '-', y)\n    b = SubAugmentedAssignment(x, y)\n    assert a.func(*a.args) == a == b\n\n    a = aug_assign(x, '*', y)\n    b = MulAugmentedAssignment(x, y)\n    assert a.func(*a.args) == a == b\n\n    a = aug_assign(x, '/', y)\n    b = DivAugmentedAssignment(x, y)\n    assert a.func(*a.args) == a == b\n\n    a = aug_assign(x, '%', y)\n    b = ModAugmentedAssignment(x, y)\n    assert a.func(*a.args) == a == b\n\n    \n    \n    raises(ValueError, lambda: aug_assign(B[i], '+', A))\n    raises(ValueError, lambda: aug_assign(B[i], '+', mat))\n    raises(ValueError, lambda: aug_assign(x, '+', mat))\n    raises(ValueError, lambda: aug_assign(x, '+', A))\n    raises(ValueError, lambda: aug_assign(A[1, 0], '+', mat))\n    \n    raises(ValueError, lambda: aug_assign(A, '+', x))\n    raises(ValueError, lambda: aug_assign(A, '+', 0))\n    \n    raises(TypeError, lambda: aug_assign(mat, '+', A))\n    raises(TypeError, lambda: aug_assign(0, '+', x))\n    raises(TypeError, lambda: aug_assign(x * x, '+', 1))\n    raises(TypeError, lambda: aug_assign(A + A, '+', mat))\n    raises(TypeError, lambda: aug_assign(B, '+', 0))\n\ndef test_CodeBlock():\n    c = CodeBlock(Assignment(x, 1), Assignment(y, x + 1))\n    assert c.func(*c.args) == c\n\n    assert c.left_hand_sides == Tuple(x, y)\n    assert c.right_hand_sides == Tuple(1, x + 1)\n\ndef test_CodeBlock_topological_sort():\n    assignments = [\n        Assignment(x, y + z),\n        Assignment(z, 1),\n        Assignment(t, x),\n        Assignment(y, 2),\n        ]\n\n    ordered_assignments = [\n        \n        Assignment(z, 1),\n        Assignment(y, 2),\n        Assignment(x, y + z),\n        Assignment(t, x),\n        ]\n    c = CodeBlock.topological_sort(assignments)\n    assert c == CodeBlock(*ordered_assignments)\n\n    \n    invalid_assignments = [\n        Assignment(x, y + z),\n        Assignment(z, 1),\n        Assignment(y, x),\n        Assignment(y, 2),\n        ]\n\n    raises(ValueError, lambda: CodeBlock.topological_sort(invalid_assignments))\n\n    \n    invalid_assignments = [\n        Assignment(x, y)\n        ]\n\n    raises(ValueError, lambda: CodeBlock.topological_sort(invalid_assignments))\n\ndef test_CodeBlock_cse():\n    c = CodeBlock(\n        Assignment(y, 1),\n        Assignment(x, sin(y)),\n        Assignment(z, sin(y)),\n        Assignment(t, x*z),\n        )\n    assert c.cse() == CodeBlock(\n        Assignment(y, 1),\n        Assignment(x0, sin(y)),\n        Assignment(x, x0),\n        Assignment(z, x0),\n        Assignment(t, x*z),\n        )\n\n    raises(NotImplementedError, lambda: CodeBlock(Assignment(x, 1),\n        Assignment(y, 1), Assignment(y, 2)).cse())\n\ndef test_For():\n    f = For(n, Range(0, 3), (Assignment(A[n, 0], x + n), aug_assign(x, '+', y)))\n    f = For(n, (1, 2, 3, 4, 5), (Assignment(A[n, 0], x + n),))\n    assert f.func(*f.args) == f\n    raises(TypeError, lambda: For(n, x, (x + y,)))\n\n\ndef test_Type():\n    t = Type('MyType')\n    assert t.name == 'MyType'\n    assert str(t) == 'MyType'\n    assert repr(t) == \"Type(name=MyType)\"\n\n\ndef test_Type_eq():\n    t1 = Type('t1')\n    t2 = Type('t2')\n    assert t1 != t2\n    assert t1 == t1 and t2 == t2\n    t1b = Type('t1')\n    assert t1 == t1b\n    assert t2 != t1b\n\n\ndef test_Type__from_expr():\n    assert Type.from_expr(i) == integer\n    u = symbols('u', real=True)\n    assert Type.from_expr(u) == real\n    assert Type.from_expr(n) == integer\n    assert Type.from_expr(3) == integer\n    assert Type.from_expr(3.0) == real\n    assert Type.from_expr(3+1j) == complex_\n    raises(ValueError, lambda: Type.from_expr(sum))\n\n\ndef test_Type__cast_check__integers():\n    \n    raises(ValueError, lambda: integer.cast_check(3.5))\n    assert integer.cast_check('3') == 3\n    assert integer.cast_check(Float('3.0000000000000000000')) == 3\n    assert integer.cast_check(Float('3.0000000000000000001')) == 3  ?\n\n    \n    assert int8.cast_check(127.0) == 127\n    raises(ValueError, lambda: int8.cast_check(128))\n    assert int8.cast_check(-128) == -128\n    raises(ValueError, lambda: int8.cast_check(-129))\n\n    assert uint8.cast_check(0) == 0\n    assert uint8.cast_check(128) == 128\n    raises(ValueError, lambda: uint8.cast_check(256.0))\n    raises(ValueError, lambda: uint8.cast_check(-1))\n\n\ndef test_Variable():\n    v = Variable(x, type_=Type('real'))\n    assert v.symbol == x\n    assert v.type == real\n    assert v.value_const == False\n    w = Variable(y, {value_const}, f32)\n    assert w.symbol == y\n    assert w.type == f32\n    assert w.value_const\n    v_n = Variable(n, type_=Type.from_expr(n))\n    assert v_n.type == integer\n    v_i = Variable(i, type_=Type.from_expr(n))\n    assert v_i.type == integer\n\n    a_i = Variable.deduced(i)\n    assert a_i.type == integer\n\n\ndef test_Variable__deduced():\n    v_i = Variable.deduced(i)\n    assert v_i.type == integer\n\n\ndef test_Pointer():\n    p = Pointer(x)\n    assert p.symbol == x\n    assert p.type == None\n    assert not p.value_const\n    assert not p.pointer_const\n    u = symbols('u', real=True)\n    py = Pointer(u, {value_const, pointer_const}, Type.from_expr(u))\n    assert py.symbol is u\n    assert py.type == real\n    assert py.value_const\n    assert py.pointer_const\n\n\ndef test_Declaration():\n    u = symbols('u', real=True)\n    vu = Variable(u, type_=Type.from_expr(u))\n    assert Declaration(vu).variable.type == real\n    vn = Variable(n, type_=Type.from_expr(n))\n    assert Declaration(vn).variable.type == integer\n\n    vuc = Variable(u, {value_const}, Type.from_expr(u))\n    decl = Declaration(vuc, 3.0)\n    assert decl.variable == vuc\n    assert isinstance(decl.value, Float)\n    assert decl.value == 3.0\n\n    vy = Variable(y, type_=integer)\n    decl2 = Declaration(vy, 3)\n    assert decl2.variable == vy\n    assert decl2.value is Integer(3)\n\n    vi = Variable(i, type_=Type.from_expr(i))\n    decl3 = Declaration(vi, 3.0)\n    assert decl3.variable.type == integer\n    assert decl3.value == 3.0\n\n    decl4 = raises(ValueError, lambda: Declaration.deduced(n, 3.5, cast=True))\n\n\n\ndef test_Declaration__deduced():\n    assert Declaration.deduced(n).variable.type == integer\n    assert Declaration.deduced(z, 3).variable.type == integer\n    assert Declaration.deduced(z, 3.0).variable.type == real\n    assert Declaration.deduced(z, 3.0+1j).variable.type == complex_\n\n\ndef test_FloatType():\n    assert f16.dig == 3\n    assert f32.dig == 6\n    assert f64.dig == 15\n    assert f80.dig == 18\n    assert f128.dig == 33\n\n    assert f16.decimal_dig == 5\n    assert f32.decimal_dig == 9\n    assert f64.decimal_dig == 17\n    assert f80.decimal_dig == 21\n    assert f128.decimal_dig == 36\n\n    assert f16.max_exponent == 16\n    assert f32.max_exponent == 128\n    assert f64.max_exponent == 1024\n    assert f80.max_exponent == 16384\n    assert f128.max_exponent == 16384\n\n    assert f16.min_exponent == -13\n    assert f32.min_exponent == -125\n    assert f64.min_exponent == -1021\n    assert f80.min_exponent == -16381\n    assert f128.min_exponent == -16381\n\n    assert abs(f16.eps / Float('0.00097656', precision=16) - 1) < 0.1*10**-f16.dig\n    assert abs(f32.eps / Float('1.1920929e-07', precision=32) - 1) < 0.1*10**-f32.dig\n    assert abs(f64.eps / Float('2.2204460492503131e-16', precision=64) - 1) < 0.1*10**-f64.dig\n    assert abs(f80.eps / Float('1.08420217248550443401e-19', precision=80) - 1) < 0.1*10**-f80.dig\n    assert abs(f128.eps / Float(' 1.92592994438723585305597794258492732e-34', precision=128) - 1) < 0.1*10**-f128.dig\n\n    assert abs(f16.max / Float('65504', precision=16) - 1) < .1*10**-f16.dig\n    assert abs(f32.max / Float('3.40282347e+38', precision=32) - 1) < 0.1*10**-f32.dig\n    assert abs(f64.max / Float('1.79769313486231571e+308', precision=64) - 1) < 0.1*10**-f64.dig  # cf. np.finfo(np.float64).max\n    assert abs(f80.max / Float('1.18973149535723176502e+4932', precision=80) - 1) < 0.1*10**-f80.dig\n    assert abs(f128.max / Float('1.18973149535723176508575932662800702e+4932', precision=128) - 1) < 0.1*10**-f128.dig\n\n    # cf. np.finfo(np.float32).tiny\n    assert abs(f16.tiny / Float('6.1035e-05', precision=16) - 1) < 0.1*10**-f16.dig\n    assert abs(f32.tiny / Float('1.17549435e-38', precision=32) - 1) < 0.1*10**-f32.dig\n    assert abs(f64.tiny / Float('2.22507385850720138e-308', precision=64) - 1) < 0.1*10**-f64.dig\n    assert abs(f80.tiny / Float('3.36210314311209350626e-4932', precision=80) - 1) < 0.1*10**-f80.dig\n    assert abs(f128.tiny / Float('3.3621031431120935062626778173217526e-4932', precision=128) - 1) < 0.1*10**-f128.dig\n\n\ndef test_Type__cast_check__floating_point():\n    raises(ValueError, lambda: f32.cast_check(123.45678949))\n    raises(ValueError, lambda: f32.cast_check(12.345678949))\n    raises(ValueError, lambda: f32.cast_check(1.2345678949))\n    raises(ValueError, lambda: f32.cast_check(.12345678949))\n    assert abs(123.456789049 - f32.cast_check(123.456789049) - 4.9e-8) < 1e-8\n    assert abs(0.12345678904 - f32.cast_check(0.12345678904) - 4e-11) < 1e-11\n\n    dcm21 = Float('0.123456789012345670499')  \n    assert abs(dcm21 - f64.cast_check(dcm21) - 4.99e-19) < 1e-19\n\n    f80.cast_check(Float('0.12345678901234567890103', precision=88))\n    raises(ValueError, lambda: f80.cast_check(Float('0.12345678901234567890149', precision=88)))\n\n    v10 = 12345.67894\n    raises(ValueError, lambda: f32.cast_check(v10))\n    assert abs(Float(str(v10), precision=64+8) - f64.cast_check(v10)) < v10*1e-16\n\n    assert abs(f32.cast_check(2147483647) - 2147483650) < 1\n\n\ndef test_Type__cast_check__complex_floating_point():\n    val9_11 = 123.456789049 + 0.123456789049j\n    raises(ValueError, lambda: c64.cast_check(.12345678949 + .12345678949j))\n    assert abs(val9_11 - c64.cast_check(val9_11) - 4.9e-8) < 1e-8\n\n    dcm21 = Float('0.123456789012345670499') + 1e-20j  \n    assert abs(dcm21 - c128.cast_check(dcm21) - 4.99e-19) < 1e-19\n    v19 = Float('0.1234567890123456749') + 1j*Float('0.1234567890123456749')\n    raises(ValueError, lambda: c128.cast_check(v19))\n", "comments": "  here things show error    here test things show error    matrix scalar    scalar matrix    non atomic lhs    here things show error    here test things show error    matrix scalar    scalar matrix    non atomic lhs    note unrelated z 1 2 kept order    cycle    undefined variable    rounding    unintuitive maybe     range    cf  np finfo(np float64) max    cf  np finfo(np float32) tiny    21 decimals    21 decimals ", "content": "from sympy import (\n    Float, Idx, IndexedBase, Integer, Matrix, MatrixSymbol, Range, sin, symbols, Tuple\n)\nfrom sympy.core.relational import Relational\nfrom sympy.utilities.pytest import raises\n\n\nfrom sympy.codegen.ast import (\n    Assignment, aug_assign, CodeBlock, For, Type, Variable, Pointer, Declaration,\n    AddAugmentedAssignment, SubAugmentedAssignment, MulAugmentedAssignment,\n    DivAugmentedAssignment, ModAugmentedAssignment, value_const, pointer_const,\n    integer, real, complex_, int8, uint8, float16 as f16, float32 as f32,\n    float64 as f64, float80 as f80, float128 as f128, complex64 as c64, complex128 as c128\n)\n\nx, y, z, t, x0 = symbols(\"x, y, z, t, x0\")\nn = symbols(\"n\", integer=True)\nA = MatrixSymbol('A', 3, 1)\nmat = Matrix([1, 2, 3])\nB = IndexedBase('B')\ni = Idx(\"i\", n)\n\n\ndef test_Assignment():\n    x, y = symbols(\"x, y\")\n    A = MatrixSymbol('A', 3, 1)\n    mat = Matrix([1, 2, 3])\n    B = IndexedBase('B')\n    n = symbols(\"n\", integer=True)\n    i = Idx(\"i\", n)\n    # Here we just do things to show they don't error\n    Assignment(x, y)\n    Assignment(x, 0)\n    Assignment(A, mat)\n    Assignment(A[1,0], 0)\n    Assignment(A[1,0], x)\n    Assignment(B[i], x)\n    Assignment(B[i], 0)\n    a = Assignment(x, y)\n    assert a.func(*a.args) == a\n    # Here we test things to show that they error\n    # Matrix to scalar\n    raises(ValueError, lambda: Assignment(B[i], A))\n    raises(ValueError, lambda: Assignment(B[i], mat))\n    raises(ValueError, lambda: Assignment(x, mat))\n    raises(ValueError, lambda: Assignment(x, A))\n    raises(ValueError, lambda: Assignment(A[1,0], mat))\n    # Scalar to matrix\n    raises(ValueError, lambda: Assignment(A, x))\n    raises(ValueError, lambda: Assignment(A, 0))\n    # Non-atomic lhs\n    raises(TypeError, lambda: Assignment(mat, A))\n    raises(TypeError, lambda: Assignment(0, x))\n    raises(TypeError, lambda: Assignment(x*x, 1))\n    raises(TypeError, lambda: Assignment(A + A, mat))\n    raises(TypeError, lambda: Assignment(B, 0))\n\n    assert Relational(x, y, ':=') == Assignment(x, y)\n\ndef test_AugAssign():\n    # Here we just do things to show they don't error\n    aug_assign(x, '+', y)\n    aug_assign(x, '+', 0)\n    aug_assign(A, '+', mat)\n    aug_assign(A[1, 0], '+', 0)\n    aug_assign(A[1, 0], '+', x)\n    aug_assign(B[i], '+', x)\n    aug_assign(B[i], '+', 0)\n\n    a = aug_assign(x, '+', y)\n    b = AddAugmentedAssignment(x, y)\n    assert a.func(*a.args) == a == b\n\n    a = aug_assign(x, '-', y)\n    b = SubAugmentedAssignment(x, y)\n    assert a.func(*a.args) == a == b\n\n    a = aug_assign(x, '*', y)\n    b = MulAugmentedAssignment(x, y)\n    assert a.func(*a.args) == a == b\n\n    a = aug_assign(x, '/', y)\n    b = DivAugmentedAssignment(x, y)\n    assert a.func(*a.args) == a == b\n\n    a = aug_assign(x, '%', y)\n    b = ModAugmentedAssignment(x, y)\n    assert a.func(*a.args) == a == b\n\n    # Here we test things to show that they error\n    # Matrix to scalar\n    raises(ValueError, lambda: aug_assign(B[i], '+', A))\n    raises(ValueError, lambda: aug_assign(B[i], '+', mat))\n    raises(ValueError, lambda: aug_assign(x, '+', mat))\n    raises(ValueError, lambda: aug_assign(x, '+', A))\n    raises(ValueError, lambda: aug_assign(A[1, 0], '+', mat))\n    # Scalar to matrix\n    raises(ValueError, lambda: aug_assign(A, '+', x))\n    raises(ValueError, lambda: aug_assign(A, '+', 0))\n    # Non-atomic lhs\n    raises(TypeError, lambda: aug_assign(mat, '+', A))\n    raises(TypeError, lambda: aug_assign(0, '+', x))\n    raises(TypeError, lambda: aug_assign(x * x, '+', 1))\n    raises(TypeError, lambda: aug_assign(A + A, '+', mat))\n    raises(TypeError, lambda: aug_assign(B, '+', 0))\n\ndef test_CodeBlock():\n    c = CodeBlock(Assignment(x, 1), Assignment(y, x + 1))\n    assert c.func(*c.args) == c\n\n    assert c.left_hand_sides == Tuple(x, y)\n    assert c.right_hand_sides == Tuple(1, x + 1)\n\ndef test_CodeBlock_topological_sort():\n    assignments = [\n        Assignment(x, y + z),\n        Assignment(z, 1),\n        Assignment(t, x),\n        Assignment(y, 2),\n        ]\n\n    ordered_assignments = [\n        # Note that the unrelated z=1 and y=2 are kept in that order\n        Assignment(z, 1),\n        Assignment(y, 2),\n        Assignment(x, y + z),\n        Assignment(t, x),\n        ]\n    c = CodeBlock.topological_sort(assignments)\n    assert c == CodeBlock(*ordered_assignments)\n\n    # Cycle\n    invalid_assignments = [\n        Assignment(x, y + z),\n        Assignment(z, 1),\n        Assignment(y, x),\n        Assignment(y, 2),\n        ]\n\n    raises(ValueError, lambda: CodeBlock.topological_sort(invalid_assignments))\n\n    # Undefined variable\n    invalid_assignments = [\n        Assignment(x, y)\n        ]\n\n    raises(ValueError, lambda: CodeBlock.topological_sort(invalid_assignments))\n\ndef test_CodeBlock_cse():\n    c = CodeBlock(\n        Assignment(y, 1),\n        Assignment(x, sin(y)),\n        Assignment(z, sin(y)),\n        Assignment(t, x*z),\n        )\n    assert c.cse() == CodeBlock(\n        Assignment(y, 1),\n        Assignment(x0, sin(y)),\n        Assignment(x, x0),\n        Assignment(z, x0),\n        Assignment(t, x*z),\n        )\n\n    raises(NotImplementedError, lambda: CodeBlock(Assignment(x, 1),\n        Assignment(y, 1), Assignment(y, 2)).cse())\n\ndef test_For():\n    f = For(n, Range(0, 3), (Assignment(A[n, 0], x + n), aug_assign(x, '+', y)))\n    f = For(n, (1, 2, 3, 4, 5), (Assignment(A[n, 0], x + n),))\n    assert f.func(*f.args) == f\n    raises(TypeError, lambda: For(n, x, (x + y,)))\n\n\ndef test_Type():\n    t = Type('MyType')\n    assert t.name == 'MyType'\n    assert str(t) == 'MyType'\n    assert repr(t) == \"Type(name=MyType)\"\n\n\ndef test_Type_eq():\n    t1 = Type('t1')\n    t2 = Type('t2')\n    assert t1 != t2\n    assert t1 == t1 and t2 == t2\n    t1b = Type('t1')\n    assert t1 == t1b\n    assert t2 != t1b\n\n\ndef test_Type__from_expr():\n    assert Type.from_expr(i) == integer\n    u = symbols('u', real=True)\n    assert Type.from_expr(u) == real\n    assert Type.from_expr(n) == integer\n    assert Type.from_expr(3) == integer\n    assert Type.from_expr(3.0) == real\n    assert Type.from_expr(3+1j) == complex_\n    raises(ValueError, lambda: Type.from_expr(sum))\n\n\ndef test_Type__cast_check__integers():\n    # Rounding\n    raises(ValueError, lambda: integer.cast_check(3.5))\n    assert integer.cast_check('3') == 3\n    assert integer.cast_check(Float('3.0000000000000000000')) == 3\n    assert integer.cast_check(Float('3.0000000000000000001')) == 3  # unintuitive maybe?\n\n    # Range\n    assert int8.cast_check(127.0) == 127\n    raises(ValueError, lambda: int8.cast_check(128))\n    assert int8.cast_check(-128) == -128\n    raises(ValueError, lambda: int8.cast_check(-129))\n\n    assert uint8.cast_check(0) == 0\n    assert uint8.cast_check(128) == 128\n    raises(ValueError, lambda: uint8.cast_check(256.0))\n    raises(ValueError, lambda: uint8.cast_check(-1))\n\n\ndef test_Variable():\n    v = Variable(x, type_=Type('real'))\n    assert v.symbol == x\n    assert v.type == real\n    assert v.value_const == False\n    w = Variable(y, {value_const}, f32)\n    assert w.symbol == y\n    assert w.type == f32\n    assert w.value_const\n    v_n = Variable(n, type_=Type.from_expr(n))\n    assert v_n.type == integer\n    v_i = Variable(i, type_=Type.from_expr(n))\n    assert v_i.type == integer\n\n    a_i = Variable.deduced(i)\n    assert a_i.type == integer\n\n\ndef test_Variable__deduced():\n    v_i = Variable.deduced(i)\n    assert v_i.type == integer\n\n\ndef test_Pointer():\n    p = Pointer(x)\n    assert p.symbol == x\n    assert p.type == None\n    assert not p.value_const\n    assert not p.pointer_const\n    u = symbols('u', real=True)\n    py = Pointer(u, {value_const, pointer_const}, Type.from_expr(u))\n    assert py.symbol is u\n    assert py.type == real\n    assert py.value_const\n    assert py.pointer_const\n\n\ndef test_Declaration():\n    u = symbols('u', real=True)\n    vu = Variable(u, type_=Type.from_expr(u))\n    assert Declaration(vu).variable.type == real\n    vn = Variable(n, type_=Type.from_expr(n))\n    assert Declaration(vn).variable.type == integer\n\n    vuc = Variable(u, {value_const}, Type.from_expr(u))\n    decl = Declaration(vuc, 3.0)\n    assert decl.variable == vuc\n    assert isinstance(decl.value, Float)\n    assert decl.value == 3.0\n\n    vy = Variable(y, type_=integer)\n    decl2 = Declaration(vy, 3)\n    assert decl2.variable == vy\n    assert decl2.value is Integer(3)\n\n    vi = Variable(i, type_=Type.from_expr(i))\n    decl3 = Declaration(vi, 3.0)\n    assert decl3.variable.type == integer\n    assert decl3.value == 3.0\n\n    decl4 = raises(ValueError, lambda: Declaration.deduced(n, 3.5, cast=True))\n\n\n\ndef test_Declaration__deduced():\n    assert Declaration.deduced(n).variable.type == integer\n    assert Declaration.deduced(z, 3).variable.type == integer\n    assert Declaration.deduced(z, 3.0).variable.type == real\n    assert Declaration.deduced(z, 3.0+1j).variable.type == complex_\n\n\ndef test_FloatType():\n    assert f16.dig == 3\n    assert f32.dig == 6\n    assert f64.dig == 15\n    assert f80.dig == 18\n    assert f128.dig == 33\n\n    assert f16.decimal_dig == 5\n    assert f32.decimal_dig == 9\n    assert f64.decimal_dig == 17\n    assert f80.decimal_dig == 21\n    assert f128.decimal_dig == 36\n\n    assert f16.max_exponent == 16\n    assert f32.max_exponent == 128\n    assert f64.max_exponent == 1024\n    assert f80.max_exponent == 16384\n    assert f128.max_exponent == 16384\n\n    assert f16.min_exponent == -13\n    assert f32.min_exponent == -125\n    assert f64.min_exponent == -1021\n    assert f80.min_exponent == -16381\n    assert f128.min_exponent == -16381\n\n    assert abs(f16.eps / Float('0.00097656', precision=16) - 1) < 0.1*10**-f16.dig\n    assert abs(f32.eps / Float('1.1920929e-07', precision=32) - 1) < 0.1*10**-f32.dig\n    assert abs(f64.eps / Float('2.2204460492503131e-16', precision=64) - 1) < 0.1*10**-f64.dig\n    assert abs(f80.eps / Float('1.08420217248550443401e-19', precision=80) - 1) < 0.1*10**-f80.dig\n    assert abs(f128.eps / Float(' 1.92592994438723585305597794258492732e-34', precision=128) - 1) < 0.1*10**-f128.dig\n\n    assert abs(f16.max / Float('65504', precision=16) - 1) < .1*10**-f16.dig\n    assert abs(f32.max / Float('3.40282347e+38', precision=32) - 1) < 0.1*10**-f32.dig\n    assert abs(f64.max / Float('1.79769313486231571e+308', precision=64) - 1) < 0.1*10**-f64.dig  # cf. np.finfo(np.float64).max\n    assert abs(f80.max / Float('1.18973149535723176502e+4932', precision=80) - 1) < 0.1*10**-f80.dig\n    assert abs(f128.max / Float('1.18973149535723176508575932662800702e+4932', precision=128) - 1) < 0.1*10**-f128.dig\n\n    # cf. np.finfo(np.float32).tiny\n    assert abs(f16.tiny / Float('6.1035e-05', precision=16) - 1) < 0.1*10**-f16.dig\n    assert abs(f32.tiny / Float('1.17549435e-38', precision=32) - 1) < 0.1*10**-f32.dig\n    assert abs(f64.tiny / Float('2.22507385850720138e-308', precision=64) - 1) < 0.1*10**-f64.dig\n    assert abs(f80.tiny / Float('3.36210314311209350626e-4932', precision=80) - 1) < 0.1*10**-f80.dig\n    assert abs(f128.tiny / Float('3.3621031431120935062626778173217526e-4932', precision=128) - 1) < 0.1*10**-f128.dig\n\n\ndef test_Type__cast_check__floating_point():\n    raises(ValueError, lambda: f32.cast_check(123.45678949))\n    raises(ValueError, lambda: f32.cast_check(12.345678949))\n    raises(ValueError, lambda: f32.cast_check(1.2345678949))\n    raises(ValueError, lambda: f32.cast_check(.12345678949))\n    assert abs(123.456789049 - f32.cast_check(123.456789049) - 4.9e-8) < 1e-8\n    assert abs(0.12345678904 - f32.cast_check(0.12345678904) - 4e-11) < 1e-11\n\n    dcm21 = Float('0.123456789012345670499')  # 21 decimals\n    assert abs(dcm21 - f64.cast_check(dcm21) - 4.99e-19) < 1e-19\n\n    f80.cast_check(Float('0.12345678901234567890103', precision=88))\n    raises(ValueError, lambda: f80.cast_check(Float('0.12345678901234567890149', precision=88)))\n\n    v10 = 12345.67894\n    raises(ValueError, lambda: f32.cast_check(v10))\n    assert abs(Float(str(v10), precision=64+8) - f64.cast_check(v10)) < v10*1e-16\n\n    assert abs(f32.cast_check(2147483647) - 2147483650) < 1\n\n\ndef test_Type__cast_check__complex_floating_point():\n    val9_11 = 123.456789049 + 0.123456789049j\n    raises(ValueError, lambda: c64.cast_check(.12345678949 + .12345678949j))\n    assert abs(val9_11 - c64.cast_check(val9_11) - 4.9e-8) < 1e-8\n\n    dcm21 = Float('0.123456789012345670499') + 1e-20j  # 21 decimals\n    assert abs(dcm21 - c128.cast_check(dcm21) - 4.99e-19) < 1e-19\n    v19 = Float('0.1234567890123456749') + 1j*Float('0.1234567890123456749')\n    raises(ValueError, lambda: c128.cast_check(v19))\n", "description": "A computer algebra system written in pure Python", "file_name": "test_ast.py", "id": "fce1fa48e61315fb643d651ec5b2e088", "language": "Python", "project_name": "sympy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/sympy-sympy/sympy-sympy-205da79/sympy/codegen/tests/test_ast.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:35:56Z", "url": "https://github.com/sympy/sympy", "wiki": true}