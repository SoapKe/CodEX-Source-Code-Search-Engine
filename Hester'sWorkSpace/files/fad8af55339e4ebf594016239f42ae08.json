{"author": "tgalal", "code": "import threading, inspect, shlex\ntry:\n    import Queue\nexcept ImportError:\n    import queue as Queue\ntry:\n    import readline\nexcept ImportError:\n    import pyreadline as readline\n\nclass clicmd(object):\n    def __init__(self, desc, order = 0):\n        self.desc = desc\n        self.order = order\n    def __call__(self, fn):\n        fn.clidesc = self.desc\n        fn.cliorder = self.order\n        return fn\n\nclass Cli(object):\n    def __init__(self):\n        self.sentCache = {}\n        self.commands = {}\n        self.acceptingInput = False\n        self.lastPrompt = True\n        self.blockingQueue = Queue.Queue()\n\n        self._queuedCmds = []\n\n        readline.set_completer(self.complete)\n        readline.parse_and_bind('tab: complete')\n\n        members = inspect.getmembers(self, predicate = inspect.ismethod)\n        for m in members:\n            if hasattr(m[1], \"clidesc\"):\n                fname = m[0]\n                fn = m[1]\n                try:\n                    cmd, subcommand = fname.split('_')\n                except ValueError:\n                    cmd = fname\n                    subcommand = \"_\"\n\n\n                if not cmd in self.commands:\n                    self.commands[cmd] = {}\n\n                self.commands[cmd][subcommand] = {\n                   \"args\": inspect.getargspec(fn)[0][1:],\n                   \"optional\": len(inspect.getargspec(fn)[3]) if inspect.getargspec(fn)[3] else 0,\n                   \"desc\": fn.clidesc,\n                   \"fn\": fn,\n                   \"order\": fn.cliorder\n                }\n        ()\n        self.inputThread = threading.Thread(target = self.startInputThread)\n        self.inputThread.daemon = True\n\n    \n\n    def queueCmd(self, cmd):\n        self._queuedCmds.append(cmd)\n\n    def startInput(self):\n        self.inputThread.start()\n\n    \n    def print_usage(self):\n        line_width = 100\n        \n        outArr = []\n\n        def addToOut(ind, cmd):\n            if ind >= len(outArr):\n                outArr.extend([None] * (ind - len(outArr) + 1))\n\n\n            if outArr[ind] != None:\n                for i in range(len(outArr) - 1, 0, -1):\n                    if outArr[i] is None:\n                        outArr[i] = outArr[ind]\n                        outArr[ind] = cmd\n                        return\n                outArr.append(cmd)\n            else:\n                outArr[ind] = cmd\n\n        for cmd, subcommands in self.commands.items():\n            for subcmd, subcmdDetails in subcommands.items():\n                out = \"\"\n                out += (\"/%s \" % cmd).ljust(15)\n                out += (\"%s \" % subcmd if subcmd != \"_\" else \"\").ljust(15)\n                args = (\"%s \" % \" \".join([\"<%s>\" % c for c in subcmdDetails[\"args\"][0:len(subcmdDetails[\"args\"])-subcmdDetails[\"optional\"]]]))\n                args += (\"%s \" % \" \".join([\"[%s]\" % c for c in subcmdDetails[\"args\"][len(subcmdDetails[\"args\"])-subcmdDetails[\"optional\"]:]]))\n                out += args.ljust(30)\n                out += subcmdDetails[\"desc\"].ljust(20)\n                addToOut(subcmdDetails[\"order\"], out)\n\n        print(\"----------------------------------------------\")\n        print(\"\\n\" . join(outArr))\n        print(\"----------------------------------------------\")\n\n    def execCmd(self, cmdInput):\n        cmdInput = cmdInput.rstrip()\n\n        if not len(cmdInput) > 1:\n            return\n\n        if cmdInput.startswith(\"/\"):\n            cmdInput = cmdInput[1:]\n        else:\n            self.print_usage()\n            return\n\n        cmdInputDissect = [c for c in shlex.split(cmdInput) if c]\n\n        cmd = cmdInputDissect[0]\n\n        if not cmd in self.commands:\n            return self.print_usage()\n\n        cmdData = self.commands[cmd]\n        if len(cmdData) == 1 and \"_\" in cmdData:\n            subcmdData = cmdData[\"_\"]\n            args = cmdInputDissect[1:] if len(cmdInputDissect) > 1 else []\n        else:\n            args = cmdInputDissect[2:] if len(cmdInputDissect) > 2 else []\n            subcmd = cmdInputDissect[1] if len(cmdInputDissect) > 1 else \"\"\n            if subcmd not in cmdData:\n                return self.print_usage()\n\n            subcmdData = cmdData[subcmd]\n\n        targetFn = subcmdData[\"fn\"]\n        if len(subcmdData[\"args\"]) < len(args) or len(subcmdData[\"args\"]) - subcmdData[\"optional\"] > len(args):\n            return self.print_usage()\n\n        return self.doExecCmd(lambda :targetFn(*args))\n\n    def doExecCmd(self, fn):\n        return fn()\n\n\n    def startInputThread(self):\n        ()\n        \n        global input\n        try: input = raw_input\n        except NameError: pass\n\n        while(True):\n\n            cmd = self._queuedCmds.pop(0) if len(self._queuedCmds) else input(self.getPrompt()).strip()\n            wait = self.execCmd(cmd)\n            if wait:\n                self.acceptingInput = False\n                self.blockingQueue.get(True)\n                ()\n                ()\n            self.acceptingInput = True\n        ()\n\n    def getPrompt(self):\n        return \"[%s]:\" % (\"connected\" if self.connected else \"offline\")\n\n    def printPrompt(self):\n        #return \"Enter Message or command: (/%s)\" % \", /\".join(self.commandMappings)\n        print(self.getPrompt())\n\n    def output(self, message, tag = \"general\", prompt = True):\n        if self.acceptingInput == True and self.lastPrompt is True:\n            print(\"\")\n\n\n        self.lastPrompt = prompt\n\n        if tag is not None:\n            print(\"%s: %s\" % (tag, message))\n        else:\n            print(message)\n        if prompt:\n            self.printPrompt()\n\n    def complete(self, text, state):\n        if state == 0:\n            for cmd in self.commands:\n                if cmd.startswith(text) and cmd != text:\n                        return cmd\n\n    def notifyInputThread(self):\n        self.blockingQueue.put(1)\n\nif __name__ == \"__main__\":\n    c = Cli()\n    c.print_usage()\n", "comments": " self cv   threading condition()                      cmd input parsing                        cv acquire()    fix python 2 x    cv wait()   self inputthread wait()   cv release()   return  enter message command  (  s)          join(self commandmappings) ", "content": "import threading, inspect, shlex\ntry:\n    import Queue\nexcept ImportError:\n    import queue as Queue\ntry:\n    import readline\nexcept ImportError:\n    import pyreadline as readline\n\nclass clicmd(object):\n    def __init__(self, desc, order = 0):\n        self.desc = desc\n        self.order = order\n    def __call__(self, fn):\n        fn.clidesc = self.desc\n        fn.cliorder = self.order\n        return fn\n\nclass Cli(object):\n    def __init__(self):\n        self.sentCache = {}\n        self.commands = {}\n        self.acceptingInput = False\n        self.lastPrompt = True\n        self.blockingQueue = Queue.Queue()\n\n        self._queuedCmds = []\n\n        readline.set_completer(self.complete)\n        readline.parse_and_bind('tab: complete')\n\n        members = inspect.getmembers(self, predicate = inspect.ismethod)\n        for m in members:\n            if hasattr(m[1], \"clidesc\"):\n                fname = m[0]\n                fn = m[1]\n                try:\n                    cmd, subcommand = fname.split('_')\n                except ValueError:\n                    cmd = fname\n                    subcommand = \"_\"\n\n\n                if not cmd in self.commands:\n                    self.commands[cmd] = {}\n\n                self.commands[cmd][subcommand] = {\n                   \"args\": inspect.getargspec(fn)[0][1:],\n                   \"optional\": len(inspect.getargspec(fn)[3]) if inspect.getargspec(fn)[3] else 0,\n                   \"desc\": fn.clidesc,\n                   \"fn\": fn,\n                   \"order\": fn.cliorder\n                }\n        #self.cv = threading.Condition()\n        self.inputThread = threading.Thread(target = self.startInputThread)\n        self.inputThread.daemon = True\n\n    \n\n    def queueCmd(self, cmd):\n        self._queuedCmds.append(cmd)\n\n    def startInput(self):\n        self.inputThread.start()\n\n    ################### cmd input parsing ####################\n    def print_usage(self):\n        line_width = 100\n        \n        outArr = []\n\n        def addToOut(ind, cmd):\n            if ind >= len(outArr):\n                outArr.extend([None] * (ind - len(outArr) + 1))\n\n\n            if outArr[ind] != None:\n                for i in range(len(outArr) - 1, 0, -1):\n                    if outArr[i] is None:\n                        outArr[i] = outArr[ind]\n                        outArr[ind] = cmd\n                        return\n                outArr.append(cmd)\n            else:\n                outArr[ind] = cmd\n\n        for cmd, subcommands in self.commands.items():\n            for subcmd, subcmdDetails in subcommands.items():\n                out = \"\"\n                out += (\"/%s \" % cmd).ljust(15)\n                out += (\"%s \" % subcmd if subcmd != \"_\" else \"\").ljust(15)\n                args = (\"%s \" % \" \".join([\"<%s>\" % c for c in subcmdDetails[\"args\"][0:len(subcmdDetails[\"args\"])-subcmdDetails[\"optional\"]]]))\n                args += (\"%s \" % \" \".join([\"[%s]\" % c for c in subcmdDetails[\"args\"][len(subcmdDetails[\"args\"])-subcmdDetails[\"optional\"]:]]))\n                out += args.ljust(30)\n                out += subcmdDetails[\"desc\"].ljust(20)\n                addToOut(subcmdDetails[\"order\"], out)\n\n        print(\"----------------------------------------------\")\n        print(\"\\n\" . join(outArr))\n        print(\"----------------------------------------------\")\n\n    def execCmd(self, cmdInput):\n        cmdInput = cmdInput.rstrip()\n\n        if not len(cmdInput) > 1:\n            return\n\n        if cmdInput.startswith(\"/\"):\n            cmdInput = cmdInput[1:]\n        else:\n            self.print_usage()\n            return\n\n        cmdInputDissect = [c for c in shlex.split(cmdInput) if c]\n\n        cmd = cmdInputDissect[0]\n\n        if not cmd in self.commands:\n            return self.print_usage()\n\n        cmdData = self.commands[cmd]\n        if len(cmdData) == 1 and \"_\" in cmdData:\n            subcmdData = cmdData[\"_\"]\n            args = cmdInputDissect[1:] if len(cmdInputDissect) > 1 else []\n        else:\n            args = cmdInputDissect[2:] if len(cmdInputDissect) > 2 else []\n            subcmd = cmdInputDissect[1] if len(cmdInputDissect) > 1 else \"\"\n            if subcmd not in cmdData:\n                return self.print_usage()\n\n            subcmdData = cmdData[subcmd]\n\n        targetFn = subcmdData[\"fn\"]\n        if len(subcmdData[\"args\"]) < len(args) or len(subcmdData[\"args\"]) - subcmdData[\"optional\"] > len(args):\n            return self.print_usage()\n\n        return self.doExecCmd(lambda :targetFn(*args))\n\n    def doExecCmd(self, fn):\n        return fn()\n\n\n    def startInputThread(self):\n        #cv.acquire()\n        # Fix Python 2.x.\n        global input\n        try: input = raw_input\n        except NameError: pass\n\n        while(True):\n\n            cmd = self._queuedCmds.pop(0) if len(self._queuedCmds) else input(self.getPrompt()).strip()\n            wait = self.execCmd(cmd)\n            if wait:\n                self.acceptingInput = False\n                self.blockingQueue.get(True)\n                #cv.wait()\n                #self.inputThread.wait()\n            self.acceptingInput = True\n        #cv.release()\n\n    def getPrompt(self):\n        return \"[%s]:\" % (\"connected\" if self.connected else \"offline\")\n\n    def printPrompt(self):\n        #return \"Enter Message or command: (/%s)\" % \", /\".join(self.commandMappings)\n        print(self.getPrompt())\n\n    def output(self, message, tag = \"general\", prompt = True):\n        if self.acceptingInput == True and self.lastPrompt is True:\n            print(\"\")\n\n\n        self.lastPrompt = prompt\n\n        if tag is not None:\n            print(\"%s: %s\" % (tag, message))\n        else:\n            print(message)\n        if prompt:\n            self.printPrompt()\n\n    def complete(self, text, state):\n        if state == 0:\n            for cmd in self.commands:\n                if cmd.startswith(text) and cmd != text:\n                        return cmd\n\n    def notifyInputThread(self):\n        self.blockingQueue.put(1)\n\nif __name__ == \"__main__\":\n    c = Cli()\n    c.print_usage()\n", "description": "The python WhatsApp library", "file_name": "cli.py", "id": "fad8af55339e4ebf594016239f42ae08", "language": "Python", "project_name": "yowsup", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tgalal-yowsup/tgalal-yowsup-03795cc/yowsup/demos/cli/cli.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:01:40Z", "url": "https://github.com/tgalal/yowsup", "wiki": true}