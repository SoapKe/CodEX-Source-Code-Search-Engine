{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom odoo import api, fields, models, _\nfrom odoo.exceptions import UserError\n\n\nclass AccountAnalyticLine(models.Model):\n    _inherit = \"account.analytic.line\"\n\n    so_line = fields.Many2one('sale.order.line', string='Sales Order Line')\n\n    @api.model\n    def create(self, values):\n        result = super(AccountAnalyticLine, self).create(values)\n        result._sale_postprocess(values)\n        return result\n\n    @api.multi\n    def write(self, values):\n        \n        sale_order_lines = self.env['sale.order.line']\n        if 'so_line' in values:\n            sale_order_lines = self.sudo().mapped('so_line')\n        result = super(AccountAnalyticLine, self).write(values)\n        self._sale_postprocess(values, additional_so_lines=sale_order_lines)\n        return result\n\n    @api.multi\n    def unlink(self):\n        sale_order_lines = self.sudo().mapped('so_line')\n        res = super(AccountAnalyticLine, self).unlink()\n        sale_order_lines.with_context(sale_analytic_force_recompute=True)._analytic_compute_delivered_quantity()\n        return res\n\n    @api.model\n    def _sale_get_fields_delivered_qty(self):\n        \"\"\" Returns a list with the field impacting the delivered quantity on SO line. \"\"\"\n        return ['so_line', 'unit_amount', 'product_uom_id']\n\n    @api.multi\n    def _sale_postprocess(self, values, additional_so_lines=None):\n        if 'so_line' not in values:  \n            \n            self.filtered(lambda aal: aal.amount <= 0).with_context(sale_analytic_norecompute=True)._sale_determine_order_line()\n\n        if any(field_name in values for field_name in self._sale_get_fields_delivered_qty()):\n            if not self._context.get('sale_analytic_norecompute'):\n                so_lines = self.sudo().filtered(lambda aal: aal.so_line).mapped('so_line')\n                if additional_so_lines:\n                    so_lines |= additional_so_lines\n                so_lines.sudo()._analytic_compute_delivered_quantity()\n\n    # NOTE JEM: thoses method are used in vendor bills to reinvoice at cost (see test `test_cost_invoicing`)\n    \n\n    @api.multi\n    def _sale_get_invoice_price(self, order):\n        self.ensure_one()\n        if self.product_id.expense_policy == 'sales_price':\n            return self.product_id.with_context(\n                partner=order.partner_id.id,\n                date_order=order.date_order,\n                pricelist=order.pricelist_id.id,\n                uom=self.product_uom_id.id\n            ).price\n        if self.unit_amount == 0.0:\n            return 0.0\n\n        \n        \n        if self.currency_id and self.amount_currency and self.currency_id == order.currency_id:\n            return abs(self.amount_currency / self.unit_amount)\n\n        price_unit = abs(self.amount / self.unit_amount)\n        currency_id = self.company_id.currency_id\n        if currency_id and currency_id != order.currency_id:\n            price_unit = currency_id.compute(price_unit, order.currency_id)\n        return price_unit\n\n    @api.multi\n    def _sale_prepare_sale_order_line_values(self, order, price):\n        self.ensure_one()\n        last_so_line = self.env['sale.order.line'].search([('order_id', '=', order.id)], order='sequence desc', limit=1)\n        last_sequence = last_so_line.sequence + 1 if last_so_line else 100\n\n        fpos = order.fiscal_position_id or order.partner_id.property_account_position_id\n        taxes = fpos.map_tax(self.product_id.taxes_id, self.product_id, order.partner_id)\n\n        return {\n            'order_id': order.id,\n            'name': self.name,\n            'sequence': last_sequence,\n            'price_unit': price,\n            'tax_id': [x.id for x in taxes],\n            'discount': 0.0,\n            'product_id': self.product_id.id,\n            'product_uom': self.product_uom_id.id,\n            'product_uom_qty': 0.0,\n            'qty_delivered': self.unit_amount,\n        }\n\n    @api.multi\n    def _sale_determine_order(self):\n        mapping = {}\n        for analytic_line in self.sudo().filtered(lambda aal: not aal.so_line and aal.product_id and aal.product_id.expense_policy != 'no'):\n            sale_order = self.env['sale.order'].search([('analytic_account_id', '=', analytic_line.account_id.id), ('state', '=', 'sale')], limit=1)\n            if not sale_order:\n                sale_order = self.env['sale.order'].search([('analytic_account_id', '=', analytic_line.account_id.id)], limit=1)\n            if not sale_order:\n                continue\n            mapping[analytic_line.id] = sale_order\n        return mapping\n\n    @api.multi\n    def _sale_determine_order_line(self):\n        \"\"\" Automatically set the SO line on the analytic line, for the expense/vendor bills flow. It retrives\n            an existing line, or create a new one (upselling expenses).\n        \"\"\"\n        \n        sale_order_map = self._sale_determine_order()\n        \n        for analytic_line in self.sudo().filtered(lambda aal: not aal.so_line and aal.product_id and aal.product_id.expense_policy != 'no'):\n            sale_order = sale_order_map.get(analytic_line.id)\n            if not sale_order:\n                continue\n\n            if sale_order.state != 'sale':\n                raise UserError(_('The Sales Order %s linked to the Analytic Account must be validated before registering expenses.') % sale_order.name)\n\n            price = analytic_line._sale_get_invoice_price(sale_order)\n            so_line = None\n            if analytic_line.product_id.expense_policy == 'sales_price' and analytic_line.product_id.invoice_policy == 'delivery':\n                so_line = self.env['sale.order.line'].search([\n                    ('order_id', '=', sale_order.id),\n                    ('price_unit', '=', price),\n                    ('product_id', '=', self.product_id.id)\n                ], limit=1)\n\n            if not so_line:\n                \n                if sale_order.state != 'sale':\n                    raise UserError(_('The Sales Order %s linked to the Analytic Account must be validated before registering expenses.') % sale_order.name)\n                so_line_values = analytic_line._sale_prepare_sale_order_line_values(sale_order, price)\n                so_line = self.env['sale.order.line'].create(so_line_values)\n                so_line._compute_tax_id()\n            else:\n                so_line.write({'qty_delivered': so_line.qty_delivered + analytic_line.unit_amount})\n\n            if so_line:  # if so line found or created, then update AAL (this will trigger the recomputation of qty delivered on SO line)\n                analytic_line.with_context(sale_analytic_norecompute=True).write({'so_line': so_line.id})\n", "comments": "    returns list field impacting delivered quantity so line              return   line    unit amount    product uom id         api multi     def  sale postprocess(self  values  additional lines none)           line  values     allow force false value line               take aal expense vendor bill  meaning negative amount             self filtered(lambda aal  aal amount    0) context(sale analytic norecompute true)  sale determine order line()          any(field name values field name self  sale get fields delivered qty())              self  context get( sale analytic norecompute )                  lines   self sudo() filtered(lambda aal  aal line) mapped( line )                 additional lines                      lines    additional lines                 lines sudo()  analytic compute delivered quantity()        note jem  thoses method used vendor bills reinvoice cost (see test  test cost invoicing )       cleaning still necessary       api multi     def  sale get invoice price(self  order)          self ensure one()         self product id expense policy     sales price               return self product id context(                 partner order partner id id                  date order order date order                  pricelist order pricelist id id                  uom self product uom id id             ) price         self unit amount    0 0              return 0 0            prevent unnecessary currency conversion could impacted exchange rate           fluctuations         self currency id self amount currency self currency id    order currency id              return abs(self amount currency   self unit amount)          price unit   abs(self amount   self unit amount)         currency id   self company id currency id         currency id currency id    order currency id              price unit   currency id compute(price unit  order currency id)         return price unit       api multi     def  sale prepare sale order line values(self  order  price)          self ensure one()         last line   self env  sale order line   search( ( order id        order id)   order  sequence desc   limit 1)         last sequence   last line sequence   1 last line else 100          fpos   order fiscal position id order partner id property account position id         taxes   fpos map tax(self product id taxes id  self product id  order partner id)          return                order id   order id               name   self name               sequence   last sequence               price unit   price               tax id    x id x taxes                discount   0 0               product id   self product id id               product uom   self product uom id id               product uom qty   0 0               qty delivered   self unit amount                  api multi     def  sale determine order(self)          mapping              analytic line self sudo() filtered(lambda aal  aal line aal product id aal product id expense policy     )              sale order   self env  sale order   search( ( analytic account id        analytic line account id id)  ( state         sale )   limit 1)             sale order                  sale order   self env  sale order   search( ( analytic account id        analytic line account id id)   limit 1)             sale order                  continue             mapping analytic line id    sale order         return mapping       api multi     def  sale determine order line(self)              automatically set so line analytic line  expense vendor bills flow  it retrives             existing line  create new one (upselling expenses)                     coding  utf 8        part odoo  see license file full copyright licensing details     get current lines update qty wil required    allow force false value line    take aal expense vendor bill  meaning negative amount    note jem  thoses method used vendor bills reinvoice cost (see test  test cost invoicing )    cleaning still necessary    prevent unnecessary currency conversion could impacted exchange rate    fluctuations    determine so   first so open linked aa    determine line    generate new so line    line found created  update aal (this trigger recomputation qty delivered so line) ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom odoo import api, fields, models, _\nfrom odoo.exceptions import UserError\n\n\nclass AccountAnalyticLine(models.Model):\n    _inherit = \"account.analytic.line\"\n\n    so_line = fields.Many2one('sale.order.line', string='Sales Order Line')\n\n    @api.model\n    def create(self, values):\n        result = super(AccountAnalyticLine, self).create(values)\n        result._sale_postprocess(values)\n        return result\n\n    @api.multi\n    def write(self, values):\n        # get current so lines for which update qty wil be required\n        sale_order_lines = self.env['sale.order.line']\n        if 'so_line' in values:\n            sale_order_lines = self.sudo().mapped('so_line')\n        result = super(AccountAnalyticLine, self).write(values)\n        self._sale_postprocess(values, additional_so_lines=sale_order_lines)\n        return result\n\n    @api.multi\n    def unlink(self):\n        sale_order_lines = self.sudo().mapped('so_line')\n        res = super(AccountAnalyticLine, self).unlink()\n        sale_order_lines.with_context(sale_analytic_force_recompute=True)._analytic_compute_delivered_quantity()\n        return res\n\n    @api.model\n    def _sale_get_fields_delivered_qty(self):\n        \"\"\" Returns a list with the field impacting the delivered quantity on SO line. \"\"\"\n        return ['so_line', 'unit_amount', 'product_uom_id']\n\n    @api.multi\n    def _sale_postprocess(self, values, additional_so_lines=None):\n        if 'so_line' not in values:  # allow to force a False value for so_line\n            # only take the AAL from expense or vendor bill, meaning having a negative amount\n            self.filtered(lambda aal: aal.amount <= 0).with_context(sale_analytic_norecompute=True)._sale_determine_order_line()\n\n        if any(field_name in values for field_name in self._sale_get_fields_delivered_qty()):\n            if not self._context.get('sale_analytic_norecompute'):\n                so_lines = self.sudo().filtered(lambda aal: aal.so_line).mapped('so_line')\n                if additional_so_lines:\n                    so_lines |= additional_so_lines\n                so_lines.sudo()._analytic_compute_delivered_quantity()\n\n    # NOTE JEM: thoses method are used in vendor bills to reinvoice at cost (see test `test_cost_invoicing`)\n    # some cleaning are still necessary\n\n    @api.multi\n    def _sale_get_invoice_price(self, order):\n        self.ensure_one()\n        if self.product_id.expense_policy == 'sales_price':\n            return self.product_id.with_context(\n                partner=order.partner_id.id,\n                date_order=order.date_order,\n                pricelist=order.pricelist_id.id,\n                uom=self.product_uom_id.id\n            ).price\n        if self.unit_amount == 0.0:\n            return 0.0\n\n        # Prevent unnecessary currency conversion that could be impacted by exchange rate\n        # fluctuations\n        if self.currency_id and self.amount_currency and self.currency_id == order.currency_id:\n            return abs(self.amount_currency / self.unit_amount)\n\n        price_unit = abs(self.amount / self.unit_amount)\n        currency_id = self.company_id.currency_id\n        if currency_id and currency_id != order.currency_id:\n            price_unit = currency_id.compute(price_unit, order.currency_id)\n        return price_unit\n\n    @api.multi\n    def _sale_prepare_sale_order_line_values(self, order, price):\n        self.ensure_one()\n        last_so_line = self.env['sale.order.line'].search([('order_id', '=', order.id)], order='sequence desc', limit=1)\n        last_sequence = last_so_line.sequence + 1 if last_so_line else 100\n\n        fpos = order.fiscal_position_id or order.partner_id.property_account_position_id\n        taxes = fpos.map_tax(self.product_id.taxes_id, self.product_id, order.partner_id)\n\n        return {\n            'order_id': order.id,\n            'name': self.name,\n            'sequence': last_sequence,\n            'price_unit': price,\n            'tax_id': [x.id for x in taxes],\n            'discount': 0.0,\n            'product_id': self.product_id.id,\n            'product_uom': self.product_uom_id.id,\n            'product_uom_qty': 0.0,\n            'qty_delivered': self.unit_amount,\n        }\n\n    @api.multi\n    def _sale_determine_order(self):\n        mapping = {}\n        for analytic_line in self.sudo().filtered(lambda aal: not aal.so_line and aal.product_id and aal.product_id.expense_policy != 'no'):\n            sale_order = self.env['sale.order'].search([('analytic_account_id', '=', analytic_line.account_id.id), ('state', '=', 'sale')], limit=1)\n            if not sale_order:\n                sale_order = self.env['sale.order'].search([('analytic_account_id', '=', analytic_line.account_id.id)], limit=1)\n            if not sale_order:\n                continue\n            mapping[analytic_line.id] = sale_order\n        return mapping\n\n    @api.multi\n    def _sale_determine_order_line(self):\n        \"\"\" Automatically set the SO line on the analytic line, for the expense/vendor bills flow. It retrives\n            an existing line, or create a new one (upselling expenses).\n        \"\"\"\n        # determine SO : first SO open linked to AA\n        sale_order_map = self._sale_determine_order()\n        # determine so line\n        for analytic_line in self.sudo().filtered(lambda aal: not aal.so_line and aal.product_id and aal.product_id.expense_policy != 'no'):\n            sale_order = sale_order_map.get(analytic_line.id)\n            if not sale_order:\n                continue\n\n            if sale_order.state != 'sale':\n                raise UserError(_('The Sales Order %s linked to the Analytic Account must be validated before registering expenses.') % sale_order.name)\n\n            price = analytic_line._sale_get_invoice_price(sale_order)\n            so_line = None\n            if analytic_line.product_id.expense_policy == 'sales_price' and analytic_line.product_id.invoice_policy == 'delivery':\n                so_line = self.env['sale.order.line'].search([\n                    ('order_id', '=', sale_order.id),\n                    ('price_unit', '=', price),\n                    ('product_id', '=', self.product_id.id)\n                ], limit=1)\n\n            if not so_line:\n                # generate a new SO line\n                if sale_order.state != 'sale':\n                    raise UserError(_('The Sales Order %s linked to the Analytic Account must be validated before registering expenses.') % sale_order.name)\n                so_line_values = analytic_line._sale_prepare_sale_order_line_values(sale_order, price)\n                so_line = self.env['sale.order.line'].create(so_line_values)\n                so_line._compute_tax_id()\n            else:\n                so_line.write({'qty_delivered': so_line.qty_delivered + analytic_line.unit_amount})\n\n            if so_line:  # if so line found or created, then update AAL (this will trigger the recomputation of qty delivered on SO line)\n                analytic_line.with_context(sale_analytic_norecompute=True).write({'so_line': so_line.id})\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "analytic.py", "id": "3732a2cc978fd49569b72a4292961d44", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/sale/models/analytic.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}