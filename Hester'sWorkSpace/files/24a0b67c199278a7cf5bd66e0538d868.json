{"author": "django", "code": "\nfrom operator import attrgetter\n\n\nclass BaseOrderWithRespectToTests:\n    \n    Answer = None\n    Post = None\n    Question = None\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.q1 = cls.Question.objects.create(text=\"Which Beatle starts with the letter 'R'?\")\n        cls.Answer.objects.create(text=\"John\", question=cls.q1)\n        cls.Answer.objects.create(text=\"Paul\", question=cls.q1)\n        cls.Answer.objects.create(text=\"George\", question=cls.q1)\n        cls.Answer.objects.create(text=\"Ringo\", question=cls.q1)\n\n    def test_default_to_insertion_order(self):\n        \n        self.assertQuerysetEqual(\n            self.q1.answer_set.all(), [\n                \"John\", \"Paul\", \"George\", \"Ringo\",\n            ],\n            attrgetter(\"text\"),\n        )\n\n    def test_previous_and_next_in_order(self):\n        \n        \n        a1 = self.q1.answer_set.all()[0]\n        self.assertEqual(a1.text, \"John\")\n        self.assertEqual(a1.get_next_in_order().text, \"Paul\")\n\n        a2 = list(self.q1.answer_set.all())[-1]\n        self.assertEqual(a2.text, \"Ringo\")\n        self.assertEqual(a2.get_previous_in_order().text, \"George\")\n\n    def test_item_ordering(self):\n        \n        a1 = self.q1.answer_set.all()[1]\n        id_list = [o.pk for o in self.q1.answer_set.all()]\n        self.assertSequenceEqual(a1.question.get_answer_order(), id_list)\n\n        \n        \n        a2 = self.Answer.objects.create(text=\"Number five\", question=self.q1)\n        self.assertEqual(list(a1.question.get_answer_order()), list(a2.question.get_answer_order()))\n\n    def test_change_ordering(self):\n        \n        a = self.Answer.objects.create(text=\"Number five\", question=self.q1)\n\n        \n        id_list = [o.pk for o in self.q1.answer_set.all()]\n        x = id_list.pop()\n        id_list.insert(-1, x)\n\n        \n        self.assertNotEqual(list(a.question.get_answer_order()), id_list)\n\n        \n        \n        a.question.set_answer_order(id_list)\n        self.assertQuerysetEqual(\n            self.q1.answer_set.all(), [\n                \"John\", \"Paul\", \"George\", \"Number five\", \"Ringo\"\n            ],\n            attrgetter(\"text\")\n        )\n\n    def test_recursive_ordering(self):\n        p1 = self.Post.objects.create(title=\"1\")\n        p2 = self.Post.objects.create(title=\"2\")\n        p1_1 = self.Post.objects.create(title=\"1.1\", parent=p1)\n        p1_2 = self.Post.objects.create(title=\"1.2\", parent=p1)\n        self.Post.objects.create(title=\"2.1\", parent=p2)\n        p1_3 = self.Post.objects.create(title=\"1.3\", parent=p1)\n        self.assertSequenceEqual(p1.get_post_order(), [p1_1.pk, p1_2.pk, p1_3.pk])\n", "comments": "    the tests shared contenttypes tests import reference models directly  subclasses inherit django test testcase         hook allow subclasses run tests alternate models     answers always ordered order inserted     we retrieve answers related particular object     order created  particular object     we retrieve ordering queryset particular item     it matter answer use check order     always     the ordering altered    swap last two items order list    by default  ordering different swapped version    change ordering swapped version      changes ordering queryset  ", "content": "\"\"\"\nThe tests are shared with contenttypes_tests and so shouldn't import or\nreference any models directly. Subclasses should inherit django.test.TestCase.\n\"\"\"\nfrom operator import attrgetter\n\n\nclass BaseOrderWithRespectToTests:\n    # Hook to allow subclasses to run these tests with alternate models.\n    Answer = None\n    Post = None\n    Question = None\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.q1 = cls.Question.objects.create(text=\"Which Beatle starts with the letter 'R'?\")\n        cls.Answer.objects.create(text=\"John\", question=cls.q1)\n        cls.Answer.objects.create(text=\"Paul\", question=cls.q1)\n        cls.Answer.objects.create(text=\"George\", question=cls.q1)\n        cls.Answer.objects.create(text=\"Ringo\", question=cls.q1)\n\n    def test_default_to_insertion_order(self):\n        # Answers will always be ordered in the order they were inserted.\n        self.assertQuerysetEqual(\n            self.q1.answer_set.all(), [\n                \"John\", \"Paul\", \"George\", \"Ringo\",\n            ],\n            attrgetter(\"text\"),\n        )\n\n    def test_previous_and_next_in_order(self):\n        # We can retrieve the answers related to a particular object, in the\n        # order they were created, once we have a particular object.\n        a1 = self.q1.answer_set.all()[0]\n        self.assertEqual(a1.text, \"John\")\n        self.assertEqual(a1.get_next_in_order().text, \"Paul\")\n\n        a2 = list(self.q1.answer_set.all())[-1]\n        self.assertEqual(a2.text, \"Ringo\")\n        self.assertEqual(a2.get_previous_in_order().text, \"George\")\n\n    def test_item_ordering(self):\n        # We can retrieve the ordering of the queryset from a particular item.\n        a1 = self.q1.answer_set.all()[1]\n        id_list = [o.pk for o in self.q1.answer_set.all()]\n        self.assertSequenceEqual(a1.question.get_answer_order(), id_list)\n\n        # It doesn't matter which answer we use to check the order, it will\n        # always be the same.\n        a2 = self.Answer.objects.create(text=\"Number five\", question=self.q1)\n        self.assertEqual(list(a1.question.get_answer_order()), list(a2.question.get_answer_order()))\n\n    def test_change_ordering(self):\n        # The ordering can be altered\n        a = self.Answer.objects.create(text=\"Number five\", question=self.q1)\n\n        # Swap the last two items in the order list\n        id_list = [o.pk for o in self.q1.answer_set.all()]\n        x = id_list.pop()\n        id_list.insert(-1, x)\n\n        # By default, the ordering is different from the swapped version\n        self.assertNotEqual(list(a.question.get_answer_order()), id_list)\n\n        # Change the ordering to the swapped version -\n        # this changes the ordering of the queryset.\n        a.question.set_answer_order(id_list)\n        self.assertQuerysetEqual(\n            self.q1.answer_set.all(), [\n                \"John\", \"Paul\", \"George\", \"Number five\", \"Ringo\"\n            ],\n            attrgetter(\"text\")\n        )\n\n    def test_recursive_ordering(self):\n        p1 = self.Post.objects.create(title=\"1\")\n        p2 = self.Post.objects.create(title=\"2\")\n        p1_1 = self.Post.objects.create(title=\"1.1\", parent=p1)\n        p1_2 = self.Post.objects.create(title=\"1.2\", parent=p1)\n        self.Post.objects.create(title=\"2.1\", parent=p2)\n        p1_3 = self.Post.objects.create(title=\"1.3\", parent=p1)\n        self.assertSequenceEqual(p1.get_post_order(), [p1_1.pk, p1_2.pk, p1_3.pk])\n", "description": "The Web framework for perfectionists with deadlines.", "file_name": "base_tests.py", "id": "24a0b67c199278a7cf5bd66e0538d868", "language": "Python", "project_name": "django", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/django-django/django-django-acfc650/tests/order_with_respect_to/base_tests.py", "save_time": "", "source": "", "update_at": "2018-03-14T02:00:36Z", "url": "https://github.com/django/django", "wiki": false}