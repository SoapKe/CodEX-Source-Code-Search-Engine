{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport re\nimport itertools\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    ExtractorError,\n    float_or_none,\n    int_or_none,\n    sanitized_Request,\n    urlencode_postdata,\n)\n\n\nclass BambuserIE(InfoExtractor):\n    IE_NAME = 'bambuser'\n    _VALID_URL = r'https?://bambuser\\.com/v/(?P<id>\\d+)'\n    _API_KEY = '005f64509e19a868399060af746a00aa'\n    _LOGIN_URL = 'https://bambuser.com/user'\n    _NETRC_MACHINE = 'bambuser'\n\n    _TEST = {\n        'url': 'http://bambuser.com/v/4050584',\n        \n        \n        'info_dict': {\n            'id': '4050584',\n            'ext': 'flv',\n            'title': 'Education engineering days - lightning talks',\n            'duration': 3741,\n            'uploader': 'pixelversity',\n            'uploader_id': '344706',\n            'timestamp': 1382976692,\n            'upload_date': '20131028',\n            'view_count': int,\n        },\n        'params': {\n            \n            \n            'skip_download': True,\n        },\n    }\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n\n        login_form = {\n            'form_id': 'user_login',\n            'op': 'Log in',\n            'name': username,\n            'pass': password,\n        }\n\n        request = sanitized_Request(\n            self._LOGIN_URL, urlencode_postdata(login_form))\n        request.add_header('Referer', self._LOGIN_URL)\n        response = self._download_webpage(\n            request, None, 'Logging in')\n\n        login_error = self._html_search_regex(\n            r'(?s)<div class=\"messages error\">(.+?)</div>',\n            response, 'login error', default=None)\n        if login_error:\n            raise ExtractorError(\n                'Unable to login: %s' % login_error, expected=True)\n\n    def _real_initialize(self):\n        self._login()\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        info = self._download_json(\n            'http://player-c.api.bambuser.com/getVideo.json?api_key=%s&vid=%s'\n            % (self._API_KEY, video_id), video_id)\n\n        error = info.get('error')\n        if error:\n            raise ExtractorError(\n                '%s returned error: %s' % (self.IE_NAME, error), expected=True)\n\n        result = info['result']\n\n        return {\n            'id': video_id,\n            'title': result['title'],\n            'url': result['url'],\n            'thumbnail': result.get('preview'),\n            'duration': int_or_none(result.get('length')),\n            'uploader': result.get('username'),\n            'uploader_id': compat_str(result.get('owner', {}).get('uid')),\n            'timestamp': int_or_none(result.get('created')),\n            'fps': float_or_none(result.get('framerate')),\n            'view_count': int_or_none(result.get('views_total')),\n            'comment_count': int_or_none(result.get('comment_count')),\n        }\n\n\nclass BambuserChannelIE(InfoExtractor):\n    IE_NAME = 'bambuser:channel'\n    _VALID_URL = r'https?://bambuser\\.com/channel/(?P<user>.*?)(?:/|\n    \n    _STEP = 50\n    _TEST = {\n        'url': 'http://bambuser.com/channel/pixelversity',\n        'info_dict': {\n            'title': 'pixelversity',\n        },\n        'playlist_mincount': 60,\n    }\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        user = mobj.group('user')\n        urls = []\n        last_id = ''\n        for i in itertools.count(1):\n            req_url = (\n                'http://bambuser.com/xhr-api/index.php?username={user}'\n                '&sort=created&access_mode=0%2C1%2C2&limit={count}'\n                '&method=broadcast&format=json&vid_older_than={last}'\n            ).format(user=user, count=self._STEP, last=last_id)\n            req = sanitized_Request(req_url)\n            \n            req.add_header('Referer', 'http://bambuser.com/channel/%s' % user)\n            data = self._download_json(\n                req, user, 'Downloading page %d' % i)\n            results = data['result']\n            if not results:\n                break\n            last_id = results[-1]['vid']\n            urls.extend(self.url_result(v['page'], 'Bambuser') for v in results)\n\n        return {\n            '_type': 'playlist',\n            'title': user,\n            'entries': urls,\n        }\n", "comments": "# MD5 seems to be flaky, see https://travis-ci.org/rg3/youtube-dl/jobs/14051016#L388\n# 'md5': 'fba8f7693e48fd4e8641b3fd5539a641',\n# It doesn't respect the 'Range' header, it would download the whole video\n# caused the travis builds to fail: https://travis-ci.org/rg3/youtube-dl/jobs/14493845#L59\n#|\\?|$)'\n# The maximum number we can get with each request\n# Without setting this header, we wouldn't get any result\n", "content": "from __future__ import unicode_literals\n\nimport re\nimport itertools\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    ExtractorError,\n    float_or_none,\n    int_or_none,\n    sanitized_Request,\n    urlencode_postdata,\n)\n\n\nclass BambuserIE(InfoExtractor):\n    IE_NAME = 'bambuser'\n    _VALID_URL = r'https?://bambuser\\.com/v/(?P<id>\\d+)'\n    _API_KEY = '005f64509e19a868399060af746a00aa'\n    _LOGIN_URL = 'https://bambuser.com/user'\n    _NETRC_MACHINE = 'bambuser'\n\n    _TEST = {\n        'url': 'http://bambuser.com/v/4050584',\n        # MD5 seems to be flaky, see https://travis-ci.org/rg3/youtube-dl/jobs/14051016#L388\n        # 'md5': 'fba8f7693e48fd4e8641b3fd5539a641',\n        'info_dict': {\n            'id': '4050584',\n            'ext': 'flv',\n            'title': 'Education engineering days - lightning talks',\n            'duration': 3741,\n            'uploader': 'pixelversity',\n            'uploader_id': '344706',\n            'timestamp': 1382976692,\n            'upload_date': '20131028',\n            'view_count': int,\n        },\n        'params': {\n            # It doesn't respect the 'Range' header, it would download the whole video\n            # caused the travis builds to fail: https://travis-ci.org/rg3/youtube-dl/jobs/14493845#L59\n            'skip_download': True,\n        },\n    }\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n\n        login_form = {\n            'form_id': 'user_login',\n            'op': 'Log in',\n            'name': username,\n            'pass': password,\n        }\n\n        request = sanitized_Request(\n            self._LOGIN_URL, urlencode_postdata(login_form))\n        request.add_header('Referer', self._LOGIN_URL)\n        response = self._download_webpage(\n            request, None, 'Logging in')\n\n        login_error = self._html_search_regex(\n            r'(?s)<div class=\"messages error\">(.+?)</div>',\n            response, 'login error', default=None)\n        if login_error:\n            raise ExtractorError(\n                'Unable to login: %s' % login_error, expected=True)\n\n    def _real_initialize(self):\n        self._login()\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        info = self._download_json(\n            'http://player-c.api.bambuser.com/getVideo.json?api_key=%s&vid=%s'\n            % (self._API_KEY, video_id), video_id)\n\n        error = info.get('error')\n        if error:\n            raise ExtractorError(\n                '%s returned error: %s' % (self.IE_NAME, error), expected=True)\n\n        result = info['result']\n\n        return {\n            'id': video_id,\n            'title': result['title'],\n            'url': result['url'],\n            'thumbnail': result.get('preview'),\n            'duration': int_or_none(result.get('length')),\n            'uploader': result.get('username'),\n            'uploader_id': compat_str(result.get('owner', {}).get('uid')),\n            'timestamp': int_or_none(result.get('created')),\n            'fps': float_or_none(result.get('framerate')),\n            'view_count': int_or_none(result.get('views_total')),\n            'comment_count': int_or_none(result.get('comment_count')),\n        }\n\n\nclass BambuserChannelIE(InfoExtractor):\n    IE_NAME = 'bambuser:channel'\n    _VALID_URL = r'https?://bambuser\\.com/channel/(?P<user>.*?)(?:/|#|\\?|$)'\n    # The maximum number we can get with each request\n    _STEP = 50\n    _TEST = {\n        'url': 'http://bambuser.com/channel/pixelversity',\n        'info_dict': {\n            'title': 'pixelversity',\n        },\n        'playlist_mincount': 60,\n    }\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        user = mobj.group('user')\n        urls = []\n        last_id = ''\n        for i in itertools.count(1):\n            req_url = (\n                'http://bambuser.com/xhr-api/index.php?username={user}'\n                '&sort=created&access_mode=0%2C1%2C2&limit={count}'\n                '&method=broadcast&format=json&vid_older_than={last}'\n            ).format(user=user, count=self._STEP, last=last_id)\n            req = sanitized_Request(req_url)\n            # Without setting this header, we wouldn't get any result\n            req.add_header('Referer', 'http://bambuser.com/channel/%s' % user)\n            data = self._download_json(\n                req, user, 'Downloading page %d' % i)\n            results = data['result']\n            if not results:\n                break\n            last_id = results[-1]['vid']\n            urls.extend(self.url_result(v['page'], 'Bambuser') for v in results)\n\n        return {\n            '_type': 'playlist',\n            'title': user,\n            'entries': urls,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "bambuser.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/bambuser.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}