{"author": "django", "code": "from unittest.mock import MagicMock\n\nfrom django.db import DEFAULT_DB_ALIAS, connection, connections\nfrom django.db.backends.base.base import BaseDatabaseWrapper\nfrom django.test import SimpleTestCase, TestCase\n\nfrom ..models import Square\n\n\nclass DatabaseWrapperTests(SimpleTestCase):\n\n    def test_initialization_class_attributes(self):\n        \n        conn = connections[DEFAULT_DB_ALIAS]\n        conn_class = type(conn)\n        attr_names = [\n            ('client_class', 'client'),\n            ('creation_class', 'creation'),\n            ('features_class', 'features'),\n            ('introspection_class', 'introspection'),\n            ('ops_class', 'ops'),\n            ('validation_class', 'validation'),\n        ]\n        for class_attr_name, instance_attr_name in attr_names:\n            class_attr_value = getattr(conn_class, class_attr_name)\n            self.assertIsNotNone(class_attr_value)\n            instance_attr_value = getattr(conn, instance_attr_name)\n            self.assertIsInstance(instance_attr_value, class_attr_value)\n\n    def test_initialization_display_name(self):\n        self.assertEqual(BaseDatabaseWrapper.display_name, 'unknown')\n        self.assertNotEqual(connection.display_name, 'unknown')\n\n\nclass ExecuteWrapperTests(TestCase):\n\n    @staticmethod\n    def call_execute(connection, params=None):\n        ret_val = '1' if params is None else '%s'\n        sql = 'SELECT ' + ret_val + connection.features.bare_select_suffix\n        with connection.cursor() as cursor:\n            cursor.execute(sql, params)\n\n    def call_executemany(self, connection, params=None):\n        # executemany() must use an update query. Make sure it does nothing\n        \n        sql = 'DELETE FROM {} WHERE 0=1 AND 0=%s'.format(Square._meta.db_table)\n        if params is None:\n            params = [(i,) for i in range(3)]\n        with connection.cursor() as cursor:\n            cursor.executemany(sql, params)\n\n    @staticmethod\n    def mock_wrapper():\n        return MagicMock(side_effect=lambda execute, *args: execute(*args))\n\n    def test_wrapper_invoked(self):\n        wrapper = self.mock_wrapper()\n        with connection.execute_wrapper(wrapper):\n            self.call_execute(connection)\n        self.assertTrue(wrapper.called)\n        (_, sql, params, many, context), _ = wrapper.call_args\n        self.assertIn('SELECT', sql)\n        self.assertIsNone(params)\n        self.assertIs(many, False)\n        self.assertEqual(context['connection'], connection)\n\n    def test_wrapper_invoked_many(self):\n        wrapper = self.mock_wrapper()\n        with connection.execute_wrapper(wrapper):\n            self.call_executemany(connection)\n        self.assertTrue(wrapper.called)\n        (_, sql, param_list, many, context), _ = wrapper.call_args\n        self.assertIn('DELETE', sql)\n        self.assertIsInstance(param_list, (list, tuple))\n        self.assertIs(many, True)\n        self.assertEqual(context['connection'], connection)\n\n    def test_database_queried(self):\n        wrapper = self.mock_wrapper()\n        with connection.execute_wrapper(wrapper):\n            with connection.cursor() as cursor:\n                sql = 'SELECT 17' + connection.features.bare_select_suffix\n                cursor.execute(sql)\n                seventeen = cursor.fetchall()\n                self.assertEqual(list(seventeen), [(17,)])\n            self.call_executemany(connection)\n\n    def test_nested_wrapper_invoked(self):\n        outer_wrapper = self.mock_wrapper()\n        inner_wrapper = self.mock_wrapper()\n        with connection.execute_wrapper(outer_wrapper), connection.execute_wrapper(inner_wrapper):\n            self.call_execute(connection)\n            self.assertEqual(inner_wrapper.call_count, 1)\n            self.call_executemany(connection)\n            self.assertEqual(inner_wrapper.call_count, 2)\n\n    def test_outer_wrapper_blocks(self):\n        def blocker(*args):\n            pass\n        wrapper = self.mock_wrapper()\n        c = connection  \n        with c.execute_wrapper(wrapper), c.execute_wrapper(blocker), c.execute_wrapper(wrapper):\n            with c.cursor() as cursor:\n                cursor.execute(\"The database never sees this\")\n                self.assertEqual(wrapper.call_count, 1)\n                cursor.executemany(\"The database never sees this %s\", [(\"either\",)])\n                self.assertEqual(wrapper.call_count, 2)\n\n    def test_wrapper_gets_sql(self):\n        wrapper = self.mock_wrapper()\n        sql = \"SELECT 'aloha'\" + connection.features.bare_select_suffix\n        with connection.execute_wrapper(wrapper), connection.cursor() as cursor:\n            cursor.execute(sql)\n        (_, reported_sql, _, _, _), _ = wrapper.call_args\n        self.assertEqual(reported_sql, sql)\n\n    def test_wrapper_connection_specific(self):\n        wrapper = self.mock_wrapper()\n        with connections['other'].execute_wrapper(wrapper):\n            self.assertEqual(connections['other'].execute_wrappers, [wrapper])\n            self.call_execute(connection)\n        self.assertFalse(wrapper.called)\n        self.assertEqual(connection.execute_wrappers, [])\n        self.assertEqual(connections['other'].execute_wrappers, [])\n", "comments": "            the  initialization  class attributes like client class         creation class set class reflected         corresponding instance attributes instantiated backend                 executemany() must use update query  make sure nothing    putting false condition where clause     this alias shortens next line  ", "content": "from unittest.mock import MagicMock\n\nfrom django.db import DEFAULT_DB_ALIAS, connection, connections\nfrom django.db.backends.base.base import BaseDatabaseWrapper\nfrom django.test import SimpleTestCase, TestCase\n\nfrom ..models import Square\n\n\nclass DatabaseWrapperTests(SimpleTestCase):\n\n    def test_initialization_class_attributes(self):\n        \"\"\"\n        The \"initialization\" class attributes like client_class and\n        creation_class should be set on the class and reflected in the\n        corresponding instance attributes of the instantiated backend.\n        \"\"\"\n        conn = connections[DEFAULT_DB_ALIAS]\n        conn_class = type(conn)\n        attr_names = [\n            ('client_class', 'client'),\n            ('creation_class', 'creation'),\n            ('features_class', 'features'),\n            ('introspection_class', 'introspection'),\n            ('ops_class', 'ops'),\n            ('validation_class', 'validation'),\n        ]\n        for class_attr_name, instance_attr_name in attr_names:\n            class_attr_value = getattr(conn_class, class_attr_name)\n            self.assertIsNotNone(class_attr_value)\n            instance_attr_value = getattr(conn, instance_attr_name)\n            self.assertIsInstance(instance_attr_value, class_attr_value)\n\n    def test_initialization_display_name(self):\n        self.assertEqual(BaseDatabaseWrapper.display_name, 'unknown')\n        self.assertNotEqual(connection.display_name, 'unknown')\n\n\nclass ExecuteWrapperTests(TestCase):\n\n    @staticmethod\n    def call_execute(connection, params=None):\n        ret_val = '1' if params is None else '%s'\n        sql = 'SELECT ' + ret_val + connection.features.bare_select_suffix\n        with connection.cursor() as cursor:\n            cursor.execute(sql, params)\n\n    def call_executemany(self, connection, params=None):\n        # executemany() must use an update query. Make sure it does nothing\n        # by putting a false condition in the WHERE clause.\n        sql = 'DELETE FROM {} WHERE 0=1 AND 0=%s'.format(Square._meta.db_table)\n        if params is None:\n            params = [(i,) for i in range(3)]\n        with connection.cursor() as cursor:\n            cursor.executemany(sql, params)\n\n    @staticmethod\n    def mock_wrapper():\n        return MagicMock(side_effect=lambda execute, *args: execute(*args))\n\n    def test_wrapper_invoked(self):\n        wrapper = self.mock_wrapper()\n        with connection.execute_wrapper(wrapper):\n            self.call_execute(connection)\n        self.assertTrue(wrapper.called)\n        (_, sql, params, many, context), _ = wrapper.call_args\n        self.assertIn('SELECT', sql)\n        self.assertIsNone(params)\n        self.assertIs(many, False)\n        self.assertEqual(context['connection'], connection)\n\n    def test_wrapper_invoked_many(self):\n        wrapper = self.mock_wrapper()\n        with connection.execute_wrapper(wrapper):\n            self.call_executemany(connection)\n        self.assertTrue(wrapper.called)\n        (_, sql, param_list, many, context), _ = wrapper.call_args\n        self.assertIn('DELETE', sql)\n        self.assertIsInstance(param_list, (list, tuple))\n        self.assertIs(many, True)\n        self.assertEqual(context['connection'], connection)\n\n    def test_database_queried(self):\n        wrapper = self.mock_wrapper()\n        with connection.execute_wrapper(wrapper):\n            with connection.cursor() as cursor:\n                sql = 'SELECT 17' + connection.features.bare_select_suffix\n                cursor.execute(sql)\n                seventeen = cursor.fetchall()\n                self.assertEqual(list(seventeen), [(17,)])\n            self.call_executemany(connection)\n\n    def test_nested_wrapper_invoked(self):\n        outer_wrapper = self.mock_wrapper()\n        inner_wrapper = self.mock_wrapper()\n        with connection.execute_wrapper(outer_wrapper), connection.execute_wrapper(inner_wrapper):\n            self.call_execute(connection)\n            self.assertEqual(inner_wrapper.call_count, 1)\n            self.call_executemany(connection)\n            self.assertEqual(inner_wrapper.call_count, 2)\n\n    def test_outer_wrapper_blocks(self):\n        def blocker(*args):\n            pass\n        wrapper = self.mock_wrapper()\n        c = connection  # This alias shortens the next line.\n        with c.execute_wrapper(wrapper), c.execute_wrapper(blocker), c.execute_wrapper(wrapper):\n            with c.cursor() as cursor:\n                cursor.execute(\"The database never sees this\")\n                self.assertEqual(wrapper.call_count, 1)\n                cursor.executemany(\"The database never sees this %s\", [(\"either\",)])\n                self.assertEqual(wrapper.call_count, 2)\n\n    def test_wrapper_gets_sql(self):\n        wrapper = self.mock_wrapper()\n        sql = \"SELECT 'aloha'\" + connection.features.bare_select_suffix\n        with connection.execute_wrapper(wrapper), connection.cursor() as cursor:\n            cursor.execute(sql)\n        (_, reported_sql, _, _, _), _ = wrapper.call_args\n        self.assertEqual(reported_sql, sql)\n\n    def test_wrapper_connection_specific(self):\n        wrapper = self.mock_wrapper()\n        with connections['other'].execute_wrapper(wrapper):\n            self.assertEqual(connections['other'].execute_wrappers, [wrapper])\n            self.call_execute(connection)\n        self.assertFalse(wrapper.called)\n        self.assertEqual(connection.execute_wrappers, [])\n        self.assertEqual(connections['other'].execute_wrappers, [])\n", "description": "The Web framework for perfectionists with deadlines.", "file_name": "test_base.py", "id": "3630ee8a04a34ee21423a6956740e977", "language": "Python", "project_name": "django", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/django-django/django-django-274e3e2/tests/backends/base/test_base.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:39:10Z", "url": "https://github.com/django/django", "wiki": false}