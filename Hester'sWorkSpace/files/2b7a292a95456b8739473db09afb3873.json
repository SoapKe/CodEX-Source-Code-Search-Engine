{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    int_or_none,\n    unified_strdate,\n    xpath_text,\n    determine_ext,\n    qualities,\n    float_or_none,\n    ExtractorError,\n)\n\n\nclass DreiSatIE(InfoExtractor):\n    IE_NAME = '3sat'\n    _VALID_URL = r'(?:https?://)?(?:www\\.)?3sat\\.de/mediathek/(?:index\\.php|mediathek\\.php)?\\?(?:(?:mode|display)=[^&]+&)*obj=(?P<id>[0-9]+)$'\n    _TESTS = [\n        {\n            'url': 'http://www.3sat.de/mediathek/index.php?mode=play&obj=45918',\n            'md5': 'be37228896d30a88f315b638900a026e',\n            'info_dict': {\n                'id': '45918',\n                'ext': 'mp4',\n                'title': 'Waidmannsheil',\n                'description': 'md5:cce00ca1d70e21425e72c86a98a56817',\n                'uploader': 'SCHWEIZWEIT',\n                'uploader_id': '100000210',\n                'upload_date': '20140913'\n            },\n            'params': {\n                'skip_download': True,  \n            }\n        },\n        {\n            'url': 'http://www.3sat.de/mediathek/mediathek.php?mode=play&obj=51066',\n            'only_matching': True,\n        },\n    ]\n\n    def _parse_smil_formats(self, smil, smil_url, video_id, namespace=None, f4m_params=None, transform_rtmp_url=None):\n        param_groups = {}\n        for param_group in smil.findall(self._xpath_ns('./head/paramGroup', namespace)):\n            group_id = param_group.attrib.get(self._xpath_ns('id', 'http://www.w3.org/XML/1998/namespace'))\n            params = {}\n            for param in param_group:\n                params[param.get('name')] = param.get('value')\n            param_groups[group_id] = params\n\n        formats = []\n        for video in smil.findall(self._xpath_ns('.//video', namespace)):\n            src = video.get('src')\n            if not src:\n                continue\n            bitrate = float_or_none(video.get('system-bitrate') or video.get('systemBitrate'), 1000)\n            group_id = video.get('paramGroup')\n            param_group = param_groups[group_id]\n            for proto in param_group['protocols'].split(','):\n                formats.append({\n                    'url': '%s://%s' % (proto, param_group['host']),\n                    'app': param_group['app'],\n                    'play_path': src,\n                    'ext': 'flv',\n                    'format_id': '%s-%d' % (proto, bitrate),\n                    'tbr': bitrate,\n                })\n        self._sort_formats(formats)\n        return formats\n\n    def extract_from_xml_url(self, video_id, xml_url):\n        doc = self._download_xml(\n            xml_url, video_id,\n            note='Downloading video info',\n            errnote='Failed to download video info')\n\n        status_code = doc.find('./status/statuscode')\n        if status_code is not None and status_code.text != 'ok':\n            code = status_code.text\n            if code == 'notVisibleAnymore':\n                message = 'Video %s is not available' % video_id\n            else:\n                message = '%s returned error: %s' % (self.IE_NAME, code)\n            raise ExtractorError(message, expected=True)\n\n        title = doc.find('.//information/title').text\n        description = xpath_text(doc, './/information/detail', 'description')\n        duration = int_or_none(xpath_text(doc, './/details/lengthSec', 'duration'))\n        uploader = xpath_text(doc, './/details/originChannelTitle', 'uploader')\n        uploader_id = xpath_text(doc, './/details/originChannelId', 'uploader id')\n        upload_date = unified_strdate(xpath_text(doc, './/details/airtime', 'upload date'))\n\n        def xml_to_thumbnails(fnode):\n            thumbnails = []\n            for node in fnode:\n                thumbnail_url = node.text\n                if not thumbnail_url:\n                    continue\n                thumbnail = {\n                    'url': thumbnail_url,\n                }\n                if 'key' in node.attrib:\n                    m = re.match('^([0-9]+)x([0-9]+)$', node.attrib['key'])\n                    if m:\n                        thumbnail['width'] = int(m.group(1))\n                        thumbnail['height'] = int(m.group(2))\n                thumbnails.append(thumbnail)\n            return thumbnails\n\n        thumbnails = xml_to_thumbnails(doc.findall('.//teaserimages/teaserimage'))\n\n        format_nodes = doc.findall('.//formitaeten/formitaet')\n        quality = qualities(['veryhigh', 'high', 'med', 'low'])\n\n        def get_quality(elem):\n            return quality(xpath_text(elem, 'quality'))\n        format_nodes.sort(key=get_quality)\n        format_ids = []\n        formats = []\n        for fnode in format_nodes:\n            video_url = fnode.find('url').text\n            is_available = 'http://www.metafilegenerator' not in video_url\n            if not is_available:\n                continue\n            format_id = fnode.attrib['basetype']\n            quality = xpath_text(fnode, './quality', 'quality')\n            format_m = re.match(r, format_id)\n\n            ext = determine_ext(video_url, None) or format_m.group('container')\n            if ext not in ('smil', 'f4m', 'm3u8'):\n                format_id = format_id + '-' + quality\n            if format_id in format_ids:\n                continue\n\n            if ext == 'meta':\n                continue\n            elif ext == 'smil':\n                formats.extend(self._extract_smil_formats(\n                    video_url, video_id, fatal=False))\n            elif ext == 'm3u8':\n                \n                \n                if video_url.startswith('https://'):\n                    continue\n                formats.extend(self._extract_m3u8_formats(\n                    video_url, video_id, 'mp4', m3u8_id=format_id, fatal=False))\n            elif ext == 'f4m':\n                formats.extend(self._extract_f4m_formats(\n                    video_url, video_id, f4m_id=format_id, fatal=False))\n            else:\n                proto = format_m.group('proto').lower()\n\n                abr = int_or_none(xpath_text(fnode, './audioBitrate', 'abr'), 1000)\n                vbr = int_or_none(xpath_text(fnode, './videoBitrate', 'vbr'), 1000)\n\n                width = int_or_none(xpath_text(fnode, './width', 'width'))\n                height = int_or_none(xpath_text(fnode, './height', 'height'))\n\n                filesize = int_or_none(xpath_text(fnode, './filesize', 'filesize'))\n\n                format_note = ''\n                if not format_note:\n                    format_note = None\n\n                formats.append({\n                    'format_id': format_id,\n                    'url': video_url,\n                    'ext': ext,\n                    'acodec': format_m.group('acodec'),\n                    'vcodec': format_m.group('vcodec'),\n                    'abr': abr,\n                    'vbr': vbr,\n                    'width': width,\n                    'height': height,\n                    'filesize': filesize,\n                    'format_note': format_note,\n                    'protocol': proto,\n                    '_available': is_available,\n                })\n            format_ids.append(format_id)\n\n        self._sort_formats(formats)\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'duration': duration,\n            'thumbnails': thumbnails,\n            'uploader': uploader,\n            'uploader_id': uploader_id,\n            'upload_date': upload_date,\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        video_id = mobj.group('id')\n        details_url = 'http://www.3sat.de/mediathek/xmlservice/web/beitragsDetails?ak=web&id=%s' % video_id\n        return self.extract_from_xml_url(video_id, details_url)\n", "comments": "(?x)\n                (?P<vcodec>[^_]+)_(?P<acodec>[^_]+)_(?P<container>[^_]+)_\n                (?P<proto>[^_]+)_(?P<index>[^_]+)_(?P<indexproto>[^_]+)\n            \n \n# m3u8 downloads\n# the certificates are misconfigured (see\n# https://github.com/rg3/youtube-dl/issues/8665)\n", "content": "from __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    int_or_none,\n    unified_strdate,\n    xpath_text,\n    determine_ext,\n    qualities,\n    float_or_none,\n    ExtractorError,\n)\n\n\nclass DreiSatIE(InfoExtractor):\n    IE_NAME = '3sat'\n    _VALID_URL = r'(?:https?://)?(?:www\\.)?3sat\\.de/mediathek/(?:index\\.php|mediathek\\.php)?\\?(?:(?:mode|display)=[^&]+&)*obj=(?P<id>[0-9]+)$'\n    _TESTS = [\n        {\n            'url': 'http://www.3sat.de/mediathek/index.php?mode=play&obj=45918',\n            'md5': 'be37228896d30a88f315b638900a026e',\n            'info_dict': {\n                'id': '45918',\n                'ext': 'mp4',\n                'title': 'Waidmannsheil',\n                'description': 'md5:cce00ca1d70e21425e72c86a98a56817',\n                'uploader': 'SCHWEIZWEIT',\n                'uploader_id': '100000210',\n                'upload_date': '20140913'\n            },\n            'params': {\n                'skip_download': True,  # m3u8 downloads\n            }\n        },\n        {\n            'url': 'http://www.3sat.de/mediathek/mediathek.php?mode=play&obj=51066',\n            'only_matching': True,\n        },\n    ]\n\n    def _parse_smil_formats(self, smil, smil_url, video_id, namespace=None, f4m_params=None, transform_rtmp_url=None):\n        param_groups = {}\n        for param_group in smil.findall(self._xpath_ns('./head/paramGroup', namespace)):\n            group_id = param_group.attrib.get(self._xpath_ns('id', 'http://www.w3.org/XML/1998/namespace'))\n            params = {}\n            for param in param_group:\n                params[param.get('name')] = param.get('value')\n            param_groups[group_id] = params\n\n        formats = []\n        for video in smil.findall(self._xpath_ns('.//video', namespace)):\n            src = video.get('src')\n            if not src:\n                continue\n            bitrate = float_or_none(video.get('system-bitrate') or video.get('systemBitrate'), 1000)\n            group_id = video.get('paramGroup')\n            param_group = param_groups[group_id]\n            for proto in param_group['protocols'].split(','):\n                formats.append({\n                    'url': '%s://%s' % (proto, param_group['host']),\n                    'app': param_group['app'],\n                    'play_path': src,\n                    'ext': 'flv',\n                    'format_id': '%s-%d' % (proto, bitrate),\n                    'tbr': bitrate,\n                })\n        self._sort_formats(formats)\n        return formats\n\n    def extract_from_xml_url(self, video_id, xml_url):\n        doc = self._download_xml(\n            xml_url, video_id,\n            note='Downloading video info',\n            errnote='Failed to download video info')\n\n        status_code = doc.find('./status/statuscode')\n        if status_code is not None and status_code.text != 'ok':\n            code = status_code.text\n            if code == 'notVisibleAnymore':\n                message = 'Video %s is not available' % video_id\n            else:\n                message = '%s returned error: %s' % (self.IE_NAME, code)\n            raise ExtractorError(message, expected=True)\n\n        title = doc.find('.//information/title').text\n        description = xpath_text(doc, './/information/detail', 'description')\n        duration = int_or_none(xpath_text(doc, './/details/lengthSec', 'duration'))\n        uploader = xpath_text(doc, './/details/originChannelTitle', 'uploader')\n        uploader_id = xpath_text(doc, './/details/originChannelId', 'uploader id')\n        upload_date = unified_strdate(xpath_text(doc, './/details/airtime', 'upload date'))\n\n        def xml_to_thumbnails(fnode):\n            thumbnails = []\n            for node in fnode:\n                thumbnail_url = node.text\n                if not thumbnail_url:\n                    continue\n                thumbnail = {\n                    'url': thumbnail_url,\n                }\n                if 'key' in node.attrib:\n                    m = re.match('^([0-9]+)x([0-9]+)$', node.attrib['key'])\n                    if m:\n                        thumbnail['width'] = int(m.group(1))\n                        thumbnail['height'] = int(m.group(2))\n                thumbnails.append(thumbnail)\n            return thumbnails\n\n        thumbnails = xml_to_thumbnails(doc.findall('.//teaserimages/teaserimage'))\n\n        format_nodes = doc.findall('.//formitaeten/formitaet')\n        quality = qualities(['veryhigh', 'high', 'med', 'low'])\n\n        def get_quality(elem):\n            return quality(xpath_text(elem, 'quality'))\n        format_nodes.sort(key=get_quality)\n        format_ids = []\n        formats = []\n        for fnode in format_nodes:\n            video_url = fnode.find('url').text\n            is_available = 'http://www.metafilegenerator' not in video_url\n            if not is_available:\n                continue\n            format_id = fnode.attrib['basetype']\n            quality = xpath_text(fnode, './quality', 'quality')\n            format_m = re.match(r'''(?x)\n                (?P<vcodec>[^_]+)_(?P<acodec>[^_]+)_(?P<container>[^_]+)_\n                (?P<proto>[^_]+)_(?P<index>[^_]+)_(?P<indexproto>[^_]+)\n            ''', format_id)\n\n            ext = determine_ext(video_url, None) or format_m.group('container')\n            if ext not in ('smil', 'f4m', 'm3u8'):\n                format_id = format_id + '-' + quality\n            if format_id in format_ids:\n                continue\n\n            if ext == 'meta':\n                continue\n            elif ext == 'smil':\n                formats.extend(self._extract_smil_formats(\n                    video_url, video_id, fatal=False))\n            elif ext == 'm3u8':\n                # the certificates are misconfigured (see\n                # https://github.com/rg3/youtube-dl/issues/8665)\n                if video_url.startswith('https://'):\n                    continue\n                formats.extend(self._extract_m3u8_formats(\n                    video_url, video_id, 'mp4', m3u8_id=format_id, fatal=False))\n            elif ext == 'f4m':\n                formats.extend(self._extract_f4m_formats(\n                    video_url, video_id, f4m_id=format_id, fatal=False))\n            else:\n                proto = format_m.group('proto').lower()\n\n                abr = int_or_none(xpath_text(fnode, './audioBitrate', 'abr'), 1000)\n                vbr = int_or_none(xpath_text(fnode, './videoBitrate', 'vbr'), 1000)\n\n                width = int_or_none(xpath_text(fnode, './width', 'width'))\n                height = int_or_none(xpath_text(fnode, './height', 'height'))\n\n                filesize = int_or_none(xpath_text(fnode, './filesize', 'filesize'))\n\n                format_note = ''\n                if not format_note:\n                    format_note = None\n\n                formats.append({\n                    'format_id': format_id,\n                    'url': video_url,\n                    'ext': ext,\n                    'acodec': format_m.group('acodec'),\n                    'vcodec': format_m.group('vcodec'),\n                    'abr': abr,\n                    'vbr': vbr,\n                    'width': width,\n                    'height': height,\n                    'filesize': filesize,\n                    'format_note': format_note,\n                    'protocol': proto,\n                    '_available': is_available,\n                })\n            format_ids.append(format_id)\n\n        self._sort_formats(formats)\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'duration': duration,\n            'thumbnails': thumbnails,\n            'uploader': uploader,\n            'uploader_id': uploader_id,\n            'upload_date': upload_date,\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        video_id = mobj.group('id')\n        details_url = 'http://www.3sat.de/mediathek/xmlservice/web/beitragsDetails?ak=web&id=%s' % video_id\n        return self.extract_from_xml_url(video_id, details_url)\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "dreisat.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/dreisat.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}