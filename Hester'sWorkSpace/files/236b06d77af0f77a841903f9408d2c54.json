{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom datetime import timedelta\nfrom odoo import api, fields, models, _\n\n\nclass SaleOrder(models.Model):\n    \"\"\"Add several date fields to Sales Orders, computed or user-entered\"\"\"\n    _inherit = 'sale.order'\n\n    commitment_date = fields.Datetime(compute='_compute_commitment_date', string='Commitment Date', store=True,\n                                      help=\"Date by which the products are sure to be delivered. This is \"\n                                           \"a date that you can promise to the customer, based on the \"\n                                           \"Product Lead Times.\")\n    requested_date = fields.Datetime('Requested Date', readonly=True, states={'draft': [('readonly', False)],\n                                     'sent': [('readonly', False)]}, copy=False,\n                                     help=\"Date by which the customer has requested the items to be \"\n                                          \"delivered.\\n\"\n                                          \"When this Order gets confirmed, the Delivery Order's \"\n                                          \"expected date will be computed based on this date and the \"\n                                          \"Company's Security Delay.\\n\"\n                                          \"Leave this field empty if you want the Delivery Order to be \"\n                                          \"processed as soon as possible. In that case the expected \"\n                                          \"date will be computed using the default method: based on \"\n                                          \"the Product Lead Times and the Company's Security Delay.\")\n    effective_date = fields.Date(compute='_compute_picking_ids', string='Effective Date', store=True,\n                                 help=\"Date on which the first Delivery Order was created.\")\n\n    @api.depends('date_order', 'order_line.customer_lead')\n    def _compute_commitment_date(self):\n        \"\"\"Compute the commitment date\"\"\"\n        for order in self:\n            dates_list = []\n            order_datetime = fields.Datetime.from_string(order.date_order)\n            for line in order.order_line.filtered(lambda x: x.state != 'cancel'):\n                dt = order_datetime + timedelta(days=line.customer_lead or 0.0)\n                dates_list.append(dt)\n            if dates_list:\n                commit_date = min(dates_list) if order.picking_policy == 'direct' else max(dates_list)\n                order.commitment_date = fields.Datetime.to_string(commit_date)\n\n    def _compute_picking_ids(self):\n        super(SaleOrder, self)._compute_picking_ids()\n        for order in self:\n            dates_list = []\n            for pick in order.picking_ids:\n                dates_list.append(fields.Datetime.from_string(pick.date))\n            if dates_list:\n                order.effective_date = fields.Datetime.to_string(min(dates_list))\n\n    @api.onchange('requested_date')\n    def onchange_requested_date(self):\n        \"\"\"Warn if the requested dates is sooner than the commitment date\"\"\"\n        if (self.requested_date and self.commitment_date and self.requested_date < self.commitment_date):\n            return {'warning': {\n                'title': _('Requested date is too soon!'),\n                'message': _(\"The date requested by the customer is \"\n                             \"sooner than the commitment date. You may be \"\n                             \"unable to honor the customer's request.\")\n                }\n            }\n\n\nclass SaleOrderLine(models.Model):\n    _inherit = 'sale.order.line'\n\n    @api.multi\n    def _prepare_procurement_values(self, group_id):\n        vals = super(SaleOrderLine, self)._prepare_procurement_values(group_id=group_id)\n        for line in self.filtered(\"order_id.requested_date\"):\n            date_planned = fields.Datetime.from_string(line.order_id.requested_date) - timedelta(days=line.order_id.company_id.security_lead)\n            vals.update({\n                'date_planned': fields.Datetime.to_string(date_planned),\n            })\n        return vals\n", "comments": "   add several date fields sales orders  computed user entered         inherit    sale order       commitment date   fields datetime(compute   compute commitment date   string  commitment date   store true                                        help  date products sure delivered  this                                               date promise customer  based                                               product lead times  )     requested date   fields datetime( requested date   readonly true  states   draft    ( readonly   false)                                         sent    ( readonly   false)    copy false                                       help  date customer requested items                                              delivered  n                                             when order gets confirmed  delivery order                                              expected date computed based date                                              company security delay  n                                             leave field empty want delivery order                                              processed soon possible  in case expected                                              date computed using default method  based                                              product lead times company security delay  )     effective date   fields date(compute   compute picking ids   string  effective date   store true                                   help  date first delivery order created  )       api depends( date order    order line customer lead )     def  compute commitment date(self)             compute commitment date            order self              dates list                  order datetime   fields datetime string(order date order)             line order order line filtered(lambda x  x state     cancel )                  dt   order datetime   timedelta(days line customer lead 0 0)                 dates list append(dt)             dates list                  commit date   min(dates list) order picking policy     direct  else max(dates list)                 order commitment date   fields datetime string(commit date)      def  compute picking ids(self)          super(saleorder  self)  compute picking ids()         order self              dates list                  pick order picking ids                  dates list append(fields datetime string(pick date))             dates list                  order effective date   fields datetime string(min(dates list))       api onchange( requested date )     def onchange requested date(self)             warn requested dates sooner commitment date           coding  utf 8        part odoo  see license file full copyright licensing details  ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom datetime import timedelta\nfrom odoo import api, fields, models, _\n\n\nclass SaleOrder(models.Model):\n    \"\"\"Add several date fields to Sales Orders, computed or user-entered\"\"\"\n    _inherit = 'sale.order'\n\n    commitment_date = fields.Datetime(compute='_compute_commitment_date', string='Commitment Date', store=True,\n                                      help=\"Date by which the products are sure to be delivered. This is \"\n                                           \"a date that you can promise to the customer, based on the \"\n                                           \"Product Lead Times.\")\n    requested_date = fields.Datetime('Requested Date', readonly=True, states={'draft': [('readonly', False)],\n                                     'sent': [('readonly', False)]}, copy=False,\n                                     help=\"Date by which the customer has requested the items to be \"\n                                          \"delivered.\\n\"\n                                          \"When this Order gets confirmed, the Delivery Order's \"\n                                          \"expected date will be computed based on this date and the \"\n                                          \"Company's Security Delay.\\n\"\n                                          \"Leave this field empty if you want the Delivery Order to be \"\n                                          \"processed as soon as possible. In that case the expected \"\n                                          \"date will be computed using the default method: based on \"\n                                          \"the Product Lead Times and the Company's Security Delay.\")\n    effective_date = fields.Date(compute='_compute_picking_ids', string='Effective Date', store=True,\n                                 help=\"Date on which the first Delivery Order was created.\")\n\n    @api.depends('date_order', 'order_line.customer_lead')\n    def _compute_commitment_date(self):\n        \"\"\"Compute the commitment date\"\"\"\n        for order in self:\n            dates_list = []\n            order_datetime = fields.Datetime.from_string(order.date_order)\n            for line in order.order_line.filtered(lambda x: x.state != 'cancel'):\n                dt = order_datetime + timedelta(days=line.customer_lead or 0.0)\n                dates_list.append(dt)\n            if dates_list:\n                commit_date = min(dates_list) if order.picking_policy == 'direct' else max(dates_list)\n                order.commitment_date = fields.Datetime.to_string(commit_date)\n\n    def _compute_picking_ids(self):\n        super(SaleOrder, self)._compute_picking_ids()\n        for order in self:\n            dates_list = []\n            for pick in order.picking_ids:\n                dates_list.append(fields.Datetime.from_string(pick.date))\n            if dates_list:\n                order.effective_date = fields.Datetime.to_string(min(dates_list))\n\n    @api.onchange('requested_date')\n    def onchange_requested_date(self):\n        \"\"\"Warn if the requested dates is sooner than the commitment date\"\"\"\n        if (self.requested_date and self.commitment_date and self.requested_date < self.commitment_date):\n            return {'warning': {\n                'title': _('Requested date is too soon!'),\n                'message': _(\"The date requested by the customer is \"\n                             \"sooner than the commitment date. You may be \"\n                             \"unable to honor the customer's request.\")\n                }\n            }\n\n\nclass SaleOrderLine(models.Model):\n    _inherit = 'sale.order.line'\n\n    @api.multi\n    def _prepare_procurement_values(self, group_id):\n        vals = super(SaleOrderLine, self)._prepare_procurement_values(group_id=group_id)\n        for line in self.filtered(\"order_id.requested_date\"):\n            date_planned = fields.Datetime.from_string(line.order_id.requested_date) - timedelta(days=line.order_id.company_id.security_lead)\n            vals.update({\n                'date_planned': fields.Datetime.to_string(date_planned),\n            })\n        return vals\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "sale_order.py", "id": "236b06d77af0f77a841903f9408d2c54", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/sale_order_dates/models/sale_order.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}