{"author": "django", "code": "import os\n\nfrom django.core.files.base import ContentFile\nfrom django.core.files.storage import Storage\nfrom django.db.models import FileField\nfrom django.test import SimpleTestCase\n\n\nclass AWSS3Storage(Storage):\n    \"\"\"\n    Simulate an AWS S3 storage which uses Unix-like paths and allows any\n    characters in file names but where there aren't actual folders but just\n    keys.\n    \"\"\"\n    prefix = 'mys3folder/'\n\n    def _save(self, name, content):\n        \"\"\"\n        This method is important to test that Storage.save() doesn't replace\n        '\\' with '/' (rather FileSystemStorage.save() does).\n        \"\"\"\n        return name\n\n    def get_valid_name(self, name):\n        return name\n\n    def get_available_name(self, name, max_length=None):\n        return name\n\n    def generate_filename(self, filename):\n        \"\"\"\n        This is the method that's important to override when using S3 so that\n        os.path() isn't called, which would break S3 keys.\n        \"\"\"\n        return self.prefix + self.get_valid_name(filename)\n\n\nclass GenerateFilenameStorageTests(SimpleTestCase):\n\n    def test_filefield_generate_filename(self):\n        f = FileField(upload_to='some/folder/')\n        self.assertEqual(\n            f.generate_filename(None, 'test with space.txt'),\n            os.path.normpath('some/folder/test_with_space.txt')\n        )\n\n    def test_filefield_generate_filename_with_upload_to(self):\n        def upload_to(instance, filename):\n            return 'some/folder/' + filename\n\n        f = FileField(upload_to=upload_to)\n        self.assertEqual(\n            f.generate_filename(None, 'test with space.txt'),\n            os.path.normpath('some/folder/test_with_space.txt')\n        )\n\n    def test_filefield_awss3_storage(self):\n        \"\"\"\n        Simulate a FileField with an S3 storage which uses keys rather than\n        folders and names. FileField and Storage shouldn't have any os.path()\n        calls that break the key.\n        \"\"\"\n        storage = AWSS3Storage()\n        folder = 'not/a/folder/'\n\n        f = FileField(upload_to=folder, storage=storage)\n        key = 'my-file-key\\\\with odd characters'\n        data = ContentFile('test')\n        expected_key = AWSS3Storage.prefix + folder + key\n\n        ()\n        result_key = f.generate_filename(None, key)\n        self.assertEqual(result_key, expected_key)\n\n        result_key = storage.save(result_key, data)\n        self.assertEqual(result_key, expected_key)\n\n        \n        def upload_to(instance, filename):\n            \n            return folder + filename\n\n        f = FileField(upload_to=upload_to, storage=storage)\n\n        ()\n        result_key = f.generate_filename(None, key)\n        self.assertEqual(result_key, expected_key)\n\n        result_key = storage.save(result_key, data)\n        self.assertEqual(result_key, expected_key)\n", "comments": "        simulate aws s3 storage uses unix like paths allows     characters file names actual folders     keys              prefix    mys3folder        def  save(self  name  content)                      this method important test storage save() replace                 (rather filesystemstorage save() does)                      return name      def get valid name(self  name)          return name      def get available name(self  name  max length none)          return name      def generate filename(self  filename)                      this method important override using s3         os path() called  would break s3 keys                      return self prefix   self get valid name(filename)   class generatefilenamestoragetests(simpletestcase)       def test filefield generate filename(self)          f   filefield(upload  folder  )         self assertequal(             f generate filename(none   test space txt )              os path normpath( folder test space txt )         )      def test filefield generate filename upload to(self)          def upload to(instance  filename)              return  folder     filename          f   filefield(upload upload to)         self assertequal(             f generate filename(none   test space txt )              os path normpath( folder test space txt )         )      def test filefield awss3 storage(self)                      simulate filefield s3 storage uses keys rather         folders names  filefield storage os path()         calls break key                 simulate call f save()    repeat test callable     return non normalized path purpose     simulate call f save() ", "content": "import os\n\nfrom django.core.files.base import ContentFile\nfrom django.core.files.storage import Storage\nfrom django.db.models import FileField\nfrom django.test import SimpleTestCase\n\n\nclass AWSS3Storage(Storage):\n    \"\"\"\n    Simulate an AWS S3 storage which uses Unix-like paths and allows any\n    characters in file names but where there aren't actual folders but just\n    keys.\n    \"\"\"\n    prefix = 'mys3folder/'\n\n    def _save(self, name, content):\n        \"\"\"\n        This method is important to test that Storage.save() doesn't replace\n        '\\' with '/' (rather FileSystemStorage.save() does).\n        \"\"\"\n        return name\n\n    def get_valid_name(self, name):\n        return name\n\n    def get_available_name(self, name, max_length=None):\n        return name\n\n    def generate_filename(self, filename):\n        \"\"\"\n        This is the method that's important to override when using S3 so that\n        os.path() isn't called, which would break S3 keys.\n        \"\"\"\n        return self.prefix + self.get_valid_name(filename)\n\n\nclass GenerateFilenameStorageTests(SimpleTestCase):\n\n    def test_filefield_generate_filename(self):\n        f = FileField(upload_to='some/folder/')\n        self.assertEqual(\n            f.generate_filename(None, 'test with space.txt'),\n            os.path.normpath('some/folder/test_with_space.txt')\n        )\n\n    def test_filefield_generate_filename_with_upload_to(self):\n        def upload_to(instance, filename):\n            return 'some/folder/' + filename\n\n        f = FileField(upload_to=upload_to)\n        self.assertEqual(\n            f.generate_filename(None, 'test with space.txt'),\n            os.path.normpath('some/folder/test_with_space.txt')\n        )\n\n    def test_filefield_awss3_storage(self):\n        \"\"\"\n        Simulate a FileField with an S3 storage which uses keys rather than\n        folders and names. FileField and Storage shouldn't have any os.path()\n        calls that break the key.\n        \"\"\"\n        storage = AWSS3Storage()\n        folder = 'not/a/folder/'\n\n        f = FileField(upload_to=folder, storage=storage)\n        key = 'my-file-key\\\\with odd characters'\n        data = ContentFile('test')\n        expected_key = AWSS3Storage.prefix + folder + key\n\n        # Simulate call to f.save()\n        result_key = f.generate_filename(None, key)\n        self.assertEqual(result_key, expected_key)\n\n        result_key = storage.save(result_key, data)\n        self.assertEqual(result_key, expected_key)\n\n        # Repeat test with a callable.\n        def upload_to(instance, filename):\n            # Return a non-normalized path on purpose.\n            return folder + filename\n\n        f = FileField(upload_to=upload_to, storage=storage)\n\n        # Simulate call to f.save()\n        result_key = f.generate_filename(None, key)\n        self.assertEqual(result_key, expected_key)\n\n        result_key = storage.save(result_key, data)\n        self.assertEqual(result_key, expected_key)\n", "description": "The Web framework for perfectionists with deadlines.", "file_name": "test_generate_filename.py", "id": "b361ed3f3d373ed487d5e741d1199f5f", "language": "Python", "project_name": "django", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/django-django/django-django-274e3e2/tests/file_storage/test_generate_filename.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:39:10Z", "url": "https://github.com/django/django", "wiki": false}