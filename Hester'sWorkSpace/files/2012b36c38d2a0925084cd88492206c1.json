{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nimport datetime\nimport logging\nimport re\nimport uuid\nfrom collections import Counter, OrderedDict\nfrom itertools import product\nfrom werkzeug import urls\n\nfrom odoo import api, fields, models, tools, SUPERUSER_ID, _\nfrom odoo.addons.http_routing.models.ir_http import slug\nfrom odoo.exceptions import UserError, ValidationError\nemail_validator = re.compile(r\"[^@]+@[^@]+\\.[^@]+\")\n_logger = logging.getLogger(__name__)\n\n\ndef dict_keys_startswith(dictionary, string):\n    \"\"\"Returns a dictionary containing the elements of <dict> whose keys start with <string>.\n        .. note::\n            This function uses dictionary comprehensions (Python >= 2.7)\n    \"\"\"\n    return {k: v for k, v in dictionary.items() if k.startswith(string)}\n\n\nclass SurveyStage(models.Model):\n    \"\"\"Stages for Kanban view of surveys\"\"\"\n\n    _name = 'survey.stage'\n    _description = 'Survey Stage'\n    _order = 'sequence,id'\n\n    name = fields.Char(required=True, translate=True)\n    sequence = fields.Integer(default=1)\n    closed = fields.Boolean(help=\"If closed, people won't be able to answer to surveys in this column.\")\n    fold = fields.Boolean(string=\"Folded in kanban view\")\n\n    _sql_constraints = [\n        ('positive_sequence', 'CHECK(sequence >= 0)', 'Sequence number MUST be a natural')\n    ]\n\n\nclass Survey(models.Model):\n    \"\"\" Settings for a multi-page/multi-question survey.\n        Each survey can have one or more attached pages, and each page can display\n        one or more questions.\n    \"\"\"\n\n    _name = 'survey.survey'\n    _description = 'Survey'\n    _rec_name = 'title'\n    _inherit = ['mail.thread', 'mail.activity.mixin']\n\n    def _default_stage(self):\n        return self.env['survey.stage'].search([], limit=1).id\n\n    title = fields.Char('Title', required=True, translate=True)\n    page_ids = fields.One2many('survey.page', 'survey_id', string='Pages', copy=True)\n    stage_id = fields.Many2one('survey.stage', string=\"Stage\", default=_default_stage,\n                               ondelete=\"set null\", copy=False, group_expand='_read_group_stage_ids')\n    auth_required = fields.Boolean('Login required', help=\"Users with a public link will be requested to login before taking part to the survey\",\n        oldname=\"authenticate\")\n    users_can_go_back = fields.Boolean('Users can go back', help=\"If checked, users can go back to previous pages.\")\n    tot_sent_survey = fields.Integer(\"Number of sent surveys\", compute=\"_compute_survey_statistic\")\n    tot_start_survey = fields.Integer(\"Number of started surveys\", compute=\"_compute_survey_statistic\")\n    tot_comp_survey = fields.Integer(\"Number of completed surveys\", compute=\"_compute_survey_statistic\")\n    description = fields.Html(\"Description\", translate=True, help=\"A long description of the purpose of the survey\")\n    color = fields.Integer('Color Index', default=0)\n    user_input_ids = fields.One2many('survey.user_input', 'survey_id', string='User responses', readonly=True)\n    designed = fields.Boolean(\"Is designed?\", compute=\"_is_designed\")\n    public_url = fields.Char(\"Public link\", compute=\"_compute_survey_url\")\n    public_url_html = fields.Char(\"Public link (html version)\", compute=\"_compute_survey_url\")\n    print_url = fields.Char(\"Print link\", compute=\"_compute_survey_url\")\n    result_url = fields.Char(\"Results link\", compute=\"_compute_survey_url\")\n    email_template_id = fields.Many2one('mail.template', string='Email Template', ondelete='set null')\n    thank_you_message = fields.Html(\"Thanks Message\", translate=True, help=\"This message will be displayed when survey is completed\")\n    quizz_mode = fields.Boolean(\"Quizz Mode\")\n    active = fields.Boolean(\"Active\", default=True)\n    is_closed = fields.Boolean(\"Is closed\", related='stage_id.closed')\n\n    def _is_designed(self):\n        for survey in self:\n            if not survey.page_ids or not [page.question_ids for page in survey.page_ids if page.question_ids]:\n                survey.designed = False\n            else:\n                survey.designed = True\n\n    @api.multi\n    def _compute_survey_statistic(self):\n        UserInput = self.env['survey.user_input']\n\n        sent_survey = UserInput.search([('survey_id', 'in', self.ids), ('type', '=', 'link')])\n        start_survey = UserInput.search(['&', ('survey_id', 'in', self.ids), '|', ('state', '=', 'skip'), ('state', '=', 'done')])\n        complete_survey = UserInput.search([('survey_id', 'in', self.ids), ('state', '=', 'done')])\n\n        for survey in self:\n            survey.tot_sent_survey = len(sent_survey.filtered(lambda user_input: user_input.survey_id == survey))\n            survey.tot_start_survey = len(start_survey.filtered(lambda user_input: user_input.survey_id == survey))\n            survey.tot_comp_survey = len(complete_survey.filtered(lambda user_input: user_input.survey_id == survey))\n\n    def _compute_survey_url(self):\n        \"\"\" Computes a public URL for the survey \"\"\"\n        base_url = '/' if self.env.context.get('relative_url') else \\\n                   self.env['ir.config_parameter'].sudo().get_param('web.base.url')\n        for survey in self:\n            survey.public_url = urls.url_join(base_url, \"survey/start/%s\" % (slug(survey)))\n            survey.print_url = urls.url_join(base_url, \"survey/print/%s\" % (slug(survey)))\n            survey.result_url = urls.url_join(base_url, \"survey/results/%s\" % (slug(survey)))\n            survey.public_url_html = '<a href=\"%s\">%s</a>' % (survey.public_url, _(\"Click here to start survey\"))\n\n    @api.model\n    def _read_group_stage_ids(self, stages, domain, order):\n        \"\"\" Read group customization in order to display all the stages in the\n            kanban view, even if they are empty\n        \"\"\"\n        stage_ids = stages._search([], order=order, access_rights_uid=SUPERUSER_ID)\n        return stages.browse(stage_ids)\n\n    \n    def copy_data(self, default=None):\n        title = _(\"%s (copy)\") % (self.title)\n        default = dict(default or {}, title=title)\n        return super(Survey, self).copy_data(default)\n\n    @api.model\n    def next_page(self, user_input, page_id, go_back=False):\n        \"\"\" The next page to display to the user, knowing that page_id is the id\n            of the last displayed page.\n\n            If page_id == 0, it will always return the first page of the survey.\n\n            If all the pages have been displayed and go_back == False, it will\n            return None\n\n            If go_back == True, it will return the *previous* page instead of the\n            next page.\n\n            .. note::\n                It is assumed here that a careful user will not try to set go_back\n                to True if she knows that the page to display is the first one!\n                (doing this will probably cause a giant worm to eat her house)\n        \"\"\"\n        survey = user_input.survey_id\n        pages = list(enumerate(survey.page_ids))\n\n        \n        if page_id == 0:\n            return (pages[0][1], 0, len(pages) == 1)\n\n        current_page_index = pages.index(next(p for p in pages if p[1].id == page_id))\n\n        \n        if current_page_index == len(pages) - 1 and not go_back:\n            return (None, -1, False)\n        \n        elif go_back and survey.users_can_go_back:\n            return (pages[current_page_index - 1][1], current_page_index - 1, False)\n        else:\n            \n            if current_page_index == len(pages) - 2:\n                return (pages[current_page_index + 1][1], current_page_index + 1, True)\n            \n            else:\n                return (pages[current_page_index + 1][1], current_page_index + 1, False)\n\n    @api.multi\n    def filter_input_ids(self, filters, finished=False):\n        \"\"\"If user applies any filters, then this function returns list of\n           filtered user_input_id and label's strings for display data in web.\n           :param filters: list of dictionary (having: row_id, ansewr_id)\n           :param finished: True for completely filled survey,Falser otherwise.\n           :returns list of filtered user_input_ids.\n        \"\"\"\n        self.ensure_one()\n        if filters:\n            domain_filter, choice = [], []\n            for current_filter in filters:\n                row_id, answer_id = current_filter['row_id'], current_filter['answer_id']\n                if row_id == 0:\n                    choice.append(answer_id)\n                else:\n                    domain_filter.extend(['|', ('value_suggested_row.id', '=', row_id), ('value_suggested.id', '=', answer_id)])\n            if choice:\n                domain_filter.insert(0, ('value_suggested.id', 'in', choice))\n            else:\n                domain_filter = domain_filter[1:]\n            input_lines = self.env['survey.user_input_line'].search(domain_filter)\n            filtered_input_ids = [input_line.user_input_id.id for input_line in input_lines]\n        else:\n            filtered_input_ids = []\n        if finished:\n            UserInput = self.env['survey.user_input']\n            if not filtered_input_ids:\n                user_inputs = UserInput.search([('survey_id', '=', self.id)])\n            else:\n                user_inputs = UserInput.browse(filtered_input_ids)\n            return user_inputs.filtered(lambda input_item: input_item.state == 'done').ids\n        return filtered_input_ids\n\n    @api.model\n    def get_filter_display_data(self, filters):\n        \"\"\"Returns data to display current filters\n            :param filters: list of dictionary (having: row_id, answer_id)\n            :returns list of dict having data to display filters.\n        \"\"\"\n        filter_display_data = []\n        if filters:\n            Label = self.env['survey.label']\n            for current_filter in filters:\n                row_id, answer_id = current_filter['row_id'], current_filter['answer_id']\n                label = Label.browse(answer_id)\n                question = label.question_id\n                if row_id == 0:\n                    labels = label\n                else:\n                    labels = Label.browse([row_id, answer_id])\n                filter_display_data.append({'question_text': question.question,\n                                            'labels': labels.mapped('value')})\n        return filter_display_data\n\n    @api.model\n    def prepare_result(self, question, current_filters=None):\n        \"\"\" Compute statistical data for questions by counting number of vote per choice on basis of filter \"\"\"\n        current_filters = current_filters if current_filters else []\n        result_summary = {}\n\n        \n        if question.type in ['simple_choice', 'multiple_choice']:\n            answers = {}\n            comments = []\n            [answers.update({label.id: {'text': label.value, 'count': 0, 'answer_id': label.id}}) for label in question.labels_ids]\n            for input_line in question.user_input_line_ids:\n                if input_line.answer_type == 'suggestion' and answers.get(input_line.value_suggested.id) and (not(current_filters) or input_line.user_input_id.id in current_filters):\n                    answers[input_line.value_suggested.id]['count'] += 1\n                if input_line.answer_type == 'text' and (not(current_filters) or input_line.user_input_id.id in current_filters):\n                    comments.append(input_line)\n            result_summary = {'answers': list(answers.values()), 'comments': comments}\n\n        \n        if question.type == 'matrix':\n            rows = OrderedDict()\n            answers = OrderedDict()\n            res = dict()\n            comments = []\n            [rows.update({label.id: label.value}) for label in question.labels_ids_2]\n            [answers.update({label.id: label.value}) for label in question.labels_ids]\n            for cell in product(rows, answers):\n                res[cell] = 0\n            for input_line in question.user_input_line_ids:\n                if input_line.answer_type == 'suggestion' and (not(current_filters) or input_line.user_input_id.id in current_filters) and input_line.value_suggested_row:\n                    res[(input_line.value_suggested_row.id, input_line.value_suggested.id)] += 1\n                if input_line.answer_type == 'text' and (not(current_filters) or input_line.user_input_id.id in current_filters):\n                    comments.append(input_line)\n            result_summary = {'answers': answers, 'rows': rows, 'result': res, 'comments': comments}\n\n        \n        if question.type in ['free_text', 'textbox', 'date']:\n            result_summary = []\n            for input_line in question.user_input_line_ids:\n                if not(current_filters) or input_line.user_input_id.id in current_filters:\n                    result_summary.append(input_line)\n\n        \n        if question.type == 'numerical_box':\n            result_summary = {'input_lines': []}\n            all_inputs = []\n            for input_line in question.user_input_line_ids:\n                if not(current_filters) or input_line.user_input_id.id in current_filters:\n                    all_inputs.append(input_line.value_number)\n                    result_summary['input_lines'].append(input_line)\n            if all_inputs:\n                result_summary.update({'average': round(sum(all_inputs) / len(all_inputs), 2),\n                                       'max': round(max(all_inputs), 2),\n                                       'min': round(min(all_inputs), 2),\n                                       'sum': sum(all_inputs),\n                                       'most_common': Counter(all_inputs).most_common(5)})\n        return result_summary\n\n    @api.model\n    def get_input_summary(self, question, current_filters=None):\n        \"\"\" Returns overall summary of question e.g. answered, skipped, total_inputs on basis of filter \"\"\"\n        current_filters = current_filters if current_filters else []\n        result = {}\n        if question.survey_id.user_input_ids:\n            total_input_ids = current_filters or [input_id.id for input_id in question.survey_id.user_input_ids if input_id.state != 'new']\n            result['total_inputs'] = len(total_input_ids)\n            question_input_ids = []\n            for user_input in question.user_input_line_ids:\n                if not user_input.skipped:\n                    question_input_ids.append(user_input.user_input_id.id)\n            result['answered'] = len(set(question_input_ids) & set(total_input_ids))\n            result['skipped'] = result['total_inputs'] - result['answered']\n        return result\n\n    \n\n    @api.multi\n    def action_start_survey(self):\n        \"\"\" Open the website page with the survey form \"\"\"\n        self.ensure_one()\n        token = self.env.context.get('survey_token')\n        trail = \"/%s\" % token if token else \"\"\n        return {\n            'type': 'ir.actions.act_url',\n            'name': \"Start Survey\",\n            'target': 'self',\n            'url': self.with_context(relative_url=True).public_url + trail\n        }\n\n    @api.multi\n    def action_send_survey(self):\n        \"\"\" Open a window to compose an email, pre-filled with the survey message \"\"\"\n        \n        if not self.page_ids or not [page.question_ids for page in self.page_ids if page.question_ids]:\n            raise UserError(_('You cannot send an invitation for a survey that has no questions.'))\n\n        if self.stage_id.closed:\n            raise UserError(_(\"You cannot send invitations for closed surveys.\"))\n\n        template = self.env.ref('survey.email_template_survey', raise_if_not_found=False)\n\n        local_context = dict(\n            self.env.context,\n            default_model='survey.survey',\n            default_res_id=self.id,\n            default_survey_id=self.id,\n            default_use_template=bool(template),\n            default_template_id=template and template.id or False,\n            default_composition_mode='comment'\n        )\n        return {\n            'type': 'ir.actions.act_window',\n            'view_type': 'form',\n            'view_mode': 'form',\n            'res_model': 'survey.mail.compose.message',\n            'target': 'new',\n            'context': local_context,\n        }\n\n    @api.multi\n    def action_print_survey(self):\n        \"\"\" Open the website page with the survey printable view \"\"\"\n        self.ensure_one()\n        token = self.env.context.get('survey_token')\n        trail = \"/\" + token if token else \"\"\n        return {\n            'type': 'ir.actions.act_url',\n            'name': \"Print Survey\",\n            'target': 'self',\n            'url': self.with_context(relative_url=True).print_url + trail\n        }\n\n    @api.multi\n    def action_result_survey(self):\n        \"\"\" Open the website page with the survey results view \"\"\"\n        self.ensure_one()\n        return {\n            'type': 'ir.actions.act_url',\n            'name': \"Results of the Survey\",\n            'target': 'self',\n            'url': self.with_context(relative_url=True).result_url\n        }\n\n    @api.multi\n    def action_test_survey(self):\n        \"\"\" Open the website page with the survey form into test mode\"\"\"\n        self.ensure_one()\n        return {\n            'type': 'ir.actions.act_url',\n            'name': \"Results of the Survey\",\n            'target': 'self',\n            'url': self.with_context(relative_url=True).public_url + \"/phantom\"\n        }\n\n    @api.multi\n    def action_survey_user_input(self):\n        action_rec = self.env.ref('survey.action_survey_user_input')\n        action = action_rec.read()[0]\n        ctx = dict(self.env.context)\n        ctx.update({'search_default_survey_id': self.ids[0],\n                    'search_default_completed': 1})\n        action['context'] = ctx\n        return action\n\n\nclass SurveyPage(models.Model):\n    \"\"\" A page for a survey.\n\n        Pages are essentially containers, allowing to group questions by ordered\n        screens.\n\n        .. note::\n            A page should be deleted if the survey it belongs to is deleted.\n    \"\"\"\n    _name = 'survey.page'\n    _description = 'Survey Page'\n    _rec_name = 'title'\n    _order = 'sequence,id'\n\n    \n\n    title = fields.Char('Page Title', required=True, translate=True)\n    survey_id = fields.Many2one('survey.survey', string='Survey', ondelete='cascade', required=True)\n    question_ids = fields.One2many('survey.question', 'page_id', string='Questions', copy=True)\n    sequence = fields.Integer('Page number', default=10)\n    description = fields.Html('Description', translate=True, oldname=\"note\", help=\"An introductory text to your page\")\n\n\nclass SurveyQuestion(models.Model):\n    \"\"\" Questions that will be asked in a survey.\n\n        Each question can have one of more suggested answers (eg. in case of\n        dropdown choices, multi-answer checkboxes, radio buttons...).\n    \"\"\"\n\n    _name = 'survey.question'\n    _description = 'Survey Question'\n    _rec_name = 'question'\n    _order = 'sequence,id'\n\n    \n\n    \n    page_id = fields.Many2one('survey.page', string='Survey page',\n            ondelete='cascade', required=True, default=lambda self: self.env.context.get('page_id'))\n    survey_id = fields.Many2one('survey.survey', related='page_id.survey_id', string='Survey')\n    sequence = fields.Integer('Sequence', default=10)\n\n    \n    question = fields.Char('Question Name', required=True, translate=True)\n    description = fields.Html('Description', help=\"Use this field to add \\\n        additional explanations about your question\", translate=True,\n        oldname='descriptive_text')\n\n    \n    type = fields.Selection([\n            ('free_text', 'Multiple Lines Text Box'),\n            ('textbox', 'Single Line Text Box'),\n            ('numerical_box', 'Numerical Value'),\n            ('date', 'Date'),\n            ('simple_choice', 'Multiple choice: only one answer'),\n            ('multiple_choice', 'Multiple choice: multiple answers allowed'),\n            ('matrix', 'Matrix')], string='Type of Question', default='free_text', required=True)\n    matrix_subtype = fields.Selection([('simple', 'One choice per row'),\n        ('multiple', 'Multiple choices per row')], string='Matrix Type', default='simple')\n    labels_ids = fields.One2many('survey.label', 'question_id', string='Types of answers', oldname='answer_choice_ids', copy=True)\n    labels_ids_2 = fields.One2many('survey.label', 'question_id_2', string='Rows of the Matrix', copy=True)\n    \n    |\n    \n    \n    \n    \n\n    \n    column_nb = fields.Selection([('12', '1'),\n                                   ('6', '2'),\n                                   ('4', '3'),\n                                   ('3', '4'),\n                                   ('2', '6')],\n        'Number of columns', default='12')\n    # These options refer to col-xx-[12|6|4|3|2] classes in Bootstrap\n    display_mode = fields.Selection([('columns', 'Radio Buttons'),\n                                      ('dropdown', 'Selection Box')],\n                                    default='columns')\n\n    \n    comments_allowed = fields.Boolean('Show Comments Field',\n        oldname=\"allow_comment\")\n    comments_message = fields.Char('Comment Message', translate=True, default=lambda self: _(\"If other, please specify:\"))\n    comment_count_as_answer = fields.Boolean('Comment Field is an Answer Choice',\n        oldname='make_comment_field')\n\n    \n    validation_required = fields.Boolean('Validate entry', oldname='is_validation_require')\n    validation_email = fields.Boolean('Input must be an email')\n    validation_length_min = fields.Integer('Minimum Text Length')\n    validation_length_max = fields.Integer('Maximum Text Length')\n    validation_min_float_value = fields.Float('Minimum value')\n    validation_max_float_value = fields.Float('Maximum value')\n    validation_min_date = fields.Date('Minimum Date')\n    validation_max_date = fields.Date('Maximum Date')\n    validation_error_msg = fields.Char('Validation Error message', oldname='validation_valid_err_msg',\n                                        translate=True, default=lambda self: _(\"The answer you entered has an invalid format.\"))\n\n    # Constraints on number of answers (matrices)\n    constr_mandatory = fields.Boolean('Mandatory Answer', oldname=\"is_require_answer\")\n    constr_error_msg = fields.Char('Error message', oldname='req_error_msg', translate=True, default=lambda self: _(\"This question requires an answer.\"))\n    user_input_line_ids = fields.One2many('survey.user_input_line', 'question_id', string='Answers', domain=[('skipped', '=', False)])\n\n    _sql_constraints = [\n        ('positive_len_min', 'CHECK (validation_length_min >= 0)', 'A length must be positive!'),\n        ('positive_len_max', 'CHECK (validation_length_max >= 0)', 'A length must be positive!'),\n        ('validation_length', 'CHECK (validation_length_min <= validation_length_max)', 'Max length cannot be smaller than min length!'),\n        ('validation_float', 'CHECK (validation_min_float_value <= validation_max_float_value)', 'Max value cannot be smaller than min value!'),\n        ('validation_date', 'CHECK (validation_min_date <= validation_max_date)', 'Max date cannot be smaller than min date!')\n    ]\n\n    @api.onchange('validation_email')\n    def onchange_validation_email(self):\n        if self.validation_email:\n            self.validation_required = False\n\n     methods\n\n    @api.multi\n    def validate_question(self, post, answer_tag):\n        \"\"\" Validate question, depending on question type and parameters \"\"\"\n        self.ensure_one()\n        try:\n            checker = getattr(self, 'validate_' + self.type)\n        except AttributeError:\n            _logger.warning(self.type + \": This type of question has no validation method\")\n            return {}\n        else:\n            return checker(post, answer_tag)\n\n    @api.multi\n    def validate_free_text(self, post, answer_tag):\n        self.ensure_one()\n        errors = {}\n        answer = post[answer_tag].strip()\n        \n        if self.constr_mandatory and not answer:\n            errors.update({answer_tag: self.constr_error_msg})\n        return errors\n\n    @api.multi\n    def validate_textbox(self, post, answer_tag):\n        self.ensure_one()\n        errors = {}\n        answer = post[answer_tag].strip()\n        \n        if self.constr_mandatory and not answer:\n            errors.update({answer_tag: self.constr_error_msg})\n        \n        \n        \n        \n        \n        if answer and self.validation_email:\n            if not email_validator.match(answer):\n                errors.update({answer_tag: _('This answer must be an email address')})\n         validation (if properly defined)\n        \n        if answer and self.validation_required:\n            if not (self.validation_length_min <= len(answer) <= self.validation_length_max):\n                errors.update({answer_tag: self.validation_error_msg})\n        return errors\n\n    @api.multi\n    def validate_numerical_box(self, post, answer_tag):\n        self.ensure_one()\n        errors = {}\n        answer = post[answer_tag].strip()\n        \n        if self.constr_mandatory and not answer:\n            errors.update({answer_tag: self.constr_error_msg})\n        \n        if answer:\n            try:\n                floatanswer = float(answer)\n            except ValueError:\n                errors.update({answer_tag: _('This is not a number')})\n         validation (if properly defined)\n        if answer and self.validation_required:\n             is not in the right range\n            with tools.ignore(Exception):\n                floatanswer = float(answer)  \n                if not (self.validation_min_float_value <= floatanswer <= self.validation_max_float_value):\n                    errors.update({answer_tag: self.validation_error_msg})\n        return errors\n\n    @api.multi\n    def validate_date(self, post, answer_tag):\n        self.ensure_one()\n        errors = {}\n        answer = post[answer_tag].strip()\n        \n        if self.constr_mandatory and not answer:\n            errors.update({answer_tag: self.constr_error_msg})\n        \n        if answer:\n            try:\n                dateanswer = fields.Date.from_string(answer)\n            except ValueError:\n                errors.update({answer_tag: _('This is not a date')})\n                return errors\n         validation (if properly defined)\n        if answer and self.validation_required:\n             is not in the right range\n            try:\n                date_from_string = fields.Date.from_string\n                dateanswer = date_from_string(answer)\n                min_date = date_from_string(self.validation_min_date)\n                max_date = date_from_string(self.validation_max_date)\n\n                if min_date and max_date and not (min_date <= dateanswer <= max_date):\n                    \n                    errors.update({answer_tag: self.validation_error_msg})\n                elif min_date and not min_date <= dateanswer:\n                    \n                    errors.update({answer_tag: self.validation_error_msg})\n                elif max_date and not dateanswer <= max_date:\n                    \n                    errors.update({answer_tag: self.validation_error_msg})\n            except ValueError:  \n                pass\n        return errors\n\n    @api.multi\n    def validate_simple_choice(self, post, answer_tag):\n        self.ensure_one()\n        errors = {}\n        if self.comments_allowed:\n            comment_tag = \"%s_%s\" % (answer_tag, 'comment')\n        \n        if self.constr_mandatory and answer_tag not in post:\n            errors.update({answer_tag: self.constr_error_msg})\n        if self.constr_mandatory and answer_tag in post and not post[answer_tag].strip():\n            errors.update({answer_tag: self.constr_error_msg})\n         is a comment and is empty\n        if self.constr_mandatory and answer_tag in post and post[answer_tag] == \"-1\" and self.comment_count_as_answer and comment_tag in post and not post[comment_tag].strip():\n            errors.update({answer_tag: self.constr_error_msg})\n        return errors\n\n    @api.multi\n    def validate_multiple_choice(self, post, answer_tag):\n        self.ensure_one()\n        errors = {}\n        if self.constr_mandatory:\n            answer_candidates = dict_keys_startswith(post, answer_tag)\n            comment_flag = answer_candidates.pop((\"%s_%s\" % (answer_tag, -1)), None)\n            if self.comments_allowed:\n                comment_answer = answer_candidates.pop((\"%s_%s\" % (answer_tag, 'comment')), '').strip()\n            \n            if all(not answer.strip() for answer in answer_candidates.values()) and answer_candidates:\n                errors.update({answer_tag: self.constr_error_msg})\n            # There is no answer neither comments (if comments count as answer)\n            if not answer_candidates and self.comment_count_as_answer and (not comment_flag or not comment_answer):\n                errors.update({answer_tag: self.constr_error_msg})\n            \n            if not answer_candidates and not self.comment_count_as_answer:\n                errors.update({answer_tag: self.constr_error_msg})\n        return errors\n\n    @api.multi\n    def validate_matrix(self, post, answer_tag):\n        self.ensure_one()\n        errors = {}\n        if self.constr_mandatory:\n            lines_number = len(self.labels_ids_2)\n            answer_candidates = dict_keys_startswith(post, answer_tag)\n            answer_candidates.pop((\"%s_%s\" % (answer_tag, 'comment')), '').strip()\n            \n            if self.matrix_subtype == 'simple':\n                answer_number = len(answer_candidates)\n            elif self.matrix_subtype == 'multiple':\n                answer_number = len({sk.rsplit('_', 1)[0] for sk in answer_candidates})\n            else:\n                raise RuntimeError(\"Invalid matrix subtype\")\n            \n            if answer_number != lines_number:\n                errors.update({answer_tag: self.constr_error_msg})\n        return errors\n\n\nclass SurveyLabel(models.Model):\n    \"\"\" A suggested answer for a question \"\"\"\n\n    _name = 'survey.label'\n    _rec_name = 'value'\n    _order = 'sequence,id'\n    _description = 'Survey Label'\n\n    question_id = fields.Many2one('survey.question', string='Question', ondelete='cascade')\n    question_id_2 = fields.Many2one('survey.question', string='Question 2', ondelete='cascade')\n    sequence = fields.Integer('Label Sequence order', default=10)\n    value = fields.Char('Suggested value', translate=True, required=True)\n    quizz_mark = fields.Float('Score for this choice', help=\"A positive score indicates a correct choice; a negative or null score indicates a wrong answer\")\n\n    @api.one\n    @api.constrains('question_id', 'question_id_2')\n    def _check_question_not_empty(self):\n        \"\"\"Ensure that field question_id XOR field question_id_2 is not null\"\"\"\n        if not bool(self.question_id) != bool(self.question_id_2):\n            raise ValidationError(\"A label must be attached to one and only one question\")\n\n\nclass SurveyUserInput(models.Model):\n    \"\"\" Metadata for a set of one user's answers to a particular survey \"\"\"\n\n    _name = \"survey.user_input\"\n    _rec_name = 'date_create'\n    _description = 'Survey User Input'\n\n    survey_id = fields.Many2one('survey.survey', string='Survey', required=True, readonly=True, ondelete='restrict')\n    date_create = fields.Datetime('Creation Date', default=fields.Datetime.now, required=True, readonly=True, copy=False)\n    deadline = fields.Datetime('Deadline', help=\"Date by which the person can open the survey and submit answers\", oldname=\"date_deadline\")\n    type = fields.Selection([('manually', 'Manually'), ('link', 'Link')], string='Answer Type', default='manually', required=True, readonly=True, oldname=\"response_type\")\n    state = fields.Selection([\n        ('new', 'Not started yet'),\n        ('skip', 'Partially completed'),\n        ('done', 'Completed')], string='Status', default='new', readonly=True)\n    test_entry = fields.Boolean(readonly=True)\n    token = fields.Char('Identification token', default=lambda self: str(uuid.uuid4()), readonly=True, required=True, copy=False)\n\n    \n    partner_id = fields.Many2one('res.partner', string='Partner', readonly=True)\n    email = fields.Char('E-mail', readonly=True)\n\n    \n    last_displayed_page_id = fields.Many2one('survey.page', string='Last displayed page')\n    \n    user_input_line_ids = fields.One2many('survey.user_input_line', 'user_input_id', string='Answers', copy=True)\n\n    \n    result_url = fields.Char(\"Public link to the survey results\", related='survey_id.result_url')\n    print_url = fields.Char(\"Public link to the empty survey\", related='survey_id.print_url')\n\n    quizz_score = fields.Float(\"Score for the quiz\", compute=\"_compute_quizz_score\", default=0.0)\n\n    @api.depends('user_input_line_ids.quizz_mark')\n    def _compute_quizz_score(self):\n        for user_input in self:\n            user_input.quizz_score = sum(user_input.user_input_line_ids.mapped('quizz_mark'))\n\n    _sql_constraints = [\n        ('unique_token', 'UNIQUE (token)', 'A token must be unique!'),\n        ('deadline_in_the_past', 'CHECK (deadline >= date_create)', 'The deadline cannot be in the past')\n    ]\n\n    @api.model\n    def do_clean_emptys(self):\n        \"\"\" Remove empty user inputs that have been created manually\n            (used as a cronjob declared in data/survey_cron.xml)\n        \"\"\"\n        an_hour_ago = fields.Datetime.to_string(datetime.datetime.now() - datetime.timedelta(hours=1))\n        self.search([('type', '=', 'manually'), ('state', '=', 'new'),\n                    ('date_create', '<', an_hour_ago)]).unlink()\n\n    @api.multi\n    def action_survey_resend(self):\n        \"\"\" Send again the invitation \"\"\"\n        self.ensure_one()\n        local_context = {\n            'survey_resent_token': True,\n            'default_partner_ids': self.partner_id and [self.partner_id.id] or [],\n            'default_multi_email': self.email or \"\",\n            'default_public': 'email_private',\n        }\n        return self.survey_id.with_context(local_context).action_send_survey()\n\n    @api.multi\n    def action_view_answers(self):\n        \"\"\" Open the website page with the survey form \"\"\"\n        self.ensure_one()\n        return {\n            'type': 'ir.actions.act_url',\n            'name': \"View Answers\",\n            'target': 'self',\n            'url': '%s/%s' % (self.print_url, self.token)\n        }\n\n    @api.multi\n    def action_survey_results(self):\n        \"\"\" Open the website page with the survey results \"\"\"\n        self.ensure_one()\n        return {\n            'type': 'ir.actions.act_url',\n            'name': \"Survey Results\",\n            'target': 'self',\n            'url': self.result_url\n        }\n\n\nclass SurveyUserInputLine(models.Model):\n    _name = 'survey.user_input_line'\n    _description = 'Survey User Input Line'\n    _rec_name = 'date_create'\n\n    user_input_id = fields.Many2one('survey.user_input', string='User Input', ondelete='cascade', required=True)\n    question_id = fields.Many2one('survey.question', string='Question', ondelete='restrict', required=True)\n    page_id = fields.Many2one(related='question_id.page_id', string=\"Page\")\n    survey_id = fields.Many2one(related='user_input_id.survey_id', string='Survey', store=True)\n    date_create = fields.Datetime('Create Date', default=fields.Datetime.now, required=True)\n    skipped = fields.Boolean('Skipped')\n    answer_type = fields.Selection([\n        ('text', 'Text'),\n        ('number', 'Number'),\n        ('date', 'Date'),\n        ('free_text', 'Free Text'),\n        ('suggestion', 'Suggestion')], string='Answer Type')\n    value_text = fields.Char('Text answer')\n    value_number = fields.Float('Numerical answer')\n    value_date = fields.Date('Date answer')\n    value_free_text = fields.Text('Free Text answer')\n    value_suggested = fields.Many2one('survey.label', string=\"Suggested answer\")\n    value_suggested_row = fields.Many2one('survey.label', string=\"Row answer\")\n    quizz_mark = fields.Float('Score given for this choice')\n\n    @api.constrains('skipped', 'answer_type')\n    def _answered_or_skipped(self):\n        for uil in self:\n            if not uil.skipped != bool(uil.answer_type):\n                raise ValidationError(_('A question cannot be unanswered and skipped'))\n\n    @api.constrains('answer_type')\n    def _check_answer_type(self):\n        for uil in self:\n            fields_type = {\n                'text': bool(uil.value_text),\n                'number': (bool(uil.value_number) or uil.value_number == 0),\n                'date': bool(uil.value_date),\n                'free_text': bool(uil.value_free_text),\n                'suggestion': bool(uil.value_suggested)\n            }\n            if not fields_type.get(uil.answer_type, True):\n                raise ValidationError(_('The answer must be in the right type'))\n\n    def _get_mark(self, value_suggested):\n        label = self.env['survey.label'].browse(int(value_suggested))\n        mark = label.quizz_mark if label.exists() else 0.0\n        return mark\n\n    @api.model\n    def create(self, vals):\n        value_suggested = vals.get('value_suggested')\n        if value_suggested:\n            vals.update({'quizz_mark': self._get_mark(value_suggested)})\n        return super(SurveyUserInputLine, self).create(vals)\n\n    @api.multi\n    def write(self, vals):\n        value_suggested = vals.get('value_suggested')\n        if value_suggested:\n            vals.update({'quizz_mark': self._get_mark(value_suggested)})\n        return super(SurveyUserInputLine, self).write(vals)\n\n    @api.model\n    def save_lines(self, user_input_id, question, post, answer_tag):\n        \"\"\" Save answers to questions, depending on question type\n\n            If an answer already exists for question and user_input_id, it will be\n            overwritten (in order to maintain data consistency).\n        \"\"\"\n        try:\n            saver = getattr(self, 'save_line_' + question.type)\n        except AttributeError:\n            _logger.error(question.type + \": This type of question has no saving function\")\n            return False\n        else:\n            saver(user_input_id, question, post, answer_tag)\n\n    @api.model\n    def save_line_free_text(self, user_input_id, question, post, answer_tag):\n        vals = {\n            'user_input_id': user_input_id,\n            'question_id': question.id,\n            'survey_id': question.survey_id.id,\n            'skipped': False,\n        }\n        if answer_tag in post and post[answer_tag].strip():\n            vals.update({'answer_type': 'free_text', 'value_free_text': post[answer_tag]})\n        else:\n            vals.update({'answer_type': None, 'skipped': True})\n        old_uil = self.search([\n            ('user_input_id', '=', user_input_id),\n            ('survey_id', '=', question.survey_id.id),\n            ('question_id', '=', question.id)\n        ])\n        if old_uil:\n            old_uil.write(vals)\n        else:\n            old_uil.create(vals)\n        return True\n\n    @api.model\n    def save_line_textbox(self, user_input_id, question, post, answer_tag):\n        vals = {\n            'user_input_id': user_input_id,\n            'question_id': question.id,\n            'survey_id': question.survey_id.id,\n            'skipped': False\n        }\n        if answer_tag in post and post[answer_tag].strip():\n            vals.update({'answer_type': 'text', 'value_text': post[answer_tag]})\n        else:\n            vals.update({'answer_type': None, 'skipped': True})\n        old_uil = self.search([\n            ('user_input_id', '=', user_input_id),\n            ('survey_id', '=', question.survey_id.id),\n            ('question_id', '=', question.id)\n        ])\n        if old_uil:\n            old_uil.write(vals)\n        else:\n            old_uil.create(vals)\n        return True\n\n    @api.model\n    def save_line_numerical_box(self, user_input_id, question, post, answer_tag):\n        vals = {\n            'user_input_id': user_input_id,\n            'question_id': question.id,\n            'survey_id': question.survey_id.id,\n            'skipped': False\n        }\n        if answer_tag in post and post[answer_tag].strip():\n            vals.update({'answer_type': 'number', 'value_number': float(post[answer_tag])})\n        else:\n            vals.update({'answer_type': None, 'skipped': True})\n        old_uil = self.search([\n            ('user_input_id', '=', user_input_id),\n            ('survey_id', '=', question.survey_id.id),\n            ('question_id', '=', question.id)\n        ])\n        if old_uil:\n            old_uil.write(vals)\n        else:\n            old_uil.create(vals)\n        return True\n\n    @api.model\n    def save_line_date(self, user_input_id, question, post, answer_tag):\n        vals = {\n            'user_input_id': user_input_id,\n            'question_id': question.id,\n            'survey_id': question.survey_id.id,\n            'skipped': False\n        }\n        if answer_tag in post and post[answer_tag].strip():\n            vals.update({'answer_type': 'date', 'value_date': post[answer_tag]})\n        else:\n            vals.update({'answer_type': None, 'skipped': True})\n        old_uil = self.search([\n            ('user_input_id', '=', user_input_id),\n            ('survey_id', '=', question.survey_id.id),\n            ('question_id', '=', question.id)\n        ])\n        if old_uil:\n            old_uil.write(vals)\n        else:\n            old_uil.create(vals)\n        return True\n\n    @api.model\n    def save_line_simple_choice(self, user_input_id, question, post, answer_tag):\n        vals = {\n            'user_input_id': user_input_id,\n            'question_id': question.id,\n            'survey_id': question.survey_id.id,\n            'skipped': False\n        }\n        old_uil = self.search([\n            ('user_input_id', '=', user_input_id),\n            ('survey_id', '=', question.survey_id.id),\n            ('question_id', '=', question.id)\n        ])\n        old_uil.sudo().unlink()\n\n        if answer_tag in post and post[answer_tag].strip():\n            vals.update({'answer_type': 'suggestion', 'value_suggested': post[answer_tag]})\n        else:\n            vals.update({'answer_type': None, 'skipped': True})\n\n        \n        if post.get(answer_tag) and post.get(answer_tag) != '-1':\n            self.create(vals)\n\n        comment_answer = post.pop((\"%s_%s\" % (answer_tag, 'comment')), '').strip()\n        if comment_answer:\n            vals.update({'answer_type': 'text', 'value_text': comment_answer, 'skipped': False, 'value_suggested': False})\n            self.create(vals)\n\n        return True\n\n    @api.model\n    def save_line_multiple_choice(self, user_input_id, question, post, answer_tag):\n        vals = {\n            'user_input_id': user_input_id,\n            'question_id': question.id,\n            'survey_id': question.survey_id.id,\n            'skipped': False\n        }\n        old_uil = self.search([\n            ('user_input_id', '=', user_input_id),\n            ('survey_id', '=', question.survey_id.id),\n            ('question_id', '=', question.id)\n        ])\n        old_uil.sudo().unlink()\n\n        ca_dict = dict_keys_startswith(post, answer_tag + '_')\n        comment_answer = ca_dict.pop((\"%s_%s\" % (answer_tag, 'comment')), '').strip()\n        if len(ca_dict) > 0:\n            for key in ca_dict:\n                \n                if key != ('%s_%s' % (answer_tag, '-1')):\n                    vals.update({'answer_type': 'suggestion', 'value_suggested': ca_dict[key]})\n                    self.create(vals)\n        if comment_answer:\n            vals.update({'answer_type': 'text', 'value_text': comment_answer, 'value_suggested': False})\n            self.create(vals)\n        if not ca_dict and not comment_answer:\n            vals.update({'answer_type': None, 'skipped': True})\n            self.create(vals)\n        return True\n\n    @api.model\n    def save_line_matrix(self, user_input_id, question, post, answer_tag):\n        vals = {\n            'user_input_id': user_input_id,\n            'question_id': question.id,\n            'survey_id': question.survey_id.id,\n            'skipped': False\n        }\n        old_uil = self.search([\n            ('user_input_id', '=', user_input_id),\n            ('survey_id', '=', question.survey_id.id),\n            ('question_id', '=', question.id)\n        ])\n        old_uil.sudo().unlink()\n\n        no_answers = True\n        ca_dict = dict_keys_startswith(post, answer_tag + '_')\n\n        comment_answer = ca_dict.pop((\"%s_%s\" % (answer_tag, 'comment')), '').strip()\n        if comment_answer:\n            vals.update({'answer_type': 'text', 'value_text': comment_answer})\n            self.create(vals)\n            no_answers = False\n\n        if question.matrix_subtype == 'simple':\n            for row in question.labels_ids_2:\n                a_tag = \"%s_%s\" % (answer_tag, row.id)\n                if a_tag in ca_dict:\n                    no_answers = False\n                    vals.update({'answer_type': 'suggestion', 'value_suggested': ca_dict[a_tag], 'value_suggested_row': row.id})\n                    self.create(vals)\n\n        elif question.matrix_subtype == 'multiple':\n            for col in question.labels_ids:\n                for row in question.labels_ids_2:\n                    a_tag = \"%s_%s_%s\" % (answer_tag, row.id, col.id)\n                    if a_tag in ca_dict:\n                        no_answers = False\n                        vals.update({'answer_type': 'suggestion', 'value_suggested': col.id, 'value_suggested_row': row.id})\n                        self.create(vals)\n        if no_answers:\n            vals.update({'answer_type': None, 'skipped': True})\n            self.create(vals)\n        return True\n", "comments": "   returns dictionary containing elements  dict  whose keys start  string              note               this function uses dictionary comprehensions (python    2 7)             return  k  v k  v dictionary items() k startswith(string)    class surveystage(models model)         stages kanban view surveys          name    survey stage       description    survey stage       order    sequence id       name   fields char(required true  translate true)     sequence   fields integer(default 1)     closed   fields boolean(help  if closed  people able answer surveys column  )     fold   fields boolean(string  folded kanban view )       sql constraints             ( positive sequence    check(sequence    0)    sequence number must natural )         class survey(models model)          settings multi page multi question survey          each survey one attached pages  page display         one questions                name    survey survey       description    survey       rec name    title       inherit     mail thread    mail activity mixin        def  default stage(self)          return self env  survey stage   search(    limit 1) id      title   fields char( title   required true  translate true)     page ids   fields one2many( survey page    survey id   string  pages   copy true)     stage id   fields many2one( survey stage   string  stage   default  default stage                                 ondelete  set null   copy false  group expand   read group stage ids )     auth required   fields boolean( login required   help  users public link requested login taking part survey           oldname  authenticate )     users go back   fields boolean( users go back   help  if checked  users go back previous pages  )     tot sent survey   fields integer( number sent surveys   compute   compute survey statistic )     tot start survey   fields integer( number started surveys   compute   compute survey statistic )     tot comp survey   fields integer( number completed surveys   compute   compute survey statistic )     description   fields html( description   translate true  help  a long description purpose survey )     color   fields integer( color index   default 0)     user input ids   fields one2many( survey user input    survey id   string  user responses   readonly true)     designed   fields boolean( is designed    compute   designed )     public url   fields char( public link   compute   compute survey url )     public url html   fields char( public link (html version)   compute   compute survey url )     print url   fields char( print link   compute   compute survey url )     result url   fields char( results link   compute   compute survey url )     email template id   fields many2one( mail template   string  email template   ondelete  set null )     thank message   fields html( thanks message   translate true  help  this message displayed survey completed )     quizz mode   fields boolean( quizz mode )     active   fields boolean( active   default true)     closed   fields boolean( is closed   related  stage id closed )      def  designed(self)          survey self              survey page ids  page question ids page survey page ids page question ids                   survey designed   false             else                  survey designed   true       api multi     def  compute survey statistic(self)          userinput   self env  survey user input            sent survey   userinput search( ( survey id      self ids)  ( type         link ) )         start survey   userinput search(      ( survey id      self ids)       ( state         skip )  ( state         done ) )         complete survey   userinput search( ( survey id      self ids)  ( state         done ) )          survey self              survey tot sent survey   len(sent survey filtered(lambda user input  user input survey id    survey))             survey tot start survey   len(start survey filtered(lambda user input  user input survey id    survey))             survey tot comp survey   len(complete survey filtered(lambda user input  user input survey id    survey))      def  compute survey url(self)              computes public url survey             base url       self env context get( relative url ) else                      self env  ir config parameter   sudo() get param( web base url )         survey self              survey public url   urls url join(base url   survey start     (slug(survey)))             survey print url   urls url join(base url   survey print     (slug(survey)))             survey result url   urls url join(base url   survey results     (slug(survey)))             survey public url html     href          (survey public url   ( click start survey ))       api model     def  read group stage ids(self  stages  domain  order)              read group customization order display stages             kanban view  even empty                     stage ids   stages  search(    order order  access rights uid superuser id)         return stages browse(stage ids)        public methods       def copy data(self  default none)          title    (  (copy) )   (self title)         default   dict(default     title title)         return super(survey  self) copy data(default)       api model     def next page(self  user input  page id  go back false)              the next page display user  knowing page id id             last displayed page               if page id    0  always return first page survey               if pages displayed go back    false              return none              if go back    true  return  previous  page instead             next page                  note                   it assumed careful user try set go back                 true knows page display first one                  (doing probably cause giant worm eat house)                     survey   user input survey id         pages   list(enumerate(survey page ids))            first page         page id    0              return (pages 0  1   0  len(pages)    1)          current page index   pages index(next(p p pages p 1  id    page id))            all pages displayed         current page index    len(pages)   1 go back              return (none   1  false)           let get back  baby          elif go back survey users go back              return (pages current page index   1  1   current page index   1  false)         else                this show last page             current page index    len(pages)   2                  return (pages current page index   1  1   current page index   1  true)               this show regular page             else                  return (pages current page index   1  1   current page index   1  false)       api multi     def filter input ids(self  filters  finished false)             if user applies filters  function returns list            filtered user input id label strings display data web              param filters  list dictionary (having  row id  ansewr id)             param finished  true completely filled survey falser otherwise              returns list filtered user input ids                      self ensure one()         filters              domain filter  choice                      current filter filters                  row id  answer id   current filter  row id    current filter  answer id                   row id    0                      choice append(answer id)                 else                      domain filter extend(      ( value suggested row id        row id)  ( value suggested id        answer id) )             choice                  domain filter insert(0  ( value suggested id      choice))             else                  domain filter   domain filter 1               input lines   self env  survey user input line   search(domain filter)             filtered input ids    input line user input id id input line input lines          else              filtered input ids              finished              userinput   self env  survey user input               filtered input ids                  user inputs   userinput search( ( survey id        self id) )             else                  user inputs   userinput browse(filtered input ids)             return user inputs filtered(lambda input item  input item state     done ) ids         return filtered input ids       api model     def get filter display data(self  filters)             returns data display current filters              param filters  list dictionary (having  row id  answer id)              returns list dict data display filters                      filter display data              filters              label   self env  survey label               current filter filters                  row id  answer id   current filter  row id    current filter  answer id                   label   label browse(answer id)                 question   label question id                 row id    0                      labels   label                 else                      labels   label browse( row id  answer id )                 filter display data append(  question text   question question                                               labels   labels mapped( value ) )         return filter display data       api model     def prepare result(self  question  current filters none)              compute statistical data questions counting number vote per choice basis filter             current filters   current filters current filters else            result summary                 calculate return statistics choice         question type   simple choice    multiple choice                answers                  comments                   answers update( label id    text   label value   count   0   answer id   label id  ) label question labels ids              input line question user input line ids                  input line answer type     suggestion  answers get(input line value suggested id) (not(current filters) input line user input id id current filters)                      answers input line value suggested id   count      1                 input line answer type     text  (not(current filters) input line user input id id current filters)                      comments append(input line)             result summary     answers   list(answers values())   comments   comments             calculate return statistics matrix         question type     matrix               rows   ordereddict()             answers   ordereddict()             res   dict()             comments                   rows update( label id  label value ) label question labels ids 2               answers update( label id  label value ) label question labels ids              cell product(rows  answers)                  res cell    0             input line question user input line ids                  input line answer type     suggestion  (not(current filters) input line user input id id current filters) input line value suggested row                      res (input line value suggested row id  input line value suggested id)     1                 input line answer type     text  (not(current filters) input line user input id id current filters)                      comments append(input line)             result summary     answers   answers   rows   rows   result   res   comments   comments             calculate return statistics free text  textbox  date         question type   free text    textbox    date                result summary                  input line question user input line ids                  not(current filters) input line user input id id current filters                      result summary append(input line)            calculate return statistics numerical box         question type     numerical box               result summary     input lines                   inputs                  input line question user input line ids                  not(current filters) input line user input id id current filters                      inputs append(input line value number)                     result summary  input lines   append(input line)             inputs                  result summary update(  average   round(sum(all inputs)   len(all inputs)  2)                                          max   round(max(all inputs)  2)                                          min   round(min(all inputs)  2)                                          sum   sum(all inputs)                                          common   counter(all inputs) common(5) )         return result summary       api model     def get input summary(self  question  current filters none)              returns overall summary question e g  answered  skipped  total inputs basis filter             current filters   current filters current filters else            result              question survey id user input ids              total input ids   current filters  input id id input id question survey id user input ids input id state     new               result  total inputs     len(total input ids)             question input ids                  user input question user input line ids                  user input skipped                      question input ids append(user input user input id id)             result  answered     len(set(question input ids)   set(total input ids))             result  skipped     result  total inputs     result  answered           return result        actions       api multi     def action start survey(self)              open website page survey form             self ensure one()         token   self env context get( survey token )         trail         token token else            return                type    ir actions act url                name    start survey                target    self                url   self context(relative url true) public url   trail                 api multi     def action send survey(self)              open window compose email  pre filled survey message               ensure survey least one page least one question          self page ids  page question ids page self page ids page question ids               raise usererror( ( you cannot send invitation survey questions  ))          self stage id closed              raise usererror( ( you cannot send invitations closed surveys  ))          template   self env ref( survey email template survey   raise found false)          local context   dict(             self env context              default model  survey survey               default res id self id              default survey id self id              default use template bool(template)              default template id template template id false              default composition mode  comment          )         return                type    ir actions act window                view type    form                view mode    form                res model    survey mail compose message                target    new                context   local context                  api multi     def action print survey(self)              open website page survey printable view             self ensure one()         token   self env context get( survey token )         trail         token token else            return                type    ir actions act url                name    print survey                target    self                url   self context(relative url true) print url   trail                 api multi     def action result survey(self)              open website page survey results view             self ensure one()         return                type    ir actions act url                name    results survey                target    self                url   self context(relative url true) result url                 api multi     def action test survey(self)              open website page survey form test mode            self ensure one()         return                type    ir actions act url                name    results survey                target    self                url   self context(relative url true) public url     phantom                  api multi     def action survey user input(self)          action rec   self env ref( survey action survey user input )         action   action rec read() 0          ctx   dict(self env context)         ctx update(  search default survey id   self ids 0                        search default completed   1 )         action  context     ctx         return action   class surveypage(models model)          a page survey           pages essentially containers  allowing group questions ordered         screens              note               a page deleted survey belongs deleted               name    survey page       description    survey page       rec name    title       order    sequence id         model fields        title   fields char( page title   required true  translate true)     survey id   fields many2one( survey survey   string  survey   ondelete  cascade   required true)     question ids   fields one2many( survey question    page id   string  questions   copy true)     sequence   fields integer( page number   default 10)     description   fields html( description   translate true  oldname  note   help  an introductory text page )   class surveyquestion(models model)          questions asked survey           each question one suggested answers (eg  case         dropdown choices  multi answer checkboxes  radio buttons   )                name    survey question       description    survey question       rec name    question       order    sequence id         model fields          question metadata     page id   fields many2one( survey page   string  survey page               ondelete  cascade   required true  default lambda self  self env context get( page id ))     survey id   fields many2one( survey survey   related  page id survey id   string  survey )     sequence   fields integer( sequence   default 10)        question     question   fields char( question name   required true  translate true)     description   fields html( description   help  use field add           additional explanations question   translate true          oldname  descriptive text )        answer     type   fields selection(              ( free text    multiple lines text box )              ( textbox    single line text box )              ( numerical box    numerical value )              ( date    date )              ( simple choice    multiple choice  one answer )              ( multiple choice    multiple choice  multiple answers allowed )              ( matrix    matrix )   string  type question   default  free text   required true)     matrix subtype   fields selection( ( simple    one choice per row )          ( multiple    multiple choices per row )   string  matrix type   default  simple )     labels ids   fields one2many( survey label    question id   string  types answers   oldname  answer choice ids   copy true)     labels ids 2   fields one2many( survey label    question id 2   string  rows matrix   copy true)       labels used proposed choices       question type    simple choice   multiple choice                             labels ids used       question type    matrix                             labels ids columns matrix                             labels ids 2 rows matrix        display options     column nb   fields selection( ( 12    1 )                                     ( 6    2 )                                     ( 4    3 )                                     ( 3    4 )                                     ( 2    6 )            number columns   default  12 )       these options refer col xx  12 6 4 3 2  classes bootstrap     display mode   fields selection( ( columns    radio buttons )                                        ( dropdown    selection box )                                       default  columns )        comments     comments allowed   fields boolean( show comments field           oldname  allow comment )     comments message   fields char( comment message   translate true  default lambda self   ( if  please specify  ))     comment count answer   fields boolean( comment field answer choice           oldname  make comment field )        validation     validation required   fields boolean( validate entry   oldname  validation require )     validation email   fields boolean( input must email )     validation length min   fields integer( minimum text length )     validation length max   fields integer( maximum text length )     validation min float value   fields float( minimum value )     validation max float value   fields float( maximum value )     validation min date   fields date( minimum date )     validation max date   fields date( maximum date )     validation error msg   fields char( validation error message   oldname  validation valid err msg                                           translate true  default lambda self   ( the answer entered invalid format  ))        constraints number answers (matrices)     constr mandatory   fields boolean( mandatory answer   oldname  require answer )     constr error msg   fields char( error message   oldname  req error msg   translate true  default lambda self   ( this question requires answer  ))     user input line ids   fields one2many( survey user input line    question id   string  answers   domain  ( skipped        false) )       sql constraints             ( positive len min    check (validation length min    0)    a length must positive  )          ( positive len max    check (validation length max    0)    a length must positive  )          ( validation length    check (validation length min    validation length max)    max length cannot smaller min length  )          ( validation float    check (validation min float value    validation max float value)    max value cannot smaller min value  )          ( validation date    check (validation min date    validation max date)    max date cannot smaller min date  )             api onchange( validation email )     def onchange validation email(self)          self validation email              self validation required   false        validation methods       api multi     def validate question(self  post  answer tag)              validate question  depending question type parameters             self ensure one()         try              checker   getattr(self   validate     self type)         except attributeerror               logger warning(self type      this type question validation method )             return            else              return checker(post  answer tag)       api multi     def validate free text(self  post  answer tag)          self ensure one()         errors              answer   post answer tag  strip()           empty answer mandatory question         self constr mandatory answer              errors update( answer tag  self constr error msg )         return errors       api multi     def validate textbox(self  post  answer tag)          self ensure one()         errors              answer   post answer tag  strip()           empty answer mandatory question         self constr mandatory answer              errors update( answer tag  self constr error msg )           email format validation           note  validation basic                strings form                something   anything   extension                accepted         answer self validation email              email validator match(answer)                  errors update( answer tag   ( this answer must email address ) )           answer validation (if properly defined)           length answer must range         answer self validation required              (self validation length min    len(answer)    self validation length max)                  errors update( answer tag  self validation error msg )         return errors       api multi     def validate numerical box(self  post  answer tag)          self ensure one()         errors              answer   post answer tag  strip()           empty answer mandatory question         self constr mandatory answer              errors update( answer tag  self constr error msg )           checks user input number         answer              try                  floatanswer   float(answer)             except valueerror                  errors update( answer tag   ( this number ) )           answer validation (if properly defined)         answer self validation required                answer right range             tools ignore(exception)                  floatanswer   float(answer)    check float done hereunder                 (self validation min float value    floatanswer    self validation max float value)                      errors update( answer tag  self validation error msg )         return errors       api multi     def validate date(self  post  answer tag)          self ensure one()         errors              answer   post answer tag  strip()           empty answer mandatory question         self constr mandatory answer              errors update( answer tag  self constr error msg )           checks user input date         answer              try                  dateanswer   fields date string(answer)             except valueerror                  errors update( answer tag   ( this date ) )                 return errors           answer validation (if properly defined)         answer self validation required                answer right range             try                  date string   fields date string                 dateanswer   date string(answer)                 min date   date string(self validation min date)                 max date   date string(self validation max date)                  min date max date (min date    dateanswer    max date)                        if minimum maximum date entered                     errors update( answer tag  self validation error msg )                 elif min date min date    dateanswer                        if minimum date entered define maximum date                     errors update( answer tag  self validation error msg )                 elif max date dateanswer    max date                        if maximum date entered define minimum date                     errors update( answer tag  self validation error msg )             except valueerror     check date done hereunder                 pass         return errors       api multi     def validate simple choice(self  post  answer tag)          self ensure one()         errors              self comments allowed              comment tag         (answer tag   comment )           empty answer mandatory self         self constr mandatory answer tag post              errors update( answer tag  self constr error msg )         self constr mandatory answer tag post post answer tag  strip()              errors update( answer tag  self constr error msg )           answer comment empty         self constr mandatory answer tag post post answer tag       1  self comment count answer comment tag post post comment tag  strip()              errors update( answer tag  self constr error msg )         return errors       api multi     def validate multiple choice(self  post  answer tag)          self ensure one()         errors              self constr mandatory              answer candidates   dict keys startswith(post  answer tag)             comment flag   answer candidates pop((      (answer tag   1))  none)             self comments allowed                  comment answer   answer candidates pop((      (answer tag   comment ))    ) strip()               preventing answers blank value             all(not answer strip() answer answer candidates values()) answer candidates                  errors update( answer tag  self constr error msg )               there answer neither comments (if comments count answer)             answer candidates self comment count answer (not comment flag comment answer)                  errors update( answer tag  self constr error msg )               there answer             answer candidates self comment count answer                  errors update( answer tag  self constr error msg )         return errors       api multi     def validate matrix(self  post  answer tag)          self ensure one()         errors              self constr mandatory              lines number   len(self labels ids 2)             answer candidates   dict keys startswith(post  answer tag)             answer candidates pop((      (answer tag   comment ))    ) strip()               number lines answered             self matrix subtype     simple                   answer number   len(answer candidates)             elif self matrix subtype     multiple                   answer number   len( sk rsplit(     1) 0  sk answer candidates )             else                  raise runtimeerror( invalid matrix subtype )               validate line answered             answer number    lines number                  errors update( answer tag  self constr error msg )         return errors   class surveylabel(models model)          a suggested answer question           name    survey label       rec name    value       order    sequence id       description    survey label       question id   fields many2one( survey question   string  question   ondelete  cascade )     question id 2   fields many2one( survey question   string  question 2   ondelete  cascade )     sequence   fields integer( label sequence order   default 10)     value   fields char( suggested value   translate true  required true)     quizz mark   fields float( score choice   help  a positive score indicates correct choice  negative null score indicates wrong answer )       api one      api constrains( question id    question id 2 )     def  check question empty(self)             ensure field question id xor field question id 2 null            bool(self question id)    bool(self question id 2)              raise validationerror( a label must attached one one question )   class surveyuserinput(models model)          metadata set one user answers particular survey           name    survey user input       rec name    date create       description    survey user input       survey id   fields many2one( survey survey   string  survey   required true  readonly true  ondelete  restrict )     date create   fields datetime( creation date   default fields datetime  required true  readonly true  copy false)     deadline   fields datetime( deadline   help  date person open survey submit answers   oldname  date deadline )     type   fields selection( ( manually    manually )  ( link    link )   string  answer type   default  manually   required true  readonly true  oldname  response type )     state   fields selection(          ( new    not started yet )          ( skip    partially completed )          ( done    completed )   string  status   default  new   readonly true)     test entry   fields boolean(readonly true)     token   fields char( identification token   default lambda self  str(uuid uuid4())  readonly true  required true  copy false)        optional identification data     partner id   fields many2one( res partner   string  partner   readonly true)     email   fields char( e mail   readonly true)        displaying data     last displayed page id   fields many2one( survey page   string  last displayed page )       the answers       user input line ids   fields one2many( survey user input line    user input id   string  answers   copy true)        urls used display answers     result url   fields char( public link survey results   related  survey id result url )     print url   fields char( public link empty survey   related  survey id print url )      quizz score   fields float( score quiz   compute   compute quizz score   default 0 0)       api depends( user input line ids quizz mark )     def  compute quizz score(self)          user input self              user input quizz score   sum(user input user input line ids mapped( quizz mark ))       sql constraints             ( unique token    unique (token)    a token must unique  )          ( deadline past    check (deadline    date create)    the deadline cannot past )             api model     def clean emptys(self)              remove empty user inputs created manually             (used cronjob declared data survey cron xml)                     hour ago   fields datetime string(datetime datetime now()   datetime timedelta(hours 1))         self search( ( type         manually )  ( state         new )                      ( date create        hour ago) ) unlink()       api multi     def action survey resend(self)              send invitation             self ensure one()         local context                  survey resent token   true               default partner ids   self partner id  self partner id id                   default multi email   self email                  default public    email private                     return self survey id context(local context) action send survey()       api multi     def action view answers(self)              open website page survey form             self ensure one()         return                type    ir actions act url                name    view answers                target    self                url         (self print url  self token)                 api multi     def action survey results(self)              open website page survey results             self ensure one()         return                type    ir actions act url                name    survey results                target    self                url   self result url             class surveyuserinputline(models model)       name    survey user input line       description    survey user input line       rec name    date create       user input id   fields many2one( survey user input   string  user input   ondelete  cascade   required true)     question id   fields many2one( survey question   string  question   ondelete  restrict   required true)     page id   fields many2one(related  question id page id   string  page )     survey id   fields many2one(related  user input id survey id   string  survey   store true)     date create   fields datetime( create date   default fields datetime  required true)     skipped   fields boolean( skipped )     answer type   fields selection(          ( text    text )          ( number    number )          ( date    date )          ( free text    free text )          ( suggestion    suggestion )   string  answer type )     value text   fields char( text answer )     value number   fields float( numerical answer )     value date   fields date( date answer )     value free text   fields text( free text answer )     value suggested   fields many2one( survey label   string  suggested answer )     value suggested row   fields many2one( survey label   string  row answer )     quizz mark   fields float( score given choice )       api constrains( skipped    answer type )     def  answered skipped(self)          uil self              uil skipped    bool(uil answer type)                  raise validationerror( ( a question cannot unanswered skipped ))       api constrains( answer type )     def  check answer type(self)          uil self              fields type                      text   bool(uil value text)                   number   (bool(uil value number) uil value number    0)                   date   bool(uil value date)                   free text   bool(uil value free text)                   suggestion   bool(uil value suggested)                           fields type get(uil answer type  true)                  raise validationerror( ( the answer must right type ))      def  get mark(self  value suggested)          label   self env  survey label   browse(int(value suggested))         mark   label quizz mark label exists() else 0 0         return mark       api model     def create(self  vals)          value suggested   vals get( value suggested )         value suggested              vals update(  quizz mark   self  get mark(value suggested) )         return super(surveyuserinputline  self) create(vals)       api multi     def write(self  vals)          value suggested   vals get( value suggested )         value suggested              vals update(  quizz mark   self  get mark(value suggested) )         return super(surveyuserinputline  self) write(vals)       api model     def save lines(self  user input id  question  post  answer tag)              save answers questions  depending question type              if answer already exists question user input id              overwritten (in order maintain data consistency)                     coding  utf 8        part odoo  see license file full copyright licensing details     public methods      first page    all pages displayed    let get back  baby     this show last page    this show regular page    calculate return statistics choice    calculate return statistics matrix    calculate return statistics free text  textbox  date    calculate return statistics numerical box    actions    ensure survey least one page least one question     model fields      model fields      question metadata    question    answer    labels used proposed choices    question type    simple choice   multiple choice                          labels ids used    question type    matrix                          labels ids columns matrix                          labels ids 2 rows matrix    display options    these options refer col xx  12 6 4 3 2  classes bootstrap    comments    validation    constraints number answers (matrices)    validation methods    empty answer mandatory question    empty answer mandatory question    email format validation    note  validation basic         strings form         something   anything   extension         accepted    answer validation (if properly defined)    length answer must range    empty answer mandatory question    checks user input number    answer validation (if properly defined)    answer right range    check float done hereunder    empty answer mandatory question    checks user input date    answer validation (if properly defined)    answer right range    if minimum maximum date entered    if minimum date entered define maximum date    if maximum date entered define minimum date    check date done hereunder    empty answer mandatory self    answer comment empty    preventing answers blank value    there answer neither comments (if comments count answer)    there answer    number lines answered    validate line answered    optional identification data    displaying data    the answers      urls used display answers      1  indicates  comment count answer  need record      1  indicates  comment count answer  need record ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nimport datetime\nimport logging\nimport re\nimport uuid\nfrom collections import Counter, OrderedDict\nfrom itertools import product\nfrom werkzeug import urls\n\nfrom odoo import api, fields, models, tools, SUPERUSER_ID, _\nfrom odoo.addons.http_routing.models.ir_http import slug\nfrom odoo.exceptions import UserError, ValidationError\nemail_validator = re.compile(r\"[^@]+@[^@]+\\.[^@]+\")\n_logger = logging.getLogger(__name__)\n\n\ndef dict_keys_startswith(dictionary, string):\n    \"\"\"Returns a dictionary containing the elements of <dict> whose keys start with <string>.\n        .. note::\n            This function uses dictionary comprehensions (Python >= 2.7)\n    \"\"\"\n    return {k: v for k, v in dictionary.items() if k.startswith(string)}\n\n\nclass SurveyStage(models.Model):\n    \"\"\"Stages for Kanban view of surveys\"\"\"\n\n    _name = 'survey.stage'\n    _description = 'Survey Stage'\n    _order = 'sequence,id'\n\n    name = fields.Char(required=True, translate=True)\n    sequence = fields.Integer(default=1)\n    closed = fields.Boolean(help=\"If closed, people won't be able to answer to surveys in this column.\")\n    fold = fields.Boolean(string=\"Folded in kanban view\")\n\n    _sql_constraints = [\n        ('positive_sequence', 'CHECK(sequence >= 0)', 'Sequence number MUST be a natural')\n    ]\n\n\nclass Survey(models.Model):\n    \"\"\" Settings for a multi-page/multi-question survey.\n        Each survey can have one or more attached pages, and each page can display\n        one or more questions.\n    \"\"\"\n\n    _name = 'survey.survey'\n    _description = 'Survey'\n    _rec_name = 'title'\n    _inherit = ['mail.thread', 'mail.activity.mixin']\n\n    def _default_stage(self):\n        return self.env['survey.stage'].search([], limit=1).id\n\n    title = fields.Char('Title', required=True, translate=True)\n    page_ids = fields.One2many('survey.page', 'survey_id', string='Pages', copy=True)\n    stage_id = fields.Many2one('survey.stage', string=\"Stage\", default=_default_stage,\n                               ondelete=\"set null\", copy=False, group_expand='_read_group_stage_ids')\n    auth_required = fields.Boolean('Login required', help=\"Users with a public link will be requested to login before taking part to the survey\",\n        oldname=\"authenticate\")\n    users_can_go_back = fields.Boolean('Users can go back', help=\"If checked, users can go back to previous pages.\")\n    tot_sent_survey = fields.Integer(\"Number of sent surveys\", compute=\"_compute_survey_statistic\")\n    tot_start_survey = fields.Integer(\"Number of started surveys\", compute=\"_compute_survey_statistic\")\n    tot_comp_survey = fields.Integer(\"Number of completed surveys\", compute=\"_compute_survey_statistic\")\n    description = fields.Html(\"Description\", translate=True, help=\"A long description of the purpose of the survey\")\n    color = fields.Integer('Color Index', default=0)\n    user_input_ids = fields.One2many('survey.user_input', 'survey_id', string='User responses', readonly=True)\n    designed = fields.Boolean(\"Is designed?\", compute=\"_is_designed\")\n    public_url = fields.Char(\"Public link\", compute=\"_compute_survey_url\")\n    public_url_html = fields.Char(\"Public link (html version)\", compute=\"_compute_survey_url\")\n    print_url = fields.Char(\"Print link\", compute=\"_compute_survey_url\")\n    result_url = fields.Char(\"Results link\", compute=\"_compute_survey_url\")\n    email_template_id = fields.Many2one('mail.template', string='Email Template', ondelete='set null')\n    thank_you_message = fields.Html(\"Thanks Message\", translate=True, help=\"This message will be displayed when survey is completed\")\n    quizz_mode = fields.Boolean(\"Quizz Mode\")\n    active = fields.Boolean(\"Active\", default=True)\n    is_closed = fields.Boolean(\"Is closed\", related='stage_id.closed')\n\n    def _is_designed(self):\n        for survey in self:\n            if not survey.page_ids or not [page.question_ids for page in survey.page_ids if page.question_ids]:\n                survey.designed = False\n            else:\n                survey.designed = True\n\n    @api.multi\n    def _compute_survey_statistic(self):\n        UserInput = self.env['survey.user_input']\n\n        sent_survey = UserInput.search([('survey_id', 'in', self.ids), ('type', '=', 'link')])\n        start_survey = UserInput.search(['&', ('survey_id', 'in', self.ids), '|', ('state', '=', 'skip'), ('state', '=', 'done')])\n        complete_survey = UserInput.search([('survey_id', 'in', self.ids), ('state', '=', 'done')])\n\n        for survey in self:\n            survey.tot_sent_survey = len(sent_survey.filtered(lambda user_input: user_input.survey_id == survey))\n            survey.tot_start_survey = len(start_survey.filtered(lambda user_input: user_input.survey_id == survey))\n            survey.tot_comp_survey = len(complete_survey.filtered(lambda user_input: user_input.survey_id == survey))\n\n    def _compute_survey_url(self):\n        \"\"\" Computes a public URL for the survey \"\"\"\n        base_url = '/' if self.env.context.get('relative_url') else \\\n                   self.env['ir.config_parameter'].sudo().get_param('web.base.url')\n        for survey in self:\n            survey.public_url = urls.url_join(base_url, \"survey/start/%s\" % (slug(survey)))\n            survey.print_url = urls.url_join(base_url, \"survey/print/%s\" % (slug(survey)))\n            survey.result_url = urls.url_join(base_url, \"survey/results/%s\" % (slug(survey)))\n            survey.public_url_html = '<a href=\"%s\">%s</a>' % (survey.public_url, _(\"Click here to start survey\"))\n\n    @api.model\n    def _read_group_stage_ids(self, stages, domain, order):\n        \"\"\" Read group customization in order to display all the stages in the\n            kanban view, even if they are empty\n        \"\"\"\n        stage_ids = stages._search([], order=order, access_rights_uid=SUPERUSER_ID)\n        return stages.browse(stage_ids)\n\n    # Public methods #\n    def copy_data(self, default=None):\n        title = _(\"%s (copy)\") % (self.title)\n        default = dict(default or {}, title=title)\n        return super(Survey, self).copy_data(default)\n\n    @api.model\n    def next_page(self, user_input, page_id, go_back=False):\n        \"\"\" The next page to display to the user, knowing that page_id is the id\n            of the last displayed page.\n\n            If page_id == 0, it will always return the first page of the survey.\n\n            If all the pages have been displayed and go_back == False, it will\n            return None\n\n            If go_back == True, it will return the *previous* page instead of the\n            next page.\n\n            .. note::\n                It is assumed here that a careful user will not try to set go_back\n                to True if she knows that the page to display is the first one!\n                (doing this will probably cause a giant worm to eat her house)\n        \"\"\"\n        survey = user_input.survey_id\n        pages = list(enumerate(survey.page_ids))\n\n        # First page\n        if page_id == 0:\n            return (pages[0][1], 0, len(pages) == 1)\n\n        current_page_index = pages.index(next(p for p in pages if p[1].id == page_id))\n\n        # All the pages have been displayed\n        if current_page_index == len(pages) - 1 and not go_back:\n            return (None, -1, False)\n        # Let's get back, baby!\n        elif go_back and survey.users_can_go_back:\n            return (pages[current_page_index - 1][1], current_page_index - 1, False)\n        else:\n            # This will show the last page\n            if current_page_index == len(pages) - 2:\n                return (pages[current_page_index + 1][1], current_page_index + 1, True)\n            # This will show a regular page\n            else:\n                return (pages[current_page_index + 1][1], current_page_index + 1, False)\n\n    @api.multi\n    def filter_input_ids(self, filters, finished=False):\n        \"\"\"If user applies any filters, then this function returns list of\n           filtered user_input_id and label's strings for display data in web.\n           :param filters: list of dictionary (having: row_id, ansewr_id)\n           :param finished: True for completely filled survey,Falser otherwise.\n           :returns list of filtered user_input_ids.\n        \"\"\"\n        self.ensure_one()\n        if filters:\n            domain_filter, choice = [], []\n            for current_filter in filters:\n                row_id, answer_id = current_filter['row_id'], current_filter['answer_id']\n                if row_id == 0:\n                    choice.append(answer_id)\n                else:\n                    domain_filter.extend(['|', ('value_suggested_row.id', '=', row_id), ('value_suggested.id', '=', answer_id)])\n            if choice:\n                domain_filter.insert(0, ('value_suggested.id', 'in', choice))\n            else:\n                domain_filter = domain_filter[1:]\n            input_lines = self.env['survey.user_input_line'].search(domain_filter)\n            filtered_input_ids = [input_line.user_input_id.id for input_line in input_lines]\n        else:\n            filtered_input_ids = []\n        if finished:\n            UserInput = self.env['survey.user_input']\n            if not filtered_input_ids:\n                user_inputs = UserInput.search([('survey_id', '=', self.id)])\n            else:\n                user_inputs = UserInput.browse(filtered_input_ids)\n            return user_inputs.filtered(lambda input_item: input_item.state == 'done').ids\n        return filtered_input_ids\n\n    @api.model\n    def get_filter_display_data(self, filters):\n        \"\"\"Returns data to display current filters\n            :param filters: list of dictionary (having: row_id, answer_id)\n            :returns list of dict having data to display filters.\n        \"\"\"\n        filter_display_data = []\n        if filters:\n            Label = self.env['survey.label']\n            for current_filter in filters:\n                row_id, answer_id = current_filter['row_id'], current_filter['answer_id']\n                label = Label.browse(answer_id)\n                question = label.question_id\n                if row_id == 0:\n                    labels = label\n                else:\n                    labels = Label.browse([row_id, answer_id])\n                filter_display_data.append({'question_text': question.question,\n                                            'labels': labels.mapped('value')})\n        return filter_display_data\n\n    @api.model\n    def prepare_result(self, question, current_filters=None):\n        \"\"\" Compute statistical data for questions by counting number of vote per choice on basis of filter \"\"\"\n        current_filters = current_filters if current_filters else []\n        result_summary = {}\n\n        # Calculate and return statistics for choice\n        if question.type in ['simple_choice', 'multiple_choice']:\n            answers = {}\n            comments = []\n            [answers.update({label.id: {'text': label.value, 'count': 0, 'answer_id': label.id}}) for label in question.labels_ids]\n            for input_line in question.user_input_line_ids:\n                if input_line.answer_type == 'suggestion' and answers.get(input_line.value_suggested.id) and (not(current_filters) or input_line.user_input_id.id in current_filters):\n                    answers[input_line.value_suggested.id]['count'] += 1\n                if input_line.answer_type == 'text' and (not(current_filters) or input_line.user_input_id.id in current_filters):\n                    comments.append(input_line)\n            result_summary = {'answers': list(answers.values()), 'comments': comments}\n\n        # Calculate and return statistics for matrix\n        if question.type == 'matrix':\n            rows = OrderedDict()\n            answers = OrderedDict()\n            res = dict()\n            comments = []\n            [rows.update({label.id: label.value}) for label in question.labels_ids_2]\n            [answers.update({label.id: label.value}) for label in question.labels_ids]\n            for cell in product(rows, answers):\n                res[cell] = 0\n            for input_line in question.user_input_line_ids:\n                if input_line.answer_type == 'suggestion' and (not(current_filters) or input_line.user_input_id.id in current_filters) and input_line.value_suggested_row:\n                    res[(input_line.value_suggested_row.id, input_line.value_suggested.id)] += 1\n                if input_line.answer_type == 'text' and (not(current_filters) or input_line.user_input_id.id in current_filters):\n                    comments.append(input_line)\n            result_summary = {'answers': answers, 'rows': rows, 'result': res, 'comments': comments}\n\n        # Calculate and return statistics for free_text, textbox, date\n        if question.type in ['free_text', 'textbox', 'date']:\n            result_summary = []\n            for input_line in question.user_input_line_ids:\n                if not(current_filters) or input_line.user_input_id.id in current_filters:\n                    result_summary.append(input_line)\n\n        # Calculate and return statistics for numerical_box\n        if question.type == 'numerical_box':\n            result_summary = {'input_lines': []}\n            all_inputs = []\n            for input_line in question.user_input_line_ids:\n                if not(current_filters) or input_line.user_input_id.id in current_filters:\n                    all_inputs.append(input_line.value_number)\n                    result_summary['input_lines'].append(input_line)\n            if all_inputs:\n                result_summary.update({'average': round(sum(all_inputs) / len(all_inputs), 2),\n                                       'max': round(max(all_inputs), 2),\n                                       'min': round(min(all_inputs), 2),\n                                       'sum': sum(all_inputs),\n                                       'most_common': Counter(all_inputs).most_common(5)})\n        return result_summary\n\n    @api.model\n    def get_input_summary(self, question, current_filters=None):\n        \"\"\" Returns overall summary of question e.g. answered, skipped, total_inputs on basis of filter \"\"\"\n        current_filters = current_filters if current_filters else []\n        result = {}\n        if question.survey_id.user_input_ids:\n            total_input_ids = current_filters or [input_id.id for input_id in question.survey_id.user_input_ids if input_id.state != 'new']\n            result['total_inputs'] = len(total_input_ids)\n            question_input_ids = []\n            for user_input in question.user_input_line_ids:\n                if not user_input.skipped:\n                    question_input_ids.append(user_input.user_input_id.id)\n            result['answered'] = len(set(question_input_ids) & set(total_input_ids))\n            result['skipped'] = result['total_inputs'] - result['answered']\n        return result\n\n    # Actions\n\n    @api.multi\n    def action_start_survey(self):\n        \"\"\" Open the website page with the survey form \"\"\"\n        self.ensure_one()\n        token = self.env.context.get('survey_token')\n        trail = \"/%s\" % token if token else \"\"\n        return {\n            'type': 'ir.actions.act_url',\n            'name': \"Start Survey\",\n            'target': 'self',\n            'url': self.with_context(relative_url=True).public_url + trail\n        }\n\n    @api.multi\n    def action_send_survey(self):\n        \"\"\" Open a window to compose an email, pre-filled with the survey message \"\"\"\n        # Ensure that this survey has at least one page with at least one question.\n        if not self.page_ids or not [page.question_ids for page in self.page_ids if page.question_ids]:\n            raise UserError(_('You cannot send an invitation for a survey that has no questions.'))\n\n        if self.stage_id.closed:\n            raise UserError(_(\"You cannot send invitations for closed surveys.\"))\n\n        template = self.env.ref('survey.email_template_survey', raise_if_not_found=False)\n\n        local_context = dict(\n            self.env.context,\n            default_model='survey.survey',\n            default_res_id=self.id,\n            default_survey_id=self.id,\n            default_use_template=bool(template),\n            default_template_id=template and template.id or False,\n            default_composition_mode='comment'\n        )\n        return {\n            'type': 'ir.actions.act_window',\n            'view_type': 'form',\n            'view_mode': 'form',\n            'res_model': 'survey.mail.compose.message',\n            'target': 'new',\n            'context': local_context,\n        }\n\n    @api.multi\n    def action_print_survey(self):\n        \"\"\" Open the website page with the survey printable view \"\"\"\n        self.ensure_one()\n        token = self.env.context.get('survey_token')\n        trail = \"/\" + token if token else \"\"\n        return {\n            'type': 'ir.actions.act_url',\n            'name': \"Print Survey\",\n            'target': 'self',\n            'url': self.with_context(relative_url=True).print_url + trail\n        }\n\n    @api.multi\n    def action_result_survey(self):\n        \"\"\" Open the website page with the survey results view \"\"\"\n        self.ensure_one()\n        return {\n            'type': 'ir.actions.act_url',\n            'name': \"Results of the Survey\",\n            'target': 'self',\n            'url': self.with_context(relative_url=True).result_url\n        }\n\n    @api.multi\n    def action_test_survey(self):\n        \"\"\" Open the website page with the survey form into test mode\"\"\"\n        self.ensure_one()\n        return {\n            'type': 'ir.actions.act_url',\n            'name': \"Results of the Survey\",\n            'target': 'self',\n            'url': self.with_context(relative_url=True).public_url + \"/phantom\"\n        }\n\n    @api.multi\n    def action_survey_user_input(self):\n        action_rec = self.env.ref('survey.action_survey_user_input')\n        action = action_rec.read()[0]\n        ctx = dict(self.env.context)\n        ctx.update({'search_default_survey_id': self.ids[0],\n                    'search_default_completed': 1})\n        action['context'] = ctx\n        return action\n\n\nclass SurveyPage(models.Model):\n    \"\"\" A page for a survey.\n\n        Pages are essentially containers, allowing to group questions by ordered\n        screens.\n\n        .. note::\n            A page should be deleted if the survey it belongs to is deleted.\n    \"\"\"\n    _name = 'survey.page'\n    _description = 'Survey Page'\n    _rec_name = 'title'\n    _order = 'sequence,id'\n\n    # Model Fields #\n\n    title = fields.Char('Page Title', required=True, translate=True)\n    survey_id = fields.Many2one('survey.survey', string='Survey', ondelete='cascade', required=True)\n    question_ids = fields.One2many('survey.question', 'page_id', string='Questions', copy=True)\n    sequence = fields.Integer('Page number', default=10)\n    description = fields.Html('Description', translate=True, oldname=\"note\", help=\"An introductory text to your page\")\n\n\nclass SurveyQuestion(models.Model):\n    \"\"\" Questions that will be asked in a survey.\n\n        Each question can have one of more suggested answers (eg. in case of\n        dropdown choices, multi-answer checkboxes, radio buttons...).\n    \"\"\"\n\n    _name = 'survey.question'\n    _description = 'Survey Question'\n    _rec_name = 'question'\n    _order = 'sequence,id'\n\n    # Model fields #\n\n    # Question metadata\n    page_id = fields.Many2one('survey.page', string='Survey page',\n            ondelete='cascade', required=True, default=lambda self: self.env.context.get('page_id'))\n    survey_id = fields.Many2one('survey.survey', related='page_id.survey_id', string='Survey')\n    sequence = fields.Integer('Sequence', default=10)\n\n    # Question\n    question = fields.Char('Question Name', required=True, translate=True)\n    description = fields.Html('Description', help=\"Use this field to add \\\n        additional explanations about your question\", translate=True,\n        oldname='descriptive_text')\n\n    # Answer\n    type = fields.Selection([\n            ('free_text', 'Multiple Lines Text Box'),\n            ('textbox', 'Single Line Text Box'),\n            ('numerical_box', 'Numerical Value'),\n            ('date', 'Date'),\n            ('simple_choice', 'Multiple choice: only one answer'),\n            ('multiple_choice', 'Multiple choice: multiple answers allowed'),\n            ('matrix', 'Matrix')], string='Type of Question', default='free_text', required=True)\n    matrix_subtype = fields.Selection([('simple', 'One choice per row'),\n        ('multiple', 'Multiple choices per row')], string='Matrix Type', default='simple')\n    labels_ids = fields.One2many('survey.label', 'question_id', string='Types of answers', oldname='answer_choice_ids', copy=True)\n    labels_ids_2 = fields.One2many('survey.label', 'question_id_2', string='Rows of the Matrix', copy=True)\n    # labels are used for proposed choices\n    # if question.type == simple choice | multiple choice\n    #                    -> only labels_ids is used\n    # if question.type == matrix\n    #                    -> labels_ids are the columns of the matrix\n    #                    -> labels_ids_2 are the rows of the matrix\n\n    # Display options\n    column_nb = fields.Selection([('12', '1'),\n                                   ('6', '2'),\n                                   ('4', '3'),\n                                   ('3', '4'),\n                                   ('2', '6')],\n        'Number of columns', default='12')\n    # These options refer to col-xx-[12|6|4|3|2] classes in Bootstrap\n    display_mode = fields.Selection([('columns', 'Radio Buttons'),\n                                      ('dropdown', 'Selection Box')],\n                                    default='columns')\n\n    # Comments\n    comments_allowed = fields.Boolean('Show Comments Field',\n        oldname=\"allow_comment\")\n    comments_message = fields.Char('Comment Message', translate=True, default=lambda self: _(\"If other, please specify:\"))\n    comment_count_as_answer = fields.Boolean('Comment Field is an Answer Choice',\n        oldname='make_comment_field')\n\n    # Validation\n    validation_required = fields.Boolean('Validate entry', oldname='is_validation_require')\n    validation_email = fields.Boolean('Input must be an email')\n    validation_length_min = fields.Integer('Minimum Text Length')\n    validation_length_max = fields.Integer('Maximum Text Length')\n    validation_min_float_value = fields.Float('Minimum value')\n    validation_max_float_value = fields.Float('Maximum value')\n    validation_min_date = fields.Date('Minimum Date')\n    validation_max_date = fields.Date('Maximum Date')\n    validation_error_msg = fields.Char('Validation Error message', oldname='validation_valid_err_msg',\n                                        translate=True, default=lambda self: _(\"The answer you entered has an invalid format.\"))\n\n    # Constraints on number of answers (matrices)\n    constr_mandatory = fields.Boolean('Mandatory Answer', oldname=\"is_require_answer\")\n    constr_error_msg = fields.Char('Error message', oldname='req_error_msg', translate=True, default=lambda self: _(\"This question requires an answer.\"))\n    user_input_line_ids = fields.One2many('survey.user_input_line', 'question_id', string='Answers', domain=[('skipped', '=', False)])\n\n    _sql_constraints = [\n        ('positive_len_min', 'CHECK (validation_length_min >= 0)', 'A length must be positive!'),\n        ('positive_len_max', 'CHECK (validation_length_max >= 0)', 'A length must be positive!'),\n        ('validation_length', 'CHECK (validation_length_min <= validation_length_max)', 'Max length cannot be smaller than min length!'),\n        ('validation_float', 'CHECK (validation_min_float_value <= validation_max_float_value)', 'Max value cannot be smaller than min value!'),\n        ('validation_date', 'CHECK (validation_min_date <= validation_max_date)', 'Max date cannot be smaller than min date!')\n    ]\n\n    @api.onchange('validation_email')\n    def onchange_validation_email(self):\n        if self.validation_email:\n            self.validation_required = False\n\n    # Validation methods\n\n    @api.multi\n    def validate_question(self, post, answer_tag):\n        \"\"\" Validate question, depending on question type and parameters \"\"\"\n        self.ensure_one()\n        try:\n            checker = getattr(self, 'validate_' + self.type)\n        except AttributeError:\n            _logger.warning(self.type + \": This type of question has no validation method\")\n            return {}\n        else:\n            return checker(post, answer_tag)\n\n    @api.multi\n    def validate_free_text(self, post, answer_tag):\n        self.ensure_one()\n        errors = {}\n        answer = post[answer_tag].strip()\n        # Empty answer to mandatory question\n        if self.constr_mandatory and not answer:\n            errors.update({answer_tag: self.constr_error_msg})\n        return errors\n\n    @api.multi\n    def validate_textbox(self, post, answer_tag):\n        self.ensure_one()\n        errors = {}\n        answer = post[answer_tag].strip()\n        # Empty answer to mandatory question\n        if self.constr_mandatory and not answer:\n            errors.update({answer_tag: self.constr_error_msg})\n        # Email format validation\n        # Note: this validation is very basic:\n        #     all the strings of the form\n        #     <something>@<anything>.<extension>\n        #     will be accepted\n        if answer and self.validation_email:\n            if not email_validator.match(answer):\n                errors.update({answer_tag: _('This answer must be an email address')})\n        # Answer validation (if properly defined)\n        # Length of the answer must be in a range\n        if answer and self.validation_required:\n            if not (self.validation_length_min <= len(answer) <= self.validation_length_max):\n                errors.update({answer_tag: self.validation_error_msg})\n        return errors\n\n    @api.multi\n    def validate_numerical_box(self, post, answer_tag):\n        self.ensure_one()\n        errors = {}\n        answer = post[answer_tag].strip()\n        # Empty answer to mandatory question\n        if self.constr_mandatory and not answer:\n            errors.update({answer_tag: self.constr_error_msg})\n        # Checks if user input is a number\n        if answer:\n            try:\n                floatanswer = float(answer)\n            except ValueError:\n                errors.update({answer_tag: _('This is not a number')})\n        # Answer validation (if properly defined)\n        if answer and self.validation_required:\n            # Answer is not in the right range\n            with tools.ignore(Exception):\n                floatanswer = float(answer)  # check that it is a float has been done hereunder\n                if not (self.validation_min_float_value <= floatanswer <= self.validation_max_float_value):\n                    errors.update({answer_tag: self.validation_error_msg})\n        return errors\n\n    @api.multi\n    def validate_date(self, post, answer_tag):\n        self.ensure_one()\n        errors = {}\n        answer = post[answer_tag].strip()\n        # Empty answer to mandatory question\n        if self.constr_mandatory and not answer:\n            errors.update({answer_tag: self.constr_error_msg})\n        # Checks if user input is a date\n        if answer:\n            try:\n                dateanswer = fields.Date.from_string(answer)\n            except ValueError:\n                errors.update({answer_tag: _('This is not a date')})\n                return errors\n        # Answer validation (if properly defined)\n        if answer and self.validation_required:\n            # Answer is not in the right range\n            try:\n                date_from_string = fields.Date.from_string\n                dateanswer = date_from_string(answer)\n                min_date = date_from_string(self.validation_min_date)\n                max_date = date_from_string(self.validation_max_date)\n\n                if min_date and max_date and not (min_date <= dateanswer <= max_date):\n                    # If Minimum and Maximum Date are entered\n                    errors.update({answer_tag: self.validation_error_msg})\n                elif min_date and not min_date <= dateanswer:\n                    # If only Minimum Date is entered and not Define Maximum Date\n                    errors.update({answer_tag: self.validation_error_msg})\n                elif max_date and not dateanswer <= max_date:\n                    # If only Maximum Date is entered and not Define Minimum Date\n                    errors.update({answer_tag: self.validation_error_msg})\n            except ValueError:  # check that it is a date has been done hereunder\n                pass\n        return errors\n\n    @api.multi\n    def validate_simple_choice(self, post, answer_tag):\n        self.ensure_one()\n        errors = {}\n        if self.comments_allowed:\n            comment_tag = \"%s_%s\" % (answer_tag, 'comment')\n        # Empty answer to mandatory self\n        if self.constr_mandatory and answer_tag not in post:\n            errors.update({answer_tag: self.constr_error_msg})\n        if self.constr_mandatory and answer_tag in post and not post[answer_tag].strip():\n            errors.update({answer_tag: self.constr_error_msg})\n        # Answer is a comment and is empty\n        if self.constr_mandatory and answer_tag in post and post[answer_tag] == \"-1\" and self.comment_count_as_answer and comment_tag in post and not post[comment_tag].strip():\n            errors.update({answer_tag: self.constr_error_msg})\n        return errors\n\n    @api.multi\n    def validate_multiple_choice(self, post, answer_tag):\n        self.ensure_one()\n        errors = {}\n        if self.constr_mandatory:\n            answer_candidates = dict_keys_startswith(post, answer_tag)\n            comment_flag = answer_candidates.pop((\"%s_%s\" % (answer_tag, -1)), None)\n            if self.comments_allowed:\n                comment_answer = answer_candidates.pop((\"%s_%s\" % (answer_tag, 'comment')), '').strip()\n            # Preventing answers with blank value\n            if all(not answer.strip() for answer in answer_candidates.values()) and answer_candidates:\n                errors.update({answer_tag: self.constr_error_msg})\n            # There is no answer neither comments (if comments count as answer)\n            if not answer_candidates and self.comment_count_as_answer and (not comment_flag or not comment_answer):\n                errors.update({answer_tag: self.constr_error_msg})\n            # There is no answer at all\n            if not answer_candidates and not self.comment_count_as_answer:\n                errors.update({answer_tag: self.constr_error_msg})\n        return errors\n\n    @api.multi\n    def validate_matrix(self, post, answer_tag):\n        self.ensure_one()\n        errors = {}\n        if self.constr_mandatory:\n            lines_number = len(self.labels_ids_2)\n            answer_candidates = dict_keys_startswith(post, answer_tag)\n            answer_candidates.pop((\"%s_%s\" % (answer_tag, 'comment')), '').strip()\n            # Number of lines that have been answered\n            if self.matrix_subtype == 'simple':\n                answer_number = len(answer_candidates)\n            elif self.matrix_subtype == 'multiple':\n                answer_number = len({sk.rsplit('_', 1)[0] for sk in answer_candidates})\n            else:\n                raise RuntimeError(\"Invalid matrix subtype\")\n            # Validate that each line has been answered\n            if answer_number != lines_number:\n                errors.update({answer_tag: self.constr_error_msg})\n        return errors\n\n\nclass SurveyLabel(models.Model):\n    \"\"\" A suggested answer for a question \"\"\"\n\n    _name = 'survey.label'\n    _rec_name = 'value'\n    _order = 'sequence,id'\n    _description = 'Survey Label'\n\n    question_id = fields.Many2one('survey.question', string='Question', ondelete='cascade')\n    question_id_2 = fields.Many2one('survey.question', string='Question 2', ondelete='cascade')\n    sequence = fields.Integer('Label Sequence order', default=10)\n    value = fields.Char('Suggested value', translate=True, required=True)\n    quizz_mark = fields.Float('Score for this choice', help=\"A positive score indicates a correct choice; a negative or null score indicates a wrong answer\")\n\n    @api.one\n    @api.constrains('question_id', 'question_id_2')\n    def _check_question_not_empty(self):\n        \"\"\"Ensure that field question_id XOR field question_id_2 is not null\"\"\"\n        if not bool(self.question_id) != bool(self.question_id_2):\n            raise ValidationError(\"A label must be attached to one and only one question\")\n\n\nclass SurveyUserInput(models.Model):\n    \"\"\" Metadata for a set of one user's answers to a particular survey \"\"\"\n\n    _name = \"survey.user_input\"\n    _rec_name = 'date_create'\n    _description = 'Survey User Input'\n\n    survey_id = fields.Many2one('survey.survey', string='Survey', required=True, readonly=True, ondelete='restrict')\n    date_create = fields.Datetime('Creation Date', default=fields.Datetime.now, required=True, readonly=True, copy=False)\n    deadline = fields.Datetime('Deadline', help=\"Date by which the person can open the survey and submit answers\", oldname=\"date_deadline\")\n    type = fields.Selection([('manually', 'Manually'), ('link', 'Link')], string='Answer Type', default='manually', required=True, readonly=True, oldname=\"response_type\")\n    state = fields.Selection([\n        ('new', 'Not started yet'),\n        ('skip', 'Partially completed'),\n        ('done', 'Completed')], string='Status', default='new', readonly=True)\n    test_entry = fields.Boolean(readonly=True)\n    token = fields.Char('Identification token', default=lambda self: str(uuid.uuid4()), readonly=True, required=True, copy=False)\n\n    # Optional Identification data\n    partner_id = fields.Many2one('res.partner', string='Partner', readonly=True)\n    email = fields.Char('E-mail', readonly=True)\n\n    # Displaying data\n    last_displayed_page_id = fields.Many2one('survey.page', string='Last displayed page')\n    # The answers !\n    user_input_line_ids = fields.One2many('survey.user_input_line', 'user_input_id', string='Answers', copy=True)\n\n    # URLs used to display the answers\n    result_url = fields.Char(\"Public link to the survey results\", related='survey_id.result_url')\n    print_url = fields.Char(\"Public link to the empty survey\", related='survey_id.print_url')\n\n    quizz_score = fields.Float(\"Score for the quiz\", compute=\"_compute_quizz_score\", default=0.0)\n\n    @api.depends('user_input_line_ids.quizz_mark')\n    def _compute_quizz_score(self):\n        for user_input in self:\n            user_input.quizz_score = sum(user_input.user_input_line_ids.mapped('quizz_mark'))\n\n    _sql_constraints = [\n        ('unique_token', 'UNIQUE (token)', 'A token must be unique!'),\n        ('deadline_in_the_past', 'CHECK (deadline >= date_create)', 'The deadline cannot be in the past')\n    ]\n\n    @api.model\n    def do_clean_emptys(self):\n        \"\"\" Remove empty user inputs that have been created manually\n            (used as a cronjob declared in data/survey_cron.xml)\n        \"\"\"\n        an_hour_ago = fields.Datetime.to_string(datetime.datetime.now() - datetime.timedelta(hours=1))\n        self.search([('type', '=', 'manually'), ('state', '=', 'new'),\n                    ('date_create', '<', an_hour_ago)]).unlink()\n\n    @api.multi\n    def action_survey_resend(self):\n        \"\"\" Send again the invitation \"\"\"\n        self.ensure_one()\n        local_context = {\n            'survey_resent_token': True,\n            'default_partner_ids': self.partner_id and [self.partner_id.id] or [],\n            'default_multi_email': self.email or \"\",\n            'default_public': 'email_private',\n        }\n        return self.survey_id.with_context(local_context).action_send_survey()\n\n    @api.multi\n    def action_view_answers(self):\n        \"\"\" Open the website page with the survey form \"\"\"\n        self.ensure_one()\n        return {\n            'type': 'ir.actions.act_url',\n            'name': \"View Answers\",\n            'target': 'self',\n            'url': '%s/%s' % (self.print_url, self.token)\n        }\n\n    @api.multi\n    def action_survey_results(self):\n        \"\"\" Open the website page with the survey results \"\"\"\n        self.ensure_one()\n        return {\n            'type': 'ir.actions.act_url',\n            'name': \"Survey Results\",\n            'target': 'self',\n            'url': self.result_url\n        }\n\n\nclass SurveyUserInputLine(models.Model):\n    _name = 'survey.user_input_line'\n    _description = 'Survey User Input Line'\n    _rec_name = 'date_create'\n\n    user_input_id = fields.Many2one('survey.user_input', string='User Input', ondelete='cascade', required=True)\n    question_id = fields.Many2one('survey.question', string='Question', ondelete='restrict', required=True)\n    page_id = fields.Many2one(related='question_id.page_id', string=\"Page\")\n    survey_id = fields.Many2one(related='user_input_id.survey_id', string='Survey', store=True)\n    date_create = fields.Datetime('Create Date', default=fields.Datetime.now, required=True)\n    skipped = fields.Boolean('Skipped')\n    answer_type = fields.Selection([\n        ('text', 'Text'),\n        ('number', 'Number'),\n        ('date', 'Date'),\n        ('free_text', 'Free Text'),\n        ('suggestion', 'Suggestion')], string='Answer Type')\n    value_text = fields.Char('Text answer')\n    value_number = fields.Float('Numerical answer')\n    value_date = fields.Date('Date answer')\n    value_free_text = fields.Text('Free Text answer')\n    value_suggested = fields.Many2one('survey.label', string=\"Suggested answer\")\n    value_suggested_row = fields.Many2one('survey.label', string=\"Row answer\")\n    quizz_mark = fields.Float('Score given for this choice')\n\n    @api.constrains('skipped', 'answer_type')\n    def _answered_or_skipped(self):\n        for uil in self:\n            if not uil.skipped != bool(uil.answer_type):\n                raise ValidationError(_('A question cannot be unanswered and skipped'))\n\n    @api.constrains('answer_type')\n    def _check_answer_type(self):\n        for uil in self:\n            fields_type = {\n                'text': bool(uil.value_text),\n                'number': (bool(uil.value_number) or uil.value_number == 0),\n                'date': bool(uil.value_date),\n                'free_text': bool(uil.value_free_text),\n                'suggestion': bool(uil.value_suggested)\n            }\n            if not fields_type.get(uil.answer_type, True):\n                raise ValidationError(_('The answer must be in the right type'))\n\n    def _get_mark(self, value_suggested):\n        label = self.env['survey.label'].browse(int(value_suggested))\n        mark = label.quizz_mark if label.exists() else 0.0\n        return mark\n\n    @api.model\n    def create(self, vals):\n        value_suggested = vals.get('value_suggested')\n        if value_suggested:\n            vals.update({'quizz_mark': self._get_mark(value_suggested)})\n        return super(SurveyUserInputLine, self).create(vals)\n\n    @api.multi\n    def write(self, vals):\n        value_suggested = vals.get('value_suggested')\n        if value_suggested:\n            vals.update({'quizz_mark': self._get_mark(value_suggested)})\n        return super(SurveyUserInputLine, self).write(vals)\n\n    @api.model\n    def save_lines(self, user_input_id, question, post, answer_tag):\n        \"\"\" Save answers to questions, depending on question type\n\n            If an answer already exists for question and user_input_id, it will be\n            overwritten (in order to maintain data consistency).\n        \"\"\"\n        try:\n            saver = getattr(self, 'save_line_' + question.type)\n        except AttributeError:\n            _logger.error(question.type + \": This type of question has no saving function\")\n            return False\n        else:\n            saver(user_input_id, question, post, answer_tag)\n\n    @api.model\n    def save_line_free_text(self, user_input_id, question, post, answer_tag):\n        vals = {\n            'user_input_id': user_input_id,\n            'question_id': question.id,\n            'survey_id': question.survey_id.id,\n            'skipped': False,\n        }\n        if answer_tag in post and post[answer_tag].strip():\n            vals.update({'answer_type': 'free_text', 'value_free_text': post[answer_tag]})\n        else:\n            vals.update({'answer_type': None, 'skipped': True})\n        old_uil = self.search([\n            ('user_input_id', '=', user_input_id),\n            ('survey_id', '=', question.survey_id.id),\n            ('question_id', '=', question.id)\n        ])\n        if old_uil:\n            old_uil.write(vals)\n        else:\n            old_uil.create(vals)\n        return True\n\n    @api.model\n    def save_line_textbox(self, user_input_id, question, post, answer_tag):\n        vals = {\n            'user_input_id': user_input_id,\n            'question_id': question.id,\n            'survey_id': question.survey_id.id,\n            'skipped': False\n        }\n        if answer_tag in post and post[answer_tag].strip():\n            vals.update({'answer_type': 'text', 'value_text': post[answer_tag]})\n        else:\n            vals.update({'answer_type': None, 'skipped': True})\n        old_uil = self.search([\n            ('user_input_id', '=', user_input_id),\n            ('survey_id', '=', question.survey_id.id),\n            ('question_id', '=', question.id)\n        ])\n        if old_uil:\n            old_uil.write(vals)\n        else:\n            old_uil.create(vals)\n        return True\n\n    @api.model\n    def save_line_numerical_box(self, user_input_id, question, post, answer_tag):\n        vals = {\n            'user_input_id': user_input_id,\n            'question_id': question.id,\n            'survey_id': question.survey_id.id,\n            'skipped': False\n        }\n        if answer_tag in post and post[answer_tag].strip():\n            vals.update({'answer_type': 'number', 'value_number': float(post[answer_tag])})\n        else:\n            vals.update({'answer_type': None, 'skipped': True})\n        old_uil = self.search([\n            ('user_input_id', '=', user_input_id),\n            ('survey_id', '=', question.survey_id.id),\n            ('question_id', '=', question.id)\n        ])\n        if old_uil:\n            old_uil.write(vals)\n        else:\n            old_uil.create(vals)\n        return True\n\n    @api.model\n    def save_line_date(self, user_input_id, question, post, answer_tag):\n        vals = {\n            'user_input_id': user_input_id,\n            'question_id': question.id,\n            'survey_id': question.survey_id.id,\n            'skipped': False\n        }\n        if answer_tag in post and post[answer_tag].strip():\n            vals.update({'answer_type': 'date', 'value_date': post[answer_tag]})\n        else:\n            vals.update({'answer_type': None, 'skipped': True})\n        old_uil = self.search([\n            ('user_input_id', '=', user_input_id),\n            ('survey_id', '=', question.survey_id.id),\n            ('question_id', '=', question.id)\n        ])\n        if old_uil:\n            old_uil.write(vals)\n        else:\n            old_uil.create(vals)\n        return True\n\n    @api.model\n    def save_line_simple_choice(self, user_input_id, question, post, answer_tag):\n        vals = {\n            'user_input_id': user_input_id,\n            'question_id': question.id,\n            'survey_id': question.survey_id.id,\n            'skipped': False\n        }\n        old_uil = self.search([\n            ('user_input_id', '=', user_input_id),\n            ('survey_id', '=', question.survey_id.id),\n            ('question_id', '=', question.id)\n        ])\n        old_uil.sudo().unlink()\n\n        if answer_tag in post and post[answer_tag].strip():\n            vals.update({'answer_type': 'suggestion', 'value_suggested': post[answer_tag]})\n        else:\n            vals.update({'answer_type': None, 'skipped': True})\n\n        # '-1' indicates 'comment count as an answer' so do not need to record it\n        if post.get(answer_tag) and post.get(answer_tag) != '-1':\n            self.create(vals)\n\n        comment_answer = post.pop((\"%s_%s\" % (answer_tag, 'comment')), '').strip()\n        if comment_answer:\n            vals.update({'answer_type': 'text', 'value_text': comment_answer, 'skipped': False, 'value_suggested': False})\n            self.create(vals)\n\n        return True\n\n    @api.model\n    def save_line_multiple_choice(self, user_input_id, question, post, answer_tag):\n        vals = {\n            'user_input_id': user_input_id,\n            'question_id': question.id,\n            'survey_id': question.survey_id.id,\n            'skipped': False\n        }\n        old_uil = self.search([\n            ('user_input_id', '=', user_input_id),\n            ('survey_id', '=', question.survey_id.id),\n            ('question_id', '=', question.id)\n        ])\n        old_uil.sudo().unlink()\n\n        ca_dict = dict_keys_startswith(post, answer_tag + '_')\n        comment_answer = ca_dict.pop((\"%s_%s\" % (answer_tag, 'comment')), '').strip()\n        if len(ca_dict) > 0:\n            for key in ca_dict:\n                # '-1' indicates 'comment count as an answer' so do not need to record it\n                if key != ('%s_%s' % (answer_tag, '-1')):\n                    vals.update({'answer_type': 'suggestion', 'value_suggested': ca_dict[key]})\n                    self.create(vals)\n        if comment_answer:\n            vals.update({'answer_type': 'text', 'value_text': comment_answer, 'value_suggested': False})\n            self.create(vals)\n        if not ca_dict and not comment_answer:\n            vals.update({'answer_type': None, 'skipped': True})\n            self.create(vals)\n        return True\n\n    @api.model\n    def save_line_matrix(self, user_input_id, question, post, answer_tag):\n        vals = {\n            'user_input_id': user_input_id,\n            'question_id': question.id,\n            'survey_id': question.survey_id.id,\n            'skipped': False\n        }\n        old_uil = self.search([\n            ('user_input_id', '=', user_input_id),\n            ('survey_id', '=', question.survey_id.id),\n            ('question_id', '=', question.id)\n        ])\n        old_uil.sudo().unlink()\n\n        no_answers = True\n        ca_dict = dict_keys_startswith(post, answer_tag + '_')\n\n        comment_answer = ca_dict.pop((\"%s_%s\" % (answer_tag, 'comment')), '').strip()\n        if comment_answer:\n            vals.update({'answer_type': 'text', 'value_text': comment_answer})\n            self.create(vals)\n            no_answers = False\n\n        if question.matrix_subtype == 'simple':\n            for row in question.labels_ids_2:\n                a_tag = \"%s_%s\" % (answer_tag, row.id)\n                if a_tag in ca_dict:\n                    no_answers = False\n                    vals.update({'answer_type': 'suggestion', 'value_suggested': ca_dict[a_tag], 'value_suggested_row': row.id})\n                    self.create(vals)\n\n        elif question.matrix_subtype == 'multiple':\n            for col in question.labels_ids:\n                for row in question.labels_ids_2:\n                    a_tag = \"%s_%s_%s\" % (answer_tag, row.id, col.id)\n                    if a_tag in ca_dict:\n                        no_answers = False\n                        vals.update({'answer_type': 'suggestion', 'value_suggested': col.id, 'value_suggested_row': row.id})\n                        self.create(vals)\n        if no_answers:\n            vals.update({'answer_type': None, 'skipped': True})\n            self.create(vals)\n        return True\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "survey.py", "id": "2012b36c38d2a0925084cd88492206c1", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/survey/models/survey.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}