{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom odoo import api, fields, models, _\nfrom odoo.exceptions import UserError, ValidationError\nfrom . import membership\n\n\nclass Partner(models.Model):\n    _inherit = 'res.partner'\n\n    associate_member = fields.Many2one('res.partner', string='Associate Member',\n        help=\"A member with whom you want to associate your membership. \"\n             \"It will consider the membership state of the associated member.\")\n    member_lines = fields.One2many('membership.membership_line', 'partner', string='Membership')\n    free_member = fields.Boolean(string='Free Member',\n        help=\"Select if you want to give free membership.\")\n    membership_amount = fields.Float(string='Membership Amount', digits=(16, 2),\n        help='The price negotiated by the partner')\n    membership_state = fields.Selection(membership.STATE, compute='_compute_membership_state',\n        string='Current Membership Status', store=True,\n        help='It indicates the membership state.\\n'\n             '-Non Member: A partner who has not applied for any membership.\\n'\n             '-Cancelled Member: A member who has cancelled his membership.\\n'\n             '-Old Member: A member whose membership date has expired.\\n'\n             '-Waiting Member: A member who has applied for the membership and whose invoice is going to be created.\\n'\n             '-Invoiced Member: A member whose invoice has been created.\\n'\n             '-Paying member: A member who has paid the membership fee.')\n    membership_start = fields.Date(compute='_compute_membership_start',\n        string ='Membership Start Date', store=True,\n        help=\"Date from which membership becomes active.\")\n    membership_stop = fields.Date(compute='_compute_membership_stop',\n        string ='Membership End Date', store=True,\n        help=\"Date until which membership remains active.\")\n    membership_cancel = fields.Date(compute='_compute_membership_cancel',\n        string ='Cancel Membership Date', store=True,\n        help=\"Date on which membership has been cancelled\")\n\n    @api.depends('member_lines.account_invoice_line.invoice_id.state',\n                 'member_lines.account_invoice_line.invoice_id.invoice_line_ids',\n                 'member_lines.account_invoice_line.invoice_id.payment_ids',\n                 'free_member',\n                 'member_lines.date_to', 'member_lines.date_from',\n                 'associate_member.membership_state')\n    def _compute_membership_state(self):\n        values = self._membership_state()\n        for partner in self:\n            partner.membership_state = values[partner.id]\n\n    @api.depends('member_lines.account_invoice_line.invoice_id.state',\n                 'member_lines.account_invoice_line.invoice_id.invoice_line_ids',\n                 'member_lines.account_invoice_line.invoice_id.payment_ids',\n                 'free_member',\n                 'member_lines.date_to', 'member_lines.date_from', 'member_lines.date_cancel',\n                 'membership_state',\n                 'associate_member.membership_state')\n    def _compute_membership_start(self):\n        \"\"\"Return  date of membership\"\"\"\n        for partner in self:\n            partner.membership_start = self.env['membership.membership_line'].search([\n                ('partner', '=', partner.associate_member.id or partner.id), ('date_cancel','=',False)\n            ], limit=1, order='date_from').date_from\n\n    @api.depends('member_lines.account_invoice_line.invoice_id.state',\n                 'member_lines.account_invoice_line.invoice_id.invoice_line_ids',\n                 'member_lines.account_invoice_line.invoice_id.payment_ids',\n                 'free_member',\n                 'member_lines.date_to', 'member_lines.date_from', 'member_lines.date_cancel',\n                 'membership_state',\n                 'associate_member.membership_state')\n    def _compute_membership_stop(self):\n        MemberLine = self.env['membership.membership_line']\n        for partner in self:\n            partner.membership_stop = self.env['membership.membership_line'].search([\n                ('partner', '=', partner.associate_member.id or partner.id),('date_cancel','=',False)\n            ], limit=1, order='date_to desc').date_to\n\n    @api.depends('member_lines.account_invoice_line.invoice_id.state',\n                 'member_lines.account_invoice_line.invoice_id.invoice_line_ids',\n                 'member_lines.account_invoice_line.invoice_id.payment_ids',\n                 'free_member',\n                 'member_lines.date_to', 'member_lines.date_from', 'member_lines.date_cancel',\n                 'membership_state',\n                 'associate_member.membership_state')\n    def _compute_membership_cancel(self):\n        for partner in self:\n            if partner.membership_state == 'canceled':\n                partner.membership_cancel = self.env['membership.membership_line'].search([\n                    ('partner', '=', partner.id)\n                ], limit=1, order='date_cancel').date_cancel\n            else:\n                partner.membership_cancel = False\n\n    def _membership_state(self):\n        \"\"\"This Function return Membership State For Given Partner. \"\"\"\n        res = {}\n        today = fields.Date.today()\n        for partner in self:\n            res[partner.id] = 'none'\n\n            if partner.membership_cancel and today > partner.membership_cancel:\n                res[partner.id] = 'free' if partner.free_member else 'canceled'\n                continue\n            if partner.membership_stop and today > partner.membership_stop:\n                res[partner.id] = 'free' if partner.free_member else 'old'\n                continue\n\n            s = 4\n            if partner.member_lines:\n                for mline in partner.member_lines:\n                    if (mline.date_to or '0000-00-00') >= today and (mline.date_from or '0000-00-00') <= today:\n                        if mline.account_invoice_line.invoice_id:\n                            mstate = mline.account_invoice_line.invoice_id.state\n                            if mstate == 'paid':\n                                s = 0\n                                inv = mline.account_invoice_line.invoice_id\n                                for payment in inv.payment_ids:\n                                    if any(payment.invoice_ids.filtered(lambda inv: inv.type == 'out_refund')):\n                                        s = 2\n                                break\n                            elif mstate == 'open' and s != 0:\n                                s = 1\n                            elif mstate == 'cancel' and s != 0 and s != 1:\n                                s = 2\n                            elif mstate == 'draft' and s != 0 and s != 1:\n                                s = 3\n                if s == 4:\n                    for mline in partner.member_lines:\n                        if (mline.date_from or '0000-00-00') < today and (mline.date_to or '0000-00-00') < today and (mline.date_from or '0000-00-00') <= (mline.date_to or '0000-00-00') and mline.account_invoice_line and mline.account_invoice_line.invoice_id.state == 'paid':\n                            s = 5\n                        else:\n                            s = 6\n                if s == 0:\n                    res[partner.id] = 'paid'\n                elif s == 1:\n                    res[partner.id] = 'invoiced'\n                elif s == 2:\n                    res[partner.id] = 'canceled'\n                elif s == 3:\n                    res[partner.id] = 'waiting'\n                elif s == 5:\n                    res[partner.id] = 'old'\n                elif s == 6:\n                    res[partner.id] = 'none'\n            if partner.free_member and s != 0:\n                res[partner.id] = 'free'\n            if partner.associate_member:\n                res_state = partner.associate_member._membership_state()\n                res[partner.id] = res_state[partner.associate_member.id]\n        return res\n\n    @api.one\n    @api.constrains('associate_member')\n    def _check_recursion_associate_member(self):\n        level = 100\n        while self:\n            self = self.associate_member\n            if not level:\n                raise ValidationError(_('Error ! You cannot create recursive associated members.'))\n            level -= 1\n\n    @api.model\n    def _cron_update_membership(self):\n        \n        pass\n\n    @api.multi\n    def create_membership_invoice(self, product_id=None, datas=None):\n        \"\"\" Create Customer Invoice of Membership for partners.\n        @param datas: datas has dictionary value which consist Id of Membership product and Cost Amount of Membership.\n                      datas = {'membership_product_id': None, 'amount': None}\n        \"\"\"\n        product_id = product_id or datas.get('membership_product_id')\n        amount = datas.get('amount', 0.0)\n        invoice_list = []\n        for partner in self:\n            addr = partner.address_get(['invoice'])\n            if partner.free_member:\n                raise UserError(_(\"Partner is a free Member.\"))\n            if not addr.get('invoice', False):\n                raise UserError(_(\"Partner doesn't have an address to make the invoice.\"))\n            invoice = self.env['account.invoice'].create({\n                'partner_id': partner.id,\n                'account_id': partner.property_account_receivable_id.id,\n                'fiscal_position_id': partner.property_account_position_id.id\n            })\n            line_values = {\n                'product_id': product_id,\n                'price_unit': amount,\n                'invoice_id': invoice.id,\n            }\n            \n            invoice_line = self.env['account.invoice.line'].new(line_values)\n            invoice_line._onchange_product_id()\n            line_values = invoice_line._convert_to_write({name: invoice_line[name] for name in invoice_line._cache})\n            line_values['price_unit'] = amount\n            invoice.write({'invoice_line_ids': [(0, 0, line_values)]})\n            invoice_list.append(invoice.id)\n            invoice.compute_taxes()\n        return invoice_list\n", "comments": "   return  date membership            partner self              partner membership start   self env  membership membership line   search(                  ( partner        partner associate member id partner id)  ( date cancel      false)                limit 1  order  date ) date       api depends( member lines account invoice line invoice id state                     member lines account invoice line invoice id invoice line ids                     member lines account invoice line invoice id payment ids                     free member                     member lines date    member lines date    member lines date cancel                     membership state                     associate member membership state )     def  compute membership stop(self)          memberline   self env  membership membership line           partner self              partner membership stop   self env  membership membership line   search(                  ( partner        partner associate member id partner id) ( date cancel      false)                limit 1  order  date desc ) date       api depends( member lines account invoice line invoice id state                     member lines account invoice line invoice id invoice line ids                     member lines account invoice line invoice id payment ids                     free member                     member lines date    member lines date    member lines date cancel                     membership state                     associate member membership state )     def  compute membership cancel(self)          partner self              partner membership state     canceled                   partner membership cancel   self env  membership membership line   search(                      ( partner        partner id)                    limit 1  order  date cancel ) date cancel             else                  partner membership cancel   false      def  membership state(self)             this function return membership state for given partner              res              today   fields date today()         partner self              res partner id     none               partner membership cancel today   partner membership cancel                  res partner id     free  partner free member else  canceled                  continue             partner membership stop today   partner membership stop                  res partner id     free  partner free member else  old                  continue                4             partner member lines                  mline partner member lines                      (mline date  0000 00 00 )    today (mline date  0000 00 00 )    today                          mline account invoice line invoice id                              mstate   mline account invoice line invoice id state                             mstate     paid                                     0                                 inv   mline account invoice line invoice id                                 payment inv payment ids                                      any(payment invoice ids filtered(lambda inv  inv type     refund ))                                            2                                 break                             elif mstate     open     0                                    1                             elif mstate     cancel     0    1                                    2                             elif mstate     draft     0    1                                    3                    4                      mline partner member lines                          (mline date  0000 00 00 )   today (mline date  0000 00 00 )   today (mline date  0000 00 00 )    (mline date  0000 00 00 ) mline account invoice line mline account invoice line invoice id state     paid                                 5                         else                                6                    0                      res partner id     paid                  elif    1                      res partner id     invoiced                  elif    2                      res partner id     canceled                  elif    3                      res partner id     waiting                  elif    5                      res partner id     old                  elif    6                      res partner id     none              partner free member    0                  res partner id     free              partner associate member                  res state   partner associate member  membership state()                 res partner id    res state partner associate member id          return res       api one      api constrains( associate member )     def  check recursion associate member(self)          level   100         self              self   self associate member             level                  raise validationerror( ( error   you cannot create recursive associated members  ))             level    1       api model     def  cron update membership(self)            used recompute  membership state   longer necessary         pass       api multi     def create membership invoice(self  product id none  datas none)              create customer invoice membership partners           param datas  datas dictionary value consist id membership product cost amount membership                        datas     membership product id   none   amount   none                     coding  utf 8        part odoo  see license file full copyright licensing details     used recompute  membership state   longer necessary    create record cache  apply onchange revert back dictionnary ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom odoo import api, fields, models, _\nfrom odoo.exceptions import UserError, ValidationError\nfrom . import membership\n\n\nclass Partner(models.Model):\n    _inherit = 'res.partner'\n\n    associate_member = fields.Many2one('res.partner', string='Associate Member',\n        help=\"A member with whom you want to associate your membership. \"\n             \"It will consider the membership state of the associated member.\")\n    member_lines = fields.One2many('membership.membership_line', 'partner', string='Membership')\n    free_member = fields.Boolean(string='Free Member',\n        help=\"Select if you want to give free membership.\")\n    membership_amount = fields.Float(string='Membership Amount', digits=(16, 2),\n        help='The price negotiated by the partner')\n    membership_state = fields.Selection(membership.STATE, compute='_compute_membership_state',\n        string='Current Membership Status', store=True,\n        help='It indicates the membership state.\\n'\n             '-Non Member: A partner who has not applied for any membership.\\n'\n             '-Cancelled Member: A member who has cancelled his membership.\\n'\n             '-Old Member: A member whose membership date has expired.\\n'\n             '-Waiting Member: A member who has applied for the membership and whose invoice is going to be created.\\n'\n             '-Invoiced Member: A member whose invoice has been created.\\n'\n             '-Paying member: A member who has paid the membership fee.')\n    membership_start = fields.Date(compute='_compute_membership_start',\n        string ='Membership Start Date', store=True,\n        help=\"Date from which membership becomes active.\")\n    membership_stop = fields.Date(compute='_compute_membership_stop',\n        string ='Membership End Date', store=True,\n        help=\"Date until which membership remains active.\")\n    membership_cancel = fields.Date(compute='_compute_membership_cancel',\n        string ='Cancel Membership Date', store=True,\n        help=\"Date on which membership has been cancelled\")\n\n    @api.depends('member_lines.account_invoice_line.invoice_id.state',\n                 'member_lines.account_invoice_line.invoice_id.invoice_line_ids',\n                 'member_lines.account_invoice_line.invoice_id.payment_ids',\n                 'free_member',\n                 'member_lines.date_to', 'member_lines.date_from',\n                 'associate_member.membership_state')\n    def _compute_membership_state(self):\n        values = self._membership_state()\n        for partner in self:\n            partner.membership_state = values[partner.id]\n\n    @api.depends('member_lines.account_invoice_line.invoice_id.state',\n                 'member_lines.account_invoice_line.invoice_id.invoice_line_ids',\n                 'member_lines.account_invoice_line.invoice_id.payment_ids',\n                 'free_member',\n                 'member_lines.date_to', 'member_lines.date_from', 'member_lines.date_cancel',\n                 'membership_state',\n                 'associate_member.membership_state')\n    def _compute_membership_start(self):\n        \"\"\"Return  date of membership\"\"\"\n        for partner in self:\n            partner.membership_start = self.env['membership.membership_line'].search([\n                ('partner', '=', partner.associate_member.id or partner.id), ('date_cancel','=',False)\n            ], limit=1, order='date_from').date_from\n\n    @api.depends('member_lines.account_invoice_line.invoice_id.state',\n                 'member_lines.account_invoice_line.invoice_id.invoice_line_ids',\n                 'member_lines.account_invoice_line.invoice_id.payment_ids',\n                 'free_member',\n                 'member_lines.date_to', 'member_lines.date_from', 'member_lines.date_cancel',\n                 'membership_state',\n                 'associate_member.membership_state')\n    def _compute_membership_stop(self):\n        MemberLine = self.env['membership.membership_line']\n        for partner in self:\n            partner.membership_stop = self.env['membership.membership_line'].search([\n                ('partner', '=', partner.associate_member.id or partner.id),('date_cancel','=',False)\n            ], limit=1, order='date_to desc').date_to\n\n    @api.depends('member_lines.account_invoice_line.invoice_id.state',\n                 'member_lines.account_invoice_line.invoice_id.invoice_line_ids',\n                 'member_lines.account_invoice_line.invoice_id.payment_ids',\n                 'free_member',\n                 'member_lines.date_to', 'member_lines.date_from', 'member_lines.date_cancel',\n                 'membership_state',\n                 'associate_member.membership_state')\n    def _compute_membership_cancel(self):\n        for partner in self:\n            if partner.membership_state == 'canceled':\n                partner.membership_cancel = self.env['membership.membership_line'].search([\n                    ('partner', '=', partner.id)\n                ], limit=1, order='date_cancel').date_cancel\n            else:\n                partner.membership_cancel = False\n\n    def _membership_state(self):\n        \"\"\"This Function return Membership State For Given Partner. \"\"\"\n        res = {}\n        today = fields.Date.today()\n        for partner in self:\n            res[partner.id] = 'none'\n\n            if partner.membership_cancel and today > partner.membership_cancel:\n                res[partner.id] = 'free' if partner.free_member else 'canceled'\n                continue\n            if partner.membership_stop and today > partner.membership_stop:\n                res[partner.id] = 'free' if partner.free_member else 'old'\n                continue\n\n            s = 4\n            if partner.member_lines:\n                for mline in partner.member_lines:\n                    if (mline.date_to or '0000-00-00') >= today and (mline.date_from or '0000-00-00') <= today:\n                        if mline.account_invoice_line.invoice_id:\n                            mstate = mline.account_invoice_line.invoice_id.state\n                            if mstate == 'paid':\n                                s = 0\n                                inv = mline.account_invoice_line.invoice_id\n                                for payment in inv.payment_ids:\n                                    if any(payment.invoice_ids.filtered(lambda inv: inv.type == 'out_refund')):\n                                        s = 2\n                                break\n                            elif mstate == 'open' and s != 0:\n                                s = 1\n                            elif mstate == 'cancel' and s != 0 and s != 1:\n                                s = 2\n                            elif mstate == 'draft' and s != 0 and s != 1:\n                                s = 3\n                if s == 4:\n                    for mline in partner.member_lines:\n                        if (mline.date_from or '0000-00-00') < today and (mline.date_to or '0000-00-00') < today and (mline.date_from or '0000-00-00') <= (mline.date_to or '0000-00-00') and mline.account_invoice_line and mline.account_invoice_line.invoice_id.state == 'paid':\n                            s = 5\n                        else:\n                            s = 6\n                if s == 0:\n                    res[partner.id] = 'paid'\n                elif s == 1:\n                    res[partner.id] = 'invoiced'\n                elif s == 2:\n                    res[partner.id] = 'canceled'\n                elif s == 3:\n                    res[partner.id] = 'waiting'\n                elif s == 5:\n                    res[partner.id] = 'old'\n                elif s == 6:\n                    res[partner.id] = 'none'\n            if partner.free_member and s != 0:\n                res[partner.id] = 'free'\n            if partner.associate_member:\n                res_state = partner.associate_member._membership_state()\n                res[partner.id] = res_state[partner.associate_member.id]\n        return res\n\n    @api.one\n    @api.constrains('associate_member')\n    def _check_recursion_associate_member(self):\n        level = 100\n        while self:\n            self = self.associate_member\n            if not level:\n                raise ValidationError(_('Error ! You cannot create recursive associated members.'))\n            level -= 1\n\n    @api.model\n    def _cron_update_membership(self):\n        # used to recompute 'membership_state'; should no longer be necessary\n        pass\n\n    @api.multi\n    def create_membership_invoice(self, product_id=None, datas=None):\n        \"\"\" Create Customer Invoice of Membership for partners.\n        @param datas: datas has dictionary value which consist Id of Membership product and Cost Amount of Membership.\n                      datas = {'membership_product_id': None, 'amount': None}\n        \"\"\"\n        product_id = product_id or datas.get('membership_product_id')\n        amount = datas.get('amount', 0.0)\n        invoice_list = []\n        for partner in self:\n            addr = partner.address_get(['invoice'])\n            if partner.free_member:\n                raise UserError(_(\"Partner is a free Member.\"))\n            if not addr.get('invoice', False):\n                raise UserError(_(\"Partner doesn't have an address to make the invoice.\"))\n            invoice = self.env['account.invoice'].create({\n                'partner_id': partner.id,\n                'account_id': partner.property_account_receivable_id.id,\n                'fiscal_position_id': partner.property_account_position_id.id\n            })\n            line_values = {\n                'product_id': product_id,\n                'price_unit': amount,\n                'invoice_id': invoice.id,\n            }\n            # create a record in cache, apply onchange then revert back to a dictionnary\n            invoice_line = self.env['account.invoice.line'].new(line_values)\n            invoice_line._onchange_product_id()\n            line_values = invoice_line._convert_to_write({name: invoice_line[name] for name in invoice_line._cache})\n            line_values['price_unit'] = amount\n            invoice.write({'invoice_line_ids': [(0, 0, line_values)]})\n            invoice_list.append(invoice.id)\n            invoice.compute_taxes()\n        return invoice_list\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "partner.py", "id": "3ae1b4c75e62393f448bee075817a65c", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/membership/models/partner.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}