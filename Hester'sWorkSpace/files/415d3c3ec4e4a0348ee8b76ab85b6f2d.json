{"author": "tensorflow", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\n\nimport numpy as np\nimport tensorflow as tf\n\n\nfrom official.resnet import resnet   pylint: disable=g-bad-import-order\n\n\nclass BlockTest(tf.test.TestCase):\n\n  def dense_run(self, tf_seed):\n    \"\"\"Simple generation of one random float and a single node dense network.\n\n      The subsequent more involved tests depend on the ability to correctly seed\n    TensorFlow. In the event that that process does not function as expected,\n    the simple dense tests will fail indicating that the issue is with the\n    tests rather than the ResNet functions.\n\n    Args:\n      tf_seed: Random seed for TensorFlow\n\n    Returns:\n      The generated random number and result of the dense network.\n    \"\"\"\n    with self.test_session(graph=tf.Graph()) as sess:\n      tf.set_random_seed(tf_seed)\n\n      x = tf.random_uniform((1, 1))\n      y = tf.layers.dense(inputs=x, units=1)\n\n      init = tf.global_variables_initializer()\n      sess.run(init)\n      return x.eval()[0, 0], y.eval()[0, 0]\n\n  def make_projection(self, filters_out, strides, data_format):\n    \"\"\"1D convolution with stride projector.\n\n    Args:\n      filters_out: Number of filters in the projection.\n      strides: Stride length for convolution.\n      data_format: channels_first or channels_last\n\n    Returns:\n      A 1 wide CNN projector function.\n    \"\"\"\n    def projection_shortcut(inputs):\n      return resnet.conv2d_fixed_padding(\n          inputs=inputs, filters=filters_out, kernel_size=1, strides=strides,\n          data_format=data_format)\n    return projection_shortcut\n\n  def resnet_block_run(self, tf_seed, batch_size, bottleneck, projection,\n                       version, width, channels):\n    \"\"\"Test whether resnet block construction has changed.\n\n      This function runs ResNet block construction under a variety of different\n    conditions.\n\n    Args:\n      tf_seed: Random seed for TensorFlow\n      batch_size: Number of points in the fake image. This is needed due to\n        batch normalization.\n      bottleneck: Whether or not to use bottleneck layers.\n      projection: Whether or not to project the input.\n      version: Which version of ResNet to test.\n      width: The width of the fake image.\n      channels: The number of channels in the fake image.\n\n    Returns:\n      The size of the block output, as well as several check values.\n    \"\"\"\n    data_format = \"channels_last\"\n\n    if version == 1:\n      block_fn = resnet._building_block_v1\n      if bottleneck:\n        block_fn = resnet._bottleneck_block_v1\n    else:\n      block_fn = resnet._building_block_v2\n      if bottleneck:\n        block_fn = resnet._bottleneck_block_v2\n\n    with self.test_session(graph=tf.Graph()) as sess:\n      tf.set_random_seed(tf_seed)\n\n      strides = 1\n      channels_out = channels\n      projection_shortcut = None\n      if projection:\n        strides = 2\n        channels_out *= strides\n        projection_shortcut = self.make_projection(\n            filters_out=channels_out, strides=strides, data_format=data_format)\n\n      filters = channels_out\n      if bottleneck:\n        filters = channels_out // 4\n\n      x = tf.random_uniform((batch_size, width, width, channels))\n\n      y = block_fn(inputs=x, filters=filters, training=True,\n                   projection_shortcut=projection_shortcut, strides=strides,\n                   data_format=data_format)\n\n      init = tf.global_variables_initializer()\n      sess.run(init)\n\n      y_array = y.eval()\n      y_flat = y_array.flatten()\n      return y_array.shape, (y_flat[0], y_flat[-1], np.sum(y_flat))\n\n  def test_dense_0(self):\n    \"\"\"Sanity check 0 on dense layer.\"\"\"\n    computed = self.dense_run(1813835975)\n    tf.assert_equal(computed, (0.8760674, 0.2547844))\n\n  def test_dense_1(self):\n    \"\"\"Sanity check 1 on dense layer.\"\"\"\n    computed = self.dense_run(3574260356)\n    tf.assert_equal(computed, (0.75590825, 0.5339718))\n\n  def test_bottleneck_v1_width_32_channels_64_batch_size_32_with_proj(self):\n    \"\"\"Test of a single ResNet block.\"\"\"\n    computed_size, computed_values = self.resnet_block_run(\n        599400476, batch_size=32, bottleneck=True, projection=True,\n        version=1, width=32, channels=64)\n    tf.assert_equal(computed_size, (32, 16, 16, 128))\n    tf.assert_equal(computed_values, (0.0, 0.92648625, 587702.4))\n\n  def test_bottleneck_v2_width_32_channels_64_batch_size_32_with_proj(self):\n    \"\"\"Test of a single ResNet block.\"\"\"\n    computed_size, computed_values = self.resnet_block_run(\n        309580726, batch_size=32, bottleneck=True, projection=True,\n        version=2, width=32, channels=64)\n    tf.assert_equal(computed_size, (32, 16, 16, 128))\n    tf.assert_equal(computed_values, (-1.8759897, -0.5546854, -12860.312))\n\n  def test_bottleneck_v1_width_32_channels_64_batch_size_32(self):\n    \"\"\"Test of a single ResNet block.\"\"\"\n    computed_size, computed_values = self.resnet_block_run(\n        1969060699, batch_size=32, bottleneck=True, projection=False,\n        version=1, width=32, channels=64)\n    tf.assert_equal(computed_size, (32, 32, 32, 64))\n    tf.assert_equal(computed_values, (0.10141289, 0.0, 1483393.0))\n\n  def test_bottleneck_v2_width_32_channels_64_batch_size_32(self):\n    \"\"\"Test of a single ResNet block.\"\"\"\n    computed_size, computed_values = self.resnet_block_run(\n        1716369119, batch_size=32, bottleneck=True, projection=False,\n        version=2, width=32, channels=64)\n    tf.assert_equal(computed_size, (32, 32, 32, 64))\n    tf.assert_equal(computed_values, (1.4106897, 0.7455499, 834762.75))\n\n  def test_building_v1_width_32_channels_64_batch_size_32_with_proj(self):\n    \"\"\"Test of a single ResNet block.\"\"\"\n    computed_size, computed_values = self.resnet_block_run(\n        1455996458, batch_size=32, bottleneck=False, projection=True,\n        version=1, width=32, channels=64)\n    tf.assert_equal(computed_size, (32, 16, 16, 128))\n    tf.assert_equal(computed_values, (0.0, 0.0, 591701.3))\n\n  def test_building_v2_width_32_channels_64_batch_size_32_with_proj(self):\n    \"\"\"Test of a single ResNet block.\"\"\"\n    computed_size, computed_values = self.resnet_block_run(\n        2770738568, batch_size=32, bottleneck=False, projection=True,\n        version=2, width=32, channels=64)\n    tf.assert_equal(computed_size, (32, 16, 16, 128))\n    tf.assert_equal(computed_values, (-0.1908517, 0.2792631, -45776.055))\n\n  def test_building_v1_width_32_channels_64_batch_size_32(self):\n    \"\"\"Test of a single ResNet block.\"\"\"\n    computed_size, computed_values = self.resnet_block_run(\n        1262621774, batch_size=32, bottleneck=False, projection=False,\n        version=1, width=32, channels=64)\n    tf.assert_equal(computed_size, (32, 32, 32, 64))\n    tf.assert_equal(computed_values, (0.0, 0.0, 1493558.9))\n\n  def test_building_v2_width_32_channels_64_batch_size_32(self):\n    \"\"\"Test of a single ResNet block.\"\"\"\n    computed_size, computed_values = self.resnet_block_run(\n        3856195393, batch_size=32, bottleneck=False, projection=False,\n        version=2, width=32, channels=64)\n    tf.assert_equal(computed_size, (32, 32, 32, 64))\n    tf.assert_equal(computed_values, (-0.12920928, 0.38566422, 1157867.9))\n\n\nif __name__ == \"__main__\":\n  tf.test.main()\n", "comments": "   simple generation one random float single node dense network         the subsequent involved tests depend ability correctly seed     tensorflow  in event process function expected      simple dense tests fail indicating issue     tests rather resnet functions       args        tf seed  random seed tensorflow      returns        the generated random number result dense network              self test session(graph tf graph()) sess        tf set random seed(tf seed)        x   tf random uniform((1  1))         tf layers dense(inputs x  units 1)        init   tf global variables initializer()       sess run(init)       return x eval() 0  0   eval() 0  0     def make projection(self  filters  strides  data format)         1d convolution stride projector       args        filters  number filters projection        strides  stride length convolution        data format  channels first channels last      returns        a 1 wide cnn projector function              def projection shortcut(inputs)        return resnet conv2d fixed padding(           inputs inputs  filters filters  kernel size 1  strides strides            data format data format)     return projection shortcut    def resnet block run(self  tf seed  batch size  bottleneck  projection                         version  width  channels)         test whether resnet block construction changed         this function runs resnet block construction variety different     conditions       args        tf seed  random seed tensorflow       batch size  number points fake image  this needed due         batch normalization        bottleneck  whether use bottleneck layers        projection  whether project input        version  which version resnet test        width  the width fake image        channels  the number channels fake image       returns        the size block output  well several check values              data format    channels last       version    1        block fn   resnet  building block v1       bottleneck          block fn   resnet  bottleneck block v1     else        block fn   resnet  building block v2       bottleneck          block fn   resnet  bottleneck block v2      self test session(graph tf graph()) sess        tf set random seed(tf seed)        strides   1       channels   channels       projection shortcut   none       projection          strides   2         channels    strides         projection shortcut   self make projection(             filters channels  strides strides  data format data format)        filters   channels       bottleneck          filters   channels    4        x   tf random uniform((batch size  width  width  channels))          block fn(inputs x  filters filters  training true                     projection shortcut projection shortcut  strides strides                     data format data format)        init   tf global variables initializer()       sess run(init)        array   eval()       flat   array flatten()       return array shape  (y flat 0   flat  1   np sum(y flat))    def test dense 0(self)         sanity check 0 dense layer         computed   self dense run(1813835975)     tf assert equal(computed  (0 8760674  0 2547844))    def test dense 1(self)         sanity check 1 dense layer         computed   self dense run(3574260356)     tf assert equal(computed  (0 75590825  0 5339718))    def test bottleneck v1 width 32 channels 64 batch size 32 proj(self)         test single resnet block         computed size  computed values   self resnet block run(         599400476  batch size 32  bottleneck true  projection true          version 1  width 32  channels 64)     tf assert equal(computed size  (32  16  16  128))     tf assert equal(computed values  (0 0  0 92648625  587702 4))    def test bottleneck v2 width 32 channels 64 batch size 32 proj(self)         test single resnet block         computed size  computed values   self resnet block run(         309580726  batch size 32  bottleneck true  projection true          version 2  width 32  channels 64)     tf assert equal(computed size  (32  16  16  128))     tf assert equal(computed values  ( 1 8759897   0 5546854   12860 312))    def test bottleneck v1 width 32 channels 64 batch size 32(self)         test single resnet block         computed size  computed values   self resnet block run(         1969060699  batch size 32  bottleneck true  projection false          version 1  width 32  channels 64)     tf assert equal(computed size  (32  32  32  64))     tf assert equal(computed values  (0 10141289  0 0  1483393 0))    def test bottleneck v2 width 32 channels 64 batch size 32(self)         test single resnet block         computed size  computed values   self resnet block run(         1716369119  batch size 32  bottleneck true  projection false          version 2  width 32  channels 64)     tf assert equal(computed size  (32  32  32  64))     tf assert equal(computed values  (1 4106897  0 7455499  834762 75))    def test building v1 width 32 channels 64 batch size 32 proj(self)         test single resnet block         computed size  computed values   self resnet block run(         1455996458  batch size 32  bottleneck false  projection true          version 1  width 32  channels 64)     tf assert equal(computed size  (32  16  16  128))     tf assert equal(computed values  (0 0  0 0  591701 3))    def test building v2 width 32 channels 64 batch size 32 proj(self)         test single resnet block         computed size  computed values   self resnet block run(         2770738568  batch size 32  bottleneck false  projection true          version 2  width 32  channels 64)     tf assert equal(computed size  (32  16  16  128))     tf assert equal(computed values  ( 0 1908517  0 2792631   45776 055))    def test building v1 width 32 channels 64 batch size 32(self)         test single resnet block         computed size  computed values   self resnet block run(         1262621774  batch size 32  bottleneck false  projection false          version 1  width 32  channels 64)     tf assert equal(computed size  (32  32  32  64))     tf assert equal(computed values  (0 0  0 0  1493558 9))    def test building v2 width 32 channels 64 batch size 32(self)         test single resnet block        copyright 2018 the tensorflow authors  all rights reserved        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license           http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license                                                                                       pylint  disable g bad import order ", "content": "# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\n\nimport numpy as np\nimport tensorflow as tf\n\n\nfrom official.resnet import resnet  # pylint: disable=g-bad-import-order\n\n\nclass BlockTest(tf.test.TestCase):\n\n  def dense_run(self, tf_seed):\n    \"\"\"Simple generation of one random float and a single node dense network.\n\n      The subsequent more involved tests depend on the ability to correctly seed\n    TensorFlow. In the event that that process does not function as expected,\n    the simple dense tests will fail indicating that the issue is with the\n    tests rather than the ResNet functions.\n\n    Args:\n      tf_seed: Random seed for TensorFlow\n\n    Returns:\n      The generated random number and result of the dense network.\n    \"\"\"\n    with self.test_session(graph=tf.Graph()) as sess:\n      tf.set_random_seed(tf_seed)\n\n      x = tf.random_uniform((1, 1))\n      y = tf.layers.dense(inputs=x, units=1)\n\n      init = tf.global_variables_initializer()\n      sess.run(init)\n      return x.eval()[0, 0], y.eval()[0, 0]\n\n  def make_projection(self, filters_out, strides, data_format):\n    \"\"\"1D convolution with stride projector.\n\n    Args:\n      filters_out: Number of filters in the projection.\n      strides: Stride length for convolution.\n      data_format: channels_first or channels_last\n\n    Returns:\n      A 1 wide CNN projector function.\n    \"\"\"\n    def projection_shortcut(inputs):\n      return resnet.conv2d_fixed_padding(\n          inputs=inputs, filters=filters_out, kernel_size=1, strides=strides,\n          data_format=data_format)\n    return projection_shortcut\n\n  def resnet_block_run(self, tf_seed, batch_size, bottleneck, projection,\n                       version, width, channels):\n    \"\"\"Test whether resnet block construction has changed.\n\n      This function runs ResNet block construction under a variety of different\n    conditions.\n\n    Args:\n      tf_seed: Random seed for TensorFlow\n      batch_size: Number of points in the fake image. This is needed due to\n        batch normalization.\n      bottleneck: Whether or not to use bottleneck layers.\n      projection: Whether or not to project the input.\n      version: Which version of ResNet to test.\n      width: The width of the fake image.\n      channels: The number of channels in the fake image.\n\n    Returns:\n      The size of the block output, as well as several check values.\n    \"\"\"\n    data_format = \"channels_last\"\n\n    if version == 1:\n      block_fn = resnet._building_block_v1\n      if bottleneck:\n        block_fn = resnet._bottleneck_block_v1\n    else:\n      block_fn = resnet._building_block_v2\n      if bottleneck:\n        block_fn = resnet._bottleneck_block_v2\n\n    with self.test_session(graph=tf.Graph()) as sess:\n      tf.set_random_seed(tf_seed)\n\n      strides = 1\n      channels_out = channels\n      projection_shortcut = None\n      if projection:\n        strides = 2\n        channels_out *= strides\n        projection_shortcut = self.make_projection(\n            filters_out=channels_out, strides=strides, data_format=data_format)\n\n      filters = channels_out\n      if bottleneck:\n        filters = channels_out // 4\n\n      x = tf.random_uniform((batch_size, width, width, channels))\n\n      y = block_fn(inputs=x, filters=filters, training=True,\n                   projection_shortcut=projection_shortcut, strides=strides,\n                   data_format=data_format)\n\n      init = tf.global_variables_initializer()\n      sess.run(init)\n\n      y_array = y.eval()\n      y_flat = y_array.flatten()\n      return y_array.shape, (y_flat[0], y_flat[-1], np.sum(y_flat))\n\n  def test_dense_0(self):\n    \"\"\"Sanity check 0 on dense layer.\"\"\"\n    computed = self.dense_run(1813835975)\n    tf.assert_equal(computed, (0.8760674, 0.2547844))\n\n  def test_dense_1(self):\n    \"\"\"Sanity check 1 on dense layer.\"\"\"\n    computed = self.dense_run(3574260356)\n    tf.assert_equal(computed, (0.75590825, 0.5339718))\n\n  def test_bottleneck_v1_width_32_channels_64_batch_size_32_with_proj(self):\n    \"\"\"Test of a single ResNet block.\"\"\"\n    computed_size, computed_values = self.resnet_block_run(\n        599400476, batch_size=32, bottleneck=True, projection=True,\n        version=1, width=32, channels=64)\n    tf.assert_equal(computed_size, (32, 16, 16, 128))\n    tf.assert_equal(computed_values, (0.0, 0.92648625, 587702.4))\n\n  def test_bottleneck_v2_width_32_channels_64_batch_size_32_with_proj(self):\n    \"\"\"Test of a single ResNet block.\"\"\"\n    computed_size, computed_values = self.resnet_block_run(\n        309580726, batch_size=32, bottleneck=True, projection=True,\n        version=2, width=32, channels=64)\n    tf.assert_equal(computed_size, (32, 16, 16, 128))\n    tf.assert_equal(computed_values, (-1.8759897, -0.5546854, -12860.312))\n\n  def test_bottleneck_v1_width_32_channels_64_batch_size_32(self):\n    \"\"\"Test of a single ResNet block.\"\"\"\n    computed_size, computed_values = self.resnet_block_run(\n        1969060699, batch_size=32, bottleneck=True, projection=False,\n        version=1, width=32, channels=64)\n    tf.assert_equal(computed_size, (32, 32, 32, 64))\n    tf.assert_equal(computed_values, (0.10141289, 0.0, 1483393.0))\n\n  def test_bottleneck_v2_width_32_channels_64_batch_size_32(self):\n    \"\"\"Test of a single ResNet block.\"\"\"\n    computed_size, computed_values = self.resnet_block_run(\n        1716369119, batch_size=32, bottleneck=True, projection=False,\n        version=2, width=32, channels=64)\n    tf.assert_equal(computed_size, (32, 32, 32, 64))\n    tf.assert_equal(computed_values, (1.4106897, 0.7455499, 834762.75))\n\n  def test_building_v1_width_32_channels_64_batch_size_32_with_proj(self):\n    \"\"\"Test of a single ResNet block.\"\"\"\n    computed_size, computed_values = self.resnet_block_run(\n        1455996458, batch_size=32, bottleneck=False, projection=True,\n        version=1, width=32, channels=64)\n    tf.assert_equal(computed_size, (32, 16, 16, 128))\n    tf.assert_equal(computed_values, (0.0, 0.0, 591701.3))\n\n  def test_building_v2_width_32_channels_64_batch_size_32_with_proj(self):\n    \"\"\"Test of a single ResNet block.\"\"\"\n    computed_size, computed_values = self.resnet_block_run(\n        2770738568, batch_size=32, bottleneck=False, projection=True,\n        version=2, width=32, channels=64)\n    tf.assert_equal(computed_size, (32, 16, 16, 128))\n    tf.assert_equal(computed_values, (-0.1908517, 0.2792631, -45776.055))\n\n  def test_building_v1_width_32_channels_64_batch_size_32(self):\n    \"\"\"Test of a single ResNet block.\"\"\"\n    computed_size, computed_values = self.resnet_block_run(\n        1262621774, batch_size=32, bottleneck=False, projection=False,\n        version=1, width=32, channels=64)\n    tf.assert_equal(computed_size, (32, 32, 32, 64))\n    tf.assert_equal(computed_values, (0.0, 0.0, 1493558.9))\n\n  def test_building_v2_width_32_channels_64_batch_size_32(self):\n    \"\"\"Test of a single ResNet block.\"\"\"\n    computed_size, computed_values = self.resnet_block_run(\n        3856195393, batch_size=32, bottleneck=False, projection=False,\n        version=2, width=32, channels=64)\n    tf.assert_equal(computed_size, (32, 32, 32, 64))\n    tf.assert_equal(computed_values, (-0.12920928, 0.38566422, 1157867.9))\n\n\nif __name__ == \"__main__\":\n  tf.test.main()\n", "description": "Models and examples built with TensorFlow", "file_name": "resnet_test.py", "id": "415d3c3ec4e4a0348ee8b76ab85b6f2d", "language": "Python", "project_name": "models", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/tensorflow-models/tensorflow-models-086d914/official/resnet/resnet_test.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:59:19Z", "url": "https://github.com/tensorflow/models", "wiki": true}