{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    HEADRequest,\n    int_or_none,\n    orderedSet,\n    remove_end,\n    strip_jsonp,\n    unescapeHTML,\n    unified_strdate,\n)\n\n\nclass ORFTVthekIE(InfoExtractor):\n    IE_NAME = 'orf:tvthek'\n    IE_DESC = 'ORF TVthek'\n    _VALID_URL = r'https?://tvthek\\.orf\\.at/(?:[^/]+/)+(?P<id>\\d+)'\n\n    _TESTS = [{\n        'url': 'http://tvthek.orf.at/program/Aufgetischt/2745173/Aufgetischt-Mit-der-Steirischen-Tafelrunde/8891389',\n        'playlist': [{\n            'md5': '2942210346ed779588f428a92db88712',\n            'info_dict': {\n                'id': '8896777',\n                'ext': 'mp4',\n                'title': 'Aufgetischt: Mit der Steirischen Tafelrunde',\n                'description': 'md5:c1272f0245537812d4e36419c207b67d',\n                'duration': 2668,\n                'upload_date': '20141208',\n            },\n        }],\n        'skip': 'Blocked outside of Austria / Germany',\n    }, {\n        'url': 'http://tvthek.orf.at/topic/Im-Wandel-der-Zeit/8002126/Best-of-Ingrid-Thurnher/7982256',\n        'info_dict': {\n            'id': '7982259',\n            'ext': 'mp4',\n            'title': 'Best of Ingrid Thurnher',\n            'upload_date': '20140527',\n            'description': 'Viele Jahre war Ingrid Thurnher das \"Gesicht\" der ZIB 2. Vor ihrem Wechsel zur ZIB 2 im Jahr 1995 moderierte sie unter anderem \"Land und Leute\", \"\u00d6sterreich-Bild\" und \"Nieder\u00f6sterreich heute\".',\n        },\n        'params': {\n            'skip_download': True,  \n        },\n        'skip': 'Blocked outside of Austria / Germany',\n    }, {\n        'url': 'http://tvthek.orf.at/topic/Fluechtlingskrise/10463081/Heimat-Fremde-Heimat/13879132/Senioren-betreuen-Migrantenkinder/13879141',\n        'only_matching': True,\n    }, {\n        'url': 'http://tvthek.orf.at/profile/Universum/35429',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        playlist_id = self._match_id(url)\n        webpage = self._download_webpage(url, playlist_id)\n\n        data_jsb = self._parse_json(\n            self._search_regex(\n                r'<div[^>]+class=([\"\\']).*?VideoPlaylist.*?\\1[^>]+data-jsb=([\"\\'])(?P<json>.+?)\\2',\n                webpage, 'playlist', group='json'),\n            playlist_id, transform_source=unescapeHTML)['playlist']['videos']\n\n        def quality_to_int(s):\n            m = re.search('([0-9]+)', s)\n            if m is None:\n                return -1\n            return int(m.group(1))\n\n        entries = []\n        for sd in data_jsb:\n            video_id, title = sd.get('id'), sd.get('title')\n            if not video_id or not title:\n                continue\n            video_id = compat_str(video_id)\n            formats = [{\n                'preference': -10 if fd['delivery'] == 'hls' else None,\n                'format_id': '%s-%s-%s' % (\n                    fd['delivery'], fd['quality'], fd['quality_string']),\n                'url': fd['src'],\n                'protocol': fd['protocol'],\n                'quality': quality_to_int(fd['quality']),\n            } for fd in sd['sources']]\n\n            \n            \n            geo_str = sd.get('geoprotection_string')\n            if geo_str:\n                try:\n                    http_url = next(\n                        f['url']\n                        for f in formats\n                        if re.match(r'^https?://.*\\.mp4$', f['url']))\n                except StopIteration:\n                    pass\n                else:\n                    req = HEADRequest(http_url)\n                    self._request_webpage(\n                        req, video_id,\n                        note='Testing for geoblocking',\n                        errnote=((\n                            'This video seems to be blocked outside of %s. '\n                            'You may want to try the streaming-* formats.')\n                            % geo_str),\n                        fatal=False)\n\n            self._check_formats(formats, video_id)\n            self._sort_formats(formats)\n\n            subtitles = {}\n            for sub in sd.get('subtitles', []):\n                sub_src = sub.get('src')\n                if not sub_src:\n                    continue\n                subtitles.setdefault(sub.get('lang', 'de-AT'), []).append({\n                    'url': sub_src,\n                })\n\n            upload_date = unified_strdate(sd.get('created_date'))\n            entries.append({\n                '_type': 'video',\n                'id': video_id,\n                'title': title,\n                'formats': formats,\n                'subtitles': subtitles,\n                'description': sd.get('description'),\n                'duration': int_or_none(sd.get('duration_in_seconds')),\n                'upload_date': upload_date,\n                'thumbnail': sd.get('image_full_url'),\n            })\n\n        return {\n            '_type': 'playlist',\n            'entries': entries,\n            'id': playlist_id,\n        }\n\n\nclass ORFRadioIE(InfoExtractor):\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        station = mobj.group('station')\n        show_date = mobj.group('date')\n        show_id = mobj.group('show')\n\n        if station == 'fm4':\n            show_id = '4%s' % show_id\n\n        data = self._download_json(\n            'http://audioapi.orf.at/%s/api/json/current/broadcast/%s/%s' % (station, show_id, show_date),\n            show_id\n        )\n\n        def extract_entry_dict(info, title, subtitle):\n            return {\n                'id': info['loopStreamId'].replace('.mp3', ''),\n                'url': 'http://loopstream01.apa.at/?channel=%s&id=%s' % (station, info['loopStreamId']),\n                'title': title,\n                'description': subtitle,\n                'duration': (info['end'] - info['start']) / 1000,\n                'timestamp': info['start'] / 1000,\n                'ext': 'mp3'\n            }\n\n        entries = [extract_entry_dict(t, data['title'], data['subtitle']) for t in data['streams']]\n\n        return {\n            '_type': 'playlist',\n            'id': show_id,\n            'title': data['title'],\n            'description': data['subtitle'],\n            'entries': entries\n        }\n\n\nclass ORFFM4IE(ORFRadioIE):\n    IE_NAME = 'orf:fm4'\n    IE_DESC = 'radio FM4'\n    _VALID_URL = r'https?://(?P<station>fm4)\\.orf\\.at/player/(?P<date>[0-9]+)/(?P<show>\\w+)'\n\n    _TEST = {\n        'url': 'http://fm4.orf.at/player/20170107/CC',\n        'md5': '2b0be47375432a7ef104453432a19212',\n        'info_dict': {\n            'id': '2017-01-07_2100_tl_54_7DaysSat18_31295',\n            'ext': 'mp3',\n            'title': 'Solid Steel Radioshow',\n            'description': 'Die Mixshow von Coldcut und Ninja Tune.',\n            'duration': 3599,\n            'timestamp': 1483819257,\n            'upload_date': '20170107',\n        },\n        'skip': 'Shows from ORF radios are only available for 7 days.'\n    }\n\n\nclass ORFOE1IE(ORFRadioIE):\n    IE_NAME = 'orf:oe1'\n    IE_DESC = 'Radio \u00d6sterreich 1'\n    _VALID_URL = r'https?://(?P<station>oe1)\\.orf\\.at/player/(?P<date>[0-9]+)/(?P<show>\\w+)'\n\n    _TEST = {\n        'url': 'http://oe1.orf.at/player/20170108/456544',\n        'md5': '34d8a6e67ea888293741c86a099b745b',\n        'info_dict': {\n            'id': '2017-01-08_0759_tl_51_7DaysSun6_256141',\n            'ext': 'mp3',\n            'title': 'Morgenjournal',\n            'duration': 609,\n            'timestamp': 1483858796,\n            'upload_date': '20170108',\n        },\n        'skip': 'Shows from ORF radios are only available for 7 days.'\n    }\n\n\nclass ORFIPTVIE(InfoExtractor):\n    IE_NAME = 'orf:iptv'\n    IE_DESC = 'iptv.ORF.at'\n    _VALID_URL = r'https?://iptv\\.orf\\.at/(?:\n\n    _TEST = {\n        'url': 'http://iptv.orf.at/stories/2275236/',\n        'md5': 'c8b22af4718a4b4af58342529453e3e5',\n        'info_dict': {\n            'id': '350612',\n            'ext': 'flv',\n            'title': 'Weitere Evakuierungen um Vulkan Calbuco',\n            'description': 'md5:d689c959bdbcf04efeddedbf2299d633',\n            'duration': 68.197,\n            'thumbnail': r're:^https?://.*\\.jpg$',\n            'upload_date': '20150425',\n        },\n    }\n\n    def _real_extract(self, url):\n        story_id = self._match_id(url)\n\n        webpage = self._download_webpage(\n            'http://iptv.orf.at/stories/%s' % story_id, story_id)\n\n        video_id = self._search_regex(\n            r'data-video(?:id)?=\"(\\d+)\"', webpage, 'video id')\n\n        data = self._download_json(\n            'http://bits.orf.at/filehandler/static-api/json/current/data.json?file=%s' % video_id,\n            video_id)[0]\n\n        duration = float_or_none(data['duration'], 1000)\n\n        video = data['sources']['default']\n        load_balancer_url = video['loadBalancerUrl']\n        abr = int_or_none(video.get('audioBitrate'))\n        vbr = int_or_none(video.get('bitrate'))\n        fps = int_or_none(video.get('videoFps'))\n        width = int_or_none(video.get('videoWidth'))\n        height = int_or_none(video.get('videoHeight'))\n        thumbnail = video.get('preview')\n\n        rendition = self._download_json(\n            load_balancer_url, video_id, transform_source=strip_jsonp)\n\n        f = {\n            'abr': abr,\n            'vbr': vbr,\n            'fps': fps,\n            'width': width,\n            'height': height,\n        }\n\n        formats = []\n        for format_id, format_url in rendition['redirect'].items():\n            if format_id == 'rtmp':\n                ff = f.copy()\n                ff.update({\n                    'url': format_url,\n                    'format_id': format_id,\n                })\n                formats.append(ff)\n            elif determine_ext(format_url) == 'f4m':\n                formats.extend(self._extract_f4m_formats(\n                    format_url, video_id, f4m_id=format_id))\n            elif determine_ext(format_url) == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    format_url, video_id, 'mp4', m3u8_id=format_id))\n            else:\n                continue\n        self._sort_formats(formats)\n\n        title = remove_end(self._og_search_title(webpage), ' - iptv.ORF.at')\n        description = self._og_search_description(webpage)\n        upload_date = unified_strdate(self._html_search_meta(\n            'dc.date', webpage, 'upload date'))\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'duration': duration,\n            'thumbnail': thumbnail,\n            'upload_date': upload_date,\n            'formats': formats,\n        }\n\n\nclass ORFFM4StoryIE(InfoExtractor):\n    IE_NAME = 'orf:fm4:story'\n    IE_DESC = 'fm4.orf.at stories'\n    _VALID_URL = r'https?://fm4\\.orf\\.at/stories/(?P<id>\\d+)'\n\n    _TEST = {\n        'url': 'http://fm4.orf.at/stories/2865738/',\n        'playlist': [{\n            'md5': 'e1c2c706c45c7b34cf478bbf409907ca',\n            'info_dict': {\n                'id': '547792',\n                'ext': 'flv',\n                'title': 'Manu Delago und Inner Tongue live',\n                'description': 'Manu Delago und Inner Tongue haben bei der FM4 Soundpark Session live alles gegeben. Hier gibt es Fotos und die gesamte Session als Video.',\n                'duration': 1748.52,\n                'thumbnail': r're:^https?://.*\\.jpg$',\n                'upload_date': '20170913',\n            },\n        }, {\n            'md5': 'c6dd2179731f86f4f55a7b49899d515f',\n            'info_dict': {\n                'id': '547798',\n                'ext': 'flv',\n                'title': 'Manu Delago und Inner Tongue live (2)',\n                'duration': 1504.08,\n                'thumbnail': r're:^https?://.*\\.jpg$',\n                'upload_date': '20170913',\n                'description': 'Manu Delago und Inner Tongue haben bei der FM4 Soundpark Session live alles gegeben. Hier gibt es Fotos und die gesamte Session als Video.',\n            },\n        }],\n    }\n\n    def _real_extract(self, url):\n        story_id = self._match_id(url)\n        webpage = self._download_webpage(url, story_id)\n\n        entries = []\n        all_ids = orderedSet(re.findall(r'data-video(?:id)?=\"(\\d+)\"', webpage))\n        for idx, video_id in enumerate(all_ids):\n            data = self._download_json(\n                'http://bits.orf.at/filehandler/static-api/json/current/data.json?file=%s' % video_id,\n                video_id)[0]\n\n            duration = float_or_none(data['duration'], 1000)\n\n            video = data['sources']['q8c']\n            load_balancer_url = video['loadBalancerUrl']\n            abr = int_or_none(video.get('audioBitrate'))\n            vbr = int_or_none(video.get('bitrate'))\n            fps = int_or_none(video.get('videoFps'))\n            width = int_or_none(video.get('videoWidth'))\n            height = int_or_none(video.get('videoHeight'))\n            thumbnail = video.get('preview')\n\n            rendition = self._download_json(\n                load_balancer_url, video_id, transform_source=strip_jsonp)\n\n            f = {\n                'abr': abr,\n                'vbr': vbr,\n                'fps': fps,\n                'width': width,\n                'height': height,\n            }\n\n            formats = []\n            for format_id, format_url in rendition['redirect'].items():\n                if format_id == 'rtmp':\n                    ff = f.copy()\n                    ff.update({\n                        'url': format_url,\n                        'format_id': format_id,\n                    })\n                    formats.append(ff)\n                elif determine_ext(format_url) == 'f4m':\n                    formats.extend(self._extract_f4m_formats(\n                        format_url, video_id, f4m_id=format_id))\n                elif determine_ext(format_url) == 'm3u8':\n                    formats.extend(self._extract_m3u8_formats(\n                        format_url, video_id, 'mp4', m3u8_id=format_id))\n                else:\n                    continue\n            self._sort_formats(formats)\n\n            title = remove_end(self._og_search_title(webpage), ' - fm4.ORF.at')\n            if idx >= 1:\n                \n                title += ' (' + str(idx + 1) + ')'\n            description = self._og_search_description(webpage)\n            upload_date = unified_strdate(self._html_search_meta(\n                'dc.date', webpage, 'upload date'))\n\n            entries.append({\n                'id': video_id,\n                'title': title,\n                'description': description,\n                'duration': duration,\n                'thumbnail': thumbnail,\n                'upload_date': upload_date,\n                'formats': formats,\n            })\n\n        return self.playlist_result(entries)\n", "comments": "# coding: utf-8\n# rtsp downloads\n# Check for geoblocking.\n# There is a property is_geoprotection, but that's always false\n#/)?stories/(?P<id>\\d+)'\n# Titles are duplicates, make them unique\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    HEADRequest,\n    int_or_none,\n    orderedSet,\n    remove_end,\n    strip_jsonp,\n    unescapeHTML,\n    unified_strdate,\n)\n\n\nclass ORFTVthekIE(InfoExtractor):\n    IE_NAME = 'orf:tvthek'\n    IE_DESC = 'ORF TVthek'\n    _VALID_URL = r'https?://tvthek\\.orf\\.at/(?:[^/]+/)+(?P<id>\\d+)'\n\n    _TESTS = [{\n        'url': 'http://tvthek.orf.at/program/Aufgetischt/2745173/Aufgetischt-Mit-der-Steirischen-Tafelrunde/8891389',\n        'playlist': [{\n            'md5': '2942210346ed779588f428a92db88712',\n            'info_dict': {\n                'id': '8896777',\n                'ext': 'mp4',\n                'title': 'Aufgetischt: Mit der Steirischen Tafelrunde',\n                'description': 'md5:c1272f0245537812d4e36419c207b67d',\n                'duration': 2668,\n                'upload_date': '20141208',\n            },\n        }],\n        'skip': 'Blocked outside of Austria / Germany',\n    }, {\n        'url': 'http://tvthek.orf.at/topic/Im-Wandel-der-Zeit/8002126/Best-of-Ingrid-Thurnher/7982256',\n        'info_dict': {\n            'id': '7982259',\n            'ext': 'mp4',\n            'title': 'Best of Ingrid Thurnher',\n            'upload_date': '20140527',\n            'description': 'Viele Jahre war Ingrid Thurnher das \"Gesicht\" der ZIB 2. Vor ihrem Wechsel zur ZIB 2 im Jahr 1995 moderierte sie unter anderem \"Land und Leute\", \"\u00d6sterreich-Bild\" und \"Nieder\u00f6sterreich heute\".',\n        },\n        'params': {\n            'skip_download': True,  # rtsp downloads\n        },\n        'skip': 'Blocked outside of Austria / Germany',\n    }, {\n        'url': 'http://tvthek.orf.at/topic/Fluechtlingskrise/10463081/Heimat-Fremde-Heimat/13879132/Senioren-betreuen-Migrantenkinder/13879141',\n        'only_matching': True,\n    }, {\n        'url': 'http://tvthek.orf.at/profile/Universum/35429',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        playlist_id = self._match_id(url)\n        webpage = self._download_webpage(url, playlist_id)\n\n        data_jsb = self._parse_json(\n            self._search_regex(\n                r'<div[^>]+class=([\"\\']).*?VideoPlaylist.*?\\1[^>]+data-jsb=([\"\\'])(?P<json>.+?)\\2',\n                webpage, 'playlist', group='json'),\n            playlist_id, transform_source=unescapeHTML)['playlist']['videos']\n\n        def quality_to_int(s):\n            m = re.search('([0-9]+)', s)\n            if m is None:\n                return -1\n            return int(m.group(1))\n\n        entries = []\n        for sd in data_jsb:\n            video_id, title = sd.get('id'), sd.get('title')\n            if not video_id or not title:\n                continue\n            video_id = compat_str(video_id)\n            formats = [{\n                'preference': -10 if fd['delivery'] == 'hls' else None,\n                'format_id': '%s-%s-%s' % (\n                    fd['delivery'], fd['quality'], fd['quality_string']),\n                'url': fd['src'],\n                'protocol': fd['protocol'],\n                'quality': quality_to_int(fd['quality']),\n            } for fd in sd['sources']]\n\n            # Check for geoblocking.\n            # There is a property is_geoprotection, but that's always false\n            geo_str = sd.get('geoprotection_string')\n            if geo_str:\n                try:\n                    http_url = next(\n                        f['url']\n                        for f in formats\n                        if re.match(r'^https?://.*\\.mp4$', f['url']))\n                except StopIteration:\n                    pass\n                else:\n                    req = HEADRequest(http_url)\n                    self._request_webpage(\n                        req, video_id,\n                        note='Testing for geoblocking',\n                        errnote=((\n                            'This video seems to be blocked outside of %s. '\n                            'You may want to try the streaming-* formats.')\n                            % geo_str),\n                        fatal=False)\n\n            self._check_formats(formats, video_id)\n            self._sort_formats(formats)\n\n            subtitles = {}\n            for sub in sd.get('subtitles', []):\n                sub_src = sub.get('src')\n                if not sub_src:\n                    continue\n                subtitles.setdefault(sub.get('lang', 'de-AT'), []).append({\n                    'url': sub_src,\n                })\n\n            upload_date = unified_strdate(sd.get('created_date'))\n            entries.append({\n                '_type': 'video',\n                'id': video_id,\n                'title': title,\n                'formats': formats,\n                'subtitles': subtitles,\n                'description': sd.get('description'),\n                'duration': int_or_none(sd.get('duration_in_seconds')),\n                'upload_date': upload_date,\n                'thumbnail': sd.get('image_full_url'),\n            })\n\n        return {\n            '_type': 'playlist',\n            'entries': entries,\n            'id': playlist_id,\n        }\n\n\nclass ORFRadioIE(InfoExtractor):\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        station = mobj.group('station')\n        show_date = mobj.group('date')\n        show_id = mobj.group('show')\n\n        if station == 'fm4':\n            show_id = '4%s' % show_id\n\n        data = self._download_json(\n            'http://audioapi.orf.at/%s/api/json/current/broadcast/%s/%s' % (station, show_id, show_date),\n            show_id\n        )\n\n        def extract_entry_dict(info, title, subtitle):\n            return {\n                'id': info['loopStreamId'].replace('.mp3', ''),\n                'url': 'http://loopstream01.apa.at/?channel=%s&id=%s' % (station, info['loopStreamId']),\n                'title': title,\n                'description': subtitle,\n                'duration': (info['end'] - info['start']) / 1000,\n                'timestamp': info['start'] / 1000,\n                'ext': 'mp3'\n            }\n\n        entries = [extract_entry_dict(t, data['title'], data['subtitle']) for t in data['streams']]\n\n        return {\n            '_type': 'playlist',\n            'id': show_id,\n            'title': data['title'],\n            'description': data['subtitle'],\n            'entries': entries\n        }\n\n\nclass ORFFM4IE(ORFRadioIE):\n    IE_NAME = 'orf:fm4'\n    IE_DESC = 'radio FM4'\n    _VALID_URL = r'https?://(?P<station>fm4)\\.orf\\.at/player/(?P<date>[0-9]+)/(?P<show>\\w+)'\n\n    _TEST = {\n        'url': 'http://fm4.orf.at/player/20170107/CC',\n        'md5': '2b0be47375432a7ef104453432a19212',\n        'info_dict': {\n            'id': '2017-01-07_2100_tl_54_7DaysSat18_31295',\n            'ext': 'mp3',\n            'title': 'Solid Steel Radioshow',\n            'description': 'Die Mixshow von Coldcut und Ninja Tune.',\n            'duration': 3599,\n            'timestamp': 1483819257,\n            'upload_date': '20170107',\n        },\n        'skip': 'Shows from ORF radios are only available for 7 days.'\n    }\n\n\nclass ORFOE1IE(ORFRadioIE):\n    IE_NAME = 'orf:oe1'\n    IE_DESC = 'Radio \u00d6sterreich 1'\n    _VALID_URL = r'https?://(?P<station>oe1)\\.orf\\.at/player/(?P<date>[0-9]+)/(?P<show>\\w+)'\n\n    _TEST = {\n        'url': 'http://oe1.orf.at/player/20170108/456544',\n        'md5': '34d8a6e67ea888293741c86a099b745b',\n        'info_dict': {\n            'id': '2017-01-08_0759_tl_51_7DaysSun6_256141',\n            'ext': 'mp3',\n            'title': 'Morgenjournal',\n            'duration': 609,\n            'timestamp': 1483858796,\n            'upload_date': '20170108',\n        },\n        'skip': 'Shows from ORF radios are only available for 7 days.'\n    }\n\n\nclass ORFIPTVIE(InfoExtractor):\n    IE_NAME = 'orf:iptv'\n    IE_DESC = 'iptv.ORF.at'\n    _VALID_URL = r'https?://iptv\\.orf\\.at/(?:#/)?stories/(?P<id>\\d+)'\n\n    _TEST = {\n        'url': 'http://iptv.orf.at/stories/2275236/',\n        'md5': 'c8b22af4718a4b4af58342529453e3e5',\n        'info_dict': {\n            'id': '350612',\n            'ext': 'flv',\n            'title': 'Weitere Evakuierungen um Vulkan Calbuco',\n            'description': 'md5:d689c959bdbcf04efeddedbf2299d633',\n            'duration': 68.197,\n            'thumbnail': r're:^https?://.*\\.jpg$',\n            'upload_date': '20150425',\n        },\n    }\n\n    def _real_extract(self, url):\n        story_id = self._match_id(url)\n\n        webpage = self._download_webpage(\n            'http://iptv.orf.at/stories/%s' % story_id, story_id)\n\n        video_id = self._search_regex(\n            r'data-video(?:id)?=\"(\\d+)\"', webpage, 'video id')\n\n        data = self._download_json(\n            'http://bits.orf.at/filehandler/static-api/json/current/data.json?file=%s' % video_id,\n            video_id)[0]\n\n        duration = float_or_none(data['duration'], 1000)\n\n        video = data['sources']['default']\n        load_balancer_url = video['loadBalancerUrl']\n        abr = int_or_none(video.get('audioBitrate'))\n        vbr = int_or_none(video.get('bitrate'))\n        fps = int_or_none(video.get('videoFps'))\n        width = int_or_none(video.get('videoWidth'))\n        height = int_or_none(video.get('videoHeight'))\n        thumbnail = video.get('preview')\n\n        rendition = self._download_json(\n            load_balancer_url, video_id, transform_source=strip_jsonp)\n\n        f = {\n            'abr': abr,\n            'vbr': vbr,\n            'fps': fps,\n            'width': width,\n            'height': height,\n        }\n\n        formats = []\n        for format_id, format_url in rendition['redirect'].items():\n            if format_id == 'rtmp':\n                ff = f.copy()\n                ff.update({\n                    'url': format_url,\n                    'format_id': format_id,\n                })\n                formats.append(ff)\n            elif determine_ext(format_url) == 'f4m':\n                formats.extend(self._extract_f4m_formats(\n                    format_url, video_id, f4m_id=format_id))\n            elif determine_ext(format_url) == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    format_url, video_id, 'mp4', m3u8_id=format_id))\n            else:\n                continue\n        self._sort_formats(formats)\n\n        title = remove_end(self._og_search_title(webpage), ' - iptv.ORF.at')\n        description = self._og_search_description(webpage)\n        upload_date = unified_strdate(self._html_search_meta(\n            'dc.date', webpage, 'upload date'))\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'duration': duration,\n            'thumbnail': thumbnail,\n            'upload_date': upload_date,\n            'formats': formats,\n        }\n\n\nclass ORFFM4StoryIE(InfoExtractor):\n    IE_NAME = 'orf:fm4:story'\n    IE_DESC = 'fm4.orf.at stories'\n    _VALID_URL = r'https?://fm4\\.orf\\.at/stories/(?P<id>\\d+)'\n\n    _TEST = {\n        'url': 'http://fm4.orf.at/stories/2865738/',\n        'playlist': [{\n            'md5': 'e1c2c706c45c7b34cf478bbf409907ca',\n            'info_dict': {\n                'id': '547792',\n                'ext': 'flv',\n                'title': 'Manu Delago und Inner Tongue live',\n                'description': 'Manu Delago und Inner Tongue haben bei der FM4 Soundpark Session live alles gegeben. Hier gibt es Fotos und die gesamte Session als Video.',\n                'duration': 1748.52,\n                'thumbnail': r're:^https?://.*\\.jpg$',\n                'upload_date': '20170913',\n            },\n        }, {\n            'md5': 'c6dd2179731f86f4f55a7b49899d515f',\n            'info_dict': {\n                'id': '547798',\n                'ext': 'flv',\n                'title': 'Manu Delago und Inner Tongue live (2)',\n                'duration': 1504.08,\n                'thumbnail': r're:^https?://.*\\.jpg$',\n                'upload_date': '20170913',\n                'description': 'Manu Delago und Inner Tongue haben bei der FM4 Soundpark Session live alles gegeben. Hier gibt es Fotos und die gesamte Session als Video.',\n            },\n        }],\n    }\n\n    def _real_extract(self, url):\n        story_id = self._match_id(url)\n        webpage = self._download_webpage(url, story_id)\n\n        entries = []\n        all_ids = orderedSet(re.findall(r'data-video(?:id)?=\"(\\d+)\"', webpage))\n        for idx, video_id in enumerate(all_ids):\n            data = self._download_json(\n                'http://bits.orf.at/filehandler/static-api/json/current/data.json?file=%s' % video_id,\n                video_id)[0]\n\n            duration = float_or_none(data['duration'], 1000)\n\n            video = data['sources']['q8c']\n            load_balancer_url = video['loadBalancerUrl']\n            abr = int_or_none(video.get('audioBitrate'))\n            vbr = int_or_none(video.get('bitrate'))\n            fps = int_or_none(video.get('videoFps'))\n            width = int_or_none(video.get('videoWidth'))\n            height = int_or_none(video.get('videoHeight'))\n            thumbnail = video.get('preview')\n\n            rendition = self._download_json(\n                load_balancer_url, video_id, transform_source=strip_jsonp)\n\n            f = {\n                'abr': abr,\n                'vbr': vbr,\n                'fps': fps,\n                'width': width,\n                'height': height,\n            }\n\n            formats = []\n            for format_id, format_url in rendition['redirect'].items():\n                if format_id == 'rtmp':\n                    ff = f.copy()\n                    ff.update({\n                        'url': format_url,\n                        'format_id': format_id,\n                    })\n                    formats.append(ff)\n                elif determine_ext(format_url) == 'f4m':\n                    formats.extend(self._extract_f4m_formats(\n                        format_url, video_id, f4m_id=format_id))\n                elif determine_ext(format_url) == 'm3u8':\n                    formats.extend(self._extract_m3u8_formats(\n                        format_url, video_id, 'mp4', m3u8_id=format_id))\n                else:\n                    continue\n            self._sort_formats(formats)\n\n            title = remove_end(self._og_search_title(webpage), ' - fm4.ORF.at')\n            if idx >= 1:\n                # Titles are duplicates, make them unique\n                title += ' (' + str(idx + 1) + ')'\n            description = self._og_search_description(webpage)\n            upload_date = unified_strdate(self._html_search_meta(\n                'dc.date', webpage, 'upload date'))\n\n            entries.append({\n                'id': video_id,\n                'title': title,\n                'description': description,\n                'duration': duration,\n                'thumbnail': thumbnail,\n                'upload_date': upload_date,\n                'formats': formats,\n            })\n\n        return self.playlist_result(entries)\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "orf.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/orf.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}