{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport os\nimport re\nimport subprocess\nimport time\n\nfrom .common import FileDownloader\nfrom ..compat import compat_str\nfrom ..utils import (\n    check_executable,\n    encodeFilename,\n    encodeArgument,\n    get_exe_version,\n)\n\n\ndef rtmpdump_version():\n    return get_exe_version(\n        'rtmpdump', ['--help'], r'(?i)RTMPDump\\s*v?([0-9a-zA-Z._-]+)')\n\n\nclass RtmpFD(FileDownloader):\n    def real_download(self, filename, info_dict):\n        def run_rtmpdump(args):\n            start = time.time()\n            resume_percent = None\n            resume_downloaded_data_len = None\n            proc = subprocess.Popen(args, stderr=subprocess.PIPE)\n            cursor_in_new_line = True\n            proc_stderr_closed = False\n            while not proc_stderr_closed:\n                \n                line = ''\n                while True:\n                    char = proc.stderr.read(1)\n                    if not char:\n                        proc_stderr_closed = True\n                        break\n                    if char in [b'\\r', b'\\n']:\n                        break\n                    line += char.decode('ascii', 'replace')\n                if not line:\n                    \n                    continue\n                mobj = re.search(r'([0-9]+\\.[0-9]{3}) kB / [0-9]+\\.[0-9]{2} sec \\(([0-9]{1,2}\\.[0-9])%\\)', line)\n                if mobj:\n                    downloaded_data_len = int(float(mobj.group(1)) * 1024)\n                    percent = float(mobj.group(2))\n                    if not resume_percent:\n                        resume_percent = percent\n                        resume_downloaded_data_len = downloaded_data_len\n                    time_now = time.time()\n                    eta = self.calc_eta(start, time_now, 100 - resume_percent, percent - resume_percent)\n                    speed = self.calc_speed(start, time_now, downloaded_data_len - resume_downloaded_data_len)\n                    data_len = None\n                    if percent > 0:\n                        data_len = int(downloaded_data_len * 100 / percent)\n                    self._hook_progress({\n                        'status': 'downloading',\n                        'downloaded_bytes': downloaded_data_len,\n                        'total_bytes_estimate': data_len,\n                        'tmpfilename': tmpfilename,\n                        'filename': filename,\n                        'eta': eta,\n                        'elapsed': time_now - start,\n                        'speed': speed,\n                    })\n                    cursor_in_new_line = False\n                else:\n                    \n                    mobj = re.search(r'([0-9]+\\.[0-9]{3}) kB / [0-9]+\\.[0-9]{2} sec', line)\n                    if mobj:\n                        downloaded_data_len = int(float(mobj.group(1)) * 1024)\n                        time_now = time.time()\n                        speed = self.calc_speed(start, time_now, downloaded_data_len)\n                        self._hook_progress({\n                            'downloaded_bytes': downloaded_data_len,\n                            'tmpfilename': tmpfilename,\n                            'filename': filename,\n                            'status': 'downloading',\n                            'elapsed': time_now - start,\n                            'speed': speed,\n                        })\n                        cursor_in_new_line = False\n                    elif self.params.get('verbose', False):\n                        if not cursor_in_new_line:\n                            self.to_screen('')\n                        cursor_in_new_line = True\n                        self.to_screen('[rtmpdump] ' + line)\n            proc.wait()\n            if not cursor_in_new_line:\n                self.to_screen('')\n            return proc.returncode\n\n        url = info_dict['url']\n        player_url = info_dict.get('player_url')\n        page_url = info_dict.get('page_url')\n        app = info_dict.get('app')\n        play_path = info_dict.get('play_path')\n        tc_url = info_dict.get('tc_url')\n        flash_version = info_dict.get('flash_version')\n        live = info_dict.get('rtmp_live', False)\n        conn = info_dict.get('rtmp_conn')\n        protocol = info_dict.get('rtmp_protocol')\n        real_time = info_dict.get('rtmp_real_time', False)\n        no_resume = info_dict.get('no_resume', False)\n        continue_dl = self.params.get('continuedl', True)\n\n        self.report_destination(filename)\n        tmpfilename = self.temp_name(filename)\n        test = self.params.get('test', False)\n\n        \n        if not check_executable('rtmpdump', ['-h']):\n            self.report_error('RTMP download detected but \"rtmpdump\" could not be run. Please install it.')\n            return False\n\n        \n        \n        \n        basic_args = [\n            'rtmpdump', '--verbose', '-r', url,\n            '-o', tmpfilename]\n        if player_url is not None:\n            basic_args += ['--swfVfy', player_url]\n        if page_url is not None:\n            basic_args += ['--pageUrl', page_url]\n        if app is not None:\n            basic_args += ['--app', app]\n        if play_path is not None:\n            basic_args += ['--playpath', play_path]\n        if tc_url is not None:\n            basic_args += ['--tcUrl', tc_url]\n        if test:\n            basic_args += ['--stop', '1']\n        if flash_version is not None:\n            basic_args += ['--flashVer', flash_version]\n        if live:\n            basic_args += ['--live']\n        if isinstance(conn, list):\n            for entry in conn:\n                basic_args += ['--conn', entry]\n        elif isinstance(conn, compat_str):\n            basic_args += ['--conn', conn]\n        if protocol is not None:\n            basic_args += ['--protocol', protocol]\n        if real_time:\n            basic_args += ['--realtime']\n\n        args = basic_args\n        if not no_resume and continue_dl and not live:\n            args += ['--resume']\n        if not live and continue_dl:\n            args += ['--skip', '1']\n\n        args = [encodeArgument(a) for a in args]\n\n        self._debug_cmd(args, exe='rtmpdump')\n\n        RD_SUCCESS = 0\n        RD_FAILED = 1\n        RD_INCOMPLETE = 2\n        RD_NO_CONNECT = 3\n\n        retval = run_rtmpdump(args)\n\n        if retval == RD_NO_CONNECT:\n            self.report_error('[rtmpdump] Could not connect to RTMP server.')\n            return False\n\n        while retval in (RD_INCOMPLETE, RD_FAILED) and not test and not live:\n            prevsize = os.path.getsize(encodeFilename(tmpfilename))\n            self.to_screen('[rtmpdump] %s bytes' % prevsize)\n            time.sleep(5.0)  \n            args = basic_args + ['--resume']\n            if retval == RD_FAILED:\n                args += ['--skip', '1']\n            args = [encodeArgument(a) for a in args]\n            retval = run_rtmpdump(args)\n            cursize = os.path.getsize(encodeFilename(tmpfilename))\n            if prevsize == cursize and retval == RD_FAILED:\n                break\n            \n            if prevsize == cursize and retval == RD_INCOMPLETE and cursize > 1024:\n                self.to_screen('[rtmpdump] Could not download the whole video. This can happen for some advertisements.')\n                retval = RD_SUCCESS\n                break\n        if retval == RD_SUCCESS or (test and retval == RD_INCOMPLETE):\n            fsize = os.path.getsize(encodeFilename(tmpfilename))\n            self.to_screen('[rtmpdump] %s bytes' % fsize)\n            self.try_rename(tmpfilename, filename)\n            self._hook_progress({\n                'downloaded_bytes': fsize,\n                'total_bytes': fsize,\n                'filename': filename,\n                'status': 'finished',\n            })\n            return True\n        else:\n            self.to_stderr('\\n')\n            self.report_error('rtmpdump exited with code %d' % retval)\n            return False\n", "comments": "# read line from stderr\n# proc_stderr_closed is True\n# no percent for live streams\n# Check for rtmpdump first\n# Download using rtmpdump. rtmpdump returns exit code 2 when\n# the connection was interrupted and resuming appears to be\n# possible. This is part of rtmpdump's normal usage, AFAIK.\n# This seems to be needed\n# Some rtmp streams seem abort after ~ 99.8%. Don't complain for those\n", "content": "from __future__ import unicode_literals\n\nimport os\nimport re\nimport subprocess\nimport time\n\nfrom .common import FileDownloader\nfrom ..compat import compat_str\nfrom ..utils import (\n    check_executable,\n    encodeFilename,\n    encodeArgument,\n    get_exe_version,\n)\n\n\ndef rtmpdump_version():\n    return get_exe_version(\n        'rtmpdump', ['--help'], r'(?i)RTMPDump\\s*v?([0-9a-zA-Z._-]+)')\n\n\nclass RtmpFD(FileDownloader):\n    def real_download(self, filename, info_dict):\n        def run_rtmpdump(args):\n            start = time.time()\n            resume_percent = None\n            resume_downloaded_data_len = None\n            proc = subprocess.Popen(args, stderr=subprocess.PIPE)\n            cursor_in_new_line = True\n            proc_stderr_closed = False\n            while not proc_stderr_closed:\n                # read line from stderr\n                line = ''\n                while True:\n                    char = proc.stderr.read(1)\n                    if not char:\n                        proc_stderr_closed = True\n                        break\n                    if char in [b'\\r', b'\\n']:\n                        break\n                    line += char.decode('ascii', 'replace')\n                if not line:\n                    # proc_stderr_closed is True\n                    continue\n                mobj = re.search(r'([0-9]+\\.[0-9]{3}) kB / [0-9]+\\.[0-9]{2} sec \\(([0-9]{1,2}\\.[0-9])%\\)', line)\n                if mobj:\n                    downloaded_data_len = int(float(mobj.group(1)) * 1024)\n                    percent = float(mobj.group(2))\n                    if not resume_percent:\n                        resume_percent = percent\n                        resume_downloaded_data_len = downloaded_data_len\n                    time_now = time.time()\n                    eta = self.calc_eta(start, time_now, 100 - resume_percent, percent - resume_percent)\n                    speed = self.calc_speed(start, time_now, downloaded_data_len - resume_downloaded_data_len)\n                    data_len = None\n                    if percent > 0:\n                        data_len = int(downloaded_data_len * 100 / percent)\n                    self._hook_progress({\n                        'status': 'downloading',\n                        'downloaded_bytes': downloaded_data_len,\n                        'total_bytes_estimate': data_len,\n                        'tmpfilename': tmpfilename,\n                        'filename': filename,\n                        'eta': eta,\n                        'elapsed': time_now - start,\n                        'speed': speed,\n                    })\n                    cursor_in_new_line = False\n                else:\n                    # no percent for live streams\n                    mobj = re.search(r'([0-9]+\\.[0-9]{3}) kB / [0-9]+\\.[0-9]{2} sec', line)\n                    if mobj:\n                        downloaded_data_len = int(float(mobj.group(1)) * 1024)\n                        time_now = time.time()\n                        speed = self.calc_speed(start, time_now, downloaded_data_len)\n                        self._hook_progress({\n                            'downloaded_bytes': downloaded_data_len,\n                            'tmpfilename': tmpfilename,\n                            'filename': filename,\n                            'status': 'downloading',\n                            'elapsed': time_now - start,\n                            'speed': speed,\n                        })\n                        cursor_in_new_line = False\n                    elif self.params.get('verbose', False):\n                        if not cursor_in_new_line:\n                            self.to_screen('')\n                        cursor_in_new_line = True\n                        self.to_screen('[rtmpdump] ' + line)\n            proc.wait()\n            if not cursor_in_new_line:\n                self.to_screen('')\n            return proc.returncode\n\n        url = info_dict['url']\n        player_url = info_dict.get('player_url')\n        page_url = info_dict.get('page_url')\n        app = info_dict.get('app')\n        play_path = info_dict.get('play_path')\n        tc_url = info_dict.get('tc_url')\n        flash_version = info_dict.get('flash_version')\n        live = info_dict.get('rtmp_live', False)\n        conn = info_dict.get('rtmp_conn')\n        protocol = info_dict.get('rtmp_protocol')\n        real_time = info_dict.get('rtmp_real_time', False)\n        no_resume = info_dict.get('no_resume', False)\n        continue_dl = self.params.get('continuedl', True)\n\n        self.report_destination(filename)\n        tmpfilename = self.temp_name(filename)\n        test = self.params.get('test', False)\n\n        # Check for rtmpdump first\n        if not check_executable('rtmpdump', ['-h']):\n            self.report_error('RTMP download detected but \"rtmpdump\" could not be run. Please install it.')\n            return False\n\n        # Download using rtmpdump. rtmpdump returns exit code 2 when\n        # the connection was interrupted and resuming appears to be\n        # possible. This is part of rtmpdump's normal usage, AFAIK.\n        basic_args = [\n            'rtmpdump', '--verbose', '-r', url,\n            '-o', tmpfilename]\n        if player_url is not None:\n            basic_args += ['--swfVfy', player_url]\n        if page_url is not None:\n            basic_args += ['--pageUrl', page_url]\n        if app is not None:\n            basic_args += ['--app', app]\n        if play_path is not None:\n            basic_args += ['--playpath', play_path]\n        if tc_url is not None:\n            basic_args += ['--tcUrl', tc_url]\n        if test:\n            basic_args += ['--stop', '1']\n        if flash_version is not None:\n            basic_args += ['--flashVer', flash_version]\n        if live:\n            basic_args += ['--live']\n        if isinstance(conn, list):\n            for entry in conn:\n                basic_args += ['--conn', entry]\n        elif isinstance(conn, compat_str):\n            basic_args += ['--conn', conn]\n        if protocol is not None:\n            basic_args += ['--protocol', protocol]\n        if real_time:\n            basic_args += ['--realtime']\n\n        args = basic_args\n        if not no_resume and continue_dl and not live:\n            args += ['--resume']\n        if not live and continue_dl:\n            args += ['--skip', '1']\n\n        args = [encodeArgument(a) for a in args]\n\n        self._debug_cmd(args, exe='rtmpdump')\n\n        RD_SUCCESS = 0\n        RD_FAILED = 1\n        RD_INCOMPLETE = 2\n        RD_NO_CONNECT = 3\n\n        retval = run_rtmpdump(args)\n\n        if retval == RD_NO_CONNECT:\n            self.report_error('[rtmpdump] Could not connect to RTMP server.')\n            return False\n\n        while retval in (RD_INCOMPLETE, RD_FAILED) and not test and not live:\n            prevsize = os.path.getsize(encodeFilename(tmpfilename))\n            self.to_screen('[rtmpdump] %s bytes' % prevsize)\n            time.sleep(5.0)  # This seems to be needed\n            args = basic_args + ['--resume']\n            if retval == RD_FAILED:\n                args += ['--skip', '1']\n            args = [encodeArgument(a) for a in args]\n            retval = run_rtmpdump(args)\n            cursize = os.path.getsize(encodeFilename(tmpfilename))\n            if prevsize == cursize and retval == RD_FAILED:\n                break\n            # Some rtmp streams seem abort after ~ 99.8%. Don't complain for those\n            if prevsize == cursize and retval == RD_INCOMPLETE and cursize > 1024:\n                self.to_screen('[rtmpdump] Could not download the whole video. This can happen for some advertisements.')\n                retval = RD_SUCCESS\n                break\n        if retval == RD_SUCCESS or (test and retval == RD_INCOMPLETE):\n            fsize = os.path.getsize(encodeFilename(tmpfilename))\n            self.to_screen('[rtmpdump] %s bytes' % fsize)\n            self.try_rename(tmpfilename, filename)\n            self._hook_progress({\n                'downloaded_bytes': fsize,\n                'total_bytes': fsize,\n                'filename': filename,\n                'status': 'finished',\n            })\n            return True\n        else:\n            self.to_stderr('\\n')\n            self.report_error('rtmpdump exited with code %d' % retval)\n            return False\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "rtmp.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/downloader/rtmp.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}