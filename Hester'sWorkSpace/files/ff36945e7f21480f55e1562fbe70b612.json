{"author": "ansible", "code": " (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n\n This file is part of Ansible\n\n Ansible is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Ansible is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\nimport sys\n\nfrom collections import defaultdict, MutableMapping\n\ntry:\n    from hashlib import sha1\nexcept ImportError:\n    from sha import sha as sha1\n\nfrom jinja2.exceptions import UndefinedError\n\nfrom ansible import constants as C\nfrom ansible.errors import AnsibleError, AnsibleParserError, AnsibleUndefinedVariable, AnsibleFileNotFound, AnsibleAssertionError\nfrom ansible.inventory.host import Host\nfrom ansible.inventory.helpers import sort_groups, get_group_vars\nfrom ansible.module_utils._text import to_native\nfrom ansible.module_utils.six import iteritems, text_type\nfrom ansible.plugins.loader import lookup_loader, vars_loader\nfrom ansible.plugins.cache import FactCache\nfrom ansible.template import Templar\nfrom ansible.utils.listify import listify_lookup_plugin_terms\nfrom ansible.utils.vars import combine_vars\nfrom ansible.utils.unsafe_proxy import wrap_var\nfrom ansible.vars.clean import namespace_facts\n\ntry:\n    from __main__ import display\nexcept ImportError:\n    from ansible.utils.display import Display\n    display = Display()\n\n\ndef preprocess_vars(a):\n    '''\n    Ensures that vars contained in the parameter passed in are\n    returned as a list of dictionaries, to ensure for instance\n    that vars loaded from a file conform to an expected state.\n    '''\n\n    if a is None:\n        return None\n    elif not isinstance(a, list):\n        data = [a]\n    else:\n        data = a\n\n    for item in data:\n        if not isinstance(item, MutableMapping):\n            raise AnsibleError(\"variable files must contain either a dictionary of variables, or a list of dictionaries. Got: %s (%s)\" % (a, type(a)))\n\n    return data\n\n\nclass VariableManager:\n\n    _ALLOWED = frozenset(['plugins_by_group', 'groups_plugins_play', 'groups_plugins_inventory', 'groups_inventory',\n                          'all_plugins_play', 'all_plugins_inventory', 'all_inventory'])\n\n    def __init__(self, loader=None, inventory=None):\n\n        self._nonpersistent_fact_cache = defaultdict(dict)\n        self._vars_cache = defaultdict(dict)\n        self._extra_vars = defaultdict(dict)\n        self._host_vars_files = defaultdict(dict)\n        self._group_vars_files = defaultdict(dict)\n        self._inventory = inventory\n        self._loader = loader\n        self._hostvars = None\n        self._omit_token = '__omit_place_holder__%s' % sha1(os.urandom(64)).hexdigest()\n        self._options_vars = defaultdict(dict)\n\n         bad cache plugin is not fatal error\n        try:\n            self._fact_cache = FactCache()\n        except AnsibleError as e:\n            display.warning(to_native(e))\n             fallback to a dict as in memory cache\n            self._fact_cache = {}\n\n    def __getstate__(self):\n        data = dict(\n            fact_cache=self._fact_cache,\n            np_fact_cache=self._nonpersistent_fact_cache,\n            vars_cache=self._vars_cache,\n            extra_vars=self._extra_vars,\n            host_vars_files=self._host_vars_files,\n            group_vars_files=self._group_vars_files,\n            omit_token=self._omit_token,\n            options_vars=self._options_vars,\n            inventory=self._inventory,\n        )\n        return data\n\n    def __setstate__(self, data):\n        self._fact_cache = data.get('fact_cache', defaultdict(dict))\n        self._nonpersistent_fact_cache = data.get('np_fact_cache', defaultdict(dict))\n        self._vars_cache = data.get('vars_cache', defaultdict(dict))\n        self._extra_vars = data.get('extra_vars', dict())\n        self._host_vars_files = data.get('host_vars_files', defaultdict(dict))\n        self._group_vars_files = data.get('group_vars_files', defaultdict(dict))\n        self._omit_token = data.get('omit_token', '__omit_place_holder__%s' % sha1(os.urandom(64)).hexdigest())\n        self._inventory = data.get('inventory', None)\n        self._options_vars = data.get('options_vars', dict())\n\n    @property\n    def extra_vars(self):\n        ''' ensures a clean copy of the extra_vars are made '''\n        return self._extra_vars.copy()\n\n    @extra_vars.setter\n    def extra_vars(self, value):\n        ''' ensures a clean copy of the extra_vars are used to set the value '''\n        if not isinstance(value, MutableMapping):\n            raise AnsibleAssertionError(\"the type of 'value' for extra_vars should be a MutableMapping, but is a %s\" % type(value))\n        self._extra_vars = value.copy()\n\n    def set_inventory(self, inventory):\n        self._inventory = inventory\n\n    @property\n    def options_vars(self):\n        ''' ensures a clean copy of the options_vars are made '''\n        return self._options_vars.copy()\n\n    @options_vars.setter\n    def options_vars(self, value):\n        ''' ensures a clean copy of the options_vars are used to set the value '''\n        if not isinstance(value, dict):\n            raise AnsibleAssertionError(\"the type of 'value' for options_vars should be a dict, but is a %s\" % type(value))\n        self._options_vars = value.copy()\n\n    def get_vars(self, play=None, host=None, task=None, include_hostvars=True, include_delegate_to=True, use_cache=True):\n        '''\n        Returns the variables, with optional \"context\" given via the parameters\n        for the play, host, and task (which could possibly result in different\n        sets of variables being returned due to the additional context).\n\n        The order of precedence is:\n        - play->roles->get_default_vars (if there is a play context)\n        - group_vars_files[host] (if there is a host context)\n        - host_vars_files[host] (if there is a host context)\n        - host->get_vars (if there is a host context)\n        - fact_cache[host] (if there is a host context)\n        - play vars (if there is a play context)\n        - play vars_files (if there's no host context, ignore\n          file names that cannot be templated)\n        - task->get_vars (if there is a task context)\n        - vars_cache[host] (if there is a host context)\n        - extra vars\n        '''\n\n        display.debug(\"in VariableManager get_vars()\")\n\n        all_vars = dict()\n        magic_variables = self._get_magic_variables(\n            play=play,\n            host=host,\n            task=task,\n            include_hostvars=include_hostvars,\n            include_delegate_to=include_delegate_to,\n        )\n\n         default for all cases\n        basedirs = [self._loader.get_basedir()]\n\n        if play:\n             first we compile any vars specified in defaults/main.yml\n             for all roles within the specified play\n            for role in play.get_roles():\n                all_vars = combine_vars(all_vars, role.get_default_vars())\n\n        if task:\n             set basedirs\n            if C.PLAYBOOK_VARS_ROOT == 'all':   should be default\n                basedirs = task.get_search_path()\n            elif C.PLAYBOOK_VARS_ROOT in ('bottom', 'playbook_dir'):   only option in 2.4.0\n                basedirs = [task.get_search_path()[0]]\n            elif C.PLAYBOOK_VARS_ROOT != 'top':\n                 preserves default basedirs, only option pre 2.3\n                raise AnsibleError('Unkown playbook vars logic: %s' % C.PLAYBOOK_VARS_ROOT)\n\n             if we have a task in this context, and that task has a role, make\n             sure it sees its defaults above any other roles, as we previously\n             (v1) made sure each task had a copy of its roles default vars\n            if task._role is not None and (play or task.action == 'include_role'):\n                all_vars = combine_vars(all_vars, task._role.get_default_vars(dep_chain=task.get_dep_chain()))\n\n        if host:\n             THE 'all' group and the rest of groups for a host, used below\n            all_group = self._inventory.groups.get('all')\n            host_groups = sort_groups([g for g in host.get_groups() if g.name not in ['all']])\n\n            def _get_plugin_vars(plugin, path, entities):\n                data = {}\n                try:\n                    data = plugin.get_vars(self._loader, path, entities)\n                except AttributeError:\n                    try:\n                        for entity in entities:\n                            if isinstance(entity, Host):\n                                data.update(plugin.get_host_vars(entity.name))\n                            else:\n                                data.update(plugin.get_group_vars(entity.name))\n                    except AttributeError:\n                        if hasattr(plugin, 'run'):\n                            raise AnsibleError(\"Cannot use v1 type vars plugin %s from %s\" % (plugin._load_name, plugin._original_path))\n                        else:\n                            raise AnsibleError(\"Invalid vars plugin %s from %s\" % (plugin._load_name, plugin._original_path))\n                return data\n\n             internal fuctions that actually do the work\n            def _plugins_inventory(entities):\n                ''' merges all entities by inventory source '''\n                data = {}\n                for inventory_dir in self._inventory._sources:\n                    if ',' in inventory_dir and not os.path.exists(inventory_dir):   skip host lists\n                        continue\n                    elif not os.path.isdir(inventory_dir):   always pass 'inventory directory'\n                        inventory_dir = os.path.dirname(inventory_dir)\n\n                    for plugin in vars_loader.all():\n                        data = combine_vars(data, _get_plugin_vars(plugin, inventory_dir, entities))\n                return data\n\n            def _plugins_play(entities):\n                ''' merges all entities adjacent to play '''\n                data = {}\n                for plugin in vars_loader.all():\n                    for path in basedirs:\n                        data = combine_vars(data, _get_plugin_vars(plugin, path, entities))\n                return data\n\n             configurable functions that are sortable via config, rememer to add to _ALLOWED if expanding this list\n            def all_inventory():\n                return all_group.get_vars()\n\n            def all_plugins_inventory():\n                return _plugins_inventory([all_group])\n\n            def all_plugins_play():\n                return _plugins_play([all_group])\n\n            def groups_inventory():\n                ''' gets group vars from inventory '''\n                return get_group_vars(host_groups)\n\n            def groups_plugins_inventory():\n                ''' gets plugin sources from inventory for groups '''\n                return _plugins_inventory(host_groups)\n\n            def groups_plugins_play():\n                ''' gets plugin sources from play for groups '''\n                return _plugins_play(host_groups)\n\n            def plugins_by_groups():\n                '''\n                    merges all plugin sources by group,\n                    This should be used instead, NOT in combination with the other groups_plugins* functions\n                '''\n                data = {}\n                for group in host_groups:\n                    data[group] = combine_vars(data[group], _plugins_inventory(group))\n                    data[group] = combine_vars(data[group], _plugins_play(group))\n                return data\n\n             Merge groups as per precedence config\n             only allow to call the functions we want exposed\n            for entry in C.VARIABLE_PRECEDENCE:\n                if entry in self._ALLOWED:\n                    display.debug('Calling %s to load vars for %s' % (entry, host.name))\n                    all_vars = combine_vars(all_vars, locals()[entry]())\n                else:\n                    display.warning('Ignoring unknown variable precedence entry: %s' % (entry))\n\n             host vars, from inventory, inventory adjacent and play adjacent via plugins\n            all_vars = combine_vars(all_vars, host.get_vars())\n            all_vars = combine_vars(all_vars, _plugins_inventory([host]))\n            all_vars = combine_vars(all_vars, _plugins_play([host]))\n\n             finally, the facts caches for this host, if it exists\n            try:\n                facts = self._fact_cache.get(host.name, {})\n                all_vars.update(namespace_facts(facts))\n\n                 push facts to main namespace\n                if C.INJECT_FACTS_AS_VARS:\n                    all_vars = combine_vars(all_vars, wrap_var(facts))\n                else:\n                     always 'promote' ansible_local\n                    all_vars = combine_vars(all_vars, wrap_var({'ansible_local': facts.get('ansible_local', {})}))\n            except KeyError:\n                pass\n\n        if play:\n            all_vars = combine_vars(all_vars, play.get_vars())\n\n            vars_files = play.get_vars_files()\n            try:\n                for vars_file_item in vars_files:\n                     create a set of temporary vars here, which incorporate the extra\n                     and magic vars so we can properly template the vars_files entries\n                    temp_vars = combine_vars(all_vars, self._extra_vars)\n                    temp_vars = combine_vars(temp_vars, magic_variables)\n                    templar = Templar(loader=self._loader, variables=temp_vars)\n\n                     we assume each item in the list is itself a list, as we\n                     support \"conditional includes\" for vars_files, which mimics\n                     the with_first_found mechanism.\n                    vars_file_list = vars_file_item\n                    if not isinstance(vars_file_list, list):\n                        vars_file_list = [vars_file_list]\n\n                     now we iterate through the (potential) files, and break out\n                     as soon as we read one from the list. If none are found, we\n                     raise an error, which is silently ignored at this point.\n                    try:\n                        for vars_file in vars_file_list:\n                            vars_file = templar.template(vars_file)\n                            try:\n                                data = preprocess_vars(self._loader.load_from_file(vars_file, unsafe=True))\n                                if data is not None:\n                                    for item in data:\n                                        all_vars = combine_vars(all_vars, item)\n                                break\n                            except AnsibleFileNotFound:\n                                 we continue on loader failures\n                                continue\n                            except AnsibleParserError:\n                                raise\n                        else:\n                             if include_delegate_to is set to False, we ignore the missing\n                             vars file here because we're working on a delegated host\n                            if include_delegate_to:\n                                raise AnsibleFileNotFound(\"vars file %s was not found\" % vars_file_item)\n                    except (UndefinedError, AnsibleUndefinedVariable):\n                        if host is not None and self._fact_cache.get(host.name, dict()).get('module_setup') and task is not None:\n                            raise AnsibleUndefinedVariable(\"an undefined variable was found when attempting to template the vars_files item '%s'\"\n                                                           % vars_file_item, obj=vars_file_item)\n                        else:\n                             we do not have a full context here, and the missing variable could be because of that\n                             so just show a warning and continue\n                            display.vvv(\"skipping vars_file '%s' due to an undefined variable\" % vars_file_item)\n                            continue\n\n                    display.vvv(\"Read vars_file '%s'\" % vars_file_item)\n            except TypeError:\n                raise AnsibleParserError(\"Error while reading vars files - please supply a list of file names. \"\n                                         \"Got '%s' of type %s\" % (vars_files, type(vars_files)))\n\n             By default, we now merge in all vars from all roles in the play,\n             unless the user has disabled this via a config option\n            if not C.DEFAULT_PRIVATE_ROLE_VARS:\n                for role in play.get_roles():\n                    all_vars = combine_vars(all_vars, role.get_vars(include_params=False))\n\n         next, we merge in the vars from the role, which will specifically\n         follow the role dependency chain, and then we merge in the tasks\n         vars (which will look at parent blocks/task includes)\n        if task:\n            if task._role:\n                all_vars = combine_vars(all_vars, task._role.get_vars(task.get_dep_chain(), include_params=False))\n            all_vars = combine_vars(all_vars, task.get_vars())\n\n         next, we merge in the vars cache (include vars) and nonpersistent\n         facts cache (set_fact/register), in that order\n        if host:\n             include_vars non-persistent cache\n            all_vars = combine_vars(all_vars, self._vars_cache.get(host.get_name(), dict()))\n             fact non-persistent cache\n            all_vars = combine_vars(all_vars, self._nonpersistent_fact_cache.get(host.name, dict()))\n\n         next, we merge in role params and task include params\n        if task:\n            if task._role:\n                all_vars = combine_vars(all_vars, task._role.get_role_params(task.get_dep_chain()))\n\n             special case for include tasks, where the include params\n             may be specified in the vars field for the task, which should\n             have higher precedence than the vars/np facts above\n            all_vars = combine_vars(all_vars, task.get_include_params())\n\n         extra vars\n        all_vars = combine_vars(all_vars, self._extra_vars)\n\n         magic variables\n        all_vars = combine_vars(all_vars, magic_variables)\n\n         special case for the 'environment' magic variable, as someone\n         may have set it as a variable and we don't want to stomp on it\n        if task:\n            all_vars['environment'] = task.environment\n\n         if we have a task and we're delegating to another host, figure out the\n         variables for that host now so we don't have to rely on hostvars later\n        if task and task.delegate_to is not None and include_delegate_to:\n            all_vars['ansible_delegated_vars'] = self._get_delegated_vars(play, task, all_vars)\n\n         'vars' magic var\n        if task or play:\n             has to be copy, otherwise recursive ref\n            all_vars['vars'] = all_vars.copy()\n\n        display.debug(\"done with get_vars()\")\n        return all_vars\n\n    def _get_magic_variables(self, play, host, task, include_hostvars, include_delegate_to):\n        '''\n        Returns a dictionary of so-called \"magic\" variables in Ansible,\n        which are special variables we set internally for use.\n        '''\n\n        variables = {}\n        variables['playbook_dir'] = os.path.abspath(self._loader.get_basedir())\n        variables['ansible_playbook_python'] = sys.executable\n\n        if play:\n            variables['role_names'] = [r._role_name for r in play.roles]\n\n        if task:\n            if task._role:\n                variables['role_name'] = task._role.get_name()\n                variables['role_path'] = task._role._role_path\n                variables['role_uuid'] = text_type(task._role._uuid)\n\n        if self._inventory is not None:\n            variables['groups'] = self._inventory.get_groups_dict()\n            if play:\n                templar = Templar(loader=self._loader)\n                if templar.is_template(play.hosts):\n                    pattern = 'all'\n                else:\n                    pattern = play.hosts or 'all'\n                 add the list of hosts in the play, as adjusted for limit/filters\n                variables['ansible_play_hosts_all'] = [x.name for x in self._inventory.get_hosts(pattern=pattern, ignore_restrictions=True)]\n                variables['ansible_play_hosts'] = [x for x in variables['ansible_play_hosts_all'] if x not in play._removed_hosts]\n                variables['ansible_play_batch'] = [x.name for x in self._inventory.get_hosts() if x.name not in play._removed_hosts]\n\n                 DEPRECATED: play_hosts should be deprecated in favor of ansible_play_batch,\n                 however this would take work in the templating engine, so for now we'll add both\n                variables['play_hosts'] = variables['ansible_play_batch']\n\n         the 'omit' value alows params to be left out if the variable they are based on is undefined\n        variables['omit'] = self._omit_token\n         Set options vars\n        for option, option_value in iteritems(self._options_vars):\n            variables[option] = option_value\n\n        if self._hostvars is not None and include_hostvars:\n            variables['hostvars'] = self._hostvars\n\n        return variables\n\n    def _get_delegated_vars(self, play, task, existing_variables):\n         we unfortunately need to template the delegate_to field here,\n         as we're fetching vars before post_validate has been called on\n         the task that has been passed in\n        vars_copy = existing_variables.copy()\n        templar = Templar(loader=self._loader, variables=vars_copy)\n\n        items = []\n        if task.loop_with is not None:\n            if task.loop_with in lookup_loader:\n                try:\n                    loop_terms = listify_lookup_plugin_terms(terms=task.loop, templar=templar,\n                                                             loader=self._loader, fail_on_undefined=True, convert_bare=False)\n                    items = lookup_loader.get(task.loop_with, loader=self._loader, templar=templar).run(terms=loop_terms, variables=vars_copy)\n                except AnsibleUndefinedVariable:\n                     This task will be skipped later due to this, so we just setup\n                     a dummy array for the later code so it doesn't fail\n                    items = [None]\n            else:\n                raise AnsibleError(\"Failed to find the lookup named '%s' in the available lookup plugins\" % task.loop_with)\n        elif task.loop is not None:\n            items = templar.template(task.loop)\n        else:\n            items = [None]\n\n        delegated_host_vars = dict()\n        item_var = getattr(task.loop_control, 'loop_var', 'item')\n        for item in items:\n             update the variables with the item value for templating, in case we need it\n            if item is not None:\n                vars_copy[item_var] = item\n\n            templar.set_available_variables(vars_copy)\n            delegated_host_name = templar.template(task.delegate_to, fail_on_undefined=False)\n            if delegated_host_name is None:\n                raise AnsibleError(message=\"Undefined delegate_to host for task:\", obj=task._ds)\n            if delegated_host_name in delegated_host_vars:\n                 no need to repeat ourselves, as the delegate_to value\n                 does not appear to be tied to the loop item variable\n                continue\n\n             a dictionary of variables to use if we have to create a new host below\n             we set the default port based on the default transport here, to make sure\n             we use the proper default for windows\n            new_port = C.DEFAULT_REMOTE_PORT\n            if C.DEFAULT_TRANSPORT == 'winrm':\n                new_port = 5986\n\n            new_delegated_host_vars = dict(\n                ansible_delegated_host=delegated_host_name,\n                ansible_host=delegated_host_name,   not redundant as other sources can change ansible_host\n                ansible_port=new_port,\n                ansible_user=C.DEFAULT_REMOTE_USER,\n                ansible_connection=C.DEFAULT_TRANSPORT,\n            )\n\n             now try to find the delegated-to host in inventory, or failing that,\n             create a new host on the fly so we can fetch variables for it\n            delegated_host = None\n            if self._inventory is not None:\n                delegated_host = self._inventory.get_host(delegated_host_name)\n                 try looking it up based on the address field, and finally\n                 fall back to creating a host on the fly to use for the var lookup\n                if delegated_host is None:\n                    if delegated_host_name in C.LOCALHOST:\n                        delegated_host = self._inventory.localhost\n                    else:\n                        for h in self._inventory.get_hosts(ignore_limits=True, ignore_restrictions=True):\n                             check if the address matches, or if both the delegated_to host\n                             and the current host are in the list of localhost aliases\n                            if h.address == delegated_host_name:\n                                delegated_host = h\n                                break\n                        else:\n                            delegated_host = Host(name=delegated_host_name)\n                            delegated_host.vars = combine_vars(delegated_host.vars, new_delegated_host_vars)\n            else:\n                delegated_host = Host(name=delegated_host_name)\n                delegated_host.vars = combine_vars(delegated_host.vars, new_delegated_host_vars)\n\n             now we go fetch the vars for the delegated-to host and save them in our\n             master dictionary of variables to be used later in the TaskExecutor/PlayContext\n            delegated_host_vars[delegated_host_name] = self.get_vars(\n                play=play,\n                host=delegated_host,\n                task=task,\n                include_delegate_to=False,\n                include_hostvars=False,\n            )\n        return delegated_host_vars\n\n    def clear_facts(self, hostname):\n        '''\n        Clears the facts for a host\n        '''\n        if hostname in self._fact_cache:\n            del self._fact_cache[hostname]\n\n    def set_host_facts(self, host, facts):\n        '''\n        Sets or updates the given facts for a host in the fact cache.\n        '''\n\n        if not isinstance(facts, dict):\n            raise AnsibleAssertionError(\"the type of 'facts' to set for host_facts should be a dict but is a %s\" % type(facts))\n\n        if host.name not in self._fact_cache:\n            self._fact_cache[host.name] = facts\n        else:\n            try:\n                self._fact_cache.update(host.name, facts)\n            except KeyError:\n                self._fact_cache[host.name] = facts\n\n    def set_nonpersistent_facts(self, host, facts):\n        '''\n        Sets or updates the given facts for a host in the fact cache.\n        '''\n\n        if not isinstance(facts, dict):\n            raise AnsibleAssertionError(\"the type of 'facts' to set for nonpersistent_facts should be a dict but is a %s\" % type(facts))\n\n        if host.name not in self._nonpersistent_fact_cache:\n            self._nonpersistent_fact_cache[host.name] = facts\n        else:\n            try:\n                self._nonpersistent_fact_cache[host.name].update(facts)\n            except KeyError:\n                self._nonpersistent_fact_cache[host.name] = facts\n\n    def set_host_variable(self, host, varname, value):\n        '''\n        Sets a value in the vars_cache for a host.\n        '''\n        host_name = host.get_name()\n        if host_name not in self._vars_cache:\n            self._vars_cache[host_name] = dict()\n        if varname in self._vars_cache[host_name] and isinstance(self._vars_cache[host_name][varname], MutableMapping) and isinstance(value, MutableMapping):\n            self._vars_cache[host_name] = combine_vars(self._vars_cache[host_name], {varname: value})\n        else:\n            self._vars_cache[host_name][varname] = value\n", "comments": "        ensures vars contained parameter passed     returned list dictionaries  ensure instance     vars loaded file conform expected state               none          return none     elif isinstance(a  list)          data         else          data        item data          isinstance(item  mutablemapping)              raise ansibleerror( variable files must contain either dictionary variables  list dictionaries  got   ( s)    (a  type(a)))      return data   class variablemanager        allowed   frozenset(  plugins group    groups plugins play    groups plugins inventory    groups inventory                              plugins play    plugins inventory    inventory  )      def   init  (self  loader none  inventory none)           self  nonpersistent fact cache   defaultdict(dict)         self  vars cache   defaultdict(dict)         self  extra vars   defaultdict(dict)         self  host vars files   defaultdict(dict)         self  group vars files   defaultdict(dict)         self  inventory   inventory         self  loader   loader         self  hostvars   none         self  omit token      omit place holder      sha1(os urandom(64)) hexdigest()         self  options vars   defaultdict(dict)            bad cache plugin fatal error         try              self  fact cache   factcache()         except ansibleerror e              display warning(to native(e))               fallback dict memory cache             self  fact cache           def   getstate  (self)          data   dict(             fact cache self  fact cache              np fact cache self  nonpersistent fact cache              vars cache self  vars cache              extra vars self  extra vars              host vars files self  host vars files              group vars files self  group vars files              omit token self  omit token              options vars self  options vars              inventory self  inventory          )         return data      def   setstate  (self  data)          self  fact cache   data get( fact cache   defaultdict(dict))         self  nonpersistent fact cache   data get( np fact cache   defaultdict(dict))         self  vars cache   data get( vars cache   defaultdict(dict))         self  extra vars   data get( extra vars   dict())         self  host vars files   data get( host vars files   defaultdict(dict))         self  group vars files   data get( group vars files   defaultdict(dict))         self  omit token   data get( omit token      omit place holder      sha1(os urandom(64)) hexdigest())         self  inventory   data get( inventory   none)         self  options vars   data get( options vars   dict())       property     def extra vars(self)              ensures clean copy extra vars made             return self  extra vars copy()       extra vars setter     def extra vars(self  value)              ensures clean copy extra vars used set value             isinstance(value  mutablemapping)              raise ansibleassertionerror( type  value  extra vars mutablemapping      type(value))         self  extra vars   value copy()      def set inventory(self  inventory)          self  inventory   inventory       property     def options vars(self)              ensures clean copy options vars made             return self  options vars copy()       options vars setter     def options vars(self  value)              ensures clean copy options vars used set value             isinstance(value  dict)              raise ansibleassertionerror( type  value  options vars dict      type(value))         self  options vars   value copy()      def get vars(self  play none  host none  task none  include hostvars true  include delegate true  use cache true)                      returns variables  optional  context  given via parameters         play  host  task (which could possibly result different         sets variables returned due additional context)           the order precedence            play  roles  get default vars (if play context)           group vars files host  (if host context)           host vars files host  (if host context)           host  get vars (if host context)           fact cache host  (if host context)           play vars (if play context)           play vars files (if host context  ignore           file names cannot templated)           task  get vars (if task context)           vars cache host  (if host context)           extra vars                      display debug( variablemanager get vars() )          vars   dict()         magic variables   self  get magic variables(             play play              host host              task task              include hostvars include hostvars              include delegate include delegate          )            default cases         basedirs    self  loader get basedir()           play                first compile vars specified defaults main yml               roles within specified play             role play get roles()                  vars   combine vars(all vars  role get default vars())          task                set basedirs             c playbook vars root          default                 basedirs   task get search path()             elif c playbook vars root ( bottom    playbook dir )     option 2 4 0                 basedirs    task get search path() 0               elif c playbook vars root     top                     preserves default basedirs  option pre 2 3                 raise ansibleerror( unkown playbook vars logic      c playbook vars root)                task context  task role  make               sure sees defaults roles  previously               (v1) made sure task copy roles default vars             task  role none (play task action     include role )                  vars   combine vars(all vars  task  role get default vars(dep chain task get dep chain()))          host                the   group rest groups host  used             group   self  inventory groups get( )             host groups   sort groups( g g host get groups() g name     )              def  get plugin vars(plugin  path  entities)                  data                      try                      data   plugin get vars(self  loader  path  entities)                 except attributeerror                      try                          entity entities                              isinstance(entity  host)                                  data update(plugin get host vars(entity name))                             else                                  data update(plugin get group vars(entity name))                     except attributeerror                          hasattr(plugin   run )                              raise ansibleerror( cannot use v1 type vars plugin      (plugin  load name  plugin  original path))                         else                              raise ansibleerror( invalid vars plugin      (plugin  load name  plugin  original path))                 return data                internal fuctions actually work             def  plugins inventory(entities)                      merges entities inventory source                     data                      inventory dir self  inventory  sources                          inventory dir os path exists(inventory dir)     skip host lists                         continue                     elif os path isdir(inventory dir)     always pass  inventory directory                          inventory dir   os path dirname(inventory dir)                      plugin vars loader all()                          data   combine vars(data   get plugin vars(plugin  inventory dir  entities))                 return data              def  plugins play(entities)                      merges entities adjacent play                     data                      plugin vars loader all()                      path basedirs                          data   combine vars(data   get plugin vars(plugin  path  entities))                 return data                configurable functions sortable via config  rememer add  allowed expanding list             def inventory()                  return group get vars()              def plugins inventory()                  return  plugins inventory( group )              def plugins play()                  return  plugins play( group )              def groups inventory()                      gets group vars inventory                     return get group vars(host groups)              def groups plugins inventory()                      gets plugin sources inventory groups                     return  plugins inventory(host groups)              def groups plugins play()                      gets plugin sources play groups                     return  plugins play(host groups)              def plugins groups()                                          merges plugin sources group                      this used instead  not combination groups plugins  functions                                     data                      group host groups                      data group    combine vars(data group    plugins inventory(group))                     data group    combine vars(data group    plugins play(group))                 return data                merge groups per precedence config               allow call functions want exposed             entry c variable precedence                  entry self  allowed                      display debug( calling  load vars     (entry  host name))                     vars   combine vars(all vars  locals() entry ())                 else                      display warning( ignoring unknown variable precedence entry      (entry))                host vars  inventory  inventory adjacent play adjacent via plugins             vars   combine vars(all vars  host get vars())             vars   combine vars(all vars   plugins inventory( host ))             vars   combine vars(all vars   plugins play( host ))                finally  facts caches host  exists             try                  facts   self  fact cache get(host name    )                 vars update(namespace facts(facts))                    push facts main namespace                 c inject facts as vars                      vars   combine vars(all vars  wrap var(facts))                 else                        always  promote  ansible local                     vars   combine vars(all vars  wrap var(  ansible local   facts get( ansible local     ) ))             except keyerror                  pass          play              vars   combine vars(all vars  play get vars())              vars files   play get vars files()             try                  vars file item vars files                        create set temporary vars  incorporate extra                       magic vars properly template vars files entries                     temp vars   combine vars(all vars  self  extra vars)                     temp vars   combine vars(temp vars  magic variables)                     templar   templar(loader self  loader  variables temp vars)                        assume item list list                        support  conditional includes  vars files  mimics                       first found mechanism                      vars file list   vars file item                     isinstance(vars file list  list)                          vars file list    vars file list                         iterate (potential) files  break                       soon read one list  if none found                        raise error  silently ignored point                      try                          vars file vars file list                              vars file   templar template(vars file)                             try                                  data   preprocess vars(self  loader load file(vars file  unsafe true))                                 data none                                      item data                                          vars   combine vars(all vars  item)                                 break                             except ansiblefilenotfound                                    continue loader failures                                 continue                             except ansibleparsererror                                  raise                         else                                include delegate set false  ignore missing                               vars file working delegated host                             include delegate                                  raise ansiblefilenotfound( vars file  found    vars file item)                     except (undefinederror  ansibleundefinedvariable)                          host none self  fact cache get(host name  dict()) get( module setup ) task none                              raise ansibleundefinedvariable( undefined variable found attempting template vars files item                                                                  vars file item  obj vars file item)                         else                                full context  missing variable could                               show warning continue                             display vvv( skipping vars file    due undefined variable    vars file item)                             continue                      display vvv( read vars file       vars file item)             except typeerror                  raise ansibleparsererror( error reading vars files   please supply list file names                                              got    type     (vars files  type(vars files)))                by default  merge vars roles play                unless user disabled via config option             c default private role vars                  role play get roles()                      vars   combine vars(all vars  role get vars(include params false))            next  merge vars role  specifically           follow role dependency chain  merge tasks           vars (which look parent blocks task includes)         task              task  role                  vars   combine vars(all vars  task  role get vars(task get dep chain()  include params false))             vars   combine vars(all vars  task get vars())            next  merge vars cache (include vars) nonpersistent           facts cache (set fact register)  order         host                include vars non persistent cache             vars   combine vars(all vars  self  vars cache get(host get name()  dict()))               fact non persistent cache             vars   combine vars(all vars  self  nonpersistent fact cache get(host name  dict()))            next  merge role params task include params         task              task  role                  vars   combine vars(all vars  task  role get role params(task get dep chain()))                special case include tasks  include params               may specified vars field task                higher precedence vars np facts             vars   combine vars(all vars  task get include params())            extra vars         vars   combine vars(all vars  self  extra vars)            magic variables         vars   combine vars(all vars  magic variables)            special case  environment  magic variable  someone           may set variable want stomp         task              vars  environment     task environment            task delegating another host  figure           variables host rely hostvars later         task task delegate none include delegate              vars  ansible delegated vars     self  get delegated vars(play  task  vars)             vars  magic var         task play                copy  otherwise recursive ref             vars  vars     vars copy()          display debug( done get vars() )         return vars      def  get magic variables(self  play  host  task  include hostvars  include delegate to)                      returns dictionary called  magic  variables ansible          special variables set internally use                       variables              variables  playbook dir     os path abspath(self  loader get basedir())         variables  ansible playbook python     sys executable          play              variables  role names      r  role name r play roles           task              task  role                  variables  role name     task  role get name()                 variables  role path     task  role  role path                 variables  role uuid     text type(task  role  uuid)          self  inventory none              variables  groups     self  inventory get groups dict()             play                  templar   templar(loader self  loader)                 templar template(play hosts)                      pattern                     else                      pattern   play hosts                     add list hosts play  adjusted limit filters                 variables  ansible play hosts      x name x self  inventory get hosts(pattern pattern  ignore restrictions true)                  variables  ansible play hosts      x x variables  ansible play hosts   x play  removed hosts                  variables  ansible play batch      x name x self  inventory get hosts() x name play  removed hosts                     deprecated  play hosts deprecated favor ansible play batch                    however would take work templating engine  add                 variables  play hosts     variables  ansible play batch               omit  value alows params left variable based undefined         variables  omit     self  omit token           set options vars         option  option value iteritems(self  options vars)              variables option    option value          self  hostvars none include hostvars              variables  hostvars     self  hostvars          return variables      def  get delegated vars(self  play  task  existing variables)            unfortunately need template delegate field            fetching vars post validate called           task passed         vars copy   existing variables copy()         templar   templar(loader self  loader  variables vars copy)          items              task loop none              task loop lookup loader                  try                      loop terms   listify lookup plugin terms(terms task loop  templar templar                                                               loader self  loader  fail undefined true  convert bare false)                     items   lookup loader get(task loop  loader self  loader  templar templar) run(terms loop terms  variables vars copy)                 except ansibleundefinedvariable                        this task skipped later due  setup                       dummy array later code fail                     items    none              else                  raise ansibleerror( failed find lookup named    available lookup plugins    task loop with)         elif task loop none              items   templar template(task loop)         else              items    none           delegated host vars   dict()         item var   getattr(task loop control   loop var    item )         item items                update variables item value templating  case need             item none                  vars copy item var    item              templar set available variables(vars copy)             delegated host name   templar template(task delegate  fail undefined false)             delegated host name none                  raise ansibleerror(message  undefined delegate host task    obj task  ds)             delegated host name delegated host vars                    need repeat  delegate value                   appear tied loop item variable                 continue                dictionary variables use create new host               set default port based default transport  make sure               use proper default windows             new port   c default remote port             c default transport     winrm                   new port   5986              new delegated host vars   dict(                 ansible delegated host delegated host name                  ansible host delegated host name     redundant sources change ansible host                 ansible port new port                  ansible user c default remote user                  ansible connection c default transport              )                try find delegated host inventory  failing                create new host fly fetch variables             delegated host   none             self  inventory none                  delegated host   self  inventory get host(delegated host name)                   try looking based address field  finally                   fall back creating host fly use var lookup                 delegated host none                      delegated host name c localhost                          delegated host   self  inventory localhost                     else                          h self  inventory get hosts(ignore limits true  ignore restrictions true)                                check address matches  delegated host                               current host list localhost aliases                             h address    delegated host name                                  delegated host   h                                 break                         else                              delegated host   host(name delegated host name)                             delegated host vars   combine vars(delegated host vars  new delegated host vars)             else                  delegated host   host(name delegated host name)                 delegated host vars   combine vars(delegated host vars  new delegated host vars)                go fetch vars delegated host save               master dictionary variables used later taskexecutor playcontext             delegated host vars delegated host name    self get vars(                 play play                  host delegated host                  task task                  include delegate false                  include hostvars false              )         return delegated host vars      def clear facts(self  hostname)                      clears facts host                     hostname self  fact cache              del self  fact cache hostname       def set host facts(self  host  facts)                      sets updates given facts host fact cache                       isinstance(facts  dict)              raise ansibleassertionerror( type  facts  set host facts dict     type(facts))          host name self  fact cache              self  fact cache host name    facts         else              try                  self  fact cache update(host name  facts)             except keyerror                  self  fact cache host name    facts      def set nonpersistent facts(self  host  facts)                      sets updates given facts host fact cache                       isinstance(facts  dict)              raise ansibleassertionerror( type  facts  set nonpersistent facts dict     type(facts))          host name self  nonpersistent fact cache              self  nonpersistent fact cache host name    facts         else              try                  self  nonpersistent fact cache host name  update(facts)             except keyerror                  self  nonpersistent fact cache host name    facts      def set host variable(self  host  varname  value)                      sets value vars cache host                 (c) 2012 2014  michael dehaan  michael dehaan gmail com        this file part ansible       ansible free software  redistribute modify    terms gnu general public license published    free software foundation  either version 3 license     (at option) later version        ansible distributed hope useful     without any warranty  without even implied warranty    merchantability fitness for a particular purpose   see    gnu general public license details        you received copy gnu general public license    along ansible   if  see  http   www gnu org licenses       make coding python3 ish    bad cache plugin fatal error    fallback dict memory cache    default cases    first compile vars specified defaults main yml    roles within specified play    set basedirs    default    option 2 4 0    preserves default basedirs  option pre 2 3    task context  task role  make    sure sees defaults roles  previously    (v1) made sure task copy roles default vars    the   group rest groups host  used    internal fuctions actually work    skip host lists    always pass  inventory directory     configurable functions sortable via config  rememer add  allowed expanding list    merge groups per precedence config    allow call functions want exposed    host vars  inventory  inventory adjacent play adjacent via plugins    finally  facts caches host  exists    push facts main namespace    always  promote  ansible local    create set temporary vars  incorporate extra    magic vars properly template vars files entries    assume item list list     support  conditional includes  vars files  mimics    first found mechanism     iterate (potential) files  break    soon read one list  if none found     raise error  silently ignored point     continue loader failures    include delegate set false  ignore missing    vars file working delegated host    full context  missing variable could    show warning continue    by default  merge vars roles play     unless user disabled via config option    next  merge vars role  specifically    follow role dependency chain  merge tasks    vars (which look parent blocks task includes)    next  merge vars cache (include vars) nonpersistent    facts cache (set fact register)  order    include vars non persistent cache    fact non persistent cache    next  merge role params task include params    special case include tasks  include params    may specified vars field task     higher precedence vars np facts    extra vars    magic variables    special case  environment  magic variable  someone    may set variable want stomp    task delegating another host  figure    variables host rely hostvars later     vars  magic var    copy  otherwise recursive ref    add list hosts play  adjusted limit filters    deprecated  play hosts deprecated favor ansible play batch     however would take work templating engine  add     omit  value alows params left variable based undefined    set options vars    unfortunately need template delegate field     fetching vars post validate called    task passed    this task skipped later due  setup    dummy array later code fail    update variables item value templating  case need    need repeat  delegate value    appear tied loop item variable    dictionary variables use create new host    set default port based default transport  make sure    use proper default windows    redundant sources change ansible host    try find delegated host inventory  failing     create new host fly fetch variables    try looking based address field  finally    fall back creating host fly use var lookup    check address matches  delegated host    current host list localhost aliases    go fetch vars delegated host save    master dictionary variables used later taskexecutor playcontext ", "content": "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\nimport sys\n\nfrom collections import defaultdict, MutableMapping\n\ntry:\n    from hashlib import sha1\nexcept ImportError:\n    from sha import sha as sha1\n\nfrom jinja2.exceptions import UndefinedError\n\nfrom ansible import constants as C\nfrom ansible.errors import AnsibleError, AnsibleParserError, AnsibleUndefinedVariable, AnsibleFileNotFound, AnsibleAssertionError\nfrom ansible.inventory.host import Host\nfrom ansible.inventory.helpers import sort_groups, get_group_vars\nfrom ansible.module_utils._text import to_native\nfrom ansible.module_utils.six import iteritems, text_type\nfrom ansible.plugins.loader import lookup_loader, vars_loader\nfrom ansible.plugins.cache import FactCache\nfrom ansible.template import Templar\nfrom ansible.utils.listify import listify_lookup_plugin_terms\nfrom ansible.utils.vars import combine_vars\nfrom ansible.utils.unsafe_proxy import wrap_var\nfrom ansible.vars.clean import namespace_facts\n\ntry:\n    from __main__ import display\nexcept ImportError:\n    from ansible.utils.display import Display\n    display = Display()\n\n\ndef preprocess_vars(a):\n    '''\n    Ensures that vars contained in the parameter passed in are\n    returned as a list of dictionaries, to ensure for instance\n    that vars loaded from a file conform to an expected state.\n    '''\n\n    if a is None:\n        return None\n    elif not isinstance(a, list):\n        data = [a]\n    else:\n        data = a\n\n    for item in data:\n        if not isinstance(item, MutableMapping):\n            raise AnsibleError(\"variable files must contain either a dictionary of variables, or a list of dictionaries. Got: %s (%s)\" % (a, type(a)))\n\n    return data\n\n\nclass VariableManager:\n\n    _ALLOWED = frozenset(['plugins_by_group', 'groups_plugins_play', 'groups_plugins_inventory', 'groups_inventory',\n                          'all_plugins_play', 'all_plugins_inventory', 'all_inventory'])\n\n    def __init__(self, loader=None, inventory=None):\n\n        self._nonpersistent_fact_cache = defaultdict(dict)\n        self._vars_cache = defaultdict(dict)\n        self._extra_vars = defaultdict(dict)\n        self._host_vars_files = defaultdict(dict)\n        self._group_vars_files = defaultdict(dict)\n        self._inventory = inventory\n        self._loader = loader\n        self._hostvars = None\n        self._omit_token = '__omit_place_holder__%s' % sha1(os.urandom(64)).hexdigest()\n        self._options_vars = defaultdict(dict)\n\n        # bad cache plugin is not fatal error\n        try:\n            self._fact_cache = FactCache()\n        except AnsibleError as e:\n            display.warning(to_native(e))\n            # fallback to a dict as in memory cache\n            self._fact_cache = {}\n\n    def __getstate__(self):\n        data = dict(\n            fact_cache=self._fact_cache,\n            np_fact_cache=self._nonpersistent_fact_cache,\n            vars_cache=self._vars_cache,\n            extra_vars=self._extra_vars,\n            host_vars_files=self._host_vars_files,\n            group_vars_files=self._group_vars_files,\n            omit_token=self._omit_token,\n            options_vars=self._options_vars,\n            inventory=self._inventory,\n        )\n        return data\n\n    def __setstate__(self, data):\n        self._fact_cache = data.get('fact_cache', defaultdict(dict))\n        self._nonpersistent_fact_cache = data.get('np_fact_cache', defaultdict(dict))\n        self._vars_cache = data.get('vars_cache', defaultdict(dict))\n        self._extra_vars = data.get('extra_vars', dict())\n        self._host_vars_files = data.get('host_vars_files', defaultdict(dict))\n        self._group_vars_files = data.get('group_vars_files', defaultdict(dict))\n        self._omit_token = data.get('omit_token', '__omit_place_holder__%s' % sha1(os.urandom(64)).hexdigest())\n        self._inventory = data.get('inventory', None)\n        self._options_vars = data.get('options_vars', dict())\n\n    @property\n    def extra_vars(self):\n        ''' ensures a clean copy of the extra_vars are made '''\n        return self._extra_vars.copy()\n\n    @extra_vars.setter\n    def extra_vars(self, value):\n        ''' ensures a clean copy of the extra_vars are used to set the value '''\n        if not isinstance(value, MutableMapping):\n            raise AnsibleAssertionError(\"the type of 'value' for extra_vars should be a MutableMapping, but is a %s\" % type(value))\n        self._extra_vars = value.copy()\n\n    def set_inventory(self, inventory):\n        self._inventory = inventory\n\n    @property\n    def options_vars(self):\n        ''' ensures a clean copy of the options_vars are made '''\n        return self._options_vars.copy()\n\n    @options_vars.setter\n    def options_vars(self, value):\n        ''' ensures a clean copy of the options_vars are used to set the value '''\n        if not isinstance(value, dict):\n            raise AnsibleAssertionError(\"the type of 'value' for options_vars should be a dict, but is a %s\" % type(value))\n        self._options_vars = value.copy()\n\n    def get_vars(self, play=None, host=None, task=None, include_hostvars=True, include_delegate_to=True, use_cache=True):\n        '''\n        Returns the variables, with optional \"context\" given via the parameters\n        for the play, host, and task (which could possibly result in different\n        sets of variables being returned due to the additional context).\n\n        The order of precedence is:\n        - play->roles->get_default_vars (if there is a play context)\n        - group_vars_files[host] (if there is a host context)\n        - host_vars_files[host] (if there is a host context)\n        - host->get_vars (if there is a host context)\n        - fact_cache[host] (if there is a host context)\n        - play vars (if there is a play context)\n        - play vars_files (if there's no host context, ignore\n          file names that cannot be templated)\n        - task->get_vars (if there is a task context)\n        - vars_cache[host] (if there is a host context)\n        - extra vars\n        '''\n\n        display.debug(\"in VariableManager get_vars()\")\n\n        all_vars = dict()\n        magic_variables = self._get_magic_variables(\n            play=play,\n            host=host,\n            task=task,\n            include_hostvars=include_hostvars,\n            include_delegate_to=include_delegate_to,\n        )\n\n        # default for all cases\n        basedirs = [self._loader.get_basedir()]\n\n        if play:\n            # first we compile any vars specified in defaults/main.yml\n            # for all roles within the specified play\n            for role in play.get_roles():\n                all_vars = combine_vars(all_vars, role.get_default_vars())\n\n        if task:\n            # set basedirs\n            if C.PLAYBOOK_VARS_ROOT == 'all':  # should be default\n                basedirs = task.get_search_path()\n            elif C.PLAYBOOK_VARS_ROOT in ('bottom', 'playbook_dir'):  # only option in 2.4.0\n                basedirs = [task.get_search_path()[0]]\n            elif C.PLAYBOOK_VARS_ROOT != 'top':\n                # preserves default basedirs, only option pre 2.3\n                raise AnsibleError('Unkown playbook vars logic: %s' % C.PLAYBOOK_VARS_ROOT)\n\n            # if we have a task in this context, and that task has a role, make\n            # sure it sees its defaults above any other roles, as we previously\n            # (v1) made sure each task had a copy of its roles default vars\n            if task._role is not None and (play or task.action == 'include_role'):\n                all_vars = combine_vars(all_vars, task._role.get_default_vars(dep_chain=task.get_dep_chain()))\n\n        if host:\n            # THE 'all' group and the rest of groups for a host, used below\n            all_group = self._inventory.groups.get('all')\n            host_groups = sort_groups([g for g in host.get_groups() if g.name not in ['all']])\n\n            def _get_plugin_vars(plugin, path, entities):\n                data = {}\n                try:\n                    data = plugin.get_vars(self._loader, path, entities)\n                except AttributeError:\n                    try:\n                        for entity in entities:\n                            if isinstance(entity, Host):\n                                data.update(plugin.get_host_vars(entity.name))\n                            else:\n                                data.update(plugin.get_group_vars(entity.name))\n                    except AttributeError:\n                        if hasattr(plugin, 'run'):\n                            raise AnsibleError(\"Cannot use v1 type vars plugin %s from %s\" % (plugin._load_name, plugin._original_path))\n                        else:\n                            raise AnsibleError(\"Invalid vars plugin %s from %s\" % (plugin._load_name, plugin._original_path))\n                return data\n\n            # internal fuctions that actually do the work\n            def _plugins_inventory(entities):\n                ''' merges all entities by inventory source '''\n                data = {}\n                for inventory_dir in self._inventory._sources:\n                    if ',' in inventory_dir and not os.path.exists(inventory_dir):  # skip host lists\n                        continue\n                    elif not os.path.isdir(inventory_dir):  # always pass 'inventory directory'\n                        inventory_dir = os.path.dirname(inventory_dir)\n\n                    for plugin in vars_loader.all():\n                        data = combine_vars(data, _get_plugin_vars(plugin, inventory_dir, entities))\n                return data\n\n            def _plugins_play(entities):\n                ''' merges all entities adjacent to play '''\n                data = {}\n                for plugin in vars_loader.all():\n                    for path in basedirs:\n                        data = combine_vars(data, _get_plugin_vars(plugin, path, entities))\n                return data\n\n            # configurable functions that are sortable via config, rememer to add to _ALLOWED if expanding this list\n            def all_inventory():\n                return all_group.get_vars()\n\n            def all_plugins_inventory():\n                return _plugins_inventory([all_group])\n\n            def all_plugins_play():\n                return _plugins_play([all_group])\n\n            def groups_inventory():\n                ''' gets group vars from inventory '''\n                return get_group_vars(host_groups)\n\n            def groups_plugins_inventory():\n                ''' gets plugin sources from inventory for groups '''\n                return _plugins_inventory(host_groups)\n\n            def groups_plugins_play():\n                ''' gets plugin sources from play for groups '''\n                return _plugins_play(host_groups)\n\n            def plugins_by_groups():\n                '''\n                    merges all plugin sources by group,\n                    This should be used instead, NOT in combination with the other groups_plugins* functions\n                '''\n                data = {}\n                for group in host_groups:\n                    data[group] = combine_vars(data[group], _plugins_inventory(group))\n                    data[group] = combine_vars(data[group], _plugins_play(group))\n                return data\n\n            # Merge groups as per precedence config\n            # only allow to call the functions we want exposed\n            for entry in C.VARIABLE_PRECEDENCE:\n                if entry in self._ALLOWED:\n                    display.debug('Calling %s to load vars for %s' % (entry, host.name))\n                    all_vars = combine_vars(all_vars, locals()[entry]())\n                else:\n                    display.warning('Ignoring unknown variable precedence entry: %s' % (entry))\n\n            # host vars, from inventory, inventory adjacent and play adjacent via plugins\n            all_vars = combine_vars(all_vars, host.get_vars())\n            all_vars = combine_vars(all_vars, _plugins_inventory([host]))\n            all_vars = combine_vars(all_vars, _plugins_play([host]))\n\n            # finally, the facts caches for this host, if it exists\n            try:\n                facts = self._fact_cache.get(host.name, {})\n                all_vars.update(namespace_facts(facts))\n\n                # push facts to main namespace\n                if C.INJECT_FACTS_AS_VARS:\n                    all_vars = combine_vars(all_vars, wrap_var(facts))\n                else:\n                    # always 'promote' ansible_local\n                    all_vars = combine_vars(all_vars, wrap_var({'ansible_local': facts.get('ansible_local', {})}))\n            except KeyError:\n                pass\n\n        if play:\n            all_vars = combine_vars(all_vars, play.get_vars())\n\n            vars_files = play.get_vars_files()\n            try:\n                for vars_file_item in vars_files:\n                    # create a set of temporary vars here, which incorporate the extra\n                    # and magic vars so we can properly template the vars_files entries\n                    temp_vars = combine_vars(all_vars, self._extra_vars)\n                    temp_vars = combine_vars(temp_vars, magic_variables)\n                    templar = Templar(loader=self._loader, variables=temp_vars)\n\n                    # we assume each item in the list is itself a list, as we\n                    # support \"conditional includes\" for vars_files, which mimics\n                    # the with_first_found mechanism.\n                    vars_file_list = vars_file_item\n                    if not isinstance(vars_file_list, list):\n                        vars_file_list = [vars_file_list]\n\n                    # now we iterate through the (potential) files, and break out\n                    # as soon as we read one from the list. If none are found, we\n                    # raise an error, which is silently ignored at this point.\n                    try:\n                        for vars_file in vars_file_list:\n                            vars_file = templar.template(vars_file)\n                            try:\n                                data = preprocess_vars(self._loader.load_from_file(vars_file, unsafe=True))\n                                if data is not None:\n                                    for item in data:\n                                        all_vars = combine_vars(all_vars, item)\n                                break\n                            except AnsibleFileNotFound:\n                                # we continue on loader failures\n                                continue\n                            except AnsibleParserError:\n                                raise\n                        else:\n                            # if include_delegate_to is set to False, we ignore the missing\n                            # vars file here because we're working on a delegated host\n                            if include_delegate_to:\n                                raise AnsibleFileNotFound(\"vars file %s was not found\" % vars_file_item)\n                    except (UndefinedError, AnsibleUndefinedVariable):\n                        if host is not None and self._fact_cache.get(host.name, dict()).get('module_setup') and task is not None:\n                            raise AnsibleUndefinedVariable(\"an undefined variable was found when attempting to template the vars_files item '%s'\"\n                                                           % vars_file_item, obj=vars_file_item)\n                        else:\n                            # we do not have a full context here, and the missing variable could be because of that\n                            # so just show a warning and continue\n                            display.vvv(\"skipping vars_file '%s' due to an undefined variable\" % vars_file_item)\n                            continue\n\n                    display.vvv(\"Read vars_file '%s'\" % vars_file_item)\n            except TypeError:\n                raise AnsibleParserError(\"Error while reading vars files - please supply a list of file names. \"\n                                         \"Got '%s' of type %s\" % (vars_files, type(vars_files)))\n\n            # By default, we now merge in all vars from all roles in the play,\n            # unless the user has disabled this via a config option\n            if not C.DEFAULT_PRIVATE_ROLE_VARS:\n                for role in play.get_roles():\n                    all_vars = combine_vars(all_vars, role.get_vars(include_params=False))\n\n        # next, we merge in the vars from the role, which will specifically\n        # follow the role dependency chain, and then we merge in the tasks\n        # vars (which will look at parent blocks/task includes)\n        if task:\n            if task._role:\n                all_vars = combine_vars(all_vars, task._role.get_vars(task.get_dep_chain(), include_params=False))\n            all_vars = combine_vars(all_vars, task.get_vars())\n\n        # next, we merge in the vars cache (include vars) and nonpersistent\n        # facts cache (set_fact/register), in that order\n        if host:\n            # include_vars non-persistent cache\n            all_vars = combine_vars(all_vars, self._vars_cache.get(host.get_name(), dict()))\n            # fact non-persistent cache\n            all_vars = combine_vars(all_vars, self._nonpersistent_fact_cache.get(host.name, dict()))\n\n        # next, we merge in role params and task include params\n        if task:\n            if task._role:\n                all_vars = combine_vars(all_vars, task._role.get_role_params(task.get_dep_chain()))\n\n            # special case for include tasks, where the include params\n            # may be specified in the vars field for the task, which should\n            # have higher precedence than the vars/np facts above\n            all_vars = combine_vars(all_vars, task.get_include_params())\n\n        # extra vars\n        all_vars = combine_vars(all_vars, self._extra_vars)\n\n        # magic variables\n        all_vars = combine_vars(all_vars, magic_variables)\n\n        # special case for the 'environment' magic variable, as someone\n        # may have set it as a variable and we don't want to stomp on it\n        if task:\n            all_vars['environment'] = task.environment\n\n        # if we have a task and we're delegating to another host, figure out the\n        # variables for that host now so we don't have to rely on hostvars later\n        if task and task.delegate_to is not None and include_delegate_to:\n            all_vars['ansible_delegated_vars'] = self._get_delegated_vars(play, task, all_vars)\n\n        # 'vars' magic var\n        if task or play:\n            # has to be copy, otherwise recursive ref\n            all_vars['vars'] = all_vars.copy()\n\n        display.debug(\"done with get_vars()\")\n        return all_vars\n\n    def _get_magic_variables(self, play, host, task, include_hostvars, include_delegate_to):\n        '''\n        Returns a dictionary of so-called \"magic\" variables in Ansible,\n        which are special variables we set internally for use.\n        '''\n\n        variables = {}\n        variables['playbook_dir'] = os.path.abspath(self._loader.get_basedir())\n        variables['ansible_playbook_python'] = sys.executable\n\n        if play:\n            variables['role_names'] = [r._role_name for r in play.roles]\n\n        if task:\n            if task._role:\n                variables['role_name'] = task._role.get_name()\n                variables['role_path'] = task._role._role_path\n                variables['role_uuid'] = text_type(task._role._uuid)\n\n        if self._inventory is not None:\n            variables['groups'] = self._inventory.get_groups_dict()\n            if play:\n                templar = Templar(loader=self._loader)\n                if templar.is_template(play.hosts):\n                    pattern = 'all'\n                else:\n                    pattern = play.hosts or 'all'\n                # add the list of hosts in the play, as adjusted for limit/filters\n                variables['ansible_play_hosts_all'] = [x.name for x in self._inventory.get_hosts(pattern=pattern, ignore_restrictions=True)]\n                variables['ansible_play_hosts'] = [x for x in variables['ansible_play_hosts_all'] if x not in play._removed_hosts]\n                variables['ansible_play_batch'] = [x.name for x in self._inventory.get_hosts() if x.name not in play._removed_hosts]\n\n                # DEPRECATED: play_hosts should be deprecated in favor of ansible_play_batch,\n                # however this would take work in the templating engine, so for now we'll add both\n                variables['play_hosts'] = variables['ansible_play_batch']\n\n        # the 'omit' value alows params to be left out if the variable they are based on is undefined\n        variables['omit'] = self._omit_token\n        # Set options vars\n        for option, option_value in iteritems(self._options_vars):\n            variables[option] = option_value\n\n        if self._hostvars is not None and include_hostvars:\n            variables['hostvars'] = self._hostvars\n\n        return variables\n\n    def _get_delegated_vars(self, play, task, existing_variables):\n        # we unfortunately need to template the delegate_to field here,\n        # as we're fetching vars before post_validate has been called on\n        # the task that has been passed in\n        vars_copy = existing_variables.copy()\n        templar = Templar(loader=self._loader, variables=vars_copy)\n\n        items = []\n        if task.loop_with is not None:\n            if task.loop_with in lookup_loader:\n                try:\n                    loop_terms = listify_lookup_plugin_terms(terms=task.loop, templar=templar,\n                                                             loader=self._loader, fail_on_undefined=True, convert_bare=False)\n                    items = lookup_loader.get(task.loop_with, loader=self._loader, templar=templar).run(terms=loop_terms, variables=vars_copy)\n                except AnsibleUndefinedVariable:\n                    # This task will be skipped later due to this, so we just setup\n                    # a dummy array for the later code so it doesn't fail\n                    items = [None]\n            else:\n                raise AnsibleError(\"Failed to find the lookup named '%s' in the available lookup plugins\" % task.loop_with)\n        elif task.loop is not None:\n            items = templar.template(task.loop)\n        else:\n            items = [None]\n\n        delegated_host_vars = dict()\n        item_var = getattr(task.loop_control, 'loop_var', 'item')\n        for item in items:\n            # update the variables with the item value for templating, in case we need it\n            if item is not None:\n                vars_copy[item_var] = item\n\n            templar.set_available_variables(vars_copy)\n            delegated_host_name = templar.template(task.delegate_to, fail_on_undefined=False)\n            if delegated_host_name is None:\n                raise AnsibleError(message=\"Undefined delegate_to host for task:\", obj=task._ds)\n            if delegated_host_name in delegated_host_vars:\n                # no need to repeat ourselves, as the delegate_to value\n                # does not appear to be tied to the loop item variable\n                continue\n\n            # a dictionary of variables to use if we have to create a new host below\n            # we set the default port based on the default transport here, to make sure\n            # we use the proper default for windows\n            new_port = C.DEFAULT_REMOTE_PORT\n            if C.DEFAULT_TRANSPORT == 'winrm':\n                new_port = 5986\n\n            new_delegated_host_vars = dict(\n                ansible_delegated_host=delegated_host_name,\n                ansible_host=delegated_host_name,  # not redundant as other sources can change ansible_host\n                ansible_port=new_port,\n                ansible_user=C.DEFAULT_REMOTE_USER,\n                ansible_connection=C.DEFAULT_TRANSPORT,\n            )\n\n            # now try to find the delegated-to host in inventory, or failing that,\n            # create a new host on the fly so we can fetch variables for it\n            delegated_host = None\n            if self._inventory is not None:\n                delegated_host = self._inventory.get_host(delegated_host_name)\n                # try looking it up based on the address field, and finally\n                # fall back to creating a host on the fly to use for the var lookup\n                if delegated_host is None:\n                    if delegated_host_name in C.LOCALHOST:\n                        delegated_host = self._inventory.localhost\n                    else:\n                        for h in self._inventory.get_hosts(ignore_limits=True, ignore_restrictions=True):\n                            # check if the address matches, or if both the delegated_to host\n                            # and the current host are in the list of localhost aliases\n                            if h.address == delegated_host_name:\n                                delegated_host = h\n                                break\n                        else:\n                            delegated_host = Host(name=delegated_host_name)\n                            delegated_host.vars = combine_vars(delegated_host.vars, new_delegated_host_vars)\n            else:\n                delegated_host = Host(name=delegated_host_name)\n                delegated_host.vars = combine_vars(delegated_host.vars, new_delegated_host_vars)\n\n            # now we go fetch the vars for the delegated-to host and save them in our\n            # master dictionary of variables to be used later in the TaskExecutor/PlayContext\n            delegated_host_vars[delegated_host_name] = self.get_vars(\n                play=play,\n                host=delegated_host,\n                task=task,\n                include_delegate_to=False,\n                include_hostvars=False,\n            )\n        return delegated_host_vars\n\n    def clear_facts(self, hostname):\n        '''\n        Clears the facts for a host\n        '''\n        if hostname in self._fact_cache:\n            del self._fact_cache[hostname]\n\n    def set_host_facts(self, host, facts):\n        '''\n        Sets or updates the given facts for a host in the fact cache.\n        '''\n\n        if not isinstance(facts, dict):\n            raise AnsibleAssertionError(\"the type of 'facts' to set for host_facts should be a dict but is a %s\" % type(facts))\n\n        if host.name not in self._fact_cache:\n            self._fact_cache[host.name] = facts\n        else:\n            try:\n                self._fact_cache.update(host.name, facts)\n            except KeyError:\n                self._fact_cache[host.name] = facts\n\n    def set_nonpersistent_facts(self, host, facts):\n        '''\n        Sets or updates the given facts for a host in the fact cache.\n        '''\n\n        if not isinstance(facts, dict):\n            raise AnsibleAssertionError(\"the type of 'facts' to set for nonpersistent_facts should be a dict but is a %s\" % type(facts))\n\n        if host.name not in self._nonpersistent_fact_cache:\n            self._nonpersistent_fact_cache[host.name] = facts\n        else:\n            try:\n                self._nonpersistent_fact_cache[host.name].update(facts)\n            except KeyError:\n                self._nonpersistent_fact_cache[host.name] = facts\n\n    def set_host_variable(self, host, varname, value):\n        '''\n        Sets a value in the vars_cache for a host.\n        '''\n        host_name = host.get_name()\n        if host_name not in self._vars_cache:\n            self._vars_cache[host_name] = dict()\n        if varname in self._vars_cache[host_name] and isinstance(self._vars_cache[host_name][varname], MutableMapping) and isinstance(value, MutableMapping):\n            self._vars_cache[host_name] = combine_vars(self._vars_cache[host_name], {varname: value})\n        else:\n            self._vars_cache[host_name][varname] = value\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "manager.py", "id": "ff36945e7f21480f55e1562fbe70b612", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/vars/manager.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}