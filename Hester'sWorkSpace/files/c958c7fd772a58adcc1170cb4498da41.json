{"author": "Miserlou", "code": "\"\"\"\nCopyright 2015-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with the License. A copy of the License is located at\n     http://aws.amazon.com/apache2.0/\nor in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n\"\"\"\nfrom __future__ import print_function\n\nimport re\nimport time\nimport pprint\nimport json\n\n\ndef lambda_handler(event, context):\n    print(\"Client token: \" + event['authorizationToken'])\n    print(\"Method ARN: \" + event['methodArn'])\n    \"\"\"validate the incoming token\"\"\"\n    \"\"\"and produce the principal user identifier associated with the token\"\"\"\n\n    \"\"\"this could be accomplished in a number of ways:\"\"\"\n    \"\"\"1. Call out to OAuth provider\"\"\"\n    \"\"\"2. Decode a JWT token inline\"\"\"\n    \"\"\"3. Lookup in a self-managed DB\"\"\"\n    principalId = \"user|a1b2c3d4\"\n\n    \"\"\"you can send a 401 Unauthorized response to the client by failing like so:\"\"\"\n    \"\"\"raise Exception('Unauthorized')\"\"\"\n\n    \"\"\"if the token is valid, a policy must be generated which will allow or deny access to the client\"\"\"\n\n    \"\"\"if access is denied, the client will receive a 403 Access Denied response\"\"\"\n    \"\"\"if access is allowed, API Gateway will proceed with the backend integration configured on the method that was called\"\"\"\n\n    \"\"\"this function must generate a policy that is associated with the recognized principal user identifier.\"\"\"\n    \"\"\"depending on your use case, you might store policies in a DB, or generate them on the fly\"\"\"\n\n    \"\"\"keep in mind, the policy is cached for 5 minutes by default (TTL is configurable in the authorizer)\"\"\"\n    \"\"\"and will apply to subsequent calls to any method/resource in the RestApi\"\"\"\n    \"\"\"made with the same token\"\"\"\n\n    \"\"\"the example policy below denies access to all resources in the RestApi\"\"\"\n    tmp = event['methodArn'].split(':')\n    apiGatewayArnTmp = tmp[5].split('/')\n    awsAccountId = tmp[4]\n\n    policy = AuthPolicy(principalId, awsAccountId)\n    policy.restApiId = apiGatewayArnTmp[0]\n    policy.region = tmp[3]\n    policy.stage = apiGatewayArnTmp[1]\n\n    \n    ()\n\n    \n    policy.allowAllMethods()\n\n    \"\"\"policy.allowMethod(HttpVerb.GET, \"/pets/*\")\"\"\"\n\n    \"\"\"finally, build the policy and exit the function using return\"\"\"\n    return policy.build()\n\nclass HttpVerb:\n    GET     = \"GET\"\n    POST    = \"POST\"\n    PUT     = \"PUT\"\n    PATCH   = \"PATCH\"\n    HEAD    = \"HEAD\"\n    DELETE  = \"DELETE\"\n    OPTIONS = \"OPTIONS\"\n    ALL     = \"*\"\n\nclass AuthPolicy(object):\n    awsAccountId = \"\"\n    \"\"\"The AWS account id the policy will be generated for. This is used to create the method ARNs.\"\"\"\n    principalId = \"\"\n    \"\"\"The principal used for the policy, this should be a unique identifier for the end user.\"\"\"\n    version = \"2012-10-17\"\n    \"\"\"The policy version used for the evaluation. This should always be '2012-10-17'\"\"\"\n    pathRegex = \"^[/.a-zA-Z0-9-\\*]+$\"\n    \"\"\"The regular expression used to validate resource paths for the policy\"\"\"\n\n    \"\"\"these are the internal lists of allowed and denied methods. These are lists\n    of objects and each object has 2 properties: A resource ARN and a nullable\n    conditions statement.\n    the build method processes these lists and generates the approriate\n    statements for the final policy\"\"\"\n    allowMethods = []\n    denyMethods = []\n\n    restApiId = \"*\"\n    \"\"\"The API Gateway API id. By default this is set to '*'\"\"\"\n    region = \"*\"\n    \"\"\"The region where the API is deployed. By default this is set to '*'\"\"\"\n    stage = \"*\"\n    \"\"\"The name of the stage used in the policy. By default this is set to '*'\"\"\"\n\n    def __init__(self, principal, awsAccountId):\n        self.awsAccountId = awsAccountId\n        self.principalId = principal\n        self.allowMethods = []\n        self.denyMethods = []\n\n    def _addMethod(self, effect, verb, resource, conditions):\n        \"\"\"Adds a method to the internal lists of allowed or denied methods. Each object in\n        the internal list contains a resource ARN and a condition statement. The condition\n        statement can be null.\"\"\"\n        if verb != \"*\" and not hasattr(HttpVerb, verb):\n            raise NameError(\"Invalid HTTP verb \" + verb + \". Allowed verbs in HttpVerb class\")\n        resourcePattern = re.compile(self.pathRegex)\n        if not resourcePattern.match(resource):\n            raise NameError(\"Invalid resource path: \" + resource + \". Path should match \" + self.pathRegex)\n\n        if resource[:1] == \"/\":\n            resource = resource[1:]\n\n        resourceArn = (\"arn:aws:execute-api:\" +\n            self.region + \":\" +\n            self.awsAccountId + \":\" +\n            self.restApiId + \"/\" +\n            self.stage + \"/\" +\n            verb + \"/\" +\n            resource)\n\n        if effect.lower() == \"allow\":\n            self.allowMethods.append({\n                'resourceArn' : resourceArn,\n                'conditions' : conditions\n            })\n        elif effect.lower() == \"deny\":\n            self.denyMethods.append({\n                'resourceArn' : resourceArn,\n                'conditions' : conditions\n            })\n\n    def _getEmptyStatement(self, effect):\n        \"\"\"Returns an empty statement object prepopulated with the correct action and the\n        desired effect.\"\"\"\n        statement = {\n            'Action': 'execute-api:Invoke',\n            'Effect': effect[:1].upper() + effect[1:].lower(),\n            'Resource': []\n        }\n\n        return statement\n\n    def _getStatementForEffect(self, effect, methods):\n        \"\"\"This function loops over an array of objects containing a resourceArn and\n        conditions statement and generates the array of statements for the policy.\"\"\"\n        statements = []\n\n        if len(methods) > 0:\n            statement = self._getEmptyStatement(effect)\n\n            for curMethod in methods:\n                if curMethod['conditions'] is None or len(curMethod['conditions']) == 0:\n                    statement['Resource'].append(curMethod['resourceArn'])\n                else:\n                    conditionalStatement = self._getEmptyStatement(effect)\n                    conditionalStatement['Resource'].append(curMethod['resourceArn'])\n                    conditionalStatement['Condition'] = curMethod['conditions']\n                    statements.append(conditionalStatement)\n\n            statements.append(statement)\n\n        return statements\n\n    def allowAllMethods(self):\n        \"\"\"Adds a '*' allow to the policy to authorize access to all methods of an API\"\"\"\n        self._addMethod(\"Allow\", HttpVerb.ALL, \"*\", [])\n\n    def denyAllMethods(self):\n        \"\"\"Adds a '*' allow to the policy to deny access to all methods of an API\"\"\"\n        self._addMethod(\"Deny\", HttpVerb.ALL, \"*\", [])\n\n    def allowMethod(self, verb, resource):\n        \"\"\"Adds an API Gateway method (Http verb + Resource path) to the list of allowed\n        methods for the policy\"\"\"\n        self._addMethod(\"Allow\", verb, resource, [])\n\n    def denyMethod(self, verb, resource):\n        \"\"\"Adds an API Gateway method (Http verb + Resource path) to the list of denied\n        methods for the policy\"\"\"\n        self._addMethod(\"Deny\", verb, resource, [])\n\n    def allowMethodWithConditions(self, verb, resource, conditions):\n        \"\"\"Adds an API Gateway method (Http verb + Resource path) to the list of allowed\n        methods and includes a condition for the policy statement. More on AWS policy\n        conditions here: http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html\n        self._addMethod(\"Allow\", verb, resource, conditions)\n\n    def denyMethodWithConditions(self, verb, resource, conditions):\n        \"\"\"Adds an API Gateway method (Http verb + Resource path) to the list of denied\n        methods and includes a condition for the policy statement. More on AWS policy\n        conditions here: http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html\n        self._addMethod(\"Deny\", verb, resource, conditions)\n\n    def build(self):\n        \"\"\"Generates the policy document based on the internal lists of allowed and denied\n        conditions. This will generate a policy with two main statements for the effect:\n        one statement for Allow and one statement for Deny.\n        Methods that includes conditions will have their own statement in the policy.\"\"\"\n        if ((self.allowMethods is None or len(self.allowMethods) == 0) and\n            (self.denyMethods is None or len(self.denyMethods) == 0)):\n            raise NameError(\"No statements defined for the policy\")\n\n        policy = {\n            'principalId' : self.principalId,\n            'policyDocument' : {\n                'Version' : self.version,\n                'Statement' : []\n            }\n        }\n\n        policy['policyDocument']['Statement'].extend(self._getStatementForEffect(\"Allow\", self.allowMethods))\n        policy['policyDocument']['Statement'].extend(self._getStatementForEffect(\"Deny\", self.denyMethods))\n\n        return policy", "comments": "    copyright 2015 2016 amazon com  inc  affiliates  all rights reserved  licensed apache license  version 2 0 (the  license )  you may use file except compliance license  a copy license located      http   aws amazon com apache2 0   license  file accompanying file  this file distributed  as is  basis  without warranties or conditions of any kind  either express implied  see license specific language governing permissions limitations license        future   import print function  import import time import pprint import json   def lambda handler(event  context)      print( client token      event  authorizationtoken  )     print( method arn      event  methodarn  )        validate incoming token           produce principal user identifier associated token            could accomplished number ways            1  call oauth provider           2  decode jwt token inline           3  lookup self managed db        principalid    user a1b2c3d4          send 401 unauthorized response client failing like            raise exception( unauthorized )            token valid  policy must generated allow deny access client            access denied  client receive 403 access denied response           access allowed  api gateway proceed backend integration configured method called            function must generate policy associated recognized principal user identifier            depending use case  might store policies db  generate fly            keep mind  policy cached 5 minutes default (ttl configurable authorizer)           apply subsequent calls method resource restapi           made token            example policy denies access resources restapi        tmp   event  methodarn   split(   )     apigatewayarntmp   tmp 5  split(   )     awsaccountid   tmp 4       policy   authpolicy(principalid  awsaccountid)     policy restapiid   apigatewayarntmp 0      policy region   tmp 3      policy stage   apigatewayarntmp 1         blueprint denies methods default       policy denyallmethods()        example allows methods     policy allowallmethods()         policy allowmethod(httpverb get    pets   )            finally  build policy exit function using return        return policy build()  class httpverb      get        get      post       post      put        put      patch      patch      head       head      delete     delete      options    options      all            class authpolicy(object)      awsaccountid             the aws account id policy generated  this used create method arns         principalid             the principal used policy  unique identifier end user         version    2012 10 17         the policy version used evaluation  this always  2012 10 17         pathregex        za z0 9               the regular expression used validate resource paths policy            internal lists allowed denied methods  these lists     objects object 2 properties  a resource arn nullable     conditions statement      build method processes lists generates approriate     statements final policy        allowmethods          denymethods           restapiid              the api gateway api id  by default set            region              the region api deployed  by default set            stage              the name stage used policy  by default set             def   init  (self  principal  awsaccountid)          self awsaccountid   awsaccountid         self principalid   principal         self allowmethods              self denymethods           def  addmethod(self  effect  verb  resource  conditions)             adds method internal lists allowed denied methods  each object         internal list contains resource arn condition statement  the condition         statement null             verb        hasattr(httpverb  verb)              raise nameerror( invalid http verb     verb      allowed verbs httpverb class )         resourcepattern   compile(self pathregex)         resourcepattern match(resource)              raise nameerror( invalid resource path      resource      path match     self pathregex)          resource  1                      resource   resource 1            resourcearn   ( arn aws execute api                 self region                     self awsaccountid                     self restapiid                     self stage                     verb                     resource)          effect lower()     allow               self allowmethods append(                   resourcearn    resourcearn                   conditions    conditions              )         elif effect lower()     deny               self denymethods append(                   resourcearn    resourcearn                   conditions    conditions              )      def  getemptystatement(self  effect)             returns empty statement object prepopulated correct action         desired effect             statement                  action    execute api invoke                effect   effect  1  upper()   effect 1   lower()               resource                         return statement      def  getstatementforeffect(self  effect  methods)             this function loops array objects containing resourcearn         conditions statement generates array statements policy             statements               len(methods)   0              statement   self  getemptystatement(effect)              curmethod methods                  curmethod  conditions   none len(curmethod  conditions  )    0                      statement  resource   append(curmethod  resourcearn  )                 else                      conditionalstatement   self  getemptystatement(effect)                     conditionalstatement  resource   append(curmethod  resourcearn  )                     conditionalstatement  condition     curmethod  conditions                       statements append(conditionalstatement)              statements append(statement)          return statements      def allowallmethods(self)             adds     allow policy authorize access methods api            self  addmethod( allow   httpverb all         )      def denyallmethods(self)             adds     allow policy deny access methods api            self  addmethod( deny   httpverb all         )      def allowmethod(self  verb  resource)             adds api gateway method (http verb   resource path) list allowed         methods policy            self  addmethod( allow   verb  resource    )      def denymethod(self  verb  resource)             adds api gateway method (http verb   resource path) list denied         methods policy            self  addmethod( deny   verb  resource    )      def allowmethodwithconditions(self  verb  resource  conditions)             adds api gateway method (http verb   resource path) list allowed         methods includes condition policy statement  more aws policy         conditions  http   docs aws amazon com iam latest userguide reference policies elements html condition            self  addmethod( allow   verb  resource  conditions)      def denymethodwithconditions(self  verb  resource  conditions)             adds api gateway method (http verb   resource path) list denied         methods includes condition policy statement  more aws policy         conditions  http   docs aws amazon com iam latest userguide reference policies elements html condition            self  addmethod( deny   verb  resource  conditions)      def build(self)             generates policy document based internal lists allowed denied         conditions  this generate policy two main statements effect          one statement allow one statement deny          methods includes conditions statement policy        blueprint denies methods default    policy denyallmethods()    example allows methods   condition      condition    ", "content": "\"\"\"\nCopyright 2015-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with the License. A copy of the License is located at\n     http://aws.amazon.com/apache2.0/\nor in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n\"\"\"\nfrom __future__ import print_function\n\nimport re\nimport time\nimport pprint\nimport json\n\n\ndef lambda_handler(event, context):\n    print(\"Client token: \" + event['authorizationToken'])\n    print(\"Method ARN: \" + event['methodArn'])\n    \"\"\"validate the incoming token\"\"\"\n    \"\"\"and produce the principal user identifier associated with the token\"\"\"\n\n    \"\"\"this could be accomplished in a number of ways:\"\"\"\n    \"\"\"1. Call out to OAuth provider\"\"\"\n    \"\"\"2. Decode a JWT token inline\"\"\"\n    \"\"\"3. Lookup in a self-managed DB\"\"\"\n    principalId = \"user|a1b2c3d4\"\n\n    \"\"\"you can send a 401 Unauthorized response to the client by failing like so:\"\"\"\n    \"\"\"raise Exception('Unauthorized')\"\"\"\n\n    \"\"\"if the token is valid, a policy must be generated which will allow or deny access to the client\"\"\"\n\n    \"\"\"if access is denied, the client will receive a 403 Access Denied response\"\"\"\n    \"\"\"if access is allowed, API Gateway will proceed with the backend integration configured on the method that was called\"\"\"\n\n    \"\"\"this function must generate a policy that is associated with the recognized principal user identifier.\"\"\"\n    \"\"\"depending on your use case, you might store policies in a DB, or generate them on the fly\"\"\"\n\n    \"\"\"keep in mind, the policy is cached for 5 minutes by default (TTL is configurable in the authorizer)\"\"\"\n    \"\"\"and will apply to subsequent calls to any method/resource in the RestApi\"\"\"\n    \"\"\"made with the same token\"\"\"\n\n    \"\"\"the example policy below denies access to all resources in the RestApi\"\"\"\n    tmp = event['methodArn'].split(':')\n    apiGatewayArnTmp = tmp[5].split('/')\n    awsAccountId = tmp[4]\n\n    policy = AuthPolicy(principalId, awsAccountId)\n    policy.restApiId = apiGatewayArnTmp[0]\n    policy.region = tmp[3]\n    policy.stage = apiGatewayArnTmp[1]\n\n    # Blueprint denies all methods by default\n    # policy.denyAllMethods()\n\n    # Example allows all methods\n    policy.allowAllMethods()\n\n    \"\"\"policy.allowMethod(HttpVerb.GET, \"/pets/*\")\"\"\"\n\n    \"\"\"finally, build the policy and exit the function using return\"\"\"\n    return policy.build()\n\nclass HttpVerb:\n    GET     = \"GET\"\n    POST    = \"POST\"\n    PUT     = \"PUT\"\n    PATCH   = \"PATCH\"\n    HEAD    = \"HEAD\"\n    DELETE  = \"DELETE\"\n    OPTIONS = \"OPTIONS\"\n    ALL     = \"*\"\n\nclass AuthPolicy(object):\n    awsAccountId = \"\"\n    \"\"\"The AWS account id the policy will be generated for. This is used to create the method ARNs.\"\"\"\n    principalId = \"\"\n    \"\"\"The principal used for the policy, this should be a unique identifier for the end user.\"\"\"\n    version = \"2012-10-17\"\n    \"\"\"The policy version used for the evaluation. This should always be '2012-10-17'\"\"\"\n    pathRegex = \"^[/.a-zA-Z0-9-\\*]+$\"\n    \"\"\"The regular expression used to validate resource paths for the policy\"\"\"\n\n    \"\"\"these are the internal lists of allowed and denied methods. These are lists\n    of objects and each object has 2 properties: A resource ARN and a nullable\n    conditions statement.\n    the build method processes these lists and generates the approriate\n    statements for the final policy\"\"\"\n    allowMethods = []\n    denyMethods = []\n\n    restApiId = \"*\"\n    \"\"\"The API Gateway API id. By default this is set to '*'\"\"\"\n    region = \"*\"\n    \"\"\"The region where the API is deployed. By default this is set to '*'\"\"\"\n    stage = \"*\"\n    \"\"\"The name of the stage used in the policy. By default this is set to '*'\"\"\"\n\n    def __init__(self, principal, awsAccountId):\n        self.awsAccountId = awsAccountId\n        self.principalId = principal\n        self.allowMethods = []\n        self.denyMethods = []\n\n    def _addMethod(self, effect, verb, resource, conditions):\n        \"\"\"Adds a method to the internal lists of allowed or denied methods. Each object in\n        the internal list contains a resource ARN and a condition statement. The condition\n        statement can be null.\"\"\"\n        if verb != \"*\" and not hasattr(HttpVerb, verb):\n            raise NameError(\"Invalid HTTP verb \" + verb + \". Allowed verbs in HttpVerb class\")\n        resourcePattern = re.compile(self.pathRegex)\n        if not resourcePattern.match(resource):\n            raise NameError(\"Invalid resource path: \" + resource + \". Path should match \" + self.pathRegex)\n\n        if resource[:1] == \"/\":\n            resource = resource[1:]\n\n        resourceArn = (\"arn:aws:execute-api:\" +\n            self.region + \":\" +\n            self.awsAccountId + \":\" +\n            self.restApiId + \"/\" +\n            self.stage + \"/\" +\n            verb + \"/\" +\n            resource)\n\n        if effect.lower() == \"allow\":\n            self.allowMethods.append({\n                'resourceArn' : resourceArn,\n                'conditions' : conditions\n            })\n        elif effect.lower() == \"deny\":\n            self.denyMethods.append({\n                'resourceArn' : resourceArn,\n                'conditions' : conditions\n            })\n\n    def _getEmptyStatement(self, effect):\n        \"\"\"Returns an empty statement object prepopulated with the correct action and the\n        desired effect.\"\"\"\n        statement = {\n            'Action': 'execute-api:Invoke',\n            'Effect': effect[:1].upper() + effect[1:].lower(),\n            'Resource': []\n        }\n\n        return statement\n\n    def _getStatementForEffect(self, effect, methods):\n        \"\"\"This function loops over an array of objects containing a resourceArn and\n        conditions statement and generates the array of statements for the policy.\"\"\"\n        statements = []\n\n        if len(methods) > 0:\n            statement = self._getEmptyStatement(effect)\n\n            for curMethod in methods:\n                if curMethod['conditions'] is None or len(curMethod['conditions']) == 0:\n                    statement['Resource'].append(curMethod['resourceArn'])\n                else:\n                    conditionalStatement = self._getEmptyStatement(effect)\n                    conditionalStatement['Resource'].append(curMethod['resourceArn'])\n                    conditionalStatement['Condition'] = curMethod['conditions']\n                    statements.append(conditionalStatement)\n\n            statements.append(statement)\n\n        return statements\n\n    def allowAllMethods(self):\n        \"\"\"Adds a '*' allow to the policy to authorize access to all methods of an API\"\"\"\n        self._addMethod(\"Allow\", HttpVerb.ALL, \"*\", [])\n\n    def denyAllMethods(self):\n        \"\"\"Adds a '*' allow to the policy to deny access to all methods of an API\"\"\"\n        self._addMethod(\"Deny\", HttpVerb.ALL, \"*\", [])\n\n    def allowMethod(self, verb, resource):\n        \"\"\"Adds an API Gateway method (Http verb + Resource path) to the list of allowed\n        methods for the policy\"\"\"\n        self._addMethod(\"Allow\", verb, resource, [])\n\n    def denyMethod(self, verb, resource):\n        \"\"\"Adds an API Gateway method (Http verb + Resource path) to the list of denied\n        methods for the policy\"\"\"\n        self._addMethod(\"Deny\", verb, resource, [])\n\n    def allowMethodWithConditions(self, verb, resource, conditions):\n        \"\"\"Adds an API Gateway method (Http verb + Resource path) to the list of allowed\n        methods and includes a condition for the policy statement. More on AWS policy\n        conditions here: http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html#Condition\"\"\"\n        self._addMethod(\"Allow\", verb, resource, conditions)\n\n    def denyMethodWithConditions(self, verb, resource, conditions):\n        \"\"\"Adds an API Gateway method (Http verb + Resource path) to the list of denied\n        methods and includes a condition for the policy statement. More on AWS policy\n        conditions here: http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html#Condition\"\"\"\n        self._addMethod(\"Deny\", verb, resource, conditions)\n\n    def build(self):\n        \"\"\"Generates the policy document based on the internal lists of allowed and denied\n        conditions. This will generate a policy with two main statements for the effect:\n        one statement for Allow and one statement for Deny.\n        Methods that includes conditions will have their own statement in the policy.\"\"\"\n        if ((self.allowMethods is None or len(self.allowMethods) == 0) and\n            (self.denyMethods is None or len(self.denyMethods) == 0)):\n            raise NameError(\"No statements defined for the policy\")\n\n        policy = {\n            'principalId' : self.principalId,\n            'policyDocument' : {\n                'Version' : self.version,\n                'Statement' : []\n            }\n        }\n\n        policy['policyDocument']['Statement'].extend(self._getStatementForEffect(\"Allow\", self.allowMethods))\n        policy['policyDocument']['Statement'].extend(self._getStatementForEffect(\"Deny\", self.denyMethods))\n\n        return policy", "description": "Serverless Python", "file_name": "authmodule.py", "id": "c958c7fd772a58adcc1170cb4498da41", "language": "Python", "project_name": "Zappa", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/Miserlou-Zappa/Miserlou-Zappa-2a31b61/example/authmodule.py", "save_time": "", "source": "", "update_at": "2018-03-17T23:49:18Z", "url": "https://github.com/Miserlou/Zappa", "wiki": true}