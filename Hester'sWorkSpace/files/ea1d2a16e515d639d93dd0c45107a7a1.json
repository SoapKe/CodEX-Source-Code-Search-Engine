{"author": "deepfakes", "code": "import cv2\nimport re\nimport os\n\nfrom pathlib import Path\nfrom tqdm import tqdm\n\nfrom lib.cli import DirectoryProcessor, FullPaths\nfrom lib.utils import BackgroundGenerator, get_folder, get_image_paths, rotate_image\n\nfrom plugins.PluginLoader import PluginLoader\n\nclass ConvertImage(DirectoryProcessor):\n    filename = ''\n    def create_parser(self, subparser, command, description):\n        self.parser = subparser.add_parser(\n            command,\n            help=\"Convert a source image to a new one with the face swapped.\",\n            description=description,\n            epilog=\"Questions and feedback: \\\n            https://github.com/deepfakes/faceswap-playground\"\n        )\n\n    def add_optional_arguments(self, parser):\n        parser.add_argument('-m', '--model-dir',\n                            action=FullPaths,\n                            dest=\"model_dir\",\n                            default=\"models\",\n                            help=\"Model directory. A directory containing the trained model \\\n                            you wish to process. Defaults to 'models'\")\n\n        parser.add_argument('-a', '--input-aligned-dir',\n                            action=FullPaths,\n                            dest=\"input_aligned_dir\",\n                            default=None,\n                            help=\"Input \\\"aligned directory\\\". A directory that should contain the \\\n                            aligned faces extracted from the input files. If you delete faces from \\\n                            this folder, they'll be skipped during conversion. If no aligned dir is \\\n                            specified, all faces will be converted.\")\n\n        parser.add_argument('-t', '--trainer',\n                            type=str,\n                            choices=PluginLoader.get_available_models(), \n                            default=PluginLoader.get_default_model(),\n                            help=\"Select the trainer that was used to create the model.\")\n\n        parser.add_argument('-s', '--swap-model',\n                            action=\"store_true\",\n                            dest=\"swap_model\",\n                            default=False,\n                            help=\"Swap the model. Instead of A -> B, swap B -> A.\")\n\n        parser.add_argument('-c', '--converter',\n                            type=str,\n                            choices=(\"Masked\", \"Adjust\"), \n                            default=\"Masked\",\n                            help=\"Converter to use.\")\n\n        parser.add_argument('-D', '--detector',\n                            type=str,\n                            choices=(\"hog\", \"cnn\"), \n                            default=\"hog\",\n                            help=\"Detector to use. 'cnn' detects much more angles but will be much more resource intensive and may fail on large files.\")\n\n        parser.add_argument('-fr', '--frame-ranges',\n                            nargs=\"+\",\n                            type=str,\n                            help=\"frame ranges to apply transfer to e.g. For frames 10 to 50 and 90 to 100 use --frame-ranges 10-50 90-100. \\\n                            Files must have the frame-number as the last number in the name!\"\n                            )\n\n        parser.add_argument('-d', '--discard-frames',\n                            action=\"store_true\",\n                            dest=\"discard_frames\",\n                            default=False,\n                            help=\"When used with --frame-ranges discards frames that are not processed instead of writing them out unchanged.\"\n                            )\n\n        parser.add_argument('-l', '--ref_threshold',\n                            type=float,\n                            dest=\"ref_threshold\",\n                            default=0.6,\n                            help=\"Threshold for positive face recognition\"\n                            )\n\n        parser.add_argument('-n', '--nfilter',\n                            type=str,\n                            dest=\"nfilter\",\n                            nargs='+',\n                            default=\"nfilter.jpg\",\n                            help=\"Reference image for the persons you do not want to process. Should be a front portrait\"\n                            )\n\n        parser.add_argument('-f', '--filter',\n                            type=str,\n                            dest=\"filter\",\n                            nargs=\"+\",\n                            default=\"filter.jpg\",\n                            help=\"Reference images for the person you want to process. Should be a front portrait\"\n                            )\n\n        parser.add_argument('-b', '--blur-size',\n                            type=int,\n                            default=2,\n                            help=\"Blur size. (Masked converter only)\")\n\n\n        parser.add_argument('-S', '--seamless',\n                            action=\"store_true\",\n                            dest=\"seamless_clone\",\n                            default=False,\n                            help=\"Use cv2's seamless clone. (Masked converter only)\")\n\n        parser.add_argument('-M', '--mask-type',\n                            type=str.lower, \n                            dest=\"mask_type\",\n                            choices=[\"rect\", \"facehull\", \"facehullandrect\"],\n                            default=\"facehullandrect\",\n                            help=\"Mask to use to replace faces. (Masked converter only)\")\n\n        parser.add_argument('-e', '--erosion-kernel-size',\n                            dest=\"erosion_kernel_size\",\n                            type=int,\n                            default=None,\n                            help=\"Erosion kernel size. (Masked converter only). Positive values apply erosion which reduces the edge of the swapped face. Negative values apply dilation which allows the swapped face to cover more space.\")\n\n        parser.add_argument('-mh', '--match-histgoram',\n                            action=\"store_true\",\n                            dest=\"match_histogram\",\n                            default=False,\n                            help=\"Use histogram matching. (Masked converter only)\")\n        \n        parser.add_argument('-sh',\n                            type=str.lower,\n                            dest=\"sharpen_image\",\n                            choices=[\"bsharpen\", \"gsharpen\"],\n                            default=\"none\",\n                            help=\"Use Sharpen Image - bsharpen = Box Blur, gsharpen = Gaussian Blur (Masked converter only)\")\n\n        parser.add_argument('-sm', '--smooth-mask',\n                            action=\"store_true\",\n                            dest=\"smooth_mask\",\n                            default=True,\n                            help=\"Smooth mask (Adjust converter only)\")\n\n        parser.add_argument('-aca', '--avg-color-adjust',\n                            action=\"store_true\",\n                            dest=\"avg_color_adjust\",\n                            default=True,\n                            help=\"Average color adjust. (Adjust converter only)\")\n\n        parser.add_argument('-g', '--gpus',\n                            type=int,\n                            default=1,\n                            help=\"Number of GPUs to use for conversion\")\n\n        return parser\n\n    def process(self):\n        \n        # Note: GAN prediction outputs a mask + an image, while other predicts only an image\n        model_name = self.arguments.trainer\n        conv_name = self.arguments.converter\n        self.input_aligned_dir = None\n\n        model = PluginLoader.get_model(model_name)(get_folder(self.arguments.model_dir), self.arguments.gpus)\n        if not model.load(self.arguments.swap_model):\n            print('Model Not Found! A valid model must be provided to continue!')\n            exit(1)\n\n        input_aligned_dir = Path(self.arguments.input_dir)/Path('aligned')\n        if self.arguments.input_aligned_dir is not None:\n            input_aligned_dir = self.arguments.input_aligned_dir\n        try:\n            self.input_aligned_dir = [Path(path) for path in get_image_paths(input_aligned_dir)]\n            if len(self.input_aligned_dir) == 0:\n                print('Aligned directory is empty, no faces will be converted!')\n            elif len(self.input_aligned_dir) <= len(self.input_dir)/3:\n                print('Aligned directory contains an amount of images much less than the input, are you sure this is the right directory?')\n        except:\n            print('Aligned directory not found. All faces listed in the alignments file will be converted.')\n\n        converter = PluginLoader.get_converter(conv_name)(model.converter(False),\n            trainer=self.arguments.trainer,\n            blur_size=self.arguments.blur_size,\n            seamless_clone=self.arguments.seamless_clone,\n            sharpen_image=self.arguments.sharpen_image,\n            mask_type=self.arguments.mask_type,\n            erosion_kernel_size=self.arguments.erosion_kernel_size,\n            match_histogram=self.arguments.match_histogram,\n            smooth_mask=self.arguments.smooth_mask,\n            avg_color_adjust=self.arguments.avg_color_adjust\n        )\n\n        batch = BackgroundGenerator(self.prepare_images(), 1)\n\n        \n        self.frame_ranges = None\n\n        \n        minmax = {\n            \"min\": 0, \n            \"max\": float(\"inf\")\n        }\n\n        if self.arguments.frame_ranges:\n            self.frame_ranges = [tuple(map(lambda q: minmax[q] if q in minmax.keys() else int(q), v.split(\"-\"))) for v in self.arguments.frame_ranges]\n\n        # last number regex. I know regex is hacky, but its reliablyhacky(tm).\n        self.imageidxre = re.compile(r'(\\d+)(?!.*\\d)')\n\n        for item in batch.iterator():\n            self.convert(converter, item)\n\n    def check_skipframe(self, filename):\n        try:\n            idx = int(self.imageidxre.findall(filename)[0])\n            return not any(map(lambda b: b[0]<=idx<=b[1], self.frame_ranges))\n        except:\n            return False\n\n    def check_skipface(self, filename, face_idx):\n        aligned_face_name = '{}_{}{}'.format(Path(filename).stem, face_idx, Path(filename).suffix)\n        aligned_face_file = Path(self.arguments.input_aligned_dir) / Path(aligned_face_name)\n        \n        bk_compat_aligned_face_name = '{}{}{}'.format(Path(filename).stem, face_idx, Path(filename).suffix)\n        bk_compat_aligned_face_file = Path(self.arguments.input_aligned_dir) / Path(bk_compat_aligned_face_name)\n        return aligned_face_file not in self.input_aligned_dir and bk_compat_aligned_face_file not in self.input_aligned_dir\n\n    def convert(self, converter, item):\n        try:\n            (filename, image, faces) = item\n\n            skip = self.check_skipframe(filename)\n            if self.arguments.discard_frames and skip:\n                return\n\n            if not skip: \n                for idx, face in faces:\n                    if self.input_aligned_dir is not None and self.check_skipface(filename, idx):\n                        print ('face {} for frame {} was deleted, skipping'.format(idx, os.path.basename(filename)))\n                        continue\n                    \n                    if face.r != 0:\n                        image = rotate_image(image, face.r)\n                        image = converter.patch_image(image, face, 64 if \"128\" not in self.arguments.trainer else 128)\n                        \n                        image = rotate_image(image, face.r * -1)\n                    else:\n                        image = converter.patch_image(image, face, 64 if \"128\" not in self.arguments.trainer else 128)\n                        \n\n            output_file = get_folder(self.output_dir) / Path(filename).name\n            cv2.imwrite(str(output_file), image)\n        except Exception as e:\n            print('Failed to convert image: {}. Reason: {}'.format(filename, e))\n\n    def prepare_images(self):\n        self.read_alignments()\n        is_have_alignments = self.have_alignments()\n        for filename in tqdm(self.read_directory()):\n            image = cv2.imread(filename)\n\n            if is_have_alignments:\n                if self.have_face(filename):\n                    faces = self.get_faces_alignments(filename, image)\n                else:\n                    print ('no alignment found for {}, skipping'.format(os.path.basename(filename)))\n                    continue\n            else:\n                faces = self.get_faces(image)\n            yield filename, image, faces\n", "comments": "  case sensitive used load plug     case sensitive used load plugin     case sensitive used load plugin    lowercase  string later     original   lowmem models go adjust masked converter    note  gan prediction outputs mask   image  predicts image    frame ranges stuff       split frame ranges parse  min   max  values    never frames less 0    last number regex  i know regex hacky  reliablyhacky(tm)     todo  remove temporary fix backwards compatibility filenames    process frame normal    check image rotations rotate mapping face    todo  this switch 64 128 hack  we separate cli option size    todo  this switch 64 128 hack  we separate cli option size ", "content": "import cv2\nimport re\nimport os\n\nfrom pathlib import Path\nfrom tqdm import tqdm\n\nfrom lib.cli import DirectoryProcessor, FullPaths\nfrom lib.utils import BackgroundGenerator, get_folder, get_image_paths, rotate_image\n\nfrom plugins.PluginLoader import PluginLoader\n\nclass ConvertImage(DirectoryProcessor):\n    filename = ''\n    def create_parser(self, subparser, command, description):\n        self.parser = subparser.add_parser(\n            command,\n            help=\"Convert a source image to a new one with the face swapped.\",\n            description=description,\n            epilog=\"Questions and feedback: \\\n            https://github.com/deepfakes/faceswap-playground\"\n        )\n\n    def add_optional_arguments(self, parser):\n        parser.add_argument('-m', '--model-dir',\n                            action=FullPaths,\n                            dest=\"model_dir\",\n                            default=\"models\",\n                            help=\"Model directory. A directory containing the trained model \\\n                            you wish to process. Defaults to 'models'\")\n\n        parser.add_argument('-a', '--input-aligned-dir',\n                            action=FullPaths,\n                            dest=\"input_aligned_dir\",\n                            default=None,\n                            help=\"Input \\\"aligned directory\\\". A directory that should contain the \\\n                            aligned faces extracted from the input files. If you delete faces from \\\n                            this folder, they'll be skipped during conversion. If no aligned dir is \\\n                            specified, all faces will be converted.\")\n\n        parser.add_argument('-t', '--trainer',\n                            type=str,\n                            choices=PluginLoader.get_available_models(), # case sensitive because this is used to load a plug-in.\n                            default=PluginLoader.get_default_model(),\n                            help=\"Select the trainer that was used to create the model.\")\n\n        parser.add_argument('-s', '--swap-model',\n                            action=\"store_true\",\n                            dest=\"swap_model\",\n                            default=False,\n                            help=\"Swap the model. Instead of A -> B, swap B -> A.\")\n\n        parser.add_argument('-c', '--converter',\n                            type=str,\n                            choices=(\"Masked\", \"Adjust\"), # case sensitive because this is used to load a plugin.\n                            default=\"Masked\",\n                            help=\"Converter to use.\")\n\n        parser.add_argument('-D', '--detector',\n                            type=str,\n                            choices=(\"hog\", \"cnn\"), # case sensitive because this is used to load a plugin.\n                            default=\"hog\",\n                            help=\"Detector to use. 'cnn' detects much more angles but will be much more resource intensive and may fail on large files.\")\n\n        parser.add_argument('-fr', '--frame-ranges',\n                            nargs=\"+\",\n                            type=str,\n                            help=\"frame ranges to apply transfer to e.g. For frames 10 to 50 and 90 to 100 use --frame-ranges 10-50 90-100. \\\n                            Files must have the frame-number as the last number in the name!\"\n                            )\n\n        parser.add_argument('-d', '--discard-frames',\n                            action=\"store_true\",\n                            dest=\"discard_frames\",\n                            default=False,\n                            help=\"When used with --frame-ranges discards frames that are not processed instead of writing them out unchanged.\"\n                            )\n\n        parser.add_argument('-l', '--ref_threshold',\n                            type=float,\n                            dest=\"ref_threshold\",\n                            default=0.6,\n                            help=\"Threshold for positive face recognition\"\n                            )\n\n        parser.add_argument('-n', '--nfilter',\n                            type=str,\n                            dest=\"nfilter\",\n                            nargs='+',\n                            default=\"nfilter.jpg\",\n                            help=\"Reference image for the persons you do not want to process. Should be a front portrait\"\n                            )\n\n        parser.add_argument('-f', '--filter',\n                            type=str,\n                            dest=\"filter\",\n                            nargs=\"+\",\n                            default=\"filter.jpg\",\n                            help=\"Reference images for the person you want to process. Should be a front portrait\"\n                            )\n\n        parser.add_argument('-b', '--blur-size',\n                            type=int,\n                            default=2,\n                            help=\"Blur size. (Masked converter only)\")\n\n\n        parser.add_argument('-S', '--seamless',\n                            action=\"store_true\",\n                            dest=\"seamless_clone\",\n                            default=False,\n                            help=\"Use cv2's seamless clone. (Masked converter only)\")\n\n        parser.add_argument('-M', '--mask-type',\n                            type=str.lower, #lowercase this, because its just a string later on.\n                            dest=\"mask_type\",\n                            choices=[\"rect\", \"facehull\", \"facehullandrect\"],\n                            default=\"facehullandrect\",\n                            help=\"Mask to use to replace faces. (Masked converter only)\")\n\n        parser.add_argument('-e', '--erosion-kernel-size',\n                            dest=\"erosion_kernel_size\",\n                            type=int,\n                            default=None,\n                            help=\"Erosion kernel size. (Masked converter only). Positive values apply erosion which reduces the edge of the swapped face. Negative values apply dilation which allows the swapped face to cover more space.\")\n\n        parser.add_argument('-mh', '--match-histgoram',\n                            action=\"store_true\",\n                            dest=\"match_histogram\",\n                            default=False,\n                            help=\"Use histogram matching. (Masked converter only)\")\n        \n        parser.add_argument('-sh',\n                            type=str.lower,\n                            dest=\"sharpen_image\",\n                            choices=[\"bsharpen\", \"gsharpen\"],\n                            default=\"none\",\n                            help=\"Use Sharpen Image - bsharpen = Box Blur, gsharpen = Gaussian Blur (Masked converter only)\")\n\n        parser.add_argument('-sm', '--smooth-mask',\n                            action=\"store_true\",\n                            dest=\"smooth_mask\",\n                            default=True,\n                            help=\"Smooth mask (Adjust converter only)\")\n\n        parser.add_argument('-aca', '--avg-color-adjust',\n                            action=\"store_true\",\n                            dest=\"avg_color_adjust\",\n                            default=True,\n                            help=\"Average color adjust. (Adjust converter only)\")\n\n        parser.add_argument('-g', '--gpus',\n                            type=int,\n                            default=1,\n                            help=\"Number of GPUs to use for conversion\")\n\n        return parser\n\n    def process(self):\n        # Original & LowMem models go with Adjust or Masked converter\n        # Note: GAN prediction outputs a mask + an image, while other predicts only an image\n        model_name = self.arguments.trainer\n        conv_name = self.arguments.converter\n        self.input_aligned_dir = None\n\n        model = PluginLoader.get_model(model_name)(get_folder(self.arguments.model_dir), self.arguments.gpus)\n        if not model.load(self.arguments.swap_model):\n            print('Model Not Found! A valid model must be provided to continue!')\n            exit(1)\n\n        input_aligned_dir = Path(self.arguments.input_dir)/Path('aligned')\n        if self.arguments.input_aligned_dir is not None:\n            input_aligned_dir = self.arguments.input_aligned_dir\n        try:\n            self.input_aligned_dir = [Path(path) for path in get_image_paths(input_aligned_dir)]\n            if len(self.input_aligned_dir) == 0:\n                print('Aligned directory is empty, no faces will be converted!')\n            elif len(self.input_aligned_dir) <= len(self.input_dir)/3:\n                print('Aligned directory contains an amount of images much less than the input, are you sure this is the right directory?')\n        except:\n            print('Aligned directory not found. All faces listed in the alignments file will be converted.')\n\n        converter = PluginLoader.get_converter(conv_name)(model.converter(False),\n            trainer=self.arguments.trainer,\n            blur_size=self.arguments.blur_size,\n            seamless_clone=self.arguments.seamless_clone,\n            sharpen_image=self.arguments.sharpen_image,\n            mask_type=self.arguments.mask_type,\n            erosion_kernel_size=self.arguments.erosion_kernel_size,\n            match_histogram=self.arguments.match_histogram,\n            smooth_mask=self.arguments.smooth_mask,\n            avg_color_adjust=self.arguments.avg_color_adjust\n        )\n\n        batch = BackgroundGenerator(self.prepare_images(), 1)\n\n        # frame ranges stuff...\n        self.frame_ranges = None\n\n        # split out the frame ranges and parse out \"min\" and \"max\" values\n        minmax = {\n            \"min\": 0, # never any frames less than 0\n            \"max\": float(\"inf\")\n        }\n\n        if self.arguments.frame_ranges:\n            self.frame_ranges = [tuple(map(lambda q: minmax[q] if q in minmax.keys() else int(q), v.split(\"-\"))) for v in self.arguments.frame_ranges]\n\n        # last number regex. I know regex is hacky, but its reliablyhacky(tm).\n        self.imageidxre = re.compile(r'(\\d+)(?!.*\\d)')\n\n        for item in batch.iterator():\n            self.convert(converter, item)\n\n    def check_skipframe(self, filename):\n        try:\n            idx = int(self.imageidxre.findall(filename)[0])\n            return not any(map(lambda b: b[0]<=idx<=b[1], self.frame_ranges))\n        except:\n            return False\n\n    def check_skipface(self, filename, face_idx):\n        aligned_face_name = '{}_{}{}'.format(Path(filename).stem, face_idx, Path(filename).suffix)\n        aligned_face_file = Path(self.arguments.input_aligned_dir) / Path(aligned_face_name)\n        # TODO: Remove this temporary fix for backwards compatibility of filenames\n        bk_compat_aligned_face_name = '{}{}{}'.format(Path(filename).stem, face_idx, Path(filename).suffix)\n        bk_compat_aligned_face_file = Path(self.arguments.input_aligned_dir) / Path(bk_compat_aligned_face_name)\n        return aligned_face_file not in self.input_aligned_dir and bk_compat_aligned_face_file not in self.input_aligned_dir\n\n    def convert(self, converter, item):\n        try:\n            (filename, image, faces) = item\n\n            skip = self.check_skipframe(filename)\n            if self.arguments.discard_frames and skip:\n                return\n\n            if not skip: # process frame as normal\n                for idx, face in faces:\n                    if self.input_aligned_dir is not None and self.check_skipface(filename, idx):\n                        print ('face {} for frame {} was deleted, skipping'.format(idx, os.path.basename(filename)))\n                        continue\n                    # Check for image rotations and rotate before mapping face\n                    if face.r != 0:\n                        image = rotate_image(image, face.r)\n                        image = converter.patch_image(image, face, 64 if \"128\" not in self.arguments.trainer else 128)\n                        # TODO: This switch between 64 and 128 is a hack for now. We should have a separate cli option for size\n                        image = rotate_image(image, face.r * -1)\n                    else:\n                        image = converter.patch_image(image, face, 64 if \"128\" not in self.arguments.trainer else 128)\n                        # TODO: This switch between 64 and 128 is a hack for now. We should have a separate cli option for size\n\n            output_file = get_folder(self.output_dir) / Path(filename).name\n            cv2.imwrite(str(output_file), image)\n        except Exception as e:\n            print('Failed to convert image: {}. Reason: {}'.format(filename, e))\n\n    def prepare_images(self):\n        self.read_alignments()\n        is_have_alignments = self.have_alignments()\n        for filename in tqdm(self.read_directory()):\n            image = cv2.imread(filename)\n\n            if is_have_alignments:\n                if self.have_face(filename):\n                    faces = self.get_faces_alignments(filename, image)\n                else:\n                    print ('no alignment found for {}, skipping'.format(os.path.basename(filename)))\n                    continue\n            else:\n                faces = self.get_faces(image)\n            yield filename, image, faces\n", "description": "Non official project based on original /r/Deepfakes thread. Many thanks to him!", "file_name": "convert.py", "id": "ea1d2a16e515d639d93dd0c45107a7a1", "language": "Python", "project_name": "faceswap", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/deepfakes-faceswap/deepfakes-faceswap-6ff64ef/scripts/convert.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:27:43Z", "url": "https://github.com/deepfakes/faceswap", "wiki": true}