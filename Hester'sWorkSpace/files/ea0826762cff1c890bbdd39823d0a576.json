{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_HTTPError,\n    compat_urllib_parse_unquote,\n)\nfrom ..utils import (\n    determine_ext,\n    ExtractorError,\n    int_or_none,\n    parse_iso8601,\n    sanitized_Request,\n    HEADRequest,\n    url_basename,\n)\n\n\nclass ViewsterIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?viewster\\.com/(?:serie|movie)/(?P<id>\\d+-\\d+-\\d+)'\n    _TESTS = [{\n        \n        'url': 'http://www.viewster.com/movie/1140-11855-000/the-listening-project/',\n        'md5': 'e642d1b27fcf3a4ffa79f194f5adde36',\n        'info_dict': {\n            'id': '1140-11855-000',\n            'ext': 'mp4',\n            'title': 'The listening Project',\n            'description': 'md5:bac720244afd1a8ea279864e67baa071',\n            'timestamp': 1214870400,\n            'upload_date': '20080701',\n            'duration': 4680,\n        },\n    }, {\n        \n        'url': 'http://www.viewster.com/serie/1284-19427-001/the-world-and-a-wall/',\n        'md5': '9243079a8531809efe1b089db102c069',\n        'info_dict': {\n            'id': '1284-19427-001',\n            'ext': 'mp4',\n            'title': 'The World and a Wall',\n            'description': 'md5:24814cf74d3453fdf5bfef9716d073e3',\n            'timestamp': 1428192000,\n            'upload_date': '20150405',\n            'duration': 1500,\n        },\n    }, {\n        \n        'url': 'http://www.viewster.com/serie/1303-19426-000/',\n        'info_dict': {\n            'id': '1303-19426-000',\n            'title': 'Is It Wrong to Try to Pick up Girls in a Dungeon?',\n            'description': 'md5:eeda9bef25b0d524b3a29a97804c2f11',\n        },\n        'playlist_count': 13,\n    }, {\n        \n        'url': 'http://www.viewster.com/serie/1284-19427-000/baby-steps-season-2/',\n        'info_dict': {\n            'id': '1284-19427-000',\n            'title': 'Baby Steps\u2014Season 2',\n            'description': 'md5:e7097a8fc97151e25f085c9eb7a1cdb1',\n        },\n        'playlist_mincount': 16,\n    }, {\n        \n        'url': 'https://www.viewster.com/serie/1280-18794-002/',\n        'only_matching': True,\n    }, {\n        \n        'url': 'https://www.viewster.com/serie/1280-18794-002/what-is-extraterritoriality-lawo/',\n        'only_matching': True,\n    }]\n\n    _ACCEPT_HEADER = 'application/json, text/javascript, */*; q=0.01'\n\n    def _download_json(self, url, video_id, note='Downloading JSON metadata', fatal=True, query={}):\n        request = sanitized_Request(url)\n        request.add_header('Accept', self._ACCEPT_HEADER)\n        request.add_header('Auth-token', self._AUTH_TOKEN)\n        return super(ViewsterIE, self)._download_json(request, video_id, note, fatal=fatal, query=query)\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        \n        self._request_webpage(\n            HEADRequest('http://www.viewster.com/'),\n            video_id, headers=self.geo_verification_headers())\n        cookies = self._get_cookies('http://www.viewster.com/')\n        self._AUTH_TOKEN = compat_urllib_parse_unquote(cookies['api_token'].value)\n\n        info = self._download_json(\n            'https://public-api.viewster.com/search/%s' % video_id,\n            video_id, 'Downloading entry JSON')\n\n        entry_id = info.get('Id') or info['id']\n\n        \n        if info.get('Type') in ('Serie', None):\n            try:\n                episodes = self._download_json(\n                    'https://public-api.viewster.com/series/%s/episodes' % entry_id,\n                    video_id, 'Downloading series JSON')\n            except ExtractorError as e:\n                if isinstance(e.cause, compat_HTTPError) and e.cause.code == 404:\n                    self.raise_geo_restricted()\n                else:\n                    raise\n            entries = [\n                self.url_result(\n                    'http://www.viewster.com/movie/%s' % episode['OriginId'], 'Viewster')\n                for episode in episodes]\n            title = (info.get('Title') or info['Synopsis']['Title']).strip()\n            description = info.get('Synopsis', {}).get('Detailed')\n            return self.playlist_result(entries, video_id, title, description)\n\n        formats = []\n        for language_set in info.get('LanguageSets', []):\n            manifest_url = None\n            m3u8_formats = []\n            audio = language_set.get('Audio') or ''\n            subtitle = language_set.get('Subtitle') or ''\n            base_format_id = audio\n            if subtitle:\n                base_format_id += '-%s' % subtitle\n\n            def concat(suffix, sep='-'):\n                return (base_format_id + '%s%s' % (sep, suffix)) if base_format_id else suffix\n\n            for media_type in ('application/f4m+xml', 'application/x-mpegURL', 'video/mp4'):\n                media = self._download_json(\n                    'https://public-api.viewster.com/movies/%s/video' % entry_id,\n                    video_id, 'Downloading %s JSON' % concat(media_type, ' '), fatal=False, query={\n                        'mediaType': media_type,\n                        'language': audio,\n                        'subtitle': subtitle,\n                    })\n                if not media:\n                    continue\n                video_url = media.get('Uri')\n                if not video_url:\n                    continue\n                ext = determine_ext(video_url)\n                if ext == 'f4m':\n                    manifest_url = video_url\n                    video_url += '&' if '?' in video_url else '?'\n                    video_url += 'hdcore=3.2.0&plugin=flowplayer-3.2.0.1'\n                    formats.extend(self._extract_f4m_formats(\n                        video_url, video_id, f4m_id=concat('hds')))\n                elif ext == 'm3u8':\n                    manifest_url = video_url\n                    m3u8_formats = self._extract_m3u8_formats(\n                        video_url, video_id, 'mp4', m3u8_id=concat('hls'),\n                        fatal=False)  \n                    if m3u8_formats:\n                        formats.extend(m3u8_formats)\n                else:\n                    qualities_basename = self._search_regex(\n                        r'/([^/]+)\\.csmil/',\n                        manifest_url, 'qualities basename', default=None)\n                    if not qualities_basename:\n                        continue\n                    QUALITIES_RE = r'((,\\d+k)+,?)'\n                    qualities = self._search_regex(\n                        QUALITIES_RE, qualities_basename,\n                        'qualities', default=None)\n                    if not qualities:\n                        continue\n                    qualities = list(map(lambda q: int(q[:-1]), qualities.strip(',').split(',')))\n                    qualities.sort()\n                    http_template = re.sub(QUALITIES_RE, r'%dk', qualities_basename)\n                    http_url_basename = url_basename(video_url)\n                    if m3u8_formats:\n                        self._sort_formats(m3u8_formats)\n                        m3u8_formats = list(filter(\n                            lambda f: f.get('vcodec') != 'none', m3u8_formats))\n                    if len(qualities) == len(m3u8_formats):\n                        for q, m3u8_format in zip(qualities, m3u8_formats):\n                            f = m3u8_format.copy()\n                            f.update({\n                                'url': video_url.replace(http_url_basename, http_template % q),\n                                'format_id': f['format_id'].replace('hls', 'http'),\n                                'protocol': 'http',\n                            })\n                            formats.append(f)\n                    else:\n                        for q in qualities:\n                            formats.append({\n                                'url': video_url.replace(http_url_basename, http_template % q),\n                                'ext': 'mp4',\n                                'format_id': 'http-%d' % q,\n                                'tbr': q,\n                            })\n\n        if not formats and not info.get('VODSettings'):\n            self.raise_geo_restricted()\n\n        self._sort_formats(formats)\n\n        synopsis = info.get('Synopsis') or {}\n        \n        title = (info.get('Title') or synopsis['Title']).strip()\n        description = synopsis.get('Detailed') or (info.get('Synopsis') or {}).get('Short')\n        duration = int_or_none(info.get('Duration'))\n        timestamp = parse_iso8601(info.get('ReleaseDate'))\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'timestamp': timestamp,\n            'duration': duration,\n            'formats': formats,\n        }\n", "comments": "# coding: utf-8\n# movie, Type=Movie\n# series episode, Type=Episode\n# serie, Type=Serie\n# unfinished serie, no Type\n# geo restricted series\n# geo restricted video\n# Get 'api_token' cookie\n# unfinished serie has no Type\n# m3u8 sometimes fail\n# Prefer title outside synopsis since it's less messy\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_HTTPError,\n    compat_urllib_parse_unquote,\n)\nfrom ..utils import (\n    determine_ext,\n    ExtractorError,\n    int_or_none,\n    parse_iso8601,\n    sanitized_Request,\n    HEADRequest,\n    url_basename,\n)\n\n\nclass ViewsterIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?viewster\\.com/(?:serie|movie)/(?P<id>\\d+-\\d+-\\d+)'\n    _TESTS = [{\n        # movie, Type=Movie\n        'url': 'http://www.viewster.com/movie/1140-11855-000/the-listening-project/',\n        'md5': 'e642d1b27fcf3a4ffa79f194f5adde36',\n        'info_dict': {\n            'id': '1140-11855-000',\n            'ext': 'mp4',\n            'title': 'The listening Project',\n            'description': 'md5:bac720244afd1a8ea279864e67baa071',\n            'timestamp': 1214870400,\n            'upload_date': '20080701',\n            'duration': 4680,\n        },\n    }, {\n        # series episode, Type=Episode\n        'url': 'http://www.viewster.com/serie/1284-19427-001/the-world-and-a-wall/',\n        'md5': '9243079a8531809efe1b089db102c069',\n        'info_dict': {\n            'id': '1284-19427-001',\n            'ext': 'mp4',\n            'title': 'The World and a Wall',\n            'description': 'md5:24814cf74d3453fdf5bfef9716d073e3',\n            'timestamp': 1428192000,\n            'upload_date': '20150405',\n            'duration': 1500,\n        },\n    }, {\n        # serie, Type=Serie\n        'url': 'http://www.viewster.com/serie/1303-19426-000/',\n        'info_dict': {\n            'id': '1303-19426-000',\n            'title': 'Is It Wrong to Try to Pick up Girls in a Dungeon?',\n            'description': 'md5:eeda9bef25b0d524b3a29a97804c2f11',\n        },\n        'playlist_count': 13,\n    }, {\n        # unfinished serie, no Type\n        'url': 'http://www.viewster.com/serie/1284-19427-000/baby-steps-season-2/',\n        'info_dict': {\n            'id': '1284-19427-000',\n            'title': 'Baby Steps\u2014Season 2',\n            'description': 'md5:e7097a8fc97151e25f085c9eb7a1cdb1',\n        },\n        'playlist_mincount': 16,\n    }, {\n        # geo restricted series\n        'url': 'https://www.viewster.com/serie/1280-18794-002/',\n        'only_matching': True,\n    }, {\n        # geo restricted video\n        'url': 'https://www.viewster.com/serie/1280-18794-002/what-is-extraterritoriality-lawo/',\n        'only_matching': True,\n    }]\n\n    _ACCEPT_HEADER = 'application/json, text/javascript, */*; q=0.01'\n\n    def _download_json(self, url, video_id, note='Downloading JSON metadata', fatal=True, query={}):\n        request = sanitized_Request(url)\n        request.add_header('Accept', self._ACCEPT_HEADER)\n        request.add_header('Auth-token', self._AUTH_TOKEN)\n        return super(ViewsterIE, self)._download_json(request, video_id, note, fatal=fatal, query=query)\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        # Get 'api_token' cookie\n        self._request_webpage(\n            HEADRequest('http://www.viewster.com/'),\n            video_id, headers=self.geo_verification_headers())\n        cookies = self._get_cookies('http://www.viewster.com/')\n        self._AUTH_TOKEN = compat_urllib_parse_unquote(cookies['api_token'].value)\n\n        info = self._download_json(\n            'https://public-api.viewster.com/search/%s' % video_id,\n            video_id, 'Downloading entry JSON')\n\n        entry_id = info.get('Id') or info['id']\n\n        # unfinished serie has no Type\n        if info.get('Type') in ('Serie', None):\n            try:\n                episodes = self._download_json(\n                    'https://public-api.viewster.com/series/%s/episodes' % entry_id,\n                    video_id, 'Downloading series JSON')\n            except ExtractorError as e:\n                if isinstance(e.cause, compat_HTTPError) and e.cause.code == 404:\n                    self.raise_geo_restricted()\n                else:\n                    raise\n            entries = [\n                self.url_result(\n                    'http://www.viewster.com/movie/%s' % episode['OriginId'], 'Viewster')\n                for episode in episodes]\n            title = (info.get('Title') or info['Synopsis']['Title']).strip()\n            description = info.get('Synopsis', {}).get('Detailed')\n            return self.playlist_result(entries, video_id, title, description)\n\n        formats = []\n        for language_set in info.get('LanguageSets', []):\n            manifest_url = None\n            m3u8_formats = []\n            audio = language_set.get('Audio') or ''\n            subtitle = language_set.get('Subtitle') or ''\n            base_format_id = audio\n            if subtitle:\n                base_format_id += '-%s' % subtitle\n\n            def concat(suffix, sep='-'):\n                return (base_format_id + '%s%s' % (sep, suffix)) if base_format_id else suffix\n\n            for media_type in ('application/f4m+xml', 'application/x-mpegURL', 'video/mp4'):\n                media = self._download_json(\n                    'https://public-api.viewster.com/movies/%s/video' % entry_id,\n                    video_id, 'Downloading %s JSON' % concat(media_type, ' '), fatal=False, query={\n                        'mediaType': media_type,\n                        'language': audio,\n                        'subtitle': subtitle,\n                    })\n                if not media:\n                    continue\n                video_url = media.get('Uri')\n                if not video_url:\n                    continue\n                ext = determine_ext(video_url)\n                if ext == 'f4m':\n                    manifest_url = video_url\n                    video_url += '&' if '?' in video_url else '?'\n                    video_url += 'hdcore=3.2.0&plugin=flowplayer-3.2.0.1'\n                    formats.extend(self._extract_f4m_formats(\n                        video_url, video_id, f4m_id=concat('hds')))\n                elif ext == 'm3u8':\n                    manifest_url = video_url\n                    m3u8_formats = self._extract_m3u8_formats(\n                        video_url, video_id, 'mp4', m3u8_id=concat('hls'),\n                        fatal=False)  # m3u8 sometimes fail\n                    if m3u8_formats:\n                        formats.extend(m3u8_formats)\n                else:\n                    qualities_basename = self._search_regex(\n                        r'/([^/]+)\\.csmil/',\n                        manifest_url, 'qualities basename', default=None)\n                    if not qualities_basename:\n                        continue\n                    QUALITIES_RE = r'((,\\d+k)+,?)'\n                    qualities = self._search_regex(\n                        QUALITIES_RE, qualities_basename,\n                        'qualities', default=None)\n                    if not qualities:\n                        continue\n                    qualities = list(map(lambda q: int(q[:-1]), qualities.strip(',').split(',')))\n                    qualities.sort()\n                    http_template = re.sub(QUALITIES_RE, r'%dk', qualities_basename)\n                    http_url_basename = url_basename(video_url)\n                    if m3u8_formats:\n                        self._sort_formats(m3u8_formats)\n                        m3u8_formats = list(filter(\n                            lambda f: f.get('vcodec') != 'none', m3u8_formats))\n                    if len(qualities) == len(m3u8_formats):\n                        for q, m3u8_format in zip(qualities, m3u8_formats):\n                            f = m3u8_format.copy()\n                            f.update({\n                                'url': video_url.replace(http_url_basename, http_template % q),\n                                'format_id': f['format_id'].replace('hls', 'http'),\n                                'protocol': 'http',\n                            })\n                            formats.append(f)\n                    else:\n                        for q in qualities:\n                            formats.append({\n                                'url': video_url.replace(http_url_basename, http_template % q),\n                                'ext': 'mp4',\n                                'format_id': 'http-%d' % q,\n                                'tbr': q,\n                            })\n\n        if not formats and not info.get('VODSettings'):\n            self.raise_geo_restricted()\n\n        self._sort_formats(formats)\n\n        synopsis = info.get('Synopsis') or {}\n        # Prefer title outside synopsis since it's less messy\n        title = (info.get('Title') or synopsis['Title']).strip()\n        description = synopsis.get('Detailed') or (info.get('Synopsis') or {}).get('Short')\n        duration = int_or_none(info.get('Duration'))\n        timestamp = parse_iso8601(info.get('ReleaseDate'))\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'timestamp': timestamp,\n            'duration': duration,\n            'formats': formats,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "viewster.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/viewster.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}