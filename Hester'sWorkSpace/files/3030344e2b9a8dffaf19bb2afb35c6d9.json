{"author": "ansible", "code": "\n -*- coding: utf-8 -*-\n\n Copyright (c) 2014, Chris Schmidt <chris.schmidt () contrastsecurity.com>\n\n Built using https://github.com/hamnis/useful-scripts/blob/master/python/download-maven-artifact\n as a reference and starting point.\n\n GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = '''\n---\nmodule: maven_artifact\nshort_description: Downloads an Artifact from a Maven Repository\nversion_added: \"2.0\"\ndescription:\n    - Downloads an artifact from a maven repository given the maven coordinates provided to the module.\n    - Can retrieve snapshots or release versions of the artifact and will resolve the latest available\n      version if one is not available.\nauthor: \"Chris Schmidt (@chrisisbeef)\"\nrequirements:\n    - lxml\n    - boto if using a S3 repository (s3://...)\noptions:\n    group_id:\n        description:\n            - The Maven groupId coordinate\n        required: true\n    artifact_id:\n        description:\n            - The maven artifactId coordinate\n        required: true\n    version:\n        description:\n            - The maven version coordinate\n        default: latest\n    classifier:\n        description:\n            - The maven classifier coordinate\n    extension:\n        description:\n            - The maven type/extension coordinate\n        default: jar\n    repository_url:\n        description:\n            - The URL of the Maven Repository to download from.\n            - Use s3://... if the repository is hosted on Amazon S3, added in version 2.2.\n        default: http://repo1.maven.org/maven2\n    username:\n        description:\n            - The username to authenticate as to the Maven Repository. Use AWS secret key of the repository is hosted on S3\n        aliases: [ \"aws_secret_key\" ]\n    password:\n        description:\n            - The password to authenticate with to the Maven Repository. Use AWS secret access key of the repository is hosted on S3\n        aliases: [ \"aws_secret_access_key\" ]\n    dest:\n        description:\n            - The path where the artifact should be written to\n            - If file mode or ownerships are specified and destination path already exists, they affect the downloaded file\n        required: true\n    state:\n        description:\n            - The desired state of the artifact\n        default: present\n        choices: [present,absent]\n    timeout:\n        description:\n            - Specifies a timeout in seconds for the connection attempt\n        default: 10\n        version_added: \"2.3\"\n    validate_certs:\n        description:\n            - If C(no), SSL certificates will not be validated. This should only be set to C(no) when no other option exists.\n        type: bool\n        default: 'yes'\n        version_added: \"1.9.3\"\n    keep_name:\n        description:\n            - If C(yes), the downloaded artifact's name is preserved, i.e the version number remains part of it.\n            - This option only has effect when C(dest) is a directory and C(version) is set to C(latest).\n        type: bool\n        default: 'no'\n        version_added: \"2.4\"\n    verify_checksum:\n        description:\n            - If C(never), the md5 checksum will never be downloaded and verified.\n            - If C(download), the md5 checksum will be downloaded and verified only after artifact download. This is the default.\n            - If C(change), the md5 checksum will be downloaded and verified if the destination already exist,\n              to verify if they are identical. This was the behaviour before 2.6. Since it downloads the md5 before (maybe)\n              downloading the artifact, and since some repository software, when acting as a proxy/cache, return a 404 error\n              if the artifact has not been cached yet, it may fail unexpectedly.\n              If you still need it, you should consider using C(always) instead - if you deal with a checksum, it is better to\n              use it to verify integrity after download.\n            - C(always) combines C(download) and C(change).\n        required: false\n        default: 'download'\n        choices: ['never', 'download', 'change', 'always']\n        version_added: \"2.6\"\nextends_documentation_fragment:\n    - files\n'''\n\nEXAMPLES = '''\n Download the latest version of the JUnit framework artifact from Maven Central\n- maven_artifact:\n    group_id: junit\n    artifact_id: junit\n    dest: /tmp/junit-latest.jar\n\n Download JUnit 4.11 from Maven Central\n- maven_artifact:\n    group_id: junit\n    artifact_id: junit\n    version: 4.11\n    dest: /tmp/junit-4.11.jar\n\n Download an artifact from a private repository requiring authentication\n- maven_artifact:\n    group_id: com.company\n    artifact_id: library-name\n    repository_url: 'https://repo.company.com/maven'\n    username: user\n    password: pass\n    dest: /tmp/library-name-latest.jar\n\n Download a WAR File to the Tomcat webapps directory to be deployed\n- maven_artifact:\n    group_id: com.company\n    artifact_id: web-app\n    extension: war\n    repository_url: 'https://repo.company.com/maven'\n    dest: /var/lib/tomcat7/webapps/web-app.war\n\n Keep a downloaded artifact's name, i.e. retain the version\n- maven_artifact:\n    version: latest\n    artifact_id: spring-core\n    group_id: org.springframework\n    dest: /tmp/\n    keep_name: yes\n'''\n\nimport hashlib\nimport os\nimport posixpath\nimport sys\n\ntry:\n    from lxml import etree\n    HAS_LXML_ETREE = True\nexcept ImportError:\n    HAS_LXML_ETREE = False\n\ntry:\n    import boto3\n    HAS_BOTO = True\nexcept ImportError:\n    HAS_BOTO = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.six.moves.urllib.parse import urlparse\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_bytes\n\n\ndef split_pre_existing_dir(dirname):\n    '''\n    Return the first pre-existing directory and a list of the new directories that will be created.\n    '''\n    head, tail = os.path.split(dirname)\n    b_head = to_bytes(head, errors='surrogate_or_strict')\n    if not os.path.exists(b_head):\n        (pre_existing_dir, new_directory_list) = split_pre_existing_dir(head)\n    else:\n        return head, [tail]\n    new_directory_list.append(tail)\n    return pre_existing_dir, new_directory_list\n\n\ndef adjust_recursive_directory_permissions(pre_existing_dir, new_directory_list, module, directory_args, changed):\n    '''\n    Walk the new directories list and make sure that permissions are as we would expect\n    '''\n    if new_directory_list:\n        working_dir = os.path.join(pre_existing_dir, new_directory_list.pop(0))\n        directory_args['path'] = working_dir\n        changed = module.set_fs_attributes_if_different(directory_args, changed)\n        changed = adjust_recursive_directory_permissions(working_dir, new_directory_list, module, directory_args, changed)\n    return changed\n\n\nclass Artifact(object):\n    def __init__(self, group_id, artifact_id, version, classifier='', extension='jar'):\n        if not group_id:\n            raise ValueError(\"group_id must be set\")\n        if not artifact_id:\n            raise ValueError(\"artifact_id must be set\")\n\n        self.group_id = group_id\n        self.artifact_id = artifact_id\n        self.version = version\n        self.classifier = classifier\n\n        if not extension:\n            self.extension = \"jar\"\n        else:\n            self.extension = extension\n\n    def is_snapshot(self):\n        return self.version and self.version.endswith(\"SNAPSHOT\")\n\n    def path(self, with_version=True):\n        base = posixpath.join(self.group_id.replace(\".\", \"/\"), self.artifact_id)\n        if with_version and self.version:\n            base = posixpath.join(base, self.version)\n        return base\n\n    def _generate_filename(self):\n        filename = self.artifact_id + \"-\" + self.classifier + \".\" + self.extension\n        if not self.classifier:\n            filename = self.artifact_id + \".\" + self.extension\n        return filename\n\n    def get_filename(self, filename=None):\n        if not filename:\n            filename = self._generate_filename()\n        elif os.path.isdir(filename):\n            filename = os.path.join(filename, self._generate_filename())\n        return filename\n\n    def __str__(self):\n        result = \"%s:%s:%s\" % (self.group_id, self.artifact_id, self.version)\n        if self.classifier:\n            result = \"%s:%s:%s:%s:%s\" % (self.group_id, self.artifact_id, self.extension, self.classifier, self.version)\n        elif self.extension != \"jar\":\n            result = \"%s:%s:%s:%s\" % (self.group_id, self.artifact_id, self.extension, self.version)\n        return result\n\n    @staticmethod\n    def parse(input):\n        parts = input.split(\":\")\n        if len(parts) >= 3:\n            g = parts[0]\n            a = parts[1]\n            v = parts[len(parts) - 1]\n            t = None\n            c = None\n            if len(parts) == 4:\n                t = parts[2]\n            if len(parts) == 5:\n                t = parts[2]\n                c = parts[3]\n            return Artifact(g, a, v, c, t)\n        else:\n            return None\n\n\nclass MavenDownloader:\n    def __init__(self, module, base=\"http://repo1.maven.org/maven2\"):\n        self.module = module\n        if base.endswith(\"/\"):\n            base = base.rstrip(\"/\")\n        self.base = base\n        self.user_agent = \"Maven Artifact Downloader/1.0\"\n        self.latest_version_found = None\n\n    def find_latest_version_available(self, artifact):\n        if self.latest_version_found:\n            return self.latest_version_found\n        path = \"/%s/maven-metadata.xml\" % (artifact.path(False))\n        xml = self._request(self.base + path, \"Failed to download maven-metadata.xml\", etree.parse)\n        v = xml.xpath(\"/metadata/versioning/versions/version[last()]/text()\")\n        if v:\n            self.latest_version_found = v[0]\n            return v[0]\n\n    def find_uri_for_artifact(self, artifact):\n        if artifact.version == \"latest\":\n            artifact.version = self.find_latest_version_available(artifact)\n\n        if artifact.is_snapshot():\n            path = \"/%s/maven-metadata.xml\" % (artifact.path())\n            xml = self._request(self.base + path, \"Failed to download maven-metadata.xml\", etree.parse)\n            timestamp = xml.xpath(\"/metadata/versioning/snapshot/timestamp/text()\")[0]\n            buildNumber = xml.xpath(\"/metadata/versioning/snapshot/buildNumber/text()\")[0]\n            for snapshotArtifact in xml.xpath(\"/metadata/versioning/snapshotVersions/snapshotVersion\"):\n                classifier = snapshotArtifact.xpath(\"classifier/text()\")\n                artifact_classifier = classifier[0] if classifier else ''\n                extension = snapshotArtifact.xpath(\"extension/text()\")\n                artifact_extension = extension[0] if extension else ''\n                if artifact_classifier == artifact.classifier and artifact_extension == artifact.extension:\n                    return self._uri_for_artifact(artifact, snapshotArtifact.xpath(\"value/text()\")[0])\n            return self._uri_for_artifact(artifact, artifact.version.replace(\"SNAPSHOT\", timestamp + \"-\" + buildNumber))\n\n        return self._uri_for_artifact(artifact, artifact.version)\n\n    def _uri_for_artifact(self, artifact, version=None):\n        if artifact.is_snapshot() and not version:\n            raise ValueError(\"Expected uniqueversion for snapshot artifact \" + str(artifact))\n        elif not artifact.is_snapshot():\n            version = artifact.version\n        if artifact.classifier:\n            return posixpath.join(self.base, artifact.path(), artifact.artifact_id + \"-\" + version + \"-\" + artifact.classifier + \".\" + artifact.extension)\n\n        return posixpath.join(self.base, artifact.path(), artifact.artifact_id + \"-\" + version + \".\" + artifact.extension)\n\n    def _request(self, url, failmsg, f):\n        url_to_use = url\n        parsed_url = urlparse(url)\n        if parsed_url.scheme == 's3':\n            parsed_url = urlparse(url)\n            bucket_name = parsed_url.netloc\n            key_name = parsed_url.path[1:]\n            client = boto3.client('s3', aws_access_key_id=self.module.params.get('username', ''), aws_secret_access_key=self.module.params.get('password', ''))\n            url_to_use = client.generate_presigned_url('get_object', Params={'Bucket': bucket_name, 'Key': key_name}, ExpiresIn=10)\n\n        req_timeout = self.module.params.get('timeout')\n\n         Hack to add parameters in the way that fetch_url expects\n        self.module.params['url_username'] = self.module.params.get('username', '')\n        self.module.params['url_password'] = self.module.params.get('password', '')\n        self.module.params['http_agent'] = self.module.params.get('user_agent', None)\n\n        response, info = fetch_url(self.module, url_to_use, timeout=req_timeout)\n        if info['status'] != 200:\n            raise ValueError(failmsg + \" because of \" + info['msg'] + \"for URL \" + url_to_use)\n        else:\n            return f(response)\n\n    def download(self, artifact, verify_download, filename=None):\n        filename = artifact.get_filename(filename)\n        if not artifact.version or artifact.version == \"latest\":\n            artifact = Artifact(artifact.group_id, artifact.artifact_id, self.find_latest_version_available(artifact),\n                                artifact.classifier, artifact.extension)\n        url = self.find_uri_for_artifact(artifact)\n        error = None\n        response = self._request(url, \"Failed to download artifact \" + str(artifact), lambda r: r)\n        if response:\n            f = open(filename, 'wb')\n            self._write_chunks(response, f, report_hook=self.chunk_report)\n            f.close()\n            with open(filename, 'wb') as f:\n                self._write_chunks(response, f, report_hook=self.chunk_report)\n\n            if verify_download and not self.verify_md5(filename, url + \".md5\"):\n                 if verify_change was set, the previous file would be deleted\n                os.remove(filename)\n                error = \"Checksum verification failed\"\n            else:\n                error = None\n        else:\n            error = \"Error downloading artifact \" + str(artifact)\n        return error\n\n    def chunk_report(self, bytes_so_far, chunk_size, total_size):\n        percent = float(bytes_so_far) / total_size\n        percent = round(percent * 100, 2)\n        sys.stdout.write(\"Downloaded %d of %d bytes (%0.2f%%)\\r\" %\n                         (bytes_so_far, total_size, percent))\n        if bytes_so_far >= total_size:\n            sys.stdout.write('\\n')\n\n    def _write_chunks(self, response, filehandle, chunk_size=8192, report_hook=None):\n        total_size = response.info().get('Content-Length').strip()\n        total_size = int(total_size)\n        bytes_so_far = 0\n\n        while True:\n            chunk = response.read(chunk_size)\n            bytes_so_far += len(chunk)\n\n            if not chunk:\n                break\n\n            filehandle.write(chunk)\n            if report_hook:\n                report_hook(bytes_so_far, chunk_size, total_size)\n\n        return bytes_so_far\n\n    def verify_md5(self, file, remote_md5):\n        result = False\n        if os.path.exists(file):\n            local_md5 = self._local_md5(file)\n            remote = self._request(remote_md5, \"Failed to download MD5\", lambda r: r.read())\n            result = local_md5 == remote\n        return result\n\n    def _local_md5(self, file):\n        md5 = hashlib.md5()\n        f = open(file, 'rb')\n        for chunk in iter(lambda: f.read(8192), ''):\n            md5.update(chunk)\n        f.close()\n        return md5.hexdigest()\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            group_id=dict(default=None),\n            artifact_id=dict(default=None),\n            version=dict(default=\"latest\"),\n            classifier=dict(default=''),\n            extension=dict(default='jar'),\n            repository_url=dict(default=None),\n            username=dict(default=None, aliases=['aws_secret_key']),\n            password=dict(default=None, no_log=True, aliases=['aws_secret_access_key']),\n            state=dict(default=\"present\", choices=[\"present\", \"absent\"]),   TODO - Implement a \"latest\" state\n            timeout=dict(default=10, type='int'),\n            dest=dict(type=\"path\", default=None),\n            validate_certs=dict(required=False, default=True, type='bool'),\n            keep_name=dict(required=False, default=False, type='bool'),\n            verify_checksum=dict(required=False, default='download', choices=['never', 'download', 'change', 'always']),\n        ),\n        add_file_common_args=True\n    )\n\n    if not HAS_LXML_ETREE:\n        module.fail_json(msg='module requires the lxml python library installed on the managed machine')\n\n    repository_url = module.params[\"repository_url\"]\n    if not repository_url:\n        repository_url = \"http://repo1.maven.org/maven2\"\n\n    try:\n        parsed_url = urlparse(repository_url)\n    except AttributeError as e:\n        module.fail_json(msg='url parsing went wrong %s' % e)\n\n    if parsed_url.scheme == 's3' and not HAS_BOTO:\n        module.fail_json(msg='boto3 required for this module, when using s3:// repository URLs')\n\n    group_id = module.params[\"group_id\"]\n    artifact_id = module.params[\"artifact_id\"]\n    version = module.params[\"version\"]\n    classifier = module.params[\"classifier\"]\n    extension = module.params[\"extension\"]\n    state = module.params[\"state\"]\n    dest = module.params[\"dest\"]\n    b_dest = to_bytes(dest, errors='surrogate_or_strict')\n    keep_name = module.params[\"keep_name\"]\n    verify_checksum = module.params[\"verify_checksum\"]\n    verify_download = verify_checksum in ['download', 'always']\n    verify_change = verify_checksum in ['change', 'always']\n\n    downloader = MavenDownloader(module, repository_url)\n\n    try:\n        artifact = Artifact(group_id, artifact_id, version, classifier, extension)\n    except ValueError as e:\n        module.fail_json(msg=e.args[0])\n\n    changed = False\n    prev_state = \"absent\"\n\n    if dest.endswith(os.sep):\n        b_dest = to_bytes(dest, errors='surrogate_or_strict')\n        if not os.path.exists(b_dest):\n            (pre_existing_dir, new_directory_list) = split_pre_existing_dir(dest)\n            os.makedirs(b_dest)\n            directory_args = module.load_file_common_arguments(module.params)\n            directory_mode = module.params[\"directory_mode\"]\n            if directory_mode is not None:\n                directory_args['mode'] = directory_mode\n            else:\n                directory_args['mode'] = None\n            changed = adjust_recursive_directory_permissions(pre_existing_dir, new_directory_list, module, directory_args, changed)\n\n    if os.path.isdir(b_dest):\n        version_part = version\n        if keep_name and version == 'latest':\n            version_part = downloader.find_latest_version_available(artifact)\n\n        if classifier:\n            dest = posixpath.join(dest, \"%s-%s-%s.%s\" % (artifact_id, version_part, classifier, extension))\n        else:\n            dest = posixpath.join(dest, \"%s-%s.%s\" % (artifact_id, version_part, extension))\n        b_dest = to_bytes(dest, errors='surrogate_or_strict')\n\n    if os.path.lexists(b_dest) and ((not verify_change) or downloader.verify_md5(dest, downloader.find_uri_for_artifact(artifact) + '.md5')):\n        prev_state = \"present\"\n\n    if prev_state == \"absent\":\n        try:\n            download_error = downloader.download(artifact, verify_download, b_dest)\n            if download_error is None:\n                changed = True\n            else:\n                module.fail_json(msg=\"Cannot download the artifact to destination: \" + download_error)\n        except ValueError as e:\n            module.fail_json(msg=e.args[0])\n\n    module.params['dest'] = dest\n    file_args = module.load_file_common_arguments(module.params)\n    changed = module.set_fs_attributes_if_different(file_args, changed)\n    if changed:\n        module.exit_json(state=state, dest=dest, group_id=group_id, artifact_id=artifact_id, version=version, classifier=classifier,\n                         extension=extension, repository_url=repository_url, changed=changed)\n    else:\n        module.exit_json(state=state, dest=dest, changed=changed)\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  maven artifact short description  downloads artifact maven repository version added   2 0  description        downloads artifact maven repository given maven coordinates provided module        can retrieve snapshots release versions artifact resolve latest available       version one available  author   chris schmidt ( chrisisbeef)  requirements        lxml       boto using s3 repository (s3      ) options      group id          description                the maven groupid coordinate         required  true     artifact id          description                the maven artifactid coordinate         required  true     version          description                the maven version coordinate         default  latest     classifier          description                the maven classifier coordinate     extension          description                the maven type extension coordinate         default  jar     repository url          description                the url maven repository download                use s3       repository hosted amazon s3  added version 2 2          default  http   repo1 maven org maven2     username          description                the username authenticate maven repository  use aws secret key repository hosted s3         aliases     aws secret key        password          description                the password authenticate maven repository  use aws secret access key repository hosted s3         aliases     aws secret access key        dest          description                the path artifact written               if file mode ownerships specified destination path already exists  affect downloaded file         required  true     state          description                the desired state artifact         default  present         choices   present absent      timeout          description                specifies timeout seconds connection attempt         default  10         version added   2 3      validate certs          description                if c(no)  ssl certificates validated  this set c(no) option exists          type  bool         default   yes          version added   1 9 3      keep name          description                if c(yes)  downloaded artifact name preserved  e version number remains part                this option effect c(dest) directory c(version) set c(latest)          type  bool         default            version added   2 4      verify checksum          description                if c(never)  md5 checksum never downloaded verified                if c(download)  md5 checksum downloaded verified artifact download  this default                if c(change)  md5 checksum downloaded verified destination already exist                verify identical  this behaviour 2 6  since downloads md5 (maybe)               downloading artifact  since repository software  acting proxy cache  return 404 error               artifact cached yet  may fail unexpectedly                if still need  consider using c(always) instead   deal checksum  better               use verify integrity download                c(always) combines c(download) c(change)          required  false         default   download          choices    never    download    change    always           version added   2 6  extends documentation fragment        files      examples         download latest version junit framework artifact maven central   maven artifact      group id  junit     artifact id  junit     dest   tmp junit latest jar    download junit 4 11 maven central   maven artifact      group id  junit     artifact id  junit     version  4 11     dest   tmp junit 4 11 jar    download artifact private repository requiring authentication   maven artifact      group id  com company     artifact id  library name     repository url   https   repo company com maven      username  user     password  pass     dest   tmp library name latest jar    download war file tomcat webapps directory deployed   maven artifact      group id  com company     artifact id  web app     extension  war     repository url   https   repo company com maven      dest   var lib tomcat7 webapps web app war    keep downloaded artifact name  e  retain version   maven artifact      version  latest     artifact id  spring core     group id  org springframework     dest   tmp      keep name  yes      import hashlib import os import posixpath import sys  try      lxml import etree     has lxml etree   true except importerror      has lxml etree   false  try      import boto3     has boto   true except importerror      has boto   false  ansible module utils basic import ansiblemodule ansible module utils six moves urllib parse import urlparse ansible module utils urls import fetch url ansible module utils  text import bytes   def split pre existing dir(dirname)              return first pre existing directory list new directories created              head  tail   os path split(dirname)     b head   bytes(head  errors  surrogate strict )     os path exists(b head)          (pre existing dir  new directory list)   split pre existing dir(head)     else          return head   tail      new directory list append(tail)     return pre existing dir  new directory list   def adjust recursive directory permissions(pre existing dir  new directory list  module  directory args  changed)              walk new directories list make sure permissions would expect             usr bin python        coding  utf 8        copyright (c) 2014  chris schmidt  chris schmidt () contrastsecurity com        built using https   github com hamnis useful scripts blob master python download maven artifact    reference starting point        gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    download latest version junit framework artifact maven central    download junit 4 11 maven central    download artifact private repository requiring authentication    download war file tomcat webapps directory deployed    keep downloaded artifact name  e  retain version    hack add parameters way fetch url expects    verify change set  previous file would deleted    todo   implement  latest  state ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Copyright (c) 2014, Chris Schmidt <chris.schmidt () contrastsecurity.com>\n#\n# Built using https://github.com/hamnis/useful-scripts/blob/master/python/download-maven-artifact\n# as a reference and starting point.\n#\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = '''\n---\nmodule: maven_artifact\nshort_description: Downloads an Artifact from a Maven Repository\nversion_added: \"2.0\"\ndescription:\n    - Downloads an artifact from a maven repository given the maven coordinates provided to the module.\n    - Can retrieve snapshots or release versions of the artifact and will resolve the latest available\n      version if one is not available.\nauthor: \"Chris Schmidt (@chrisisbeef)\"\nrequirements:\n    - lxml\n    - boto if using a S3 repository (s3://...)\noptions:\n    group_id:\n        description:\n            - The Maven groupId coordinate\n        required: true\n    artifact_id:\n        description:\n            - The maven artifactId coordinate\n        required: true\n    version:\n        description:\n            - The maven version coordinate\n        default: latest\n    classifier:\n        description:\n            - The maven classifier coordinate\n    extension:\n        description:\n            - The maven type/extension coordinate\n        default: jar\n    repository_url:\n        description:\n            - The URL of the Maven Repository to download from.\n            - Use s3://... if the repository is hosted on Amazon S3, added in version 2.2.\n        default: http://repo1.maven.org/maven2\n    username:\n        description:\n            - The username to authenticate as to the Maven Repository. Use AWS secret key of the repository is hosted on S3\n        aliases: [ \"aws_secret_key\" ]\n    password:\n        description:\n            - The password to authenticate with to the Maven Repository. Use AWS secret access key of the repository is hosted on S3\n        aliases: [ \"aws_secret_access_key\" ]\n    dest:\n        description:\n            - The path where the artifact should be written to\n            - If file mode or ownerships are specified and destination path already exists, they affect the downloaded file\n        required: true\n    state:\n        description:\n            - The desired state of the artifact\n        default: present\n        choices: [present,absent]\n    timeout:\n        description:\n            - Specifies a timeout in seconds for the connection attempt\n        default: 10\n        version_added: \"2.3\"\n    validate_certs:\n        description:\n            - If C(no), SSL certificates will not be validated. This should only be set to C(no) when no other option exists.\n        type: bool\n        default: 'yes'\n        version_added: \"1.9.3\"\n    keep_name:\n        description:\n            - If C(yes), the downloaded artifact's name is preserved, i.e the version number remains part of it.\n            - This option only has effect when C(dest) is a directory and C(version) is set to C(latest).\n        type: bool\n        default: 'no'\n        version_added: \"2.4\"\n    verify_checksum:\n        description:\n            - If C(never), the md5 checksum will never be downloaded and verified.\n            - If C(download), the md5 checksum will be downloaded and verified only after artifact download. This is the default.\n            - If C(change), the md5 checksum will be downloaded and verified if the destination already exist,\n              to verify if they are identical. This was the behaviour before 2.6. Since it downloads the md5 before (maybe)\n              downloading the artifact, and since some repository software, when acting as a proxy/cache, return a 404 error\n              if the artifact has not been cached yet, it may fail unexpectedly.\n              If you still need it, you should consider using C(always) instead - if you deal with a checksum, it is better to\n              use it to verify integrity after download.\n            - C(always) combines C(download) and C(change).\n        required: false\n        default: 'download'\n        choices: ['never', 'download', 'change', 'always']\n        version_added: \"2.6\"\nextends_documentation_fragment:\n    - files\n'''\n\nEXAMPLES = '''\n# Download the latest version of the JUnit framework artifact from Maven Central\n- maven_artifact:\n    group_id: junit\n    artifact_id: junit\n    dest: /tmp/junit-latest.jar\n\n# Download JUnit 4.11 from Maven Central\n- maven_artifact:\n    group_id: junit\n    artifact_id: junit\n    version: 4.11\n    dest: /tmp/junit-4.11.jar\n\n# Download an artifact from a private repository requiring authentication\n- maven_artifact:\n    group_id: com.company\n    artifact_id: library-name\n    repository_url: 'https://repo.company.com/maven'\n    username: user\n    password: pass\n    dest: /tmp/library-name-latest.jar\n\n# Download a WAR File to the Tomcat webapps directory to be deployed\n- maven_artifact:\n    group_id: com.company\n    artifact_id: web-app\n    extension: war\n    repository_url: 'https://repo.company.com/maven'\n    dest: /var/lib/tomcat7/webapps/web-app.war\n\n# Keep a downloaded artifact's name, i.e. retain the version\n- maven_artifact:\n    version: latest\n    artifact_id: spring-core\n    group_id: org.springframework\n    dest: /tmp/\n    keep_name: yes\n'''\n\nimport hashlib\nimport os\nimport posixpath\nimport sys\n\ntry:\n    from lxml import etree\n    HAS_LXML_ETREE = True\nexcept ImportError:\n    HAS_LXML_ETREE = False\n\ntry:\n    import boto3\n    HAS_BOTO = True\nexcept ImportError:\n    HAS_BOTO = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.six.moves.urllib.parse import urlparse\nfrom ansible.module_utils.urls import fetch_url\nfrom ansible.module_utils._text import to_bytes\n\n\ndef split_pre_existing_dir(dirname):\n    '''\n    Return the first pre-existing directory and a list of the new directories that will be created.\n    '''\n    head, tail = os.path.split(dirname)\n    b_head = to_bytes(head, errors='surrogate_or_strict')\n    if not os.path.exists(b_head):\n        (pre_existing_dir, new_directory_list) = split_pre_existing_dir(head)\n    else:\n        return head, [tail]\n    new_directory_list.append(tail)\n    return pre_existing_dir, new_directory_list\n\n\ndef adjust_recursive_directory_permissions(pre_existing_dir, new_directory_list, module, directory_args, changed):\n    '''\n    Walk the new directories list and make sure that permissions are as we would expect\n    '''\n    if new_directory_list:\n        working_dir = os.path.join(pre_existing_dir, new_directory_list.pop(0))\n        directory_args['path'] = working_dir\n        changed = module.set_fs_attributes_if_different(directory_args, changed)\n        changed = adjust_recursive_directory_permissions(working_dir, new_directory_list, module, directory_args, changed)\n    return changed\n\n\nclass Artifact(object):\n    def __init__(self, group_id, artifact_id, version, classifier='', extension='jar'):\n        if not group_id:\n            raise ValueError(\"group_id must be set\")\n        if not artifact_id:\n            raise ValueError(\"artifact_id must be set\")\n\n        self.group_id = group_id\n        self.artifact_id = artifact_id\n        self.version = version\n        self.classifier = classifier\n\n        if not extension:\n            self.extension = \"jar\"\n        else:\n            self.extension = extension\n\n    def is_snapshot(self):\n        return self.version and self.version.endswith(\"SNAPSHOT\")\n\n    def path(self, with_version=True):\n        base = posixpath.join(self.group_id.replace(\".\", \"/\"), self.artifact_id)\n        if with_version and self.version:\n            base = posixpath.join(base, self.version)\n        return base\n\n    def _generate_filename(self):\n        filename = self.artifact_id + \"-\" + self.classifier + \".\" + self.extension\n        if not self.classifier:\n            filename = self.artifact_id + \".\" + self.extension\n        return filename\n\n    def get_filename(self, filename=None):\n        if not filename:\n            filename = self._generate_filename()\n        elif os.path.isdir(filename):\n            filename = os.path.join(filename, self._generate_filename())\n        return filename\n\n    def __str__(self):\n        result = \"%s:%s:%s\" % (self.group_id, self.artifact_id, self.version)\n        if self.classifier:\n            result = \"%s:%s:%s:%s:%s\" % (self.group_id, self.artifact_id, self.extension, self.classifier, self.version)\n        elif self.extension != \"jar\":\n            result = \"%s:%s:%s:%s\" % (self.group_id, self.artifact_id, self.extension, self.version)\n        return result\n\n    @staticmethod\n    def parse(input):\n        parts = input.split(\":\")\n        if len(parts) >= 3:\n            g = parts[0]\n            a = parts[1]\n            v = parts[len(parts) - 1]\n            t = None\n            c = None\n            if len(parts) == 4:\n                t = parts[2]\n            if len(parts) == 5:\n                t = parts[2]\n                c = parts[3]\n            return Artifact(g, a, v, c, t)\n        else:\n            return None\n\n\nclass MavenDownloader:\n    def __init__(self, module, base=\"http://repo1.maven.org/maven2\"):\n        self.module = module\n        if base.endswith(\"/\"):\n            base = base.rstrip(\"/\")\n        self.base = base\n        self.user_agent = \"Maven Artifact Downloader/1.0\"\n        self.latest_version_found = None\n\n    def find_latest_version_available(self, artifact):\n        if self.latest_version_found:\n            return self.latest_version_found\n        path = \"/%s/maven-metadata.xml\" % (artifact.path(False))\n        xml = self._request(self.base + path, \"Failed to download maven-metadata.xml\", etree.parse)\n        v = xml.xpath(\"/metadata/versioning/versions/version[last()]/text()\")\n        if v:\n            self.latest_version_found = v[0]\n            return v[0]\n\n    def find_uri_for_artifact(self, artifact):\n        if artifact.version == \"latest\":\n            artifact.version = self.find_latest_version_available(artifact)\n\n        if artifact.is_snapshot():\n            path = \"/%s/maven-metadata.xml\" % (artifact.path())\n            xml = self._request(self.base + path, \"Failed to download maven-metadata.xml\", etree.parse)\n            timestamp = xml.xpath(\"/metadata/versioning/snapshot/timestamp/text()\")[0]\n            buildNumber = xml.xpath(\"/metadata/versioning/snapshot/buildNumber/text()\")[0]\n            for snapshotArtifact in xml.xpath(\"/metadata/versioning/snapshotVersions/snapshotVersion\"):\n                classifier = snapshotArtifact.xpath(\"classifier/text()\")\n                artifact_classifier = classifier[0] if classifier else ''\n                extension = snapshotArtifact.xpath(\"extension/text()\")\n                artifact_extension = extension[0] if extension else ''\n                if artifact_classifier == artifact.classifier and artifact_extension == artifact.extension:\n                    return self._uri_for_artifact(artifact, snapshotArtifact.xpath(\"value/text()\")[0])\n            return self._uri_for_artifact(artifact, artifact.version.replace(\"SNAPSHOT\", timestamp + \"-\" + buildNumber))\n\n        return self._uri_for_artifact(artifact, artifact.version)\n\n    def _uri_for_artifact(self, artifact, version=None):\n        if artifact.is_snapshot() and not version:\n            raise ValueError(\"Expected uniqueversion for snapshot artifact \" + str(artifact))\n        elif not artifact.is_snapshot():\n            version = artifact.version\n        if artifact.classifier:\n            return posixpath.join(self.base, artifact.path(), artifact.artifact_id + \"-\" + version + \"-\" + artifact.classifier + \".\" + artifact.extension)\n\n        return posixpath.join(self.base, artifact.path(), artifact.artifact_id + \"-\" + version + \".\" + artifact.extension)\n\n    def _request(self, url, failmsg, f):\n        url_to_use = url\n        parsed_url = urlparse(url)\n        if parsed_url.scheme == 's3':\n            parsed_url = urlparse(url)\n            bucket_name = parsed_url.netloc\n            key_name = parsed_url.path[1:]\n            client = boto3.client('s3', aws_access_key_id=self.module.params.get('username', ''), aws_secret_access_key=self.module.params.get('password', ''))\n            url_to_use = client.generate_presigned_url('get_object', Params={'Bucket': bucket_name, 'Key': key_name}, ExpiresIn=10)\n\n        req_timeout = self.module.params.get('timeout')\n\n        # Hack to add parameters in the way that fetch_url expects\n        self.module.params['url_username'] = self.module.params.get('username', '')\n        self.module.params['url_password'] = self.module.params.get('password', '')\n        self.module.params['http_agent'] = self.module.params.get('user_agent', None)\n\n        response, info = fetch_url(self.module, url_to_use, timeout=req_timeout)\n        if info['status'] != 200:\n            raise ValueError(failmsg + \" because of \" + info['msg'] + \"for URL \" + url_to_use)\n        else:\n            return f(response)\n\n    def download(self, artifact, verify_download, filename=None):\n        filename = artifact.get_filename(filename)\n        if not artifact.version or artifact.version == \"latest\":\n            artifact = Artifact(artifact.group_id, artifact.artifact_id, self.find_latest_version_available(artifact),\n                                artifact.classifier, artifact.extension)\n        url = self.find_uri_for_artifact(artifact)\n        error = None\n        response = self._request(url, \"Failed to download artifact \" + str(artifact), lambda r: r)\n        if response:\n            f = open(filename, 'wb')\n            self._write_chunks(response, f, report_hook=self.chunk_report)\n            f.close()\n            with open(filename, 'wb') as f:\n                self._write_chunks(response, f, report_hook=self.chunk_report)\n\n            if verify_download and not self.verify_md5(filename, url + \".md5\"):\n                # if verify_change was set, the previous file would be deleted\n                os.remove(filename)\n                error = \"Checksum verification failed\"\n            else:\n                error = None\n        else:\n            error = \"Error downloading artifact \" + str(artifact)\n        return error\n\n    def chunk_report(self, bytes_so_far, chunk_size, total_size):\n        percent = float(bytes_so_far) / total_size\n        percent = round(percent * 100, 2)\n        sys.stdout.write(\"Downloaded %d of %d bytes (%0.2f%%)\\r\" %\n                         (bytes_so_far, total_size, percent))\n        if bytes_so_far >= total_size:\n            sys.stdout.write('\\n')\n\n    def _write_chunks(self, response, filehandle, chunk_size=8192, report_hook=None):\n        total_size = response.info().get('Content-Length').strip()\n        total_size = int(total_size)\n        bytes_so_far = 0\n\n        while True:\n            chunk = response.read(chunk_size)\n            bytes_so_far += len(chunk)\n\n            if not chunk:\n                break\n\n            filehandle.write(chunk)\n            if report_hook:\n                report_hook(bytes_so_far, chunk_size, total_size)\n\n        return bytes_so_far\n\n    def verify_md5(self, file, remote_md5):\n        result = False\n        if os.path.exists(file):\n            local_md5 = self._local_md5(file)\n            remote = self._request(remote_md5, \"Failed to download MD5\", lambda r: r.read())\n            result = local_md5 == remote\n        return result\n\n    def _local_md5(self, file):\n        md5 = hashlib.md5()\n        f = open(file, 'rb')\n        for chunk in iter(lambda: f.read(8192), ''):\n            md5.update(chunk)\n        f.close()\n        return md5.hexdigest()\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            group_id=dict(default=None),\n            artifact_id=dict(default=None),\n            version=dict(default=\"latest\"),\n            classifier=dict(default=''),\n            extension=dict(default='jar'),\n            repository_url=dict(default=None),\n            username=dict(default=None, aliases=['aws_secret_key']),\n            password=dict(default=None, no_log=True, aliases=['aws_secret_access_key']),\n            state=dict(default=\"present\", choices=[\"present\", \"absent\"]),  # TODO - Implement a \"latest\" state\n            timeout=dict(default=10, type='int'),\n            dest=dict(type=\"path\", default=None),\n            validate_certs=dict(required=False, default=True, type='bool'),\n            keep_name=dict(required=False, default=False, type='bool'),\n            verify_checksum=dict(required=False, default='download', choices=['never', 'download', 'change', 'always']),\n        ),\n        add_file_common_args=True\n    )\n\n    if not HAS_LXML_ETREE:\n        module.fail_json(msg='module requires the lxml python library installed on the managed machine')\n\n    repository_url = module.params[\"repository_url\"]\n    if not repository_url:\n        repository_url = \"http://repo1.maven.org/maven2\"\n\n    try:\n        parsed_url = urlparse(repository_url)\n    except AttributeError as e:\n        module.fail_json(msg='url parsing went wrong %s' % e)\n\n    if parsed_url.scheme == 's3' and not HAS_BOTO:\n        module.fail_json(msg='boto3 required for this module, when using s3:// repository URLs')\n\n    group_id = module.params[\"group_id\"]\n    artifact_id = module.params[\"artifact_id\"]\n    version = module.params[\"version\"]\n    classifier = module.params[\"classifier\"]\n    extension = module.params[\"extension\"]\n    state = module.params[\"state\"]\n    dest = module.params[\"dest\"]\n    b_dest = to_bytes(dest, errors='surrogate_or_strict')\n    keep_name = module.params[\"keep_name\"]\n    verify_checksum = module.params[\"verify_checksum\"]\n    verify_download = verify_checksum in ['download', 'always']\n    verify_change = verify_checksum in ['change', 'always']\n\n    downloader = MavenDownloader(module, repository_url)\n\n    try:\n        artifact = Artifact(group_id, artifact_id, version, classifier, extension)\n    except ValueError as e:\n        module.fail_json(msg=e.args[0])\n\n    changed = False\n    prev_state = \"absent\"\n\n    if dest.endswith(os.sep):\n        b_dest = to_bytes(dest, errors='surrogate_or_strict')\n        if not os.path.exists(b_dest):\n            (pre_existing_dir, new_directory_list) = split_pre_existing_dir(dest)\n            os.makedirs(b_dest)\n            directory_args = module.load_file_common_arguments(module.params)\n            directory_mode = module.params[\"directory_mode\"]\n            if directory_mode is not None:\n                directory_args['mode'] = directory_mode\n            else:\n                directory_args['mode'] = None\n            changed = adjust_recursive_directory_permissions(pre_existing_dir, new_directory_list, module, directory_args, changed)\n\n    if os.path.isdir(b_dest):\n        version_part = version\n        if keep_name and version == 'latest':\n            version_part = downloader.find_latest_version_available(artifact)\n\n        if classifier:\n            dest = posixpath.join(dest, \"%s-%s-%s.%s\" % (artifact_id, version_part, classifier, extension))\n        else:\n            dest = posixpath.join(dest, \"%s-%s.%s\" % (artifact_id, version_part, extension))\n        b_dest = to_bytes(dest, errors='surrogate_or_strict')\n\n    if os.path.lexists(b_dest) and ((not verify_change) or downloader.verify_md5(dest, downloader.find_uri_for_artifact(artifact) + '.md5')):\n        prev_state = \"present\"\n\n    if prev_state == \"absent\":\n        try:\n            download_error = downloader.download(artifact, verify_download, b_dest)\n            if download_error is None:\n                changed = True\n            else:\n                module.fail_json(msg=\"Cannot download the artifact to destination: \" + download_error)\n        except ValueError as e:\n            module.fail_json(msg=e.args[0])\n\n    module.params['dest'] = dest\n    file_args = module.load_file_common_arguments(module.params)\n    changed = module.set_fs_attributes_if_different(file_args, changed)\n    if changed:\n        module.exit_json(state=state, dest=dest, group_id=group_id, artifact_id=artifact_id, version=version, classifier=classifier,\n                         extension=extension, repository_url=repository_url, changed=changed)\n    else:\n        module.exit_json(state=state, dest=dest, changed=changed)\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "maven_artifact.py", "id": "3030344e2b9a8dffaf19bb2afb35c6d9", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/packaging/language/maven_artifact.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}