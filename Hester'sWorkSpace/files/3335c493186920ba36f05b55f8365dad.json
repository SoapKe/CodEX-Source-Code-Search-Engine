{"author": "keon", "code": "\n\n \n\nclass Job:\n    def __init__(self, start, finish, profit):\n        self.start  = start\n        self.finish = finish\n        self.profit  = profit\n \n \n\n\n\n\n\n\ndef binarySearch(job, start_index):\n \n    \n    lo = 0\n    hi = start_index - 1\n \n    \n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if job[mid].finish <= job[start_index].start:\n            if job[mid + 1].finish <= job[start_index].start:\n                lo = mid + 1\n            else:\n                return mid\n        else:\n            hi = mid - 1\n    return -1\n \n\n\ndef schedule(job):\n   \n    \n    job = sorted(job, key = lambda j: j.finish)\n \n    \n    \n    n = len(job) \n    table = [0 for _ in range(n)]\n \n    table[0] = job[0].profit;\n \n    \n    for i in range(1, n):\n \n        \n        inclProf = job[i].profit\n        l = binarySearch(job, i)\n        if (l != -1):\n            inclProf += table[l];\n \n        \n        table[i] = max(inclProf, table[i - 1])\n \n    return table[n-1]\n", "comments": "python program weighted job scheduling using dynamic programming binary search class represent job a binary search based function find latest job (before current job) conflict current job \"index\" index current job this function returns -1 jobs index conflict the array jobs[] sorted increasing order finish time initialize 'lo' 'hi' binary search perform binary search iteratively the main function returns maximum possible profit given array jobs sort jobs according finish time create array store solutions subproblems table[i] stores profit jobs till arr[i] (including arr[i]) fill entries table[] using recursive property find profit including current job store maximum including excluding", "content": "# Python program for weighted job scheduling using Dynamic \n# Programming and Binary Search\n \n# Class to represent a job\nclass Job:\n    def __init__(self, start, finish, profit):\n        self.start  = start\n        self.finish = finish\n        self.profit  = profit\n \n \n# A Binary Search based function to find the latest job\n# (before current job) that doesn't conflict with current\n# job.  \"index\" is index of the current job.  This function\n# returns -1 if all jobs before index conflict with it.\n# The array jobs[] is sorted in increasing order of finish\n# time.\ndef binarySearch(job, start_index):\n \n    # Initialize 'lo' and 'hi' for Binary Search\n    lo = 0\n    hi = start_index - 1\n \n    # Perform binary Search iteratively\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if job[mid].finish <= job[start_index].start:\n            if job[mid + 1].finish <= job[start_index].start:\n                lo = mid + 1\n            else:\n                return mid\n        else:\n            hi = mid - 1\n    return -1\n \n# The main function that returns the maximum possible\n# profit from given array of jobs\ndef schedule(job):\n   \n    # Sort jobs according to finish time\n    job = sorted(job, key = lambda j: j.finish)\n \n    # Create an array to store solutions of subproblems.  table[i]\n    # stores the profit for jobs till arr[i] (including arr[i])\n    n = len(job) \n    table = [0 for _ in range(n)]\n \n    table[0] = job[0].profit;\n \n    # Fill entries in table[] using recursive property\n    for i in range(1, n):\n \n        # Find profit including the current job\n        inclProf = job[i].profit\n        l = binarySearch(job, i)\n        if (l != -1):\n            inclProf += table[l];\n \n        # Store maximum of including and excluding\n        table[i] = max(inclProf, table[i - 1])\n \n    return table[n-1]\n", "description": "Minimal examples of data structures and algorithms in Python", "file_name": "job_scheduling.py", "id": "3335c493186920ba36f05b55f8365dad", "language": "Python", "project_name": "algorithms", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/keon-algorithms/keon-algorithms-abe4cb1/dp/job_scheduling.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:56:36Z", "url": "https://github.com/keon/algorithms", "wiki": true}