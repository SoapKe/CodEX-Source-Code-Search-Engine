{"author": "nvbn", "code": "import pytest\nfrom io import BytesIO\nfrom thefuck.types import Command\nfrom thefuck.rules.docker_not_command import get_new_command, match\n\n\n@pytest.fixture\ndef docker_help(mocker):\n    help = b\n    mock = mocker.patch('subprocess.Popen')\n    mock.return_value.stdout = BytesIO(help)\n    return mock\n\n\ndef output(cmd):\n    return \"docker: '{}' is not a docker command.\\n\" \\\n           \"See 'docker --help'.\".format(cmd)\n\n\ndef test_match():\n    assert match(Command('docker pes', output('pes')))\n\n\n@pytest.mark.parametrize('script, output', [\n    ('docker ps', ''),\n    ('cat pes', output('pes'))])\ndef test_not_match(script, output):\n    assert not match(Command(script, output))\n\n\n@pytest.mark.usefixtures('docker_help')\n@pytest.mark.parametrize('wrong, fixed', [\n    ('pes', ['ps', 'push', 'pause']),\n    ('tags', ['tag', 'stats', 'images'])])\ndef test_get_new_command(wrong, fixed):\n    command = Command('docker {}'.format(wrong), output(wrong))\n    assert get_new_command(command) == ['docker {}'.format(x) for x in fixed]\n", "comments": "Usage: docker [OPTIONS] COMMAND [arg...]\n\nA self-sufficient runtime for linux containers.\n\nOptions:\n\n  --api-cors-header=                   Set CORS headers in the remote API\n  -b, --bridge=                        Attach containers to a network bridge\n  --bip=                               Specify network bridge IP\n  -D, --debug=false                    Enable debug mode\n  -d, --daemon=false                   Enable daemon mode\n  --default-gateway=                   Container default gateway IPv4 address\n  --default-gateway-v6=                Container default gateway IPv6 address\n  --default-ulimit=[]                  Set default ulimits for containers\n  --dns=[]                             DNS server to use\n  --dns-search=[]                      DNS search domains to use\n  -e, --exec-driver=native             Exec driver to use\n  --exec-opt=[]                        Set exec driver options\n  --exec-root=/var/run/docker          Root of the Docker execdriver\n  --fixed-cidr=                        IPv4 subnet for fixed IPs\n  --fixed-cidr-v6=                     IPv6 subnet for fixed IPs\n  -G, --group=docker                   Group for the unix socket\n  -g, --graph=/var/lib/docker          Root of the Docker runtime\n  -H, --host=[]                        Daemon socket(s) to connect to\n  -h, --help=false                     Print usage\n  --icc=true                           Enable inter-container communication\n  --insecure-registry=[]               Enable insecure registry communication\n  --ip=0.0.0.0                         Default IP when binding container ports\n  --ip-forward=true                    Enable net.ipv4.ip_forward\n  --ip-masq=true                       Enable IP masquerading\n  --iptables=true                      Enable addition of iptables rules\n  --ipv6=false                         Enable IPv6 networking\n  -l, --log-level=info                 Set the logging level\n  --label=[]                           Set key=value labels to the daemon\n  --log-driver=json-file               Default driver for container logs\n  --log-opt=map[]                      Set log driver options\n  --mtu=0                              Set the containers network MTU\n  -p, --pidfile=/var/run/docker.pid    Path to use for daemon PID file\n  --registry-mirror=[]                 Preferred Docker registry mirror\n  -s, --storage-driver=                Storage driver to use\n  --selinux-enabled=false              Enable selinux support\n  --storage-opt=[]                     Set storage driver options\n  --tls=false                          Use TLS; implied by --tlsverify\n  --tlscacert=~/.docker/ca.pem         Trust certs signed only by this CA\n  --tlscert=~/.docker/cert.pem         Path to TLS certificate file\n  --tlskey=~/.docker/key.pem           Path to TLS key file\n  --tlsverify=false                    Use TLS and verify the remote\n  --userland-proxy=true                Use userland proxy for loopback traffic\n  -v, --version=false                  Print version information and quit\n\nCommands:\n    attach    Attach to a running container\n    build     Build an image from a Dockerfile\n    commit    Create a new image from a container's changes\n    cp        Copy files/folders from a container's filesystem to the host path\n    create    Create a new container\n    diff      Inspect changes on a container's filesystem\n    events    Get real time events from the server\n    exec      Run a command in a running container\n    export    Stream the contents of a container as a tar archive\n    history   Show the history of an image\n    images    List images\n    import    Create a new filesystem image from the contents of a tarball\n    info      Display system-wide information\n    inspect   Return low-level information on a container or image\n    kill      Kill a running container\n    load      Load an image from a tar archive\n    login     Register or log in to a Docker registry server\n    logout    Log out from a Docker registry server\n    logs      Fetch the logs of a container\n    pause     Pause all processes within a container\n    port      Lookup the public-facing port that is NAT-ed to PRIVATE_PORT\n    ps        List containers\n    pull      Pull an image or a repository from a Docker registry server\n    push      Push an image or a repository to a Docker registry server\n    rename    Rename an existing container\n    restart   Restart a running container\n    rm        Remove one or more containers\n    rmi       Remove one or more images\n    run       Run a command in a new container\n    save      Save an image to a tar archive\n    search    Search for an image on the Docker Hub\n    start     Start a stopped container\n    stats     Display a stream of a containers' resource usage statistics\n    stop      Stop a running container\n    tag       Tag an image into a repository\n    top       Lookup the running processes of a container\n    unpause   Unpause a paused container\n    version   Show the Docker version information\n    wait      Block until a container stops, then print its exit code\n\nRun 'docker COMMAND --help' for more information on a command.\n\n\n\n", "content": "import pytest\nfrom io import BytesIO\nfrom thefuck.types import Command\nfrom thefuck.rules.docker_not_command import get_new_command, match\n\n\n@pytest.fixture\ndef docker_help(mocker):\n    help = b'''Usage: docker [OPTIONS] COMMAND [arg...]\n\nA self-sufficient runtime for linux containers.\n\nOptions:\n\n  --api-cors-header=                   Set CORS headers in the remote API\n  -b, --bridge=                        Attach containers to a network bridge\n  --bip=                               Specify network bridge IP\n  -D, --debug=false                    Enable debug mode\n  -d, --daemon=false                   Enable daemon mode\n  --default-gateway=                   Container default gateway IPv4 address\n  --default-gateway-v6=                Container default gateway IPv6 address\n  --default-ulimit=[]                  Set default ulimits for containers\n  --dns=[]                             DNS server to use\n  --dns-search=[]                      DNS search domains to use\n  -e, --exec-driver=native             Exec driver to use\n  --exec-opt=[]                        Set exec driver options\n  --exec-root=/var/run/docker          Root of the Docker execdriver\n  --fixed-cidr=                        IPv4 subnet for fixed IPs\n  --fixed-cidr-v6=                     IPv6 subnet for fixed IPs\n  -G, --group=docker                   Group for the unix socket\n  -g, --graph=/var/lib/docker          Root of the Docker runtime\n  -H, --host=[]                        Daemon socket(s) to connect to\n  -h, --help=false                     Print usage\n  --icc=true                           Enable inter-container communication\n  --insecure-registry=[]               Enable insecure registry communication\n  --ip=0.0.0.0                         Default IP when binding container ports\n  --ip-forward=true                    Enable net.ipv4.ip_forward\n  --ip-masq=true                       Enable IP masquerading\n  --iptables=true                      Enable addition of iptables rules\n  --ipv6=false                         Enable IPv6 networking\n  -l, --log-level=info                 Set the logging level\n  --label=[]                           Set key=value labels to the daemon\n  --log-driver=json-file               Default driver for container logs\n  --log-opt=map[]                      Set log driver options\n  --mtu=0                              Set the containers network MTU\n  -p, --pidfile=/var/run/docker.pid    Path to use for daemon PID file\n  --registry-mirror=[]                 Preferred Docker registry mirror\n  -s, --storage-driver=                Storage driver to use\n  --selinux-enabled=false              Enable selinux support\n  --storage-opt=[]                     Set storage driver options\n  --tls=false                          Use TLS; implied by --tlsverify\n  --tlscacert=~/.docker/ca.pem         Trust certs signed only by this CA\n  --tlscert=~/.docker/cert.pem         Path to TLS certificate file\n  --tlskey=~/.docker/key.pem           Path to TLS key file\n  --tlsverify=false                    Use TLS and verify the remote\n  --userland-proxy=true                Use userland proxy for loopback traffic\n  -v, --version=false                  Print version information and quit\n\nCommands:\n    attach    Attach to a running container\n    build     Build an image from a Dockerfile\n    commit    Create a new image from a container's changes\n    cp        Copy files/folders from a container's filesystem to the host path\n    create    Create a new container\n    diff      Inspect changes on a container's filesystem\n    events    Get real time events from the server\n    exec      Run a command in a running container\n    export    Stream the contents of a container as a tar archive\n    history   Show the history of an image\n    images    List images\n    import    Create a new filesystem image from the contents of a tarball\n    info      Display system-wide information\n    inspect   Return low-level information on a container or image\n    kill      Kill a running container\n    load      Load an image from a tar archive\n    login     Register or log in to a Docker registry server\n    logout    Log out from a Docker registry server\n    logs      Fetch the logs of a container\n    pause     Pause all processes within a container\n    port      Lookup the public-facing port that is NAT-ed to PRIVATE_PORT\n    ps        List containers\n    pull      Pull an image or a repository from a Docker registry server\n    push      Push an image or a repository to a Docker registry server\n    rename    Rename an existing container\n    restart   Restart a running container\n    rm        Remove one or more containers\n    rmi       Remove one or more images\n    run       Run a command in a new container\n    save      Save an image to a tar archive\n    search    Search for an image on the Docker Hub\n    start     Start a stopped container\n    stats     Display a stream of a containers' resource usage statistics\n    stop      Stop a running container\n    tag       Tag an image into a repository\n    top       Lookup the running processes of a container\n    unpause   Unpause a paused container\n    version   Show the Docker version information\n    wait      Block until a container stops, then print its exit code\n\nRun 'docker COMMAND --help' for more information on a command.\n'''\n    mock = mocker.patch('subprocess.Popen')\n    mock.return_value.stdout = BytesIO(help)\n    return mock\n\n\ndef output(cmd):\n    return \"docker: '{}' is not a docker command.\\n\" \\\n           \"See 'docker --help'.\".format(cmd)\n\n\ndef test_match():\n    assert match(Command('docker pes', output('pes')))\n\n\n@pytest.mark.parametrize('script, output', [\n    ('docker ps', ''),\n    ('cat pes', output('pes'))])\ndef test_not_match(script, output):\n    assert not match(Command(script, output))\n\n\n@pytest.mark.usefixtures('docker_help')\n@pytest.mark.parametrize('wrong, fixed', [\n    ('pes', ['ps', 'push', 'pause']),\n    ('tags', ['tag', 'stats', 'images'])])\ndef test_get_new_command(wrong, fixed):\n    command = Command('docker {}'.format(wrong), output(wrong))\n    assert get_new_command(command) == ['docker {}'.format(x) for x in fixed]\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "test_docker_not_command.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/tests/rules/test_docker_not_command.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}