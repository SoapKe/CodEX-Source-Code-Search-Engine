{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nimport itertools\nimport psycopg2\n\nfrom odoo.addons import decimal_precision as dp\n\nfrom odoo import api, fields, models, tools, _\nfrom odoo.exceptions import ValidationError, RedirectWarning, except_orm\nfrom odoo.tools import pycompat\n\n\nclass ProductTemplate(models.Model):\n    _name = \"product.template\"\n    _inherit = ['mail.thread', 'mail.activity.mixin']\n    _description = \"Product Template\"\n    _order = \"name\"\n\n    def _get_default_category_id(self):\n        if self._context.get('categ_id') or self._context.get('default_categ_id'):\n            return self._context.get('categ_id') or self._context.get('default_categ_id')\n        category = self.env.ref('product.product_category_all', raise_if_not_found=False)\n        if not category:\n            category = self.env['product.category'].search([], limit=1)\n        if category:\n            return category.id\n        else:\n            err_msg = _('You must define at least one product category in order to be able to create products.')\n            redir_msg = _('Go to Internal Categories')\n            raise RedirectWarning(err_msg, self.env.ref('product.product_category_action_form').id, redir_msg)\n\n    def _get_default_uom_id(self):\n        return self.env[\"product.uom\"].search([], limit=1, order='id').id\n\n    name = fields.Char('Name', index=True, required=True, translate=True)\n    sequence = fields.Integer('Sequence', default=1, help='Gives the sequence order when displaying a product list')\n    description = fields.Text(\n        'Description', translate=True,\n        help=\"A precise description of the Product, used only for internal information purposes.\")\n    description_purchase = fields.Text(\n        'Purchase Description', translate=True,\n        help=\"A description of the Product that you want to communicate to your vendors. \"\n             \"This description will be copied to every Purchase Order, Receipt and Vendor Bill/Credit Note.\")\n    description_sale = fields.Text(\n        'Sale Description', translate=True,\n        help=\"A description of the Product that you want to communicate to your customers. \"\n             \"This description will be copied to every Sales Order, Delivery Order and Customer Invoice/Credit Note\")\n    type = fields.Selection([\n        ('consu', _('Consumable')),\n        ('service', _('Service'))], string='Product Type', default='consu', required=True,\n        help='A stockable product is a product for which you manage stock. The \"Inventory\" app has to be installed.\\n'\n             'A consumable product, on the other hand, is a product for which stock is not managed.\\n'\n             'A service is a non-material product you provide.\\n'\n             'A digital content is a non-material product you sell online. The files attached to the products are the one that are sold on '\n             'the e-commerce such as e-books, music, pictures,... The \"Digital Product\" module has to be installed.')\n    rental = fields.Boolean('Can be Rent')\n    categ_id = fields.Many2one(\n        'product.category', 'Internal Category',\n        change_default=True, default=_get_default_category_id,\n        required=True, help=\"Select category for the current product\")\n\n    currency_id = fields.Many2one(\n        'res.currency', 'Currency', compute='_compute_currency_id')\n\n    \n    price = fields.Float(\n        'Price', compute='_compute_template_price', inverse='_set_template_price',\n        digits=dp.get_precision('Product Price'))\n    list_price = fields.Float(\n        'Sales Price', default=1.0,\n        digits=dp.get_precision('Product Price'),\n        help=\"Base price to compute the customer price. Sometimes called the catalog price.\")\n    lst_price = fields.Float(\n        'Public Price', related='list_price',\n        digits=dp.get_precision('Product Price'))\n    standard_price = fields.Float(\n        'Cost', compute='_compute_standard_price',\n        inverse='_set_standard_price', search='_search_standard_price',\n        digits=dp.get_precision('Product Price'), groups=\"base.group_user\",\n        help = \"Cost used for stock valuation in standard price and as a first price to set in average/fifo. \"\n               \"Also used as a base price for pricelists. \"\n               \"Expressed in the default unit of measure of the product. \")\n\n    volume = fields.Float(\n        'Volume', compute='_compute_volume', inverse='_set_volume',\n        help=\"The volume in m3.\", store=True)\n    weight = fields.Float(\n        'Weight', compute='_compute_weight', digits=dp.get_precision('Stock Weight'),\n        inverse='_set_weight', store=True,\n        help=\"The weight of the contents in Kg, not including any packaging, etc.\")\n\n    sale_ok = fields.Boolean(\n        'Can be Sold', default=True,\n        help=\"Specify if the product can be selected in a sales order line.\")\n    purchase_ok = fields.Boolean('Can be Purchased', default=True)\n    pricelist_id = fields.Many2one(\n        'product.pricelist', 'Pricelist', store=False,\n        help='Technical field. Used for searching on pricelists, not stored in database.')\n    uom_id = fields.Many2one(\n        'product.uom', 'Unit of Measure',\n        default=_get_default_uom_id, required=True,\n        help=\"Default Unit of Measure used for all stock operation.\")\n    uom_po_id = fields.Many2one(\n        'product.uom', 'Purchase Unit of Measure',\n        default=_get_default_uom_id, required=True,\n        help=\"Default Unit of Measure used for purchase orders. It must be in the same category than the default unit of measure.\")\n    company_id = fields.Many2one(\n        'res.company', 'Company',\n        default=lambda self: self.env['res.company']._company_default_get('product.template'), index=1)\n    packaging_ids = fields.One2many(\n        'product.packaging', string=\"Product Packages\", compute=\"_compute_packaging_ids\", inverse=\"_set_packaging_ids\",\n        help=\"Gives the different ways to package the same product.\")\n    seller_ids = fields.One2many('product.supplierinfo', 'product_tmpl_id', 'Vendors')\n    variant_seller_ids = fields.One2many('product.supplierinfo', 'product_tmpl_id')\n\n    active = fields.Boolean('Active', default=True, help=\"If unchecked, it will allow you to hide the product without removing it.\")\n    color = fields.Integer('Color Index')\n\n    is_product_variant = fields.Boolean(string='Is a product variant', compute='_compute_is_product_variant')\n    attribute_line_ids = fields.One2many('product.attribute.line', 'product_tmpl_id', 'Product Attributes')\n    product_variant_ids = fields.One2many('product.product', 'product_tmpl_id', 'Products', required=True)\n    \n    product_variant_id = fields.Many2one('product.product', 'Product', compute='_compute_product_variant_id')\n\n    product_variant_count = fields.Integer(\n        '# Product Variants', compute='_compute_product_variant_count')\n\n    \n    barcode = fields.Char('Barcode', oldname='ean13', related='product_variant_ids.barcode')\n    default_code = fields.Char(\n        'Internal Reference', compute='_compute_default_code',\n        inverse='_set_default_code', store=True)\n\n    item_ids = fields.One2many('product.pricelist.item', 'product_tmpl_id', 'Pricelist Items')\n\n    \n    image = fields.Binary(\n        \"Image\", attachment=True,\n        help=\"This field holds the image used as image for the product, limited to 1024x1024px.\")\n    image_medium = fields.Binary(\n        \"Medium-sized image\", attachment=True,\n        help=\"Medium-sized image of the product. It is automatically \"\n             \"resized as a 128x128px image, with aspect ratio preserved, \"\n             \"only when the image exceeds one of those sizes. Use this field in form views or some kanban views.\")\n    image_small = fields.Binary(\n        \"Small-sized image\", attachment=True,\n        help=\"Small-sized image of the product. It is automatically \"\n             \"resized as a 64x64px image, with aspect ratio preserved. \"\n             \"Use this field anywhere a small image is required.\")\n\n    @api.depends('product_variant_ids')\n    def _compute_product_variant_id(self):\n        for p in self:\n            p.product_variant_id = p.product_variant_ids[:1].id\n\n    @api.multi\n    def _compute_currency_id(self):\n        try:\n            main_company = self.sudo().env.ref('base.main_company')\n        except ValueError:\n            main_company = self.env['res.company'].sudo().search([], limit=1, order=\"id\")\n        for template in self:\n            template.currency_id = template.company_id.sudo().currency_id.id or main_company.currency_id.id\n\n    @api.multi\n    def _compute_template_price(self):\n        prices = {}\n        pricelist_id_or_name = self._context.get('pricelist')\n        if pricelist_id_or_name:\n            pricelist = None\n            partner = self._context.get('partner')\n            quantity = self._context.get('quantity', 1.0)\n\n            \n            if isinstance(pricelist_id_or_name, pycompat.string_types):\n                pricelist_data = self.env['product.pricelist'].name_search(pricelist_id_or_name, operator='=', limit=1)\n                if pricelist_data:\n                    pricelist = self.env['product.pricelist'].browse(pricelist_data[0][0])\n            elif isinstance(pricelist_id_or_name, pycompat.integer_types):\n                pricelist = self.env['product.pricelist'].browse(pricelist_id_or_name)\n\n            if pricelist:\n                quantities = [quantity] * len(self)\n                partners = [partner] * len(self)\n                prices = pricelist.get_products_price(self, quantities, partners)\n\n        for template in self:\n            template.price = prices.get(template.id, 0.0)\n\n    @api.multi\n    def _set_template_price(self):\n        if self._context.get('uom'):\n            for template in self:\n                value = self.env['product.uom'].browse(self._context['uom'])._compute_price(template.price, template.uom_id)\n                template.write({'list_price': value})\n        else:\n            self.write({'list_price': self.price})\n\n    @api.depends('product_variant_ids', 'product_variant_ids.standard_price')\n    def _compute_standard_price(self):\n        unique_variants = self.filtered(lambda template: len(template.product_variant_ids) == 1)\n        for template in unique_variants:\n            template.standard_price = template.product_variant_ids.standard_price\n        for template in (self - unique_variants):\n            template.standard_price = 0.0\n\n    @api.one\n    def _set_standard_price(self):\n        if len(self.product_variant_ids) == 1:\n            self.product_variant_ids.standard_price = self.standard_price\n\n    def _search_standard_price(self, operator, value):\n        products = self.env['product.product'].search([('standard_price', operator, value)], limit=None)\n        return [('id', 'in', products.mapped('product_tmpl_id').ids)]\n\n    @api.depends('product_variant_ids', 'product_variant_ids.volume')\n    def _compute_volume(self):\n        unique_variants = self.filtered(lambda template: len(template.product_variant_ids) == 1)\n        for template in unique_variants:\n            template.volume = template.product_variant_ids.volume\n        for template in (self - unique_variants):\n            template.volume = 0.0\n\n    @api.one\n    def _set_volume(self):\n        if len(self.product_variant_ids) == 1:\n            self.product_variant_ids.volume = self.volume\n\n    @api.depends('product_variant_ids', 'product_variant_ids.weight')\n    def _compute_weight(self):\n        unique_variants = self.filtered(lambda template: len(template.product_variant_ids) == 1)\n        for template in unique_variants:\n            template.weight = template.product_variant_ids.weight\n        for template in (self - unique_variants):\n            template.weight = 0.0\n\n    def _compute_is_product_variant(self):\n        for template in self:\n            if template._name == 'product.template':\n                template.is_product_variant = False\n            else:\n                template.is_product_variant = True\n\n    @api.one\n    def _set_weight(self):\n        if len(self.product_variant_ids) == 1:\n            self.product_variant_ids.weight = self.weight\n\n    @api.one\n    @api.depends('product_variant_ids.product_tmpl_id')\n    def _compute_product_variant_count(self):\n        self.product_variant_count = len(self.product_variant_ids)\n\n    @api.depends('product_variant_ids', 'product_variant_ids.default_code')\n    def _compute_default_code(self):\n        unique_variants = self.filtered(lambda template: len(template.product_variant_ids) == 1)\n        for template in unique_variants:\n            template.default_code = template.product_variant_ids.default_code\n        for template in (self - unique_variants):\n            template.default_code = ''\n\n    @api.one\n    def _set_default_code(self):\n        if len(self.product_variant_ids) == 1:\n            self.product_variant_ids.default_code = self.default_code\n\n    @api.depends('product_variant_ids', 'product_variant_ids.packaging_ids')\n    def _compute_packaging_ids(self):\n        for p in self:\n            if len(p.product_variant_ids) == 1:\n                p.packaging_ids = p.product_variant_ids.packaging_ids\n\n    def _set_packaging_ids(self):\n        for p in self:\n            if len(p.product_variant_ids) == 1:\n                p.product_variant_ids.packaging_ids = p.packaging_ids\n\n    @api.constrains('uom_id', 'uom_po_id')\n    def _check_uom(self):\n        if any(template.uom_id and template.uom_po_id and template.uom_id.category_id != template.uom_po_id.category_id for template in self):\n            raise ValidationError(_('Error: The default Unit of Measure and the purchase Unit of Measure must be in the same category.'))\n        return True\n\n    @api.onchange('uom_id')\n    def _onchange_uom_id(self):\n        if self.uom_id:\n            self.uom_po_id = self.uom_id.id\n\n    @api.model\n    def create(self, vals):\n        \n        \n        tools.image_resize_images(vals)\n        template = super(ProductTemplate, self).create(vals)\n        if \"create_product_product\" not in self._context:\n            template.with_context(create_from_tmpl=True).create_variant_ids()\n\n        \n        related_vals = {}\n        if vals.get('barcode'):\n            related_vals['barcode'] = vals['barcode']\n        if vals.get('default_code'):\n            related_vals['default_code'] = vals['default_code']\n        if vals.get('standard_price'):\n            related_vals['standard_price'] = vals['standard_price']\n        if vals.get('volume'):\n            related_vals['volume'] = vals['volume']\n        if vals.get('weight'):\n            related_vals['weight'] = vals['weight']\n        if related_vals:\n            template.write(related_vals)\n        return template\n\n    @api.multi\n    def write(self, vals):\n        tools.image_resize_images(vals)\n        res = super(ProductTemplate, self).write(vals)\n        if 'attribute_line_ids' in vals or vals.get('active'):\n            self.create_variant_ids()\n        if 'active' in vals and not vals.get('active'):\n            self.with_context(active_test=False).mapped('product_variant_ids').write({'active': vals.get('active')})\n        return res\n\n    @api.multi\n    def copy(self, default=None):\n        \n        self.ensure_one()\n        if default is None:\n            default = {}\n        if 'name' not in default:\n            default['name'] = _(\"%s (copy)\") % self.name\n        return super(ProductTemplate, self).copy(default=default)\n\n    @api.multi\n    def name_get(self):\n        return [(template.id, '%s%s' % (template.default_code and '[%s] ' % template.default_code or '', template.name))\n                for template in self]\n\n    @api.model\n    def name_search(self, name='', args=None, operator='ilike', limit=100):\n        \n        \n        if not name or any(term[0] == 'id' for term in (args or [])):\n            return super(ProductTemplate, self).name_search(name=name, args=args, operator=operator, limit=limit)\n\n        Product = self.env['product.product']\n        templates = self.browse([])\n        while True:\n            domain = templates and [('product_tmpl_id', 'not in', templates.ids)] or []\n            args = args if args is not None else []\n            products_ns = Product.name_search(name, args+domain, operator=operator)\n            products = Product.browse([x[0] for x in products_ns])\n            templates |= products.mapped('product_tmpl_id')\n            if (not products) or (limit and (len(templates) > limit)):\n                break\n\n        # re-apply product.template order + name_get\n        return super(ProductTemplate, self).name_search(\n            '', args=[('id', 'in', list(set(templates.ids)))],\n            operator='ilike', limit=limit)\n\n    @api.multi\n    def price_compute(self, price_type, uom=False, currency=False, company=False):\n        # TDE FIXME: delegate to template or not ? fields are reencoded here ...\n        \n        if not uom and self._context.get('uom'):\n            uom = self.env['product.uom'].browse(self._context['uom'])\n        if not currency and self._context.get('currency'):\n            currency = self.env['res.currency'].browse(self._context['currency'])\n\n        templates = self\n        if price_type == 'standard_price':\n            \n            \n            \n            templates = self.with_context(force_company=company and company.id or self._context.get('force_company', self.env.user.company_id.id)).sudo()\n\n        prices = dict.fromkeys(self.ids, 0.0)\n        for template in templates:\n            prices[template.id] = template[price_type] or 0.0\n\n            if uom:\n                prices[template.id] = template.uom_id._compute_price(prices[template.id], uom)\n\n            \n            \n            if currency:\n                prices[template.id] = template.currency_id.compute(prices[template.id], currency)\n\n        return prices\n\n    \n    @api.model\n    def _price_get(self, products, ptype='list_price'):\n        return products.price_compute(ptype)\n\n    @api.multi\n    def create_variant_ids(self):\n        Product = self.env[\"product.product\"]\n        AttributeValues = self.env['product.attribute.value']\n        for tmpl_id in self.with_context(active_test=False):\n            \n            \n            variant_alone = tmpl_id.attribute_line_ids.filtered(lambda line: line.attribute_id.create_variant and len(line.value_ids) == 1).mapped('value_ids')\n            for value_id in variant_alone:\n                updated_products = tmpl_id.product_variant_ids.filtered(lambda product: value_id.attribute_id not in product.mapped('attribute_value_ids.attribute_id'))\n                updated_products.write({'attribute_value_ids': [(4, value_id.id)]})\n\n            # iterator of n-uple of product.attribute.value *ids*\n            variant_matrix = [\n                AttributeValues.browse(value_ids)\n                for value_ids in itertools.product(*(line.value_ids.ids for line in tmpl_id.attribute_line_ids if line.value_ids[:1].attribute_id.create_variant))\n            ]\n\n            # get the value (id) sets of existing variants\n            existing_variants = {frozenset(variant.attribute_value_ids.filtered(lambda r: r.attribute_id.create_variant).ids) for variant in tmpl_id.product_variant_ids}\n            \n            \n            to_create_variants = [\n                value_ids\n                for value_ids in variant_matrix\n                if set(value_ids.ids) not in existing_variants\n            ]\n\n            \n            variants_to_activate = self.env['product.product']\n            variants_to_unlink = self.env['product.product']\n            for product_id in tmpl_id.product_variant_ids:\n                if not product_id.active and product_id.attribute_value_ids.filtered(lambda r: r.attribute_id.create_variant) in variant_matrix:\n                    variants_to_activate |= product_id\n                elif product_id.attribute_value_ids.filtered(lambda r: r.attribute_id.create_variant) not in variant_matrix:\n                    variants_to_unlink |= product_id\n            if variants_to_activate:\n                variants_to_activate.write({'active': True})\n\n            \n            for variant_ids in to_create_variants:\n                new_variant = Product.create({\n                    'product_tmpl_id': tmpl_id.id,\n                    'attribute_value_ids': [(6, 0, variant_ids.ids)]\n                })\n\n            \n            for variant in variants_to_unlink:\n                try:\n                    with self._cr.savepoint(), tools.mute_logger('odoo.sql_db'):\n                        variant.unlink()\n                \n                except (psycopg2.Error, except_orm):\n                    variant.write({'active': False})\n                    pass\n        return True\n", "comments": "    store initial standard price order able retrieve cost product template given date           coding  utf 8        part odoo  see license file full copyright licensing details     price fields    performance  product variant id provides prefetching first product variant    related display product product information product variant    image  image fields base64 encoded pil supported    support context pricelists specified display name id compatibility    tde fixme  context brol    this needed set given values first variant creation    tde fixme  probably copy data    only use product product heuristics search term domain    specify match  product template  ids     apply product template order   name get    tde fixme  delegate template   fields reencoded        compatibility context keys used bit everywhere code    standard price field seen users base group user    thus  order compute sale price cost users group    we fetch standard price superuser    convert current user company currency asked one    this right cause field cannot one currency    compatibility remove v10   deprecated    adding attribute one value recreate product    write attribute every product make sure lose    iterator n uple product attribute value  ids     get value (id) sets existing variants       value set  create recordset values create       variant value set already variant    check product    create new product    unlink inactive product    we catch kind exception sure operation fail  ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nimport itertools\nimport psycopg2\n\nfrom odoo.addons import decimal_precision as dp\n\nfrom odoo import api, fields, models, tools, _\nfrom odoo.exceptions import ValidationError, RedirectWarning, except_orm\nfrom odoo.tools import pycompat\n\n\nclass ProductTemplate(models.Model):\n    _name = \"product.template\"\n    _inherit = ['mail.thread', 'mail.activity.mixin']\n    _description = \"Product Template\"\n    _order = \"name\"\n\n    def _get_default_category_id(self):\n        if self._context.get('categ_id') or self._context.get('default_categ_id'):\n            return self._context.get('categ_id') or self._context.get('default_categ_id')\n        category = self.env.ref('product.product_category_all', raise_if_not_found=False)\n        if not category:\n            category = self.env['product.category'].search([], limit=1)\n        if category:\n            return category.id\n        else:\n            err_msg = _('You must define at least one product category in order to be able to create products.')\n            redir_msg = _('Go to Internal Categories')\n            raise RedirectWarning(err_msg, self.env.ref('product.product_category_action_form').id, redir_msg)\n\n    def _get_default_uom_id(self):\n        return self.env[\"product.uom\"].search([], limit=1, order='id').id\n\n    name = fields.Char('Name', index=True, required=True, translate=True)\n    sequence = fields.Integer('Sequence', default=1, help='Gives the sequence order when displaying a product list')\n    description = fields.Text(\n        'Description', translate=True,\n        help=\"A precise description of the Product, used only for internal information purposes.\")\n    description_purchase = fields.Text(\n        'Purchase Description', translate=True,\n        help=\"A description of the Product that you want to communicate to your vendors. \"\n             \"This description will be copied to every Purchase Order, Receipt and Vendor Bill/Credit Note.\")\n    description_sale = fields.Text(\n        'Sale Description', translate=True,\n        help=\"A description of the Product that you want to communicate to your customers. \"\n             \"This description will be copied to every Sales Order, Delivery Order and Customer Invoice/Credit Note\")\n    type = fields.Selection([\n        ('consu', _('Consumable')),\n        ('service', _('Service'))], string='Product Type', default='consu', required=True,\n        help='A stockable product is a product for which you manage stock. The \"Inventory\" app has to be installed.\\n'\n             'A consumable product, on the other hand, is a product for which stock is not managed.\\n'\n             'A service is a non-material product you provide.\\n'\n             'A digital content is a non-material product you sell online. The files attached to the products are the one that are sold on '\n             'the e-commerce such as e-books, music, pictures,... The \"Digital Product\" module has to be installed.')\n    rental = fields.Boolean('Can be Rent')\n    categ_id = fields.Many2one(\n        'product.category', 'Internal Category',\n        change_default=True, default=_get_default_category_id,\n        required=True, help=\"Select category for the current product\")\n\n    currency_id = fields.Many2one(\n        'res.currency', 'Currency', compute='_compute_currency_id')\n\n    # price fields\n    price = fields.Float(\n        'Price', compute='_compute_template_price', inverse='_set_template_price',\n        digits=dp.get_precision('Product Price'))\n    list_price = fields.Float(\n        'Sales Price', default=1.0,\n        digits=dp.get_precision('Product Price'),\n        help=\"Base price to compute the customer price. Sometimes called the catalog price.\")\n    lst_price = fields.Float(\n        'Public Price', related='list_price',\n        digits=dp.get_precision('Product Price'))\n    standard_price = fields.Float(\n        'Cost', compute='_compute_standard_price',\n        inverse='_set_standard_price', search='_search_standard_price',\n        digits=dp.get_precision('Product Price'), groups=\"base.group_user\",\n        help = \"Cost used for stock valuation in standard price and as a first price to set in average/fifo. \"\n               \"Also used as a base price for pricelists. \"\n               \"Expressed in the default unit of measure of the product. \")\n\n    volume = fields.Float(\n        'Volume', compute='_compute_volume', inverse='_set_volume',\n        help=\"The volume in m3.\", store=True)\n    weight = fields.Float(\n        'Weight', compute='_compute_weight', digits=dp.get_precision('Stock Weight'),\n        inverse='_set_weight', store=True,\n        help=\"The weight of the contents in Kg, not including any packaging, etc.\")\n\n    sale_ok = fields.Boolean(\n        'Can be Sold', default=True,\n        help=\"Specify if the product can be selected in a sales order line.\")\n    purchase_ok = fields.Boolean('Can be Purchased', default=True)\n    pricelist_id = fields.Many2one(\n        'product.pricelist', 'Pricelist', store=False,\n        help='Technical field. Used for searching on pricelists, not stored in database.')\n    uom_id = fields.Many2one(\n        'product.uom', 'Unit of Measure',\n        default=_get_default_uom_id, required=True,\n        help=\"Default Unit of Measure used for all stock operation.\")\n    uom_po_id = fields.Many2one(\n        'product.uom', 'Purchase Unit of Measure',\n        default=_get_default_uom_id, required=True,\n        help=\"Default Unit of Measure used for purchase orders. It must be in the same category than the default unit of measure.\")\n    company_id = fields.Many2one(\n        'res.company', 'Company',\n        default=lambda self: self.env['res.company']._company_default_get('product.template'), index=1)\n    packaging_ids = fields.One2many(\n        'product.packaging', string=\"Product Packages\", compute=\"_compute_packaging_ids\", inverse=\"_set_packaging_ids\",\n        help=\"Gives the different ways to package the same product.\")\n    seller_ids = fields.One2many('product.supplierinfo', 'product_tmpl_id', 'Vendors')\n    variant_seller_ids = fields.One2many('product.supplierinfo', 'product_tmpl_id')\n\n    active = fields.Boolean('Active', default=True, help=\"If unchecked, it will allow you to hide the product without removing it.\")\n    color = fields.Integer('Color Index')\n\n    is_product_variant = fields.Boolean(string='Is a product variant', compute='_compute_is_product_variant')\n    attribute_line_ids = fields.One2many('product.attribute.line', 'product_tmpl_id', 'Product Attributes')\n    product_variant_ids = fields.One2many('product.product', 'product_tmpl_id', 'Products', required=True)\n    # performance: product_variant_id provides prefetching on the first product variant only\n    product_variant_id = fields.Many2one('product.product', 'Product', compute='_compute_product_variant_id')\n\n    product_variant_count = fields.Integer(\n        '# Product Variants', compute='_compute_product_variant_count')\n\n    # related to display product product information if is_product_variant\n    barcode = fields.Char('Barcode', oldname='ean13', related='product_variant_ids.barcode')\n    default_code = fields.Char(\n        'Internal Reference', compute='_compute_default_code',\n        inverse='_set_default_code', store=True)\n\n    item_ids = fields.One2many('product.pricelist.item', 'product_tmpl_id', 'Pricelist Items')\n\n    # image: all image fields are base64 encoded and PIL-supported\n    image = fields.Binary(\n        \"Image\", attachment=True,\n        help=\"This field holds the image used as image for the product, limited to 1024x1024px.\")\n    image_medium = fields.Binary(\n        \"Medium-sized image\", attachment=True,\n        help=\"Medium-sized image of the product. It is automatically \"\n             \"resized as a 128x128px image, with aspect ratio preserved, \"\n             \"only when the image exceeds one of those sizes. Use this field in form views or some kanban views.\")\n    image_small = fields.Binary(\n        \"Small-sized image\", attachment=True,\n        help=\"Small-sized image of the product. It is automatically \"\n             \"resized as a 64x64px image, with aspect ratio preserved. \"\n             \"Use this field anywhere a small image is required.\")\n\n    @api.depends('product_variant_ids')\n    def _compute_product_variant_id(self):\n        for p in self:\n            p.product_variant_id = p.product_variant_ids[:1].id\n\n    @api.multi\n    def _compute_currency_id(self):\n        try:\n            main_company = self.sudo().env.ref('base.main_company')\n        except ValueError:\n            main_company = self.env['res.company'].sudo().search([], limit=1, order=\"id\")\n        for template in self:\n            template.currency_id = template.company_id.sudo().currency_id.id or main_company.currency_id.id\n\n    @api.multi\n    def _compute_template_price(self):\n        prices = {}\n        pricelist_id_or_name = self._context.get('pricelist')\n        if pricelist_id_or_name:\n            pricelist = None\n            partner = self._context.get('partner')\n            quantity = self._context.get('quantity', 1.0)\n\n            # Support context pricelists specified as display_name or ID for compatibility\n            if isinstance(pricelist_id_or_name, pycompat.string_types):\n                pricelist_data = self.env['product.pricelist'].name_search(pricelist_id_or_name, operator='=', limit=1)\n                if pricelist_data:\n                    pricelist = self.env['product.pricelist'].browse(pricelist_data[0][0])\n            elif isinstance(pricelist_id_or_name, pycompat.integer_types):\n                pricelist = self.env['product.pricelist'].browse(pricelist_id_or_name)\n\n            if pricelist:\n                quantities = [quantity] * len(self)\n                partners = [partner] * len(self)\n                prices = pricelist.get_products_price(self, quantities, partners)\n\n        for template in self:\n            template.price = prices.get(template.id, 0.0)\n\n    @api.multi\n    def _set_template_price(self):\n        if self._context.get('uom'):\n            for template in self:\n                value = self.env['product.uom'].browse(self._context['uom'])._compute_price(template.price, template.uom_id)\n                template.write({'list_price': value})\n        else:\n            self.write({'list_price': self.price})\n\n    @api.depends('product_variant_ids', 'product_variant_ids.standard_price')\n    def _compute_standard_price(self):\n        unique_variants = self.filtered(lambda template: len(template.product_variant_ids) == 1)\n        for template in unique_variants:\n            template.standard_price = template.product_variant_ids.standard_price\n        for template in (self - unique_variants):\n            template.standard_price = 0.0\n\n    @api.one\n    def _set_standard_price(self):\n        if len(self.product_variant_ids) == 1:\n            self.product_variant_ids.standard_price = self.standard_price\n\n    def _search_standard_price(self, operator, value):\n        products = self.env['product.product'].search([('standard_price', operator, value)], limit=None)\n        return [('id', 'in', products.mapped('product_tmpl_id').ids)]\n\n    @api.depends('product_variant_ids', 'product_variant_ids.volume')\n    def _compute_volume(self):\n        unique_variants = self.filtered(lambda template: len(template.product_variant_ids) == 1)\n        for template in unique_variants:\n            template.volume = template.product_variant_ids.volume\n        for template in (self - unique_variants):\n            template.volume = 0.0\n\n    @api.one\n    def _set_volume(self):\n        if len(self.product_variant_ids) == 1:\n            self.product_variant_ids.volume = self.volume\n\n    @api.depends('product_variant_ids', 'product_variant_ids.weight')\n    def _compute_weight(self):\n        unique_variants = self.filtered(lambda template: len(template.product_variant_ids) == 1)\n        for template in unique_variants:\n            template.weight = template.product_variant_ids.weight\n        for template in (self - unique_variants):\n            template.weight = 0.0\n\n    def _compute_is_product_variant(self):\n        for template in self:\n            if template._name == 'product.template':\n                template.is_product_variant = False\n            else:\n                template.is_product_variant = True\n\n    @api.one\n    def _set_weight(self):\n        if len(self.product_variant_ids) == 1:\n            self.product_variant_ids.weight = self.weight\n\n    @api.one\n    @api.depends('product_variant_ids.product_tmpl_id')\n    def _compute_product_variant_count(self):\n        self.product_variant_count = len(self.product_variant_ids)\n\n    @api.depends('product_variant_ids', 'product_variant_ids.default_code')\n    def _compute_default_code(self):\n        unique_variants = self.filtered(lambda template: len(template.product_variant_ids) == 1)\n        for template in unique_variants:\n            template.default_code = template.product_variant_ids.default_code\n        for template in (self - unique_variants):\n            template.default_code = ''\n\n    @api.one\n    def _set_default_code(self):\n        if len(self.product_variant_ids) == 1:\n            self.product_variant_ids.default_code = self.default_code\n\n    @api.depends('product_variant_ids', 'product_variant_ids.packaging_ids')\n    def _compute_packaging_ids(self):\n        for p in self:\n            if len(p.product_variant_ids) == 1:\n                p.packaging_ids = p.product_variant_ids.packaging_ids\n\n    def _set_packaging_ids(self):\n        for p in self:\n            if len(p.product_variant_ids) == 1:\n                p.product_variant_ids.packaging_ids = p.packaging_ids\n\n    @api.constrains('uom_id', 'uom_po_id')\n    def _check_uom(self):\n        if any(template.uom_id and template.uom_po_id and template.uom_id.category_id != template.uom_po_id.category_id for template in self):\n            raise ValidationError(_('Error: The default Unit of Measure and the purchase Unit of Measure must be in the same category.'))\n        return True\n\n    @api.onchange('uom_id')\n    def _onchange_uom_id(self):\n        if self.uom_id:\n            self.uom_po_id = self.uom_id.id\n\n    @api.model\n    def create(self, vals):\n        ''' Store the initial standard price in order to be able to retrieve the cost of a product template for a given date'''\n        # TDE FIXME: context brol\n        tools.image_resize_images(vals)\n        template = super(ProductTemplate, self).create(vals)\n        if \"create_product_product\" not in self._context:\n            template.with_context(create_from_tmpl=True).create_variant_ids()\n\n        # This is needed to set given values to first variant after creation\n        related_vals = {}\n        if vals.get('barcode'):\n            related_vals['barcode'] = vals['barcode']\n        if vals.get('default_code'):\n            related_vals['default_code'] = vals['default_code']\n        if vals.get('standard_price'):\n            related_vals['standard_price'] = vals['standard_price']\n        if vals.get('volume'):\n            related_vals['volume'] = vals['volume']\n        if vals.get('weight'):\n            related_vals['weight'] = vals['weight']\n        if related_vals:\n            template.write(related_vals)\n        return template\n\n    @api.multi\n    def write(self, vals):\n        tools.image_resize_images(vals)\n        res = super(ProductTemplate, self).write(vals)\n        if 'attribute_line_ids' in vals or vals.get('active'):\n            self.create_variant_ids()\n        if 'active' in vals and not vals.get('active'):\n            self.with_context(active_test=False).mapped('product_variant_ids').write({'active': vals.get('active')})\n        return res\n\n    @api.multi\n    def copy(self, default=None):\n        # TDE FIXME: should probably be copy_data\n        self.ensure_one()\n        if default is None:\n            default = {}\n        if 'name' not in default:\n            default['name'] = _(\"%s (copy)\") % self.name\n        return super(ProductTemplate, self).copy(default=default)\n\n    @api.multi\n    def name_get(self):\n        return [(template.id, '%s%s' % (template.default_code and '[%s] ' % template.default_code or '', template.name))\n                for template in self]\n\n    @api.model\n    def name_search(self, name='', args=None, operator='ilike', limit=100):\n        # Only use the product.product heuristics if there is a search term and the domain\n        # does not specify a match on `product.template` IDs.\n        if not name or any(term[0] == 'id' for term in (args or [])):\n            return super(ProductTemplate, self).name_search(name=name, args=args, operator=operator, limit=limit)\n\n        Product = self.env['product.product']\n        templates = self.browse([])\n        while True:\n            domain = templates and [('product_tmpl_id', 'not in', templates.ids)] or []\n            args = args if args is not None else []\n            products_ns = Product.name_search(name, args+domain, operator=operator)\n            products = Product.browse([x[0] for x in products_ns])\n            templates |= products.mapped('product_tmpl_id')\n            if (not products) or (limit and (len(templates) > limit)):\n                break\n\n        # re-apply product.template order + name_get\n        return super(ProductTemplate, self).name_search(\n            '', args=[('id', 'in', list(set(templates.ids)))],\n            operator='ilike', limit=limit)\n\n    @api.multi\n    def price_compute(self, price_type, uom=False, currency=False, company=False):\n        # TDE FIXME: delegate to template or not ? fields are reencoded here ...\n        # compatibility about context keys used a bit everywhere in the code\n        if not uom and self._context.get('uom'):\n            uom = self.env['product.uom'].browse(self._context['uom'])\n        if not currency and self._context.get('currency'):\n            currency = self.env['res.currency'].browse(self._context['currency'])\n\n        templates = self\n        if price_type == 'standard_price':\n            # standard_price field can only be seen by users in base.group_user\n            # Thus, in order to compute the sale price from the cost for users not in this group\n            # We fetch the standard price as the superuser\n            templates = self.with_context(force_company=company and company.id or self._context.get('force_company', self.env.user.company_id.id)).sudo()\n\n        prices = dict.fromkeys(self.ids, 0.0)\n        for template in templates:\n            prices[template.id] = template[price_type] or 0.0\n\n            if uom:\n                prices[template.id] = template.uom_id._compute_price(prices[template.id], uom)\n\n            # Convert from current user company currency to asked one\n            # This is right cause a field cannot be in more than one currency\n            if currency:\n                prices[template.id] = template.currency_id.compute(prices[template.id], currency)\n\n        return prices\n\n    # compatibility to remove after v10 - DEPRECATED\n    @api.model\n    def _price_get(self, products, ptype='list_price'):\n        return products.price_compute(ptype)\n\n    @api.multi\n    def create_variant_ids(self):\n        Product = self.env[\"product.product\"]\n        AttributeValues = self.env['product.attribute.value']\n        for tmpl_id in self.with_context(active_test=False):\n            # adding an attribute with only one value should not recreate product\n            # write this attribute on every product to make sure we don't lose them\n            variant_alone = tmpl_id.attribute_line_ids.filtered(lambda line: line.attribute_id.create_variant and len(line.value_ids) == 1).mapped('value_ids')\n            for value_id in variant_alone:\n                updated_products = tmpl_id.product_variant_ids.filtered(lambda product: value_id.attribute_id not in product.mapped('attribute_value_ids.attribute_id'))\n                updated_products.write({'attribute_value_ids': [(4, value_id.id)]})\n\n            # iterator of n-uple of product.attribute.value *ids*\n            variant_matrix = [\n                AttributeValues.browse(value_ids)\n                for value_ids in itertools.product(*(line.value_ids.ids for line in tmpl_id.attribute_line_ids if line.value_ids[:1].attribute_id.create_variant))\n            ]\n\n            # get the value (id) sets of existing variants\n            existing_variants = {frozenset(variant.attribute_value_ids.filtered(lambda r: r.attribute_id.create_variant).ids) for variant in tmpl_id.product_variant_ids}\n            # -> for each value set, create a recordset of values to create a\n            #    variant for if the value set isn't already a variant\n            to_create_variants = [\n                value_ids\n                for value_ids in variant_matrix\n                if set(value_ids.ids) not in existing_variants\n            ]\n\n            # check product\n            variants_to_activate = self.env['product.product']\n            variants_to_unlink = self.env['product.product']\n            for product_id in tmpl_id.product_variant_ids:\n                if not product_id.active and product_id.attribute_value_ids.filtered(lambda r: r.attribute_id.create_variant) in variant_matrix:\n                    variants_to_activate |= product_id\n                elif product_id.attribute_value_ids.filtered(lambda r: r.attribute_id.create_variant) not in variant_matrix:\n                    variants_to_unlink |= product_id\n            if variants_to_activate:\n                variants_to_activate.write({'active': True})\n\n            # create new product\n            for variant_ids in to_create_variants:\n                new_variant = Product.create({\n                    'product_tmpl_id': tmpl_id.id,\n                    'attribute_value_ids': [(6, 0, variant_ids.ids)]\n                })\n\n            # unlink or inactive product\n            for variant in variants_to_unlink:\n                try:\n                    with self._cr.savepoint(), tools.mute_logger('odoo.sql_db'):\n                        variant.unlink()\n                # We catch all kind of exception to be sure that the operation doesn't fail.\n                except (psycopg2.Error, except_orm):\n                    variant.write({'active': False})\n                    pass\n        return True\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "product_template.py", "id": "9a9bdf4ceecea7de820ba469d972451e", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/product/models/product_template.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}