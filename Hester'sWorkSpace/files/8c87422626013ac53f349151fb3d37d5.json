{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    ExtractorError,\n    clean_html,\n    compat_str,\n    float_or_none,\n    int_or_none,\n    parse_iso8601,\n    try_get,\n    urljoin,\n)\n\n\nclass BeamProBaseIE(InfoExtractor):\n    _API_BASE = 'https://mixer.com/api/v1'\n    _RATINGS = {'family': 0, 'teen': 13, '18+': 18}\n\n    def _extract_channel_info(self, chan):\n        user_id = chan.get('userId') or try_get(chan, lambda x: x['user']['id'])\n        return {\n            'uploader': chan.get('token') or try_get(\n                chan, lambda x: x['user']['username'], compat_str),\n            'uploader_id': compat_str(user_id) if user_id else None,\n            'age_limit': self._RATINGS.get(chan.get('audience')),\n        }\n\n\nclass BeamProLiveIE(BeamProBaseIE):\n    IE_NAME = 'Mixer:live'\n    _VALID_URL = r'https?://(?:\\w+\\.)?(?:beam\\.pro|mixer\\.com)/(?P<id>[^/?\n    _TEST = {\n        'url': 'http://mixer.com/niterhayven',\n        'info_dict': {\n            'id': '261562',\n            'ext': 'mp4',\n            'title': 'Introducing The Witcher 3 //  The Grind Starts Now!',\n            'description': 'md5:0b161ac080f15fe05d18a07adb44a74d',\n            'thumbnail': r're:https://.*\\.jpg$',\n            'timestamp': 1483477281,\n            'upload_date': '20170103',\n            'uploader': 'niterhayven',\n            'uploader_id': '373396',\n            'age_limit': 18,\n            'is_live': True,\n            'view_count': int,\n        },\n        'skip': 'niterhayven is offline',\n        'params': {\n            'skip_download': True,\n        },\n    }\n\n    _MANIFEST_URL_TEMPLATE = '%s/channels/%%s/manifest.%%s' % BeamProBaseIE._API_BASE\n\n    @classmethod\n    def suitable(cls, url):\n        return False if BeamProVodIE.suitable(url) else super(BeamProLiveIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_name = self._match_id(url)\n\n        chan = self._download_json(\n            '%s/channels/%s' % (self._API_BASE, channel_name), channel_name)\n\n        if chan.get('online') is False:\n            raise ExtractorError(\n                '{0} is offline'.format(channel_name), expected=True)\n\n        channel_id = chan['id']\n\n        def manifest_url(kind):\n            return self._MANIFEST_URL_TEMPLATE % (channel_id, kind)\n\n        formats = self._extract_m3u8_formats(\n            manifest_url('m3u8'), channel_name, ext='mp4', m3u8_id='hls',\n            fatal=False)\n        formats.extend(self._extract_smil_formats(\n            manifest_url('smil'), channel_name, fatal=False))\n        self._sort_formats(formats)\n\n        info = {\n            'id': compat_str(chan.get('id') or channel_name),\n            'title': self._live_title(chan.get('name') or channel_name),\n            'description': clean_html(chan.get('description')),\n            'thumbnail': try_get(\n                chan, lambda x: x['thumbnail']['url'], compat_str),\n            'timestamp': parse_iso8601(chan.get('updatedAt')),\n            'is_live': True,\n            'view_count': int_or_none(chan.get('viewersTotal')),\n            'formats': formats,\n        }\n        info.update(self._extract_channel_info(chan))\n\n        return info\n\n\nclass BeamProVodIE(BeamProBaseIE):\n    IE_NAME = 'Mixer:vod'\n    _VALID_URL = r'https?://(?:\\w+\\.)?(?:beam\\.pro|mixer\\.com)/[^/?\n    _TEST = {\n        'url': 'https://mixer.com/willow8714?vod=2259830',\n        'md5': 'b2431e6e8347dc92ebafb565d368b76b',\n        'info_dict': {\n            'id': '2259830',\n            'ext': 'mp4',\n            'title': 'willow8714\\'s Channel',\n            'duration': 6828.15,\n            'thumbnail': r're:https://.*source\\.png$',\n            'timestamp': 1494046474,\n            'upload_date': '20170506',\n            'uploader': 'willow8714',\n            'uploader_id': '6085379',\n            'age_limit': 13,\n            'view_count': int,\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }\n\n    @staticmethod\n    def _extract_format(vod, vod_type):\n        if not vod.get('baseUrl'):\n            return []\n\n        if vod_type == 'hls':\n            filename, protocol = 'manifest.m3u8', 'm3u8_native'\n        elif vod_type == 'raw':\n            filename, protocol = 'source.mp4', 'https'\n        else:\n            assert False\n\n        data = vod.get('data') if isinstance(vod.get('data'), dict) else {}\n\n        format_id = [vod_type]\n        if isinstance(data.get('Height'), compat_str):\n            format_id.append('%sp' % data['Height'])\n\n        return [{\n            'url': urljoin(vod['baseUrl'], filename),\n            'format_id': '-'.join(format_id),\n            'ext': 'mp4',\n            'protocol': protocol,\n            'width': int_or_none(data.get('Width')),\n            'height': int_or_none(data.get('Height')),\n            'fps': int_or_none(data.get('Fps')),\n            'tbr': int_or_none(data.get('Bitrate'), 1000),\n        }]\n\n    def _real_extract(self, url):\n        vod_id = self._match_id(url)\n\n        vod_info = self._download_json(\n            '%s/recordings/%s' % (self._API_BASE, vod_id), vod_id)\n\n        state = vod_info.get('state')\n        if state != 'AVAILABLE':\n            raise ExtractorError(\n                'VOD %s is not available (state: %s)' % (vod_id, state),\n                expected=True)\n\n        formats = []\n        thumbnail_url = None\n\n        for vod in vod_info['vods']:\n            vod_type = vod.get('format')\n            if vod_type in ('hls', 'raw'):\n                formats.extend(self._extract_format(vod, vod_type))\n            elif vod_type == 'thumbnail':\n                thumbnail_url = urljoin(vod.get('baseUrl'), 'source.png')\n\n        self._sort_formats(formats)\n\n        info = {\n            'id': vod_id,\n            'title': vod_info.get('name') or vod_id,\n            'duration': float_or_none(vod_info.get('duration')),\n            'thumbnail': thumbnail_url,\n            'timestamp': parse_iso8601(vod_info.get('createdAt')),\n            'view_count': int_or_none(vod_info.get('viewsTotal')),\n            'formats': formats,\n        }\n        info.update(self._extract_channel_info(vod_info.get('channel') or {}))\n\n        return info\n", "comments": "# coding: utf-8\n#&]+)'\n#&]+\\?.*?\\bvod=(?P<id>\\d+)'\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    ExtractorError,\n    clean_html,\n    compat_str,\n    float_or_none,\n    int_or_none,\n    parse_iso8601,\n    try_get,\n    urljoin,\n)\n\n\nclass BeamProBaseIE(InfoExtractor):\n    _API_BASE = 'https://mixer.com/api/v1'\n    _RATINGS = {'family': 0, 'teen': 13, '18+': 18}\n\n    def _extract_channel_info(self, chan):\n        user_id = chan.get('userId') or try_get(chan, lambda x: x['user']['id'])\n        return {\n            'uploader': chan.get('token') or try_get(\n                chan, lambda x: x['user']['username'], compat_str),\n            'uploader_id': compat_str(user_id) if user_id else None,\n            'age_limit': self._RATINGS.get(chan.get('audience')),\n        }\n\n\nclass BeamProLiveIE(BeamProBaseIE):\n    IE_NAME = 'Mixer:live'\n    _VALID_URL = r'https?://(?:\\w+\\.)?(?:beam\\.pro|mixer\\.com)/(?P<id>[^/?#&]+)'\n    _TEST = {\n        'url': 'http://mixer.com/niterhayven',\n        'info_dict': {\n            'id': '261562',\n            'ext': 'mp4',\n            'title': 'Introducing The Witcher 3 //  The Grind Starts Now!',\n            'description': 'md5:0b161ac080f15fe05d18a07adb44a74d',\n            'thumbnail': r're:https://.*\\.jpg$',\n            'timestamp': 1483477281,\n            'upload_date': '20170103',\n            'uploader': 'niterhayven',\n            'uploader_id': '373396',\n            'age_limit': 18,\n            'is_live': True,\n            'view_count': int,\n        },\n        'skip': 'niterhayven is offline',\n        'params': {\n            'skip_download': True,\n        },\n    }\n\n    _MANIFEST_URL_TEMPLATE = '%s/channels/%%s/manifest.%%s' % BeamProBaseIE._API_BASE\n\n    @classmethod\n    def suitable(cls, url):\n        return False if BeamProVodIE.suitable(url) else super(BeamProLiveIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_name = self._match_id(url)\n\n        chan = self._download_json(\n            '%s/channels/%s' % (self._API_BASE, channel_name), channel_name)\n\n        if chan.get('online') is False:\n            raise ExtractorError(\n                '{0} is offline'.format(channel_name), expected=True)\n\n        channel_id = chan['id']\n\n        def manifest_url(kind):\n            return self._MANIFEST_URL_TEMPLATE % (channel_id, kind)\n\n        formats = self._extract_m3u8_formats(\n            manifest_url('m3u8'), channel_name, ext='mp4', m3u8_id='hls',\n            fatal=False)\n        formats.extend(self._extract_smil_formats(\n            manifest_url('smil'), channel_name, fatal=False))\n        self._sort_formats(formats)\n\n        info = {\n            'id': compat_str(chan.get('id') or channel_name),\n            'title': self._live_title(chan.get('name') or channel_name),\n            'description': clean_html(chan.get('description')),\n            'thumbnail': try_get(\n                chan, lambda x: x['thumbnail']['url'], compat_str),\n            'timestamp': parse_iso8601(chan.get('updatedAt')),\n            'is_live': True,\n            'view_count': int_or_none(chan.get('viewersTotal')),\n            'formats': formats,\n        }\n        info.update(self._extract_channel_info(chan))\n\n        return info\n\n\nclass BeamProVodIE(BeamProBaseIE):\n    IE_NAME = 'Mixer:vod'\n    _VALID_URL = r'https?://(?:\\w+\\.)?(?:beam\\.pro|mixer\\.com)/[^/?#&]+\\?.*?\\bvod=(?P<id>\\d+)'\n    _TEST = {\n        'url': 'https://mixer.com/willow8714?vod=2259830',\n        'md5': 'b2431e6e8347dc92ebafb565d368b76b',\n        'info_dict': {\n            'id': '2259830',\n            'ext': 'mp4',\n            'title': 'willow8714\\'s Channel',\n            'duration': 6828.15,\n            'thumbnail': r're:https://.*source\\.png$',\n            'timestamp': 1494046474,\n            'upload_date': '20170506',\n            'uploader': 'willow8714',\n            'uploader_id': '6085379',\n            'age_limit': 13,\n            'view_count': int,\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }\n\n    @staticmethod\n    def _extract_format(vod, vod_type):\n        if not vod.get('baseUrl'):\n            return []\n\n        if vod_type == 'hls':\n            filename, protocol = 'manifest.m3u8', 'm3u8_native'\n        elif vod_type == 'raw':\n            filename, protocol = 'source.mp4', 'https'\n        else:\n            assert False\n\n        data = vod.get('data') if isinstance(vod.get('data'), dict) else {}\n\n        format_id = [vod_type]\n        if isinstance(data.get('Height'), compat_str):\n            format_id.append('%sp' % data['Height'])\n\n        return [{\n            'url': urljoin(vod['baseUrl'], filename),\n            'format_id': '-'.join(format_id),\n            'ext': 'mp4',\n            'protocol': protocol,\n            'width': int_or_none(data.get('Width')),\n            'height': int_or_none(data.get('Height')),\n            'fps': int_or_none(data.get('Fps')),\n            'tbr': int_or_none(data.get('Bitrate'), 1000),\n        }]\n\n    def _real_extract(self, url):\n        vod_id = self._match_id(url)\n\n        vod_info = self._download_json(\n            '%s/recordings/%s' % (self._API_BASE, vod_id), vod_id)\n\n        state = vod_info.get('state')\n        if state != 'AVAILABLE':\n            raise ExtractorError(\n                'VOD %s is not available (state: %s)' % (vod_id, state),\n                expected=True)\n\n        formats = []\n        thumbnail_url = None\n\n        for vod in vod_info['vods']:\n            vod_type = vod.get('format')\n            if vod_type in ('hls', 'raw'):\n                formats.extend(self._extract_format(vod, vod_type))\n            elif vod_type == 'thumbnail':\n                thumbnail_url = urljoin(vod.get('baseUrl'), 'source.png')\n\n        self._sort_formats(formats)\n\n        info = {\n            'id': vod_id,\n            'title': vod_info.get('name') or vod_id,\n            'duration': float_or_none(vod_info.get('duration')),\n            'thumbnail': thumbnail_url,\n            'timestamp': parse_iso8601(vod_info.get('createdAt')),\n            'view_count': int_or_none(vod_info.get('viewsTotal')),\n            'formats': formats,\n        }\n        info.update(self._extract_channel_info(vod_info.get('channel') or {}))\n\n        return info\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "beampro.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/beampro.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}