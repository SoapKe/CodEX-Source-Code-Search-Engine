{"author": "eliangcs", "code": "\"\"\"Functions that deal with the user configuration.\"\"\"\n\nimport os\nimport shutil\n\nimport six\n\nfrom . import defaultconfig\nfrom . import xdg\n\n\ndef get_user_config_path():\n    \"\"\"Get the path to the user config file.\"\"\"\n    return os.path.join(xdg.get_config_dir(), 'config.py')\n\n\ndef initialize():\n    \"\"\"Initialize a default config file if it doesn't exist yet.\n\n    Returns:\n        tuple: A tuple of (copied, dst_path). `copied` is a bool indicating if\n            this function created the default config file. `dst_path` is the\n            path of the user config file.\n    \"\"\"\n    dst_path = get_user_config_path()\n    copied = False\n    if not os.path.exists(dst_path):\n        src_path = os.path.join(os.path.dirname(__file__), 'defaultconfig.py')\n        shutil.copyfile(src_path, dst_path)\n        copied = True\n    return copied, dst_path\n\n\ndef _module_to_dict(module):\n    attrs = {}\n    attr_names = filter(lambda n: not n.startswith('_'), dir(module))\n    for name in attr_names:\n        value = getattr(module, name)\n        attrs[name] = value\n    return attrs\n\n\ndef load_default():\n    \"\"\"Return default config as a dict.\"\"\"\n    return _module_to_dict(defaultconfig)\n\n\ndef load_user():\n    \"\"\"Read user config file and return it as a dict.\"\"\"\n    config_path = get_user_config_path()\n    config = {}\n\n    \n    with open(config_path) as f:\n        code = compile(f.read(), config_path, 'exec')\n    exec(code, config)\n\n    keys = list(six.iterkeys(config))\n    for k in keys:\n        if k.startswith('_'):\n            del config[k]\n\n    return config\n\n\ndef load():\n    \"\"\"Read default and user config files and return them as a dict.\"\"\"\n    config = load_default()\n    config.update(load_user())\n    return config\n", "comments": "   functions deal user configuration      import os import shutil  import six    import defaultconfig   import xdg   def get user config path()         get path user config file         return os path join(xdg get config dir()   config py )   def initialize()         initialize default config file exist yet       returns          tuple  a tuple (copied  dst path)   copied  bool indicating             function created default config file   dst path              path user config file              dst path   get user config path()     copied   false     os path exists(dst path)          src path   os path join(os path dirname(  file  )   defaultconfig py )         shutil copyfile(src path  dst path)         copied   true     return copied  dst path   def  module dict(module)      attrs          attr names   filter(lambda n  n startswith(   )  dir(module))     name attr names          value   getattr(module  name)         attrs name    value     return attrs   def load default()         return default config dict         return  module dict(defaultconfig)   def load user()         read user config file return dict         config path   get user config path()     config             todo  this may overkill slow reading config file     open(config path) f          code   compile(f read()  config path   exec )     exec(code  config)      keys   list(six iterkeys(config))     k keys          k startswith(   )              del config k       return config   def load()         read default user config files return dict        todo  this may overkill slow reading config file ", "content": "\"\"\"Functions that deal with the user configuration.\"\"\"\n\nimport os\nimport shutil\n\nimport six\n\nfrom . import defaultconfig\nfrom . import xdg\n\n\ndef get_user_config_path():\n    \"\"\"Get the path to the user config file.\"\"\"\n    return os.path.join(xdg.get_config_dir(), 'config.py')\n\n\ndef initialize():\n    \"\"\"Initialize a default config file if it doesn't exist yet.\n\n    Returns:\n        tuple: A tuple of (copied, dst_path). `copied` is a bool indicating if\n            this function created the default config file. `dst_path` is the\n            path of the user config file.\n    \"\"\"\n    dst_path = get_user_config_path()\n    copied = False\n    if not os.path.exists(dst_path):\n        src_path = os.path.join(os.path.dirname(__file__), 'defaultconfig.py')\n        shutil.copyfile(src_path, dst_path)\n        copied = True\n    return copied, dst_path\n\n\ndef _module_to_dict(module):\n    attrs = {}\n    attr_names = filter(lambda n: not n.startswith('_'), dir(module))\n    for name in attr_names:\n        value = getattr(module, name)\n        attrs[name] = value\n    return attrs\n\n\ndef load_default():\n    \"\"\"Return default config as a dict.\"\"\"\n    return _module_to_dict(defaultconfig)\n\n\ndef load_user():\n    \"\"\"Read user config file and return it as a dict.\"\"\"\n    config_path = get_user_config_path()\n    config = {}\n\n    # TODO: This may be overkill and too slow just for reading a config file\n    with open(config_path) as f:\n        code = compile(f.read(), config_path, 'exec')\n    exec(code, config)\n\n    keys = list(six.iterkeys(config))\n    for k in keys:\n        if k.startswith('_'):\n            del config[k]\n\n    return config\n\n\ndef load():\n    \"\"\"Read default and user config files and return them as a dict.\"\"\"\n    config = load_default()\n    config.update(load_user())\n    return config\n", "description": "HTTPie + prompt_toolkit = an interactive command-line HTTP client featuring autocomplete and syntax highlighting", "file_name": "config.py", "id": "a100829d1c448130f371598e272441d5", "language": "Python", "project_name": "http-prompt", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/eliangcs-http-prompt/eliangcs-http-prompt-87f1e9d/http_prompt/config.py", "save_time": "", "source": "", "update_at": "2018-03-17T18:26:33Z", "url": "https://github.com/eliangcs/http-prompt", "wiki": true}