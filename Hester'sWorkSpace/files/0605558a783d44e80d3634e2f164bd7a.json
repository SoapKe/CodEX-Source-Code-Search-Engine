{"author": "aws", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\"). You\n may not use this file except in compliance with the License. A copy of\n the License is located at\n\n     http://aws.amazon.com/apache2.0/\n\n or in the \"license\" file accompanying this file. This file is\n distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n ANY KIND, either express or implied. See the License for the specific\n language governing permissions and limitations under the License.\nfrom awscli.testutils import unittest, skip_if_windows, FileCreator\nimport signal\nimport platform\nimport json\nimport sys\nimport os\n\nimport mock\n\nfrom awscli.compat import six\nfrom awscli.help import PosixHelpRenderer, ExecutableNotFoundError\nfrom awscli.help import WindowsHelpRenderer, ProviderHelpCommand, HelpCommand\nfrom awscli.help import TopicListerCommand, TopicHelpCommand\nfrom awscli.argparser import HELP_BLURB\n\n\nclass HelpSpyMixin(object):\n    def __init__(self):\n        self.exists_on_path = {}\n        self.popen_calls = []\n        self.mock_popen = mock.Mock()\n\n    def _exists_on_path(self, name):\n        return self.exists_on_path.get(name)\n\n    def _popen(self, *args, **kwargs):\n        self.popen_calls.append((args, kwargs))\n        return self.mock_popen\n\n\nclass FakePosixHelpRenderer(HelpSpyMixin, PosixHelpRenderer):\n    def __init__(self, output_stream=sys.stdout):\n        HelpSpyMixin.__init__(self)\n        PosixHelpRenderer.__init__(self, output_stream)\n\n\nclass FakeWindowsHelpRenderer(HelpSpyMixin, WindowsHelpRenderer):\n    def __init__(self, output_stream=sys.stdout):\n        HelpSpyMixin.__init__(self)\n        WindowsHelpRenderer.__init__(self, output_stream)\n\n\nclass TestHelpPager(unittest.TestCase):\n\n    def setUp(self):\n        self.environ = {}\n        self.environ_patch = mock.patch('os.environ', self.environ)\n        self.environ_patch.start()\n        self.renderer = PosixHelpRenderer()\n\n    def tearDown(self):\n        self.environ_patch.stop()\n\n    def test_no_env_vars(self):\n        self.assertEqual(self.renderer.get_pager_cmdline(),\n                         self.renderer.PAGER.split())\n\n    def test_manpager(self):\n        pager_cmd = 'foobar'\n        os.environ['MANPAGER'] = pager_cmd\n        self.assertEqual(self.renderer.get_pager_cmdline(),\n                         pager_cmd.split())\n\n    def test_pager(self):\n        pager_cmd = 'fiebaz'\n        os.environ['PAGER'] = pager_cmd\n        self.assertEqual(self.renderer.get_pager_cmdline(),\n                         pager_cmd.split())\n\n    def test_both(self):\n        os.environ['MANPAGER'] = 'foobar'\n        os.environ['PAGER'] = 'fiebaz'\n        self.assertEqual(self.renderer.get_pager_cmdline(),\n                         'foobar'.split())\n\n    def test_manpager_with_args(self):\n        pager_cmd = 'less -X'\n        os.environ['MANPAGER'] = pager_cmd\n        self.assertEqual(self.renderer.get_pager_cmdline(),\n                         pager_cmd.split())\n\n    def test_pager_with_args(self):\n        pager_cmd = 'less -X --clearscreen'\n        os.environ['PAGER'] = pager_cmd\n        self.assertEqual(self.renderer.get_pager_cmdline(),\n                         pager_cmd.split())\n\n    @skip_if_windows('Requires posix system.')\n    def test_no_groff_exists(self):\n        renderer = FakePosixHelpRenderer()\n        renderer.exists_on_path['groff'] = False\n        expected_error = 'Could not find executable named \"groff\"'\n        with self.assertRaisesRegexp(ExecutableNotFoundError, expected_error):\n            renderer.render('foo')\n\n    @skip_if_windows('Requires POSIX system.')\n    def test_no_pager_exists(self):\n        fake_pager = 'foobar'\n        os.environ['MANPAGER'] = fake_pager\n        stdout = six.StringIO()\n        renderer = FakePosixHelpRenderer(output_stream=stdout)\n        renderer.exists_on_path[fake_pager] = False\n\n        renderer.exists_on_path['groff'] = True\n        renderer.mock_popen.communicate.return_value = (b'foo', '')\n        renderer.render('foo')\n        self.assertEqual(stdout.getvalue(), 'foo\\n')\n\n    def test_shlex_split_for_pager_var(self):\n        pager_cmd = '/bin/sh -c \"col -bx | vim -c \\'set ft=man\\' -\"'\n        os.environ['PAGER'] = pager_cmd\n        self.assertEqual(self.renderer.get_pager_cmdline(),\n                         ['/bin/sh', '-c', \"col -bx | vim -c 'set ft=man' -\"])\n\n    def test_can_render_contents(self):\n        renderer = FakePosixHelpRenderer()\n        renderer.exists_on_path['groff'] = True\n        renderer.exists_on_path['less'] = True\n        renderer.mock_popen.communicate.return_value = ('rendered', '')\n        renderer.render('foo')\n        self.assertEqual(renderer.popen_calls[-1][0], (['less', '-R'],))\n\n    def test_can_page_output_on_windows(self):\n        renderer = FakeWindowsHelpRenderer()\n        renderer.mock_popen.communicate.return_value = ('rendered', '')\n        renderer.render('foo')\n        self.assertEqual(renderer.popen_calls[-1][0], (['more'],))\n\n    @skip_if_windows(\"Ctrl-C not valid on windows.\")\n    def test_can_handle_ctrl_c(self):\n        class CtrlCRenderer(FakePosixHelpRenderer):\n            def _popen(self, *args, **kwargs):\n                if self._is_pager_call(args):\n                    os.kill(os.getpid(), signal.SIGINT)\n                return self.mock_popen\n\n            def _is_pager_call(self, args):\n                return 'less' in args[0]\n\n        renderer = CtrlCRenderer()\n        renderer.mock_popen.communicate.return_value = ('send to pager', '')\n        renderer.exists_on_path['groff'] = True\n        renderer.exists_on_path['less'] = True\n        renderer.render('foo')\n        last_call = renderer.mock_popen.communicate.call_args_list[-1]\n        self.assertEqual(last_call, mock.call(input='send to pager'))\n\n\nclass TestHelpCommandBase(unittest.TestCase):\n    def setUp(self):\n        self.session = mock.Mock()\n        self.file_creator = FileCreator()\n\n    def tearDown(self):\n        self.file_creator.remove_all()\n\n\nclass TestHelpCommand(TestHelpCommandBase):\n    \n    def setUp(self):\n        super(TestHelpCommand, self).setUp()\n        self.doc_handler_mock = mock.Mock()\n        self.subcommand_mock = mock.Mock()\n        self.renderer = mock.Mock()\n\n        class SampleHelpCommand(HelpCommand):\n            EventHandlerClass = self.doc_handler_mock\n\n            @property\n            def subcommand_table(sample_help_cmd_self):\n                return {'mycommand': self.subcommand_mock}\n\n        self.cmd = SampleHelpCommand(self.session, None, None, None)\n        self.cmd.renderer = self.renderer\n\n    def test_subcommand_call(self):\n        self.cmd(['mycommand'], None)\n        self.subcommand_mock.assert_called_with([], None)\n        self.assertFalse(self.doc_handler_mock.called)\n\n    def test_regular_call(self):\n        self.cmd([], None)\n        self.assertFalse(self.subcommand_mock.called)\n        self.doc_handler_mock.assert_called_with(self.cmd)\n        self.assertTrue(self.renderer.render.called)\n\n    def test_invalid_subcommand(self):\n        with mock.patch('sys.stderr') as f:\n            with self.assertRaises(SystemExit):\n                self.cmd(['no-exist-command'], None)\n         We should see the pointer to \"aws help\" in the error message.\n        error_message = ''.join(arg[0][0] for arg in f.write.call_args_list)\n        self.assertIn(HELP_BLURB, error_message)\n\n\nclass TestProviderHelpCommand(TestHelpCommandBase):\n    def setUp(self):\n        super(TestProviderHelpCommand, self).setUp()\n        self.session.provider = None\n        self.command_table = {}\n        self.arg_table = {}\n        self.description = None\n        self.synopsis = None\n        self.usage = None\n\n         Create a temporary index file for ``aws help [command]`` to use.\n        self.tags_dict = {\n            'topic-name-1': {},\n            'topic-name-2': {}\n        }\n        json_index = self.file_creator.create_file('index.json', '')\n        with open(json_index, 'w') as f:\n            json.dump(self.tags_dict, f, indent=4, sort_keys=True)\n        self.json_patch = mock.patch(\n            'awscli.topictags.TopicTagDB.index_file', json_index)\n        self.json_patch.start()\n\n        self.cmd = ProviderHelpCommand(self.session, self.command_table,\n                                       self.arg_table, self.description,\n                                       self.synopsis, self.usage)\n\n    def tearDown(self):\n        self.json_patch.stop()\n        super(TestProviderHelpCommand, self).tearDown()\n\n    def test_related_items(self):\n        self.assertEqual(self.cmd.related_items, ['aws help topics'])\n\n    def test_subcommand_table(self):\n        subcommand_table = self.cmd.subcommand_table\n\n        self.assertEqual(len(subcommand_table), 3)\n\n         Ensure there is a topics command\n        self.assertIn('topics', subcommand_table)\n        self.assertIsInstance(subcommand_table['topics'], TopicListerCommand)\n\n         Ensure the topics are there as well\n        self.assertIn('topic-name-1', subcommand_table)\n        self.assertIsInstance(subcommand_table['topic-name-1'],\n                              TopicHelpCommand)\n        self.assertEqual(subcommand_table['topic-name-1'].name, 'topic-name-1')\n\n        self.assertIn('topic-name-2', subcommand_table)\n        self.assertIsInstance(subcommand_table['topic-name-2'],\n                              TopicHelpCommand)\n        self.assertEqual(subcommand_table['topic-name-2'].name,\n                         'topic-name-2')\n\n\nclass TestTopicListerCommand(TestHelpCommandBase):\n    def setUp(self):\n        super(TestTopicListerCommand, self).setUp()\n        self.cmd = TopicListerCommand(self.session)\n\n    def test_event_class(self):\n        self.assertEqual(self.cmd.event_class, 'topics')\n\n    def test_name(self):\n        self.assertEqual(self.cmd.name, 'topics')\n\n\nclass TestTopicHelpCommand(TestHelpCommandBase):\n    def setUp(self):\n        super(TestTopicHelpCommand, self).setUp()\n        self.name = 'topic-name-1'\n        self.cmd = TopicHelpCommand(self.session, self.name)\n\n    def test_event_class(self):\n        self.assertEqual(self.cmd.event_class, 'topics.topic-name-1')\n\n    def test_name(self):\n        self.assertEqual(self.cmd.name, self.name)\n", "comments": "   test deeper functionality helpcommand      we subclassing helpcommand ensure behaving     expected             copyright 2012 2013 amazon com  inc  affiliates  all rights reserved        licensed apache license  version 2 0 (the  license )  you    may use file except compliance license  a copy    license located           http   aws amazon com apache2 0         license  file accompanying file  this file    distributed  as is  basis  without warranties or conditions of    any kind  either express implied  see license specific    language governing permissions limitations license     we see pointer  aws help  error message     create temporary index file   aws help  command    use     ensure topics command    ensure topics well ", "content": "# Copyright 2012-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"). You\n# may not use this file except in compliance with the License. A copy of\n# the License is located at\n#\n#     http://aws.amazon.com/apache2.0/\n#\n# or in the \"license\" file accompanying this file. This file is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n# ANY KIND, either express or implied. See the License for the specific\n# language governing permissions and limitations under the License.\nfrom awscli.testutils import unittest, skip_if_windows, FileCreator\nimport signal\nimport platform\nimport json\nimport sys\nimport os\n\nimport mock\n\nfrom awscli.compat import six\nfrom awscli.help import PosixHelpRenderer, ExecutableNotFoundError\nfrom awscli.help import WindowsHelpRenderer, ProviderHelpCommand, HelpCommand\nfrom awscli.help import TopicListerCommand, TopicHelpCommand\nfrom awscli.argparser import HELP_BLURB\n\n\nclass HelpSpyMixin(object):\n    def __init__(self):\n        self.exists_on_path = {}\n        self.popen_calls = []\n        self.mock_popen = mock.Mock()\n\n    def _exists_on_path(self, name):\n        return self.exists_on_path.get(name)\n\n    def _popen(self, *args, **kwargs):\n        self.popen_calls.append((args, kwargs))\n        return self.mock_popen\n\n\nclass FakePosixHelpRenderer(HelpSpyMixin, PosixHelpRenderer):\n    def __init__(self, output_stream=sys.stdout):\n        HelpSpyMixin.__init__(self)\n        PosixHelpRenderer.__init__(self, output_stream)\n\n\nclass FakeWindowsHelpRenderer(HelpSpyMixin, WindowsHelpRenderer):\n    def __init__(self, output_stream=sys.stdout):\n        HelpSpyMixin.__init__(self)\n        WindowsHelpRenderer.__init__(self, output_stream)\n\n\nclass TestHelpPager(unittest.TestCase):\n\n    def setUp(self):\n        self.environ = {}\n        self.environ_patch = mock.patch('os.environ', self.environ)\n        self.environ_patch.start()\n        self.renderer = PosixHelpRenderer()\n\n    def tearDown(self):\n        self.environ_patch.stop()\n\n    def test_no_env_vars(self):\n        self.assertEqual(self.renderer.get_pager_cmdline(),\n                         self.renderer.PAGER.split())\n\n    def test_manpager(self):\n        pager_cmd = 'foobar'\n        os.environ['MANPAGER'] = pager_cmd\n        self.assertEqual(self.renderer.get_pager_cmdline(),\n                         pager_cmd.split())\n\n    def test_pager(self):\n        pager_cmd = 'fiebaz'\n        os.environ['PAGER'] = pager_cmd\n        self.assertEqual(self.renderer.get_pager_cmdline(),\n                         pager_cmd.split())\n\n    def test_both(self):\n        os.environ['MANPAGER'] = 'foobar'\n        os.environ['PAGER'] = 'fiebaz'\n        self.assertEqual(self.renderer.get_pager_cmdline(),\n                         'foobar'.split())\n\n    def test_manpager_with_args(self):\n        pager_cmd = 'less -X'\n        os.environ['MANPAGER'] = pager_cmd\n        self.assertEqual(self.renderer.get_pager_cmdline(),\n                         pager_cmd.split())\n\n    def test_pager_with_args(self):\n        pager_cmd = 'less -X --clearscreen'\n        os.environ['PAGER'] = pager_cmd\n        self.assertEqual(self.renderer.get_pager_cmdline(),\n                         pager_cmd.split())\n\n    @skip_if_windows('Requires posix system.')\n    def test_no_groff_exists(self):\n        renderer = FakePosixHelpRenderer()\n        renderer.exists_on_path['groff'] = False\n        expected_error = 'Could not find executable named \"groff\"'\n        with self.assertRaisesRegexp(ExecutableNotFoundError, expected_error):\n            renderer.render('foo')\n\n    @skip_if_windows('Requires POSIX system.')\n    def test_no_pager_exists(self):\n        fake_pager = 'foobar'\n        os.environ['MANPAGER'] = fake_pager\n        stdout = six.StringIO()\n        renderer = FakePosixHelpRenderer(output_stream=stdout)\n        renderer.exists_on_path[fake_pager] = False\n\n        renderer.exists_on_path['groff'] = True\n        renderer.mock_popen.communicate.return_value = (b'foo', '')\n        renderer.render('foo')\n        self.assertEqual(stdout.getvalue(), 'foo\\n')\n\n    def test_shlex_split_for_pager_var(self):\n        pager_cmd = '/bin/sh -c \"col -bx | vim -c \\'set ft=man\\' -\"'\n        os.environ['PAGER'] = pager_cmd\n        self.assertEqual(self.renderer.get_pager_cmdline(),\n                         ['/bin/sh', '-c', \"col -bx | vim -c 'set ft=man' -\"])\n\n    def test_can_render_contents(self):\n        renderer = FakePosixHelpRenderer()\n        renderer.exists_on_path['groff'] = True\n        renderer.exists_on_path['less'] = True\n        renderer.mock_popen.communicate.return_value = ('rendered', '')\n        renderer.render('foo')\n        self.assertEqual(renderer.popen_calls[-1][0], (['less', '-R'],))\n\n    def test_can_page_output_on_windows(self):\n        renderer = FakeWindowsHelpRenderer()\n        renderer.mock_popen.communicate.return_value = ('rendered', '')\n        renderer.render('foo')\n        self.assertEqual(renderer.popen_calls[-1][0], (['more'],))\n\n    @skip_if_windows(\"Ctrl-C not valid on windows.\")\n    def test_can_handle_ctrl_c(self):\n        class CtrlCRenderer(FakePosixHelpRenderer):\n            def _popen(self, *args, **kwargs):\n                if self._is_pager_call(args):\n                    os.kill(os.getpid(), signal.SIGINT)\n                return self.mock_popen\n\n            def _is_pager_call(self, args):\n                return 'less' in args[0]\n\n        renderer = CtrlCRenderer()\n        renderer.mock_popen.communicate.return_value = ('send to pager', '')\n        renderer.exists_on_path['groff'] = True\n        renderer.exists_on_path['less'] = True\n        renderer.render('foo')\n        last_call = renderer.mock_popen.communicate.call_args_list[-1]\n        self.assertEqual(last_call, mock.call(input='send to pager'))\n\n\nclass TestHelpCommandBase(unittest.TestCase):\n    def setUp(self):\n        self.session = mock.Mock()\n        self.file_creator = FileCreator()\n\n    def tearDown(self):\n        self.file_creator.remove_all()\n\n\nclass TestHelpCommand(TestHelpCommandBase):\n    \"\"\"Test some of the deeper functionality of the HelpCommand\n\n    We do this by subclassing from HelpCommand and ensure it is behaving\n    as expected.\n    \"\"\"\n    def setUp(self):\n        super(TestHelpCommand, self).setUp()\n        self.doc_handler_mock = mock.Mock()\n        self.subcommand_mock = mock.Mock()\n        self.renderer = mock.Mock()\n\n        class SampleHelpCommand(HelpCommand):\n            EventHandlerClass = self.doc_handler_mock\n\n            @property\n            def subcommand_table(sample_help_cmd_self):\n                return {'mycommand': self.subcommand_mock}\n\n        self.cmd = SampleHelpCommand(self.session, None, None, None)\n        self.cmd.renderer = self.renderer\n\n    def test_subcommand_call(self):\n        self.cmd(['mycommand'], None)\n        self.subcommand_mock.assert_called_with([], None)\n        self.assertFalse(self.doc_handler_mock.called)\n\n    def test_regular_call(self):\n        self.cmd([], None)\n        self.assertFalse(self.subcommand_mock.called)\n        self.doc_handler_mock.assert_called_with(self.cmd)\n        self.assertTrue(self.renderer.render.called)\n\n    def test_invalid_subcommand(self):\n        with mock.patch('sys.stderr') as f:\n            with self.assertRaises(SystemExit):\n                self.cmd(['no-exist-command'], None)\n        # We should see the pointer to \"aws help\" in the error message.\n        error_message = ''.join(arg[0][0] for arg in f.write.call_args_list)\n        self.assertIn(HELP_BLURB, error_message)\n\n\nclass TestProviderHelpCommand(TestHelpCommandBase):\n    def setUp(self):\n        super(TestProviderHelpCommand, self).setUp()\n        self.session.provider = None\n        self.command_table = {}\n        self.arg_table = {}\n        self.description = None\n        self.synopsis = None\n        self.usage = None\n\n        # Create a temporary index file for ``aws help [command]`` to use.\n        self.tags_dict = {\n            'topic-name-1': {},\n            'topic-name-2': {}\n        }\n        json_index = self.file_creator.create_file('index.json', '')\n        with open(json_index, 'w') as f:\n            json.dump(self.tags_dict, f, indent=4, sort_keys=True)\n        self.json_patch = mock.patch(\n            'awscli.topictags.TopicTagDB.index_file', json_index)\n        self.json_patch.start()\n\n        self.cmd = ProviderHelpCommand(self.session, self.command_table,\n                                       self.arg_table, self.description,\n                                       self.synopsis, self.usage)\n\n    def tearDown(self):\n        self.json_patch.stop()\n        super(TestProviderHelpCommand, self).tearDown()\n\n    def test_related_items(self):\n        self.assertEqual(self.cmd.related_items, ['aws help topics'])\n\n    def test_subcommand_table(self):\n        subcommand_table = self.cmd.subcommand_table\n\n        self.assertEqual(len(subcommand_table), 3)\n\n        # Ensure there is a topics command\n        self.assertIn('topics', subcommand_table)\n        self.assertIsInstance(subcommand_table['topics'], TopicListerCommand)\n\n        # Ensure the topics are there as well\n        self.assertIn('topic-name-1', subcommand_table)\n        self.assertIsInstance(subcommand_table['topic-name-1'],\n                              TopicHelpCommand)\n        self.assertEqual(subcommand_table['topic-name-1'].name, 'topic-name-1')\n\n        self.assertIn('topic-name-2', subcommand_table)\n        self.assertIsInstance(subcommand_table['topic-name-2'],\n                              TopicHelpCommand)\n        self.assertEqual(subcommand_table['topic-name-2'].name,\n                         'topic-name-2')\n\n\nclass TestTopicListerCommand(TestHelpCommandBase):\n    def setUp(self):\n        super(TestTopicListerCommand, self).setUp()\n        self.cmd = TopicListerCommand(self.session)\n\n    def test_event_class(self):\n        self.assertEqual(self.cmd.event_class, 'topics')\n\n    def test_name(self):\n        self.assertEqual(self.cmd.name, 'topics')\n\n\nclass TestTopicHelpCommand(TestHelpCommandBase):\n    def setUp(self):\n        super(TestTopicHelpCommand, self).setUp()\n        self.name = 'topic-name-1'\n        self.cmd = TopicHelpCommand(self.session, self.name)\n\n    def test_event_class(self):\n        self.assertEqual(self.cmd.event_class, 'topics.topic-name-1')\n\n    def test_name(self):\n        self.assertEqual(self.cmd.name, self.name)\n", "description": "Universal Command Line Interface for Amazon Web Services", "file_name": "test_help.py", "id": "0605558a783d44e80d3634e2f164bd7a", "language": "Python", "project_name": "aws-cli", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/aws-aws-cli/aws-aws-cli-d705c60/tests/unit/test_help.py", "save_time": "", "source": "", "update_at": "2018-03-18T15:33:26Z", "url": "https://github.com/aws/aws-cli", "wiki": false}