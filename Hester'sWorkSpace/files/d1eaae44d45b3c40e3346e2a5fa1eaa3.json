{"author": "nvbn", "code": "import re\nimport os\nfrom thefuck.utils import memoize, default_settings\nfrom thefuck.conf import settings\nfrom thefuck.shells import shell\n\n\n\npatterns = (\n    \n    '^    at {file}:{line}:{col}',\n    \n    '^   {file}:{line}:{col}',\n    \n    '^  File \"{file}\", line {line}',\n    \n    '^awk: {file}:{line}:',\n    \n    '^fatal: bad config file line {line} in {file}',\n    \n    '^llc: {file}:{line}:{col}:',\n    \n    '^lua: {file}:{line}:',\n    \n    '^{file} \\\\(line {line}\\\\):',\n    \n    '^{file}: line {line}: ',\n    \n    '^{file}:{line}:{col}',\n    \n    '^{file}:{line}:',\n    \n    'at {file} line {line}',\n)\n\n\n\ndef _make_pattern(pattern):\n    pattern = pattern.replace('{file}', '(?P<file>[^:\\n]+)') \\\n                     .replace('{line}', '(?P<line>[0-9]+)') \\\n                     .replace('{col}', '(?P<col>[0-9]+)')\n    return re.compile(pattern, re.MULTILINE)\n\n\npatterns = [_make_pattern(p).search for p in patterns]\n\n\n@memoize\ndef _search(output):\n    for pattern in patterns:\n        m = pattern(output)\n        if m and os.path.isfile(m.group('file')):\n            return m\n\n\ndef match(command):\n    if 'EDITOR' not in os.environ:\n        return False\n\n    return _search(command.output)\n\n\n@default_settings({'fixlinecmd': u'{editor} {file} +{line}',\n                   'fixcolcmd': None})\ndef get_new_command(command):\n    m = _search(command.output)\n\n    \n    \n    if settings.fixcolcmd and 'col' in m.groupdict():\n        editor_call = settings.fixcolcmd.format(editor=os.environ['EDITOR'],\n                                                file=m.group('file'),\n                                                line=m.group('line'),\n                                                col=m.group('col'))\n    else:\n        editor_call = settings.fixlinecmd.format(editor=os.environ['EDITOR'],\n                                                 file=m.group('file'),\n                                                 line=m.group('line'))\n\n    return shell.and_(editor_call, command.script)\n", "comments": "# order is important: only the first match is considered\n# js, node:\n# cargo:\n# python, thefuck:\n# awk:\n# git\n# llc:\n# lua:\n# fish:\n# bash, sh, ssh:\n# cargo, clang, gcc, go, pep8, rustc:\n# ghc, make, ruby, zsh:\n# perl:\n# for the sake of readability do not use named groups above\n# Note: there does not seem to be a standard for columns, so they are just\n# ignored by default\n", "content": "import re\nimport os\nfrom thefuck.utils import memoize, default_settings\nfrom thefuck.conf import settings\nfrom thefuck.shells import shell\n\n\n# order is important: only the first match is considered\npatterns = (\n    # js, node:\n    '^    at {file}:{line}:{col}',\n    # cargo:\n    '^   {file}:{line}:{col}',\n    # python, thefuck:\n    '^  File \"{file}\", line {line}',\n    # awk:\n    '^awk: {file}:{line}:',\n    # git\n    '^fatal: bad config file line {line} in {file}',\n    # llc:\n    '^llc: {file}:{line}:{col}:',\n    # lua:\n    '^lua: {file}:{line}:',\n    # fish:\n    '^{file} \\\\(line {line}\\\\):',\n    # bash, sh, ssh:\n    '^{file}: line {line}: ',\n    # cargo, clang, gcc, go, pep8, rustc:\n    '^{file}:{line}:{col}',\n    # ghc, make, ruby, zsh:\n    '^{file}:{line}:',\n    # perl:\n    'at {file} line {line}',\n)\n\n\n# for the sake of readability do not use named groups above\ndef _make_pattern(pattern):\n    pattern = pattern.replace('{file}', '(?P<file>[^:\\n]+)') \\\n                     .replace('{line}', '(?P<line>[0-9]+)') \\\n                     .replace('{col}', '(?P<col>[0-9]+)')\n    return re.compile(pattern, re.MULTILINE)\n\n\npatterns = [_make_pattern(p).search for p in patterns]\n\n\n@memoize\ndef _search(output):\n    for pattern in patterns:\n        m = pattern(output)\n        if m and os.path.isfile(m.group('file')):\n            return m\n\n\ndef match(command):\n    if 'EDITOR' not in os.environ:\n        return False\n\n    return _search(command.output)\n\n\n@default_settings({'fixlinecmd': u'{editor} {file} +{line}',\n                   'fixcolcmd': None})\ndef get_new_command(command):\n    m = _search(command.output)\n\n    # Note: there does not seem to be a standard for columns, so they are just\n    # ignored by default\n    if settings.fixcolcmd and 'col' in m.groupdict():\n        editor_call = settings.fixcolcmd.format(editor=os.environ['EDITOR'],\n                                                file=m.group('file'),\n                                                line=m.group('line'),\n                                                col=m.group('col'))\n    else:\n        editor_call = settings.fixlinecmd.format(editor=os.environ['EDITOR'],\n                                                 file=m.group('file'),\n                                                 line=m.group('line'))\n\n    return shell.and_(editor_call, command.script)\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "fix_file.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/thefuck/rules/fix_file.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}