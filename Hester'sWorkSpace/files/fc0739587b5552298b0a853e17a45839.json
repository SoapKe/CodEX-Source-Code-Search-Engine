{"author": "ansible", "code": "# Copyright (c) 2017 Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nDOCUMENTATION = '''\n    inventory: yaml\n    version_added: \"2.4\"\n    short_description: Uses a specifically YAML file as inventory source.\n    description:\n        - \"YAML based inventory, starts with the 'all' group and has hosts/vars/children entries.\"\n        - Host entries can have sub-entries defined, which will be treated as variables.\n        - Vars entries are normal group vars.\n        - \"Children are 'child groups', which can also have their own vars/hosts/children and so on.\"\n        - File MUST have a valid extension, defined in configuration\n    notes:\n        - It takes the place of the previously hardcoded YAML inventory.\n        - To function it requires being whitelisted in configuration.\n    options:\n      yaml_extensions:\n        description: list of 'valid' extensions for files containing YAML\n        type: list\n        default: ['.yaml', '.yml', '.json']\n        env:\n          - name: ANSIBLE_YAML_FILENAME_EXT\n          - name: ANSIBLE_INVENTORY_PLUGIN_EXTS\n        ini:\n          - key: yaml_valid_extensions\n            section: defaults\n          - section: inventory_plugin_yaml\n            key: yaml_valid_extensions\n\n'''\nEXAMPLES = '''\nall: \n    hosts:\n        test1:\n        test2:\n            var1: value1\n    vars:\n        group_var1: value2\n    children:   \n        other_group:\n            children:\n                group_x:\n                    hosts:\n                        test5\n            vars:\n                g2_var2: value3\n            hosts:\n                test4:\n                    ansible_host: 127.0.0.1\n        last_group:\n            hosts:\n                test1 \n            vars:\n                last_var: MYVALUE\n'''\n\nimport os\nfrom collections import MutableMapping\n\nfrom ansible.errors import AnsibleParserError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native\nfrom ansible.parsing.utils.addresses import parse_address\nfrom ansible.plugins.inventory import BaseFileInventoryPlugin, detect_range, expand_hostname_range\n\n\nclass InventoryModule(BaseFileInventoryPlugin):\n\n    NAME = 'yaml'\n\n    def __init__(self):\n\n        super(InventoryModule, self).__init__()\n\n    def verify_file(self, path):\n\n        valid = False\n        if super(InventoryModule, self).verify_file(path):\n            file_name, ext = os.path.splitext(path)\n            if not ext or ext in self.get_option('yaml_extensions'):\n                valid = True\n        return valid\n\n    def parse(self, inventory, loader, path, cache=True):\n        ''' parses the inventory file '''\n\n        super(InventoryModule, self).parse(inventory, loader, path)\n\n        try:\n            data = self.loader.load_from_file(path)\n        except Exception as e:\n            raise AnsibleParserError(e)\n\n        if not data:\n            raise AnsibleParserError('Parsed empty YAML file')\n        elif not isinstance(data, MutableMapping):\n            raise AnsibleParserError('YAML inventory has invalid structure, it should be a dictionary, got: %s' % type(data))\n        elif data.get('plugin'):\n            raise AnsibleParserError('Plugin configuration YAML file, not YAML inventory')\n\n        \n        # to get host, vars and subgroups (which we iterate over recursivelly)\n        if isinstance(data, MutableMapping):\n            for group_name in data:\n                self._parse_group(group_name, data[group_name])\n        else:\n            raise AnsibleParserError(\"Invalid data from file, expected dictionary and got:\\n\\n%s\" % to_native(data))\n\n    def _parse_group(self, group, group_data):\n\n        self.inventory.add_group(group)\n\n        if isinstance(group_data, MutableMapping):\n            \n            for section in ['vars', 'children', 'hosts']:\n                if section in group_data:\n                    \n                    if isinstance(group_data[section], string_types):\n                        group_data[section] = {group_data[section]: None}\n\n                    if not isinstance(group_data[section], MutableMapping):\n                        raise AnsibleParserError('Invalid \"%s\" entry for \"%s\" group, requires a dictionary, found \"%s\" instead.' %\n                                                 (section, group, type(group_data[section])))\n\n            for key in group_data:\n                if key == 'vars':\n                    for var in group_data['vars']:\n                        self.inventory.set_variable(group, var, group_data['vars'][var])\n\n                elif key == 'children':\n                    for subgroup in group_data['children']:\n                        self._parse_group(subgroup, group_data['children'][subgroup])\n                        self.inventory.add_child(group, subgroup)\n\n                elif key == 'hosts':\n                    for host_pattern in group_data['hosts']:\n                        hosts, port = self._parse_host(host_pattern)\n                        self._populate_host_vars(hosts, group_data['hosts'][host_pattern] or {}, group, port)\n                else:\n                    self.display.warning('Skipping unexpected key (%s) in group (%s), only \"vars\", \"children\" and \"hosts\" are valid' % (key, group))\n\n    def _parse_host(self, host_pattern):\n        '''\n        Each host key can be a pattern, try to process it and add variables as needed\n        '''\n        (hostnames, port) = self._expand_hostpattern(host_pattern)\n\n        return hostnames, port\n\n    def _expand_hostpattern(self, hostpattern):\n        '''\n        Takes a single host pattern and returns a list of hostnames and an\n        optional port number that applies to all of them.\n        '''\n        \n        ?\n\n        try:\n            (pattern, port) = parse_address(hostpattern, allow_ranges=True)\n        except:\n            \n            pattern = hostpattern\n            port = None\n\n        \n        # more hostnames, depending on whether it contains any [x:y] ranges.\n\n        if detect_range(pattern):\n            hostnames = expand_hostname_range(pattern)\n        else:\n            hostnames = [pattern]\n\n        return (hostnames, port)\n", "comments": "        inventory  yaml     version added   2 4      short description  uses specifically yaml file inventory source      description             yaml based inventory  starts   group hosts vars children entries             host entries sub entries defined  treated variables            vars entries normal group vars             children  child groups   also vars hosts children             file must valid extension  defined configuration     notes            it takes place previously hardcoded yaml inventory            to function requires whitelisted configuration      options        yaml extensions          description  list  valid  extensions files containing yaml         type  list         default     yaml     yml     json           env              name  ansible yaml filename ext             name  ansible inventory plugin exts         ini              key  yaml valid extensions             section  defaults             section  inventory plugin yaml             key  yaml valid extensions      examples          keys must unique  e  one  hosts  per group     hosts          test1          test2              var1  value1     vars          group var1  value2     children      key order matter  indentation         group              children                  group x                      hosts                          test5             vars                  g2 var2  value3             hosts                  test4                      ansible host  127 0 0 1         last group              hosts                  test1   host  additional group membership             vars                  last var  myvalue      import os collections import mutablemapping  ansible errors import ansibleparsererror ansible module utils six import string types ansible module utils  text import native ansible parsing utils addresses import parse address ansible plugins inventory import basefileinventoryplugin  detect range  expand hostname range   class inventorymodule(basefileinventoryplugin)       name    yaml       def   init  (self)           super(inventorymodule  self)   init  ()      def verify file(self  path)           valid   false         super(inventorymodule  self) verify file(path)              file name  ext   os path splitext(path)             ext ext self get option( yaml extensions )                  valid   true         return valid      def parse(self  inventory  loader  path  cache true)              parses inventory file              super(inventorymodule  self) parse(inventory  loader  path)          try              data   self loader load file(path)         except exception e              raise ansibleparsererror(e)          data              raise ansibleparsererror( parsed empty yaml file )         elif isinstance(data  mutablemapping)              raise ansibleparsererror( yaml inventory invalid structure  dictionary  got      type(data))         elif data get( plugin )              raise ansibleparsererror( plugin configuration yaml file  yaml inventory )            we expect top level keys correspond groups  iterate           get host  vars subgroups (which iterate recursivelly)         isinstance(data  mutablemapping)              group name data                  self  parse group(group name  data group name )         else              raise ansibleparsererror( invalid data file  expected dictionary got  n n    native(data))      def  parse group(self  group  group data)           self inventory add group(group)          isinstance(group data  mutablemapping)                make sure dicts             section   vars    children    hosts                    section group data                        convert strings dicts allowed                     isinstance(group data section   string types)                          group data section     group data section   none                       isinstance(group data section   mutablemapping)                          raise ansibleparsererror( invalid    entry    group  requires dictionary  found    instead                                                      (section  group  type(group data section )))              key group data                  key     vars                       var group data  vars                            self inventory set variable(group  var  group data  vars   var )                  elif key     children                       subgroup group data  children                            self  parse group(subgroup  group data  children   subgroup )                         self inventory add child(group  subgroup)                  elif key     hosts                       host pattern group data  hosts                            hosts  port   self  parse host(host pattern)                         self  populate host vars(hosts  group data  hosts   host pattern      group  port)                 else                      self display warning( skipping unexpected key ( s) group ( s)   vars    children   hosts  valid    (key  group))      def  parse host(self  host pattern)                      each host key pattern  try process add variables needed                     (hostnames  port)   self  expand hostpattern(host pattern)          return hostnames  port      def  expand hostpattern(self  hostpattern)                      takes single host pattern returns list hostnames         optional port number applies                 copyright (c) 2017 ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    keys must unique  e  one  hosts  per group    key order matter  indentation    host  additional group membership    we expect top level keys correspond groups  iterate    get host  vars subgroups (which iterate recursivelly)    make sure dicts    convert strings dicts allowed    can given hostpattern parsed host optional port    specification     recognizable host pattern    once separated pattern  expand list one    hostnames  depending whether contains  x  ranges  ", "content": "# Copyright (c) 2017 Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nDOCUMENTATION = '''\n    inventory: yaml\n    version_added: \"2.4\"\n    short_description: Uses a specifically YAML file as inventory source.\n    description:\n        - \"YAML based inventory, starts with the 'all' group and has hosts/vars/children entries.\"\n        - Host entries can have sub-entries defined, which will be treated as variables.\n        - Vars entries are normal group vars.\n        - \"Children are 'child groups', which can also have their own vars/hosts/children and so on.\"\n        - File MUST have a valid extension, defined in configuration\n    notes:\n        - It takes the place of the previously hardcoded YAML inventory.\n        - To function it requires being whitelisted in configuration.\n    options:\n      yaml_extensions:\n        description: list of 'valid' extensions for files containing YAML\n        type: list\n        default: ['.yaml', '.yml', '.json']\n        env:\n          - name: ANSIBLE_YAML_FILENAME_EXT\n          - name: ANSIBLE_INVENTORY_PLUGIN_EXTS\n        ini:\n          - key: yaml_valid_extensions\n            section: defaults\n          - section: inventory_plugin_yaml\n            key: yaml_valid_extensions\n\n'''\nEXAMPLES = '''\nall: # keys must be unique, i.e. only one 'hosts' per group\n    hosts:\n        test1:\n        test2:\n            var1: value1\n    vars:\n        group_var1: value2\n    children:   # key order does not matter, indentation does\n        other_group:\n            children:\n                group_x:\n                    hosts:\n                        test5\n            vars:\n                g2_var2: value3\n            hosts:\n                test4:\n                    ansible_host: 127.0.0.1\n        last_group:\n            hosts:\n                test1 # same host as above, additional group membership\n            vars:\n                last_var: MYVALUE\n'''\n\nimport os\nfrom collections import MutableMapping\n\nfrom ansible.errors import AnsibleParserError\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils._text import to_native\nfrom ansible.parsing.utils.addresses import parse_address\nfrom ansible.plugins.inventory import BaseFileInventoryPlugin, detect_range, expand_hostname_range\n\n\nclass InventoryModule(BaseFileInventoryPlugin):\n\n    NAME = 'yaml'\n\n    def __init__(self):\n\n        super(InventoryModule, self).__init__()\n\n    def verify_file(self, path):\n\n        valid = False\n        if super(InventoryModule, self).verify_file(path):\n            file_name, ext = os.path.splitext(path)\n            if not ext or ext in self.get_option('yaml_extensions'):\n                valid = True\n        return valid\n\n    def parse(self, inventory, loader, path, cache=True):\n        ''' parses the inventory file '''\n\n        super(InventoryModule, self).parse(inventory, loader, path)\n\n        try:\n            data = self.loader.load_from_file(path)\n        except Exception as e:\n            raise AnsibleParserError(e)\n\n        if not data:\n            raise AnsibleParserError('Parsed empty YAML file')\n        elif not isinstance(data, MutableMapping):\n            raise AnsibleParserError('YAML inventory has invalid structure, it should be a dictionary, got: %s' % type(data))\n        elif data.get('plugin'):\n            raise AnsibleParserError('Plugin configuration YAML file, not YAML inventory')\n\n        # We expect top level keys to correspond to groups, iterate over them\n        # to get host, vars and subgroups (which we iterate over recursivelly)\n        if isinstance(data, MutableMapping):\n            for group_name in data:\n                self._parse_group(group_name, data[group_name])\n        else:\n            raise AnsibleParserError(\"Invalid data from file, expected dictionary and got:\\n\\n%s\" % to_native(data))\n\n    def _parse_group(self, group, group_data):\n\n        self.inventory.add_group(group)\n\n        if isinstance(group_data, MutableMapping):\n            # make sure they are dicts\n            for section in ['vars', 'children', 'hosts']:\n                if section in group_data:\n                    # convert strings to dicts as these are allowed\n                    if isinstance(group_data[section], string_types):\n                        group_data[section] = {group_data[section]: None}\n\n                    if not isinstance(group_data[section], MutableMapping):\n                        raise AnsibleParserError('Invalid \"%s\" entry for \"%s\" group, requires a dictionary, found \"%s\" instead.' %\n                                                 (section, group, type(group_data[section])))\n\n            for key in group_data:\n                if key == 'vars':\n                    for var in group_data['vars']:\n                        self.inventory.set_variable(group, var, group_data['vars'][var])\n\n                elif key == 'children':\n                    for subgroup in group_data['children']:\n                        self._parse_group(subgroup, group_data['children'][subgroup])\n                        self.inventory.add_child(group, subgroup)\n\n                elif key == 'hosts':\n                    for host_pattern in group_data['hosts']:\n                        hosts, port = self._parse_host(host_pattern)\n                        self._populate_host_vars(hosts, group_data['hosts'][host_pattern] or {}, group, port)\n                else:\n                    self.display.warning('Skipping unexpected key (%s) in group (%s), only \"vars\", \"children\" and \"hosts\" are valid' % (key, group))\n\n    def _parse_host(self, host_pattern):\n        '''\n        Each host key can be a pattern, try to process it and add variables as needed\n        '''\n        (hostnames, port) = self._expand_hostpattern(host_pattern)\n\n        return hostnames, port\n\n    def _expand_hostpattern(self, hostpattern):\n        '''\n        Takes a single host pattern and returns a list of hostnames and an\n        optional port number that applies to all of them.\n        '''\n        # Can the given hostpattern be parsed as a host with an optional port\n        # specification?\n\n        try:\n            (pattern, port) = parse_address(hostpattern, allow_ranges=True)\n        except:\n            # not a recognizable host pattern\n            pattern = hostpattern\n            port = None\n\n        # Once we have separated the pattern, we expand it into list of one or\n        # more hostnames, depending on whether it contains any [x:y] ranges.\n\n        if detect_range(pattern):\n            hostnames = expand_hostname_range(pattern)\n        else:\n            hostnames = [pattern]\n\n        return (hostnames, port)\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "yaml.py", "id": "fc0739587b5552298b0a853e17a45839", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/plugins/inventory/yaml.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}