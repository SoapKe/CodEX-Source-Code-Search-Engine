{"author": "mopidy", "code": "from __future__ import absolute_import, print_function, unicode_literals\n\nimport logging\nimport os\nimport signal\nimport sys\n\nimport pykka.debug\n\nfrom mopidy import commands, config as config_lib, ext\nfrom mopidy.internal import encoding, log, path, process, versioning\nfrom mopidy.internal.gi import Gst  \n\ntry:\n    \n    import dbus.mainloop.glib\n    dbus.mainloop.glib.threads_init()\n    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)\nexcept ImportError:\n    pass\n\nlogger = logging.getLogger(__name__)\n\n\ndef main():\n    log.bootstrap_delayed_logging()\n    logger.info('Starting Mopidy %s', versioning.get_version())\n\n    signal.signal(signal.SIGTERM, process.sigterm_handler)\n    \n    if hasattr(signal, 'SIGUSR1'):\n        signal.signal(signal.SIGUSR1, pykka.debug.log_thread_tracebacks)\n\n    try:\n        registry = ext.Registry()\n\n        root_cmd = commands.RootCommand()\n        config_cmd = commands.ConfigCommand()\n        deps_cmd = commands.DepsCommand()\n\n        root_cmd.set(extension=None, registry=registry)\n        root_cmd.add_child('config', config_cmd)\n        root_cmd.add_child('deps', deps_cmd)\n\n        extensions_data = ext.load_extensions()\n\n        for data in extensions_data:\n            if data.command:  ?\n                data.command.set(extension=data.extension)\n                root_cmd.add_child(data.extension.ext_name, data.command)\n\n        args = root_cmd.parse(sys.argv[1:])\n\n        config, config_errors = config_lib.load(\n            args.config_files,\n            [d.config_schema for d in extensions_data],\n            [d.config_defaults for d in extensions_data],\n            args.config_overrides)\n\n        create_core_dirs(config)\n        create_initial_config_file(args, extensions_data)\n\n        verbosity_level = args.base_verbosity_level\n        if args.verbosity_level:\n            verbosity_level += args.verbosity_level\n\n        log.setup_logging(config, verbosity_level, args.save_debug_log)\n\n        extensions = {\n            'validate': [], 'config': [], 'disabled': [], 'enabled': []}\n        for data in extensions_data:\n            extension = data.extension\n\n            \n            if not ext.validate_extension_data(data):\n                config[extension.ext_name] = {'enabled': False}\n                config_errors[extension.ext_name] = {\n                    'enabled': 'extension disabled by self check.'}\n                extensions['validate'].append(extension)\n            elif not config[extension.ext_name]['enabled']:\n                config[extension.ext_name] = {'enabled': False}\n                config_errors[extension.ext_name] = {\n                    'enabled': 'extension disabled by user config.'}\n                extensions['disabled'].append(extension)\n            elif config_errors.get(extension.ext_name):\n                config[extension.ext_name]['enabled'] = False\n                config_errors[extension.ext_name]['enabled'] = (\n                    'extension disabled due to config errors.')\n                extensions['config'].append(extension)\n            else:\n                extensions['enabled'].append(extension)\n\n        log_extension_info([d.extension for d in extensions_data],\n                           extensions['enabled'])\n\n        \n        if args.command == config_cmd:\n            schemas = [d.config_schema for d in extensions_data]\n            return args.command.run(config, config_errors, schemas)\n        elif args.command == deps_cmd:\n            return args.command.run()\n\n        check_config_errors(config, config_errors, extensions)\n\n        if not extensions['enabled']:\n            logger.error('No extension enabled, exiting...')\n            sys.exit(1)\n\n        \n        proxied_config = config_lib.Proxy(config)\n\n        if args.extension and args.extension not in extensions['enabled']:\n            logger.error(\n                'Unable to run command provided by disabled extension %s',\n                args.extension.ext_name)\n            return 1\n\n        for extension in extensions['enabled']:\n            try:\n                extension.setup(registry)\n            except Exception:\n                \n                \n                \n                \n                logger.exception('Extension %s failed during setup, this might'\n                                 ' have left the registry in a bad state.',\n                                 extension.ext_name)\n\n        \n        \n        try:\n            return args.command.run(args, proxied_config)\n        except NotImplementedError:\n            print(root_cmd.format_help())\n            return 1\n\n    except KeyboardInterrupt:\n        pass\n    except Exception as ex:\n        logger.exception(ex)\n        raise\n\n\ndef create_core_dirs(config):\n    path.get_or_create_dir(config['core']['cache_dir'])\n    path.get_or_create_dir(config['core']['config_dir'])\n    path.get_or_create_dir(config['core']['data_dir'])\n\n\ndef create_initial_config_file(args, extensions_data):\n    \n\n    config_file = args.config_files[-1]\n\n    if os.path.exists(path.expand_path(config_file)):\n        return\n\n    try:\n        default = config_lib.format_initial(extensions_data)\n        path.get_or_create_file(config_file, mkdir=False, content=default)\n        logger.info('Initialized %s with default config', config_file)\n    except IOError as error:\n        logger.warning(\n            'Unable to initialize %s with default config: %s',\n            config_file, encoding.locale_decode(error))\n\n\ndef log_extension_info(all_extensions, enabled_extensions):\n    ?\n    enabled_names = set(e.ext_name for e in enabled_extensions)\n    disabled_names = set(e.ext_name for e in all_extensions) - enabled_names\n    logger.info(\n        'Enabled extensions: %s', ', '.join(enabled_names) or 'none')\n    logger.info(\n        'Disabled extensions: %s', ', '.join(disabled_names) or 'none')\n\n\ndef check_config_errors(config, errors, extensions):\n    fatal_errors = []\n    extension_names = {}\n    all_extension_names = set()\n\n    for state in extensions:\n        extension_names[state] = set(e.ext_name for e in extensions[state])\n        all_extension_names.update(extension_names[state])\n\n    for section in sorted(errors):\n        if not errors[section]:\n            continue\n\n        if section not in all_extension_names:\n            logger.warning('Found fatal %s configuration errors:', section)\n            fatal_errors.append(section)\n        elif section in extension_names['config']:\n            del errors[section]['enabled']\n            logger.warning('Found %s configuration errors, the extension '\n                           'has been automatically disabled:', section)\n        else:\n            continue\n\n        for field, msg in errors[section].items():\n            logger.warning('  %s/%s %s', section, field, msg)\n\n    if extensions['config']:\n        logger.warning('Please fix the extension configuration errors or '\n                       'disable the extensions to silence these messages.')\n\n    if fatal_errors:\n        logger.error('Please fix fatal configuration errors, exiting...')\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n", "comments": "   initialize whatever last config file defaults       noqa  f401    make gobject mainloop event loop python dbus    windows signal sigusr1    todo  check isinstance     todo  factor helper tested    config deps commands simply special cased     read config  please     todo  would nice transactional registry  but sadly    bit tricky since current api giving mutable    list  we might however able replace    collections sequence provide ro view     anything wants exit point must use    mopidy internal process exit process actors started     todo  distinguish disabled vs blocked env  ", "content": "from __future__ import absolute_import, print_function, unicode_literals\n\nimport logging\nimport os\nimport signal\nimport sys\n\nimport pykka.debug\n\nfrom mopidy import commands, config as config_lib, ext\nfrom mopidy.internal import encoding, log, path, process, versioning\nfrom mopidy.internal.gi import Gst  # noqa: F401\n\ntry:\n    # Make GObject's mainloop the event loop for python-dbus\n    import dbus.mainloop.glib\n    dbus.mainloop.glib.threads_init()\n    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)\nexcept ImportError:\n    pass\n\nlogger = logging.getLogger(__name__)\n\n\ndef main():\n    log.bootstrap_delayed_logging()\n    logger.info('Starting Mopidy %s', versioning.get_version())\n\n    signal.signal(signal.SIGTERM, process.sigterm_handler)\n    # Windows does not have signal.SIGUSR1\n    if hasattr(signal, 'SIGUSR1'):\n        signal.signal(signal.SIGUSR1, pykka.debug.log_thread_tracebacks)\n\n    try:\n        registry = ext.Registry()\n\n        root_cmd = commands.RootCommand()\n        config_cmd = commands.ConfigCommand()\n        deps_cmd = commands.DepsCommand()\n\n        root_cmd.set(extension=None, registry=registry)\n        root_cmd.add_child('config', config_cmd)\n        root_cmd.add_child('deps', deps_cmd)\n\n        extensions_data = ext.load_extensions()\n\n        for data in extensions_data:\n            if data.command:  # TODO: check isinstance?\n                data.command.set(extension=data.extension)\n                root_cmd.add_child(data.extension.ext_name, data.command)\n\n        args = root_cmd.parse(sys.argv[1:])\n\n        config, config_errors = config_lib.load(\n            args.config_files,\n            [d.config_schema for d in extensions_data],\n            [d.config_defaults for d in extensions_data],\n            args.config_overrides)\n\n        create_core_dirs(config)\n        create_initial_config_file(args, extensions_data)\n\n        verbosity_level = args.base_verbosity_level\n        if args.verbosity_level:\n            verbosity_level += args.verbosity_level\n\n        log.setup_logging(config, verbosity_level, args.save_debug_log)\n\n        extensions = {\n            'validate': [], 'config': [], 'disabled': [], 'enabled': []}\n        for data in extensions_data:\n            extension = data.extension\n\n            # TODO: factor out all of this to a helper that can be tested\n            if not ext.validate_extension_data(data):\n                config[extension.ext_name] = {'enabled': False}\n                config_errors[extension.ext_name] = {\n                    'enabled': 'extension disabled by self check.'}\n                extensions['validate'].append(extension)\n            elif not config[extension.ext_name]['enabled']:\n                config[extension.ext_name] = {'enabled': False}\n                config_errors[extension.ext_name] = {\n                    'enabled': 'extension disabled by user config.'}\n                extensions['disabled'].append(extension)\n            elif config_errors.get(extension.ext_name):\n                config[extension.ext_name]['enabled'] = False\n                config_errors[extension.ext_name]['enabled'] = (\n                    'extension disabled due to config errors.')\n                extensions['config'].append(extension)\n            else:\n                extensions['enabled'].append(extension)\n\n        log_extension_info([d.extension for d in extensions_data],\n                           extensions['enabled'])\n\n        # Config and deps commands are simply special cased for now.\n        if args.command == config_cmd:\n            schemas = [d.config_schema for d in extensions_data]\n            return args.command.run(config, config_errors, schemas)\n        elif args.command == deps_cmd:\n            return args.command.run()\n\n        check_config_errors(config, config_errors, extensions)\n\n        if not extensions['enabled']:\n            logger.error('No extension enabled, exiting...')\n            sys.exit(1)\n\n        # Read-only config from here on, please.\n        proxied_config = config_lib.Proxy(config)\n\n        if args.extension and args.extension not in extensions['enabled']:\n            logger.error(\n                'Unable to run command provided by disabled extension %s',\n                args.extension.ext_name)\n            return 1\n\n        for extension in extensions['enabled']:\n            try:\n                extension.setup(registry)\n            except Exception:\n                # TODO: would be nice a transactional registry. But sadly this\n                # is a bit tricky since our current API is giving out a mutable\n                # list. We might however be able to replace this with a\n                # collections.Sequence to provide a RO view.\n                logger.exception('Extension %s failed during setup, this might'\n                                 ' have left the registry in a bad state.',\n                                 extension.ext_name)\n\n        # Anything that wants to exit after this point must use\n        # mopidy.internal.process.exit_process as actors can have been started.\n        try:\n            return args.command.run(args, proxied_config)\n        except NotImplementedError:\n            print(root_cmd.format_help())\n            return 1\n\n    except KeyboardInterrupt:\n        pass\n    except Exception as ex:\n        logger.exception(ex)\n        raise\n\n\ndef create_core_dirs(config):\n    path.get_or_create_dir(config['core']['cache_dir'])\n    path.get_or_create_dir(config['core']['config_dir'])\n    path.get_or_create_dir(config['core']['data_dir'])\n\n\ndef create_initial_config_file(args, extensions_data):\n    \"\"\"Initialize whatever the last config file is with defaults\"\"\"\n\n    config_file = args.config_files[-1]\n\n    if os.path.exists(path.expand_path(config_file)):\n        return\n\n    try:\n        default = config_lib.format_initial(extensions_data)\n        path.get_or_create_file(config_file, mkdir=False, content=default)\n        logger.info('Initialized %s with default config', config_file)\n    except IOError as error:\n        logger.warning(\n            'Unable to initialize %s with default config: %s',\n            config_file, encoding.locale_decode(error))\n\n\ndef log_extension_info(all_extensions, enabled_extensions):\n    # TODO: distinguish disabled vs blocked by env?\n    enabled_names = set(e.ext_name for e in enabled_extensions)\n    disabled_names = set(e.ext_name for e in all_extensions) - enabled_names\n    logger.info(\n        'Enabled extensions: %s', ', '.join(enabled_names) or 'none')\n    logger.info(\n        'Disabled extensions: %s', ', '.join(disabled_names) or 'none')\n\n\ndef check_config_errors(config, errors, extensions):\n    fatal_errors = []\n    extension_names = {}\n    all_extension_names = set()\n\n    for state in extensions:\n        extension_names[state] = set(e.ext_name for e in extensions[state])\n        all_extension_names.update(extension_names[state])\n\n    for section in sorted(errors):\n        if not errors[section]:\n            continue\n\n        if section not in all_extension_names:\n            logger.warning('Found fatal %s configuration errors:', section)\n            fatal_errors.append(section)\n        elif section in extension_names['config']:\n            del errors[section]['enabled']\n            logger.warning('Found %s configuration errors, the extension '\n                           'has been automatically disabled:', section)\n        else:\n            continue\n\n        for field, msg in errors[section].items():\n            logger.warning('  %s/%s %s', section, field, msg)\n\n    if extensions['config']:\n        logger.warning('Please fix the extension configuration errors or '\n                       'disable the extensions to silence these messages.')\n\n    if fatal_errors:\n        logger.error('Please fix fatal configuration errors, exiting...')\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n", "description": "Mopidy is an extensible music server that plays music from local disk, Spotify, SoundCloud, Google Play Music, and more. You edit the playlist from any phone, tablet, or computer using a range of MPD and web clients.", "file_name": "__main__.py", "id": "1938b0511a0e6cb99d913c79164564b3", "language": "Python", "project_name": "mopidy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mopidy-mopidy/mopidy-mopidy-79d42c3/mopidy/__main__.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:12:51Z", "url": "https://github.com/mopidy/mopidy", "wiki": false}