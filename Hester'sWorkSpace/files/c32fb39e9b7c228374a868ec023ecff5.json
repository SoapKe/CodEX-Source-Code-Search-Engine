{"author": "docker", "code": "\n\"\"\"\nMigrate a Compose file from the V1 format in Compose 1.5 to the V2 format\nsupported by Compose 1.6+\n\"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import unicode_literals\n\nimport argparse\nimport logging\nimport sys\n\nimport ruamel.yaml\n\nfrom compose.config.types import VolumeSpec\n\n\nlog = logging.getLogger('migrate')\n\n\ndef migrate(content):\n    data = ruamel.yaml.load(content, ruamel.yaml.RoundTripLoader)\n\n    service_names = data.keys()\n\n    for name, service in data.items():\n        warn_for_links(name, service)\n        warn_for_external_links(name, service)\n        rewrite_net(service, service_names)\n        rewrite_build(service)\n        rewrite_logging(service)\n        rewrite_volumes_from(service, service_names)\n\n    services = {name: data.pop(name) for name in data.keys()}\n\n    data['version'] = \"2\"\n    data['services'] = services\n    create_volumes_section(data)\n\n    return data\n\n\ndef warn_for_links(name, service):\n    links = service.get('links')\n    if links:\n        example_service = links[0].partition(':')[0]\n        log.warn(\n            \"Service {name} has links, which no longer create environment \"\n            \"variables such as {example_service_upper}_PORT. \"\n            \"If you are using those in your application code, you should \"\n            \"instead connect directly to the hostname, e.g. \"\n            \"'{example_service}'.\"\n            .format(name=name, example_service=example_service,\n                    example_service_upper=example_service.upper()))\n\n\ndef warn_for_external_links(name, service):\n    external_links = service.get('external_links')\n    if external_links:\n        log.warn(\n            \"Service {name} has external_links: {ext}, which now work \"\n            \"slightly differently. In particular, two containers must be \"\n            \"connected to at least one network in common in order to \"\n            \"communicate, even if explicitly linked together.\\n\\n\"\n            \"Either connect the external container to your app's default \"\n            \"network, or connect both the external container and your \"\n            \"service's containers to a pre-existing network. See \"\n            \"https://docs.docker.com/compose/networking/ \"\n            \"for more on how to do this.\"\n            .format(name=name, ext=external_links))\n\n\ndef rewrite_net(service, service_names):\n    if 'net' in service:\n        network_mode = service.pop('net')\n\n        \n        if network_mode.startswith('container:'):\n            name = network_mode.partition(':')[2]\n            if name in service_names:\n                network_mode = 'service:{}'.format(name)\n\n        service['network_mode'] = network_mode\n\n\ndef rewrite_build(service):\n    if 'dockerfile' in service:\n        service['build'] = {\n            'context': service.pop('build'),\n            'dockerfile': service.pop('dockerfile'),\n        }\n\n\ndef rewrite_logging(service):\n    if 'log_driver' in service:\n        service['logging'] = {'driver': service.pop('log_driver')}\n        if 'log_opt' in service:\n            service['logging']['options'] = service.pop('log_opt')\n\n\ndef rewrite_volumes_from(service, service_names):\n    for idx, volume_from in enumerate(service.get('volumes_from', [])):\n        if volume_from.split(':', 1)[0] not in service_names:\n            service['volumes_from'][idx] = 'container:%s' % volume_from\n\n\ndef create_volumes_section(data):\n    named_volumes = get_named_volumes(data['services'])\n    if named_volumes:\n        log.warn(\n            \"Named volumes ({names}) must be explicitly declared. Creating a \"\n            \"'volumes' section with declarations.\\n\\n\"\n            \"For backwards-compatibility, they've been declared as external. \"\n            \"If you don't mind the volume names being prefixed with the \"\n            \"project name, you can remove the 'external' option from each one.\"\n            .format(names=', '.join(list(named_volumes))))\n\n        data['volumes'] = named_volumes\n\n\ndef get_named_volumes(services):\n    volume_specs = [\n        VolumeSpec.parse(volume)\n        for service in services.values()\n        for volume in service.get('volumes', [])\n    ]\n    names = {\n        spec.external\n        for spec in volume_specs\n        if spec.is_named_volume\n    }\n    return {name: {'external': True} for name in names}\n\n\ndef write(stream, new_format, indent, width):\n    ruamel.yaml.dump(\n        new_format,\n        stream,\n        Dumper=ruamel.yaml.RoundTripDumper,\n        indent=indent,\n        width=width)\n\n\ndef parse_opts(args):\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"filename\", help=\"Compose file filename.\")\n    parser.add_argument(\"-i\", \"--in-place\", action='store_true')\n    parser.add_argument(\n        \"--indent\", type=int, default=2,\n        help=\"Number of spaces used to indent the output yaml.\")\n    parser.add_argument(\n        \"--width\", type=int, default=80,\n        help=\"Number of spaces used as the output width.\")\n    return parser.parse_args()\n\n\ndef main(args):\n    logging.basicConfig(format='\\033[33m%(levelname)s:\\033[37m %(message)s\\033[0m\\n')\n\n    opts = parse_opts(args)\n\n    with open(opts.filename, 'r') as fh:\n        new_format = migrate(fh.read())\n\n    if opts.in_place:\n        output = open(opts.filename, 'w')\n    else:\n        output = sys.stdout\n    write(output, new_format, opts.indent, opts.width)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv)\n", "comments": "    migrate compose file v1 format compose 1 5 v2 format supported compose 1 6          usr bin env python     container  service name    service  service name   ", "content": "#!/usr/bin/env python\n\"\"\"\nMigrate a Compose file from the V1 format in Compose 1.5 to the V2 format\nsupported by Compose 1.6+\n\"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import unicode_literals\n\nimport argparse\nimport logging\nimport sys\n\nimport ruamel.yaml\n\nfrom compose.config.types import VolumeSpec\n\n\nlog = logging.getLogger('migrate')\n\n\ndef migrate(content):\n    data = ruamel.yaml.load(content, ruamel.yaml.RoundTripLoader)\n\n    service_names = data.keys()\n\n    for name, service in data.items():\n        warn_for_links(name, service)\n        warn_for_external_links(name, service)\n        rewrite_net(service, service_names)\n        rewrite_build(service)\n        rewrite_logging(service)\n        rewrite_volumes_from(service, service_names)\n\n    services = {name: data.pop(name) for name in data.keys()}\n\n    data['version'] = \"2\"\n    data['services'] = services\n    create_volumes_section(data)\n\n    return data\n\n\ndef warn_for_links(name, service):\n    links = service.get('links')\n    if links:\n        example_service = links[0].partition(':')[0]\n        log.warn(\n            \"Service {name} has links, which no longer create environment \"\n            \"variables such as {example_service_upper}_PORT. \"\n            \"If you are using those in your application code, you should \"\n            \"instead connect directly to the hostname, e.g. \"\n            \"'{example_service}'.\"\n            .format(name=name, example_service=example_service,\n                    example_service_upper=example_service.upper()))\n\n\ndef warn_for_external_links(name, service):\n    external_links = service.get('external_links')\n    if external_links:\n        log.warn(\n            \"Service {name} has external_links: {ext}, which now work \"\n            \"slightly differently. In particular, two containers must be \"\n            \"connected to at least one network in common in order to \"\n            \"communicate, even if explicitly linked together.\\n\\n\"\n            \"Either connect the external container to your app's default \"\n            \"network, or connect both the external container and your \"\n            \"service's containers to a pre-existing network. See \"\n            \"https://docs.docker.com/compose/networking/ \"\n            \"for more on how to do this.\"\n            .format(name=name, ext=external_links))\n\n\ndef rewrite_net(service, service_names):\n    if 'net' in service:\n        network_mode = service.pop('net')\n\n        # \"container:<service name>\" is now \"service:<service name>\"\n        if network_mode.startswith('container:'):\n            name = network_mode.partition(':')[2]\n            if name in service_names:\n                network_mode = 'service:{}'.format(name)\n\n        service['network_mode'] = network_mode\n\n\ndef rewrite_build(service):\n    if 'dockerfile' in service:\n        service['build'] = {\n            'context': service.pop('build'),\n            'dockerfile': service.pop('dockerfile'),\n        }\n\n\ndef rewrite_logging(service):\n    if 'log_driver' in service:\n        service['logging'] = {'driver': service.pop('log_driver')}\n        if 'log_opt' in service:\n            service['logging']['options'] = service.pop('log_opt')\n\n\ndef rewrite_volumes_from(service, service_names):\n    for idx, volume_from in enumerate(service.get('volumes_from', [])):\n        if volume_from.split(':', 1)[0] not in service_names:\n            service['volumes_from'][idx] = 'container:%s' % volume_from\n\n\ndef create_volumes_section(data):\n    named_volumes = get_named_volumes(data['services'])\n    if named_volumes:\n        log.warn(\n            \"Named volumes ({names}) must be explicitly declared. Creating a \"\n            \"'volumes' section with declarations.\\n\\n\"\n            \"For backwards-compatibility, they've been declared as external. \"\n            \"If you don't mind the volume names being prefixed with the \"\n            \"project name, you can remove the 'external' option from each one.\"\n            .format(names=', '.join(list(named_volumes))))\n\n        data['volumes'] = named_volumes\n\n\ndef get_named_volumes(services):\n    volume_specs = [\n        VolumeSpec.parse(volume)\n        for service in services.values()\n        for volume in service.get('volumes', [])\n    ]\n    names = {\n        spec.external\n        for spec in volume_specs\n        if spec.is_named_volume\n    }\n    return {name: {'external': True} for name in names}\n\n\ndef write(stream, new_format, indent, width):\n    ruamel.yaml.dump(\n        new_format,\n        stream,\n        Dumper=ruamel.yaml.RoundTripDumper,\n        indent=indent,\n        width=width)\n\n\ndef parse_opts(args):\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"filename\", help=\"Compose file filename.\")\n    parser.add_argument(\"-i\", \"--in-place\", action='store_true')\n    parser.add_argument(\n        \"--indent\", type=int, default=2,\n        help=\"Number of spaces used to indent the output yaml.\")\n    parser.add_argument(\n        \"--width\", type=int, default=80,\n        help=\"Number of spaces used as the output width.\")\n    return parser.parse_args()\n\n\ndef main(args):\n    logging.basicConfig(format='\\033[33m%(levelname)s:\\033[37m %(message)s\\033[0m\\n')\n\n    opts = parse_opts(args)\n\n    with open(opts.filename, 'r') as fh:\n        new_format = migrate(fh.read())\n\n    if opts.in_place:\n        output = open(opts.filename, 'w')\n    else:\n        output = sys.stdout\n    write(output, new_format, opts.indent, opts.width)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv)\n", "description": "Define and run multi-container applications with Docker", "file_name": "migrate-compose-file-v1-to-v2.py", "id": "c32fb39e9b7c228374a868ec023ecff5", "language": "Python", "project_name": "compose", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/docker-compose/docker-compose-867ad15/contrib/migration/migrate-compose-file-v1-to-v2.py", "save_time": "", "source": "", "update_at": "2018-03-13T22:03:14Z", "url": "https://github.com/docker/compose", "wiki": false}