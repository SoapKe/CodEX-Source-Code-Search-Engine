{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom odoo import api, fields, models, SUPERUSER_ID, _\nfrom odoo.exceptions import UserError, ValidationError\n\n\nclass PosSession(models.Model):\n    _name = 'pos.session'\n    _order = 'id desc'\n\n    POS_SESSION_STATE = [\n        ('opening_control', 'Opening Control'),  \n        ('opened', 'In Progress'),               \n        ('closing_control', 'Closing Control'),  \n        ('closed', 'Closed & Posted'),\n    ]\n\n    def _confirm_orders(self):\n        for session in self:\n            company_id = session.config_id.journal_id.company_id.id\n            orders = session.order_ids.filtered(lambda order: order.state == 'paid')\n            journal_id = self.env['ir.config_parameter'].sudo().get_param(\n                'pos.closing.journal_id_%s' % company_id, default=session.config_id.journal_id.id)\n            if not journal_id:\n                raise UserError(_(\"You have to set a Sale Journal for the POS:%s\") % (session.config_id.name,))\n\n            move = self.env['pos.order'].with_context(force_company=company_id)._create_account_move(session.start_at, session.name, int(journal_id), company_id)\n            orders.with_context(force_company=company_id)._create_account_move_line(session, move)\n            for order in session.order_ids.filtered(lambda o: o.state not in ['done', 'invoiced']):\n                if order.state not in ('paid'):\n                    raise UserError(\n                        _(\"You cannot confirm all orders of this session, because they have not the 'paid' status.\\n\"\n                          \"{reference} is in state {state}, total amount: {total}, paid: {paid}\").format(\n                            reference=order.pos_reference or order.name,\n                            state=order.state,\n                            total=order.amount_total,\n                            paid=order.amount_paid,\n                        ))\n                order.action_pos_order_done()\n            orders = session.order_ids.filtered(lambda order: order.state in ['invoiced', 'done'])\n            orders.sudo()._reconcile_payments()\n\n    config_id = fields.Many2one(\n        'pos.config', string='Point of Sale',\n        help=\"The physical point of sale you will use.\",\n        required=True,\n        index=True)\n    name = fields.Char(string='Session ID', required=True, readonly=True, default='/')\n    user_id = fields.Many2one(\n        'res.users', string='Responsible',\n        required=True,\n        index=True,\n        readonly=True,\n        states={'opening_control': [('readonly', False)]},\n        default=lambda self: self.env.uid)\n    currency_id = fields.Many2one('res.currency', related='config_id.currency_id', string=\"Currency\")\n    start_at = fields.Datetime(string='Opening Date', readonly=True)\n    stop_at = fields.Datetime(string='Closing Date', readonly=True, copy=False)\n\n    state = fields.Selection(\n        POS_SESSION_STATE, string='Status',\n        required=True, readonly=True,\n        index=True, copy=False, default='opening_control')\n\n    sequence_number = fields.Integer(string='Order Sequence Number', help='A sequence number that is incremented with each order', default=1)\n    login_number = fields.Integer(string='Login Sequence Number', help='A sequence number that is incremented each time a user resumes the pos session', default=0)\n\n    cash_control = fields.Boolean(compute='_compute_cash_all', string='Has Cash Control')\n    cash_journal_id = fields.Many2one('account.journal', compute='_compute_cash_all', string='Cash Journal', store=True)\n    cash_register_id = fields.Many2one('account.bank.statement', compute='_compute_cash_all', string='Cash Register', store=True)\n\n    cash_register_balance_end_real = fields.Monetary(\n        related='cash_register_id.balance_end_real',\n        string=\"Ending Balance\",\n        help=\"Total of closing cash control lines.\",\n        readonly=True)\n    cash_register_balance_start = fields.Monetary(\n        related='cash_register_id.balance_start',\n        string=\"Starting Balance\",\n        help=\"Total of opening cash control lines.\",\n        readonly=True)\n    cash_register_total_entry_encoding = fields.Monetary(\n        related='cash_register_id.total_entry_encoding',\n        string='Total Cash Transaction',\n        readonly=True,\n        help=\"Total of all paid sales orders\")\n    cash_register_balance_end = fields.Monetary(\n        related='cash_register_id.balance_end',\n        digits=0,\n        string=\"Theoretical Closing Balance\",\n        help=\"Sum of opening balance and transactions.\",\n        readonly=True)\n    cash_register_difference = fields.Monetary(\n        related='cash_register_id.difference',\n        string='Difference',\n        help=\"Difference between the theoretical closing balance and the real closing balance.\",\n        readonly=True)\n\n    journal_ids = fields.Many2many(\n        'account.journal',\n        related='config_id.journal_ids',\n        readonly=True,\n        string='Available Payment Methods')\n    order_ids = fields.One2many('pos.order', 'session_id',  string='Orders')\n    statement_ids = fields.One2many('account.bank.statement', 'pos_session_id', string='Bank Statement', readonly=True)\n    picking_count = fields.Integer(compute='_compute_picking_count')\n    rescue = fields.Boolean(string='Recovery Session',\n        help=\"Auto-generated session for orphan orders, ignored in constraints\",\n        readonly=True,\n        copy=False)\n\n    _sql_constraints = [('uniq_name', 'unique(name)', \"The name of this POS Session must be unique !\")]\n\n    @api.multi\n    def _compute_picking_count(self):\n        for pos in self:\n            pickings = pos.order_ids.mapped('picking_id').filtered(lambda x: x.state != 'done')\n            pos.picking_count = len(pickings.ids)\n\n    @api.multi\n    def action_stock_picking(self):\n        pickings = self.order_ids.mapped('picking_id').filtered(lambda x: x.state != 'done')\n        action_picking = self.env.ref('stock.action_picking_tree_ready')\n        action = action_picking.read()[0]\n        action['context'] = {}\n        action['domain'] = [('id', 'in', pickings.ids)]\n        return action\n\n    @api.depends('config_id', 'statement_ids')\n    def _compute_cash_all(self):\n        for session in self:\n            session.cash_journal_id = session.cash_register_id = session.cash_control = False\n            if session.config_id.cash_control:\n                for statement in session.statement_ids:\n                    if statement.journal_id.type == 'cash':\n                        session.cash_control = True\n                        session.cash_journal_id = statement.journal_id.id\n                        session.cash_register_id = statement.id\n                if not session.cash_control and session.state != 'closed':\n                    raise UserError(_(\"Cash control can only be applied to cash journals.\"))\n\n    @api.constrains('user_id', 'state')\n    def _check_unicity(self):\n        \n        if self.search_count([\n                ('state', 'not in', ('closed', 'closing_control')),\n                ('user_id', '=', self.user_id.id),\n                ('rescue', '=', False)\n            ]) > 1:\n            raise ValidationError(_(\"You cannot create two active sessions with the same responsible!\"))\n\n    @api.constrains('config_id')\n    def _check_pos_config(self):\n        if self.search_count([\n                ('state', '!=', 'closed'),\n                ('config_id', '=', self.config_id.id),\n                ('rescue', '=', False)\n            ]) > 1:\n            raise ValidationError(_(\"Another session is already opened for this point of sale.\"))\n\n    @api.model\n    def create(self, values):\n        config_id = values.get('config_id') or self.env.context.get('default_config_id')\n        if not config_id:\n            raise UserError(_(\"You should assign a Point of Sale to your session.\"))\n\n        \n        \n        \n        \n        pos_config = self.env['pos.config'].browse(config_id)\n        ctx = dict(self.env.context, company_id=pos_config.company_id.id)\n        if not pos_config.journal_id:\n            default_journals = pos_config.with_context(ctx).default_get(['journal_id', 'invoice_journal_id'])\n            if (not default_journals.get('journal_id') or\n                    not default_journals.get('invoice_journal_id')):\n                raise UserError(_(\"Unable to open the session. You have to assign a sales journal to your point of sale.\"))\n            pos_config.with_context(ctx).sudo().write({\n                'journal_id': default_journals['journal_id'],\n                'invoice_journal_id': default_journals['invoice_journal_id']})\n        \n        if not pos_config.journal_ids:\n            Journal = self.env['account.journal']\n            journals = Journal.with_context(ctx).search([('journal_user', '=', True), ('type', '=', 'cash')])\n            if not journals:\n                journals = Journal.with_context(ctx).search([('type', '=', 'cash')])\n                if not journals:\n                    journals = Journal.with_context(ctx).search([('journal_user', '=', True)])\n            journals.sudo().write({'journal_user': True})\n            pos_config.sudo().write({'journal_ids': [(6, 0, journals.ids)]})\n\n        pos_name = self.env['ir.sequence'].with_context(ctx).next_by_code('pos.session')\n        if values.get('name'):\n            pos_name += ' ' + values['name']\n\n        statements = []\n        ABS = self.env['account.bank.statement']\n        uid = SUPERUSER_ID if self.env.user.has_group('point_of_sale.group_pos_user') else self.env.user.id\n        for journal in pos_config.journal_ids:\n            \n            \n            \n            ctx['journal_id'] = journal.id if pos_config.cash_control and journal.type == 'cash' else False\n            st_values = {\n                'journal_id': journal.id,\n                'user_id': self.env.user.id,\n                'name': pos_name\n            }\n\n            statements.append(ABS.with_context(ctx).sudo(uid).create(st_values).id)\n\n        values.update({\n            'name': pos_name,\n            'statement_ids': [(6, 0, statements)],\n            'config_id': config_id\n        })\n\n        res = super(PosSession, self.with_context(ctx).sudo(uid)).create(values)\n        if not pos_config.cash_control:\n            res.action_pos_session_open()\n\n        return res\n\n    @api.multi\n    def unlink(self):\n        for session in self.filtered(lambda s: s.statement_ids):\n            session.statement_ids.unlink()\n        return super(PosSession, self).unlink()\n\n    @api.multi\n    def login(self):\n        self.ensure_one()\n        self.write({\n            'login_number': self.login_number + 1,\n        })\n\n    @api.multi\n    def action_pos_session_open(self):\n        \n        \n        for session in self.filtered(lambda session: session.state == 'opening_control'):\n            values = {}\n            if not session.start_at:\n                values['start_at'] = fields.Datetime.now()\n            values['state'] = 'opened'\n            session.write(values)\n            session.statement_ids.button_open()\n        return True\n\n    @api.multi\n    def action_pos_session_closing_control(self):\n        self._check_pos_session_balance()\n        for session in self:\n            session.write({'state': 'closing_control', 'stop_at': fields.Datetime.now()})\n            if not session.config_id.cash_control:\n                session.action_pos_session_close()\n\n    @api.multi\n    def _check_pos_session_balance(self):\n        for session in self:\n            for statement in session.statement_ids:\n                if (statement != session.cash_register_id) and (statement.balance_end != statement.balance_end_real):\n                    statement.write({'balance_end_real': statement.balance_end})\n\n    @api.multi\n    def action_pos_session_validate(self):\n        self._check_pos_session_balance()\n        self.action_pos_session_close()\n\n    @api.multi\n    def action_pos_session_close(self):\n        \n        for session in self:\n            company_id = session.config_id.company_id.id\n            ctx = dict(self.env.context, force_company=company_id, company_id=company_id)\n            for st in session.statement_ids:\n                if abs(st.difference) > st.journal_id.amount_authorized_diff:\n                    \n                    if not self.user_has_groups(\"point_of_sale.group_pos_manager\"):\n                        raise UserError(_(\"Your ending balance is too different from the theoretical cash closing (%.2f), the maximum allowed is: %.2f. You can contact your manager to force it.\") % (st.difference, st.journal_id.amount_authorized_diff))\n                if (st.journal_id.type not in ['bank', 'cash']):\n                    raise UserError(_(\"The type of the journal for your payment method should be bank or cash \"))\n                st.with_context(ctx).sudo().button_confirm_bank()\n        self.with_context(ctx)._confirm_orders()\n        self.write({'state': 'closed'})\n        return {\n            'type': 'ir.actions.client',\n            'name': 'Point of Sale Menu',\n            'tag': 'reload',\n            'params': {'menu_id': self.env.ref('point_of_sale.menu_point_root').id},\n        }\n\n    @api.multi\n    def open_frontend_cb(self):\n        if not self.ids:\n            return {}\n        for session in self.filtered(lambda s: s.user_id.id != self.env.uid):\n            raise UserError(_(\"You cannot use the session of another user. This session is owned by %s. \"\n                              \"Please first close this one to use this point of sale.\") % session.user_id.name)\n        return {\n            'type': 'ir.actions.act_url',\n            'target': 'self',\n            'url':   '/pos/web/',\n        }\n\n    @api.multi\n    def open_cashbox(self):\n        self.ensure_one()\n        context = dict(self._context)\n        balance_type = context.get('balance') or 'start'\n        context['bank_statement_id'] = self.cash_register_id.id\n        context['balance'] = balance_type\n        context['default_pos_id'] = self.config_id.id\n\n        action = {\n            'name': _('Cash Control'),\n            'view_type': 'form',\n            'view_mode': 'form',\n            'res_model': 'account.bank.statement.cashbox',\n            'view_id': self.env.ref('account.view_account_bnk_stmt_cashbox').id,\n            'type': 'ir.actions.act_window',\n            'context': context,\n            'target': 'new'\n        }\n\n        cashbox_id = None\n        if balance_type == 'start':\n            cashbox_id = self.cash_register_id.cashbox_start_id.id\n        else:\n            cashbox_id = self.cash_register_id.cashbox_end_id.id\n        if cashbox_id:\n            action['res_id'] = cashbox_id\n\n        return action\n", "comments": "      coding  utf 8        part odoo  see license file full copyright licensing details     method action pos session open    method action pos session closing control    method action pos session close    open session  opening control    opened    closing control  one user    journal id required pos config    exists installation  if nothing configured    installation minimal configuration  impossible     xml files coa yet installed     define cash journal payment method exists    set journal id used    account bank statement set opening balance    newly created bank statement    second browse need refetch data db cash register id    open sessions already opened    close cashbox    the pos manager close statements maximums  ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom odoo import api, fields, models, SUPERUSER_ID, _\nfrom odoo.exceptions import UserError, ValidationError\n\n\nclass PosSession(models.Model):\n    _name = 'pos.session'\n    _order = 'id desc'\n\n    POS_SESSION_STATE = [\n        ('opening_control', 'Opening Control'),  # method action_pos_session_open\n        ('opened', 'In Progress'),               # method action_pos_session_closing_control\n        ('closing_control', 'Closing Control'),  # method action_pos_session_close\n        ('closed', 'Closed & Posted'),\n    ]\n\n    def _confirm_orders(self):\n        for session in self:\n            company_id = session.config_id.journal_id.company_id.id\n            orders = session.order_ids.filtered(lambda order: order.state == 'paid')\n            journal_id = self.env['ir.config_parameter'].sudo().get_param(\n                'pos.closing.journal_id_%s' % company_id, default=session.config_id.journal_id.id)\n            if not journal_id:\n                raise UserError(_(\"You have to set a Sale Journal for the POS:%s\") % (session.config_id.name,))\n\n            move = self.env['pos.order'].with_context(force_company=company_id)._create_account_move(session.start_at, session.name, int(journal_id), company_id)\n            orders.with_context(force_company=company_id)._create_account_move_line(session, move)\n            for order in session.order_ids.filtered(lambda o: o.state not in ['done', 'invoiced']):\n                if order.state not in ('paid'):\n                    raise UserError(\n                        _(\"You cannot confirm all orders of this session, because they have not the 'paid' status.\\n\"\n                          \"{reference} is in state {state}, total amount: {total}, paid: {paid}\").format(\n                            reference=order.pos_reference or order.name,\n                            state=order.state,\n                            total=order.amount_total,\n                            paid=order.amount_paid,\n                        ))\n                order.action_pos_order_done()\n            orders = session.order_ids.filtered(lambda order: order.state in ['invoiced', 'done'])\n            orders.sudo()._reconcile_payments()\n\n    config_id = fields.Many2one(\n        'pos.config', string='Point of Sale',\n        help=\"The physical point of sale you will use.\",\n        required=True,\n        index=True)\n    name = fields.Char(string='Session ID', required=True, readonly=True, default='/')\n    user_id = fields.Many2one(\n        'res.users', string='Responsible',\n        required=True,\n        index=True,\n        readonly=True,\n        states={'opening_control': [('readonly', False)]},\n        default=lambda self: self.env.uid)\n    currency_id = fields.Many2one('res.currency', related='config_id.currency_id', string=\"Currency\")\n    start_at = fields.Datetime(string='Opening Date', readonly=True)\n    stop_at = fields.Datetime(string='Closing Date', readonly=True, copy=False)\n\n    state = fields.Selection(\n        POS_SESSION_STATE, string='Status',\n        required=True, readonly=True,\n        index=True, copy=False, default='opening_control')\n\n    sequence_number = fields.Integer(string='Order Sequence Number', help='A sequence number that is incremented with each order', default=1)\n    login_number = fields.Integer(string='Login Sequence Number', help='A sequence number that is incremented each time a user resumes the pos session', default=0)\n\n    cash_control = fields.Boolean(compute='_compute_cash_all', string='Has Cash Control')\n    cash_journal_id = fields.Many2one('account.journal', compute='_compute_cash_all', string='Cash Journal', store=True)\n    cash_register_id = fields.Many2one('account.bank.statement', compute='_compute_cash_all', string='Cash Register', store=True)\n\n    cash_register_balance_end_real = fields.Monetary(\n        related='cash_register_id.balance_end_real',\n        string=\"Ending Balance\",\n        help=\"Total of closing cash control lines.\",\n        readonly=True)\n    cash_register_balance_start = fields.Monetary(\n        related='cash_register_id.balance_start',\n        string=\"Starting Balance\",\n        help=\"Total of opening cash control lines.\",\n        readonly=True)\n    cash_register_total_entry_encoding = fields.Monetary(\n        related='cash_register_id.total_entry_encoding',\n        string='Total Cash Transaction',\n        readonly=True,\n        help=\"Total of all paid sales orders\")\n    cash_register_balance_end = fields.Monetary(\n        related='cash_register_id.balance_end',\n        digits=0,\n        string=\"Theoretical Closing Balance\",\n        help=\"Sum of opening balance and transactions.\",\n        readonly=True)\n    cash_register_difference = fields.Monetary(\n        related='cash_register_id.difference',\n        string='Difference',\n        help=\"Difference between the theoretical closing balance and the real closing balance.\",\n        readonly=True)\n\n    journal_ids = fields.Many2many(\n        'account.journal',\n        related='config_id.journal_ids',\n        readonly=True,\n        string='Available Payment Methods')\n    order_ids = fields.One2many('pos.order', 'session_id',  string='Orders')\n    statement_ids = fields.One2many('account.bank.statement', 'pos_session_id', string='Bank Statement', readonly=True)\n    picking_count = fields.Integer(compute='_compute_picking_count')\n    rescue = fields.Boolean(string='Recovery Session',\n        help=\"Auto-generated session for orphan orders, ignored in constraints\",\n        readonly=True,\n        copy=False)\n\n    _sql_constraints = [('uniq_name', 'unique(name)', \"The name of this POS Session must be unique !\")]\n\n    @api.multi\n    def _compute_picking_count(self):\n        for pos in self:\n            pickings = pos.order_ids.mapped('picking_id').filtered(lambda x: x.state != 'done')\n            pos.picking_count = len(pickings.ids)\n\n    @api.multi\n    def action_stock_picking(self):\n        pickings = self.order_ids.mapped('picking_id').filtered(lambda x: x.state != 'done')\n        action_picking = self.env.ref('stock.action_picking_tree_ready')\n        action = action_picking.read()[0]\n        action['context'] = {}\n        action['domain'] = [('id', 'in', pickings.ids)]\n        return action\n\n    @api.depends('config_id', 'statement_ids')\n    def _compute_cash_all(self):\n        for session in self:\n            session.cash_journal_id = session.cash_register_id = session.cash_control = False\n            if session.config_id.cash_control:\n                for statement in session.statement_ids:\n                    if statement.journal_id.type == 'cash':\n                        session.cash_control = True\n                        session.cash_journal_id = statement.journal_id.id\n                        session.cash_register_id = statement.id\n                if not session.cash_control and session.state != 'closed':\n                    raise UserError(_(\"Cash control can only be applied to cash journals.\"))\n\n    @api.constrains('user_id', 'state')\n    def _check_unicity(self):\n        # open if there is no session in 'opening_control', 'opened', 'closing_control' for one user\n        if self.search_count([\n                ('state', 'not in', ('closed', 'closing_control')),\n                ('user_id', '=', self.user_id.id),\n                ('rescue', '=', False)\n            ]) > 1:\n            raise ValidationError(_(\"You cannot create two active sessions with the same responsible!\"))\n\n    @api.constrains('config_id')\n    def _check_pos_config(self):\n        if self.search_count([\n                ('state', '!=', 'closed'),\n                ('config_id', '=', self.config_id.id),\n                ('rescue', '=', False)\n            ]) > 1:\n            raise ValidationError(_(\"Another session is already opened for this point of sale.\"))\n\n    @api.model\n    def create(self, values):\n        config_id = values.get('config_id') or self.env.context.get('default_config_id')\n        if not config_id:\n            raise UserError(_(\"You should assign a Point of Sale to your session.\"))\n\n        # journal_id is not required on the pos_config because it does not\n        # exists at the installation. If nothing is configured at the\n        # installation we do the minimal configuration. Impossible to do in\n        # the .xml files as the CoA is not yet installed.\n        pos_config = self.env['pos.config'].browse(config_id)\n        ctx = dict(self.env.context, company_id=pos_config.company_id.id)\n        if not pos_config.journal_id:\n            default_journals = pos_config.with_context(ctx).default_get(['journal_id', 'invoice_journal_id'])\n            if (not default_journals.get('journal_id') or\n                    not default_journals.get('invoice_journal_id')):\n                raise UserError(_(\"Unable to open the session. You have to assign a sales journal to your point of sale.\"))\n            pos_config.with_context(ctx).sudo().write({\n                'journal_id': default_journals['journal_id'],\n                'invoice_journal_id': default_journals['invoice_journal_id']})\n        # define some cash journal if no payment method exists\n        if not pos_config.journal_ids:\n            Journal = self.env['account.journal']\n            journals = Journal.with_context(ctx).search([('journal_user', '=', True), ('type', '=', 'cash')])\n            if not journals:\n                journals = Journal.with_context(ctx).search([('type', '=', 'cash')])\n                if not journals:\n                    journals = Journal.with_context(ctx).search([('journal_user', '=', True)])\n            journals.sudo().write({'journal_user': True})\n            pos_config.sudo().write({'journal_ids': [(6, 0, journals.ids)]})\n\n        pos_name = self.env['ir.sequence'].with_context(ctx).next_by_code('pos.session')\n        if values.get('name'):\n            pos_name += ' ' + values['name']\n\n        statements = []\n        ABS = self.env['account.bank.statement']\n        uid = SUPERUSER_ID if self.env.user.has_group('point_of_sale.group_pos_user') else self.env.user.id\n        for journal in pos_config.journal_ids:\n            # set the journal_id which should be used by\n            # account.bank.statement to set the opening balance of the\n            # newly created bank statement\n            ctx['journal_id'] = journal.id if pos_config.cash_control and journal.type == 'cash' else False\n            st_values = {\n                'journal_id': journal.id,\n                'user_id': self.env.user.id,\n                'name': pos_name\n            }\n\n            statements.append(ABS.with_context(ctx).sudo(uid).create(st_values).id)\n\n        values.update({\n            'name': pos_name,\n            'statement_ids': [(6, 0, statements)],\n            'config_id': config_id\n        })\n\n        res = super(PosSession, self.with_context(ctx).sudo(uid)).create(values)\n        if not pos_config.cash_control:\n            res.action_pos_session_open()\n\n        return res\n\n    @api.multi\n    def unlink(self):\n        for session in self.filtered(lambda s: s.statement_ids):\n            session.statement_ids.unlink()\n        return super(PosSession, self).unlink()\n\n    @api.multi\n    def login(self):\n        self.ensure_one()\n        self.write({\n            'login_number': self.login_number + 1,\n        })\n\n    @api.multi\n    def action_pos_session_open(self):\n        # second browse because we need to refetch the data from the DB for cash_register_id\n        # we only open sessions that haven't already been opened\n        for session in self.filtered(lambda session: session.state == 'opening_control'):\n            values = {}\n            if not session.start_at:\n                values['start_at'] = fields.Datetime.now()\n            values['state'] = 'opened'\n            session.write(values)\n            session.statement_ids.button_open()\n        return True\n\n    @api.multi\n    def action_pos_session_closing_control(self):\n        self._check_pos_session_balance()\n        for session in self:\n            session.write({'state': 'closing_control', 'stop_at': fields.Datetime.now()})\n            if not session.config_id.cash_control:\n                session.action_pos_session_close()\n\n    @api.multi\n    def _check_pos_session_balance(self):\n        for session in self:\n            for statement in session.statement_ids:\n                if (statement != session.cash_register_id) and (statement.balance_end != statement.balance_end_real):\n                    statement.write({'balance_end_real': statement.balance_end})\n\n    @api.multi\n    def action_pos_session_validate(self):\n        self._check_pos_session_balance()\n        self.action_pos_session_close()\n\n    @api.multi\n    def action_pos_session_close(self):\n        # Close CashBox\n        for session in self:\n            company_id = session.config_id.company_id.id\n            ctx = dict(self.env.context, force_company=company_id, company_id=company_id)\n            for st in session.statement_ids:\n                if abs(st.difference) > st.journal_id.amount_authorized_diff:\n                    # The pos manager can close statements with maximums.\n                    if not self.user_has_groups(\"point_of_sale.group_pos_manager\"):\n                        raise UserError(_(\"Your ending balance is too different from the theoretical cash closing (%.2f), the maximum allowed is: %.2f. You can contact your manager to force it.\") % (st.difference, st.journal_id.amount_authorized_diff))\n                if (st.journal_id.type not in ['bank', 'cash']):\n                    raise UserError(_(\"The type of the journal for your payment method should be bank or cash \"))\n                st.with_context(ctx).sudo().button_confirm_bank()\n        self.with_context(ctx)._confirm_orders()\n        self.write({'state': 'closed'})\n        return {\n            'type': 'ir.actions.client',\n            'name': 'Point of Sale Menu',\n            'tag': 'reload',\n            'params': {'menu_id': self.env.ref('point_of_sale.menu_point_root').id},\n        }\n\n    @api.multi\n    def open_frontend_cb(self):\n        if not self.ids:\n            return {}\n        for session in self.filtered(lambda s: s.user_id.id != self.env.uid):\n            raise UserError(_(\"You cannot use the session of another user. This session is owned by %s. \"\n                              \"Please first close this one to use this point of sale.\") % session.user_id.name)\n        return {\n            'type': 'ir.actions.act_url',\n            'target': 'self',\n            'url':   '/pos/web/',\n        }\n\n    @api.multi\n    def open_cashbox(self):\n        self.ensure_one()\n        context = dict(self._context)\n        balance_type = context.get('balance') or 'start'\n        context['bank_statement_id'] = self.cash_register_id.id\n        context['balance'] = balance_type\n        context['default_pos_id'] = self.config_id.id\n\n        action = {\n            'name': _('Cash Control'),\n            'view_type': 'form',\n            'view_mode': 'form',\n            'res_model': 'account.bank.statement.cashbox',\n            'view_id': self.env.ref('account.view_account_bnk_stmt_cashbox').id,\n            'type': 'ir.actions.act_window',\n            'context': context,\n            'target': 'new'\n        }\n\n        cashbox_id = None\n        if balance_type == 'start':\n            cashbox_id = self.cash_register_id.cashbox_start_id.id\n        else:\n            cashbox_id = self.cash_register_id.cashbox_end_id.id\n        if cashbox_id:\n            action['res_id'] = cashbox_id\n\n        return action\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "pos_session.py", "id": "f396b0267b0265958cd503c773c631a4", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/point_of_sale/models/pos_session.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}