{"author": "nvbn", "code": "\nfrom ..system import init_output\n\ninit_output()\n\nimport getpass  \nimport os  \nimport json  \nfrom tempfile import gettempdir  \nimport time  \nimport six  \nfrom psutil import Process  \nfrom .. import logs, const  \nfrom ..shells import shell  \nfrom ..conf import settings  \nfrom ..system import Path  \n\n\ndef _get_shell_pid():\n    \n    settings.init()\n    configuration_details = shell.how_to_configure()\n    if (\n        configuration_details and\n        configuration_details.can_configure_automatically\n    ):\n        if _is_already_configured(configuration_details):\n            logs.already_configured(configuration_details)\n            return\n        elif _is_second_run():\n            _configure(configuration_details)\n            logs.configured_successfully(configuration_details)\n            return\n        else:\n            _record_first_run()\n\n    logs.how_to_configure_alias(configuration_details)\n", "comments": "Returns parent process pid.\"\"\"\n    proc = Process(os.getpid())\n\n    try:\n        return proc.parent().pid\n    except TypeError:\n        return proc.parent.pid\n\n\ndef _get_not_configured_usage_tracker_path():\n    \"\"\"Returns path of special file where we store latest shell pid.\"\"\"\n    return Path(gettempdir()).joinpath(u'thefuck.last_not_configured_run_{}'.format(\n        getpass.getuser(),\n    ))\n\n\ndef _record_first_run():\n    \"\"\"Records shell pid to tracker file.\"\"\"\n    info = {'pid': _get_shell_pid(),\n            'time': time.time()}\n\n    mode = 'wb' if six.PY2 else 'w'\n    with _get_not_configured_usage_tracker_path().open(mode) as tracker:\n        json.dump(info, tracker)\n\n\ndef _get_previous_command():\n    history = shell.get_history()\n\n    if history:\n        return history[-1]\n    else:\n        return None\n\n\ndef _is_second_run():\n    \"\"\"Returns `True` when we know that `fuck` called second time.\"\"\"\n    tracker_path = _get_not_configured_usage_tracker_path()\n    if not tracker_path.exists():\n        return False\n\n    current_pid = _get_shell_pid()\n    with tracker_path.open('r') as tracker:\n        try:\n            info = json.load(tracker)\n        except ValueError:\n            return False\n\n    if not (isinstance(info, dict) and info.get('pid') == current_pid):\n        return False\n\n    return (_get_previous_command() == 'fuck' or\n            time.time() - info.get('time', 0) < const.CONFIGURATION_TIMEOUT)\n\n\ndef _is_already_configured(configuration_details):\n    \"\"\"Returns `True` when alias already in shell config.\"\"\"\n    path = Path(configuration_details.path).expanduser()\n    with path.open('r') as shell_config:\n        return configuration_details.content in shell_config.read()\n\n\ndef _configure(configuration_details):\n    \"\"\"Adds alias to shell config.\"\"\"\n    path = Path(configuration_details.path).expanduser()\n    with path.open('a') as shell_config:\n        shell_config.write(u'\\n')\n        shell_config.write(configuration_details.content)\n        shell_config.write(u'\\n')\n\n\ndef main():\n    \"\"\"Shows useful information about how-to configure alias on a first run\n    and configure automatically on a second.\n\n    It'll be only visible when user type fuck and when alias isn't configured.\n\n    \n \n# Initialize output before importing any module, that can use colorama.\n# noqa: E402\n# noqa: E402\n# noqa: E402\n# noqa: E402\n# noqa: E402\n# noqa: E402\n# noqa: E402\n# noqa: E402\n# noqa: E402\n# noqa: E402\n# noqa: E402\n", "content": "# Initialize output before importing any module, that can use colorama.\nfrom ..system import init_output\n\ninit_output()\n\nimport getpass  # noqa: E402\nimport os  # noqa: E402\nimport json  # noqa: E402\nfrom tempfile import gettempdir  # noqa: E402\nimport time  # noqa: E402\nimport six  # noqa: E402\nfrom psutil import Process  # noqa: E402\nfrom .. import logs, const  # noqa: E402\nfrom ..shells import shell  # noqa: E402\nfrom ..conf import settings  # noqa: E402\nfrom ..system import Path  # noqa: E402\n\n\ndef _get_shell_pid():\n    \"\"\"Returns parent process pid.\"\"\"\n    proc = Process(os.getpid())\n\n    try:\n        return proc.parent().pid\n    except TypeError:\n        return proc.parent.pid\n\n\ndef _get_not_configured_usage_tracker_path():\n    \"\"\"Returns path of special file where we store latest shell pid.\"\"\"\n    return Path(gettempdir()).joinpath(u'thefuck.last_not_configured_run_{}'.format(\n        getpass.getuser(),\n    ))\n\n\ndef _record_first_run():\n    \"\"\"Records shell pid to tracker file.\"\"\"\n    info = {'pid': _get_shell_pid(),\n            'time': time.time()}\n\n    mode = 'wb' if six.PY2 else 'w'\n    with _get_not_configured_usage_tracker_path().open(mode) as tracker:\n        json.dump(info, tracker)\n\n\ndef _get_previous_command():\n    history = shell.get_history()\n\n    if history:\n        return history[-1]\n    else:\n        return None\n\n\ndef _is_second_run():\n    \"\"\"Returns `True` when we know that `fuck` called second time.\"\"\"\n    tracker_path = _get_not_configured_usage_tracker_path()\n    if not tracker_path.exists():\n        return False\n\n    current_pid = _get_shell_pid()\n    with tracker_path.open('r') as tracker:\n        try:\n            info = json.load(tracker)\n        except ValueError:\n            return False\n\n    if not (isinstance(info, dict) and info.get('pid') == current_pid):\n        return False\n\n    return (_get_previous_command() == 'fuck' or\n            time.time() - info.get('time', 0) < const.CONFIGURATION_TIMEOUT)\n\n\ndef _is_already_configured(configuration_details):\n    \"\"\"Returns `True` when alias already in shell config.\"\"\"\n    path = Path(configuration_details.path).expanduser()\n    with path.open('r') as shell_config:\n        return configuration_details.content in shell_config.read()\n\n\ndef _configure(configuration_details):\n    \"\"\"Adds alias to shell config.\"\"\"\n    path = Path(configuration_details.path).expanduser()\n    with path.open('a') as shell_config:\n        shell_config.write(u'\\n')\n        shell_config.write(configuration_details.content)\n        shell_config.write(u'\\n')\n\n\ndef main():\n    \"\"\"Shows useful information about how-to configure alias on a first run\n    and configure automatically on a second.\n\n    It'll be only visible when user type fuck and when alias isn't configured.\n\n    \"\"\"\n    settings.init()\n    configuration_details = shell.how_to_configure()\n    if (\n        configuration_details and\n        configuration_details.can_configure_automatically\n    ):\n        if _is_already_configured(configuration_details):\n            logs.already_configured(configuration_details)\n            return\n        elif _is_second_run():\n            _configure(configuration_details)\n            logs.configured_successfully(configuration_details)\n            return\n        else:\n            _record_first_run()\n\n    logs.how_to_configure_alias(configuration_details)\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "not_configured.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/thefuck/entrypoints/not_configured.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}