{"author": "django", "code": "from django.core.exceptions import FieldError\nfrom django.test import SimpleTestCase, TestCase\n\nfrom .models import (\n    Bookmark, Domain, Family, Genus, HybridSpecies, Kingdom, Klass, Order,\n    Phylum, Pizza, Species, TaggedItem,\n)\n\n\nclass SelectRelatedTests(TestCase):\n\n    @classmethod\n    def create_tree(cls, stringtree):\n        \"\"\"\n        Helper to create a complete tree.\n        \"\"\"\n        names = stringtree.split()\n        models = [Domain, Kingdom, Phylum, Klass, Order, Family, Genus, Species]\n        assert len(names) == len(models), (names, models)\n\n        parent = None\n        for name, model in zip(names, models):\n            try:\n                obj = model.objects.get(name=name)\n            except model.DoesNotExist:\n                obj = model(name=name)\n            if parent:\n                setattr(obj, parent.__class__.__name__.lower(), parent)\n            obj.save()\n            parent = obj\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.create_tree(\"Eukaryota Animalia Anthropoda Insecta Diptera Drosophilidae Drosophila melanogaster\")\n        cls.create_tree(\"Eukaryota Animalia Chordata Mammalia Primates Hominidae Homo sapiens\")\n        cls.create_tree(\"Eukaryota Plantae Magnoliophyta Magnoliopsida Fabales Fabaceae Pisum sativum\")\n        cls.create_tree(\"Eukaryota Fungi Basidiomycota Homobasidiomycatae Agaricales Amanitacae Amanita muscaria\")\n\n    def test_access_fks_without_select_related(self):\n        \"\"\"\n        Normally, accessing FKs doesn't fill in related objects\n        \"\"\"\n        with self.assertNumQueries(8):\n            fly = Species.objects.get(name=\"melanogaster\")\n            domain = fly.genus.family.order.klass.phylum.kingdom.domain\n            self.assertEqual(domain.name, 'Eukaryota')\n\n    def test_access_fks_with_select_related(self):\n        \"\"\"\n        A select_related() call will fill in those related objects without any\n        extra queries\n        \"\"\"\n        with self.assertNumQueries(1):\n            person = (\n                Species.objects\n                .select_related('genus__family__order__klass__phylum__kingdom__domain')\n                .get(name=\"sapiens\")\n            )\n            domain = person.genus.family.order.klass.phylum.kingdom.domain\n            self.assertEqual(domain.name, 'Eukaryota')\n\n    def test_list_without_select_related(self):\n        \"\"\"\n        select_related() also of course applies to entire lists, not just\n        items. This test verifies the expected behavior without select_related.\n        \"\"\"\n        with self.assertNumQueries(9):\n            world = Species.objects.all()\n            families = [o.genus.family.name for o in world]\n            self.assertEqual(sorted(families), [\n                'Amanitacae',\n                'Drosophilidae',\n                'Fabaceae',\n                'Hominidae',\n            ])\n\n    def test_list_with_select_related(self):\n        \"\"\"\n        select_related() also of course applies to entire lists, not just\n        items. This test verifies the expected behavior with select_related.\n        \"\"\"\n        with self.assertNumQueries(1):\n            world = Species.objects.all().select_related()\n            families = [o.genus.family.name for o in world]\n            self.assertEqual(sorted(families), [\n                'Amanitacae',\n                'Drosophilidae',\n                'Fabaceae',\n                'Hominidae',\n            ])\n\n    def test_list_with_depth(self):\n        \"\"\"\n        Passing a relationship field lookup specifier to select_related() will\n        stop the descent at a particular level. This can be used on lists as\n        well.\n        \"\"\"\n        with self.assertNumQueries(5):\n            world = Species.objects.all().select_related('genus__family')\n            orders = [o.genus.family.order.name for o in world]\n            self.assertEqual(sorted(orders), ['Agaricales', 'Diptera', 'Fabales', 'Primates'])\n\n    def test_select_related_with_extra(self):\n        s = (Species.objects.all()\n             .select_related()\n             .extra(select={'a': 'select_related_species.id + 10'})[0])\n        self.assertEqual(s.id + 10, s.a)\n\n    def test_certain_fields(self):\n        \"\"\"\n        The optional fields passed to select_related() control which related\n        models we pull in. This allows for smaller queries.\n\n        In this case, we explicitly say to select the 'genus' and\n        'genus.family' models, leading to the same number of queries as before.\n        \"\"\"\n        with self.assertNumQueries(1):\n            world = Species.objects.select_related('genus__family')\n            families = [o.genus.family.name for o in world]\n            self.assertEqual(sorted(families), ['Amanitacae', 'Drosophilidae', 'Fabaceae', 'Hominidae'])\n\n    def test_more_certain_fields(self):\n        \"\"\"\n        In this case, we explicitly say to select the 'genus' and\n        'genus.family' models, leading to the same number of queries as before.\n        \"\"\"\n        with self.assertNumQueries(2):\n            world = Species.objects.filter(genus__name='Amanita')\\\n                .select_related('genus__family')\n            orders = [o.genus.family.order.name for o in world]\n            self.assertEqual(orders, ['Agaricales'])\n\n    def test_field_traversal(self):\n        with self.assertNumQueries(1):\n            s = (Species.objects.all()\n                 .select_related('genus__family__order')\n                 .order_by('id')[0:1].get().genus.family.order.name)\n            self.assertEqual(s, 'Diptera')\n\n    def test_none_clears_list(self):\n        queryset = Species.objects.select_related('genus').select_related(None)\n        self.assertIs(queryset.query.select_related, False)\n\n    def test_chaining(self):\n        parent_1, parent_2 = Species.objects.all()[:2]\n        HybridSpecies.objects.create(name='hybrid', parent_1=parent_1, parent_2=parent_2)\n        queryset = HybridSpecies.objects.select_related('parent_1').select_related('parent_2')\n        with self.assertNumQueries(1):\n            obj = queryset[0]\n            self.assertEqual(obj.parent_1, parent_1)\n            self.assertEqual(obj.parent_2, parent_2)\n\n    def test_reverse_relation_caching(self):\n        species = Species.objects.select_related('genus').filter(name='melanogaster').first()\n        with self.assertNumQueries(0):\n            self.assertEqual(species.genus.name, 'Drosophila')\n        \n        self.assertEqual(species.genus._state.fields_cache, {})\n        with self.assertNumQueries(1):\n            self.assertEqual(species.genus.species_set.first().name, 'melanogaster')\n\n    def test_select_related_after_values(self):\n        \"\"\"\n        Running select_related() after calling values() raises a TypeError\n        \"\"\"\n        message = \"Cannot call select_related() after .values() or .values_list()\"\n        with self.assertRaisesMessage(TypeError, message):\n            list(Species.objects.values('name').select_related('genus'))\n\n    def test_select_related_after_values_list(self):\n        \"\"\"\n        Running select_related() after calling values_list() raises a TypeError\n        \"\"\"\n        message = \"Cannot call select_related() after .values() or .values_list()\"\n        with self.assertRaisesMessage(TypeError, message):\n            list(Species.objects.values_list('name').select_related('genus'))\n\n\nclass SelectRelatedValidationTests(SimpleTestCase):\n    \"\"\"\n    select_related() should thrown an error on fields that do not exist and\n    non-relational fields.\n    \"\"\"\n    non_relational_error = \"Non-relational field given in select_related: '%s'. Choices are: %s\"\n    invalid_error = \"Invalid field name(s) given in select_related: '%s'. Choices are: %s\"\n\n    def test_non_relational_field(self):\n        with self.assertRaisesMessage(FieldError, self.non_relational_error % ('name', 'genus')):\n            list(Species.objects.select_related('name__some_field'))\n\n        with self.assertRaisesMessage(FieldError, self.non_relational_error % ('name', 'genus')):\n            list(Species.objects.select_related('name'))\n\n        with self.assertRaisesMessage(FieldError, self.non_relational_error % ('name', '(none)')):\n            list(Domain.objects.select_related('name'))\n\n    def test_non_relational_field_nested(self):\n        with self.assertRaisesMessage(FieldError, self.non_relational_error % ('name', 'family')):\n            list(Species.objects.select_related('genus__name'))\n\n    def test_many_to_many_field(self):\n        with self.assertRaisesMessage(FieldError, self.invalid_error % ('toppings', '(none)')):\n            list(Pizza.objects.select_related('toppings'))\n\n    def test_reverse_relational_field(self):\n        with self.assertRaisesMessage(FieldError, self.invalid_error % ('child_1', 'genus')):\n            list(Species.objects.select_related('child_1'))\n\n    def test_invalid_field(self):\n        with self.assertRaisesMessage(FieldError, self.invalid_error % ('invalid_field', 'genus')):\n            list(Species.objects.select_related('invalid_field'))\n\n        with self.assertRaisesMessage(FieldError, self.invalid_error % ('related_invalid_field', 'family')):\n            list(Species.objects.select_related('genus__related_invalid_field'))\n\n        with self.assertRaisesMessage(FieldError, self.invalid_error % ('invalid_field', '(none)')):\n            list(Domain.objects.select_related('invalid_field'))\n\n    def test_generic_relations(self):\n        with self.assertRaisesMessage(FieldError, self.invalid_error % ('tags', '')):\n            list(Bookmark.objects.select_related('tags'))\n\n        with self.assertRaisesMessage(FieldError, self.invalid_error % ('content_object', 'content_type')):\n            list(TaggedItem.objects.select_related('content_object'))\n", "comments": "            helper create complete tree                      names   stringtree split()         models    domain  kingdom  phylum  klass  order  family  genus  species          assert len(names)    len(models)  (names  models)          parent   none         name  model zip(names  models)              try                  obj   model objects get(name name)             except model doesnotexist                  obj   model(name name)             parent                  setattr(obj  parent   class     name   lower()  parent)             obj save()             parent   obj       classmethod     def setuptestdata(cls)          cls create tree( eukaryota animalia anthropoda insecta diptera drosophilidae drosophila melanogaster )         cls create tree( eukaryota animalia chordata mammalia primates hominidae homo sapiens )         cls create tree( eukaryota plantae magnoliophyta magnoliopsida fabales fabaceae pisum sativum )         cls create tree( eukaryota fungi basidiomycota homobasidiomycatae agaricales amanitacae amanita muscaria )      def test access fks without select related(self)                      normally  accessing fks fill related objects                     self assertnumqueries(8)              fly   species objects get(name  melanogaster )             domain   fly genus family order klass phylum kingdom domain             self assertequal(domain name   eukaryota )      def test access fks select related(self)                      a select related() call fill related objects without         extra queries                     self assertnumqueries(1)              person   (                 species objects                  select related( genus  family  order  klass  phylum  kingdom  domain )                  get(name  sapiens )             )             domain   person genus family order klass phylum kingdom domain             self assertequal(domain name   eukaryota )      def test list without select related(self)                      select related() also course applies entire lists          items  this test verifies expected behavior without select related                      self assertnumqueries(9)              world   species objects all()             families    genus family name world              self assertequal(sorted(families)                     amanitacae                    drosophilidae                    fabaceae                    hominidae                )      def test list select related(self)                      select related() also course applies entire lists          items  this test verifies expected behavior select related                      self assertnumqueries(1)              world   species objects all() select related()             families    genus family name world              self assertequal(sorted(families)                     amanitacae                    drosophilidae                    fabaceae                    hominidae                )      def test list depth(self)                      passing relationship field lookup specifier select related()         stop descent particular level  this used lists         well                      self assertnumqueries(5)              world   species objects all() select related( genus  family )             orders    genus family order name world              self assertequal(sorted(orders)    agaricales    diptera    fabales    primates  )      def test select related extra(self)            (species objects all()               select related()               extra(select      select related species id   10  ) 0 )         self assertequal(s id   10  a)      def test certain fields(self)                      the optional fields passed select related() control related         models pull  this allows smaller queries           in case  explicitly say select  genus           genus family  models  leading number queries                      self assertnumqueries(1)              world   species objects select related( genus  family )             families    genus family name world              self assertequal(sorted(families)    amanitacae    drosophilidae    fabaceae    hominidae  )      def test certain fields(self)                      in case  explicitly say select  genus           genus family  models  leading number queries                      self assertnumqueries(2)              world   species objects filter(genus  name  amanita )                   select related( genus  family )             orders    genus family order name world              self assertequal(orders    agaricales  )      def test field traversal(self)          self assertnumqueries(1)                (species objects all()                   select related( genus  family  order )                   order by( id ) 0 1  get() genus family order name)             self assertequal(s   diptera )      def test none clears list(self)          queryset   species objects select related( genus ) select related(none)         self assertis(queryset query select related  false)      def test chaining(self)          parent 1  parent 2   species objects all()  2          hybridspecies objects create(name  hybrid   parent 1 parent 1  parent 2 parent 2)         queryset   hybridspecies objects select related( parent 1 ) select related( parent 2 )         self assertnumqueries(1)              obj   queryset 0              self assertequal(obj parent 1  parent 1)             self assertequal(obj parent 2  parent 2)      def test reverse relation caching(self)          species   species objects select related( genus ) filter(name  melanogaster ) first()         self assertnumqueries(0)              self assertequal(species genus name   drosophila )           the species set reverse relation cached          self assertequal(species genus  state fields cache    )         self assertnumqueries(1)              self assertequal(species genus species set first() name   melanogaster )      def test select related values(self)                      running select related() calling values() raises typeerror                     message    cannot call select related()  values()  values list()          self assertraisesmessage(typeerror  message)              list(species objects values( name ) select related( genus ))      def test select related values list(self)                      running select related() calling values list() raises typeerror                     message    cannot call select related()  values()  values list()          self assertraisesmessage(typeerror  message)              list(species objects values list( name ) select related( genus ))   class selectrelatedvalidationtests(simpletestcase)              select related() thrown error fields exist     non relational fields             the species set reverse relation cached  ", "content": "from django.core.exceptions import FieldError\nfrom django.test import SimpleTestCase, TestCase\n\nfrom .models import (\n    Bookmark, Domain, Family, Genus, HybridSpecies, Kingdom, Klass, Order,\n    Phylum, Pizza, Species, TaggedItem,\n)\n\n\nclass SelectRelatedTests(TestCase):\n\n    @classmethod\n    def create_tree(cls, stringtree):\n        \"\"\"\n        Helper to create a complete tree.\n        \"\"\"\n        names = stringtree.split()\n        models = [Domain, Kingdom, Phylum, Klass, Order, Family, Genus, Species]\n        assert len(names) == len(models), (names, models)\n\n        parent = None\n        for name, model in zip(names, models):\n            try:\n                obj = model.objects.get(name=name)\n            except model.DoesNotExist:\n                obj = model(name=name)\n            if parent:\n                setattr(obj, parent.__class__.__name__.lower(), parent)\n            obj.save()\n            parent = obj\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.create_tree(\"Eukaryota Animalia Anthropoda Insecta Diptera Drosophilidae Drosophila melanogaster\")\n        cls.create_tree(\"Eukaryota Animalia Chordata Mammalia Primates Hominidae Homo sapiens\")\n        cls.create_tree(\"Eukaryota Plantae Magnoliophyta Magnoliopsida Fabales Fabaceae Pisum sativum\")\n        cls.create_tree(\"Eukaryota Fungi Basidiomycota Homobasidiomycatae Agaricales Amanitacae Amanita muscaria\")\n\n    def test_access_fks_without_select_related(self):\n        \"\"\"\n        Normally, accessing FKs doesn't fill in related objects\n        \"\"\"\n        with self.assertNumQueries(8):\n            fly = Species.objects.get(name=\"melanogaster\")\n            domain = fly.genus.family.order.klass.phylum.kingdom.domain\n            self.assertEqual(domain.name, 'Eukaryota')\n\n    def test_access_fks_with_select_related(self):\n        \"\"\"\n        A select_related() call will fill in those related objects without any\n        extra queries\n        \"\"\"\n        with self.assertNumQueries(1):\n            person = (\n                Species.objects\n                .select_related('genus__family__order__klass__phylum__kingdom__domain')\n                .get(name=\"sapiens\")\n            )\n            domain = person.genus.family.order.klass.phylum.kingdom.domain\n            self.assertEqual(domain.name, 'Eukaryota')\n\n    def test_list_without_select_related(self):\n        \"\"\"\n        select_related() also of course applies to entire lists, not just\n        items. This test verifies the expected behavior without select_related.\n        \"\"\"\n        with self.assertNumQueries(9):\n            world = Species.objects.all()\n            families = [o.genus.family.name for o in world]\n            self.assertEqual(sorted(families), [\n                'Amanitacae',\n                'Drosophilidae',\n                'Fabaceae',\n                'Hominidae',\n            ])\n\n    def test_list_with_select_related(self):\n        \"\"\"\n        select_related() also of course applies to entire lists, not just\n        items. This test verifies the expected behavior with select_related.\n        \"\"\"\n        with self.assertNumQueries(1):\n            world = Species.objects.all().select_related()\n            families = [o.genus.family.name for o in world]\n            self.assertEqual(sorted(families), [\n                'Amanitacae',\n                'Drosophilidae',\n                'Fabaceae',\n                'Hominidae',\n            ])\n\n    def test_list_with_depth(self):\n        \"\"\"\n        Passing a relationship field lookup specifier to select_related() will\n        stop the descent at a particular level. This can be used on lists as\n        well.\n        \"\"\"\n        with self.assertNumQueries(5):\n            world = Species.objects.all().select_related('genus__family')\n            orders = [o.genus.family.order.name for o in world]\n            self.assertEqual(sorted(orders), ['Agaricales', 'Diptera', 'Fabales', 'Primates'])\n\n    def test_select_related_with_extra(self):\n        s = (Species.objects.all()\n             .select_related()\n             .extra(select={'a': 'select_related_species.id + 10'})[0])\n        self.assertEqual(s.id + 10, s.a)\n\n    def test_certain_fields(self):\n        \"\"\"\n        The optional fields passed to select_related() control which related\n        models we pull in. This allows for smaller queries.\n\n        In this case, we explicitly say to select the 'genus' and\n        'genus.family' models, leading to the same number of queries as before.\n        \"\"\"\n        with self.assertNumQueries(1):\n            world = Species.objects.select_related('genus__family')\n            families = [o.genus.family.name for o in world]\n            self.assertEqual(sorted(families), ['Amanitacae', 'Drosophilidae', 'Fabaceae', 'Hominidae'])\n\n    def test_more_certain_fields(self):\n        \"\"\"\n        In this case, we explicitly say to select the 'genus' and\n        'genus.family' models, leading to the same number of queries as before.\n        \"\"\"\n        with self.assertNumQueries(2):\n            world = Species.objects.filter(genus__name='Amanita')\\\n                .select_related('genus__family')\n            orders = [o.genus.family.order.name for o in world]\n            self.assertEqual(orders, ['Agaricales'])\n\n    def test_field_traversal(self):\n        with self.assertNumQueries(1):\n            s = (Species.objects.all()\n                 .select_related('genus__family__order')\n                 .order_by('id')[0:1].get().genus.family.order.name)\n            self.assertEqual(s, 'Diptera')\n\n    def test_none_clears_list(self):\n        queryset = Species.objects.select_related('genus').select_related(None)\n        self.assertIs(queryset.query.select_related, False)\n\n    def test_chaining(self):\n        parent_1, parent_2 = Species.objects.all()[:2]\n        HybridSpecies.objects.create(name='hybrid', parent_1=parent_1, parent_2=parent_2)\n        queryset = HybridSpecies.objects.select_related('parent_1').select_related('parent_2')\n        with self.assertNumQueries(1):\n            obj = queryset[0]\n            self.assertEqual(obj.parent_1, parent_1)\n            self.assertEqual(obj.parent_2, parent_2)\n\n    def test_reverse_relation_caching(self):\n        species = Species.objects.select_related('genus').filter(name='melanogaster').first()\n        with self.assertNumQueries(0):\n            self.assertEqual(species.genus.name, 'Drosophila')\n        # The species_set reverse relation isn't cached.\n        self.assertEqual(species.genus._state.fields_cache, {})\n        with self.assertNumQueries(1):\n            self.assertEqual(species.genus.species_set.first().name, 'melanogaster')\n\n    def test_select_related_after_values(self):\n        \"\"\"\n        Running select_related() after calling values() raises a TypeError\n        \"\"\"\n        message = \"Cannot call select_related() after .values() or .values_list()\"\n        with self.assertRaisesMessage(TypeError, message):\n            list(Species.objects.values('name').select_related('genus'))\n\n    def test_select_related_after_values_list(self):\n        \"\"\"\n        Running select_related() after calling values_list() raises a TypeError\n        \"\"\"\n        message = \"Cannot call select_related() after .values() or .values_list()\"\n        with self.assertRaisesMessage(TypeError, message):\n            list(Species.objects.values_list('name').select_related('genus'))\n\n\nclass SelectRelatedValidationTests(SimpleTestCase):\n    \"\"\"\n    select_related() should thrown an error on fields that do not exist and\n    non-relational fields.\n    \"\"\"\n    non_relational_error = \"Non-relational field given in select_related: '%s'. Choices are: %s\"\n    invalid_error = \"Invalid field name(s) given in select_related: '%s'. Choices are: %s\"\n\n    def test_non_relational_field(self):\n        with self.assertRaisesMessage(FieldError, self.non_relational_error % ('name', 'genus')):\n            list(Species.objects.select_related('name__some_field'))\n\n        with self.assertRaisesMessage(FieldError, self.non_relational_error % ('name', 'genus')):\n            list(Species.objects.select_related('name'))\n\n        with self.assertRaisesMessage(FieldError, self.non_relational_error % ('name', '(none)')):\n            list(Domain.objects.select_related('name'))\n\n    def test_non_relational_field_nested(self):\n        with self.assertRaisesMessage(FieldError, self.non_relational_error % ('name', 'family')):\n            list(Species.objects.select_related('genus__name'))\n\n    def test_many_to_many_field(self):\n        with self.assertRaisesMessage(FieldError, self.invalid_error % ('toppings', '(none)')):\n            list(Pizza.objects.select_related('toppings'))\n\n    def test_reverse_relational_field(self):\n        with self.assertRaisesMessage(FieldError, self.invalid_error % ('child_1', 'genus')):\n            list(Species.objects.select_related('child_1'))\n\n    def test_invalid_field(self):\n        with self.assertRaisesMessage(FieldError, self.invalid_error % ('invalid_field', 'genus')):\n            list(Species.objects.select_related('invalid_field'))\n\n        with self.assertRaisesMessage(FieldError, self.invalid_error % ('related_invalid_field', 'family')):\n            list(Species.objects.select_related('genus__related_invalid_field'))\n\n        with self.assertRaisesMessage(FieldError, self.invalid_error % ('invalid_field', '(none)')):\n            list(Domain.objects.select_related('invalid_field'))\n\n    def test_generic_relations(self):\n        with self.assertRaisesMessage(FieldError, self.invalid_error % ('tags', '')):\n            list(Bookmark.objects.select_related('tags'))\n\n        with self.assertRaisesMessage(FieldError, self.invalid_error % ('content_object', 'content_type')):\n            list(TaggedItem.objects.select_related('content_object'))\n", "description": "The Web framework for perfectionists with deadlines.", "file_name": "tests.py", "id": "59943c6cc8dc0d11bc782a61cb05850f", "language": "Python", "project_name": "django", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/django-django/django-django-274e3e2/tests/select_related/tests.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:39:10Z", "url": "https://github.com/django/django", "wiki": false}