{"author": "jakubroztocil", "code": "from __future__ import absolute_import\nimport json\n\nimport pygments.lexer\nimport pygments.token\nimport pygments.styles\nimport pygments.lexers\nimport pygments.style\nfrom pygments.formatters.terminal import TerminalFormatter\nfrom pygments.formatters.terminal256 import Terminal256Formatter\nfrom pygments.lexers.special import TextLexer\nfrom pygments.lexers.text import HttpLexer as PygmentsHttpLexer\nfrom pygments.util import ClassNotFound\n\nfrom httpie.compat import is_windows\nfrom httpie.plugins import FormatterPlugin\n\n\nAVAILABLE_STYLES = set(pygments.styles.STYLE_MAP.keys())\nAVAILABLE_STYLES.add('solarized')\n\n\nPRESET_STYLE = 'preset'\nAVAILABLE_STYLES.add(PRESET_STYLE)\n\nif is_windows:\n    \n    \n    DEFAULT_STYLE = 'fruity'\nelse:\n    DEFAULT_STYLE = 'solarized'\n\n\nclass ColorFormatter(FormatterPlugin):\n    \n    BASE03 = \"\n    BASE02 = \"\n    BASE01 = \"\n    BASE00 = \"\n    BASE0 = \"\n    BASE1 = \"\n    BASE2 = \"\n    BASE3 = \"\n    YELLOW = \"\n    ORANGE = \"\n    RED = \"\n    MAGENTA = \"\n    VIOLET = \"\n    BLUE = \"\n    CYAN = \"\n    GREEN = \"\n\n    background_color = BASE03\n    styles = {\n        pygments.token.Keyword: GREEN,\n        pygments.token.Keyword.Constant: ORANGE,\n        pygments.token.Keyword.Declaration: BLUE,\n        pygments.token.Keyword.Namespace: ORANGE,\n        pygments.token.Keyword.Reserved: BLUE,\n        pygments.token.Keyword.Type: RED,\n        pygments.token.Name.Attribute: BASE1,\n        pygments.token.Name.Builtin: BLUE,\n        pygments.token.Name.Builtin.Pseudo: BLUE,\n        pygments.token.Name.Class: BLUE,\n        pygments.token.Name.Constant: ORANGE,\n        pygments.token.Name.Decorator: BLUE,\n        pygments.token.Name.Entity: ORANGE,\n        pygments.token.Name.Exception: YELLOW,\n        pygments.token.Name.Function: BLUE,\n        pygments.token.Name.Tag: BLUE,\n        pygments.token.Name.Variable: BLUE,\n        pygments.token.String: CYAN,\n        pygments.token.String.Backtick: BASE01,\n        pygments.token.String.Char: CYAN,\n        pygments.token.String.Doc: CYAN,\n        pygments.token.String.Escape: RED,\n        pygments.token.String.Heredoc: CYAN,\n        pygments.token.String.Regex: RED,\n        pygments.token.Number: CYAN,\n        pygments.token.Operator: BASE1,\n        pygments.token.Operator.Word: GREEN,\n        pygments.token.Comment: BASE01,\n        pygments.token.Comment.Preproc: GREEN,\n        pygments.token.Comment.Special: GREEN,\n        pygments.token.Generic.Deleted: CYAN,\n        pygments.token.Generic.Emph: 'italic',\n        pygments.token.Generic.Error: RED,\n        pygments.token.Generic.Heading: ORANGE,\n        pygments.token.Generic.Inserted: GREEN,\n        pygments.token.Generic.Strong: 'bold',\n        pygments.token.Generic.Subheading: ORANGE,\n        pygments.token.Token: BASE1,\n        pygments.token.Token.Other: ORANGE,\n    }\n", "comments": "\n    Colorize using Pygments\n\n    This processor that applies syntax highlighting to the headers,\n    and also to the body if its content type is recognized.\n\n    \"\"\"\n    group_name = 'colors'\n\n    def __init__(self, env, explicit_json=False,\n                 color_scheme=DEFAULT_STYLE, **kwargs):\n        super(ColorFormatter, self).__init__(**kwargs)\n        if not env.colors:\n            self.enabled = False\n            return\n\n        # --json, -j\n        self.explicit_json = explicit_json\n\n        try:\n            style_class = pygments.styles.get_style_by_name(color_scheme)\n        except ClassNotFound:\n            style_class = Solarized256Style\n\n        if color_scheme != PRESET_STYLE and env.colors == 256:\n            fmt_class = Terminal256Formatter\n        else:\n            fmt_class = TerminalFormatter\n        self.formatter = fmt_class(style=style_class)\n\n        if color_scheme == PRESET_STYLE:\n            self.http_lexer = PygmentsHttpLexer()\n        else:\n            self.http_lexer = HTTPLexer()\n\n    def format_headers(self, headers):\n        return pygments.highlight(headers, self.http_lexer, self.formatter).strip()\n\n    def format_body(self, body, mime):\n        lexer = self.get_lexer(mime, body)\n        if lexer:\n            body = pygments.highlight(body, lexer, self.formatter)\n        return body.strip()\n\n    def get_lexer(self, mime, body):\n        return get_lexer(\n            mime=mime,\n            explicit_json=self.explicit_json,\n            body=body,\n        )\n\n\ndef get_lexer(mime, explicit_json=False, body=''):\n\n    # Build candidate mime type and lexer names.\n    mime_types, lexer_names = [mime], []\n    type_, subtype = mime.split('/', 1)\n    if '+' not in subtype:\n        lexer_names.append(subtype)\n    else:\n        subtype_name, subtype_suffix = subtype.split('+', 1)\n        lexer_names.extend([subtype_name, subtype_suffix])\n        mime_types.extend([\n            '%s/%s' % (type_, subtype_name),\n            '%s/%s' % (type_, subtype_suffix)\n        ])\n\n    # As a last resort, if no lexer feels responsible, and\n    # the subtype contains 'json', take the JSON lexer\n    if 'json' in subtype:\n        lexer_names.append('json')\n\n    # Try to resolve the right lexer.\n    lexer = None\n    for mime_type in mime_types:\n        try:\n            lexer = pygments.lexers.get_lexer_for_mimetype(mime_type)\n            break\n        except ClassNotFound:\n            pass\n    else:\n        for name in lexer_names:\n            try:\n                lexer = pygments.lexers.get_lexer_by_name(name)\n            except ClassNotFound:\n                pass\n\n    if explicit_json and body and (not lexer or isinstance(lexer, TextLexer)):\n        # JSON response with an incorrect Content-Type?\n        try:\n            json.loads(body)  # FIXME: the body also gets parsed in json.py\n        except ValueError:\n            pass  # Nope\n        else:\n            lexer = pygments.lexers.get_lexer_by_name('json')\n\n    return lexer\n\n\nclass HTTPLexer(pygments.lexer.RegexLexer):\n    \"\"\"Simplified HTTP lexer for Pygments.\n\n    It only operates on headers and provides a stronger contrast between\n    their names and values than the original one bundled with Pygments\n    (:class:`pygments.lexers.text import HttpLexer`), especially when\n    Solarized color scheme is used.\n\n    \"\"\"\n    name = 'HTTP'\n    aliases = ['http']\n    filenames = ['*.http']\n    tokens = {\n        'root': [\n            # Request-Line\n            (r'([A-Z]+)( +)([^ ]+)( +)(HTTP)(/)(\\d+\\.\\d+)',\n             pygments.lexer.bygroups(\n                 pygments.token.Name.Function,\n                 pygments.token.Text,\n                 pygments.token.Name.Namespace,\n                 pygments.token.Text,\n                 pygments.token.Keyword.Reserved,\n                 pygments.token.Operator,\n                 pygments.token.Number\n             )),\n            # Response Status-Line\n            (r'(HTTP)(/)(\\d+\\.\\d+)( +)(\\d{3})( +)(.+)',\n             pygments.lexer.bygroups(\n                 pygments.token.Keyword.Reserved,  # 'HTTP'\n                 pygments.token.Operator,  # '/'\n                 pygments.token.Number,  # Version\n                 pygments.token.Text,\n                 pygments.token.Number,  # Status code\n                 pygments.token.Text,\n                 pygments.token.Name.Exception,  # Reason\n             )),\n            # Header\n            (r'(.*?)( *)(:)( *)(.+)', pygments.lexer.bygroups(\n                pygments.token.Name.Attribute,  # Name\n                pygments.token.Text,\n                pygments.token.Operator,  # Colon\n                pygments.token.Text,\n                pygments.token.String  # Value\n            ))\n        ]\n    }\n\n\nclass Solarized256Style(pygments.style.Style):\n    \"\"\"\n    solarized256\n    ------------\n\n    A Pygments style inspired by Solarized's 256 color mode.\n\n    :copyright: (c) 2011 by Hank Gay, (c) 2012 by John Mastro.\n    :license: BSD, see LICENSE for more details.\n\n    \n \n# This is the native style provided by the terminal emulator color scheme\n# Colors on Windows via colorama don't look that\n# great and fruity seems to give the best result there\n#1c1c1c\"\n#262626\"\n#4e4e4e\"\n#585858\"\n#808080\"\n#8a8a8a\"\n#d7d7af\"\n#ffffd7\"\n#af8700\"\n#d75f00\"\n#af0000\"\n#af005f\"\n#5f5faf\"\n#0087ff\"\n#00afaf\"\n#5f8700\"\n", "content": "from __future__ import absolute_import\nimport json\n\nimport pygments.lexer\nimport pygments.token\nimport pygments.styles\nimport pygments.lexers\nimport pygments.style\nfrom pygments.formatters.terminal import TerminalFormatter\nfrom pygments.formatters.terminal256 import Terminal256Formatter\nfrom pygments.lexers.special import TextLexer\nfrom pygments.lexers.text import HttpLexer as PygmentsHttpLexer\nfrom pygments.util import ClassNotFound\n\nfrom httpie.compat import is_windows\nfrom httpie.plugins import FormatterPlugin\n\n\nAVAILABLE_STYLES = set(pygments.styles.STYLE_MAP.keys())\nAVAILABLE_STYLES.add('solarized')\n\n# This is the native style provided by the terminal emulator color scheme\nPRESET_STYLE = 'preset'\nAVAILABLE_STYLES.add(PRESET_STYLE)\n\nif is_windows:\n    # Colors on Windows via colorama don't look that\n    # great and fruity seems to give the best result there\n    DEFAULT_STYLE = 'fruity'\nelse:\n    DEFAULT_STYLE = 'solarized'\n\n\nclass ColorFormatter(FormatterPlugin):\n    \"\"\"\n    Colorize using Pygments\n\n    This processor that applies syntax highlighting to the headers,\n    and also to the body if its content type is recognized.\n\n    \"\"\"\n    group_name = 'colors'\n\n    def __init__(self, env, explicit_json=False,\n                 color_scheme=DEFAULT_STYLE, **kwargs):\n        super(ColorFormatter, self).__init__(**kwargs)\n        if not env.colors:\n            self.enabled = False\n            return\n\n        # --json, -j\n        self.explicit_json = explicit_json\n\n        try:\n            style_class = pygments.styles.get_style_by_name(color_scheme)\n        except ClassNotFound:\n            style_class = Solarized256Style\n\n        if color_scheme != PRESET_STYLE and env.colors == 256:\n            fmt_class = Terminal256Formatter\n        else:\n            fmt_class = TerminalFormatter\n        self.formatter = fmt_class(style=style_class)\n\n        if color_scheme == PRESET_STYLE:\n            self.http_lexer = PygmentsHttpLexer()\n        else:\n            self.http_lexer = HTTPLexer()\n\n    def format_headers(self, headers):\n        return pygments.highlight(headers, self.http_lexer, self.formatter).strip()\n\n    def format_body(self, body, mime):\n        lexer = self.get_lexer(mime, body)\n        if lexer:\n            body = pygments.highlight(body, lexer, self.formatter)\n        return body.strip()\n\n    def get_lexer(self, mime, body):\n        return get_lexer(\n            mime=mime,\n            explicit_json=self.explicit_json,\n            body=body,\n        )\n\n\ndef get_lexer(mime, explicit_json=False, body=''):\n\n    # Build candidate mime type and lexer names.\n    mime_types, lexer_names = [mime], []\n    type_, subtype = mime.split('/', 1)\n    if '+' not in subtype:\n        lexer_names.append(subtype)\n    else:\n        subtype_name, subtype_suffix = subtype.split('+', 1)\n        lexer_names.extend([subtype_name, subtype_suffix])\n        mime_types.extend([\n            '%s/%s' % (type_, subtype_name),\n            '%s/%s' % (type_, subtype_suffix)\n        ])\n\n    # As a last resort, if no lexer feels responsible, and\n    # the subtype contains 'json', take the JSON lexer\n    if 'json' in subtype:\n        lexer_names.append('json')\n\n    # Try to resolve the right lexer.\n    lexer = None\n    for mime_type in mime_types:\n        try:\n            lexer = pygments.lexers.get_lexer_for_mimetype(mime_type)\n            break\n        except ClassNotFound:\n            pass\n    else:\n        for name in lexer_names:\n            try:\n                lexer = pygments.lexers.get_lexer_by_name(name)\n            except ClassNotFound:\n                pass\n\n    if explicit_json and body and (not lexer or isinstance(lexer, TextLexer)):\n        # JSON response with an incorrect Content-Type?\n        try:\n            json.loads(body)  # FIXME: the body also gets parsed in json.py\n        except ValueError:\n            pass  # Nope\n        else:\n            lexer = pygments.lexers.get_lexer_by_name('json')\n\n    return lexer\n\n\nclass HTTPLexer(pygments.lexer.RegexLexer):\n    \"\"\"Simplified HTTP lexer for Pygments.\n\n    It only operates on headers and provides a stronger contrast between\n    their names and values than the original one bundled with Pygments\n    (:class:`pygments.lexers.text import HttpLexer`), especially when\n    Solarized color scheme is used.\n\n    \"\"\"\n    name = 'HTTP'\n    aliases = ['http']\n    filenames = ['*.http']\n    tokens = {\n        'root': [\n            # Request-Line\n            (r'([A-Z]+)( +)([^ ]+)( +)(HTTP)(/)(\\d+\\.\\d+)',\n             pygments.lexer.bygroups(\n                 pygments.token.Name.Function,\n                 pygments.token.Text,\n                 pygments.token.Name.Namespace,\n                 pygments.token.Text,\n                 pygments.token.Keyword.Reserved,\n                 pygments.token.Operator,\n                 pygments.token.Number\n             )),\n            # Response Status-Line\n            (r'(HTTP)(/)(\\d+\\.\\d+)( +)(\\d{3})( +)(.+)',\n             pygments.lexer.bygroups(\n                 pygments.token.Keyword.Reserved,  # 'HTTP'\n                 pygments.token.Operator,  # '/'\n                 pygments.token.Number,  # Version\n                 pygments.token.Text,\n                 pygments.token.Number,  # Status code\n                 pygments.token.Text,\n                 pygments.token.Name.Exception,  # Reason\n             )),\n            # Header\n            (r'(.*?)( *)(:)( *)(.+)', pygments.lexer.bygroups(\n                pygments.token.Name.Attribute,  # Name\n                pygments.token.Text,\n                pygments.token.Operator,  # Colon\n                pygments.token.Text,\n                pygments.token.String  # Value\n            ))\n        ]\n    }\n\n\nclass Solarized256Style(pygments.style.Style):\n    \"\"\"\n    solarized256\n    ------------\n\n    A Pygments style inspired by Solarized's 256 color mode.\n\n    :copyright: (c) 2011 by Hank Gay, (c) 2012 by John Mastro.\n    :license: BSD, see LICENSE for more details.\n\n    \"\"\"\n    BASE03 = \"#1c1c1c\"\n    BASE02 = \"#262626\"\n    BASE01 = \"#4e4e4e\"\n    BASE00 = \"#585858\"\n    BASE0 = \"#808080\"\n    BASE1 = \"#8a8a8a\"\n    BASE2 = \"#d7d7af\"\n    BASE3 = \"#ffffd7\"\n    YELLOW = \"#af8700\"\n    ORANGE = \"#d75f00\"\n    RED = \"#af0000\"\n    MAGENTA = \"#af005f\"\n    VIOLET = \"#5f5faf\"\n    BLUE = \"#0087ff\"\n    CYAN = \"#00afaf\"\n    GREEN = \"#5f8700\"\n\n    background_color = BASE03\n    styles = {\n        pygments.token.Keyword: GREEN,\n        pygments.token.Keyword.Constant: ORANGE,\n        pygments.token.Keyword.Declaration: BLUE,\n        pygments.token.Keyword.Namespace: ORANGE,\n        pygments.token.Keyword.Reserved: BLUE,\n        pygments.token.Keyword.Type: RED,\n        pygments.token.Name.Attribute: BASE1,\n        pygments.token.Name.Builtin: BLUE,\n        pygments.token.Name.Builtin.Pseudo: BLUE,\n        pygments.token.Name.Class: BLUE,\n        pygments.token.Name.Constant: ORANGE,\n        pygments.token.Name.Decorator: BLUE,\n        pygments.token.Name.Entity: ORANGE,\n        pygments.token.Name.Exception: YELLOW,\n        pygments.token.Name.Function: BLUE,\n        pygments.token.Name.Tag: BLUE,\n        pygments.token.Name.Variable: BLUE,\n        pygments.token.String: CYAN,\n        pygments.token.String.Backtick: BASE01,\n        pygments.token.String.Char: CYAN,\n        pygments.token.String.Doc: CYAN,\n        pygments.token.String.Escape: RED,\n        pygments.token.String.Heredoc: CYAN,\n        pygments.token.String.Regex: RED,\n        pygments.token.Number: CYAN,\n        pygments.token.Operator: BASE1,\n        pygments.token.Operator.Word: GREEN,\n        pygments.token.Comment: BASE01,\n        pygments.token.Comment.Preproc: GREEN,\n        pygments.token.Comment.Special: GREEN,\n        pygments.token.Generic.Deleted: CYAN,\n        pygments.token.Generic.Emph: 'italic',\n        pygments.token.Generic.Error: RED,\n        pygments.token.Generic.Heading: ORANGE,\n        pygments.token.Generic.Inserted: GREEN,\n        pygments.token.Generic.Strong: 'bold',\n        pygments.token.Generic.Subheading: ORANGE,\n        pygments.token.Token: BASE1,\n        pygments.token.Token.Other: ORANGE,\n    }\n", "description": "Modern command line HTTP client \u2013 user-friendly curl alternative with intuitive UI, JSON support, syntax highlighting, wget-like downloads, extensions, etc.  https://httpie.org", "file_name": "colors.py", "language": "Python", "project_name": "httpie", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/jakubroztocil_httpie/jakubroztocil-httpie-0f4dce9/httpie/output/formatters/colors.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:20:06Z", "url": "https://github.com/jakubroztocil/httpie", "wiki": false}