{"author": "ansible", "code": "\n\"\"\"Wrapper around yamllint that supports YAML embedded in Ansible modules.\"\"\"\n\nfrom __future__ import absolute_import, print_function\n\nimport ast\nimport json\nimport os\nimport sys\n\nfrom yamllint import linter\nfrom yamllint.config import YamlLintConfig\n\n\ndef main():\n    \"\"\"Main program body.\"\"\"\n    paths = sys.argv[1:] or sys.stdin.read().splitlines()\n\n    checker = YamlChecker()\n    checker.check(paths)\n    checker.report()\n\n\nclass YamlChecker(object):\n    \"\"\"Wrapper around yamllint that supports YAML embedded in Ansible modules.\"\"\"\n    def __init__(self):\n        self.messages = []\n\n    def report(self):\n        \"\"\"Print yamllint report to stdout.\"\"\"\n        report = dict(\n            messages=self.messages,\n        )\n\n        print(json.dumps(report, indent=4, sort_keys=True))\n\n    def check(self, paths):\n        \"\"\"\n        :type paths: str\n        \"\"\"\n        yaml_conf = YamlLintConfig(file='test/sanity/yamllint/config/default.yml')\n        module_conf = YamlLintConfig(file='test/sanity/yamllint/config/modules.yml')\n\n        for path in paths:\n            extension = os.path.splitext(path)[1]\n\n            with open(path) as f:\n                contents = f.read()\n\n            if extension in ('.yml', '.yaml'):\n                self.check_yaml(yaml_conf, path, contents)\n            elif extension == '.py':\n                self.check_module(module_conf, path, contents)\n            else:\n                raise Exception('unsupported extension: %s' % extension)\n\n    def check_yaml(self, conf, path, contents):\n        \"\"\"\n        :type conf: YamlLintConfig\n        :type path: str\n        :type contents: str\n        \"\"\"\n        self.messages += [self.result_to_message(r, path) for r in linter.run(contents, conf, path)]\n\n    def check_module(self, conf, path, contents):\n        \"\"\"\n        :type conf: YamlLintConfig\n        :type path: str\n        :type contents: str\n        \"\"\"\n        docs = self.get_module_docs(path, contents)\n\n        for key, value in docs.items():\n            yaml = value['yaml']\n            lineno = value['lineno']\n\n            if yaml.startswith('\\n'):\n                yaml = yaml[1:]\n                lineno += 1\n\n            messages = list(linter.run(yaml, conf, path))\n\n            self.messages += [self.result_to_message(r, path, lineno - 1, key) for r in messages]\n\n    @staticmethod\n    def result_to_message(result, path, line_offset=0, prefix=''):\n        \"\"\"\n        :type result: any\n        :type path: str\n        :type line_offset: int\n        :type prefix: str\n        :rtype: dict[str, any]\n        \"\"\"\n        if prefix:\n            prefix = '%s: ' % prefix\n\n        return dict(\n            code=result.rule or result.level,\n            message=prefix + result.desc,\n            path=path,\n            line=result.line + line_offset,\n            column=result.column,\n            level=result.level,\n        )\n\n    def get_module_docs(self, path, contents):\n        \"\"\"\n        :type path: str\n        :type contents: str\n        :rtype: dict[str, any]\n        \"\"\"\n        module_doc_types = [\n            'DOCUMENTATION',\n            'EXAMPLES',\n            'RETURN',\n        ]\n\n        docs = {}\n\n        def check_assignment(statement, doc_types=None):\n            \"\"\"Check the given statement for a documentation assignment.\"\"\"\n            for target in statement.targets:\n                if doc_types and target.id not in doc_types:\n                    continue\n\n                docs[target.id] = dict(\n                    yaml=statement.value.s,\n                    lineno=statement.lineno,\n                    end_lineno=statement.lineno + len(statement.value.s.splitlines())\n                )\n\n        module_ast = self.parse_module(path, contents)\n\n        if not module_ast:\n            return {}\n\n        if path.startswith('lib/ansible/modules/'):\n            for body_statement in module_ast.body:\n                if isinstance(body_statement, ast.Assign):\n                    check_assignment(body_statement, module_doc_types)\n        elif path.startswith('lib/ansible/utils/module_docs_fragments/'):\n            for body_statement in module_ast.body:\n                if isinstance(body_statement, ast.ClassDef):\n                    for class_statement in body_statement.body:\n                        if isinstance(class_statement, ast.Assign):\n                            check_assignment(class_statement)\n        else:\n            raise Exception('unsupported path: %s' % path)\n\n        return docs\n\n    def parse_module(self, path, contents):\n        \"\"\"\n        :type path: str\n        :type contents: str\n        :rtype: ast.Module |\n        try:\n            return ast.parse(contents)\n        except SyntaxError as ex:\n            self.messages.append(dict(\n                code='python-syntax-error',\n                message=str(ex),\n                path=path,\n                line=ex.lineno,\n                column=ex.offset,\n                level='error',\n            ))\n        except Exception as ex:\n            self.messages.append(dict(\n                code='python-parse-error',\n                message=str(ex),\n                path=path,\n                line=0,\n                column=0,\n                level='error',\n            ))\n\n        return None\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "   wrapper around yamllint supports yaml embedded ansible modules        future   import absolute import  print function  import ast import json import os import sys  yamllint import linter yamllint config import yamllintconfig   def main()         main program body         paths   sys argv 1   sys stdin read() splitlines()      checker   yamlchecker()     checker check(paths)     checker report()   class yamlchecker(object)         wrapper around yamllint supports yaml embedded ansible modules         def   init  (self)          self messages           def report(self)             print yamllint report stdout             report   dict(             messages self messages          )          print(json dumps(report  indent 4  sort keys true))      def check(self  paths)                       type paths  str                     yaml conf   yamllintconfig(file  test sanity yamllint config default yml )         module conf   yamllintconfig(file  test sanity yamllint config modules yml )          path paths              extension   os path splitext(path) 1               open(path) f                  contents   f read()              extension (  yml     yaml )                  self check yaml(yaml conf  path  contents)             elif extension      py                   self check module(module conf  path  contents)             else                  raise exception( unsupported extension      extension)      def check yaml(self  conf  path  contents)                       type conf  yamllintconfig          type path  str          type contents  str                     self messages     self result message(r  path) r linter run(contents  conf  path)       def check module(self  conf  path  contents)                       type conf  yamllintconfig          type path  str          type contents  str                     docs   self get module docs(path  contents)          key  value docs items()              yaml   value  yaml               lineno   value  lineno                yaml startswith(  n )                  yaml   yaml 1                   lineno    1              messages   list(linter run(yaml  conf  path))              self messages     self result message(r  path  lineno   1  key) r messages        staticmethod     def result message(result  path  line offset 0  prefix   )                       type result           type path  str          type line offset  int          type prefix  str          rtype  dict str                       prefix              prefix          prefix          return dict(             code result rule result level              message prefix   result desc              path path              line result line   line offset              column result column              level result level          )      def get module docs(self  path  contents)                       type path  str          type contents  str          rtype  dict str                       module doc types                  documentation                examples                return                      docs               def check assignment(statement  doc types none)                 check given statement documentation assignment                 target statement targets                  doc types target id doc types                      continue                  docs target id    dict(                     yaml statement value                      lineno statement lineno                      end lineno statement lineno   len(statement value splitlines())                 )          module ast   self parse module(path  contents)          module ast              return             path startswith( lib ansible modules  )              body statement module ast body                  isinstance(body statement  ast assign)                      check assignment(body statement  module doc types)         elif path startswith( lib ansible utils module docs fragments  )              body statement module ast body                  isinstance(body statement  ast classdef)                      class statement body statement body                          isinstance(class statement  ast assign)                              check assignment(class statement)         else              raise exception( unsupported path      path)          return docs      def parse module(self  path  contents)                       type path  str          type contents  str          rtype  ast module   none                 usr bin env python ", "content": "#!/usr/bin/env python\n\"\"\"Wrapper around yamllint that supports YAML embedded in Ansible modules.\"\"\"\n\nfrom __future__ import absolute_import, print_function\n\nimport ast\nimport json\nimport os\nimport sys\n\nfrom yamllint import linter\nfrom yamllint.config import YamlLintConfig\n\n\ndef main():\n    \"\"\"Main program body.\"\"\"\n    paths = sys.argv[1:] or sys.stdin.read().splitlines()\n\n    checker = YamlChecker()\n    checker.check(paths)\n    checker.report()\n\n\nclass YamlChecker(object):\n    \"\"\"Wrapper around yamllint that supports YAML embedded in Ansible modules.\"\"\"\n    def __init__(self):\n        self.messages = []\n\n    def report(self):\n        \"\"\"Print yamllint report to stdout.\"\"\"\n        report = dict(\n            messages=self.messages,\n        )\n\n        print(json.dumps(report, indent=4, sort_keys=True))\n\n    def check(self, paths):\n        \"\"\"\n        :type paths: str\n        \"\"\"\n        yaml_conf = YamlLintConfig(file='test/sanity/yamllint/config/default.yml')\n        module_conf = YamlLintConfig(file='test/sanity/yamllint/config/modules.yml')\n\n        for path in paths:\n            extension = os.path.splitext(path)[1]\n\n            with open(path) as f:\n                contents = f.read()\n\n            if extension in ('.yml', '.yaml'):\n                self.check_yaml(yaml_conf, path, contents)\n            elif extension == '.py':\n                self.check_module(module_conf, path, contents)\n            else:\n                raise Exception('unsupported extension: %s' % extension)\n\n    def check_yaml(self, conf, path, contents):\n        \"\"\"\n        :type conf: YamlLintConfig\n        :type path: str\n        :type contents: str\n        \"\"\"\n        self.messages += [self.result_to_message(r, path) for r in linter.run(contents, conf, path)]\n\n    def check_module(self, conf, path, contents):\n        \"\"\"\n        :type conf: YamlLintConfig\n        :type path: str\n        :type contents: str\n        \"\"\"\n        docs = self.get_module_docs(path, contents)\n\n        for key, value in docs.items():\n            yaml = value['yaml']\n            lineno = value['lineno']\n\n            if yaml.startswith('\\n'):\n                yaml = yaml[1:]\n                lineno += 1\n\n            messages = list(linter.run(yaml, conf, path))\n\n            self.messages += [self.result_to_message(r, path, lineno - 1, key) for r in messages]\n\n    @staticmethod\n    def result_to_message(result, path, line_offset=0, prefix=''):\n        \"\"\"\n        :type result: any\n        :type path: str\n        :type line_offset: int\n        :type prefix: str\n        :rtype: dict[str, any]\n        \"\"\"\n        if prefix:\n            prefix = '%s: ' % prefix\n\n        return dict(\n            code=result.rule or result.level,\n            message=prefix + result.desc,\n            path=path,\n            line=result.line + line_offset,\n            column=result.column,\n            level=result.level,\n        )\n\n    def get_module_docs(self, path, contents):\n        \"\"\"\n        :type path: str\n        :type contents: str\n        :rtype: dict[str, any]\n        \"\"\"\n        module_doc_types = [\n            'DOCUMENTATION',\n            'EXAMPLES',\n            'RETURN',\n        ]\n\n        docs = {}\n\n        def check_assignment(statement, doc_types=None):\n            \"\"\"Check the given statement for a documentation assignment.\"\"\"\n            for target in statement.targets:\n                if doc_types and target.id not in doc_types:\n                    continue\n\n                docs[target.id] = dict(\n                    yaml=statement.value.s,\n                    lineno=statement.lineno,\n                    end_lineno=statement.lineno + len(statement.value.s.splitlines())\n                )\n\n        module_ast = self.parse_module(path, contents)\n\n        if not module_ast:\n            return {}\n\n        if path.startswith('lib/ansible/modules/'):\n            for body_statement in module_ast.body:\n                if isinstance(body_statement, ast.Assign):\n                    check_assignment(body_statement, module_doc_types)\n        elif path.startswith('lib/ansible/utils/module_docs_fragments/'):\n            for body_statement in module_ast.body:\n                if isinstance(body_statement, ast.ClassDef):\n                    for class_statement in body_statement.body:\n                        if isinstance(class_statement, ast.Assign):\n                            check_assignment(class_statement)\n        else:\n            raise Exception('unsupported path: %s' % path)\n\n        return docs\n\n    def parse_module(self, path, contents):\n        \"\"\"\n        :type path: str\n        :type contents: str\n        :rtype: ast.Module | None\n        \"\"\"\n        try:\n            return ast.parse(contents)\n        except SyntaxError as ex:\n            self.messages.append(dict(\n                code='python-syntax-error',\n                message=str(ex),\n                path=path,\n                line=ex.lineno,\n                column=ex.offset,\n                level='error',\n            ))\n        except Exception as ex:\n            self.messages.append(dict(\n                code='python-parse-error',\n                message=str(ex),\n                path=path,\n                line=0,\n                column=0,\n                level='error',\n            ))\n\n        return None\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "yamllinter.py", "id": "12a5fe66804b892bb99a708443196c1c", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/test/sanity/yamllint/yamllinter.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}