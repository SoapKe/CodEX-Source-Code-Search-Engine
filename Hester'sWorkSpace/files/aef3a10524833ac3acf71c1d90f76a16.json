{"author": "odoo", "code": "# -*- coding: utf-8 -*-\nimport ast\nimport base64\nimport logging\nimport lxml\nimport os\nimport sys\nimport zipfile\nfrom os.path import join as opj\n\nfrom odoo import api, fields, models, _\nfrom odoo.exceptions import UserError\nfrom odoo.modules import load_information_from_description_file\nfrom odoo.tools import convert_file, exception_to_unicode, pycompat\nfrom odoo.tools.osutil import tempdir\n\n_logger = logging.getLogger(__name__)\n\nMAX_FILE_SIZE = 100 * 1024 * 1024  \n\n\nclass IrModule(models.Model):\n    _inherit = \"ir.module.module\"\n\n    imported = fields.Boolean(string=\"Imported Module\")\n\n    @api.multi\n    def _import_module(self, module, path, force=False):\n        known_mods = self.search([])\n        known_mods_names = {m.name: m for m in known_mods}\n        installed_mods = [m.name for m in known_mods if m.state == 'installed']\n\n        terp = load_information_from_description_file(module, mod_path=path)\n        values = self.get_values_from_terp(terp)\n\n        unmet_dependencies = set(terp['depends']).difference(installed_mods)\n\n        if unmet_dependencies:\n            if (unmet_dependencies == set(['web_studio']) and\n                    _is_studio_custom(path)):\n                err = _(\"Studio customizations require Studio\")\n            else:\n                err = _(\"Unmet module dependencies: %s\") % ', '.join(\n                    unmet_dependencies,\n                )\n            raise UserError(err)\n        elif 'web_studio' not in installed_mods and _is_studio_custom(path):\n            raise UserError(_(\"Studio customizations require Studio\"))\n\n        mod = known_mods_names.get(module)\n        if mod:\n            mod.write(dict(state='installed', **values))\n            mode = 'update' if not force else 'init'\n        else:\n            assert terp.get('installable', True), \"Module not installable\"\n            self.create(dict(name=module, state='installed', imported=True, **values))\n            mode = 'init'\n\n        for kind in ['data', 'init_xml', 'update_xml']:\n            for filename in terp[kind]:\n                ext = os.path.splitext(filename)[1].lower()\n                if ext not in ('.xml', '.csv', '.sql'):\n                    _logger.info(\"module %s: skip unsupported file %s\", module, filename)\n                    continue\n                _logger.info(\"module %s: loading %s\", module, filename)\n                noupdate = False\n                if ext == '.csv' and kind in ('init', 'init_xml'):\n                    noupdate = True\n                pathname = opj(path, filename)\n                idref = {}\n                convert_file(self.env.cr, module, filename, idref, mode=mode, noupdate=noupdate, kind=kind, pathname=pathname)\n\n        path_static = opj(path, 'static')\n        IrAttachment = self.env['ir.attachment']\n        if os.path.isdir(path_static):\n            for root, dirs, files in os.walk(path_static):\n                for static_file in files:\n                    full_path = opj(root, static_file)\n                    with open(full_path, 'rb') as fp:\n                        data = base64.b64encode(fp.read())\n                    url_path = '/{}{}'.format(module, full_path.split(path)[1].replace(os.path.sep, '/'))\n                    if not isinstance(url_path, pycompat.text_type):\n                        url_path = url_path.decode(sys.getfilesystemencoding())\n                    filename = os.path.split(url_path)[1]\n                    values = dict(\n                        name=filename,\n                        datas_fname=filename,\n                        url=url_path,\n                        res_model='ir.ui.view',\n                        type='binary',\n                        datas=data,\n                    )\n                    attachment = IrAttachment.search([('url', '=', url_path), ('type', '=', 'binary'), ('res_model', '=', 'ir.ui.view')])\n                    if attachment:\n                        attachment.write(values)\n                    else:\n                        IrAttachment.create(values)\n\n        return True\n\n    @api.model\n    def import_zipfile(self, module_file, force=False):\n        if not module_file:\n            raise Exception(_(\"No file sent.\"))\n        if not zipfile.is_zipfile(module_file):\n            raise UserError(_('File is not a zip file!'))\n\n        success = []\n        errors = dict()\n        module_names = []\n        with zipfile.ZipFile(module_file, \"r\") as z:\n            for zf in z.filelist:\n                if zf.file_size > MAX_FILE_SIZE:\n                    raise UserError(_(\"File '%s' exceed maximum allowed file size\") % zf.filename)\n\n            with tempdir() as module_dir:\n                import odoo.modules.module as module\n                try:\n                    module.ad_paths.append(module_dir)\n                    z.extractall(module_dir)\n                    dirs = [d for d in os.listdir(module_dir) if os.path.isdir(opj(module_dir, d))]\n                    for mod_name in dirs:\n                        module_names.append(mod_name)\n                        try:\n                            # assert mod_name.startswith('theme_')\n                            path = opj(module_dir, mod_name)\n                            self._import_module(mod_name, path, force=force)\n                            success.append(mod_name)\n                        except Exception as e:\n                            _logger.exception('Error while importing module')\n                            errors[mod_name] = exception_to_unicode(e)\n                finally:\n                    module.ad_paths.remove(module_dir)\n        r = [\"Successfully imported module '%s'\" % mod for mod in success]\n        for mod, error in errors.items():\n            r.append(\"Error while importing module '%s': %r\" % (mod, error))\n        return '\\n'.join(r), module_names\n\n\ndef _is_studio_custom(path):\n    \n    filepaths = []\n    for level in os.walk(path):\n        filepaths += [os.path.join(level[0], fn) for fn in level[2]]\n    filepaths = [fp for fp in filepaths if fp.lower().endswith('.xml')]\n\n    for fp in filepaths:\n        root = lxml.etree.parse(fp).getroot()\n\n        for record in root:\n            \n            try:\n                # ast.literal_eval is like eval(), but safer\n                \n                ctx = ast.literal_eval(record.get('context'))\n                \n                \n                if ctx and ctx.get('studio'):\n                    return True\n            except Exception:\n                continue\n    return False\n", "comments": "        checks imported records see references     studio  would mean module created using studio      returns true records contains context key     studio  false none records                coding  utf 8        megabytes    assert mod name startswith( theme  )    might context non studio module    ast literal eval like eval()  safer    context string representing python dict    cases studio false    checking existence enough ", "content": "# -*- coding: utf-8 -*-\nimport ast\nimport base64\nimport logging\nimport lxml\nimport os\nimport sys\nimport zipfile\nfrom os.path import join as opj\n\nfrom odoo import api, fields, models, _\nfrom odoo.exceptions import UserError\nfrom odoo.modules import load_information_from_description_file\nfrom odoo.tools import convert_file, exception_to_unicode, pycompat\nfrom odoo.tools.osutil import tempdir\n\n_logger = logging.getLogger(__name__)\n\nMAX_FILE_SIZE = 100 * 1024 * 1024  # in megabytes\n\n\nclass IrModule(models.Model):\n    _inherit = \"ir.module.module\"\n\n    imported = fields.Boolean(string=\"Imported Module\")\n\n    @api.multi\n    def _import_module(self, module, path, force=False):\n        known_mods = self.search([])\n        known_mods_names = {m.name: m for m in known_mods}\n        installed_mods = [m.name for m in known_mods if m.state == 'installed']\n\n        terp = load_information_from_description_file(module, mod_path=path)\n        values = self.get_values_from_terp(terp)\n\n        unmet_dependencies = set(terp['depends']).difference(installed_mods)\n\n        if unmet_dependencies:\n            if (unmet_dependencies == set(['web_studio']) and\n                    _is_studio_custom(path)):\n                err = _(\"Studio customizations require Studio\")\n            else:\n                err = _(\"Unmet module dependencies: %s\") % ', '.join(\n                    unmet_dependencies,\n                )\n            raise UserError(err)\n        elif 'web_studio' not in installed_mods and _is_studio_custom(path):\n            raise UserError(_(\"Studio customizations require Studio\"))\n\n        mod = known_mods_names.get(module)\n        if mod:\n            mod.write(dict(state='installed', **values))\n            mode = 'update' if not force else 'init'\n        else:\n            assert terp.get('installable', True), \"Module not installable\"\n            self.create(dict(name=module, state='installed', imported=True, **values))\n            mode = 'init'\n\n        for kind in ['data', 'init_xml', 'update_xml']:\n            for filename in terp[kind]:\n                ext = os.path.splitext(filename)[1].lower()\n                if ext not in ('.xml', '.csv', '.sql'):\n                    _logger.info(\"module %s: skip unsupported file %s\", module, filename)\n                    continue\n                _logger.info(\"module %s: loading %s\", module, filename)\n                noupdate = False\n                if ext == '.csv' and kind in ('init', 'init_xml'):\n                    noupdate = True\n                pathname = opj(path, filename)\n                idref = {}\n                convert_file(self.env.cr, module, filename, idref, mode=mode, noupdate=noupdate, kind=kind, pathname=pathname)\n\n        path_static = opj(path, 'static')\n        IrAttachment = self.env['ir.attachment']\n        if os.path.isdir(path_static):\n            for root, dirs, files in os.walk(path_static):\n                for static_file in files:\n                    full_path = opj(root, static_file)\n                    with open(full_path, 'rb') as fp:\n                        data = base64.b64encode(fp.read())\n                    url_path = '/{}{}'.format(module, full_path.split(path)[1].replace(os.path.sep, '/'))\n                    if not isinstance(url_path, pycompat.text_type):\n                        url_path = url_path.decode(sys.getfilesystemencoding())\n                    filename = os.path.split(url_path)[1]\n                    values = dict(\n                        name=filename,\n                        datas_fname=filename,\n                        url=url_path,\n                        res_model='ir.ui.view',\n                        type='binary',\n                        datas=data,\n                    )\n                    attachment = IrAttachment.search([('url', '=', url_path), ('type', '=', 'binary'), ('res_model', '=', 'ir.ui.view')])\n                    if attachment:\n                        attachment.write(values)\n                    else:\n                        IrAttachment.create(values)\n\n        return True\n\n    @api.model\n    def import_zipfile(self, module_file, force=False):\n        if not module_file:\n            raise Exception(_(\"No file sent.\"))\n        if not zipfile.is_zipfile(module_file):\n            raise UserError(_('File is not a zip file!'))\n\n        success = []\n        errors = dict()\n        module_names = []\n        with zipfile.ZipFile(module_file, \"r\") as z:\n            for zf in z.filelist:\n                if zf.file_size > MAX_FILE_SIZE:\n                    raise UserError(_(\"File '%s' exceed maximum allowed file size\") % zf.filename)\n\n            with tempdir() as module_dir:\n                import odoo.modules.module as module\n                try:\n                    module.ad_paths.append(module_dir)\n                    z.extractall(module_dir)\n                    dirs = [d for d in os.listdir(module_dir) if os.path.isdir(opj(module_dir, d))]\n                    for mod_name in dirs:\n                        module_names.append(mod_name)\n                        try:\n                            # assert mod_name.startswith('theme_')\n                            path = opj(module_dir, mod_name)\n                            self._import_module(mod_name, path, force=force)\n                            success.append(mod_name)\n                        except Exception as e:\n                            _logger.exception('Error while importing module')\n                            errors[mod_name] = exception_to_unicode(e)\n                finally:\n                    module.ad_paths.remove(module_dir)\n        r = [\"Successfully imported module '%s'\" % mod for mod in success]\n        for mod, error in errors.items():\n            r.append(\"Error while importing module '%s': %r\" % (mod, error))\n        return '\\n'.join(r), module_names\n\n\ndef _is_studio_custom(path):\n    \"\"\"\n    Checks the to-be-imported records to see if there are any references to\n    studio, which would mean that the module was created using studio\n\n    Returns True if any of the records contains a context with the key\n    studio in it, False if none of the records do\n    \"\"\"\n    filepaths = []\n    for level in os.walk(path):\n        filepaths += [os.path.join(level[0], fn) for fn in level[2]]\n    filepaths = [fp for fp in filepaths if fp.lower().endswith('.xml')]\n\n    for fp in filepaths:\n        root = lxml.etree.parse(fp).getroot()\n\n        for record in root:\n            # there might not be a context if it's a non-studio module\n            try:\n                # ast.literal_eval is like eval(), but safer\n                # context is a string representing a python dict\n                ctx = ast.literal_eval(record.get('context'))\n                # there are no cases in which studio is false\n                # so just checking for its existence is enough\n                if ctx and ctx.get('studio'):\n                    return True\n            except Exception:\n                continue\n    return False\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "ir_module.py", "id": "aef3a10524833ac3acf71c1d90f76a16", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/base_import_module/models/ir_module.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}