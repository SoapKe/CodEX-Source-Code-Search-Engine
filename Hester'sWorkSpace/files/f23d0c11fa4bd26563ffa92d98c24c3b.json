{"author": "nvbn", "code": "from io import BytesIO\n\nimport pytest\nfrom thefuck.rules.port_already_in_use import match, get_new_command\nfrom thefuck.types import Command\n\noutputs = [\n    \n\n\n@pytest.fixture(autouse=True)\ndef lsof(mocker):\n    patch = mocker.patch('thefuck.rules.port_already_in_use.Popen')\n    patch.return_value.stdout = BytesIO(lsof_stdout)\n    return patch\n\n\n@pytest.mark.usefixtures('no_memoize')\n@pytest.mark.parametrize(\n    'command',\n    [Command('./app', output) for output in outputs]\n    + [Command('./app', output) for output in outputs])\ndef test_match(command):\n    assert match(command)\n\n\n@pytest.mark.usefixtures('no_memoize')\n@pytest.mark.parametrize('command, lsof_output', [\n    (Command('./app', ''), lsof_stdout),\n    (Command('./app', outputs[1]), b''),\n    (Command('./app', outputs[2]), b'')])\ndef test_not_match(lsof, command, lsof_output):\n    lsof.return_value.stdout = BytesIO(lsof_output)\n\n    assert not match(command)\n\n\n@pytest.mark.parametrize(\n    'command',\n    [Command('./app', output) for output in outputs]\n    + [Command('./app', output) for output in outputs])\ndef test_get_new_command(command):\n    assert get_new_command(command) == 'kill 18233 && ./app'\n", "comments": "\n\nDE 70% 1/1 build modulesevents.js:141\n      throw er; // Unhandled 'error' event\n      ^\n\nError: listen EADDRINUSE 127.0.0.1:8080\n    at Object.exports._errnoException (util.js:873:11)\n    at exports._exceptionWithHostPort (util.js:896:20)\n    at Server._listen2 (net.js:1250:14)\n    at listen (net.js:1286:10)\n    at net.js:1395:9\n    at GetAddrInfoReqWrap.asyncCallback [as callback] (dns.js:64:16)\n    at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:83:10)\n\n    ''',\n    '''\n[6:40:01 AM] <START> Building Dependency Graph\n[6:40:01 AM] <START> Crawling File System\n ERROR  Packager can't listen on port 8080\nMost likely another process is already using this port\nRun the following command to find out which process:\n\n   lsof -n -i4TCP:8080\n\nYou can either shut down the other process:\n\n   kill -9 <PID>\n\nor run packager on different port.\n\n    ''',\n    '''\nTraceback (most recent call last):\n  File \"/usr/lib/python3.5/runpy.py\", line 184, in _run_module_as_main\n    \"__main__\", mod_spec)\n  File \"/usr/lib/python3.5/runpy.py\", line 85, in _run_code\n    exec(code, run_globals)\n  File \"/home/nvbn/exp/code_view/server/code_view/main.py\", line 14, in <module>\n    web.run_app(app)\n  File \"/home/nvbn/.virtualenvs/code_view/lib/python3.5/site-packages/aiohttp/web.py\", line 310, in run_app\n    backlog=backlog))\n  File \"/usr/lib/python3.5/asyncio/base_events.py\", line 373, in run_until_complete\n    return future.result()\n  File \"/usr/lib/python3.5/asyncio/futures.py\", line 274, in result\n    raise self._exception\n  File \"/usr/lib/python3.5/asyncio/tasks.py\", line 240, in _step\n    result = coro.send(None)\n  File \"/usr/lib/python3.5/asyncio/base_events.py\", line 953, in create_server\n    % (sa, err.strerror.lower()))\nOSError: [Errno 98] error while attempting to bind on address ('0.0.0.0', 8080): address already in use\nTask was destroyed but it is pending!\ntask: <Task pending coro=<RedisProtocol._reader_coroutine() running at /home/nvbn/.virtualenvs/code_view/lib/python3.5/site-packages/asyncio_redis/protocol.py:921> wait_for=<Future pending cb=[Task._wakeup()]>>\n    '''\n]\n\nlsof_stdout = b'''COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nnode    18233 nvbn   16u  IPv4 557134      0t0  TCP localhost:http-alt (LISTEN)\n\n\n\n", "content": "from io import BytesIO\n\nimport pytest\nfrom thefuck.rules.port_already_in_use import match, get_new_command\nfrom thefuck.types import Command\n\noutputs = [\n    '''\n\nDE 70% 1/1 build modulesevents.js:141\n      throw er; // Unhandled 'error' event\n      ^\n\nError: listen EADDRINUSE 127.0.0.1:8080\n    at Object.exports._errnoException (util.js:873:11)\n    at exports._exceptionWithHostPort (util.js:896:20)\n    at Server._listen2 (net.js:1250:14)\n    at listen (net.js:1286:10)\n    at net.js:1395:9\n    at GetAddrInfoReqWrap.asyncCallback [as callback] (dns.js:64:16)\n    at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:83:10)\n\n    ''',\n    '''\n[6:40:01 AM] <START> Building Dependency Graph\n[6:40:01 AM] <START> Crawling File System\n ERROR  Packager can't listen on port 8080\nMost likely another process is already using this port\nRun the following command to find out which process:\n\n   lsof -n -i4TCP:8080\n\nYou can either shut down the other process:\n\n   kill -9 <PID>\n\nor run packager on different port.\n\n    ''',\n    '''\nTraceback (most recent call last):\n  File \"/usr/lib/python3.5/runpy.py\", line 184, in _run_module_as_main\n    \"__main__\", mod_spec)\n  File \"/usr/lib/python3.5/runpy.py\", line 85, in _run_code\n    exec(code, run_globals)\n  File \"/home/nvbn/exp/code_view/server/code_view/main.py\", line 14, in <module>\n    web.run_app(app)\n  File \"/home/nvbn/.virtualenvs/code_view/lib/python3.5/site-packages/aiohttp/web.py\", line 310, in run_app\n    backlog=backlog))\n  File \"/usr/lib/python3.5/asyncio/base_events.py\", line 373, in run_until_complete\n    return future.result()\n  File \"/usr/lib/python3.5/asyncio/futures.py\", line 274, in result\n    raise self._exception\n  File \"/usr/lib/python3.5/asyncio/tasks.py\", line 240, in _step\n    result = coro.send(None)\n  File \"/usr/lib/python3.5/asyncio/base_events.py\", line 953, in create_server\n    % (sa, err.strerror.lower()))\nOSError: [Errno 98] error while attempting to bind on address ('0.0.0.0', 8080): address already in use\nTask was destroyed but it is pending!\ntask: <Task pending coro=<RedisProtocol._reader_coroutine() running at /home/nvbn/.virtualenvs/code_view/lib/python3.5/site-packages/asyncio_redis/protocol.py:921> wait_for=<Future pending cb=[Task._wakeup()]>>\n    '''\n]\n\nlsof_stdout = b'''COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nnode    18233 nvbn   16u  IPv4 557134      0t0  TCP localhost:http-alt (LISTEN)\n'''\n\n\n@pytest.fixture(autouse=True)\ndef lsof(mocker):\n    patch = mocker.patch('thefuck.rules.port_already_in_use.Popen')\n    patch.return_value.stdout = BytesIO(lsof_stdout)\n    return patch\n\n\n@pytest.mark.usefixtures('no_memoize')\n@pytest.mark.parametrize(\n    'command',\n    [Command('./app', output) for output in outputs]\n    + [Command('./app', output) for output in outputs])\ndef test_match(command):\n    assert match(command)\n\n\n@pytest.mark.usefixtures('no_memoize')\n@pytest.mark.parametrize('command, lsof_output', [\n    (Command('./app', ''), lsof_stdout),\n    (Command('./app', outputs[1]), b''),\n    (Command('./app', outputs[2]), b'')])\ndef test_not_match(lsof, command, lsof_output):\n    lsof.return_value.stdout = BytesIO(lsof_output)\n\n    assert not match(command)\n\n\n@pytest.mark.parametrize(\n    'command',\n    [Command('./app', output) for output in outputs]\n    + [Command('./app', output) for output in outputs])\ndef test_get_new_command(command):\n    assert get_new_command(command) == 'kill 18233 && ./app'\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "test_port_already_in_use.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/tests/rules/test_port_already_in_use.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}