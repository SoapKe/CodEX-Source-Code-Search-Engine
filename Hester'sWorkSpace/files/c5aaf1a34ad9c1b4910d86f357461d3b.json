{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport errno\nimport os\nimport socket\nimport time\nimport random\nimport re\n\nfrom .common import FileDownloader\nfrom ..compat import (\n    compat_str,\n    compat_urllib_error,\n)\nfrom ..utils import (\n    ContentTooShortError,\n    encodeFilename,\n    int_or_none,\n    sanitize_open,\n    sanitized_Request,\n    write_xattr,\n    XAttrMetadataError,\n    XAttrUnavailableError,\n)\n\n\nclass HttpFD(FileDownloader):\n    def real_download(self, filename, info_dict):\n        url = info_dict['url']\n\n        class DownloadContext(dict):\n            __getattr__ = dict.get\n            __setattr__ = dict.__setitem__\n            __delattr__ = dict.__delitem__\n\n        ctx = DownloadContext()\n        ctx.filename = filename\n        ctx.tmpfilename = self.temp_name(filename)\n        ctx.stream = None\n\n        \n        headers = {'Youtubedl-no-compression': 'True'}\n        add_headers = info_dict.get('http_headers')\n        if add_headers:\n            headers.update(add_headers)\n\n        is_test = self.params.get('test', False)\n        chunk_size = self._TEST_FILE_SIZE if is_test else (\n            info_dict.get('downloader_options', {}).get('http_chunk_size') or\n            self.params.get('http_chunk_size') or 0)\n\n        ctx.open_mode = 'wb'\n        ctx.resume_len = 0\n        ctx.data_len = None\n        ctx.block_size = self.params.get('buffersize', 1024)\n        ctx.start_time = time.time()\n        ctx.chunk_size = None\n\n        if self.params.get('continuedl', True):\n            \n            if os.path.isfile(encodeFilename(ctx.tmpfilename)):\n                ctx.resume_len = os.path.getsize(\n                    encodeFilename(ctx.tmpfilename))\n\n        ctx.is_resume = ctx.resume_len > 0\n\n        count = 0\n        retries = self.params.get('retries', 0)\n\n        class SucceedDownload(Exception):\n            pass\n\n        class RetryDownload(Exception):\n            def __init__(self, source_error):\n                self.source_error = source_error\n\n        class NextFragment(Exception):\n            pass\n\n        def set_range(req, start, end):\n            range_header = 'bytes=%d-' % start\n            if end:\n                range_header += compat_str(end)\n            req.add_header('Range', range_header)\n\n        def establish_connection():\n            ctx.chunk_size = (random.randint(int(chunk_size * 0.95), chunk_size)\n                              if not is_test and chunk_size else chunk_size)\n            if ctx.resume_len > 0:\n                range_start = ctx.resume_len\n                if ctx.is_resume:\n                    self.report_resuming_byte(ctx.resume_len)\n                ctx.open_mode = 'ab'\n            elif ctx.chunk_size > 0:\n                range_start = 0\n            else:\n                range_start = None\n            ctx.is_resume = False\n            range_end = range_start + ctx.chunk_size - 1 if ctx.chunk_size else None\n            if range_end and ctx.data_len is not None and range_end >= ctx.data_len:\n                range_end = ctx.data_len - 1\n            has_range = range_start is not None\n            ctx.has_range = has_range\n            request = sanitized_Request(url, None, headers)\n            if has_range:\n                set_range(request, range_start, range_end)\n            \n            try:\n                ctx.data = self.ydl.urlopen(request)\n                \n                \n                \n                \n                \n                if has_range:\n                    content_range = ctx.data.headers.get('Content-Range')\n                    if content_range:\n                        content_range_m = re.search(r'bytes (\\d+)-(\\d+)?(?:/(\\d+))?', content_range)\n                        \n                        if content_range_m:\n                            if range_start == int(content_range_m.group(1)):\n                                content_range_end = int_or_none(content_range_m.group(2))\n                                content_len = int_or_none(content_range_m.group(3))\n                                accept_content_len = (\n                                    \n                                    not ctx.chunk_size or\n                                    \n                                    \n                                    content_range_end == range_end or\n                                    content_len < range_end)\n                                if accept_content_len:\n                                    ctx.data_len = content_len\n                                    return\n                    \n                    \n                    \n                    self.report_unable_to_resume()\n                    ctx.resume_len = 0\n                    ctx.open_mode = 'wb'\n                ctx.data_len = int_or_none(ctx.data.info().get('Content-length', None))\n                return\n            except (compat_urllib_error.HTTPError, ) as err:\n                if err.code == 416:\n                    \n                    try:\n                        \n                        ctx.data = self.ydl.urlopen(\n                            sanitized_Request(url, None, headers))\n                        content_length = ctx.data.info()['Content-Length']\n                    except (compat_urllib_error.HTTPError, ) as err:\n                        if err.code < 500 or err.code >= 600:\n                            raise\n                    else:\n                        \n                        if (content_length is not None and\n                                (ctx.resume_len - 100 < int(content_length) < ctx.resume_len + 100)):\n                            \n                            \n                            \n                            \n                            \n                            \n                            \n                            self.report_file_already_downloaded(ctx.filename)\n                            self.try_rename(ctx.tmpfilename, ctx.filename)\n                            self._hook_progress({\n                                'filename': ctx.filename,\n                                'status': 'finished',\n                                'downloaded_bytes': ctx.resume_len,\n                                'total_bytes': ctx.resume_len,\n                            })\n                            raise SucceedDownload()\n                        else:\n                            \n                            self.report_unable_to_resume()\n                            ctx.resume_len = 0\n                            ctx.open_mode = 'wb'\n                            return\n                elif err.code < 500 or err.code >= 600:\n                    \n                    raise\n                raise RetryDownload(err)\n            except socket.error as err:\n                if err.errno != errno.ECONNRESET:\n                    \n                    raise\n                raise RetryDownload(err)\n\n        def download():\n            data_len = ctx.data.info().get('Content-length', None)\n\n            \n            \n            \n            \n            \n            if is_test and (data_len is None or int(data_len) > self._TEST_FILE_SIZE):\n                data_len = self._TEST_FILE_SIZE\n\n            if data_len is not None:\n                data_len = int(data_len) + ctx.resume_len\n                min_data_len = self.params.get('min_filesize')\n                max_data_len = self.params.get('max_filesize')\n                if min_data_len is not None and data_len < min_data_len:\n                    self.to_screen('\\r[download] File is smaller than min-filesize (%s bytes < %s bytes). Aborting.' % (data_len, min_data_len))\n                    return False\n                if max_data_len is not None and data_len > max_data_len:\n                    self.to_screen('\\r[download] File is larger than max-filesize (%s bytes > %s bytes). Aborting.' % (data_len, max_data_len))\n                    return False\n\n            byte_counter = 0 + ctx.resume_len\n            block_size = ctx.block_size\n            start = time.time()\n\n            \n            now = None  \n            before = start  \n\n            def retry(e):\n                if ctx.tmpfilename != '-':\n                    ctx.stream.close()\n                ctx.stream = None\n                ctx.resume_len = os.path.getsize(encodeFilename(ctx.tmpfilename))\n                raise RetryDownload(e)\n\n            while True:\n                try:\n                    \n                    data_block = ctx.data.read(block_size if not is_test else min(block_size, data_len - byte_counter))\n                \n                \n                except socket.timeout as e:\n                    retry(e)\n                except socket.error as e:\n                    if e.errno not in (errno.ECONNRESET, errno.ETIMEDOUT):\n                        raise\n                    retry(e)\n\n                byte_counter += len(data_block)\n\n                \n                if len(data_block) == 0:\n                    break\n\n                \n                if ctx.stream is None:\n                    try:\n                        ctx.stream, ctx.tmpfilename = sanitize_open(\n                            ctx.tmpfilename, ctx.open_mode)\n                        assert ctx.stream is not None\n                        ctx.filename = self.undo_temp_name(ctx.tmpfilename)\n                        self.report_destination(ctx.filename)\n                    except (OSError, IOError) as err:\n                        self.report_error('unable to open for writing: %s' % str(err))\n                        return False\n\n                    if self.params.get('xattr_set_filesize', False) and data_len is not None:\n                        try:\n                            write_xattr(ctx.tmpfilename, 'user.ytdl.filesize', str(data_len).encode('utf-8'))\n                        except (XAttrUnavailableError, XAttrMetadataError) as err:\n                            self.report_error('unable to set filesize xattr: %s' % str(err))\n\n                try:\n                    ctx.stream.write(data_block)\n                except (IOError, OSError) as err:\n                    self.to_stderr('\\n')\n                    self.report_error('unable to write data: %s' % str(err))\n                    return False\n\n                \n                self.slow_down(start, now, byte_counter - ctx.resume_len)\n\n                \n                now = time.time()\n                after = now\n\n                \n                if not self.params.get('noresizebuffer', False):\n                    block_size = self.best_block_size(after - before, len(data_block))\n\n                before = after\n\n                \n                speed = self.calc_speed(start, now, byte_counter - ctx.resume_len)\n                if ctx.data_len is None:\n                    eta = None\n                else:\n                    eta = self.calc_eta(start, time.time(), ctx.data_len - ctx.resume_len, byte_counter - ctx.resume_len)\n\n                self._hook_progress({\n                    'status': 'downloading',\n                    'downloaded_bytes': byte_counter,\n                    'total_bytes': ctx.data_len,\n                    'tmpfilename': ctx.tmpfilename,\n                    'filename': ctx.filename,\n                    'eta': eta,\n                    'speed': speed,\n                    'elapsed': now - ctx.start_time,\n                })\n\n                if is_test and byte_counter == data_len:\n                    break\n\n            if not is_test and ctx.chunk_size and ctx.data_len is not None and byte_counter < ctx.data_len:\n                ctx.resume_len = byte_counter\n                \n                raise NextFragment()\n\n            if ctx.stream is None:\n                self.to_stderr('\\n')\n                self.report_error('Did not get any data blocks')\n                return False\n            if ctx.tmpfilename != '-':\n                ctx.stream.close()\n\n            if data_len is not None and byte_counter != data_len:\n                err = ContentTooShortError(byte_counter, int(data_len))\n                if count <= retries:\n                    retry(err)\n                raise err\n\n            self.try_rename(ctx.tmpfilename, ctx.filename)\n\n            \n            if self.params.get('updatetime', True):\n                info_dict['filetime'] = self.try_utime(ctx.filename, ctx.data.info().get('last-modified', None))\n\n            self._hook_progress({\n                'downloaded_bytes': byte_counter,\n                'total_bytes': byte_counter,\n                'filename': ctx.filename,\n                'status': 'finished',\n                'elapsed': time.time() - ctx.start_time,\n            })\n\n            return True\n\n        while count <= retries:\n            try:\n                establish_connection()\n                return download()\n            except RetryDownload as e:\n                count += 1\n                if count <= retries:\n                    self.report_retry(e.source_error, count, retries)\n                continue\n            except NextFragment:\n                continue\n            except SucceedDownload:\n                return True\n\n        self.report_error('giving up after %s retries' % retries)\n        return False\n", "comments": "# Do not include the Accept-Encoding header\n# Establish possible resume length\n# Establish connection\n# When trying to resume, Content-Range HTTP header of response has to be checked\n# to match the value of requested Range HTTP header. This is due to a webservers\n# that don't support resuming and serve a whole file with no Content-Range\n# set in response despite of requested Range (see\n# https://github.com/rg3/youtube-dl/issues/6057#issuecomment-126129799)\n# Content-Range is present and matches requested Range, resume is possible\n# Non-chunked download\n# Chunked download and requested piece or\n# its part is promised to be served\n# Content-Range is either not present or invalid. Assuming remote webserver is\n# trying to send the whole file, resume is not possible, so wiping the local file\n# and performing entire redownload\n# Unable to resume (requested range not satisfiable)\n# Open the connection again without the range header\n# Examine the reported length\n# The file had already been fully downloaded.\n# Explanation to the above condition: in issue #175 it was revealed that\n# YouTube sometimes adds or removes a few bytes from the end of the file,\n# changing the file size slightly and causing problems for some users. So\n# I decided to implement a suggested change and consider the file\n# completely downloaded if the file size differs less than 100 bytes from\n# the one in the hard drive.\n# The length does not match, we start the download over\n# Unexpected HTTP error\n# Connection reset is no problem, just retry\n# Range HTTP header may be ignored/unsupported by a webserver\n# (e.g. extractor/scivee.py, extractor/bambuser.py).\n# However, for a test we still would like to download just a piece of a file.\n# To achieve this we limit data_len to _TEST_FILE_SIZE and manually control\n# block size when downloading a file.\n# measure time over whole while-loop, so slow_down() and best_block_size() work together properly\n# needed for slow_down() in the first loop run\n# start measuring\n# Download and write\n# socket.timeout is a subclass of socket.error but may not have\n# errno set\n# exit loop when download is finished\n# Open destination file just in time\n# Apply rate limit\n# end measuring of one loop run\n# Adjust block size\n# Progress message\n# ctx.block_size = block_size\n# Update file modification time\n", "content": "from __future__ import unicode_literals\n\nimport errno\nimport os\nimport socket\nimport time\nimport random\nimport re\n\nfrom .common import FileDownloader\nfrom ..compat import (\n    compat_str,\n    compat_urllib_error,\n)\nfrom ..utils import (\n    ContentTooShortError,\n    encodeFilename,\n    int_or_none,\n    sanitize_open,\n    sanitized_Request,\n    write_xattr,\n    XAttrMetadataError,\n    XAttrUnavailableError,\n)\n\n\nclass HttpFD(FileDownloader):\n    def real_download(self, filename, info_dict):\n        url = info_dict['url']\n\n        class DownloadContext(dict):\n            __getattr__ = dict.get\n            __setattr__ = dict.__setitem__\n            __delattr__ = dict.__delitem__\n\n        ctx = DownloadContext()\n        ctx.filename = filename\n        ctx.tmpfilename = self.temp_name(filename)\n        ctx.stream = None\n\n        # Do not include the Accept-Encoding header\n        headers = {'Youtubedl-no-compression': 'True'}\n        add_headers = info_dict.get('http_headers')\n        if add_headers:\n            headers.update(add_headers)\n\n        is_test = self.params.get('test', False)\n        chunk_size = self._TEST_FILE_SIZE if is_test else (\n            info_dict.get('downloader_options', {}).get('http_chunk_size') or\n            self.params.get('http_chunk_size') or 0)\n\n        ctx.open_mode = 'wb'\n        ctx.resume_len = 0\n        ctx.data_len = None\n        ctx.block_size = self.params.get('buffersize', 1024)\n        ctx.start_time = time.time()\n        ctx.chunk_size = None\n\n        if self.params.get('continuedl', True):\n            # Establish possible resume length\n            if os.path.isfile(encodeFilename(ctx.tmpfilename)):\n                ctx.resume_len = os.path.getsize(\n                    encodeFilename(ctx.tmpfilename))\n\n        ctx.is_resume = ctx.resume_len > 0\n\n        count = 0\n        retries = self.params.get('retries', 0)\n\n        class SucceedDownload(Exception):\n            pass\n\n        class RetryDownload(Exception):\n            def __init__(self, source_error):\n                self.source_error = source_error\n\n        class NextFragment(Exception):\n            pass\n\n        def set_range(req, start, end):\n            range_header = 'bytes=%d-' % start\n            if end:\n                range_header += compat_str(end)\n            req.add_header('Range', range_header)\n\n        def establish_connection():\n            ctx.chunk_size = (random.randint(int(chunk_size * 0.95), chunk_size)\n                              if not is_test and chunk_size else chunk_size)\n            if ctx.resume_len > 0:\n                range_start = ctx.resume_len\n                if ctx.is_resume:\n                    self.report_resuming_byte(ctx.resume_len)\n                ctx.open_mode = 'ab'\n            elif ctx.chunk_size > 0:\n                range_start = 0\n            else:\n                range_start = None\n            ctx.is_resume = False\n            range_end = range_start + ctx.chunk_size - 1 if ctx.chunk_size else None\n            if range_end and ctx.data_len is not None and range_end >= ctx.data_len:\n                range_end = ctx.data_len - 1\n            has_range = range_start is not None\n            ctx.has_range = has_range\n            request = sanitized_Request(url, None, headers)\n            if has_range:\n                set_range(request, range_start, range_end)\n            # Establish connection\n            try:\n                ctx.data = self.ydl.urlopen(request)\n                # When trying to resume, Content-Range HTTP header of response has to be checked\n                # to match the value of requested Range HTTP header. This is due to a webservers\n                # that don't support resuming and serve a whole file with no Content-Range\n                # set in response despite of requested Range (see\n                # https://github.com/rg3/youtube-dl/issues/6057#issuecomment-126129799)\n                if has_range:\n                    content_range = ctx.data.headers.get('Content-Range')\n                    if content_range:\n                        content_range_m = re.search(r'bytes (\\d+)-(\\d+)?(?:/(\\d+))?', content_range)\n                        # Content-Range is present and matches requested Range, resume is possible\n                        if content_range_m:\n                            if range_start == int(content_range_m.group(1)):\n                                content_range_end = int_or_none(content_range_m.group(2))\n                                content_len = int_or_none(content_range_m.group(3))\n                                accept_content_len = (\n                                    # Non-chunked download\n                                    not ctx.chunk_size or\n                                    # Chunked download and requested piece or\n                                    # its part is promised to be served\n                                    content_range_end == range_end or\n                                    content_len < range_end)\n                                if accept_content_len:\n                                    ctx.data_len = content_len\n                                    return\n                    # Content-Range is either not present or invalid. Assuming remote webserver is\n                    # trying to send the whole file, resume is not possible, so wiping the local file\n                    # and performing entire redownload\n                    self.report_unable_to_resume()\n                    ctx.resume_len = 0\n                    ctx.open_mode = 'wb'\n                ctx.data_len = int_or_none(ctx.data.info().get('Content-length', None))\n                return\n            except (compat_urllib_error.HTTPError, ) as err:\n                if err.code == 416:\n                    # Unable to resume (requested range not satisfiable)\n                    try:\n                        # Open the connection again without the range header\n                        ctx.data = self.ydl.urlopen(\n                            sanitized_Request(url, None, headers))\n                        content_length = ctx.data.info()['Content-Length']\n                    except (compat_urllib_error.HTTPError, ) as err:\n                        if err.code < 500 or err.code >= 600:\n                            raise\n                    else:\n                        # Examine the reported length\n                        if (content_length is not None and\n                                (ctx.resume_len - 100 < int(content_length) < ctx.resume_len + 100)):\n                            # The file had already been fully downloaded.\n                            # Explanation to the above condition: in issue #175 it was revealed that\n                            # YouTube sometimes adds or removes a few bytes from the end of the file,\n                            # changing the file size slightly and causing problems for some users. So\n                            # I decided to implement a suggested change and consider the file\n                            # completely downloaded if the file size differs less than 100 bytes from\n                            # the one in the hard drive.\n                            self.report_file_already_downloaded(ctx.filename)\n                            self.try_rename(ctx.tmpfilename, ctx.filename)\n                            self._hook_progress({\n                                'filename': ctx.filename,\n                                'status': 'finished',\n                                'downloaded_bytes': ctx.resume_len,\n                                'total_bytes': ctx.resume_len,\n                            })\n                            raise SucceedDownload()\n                        else:\n                            # The length does not match, we start the download over\n                            self.report_unable_to_resume()\n                            ctx.resume_len = 0\n                            ctx.open_mode = 'wb'\n                            return\n                elif err.code < 500 or err.code >= 600:\n                    # Unexpected HTTP error\n                    raise\n                raise RetryDownload(err)\n            except socket.error as err:\n                if err.errno != errno.ECONNRESET:\n                    # Connection reset is no problem, just retry\n                    raise\n                raise RetryDownload(err)\n\n        def download():\n            data_len = ctx.data.info().get('Content-length', None)\n\n            # Range HTTP header may be ignored/unsupported by a webserver\n            # (e.g. extractor/scivee.py, extractor/bambuser.py).\n            # However, for a test we still would like to download just a piece of a file.\n            # To achieve this we limit data_len to _TEST_FILE_SIZE and manually control\n            # block size when downloading a file.\n            if is_test and (data_len is None or int(data_len) > self._TEST_FILE_SIZE):\n                data_len = self._TEST_FILE_SIZE\n\n            if data_len is not None:\n                data_len = int(data_len) + ctx.resume_len\n                min_data_len = self.params.get('min_filesize')\n                max_data_len = self.params.get('max_filesize')\n                if min_data_len is not None and data_len < min_data_len:\n                    self.to_screen('\\r[download] File is smaller than min-filesize (%s bytes < %s bytes). Aborting.' % (data_len, min_data_len))\n                    return False\n                if max_data_len is not None and data_len > max_data_len:\n                    self.to_screen('\\r[download] File is larger than max-filesize (%s bytes > %s bytes). Aborting.' % (data_len, max_data_len))\n                    return False\n\n            byte_counter = 0 + ctx.resume_len\n            block_size = ctx.block_size\n            start = time.time()\n\n            # measure time over whole while-loop, so slow_down() and best_block_size() work together properly\n            now = None  # needed for slow_down() in the first loop run\n            before = start  # start measuring\n\n            def retry(e):\n                if ctx.tmpfilename != '-':\n                    ctx.stream.close()\n                ctx.stream = None\n                ctx.resume_len = os.path.getsize(encodeFilename(ctx.tmpfilename))\n                raise RetryDownload(e)\n\n            while True:\n                try:\n                    # Download and write\n                    data_block = ctx.data.read(block_size if not is_test else min(block_size, data_len - byte_counter))\n                # socket.timeout is a subclass of socket.error but may not have\n                # errno set\n                except socket.timeout as e:\n                    retry(e)\n                except socket.error as e:\n                    if e.errno not in (errno.ECONNRESET, errno.ETIMEDOUT):\n                        raise\n                    retry(e)\n\n                byte_counter += len(data_block)\n\n                # exit loop when download is finished\n                if len(data_block) == 0:\n                    break\n\n                # Open destination file just in time\n                if ctx.stream is None:\n                    try:\n                        ctx.stream, ctx.tmpfilename = sanitize_open(\n                            ctx.tmpfilename, ctx.open_mode)\n                        assert ctx.stream is not None\n                        ctx.filename = self.undo_temp_name(ctx.tmpfilename)\n                        self.report_destination(ctx.filename)\n                    except (OSError, IOError) as err:\n                        self.report_error('unable to open for writing: %s' % str(err))\n                        return False\n\n                    if self.params.get('xattr_set_filesize', False) and data_len is not None:\n                        try:\n                            write_xattr(ctx.tmpfilename, 'user.ytdl.filesize', str(data_len).encode('utf-8'))\n                        except (XAttrUnavailableError, XAttrMetadataError) as err:\n                            self.report_error('unable to set filesize xattr: %s' % str(err))\n\n                try:\n                    ctx.stream.write(data_block)\n                except (IOError, OSError) as err:\n                    self.to_stderr('\\n')\n                    self.report_error('unable to write data: %s' % str(err))\n                    return False\n\n                # Apply rate limit\n                self.slow_down(start, now, byte_counter - ctx.resume_len)\n\n                # end measuring of one loop run\n                now = time.time()\n                after = now\n\n                # Adjust block size\n                if not self.params.get('noresizebuffer', False):\n                    block_size = self.best_block_size(after - before, len(data_block))\n\n                before = after\n\n                # Progress message\n                speed = self.calc_speed(start, now, byte_counter - ctx.resume_len)\n                if ctx.data_len is None:\n                    eta = None\n                else:\n                    eta = self.calc_eta(start, time.time(), ctx.data_len - ctx.resume_len, byte_counter - ctx.resume_len)\n\n                self._hook_progress({\n                    'status': 'downloading',\n                    'downloaded_bytes': byte_counter,\n                    'total_bytes': ctx.data_len,\n                    'tmpfilename': ctx.tmpfilename,\n                    'filename': ctx.filename,\n                    'eta': eta,\n                    'speed': speed,\n                    'elapsed': now - ctx.start_time,\n                })\n\n                if is_test and byte_counter == data_len:\n                    break\n\n            if not is_test and ctx.chunk_size and ctx.data_len is not None and byte_counter < ctx.data_len:\n                ctx.resume_len = byte_counter\n                # ctx.block_size = block_size\n                raise NextFragment()\n\n            if ctx.stream is None:\n                self.to_stderr('\\n')\n                self.report_error('Did not get any data blocks')\n                return False\n            if ctx.tmpfilename != '-':\n                ctx.stream.close()\n\n            if data_len is not None and byte_counter != data_len:\n                err = ContentTooShortError(byte_counter, int(data_len))\n                if count <= retries:\n                    retry(err)\n                raise err\n\n            self.try_rename(ctx.tmpfilename, ctx.filename)\n\n            # Update file modification time\n            if self.params.get('updatetime', True):\n                info_dict['filetime'] = self.try_utime(ctx.filename, ctx.data.info().get('last-modified', None))\n\n            self._hook_progress({\n                'downloaded_bytes': byte_counter,\n                'total_bytes': byte_counter,\n                'filename': ctx.filename,\n                'status': 'finished',\n                'elapsed': time.time() - ctx.start_time,\n            })\n\n            return True\n\n        while count <= retries:\n            try:\n                establish_connection()\n                return download()\n            except RetryDownload as e:\n                count += 1\n                if count <= retries:\n                    self.report_retry(e.source_error, count, retries)\n                continue\n            except NextFragment:\n                continue\n            except SucceedDownload:\n                return True\n\n        self.report_error('giving up after %s retries' % retries)\n        return False\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "http.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/downloader/http.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}