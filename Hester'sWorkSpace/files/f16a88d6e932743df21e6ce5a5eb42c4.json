{"author": "tensorflow", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\"\"\"Testing support code.\"\"\"\n\n internal imports\nimport numpy as np\nimport six\n\nfrom google.protobuf import text_format\n\n\ndef assert_set_equality(test_case, expected, actual):\n  \"\"\"Asserts that two lists are equal without order.\n\n  Given two lists, treat them as sets and test equality. This function only\n  requires an __eq__ method to be defined on the objects, and not __hash__\n  which set comparison requires. This function removes the burden of defining\n  a __hash__ method just for testing.\n\n  This function calls into tf.test.TestCase.assert* methods and behaves\n  like a test assert. The function returns if `expected` and `actual`\n  contain the same objects regardless of ordering.\n\n  Note, this is an O(n^2) operation and is not suitable for large lists.\n\n  Args:\n    test_case: A tf.test.TestCase instance from a test.\n    expected: A list of objects.\n    actual: A list of objects.\n  \"\"\"\n  actual_found = np.zeros(len(actual), dtype=bool)\n  for expected_obj in expected:\n    found = False\n    for i, actual_obj in enumerate(actual):\n      if expected_obj == actual_obj:\n        actual_found[i] = True\n        found = True\n        break\n    if not found:\n      test_case.fail('Expected %s not found in actual collection' %\n                     expected_obj)\n  if not np.all(actual_found):\n    test_case.fail('Actual objects %s not found in expected collection' %\n                   np.array(actual)[np.invert(actual_found)])\n\n\ndef parse_test_proto(proto_type, proto_string):\n  instance = proto_type()\n  text_format.Merge(proto_string, instance)\n  return instance\n\n\nclass MockStringProto(object):\n  \"\"\"Provides common methods for a protocol buffer object.\n\n  Wraps a single string value. This makes testing equality easy.\n  \"\"\"\n\n  def __init__(self, string=''):\n    self.string = string\n\n  @staticmethod\n  def FromString(string):   pylint: disable=invalid-name\n    return MockStringProto(string)\n\n  def SerializeToString(self):   pylint: disable=invalid-name\n     protobuf's SerializeToString returns binary string\n    if six.PY3:\n      return ('serialized:' + self.string).encode('utf-8')\n    else:\n      return 'serialized:' + self.string\n\n  def __eq__(self, other):\n    return isinstance(other, MockStringProto) and self.string == other.string\n\n  def __hash__(self):\n    return hash(self.string)\n", "comments": "   testing support code        internal imports import numpy np import six  google protobuf import text format   def assert set equality(test case  expected  actual)       asserts two lists equal without order     given two lists  treat sets test equality  this function   requires   eq   method defined objects    hash     set comparison requires  this function removes burden defining     hash   method testing     this function calls tf test testcase assert  methods behaves   like test assert  the function returns  expected   actual    contain objects regardless ordering     note  o(n 2) operation suitable large lists     args      test case  a tf test testcase instance test      expected  a list objects      actual  a list objects          actual found   np zeros(len(actual)  dtype bool)   expected obj expected      found   false      actual obj enumerate(actual)        expected obj    actual obj          actual found    true         found   true         break     found        test case fail( expected  found actual collection                         expected obj)   np all(actual found)      test case fail( actual objects  found expected collection                       np array(actual) np invert(actual found) )   def parse test proto(proto type  proto string)    instance   proto type()   text format merge(proto string  instance)   return instance   class mockstringproto(object)       provides common methods protocol buffer object     wraps single string value  this makes testing equality easy           copyright 2016 google inc  all rights reserved        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license          http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license     internal imports    pylint  disable invalid name    pylint  disable invalid name    protobuf serializetostring returns binary string ", "content": "# Copyright 2016 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Testing support code.\"\"\"\n\n# internal imports\nimport numpy as np\nimport six\n\nfrom google.protobuf import text_format\n\n\ndef assert_set_equality(test_case, expected, actual):\n  \"\"\"Asserts that two lists are equal without order.\n\n  Given two lists, treat them as sets and test equality. This function only\n  requires an __eq__ method to be defined on the objects, and not __hash__\n  which set comparison requires. This function removes the burden of defining\n  a __hash__ method just for testing.\n\n  This function calls into tf.test.TestCase.assert* methods and behaves\n  like a test assert. The function returns if `expected` and `actual`\n  contain the same objects regardless of ordering.\n\n  Note, this is an O(n^2) operation and is not suitable for large lists.\n\n  Args:\n    test_case: A tf.test.TestCase instance from a test.\n    expected: A list of objects.\n    actual: A list of objects.\n  \"\"\"\n  actual_found = np.zeros(len(actual), dtype=bool)\n  for expected_obj in expected:\n    found = False\n    for i, actual_obj in enumerate(actual):\n      if expected_obj == actual_obj:\n        actual_found[i] = True\n        found = True\n        break\n    if not found:\n      test_case.fail('Expected %s not found in actual collection' %\n                     expected_obj)\n  if not np.all(actual_found):\n    test_case.fail('Actual objects %s not found in expected collection' %\n                   np.array(actual)[np.invert(actual_found)])\n\n\ndef parse_test_proto(proto_type, proto_string):\n  instance = proto_type()\n  text_format.Merge(proto_string, instance)\n  return instance\n\n\nclass MockStringProto(object):\n  \"\"\"Provides common methods for a protocol buffer object.\n\n  Wraps a single string value. This makes testing equality easy.\n  \"\"\"\n\n  def __init__(self, string=''):\n    self.string = string\n\n  @staticmethod\n  def FromString(string):  # pylint: disable=invalid-name\n    return MockStringProto(string)\n\n  def SerializeToString(self):  # pylint: disable=invalid-name\n    # protobuf's SerializeToString returns binary string\n    if six.PY3:\n      return ('serialized:' + self.string).encode('utf-8')\n    else:\n      return 'serialized:' + self.string\n\n  def __eq__(self, other):\n    return isinstance(other, MockStringProto) and self.string == other.string\n\n  def __hash__(self):\n    return hash(self.string)\n", "description": "Magenta: Music and Art Generation with Machine Intelligence", "file_name": "testing_lib.py", "id": "f16a88d6e932743df21e6ce5a5eb42c4", "language": "Python", "project_name": "magenta", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tensorflow-magenta/tensorflow-magenta-ca73164/magenta/common/testing_lib.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:00:14Z", "url": "https://github.com/tensorflow/magenta", "wiki": false}