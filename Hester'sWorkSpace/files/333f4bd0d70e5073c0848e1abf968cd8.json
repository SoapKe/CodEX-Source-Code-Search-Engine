{"author": "ansible", "code": " (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n\n This file is part of Ansible\n\n Ansible is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Ansible is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nDOCUMENTATION = '''\n    strategy: linear\n    short_description: Executes tasks in a linear fashion\n    description:\n        - Task execution is in lockstep per host batch as defined by C(serial) (default all).\n          Up to the fork limit of hosts will execute each task at the same time and then\n          the next series of hosts until the batch is done, before going on to the next task.\n    version_added: \"2.0\"\n    notes:\n     - This was the default Ansible behaviour before 'strategy plugins' were introduced in 2.0.\n    author: Ansible Core Team\n'''\n\nfrom ansible.errors import AnsibleError\nfrom ansible.executor.play_iterator import PlayIterator\nfrom ansible.module_utils.six import iteritems\nfrom ansible.module_utils._text import to_text\nfrom ansible.playbook.block import Block\nfrom ansible.playbook.included_file import IncludedFile\nfrom ansible.playbook.task import Task\nfrom ansible.plugins.loader import action_loader\nfrom ansible.plugins.strategy import StrategyBase\nfrom ansible.template import Templar\n\n\ntry:\n    from __main__ import display\nexcept ImportError:\n    from ansible.utils.display import Display\n    display = Display()\n\n\nclass StrategyModule(StrategyBase):\n\n    def _get_next_task_lockstep(self, hosts, iterator):\n        '''\n        Returns a list of (host, task) tuples, where the task may\n        be a noop task to keep the iterator in lock step across\n        all hosts.\n        '''\n\n        noop_task = Task()\n        noop_task.action = 'meta'\n        noop_task.args['_raw_params'] = 'noop'\n        noop_task.set_loader(iterator._play._loader)\n\n        host_tasks = {}\n        display.debug(\"building list of next tasks for hosts\")\n        for host in hosts:\n            host_tasks[host.name] = iterator.get_next_task_for_host(host, peek=True)\n        display.debug(\"done building task lists\")\n\n        num_setups = 0\n        num_tasks = 0\n        num_rescue = 0\n        num_always = 0\n\n        display.debug(\"counting tasks in each state of execution\")\n        host_tasks_to_run = [(host, state_task)\n                             for host, state_task in iteritems(host_tasks)\n                             if state_task and state_task[1]]\n\n        if host_tasks_to_run:\n            try:\n                lowest_cur_block = min(\n                    (s.cur_block for h, (s, t) in host_tasks_to_run\n                     if s.run_state != PlayIterator.ITERATING_COMPLETE))\n            except ValueError:\n                lowest_cur_block = None\n        else:\n             empty host_tasks_to_run will just run till the end of the function\n             without ever touching lowest_cur_block\n            lowest_cur_block = None\n\n        for (k, v) in host_tasks_to_run:\n            (s, t) = v\n\n            if s.cur_block > lowest_cur_block:\n                 Not the current block, ignore it\n                continue\n\n            if s.run_state == PlayIterator.ITERATING_SETUP:\n                num_setups += 1\n            elif s.run_state == PlayIterator.ITERATING_TASKS:\n                num_tasks += 1\n            elif s.run_state == PlayIterator.ITERATING_RESCUE:\n                num_rescue += 1\n            elif s.run_state == PlayIterator.ITERATING_ALWAYS:\n                num_always += 1\n        display.debug(\"done counting tasks in each state of execution:\\n\\tnum_setups: %s\\n\\tnum_tasks: %s\\n\\tnum_rescue: %s\\n\\tnum_always: %s\" % (num_setups,\n                                                                                                                                                  num_tasks,\n                                                                                                                                                  num_rescue,\n                                                                                                                                                  num_always))\n\n        def _advance_selected_hosts(hosts, cur_block, cur_state):\n            '''\n            This helper returns the task for all hosts in the requested\n            state, otherwise they get a noop dummy task. This also advances\n            the state of the host, since the given states are determined\n            while using peek=True.\n            '''\n             we return the values in the order they were originally\n             specified in the given hosts array\n            rvals = []\n            display.debug(\"starting to advance hosts\")\n            for host in hosts:\n                host_state_task = host_tasks.get(host.name)\n                if host_state_task is None:\n                    continue\n                (s, t) = host_state_task\n                if t is None:\n                    continue\n                if s.run_state == cur_state and s.cur_block == cur_block:\n                    new_t = iterator.get_next_task_for_host(host)\n                    rvals.append((host, t))\n                else:\n                    rvals.append((host, noop_task))\n            display.debug(\"done advancing hosts to next task\")\n            return rvals\n\n         if any hosts are in ITERATING_SETUP, return the setup task\n         while all other hosts get a noop\n        if num_setups:\n            display.debug(\"advancing hosts in ITERATING_SETUP\")\n            return _advance_selected_hosts(hosts, lowest_cur_block, PlayIterator.ITERATING_SETUP)\n\n         if any hosts are in ITERATING_TASKS, return the next normal\n         task for these hosts, while all other hosts get a noop\n        if num_tasks:\n            display.debug(\"advancing hosts in ITERATING_TASKS\")\n            return _advance_selected_hosts(hosts, lowest_cur_block, PlayIterator.ITERATING_TASKS)\n\n         if any hosts are in ITERATING_RESCUE, return the next rescue\n         task for these hosts, while all other hosts get a noop\n        if num_rescue:\n            display.debug(\"advancing hosts in ITERATING_RESCUE\")\n            return _advance_selected_hosts(hosts, lowest_cur_block, PlayIterator.ITERATING_RESCUE)\n\n         if any hosts are in ITERATING_ALWAYS, return the next always\n         task for these hosts, while all other hosts get a noop\n        if num_always:\n            display.debug(\"advancing hosts in ITERATING_ALWAYS\")\n            return _advance_selected_hosts(hosts, lowest_cur_block, PlayIterator.ITERATING_ALWAYS)\n\n         at this point, everything must be ITERATING_COMPLETE, so we\n         return None for all hosts in the list\n        display.debug(\"all hosts are done, so returning None's for all hosts\")\n        return [(host, None) for host in hosts]\n\n    def run(self, iterator, play_context):\n        '''\n        The linear strategy is simple - get the next task and queue\n        it for all hosts, then wait for the queue to drain before\n        moving on to the next task\n        '''\n\n         iteratate over each task, while there is one left to run\n        result = self._tqm.RUN_OK\n        work_to_do = True\n        while work_to_do and not self._tqm._terminated:\n\n            try:\n                display.debug(\"getting the remaining hosts for this loop\")\n                hosts_left = self.get_hosts_left(iterator)\n                display.debug(\"done getting the remaining hosts for this loop\")\n\n                 queue up this task for each host in the inventory\n                callback_sent = False\n                work_to_do = False\n\n                host_results = []\n                host_tasks = self._get_next_task_lockstep(hosts_left, iterator)\n\n                 skip control\n                skip_rest = False\n                choose_step = True\n\n                 flag set if task is set to any_errors_fatal\n                any_errors_fatal = False\n\n                results = []\n                for (host, task) in host_tasks:\n                    if not task:\n                        continue\n\n                    if self._tqm._terminated:\n                        break\n\n                    run_once = False\n                    work_to_do = True\n\n                     test to see if the task across all hosts points to an action plugin which\n                     sets BYPASS_HOST_LOOP to true, or if it has run_once enabled. If so, we\n                     will only send this task to the first host in the list.\n\n                    try:\n                        action = action_loader.get(task.action, class_only=True)\n                    except KeyError:\n                         we don't care here, because the action may simply not have a\n                         corresponding action plugin\n                        action = None\n\n                     check to see if this task should be skipped, due to it being a member of a\n                     role which has already run (and whether that role allows duplicate execution)\n                    if task._role and task._role.has_run(host):\n                         If there is no metadata, the default behavior is to not allow duplicates,\n                         if there is metadata, check to see if the allow_duplicates flag was set to true\n                        if task._role._metadata is None or task._role._metadata and not task._role._metadata.allow_duplicates:\n                            display.debug(\"'%s' skipped because role has already run\" % task)\n                            continue\n\n                    if task.action == 'meta':\n                         for the linear strategy, we run meta tasks just once and for\n                         all hosts currently being iterated over rather than one host\n                        results.extend(self._execute_meta(task, play_context, iterator, host))\n                        if task.args.get('_raw_params', None) != 'noop':\n                            run_once = True\n                    else:\n                         handle step if needed, skip meta actions as they are used internally\n                        if self._step and choose_step:\n                            if self._take_step(task):\n                                choose_step = False\n                            else:\n                                skip_rest = True\n                                break\n\n                        display.debug(\"getting variables\")\n                        task_vars = self._variable_manager.get_vars(play=iterator._play, host=host, task=task)\n                        self.add_tqm_variables(task_vars, play=iterator._play)\n                        templar = Templar(loader=self._loader, variables=task_vars)\n                        display.debug(\"done getting variables\")\n\n                        run_once = templar.template(task.run_once) or action and getattr(action, 'BYPASS_HOST_LOOP', False)\n\n                        if (task.any_errors_fatal or run_once) and not task.ignore_errors:\n                            any_errors_fatal = True\n\n                        if not callback_sent:\n                            display.debug(\"sending task start callback, copying the task so we can template it temporarily\")\n                            saved_name = task.name\n                            display.debug(\"done copying, going to template now\")\n                            try:\n                                task.name = to_text(templar.template(task.name, fail_on_undefined=False), nonstring='empty')\n                                display.debug(\"done templating\")\n                            except:\n                                 just ignore any errors during task name templating,\n                                 we don't care if it just shows the raw name\n                                display.debug(\"templating failed for some reason\")\n                            display.debug(\"here goes the callback...\")\n                            self._tqm.send_callback('v2_playbook_on_task_start', task, is_conditional=False)\n                            task.name = saved_name\n                            callback_sent = True\n                            display.debug(\"sending task start callback\")\n\n                        self._blocked_hosts[host.get_name()] = True\n                        self._queue_task(host, task, task_vars, play_context)\n                        del task_vars\n\n                     if we're bypassing the host loop, break out now\n                    if run_once:\n                        break\n\n                    results += self._process_pending_results(iterator, max_passes=max(1, int(len(self._tqm._workers) * 0.1)))\n\n                 go to next host/task group\n                if skip_rest:\n                    continue\n\n                display.debug(\"done queuing things up, now waiting for results queue to drain\")\n                if self._pending_results > 0:\n                    results += self._wait_on_pending_results(iterator)\n\n                host_results.extend(results)\n\n                self.update_active_connections(results)\n\n                try:\n                    included_files = IncludedFile.process_include_results(\n                        host_results,\n                        iterator=iterator,\n                        loader=self._loader,\n                        variable_manager=self._variable_manager\n                    )\n                except AnsibleError as e:\n                     this is a fatal error, so we abort here regardless of block state\n                    return self._tqm.RUN_ERROR\n\n                include_failure = False\n                if len(included_files) > 0:\n                    display.debug(\"we have included files to process\")\n\n                     A noop task for use in padding dynamic includes\n                    noop_task = Task()\n                    noop_task.action = 'meta'\n                    noop_task.args['_raw_params'] = 'noop'\n                    noop_task.set_loader(iterator._play._loader)\n\n                    display.debug(\"generating all_blocks data\")\n                    all_blocks = dict((host, []) for host in hosts_left)\n                    display.debug(\"done generating all_blocks data\")\n                    for included_file in included_files:\n                        display.debug(\"processing included file: %s\" % included_file._filename)\n                         included hosts get the task list while those excluded get an equal-length\n                         list of noop tasks, to make sure that they continue running in lock-step\n                        try:\n                            if included_file._is_role:\n                                new_ir = self._copy_included_file(included_file)\n\n                                new_blocks, handler_blocks = new_ir.get_block_list(\n                                    play=iterator._play,\n                                    variable_manager=self._variable_manager,\n                                    loader=self._loader,\n                                )\n                                self._tqm.update_handler_list([handler for handler_block in handler_blocks for handler in handler_block.block])\n                            else:\n                                new_blocks = self._load_included_file(included_file, iterator=iterator)\n\n                            display.debug(\"iterating over new_blocks loaded from include file\")\n                            for new_block in new_blocks:\n                                task_vars = self._variable_manager.get_vars(\n                                    play=iterator._play,\n                                    task=included_file._task,\n                                )\n                                display.debug(\"filtering new block on tags\")\n                                final_block = new_block.filter_tagged_tasks(play_context, task_vars)\n                                display.debug(\"done filtering new block on tags\")\n\n                                noop_block = Block(parent_block=task._parent)\n                                noop_block.block = [noop_task for t in new_block.block]\n                                noop_block.always = [noop_task for t in new_block.always]\n                                noop_block.rescue = [noop_task for t in new_block.rescue]\n\n                                for host in hosts_left:\n                                    if host in included_file._hosts:\n                                        all_blocks[host].append(final_block)\n                                    else:\n                                        all_blocks[host].append(noop_block)\n                            display.debug(\"done iterating over new_blocks loaded from include file\")\n\n                        except AnsibleError as e:\n                            for host in included_file._hosts:\n                                self._tqm._failed_hosts[host.name] = True\n                                iterator.mark_host_failed(host)\n                            display.error(to_text(e), wrap_text=False)\n                            include_failure = True\n                            continue\n\n                     finally go through all of the hosts and append the\n                     accumulated blocks to their list of tasks\n                    display.debug(\"extending task lists for all hosts with included blocks\")\n\n                    for host in hosts_left:\n                        iterator.add_tasks(host, all_blocks[host])\n\n                    display.debug(\"done extending task lists\")\n                    display.debug(\"done processing included files\")\n\n                display.debug(\"results queue empty\")\n\n                display.debug(\"checking for any_errors_fatal\")\n                failed_hosts = []\n                unreachable_hosts = []\n                for res in results:\n                    if res.is_failed() and iterator.is_failed(res._host):\n                        failed_hosts.append(res._host.name)\n                    elif res.is_unreachable():\n                        unreachable_hosts.append(res._host.name)\n\n                 if any_errors_fatal and we had an error, mark all hosts as failed\n                if any_errors_fatal and (len(failed_hosts) > 0 or len(unreachable_hosts) > 0):\n                    dont_fail_states = frozenset([iterator.ITERATING_RESCUE, iterator.ITERATING_ALWAYS])\n                    for host in hosts_left:\n                        (s, _) = iterator.get_next_task_for_host(host, peek=True)\n                        if s.run_state not in dont_fail_states or \\\n                           s.run_state == iterator.ITERATING_RESCUE and s.fail_state & iterator.FAILED_RESCUE != 0:\n                            self._tqm._failed_hosts[host.name] = True\n                            result |= self._tqm.RUN_FAILED_BREAK_PLAY\n                display.debug(\"done checking for any_errors_fatal\")\n\n                display.debug(\"checking for max_fail_percentage\")\n                if iterator._play.max_fail_percentage is not None and len(results) > 0:\n                    percentage = iterator._play.max_fail_percentage / 100.0\n\n                    if (len(self._tqm._failed_hosts) / iterator.batch_size) > percentage:\n                        for host in hosts_left:\n                             don't double-mark hosts, or the iterator will potentially\n                             fail them out of the rescue/always states\n                            if host.name not in failed_hosts:\n                                self._tqm._failed_hosts[host.name] = True\n                                iterator.mark_host_failed(host)\n                        self._tqm.send_callback('v2_playbook_on_no_hosts_remaining')\n                        result |= self._tqm.RUN_FAILED_BREAK_PLAY\n                    display.debug('(%s failed / %s total )> %s max fail' % (len(self._tqm._failed_hosts), iterator.batch_size, percentage))\n                display.debug(\"done checking for max_fail_percentage\")\n\n                display.debug(\"checking to see if all hosts have failed and the running result is not ok\")\n                if result != self._tqm.RUN_OK and len(self._tqm._failed_hosts) >= len(hosts_left):\n                    display.debug(\"^ not ok, so returning result now\")\n                    self._tqm.send_callback('v2_playbook_on_no_hosts_remaining')\n                    return result\n                display.debug(\"done checking to see if all hosts have failed\")\n\n            except (IOError, EOFError) as e:\n                display.debug(\"got IOError/EOFError in task loop: %s\" % e)\n                 most likely an abort, return failed\n                return self._tqm.RUN_UNKNOWN_ERROR\n\n         run the base class run() method, which executes the cleanup function\n         and runs any outstanding handlers which have been triggered\n\n        return super(StrategyModule, self).run(iterator, play_context, result)\n", "comments": "        strategy  linear     short description  executes tasks linear fashion     description            task execution lockstep per host batch defined c(serial) (default all)            up fork limit hosts execute task time           next series hosts batch done  going next task      version added   2 0      notes         this default ansible behaviour  strategy plugins  introduced 2 0      author  ansible core team      ansible errors import ansibleerror ansible executor play iterator import playiterator ansible module utils six import iteritems ansible module utils  text import text ansible playbook block import block ansible playbook included file import includedfile ansible playbook task import task ansible plugins loader import action loader ansible plugins strategy import strategybase ansible template import templar   try        main   import display except importerror      ansible utils display import display     display   display()   class strategymodule(strategybase)       def  get next task lockstep(self  hosts  iterator)                      returns list (host  task) tuples  task may         noop task keep iterator lock step across         hosts                       noop task   task()         noop task action    meta          noop task args   raw params      noop          noop task set loader(iterator  play  loader)          host tasks              display debug( building list next tasks hosts )         host hosts              host tasks host name    iterator get next task host(host  peek true)         display debug( done building task lists )          num setups   0         num tasks   0         num rescue   0         num always   0          display debug( counting tasks state execution )         host tasks run    (host  state task)                              host  state task iteritems(host tasks)                              state task state task 1            host tasks run              try                  lowest cur block   min(                     (s cur block h  (s  t) host tasks run                      run state    playiterator iterating complete))             except valueerror                  lowest cur block   none         else                empty host tasks run run till end function               without ever touching lowest cur block             lowest cur block   none          (k  v) host tasks run              (s  t)   v              cur block   lowest cur block                    not current block  ignore                 continue              run state    playiterator iterating setup                  num setups    1             elif run state    playiterator iterating tasks                  num tasks    1             elif run state    playiterator iterating rescue                  num rescue    1             elif run state    playiterator iterating always                  num always    1         display debug( done counting tasks state execution  n tnum setups   n tnum tasks   n tnum rescue   n tnum always      (num setups                                                                                                                                                    num tasks                                                                                                                                                    num rescue                                                                                                                                                    num always))          def  advance selected hosts(hosts  cur block  cur state)                              this helper returns task hosts requested             state  otherwise get noop dummy task  this also advances             state host  since given states determined             using peek true                                return values order originally               specified given hosts array             rvals                  display debug( starting advance hosts )             host hosts                  host state task   host tasks get(host name)                 host state task none                      continue                 (s  t)   host state task                 none                      continue                 run state    cur state cur block    cur block                      new   iterator get next task host(host)                     rvals append((host  t))                 else                      rvals append((host  noop task))             display debug( done advancing hosts next task )             return rvals            hosts iterating setup  return setup task           hosts get noop         num setups              display debug( advancing hosts iterating setup )             return  advance selected hosts(hosts  lowest cur block  playiterator iterating setup)            hosts iterating tasks  return next normal           task hosts  hosts get noop         num tasks              display debug( advancing hosts iterating tasks )             return  advance selected hosts(hosts  lowest cur block  playiterator iterating tasks)            hosts iterating rescue  return next rescue           task hosts  hosts get noop         num rescue              display debug( advancing hosts iterating rescue )             return  advance selected hosts(hosts  lowest cur block  playiterator iterating rescue)            hosts iterating always  return next always           task hosts  hosts get noop         num always              display debug( advancing hosts iterating always )             return  advance selected hosts(hosts  lowest cur block  playiterator iterating always)            point  everything must iterating complete            return none hosts list         display debug( hosts done  returning none hosts )         return  (host  none) host hosts       def run(self  iterator  play context)                      the linear strategy simple   get next task queue         hosts  wait queue drain         moving next task                (c) 2012 2014  michael dehaan  michael dehaan gmail com        this file part ansible       ansible free software  redistribute modify    terms gnu general public license published    free software foundation  either version 3 license     (at option) later version        ansible distributed hope useful     without any warranty  without even implied warranty    merchantability fitness for a particular purpose   see    gnu general public license details        you received copy gnu general public license    along ansible   if  see  http   www gnu org licenses       make coding python3 ish    empty host tasks run run till end function    without ever touching lowest cur block    not current block  ignore    return values order originally    specified given hosts array    hosts iterating setup  return setup task    hosts get noop    hosts iterating tasks  return next normal    task hosts  hosts get noop    hosts iterating rescue  return next rescue    task hosts  hosts get noop    hosts iterating always  return next always    task hosts  hosts get noop    point  everything must iterating complete     return none hosts list    iteratate task  one left run    queue task host inventory    skip control    flag set task set errors fatal    test see task across hosts points action plugin    sets bypass host loop true  run enabled  if     send task first host list     care  action may simply    corresponding action plugin    check see task skipped  due member    role already run (and whether role allows duplicate execution)    if metadata  default behavior allow duplicates     metadata  check see allow duplicates flag set true    linear strategy  run meta tasks    hosts currently iterated rather one host    handle step needed  skip meta actions used internally    ignore errors task name templating     care shows raw name    bypassing host loop  break    go next host task group    fatal error  abort regardless block state    a noop task use padding dynamic includes    included hosts get task list excluded get equal length    list noop tasks  make sure continue running lock step    finally go hosts append    accumulated blocks list tasks    errors fatal error  mark hosts failed    double mark hosts  iterator potentially    fail rescue always states    likely abort  return failed    run base class run() method  executes cleanup function    runs outstanding handlers triggered ", "content": "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nDOCUMENTATION = '''\n    strategy: linear\n    short_description: Executes tasks in a linear fashion\n    description:\n        - Task execution is in lockstep per host batch as defined by C(serial) (default all).\n          Up to the fork limit of hosts will execute each task at the same time and then\n          the next series of hosts until the batch is done, before going on to the next task.\n    version_added: \"2.0\"\n    notes:\n     - This was the default Ansible behaviour before 'strategy plugins' were introduced in 2.0.\n    author: Ansible Core Team\n'''\n\nfrom ansible.errors import AnsibleError\nfrom ansible.executor.play_iterator import PlayIterator\nfrom ansible.module_utils.six import iteritems\nfrom ansible.module_utils._text import to_text\nfrom ansible.playbook.block import Block\nfrom ansible.playbook.included_file import IncludedFile\nfrom ansible.playbook.task import Task\nfrom ansible.plugins.loader import action_loader\nfrom ansible.plugins.strategy import StrategyBase\nfrom ansible.template import Templar\n\n\ntry:\n    from __main__ import display\nexcept ImportError:\n    from ansible.utils.display import Display\n    display = Display()\n\n\nclass StrategyModule(StrategyBase):\n\n    def _get_next_task_lockstep(self, hosts, iterator):\n        '''\n        Returns a list of (host, task) tuples, where the task may\n        be a noop task to keep the iterator in lock step across\n        all hosts.\n        '''\n\n        noop_task = Task()\n        noop_task.action = 'meta'\n        noop_task.args['_raw_params'] = 'noop'\n        noop_task.set_loader(iterator._play._loader)\n\n        host_tasks = {}\n        display.debug(\"building list of next tasks for hosts\")\n        for host in hosts:\n            host_tasks[host.name] = iterator.get_next_task_for_host(host, peek=True)\n        display.debug(\"done building task lists\")\n\n        num_setups = 0\n        num_tasks = 0\n        num_rescue = 0\n        num_always = 0\n\n        display.debug(\"counting tasks in each state of execution\")\n        host_tasks_to_run = [(host, state_task)\n                             for host, state_task in iteritems(host_tasks)\n                             if state_task and state_task[1]]\n\n        if host_tasks_to_run:\n            try:\n                lowest_cur_block = min(\n                    (s.cur_block for h, (s, t) in host_tasks_to_run\n                     if s.run_state != PlayIterator.ITERATING_COMPLETE))\n            except ValueError:\n                lowest_cur_block = None\n        else:\n            # empty host_tasks_to_run will just run till the end of the function\n            # without ever touching lowest_cur_block\n            lowest_cur_block = None\n\n        for (k, v) in host_tasks_to_run:\n            (s, t) = v\n\n            if s.cur_block > lowest_cur_block:\n                # Not the current block, ignore it\n                continue\n\n            if s.run_state == PlayIterator.ITERATING_SETUP:\n                num_setups += 1\n            elif s.run_state == PlayIterator.ITERATING_TASKS:\n                num_tasks += 1\n            elif s.run_state == PlayIterator.ITERATING_RESCUE:\n                num_rescue += 1\n            elif s.run_state == PlayIterator.ITERATING_ALWAYS:\n                num_always += 1\n        display.debug(\"done counting tasks in each state of execution:\\n\\tnum_setups: %s\\n\\tnum_tasks: %s\\n\\tnum_rescue: %s\\n\\tnum_always: %s\" % (num_setups,\n                                                                                                                                                  num_tasks,\n                                                                                                                                                  num_rescue,\n                                                                                                                                                  num_always))\n\n        def _advance_selected_hosts(hosts, cur_block, cur_state):\n            '''\n            This helper returns the task for all hosts in the requested\n            state, otherwise they get a noop dummy task. This also advances\n            the state of the host, since the given states are determined\n            while using peek=True.\n            '''\n            # we return the values in the order they were originally\n            # specified in the given hosts array\n            rvals = []\n            display.debug(\"starting to advance hosts\")\n            for host in hosts:\n                host_state_task = host_tasks.get(host.name)\n                if host_state_task is None:\n                    continue\n                (s, t) = host_state_task\n                if t is None:\n                    continue\n                if s.run_state == cur_state and s.cur_block == cur_block:\n                    new_t = iterator.get_next_task_for_host(host)\n                    rvals.append((host, t))\n                else:\n                    rvals.append((host, noop_task))\n            display.debug(\"done advancing hosts to next task\")\n            return rvals\n\n        # if any hosts are in ITERATING_SETUP, return the setup task\n        # while all other hosts get a noop\n        if num_setups:\n            display.debug(\"advancing hosts in ITERATING_SETUP\")\n            return _advance_selected_hosts(hosts, lowest_cur_block, PlayIterator.ITERATING_SETUP)\n\n        # if any hosts are in ITERATING_TASKS, return the next normal\n        # task for these hosts, while all other hosts get a noop\n        if num_tasks:\n            display.debug(\"advancing hosts in ITERATING_TASKS\")\n            return _advance_selected_hosts(hosts, lowest_cur_block, PlayIterator.ITERATING_TASKS)\n\n        # if any hosts are in ITERATING_RESCUE, return the next rescue\n        # task for these hosts, while all other hosts get a noop\n        if num_rescue:\n            display.debug(\"advancing hosts in ITERATING_RESCUE\")\n            return _advance_selected_hosts(hosts, lowest_cur_block, PlayIterator.ITERATING_RESCUE)\n\n        # if any hosts are in ITERATING_ALWAYS, return the next always\n        # task for these hosts, while all other hosts get a noop\n        if num_always:\n            display.debug(\"advancing hosts in ITERATING_ALWAYS\")\n            return _advance_selected_hosts(hosts, lowest_cur_block, PlayIterator.ITERATING_ALWAYS)\n\n        # at this point, everything must be ITERATING_COMPLETE, so we\n        # return None for all hosts in the list\n        display.debug(\"all hosts are done, so returning None's for all hosts\")\n        return [(host, None) for host in hosts]\n\n    def run(self, iterator, play_context):\n        '''\n        The linear strategy is simple - get the next task and queue\n        it for all hosts, then wait for the queue to drain before\n        moving on to the next task\n        '''\n\n        # iteratate over each task, while there is one left to run\n        result = self._tqm.RUN_OK\n        work_to_do = True\n        while work_to_do and not self._tqm._terminated:\n\n            try:\n                display.debug(\"getting the remaining hosts for this loop\")\n                hosts_left = self.get_hosts_left(iterator)\n                display.debug(\"done getting the remaining hosts for this loop\")\n\n                # queue up this task for each host in the inventory\n                callback_sent = False\n                work_to_do = False\n\n                host_results = []\n                host_tasks = self._get_next_task_lockstep(hosts_left, iterator)\n\n                # skip control\n                skip_rest = False\n                choose_step = True\n\n                # flag set if task is set to any_errors_fatal\n                any_errors_fatal = False\n\n                results = []\n                for (host, task) in host_tasks:\n                    if not task:\n                        continue\n\n                    if self._tqm._terminated:\n                        break\n\n                    run_once = False\n                    work_to_do = True\n\n                    # test to see if the task across all hosts points to an action plugin which\n                    # sets BYPASS_HOST_LOOP to true, or if it has run_once enabled. If so, we\n                    # will only send this task to the first host in the list.\n\n                    try:\n                        action = action_loader.get(task.action, class_only=True)\n                    except KeyError:\n                        # we don't care here, because the action may simply not have a\n                        # corresponding action plugin\n                        action = None\n\n                    # check to see if this task should be skipped, due to it being a member of a\n                    # role which has already run (and whether that role allows duplicate execution)\n                    if task._role and task._role.has_run(host):\n                        # If there is no metadata, the default behavior is to not allow duplicates,\n                        # if there is metadata, check to see if the allow_duplicates flag was set to true\n                        if task._role._metadata is None or task._role._metadata and not task._role._metadata.allow_duplicates:\n                            display.debug(\"'%s' skipped because role has already run\" % task)\n                            continue\n\n                    if task.action == 'meta':\n                        # for the linear strategy, we run meta tasks just once and for\n                        # all hosts currently being iterated over rather than one host\n                        results.extend(self._execute_meta(task, play_context, iterator, host))\n                        if task.args.get('_raw_params', None) != 'noop':\n                            run_once = True\n                    else:\n                        # handle step if needed, skip meta actions as they are used internally\n                        if self._step and choose_step:\n                            if self._take_step(task):\n                                choose_step = False\n                            else:\n                                skip_rest = True\n                                break\n\n                        display.debug(\"getting variables\")\n                        task_vars = self._variable_manager.get_vars(play=iterator._play, host=host, task=task)\n                        self.add_tqm_variables(task_vars, play=iterator._play)\n                        templar = Templar(loader=self._loader, variables=task_vars)\n                        display.debug(\"done getting variables\")\n\n                        run_once = templar.template(task.run_once) or action and getattr(action, 'BYPASS_HOST_LOOP', False)\n\n                        if (task.any_errors_fatal or run_once) and not task.ignore_errors:\n                            any_errors_fatal = True\n\n                        if not callback_sent:\n                            display.debug(\"sending task start callback, copying the task so we can template it temporarily\")\n                            saved_name = task.name\n                            display.debug(\"done copying, going to template now\")\n                            try:\n                                task.name = to_text(templar.template(task.name, fail_on_undefined=False), nonstring='empty')\n                                display.debug(\"done templating\")\n                            except:\n                                # just ignore any errors during task name templating,\n                                # we don't care if it just shows the raw name\n                                display.debug(\"templating failed for some reason\")\n                            display.debug(\"here goes the callback...\")\n                            self._tqm.send_callback('v2_playbook_on_task_start', task, is_conditional=False)\n                            task.name = saved_name\n                            callback_sent = True\n                            display.debug(\"sending task start callback\")\n\n                        self._blocked_hosts[host.get_name()] = True\n                        self._queue_task(host, task, task_vars, play_context)\n                        del task_vars\n\n                    # if we're bypassing the host loop, break out now\n                    if run_once:\n                        break\n\n                    results += self._process_pending_results(iterator, max_passes=max(1, int(len(self._tqm._workers) * 0.1)))\n\n                # go to next host/task group\n                if skip_rest:\n                    continue\n\n                display.debug(\"done queuing things up, now waiting for results queue to drain\")\n                if self._pending_results > 0:\n                    results += self._wait_on_pending_results(iterator)\n\n                host_results.extend(results)\n\n                self.update_active_connections(results)\n\n                try:\n                    included_files = IncludedFile.process_include_results(\n                        host_results,\n                        iterator=iterator,\n                        loader=self._loader,\n                        variable_manager=self._variable_manager\n                    )\n                except AnsibleError as e:\n                    # this is a fatal error, so we abort here regardless of block state\n                    return self._tqm.RUN_ERROR\n\n                include_failure = False\n                if len(included_files) > 0:\n                    display.debug(\"we have included files to process\")\n\n                    # A noop task for use in padding dynamic includes\n                    noop_task = Task()\n                    noop_task.action = 'meta'\n                    noop_task.args['_raw_params'] = 'noop'\n                    noop_task.set_loader(iterator._play._loader)\n\n                    display.debug(\"generating all_blocks data\")\n                    all_blocks = dict((host, []) for host in hosts_left)\n                    display.debug(\"done generating all_blocks data\")\n                    for included_file in included_files:\n                        display.debug(\"processing included file: %s\" % included_file._filename)\n                        # included hosts get the task list while those excluded get an equal-length\n                        # list of noop tasks, to make sure that they continue running in lock-step\n                        try:\n                            if included_file._is_role:\n                                new_ir = self._copy_included_file(included_file)\n\n                                new_blocks, handler_blocks = new_ir.get_block_list(\n                                    play=iterator._play,\n                                    variable_manager=self._variable_manager,\n                                    loader=self._loader,\n                                )\n                                self._tqm.update_handler_list([handler for handler_block in handler_blocks for handler in handler_block.block])\n                            else:\n                                new_blocks = self._load_included_file(included_file, iterator=iterator)\n\n                            display.debug(\"iterating over new_blocks loaded from include file\")\n                            for new_block in new_blocks:\n                                task_vars = self._variable_manager.get_vars(\n                                    play=iterator._play,\n                                    task=included_file._task,\n                                )\n                                display.debug(\"filtering new block on tags\")\n                                final_block = new_block.filter_tagged_tasks(play_context, task_vars)\n                                display.debug(\"done filtering new block on tags\")\n\n                                noop_block = Block(parent_block=task._parent)\n                                noop_block.block = [noop_task for t in new_block.block]\n                                noop_block.always = [noop_task for t in new_block.always]\n                                noop_block.rescue = [noop_task for t in new_block.rescue]\n\n                                for host in hosts_left:\n                                    if host in included_file._hosts:\n                                        all_blocks[host].append(final_block)\n                                    else:\n                                        all_blocks[host].append(noop_block)\n                            display.debug(\"done iterating over new_blocks loaded from include file\")\n\n                        except AnsibleError as e:\n                            for host in included_file._hosts:\n                                self._tqm._failed_hosts[host.name] = True\n                                iterator.mark_host_failed(host)\n                            display.error(to_text(e), wrap_text=False)\n                            include_failure = True\n                            continue\n\n                    # finally go through all of the hosts and append the\n                    # accumulated blocks to their list of tasks\n                    display.debug(\"extending task lists for all hosts with included blocks\")\n\n                    for host in hosts_left:\n                        iterator.add_tasks(host, all_blocks[host])\n\n                    display.debug(\"done extending task lists\")\n                    display.debug(\"done processing included files\")\n\n                display.debug(\"results queue empty\")\n\n                display.debug(\"checking for any_errors_fatal\")\n                failed_hosts = []\n                unreachable_hosts = []\n                for res in results:\n                    if res.is_failed() and iterator.is_failed(res._host):\n                        failed_hosts.append(res._host.name)\n                    elif res.is_unreachable():\n                        unreachable_hosts.append(res._host.name)\n\n                # if any_errors_fatal and we had an error, mark all hosts as failed\n                if any_errors_fatal and (len(failed_hosts) > 0 or len(unreachable_hosts) > 0):\n                    dont_fail_states = frozenset([iterator.ITERATING_RESCUE, iterator.ITERATING_ALWAYS])\n                    for host in hosts_left:\n                        (s, _) = iterator.get_next_task_for_host(host, peek=True)\n                        if s.run_state not in dont_fail_states or \\\n                           s.run_state == iterator.ITERATING_RESCUE and s.fail_state & iterator.FAILED_RESCUE != 0:\n                            self._tqm._failed_hosts[host.name] = True\n                            result |= self._tqm.RUN_FAILED_BREAK_PLAY\n                display.debug(\"done checking for any_errors_fatal\")\n\n                display.debug(\"checking for max_fail_percentage\")\n                if iterator._play.max_fail_percentage is not None and len(results) > 0:\n                    percentage = iterator._play.max_fail_percentage / 100.0\n\n                    if (len(self._tqm._failed_hosts) / iterator.batch_size) > percentage:\n                        for host in hosts_left:\n                            # don't double-mark hosts, or the iterator will potentially\n                            # fail them out of the rescue/always states\n                            if host.name not in failed_hosts:\n                                self._tqm._failed_hosts[host.name] = True\n                                iterator.mark_host_failed(host)\n                        self._tqm.send_callback('v2_playbook_on_no_hosts_remaining')\n                        result |= self._tqm.RUN_FAILED_BREAK_PLAY\n                    display.debug('(%s failed / %s total )> %s max fail' % (len(self._tqm._failed_hosts), iterator.batch_size, percentage))\n                display.debug(\"done checking for max_fail_percentage\")\n\n                display.debug(\"checking to see if all hosts have failed and the running result is not ok\")\n                if result != self._tqm.RUN_OK and len(self._tqm._failed_hosts) >= len(hosts_left):\n                    display.debug(\"^ not ok, so returning result now\")\n                    self._tqm.send_callback('v2_playbook_on_no_hosts_remaining')\n                    return result\n                display.debug(\"done checking to see if all hosts have failed\")\n\n            except (IOError, EOFError) as e:\n                display.debug(\"got IOError/EOFError in task loop: %s\" % e)\n                # most likely an abort, return failed\n                return self._tqm.RUN_UNKNOWN_ERROR\n\n        # run the base class run() method, which executes the cleanup function\n        # and runs any outstanding handlers which have been triggered\n\n        return super(StrategyModule, self).run(iterator, play_context, result)\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "linear.py", "id": "333f4bd0d70e5073c0848e1abf968cd8", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/plugins/strategy/linear.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}