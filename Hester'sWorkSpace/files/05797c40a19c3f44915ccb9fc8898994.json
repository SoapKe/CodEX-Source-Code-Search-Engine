{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport json\nimport random\nimport re\nimport time\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_urlparse,\n)\nfrom ..utils import (\n    ExtractorError,\n    float_or_none,\n    int_or_none,\n    KNOWN_EXTENSIONS,\n    parse_filesize,\n    unescapeHTML,\n    update_url_query,\n    unified_strdate,\n)\n\n\nclass BandcampIE(InfoExtractor):\n    _VALID_URL = r'https?://.*?\\.bandcamp\\.com/track/(?P<title>[^/?\n    _TESTS = [{\n        'url': 'http://youtube-dl.bandcamp.com/track/youtube-dl-test-song',\n        'md5': 'c557841d5e50261777a6585648adf439',\n        'info_dict': {\n            'id': '1812978515',\n            'ext': 'mp3',\n            'title': \"youtube-dl  \\\"'/\\\\\\u00e4\\u21ad - youtube-dl test song \\\"'/\\\\\\u00e4\\u21ad\",\n            'duration': 9.8485,\n        },\n        '_skip': 'There is a limit of 200 free downloads / month for the test song'\n    }, {\n        'url': 'http://benprunty.bandcamp.com/track/lanius-battle',\n        'md5': '0369ace6b939f0927e62c67a1a8d9fa7',\n        'info_dict': {\n            'id': '2650410135',\n            'ext': 'aiff',\n            'title': 'Ben Prunty - Lanius (Battle)',\n            'uploader': 'Ben Prunty',\n        },\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        title = mobj.group('title')\n        webpage = self._download_webpage(url, title)\n        thumbnail = self._html_search_meta('og:image', webpage, default=None)\n        m_download = re.search(r'freeDownloadPage: \"(.*?)\"', webpage)\n        if not m_download:\n            m_trackinfo = re.search(r'trackinfo: (.+),\\s*?\\n', webpage)\n            if m_trackinfo:\n                json_code = m_trackinfo.group(1)\n                data = json.loads(json_code)[0]\n                track_id = compat_str(data['id'])\n\n                if not data.get('file'):\n                    raise ExtractorError('Not streamable', video_id=track_id, expected=True)\n\n                formats = []\n                for format_id, format_url in data['file'].items():\n                    ext, abr_str = format_id.split('-', 1)\n                    formats.append({\n                        'format_id': format_id,\n                        'url': self._proto_relative_url(format_url, 'http:'),\n                        'ext': ext,\n                        'vcodec': 'none',\n                        'acodec': ext,\n                        'abr': int_or_none(abr_str),\n                    })\n\n                self._sort_formats(formats)\n\n                return {\n                    'id': track_id,\n                    'title': data['title'],\n                    'thumbnail': thumbnail,\n                    'formats': formats,\n                    'duration': float_or_none(data.get('duration')),\n                }\n            else:\n                raise ExtractorError('No free songs found')\n\n        download_link = m_download.group(1)\n        video_id = self._search_regex(\n            r'(?ms)var TralbumData = .*?[{,]\\s*id: (?P<id>\\d+),?$',\n            webpage, 'video id')\n\n        download_webpage = self._download_webpage(\n            download_link, video_id, 'Downloading free downloads page')\n\n        blob = self._parse_json(\n            self._search_regex(\n                r'data-blob=([\"\\'])(?P<blob>{.+?})\\1', download_webpage,\n                'blob', group='blob'),\n            video_id, transform_source=unescapeHTML)\n\n        info = blob['digital_items'][0]\n\n        downloads = info['downloads']\n        track = info['title']\n\n        artist = info.get('artist')\n        title = '%s - %s' % (artist, track) if artist else track\n\n        download_formats = {}\n        for f in blob['download_formats']:\n            name, ext = f.get('name'), f.get('file_extension')\n            if all(isinstance(x, compat_str) for x in (name, ext)):\n                download_formats[name] = ext.strip('.')\n\n        formats = []\n        for format_id, f in downloads.items():\n            format_url = f.get('url')\n            if not format_url:\n                continue\n            \n            \n            stat_url = update_url_query(\n                format_url.replace('/download/', '/statdownload/'), {\n                    '.rand': int(time.time() * 1000 * random.random()),\n                })\n            format_id = f.get('encoding_name') or format_id\n            stat = self._download_json(\n                stat_url, video_id, 'Downloading %s JSON' % format_id,\n                transform_source=lambda s: s[s.index('{'):s.rindex('}') + 1],\n                fatal=False)\n            if not stat:\n                continue\n            retry_url = stat.get('retry_url')\n            if not isinstance(retry_url, compat_str):\n                continue\n            formats.append({\n                'url': self._proto_relative_url(retry_url, 'http:'),\n                'ext': download_formats.get(format_id),\n                'format_id': format_id,\n                'format_note': f.get('description'),\n                'filesize': parse_filesize(f.get('size_mb')),\n                'vcodec': 'none',\n            })\n        self._sort_formats(formats)\n\n        return {\n            'id': video_id,\n            'title': title,\n            'thumbnail': info.get('thumb_url') or thumbnail,\n            'uploader': info.get('artist'),\n            'artist': artist,\n            'track': track,\n            'formats': formats,\n        }\n\n\nclass BandcampAlbumIE(InfoExtractor):\n    IE_NAME = 'Bandcamp:album'\n    _VALID_URL = r'https?://(?:(?P<subdomain>[^.]+)\\.)?bandcamp\\.com(?:/album/(?P<album_id>[^/?\n\n    _TESTS = [{\n        'url': 'http://blazo.bandcamp.com/album/jazz-format-mixtape-vol-1',\n        'playlist': [\n            {\n                'md5': '39bc1eded3476e927c724321ddf116cf',\n                'info_dict': {\n                    'id': '1353101989',\n                    'ext': 'mp3',\n                    'title': 'Intro',\n                }\n            },\n            {\n                'md5': '1a2c32e2691474643e912cc6cd4bffaa',\n                'info_dict': {\n                    'id': '38097443',\n                    'ext': 'mp3',\n                    'title': 'Kero One - Keep It Alive (Blazo remix)',\n                }\n            },\n        ],\n        'info_dict': {\n            'title': 'Jazz Format Mixtape vol.1',\n            'id': 'jazz-format-mixtape-vol-1',\n            'uploader_id': 'blazo',\n        },\n        'params': {\n            'playlistend': 2\n        },\n        'skip': 'Bandcamp imposes download limits.'\n    }, {\n        'url': 'http://nightbringer.bandcamp.com/album/hierophany-of-the-open-grave',\n        'info_dict': {\n            'title': 'Hierophany of the Open Grave',\n            'uploader_id': 'nightbringer',\n            'id': 'hierophany-of-the-open-grave',\n        },\n        'playlist_mincount': 9,\n    }, {\n        'url': 'http://dotscale.bandcamp.com',\n        'info_dict': {\n            'title': 'Loom',\n            'id': 'dotscale',\n            'uploader_id': 'dotscale',\n        },\n        'playlist_mincount': 7,\n    }, {\n        \n        'url': 'https://jstrecords.bandcamp.com/album/entropy-ep',\n        'info_dict': {\n            'title': '\"Entropy\" EP',\n            'uploader_id': 'jstrecords',\n            'id': 'entropy-ep',\n        },\n        'playlist_mincount': 3,\n    }, {\n        \n        'url': 'https://insulters.bandcamp.com/album/we-are-the-plague',\n        'info_dict': {\n            'id': 'we-are-the-plague',\n            'title': 'WE ARE THE PLAGUE',\n            'uploader_id': 'insulters',\n        },\n        'playlist_count': 2,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return (False\n                if BandcampWeeklyIE.suitable(url) or BandcampIE.suitable(url)\n                else super(BandcampAlbumIE, cls).suitable(url))\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        uploader_id = mobj.group('subdomain')\n        album_id = mobj.group('album_id')\n        playlist_id = album_id or uploader_id\n        webpage = self._download_webpage(url, playlist_id)\n        track_elements = re.findall(\n            r'(?s)<div[^>]*>(.*?<a[^>]+href=\"([^\"]+?)\"[^>]+itemprop=\"url\"[^>]*>.*?)</div>', webpage)\n        if not track_elements:\n            raise ExtractorError('The page doesn\\'t contain any tracks')\n        \n        entries = [\n            self.url_result(\n                compat_urlparse.urljoin(url, t_path),\n                ie=BandcampIE.ie_key(),\n                video_title=self._search_regex(\n                    r'<span\\b[^>]+\\bitemprop=[\"\\']name[\"\\'][^>]*>([^<]+)',\n                    elem_content, 'track title', fatal=False))\n            for elem_content, t_path in track_elements\n            if self._html_search_meta('duration', elem_content, default=None)]\n\n        title = self._html_search_regex(\n            r'album_title\\s*:\\s*\"((?:\\\\.|[^\"\\\\])+?)\"',\n            webpage, 'title', fatal=False)\n        if title:\n            title = title.replace(r'\\\"', '\"')\n        return {\n            '_type': 'playlist',\n            'uploader_id': uploader_id,\n            'id': playlist_id,\n            'title': title,\n            'entries': entries,\n        }\n\n\nclass BandcampWeeklyIE(InfoExtractor):\n    IE_NAME = 'Bandcamp:weekly'\n    _VALID_URL = r'https?://(?:www\\.)?bandcamp\\.com/?\\?(?:.*?&)?show=(?P<id>\\d+)'\n    _TESTS = [{\n        'url': 'https://bandcamp.com/?show=224',\n        'md5': 'b00df799c733cf7e0c567ed187dea0fd',\n        'info_dict': {\n            'id': '224',\n            'ext': 'opus',\n            'title': 'BC Weekly April 4th 2017 - Magic Moments',\n            'description': 'md5:5d48150916e8e02d030623a48512c874',\n            'duration': 5829.77,\n            'release_date': '20170404',\n            'series': 'Bandcamp Weekly',\n            'episode': 'Magic Moments',\n            'episode_number': 208,\n            'episode_id': '224',\n        }\n    }, {\n        'url': 'https://bandcamp.com/?blah/blah@&show=228',\n        'only_matching': True\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        webpage = self._download_webpage(url, video_id)\n\n        blob = self._parse_json(\n            self._search_regex(\n                r'data-blob=([\"\\'])(?P<blob>{.+?})\\1', webpage,\n                'blob', group='blob'),\n            video_id, transform_source=unescapeHTML)\n\n        show = blob['bcw_show']\n\n        \n        \n        show_id = int_or_none(show.get('show_id')) or int_or_none(video_id)\n\n        formats = []\n        for format_id, format_url in show['audio_stream'].items():\n            if not isinstance(format_url, compat_str):\n                continue\n            for known_ext in KNOWN_EXTENSIONS:\n                if known_ext in format_id:\n                    ext = known_ext\n                    break\n            else:\n                ext = None\n            formats.append({\n                'format_id': format_id,\n                'url': format_url,\n                'ext': ext,\n                'vcodec': 'none',\n            })\n        self._sort_formats(formats)\n\n        title = show.get('audio_title') or 'Bandcamp Weekly'\n        subtitle = show.get('subtitle')\n        if subtitle:\n            title += ' - %s' % subtitle\n\n        episode_number = None\n        seq = blob.get('bcw_seq')\n\n        if seq and isinstance(seq, list):\n            try:\n                episode_number = next(\n                    int_or_none(e.get('episode_number'))\n                    for e in seq\n                    if isinstance(e, dict) and int_or_none(e.get('id')) == show_id)\n            except StopIteration:\n                pass\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': show.get('desc') or show.get('short_desc'),\n            'duration': float_or_none(show.get('audio_duration')),\n            'is_live': False,\n            'release_date': unified_strdate(show.get('published_date')),\n            'series': 'Bandcamp Weekly',\n            'episode': show.get('subtitle'),\n            'episode_number': episode_number,\n            'episode_id': compat_str(video_id),\n            'formats': formats\n        }\n", "comments": "#&]+)'\n# Stat URL generation algorithm is reverse engineered from\n# download_*_bundle_*.js\n#&]+))?'\n# with escaped quote in title\n# not all tracks have songs\n# Only tracks with duration info have songs\n# This is desired because any invalid show id redirects to `bandcamp.com`\n# which happens to expose the latest Bandcamp Weekly episode.\n", "content": "from __future__ import unicode_literals\n\nimport json\nimport random\nimport re\nimport time\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_urlparse,\n)\nfrom ..utils import (\n    ExtractorError,\n    float_or_none,\n    int_or_none,\n    KNOWN_EXTENSIONS,\n    parse_filesize,\n    unescapeHTML,\n    update_url_query,\n    unified_strdate,\n)\n\n\nclass BandcampIE(InfoExtractor):\n    _VALID_URL = r'https?://.*?\\.bandcamp\\.com/track/(?P<title>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'http://youtube-dl.bandcamp.com/track/youtube-dl-test-song',\n        'md5': 'c557841d5e50261777a6585648adf439',\n        'info_dict': {\n            'id': '1812978515',\n            'ext': 'mp3',\n            'title': \"youtube-dl  \\\"'/\\\\\\u00e4\\u21ad - youtube-dl test song \\\"'/\\\\\\u00e4\\u21ad\",\n            'duration': 9.8485,\n        },\n        '_skip': 'There is a limit of 200 free downloads / month for the test song'\n    }, {\n        'url': 'http://benprunty.bandcamp.com/track/lanius-battle',\n        'md5': '0369ace6b939f0927e62c67a1a8d9fa7',\n        'info_dict': {\n            'id': '2650410135',\n            'ext': 'aiff',\n            'title': 'Ben Prunty - Lanius (Battle)',\n            'uploader': 'Ben Prunty',\n        },\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        title = mobj.group('title')\n        webpage = self._download_webpage(url, title)\n        thumbnail = self._html_search_meta('og:image', webpage, default=None)\n        m_download = re.search(r'freeDownloadPage: \"(.*?)\"', webpage)\n        if not m_download:\n            m_trackinfo = re.search(r'trackinfo: (.+),\\s*?\\n', webpage)\n            if m_trackinfo:\n                json_code = m_trackinfo.group(1)\n                data = json.loads(json_code)[0]\n                track_id = compat_str(data['id'])\n\n                if not data.get('file'):\n                    raise ExtractorError('Not streamable', video_id=track_id, expected=True)\n\n                formats = []\n                for format_id, format_url in data['file'].items():\n                    ext, abr_str = format_id.split('-', 1)\n                    formats.append({\n                        'format_id': format_id,\n                        'url': self._proto_relative_url(format_url, 'http:'),\n                        'ext': ext,\n                        'vcodec': 'none',\n                        'acodec': ext,\n                        'abr': int_or_none(abr_str),\n                    })\n\n                self._sort_formats(formats)\n\n                return {\n                    'id': track_id,\n                    'title': data['title'],\n                    'thumbnail': thumbnail,\n                    'formats': formats,\n                    'duration': float_or_none(data.get('duration')),\n                }\n            else:\n                raise ExtractorError('No free songs found')\n\n        download_link = m_download.group(1)\n        video_id = self._search_regex(\n            r'(?ms)var TralbumData = .*?[{,]\\s*id: (?P<id>\\d+),?$',\n            webpage, 'video id')\n\n        download_webpage = self._download_webpage(\n            download_link, video_id, 'Downloading free downloads page')\n\n        blob = self._parse_json(\n            self._search_regex(\n                r'data-blob=([\"\\'])(?P<blob>{.+?})\\1', download_webpage,\n                'blob', group='blob'),\n            video_id, transform_source=unescapeHTML)\n\n        info = blob['digital_items'][0]\n\n        downloads = info['downloads']\n        track = info['title']\n\n        artist = info.get('artist')\n        title = '%s - %s' % (artist, track) if artist else track\n\n        download_formats = {}\n        for f in blob['download_formats']:\n            name, ext = f.get('name'), f.get('file_extension')\n            if all(isinstance(x, compat_str) for x in (name, ext)):\n                download_formats[name] = ext.strip('.')\n\n        formats = []\n        for format_id, f in downloads.items():\n            format_url = f.get('url')\n            if not format_url:\n                continue\n            # Stat URL generation algorithm is reverse engineered from\n            # download_*_bundle_*.js\n            stat_url = update_url_query(\n                format_url.replace('/download/', '/statdownload/'), {\n                    '.rand': int(time.time() * 1000 * random.random()),\n                })\n            format_id = f.get('encoding_name') or format_id\n            stat = self._download_json(\n                stat_url, video_id, 'Downloading %s JSON' % format_id,\n                transform_source=lambda s: s[s.index('{'):s.rindex('}') + 1],\n                fatal=False)\n            if not stat:\n                continue\n            retry_url = stat.get('retry_url')\n            if not isinstance(retry_url, compat_str):\n                continue\n            formats.append({\n                'url': self._proto_relative_url(retry_url, 'http:'),\n                'ext': download_formats.get(format_id),\n                'format_id': format_id,\n                'format_note': f.get('description'),\n                'filesize': parse_filesize(f.get('size_mb')),\n                'vcodec': 'none',\n            })\n        self._sort_formats(formats)\n\n        return {\n            'id': video_id,\n            'title': title,\n            'thumbnail': info.get('thumb_url') or thumbnail,\n            'uploader': info.get('artist'),\n            'artist': artist,\n            'track': track,\n            'formats': formats,\n        }\n\n\nclass BandcampAlbumIE(InfoExtractor):\n    IE_NAME = 'Bandcamp:album'\n    _VALID_URL = r'https?://(?:(?P<subdomain>[^.]+)\\.)?bandcamp\\.com(?:/album/(?P<album_id>[^/?#&]+))?'\n\n    _TESTS = [{\n        'url': 'http://blazo.bandcamp.com/album/jazz-format-mixtape-vol-1',\n        'playlist': [\n            {\n                'md5': '39bc1eded3476e927c724321ddf116cf',\n                'info_dict': {\n                    'id': '1353101989',\n                    'ext': 'mp3',\n                    'title': 'Intro',\n                }\n            },\n            {\n                'md5': '1a2c32e2691474643e912cc6cd4bffaa',\n                'info_dict': {\n                    'id': '38097443',\n                    'ext': 'mp3',\n                    'title': 'Kero One - Keep It Alive (Blazo remix)',\n                }\n            },\n        ],\n        'info_dict': {\n            'title': 'Jazz Format Mixtape vol.1',\n            'id': 'jazz-format-mixtape-vol-1',\n            'uploader_id': 'blazo',\n        },\n        'params': {\n            'playlistend': 2\n        },\n        'skip': 'Bandcamp imposes download limits.'\n    }, {\n        'url': 'http://nightbringer.bandcamp.com/album/hierophany-of-the-open-grave',\n        'info_dict': {\n            'title': 'Hierophany of the Open Grave',\n            'uploader_id': 'nightbringer',\n            'id': 'hierophany-of-the-open-grave',\n        },\n        'playlist_mincount': 9,\n    }, {\n        'url': 'http://dotscale.bandcamp.com',\n        'info_dict': {\n            'title': 'Loom',\n            'id': 'dotscale',\n            'uploader_id': 'dotscale',\n        },\n        'playlist_mincount': 7,\n    }, {\n        # with escaped quote in title\n        'url': 'https://jstrecords.bandcamp.com/album/entropy-ep',\n        'info_dict': {\n            'title': '\"Entropy\" EP',\n            'uploader_id': 'jstrecords',\n            'id': 'entropy-ep',\n        },\n        'playlist_mincount': 3,\n    }, {\n        # not all tracks have songs\n        'url': 'https://insulters.bandcamp.com/album/we-are-the-plague',\n        'info_dict': {\n            'id': 'we-are-the-plague',\n            'title': 'WE ARE THE PLAGUE',\n            'uploader_id': 'insulters',\n        },\n        'playlist_count': 2,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return (False\n                if BandcampWeeklyIE.suitable(url) or BandcampIE.suitable(url)\n                else super(BandcampAlbumIE, cls).suitable(url))\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        uploader_id = mobj.group('subdomain')\n        album_id = mobj.group('album_id')\n        playlist_id = album_id or uploader_id\n        webpage = self._download_webpage(url, playlist_id)\n        track_elements = re.findall(\n            r'(?s)<div[^>]*>(.*?<a[^>]+href=\"([^\"]+?)\"[^>]+itemprop=\"url\"[^>]*>.*?)</div>', webpage)\n        if not track_elements:\n            raise ExtractorError('The page doesn\\'t contain any tracks')\n        # Only tracks with duration info have songs\n        entries = [\n            self.url_result(\n                compat_urlparse.urljoin(url, t_path),\n                ie=BandcampIE.ie_key(),\n                video_title=self._search_regex(\n                    r'<span\\b[^>]+\\bitemprop=[\"\\']name[\"\\'][^>]*>([^<]+)',\n                    elem_content, 'track title', fatal=False))\n            for elem_content, t_path in track_elements\n            if self._html_search_meta('duration', elem_content, default=None)]\n\n        title = self._html_search_regex(\n            r'album_title\\s*:\\s*\"((?:\\\\.|[^\"\\\\])+?)\"',\n            webpage, 'title', fatal=False)\n        if title:\n            title = title.replace(r'\\\"', '\"')\n        return {\n            '_type': 'playlist',\n            'uploader_id': uploader_id,\n            'id': playlist_id,\n            'title': title,\n            'entries': entries,\n        }\n\n\nclass BandcampWeeklyIE(InfoExtractor):\n    IE_NAME = 'Bandcamp:weekly'\n    _VALID_URL = r'https?://(?:www\\.)?bandcamp\\.com/?\\?(?:.*?&)?show=(?P<id>\\d+)'\n    _TESTS = [{\n        'url': 'https://bandcamp.com/?show=224',\n        'md5': 'b00df799c733cf7e0c567ed187dea0fd',\n        'info_dict': {\n            'id': '224',\n            'ext': 'opus',\n            'title': 'BC Weekly April 4th 2017 - Magic Moments',\n            'description': 'md5:5d48150916e8e02d030623a48512c874',\n            'duration': 5829.77,\n            'release_date': '20170404',\n            'series': 'Bandcamp Weekly',\n            'episode': 'Magic Moments',\n            'episode_number': 208,\n            'episode_id': '224',\n        }\n    }, {\n        'url': 'https://bandcamp.com/?blah/blah@&show=228',\n        'only_matching': True\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        webpage = self._download_webpage(url, video_id)\n\n        blob = self._parse_json(\n            self._search_regex(\n                r'data-blob=([\"\\'])(?P<blob>{.+?})\\1', webpage,\n                'blob', group='blob'),\n            video_id, transform_source=unescapeHTML)\n\n        show = blob['bcw_show']\n\n        # This is desired because any invalid show id redirects to `bandcamp.com`\n        # which happens to expose the latest Bandcamp Weekly episode.\n        show_id = int_or_none(show.get('show_id')) or int_or_none(video_id)\n\n        formats = []\n        for format_id, format_url in show['audio_stream'].items():\n            if not isinstance(format_url, compat_str):\n                continue\n            for known_ext in KNOWN_EXTENSIONS:\n                if known_ext in format_id:\n                    ext = known_ext\n                    break\n            else:\n                ext = None\n            formats.append({\n                'format_id': format_id,\n                'url': format_url,\n                'ext': ext,\n                'vcodec': 'none',\n            })\n        self._sort_formats(formats)\n\n        title = show.get('audio_title') or 'Bandcamp Weekly'\n        subtitle = show.get('subtitle')\n        if subtitle:\n            title += ' - %s' % subtitle\n\n        episode_number = None\n        seq = blob.get('bcw_seq')\n\n        if seq and isinstance(seq, list):\n            try:\n                episode_number = next(\n                    int_or_none(e.get('episode_number'))\n                    for e in seq\n                    if isinstance(e, dict) and int_or_none(e.get('id')) == show_id)\n            except StopIteration:\n                pass\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': show.get('desc') or show.get('short_desc'),\n            'duration': float_or_none(show.get('audio_duration')),\n            'is_live': False,\n            'release_date': unified_strdate(show.get('published_date')),\n            'series': 'Bandcamp Weekly',\n            'episode': show.get('subtitle'),\n            'episode_number': episode_number,\n            'episode_id': compat_str(video_id),\n            'formats': formats\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "bandcamp.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/bandcamp.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}