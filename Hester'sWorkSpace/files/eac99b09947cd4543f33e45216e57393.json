{"author": "mailpile", "code": "\n\n This is code which tries very hard to interpret the From:, To: and Cc:\n lines found in real-world e-mail addresses and make sense of them.\n\n The general strategy of this script is to:\n    1. parse header into tokens\n    2. group tokens together into address + name constructs\n    3. normalize each group to a standard format\n\n In practice, we do this in two passes - first a strict pass where we try\n to parse things semi-sensibly.  If that fails, there is a second pass\n where we try to cope with certain types of weirdness we've seen in the\n wild. The wild can be pretty wild.\n\n This parser is NOT fully RFC2822 compliant - in particular it will get\n confused by nested comments (see FIXME in tests below).\n\nimport sys\nimport traceback\n\nfrom mailpile.mailutils import AddressHeaderParser as AHP\n\n\nahp_tests = AHP(AHP.TEST_HEADER_DATA)\nprint '_tokens: %s' % ahp_tests._tokens\nprint '_groups: %s' % ahp_tests._groups\nprint '%s' % ahp_tests\nprint 'normalized: %s' % ahp_tests.normalized()\n\n\nheaders, header, inheader = {}, None, False\nfor line in sys.stdin:\n    if inheader:\n        if line in ('\\n', '\\r\\n'):\n            for hdr in ('from', 'to', 'cc'):\n                val = headers.get(hdr, '').replace('\\n', ' ').strip()\n                if val:\n                    try:\n                        nv = AHP(val, _raise=True).normalized()\n                        if '\\\\' in nv:\n                            print 'ESCAPED: %s: %s (was %s)' % (hdr, nv, val)\n                        else:\n                            print '%s' % (nv,)\n                    except ValueError:\n                        print 'FAILED: %s: %s -- %s' % (hdr, val,\n                            traceback.format_exc().replace('\\n', '  '))\n            headers, header, inheader = {}, None, False\n        elif line[:1] in (' ', '\\t') and header:\n            headers[header] = headers[header].rstrip() + line[1:]\n        else:\n            try:\n                header, value = line.split(': ', 1)\n                header = header.lower()\n                headers[header] = headers.get(header, '') + ' ' + value\n            except ValueError:\n                headers, header, inheader = {}, None, False\n    else:\n        if line.startswith('From '):\n            inheader = True\n", "comments": "   usr bin env python2 7       this code tries hard interpret from   to  cc     lines found real world e mail addresses make sense        the general strategy script        1  parse header tokens       2  group tokens together address   name constructs       3  normalize group standard format       in practice  two passes   first strict pass try    parse things semi sensibly   if fails  second pass    try cope certain types weirdness seen    wild  the wild pretty wild        this parser not fully rfc2822 compliant   particular get    confused nested comments (see fixme tests below)     ", "content": "#!/usr/bin/env python2.7\n#\n# This is code which tries very hard to interpret the From:, To: and Cc:\n# lines found in real-world e-mail addresses and make sense of them.\n#\n# The general strategy of this script is to:\n#    1. parse header into tokens\n#    2. group tokens together into address + name constructs\n#    3. normalize each group to a standard format\n#\n# In practice, we do this in two passes - first a strict pass where we try\n# to parse things semi-sensibly.  If that fails, there is a second pass\n# where we try to cope with certain types of weirdness we've seen in the\n# wild. The wild can be pretty wild.\n#\n# This parser is NOT fully RFC2822 compliant - in particular it will get\n# confused by nested comments (see FIXME in tests below).\n#\nimport sys\nimport traceback\n\nfrom mailpile.mailutils import AddressHeaderParser as AHP\n\n\nahp_tests = AHP(AHP.TEST_HEADER_DATA)\nprint '_tokens: %s' % ahp_tests._tokens\nprint '_groups: %s' % ahp_tests._groups\nprint '%s' % ahp_tests\nprint 'normalized: %s' % ahp_tests.normalized()\n\n\nheaders, header, inheader = {}, None, False\nfor line in sys.stdin:\n    if inheader:\n        if line in ('\\n', '\\r\\n'):\n            for hdr in ('from', 'to', 'cc'):\n                val = headers.get(hdr, '').replace('\\n', ' ').strip()\n                if val:\n                    try:\n                        nv = AHP(val, _raise=True).normalized()\n                        if '\\\\' in nv:\n                            print 'ESCAPED: %s: %s (was %s)' % (hdr, nv, val)\n                        else:\n                            print '%s' % (nv,)\n                    except ValueError:\n                        print 'FAILED: %s: %s -- %s' % (hdr, val,\n                            traceback.format_exc().replace('\\n', '  '))\n            headers, header, inheader = {}, None, False\n        elif line[:1] in (' ', '\\t') and header:\n            headers[header] = headers[header].rstrip() + line[1:]\n        else:\n            try:\n                header, value = line.split(': ', 1)\n                header = header.lower()\n                headers[header] = headers.get(header, '') + ' ' + value\n            except ValueError:\n                headers, header, inheader = {}, None, False\n    else:\n        if line.startswith('From '):\n            inheader = True\n", "description": "A free & open modern, fast email client with user-friendly encryption and privacy features", "file_name": "email-parsing-test.py", "id": "eac99b09947cd4543f33e45216e57393", "language": "Python", "project_name": "Mailpile", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mailpile-Mailpile/mailpile-Mailpile-8ebc5fe/scripts/email-parsing-test.py", "save_time": "", "source": "", "update_at": "2018-03-17T23:54:52Z", "url": "https://github.com/mailpile/Mailpile", "wiki": true}