{"author": "mitmproxy", "code": "\"\"\"\nThis inline script allows conditional TLS Interception based\non a user-defined strategy.\n\nExample:\n\n    > mitmdump -s tls_passthrough.py\n\n    1. curl --proxy http://localhost:8080 https://example.com --insecure\n    // works - we'll also see the contents in mitmproxy\n\n    2. curl --proxy http://localhost:8080 https://example.com --insecure\n    // still works - we'll also see the contents in mitmproxy\n\n    3. curl --proxy http://localhost:8080 https://example.com\n    // fails with a certificate error, which we will also see in mitmproxy\n\n    4. curl --proxy http://localhost:8080 https://example.com\n    // works again, but mitmproxy does not intercept and we do *not* see the contents\n\nAuthors: Maximilian Hils, Matthew Tuusberg\n\"\"\"\nimport collections\nimport random\n\nfrom enum import Enum\n\nimport mitmproxy\nfrom mitmproxy import ctx\nfrom mitmproxy.exceptions import TlsProtocolException\nfrom mitmproxy.proxy.protocol import TlsLayer, RawTCPLayer\n\n\nclass InterceptionResult(Enum):\n    success = True\n    failure = False\n    skipped = None\n\n\nclass _TlsStrategy:\n    \"\"\"\n    Abstract base class for interception strategies.\n    \"\"\"\n\n    def __init__(self):\n        \n        self.history = collections.defaultdict(lambda: collections.deque(maxlen=200))\n\n    def should_intercept(self, server_address):\n        \"\"\"\n        Returns:\n            True, if we should attempt to intercept the connection.\n            False, if we want to employ pass-through instead.\n        \"\"\"\n        raise NotImplementedError()\n\n    def record_success(self, server_address):\n        self.history[server_address].append(InterceptionResult.success)\n\n    def record_failure(self, server_address):\n        self.history[server_address].append(InterceptionResult.failure)\n\n    def record_skipped(self, server_address):\n        self.history[server_address].append(InterceptionResult.skipped)\n\n\nclass ConservativeStrategy(_TlsStrategy):\n    \"\"\"\n    Conservative Interception Strategy - only intercept if there haven't been any failed attempts\n    in the history.\n    \"\"\"\n\n    def should_intercept(self, server_address):\n        if InterceptionResult.failure in self.history[server_address]:\n            return False\n        return True\n\n\nclass ProbabilisticStrategy(_TlsStrategy):\n    \"\"\"\n    Fixed probability that we intercept a given connection.\n    \"\"\"\n\n    def __init__(self, p):\n        self.p = p\n        super(ProbabilisticStrategy, self).__init__()\n\n    def should_intercept(self, server_address):\n        return random.uniform(0, 1) < self.p\n\n\nclass TlsFeedback(TlsLayer):\n    \"\"\"\n    Monkey-patch _establish_tls_with_client to get feedback if TLS could be established\n    successfully on the client connection (which may fail due to cert pinning).\n    \"\"\"\n\n    def _establish_tls_with_client(self):\n        server_address = self.server_conn.address\n\n        try:\n            super(TlsFeedback, self)._establish_tls_with_client()\n        except TlsProtocolException as e:\n            tls_strategy.record_failure(server_address)\n            raise e\n        else:\n            tls_strategy.record_success(server_address)\n\n\n\n\ntls_strategy = None\n\n\ndef load(l):\n    l.add_option(\n        \"tlsstrat\", int, 0, \"TLS passthrough strategy (0-100)\",\n    )\n\n\ndef configure(updated):\n    global tls_strategy\n    if ctx.options.tlsstrat > 0:\n        tls_strategy = ProbabilisticStrategy(float(ctx.options.tlsstrat) / 100.0)\n    else:\n        tls_strategy = ConservativeStrategy()\n\n\ndef next_layer(next_layer):\n    \"\"\"\n    This hook does the actual magic - if the next layer is planned to be a TLS layer,\n    we check if we want to enter pass-through mode instead.\n    \"\"\"\n    if isinstance(next_layer, TlsLayer) and next_layer._client_tls:\n        server_address = next_layer.server_conn.address\n\n        if tls_strategy.should_intercept(server_address):\n            \n            \n            next_layer.__class__ = TlsFeedback\n        else:\n            \n            mitmproxy.ctx.log(\"TLS passthrough for %s\" % repr(next_layer.server_conn.address), \"info\")\n            next_layer_replacement = RawTCPLayer(next_layer.ctx, ignore=True)\n            next_layer.reply.send(next_layer_replacement)\n            tls_strategy.record_skipped(server_address)\n", "comments": "    this inline script allows conditional tls interception based user defined strategy   example         mitmdump  tls passthrough py      1  curl   proxy http   localhost 8080 https   example com   insecure        works   also see contents mitmproxy      2  curl   proxy http   localhost 8080 https   example com   insecure        still works   also see contents mitmproxy      3  curl   proxy http   localhost 8080 https   example com        fails certificate error  also see mitmproxy      4  curl   proxy http   localhost 8080 https   example com        works  mitmproxy intercept   see contents  authors  maximilian hils  matthew tuusberg     import collections import random  enum import enum  import mitmproxy mitmproxy import ctx mitmproxy exceptions import tlsprotocolexception mitmproxy proxy protocol import tlslayer  rawtcplayer   class interceptionresult(enum)      success   true     failure   false     skipped   none   class  tlsstrategy              abstract base class interception strategies               def   init  (self)            a server address    interception results mapping         self history   collections defaultdict(lambda  collections deque(maxlen 200))      def intercept(self  server address)                      returns              true  attempt intercept connection              false  want employ pass instead                      raise notimplementederror()      def record success(self  server address)          self history server address  append(interceptionresult success)      def record failure(self  server address)          self history server address  append(interceptionresult failure)      def record skipped(self  server address)          self history server address  append(interceptionresult skipped)   class conservativestrategy( tlsstrategy)              conservative interception strategy   intercept failed attempts     history               def intercept(self  server address)          interceptionresult failure self history server address               return false         return true   class probabilisticstrategy( tlsstrategy)              fixed probability intercept given connection               def   init  (self  p)          self p   p         super(probabilisticstrategy  self)   init  ()      def intercept(self  server address)          return random uniform(0  1)   self p   class tlsfeedback(tlslayer)              monkey patch  establish tls client get feedback tls could established     successfully client connection (which may fail due cert pinning)               def  establish tls client(self)          server address   self server conn address          try              super(tlsfeedback  self)  establish tls client()         except tlsprotocolexception e              tls strategy record failure(server address)             raise e         else              tls strategy record success(server address)     inline script hooks   tls strategy   none   def load(l)      l add option(          tlsstrat   int  0   tls passthrough strategy (0 100)       )   def configure(updated)      global tls strategy     ctx options tlsstrat   0          tls strategy   probabilisticstrategy(float(ctx options tlsstrat)   100 0)     else          tls strategy   conservativestrategy()   def next layer(next layer)              this hook actual magic   next layer planned tls layer      check want enter pass mode instead             a server address    interception results mapping    inline script hooks     we try intercept     monkey patch layer get feedback tlslayer interception worked     we intercept   reply pass layer add  skipped  entry  ", "content": "\"\"\"\nThis inline script allows conditional TLS Interception based\non a user-defined strategy.\n\nExample:\n\n    > mitmdump -s tls_passthrough.py\n\n    1. curl --proxy http://localhost:8080 https://example.com --insecure\n    // works - we'll also see the contents in mitmproxy\n\n    2. curl --proxy http://localhost:8080 https://example.com --insecure\n    // still works - we'll also see the contents in mitmproxy\n\n    3. curl --proxy http://localhost:8080 https://example.com\n    // fails with a certificate error, which we will also see in mitmproxy\n\n    4. curl --proxy http://localhost:8080 https://example.com\n    // works again, but mitmproxy does not intercept and we do *not* see the contents\n\nAuthors: Maximilian Hils, Matthew Tuusberg\n\"\"\"\nimport collections\nimport random\n\nfrom enum import Enum\n\nimport mitmproxy\nfrom mitmproxy import ctx\nfrom mitmproxy.exceptions import TlsProtocolException\nfrom mitmproxy.proxy.protocol import TlsLayer, RawTCPLayer\n\n\nclass InterceptionResult(Enum):\n    success = True\n    failure = False\n    skipped = None\n\n\nclass _TlsStrategy:\n    \"\"\"\n    Abstract base class for interception strategies.\n    \"\"\"\n\n    def __init__(self):\n        # A server_address -> interception results mapping\n        self.history = collections.defaultdict(lambda: collections.deque(maxlen=200))\n\n    def should_intercept(self, server_address):\n        \"\"\"\n        Returns:\n            True, if we should attempt to intercept the connection.\n            False, if we want to employ pass-through instead.\n        \"\"\"\n        raise NotImplementedError()\n\n    def record_success(self, server_address):\n        self.history[server_address].append(InterceptionResult.success)\n\n    def record_failure(self, server_address):\n        self.history[server_address].append(InterceptionResult.failure)\n\n    def record_skipped(self, server_address):\n        self.history[server_address].append(InterceptionResult.skipped)\n\n\nclass ConservativeStrategy(_TlsStrategy):\n    \"\"\"\n    Conservative Interception Strategy - only intercept if there haven't been any failed attempts\n    in the history.\n    \"\"\"\n\n    def should_intercept(self, server_address):\n        if InterceptionResult.failure in self.history[server_address]:\n            return False\n        return True\n\n\nclass ProbabilisticStrategy(_TlsStrategy):\n    \"\"\"\n    Fixed probability that we intercept a given connection.\n    \"\"\"\n\n    def __init__(self, p):\n        self.p = p\n        super(ProbabilisticStrategy, self).__init__()\n\n    def should_intercept(self, server_address):\n        return random.uniform(0, 1) < self.p\n\n\nclass TlsFeedback(TlsLayer):\n    \"\"\"\n    Monkey-patch _establish_tls_with_client to get feedback if TLS could be established\n    successfully on the client connection (which may fail due to cert pinning).\n    \"\"\"\n\n    def _establish_tls_with_client(self):\n        server_address = self.server_conn.address\n\n        try:\n            super(TlsFeedback, self)._establish_tls_with_client()\n        except TlsProtocolException as e:\n            tls_strategy.record_failure(server_address)\n            raise e\n        else:\n            tls_strategy.record_success(server_address)\n\n\n# inline script hooks below.\n\ntls_strategy = None\n\n\ndef load(l):\n    l.add_option(\n        \"tlsstrat\", int, 0, \"TLS passthrough strategy (0-100)\",\n    )\n\n\ndef configure(updated):\n    global tls_strategy\n    if ctx.options.tlsstrat > 0:\n        tls_strategy = ProbabilisticStrategy(float(ctx.options.tlsstrat) / 100.0)\n    else:\n        tls_strategy = ConservativeStrategy()\n\n\ndef next_layer(next_layer):\n    \"\"\"\n    This hook does the actual magic - if the next layer is planned to be a TLS layer,\n    we check if we want to enter pass-through mode instead.\n    \"\"\"\n    if isinstance(next_layer, TlsLayer) and next_layer._client_tls:\n        server_address = next_layer.server_conn.address\n\n        if tls_strategy.should_intercept(server_address):\n            # We try to intercept.\n            # Monkey-Patch the layer to get feedback from the TLSLayer if interception worked.\n            next_layer.__class__ = TlsFeedback\n        else:\n            # We don't intercept - reply with a pass-through layer and add a \"skipped\" entry.\n            mitmproxy.ctx.log(\"TLS passthrough for %s\" % repr(next_layer.server_conn.address), \"info\")\n            next_layer_replacement = RawTCPLayer(next_layer.ctx, ignore=True)\n            next_layer.reply.send(next_layer_replacement)\n            tls_strategy.record_skipped(server_address)\n", "description": "An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers.", "file_name": "tls_passthrough.py", "id": "5df516454fb3e5ef11bfa2c96500ab1a", "language": "Python", "project_name": "mitmproxy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mitmproxy-mitmproxy/mitmproxy-mitmproxy-3c7725a/examples/complex/tls_passthrough.py", "save_time": "", "source": "", "update_at": "2018-03-18T11:30:56Z", "url": "https://github.com/mitmproxy/mitmproxy", "wiki": false}