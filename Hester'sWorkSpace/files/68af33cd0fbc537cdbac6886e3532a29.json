{"author": "django", "code": "from unittest import mock, skipUnless\n\nfrom django.db import connection\nfrom django.db.models import Index\nfrom django.db.utils import DatabaseError\nfrom django.test import TransactionTestCase, skipUnlessDBFeature\n\nfrom .models import Article, ArticleReporter, City, District, Reporter\n\n\nclass IntrospectionTests(TransactionTestCase):\n\n    available_apps = ['introspection']\n\n    def test_table_names(self):\n        tl = connection.introspection.table_names()\n        self.assertEqual(tl, sorted(tl))\n        self.assertIn(Reporter._meta.db_table, tl, \"'%s' isn't in table_list().\" % Reporter._meta.db_table)\n        self.assertIn(Article._meta.db_table, tl, \"'%s' isn't in table_list().\" % Article._meta.db_table)\n\n    def test_django_table_names(self):\n        with connection.cursor() as cursor:\n            cursor.execute('CREATE TABLE django_ixn_test_table (id INTEGER);')\n            tl = connection.introspection.django_table_names()\n            cursor.execute(\"DROP TABLE django_ixn_test_table;\")\n            self.assertNotIn('django_ixn_test_table', tl,\n                             \"django_table_names() returned a non-Django table\")\n\n    def test_django_table_names_retval_type(self):\n        \n        tl = connection.introspection.django_table_names(only_existing=True)\n        self.assertIs(type(tl), list)\n        tl = connection.introspection.django_table_names(only_existing=False)\n        self.assertIs(type(tl), list)\n\n    def test_table_names_with_views(self):\n        with connection.cursor() as cursor:\n            try:\n                cursor.execute(\n                    'CREATE VIEW introspection_article_view AS SELECT headline '\n                    'from introspection_article;')\n            except DatabaseError as e:\n                if 'insufficient privileges' in str(e):\n                    self.fail(\"The test user has no CREATE VIEW privileges\")\n                else:\n                    raise\n        try:\n            self.assertIn('introspection_article_view', connection.introspection.table_names(include_views=True))\n            self.assertNotIn('introspection_article_view', connection.introspection.table_names())\n        finally:\n            with connection.cursor() as cursor:\n                cursor.execute('DROP VIEW introspection_article_view')\n\n    def test_unmanaged_through_model(self):\n        tables = connection.introspection.django_table_names()\n        self.assertNotIn(ArticleReporter._meta.db_table, tables)\n\n    def test_installed_models(self):\n        tables = [Article._meta.db_table, Reporter._meta.db_table]\n        models = connection.introspection.installed_models(tables)\n        self.assertEqual(models, {Article, Reporter})\n\n    def test_sequence_list(self):\n        sequences = connection.introspection.sequence_list()\n        reporter_seqs = [seq for seq in sequences if seq['table'] == Reporter._meta.db_table]\n        self.assertEqual(len(reporter_seqs), 1, 'Reporter sequence not found in sequence_list()')\n        self.assertEqual(reporter_seqs[0]['column'], 'id')\n\n    def test_get_table_description_names(self):\n        with connection.cursor() as cursor:\n            desc = connection.introspection.get_table_description(cursor, Reporter._meta.db_table)\n        self.assertEqual([r[0] for r in desc],\n                         [f.column for f in Reporter._meta.fields])\n\n    def test_get_table_description_types(self):\n        with connection.cursor() as cursor:\n            desc = connection.introspection.get_table_description(cursor, Reporter._meta.db_table)\n        self.assertEqual(\n            [datatype(r[1], r) for r in desc],\n            ['AutoField' if connection.features.can_introspect_autofield else 'IntegerField',\n             'CharField', 'CharField', 'CharField',\n             'BigIntegerField' if connection.features.can_introspect_big_integer_field else 'IntegerField',\n             'BinaryField' if connection.features.can_introspect_binary_field else 'TextField',\n             'SmallIntegerField' if connection.features.can_introspect_small_integer_field else 'IntegerField']\n        )\n\n    def test_get_table_description_col_lengths(self):\n        with connection.cursor() as cursor:\n            desc = connection.introspection.get_table_description(cursor, Reporter._meta.db_table)\n        self.assertEqual(\n            [r[3] for r in desc if datatype(r[1], r) == 'CharField'],\n            [30, 30, 254]\n        )\n\n    @skipUnlessDBFeature('can_introspect_null')\n    def test_get_table_description_nullable(self):\n        with connection.cursor() as cursor:\n            desc = connection.introspection.get_table_description(cursor, Reporter._meta.db_table)\n        nullable_by_backend = connection.features.interprets_empty_strings_as_nulls\n        self.assertEqual(\n            [r[6] for r in desc],\n            [False, nullable_by_backend, nullable_by_backend, nullable_by_backend, True, True, False]\n        )\n\n    @skipUnlessDBFeature('can_introspect_autofield')\n    def test_bigautofield(self):\n        with connection.cursor() as cursor:\n            desc = connection.introspection.get_table_description(cursor, City._meta.db_table)\n        self.assertIn('BigAutoField', [datatype(r[1], r) for r in desc])\n\n    \n    @skipUnlessDBFeature('has_real_datatype')\n    def test_postgresql_real_type(self):\n        with connection.cursor() as cursor:\n            cursor.execute(\"CREATE TABLE django_ixn_real_test_table (number REAL);\")\n            desc = connection.introspection.get_table_description(cursor, 'django_ixn_real_test_table')\n            cursor.execute('DROP TABLE django_ixn_real_test_table;')\n        self.assertEqual(datatype(desc[0][1], desc[0]), 'FloatField')\n\n    @skipUnlessDBFeature('can_introspect_foreign_keys')\n    def test_get_relations(self):\n        with connection.cursor() as cursor:\n            relations = connection.introspection.get_relations(cursor, Article._meta.db_table)\n\n        # That's {field_name: (field_name_other_table, other_table)}\n        expected_relations = {\n            'reporter_id': ('id', Reporter._meta.db_table),\n            'response_to_id': ('id', Article._meta.db_table),\n        }\n        self.assertEqual(relations, expected_relations)\n\n        # Removing a field shouldn't disturb get_relations (#17785)\n        body = Article._meta.get_field('body')\n        with connection.schema_editor() as editor:\n            editor.remove_field(Article, body)\n        with connection.cursor() as cursor:\n            relations = connection.introspection.get_relations(cursor, Article._meta.db_table)\n        with connection.schema_editor() as editor:\n            editor.add_field(Article, body)\n        self.assertEqual(relations, expected_relations)\n\n    @skipUnless(connection.vendor == 'sqlite', \"This is an sqlite-specific issue\")\n    def test_get_relations_alt_format(self):\n        \"\"\"\n        With SQLite, foreign keys can be added with different syntaxes and\n        formatting.\n        \"\"\"\n        create_table_statements = [\n            \"CREATE TABLE track(id, art_id INTEGER, FOREIGN KEY(art_id) REFERENCES {}(id));\",\n            \"CREATE TABLE track(id, art_id INTEGER, FOREIGN KEY (art_id) REFERENCES {}(id));\"\n        ]\n        for statement in create_table_statements:\n            with connection.cursor() as cursor:\n                cursor.fetchone = mock.Mock(return_value=[statement.format(Article._meta.db_table), 'table'])\n                relations = connection.introspection.get_relations(cursor, 'mocked_table')\n            self.assertEqual(relations, {'art_id': ('id', Article._meta.db_table)})\n\n    @skipUnlessDBFeature('can_introspect_foreign_keys')\n    def test_get_key_columns(self):\n        with connection.cursor() as cursor:\n            key_columns = connection.introspection.get_key_columns(cursor, Article._meta.db_table)\n        self.assertEqual(\n            set(key_columns),\n            {('reporter_id', Reporter._meta.db_table, 'id'),\n             ('response_to_id', Article._meta.db_table, 'id')})\n\n    def test_get_primary_key_column(self):\n        with connection.cursor() as cursor:\n            primary_key_column = connection.introspection.get_primary_key_column(cursor, Article._meta.db_table)\n            pk_fk_column = connection.introspection.get_primary_key_column(cursor, District._meta.db_table)\n        self.assertEqual(primary_key_column, 'id')\n        self.assertEqual(pk_fk_column, 'city_id')\n\n    def test_get_constraints_index_types(self):\n        with connection.cursor() as cursor:\n            constraints = connection.introspection.get_constraints(cursor, Article._meta.db_table)\n        index = {}\n        index2 = {}\n        for val in constraints.values():\n            if val['columns'] == ['headline', 'pub_date']:\n                index = val\n            if val['columns'] == ['headline', 'response_to_id', 'pub_date', 'reporter_id']:\n                index2 = val\n        self.assertEqual(index['type'], Index.suffix)\n        self.assertEqual(index2['type'], Index.suffix)\n\n    @skipUnlessDBFeature('supports_index_column_ordering')\n    def test_get_constraints_indexes_orders(self):\n        \"\"\"\n        Indexes have the 'orders' key with a list of 'ASC'/'DESC' values.\n        \"\"\"\n        with connection.cursor() as cursor:\n            constraints = connection.introspection.get_constraints(cursor, Article._meta.db_table)\n        indexes_verified = 0\n        expected_columns = [\n            ['reporter_id'],\n            ['headline', 'pub_date'],\n            ['response_to_id'],\n            ['headline', 'response_to_id', 'pub_date', 'reporter_id'],\n        ]\n        for val in constraints.values():\n            if val['index'] and not (val['primary_key'] or val['unique']):\n                self.assertIn(val['columns'], expected_columns)\n                self.assertEqual(val['orders'], ['ASC'] * len(val['columns']))\n                indexes_verified += 1\n        self.assertEqual(indexes_verified, 4)\n\n\ndef datatype(dbtype, description):\n    \"\"\"Helper to convert a data type into a string.\"\"\"\n    dt = connection.introspection.get_field_type(dbtype, description)\n    if type(dt) is tuple:\n        return dt[0]\n    else:\n        return dt\n", "comments": "            with sqlite  foreign keys added different syntaxes         formatting                      create table statements                  create table track(id  art id integer  foreign key(art id) references   (id))                 create table track(id  art id integer  foreign key (art id) references   (id))                     statement create table statements              connection cursor() cursor                  cursor fetchone   mock mock(return value  statement format(article  meta db table)   table  )                 relations   connection introspection get relations(cursor   mocked table )             self assertequal(relations    art id   ( id   article  meta db table) )       skipunlessdbfeature( introspect foreign keys )     def test get key columns(self)          connection cursor() cursor              key columns   connection introspection get key columns(cursor  article  meta db table)         self assertequal(             set(key columns)               ( reporter id   reporter  meta db table   id )               ( response id   article  meta db table   id ) )      def test get primary key column(self)          connection cursor() cursor              primary key column   connection introspection get primary key column(cursor  article  meta db table)             pk fk column   connection introspection get primary key column(cursor  district  meta db table)         self assertequal(primary key column   id )         self assertequal(pk fk column   city id )      def test get constraints index types(self)          connection cursor() cursor              constraints   connection introspection get constraints(cursor  article  meta db table)         index              index2              val constraints values()              val  columns        headline    pub date                    index   val             val  columns        headline    response id    pub date    reporter id                    index2   val         self assertequal(index  type    index suffix)         self assertequal(index2  type    index suffix)       skipunlessdbfeature( supports index column ordering )     def test get constraints indexes orders(self)                      indexes  orders  key list  asc   desc  values                      connection cursor() cursor              constraints   connection introspection get constraints(cursor  article  meta db table)         indexes verified   0         expected columns                   reporter id                  headline    pub date                  response id                  headline    response id    pub date    reporter id                      val constraints values()              val  index   (val  primary key   val  unique  )                  self assertin(val  columns    expected columns)                 self assertequal(val  orders      asc     len(val  columns  ))                 indexes verified    1         self assertequal(indexes verified  4)   def datatype(dbtype  description)         helper convert data type string        table name list  15216    regression test  9991    real  types postgres    that  field name  (field name table  table)     removing field disturb get relations ( 17785) ", "content": "from unittest import mock, skipUnless\n\nfrom django.db import connection\nfrom django.db.models import Index\nfrom django.db.utils import DatabaseError\nfrom django.test import TransactionTestCase, skipUnlessDBFeature\n\nfrom .models import Article, ArticleReporter, City, District, Reporter\n\n\nclass IntrospectionTests(TransactionTestCase):\n\n    available_apps = ['introspection']\n\n    def test_table_names(self):\n        tl = connection.introspection.table_names()\n        self.assertEqual(tl, sorted(tl))\n        self.assertIn(Reporter._meta.db_table, tl, \"'%s' isn't in table_list().\" % Reporter._meta.db_table)\n        self.assertIn(Article._meta.db_table, tl, \"'%s' isn't in table_list().\" % Article._meta.db_table)\n\n    def test_django_table_names(self):\n        with connection.cursor() as cursor:\n            cursor.execute('CREATE TABLE django_ixn_test_table (id INTEGER);')\n            tl = connection.introspection.django_table_names()\n            cursor.execute(\"DROP TABLE django_ixn_test_table;\")\n            self.assertNotIn('django_ixn_test_table', tl,\n                             \"django_table_names() returned a non-Django table\")\n\n    def test_django_table_names_retval_type(self):\n        # Table name is a list #15216\n        tl = connection.introspection.django_table_names(only_existing=True)\n        self.assertIs(type(tl), list)\n        tl = connection.introspection.django_table_names(only_existing=False)\n        self.assertIs(type(tl), list)\n\n    def test_table_names_with_views(self):\n        with connection.cursor() as cursor:\n            try:\n                cursor.execute(\n                    'CREATE VIEW introspection_article_view AS SELECT headline '\n                    'from introspection_article;')\n            except DatabaseError as e:\n                if 'insufficient privileges' in str(e):\n                    self.fail(\"The test user has no CREATE VIEW privileges\")\n                else:\n                    raise\n        try:\n            self.assertIn('introspection_article_view', connection.introspection.table_names(include_views=True))\n            self.assertNotIn('introspection_article_view', connection.introspection.table_names())\n        finally:\n            with connection.cursor() as cursor:\n                cursor.execute('DROP VIEW introspection_article_view')\n\n    def test_unmanaged_through_model(self):\n        tables = connection.introspection.django_table_names()\n        self.assertNotIn(ArticleReporter._meta.db_table, tables)\n\n    def test_installed_models(self):\n        tables = [Article._meta.db_table, Reporter._meta.db_table]\n        models = connection.introspection.installed_models(tables)\n        self.assertEqual(models, {Article, Reporter})\n\n    def test_sequence_list(self):\n        sequences = connection.introspection.sequence_list()\n        reporter_seqs = [seq for seq in sequences if seq['table'] == Reporter._meta.db_table]\n        self.assertEqual(len(reporter_seqs), 1, 'Reporter sequence not found in sequence_list()')\n        self.assertEqual(reporter_seqs[0]['column'], 'id')\n\n    def test_get_table_description_names(self):\n        with connection.cursor() as cursor:\n            desc = connection.introspection.get_table_description(cursor, Reporter._meta.db_table)\n        self.assertEqual([r[0] for r in desc],\n                         [f.column for f in Reporter._meta.fields])\n\n    def test_get_table_description_types(self):\n        with connection.cursor() as cursor:\n            desc = connection.introspection.get_table_description(cursor, Reporter._meta.db_table)\n        self.assertEqual(\n            [datatype(r[1], r) for r in desc],\n            ['AutoField' if connection.features.can_introspect_autofield else 'IntegerField',\n             'CharField', 'CharField', 'CharField',\n             'BigIntegerField' if connection.features.can_introspect_big_integer_field else 'IntegerField',\n             'BinaryField' if connection.features.can_introspect_binary_field else 'TextField',\n             'SmallIntegerField' if connection.features.can_introspect_small_integer_field else 'IntegerField']\n        )\n\n    def test_get_table_description_col_lengths(self):\n        with connection.cursor() as cursor:\n            desc = connection.introspection.get_table_description(cursor, Reporter._meta.db_table)\n        self.assertEqual(\n            [r[3] for r in desc if datatype(r[1], r) == 'CharField'],\n            [30, 30, 254]\n        )\n\n    @skipUnlessDBFeature('can_introspect_null')\n    def test_get_table_description_nullable(self):\n        with connection.cursor() as cursor:\n            desc = connection.introspection.get_table_description(cursor, Reporter._meta.db_table)\n        nullable_by_backend = connection.features.interprets_empty_strings_as_nulls\n        self.assertEqual(\n            [r[6] for r in desc],\n            [False, nullable_by_backend, nullable_by_backend, nullable_by_backend, True, True, False]\n        )\n\n    @skipUnlessDBFeature('can_introspect_autofield')\n    def test_bigautofield(self):\n        with connection.cursor() as cursor:\n            desc = connection.introspection.get_table_description(cursor, City._meta.db_table)\n        self.assertIn('BigAutoField', [datatype(r[1], r) for r in desc])\n\n    # Regression test for #9991 - 'real' types in postgres\n    @skipUnlessDBFeature('has_real_datatype')\n    def test_postgresql_real_type(self):\n        with connection.cursor() as cursor:\n            cursor.execute(\"CREATE TABLE django_ixn_real_test_table (number REAL);\")\n            desc = connection.introspection.get_table_description(cursor, 'django_ixn_real_test_table')\n            cursor.execute('DROP TABLE django_ixn_real_test_table;')\n        self.assertEqual(datatype(desc[0][1], desc[0]), 'FloatField')\n\n    @skipUnlessDBFeature('can_introspect_foreign_keys')\n    def test_get_relations(self):\n        with connection.cursor() as cursor:\n            relations = connection.introspection.get_relations(cursor, Article._meta.db_table)\n\n        # That's {field_name: (field_name_other_table, other_table)}\n        expected_relations = {\n            'reporter_id': ('id', Reporter._meta.db_table),\n            'response_to_id': ('id', Article._meta.db_table),\n        }\n        self.assertEqual(relations, expected_relations)\n\n        # Removing a field shouldn't disturb get_relations (#17785)\n        body = Article._meta.get_field('body')\n        with connection.schema_editor() as editor:\n            editor.remove_field(Article, body)\n        with connection.cursor() as cursor:\n            relations = connection.introspection.get_relations(cursor, Article._meta.db_table)\n        with connection.schema_editor() as editor:\n            editor.add_field(Article, body)\n        self.assertEqual(relations, expected_relations)\n\n    @skipUnless(connection.vendor == 'sqlite', \"This is an sqlite-specific issue\")\n    def test_get_relations_alt_format(self):\n        \"\"\"\n        With SQLite, foreign keys can be added with different syntaxes and\n        formatting.\n        \"\"\"\n        create_table_statements = [\n            \"CREATE TABLE track(id, art_id INTEGER, FOREIGN KEY(art_id) REFERENCES {}(id));\",\n            \"CREATE TABLE track(id, art_id INTEGER, FOREIGN KEY (art_id) REFERENCES {}(id));\"\n        ]\n        for statement in create_table_statements:\n            with connection.cursor() as cursor:\n                cursor.fetchone = mock.Mock(return_value=[statement.format(Article._meta.db_table), 'table'])\n                relations = connection.introspection.get_relations(cursor, 'mocked_table')\n            self.assertEqual(relations, {'art_id': ('id', Article._meta.db_table)})\n\n    @skipUnlessDBFeature('can_introspect_foreign_keys')\n    def test_get_key_columns(self):\n        with connection.cursor() as cursor:\n            key_columns = connection.introspection.get_key_columns(cursor, Article._meta.db_table)\n        self.assertEqual(\n            set(key_columns),\n            {('reporter_id', Reporter._meta.db_table, 'id'),\n             ('response_to_id', Article._meta.db_table, 'id')})\n\n    def test_get_primary_key_column(self):\n        with connection.cursor() as cursor:\n            primary_key_column = connection.introspection.get_primary_key_column(cursor, Article._meta.db_table)\n            pk_fk_column = connection.introspection.get_primary_key_column(cursor, District._meta.db_table)\n        self.assertEqual(primary_key_column, 'id')\n        self.assertEqual(pk_fk_column, 'city_id')\n\n    def test_get_constraints_index_types(self):\n        with connection.cursor() as cursor:\n            constraints = connection.introspection.get_constraints(cursor, Article._meta.db_table)\n        index = {}\n        index2 = {}\n        for val in constraints.values():\n            if val['columns'] == ['headline', 'pub_date']:\n                index = val\n            if val['columns'] == ['headline', 'response_to_id', 'pub_date', 'reporter_id']:\n                index2 = val\n        self.assertEqual(index['type'], Index.suffix)\n        self.assertEqual(index2['type'], Index.suffix)\n\n    @skipUnlessDBFeature('supports_index_column_ordering')\n    def test_get_constraints_indexes_orders(self):\n        \"\"\"\n        Indexes have the 'orders' key with a list of 'ASC'/'DESC' values.\n        \"\"\"\n        with connection.cursor() as cursor:\n            constraints = connection.introspection.get_constraints(cursor, Article._meta.db_table)\n        indexes_verified = 0\n        expected_columns = [\n            ['reporter_id'],\n            ['headline', 'pub_date'],\n            ['response_to_id'],\n            ['headline', 'response_to_id', 'pub_date', 'reporter_id'],\n        ]\n        for val in constraints.values():\n            if val['index'] and not (val['primary_key'] or val['unique']):\n                self.assertIn(val['columns'], expected_columns)\n                self.assertEqual(val['orders'], ['ASC'] * len(val['columns']))\n                indexes_verified += 1\n        self.assertEqual(indexes_verified, 4)\n\n\ndef datatype(dbtype, description):\n    \"\"\"Helper to convert a data type into a string.\"\"\"\n    dt = connection.introspection.get_field_type(dbtype, description)\n    if type(dt) is tuple:\n        return dt[0]\n    else:\n        return dt\n", "description": "The Web framework for perfectionists with deadlines.", "file_name": "tests.py", "id": "68af33cd0fbc537cdbac6886e3532a29", "language": "Python", "project_name": "django", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/django-django/django-django-acfc650/tests/introspection/tests.py", "save_time": "", "source": "", "update_at": "2018-03-14T02:00:36Z", "url": "https://github.com/django/django", "wiki": false}