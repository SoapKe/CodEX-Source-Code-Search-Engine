{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .adobepass import AdobePassIE\nfrom ..utils import (\n    int_or_none,\n    determine_ext,\n    parse_age_limit,\n    urlencode_postdata,\n    ExtractorError,\n)\n\n\nclass GoIE(AdobePassIE):\n    _SITE_INFO = {\n        'abc': {\n            'brand': '001',\n            'requestor_id': 'ABC',\n        },\n        'freeform': {\n            'brand': '002',\n            'requestor_id': 'ABCFamily',\n        },\n        'watchdisneychannel': {\n            'brand': '004',\n            'requestor_id': 'Disney',\n        },\n        'watchdisneyjunior': {\n            'brand': '008',\n            'requestor_id': 'DisneyJunior',\n        },\n        'watchdisneyxd': {\n            'brand': '009',\n            'requestor_id': 'DisneyXD',\n        }\n    }\n    _VALID_URL = r'https?://(?:(?P<sub_domain>%s)\\.)?go\\.com/(?:(?:[^/]+/)*(?P<id>vdka\\w+)|(?:[^/]+/)*(?P<display_id>[^/?\n    _TESTS = [{\n        'url': 'http://abc.go.com/shows/designated-survivor/video/most-recent/VDKA3807643',\n        'info_dict': {\n            'id': 'VDKA3807643',\n            'ext': 'mp4',\n            'title': 'The Traitor in the White House',\n            'description': 'md5:05b009d2d145a1e85d25111bd37222e8',\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }, {\n        'url': 'http://watchdisneyxd.go.com/doraemon',\n        'info_dict': {\n            'title': 'Doraemon',\n            'id': 'SH55574025',\n        },\n        'playlist_mincount': 51,\n    }, {\n        'url': 'http://abc.go.com/shows/the-catch/episode-guide/season-01/10-the-wedding',\n        'only_matching': True,\n    }, {\n        'url': 'http://abc.go.com/shows/world-news-tonight/episode-guide/2017-02/17-021717-intense-stand-off-between-man-with-rifle-and-police-in-oakland',\n        'only_matching': True,\n    }]\n\n    def _extract_videos(self, brand, video_id='-1', show_id='-1'):\n        display_id = video_id if video_id != '-1' else show_id\n        return self._download_json(\n            'http://api.contents.watchabc.go.com/vp2/ws/contents/3000/videos/%s/001/-1/%s/-1/%s/-1/-1.json' % (brand, show_id, video_id),\n            display_id)['video']\n\n    def _real_extract(self, url):\n        sub_domain, video_id, display_id = re.match(self._VALID_URL, url).groups()\n        site_info = self._SITE_INFO[sub_domain]\n        brand = site_info['brand']\n        if not video_id:\n            webpage = self._download_webpage(url, display_id)\n            video_id = self._search_regex(\n                \n                \n                r'data-video-id=[\"\\']*(VDKA\\w+)', webpage, 'video id', default=None)\n            if not video_id:\n                \n                \n                show_id = self._search_regex(r'data-show-id=[\"\\']*(SH\\d+)', webpage, 'show id')\n                videos = self._extract_videos(brand, show_id=show_id)\n                show_title = self._search_regex(r'data-show-title=\"([^\"]+)\"', webpage, 'show title', fatal=False)\n                entries = []\n                for video in videos:\n                    entries.append(self.url_result(\n                        video['url'], 'Go', video.get('id'), video.get('title')))\n                entries.reverse()\n                return self.playlist_result(entries, show_id, show_title)\n        video_data = self._extract_videos(brand, video_id)[0]\n        video_id = video_data['id']\n        title = video_data['title']\n\n        formats = []\n        for asset in video_data.get('assets', {}).get('asset', []):\n            asset_url = asset.get('value')\n            if not asset_url:\n                continue\n            format_id = asset.get('format')\n            ext = determine_ext(asset_url)\n            if ext == 'm3u8':\n                video_type = video_data.get('type')\n                data = {\n                    'video_id': video_data['id'],\n                    'video_type': video_type,\n                    'brand': brand,\n                    'device': '001',\n                }\n                if video_data.get('accesslevel') == '1':\n                    requestor_id = site_info['requestor_id']\n                    resource = self._get_mvpd_resource(\n                        requestor_id, title, video_id, None)\n                    auth = self._extract_mvpd_auth(\n                        url, video_id, requestor_id, resource)\n                    data.update({\n                        'token': auth,\n                        'token_type': 'ap',\n                        'adobe_requestor_id': requestor_id,\n                    })\n                else:\n                    self._initialize_geo_bypass(['US'])\n                entitlement = self._download_json(\n                    'https://api.entitlement.watchabc.go.com/vp2/ws-secure/entitlement/2020/authorize.json',\n                    video_id, data=urlencode_postdata(data))\n                errors = entitlement.get('errors', {}).get('errors', [])\n                if errors:\n                    for error in errors:\n                        if error.get('code') == 1002:\n                            self.raise_geo_restricted(\n                                error['message'], countries=['US'])\n                    error_message = ', '.join([error['message'] for error in errors])\n                    raise ExtractorError('%s said: %s' % (self.IE_NAME, error_message), expected=True)\n                asset_url += '?' + entitlement['uplynkData']['sessionKey']\n                formats.extend(self._extract_m3u8_formats(\n                    asset_url, video_id, 'mp4', m3u8_id=format_id or 'hls', fatal=False))\n            else:\n                f = {\n                    'format_id': format_id,\n                    'url': asset_url,\n                    'ext': ext,\n                }\n                if re.search(r'(?:/mp4/source/|_source\\.mp4)', asset_url):\n                    f.update({\n                        'format_id': ('%s-' % format_id if format_id else '') + 'SOURCE',\n                        'preference': 1,\n                    })\n                else:\n                    mobj = re.search(r'/(\\d+)x(\\d+)/', asset_url)\n                    if mobj:\n                        height = int(mobj.group(2))\n                        f.update({\n                            'format_id': ('%s-' % format_id if format_id else '') + '%dP' % height,\n                            'width': int(mobj.group(1)),\n                            'height': height,\n                        })\n                formats.append(f)\n        self._sort_formats(formats)\n\n        subtitles = {}\n        for cc in video_data.get('closedcaption', {}).get('src', []):\n            cc_url = cc.get('value')\n            if not cc_url:\n                continue\n            ext = determine_ext(cc_url)\n            if ext == 'xml':\n                ext = 'ttml'\n            subtitles.setdefault(cc.get('lang'), []).append({\n                'url': cc_url,\n                'ext': ext,\n            })\n\n        thumbnails = []\n        for thumbnail in video_data.get('thumbnails', {}).get('thumbnail', []):\n            thumbnail_url = thumbnail.get('value')\n            if not thumbnail_url:\n                continue\n            thumbnails.append({\n                'url': thumbnail_url,\n                'width': int_or_none(thumbnail.get('width')),\n                'height': int_or_none(thumbnail.get('height')),\n            })\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': video_data.get('longdescription') or video_data.get('description'),\n            'duration': int_or_none(video_data.get('duration', {}).get('value'), 1000),\n            'age_limit': parse_age_limit(video_data.get('tvrating', {}).get('rating')),\n            'episode_number': int_or_none(video_data.get('episodenumber')),\n            'series': video_data.get('show', {}).get('title'),\n            'season_number': int_or_none(video_data.get('season', {}).get('num')),\n            'thumbnails': thumbnails,\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n", "comments": "# coding: utf-8\n#]+))' % '|'.join(_SITE_INFO.keys())\n# m3u8 download\n# There may be inner quotes, e.g. data-video-id=\"'VDKA3609139'\"\n# from http://freeform.go.com/shows/shadowhunters/episodes/season-2/1-this-guilty-blood\n# show extraction works for Disney, DisneyJunior and DisneyXD\n# ABC and Freeform has different layout\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .adobepass import AdobePassIE\nfrom ..utils import (\n    int_or_none,\n    determine_ext,\n    parse_age_limit,\n    urlencode_postdata,\n    ExtractorError,\n)\n\n\nclass GoIE(AdobePassIE):\n    _SITE_INFO = {\n        'abc': {\n            'brand': '001',\n            'requestor_id': 'ABC',\n        },\n        'freeform': {\n            'brand': '002',\n            'requestor_id': 'ABCFamily',\n        },\n        'watchdisneychannel': {\n            'brand': '004',\n            'requestor_id': 'Disney',\n        },\n        'watchdisneyjunior': {\n            'brand': '008',\n            'requestor_id': 'DisneyJunior',\n        },\n        'watchdisneyxd': {\n            'brand': '009',\n            'requestor_id': 'DisneyXD',\n        }\n    }\n    _VALID_URL = r'https?://(?:(?P<sub_domain>%s)\\.)?go\\.com/(?:(?:[^/]+/)*(?P<id>vdka\\w+)|(?:[^/]+/)*(?P<display_id>[^/?#]+))' % '|'.join(_SITE_INFO.keys())\n    _TESTS = [{\n        'url': 'http://abc.go.com/shows/designated-survivor/video/most-recent/VDKA3807643',\n        'info_dict': {\n            'id': 'VDKA3807643',\n            'ext': 'mp4',\n            'title': 'The Traitor in the White House',\n            'description': 'md5:05b009d2d145a1e85d25111bd37222e8',\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n    }, {\n        'url': 'http://watchdisneyxd.go.com/doraemon',\n        'info_dict': {\n            'title': 'Doraemon',\n            'id': 'SH55574025',\n        },\n        'playlist_mincount': 51,\n    }, {\n        'url': 'http://abc.go.com/shows/the-catch/episode-guide/season-01/10-the-wedding',\n        'only_matching': True,\n    }, {\n        'url': 'http://abc.go.com/shows/world-news-tonight/episode-guide/2017-02/17-021717-intense-stand-off-between-man-with-rifle-and-police-in-oakland',\n        'only_matching': True,\n    }]\n\n    def _extract_videos(self, brand, video_id='-1', show_id='-1'):\n        display_id = video_id if video_id != '-1' else show_id\n        return self._download_json(\n            'http://api.contents.watchabc.go.com/vp2/ws/contents/3000/videos/%s/001/-1/%s/-1/%s/-1/-1.json' % (brand, show_id, video_id),\n            display_id)['video']\n\n    def _real_extract(self, url):\n        sub_domain, video_id, display_id = re.match(self._VALID_URL, url).groups()\n        site_info = self._SITE_INFO[sub_domain]\n        brand = site_info['brand']\n        if not video_id:\n            webpage = self._download_webpage(url, display_id)\n            video_id = self._search_regex(\n                # There may be inner quotes, e.g. data-video-id=\"'VDKA3609139'\"\n                # from http://freeform.go.com/shows/shadowhunters/episodes/season-2/1-this-guilty-blood\n                r'data-video-id=[\"\\']*(VDKA\\w+)', webpage, 'video id', default=None)\n            if not video_id:\n                # show extraction works for Disney, DisneyJunior and DisneyXD\n                # ABC and Freeform has different layout\n                show_id = self._search_regex(r'data-show-id=[\"\\']*(SH\\d+)', webpage, 'show id')\n                videos = self._extract_videos(brand, show_id=show_id)\n                show_title = self._search_regex(r'data-show-title=\"([^\"]+)\"', webpage, 'show title', fatal=False)\n                entries = []\n                for video in videos:\n                    entries.append(self.url_result(\n                        video['url'], 'Go', video.get('id'), video.get('title')))\n                entries.reverse()\n                return self.playlist_result(entries, show_id, show_title)\n        video_data = self._extract_videos(brand, video_id)[0]\n        video_id = video_data['id']\n        title = video_data['title']\n\n        formats = []\n        for asset in video_data.get('assets', {}).get('asset', []):\n            asset_url = asset.get('value')\n            if not asset_url:\n                continue\n            format_id = asset.get('format')\n            ext = determine_ext(asset_url)\n            if ext == 'm3u8':\n                video_type = video_data.get('type')\n                data = {\n                    'video_id': video_data['id'],\n                    'video_type': video_type,\n                    'brand': brand,\n                    'device': '001',\n                }\n                if video_data.get('accesslevel') == '1':\n                    requestor_id = site_info['requestor_id']\n                    resource = self._get_mvpd_resource(\n                        requestor_id, title, video_id, None)\n                    auth = self._extract_mvpd_auth(\n                        url, video_id, requestor_id, resource)\n                    data.update({\n                        'token': auth,\n                        'token_type': 'ap',\n                        'adobe_requestor_id': requestor_id,\n                    })\n                else:\n                    self._initialize_geo_bypass(['US'])\n                entitlement = self._download_json(\n                    'https://api.entitlement.watchabc.go.com/vp2/ws-secure/entitlement/2020/authorize.json',\n                    video_id, data=urlencode_postdata(data))\n                errors = entitlement.get('errors', {}).get('errors', [])\n                if errors:\n                    for error in errors:\n                        if error.get('code') == 1002:\n                            self.raise_geo_restricted(\n                                error['message'], countries=['US'])\n                    error_message = ', '.join([error['message'] for error in errors])\n                    raise ExtractorError('%s said: %s' % (self.IE_NAME, error_message), expected=True)\n                asset_url += '?' + entitlement['uplynkData']['sessionKey']\n                formats.extend(self._extract_m3u8_formats(\n                    asset_url, video_id, 'mp4', m3u8_id=format_id or 'hls', fatal=False))\n            else:\n                f = {\n                    'format_id': format_id,\n                    'url': asset_url,\n                    'ext': ext,\n                }\n                if re.search(r'(?:/mp4/source/|_source\\.mp4)', asset_url):\n                    f.update({\n                        'format_id': ('%s-' % format_id if format_id else '') + 'SOURCE',\n                        'preference': 1,\n                    })\n                else:\n                    mobj = re.search(r'/(\\d+)x(\\d+)/', asset_url)\n                    if mobj:\n                        height = int(mobj.group(2))\n                        f.update({\n                            'format_id': ('%s-' % format_id if format_id else '') + '%dP' % height,\n                            'width': int(mobj.group(1)),\n                            'height': height,\n                        })\n                formats.append(f)\n        self._sort_formats(formats)\n\n        subtitles = {}\n        for cc in video_data.get('closedcaption', {}).get('src', []):\n            cc_url = cc.get('value')\n            if not cc_url:\n                continue\n            ext = determine_ext(cc_url)\n            if ext == 'xml':\n                ext = 'ttml'\n            subtitles.setdefault(cc.get('lang'), []).append({\n                'url': cc_url,\n                'ext': ext,\n            })\n\n        thumbnails = []\n        for thumbnail in video_data.get('thumbnails', {}).get('thumbnail', []):\n            thumbnail_url = thumbnail.get('value')\n            if not thumbnail_url:\n                continue\n            thumbnails.append({\n                'url': thumbnail_url,\n                'width': int_or_none(thumbnail.get('width')),\n                'height': int_or_none(thumbnail.get('height')),\n            })\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': video_data.get('longdescription') or video_data.get('description'),\n            'duration': int_or_none(video_data.get('duration', {}).get('value'), 1000),\n            'age_limit': parse_age_limit(video_data.get('tvrating', {}).get('rating')),\n            'episode_number': int_or_none(video_data.get('episodenumber')),\n            'series': video_data.get('show', {}).get('title'),\n            'season_number': int_or_none(video_data.get('season', {}).get('num')),\n            'thumbnails': thumbnails,\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "go.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/go.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}