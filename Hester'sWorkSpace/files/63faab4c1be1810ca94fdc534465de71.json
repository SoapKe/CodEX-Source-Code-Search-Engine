{"author": "getsentry", "code": "from __future__ import absolute_import\n\nfrom collections import (\n    OrderedDict,\n    defaultdict,\n)\nfrom exam import fixture\nfrom six.moves import reduce\n\nfrom sentry.digests import Record\nfrom sentry.digests.notifications import (\n    Notification,\n    event_to_record,\n    rewrite_record,\n    group_records,\n    sort_group_contents,\n    sort_rule_groups,\n)\nfrom sentry.models import Rule\nfrom sentry.testutils import TestCase\n\n\nclass RewriteRecordTestCase(TestCase):\n    @fixture\n    def rule(self):\n        return self.event.project.rule_set.all()[0]\n\n    @fixture\n    def record(self):\n        return event_to_record(self.event, (self.rule, ))\n\n    def test_success(self):\n        assert rewrite_record(\n            self.record,\n            project=self.event.project,\n            groups={\n                self.event.group.id: self.event.group,\n            },\n            rules={\n                self.rule.id: self.rule,\n            },\n        ) == Record(\n            self.record.key,\n            Notification(\n                self.event,\n                [self.rule],\n            ),\n            self.record.timestamp,\n        )\n\n    def test_without_group(self):\n        \n        assert rewrite_record(\n            self.record,\n            project=self.event.project,\n            groups={},\n            rules={\n                self.rule.id: self.rule,\n            },\n        ) is None\n\n    def test_filters_invalid_rules(self):\n        \n        assert rewrite_record(\n            self.record,\n            project=self.event.project,\n            groups={\n                self.event.group.id: self.event.group,\n            },\n            rules={},\n        ) == Record(\n            self.record.key,\n            Notification(self.event, []),\n            self.record.timestamp,\n        )\n\n\nclass GroupRecordsTestCase(TestCase):\n    @fixture\n    def rule(self):\n        return self.project.rule_set.all()[0]\n\n    def test_success(self):\n        events = [self.create_event(group=self.group) for _ in range(3)]\n        records = [\n            Record(event.id, Notification(event, [self.rule]), event.datetime) for event in events\n        ]\n        assert reduce(group_records, records, defaultdict(lambda: defaultdict(list))) == {\n            self.rule: {\n                self.group: records,\n            },\n        }\n\n\nclass SortRecordsTestCase(TestCase):\n    def test_success(self):\n        Rule.objects.create(\n            project=self.project,\n            label='Send a notification for regressions',\n            data={\n                'match':\n                'all',\n                'conditions': [\n                    {\n                        'id': 'sentry.rules.conditions.regression_event.RegressionEventCondition'\n                    },\n                ],\n                'actions': [\n                    {\n                        'id': 'sentry.rules.actions.notify_event.NotifyEventAction'\n                    },\n                ],\n            }\n        )\n\n        rules = list(self.project.rule_set.all())\n        groups = [self.create_group() for _ in range(3)]\n\n        groups[0].event_count = 10\n        groups[0].user_count = 4\n\n        groups[1].event_count = 5\n        groups[1].user_count = 2\n\n        groups[2].event_count = 5\n        groups[2].user_count = 1\n\n        grouped = {\n            rules[0]: {\n                groups[0]: [],\n            },\n            rules[1]: {\n                groups[1]: [],\n                groups[2]: [],\n            },\n        }\n\n        assert sort_rule_groups(sort_group_contents(grouped)) == OrderedDict(\n            (\n                (rules[1], OrderedDict(((groups[1], []), (groups[2], []), ))),\n                (rules[0], OrderedDict(((groups[0], []), ))),\n            )\n        )\n", "comments": "  if record associated group  returned none     if record associated group  returned none  ", "content": "from __future__ import absolute_import\n\nfrom collections import (\n    OrderedDict,\n    defaultdict,\n)\nfrom exam import fixture\nfrom six.moves import reduce\n\nfrom sentry.digests import Record\nfrom sentry.digests.notifications import (\n    Notification,\n    event_to_record,\n    rewrite_record,\n    group_records,\n    sort_group_contents,\n    sort_rule_groups,\n)\nfrom sentry.models import Rule\nfrom sentry.testutils import TestCase\n\n\nclass RewriteRecordTestCase(TestCase):\n    @fixture\n    def rule(self):\n        return self.event.project.rule_set.all()[0]\n\n    @fixture\n    def record(self):\n        return event_to_record(self.event, (self.rule, ))\n\n    def test_success(self):\n        assert rewrite_record(\n            self.record,\n            project=self.event.project,\n            groups={\n                self.event.group.id: self.event.group,\n            },\n            rules={\n                self.rule.id: self.rule,\n            },\n        ) == Record(\n            self.record.key,\n            Notification(\n                self.event,\n                [self.rule],\n            ),\n            self.record.timestamp,\n        )\n\n    def test_without_group(self):\n        # If the record can't be associated with a group, it should be returned as None.\n        assert rewrite_record(\n            self.record,\n            project=self.event.project,\n            groups={},\n            rules={\n                self.rule.id: self.rule,\n            },\n        ) is None\n\n    def test_filters_invalid_rules(self):\n        # If the record can't be associated with a group, it should be returned as None.\n        assert rewrite_record(\n            self.record,\n            project=self.event.project,\n            groups={\n                self.event.group.id: self.event.group,\n            },\n            rules={},\n        ) == Record(\n            self.record.key,\n            Notification(self.event, []),\n            self.record.timestamp,\n        )\n\n\nclass GroupRecordsTestCase(TestCase):\n    @fixture\n    def rule(self):\n        return self.project.rule_set.all()[0]\n\n    def test_success(self):\n        events = [self.create_event(group=self.group) for _ in range(3)]\n        records = [\n            Record(event.id, Notification(event, [self.rule]), event.datetime) for event in events\n        ]\n        assert reduce(group_records, records, defaultdict(lambda: defaultdict(list))) == {\n            self.rule: {\n                self.group: records,\n            },\n        }\n\n\nclass SortRecordsTestCase(TestCase):\n    def test_success(self):\n        Rule.objects.create(\n            project=self.project,\n            label='Send a notification for regressions',\n            data={\n                'match':\n                'all',\n                'conditions': [\n                    {\n                        'id': 'sentry.rules.conditions.regression_event.RegressionEventCondition'\n                    },\n                ],\n                'actions': [\n                    {\n                        'id': 'sentry.rules.actions.notify_event.NotifyEventAction'\n                    },\n                ],\n            }\n        )\n\n        rules = list(self.project.rule_set.all())\n        groups = [self.create_group() for _ in range(3)]\n\n        groups[0].event_count = 10\n        groups[0].user_count = 4\n\n        groups[1].event_count = 5\n        groups[1].user_count = 2\n\n        groups[2].event_count = 5\n        groups[2].user_count = 1\n\n        grouped = {\n            rules[0]: {\n                groups[0]: [],\n            },\n            rules[1]: {\n                groups[1]: [],\n                groups[2]: [],\n            },\n        }\n\n        assert sort_rule_groups(sort_group_contents(grouped)) == OrderedDict(\n            (\n                (rules[1], OrderedDict(((groups[1], []), (groups[2], []), ))),\n                (rules[0], OrderedDict(((groups[0], []), ))),\n            )\n        )\n", "description": "Sentry is a cross-platform crash reporting and aggregation platform.", "file_name": "test_notifications.py", "id": "63faab4c1be1810ca94fdc534465de71", "language": "Python", "project_name": "sentry", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/getsentry-sentry/getsentry-sentry-6a9c7e2/tests/sentry/digests/test_notifications.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:23:24Z", "url": "https://github.com/getsentry/sentry", "wiki": false}