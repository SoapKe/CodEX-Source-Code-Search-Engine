{"author": "eliangcs", "code": "from http_prompt.tree import Node\n\n\nclass Context(object):\n\n    def __init__(self, url=None, spec=None):\n        self.url = url\n        self.headers = {}\n        self.querystring_params = {}\n        self.body_params = {}\n        self.body_json_params = {}\n        self.options = {}\n        self.should_exit = False\n\n        \n        self.root = Node('root')\n        if spec:\n            if not self.url:\n                schemes = spec.get('schemes')\n                scheme = schemes[0] if schemes else 'https'\n                self.url = (scheme + '://' +\n                            spec.get('host', 'http://localhost:8000') +\n                            spec.get('basePath', ''))\n\n            base_path_tokens = list(filter(lambda s: s,\n                                    spec.get('basePath', '').split('/')))\n            paths = spec.get('paths')\n            if paths:\n                for path in paths:\n                    path_tokens = (base_path_tokens +\n                                   list(filter(lambda s: s, path.split('/'))))\n                    self.root.add_path(*path_tokens)\n                    endpoint = paths[path]\n                    for method, info in endpoint.items():\n                        params = info.get('parameters')\n                        if params:\n                            for param in params:\n                                if param.get('in') != 'path':\n                                    full_path = path_tokens + [param['name']]\n                                    self.root.add_path(*full_path,\n                                                       node_type='file')\n        elif not self.url:\n            self.url = 'http://localhost:8000'\n\n    def __eq__(self, other):\n        return (self.url == other.url and\n                self.headers == other.headers and\n                self.options == other.options and\n                self.querystring_params == other.querystring_params and\n                self.body_params == other.body_params and\n                self.body_json_params == other.body_json_params and\n                self.should_exit == other.should_exit)\n\n    def copy(self):\n        context = Context(self.url)\n        context.headers = self.headers.copy()\n        context.querystring_params = self.querystring_params.copy()\n        context.body_params = self.body_params.copy()\n        context.body_json_params = self.body_json_params.copy()\n        context.options = self.options.copy()\n        context.should_exit = self.should_exit\n        return context\n\n    def update(self, context):\n        if context.url:\n            self.url = context.url\n\n        self.headers.update(context.headers)\n        self.querystring_params.update(context.querystring_params)\n        self.body_params.update(context.body_params)\n        self.body_json_params.update(context.body_json_params)\n        self.options.update(context.options)\n        self.should_exit = self.should_exit\n", "comments": "  create tree supporting api spec ls command ", "content": "from http_prompt.tree import Node\n\n\nclass Context(object):\n\n    def __init__(self, url=None, spec=None):\n        self.url = url\n        self.headers = {}\n        self.querystring_params = {}\n        self.body_params = {}\n        self.body_json_params = {}\n        self.options = {}\n        self.should_exit = False\n\n        # Create a tree for supporting API spec and ls command\n        self.root = Node('root')\n        if spec:\n            if not self.url:\n                schemes = spec.get('schemes')\n                scheme = schemes[0] if schemes else 'https'\n                self.url = (scheme + '://' +\n                            spec.get('host', 'http://localhost:8000') +\n                            spec.get('basePath', ''))\n\n            base_path_tokens = list(filter(lambda s: s,\n                                    spec.get('basePath', '').split('/')))\n            paths = spec.get('paths')\n            if paths:\n                for path in paths:\n                    path_tokens = (base_path_tokens +\n                                   list(filter(lambda s: s, path.split('/'))))\n                    self.root.add_path(*path_tokens)\n                    endpoint = paths[path]\n                    for method, info in endpoint.items():\n                        params = info.get('parameters')\n                        if params:\n                            for param in params:\n                                if param.get('in') != 'path':\n                                    full_path = path_tokens + [param['name']]\n                                    self.root.add_path(*full_path,\n                                                       node_type='file')\n        elif not self.url:\n            self.url = 'http://localhost:8000'\n\n    def __eq__(self, other):\n        return (self.url == other.url and\n                self.headers == other.headers and\n                self.options == other.options and\n                self.querystring_params == other.querystring_params and\n                self.body_params == other.body_params and\n                self.body_json_params == other.body_json_params and\n                self.should_exit == other.should_exit)\n\n    def copy(self):\n        context = Context(self.url)\n        context.headers = self.headers.copy()\n        context.querystring_params = self.querystring_params.copy()\n        context.body_params = self.body_params.copy()\n        context.body_json_params = self.body_json_params.copy()\n        context.options = self.options.copy()\n        context.should_exit = self.should_exit\n        return context\n\n    def update(self, context):\n        if context.url:\n            self.url = context.url\n\n        self.headers.update(context.headers)\n        self.querystring_params.update(context.querystring_params)\n        self.body_params.update(context.body_params)\n        self.body_json_params.update(context.body_json_params)\n        self.options.update(context.options)\n        self.should_exit = self.should_exit\n", "description": "HTTPie + prompt_toolkit = an interactive command-line HTTP client featuring autocomplete and syntax highlighting", "file_name": "__init__.py", "id": "73218990f212b32b8c300b9376260b35", "language": "Python", "project_name": "http-prompt", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/eliangcs-http-prompt/eliangcs-http-prompt-87f1e9d/http_prompt/context/__init__.py", "save_time": "", "source": "", "update_at": "2018-03-17T18:26:33Z", "url": "https://github.com/eliangcs/http-prompt", "wiki": true}