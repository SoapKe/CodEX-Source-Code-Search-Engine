{"author": "django", "code": "from django.core.exceptions import FieldError\nfrom django.db.models import Count, F, Max\nfrom django.test import TestCase\n\nfrom .models import A, B, Bar, D, DataPoint, Foo, RelatedPoint\n\n\nclass SimpleTest(TestCase):\n    def setUp(self):\n        self.a1 = A.objects.create()\n        self.a2 = A.objects.create()\n        for x in range(20):\n            B.objects.create(a=self.a1)\n            D.objects.create(a=self.a1)\n\n    def test_nonempty_update(self):\n        \"\"\"\n        Update changes the right number of rows for a nonempty queryset\n        \"\"\"\n        num_updated = self.a1.b_set.update(y=100)\n        self.assertEqual(num_updated, 20)\n        cnt = B.objects.filter(y=100).count()\n        self.assertEqual(cnt, 20)\n\n    def test_empty_update(self):\n        \"\"\"\n        Update changes the right number of rows for an empty queryset\n        \"\"\"\n        num_updated = self.a2.b_set.update(y=100)\n        self.assertEqual(num_updated, 0)\n        cnt = B.objects.filter(y=100).count()\n        self.assertEqual(cnt, 0)\n\n    def test_nonempty_update_with_inheritance(self):\n        \"\"\"\n        Update changes the right number of rows for an empty queryset\n        when the update affects only a base table\n        \"\"\"\n        num_updated = self.a1.d_set.update(y=100)\n        self.assertEqual(num_updated, 20)\n        cnt = D.objects.filter(y=100).count()\n        self.assertEqual(cnt, 20)\n\n    def test_empty_update_with_inheritance(self):\n        \"\"\"\n        Update changes the right number of rows for an empty queryset\n        when the update affects only a base table\n        \"\"\"\n        num_updated = self.a2.d_set.update(y=100)\n        self.assertEqual(num_updated, 0)\n        cnt = D.objects.filter(y=100).count()\n        self.assertEqual(cnt, 0)\n\n    def test_foreign_key_update_with_id(self):\n        \"\"\"\n        Update works using <field>_id for foreign keys\n        \"\"\"\n        num_updated = self.a1.d_set.update(a_id=self.a2)\n        self.assertEqual(num_updated, 20)\n        self.assertEqual(self.a2.d_set.count(), 20)\n\n\nclass AdvancedTests(TestCase):\n\n    def setUp(self):\n        self.d0 = DataPoint.objects.create(name=\"d0\", value=\"apple\")\n        self.d2 = DataPoint.objects.create(name=\"d2\", value=\"banana\")\n        self.d3 = DataPoint.objects.create(name=\"d3\", value=\"banana\")\n        self.r1 = RelatedPoint.objects.create(name=\"r1\", data=self.d3)\n\n    def test_update(self):\n        \"\"\"\n        Objects are updated by first filtering the candidates into a queryset\n        and then calling the update() method. It executes immediately and\n        returns nothing.\n        \"\"\"\n        resp = DataPoint.objects.filter(value=\"apple\").update(name=\"d1\")\n        self.assertEqual(resp, 1)\n        resp = DataPoint.objects.filter(value=\"apple\")\n        self.assertEqual(list(resp), [self.d0])\n\n    def test_update_multiple_objects(self):\n        \"\"\"\n        We can update multiple objects at once.\n        \"\"\"\n        resp = DataPoint.objects.filter(value=\"banana\").update(\n            value=\"pineapple\")\n        self.assertEqual(resp, 2)\n        self.assertEqual(DataPoint.objects.get(name=\"d2\").value, 'pineapple')\n\n    def test_update_fk(self):\n        \"\"\"\n        Foreign key fields can also be updated, although you can only update\n        the object referred to, not anything inside the related object.\n        \"\"\"\n        resp = RelatedPoint.objects.filter(name=\"r1\").update(data=self.d0)\n        self.assertEqual(resp, 1)\n        resp = RelatedPoint.objects.filter(data__name=\"d0\")\n        self.assertEqual(list(resp), [self.r1])\n\n    def test_update_multiple_fields(self):\n        \"\"\"\n        Multiple fields can be updated at once\n        \"\"\"\n        resp = DataPoint.objects.filter(value=\"apple\").update(\n            value=\"fruit\", another_value=\"peach\")\n        self.assertEqual(resp, 1)\n        d = DataPoint.objects.get(name=\"d0\")\n        self.assertEqual(d.value, 'fruit')\n        self.assertEqual(d.another_value, 'peach')\n\n    def test_update_all(self):\n        \"\"\"\n        In the rare case you want to update every instance of a model, update()\n        is also a manager method.\n        \"\"\"\n        self.assertEqual(DataPoint.objects.update(value='thing'), 3)\n        resp = DataPoint.objects.values('value').distinct()\n        self.assertEqual(list(resp), [{'value': 'thing'}])\n\n    def test_update_slice_fail(self):\n        \"\"\"\n        We do not support update on already sliced query sets.\n        \"\"\"\n        method = DataPoint.objects.all()[:2].update\n        msg = 'Cannot update a query once a slice has been taken.'\n        with self.assertRaisesMessage(AssertionError, msg):\n            method(another_value='another thing')\n\n    def test_update_respects_to_field(self):\n        \"\"\"\n        Update of an FK field which specifies a to_field works.\n        \"\"\"\n        a_foo = Foo.objects.create(target='aaa')\n        b_foo = Foo.objects.create(target='bbb')\n        bar = Bar.objects.create(foo=a_foo)\n        self.assertEqual(bar.foo_id, a_foo.target)\n        bar_qs = Bar.objects.filter(pk=bar.pk)\n        self.assertEqual(bar_qs[0].foo_id, a_foo.target)\n        bar_qs.update(foo=b_foo)\n        self.assertEqual(bar_qs[0].foo_id, b_foo.target)\n\n    def test_update_m2m_field(self):\n        msg = (\n            'Cannot update model field '\n            '<django.db.models.fields.related.ManyToManyField: m2m_foo> '\n            '(only non-relations and foreign keys permitted).'\n        )\n        with self.assertRaisesMessage(FieldError, msg):\n            Bar.objects.update(m2m_foo='whatever')\n\n    def test_update_annotated_queryset(self):\n        \"\"\"\n        Update of a queryset that's been annotated.\n        \"\"\"\n        \n        qs = DataPoint.objects.annotate(alias=F('value'))\n        self.assertEqual(qs.update(another_value='foo'), 3)\n        \n        qs = DataPoint.objects.annotate(alias=F('value')).filter(alias='apple')\n        self.assertEqual(qs.update(another_value='foo'), 1)\n        \n        qs = DataPoint.objects.annotate(alias=F('value'))\n        self.assertEqual(qs.update(another_value=F('alias')), 3)\n        \n        qs = DataPoint.objects.annotate(max=Max('value'))\n        with self.assertRaisesMessage(FieldError, 'Aggregate functions are not allowed in this query'):\n            qs.update(another_value=F('max'))\n\n    def test_update_annotated_multi_table_queryset(self):\n        \"\"\"\n        Update of a queryset that's been annotated and involves multiple tables.\n        \"\"\"\n        \n        qs = DataPoint.objects.annotate(related_count=Count('relatedpoint'))\n        self.assertEqual(qs.update(value='Foo'), 3)\n        \n        qs = DataPoint.objects.annotate(related_count=Count('relatedpoint'))\n        self.assertEqual(qs.filter(related_count=1).update(value='Foo'), 1)\n        \n        \n        # qs = RelatedPoint.objects.annotate(data_name=F('data__name'))\n        # updated = qs.update(name=F('data_name'))\n        # self.assertEqual(updated, 1)\n        \n        qs = RelatedPoint.objects.annotate(max=Max('data__value'))\n        with self.assertRaisesMessage(FieldError, 'Aggregate functions are not allowed in this query'):\n            qs.update(name=F('max'))\n", "comments": "            update changes right number rows nonempty queryset                     num updated   self a1 b set update(y 100)         self assertequal(num updated  20)         cnt   b objects filter(y 100) count()         self assertequal(cnt  20)      def test empty update(self)                      update changes right number rows empty queryset                     num updated   self a2 b set update(y 100)         self assertequal(num updated  0)         cnt   b objects filter(y 100) count()         self assertequal(cnt  0)      def test nonempty update inheritance(self)                      update changes right number rows empty queryset         update affects base table                     num updated   self a1 set update(y 100)         self assertequal(num updated  20)         cnt   d objects filter(y 100) count()         self assertequal(cnt  20)      def test empty update inheritance(self)                      update changes right number rows empty queryset         update affects base table                     num updated   self a2 set update(y 100)         self assertequal(num updated  0)         cnt   d objects filter(y 100) count()         self assertequal(cnt  0)      def test foreign key update id(self)                      update works using  field  id foreign keys                     num updated   self a1 set update(a id self a2)         self assertequal(num updated  20)         self assertequal(self a2 set count()  20)   class advancedtests(testcase)       def setup(self)          self d0   datapoint objects create(name  d0   value  apple )         self d2   datapoint objects create(name  d2   value  banana )         self d3   datapoint objects create(name  d3   value  banana )         self r1   relatedpoint objects create(name  r1   data self d3)      def test update(self)                      objects updated first filtering candidates queryset         calling update() method  it executes immediately         returns nothing                      resp   datapoint objects filter(value  apple ) update(name  d1 )         self assertequal(resp  1)         resp   datapoint objects filter(value  apple )         self assertequal(list(resp)   self d0 )      def test update multiple objects(self)                      we update multiple objects                      resp   datapoint objects filter(value  banana ) update(             value  pineapple )         self assertequal(resp  2)         self assertequal(datapoint objects get(name  d2 ) value   pineapple )      def test update fk(self)                      foreign key fields also updated  although update         object referred  anything inside related object                      resp   relatedpoint objects filter(name  r1 ) update(data self d0)         self assertequal(resp  1)         resp   relatedpoint objects filter(data  name  d0 )         self assertequal(list(resp)   self r1 )      def test update multiple fields(self)                      multiple fields updated                     resp   datapoint objects filter(value  apple ) update(             value  fruit   another value  peach )         self assertequal(resp  1)           datapoint objects get(name  d0 )         self assertequal(d value   fruit )         self assertequal(d another value   peach )      def test update all(self)                      in rare case want update every instance model  update()         also manager method                      self assertequal(datapoint objects update(value  thing )  3)         resp   datapoint objects values( value ) distinct()         self assertequal(list(resp)     value    thing   )      def test update slice fail(self)                      we support update already sliced query sets                      method   datapoint objects all()  2  update         msg    cannot update query slice taken           self assertraisesmessage(assertionerror  msg)              method(another value  another thing )      def test update respects field(self)                      update fk field specifies field works                      foo   foo objects create(target  aaa )         b foo   foo objects create(target  bbb )         bar   bar objects create(foo foo)         self assertequal(bar foo id  foo target)         bar qs   bar objects filter(pk bar pk)         self assertequal(bar qs 0  foo id  foo target)         bar qs update(foo b foo)         self assertequal(bar qs 0  foo id  b foo target)      def test update m2m field(self)          msg   (              cannot update model field                 django db models fields related manytomanyfield  m2m foo                 (only non relations foreign keys permitted)           )         self assertraisesmessage(fielderror  msg)              bar objects update(m2m foo  whatever )      def test update annotated queryset(self)                      update queryset annotated                        trivial annotated update         qs   datapoint objects annotate(alias f( value ))         self assertequal(qs update(another value  foo )  3)           update annotation used filtering         qs   datapoint objects annotate(alias f( value )) filter(alias  apple )         self assertequal(qs update(another value  foo )  1)           update annotation used update parameters         qs   datapoint objects annotate(alias f( value ))         self assertequal(qs update(another value f( alias ))  3)           update aggregation annotation used update parameters         qs   datapoint objects annotate(max max( value ))         self assertraisesmessage(fielderror   aggregate functions allowed query )              qs update(another value f( max ))      def test update annotated multi table queryset(self)                      update queryset annotated involves multiple tables                 trivial annotated update    update annotation used filtering    update annotation used update parameters    update aggregation annotation used update parameters    trivial annotated update    update annotation used filtering    update annotation used update parameters     26539   this forbidden also generate proper sql    qs   relatedpoint objects annotate(data name f( data  name ))    updated   qs update(name f( data name ))    self assertequal(updated  1)    update aggregation annotation used update parameters ", "content": "from django.core.exceptions import FieldError\nfrom django.db.models import Count, F, Max\nfrom django.test import TestCase\n\nfrom .models import A, B, Bar, D, DataPoint, Foo, RelatedPoint\n\n\nclass SimpleTest(TestCase):\n    def setUp(self):\n        self.a1 = A.objects.create()\n        self.a2 = A.objects.create()\n        for x in range(20):\n            B.objects.create(a=self.a1)\n            D.objects.create(a=self.a1)\n\n    def test_nonempty_update(self):\n        \"\"\"\n        Update changes the right number of rows for a nonempty queryset\n        \"\"\"\n        num_updated = self.a1.b_set.update(y=100)\n        self.assertEqual(num_updated, 20)\n        cnt = B.objects.filter(y=100).count()\n        self.assertEqual(cnt, 20)\n\n    def test_empty_update(self):\n        \"\"\"\n        Update changes the right number of rows for an empty queryset\n        \"\"\"\n        num_updated = self.a2.b_set.update(y=100)\n        self.assertEqual(num_updated, 0)\n        cnt = B.objects.filter(y=100).count()\n        self.assertEqual(cnt, 0)\n\n    def test_nonempty_update_with_inheritance(self):\n        \"\"\"\n        Update changes the right number of rows for an empty queryset\n        when the update affects only a base table\n        \"\"\"\n        num_updated = self.a1.d_set.update(y=100)\n        self.assertEqual(num_updated, 20)\n        cnt = D.objects.filter(y=100).count()\n        self.assertEqual(cnt, 20)\n\n    def test_empty_update_with_inheritance(self):\n        \"\"\"\n        Update changes the right number of rows for an empty queryset\n        when the update affects only a base table\n        \"\"\"\n        num_updated = self.a2.d_set.update(y=100)\n        self.assertEqual(num_updated, 0)\n        cnt = D.objects.filter(y=100).count()\n        self.assertEqual(cnt, 0)\n\n    def test_foreign_key_update_with_id(self):\n        \"\"\"\n        Update works using <field>_id for foreign keys\n        \"\"\"\n        num_updated = self.a1.d_set.update(a_id=self.a2)\n        self.assertEqual(num_updated, 20)\n        self.assertEqual(self.a2.d_set.count(), 20)\n\n\nclass AdvancedTests(TestCase):\n\n    def setUp(self):\n        self.d0 = DataPoint.objects.create(name=\"d0\", value=\"apple\")\n        self.d2 = DataPoint.objects.create(name=\"d2\", value=\"banana\")\n        self.d3 = DataPoint.objects.create(name=\"d3\", value=\"banana\")\n        self.r1 = RelatedPoint.objects.create(name=\"r1\", data=self.d3)\n\n    def test_update(self):\n        \"\"\"\n        Objects are updated by first filtering the candidates into a queryset\n        and then calling the update() method. It executes immediately and\n        returns nothing.\n        \"\"\"\n        resp = DataPoint.objects.filter(value=\"apple\").update(name=\"d1\")\n        self.assertEqual(resp, 1)\n        resp = DataPoint.objects.filter(value=\"apple\")\n        self.assertEqual(list(resp), [self.d0])\n\n    def test_update_multiple_objects(self):\n        \"\"\"\n        We can update multiple objects at once.\n        \"\"\"\n        resp = DataPoint.objects.filter(value=\"banana\").update(\n            value=\"pineapple\")\n        self.assertEqual(resp, 2)\n        self.assertEqual(DataPoint.objects.get(name=\"d2\").value, 'pineapple')\n\n    def test_update_fk(self):\n        \"\"\"\n        Foreign key fields can also be updated, although you can only update\n        the object referred to, not anything inside the related object.\n        \"\"\"\n        resp = RelatedPoint.objects.filter(name=\"r1\").update(data=self.d0)\n        self.assertEqual(resp, 1)\n        resp = RelatedPoint.objects.filter(data__name=\"d0\")\n        self.assertEqual(list(resp), [self.r1])\n\n    def test_update_multiple_fields(self):\n        \"\"\"\n        Multiple fields can be updated at once\n        \"\"\"\n        resp = DataPoint.objects.filter(value=\"apple\").update(\n            value=\"fruit\", another_value=\"peach\")\n        self.assertEqual(resp, 1)\n        d = DataPoint.objects.get(name=\"d0\")\n        self.assertEqual(d.value, 'fruit')\n        self.assertEqual(d.another_value, 'peach')\n\n    def test_update_all(self):\n        \"\"\"\n        In the rare case you want to update every instance of a model, update()\n        is also a manager method.\n        \"\"\"\n        self.assertEqual(DataPoint.objects.update(value='thing'), 3)\n        resp = DataPoint.objects.values('value').distinct()\n        self.assertEqual(list(resp), [{'value': 'thing'}])\n\n    def test_update_slice_fail(self):\n        \"\"\"\n        We do not support update on already sliced query sets.\n        \"\"\"\n        method = DataPoint.objects.all()[:2].update\n        msg = 'Cannot update a query once a slice has been taken.'\n        with self.assertRaisesMessage(AssertionError, msg):\n            method(another_value='another thing')\n\n    def test_update_respects_to_field(self):\n        \"\"\"\n        Update of an FK field which specifies a to_field works.\n        \"\"\"\n        a_foo = Foo.objects.create(target='aaa')\n        b_foo = Foo.objects.create(target='bbb')\n        bar = Bar.objects.create(foo=a_foo)\n        self.assertEqual(bar.foo_id, a_foo.target)\n        bar_qs = Bar.objects.filter(pk=bar.pk)\n        self.assertEqual(bar_qs[0].foo_id, a_foo.target)\n        bar_qs.update(foo=b_foo)\n        self.assertEqual(bar_qs[0].foo_id, b_foo.target)\n\n    def test_update_m2m_field(self):\n        msg = (\n            'Cannot update model field '\n            '<django.db.models.fields.related.ManyToManyField: m2m_foo> '\n            '(only non-relations and foreign keys permitted).'\n        )\n        with self.assertRaisesMessage(FieldError, msg):\n            Bar.objects.update(m2m_foo='whatever')\n\n    def test_update_annotated_queryset(self):\n        \"\"\"\n        Update of a queryset that's been annotated.\n        \"\"\"\n        # Trivial annotated update\n        qs = DataPoint.objects.annotate(alias=F('value'))\n        self.assertEqual(qs.update(another_value='foo'), 3)\n        # Update where annotation is used for filtering\n        qs = DataPoint.objects.annotate(alias=F('value')).filter(alias='apple')\n        self.assertEqual(qs.update(another_value='foo'), 1)\n        # Update where annotation is used in update parameters\n        qs = DataPoint.objects.annotate(alias=F('value'))\n        self.assertEqual(qs.update(another_value=F('alias')), 3)\n        # Update where aggregation annotation is used in update parameters\n        qs = DataPoint.objects.annotate(max=Max('value'))\n        with self.assertRaisesMessage(FieldError, 'Aggregate functions are not allowed in this query'):\n            qs.update(another_value=F('max'))\n\n    def test_update_annotated_multi_table_queryset(self):\n        \"\"\"\n        Update of a queryset that's been annotated and involves multiple tables.\n        \"\"\"\n        # Trivial annotated update\n        qs = DataPoint.objects.annotate(related_count=Count('relatedpoint'))\n        self.assertEqual(qs.update(value='Foo'), 3)\n        # Update where annotation is used for filtering\n        qs = DataPoint.objects.annotate(related_count=Count('relatedpoint'))\n        self.assertEqual(qs.filter(related_count=1).update(value='Foo'), 1)\n        # Update where annotation is used in update parameters\n        # #26539 - This isn't forbidden but also doesn't generate proper SQL\n        # qs = RelatedPoint.objects.annotate(data_name=F('data__name'))\n        # updated = qs.update(name=F('data_name'))\n        # self.assertEqual(updated, 1)\n        # Update where aggregation annotation is used in update parameters\n        qs = RelatedPoint.objects.annotate(max=Max('data__value'))\n        with self.assertRaisesMessage(FieldError, 'Aggregate functions are not allowed in this query'):\n            qs.update(name=F('max'))\n", "description": "The Web framework for perfectionists with deadlines.", "file_name": "tests.py", "id": "d83840fc7a5c2d12d03f499b3e61cf73", "language": "Python", "project_name": "django", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/django-django/django-django-acfc650/tests/update/tests.py", "save_time": "", "source": "", "update_at": "2018-03-14T02:00:36Z", "url": "https://github.com/django/django", "wiki": false}