{"author": "nvbn", "code": "import io\nimport os\nimport shlex\nimport six\nfrom collections import namedtuple\nfrom ..logs import warn\nfrom ..utils import memoize\nfrom ..conf import settings\nfrom ..system import Path\n\n\nShellConfiguration = namedtuple('ShellConfiguration', (\n    'content', 'path', 'reload', 'can_configure_automatically'))\n\n\nclass Generic(object):\n    def get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self.get_aliases()\n        binary = command_script.split(' ')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        \n        return ['alias', 'bg', 'bind', 'break', 'builtin', 'case', 'cd',\n                'command', 'compgen', 'complete', 'continue', 'declare',\n                'dirs', 'disown', 'echo', 'enable', 'eval', 'exec', 'exit',\n                'export', 'fc', 'fg', 'getopts', 'hash', 'help', 'history',\n                'if', 'jobs', 'kill', 'let', 'local', 'logout', 'popd',\n                'printf', 'pushd', 'pwd', 'read', 'readonly', 'return', 'set',\n                'shift', 'shopt', 'source', 'suspend', 'test', 'times', 'trap',\n                'type', 'typeset', 'ulimit', 'umask', 'unalias', 'unset',\n                'until', 'wait', 'while']\n\n    def _create_shell_configuration(self, content, path, reload):\n        return ShellConfiguration(\n            content=content,\n            path=path,\n            reload=reload,\n            can_configure_automatically=Path(path).expanduser().exists())\n", "comments": "Prepares command before running in app.\"\"\"\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        \"\"\"Prepares command for running in shell.\"\"\"\n        return command_script\n\n    def app_alias(self, alias_name):\n        return \"alias {0}='eval $(TF_ALIAS={0} PYTHONIOENCODING=utf-8 \" \\\n               \"thefuck $(fc -ln -1))'\".format(alias_name)\n\n    def instant_mode_alias(self, alias_name):\n        warn(\"Instant mode not supported by your shell\")\n        return self.app_alias(alias_name)\n\n    def _get_history_file_name(self):\n        return ''\n\n    def _get_history_line(self, command_script):\n        return ''\n\n    @memoize\n    def get_history(self):\n        return list(self._get_history_lines())\n\n    def _get_history_lines(self):\n        \"\"\"Returns list of history entries.\"\"\"\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with io.open(history_file_name, 'r',\n                         encoding='utf-8', errors='ignore') as history_file:\n\n                lines = history_file.readlines()\n                if settings.history_limit:\n                    lines = lines[-settings.history_limit:]\n\n                for line in lines:\n                    prepared = self._script_from_history(line) \\\n                        .strip()\n                    if prepared:\n                        yield prepared\n\n    def and_(self, *commands):\n        return u' && '.join(commands)\n\n    def or_(self, *commands):\n        return u' || '.join(commands)\n\n    def how_to_configure(self):\n        return\n\n    def split_command(self, command):\n        \"\"\"Split the command using shell-like syntax.\"\"\"\n        encoded = self.encode_utf8(command)\n\n        try:\n            splitted = [s.replace(\"??\", \"\\ \") for s in shlex.split(encoded.replace('\\ ', '??'))]\n        except ValueError:\n            splitted = encoded.split(' ')\n\n        return self.decode_utf8(splitted)\n\n    def encode_utf8(self, command):\n        if six.PY2:\n            return command.encode('utf8')\n        return command\n\n    def decode_utf8(self, command_parts):\n        if six.PY2:\n            return [s.decode('utf8') for s in command_parts]\n        return command_parts\n\n    def quote(self, s):\n        \"\"\"Return a shell-escaped version of the string s.\"\"\"\n\n        if six.PY2:\n            from pipes import quote\n        else:\n            from shlex import quote\n\n        return quote(s)\n\n    def _script_from_history(self, line):\n        return line\n\n    def put_to_history(self, command):\n        \"\"\"Adds fixed command to shell history.\n\n        In most of shells we change history on shell-level, but not\n        all shells support it (Fish).\n\n        \"\"\"\n\n    def get_builtin_commands(self):\n        \"\"\"Returns shells builtin commands.\n.\n", "content": "import io\nimport os\nimport shlex\nimport six\nfrom collections import namedtuple\nfrom ..logs import warn\nfrom ..utils import memoize\nfrom ..conf import settings\nfrom ..system import Path\n\n\nShellConfiguration = namedtuple('ShellConfiguration', (\n    'content', 'path', 'reload', 'can_configure_automatically'))\n\n\nclass Generic(object):\n    def get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self.get_aliases()\n        binary = command_script.split(' ')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        \"\"\"Prepares command before running in app.\"\"\"\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        \"\"\"Prepares command for running in shell.\"\"\"\n        return command_script\n\n    def app_alias(self, alias_name):\n        return \"alias {0}='eval $(TF_ALIAS={0} PYTHONIOENCODING=utf-8 \" \\\n               \"thefuck $(fc -ln -1))'\".format(alias_name)\n\n    def instant_mode_alias(self, alias_name):\n        warn(\"Instant mode not supported by your shell\")\n        return self.app_alias(alias_name)\n\n    def _get_history_file_name(self):\n        return ''\n\n    def _get_history_line(self, command_script):\n        return ''\n\n    @memoize\n    def get_history(self):\n        return list(self._get_history_lines())\n\n    def _get_history_lines(self):\n        \"\"\"Returns list of history entries.\"\"\"\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with io.open(history_file_name, 'r',\n                         encoding='utf-8', errors='ignore') as history_file:\n\n                lines = history_file.readlines()\n                if settings.history_limit:\n                    lines = lines[-settings.history_limit:]\n\n                for line in lines:\n                    prepared = self._script_from_history(line) \\\n                        .strip()\n                    if prepared:\n                        yield prepared\n\n    def and_(self, *commands):\n        return u' && '.join(commands)\n\n    def or_(self, *commands):\n        return u' || '.join(commands)\n\n    def how_to_configure(self):\n        return\n\n    def split_command(self, command):\n        \"\"\"Split the command using shell-like syntax.\"\"\"\n        encoded = self.encode_utf8(command)\n\n        try:\n            splitted = [s.replace(\"??\", \"\\ \") for s in shlex.split(encoded.replace('\\ ', '??'))]\n        except ValueError:\n            splitted = encoded.split(' ')\n\n        return self.decode_utf8(splitted)\n\n    def encode_utf8(self, command):\n        if six.PY2:\n            return command.encode('utf8')\n        return command\n\n    def decode_utf8(self, command_parts):\n        if six.PY2:\n            return [s.decode('utf8') for s in command_parts]\n        return command_parts\n\n    def quote(self, s):\n        \"\"\"Return a shell-escaped version of the string s.\"\"\"\n\n        if six.PY2:\n            from pipes import quote\n        else:\n            from shlex import quote\n\n        return quote(s)\n\n    def _script_from_history(self, line):\n        return line\n\n    def put_to_history(self, command):\n        \"\"\"Adds fixed command to shell history.\n\n        In most of shells we change history on shell-level, but not\n        all shells support it (Fish).\n\n        \"\"\"\n\n    def get_builtin_commands(self):\n        \"\"\"Returns shells builtin commands.\"\"\"\n        return ['alias', 'bg', 'bind', 'break', 'builtin', 'case', 'cd',\n                'command', 'compgen', 'complete', 'continue', 'declare',\n                'dirs', 'disown', 'echo', 'enable', 'eval', 'exec', 'exit',\n                'export', 'fc', 'fg', 'getopts', 'hash', 'help', 'history',\n                'if', 'jobs', 'kill', 'let', 'local', 'logout', 'popd',\n                'printf', 'pushd', 'pwd', 'read', 'readonly', 'return', 'set',\n                'shift', 'shopt', 'source', 'suspend', 'test', 'times', 'trap',\n                'type', 'typeset', 'ulimit', 'umask', 'unalias', 'unset',\n                'until', 'wait', 'while']\n\n    def _create_shell_configuration(self, content, path, reload):\n        return ShellConfiguration(\n            content=content,\n            path=path,\n            reload=reload,\n            can_configure_automatically=Path(path).expanduser().exists())\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "generic.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/thefuck/shells/generic.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}