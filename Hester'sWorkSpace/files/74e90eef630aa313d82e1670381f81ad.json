{"author": "ansible", "code": "\n\n Ansible module to manage IPv4 policy objects in fortigate devices\n (c) 2017, Benjamin Jolivot <bjolivot@gmail.com>\n GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = \"\"\"\n---\nmodule: fortios_ipv4_policy\nversion_added: \"2.3\"\nauthor: \"Benjamin Jolivot (@bjolivot)\"\nshort_description: Manage IPv4 policy objects on Fortinet FortiOS firewall devices\ndescription:\n  - This module provides management of firewall IPv4 policies on FortiOS devices.\nextends_documentation_fragment: fortios\noptions:\n  id:\n    description:\n      - \"Policy ID.\n        Warning: policy ID number is different than Policy sequence number.\n        The policy ID is the number assigned at policy creation.\n        The sequence number represents the order in which the Fortigate will evaluate the rule for policy enforcement,\n        and also the order in which rules are listed in the GUI and CLI.\n        These two numbers do not necessarily correlate: this module is based off policy ID.\n        TIP: policy ID can be viewed in the GUI by adding 'ID' to the display columns\"\n    required: true\n  state:\n    description:\n      - Specifies if policy I(id) need to be added or deleted.\n    choices: ['present', 'absent']\n    default: present\n  src_intf:\n    description:\n      - Specifies source interface name(s).\n    default: any\n  dst_intf:\n    description:\n      - Specifies destination interface name(s).\n    default: any\n  src_addr:\n    description:\n      - Specifies source address (or group) object name(s). Required when I(state=present).\n  src_addr_negate:\n    description:\n      - Negate source address param.\n    default: false\n    choices: [\"true\", \"false\"]\n  dst_addr:\n    description:\n      - Specifies destination address (or group) object name(s). Required when I(state=present).\n  dst_addr_negate:\n    description:\n      - Negate destination address param.\n    default: false\n    choices: [\"true\", \"false\"]\n  policy_action:\n    description:\n      - Specifies accept or deny action policy. Required when I(state=present).\n    choices: ['accept', 'deny']\n    aliases: ['action']\n  service:\n    description:\n      - \"Specifies policy service(s), could be a list (ex: ['MAIL','DNS']). Required when I(state=present).\"\n    aliases:\n      - services\n  service_negate:\n    description:\n      - Negate policy service(s) defined in service value.\n    default: false\n    choices: [\"true\", \"false\"]\n  schedule:\n    description:\n      - defines policy schedule.\n    default: 'always'\n  nat:\n    description:\n      - Enable or disable Nat.\n    default: false\n    choices: [\"true\", \"false\"]\n  fixedport:\n    description:\n      - Use fixed port for nat.\n    default: false\n    choices: [\"true\", \"false\"]\n  poolname:\n    description:\n      - Specifies NAT pool name.\n  av_profile:\n    description:\n      - Specifies Antivirus profile name.\n  webfilter_profile:\n    description:\n      - Specifies Webfilter profile name.\n  ips_sensor:\n    description:\n      - Specifies IPS Sensor profile name.\n  application_list:\n    description:\n      - Specifies Application Control name.\n  logtraffic:\n    version_added: \"2.4\"\n    description:\n      - Logs sessions that matched policy.\n    default: utm\n    choices: ['disable', 'utm', 'all']\n  logtraffic_start:\n    version_added: \"2.4\"\n    description:\n      - Logs beginning of session as well.\n    default: false\n    choices: [\"true\", \"false\"]\n  comment:\n    description:\n      - free text to describe policy.\nnotes:\n  - This module requires pyFG library.\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: Allow external DNS call\n  fortios_ipv4_policy:\n    host: 192.168.0.254\n    username: admin\n    password: password\n    id: 42\n    src_addr: internal_network\n    dst_addr: all\n    service: dns\n    nat: True\n    state: present\n    policy_action: accept\n    logtraffic: disable\n\n- name: Public Web\n  fortios_ipv4_policy:\n    host: 192.168.0.254\n    username: admin\n    password: password\n    id: 42\n    src_addr: all\n    dst_addr: webservers\n    services:\n      - http\n      - https\n    state: present\n    policy_action: accept\n\n- name: Some Policy\n  fortios_ipv4_policy:\n    host: 192.168.0.254\n    username: admin\n    password: password\n    id: 42\n    comment: \"no comment (created by ansible)\"\n    src_intf: vl1000\n    src_addr:\n      - some_serverA\n      - some_serverB\n    dst_intf:\n      - vl2000\n      - vl3000\n    dst_addr: all\n    services:\n      - HTTP\n      - HTTPS\n    nat: True\n    state: present\n    policy_action: accept\n    logtraffic: disable\n  tags:\n    - policy\n\"\"\"\n\nRETURN = \"\"\"\nfirewall_address_config:\n  description: full firewall addresses config string\n  returned: always\n  type: string\nchange_string:\n  description: The commands executed by the module\n  returned: only if config changed\n  type: string\nmsg_error_list:\n  description: \"List of errors returned by CLI (use -vvv for better readability).\"\n  returned: only when error\n  type: string\n\"\"\"\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.network.fortios.fortios import fortios_argument_spec, fortios_required_if\nfrom ansible.module_utils.network.fortios.fortios import backup, AnsibleFortios\n\n\ndef main():\n    argument_spec = dict(\n        comment=dict(type='str'),\n        id=dict(type='int', required=True),\n        src_intf=dict(type='list', default='any'),\n        dst_intf=dict(type='list', default='any'),\n        state=dict(choices=['present', 'absent'], default='present'),\n        src_addr=dict(type='list'),\n        dst_addr=dict(type='list'),\n        src_addr_negate=dict(type='bool', default=False),\n        dst_addr_negate=dict(type='bool', default=False),\n        policy_action=dict(choices=['accept', 'deny'], aliases=['action']),\n        service=dict(aliases=['services'], type='list'),\n        service_negate=dict(type='bool', default=False),\n        schedule=dict(type='str', default='always'),\n        nat=dict(type='bool', default=False),\n        fixedport=dict(type='bool', default=False),\n        poolname=dict(type='str'),\n        av_profile=dict(type='str'),\n        webfilter_profile=dict(type='str'),\n        ips_sensor=dict(type='str'),\n        application_list=dict(type='str'),\n        logtraffic=dict(choices=['disable', 'all', 'utm'], default='utm'),\n        logtraffic_start=dict(type='bool', default=False),\n    )\n\n     merge global required_if & argument_spec from module_utils/fortios.py\n    argument_spec.update(fortios_argument_spec)\n\n    ipv4_policy_required_if = [\n        ['state', 'present', ['src_addr', 'dst_addr', 'policy_action', 'service']],\n    ]\n\n    module = AnsibleModule(\n        argument_spec=argument_spec,\n        supports_check_mode=True,\n        required_if=fortios_required_if + ipv4_policy_required_if,\n    )\n\n     init forti object\n    fortigate = AnsibleFortios(module)\n\n     Security policies root path\n    config_path = 'firewall policy'\n\n     test params\n     NAT related\n    if not module.params['nat']:\n        if module.params['poolname']:\n            module.fail_json(msg='Poolname param requires NAT to be true.')\n        if module.params['fixedport']:\n            module.fail_json(msg='Fixedport param requires NAT to be true.')\n\n     log options\n    if module.params['logtraffic_start']:\n        if not module.params['logtraffic'] == 'all':\n            module.fail_json(msg='Logtraffic_start param requires logtraffic to be set to \"all\".')\n\n     id must be str(int) for pyFG to work\n    policy_id = str(module.params['id'])\n\n     load config\n    fortigate.load_config(config_path)\n\n     Absent State\n    if module.params['state'] == 'absent':\n        fortigate.candidate_config[config_path].del_block(policy_id)\n\n     Present state\n    elif module.params['state'] == 'present':\n        new_policy = fortigate.get_empty_configuration_block(policy_id, 'edit')\n\n         src / dest / service / interfaces\n        new_policy.set_param('srcintf', \" \".join('\"' + item + '\"' for item in module.params['src_intf']))\n        new_policy.set_param('dstintf', \" \".join('\"' + item + '\"' for item in module.params['dst_intf']))\n\n        new_policy.set_param('srcaddr', \" \".join('\"' + item + '\"' for item in module.params['src_addr']))\n        new_policy.set_param('dstaddr', \" \".join('\"' + item + '\"' for item in module.params['dst_addr']))\n        new_policy.set_param('service', \" \".join('\"' + item + '\"' for item in module.params['service']))\n\n         negate src / dest / service\n        if module.params['src_addr_negate']:\n            new_policy.set_param('srcaddr-negate', 'enable')\n        if module.params['dst_addr_negate']:\n            new_policy.set_param('dstaddr-negate', 'enable')\n        if module.params['service_negate']:\n            new_policy.set_param('service-negate', 'enable')\n\n         action\n        new_policy.set_param('action', '%s' % (module.params['policy_action']))\n\n         logging\n        new_policy.set_param('logtraffic', '%s' % (module.params['logtraffic']))\n        if module.params['logtraffic'] == 'all':\n            if module.params['logtraffic_start']:\n                new_policy.set_param('logtraffic-start', 'enable')\n            else:\n                new_policy.set_param('logtraffic-start', 'disable')\n\n         Schedule\n        new_policy.set_param('schedule', '%s' % (module.params['schedule']))\n\n         NAT\n        if module.params['nat']:\n            new_policy.set_param('nat', 'enable')\n            if module.params['fixedport']:\n                new_policy.set_param('fixedport', 'enable')\n            if module.params['poolname'] is not None:\n                new_policy.set_param('ippool', 'enable')\n                new_policy.set_param('poolname', '\"%s\"' % (module.params['poolname']))\n\n         security profiles:\n        if module.params['av_profile'] is not None:\n            new_policy.set_param('av-profile', '\"%s\"' % (module.params['av_profile']))\n        if module.params['webfilter_profile'] is not None:\n            new_policy.set_param('webfilter-profile', '\"%s\"' % (module.params['webfilter_profile']))\n        if module.params['ips_sensor'] is not None:\n            new_policy.set_param('ips-sensor', '\"%s\"' % (module.params['ips_sensor']))\n        if module.params['application_list'] is not None:\n            new_policy.set_param('application-list', '\"%s\"' % (module.params['application_list']))\n\n         comment\n        if module.params['comment'] is not None:\n            new_policy.set_param('comment', '\"%s\"' % (module.params['comment']))\n\n         add the new policy to the device\n        fortigate.add_block(policy_id, new_policy)\n\n     Apply changes\n    fortigate.apply_changes()\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  fortios ipv4 policy version added   2 3  author   benjamin jolivot ( bjolivot)  short description  manage ipv4 policy objects fortinet fortios firewall devices description      this module provides management firewall ipv4 policies fortios devices  extends documentation fragment  fortios options    id      description           policy id          warning  policy id number different policy sequence number          the policy id number assigned policy creation          the sequence number represents order fortigate evaluate rule policy enforcement          also order rules listed gui cli          these two numbers necessarily correlate  module based policy id          tip  policy id viewed gui adding  id  display columns      required  true   state      description          specifies policy i(id) need added deleted      choices    present    absent       default  present   src intf      description          specifies source interface name(s)      default    dst intf      description          specifies destination interface name(s)      default    src addr      description          specifies source address (or group) object name(s)  required i(state present)    src addr negate      description          negate source address param      default  false     choices    true    false     dst addr      description          specifies destination address (or group) object name(s)  required i(state present)    dst addr negate      description          negate destination address param      default  false     choices    true    false     policy action      description          specifies accept deny action policy  required i(state present)      choices    accept    deny       aliases    action     service      description           specifies policy service(s)  could list (ex    mail   dns  )  required i(state present)       aliases          services   service negate      description          negate policy service(s) defined service value      default  false     choices    true    false     schedule      description          defines policy schedule      default   always    nat      description          enable disable nat      default  false     choices    true    false     fixedport      description          use fixed port nat      default  false     choices    true    false     poolname      description          specifies nat pool name    av profile      description          specifies antivirus profile name    webfilter profile      description          specifies webfilter profile name    ips sensor      description          specifies ips sensor profile name    application list      description          specifies application control name    logtraffic      version added   2 4      description          logs sessions matched policy      default  utm     choices    disable    utm        logtraffic start      version added   2 4      description          logs beginning session well      default  false     choices    true    false     comment      description          free text describe policy  notes      this module requires pyfg library       examples         name  allow external dns call   fortios ipv4 policy      host  192 168 0 254     username  admin     password  password     id  42     src addr  internal network     dst addr      service  dns     nat  true     state  present     policy action  accept     logtraffic  disable    name  public web   fortios ipv4 policy      host  192 168 0 254     username  admin     password  password     id  42     src addr      dst addr  webservers     services          http         https     state  present     policy action  accept    name  some policy   fortios ipv4 policy      host  192 168 0 254     username  admin     password  password     id  42     comment   comment (created ansible)      src intf  vl1000     src addr          servera         serverb     dst intf          vl2000         vl3000     dst addr      services          http         https     nat  true     state  present     policy action  accept     logtraffic  disable   tags        policy      return       firewall address config    description  full firewall addresses config string   returned  always   type  string change string    description  the commands executed module   returned  config changed   type  string msg error list    description   list errors returned cli (use  vvv better readability)     returned  error   type  string         usr bin python       ansible module manage ipv4 policy objects fortigate devices    (c) 2017  benjamin jolivot  bjolivot gmail com     gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    merge global required   argument spec module utils fortios py    init forti object    security policies root path    test params    nat related    log options    id must str(int) pyfg work    load config    absent state    present state    src   dest   service   interfaces    negate src   dest   service    action    logging    schedule    nat    security profiles     comment    add new policy device    apply changes ", "content": "#!/usr/bin/python\n#\n# Ansible module to manage IPv4 policy objects in fortigate devices\n# (c) 2017, Benjamin Jolivot <bjolivot@gmail.com>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = \"\"\"\n---\nmodule: fortios_ipv4_policy\nversion_added: \"2.3\"\nauthor: \"Benjamin Jolivot (@bjolivot)\"\nshort_description: Manage IPv4 policy objects on Fortinet FortiOS firewall devices\ndescription:\n  - This module provides management of firewall IPv4 policies on FortiOS devices.\nextends_documentation_fragment: fortios\noptions:\n  id:\n    description:\n      - \"Policy ID.\n        Warning: policy ID number is different than Policy sequence number.\n        The policy ID is the number assigned at policy creation.\n        The sequence number represents the order in which the Fortigate will evaluate the rule for policy enforcement,\n        and also the order in which rules are listed in the GUI and CLI.\n        These two numbers do not necessarily correlate: this module is based off policy ID.\n        TIP: policy ID can be viewed in the GUI by adding 'ID' to the display columns\"\n    required: true\n  state:\n    description:\n      - Specifies if policy I(id) need to be added or deleted.\n    choices: ['present', 'absent']\n    default: present\n  src_intf:\n    description:\n      - Specifies source interface name(s).\n    default: any\n  dst_intf:\n    description:\n      - Specifies destination interface name(s).\n    default: any\n  src_addr:\n    description:\n      - Specifies source address (or group) object name(s). Required when I(state=present).\n  src_addr_negate:\n    description:\n      - Negate source address param.\n    default: false\n    choices: [\"true\", \"false\"]\n  dst_addr:\n    description:\n      - Specifies destination address (or group) object name(s). Required when I(state=present).\n  dst_addr_negate:\n    description:\n      - Negate destination address param.\n    default: false\n    choices: [\"true\", \"false\"]\n  policy_action:\n    description:\n      - Specifies accept or deny action policy. Required when I(state=present).\n    choices: ['accept', 'deny']\n    aliases: ['action']\n  service:\n    description:\n      - \"Specifies policy service(s), could be a list (ex: ['MAIL','DNS']). Required when I(state=present).\"\n    aliases:\n      - services\n  service_negate:\n    description:\n      - Negate policy service(s) defined in service value.\n    default: false\n    choices: [\"true\", \"false\"]\n  schedule:\n    description:\n      - defines policy schedule.\n    default: 'always'\n  nat:\n    description:\n      - Enable or disable Nat.\n    default: false\n    choices: [\"true\", \"false\"]\n  fixedport:\n    description:\n      - Use fixed port for nat.\n    default: false\n    choices: [\"true\", \"false\"]\n  poolname:\n    description:\n      - Specifies NAT pool name.\n  av_profile:\n    description:\n      - Specifies Antivirus profile name.\n  webfilter_profile:\n    description:\n      - Specifies Webfilter profile name.\n  ips_sensor:\n    description:\n      - Specifies IPS Sensor profile name.\n  application_list:\n    description:\n      - Specifies Application Control name.\n  logtraffic:\n    version_added: \"2.4\"\n    description:\n      - Logs sessions that matched policy.\n    default: utm\n    choices: ['disable', 'utm', 'all']\n  logtraffic_start:\n    version_added: \"2.4\"\n    description:\n      - Logs beginning of session as well.\n    default: false\n    choices: [\"true\", \"false\"]\n  comment:\n    description:\n      - free text to describe policy.\nnotes:\n  - This module requires pyFG library.\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: Allow external DNS call\n  fortios_ipv4_policy:\n    host: 192.168.0.254\n    username: admin\n    password: password\n    id: 42\n    src_addr: internal_network\n    dst_addr: all\n    service: dns\n    nat: True\n    state: present\n    policy_action: accept\n    logtraffic: disable\n\n- name: Public Web\n  fortios_ipv4_policy:\n    host: 192.168.0.254\n    username: admin\n    password: password\n    id: 42\n    src_addr: all\n    dst_addr: webservers\n    services:\n      - http\n      - https\n    state: present\n    policy_action: accept\n\n- name: Some Policy\n  fortios_ipv4_policy:\n    host: 192.168.0.254\n    username: admin\n    password: password\n    id: 42\n    comment: \"no comment (created by ansible)\"\n    src_intf: vl1000\n    src_addr:\n      - some_serverA\n      - some_serverB\n    dst_intf:\n      - vl2000\n      - vl3000\n    dst_addr: all\n    services:\n      - HTTP\n      - HTTPS\n    nat: True\n    state: present\n    policy_action: accept\n    logtraffic: disable\n  tags:\n    - policy\n\"\"\"\n\nRETURN = \"\"\"\nfirewall_address_config:\n  description: full firewall addresses config string\n  returned: always\n  type: string\nchange_string:\n  description: The commands executed by the module\n  returned: only if config changed\n  type: string\nmsg_error_list:\n  description: \"List of errors returned by CLI (use -vvv for better readability).\"\n  returned: only when error\n  type: string\n\"\"\"\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.network.fortios.fortios import fortios_argument_spec, fortios_required_if\nfrom ansible.module_utils.network.fortios.fortios import backup, AnsibleFortios\n\n\ndef main():\n    argument_spec = dict(\n        comment=dict(type='str'),\n        id=dict(type='int', required=True),\n        src_intf=dict(type='list', default='any'),\n        dst_intf=dict(type='list', default='any'),\n        state=dict(choices=['present', 'absent'], default='present'),\n        src_addr=dict(type='list'),\n        dst_addr=dict(type='list'),\n        src_addr_negate=dict(type='bool', default=False),\n        dst_addr_negate=dict(type='bool', default=False),\n        policy_action=dict(choices=['accept', 'deny'], aliases=['action']),\n        service=dict(aliases=['services'], type='list'),\n        service_negate=dict(type='bool', default=False),\n        schedule=dict(type='str', default='always'),\n        nat=dict(type='bool', default=False),\n        fixedport=dict(type='bool', default=False),\n        poolname=dict(type='str'),\n        av_profile=dict(type='str'),\n        webfilter_profile=dict(type='str'),\n        ips_sensor=dict(type='str'),\n        application_list=dict(type='str'),\n        logtraffic=dict(choices=['disable', 'all', 'utm'], default='utm'),\n        logtraffic_start=dict(type='bool', default=False),\n    )\n\n    # merge global required_if & argument_spec from module_utils/fortios.py\n    argument_spec.update(fortios_argument_spec)\n\n    ipv4_policy_required_if = [\n        ['state', 'present', ['src_addr', 'dst_addr', 'policy_action', 'service']],\n    ]\n\n    module = AnsibleModule(\n        argument_spec=argument_spec,\n        supports_check_mode=True,\n        required_if=fortios_required_if + ipv4_policy_required_if,\n    )\n\n    # init forti object\n    fortigate = AnsibleFortios(module)\n\n    # Security policies root path\n    config_path = 'firewall policy'\n\n    # test params\n    # NAT related\n    if not module.params['nat']:\n        if module.params['poolname']:\n            module.fail_json(msg='Poolname param requires NAT to be true.')\n        if module.params['fixedport']:\n            module.fail_json(msg='Fixedport param requires NAT to be true.')\n\n    # log options\n    if module.params['logtraffic_start']:\n        if not module.params['logtraffic'] == 'all':\n            module.fail_json(msg='Logtraffic_start param requires logtraffic to be set to \"all\".')\n\n    # id must be str(int) for pyFG to work\n    policy_id = str(module.params['id'])\n\n    # load config\n    fortigate.load_config(config_path)\n\n    # Absent State\n    if module.params['state'] == 'absent':\n        fortigate.candidate_config[config_path].del_block(policy_id)\n\n    # Present state\n    elif module.params['state'] == 'present':\n        new_policy = fortigate.get_empty_configuration_block(policy_id, 'edit')\n\n        # src / dest / service / interfaces\n        new_policy.set_param('srcintf', \" \".join('\"' + item + '\"' for item in module.params['src_intf']))\n        new_policy.set_param('dstintf', \" \".join('\"' + item + '\"' for item in module.params['dst_intf']))\n\n        new_policy.set_param('srcaddr', \" \".join('\"' + item + '\"' for item in module.params['src_addr']))\n        new_policy.set_param('dstaddr', \" \".join('\"' + item + '\"' for item in module.params['dst_addr']))\n        new_policy.set_param('service', \" \".join('\"' + item + '\"' for item in module.params['service']))\n\n        # negate src / dest / service\n        if module.params['src_addr_negate']:\n            new_policy.set_param('srcaddr-negate', 'enable')\n        if module.params['dst_addr_negate']:\n            new_policy.set_param('dstaddr-negate', 'enable')\n        if module.params['service_negate']:\n            new_policy.set_param('service-negate', 'enable')\n\n        # action\n        new_policy.set_param('action', '%s' % (module.params['policy_action']))\n\n        # logging\n        new_policy.set_param('logtraffic', '%s' % (module.params['logtraffic']))\n        if module.params['logtraffic'] == 'all':\n            if module.params['logtraffic_start']:\n                new_policy.set_param('logtraffic-start', 'enable')\n            else:\n                new_policy.set_param('logtraffic-start', 'disable')\n\n        # Schedule\n        new_policy.set_param('schedule', '%s' % (module.params['schedule']))\n\n        # NAT\n        if module.params['nat']:\n            new_policy.set_param('nat', 'enable')\n            if module.params['fixedport']:\n                new_policy.set_param('fixedport', 'enable')\n            if module.params['poolname'] is not None:\n                new_policy.set_param('ippool', 'enable')\n                new_policy.set_param('poolname', '\"%s\"' % (module.params['poolname']))\n\n        # security profiles:\n        if module.params['av_profile'] is not None:\n            new_policy.set_param('av-profile', '\"%s\"' % (module.params['av_profile']))\n        if module.params['webfilter_profile'] is not None:\n            new_policy.set_param('webfilter-profile', '\"%s\"' % (module.params['webfilter_profile']))\n        if module.params['ips_sensor'] is not None:\n            new_policy.set_param('ips-sensor', '\"%s\"' % (module.params['ips_sensor']))\n        if module.params['application_list'] is not None:\n            new_policy.set_param('application-list', '\"%s\"' % (module.params['application_list']))\n\n        # comment\n        if module.params['comment'] is not None:\n            new_policy.set_param('comment', '\"%s\"' % (module.params['comment']))\n\n        # add the new policy to the device\n        fortigate.add_block(policy_id, new_policy)\n\n    # Apply changes\n    fortigate.apply_changes()\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "fortios_ipv4_policy.py", "id": "74e90eef630aa313d82e1670381f81ad", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/network/fortios/fortios_ipv4_policy.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}