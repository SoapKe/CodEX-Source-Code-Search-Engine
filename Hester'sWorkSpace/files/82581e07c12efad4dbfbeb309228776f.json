{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\nfrom datetime import datetime\nfrom dateutil.relativedelta import relativedelta\n\nfrom odoo import api, fields, models, tools\n\n\n_INTERVALS = {\n    'hours': lambda interval: relativedelta(hours=interval),\n    'days': lambda interval: relativedelta(days=interval),\n    'weeks': lambda interval: relativedelta(days=7*interval),\n    'months': lambda interval: relativedelta(months=interval),\n    'now': lambda interval: relativedelta(hours=0),\n}\n\n\nclass EventTypeMail(models.Model):\n    \"\"\" Template of event.mail to attach to event.type. Those will be copied\n    upon all events created in that type to ease event creation. \"\"\"\n    _name = 'event.type.mail'\n    _description = 'Mail Scheduling on Event Type'\n\n    event_type_id = fields.Many2one(\n        'event.type', string='Event Type',\n        ondelete='cascade', required=True)\n    interval_nbr = fields.Integer('Interval', default=1)\n    interval_unit = fields.Selection([\n        ('now', 'Immediately'),\n        ('hours', 'Hour(s)'), ('days', 'Day(s)'),\n        ('weeks', 'Week(s)'), ('months', 'Month(s)')],\n        string='Unit', default='hours', required=True)\n    interval_type = fields.Selection([\n        ('after_sub', 'After each registration'),\n        ('before_event', 'Before the event'),\n        ('after_event', 'After the event')],\n        string='Trigger', default=\"before_event\", required=True)\n    template_id = fields.Many2one(\n        'mail.template', string='Email Template',\n        domain=[('model', '=', 'event.registration')], required=True, ondelete='restrict',\n        help='This field contains the template of the mail that will be automatically sent')\n\n\nclass EventMailScheduler(models.Model):\n    \"\"\" Event automated mailing. This model replaces all existing fields and\n    configuration allowing to send emails on events since Odoo 9. A cron exists\n    that periodically checks for mailing to run. \"\"\"\n    _name = 'event.mail'\n    _rec_name = 'event_id'\n    _description = 'Event Automated Mailing'\n\n    event_id = fields.Many2one('event.event', string='Event', required=True, ondelete='cascade')\n    sequence = fields.Integer('Display order')\n    interval_nbr = fields.Integer('Interval', default=1)\n    interval_unit = fields.Selection([\n        ('now', 'Immediately'),\n        ('hours', 'Hour(s)'), ('days', 'Day(s)'),\n        ('weeks', 'Week(s)'), ('months', 'Month(s)')],\n        string='Unit', default='hours', required=True)\n    interval_type = fields.Selection([\n        ('after_sub', 'After each registration'),\n        ('before_event', 'Before the event'),\n        ('after_event', 'After the event')],\n        string='Trigger ', default=\"before_event\", required=True)\n    template_id = fields.Many2one(\n        'mail.template', string='Email Template',\n        domain=[('model', '=', 'event.registration')], required=True, ondelete='restrict',\n        help='This field contains the template of the mail that will be automatically sent')\n    scheduled_date = fields.Datetime('Scheduled Sent Mail', compute='_compute_scheduled_date', store=True)\n    mail_registration_ids = fields.One2many('event.mail.registration', 'scheduler_id')\n    mail_sent = fields.Boolean('Mail Sent on Event')\n    done = fields.Boolean('Sent', compute='_compute_done', store=True)\n\n    @api.one\n    @api.depends('mail_sent', 'interval_type', 'event_id.registration_ids', 'mail_registration_ids')\n    def _compute_done(self):\n        if self.interval_type in ['before_event', 'after_event']:\n            self.done = self.mail_sent\n        else:\n            self.done = len(self.mail_registration_ids) == len(self.event_id.registration_ids) and all(mail.mail_sent for mail in self.mail_registration_ids)\n\n    @api.one\n    @api.depends('event_id.state', 'event_id.date_begin', 'interval_type', 'interval_unit', 'interval_nbr')\n    def _compute_scheduled_date(self):\n        if self.event_id.state not in ['confirm', 'done']:\n            self.scheduled_date = False\n        else:\n            if self.interval_type == 'after_sub':\n                date, sign = self.event_id.create_date, 1\n            elif self.interval_type == 'before_event':\n                date, sign = self.event_id.date_begin, -1\n            else:\n                date, sign = self.event_id.date_end, 1\n\n            self.scheduled_date = datetime.strptime(date, tools.DEFAULT_SERVER_DATETIME_FORMAT) + _INTERVALS[self.interval_unit](sign * self.interval_nbr)\n\n    @api.one\n    def execute(self):\n        now = fields.Datetime.now()\n        if self.interval_type == 'after_sub':\n            \n            lines = [\n                (0, 0, {'registration_id': registration.id})\n                for registration in (self.event_id.registration_ids - self.mapped('mail_registration_ids.registration_id'))\n            ]\n            if lines:\n                self.write({'mail_registration_ids': lines})\n            \n            self.mail_registration_ids.filtered(lambda reg: reg.scheduled_date and reg.scheduled_date <= now).execute()\n        else:\n            \n            if not self.mail_sent and (self.interval_type != 'before_event' or self.event_id.date_end > now):\n                self.event_id.mail_attendees(self.template_id.id)\n                self.write({'mail_sent': True})\n        return True\n\n    @api.model\n    def run(self, autocommit=False):\n        schedulers = self.search([('done', '=', False), ('scheduled_date', '<=', datetime.strftime(fields.datetime.now(), tools.DEFAULT_SERVER_DATETIME_FORMAT))])\n        for scheduler in schedulers:\n            scheduler.execute()\n            if autocommit:\n                self.env.cr.commit()\n        return True\n\n\nclass EventMailRegistration(models.Model):\n    _name = 'event.mail.registration'\n    _description = 'Registration Mail Scheduler'\n    _rec_name = 'scheduler_id'\n    _order = 'scheduled_date DESC'\n\n    scheduler_id = fields.Many2one('event.mail', 'Mail Scheduler', required=True, ondelete='cascade')\n    registration_id = fields.Many2one('event.registration', 'Attendee', required=True, ondelete='cascade')\n    scheduled_date = fields.Datetime('Scheduled Time', compute='_compute_scheduled_date', store=True)\n    mail_sent = fields.Boolean('Mail Sent')\n\n    @api.one\n    def execute(self):\n        if self.registration_id.state in ['open', 'done'] and not self.mail_sent:\n            self.scheduler_id.template_id.send_mail(self.registration_id.id)\n            self.write({'mail_sent': True})\n\n    @api.one\n    @api.depends('registration_id', 'scheduler_id.interval_unit', 'scheduler_id.interval_type')\n    def _compute_scheduled_date(self):\n        if self.registration_id:\n            date_open = self.registration_id.date_open\n            date_open_datetime = date_open and datetime.strptime(date_open, tools.DEFAULT_SERVER_DATETIME_FORMAT) or fields.datetime.now()\n            self.scheduled_date = date_open_datetime + _INTERVALS[self.scheduler_id.interval_unit](self.scheduler_id.interval_nbr)\n        else:\n            self.scheduled_date = False\n", "comments": "    template event mail attach event type  those copied     upon events created type ease event creation           name    event type mail       description    mail scheduling event type       event type id   fields many2one(          event type   string  event type           ondelete  cascade   required true)     interval nbr   fields integer( interval   default 1)     interval unit   fields selection(          (    immediately )          ( hours    hour(s) )  ( days    day(s) )          ( weeks    week(s) )  ( months    month(s) )           string  unit   default  hours   required true)     interval type   fields selection(          ( sub    after registration )          ( event    before event )          ( event    after event )           string  trigger   default  event   required true)     template id   fields many2one(          mail template   string  email template           domain  ( model         event registration )   required true  ondelete  restrict           help  this field contains template mail automatically sent )   class eventmailscheduler(models model)          event automated mailing  this model replaces existing fields     configuration allowing send emails events since odoo 9  a cron exists     periodically checks mailing run             coding  utf 8        update registration lines    execute scheduler registrations    do send emails mailing scheduled event event ", "content": "# -*- coding: utf-8 -*-\n\nfrom datetime import datetime\nfrom dateutil.relativedelta import relativedelta\n\nfrom odoo import api, fields, models, tools\n\n\n_INTERVALS = {\n    'hours': lambda interval: relativedelta(hours=interval),\n    'days': lambda interval: relativedelta(days=interval),\n    'weeks': lambda interval: relativedelta(days=7*interval),\n    'months': lambda interval: relativedelta(months=interval),\n    'now': lambda interval: relativedelta(hours=0),\n}\n\n\nclass EventTypeMail(models.Model):\n    \"\"\" Template of event.mail to attach to event.type. Those will be copied\n    upon all events created in that type to ease event creation. \"\"\"\n    _name = 'event.type.mail'\n    _description = 'Mail Scheduling on Event Type'\n\n    event_type_id = fields.Many2one(\n        'event.type', string='Event Type',\n        ondelete='cascade', required=True)\n    interval_nbr = fields.Integer('Interval', default=1)\n    interval_unit = fields.Selection([\n        ('now', 'Immediately'),\n        ('hours', 'Hour(s)'), ('days', 'Day(s)'),\n        ('weeks', 'Week(s)'), ('months', 'Month(s)')],\n        string='Unit', default='hours', required=True)\n    interval_type = fields.Selection([\n        ('after_sub', 'After each registration'),\n        ('before_event', 'Before the event'),\n        ('after_event', 'After the event')],\n        string='Trigger', default=\"before_event\", required=True)\n    template_id = fields.Many2one(\n        'mail.template', string='Email Template',\n        domain=[('model', '=', 'event.registration')], required=True, ondelete='restrict',\n        help='This field contains the template of the mail that will be automatically sent')\n\n\nclass EventMailScheduler(models.Model):\n    \"\"\" Event automated mailing. This model replaces all existing fields and\n    configuration allowing to send emails on events since Odoo 9. A cron exists\n    that periodically checks for mailing to run. \"\"\"\n    _name = 'event.mail'\n    _rec_name = 'event_id'\n    _description = 'Event Automated Mailing'\n\n    event_id = fields.Many2one('event.event', string='Event', required=True, ondelete='cascade')\n    sequence = fields.Integer('Display order')\n    interval_nbr = fields.Integer('Interval', default=1)\n    interval_unit = fields.Selection([\n        ('now', 'Immediately'),\n        ('hours', 'Hour(s)'), ('days', 'Day(s)'),\n        ('weeks', 'Week(s)'), ('months', 'Month(s)')],\n        string='Unit', default='hours', required=True)\n    interval_type = fields.Selection([\n        ('after_sub', 'After each registration'),\n        ('before_event', 'Before the event'),\n        ('after_event', 'After the event')],\n        string='Trigger ', default=\"before_event\", required=True)\n    template_id = fields.Many2one(\n        'mail.template', string='Email Template',\n        domain=[('model', '=', 'event.registration')], required=True, ondelete='restrict',\n        help='This field contains the template of the mail that will be automatically sent')\n    scheduled_date = fields.Datetime('Scheduled Sent Mail', compute='_compute_scheduled_date', store=True)\n    mail_registration_ids = fields.One2many('event.mail.registration', 'scheduler_id')\n    mail_sent = fields.Boolean('Mail Sent on Event')\n    done = fields.Boolean('Sent', compute='_compute_done', store=True)\n\n    @api.one\n    @api.depends('mail_sent', 'interval_type', 'event_id.registration_ids', 'mail_registration_ids')\n    def _compute_done(self):\n        if self.interval_type in ['before_event', 'after_event']:\n            self.done = self.mail_sent\n        else:\n            self.done = len(self.mail_registration_ids) == len(self.event_id.registration_ids) and all(mail.mail_sent for mail in self.mail_registration_ids)\n\n    @api.one\n    @api.depends('event_id.state', 'event_id.date_begin', 'interval_type', 'interval_unit', 'interval_nbr')\n    def _compute_scheduled_date(self):\n        if self.event_id.state not in ['confirm', 'done']:\n            self.scheduled_date = False\n        else:\n            if self.interval_type == 'after_sub':\n                date, sign = self.event_id.create_date, 1\n            elif self.interval_type == 'before_event':\n                date, sign = self.event_id.date_begin, -1\n            else:\n                date, sign = self.event_id.date_end, 1\n\n            self.scheduled_date = datetime.strptime(date, tools.DEFAULT_SERVER_DATETIME_FORMAT) + _INTERVALS[self.interval_unit](sign * self.interval_nbr)\n\n    @api.one\n    def execute(self):\n        now = fields.Datetime.now()\n        if self.interval_type == 'after_sub':\n            # update registration lines\n            lines = [\n                (0, 0, {'registration_id': registration.id})\n                for registration in (self.event_id.registration_ids - self.mapped('mail_registration_ids.registration_id'))\n            ]\n            if lines:\n                self.write({'mail_registration_ids': lines})\n            # execute scheduler on registrations\n            self.mail_registration_ids.filtered(lambda reg: reg.scheduled_date and reg.scheduled_date <= now).execute()\n        else:\n            # Do not send emails if the mailing was scheduled before the event but the event is over\n            if not self.mail_sent and (self.interval_type != 'before_event' or self.event_id.date_end > now):\n                self.event_id.mail_attendees(self.template_id.id)\n                self.write({'mail_sent': True})\n        return True\n\n    @api.model\n    def run(self, autocommit=False):\n        schedulers = self.search([('done', '=', False), ('scheduled_date', '<=', datetime.strftime(fields.datetime.now(), tools.DEFAULT_SERVER_DATETIME_FORMAT))])\n        for scheduler in schedulers:\n            scheduler.execute()\n            if autocommit:\n                self.env.cr.commit()\n        return True\n\n\nclass EventMailRegistration(models.Model):\n    _name = 'event.mail.registration'\n    _description = 'Registration Mail Scheduler'\n    _rec_name = 'scheduler_id'\n    _order = 'scheduled_date DESC'\n\n    scheduler_id = fields.Many2one('event.mail', 'Mail Scheduler', required=True, ondelete='cascade')\n    registration_id = fields.Many2one('event.registration', 'Attendee', required=True, ondelete='cascade')\n    scheduled_date = fields.Datetime('Scheduled Time', compute='_compute_scheduled_date', store=True)\n    mail_sent = fields.Boolean('Mail Sent')\n\n    @api.one\n    def execute(self):\n        if self.registration_id.state in ['open', 'done'] and not self.mail_sent:\n            self.scheduler_id.template_id.send_mail(self.registration_id.id)\n            self.write({'mail_sent': True})\n\n    @api.one\n    @api.depends('registration_id', 'scheduler_id.interval_unit', 'scheduler_id.interval_type')\n    def _compute_scheduled_date(self):\n        if self.registration_id:\n            date_open = self.registration_id.date_open\n            date_open_datetime = date_open and datetime.strptime(date_open, tools.DEFAULT_SERVER_DATETIME_FORMAT) or fields.datetime.now()\n            self.scheduled_date = date_open_datetime + _INTERVALS[self.scheduler_id.interval_unit](self.scheduler_id.interval_nbr)\n        else:\n            self.scheduled_date = False\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "event_mail.py", "id": "82581e07c12efad4dbfbeb309228776f", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/event/models/event_mail.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}