{"author": "chubin", "code": "import logging\nimport os\nimport re\nimport requests\nimport socket\nimport time\n\nimport geoip2.database\nfrom geopy.geocoders import Nominatim\nimport jinja2\n\nfrom gevent.wsgi import WSGIServer\nfrom gevent.monkey import patch_all\nfrom gevent.subprocess import Popen, PIPE\npatch_all()\n\nimport dns.resolver\nfrom dns.exception import DNSException\n\nfrom flask import Flask, request, render_template, send_from_directory\napp = Flask(__name__)\n\nMYDIR = os.environ.get('WTTR_MYDIR', os.path.abspath(os.path.dirname( os.path.dirname('__file__') )))\nGEOLITE = os.environ.get('WTTR_GEOLITE', os.path.join( MYDIR, \"GeoLite2-City.mmdb\" ))\nWEGO = os.environ.get('WTTR_WEGO', \"/home/igor/go/bin/wego\")\nLISTEN_HOST = os.environ.get('WTTR_LISTEN_HOST', \"127.0.0.1\")\nLISTEN_PORT = int(os.environ.get('WTTR_LISTEN_PORT', \"8002\"))\n\nCACHEDIR  = os.path.join( MYDIR, \"cache\" )\nIP2LCACHE = os.path.join( MYDIR, \"cache/ip2l\" )\nALIASES   = os.path.join( MYDIR, \"share/aliases\" )\nANSI2HTML = os.path.join( MYDIR, \"share/ansi2html.sh\" )\nHELP_FILE = os.path.join( MYDIR, 'share/help.txt' )\nLOG_FILE  = os.path.join( MYDIR, 'log/main.log' )\nTEMPLATES = os.path.join( MYDIR, 'share/templates' )\nSTATIC    = os.path.join( MYDIR, 'share/static' )\n\nNOT_FOUND_LOCATION = \"NOT_FOUND\"\nDEFAULT_LOCATION = \"Oymyakon\"\n\nNOT_FOUND_MESSAGE = \nPLAIN_TEXT_AGENTS = [\n    \"curl\",\n    \"httpie\",\n    \"lwp-request\",\n    \"wget\",\n    \"python-requests\"\n]\n\nif not os.path.exists(os.path.dirname( LOG_FILE )):\n    os.makedirs( os.path.dirname( LOG_FILE ) )\nlogging.basicConfig(filename=LOG_FILE, level=logging.DEBUG)\n\nreader = geoip2.database.Reader(GEOLITE)\ngeolocator = Nominatim()\n\nmy_loader = jinja2.ChoiceLoader([\n    app.jinja_loader,\n    jinja2.FileSystemLoader(TEMPLATES),\n])\napp.jinja_loader = my_loader\n\n\nclass Limits:\n    def __init__( self ):\n        self.intervals = [ 'min', 'hour', 'day' ]\n        self.divisor = {\n            'min':      60,\n            'hour':     3600,\n            'day':      86400,\n            }\n        self.counter = {\n            'min':      {},\n            'hour':     {},\n            'day':      {},  \n            }\n        self.limit = {\n            'min':      10,\n            'hour':     20,\n            'day':      100,\n            }\n        self.last_update = {\n            'min':      0,\n            'hour':     0,\n            'day':      0,\n            }\n        self.clear_counters()\n\n    def check_ip( self, ip ):\n        self.clear_counters()\n        for interval in self.intervals:\n            if ip not in self.counter[interval]:\n                self.counter[interval][ip] = 0\n            self.counter[interval][ip] += 1\n            if self.limit[interval] <= self.counter[interval][ip]:\n                log(\"Too many queries: %s in %s for %s\" % (self.limit[interval], interval, ip) )\n                raise RuntimeError(\"Not so fast! Number of queries per %s is limited to %s\" % (interval, self.limit[interval]))\n            print self.counter\n\n    def clear_counters( self ):\n        t = int( time.time() )\n        for interval in self.intervals:\n            if t / self.divisor[interval] != self.last_update[interval]:\n                self.counter[interval] = {}\n                self.last_update[interval] = t / self.divisor[interval]\n        \n\nlimits = Limits()\n\ndef error( text ):\n    print text\n    raise RuntimeError(text)\n\ndef log( text ):\n    print text.encode('utf-8')\n    logging.info( text.encode('utf-8') )\n\ndef is_ip( ip ):\n    if re.match('\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}', ip) is None:\n        return False\n    try:\n        socket.inet_aton(ip)\n        return True\n    except socket.error:\n        return False\n\ndef save_weather_data( location, filename ):\n\n    if location == NOT_FOUND_LOCATION:\n        location_not_found = True\n        location = DEFAULT_LOCATION\n    else:\n        location_not_found = False\n    p = Popen( [ WEGO, '-location=%s' % location ], stdout=PIPE, stderr=PIPE )\n    stdout, stderr = p.communicate()\n    if p.returncode != 0:\n        error( stdout + stderr )\n\n    dirname = os.path.dirname( filename )\n    if not os.path.exists( dirname ):\n        os.makedirs( dirname )\n    \n    if location_not_found:\n        stdout += NOT_FOUND_MESSAGE\n\n    open( filename, 'w' ).write( stdout )\n\n    p = Popen( [ \"bash\", ANSI2HTML, \"--palette=solarized\", \"--bg=dark\" ],  stdin=PIPE, stdout=PIPE, stderr=PIPE )\n    stdout, stderr = p.communicate( stdout )\n    if p.returncode != 0:\n        error( stdout + stderr )\n\n    open( filename+'.html', 'w' ).write( stdout )\n\ndef get_filename( location ):\n    location = location.replace('/', '_')\n    timestamp = time.strftime( \"%Y%m%d%H\", time.localtime() )\n    return \"%s/%s/%s\" % ( CACHEDIR, location, timestamp )\n\ndef get_wetter(location, ip, html=False):\n    filename = get_filename( location )\n    if not os.path.exists( filename ):\n        limits.check_ip( ip )\n        save_weather_data( location, filename )\n    if html:\n        filename += '.html'\n    return open(filename).read()\n\n\ndef ip2location( ip ):\n    cached = os.path.join( IP2LCACHE, ip )\n\n    if os.path.exists( cached ):\n        return open( cached, 'r' ).read()\n\n    try:\n        t = requests.get( 'http://api.ip2location.com/?ip=%s&key=demo&package=WS10' % ip ).text\n        if ';' in t:\n            location = t.split(';')[3]\n            if not os.path.exists( IP2LCACHE ):\n                os.makedirs( IP2LCACHE )\n            open( cached, 'w' ).write( location )\n            return location\n    except:\n            pass\n\ndef get_location( ip_addr ):\n    response = reader.city( ip_addr )\n    city = response.city.name\n    if city is None and response.location:\n        coord = \"%s, %s\" % (response.location.latitude, response.location.longitude)\n        location = geolocator.reverse(coord, language='en')\n        city = location.raw.get('address', {}).get('city')\n    if city is None:\n        print ip_addr\n        city = ip2location( ip_addr )\n    return city or NOT_FOUND_LOCATION\n\ndef load_aliases( aliases_filename ):\n    aliases_db = {}\n    with open( aliases_filename, 'r' ) as f:\n        for line in f.readlines():\n            from_, to_ = line.split(':', 1)\n            aliases_db[ from_.strip().lower() ] = to_.strip()\n    return aliases_db\n\nlocation_alias = load_aliases( ALIASES )\ndef location_canonical_name( location ):\n    if location.lower() in location_alias:\n        return location_alias[location.lower()]\n    return location\n\ndef show_help():\n    return open(HELP_FILE, 'r').read()\n\n@app.route('/files/<path:path>')\ndef send_static(path):\n    return send_from_directory(STATIC, path)\n\n@app.route('/favicon.ico')\ndef send_favicon():\n    return send_from_directory(STATIC, 'favicon.ico')\n\n@app.route(\"/\")\n@app.route(\"/<string:location>\")\ndef wttr(location = None):\n\n    user_agent = request.headers.get('User-Agent').lower()\n\n    if any(agent in user_agent for agent in PLAIN_TEXT_AGENTS):\n        html_output = False\n    else:\n        html_output = True\n\n\n    if location == ':help':\n        help_ = show_help()\n        if html_output:\n            return render_template( 'index.html', body=help_ )\n        else:\n            return help_\n\n    orig_location = location\n\n    if request.headers.getlist(\"X-Forwarded-For\"):\n        ip = request.headers.getlist(\"X-Forwarded-For\")[0]\n        if ip.startswith('::ffff:'):\n            ip = ip[7:]\n    else:\n        ip = request.remote_addr\n\n    try:\n        if location is None:\n            location = get_location( ip )\n\n        if is_ip( location ):\n            location = get_location( location )\n        if location.startswith('@'):\n            try:\n                loc = dns.resolver.query( location[1:], 'LOC' )\n                location = str(\"%.7f,%.7f\" % (loc[0].float_latitude, loc[0].float_longitude))\n            except DNSException, e:\n                location = get_location( socket.gethostbyname( location[1:] ) )\n\n        location = location_canonical_name( location )\n        log(\"%s %s %s %s\" % (ip, user_agent, orig_location, location))\n        return get_wetter( location, ip, html=html_output )\n    except Exception, e:\n        logging.error(\"Exception has occurred\", exc_info=1)\n        return str(e).rstrip()+\"\\n\"\n\nserver = WSGIServer((LISTEN_HOST, LISTEN_PORT), app)\nserver.serve_forever()\n\n", "comments": "    we unable find location  brought oymyakon  one coldest permanently inhabited locales planet      ", "content": "import logging\nimport os\nimport re\nimport requests\nimport socket\nimport time\n\nimport geoip2.database\nfrom geopy.geocoders import Nominatim\nimport jinja2\n\nfrom gevent.wsgi import WSGIServer\nfrom gevent.monkey import patch_all\nfrom gevent.subprocess import Popen, PIPE\npatch_all()\n\nimport dns.resolver\nfrom dns.exception import DNSException\n\nfrom flask import Flask, request, render_template, send_from_directory\napp = Flask(__name__)\n\nMYDIR = os.environ.get('WTTR_MYDIR', os.path.abspath(os.path.dirname( os.path.dirname('__file__') )))\nGEOLITE = os.environ.get('WTTR_GEOLITE', os.path.join( MYDIR, \"GeoLite2-City.mmdb\" ))\nWEGO = os.environ.get('WTTR_WEGO', \"/home/igor/go/bin/wego\")\nLISTEN_HOST = os.environ.get('WTTR_LISTEN_HOST', \"127.0.0.1\")\nLISTEN_PORT = int(os.environ.get('WTTR_LISTEN_PORT', \"8002\"))\n\nCACHEDIR  = os.path.join( MYDIR, \"cache\" )\nIP2LCACHE = os.path.join( MYDIR, \"cache/ip2l\" )\nALIASES   = os.path.join( MYDIR, \"share/aliases\" )\nANSI2HTML = os.path.join( MYDIR, \"share/ansi2html.sh\" )\nHELP_FILE = os.path.join( MYDIR, 'share/help.txt' )\nLOG_FILE  = os.path.join( MYDIR, 'log/main.log' )\nTEMPLATES = os.path.join( MYDIR, 'share/templates' )\nSTATIC    = os.path.join( MYDIR, 'share/static' )\n\nNOT_FOUND_LOCATION = \"NOT_FOUND\"\nDEFAULT_LOCATION = \"Oymyakon\"\n\nNOT_FOUND_MESSAGE = \"\"\"\nWe were unable to find your location,\nso we have brought you to Oymyakon,\none of the coldest permanently inhabited locales on the planet.\n\"\"\"\nPLAIN_TEXT_AGENTS = [\n    \"curl\",\n    \"httpie\",\n    \"lwp-request\",\n    \"wget\",\n    \"python-requests\"\n]\n\nif not os.path.exists(os.path.dirname( LOG_FILE )):\n    os.makedirs( os.path.dirname( LOG_FILE ) )\nlogging.basicConfig(filename=LOG_FILE, level=logging.DEBUG)\n\nreader = geoip2.database.Reader(GEOLITE)\ngeolocator = Nominatim()\n\nmy_loader = jinja2.ChoiceLoader([\n    app.jinja_loader,\n    jinja2.FileSystemLoader(TEMPLATES),\n])\napp.jinja_loader = my_loader\n\n\nclass Limits:\n    def __init__( self ):\n        self.intervals = [ 'min', 'hour', 'day' ]\n        self.divisor = {\n            'min':      60,\n            'hour':     3600,\n            'day':      86400,\n            }\n        self.counter = {\n            'min':      {},\n            'hour':     {},\n            'day':      {},  \n            }\n        self.limit = {\n            'min':      10,\n            'hour':     20,\n            'day':      100,\n            }\n        self.last_update = {\n            'min':      0,\n            'hour':     0,\n            'day':      0,\n            }\n        self.clear_counters()\n\n    def check_ip( self, ip ):\n        self.clear_counters()\n        for interval in self.intervals:\n            if ip not in self.counter[interval]:\n                self.counter[interval][ip] = 0\n            self.counter[interval][ip] += 1\n            if self.limit[interval] <= self.counter[interval][ip]:\n                log(\"Too many queries: %s in %s for %s\" % (self.limit[interval], interval, ip) )\n                raise RuntimeError(\"Not so fast! Number of queries per %s is limited to %s\" % (interval, self.limit[interval]))\n            print self.counter\n\n    def clear_counters( self ):\n        t = int( time.time() )\n        for interval in self.intervals:\n            if t / self.divisor[interval] != self.last_update[interval]:\n                self.counter[interval] = {}\n                self.last_update[interval] = t / self.divisor[interval]\n        \n\nlimits = Limits()\n\ndef error( text ):\n    print text\n    raise RuntimeError(text)\n\ndef log( text ):\n    print text.encode('utf-8')\n    logging.info( text.encode('utf-8') )\n\ndef is_ip( ip ):\n    if re.match('\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}', ip) is None:\n        return False\n    try:\n        socket.inet_aton(ip)\n        return True\n    except socket.error:\n        return False\n\ndef save_weather_data( location, filename ):\n\n    if location == NOT_FOUND_LOCATION:\n        location_not_found = True\n        location = DEFAULT_LOCATION\n    else:\n        location_not_found = False\n    p = Popen( [ WEGO, '-location=%s' % location ], stdout=PIPE, stderr=PIPE )\n    stdout, stderr = p.communicate()\n    if p.returncode != 0:\n        error( stdout + stderr )\n\n    dirname = os.path.dirname( filename )\n    if not os.path.exists( dirname ):\n        os.makedirs( dirname )\n    \n    if location_not_found:\n        stdout += NOT_FOUND_MESSAGE\n\n    open( filename, 'w' ).write( stdout )\n\n    p = Popen( [ \"bash\", ANSI2HTML, \"--palette=solarized\", \"--bg=dark\" ],  stdin=PIPE, stdout=PIPE, stderr=PIPE )\n    stdout, stderr = p.communicate( stdout )\n    if p.returncode != 0:\n        error( stdout + stderr )\n\n    open( filename+'.html', 'w' ).write( stdout )\n\ndef get_filename( location ):\n    location = location.replace('/', '_')\n    timestamp = time.strftime( \"%Y%m%d%H\", time.localtime() )\n    return \"%s/%s/%s\" % ( CACHEDIR, location, timestamp )\n\ndef get_wetter(location, ip, html=False):\n    filename = get_filename( location )\n    if not os.path.exists( filename ):\n        limits.check_ip( ip )\n        save_weather_data( location, filename )\n    if html:\n        filename += '.html'\n    return open(filename).read()\n\n\ndef ip2location( ip ):\n    cached = os.path.join( IP2LCACHE, ip )\n\n    if os.path.exists( cached ):\n        return open( cached, 'r' ).read()\n\n    try:\n        t = requests.get( 'http://api.ip2location.com/?ip=%s&key=demo&package=WS10' % ip ).text\n        if ';' in t:\n            location = t.split(';')[3]\n            if not os.path.exists( IP2LCACHE ):\n                os.makedirs( IP2LCACHE )\n            open( cached, 'w' ).write( location )\n            return location\n    except:\n            pass\n\ndef get_location( ip_addr ):\n    response = reader.city( ip_addr )\n    city = response.city.name\n    if city is None and response.location:\n        coord = \"%s, %s\" % (response.location.latitude, response.location.longitude)\n        location = geolocator.reverse(coord, language='en')\n        city = location.raw.get('address', {}).get('city')\n    if city is None:\n        print ip_addr\n        city = ip2location( ip_addr )\n    return city or NOT_FOUND_LOCATION\n\ndef load_aliases( aliases_filename ):\n    aliases_db = {}\n    with open( aliases_filename, 'r' ) as f:\n        for line in f.readlines():\n            from_, to_ = line.split(':', 1)\n            aliases_db[ from_.strip().lower() ] = to_.strip()\n    return aliases_db\n\nlocation_alias = load_aliases( ALIASES )\ndef location_canonical_name( location ):\n    if location.lower() in location_alias:\n        return location_alias[location.lower()]\n    return location\n\ndef show_help():\n    return open(HELP_FILE, 'r').read()\n\n@app.route('/files/<path:path>')\ndef send_static(path):\n    return send_from_directory(STATIC, path)\n\n@app.route('/favicon.ico')\ndef send_favicon():\n    return send_from_directory(STATIC, 'favicon.ico')\n\n@app.route(\"/\")\n@app.route(\"/<string:location>\")\ndef wttr(location = None):\n\n    user_agent = request.headers.get('User-Agent').lower()\n\n    if any(agent in user_agent for agent in PLAIN_TEXT_AGENTS):\n        html_output = False\n    else:\n        html_output = True\n\n\n    if location == ':help':\n        help_ = show_help()\n        if html_output:\n            return render_template( 'index.html', body=help_ )\n        else:\n            return help_\n\n    orig_location = location\n\n    if request.headers.getlist(\"X-Forwarded-For\"):\n        ip = request.headers.getlist(\"X-Forwarded-For\")[0]\n        if ip.startswith('::ffff:'):\n            ip = ip[7:]\n    else:\n        ip = request.remote_addr\n\n    try:\n        if location is None:\n            location = get_location( ip )\n\n        if is_ip( location ):\n            location = get_location( location )\n        if location.startswith('@'):\n            try:\n                loc = dns.resolver.query( location[1:], 'LOC' )\n                location = str(\"%.7f,%.7f\" % (loc[0].float_latitude, loc[0].float_longitude))\n            except DNSException, e:\n                location = get_location( socket.gethostbyname( location[1:] ) )\n\n        location = location_canonical_name( location )\n        log(\"%s %s %s %s\" % (ip, user_agent, orig_location, location))\n        return get_wetter( location, ip, html=html_output )\n    except Exception, e:\n        logging.error(\"Exception has occurred\", exc_info=1)\n        return str(e).rstrip()+\"\\n\"\n\nserver = WSGIServer((LISTEN_HOST, LISTEN_PORT), app)\nserver.serve_forever()\n\n", "description": ":partly_sunny: The right way to check the weather", "file_name": "srv.py", "id": "9ac3467a24479854dfcb0c885b30b7c5", "language": "Python", "project_name": "wttr.in", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/chubin-wttr.in/chubin-wttr.in-b454dd0/bin/srv.py", "save_time": "", "source": "", "update_at": "2018-03-18T15:59:57Z", "url": "https://github.com/chubin/wttr.in", "wiki": true}