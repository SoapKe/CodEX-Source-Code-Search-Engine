{"author": "ansible", "code": " (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n\n This file is part of Ansible\n\n Ansible is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Ansible is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport ast\nimport sys\n\nfrom ansible import constants as C\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils.six.moves import builtins\nfrom ansible.plugins.loader import filter_loader, test_loader\n\n\ndef safe_eval(expr, locals=None, include_exceptions=False):\n    '''\n    This is intended for allowing things like:\n    with_items: a_list_variable\n\n    Where Jinja2 would return a string but we do not want to allow it to\n    call functions (outside of Jinja2, where the env is constrained).\n\n    Based on:\n    http://stackoverflow.com/questions/12523516/using-ast-and-whitelists-to-make-pythons-eval-safe\n    '''\n    locals = {} if locals is None else locals\n\n     define certain JSON types\n     eg. JSON booleans are unknown to python eval()\n    JSON_TYPES = {\n        'false': False,\n        'null': None,\n        'true': True,\n    }\n\n     this is the whitelist of AST nodes we are going to\n     allow in the evaluation. Any node type other than\n     those listed here will raise an exception in our custom\n     visitor class defined below.\n    SAFE_NODES = set(\n        (\n            ast.Add,\n            ast.BinOp,\n             ast.Call,\n            ast.Compare,\n            ast.Dict,\n            ast.Div,\n            ast.Expression,\n            ast.List,\n            ast.Load,\n            ast.Mult,\n            ast.Num,\n            ast.Name,\n            ast.Str,\n            ast.Sub,\n            ast.USub,\n            ast.Tuple,\n            ast.UnaryOp,\n        )\n    )\n\n     AST node types were expanded after 2.6\n    if sys.version_info[:2] >= (2, 7):\n        SAFE_NODES.update(\n            set(\n                (ast.Set,)\n            )\n        )\n\n     And in Python 3.4 too\n    if sys.version_info[:2] >= (3, 4):\n        SAFE_NODES.update(\n            set(\n                (ast.NameConstant,)\n            )\n        )\n\n    filter_list = []\n    for filter in filter_loader.all():\n        filter_list.extend(filter.filters().keys())\n\n    test_list = []\n    for test in test_loader.all():\n        test_list.extend(test.tests().keys())\n\n    CALL_WHITELIST = C.DEFAULT_CALLABLE_WHITELIST + filter_list + test_list\n\n    class CleansingNodeVisitor(ast.NodeVisitor):\n        def generic_visit(self, node, inside_call=False):\n            if type(node) not in SAFE_NODES:\n                raise Exception(\"invalid expression (%s)\" % expr)\n            elif isinstance(node, ast.Call):\n                inside_call = True\n            elif isinstance(node, ast.Name) and inside_call:\n                 Disallow calls to builtin functions that we have not vetted\n                 as safe.  Other functions are excluded by setting locals in\n                 the call to eval() later on\n                if hasattr(builtins, node.id) and node.id not in CALL_WHITELIST:\n                    raise Exception(\"invalid function: %s\" % node.id)\n             iterate over all child nodes\n            for child_node in ast.iter_child_nodes(node):\n                self.generic_visit(child_node, inside_call)\n\n    if not isinstance(expr, string_types):\n         already templated to a datastructure, perhaps?\n        if include_exceptions:\n            return (expr, None)\n        return expr\n\n    cnv = CleansingNodeVisitor()\n    try:\n        parsed_tree = ast.parse(expr, mode='eval')\n        cnv.visit(parsed_tree)\n        compiled = compile(parsed_tree, expr, 'eval')\n         Note: passing our own globals and locals here constrains what\n         callables (and other identifiers) are recognized.  this is in\n         addition to the filtering of builtins done in CleansingNodeVisitor\n        result = eval(compiled, JSON_TYPES, dict(locals))\n\n        if include_exceptions:\n            return (result, None)\n        else:\n            return result\n    except SyntaxError as e:\n         special handling for syntax errors, we just return\n         the expression string back as-is to support late evaluation\n        if include_exceptions:\n            return (expr, None)\n        return expr\n    except Exception as e:\n        if include_exceptions:\n            return (expr, e)\n        return expr\n", "comments": "        this intended allowing things like      items  list variable      where jinja2 would return string want allow     call functions (outside jinja2  env constrained)       based      http   stackoverflow com questions 12523516 using ast whitelists make pythons eval safe            (c) 2012  michael dehaan  michael dehaan gmail com        this file part ansible       ansible free software  redistribute modify    terms gnu general public license published    free software foundation  either version 3 license     (at option) later version        ansible distributed hope useful     without any warranty  without even implied warranty    merchantability fitness for a particular purpose   see    gnu general public license details        you received copy gnu general public license    along ansible   if  see  http   www gnu org licenses       define certain json types    eg  json booleans unknown python eval()    whitelist ast nodes going    allow evaluation  any node type    listed raise exception custom    visitor class defined     ast call     ast node types expanded 2 6    and python 3 4    disallow calls builtin functions vetted    safe   other functions excluded setting locals    call eval() later    iterate child nodes    already templated datastructure  perhaps     note  passing globals locals constrains    callables (and identifiers) recognized      addition filtering builtins done cleansingnodevisitor    special handling syntax errors  return    expression string back support late evaluation ", "content": "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport ast\nimport sys\n\nfrom ansible import constants as C\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils.six.moves import builtins\nfrom ansible.plugins.loader import filter_loader, test_loader\n\n\ndef safe_eval(expr, locals=None, include_exceptions=False):\n    '''\n    This is intended for allowing things like:\n    with_items: a_list_variable\n\n    Where Jinja2 would return a string but we do not want to allow it to\n    call functions (outside of Jinja2, where the env is constrained).\n\n    Based on:\n    http://stackoverflow.com/questions/12523516/using-ast-and-whitelists-to-make-pythons-eval-safe\n    '''\n    locals = {} if locals is None else locals\n\n    # define certain JSON types\n    # eg. JSON booleans are unknown to python eval()\n    JSON_TYPES = {\n        'false': False,\n        'null': None,\n        'true': True,\n    }\n\n    # this is the whitelist of AST nodes we are going to\n    # allow in the evaluation. Any node type other than\n    # those listed here will raise an exception in our custom\n    # visitor class defined below.\n    SAFE_NODES = set(\n        (\n            ast.Add,\n            ast.BinOp,\n            # ast.Call,\n            ast.Compare,\n            ast.Dict,\n            ast.Div,\n            ast.Expression,\n            ast.List,\n            ast.Load,\n            ast.Mult,\n            ast.Num,\n            ast.Name,\n            ast.Str,\n            ast.Sub,\n            ast.USub,\n            ast.Tuple,\n            ast.UnaryOp,\n        )\n    )\n\n    # AST node types were expanded after 2.6\n    if sys.version_info[:2] >= (2, 7):\n        SAFE_NODES.update(\n            set(\n                (ast.Set,)\n            )\n        )\n\n    # And in Python 3.4 too\n    if sys.version_info[:2] >= (3, 4):\n        SAFE_NODES.update(\n            set(\n                (ast.NameConstant,)\n            )\n        )\n\n    filter_list = []\n    for filter in filter_loader.all():\n        filter_list.extend(filter.filters().keys())\n\n    test_list = []\n    for test in test_loader.all():\n        test_list.extend(test.tests().keys())\n\n    CALL_WHITELIST = C.DEFAULT_CALLABLE_WHITELIST + filter_list + test_list\n\n    class CleansingNodeVisitor(ast.NodeVisitor):\n        def generic_visit(self, node, inside_call=False):\n            if type(node) not in SAFE_NODES:\n                raise Exception(\"invalid expression (%s)\" % expr)\n            elif isinstance(node, ast.Call):\n                inside_call = True\n            elif isinstance(node, ast.Name) and inside_call:\n                # Disallow calls to builtin functions that we have not vetted\n                # as safe.  Other functions are excluded by setting locals in\n                # the call to eval() later on\n                if hasattr(builtins, node.id) and node.id not in CALL_WHITELIST:\n                    raise Exception(\"invalid function: %s\" % node.id)\n            # iterate over all child nodes\n            for child_node in ast.iter_child_nodes(node):\n                self.generic_visit(child_node, inside_call)\n\n    if not isinstance(expr, string_types):\n        # already templated to a datastructure, perhaps?\n        if include_exceptions:\n            return (expr, None)\n        return expr\n\n    cnv = CleansingNodeVisitor()\n    try:\n        parsed_tree = ast.parse(expr, mode='eval')\n        cnv.visit(parsed_tree)\n        compiled = compile(parsed_tree, expr, 'eval')\n        # Note: passing our own globals and locals here constrains what\n        # callables (and other identifiers) are recognized.  this is in\n        # addition to the filtering of builtins done in CleansingNodeVisitor\n        result = eval(compiled, JSON_TYPES, dict(locals))\n\n        if include_exceptions:\n            return (result, None)\n        else:\n            return result\n    except SyntaxError as e:\n        # special handling for syntax errors, we just return\n        # the expression string back as-is to support late evaluation\n        if include_exceptions:\n            return (expr, None)\n        return expr\n    except Exception as e:\n        if include_exceptions:\n            return (expr, e)\n        return expr\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "safe_eval.py", "id": "bfe0c04e03d599a5edf57797e222aadf", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/template/safe_eval.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}