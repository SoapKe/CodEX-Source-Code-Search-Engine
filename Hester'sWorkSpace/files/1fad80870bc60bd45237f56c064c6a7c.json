{"author": "rg3", "code": "\n\nimport argparse\nimport ctypes\nimport functools\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nimport threading\nimport traceback\nimport os.path\n\nsys.path.insert(0, os.path.dirname(os.path.dirname((os.path.abspath(__file__)))))\nfrom youtube_dl.compat import (\n    compat_input,\n    compat_http_server,\n    compat_str,\n    compat_urlparse,\n)\n\n\n\ntry:\n    import winreg as compat_winreg\nexcept ImportError:  \n    import _winreg as compat_winreg\n\ntry:\n    import socketserver as compat_socketserver\nexcept ImportError:  \n    import SocketServer as compat_socketserver\n\n\nclass BuildHTTPServer(compat_socketserver.ThreadingMixIn, compat_http_server.HTTPServer):\n    allow_reuse_address = True\n\n\nadvapi32 = ctypes.windll.advapi32\n\nSC_MANAGER_ALL_ACCESS = 0xf003f\nSC_MANAGER_CREATE_SERVICE = 0x02\nSERVICE_WIN32_OWN_PROCESS = 0x10\nSERVICE_AUTO_START = 0x2\nSERVICE_ERROR_NORMAL = 0x1\nDELETE = 0x00010000\nSERVICE_STATUS_START_PENDING = 0x00000002\nSERVICE_STATUS_RUNNING = 0x00000004\nSERVICE_ACCEPT_STOP = 0x1\n\nSVCNAME = 'youtubedl_builder'\n\nLPTSTR = ctypes.c_wchar_p\nSTART_CALLBACK = ctypes.WINFUNCTYPE(None, ctypes.c_int, ctypes.POINTER(LPTSTR))\n\n\nclass SERVICE_TABLE_ENTRY(ctypes.Structure):\n    _fields_ = [\n        ('lpServiceName', LPTSTR),\n        ('lpServiceProc', START_CALLBACK)\n    ]\n\n\nHandlerEx = ctypes.WINFUNCTYPE(\n    ctypes.c_int,     \n    ctypes.c_int,     \n    ctypes.c_int,     \n    ctypes.c_void_p,  \n    ctypes.c_void_p,  \n)\n\n\ndef _ctypes_array(c_type, py_array):\n    ar = (c_type * len(py_array))()\n    ar[:] = py_array\n    return ar\n\n\ndef win_OpenSCManager():\n    res = advapi32.OpenSCManagerW(None, None, SC_MANAGER_ALL_ACCESS)\n    if not res:\n        raise Exception('Opening service manager failed - '\n                        'are you running this as administrator?')\n    return res\n\n\ndef win_install_service(service_name, cmdline):\n    manager = win_OpenSCManager()\n    try:\n        h = advapi32.CreateServiceW(\n            manager, service_name, None,\n            SC_MANAGER_CREATE_SERVICE, SERVICE_WIN32_OWN_PROCESS,\n            SERVICE_AUTO_START, SERVICE_ERROR_NORMAL,\n            cmdline, None, None, None, None, None)\n        if not h:\n            raise OSError('Service creation failed: %s' % ctypes.FormatError())\n\n        advapi32.CloseServiceHandle(h)\n    finally:\n        advapi32.CloseServiceHandle(manager)\n\n\ndef win_uninstall_service(service_name):\n    manager = win_OpenSCManager()\n    try:\n        h = advapi32.OpenServiceW(manager, service_name, DELETE)\n        if not h:\n            raise OSError('Could not find service %s: %s' % (\n                service_name, ctypes.FormatError()))\n\n        try:\n            if not advapi32.DeleteService(h):\n                raise OSError('Deletion failed: %s' % ctypes.FormatError())\n        finally:\n            advapi32.CloseServiceHandle(h)\n    finally:\n        advapi32.CloseServiceHandle(manager)\n\n\ndef win_service_report_event(service_name, msg, is_error=True):\n    with open('C:/sshkeys/log', 'a', encoding='utf-8') as f:\n        f.write(msg + '\\n')\n\n    event_log = advapi32.RegisterEventSourceW(None, service_name)\n    if not event_log:\n        raise OSError('Could not report event: %s' % ctypes.FormatError())\n\n    try:\n        type_id = 0x0001 if is_error else 0x0004\n        event_id = 0xc0000000 if is_error else 0x40000000\n        lines = _ctypes_array(LPTSTR, [msg])\n\n        if not advapi32.ReportEventW(\n                event_log, type_id, 0, event_id, None, len(lines), 0,\n                lines, None):\n            raise OSError('Event reporting failed: %s' % ctypes.FormatError())\n    finally:\n        advapi32.DeregisterEventSource(event_log)\n\n\ndef win_service_handler(stop_event, *args):\n    try:\n        raise ValueError('Handler called with args ' + repr(args))\n        TODO\n    except Exception as e:\n        tb = traceback.format_exc()\n        msg = str(e) + '\\n' + tb\n        win_service_report_event(service_name, msg, is_error=True)\n        raise\n\n\ndef win_service_set_status(handle, status_code):\n    svcStatus = SERVICE_STATUS()\n    svcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS\n    svcStatus.dwCurrentState = status_code\n    svcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP\n\n    svcStatus.dwServiceSpecificExitCode = 0\n\n    if not advapi32.SetServiceStatus(handle, ctypes.byref(svcStatus)):\n        raise OSError('SetServiceStatus failed: %r' % ctypes.FormatError())\n\n\ndef win_service_main(service_name, real_main, argc, argv_raw):\n    try:\n        \n        stop_event = threading.Event()\n        handler = HandlerEx(functools.partial(stop_event, win_service_handler))\n        h = advapi32.RegisterServiceCtrlHandlerExW(service_name, handler, None)\n        if not h:\n            raise OSError('Handler registration failed: %s' %\n                          ctypes.FormatError())\n\n        TODO\n    except Exception as e:\n        tb = traceback.format_exc()\n        msg = str(e) + '\\n' + tb\n        win_service_report_event(service_name, msg, is_error=True)\n        raise\n\n\ndef win_service_start(service_name, real_main):\n    try:\n        cb = START_CALLBACK(\n            functools.partial(win_service_main, service_name, real_main))\n        dispatch_table = _ctypes_array(SERVICE_TABLE_ENTRY, [\n            SERVICE_TABLE_ENTRY(\n                service_name,\n                cb\n            ),\n            SERVICE_TABLE_ENTRY(None, ctypes.cast(None, START_CALLBACK))\n        ])\n\n        if not advapi32.StartServiceCtrlDispatcherW(dispatch_table):\n            raise OSError('ctypes start failed: %s' % ctypes.FormatError())\n    except Exception as e:\n        tb = traceback.format_exc()\n        msg = str(e) + '\\n' + tb\n        win_service_report_event(service_name, msg, is_error=True)\n        raise\n\n\ndef main(args=None):\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-i', '--install',\n                        action='store_const', dest='action', const='install',\n                        help='Launch at Windows startup')\n    parser.add_argument('-u', '--uninstall',\n                        action='store_const', dest='action', const='uninstall',\n                        help='Remove Windows service')\n    parser.add_argument('-s', '--service',\n                        action='store_const', dest='action', const='service',\n                        help='Run as a Windows service')\n    parser.add_argument('-b', '--bind', metavar='<host:port>',\n                        action='store', default='0.0.0.0:8142',\n                        help='Bind to host:port (default %default)')\n    options = parser.parse_args(args=args)\n\n    if options.action == 'install':\n        fn = os.path.abspath(__file__).replace('v:', '\\\\\\\\vboxsrv\\\\vbox')\n        cmdline = '%s %s -s -b %s' % (sys.executable, fn, options.bind)\n        win_install_service(SVCNAME, cmdline)\n        return\n\n    if options.action == 'uninstall':\n        win_uninstall_service(SVCNAME)\n        return\n\n    if options.action == 'service':\n        win_service_start(SVCNAME, main)\n        return\n\n    host, port_str = options.bind.split(':')\n    port = int(port_str)\n\n    print('Listening on %s:%d' % (host, port))\n    srv = BuildHTTPServer((host, port), BuildHTTPRequestHandler)\n    thr = threading.Thread(target=srv.serve_forever)\n    thr.start()\n    compat_input('Press ENTER to shut down')\n    srv.shutdown()\n    thr.join()\n\n\ndef rmtree(path):\n    for name in os.listdir(path):\n        fname = os.path.join(path, name)\n        if os.path.isdir(fname):\n            rmtree(fname)\n        else:\n            os.chmod(fname, 0o666)\n            os.remove(fname)\n    os.rmdir(path)\n\n\nclass BuildError(Exception):\n    def __init__(self, output, code=500):\n        self.output = output\n        self.code = code\n\n    def __str__(self):\n        return self.output\n\n\nclass HTTPError(BuildError):\n    pass\n\n\nclass PythonBuilder(object):\n    def __init__(self, **kwargs):\n        python_version = kwargs.pop('python', '3.4')\n        python_path = None\n        for node in ('Wow6432Node\\\\', ''):\n            try:\n                key = compat_winreg.OpenKey(\n                    compat_winreg.HKEY_LOCAL_MACHINE,\n                    r'SOFTWARE\\%sPython\\PythonCore\\%s\\InstallPath' % (node, python_version))\n                try:\n                    python_path, _ = compat_winreg.QueryValueEx(key, '')\n                finally:\n                    compat_winreg.CloseKey(key)\n                break\n            except Exception:\n                pass\n\n        if not python_path:\n            raise BuildError('No such Python version: %s' % python_version)\n\n        self.pythonPath = python_path\n\n        super(PythonBuilder, self).__init__(**kwargs)\n\n\nclass GITInfoBuilder(object):\n    def __init__(self, **kwargs):\n        try:\n            self.user, self.repoName = kwargs['path'][:2]\n            self.rev = kwargs.pop('rev')\n        except ValueError:\n            raise BuildError('Invalid path')\n        except KeyError as e:\n            raise BuildError('Missing mandatory parameter \"%s\"' % e.args[0])\n\n        path = os.path.join(os.environ['APPDATA'], 'Build archive', self.repoName, self.user)\n        if not os.path.exists(path):\n            os.makedirs(path)\n        self.basePath = tempfile.mkdtemp(dir=path)\n        self.buildPath = os.path.join(self.basePath, 'build')\n\n        super(GITInfoBuilder, self).__init__(**kwargs)\n\n\nclass GITBuilder(GITInfoBuilder):\n    def build(self):\n        try:\n            subprocess.check_output(['git', 'clone', 'git://github.com/%s/%s.git' % (self.user, self.repoName), self.buildPath])\n            subprocess.check_output(['git', 'checkout', self.rev], cwd=self.buildPath)\n        except subprocess.CalledProcessError as e:\n            raise BuildError(e.output)\n\n        super(GITBuilder, self).build()\n\n\nclass YoutubeDLBuilder(object):\n    authorizedUsers = ['fraca7', 'phihag', 'rg3', 'FiloSottile']\n\n    def __init__(self, **kwargs):\n        if self.repoName != 'youtube-dl':\n            raise BuildError('Invalid repository \"%s\"' % self.repoName)\n        if self.user not in self.authorizedUsers:\n            raise HTTPError('Unauthorized user \"%s\"' % self.user, 401)\n\n        super(YoutubeDLBuilder, self).__init__(**kwargs)\n\n    def build(self):\n        try:\n            proc = subprocess.Popen([os.path.join(self.pythonPath, 'python.exe'), 'setup.py', 'py2exe'], stdin=subprocess.PIPE, cwd=self.buildPath)\n            proc.wait()\n            \n            \n        except subprocess.CalledProcessError as e:\n            raise BuildError(e.output)\n\n        super(YoutubeDLBuilder, self).build()\n\n\nclass DownloadBuilder(object):\n    def __init__(self, **kwargs):\n        self.handler = kwargs.pop('handler')\n        self.srcPath = os.path.join(self.buildPath, *tuple(kwargs['path'][2:]))\n        self.srcPath = os.path.abspath(os.path.normpath(self.srcPath))\n        if not self.srcPath.startswith(self.buildPath):\n            raise HTTPError(self.srcPath, 401)\n\n        super(DownloadBuilder, self).__init__(**kwargs)\n\n    def build(self):\n        if not os.path.exists(self.srcPath):\n            raise HTTPError('No such file', 404)\n        if os.path.isdir(self.srcPath):\n            raise HTTPError('Is a directory: %s' % self.srcPath, 401)\n\n        self.handler.send_response(200)\n        self.handler.send_header('Content-Type', 'application/octet-stream')\n        self.handler.send_header('Content-Disposition', 'attachment; filename=%s' % os.path.split(self.srcPath)[-1])\n        self.handler.send_header('Content-Length', str(os.stat(self.srcPath).st_size))\n        self.handler.end_headers()\n\n        with open(self.srcPath, 'rb') as src:\n            shutil.copyfileobj(src, self.handler.wfile)\n\n        super(DownloadBuilder, self).build()\n\n\nclass CleanupTempDir(object):\n    def build(self):\n        try:\n            rmtree(self.basePath)\n        except Exception as e:\n            print('WARNING deleting \"%s\": %s' % (self.basePath, e))\n\n        super(CleanupTempDir, self).build()\n\n\nclass Null(object):\n    def __init__(self, **kwargs):\n        pass\n\n    def start(self):\n        pass\n\n    def close(self):\n        pass\n\n    def build(self):\n        pass\n\n\nclass Builder(PythonBuilder, GITBuilder, YoutubeDLBuilder, DownloadBuilder, CleanupTempDir, Null):\n    pass\n\n\nclass BuildHTTPRequestHandler(compat_http_server.BaseHTTPRequestHandler):\n    actionDict = {'build': Builder, 'download': Builder}  \n\n    def do_GET(self):\n        path = compat_urlparse.urlparse(self.path)\n        paramDict = dict([(key, value[0]) for key, value in compat_urlparse.parse_qs(path.query).items()])\n        action, _, path = path.path.strip('/').partition('/')\n        if path:\n            path = path.split('/')\n            if action in self.actionDict:\n                try:\n                    builder = self.actionDict[action](path=path, handler=self, **paramDict)\n                    builder.start()\n                    try:\n                        builder.build()\n                    finally:\n                        builder.close()\n                except BuildError as e:\n                    self.send_response(e.code)\n                    msg = compat_str(e).encode('UTF-8')\n                    self.send_header('Content-Type', 'text/plain; charset=UTF-8')\n                    self.send_header('Content-Length', len(msg))\n                    self.end_headers()\n                    self.wfile.write(msg)\n            else:\n                self.send_response(500, 'Unknown build method \"%s\"' % action)\n        else:\n            self.send_response(500, 'Malformed URL')\n\nif __name__ == '__main__':\n    main()\n", "comments": "#!/usr/bin/python3\n# These are not used outside of buildserver.py thus not in compat.py\n# Python 2\n# Python 2\n# return\n# dwControl\n# dwEventType\n# lpEventData,\n# lpContext,\n# args = [argv_raw[i].value for i in range(argc)]\n#subprocess.check_output([os.path.join(self.pythonPath, 'python.exe'), 'setup.py', 'py2exe'],\n#                        cwd=self.buildPath)\n# They're the same, no more caching.\n", "content": "#!/usr/bin/python3\n\nimport argparse\nimport ctypes\nimport functools\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nimport threading\nimport traceback\nimport os.path\n\nsys.path.insert(0, os.path.dirname(os.path.dirname((os.path.abspath(__file__)))))\nfrom youtube_dl.compat import (\n    compat_input,\n    compat_http_server,\n    compat_str,\n    compat_urlparse,\n)\n\n# These are not used outside of buildserver.py thus not in compat.py\n\ntry:\n    import winreg as compat_winreg\nexcept ImportError:  # Python 2\n    import _winreg as compat_winreg\n\ntry:\n    import socketserver as compat_socketserver\nexcept ImportError:  # Python 2\n    import SocketServer as compat_socketserver\n\n\nclass BuildHTTPServer(compat_socketserver.ThreadingMixIn, compat_http_server.HTTPServer):\n    allow_reuse_address = True\n\n\nadvapi32 = ctypes.windll.advapi32\n\nSC_MANAGER_ALL_ACCESS = 0xf003f\nSC_MANAGER_CREATE_SERVICE = 0x02\nSERVICE_WIN32_OWN_PROCESS = 0x10\nSERVICE_AUTO_START = 0x2\nSERVICE_ERROR_NORMAL = 0x1\nDELETE = 0x00010000\nSERVICE_STATUS_START_PENDING = 0x00000002\nSERVICE_STATUS_RUNNING = 0x00000004\nSERVICE_ACCEPT_STOP = 0x1\n\nSVCNAME = 'youtubedl_builder'\n\nLPTSTR = ctypes.c_wchar_p\nSTART_CALLBACK = ctypes.WINFUNCTYPE(None, ctypes.c_int, ctypes.POINTER(LPTSTR))\n\n\nclass SERVICE_TABLE_ENTRY(ctypes.Structure):\n    _fields_ = [\n        ('lpServiceName', LPTSTR),\n        ('lpServiceProc', START_CALLBACK)\n    ]\n\n\nHandlerEx = ctypes.WINFUNCTYPE(\n    ctypes.c_int,     # return\n    ctypes.c_int,     # dwControl\n    ctypes.c_int,     # dwEventType\n    ctypes.c_void_p,  # lpEventData,\n    ctypes.c_void_p,  # lpContext,\n)\n\n\ndef _ctypes_array(c_type, py_array):\n    ar = (c_type * len(py_array))()\n    ar[:] = py_array\n    return ar\n\n\ndef win_OpenSCManager():\n    res = advapi32.OpenSCManagerW(None, None, SC_MANAGER_ALL_ACCESS)\n    if not res:\n        raise Exception('Opening service manager failed - '\n                        'are you running this as administrator?')\n    return res\n\n\ndef win_install_service(service_name, cmdline):\n    manager = win_OpenSCManager()\n    try:\n        h = advapi32.CreateServiceW(\n            manager, service_name, None,\n            SC_MANAGER_CREATE_SERVICE, SERVICE_WIN32_OWN_PROCESS,\n            SERVICE_AUTO_START, SERVICE_ERROR_NORMAL,\n            cmdline, None, None, None, None, None)\n        if not h:\n            raise OSError('Service creation failed: %s' % ctypes.FormatError())\n\n        advapi32.CloseServiceHandle(h)\n    finally:\n        advapi32.CloseServiceHandle(manager)\n\n\ndef win_uninstall_service(service_name):\n    manager = win_OpenSCManager()\n    try:\n        h = advapi32.OpenServiceW(manager, service_name, DELETE)\n        if not h:\n            raise OSError('Could not find service %s: %s' % (\n                service_name, ctypes.FormatError()))\n\n        try:\n            if not advapi32.DeleteService(h):\n                raise OSError('Deletion failed: %s' % ctypes.FormatError())\n        finally:\n            advapi32.CloseServiceHandle(h)\n    finally:\n        advapi32.CloseServiceHandle(manager)\n\n\ndef win_service_report_event(service_name, msg, is_error=True):\n    with open('C:/sshkeys/log', 'a', encoding='utf-8') as f:\n        f.write(msg + '\\n')\n\n    event_log = advapi32.RegisterEventSourceW(None, service_name)\n    if not event_log:\n        raise OSError('Could not report event: %s' % ctypes.FormatError())\n\n    try:\n        type_id = 0x0001 if is_error else 0x0004\n        event_id = 0xc0000000 if is_error else 0x40000000\n        lines = _ctypes_array(LPTSTR, [msg])\n\n        if not advapi32.ReportEventW(\n                event_log, type_id, 0, event_id, None, len(lines), 0,\n                lines, None):\n            raise OSError('Event reporting failed: %s' % ctypes.FormatError())\n    finally:\n        advapi32.DeregisterEventSource(event_log)\n\n\ndef win_service_handler(stop_event, *args):\n    try:\n        raise ValueError('Handler called with args ' + repr(args))\n        TODO\n    except Exception as e:\n        tb = traceback.format_exc()\n        msg = str(e) + '\\n' + tb\n        win_service_report_event(service_name, msg, is_error=True)\n        raise\n\n\ndef win_service_set_status(handle, status_code):\n    svcStatus = SERVICE_STATUS()\n    svcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS\n    svcStatus.dwCurrentState = status_code\n    svcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP\n\n    svcStatus.dwServiceSpecificExitCode = 0\n\n    if not advapi32.SetServiceStatus(handle, ctypes.byref(svcStatus)):\n        raise OSError('SetServiceStatus failed: %r' % ctypes.FormatError())\n\n\ndef win_service_main(service_name, real_main, argc, argv_raw):\n    try:\n        # args = [argv_raw[i].value for i in range(argc)]\n        stop_event = threading.Event()\n        handler = HandlerEx(functools.partial(stop_event, win_service_handler))\n        h = advapi32.RegisterServiceCtrlHandlerExW(service_name, handler, None)\n        if not h:\n            raise OSError('Handler registration failed: %s' %\n                          ctypes.FormatError())\n\n        TODO\n    except Exception as e:\n        tb = traceback.format_exc()\n        msg = str(e) + '\\n' + tb\n        win_service_report_event(service_name, msg, is_error=True)\n        raise\n\n\ndef win_service_start(service_name, real_main):\n    try:\n        cb = START_CALLBACK(\n            functools.partial(win_service_main, service_name, real_main))\n        dispatch_table = _ctypes_array(SERVICE_TABLE_ENTRY, [\n            SERVICE_TABLE_ENTRY(\n                service_name,\n                cb\n            ),\n            SERVICE_TABLE_ENTRY(None, ctypes.cast(None, START_CALLBACK))\n        ])\n\n        if not advapi32.StartServiceCtrlDispatcherW(dispatch_table):\n            raise OSError('ctypes start failed: %s' % ctypes.FormatError())\n    except Exception as e:\n        tb = traceback.format_exc()\n        msg = str(e) + '\\n' + tb\n        win_service_report_event(service_name, msg, is_error=True)\n        raise\n\n\ndef main(args=None):\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-i', '--install',\n                        action='store_const', dest='action', const='install',\n                        help='Launch at Windows startup')\n    parser.add_argument('-u', '--uninstall',\n                        action='store_const', dest='action', const='uninstall',\n                        help='Remove Windows service')\n    parser.add_argument('-s', '--service',\n                        action='store_const', dest='action', const='service',\n                        help='Run as a Windows service')\n    parser.add_argument('-b', '--bind', metavar='<host:port>',\n                        action='store', default='0.0.0.0:8142',\n                        help='Bind to host:port (default %default)')\n    options = parser.parse_args(args=args)\n\n    if options.action == 'install':\n        fn = os.path.abspath(__file__).replace('v:', '\\\\\\\\vboxsrv\\\\vbox')\n        cmdline = '%s %s -s -b %s' % (sys.executable, fn, options.bind)\n        win_install_service(SVCNAME, cmdline)\n        return\n\n    if options.action == 'uninstall':\n        win_uninstall_service(SVCNAME)\n        return\n\n    if options.action == 'service':\n        win_service_start(SVCNAME, main)\n        return\n\n    host, port_str = options.bind.split(':')\n    port = int(port_str)\n\n    print('Listening on %s:%d' % (host, port))\n    srv = BuildHTTPServer((host, port), BuildHTTPRequestHandler)\n    thr = threading.Thread(target=srv.serve_forever)\n    thr.start()\n    compat_input('Press ENTER to shut down')\n    srv.shutdown()\n    thr.join()\n\n\ndef rmtree(path):\n    for name in os.listdir(path):\n        fname = os.path.join(path, name)\n        if os.path.isdir(fname):\n            rmtree(fname)\n        else:\n            os.chmod(fname, 0o666)\n            os.remove(fname)\n    os.rmdir(path)\n\n\nclass BuildError(Exception):\n    def __init__(self, output, code=500):\n        self.output = output\n        self.code = code\n\n    def __str__(self):\n        return self.output\n\n\nclass HTTPError(BuildError):\n    pass\n\n\nclass PythonBuilder(object):\n    def __init__(self, **kwargs):\n        python_version = kwargs.pop('python', '3.4')\n        python_path = None\n        for node in ('Wow6432Node\\\\', ''):\n            try:\n                key = compat_winreg.OpenKey(\n                    compat_winreg.HKEY_LOCAL_MACHINE,\n                    r'SOFTWARE\\%sPython\\PythonCore\\%s\\InstallPath' % (node, python_version))\n                try:\n                    python_path, _ = compat_winreg.QueryValueEx(key, '')\n                finally:\n                    compat_winreg.CloseKey(key)\n                break\n            except Exception:\n                pass\n\n        if not python_path:\n            raise BuildError('No such Python version: %s' % python_version)\n\n        self.pythonPath = python_path\n\n        super(PythonBuilder, self).__init__(**kwargs)\n\n\nclass GITInfoBuilder(object):\n    def __init__(self, **kwargs):\n        try:\n            self.user, self.repoName = kwargs['path'][:2]\n            self.rev = kwargs.pop('rev')\n        except ValueError:\n            raise BuildError('Invalid path')\n        except KeyError as e:\n            raise BuildError('Missing mandatory parameter \"%s\"' % e.args[0])\n\n        path = os.path.join(os.environ['APPDATA'], 'Build archive', self.repoName, self.user)\n        if not os.path.exists(path):\n            os.makedirs(path)\n        self.basePath = tempfile.mkdtemp(dir=path)\n        self.buildPath = os.path.join(self.basePath, 'build')\n\n        super(GITInfoBuilder, self).__init__(**kwargs)\n\n\nclass GITBuilder(GITInfoBuilder):\n    def build(self):\n        try:\n            subprocess.check_output(['git', 'clone', 'git://github.com/%s/%s.git' % (self.user, self.repoName), self.buildPath])\n            subprocess.check_output(['git', 'checkout', self.rev], cwd=self.buildPath)\n        except subprocess.CalledProcessError as e:\n            raise BuildError(e.output)\n\n        super(GITBuilder, self).build()\n\n\nclass YoutubeDLBuilder(object):\n    authorizedUsers = ['fraca7', 'phihag', 'rg3', 'FiloSottile']\n\n    def __init__(self, **kwargs):\n        if self.repoName != 'youtube-dl':\n            raise BuildError('Invalid repository \"%s\"' % self.repoName)\n        if self.user not in self.authorizedUsers:\n            raise HTTPError('Unauthorized user \"%s\"' % self.user, 401)\n\n        super(YoutubeDLBuilder, self).__init__(**kwargs)\n\n    def build(self):\n        try:\n            proc = subprocess.Popen([os.path.join(self.pythonPath, 'python.exe'), 'setup.py', 'py2exe'], stdin=subprocess.PIPE, cwd=self.buildPath)\n            proc.wait()\n            #subprocess.check_output([os.path.join(self.pythonPath, 'python.exe'), 'setup.py', 'py2exe'],\n            #                        cwd=self.buildPath)\n        except subprocess.CalledProcessError as e:\n            raise BuildError(e.output)\n\n        super(YoutubeDLBuilder, self).build()\n\n\nclass DownloadBuilder(object):\n    def __init__(self, **kwargs):\n        self.handler = kwargs.pop('handler')\n        self.srcPath = os.path.join(self.buildPath, *tuple(kwargs['path'][2:]))\n        self.srcPath = os.path.abspath(os.path.normpath(self.srcPath))\n        if not self.srcPath.startswith(self.buildPath):\n            raise HTTPError(self.srcPath, 401)\n\n        super(DownloadBuilder, self).__init__(**kwargs)\n\n    def build(self):\n        if not os.path.exists(self.srcPath):\n            raise HTTPError('No such file', 404)\n        if os.path.isdir(self.srcPath):\n            raise HTTPError('Is a directory: %s' % self.srcPath, 401)\n\n        self.handler.send_response(200)\n        self.handler.send_header('Content-Type', 'application/octet-stream')\n        self.handler.send_header('Content-Disposition', 'attachment; filename=%s' % os.path.split(self.srcPath)[-1])\n        self.handler.send_header('Content-Length', str(os.stat(self.srcPath).st_size))\n        self.handler.end_headers()\n\n        with open(self.srcPath, 'rb') as src:\n            shutil.copyfileobj(src, self.handler.wfile)\n\n        super(DownloadBuilder, self).build()\n\n\nclass CleanupTempDir(object):\n    def build(self):\n        try:\n            rmtree(self.basePath)\n        except Exception as e:\n            print('WARNING deleting \"%s\": %s' % (self.basePath, e))\n\n        super(CleanupTempDir, self).build()\n\n\nclass Null(object):\n    def __init__(self, **kwargs):\n        pass\n\n    def start(self):\n        pass\n\n    def close(self):\n        pass\n\n    def build(self):\n        pass\n\n\nclass Builder(PythonBuilder, GITBuilder, YoutubeDLBuilder, DownloadBuilder, CleanupTempDir, Null):\n    pass\n\n\nclass BuildHTTPRequestHandler(compat_http_server.BaseHTTPRequestHandler):\n    actionDict = {'build': Builder, 'download': Builder}  # They're the same, no more caching.\n\n    def do_GET(self):\n        path = compat_urlparse.urlparse(self.path)\n        paramDict = dict([(key, value[0]) for key, value in compat_urlparse.parse_qs(path.query).items()])\n        action, _, path = path.path.strip('/').partition('/')\n        if path:\n            path = path.split('/')\n            if action in self.actionDict:\n                try:\n                    builder = self.actionDict[action](path=path, handler=self, **paramDict)\n                    builder.start()\n                    try:\n                        builder.build()\n                    finally:\n                        builder.close()\n                except BuildError as e:\n                    self.send_response(e.code)\n                    msg = compat_str(e).encode('UTF-8')\n                    self.send_header('Content-Type', 'text/plain; charset=UTF-8')\n                    self.send_header('Content-Length', len(msg))\n                    self.end_headers()\n                    self.wfile.write(msg)\n            else:\n                self.send_response(500, 'Unknown build method \"%s\"' % action)\n        else:\n            self.send_response(500, 'Malformed URL')\n\nif __name__ == '__main__':\n    main()\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "buildserver.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/devscripts/buildserver.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}