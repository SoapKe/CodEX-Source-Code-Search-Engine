{"author": "powerline", "code": "\n\nfrom __future__ import (unicode_literals, division, absolute_import, print_function)\n\nimport os\nimport socket\nimport sys\nimport codecs\nimport platform\nimport re\n\n\ntest_root = os.environ['TEST_ROOT']\ntest_type = sys.argv[1]\ntest_client = sys.argv[2]\nshell = sys.argv[3]\nfname = os.path.join(test_root, '.'.join((shell, test_type, test_client, 'full.log')))\nnew_fname = os.path.join(test_root, '.'.join((shell, test_type, test_client, 'log')))\npid_fname = os.path.join(test_root, '3rd', 'pid')\n\nis_pypy = platform.python_implementation() == 'PyPy'\n\n\ntry:\n\twith open(pid_fname, 'r') as P:\n\t\tpid = P.read().strip()\nexcept IOError:\n\tpid = None\nhostname = socket.gethostname()\nuser = os.environ['USER']\n\nREFS_RE = re.compile(r'^\\[\\d+ refs\\]\\n')\nIPYPY_DEANSI_RE = re.compile(r'\\033(?:\\[(?:\\?\\d+[lh]|[^a-zA-Z]+[a-ln-zA-Z])|[=>])')\nZSH_HL_RE = re.compile(r'\\033\\[\\?\\d+[hl]')\n\nstart_str = 'cd \"$TEST_ROOT\"/3rd'\nif shell == 'pdb':\n\tstart_str = 'class Foo(object):'\n\nwith codecs.open(fname, 'r', encoding='utf-8') as R:\n\twith codecs.open(new_fname, 'w', encoding='utf-8') as W:\n\t\tfound_cd = False\n\t\ti = -1\n\t\tfor line in (R if shell != 'fish' else R.read().split('\\n')):\n\t\t\ti += 1\n\t\t\tif not found_cd:\n\t\t\t\tfound_cd = (start_str in line)\n\t\t\t\tcontinue\n\t\t\tif 'true is the last line' in line:\n\t\t\t\tbreak\n\t\t\tline = line.translate({\n\t\t\t\tord('\\r'): None\n\t\t\t})\n\t\t\tif REFS_RE.match(line):\n\t\t\t\tcontinue\n\t\t\tline = line.replace(hostname, 'HOSTNAME')\n\t\t\tline = line.replace(user, 'USER')\n\t\t\tif pid is not None:\n\t\t\t\tline = line.replace(pid, 'PID')\n\t\t\tif shell == 'zsh':\n\t\t\t\tline = line.replace('\\033[0m\\033[23m\\033[24m\\033[J', '')\n\t\t\t\tline = ZSH_HL_RE.subn('', line)[0]\n\t\t\telif shell == 'fish':\n\t\t\t\tres = ''\n\t\t\t\ttry:\n\t\t\t\t\twhile line.index('\\033[0;'):\n\t\t\t\t\t\tstart = line.index('\\033[0;')\n\t\t\t\t\t\tend = line.index('\\033[0m', start)\n\t\t\t\t\t\tres += line[start:end + 4] + '\\n'\n\t\t\t\t\t\tline = line[end + 4:]\n\t\t\t\texcept ValueError:\n\t\t\t\t\tpass\n\t\t\t\tline = res\n\t\t\telif shell == 'tcsh':\n\t\t\t\ttry:\n\t\t\t\t\tstart = line.index('\\033[0;')\n\t\t\t\t\tend = line.index(' ', start)\n\t\t\t\t\tline = line[start:end] + '\\n'\n\t\t\t\texcept ValueError:\n\t\t\t\t\tline = ''\n\t\t\telif shell == 'mksh':\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif line.startswith('[1] + Terminated'):\n\t\t\t\t\tline = '[1] + Terminated bash -c ...\\n'\n\t\t\telif shell == 'dash':\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif line.startswith('[1] + Terminated'):\n\t\t\t\t\tcontinue\n\t\t\telif shell == 'ipython' and is_pypy:\n\t\t\t\ttry:\n\t\t\t\t\tend_idx = line.rindex('\\033[0m')\n\t\t\t\t\ttry:\n\t\t\t\t\t\tidx = line[:end_idx].rindex('\\033[1;1H')\n\t\t\t\t\texcept ValueError:\n\t\t\t\t\t\tidx = line[:end_idx].rindex('\\033[?25h')\n\t\t\t\t\tline = line[idx + len('\\033[1;1H'):]\n\t\t\t\texcept ValueError:\n\t\t\t\t\tpass\n\t\t\t\ttry:\n\t\t\t\t\tdata_end_idx = line.rindex('\\033[1;1H')\n\t\t\t\t\tline = line[:data_end_idx] + '\\n'\n\t\t\t\texcept ValueError:\n\t\t\t\t\tpass\n\t\t\t\tif line == '\\033[1;1H\\n':\n\t\t\t\t\tcontinue\n\t\t\t\twas_empty = line == '\\n'\n\t\t\t\tline = IPYPY_DEANSI_RE.subn('', line)[0]\n\t\t\t\tif line == '\\n' and not was_empty:\n\t\t\t\t\tline = ''\n\t\t\telif shell == 'rc':\n\t\t\t\tif line == 'read() failed: Connection reset by peer\\n':\n\t\t\t\t\tline = ''\n\t\t\telif shell == 'pdb':\n\t\t\t\tif is_pypy:\n\t\t\t\t\tif line == '\\033[?1h\\033=\\033[?25l\\033[1A\\n':\n\t\t\t\t\t\tline = ''\n\t\t\t\t\tline = IPYPY_DEANSI_RE.subn('', line)[0]\n\t\t\t\t\tif line == '\\n':\n\t\t\t\t\t\tline = ''\n\t\t\t\tif line.startswith(('>',)):\n\t\t\t\t\tline = ''\n\t\t\t\telif line == '-> self.quitting = 1\\n':\n\t\t\t\t\tline = '-> self.quitting = True\\n'\n\t\t\t\telif line == '\\n':\n\t\t\t\t\tline = ''\n\t\t\t\tif line == '-> self.quitting = True\\n':\n\t\t\t\t\tbreak\n\t\t\tW.write(line)\n", "comments": "   usr bin env python    vim fileencoding utf 8 noet    output different travis  machine i see full     command  travis truncated  true      position line stable  may go     next line ", "content": "#!/usr/bin/env python\n# vim:fileencoding=utf-8:noet\nfrom __future__ import (unicode_literals, division, absolute_import, print_function)\n\nimport os\nimport socket\nimport sys\nimport codecs\nimport platform\nimport re\n\n\ntest_root = os.environ['TEST_ROOT']\ntest_type = sys.argv[1]\ntest_client = sys.argv[2]\nshell = sys.argv[3]\nfname = os.path.join(test_root, '.'.join((shell, test_type, test_client, 'full.log')))\nnew_fname = os.path.join(test_root, '.'.join((shell, test_type, test_client, 'log')))\npid_fname = os.path.join(test_root, '3rd', 'pid')\n\nis_pypy = platform.python_implementation() == 'PyPy'\n\n\ntry:\n\twith open(pid_fname, 'r') as P:\n\t\tpid = P.read().strip()\nexcept IOError:\n\tpid = None\nhostname = socket.gethostname()\nuser = os.environ['USER']\n\nREFS_RE = re.compile(r'^\\[\\d+ refs\\]\\n')\nIPYPY_DEANSI_RE = re.compile(r'\\033(?:\\[(?:\\?\\d+[lh]|[^a-zA-Z]+[a-ln-zA-Z])|[=>])')\nZSH_HL_RE = re.compile(r'\\033\\[\\?\\d+[hl]')\n\nstart_str = 'cd \"$TEST_ROOT\"/3rd'\nif shell == 'pdb':\n\tstart_str = 'class Foo(object):'\n\nwith codecs.open(fname, 'r', encoding='utf-8') as R:\n\twith codecs.open(new_fname, 'w', encoding='utf-8') as W:\n\t\tfound_cd = False\n\t\ti = -1\n\t\tfor line in (R if shell != 'fish' else R.read().split('\\n')):\n\t\t\ti += 1\n\t\t\tif not found_cd:\n\t\t\t\tfound_cd = (start_str in line)\n\t\t\t\tcontinue\n\t\t\tif 'true is the last line' in line:\n\t\t\t\tbreak\n\t\t\tline = line.translate({\n\t\t\t\tord('\\r'): None\n\t\t\t})\n\t\t\tif REFS_RE.match(line):\n\t\t\t\tcontinue\n\t\t\tline = line.replace(hostname, 'HOSTNAME')\n\t\t\tline = line.replace(user, 'USER')\n\t\t\tif pid is not None:\n\t\t\t\tline = line.replace(pid, 'PID')\n\t\t\tif shell == 'zsh':\n\t\t\t\tline = line.replace('\\033[0m\\033[23m\\033[24m\\033[J', '')\n\t\t\t\tline = ZSH_HL_RE.subn('', line)[0]\n\t\t\telif shell == 'fish':\n\t\t\t\tres = ''\n\t\t\t\ttry:\n\t\t\t\t\twhile line.index('\\033[0;'):\n\t\t\t\t\t\tstart = line.index('\\033[0;')\n\t\t\t\t\t\tend = line.index('\\033[0m', start)\n\t\t\t\t\t\tres += line[start:end + 4] + '\\n'\n\t\t\t\t\t\tline = line[end + 4:]\n\t\t\t\texcept ValueError:\n\t\t\t\t\tpass\n\t\t\t\tline = res\n\t\t\telif shell == 'tcsh':\n\t\t\t\ttry:\n\t\t\t\t\tstart = line.index('\\033[0;')\n\t\t\t\t\tend = line.index(' ', start)\n\t\t\t\t\tline = line[start:end] + '\\n'\n\t\t\t\texcept ValueError:\n\t\t\t\t\tline = ''\n\t\t\telif shell == 'mksh':\n\t\t\t\t# Output is different in travis: on my machine I see full \n\t\t\t\t# command, in travis it is truncated just after `true`.\n\t\t\t\tif line.startswith('[1] + Terminated'):\n\t\t\t\t\tline = '[1] + Terminated bash -c ...\\n'\n\t\t\telif shell == 'dash':\n\t\t\t\t# Position of this line is not stable: it may go both before and \n\t\t\t\t# after the next line\n\t\t\t\tif line.startswith('[1] + Terminated'):\n\t\t\t\t\tcontinue\n\t\t\telif shell == 'ipython' and is_pypy:\n\t\t\t\ttry:\n\t\t\t\t\tend_idx = line.rindex('\\033[0m')\n\t\t\t\t\ttry:\n\t\t\t\t\t\tidx = line[:end_idx].rindex('\\033[1;1H')\n\t\t\t\t\texcept ValueError:\n\t\t\t\t\t\tidx = line[:end_idx].rindex('\\033[?25h')\n\t\t\t\t\tline = line[idx + len('\\033[1;1H'):]\n\t\t\t\texcept ValueError:\n\t\t\t\t\tpass\n\t\t\t\ttry:\n\t\t\t\t\tdata_end_idx = line.rindex('\\033[1;1H')\n\t\t\t\t\tline = line[:data_end_idx] + '\\n'\n\t\t\t\texcept ValueError:\n\t\t\t\t\tpass\n\t\t\t\tif line == '\\033[1;1H\\n':\n\t\t\t\t\tcontinue\n\t\t\t\twas_empty = line == '\\n'\n\t\t\t\tline = IPYPY_DEANSI_RE.subn('', line)[0]\n\t\t\t\tif line == '\\n' and not was_empty:\n\t\t\t\t\tline = ''\n\t\t\telif shell == 'rc':\n\t\t\t\tif line == 'read() failed: Connection reset by peer\\n':\n\t\t\t\t\tline = ''\n\t\t\telif shell == 'pdb':\n\t\t\t\tif is_pypy:\n\t\t\t\t\tif line == '\\033[?1h\\033=\\033[?25l\\033[1A\\n':\n\t\t\t\t\t\tline = ''\n\t\t\t\t\tline = IPYPY_DEANSI_RE.subn('', line)[0]\n\t\t\t\t\tif line == '\\n':\n\t\t\t\t\t\tline = ''\n\t\t\t\tif line.startswith(('>',)):\n\t\t\t\t\tline = ''\n\t\t\t\telif line == '-> self.quitting = 1\\n':\n\t\t\t\t\tline = '-> self.quitting = True\\n'\n\t\t\t\telif line == '\\n':\n\t\t\t\t\tline = ''\n\t\t\t\tif line == '-> self.quitting = True\\n':\n\t\t\t\t\tbreak\n\t\t\tW.write(line)\n", "description": "Powerline is a statusline plugin for vim, and provides statuslines and prompts for several other applications, including zsh, bash, tmux, IPython, Awesome and Qtile.", "file_name": "postproc.py", "id": "f9e3d5c0c60968b843a1854a420b60db", "language": "Python", "project_name": "powerline", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/powerline-powerline/powerline-powerline-d36850f/tests/test_shells/postproc.py", "save_time": "", "source": "", "update_at": "2018-03-18T09:00:33Z", "url": "https://github.com/powerline/powerline", "wiki": false}