{"author": "odoo", "code": "from .pyjsparserdata import *\n\n\nclass BaseNode:\n    def finish(self):\n        pass\n\n    def finishArrayExpression(self, elements):\n        self.type = Syntax.ArrayExpression\n        self.elements = elements\n        self.finish()\n        return self\n\n    def finishArrayPattern(self, elements):\n        self.type = Syntax.ArrayPattern\n        self.elements = elements\n        self.finish()\n        return self\n\n    def finishArrowFunctionExpression(self, params, defaults, body, expression):\n        self.type = Syntax.ArrowFunctionExpression\n        self.id = None\n        self.params = params\n        self.defaults = defaults\n        self.body = body\n        self.generator = False\n        self.expression = expression\n        self.finish()\n        return self\n\n    def finishAssignmentExpression(self, operator, left, right):\n        self.type = Syntax.AssignmentExpression\n        self.operator = operator\n        self.left = left\n        self.right = right\n        self.finish()\n        return self\n\n    def finishAssignmentPattern(self, left, right):\n        self.type = Syntax.AssignmentPattern\n        self.left = left\n        self.right = right\n        self.finish()\n        return self\n\n    def finishBinaryExpression(self, operator, left, right):\n        self.type = Syntax.LogicalExpression if (operator == '||' or operator == '&&') else Syntax.BinaryExpression\n        self.operator = operator\n        self.left = left\n        self.right = right\n        self.finish()\n        return self\n\n    def finishBlockStatement(self, body):\n        self.type = Syntax.BlockStatement\n        self.body = body\n        self.finish()\n        return self\n\n    def finishBreakStatement(self, label):\n        self.type = Syntax.BreakStatement\n        self.label = label\n        self.finish()\n        return self\n\n    def finishCallExpression(self, callee, args):\n        self.type = Syntax.CallExpression\n        self.callee = callee\n        self.arguments = args\n        self.finish()\n        return self\n\n    def finishCatchClause(self, param, body):\n        self.type = Syntax.CatchClause\n        self.param = param\n        self.body = body\n        self.finish()\n        return self\n\n    def finishClassBody(self, body):\n        self.type = Syntax.ClassBody\n        self.body = body\n        self.finish()\n        return self\n\n    def finishClassDeclaration(self, id, superClass, body):\n        self.type = Syntax.ClassDeclaration\n        self.id = id\n        self.superClass = superClass\n        self.body = body\n        self.finish()\n        return self\n\n    def finishClassExpression(self, id, superClass, body):\n        self.type = Syntax.ClassExpression\n        self.id = id\n        self.superClass = superClass\n        self.body = body\n        self.finish()\n        return self\n\n    def finishConditionalExpression(self, test, consequent, alternate):\n        self.type = Syntax.ConditionalExpression\n        self.test = test\n        self.consequent = consequent\n        self.alternate = alternate\n        self.finish()\n        return self\n\n    def finishContinueStatement(self, label):\n        self.type = Syntax.ContinueStatement\n        self.label = label\n        self.finish()\n        return self\n\n    def finishDebuggerStatement(self, ):\n        self.type = Syntax.DebuggerStatement\n        self.finish()\n        return self\n\n    def finishDoWhileStatement(self, body, test):\n        self.type = Syntax.DoWhileStatement\n        self.body = body\n        self.test = test\n        self.finish()\n        return self\n\n    def finishEmptyStatement(self, ):\n        self.type = Syntax.EmptyStatement\n        self.finish()\n        return self\n\n    def finishExpressionStatement(self, expression):\n        self.type = Syntax.ExpressionStatement\n        self.expression = expression\n        self.finish()\n        return self\n\n    def finishForStatement(self, init, test, update, body):\n        self.type = Syntax.ForStatement\n        self.init = init\n        self.test = test\n        self.update = update\n        self.body = body\n        self.finish()\n        return self\n\n    def finishForInStatement(self, left, right, body):\n        self.type = Syntax.ForInStatement\n        self.left = left\n        self.right = right\n        self.body = body\n        self.each = False\n        self.finish()\n        return self\n\n    def finishFunctionDeclaration(self, id, params, defaults, body):\n        self.type = Syntax.FunctionDeclaration\n        self.id = id\n        self.params = params\n        self.defaults = defaults\n        self.body = body\n        self.generator = False\n        self.expression = False\n        self.finish()\n        return self\n\n    def finishFunctionExpression(self, id, params, defaults, body):\n        self.type = Syntax.FunctionExpression\n        self.id = id\n        self.params = params\n        self.defaults = defaults\n        self.body = body\n        self.generator = False\n        self.expression = False\n        self.finish()\n        return self\n\n    def finishIdentifier(self, name):\n        self.type = Syntax.Identifier\n        self.name = name\n        self.finish()\n        return self\n\n    def finishIfStatement(self, test, consequent, alternate):\n        self.type = Syntax.IfStatement\n        self.test = test\n        self.consequent = consequent\n        self.alternate = alternate\n        self.finish()\n        return self\n\n    def finishLabeledStatement(self, label, body):\n        self.type = Syntax.LabeledStatement\n        self.label = label\n        self.body = body\n        self.finish()\n        return self\n\n    def finishLiteral(self, token):\n        self.type = Syntax.Literal\n        self.value = token['value']\n        self.raw = None  ?\n        if token.get('regex'):\n            self.regex = token['regex']\n        self.finish()\n        return self\n\n    def finishMemberExpression(self, accessor, object, property):\n        self.type = Syntax.MemberExpression\n        self.computed = accessor == '['\n        self.object = object\n        self.property = property\n        self.finish()\n        return self\n\n    def finishNewExpression(self, callee, args):\n        self.type = Syntax.NewExpression\n        self.callee = callee\n        self.arguments = args\n        self.finish()\n        return self\n\n    def finishObjectExpression(self, properties):\n        self.type = Syntax.ObjectExpression\n        self.properties = properties\n        self.finish()\n        return self\n\n    def finishObjectPattern(self, properties):\n        self.type = Syntax.ObjectPattern\n        self.properties = properties\n        self.finish()\n        return self\n\n    def finishPostfixExpression(self, operator, argument):\n        self.type = Syntax.UpdateExpression\n        self.operator = operator\n        self.argument = argument\n        self.prefix = False\n        self.finish()\n        return self\n\n    def finishProgram(self, body):\n        self.type = Syntax.Program\n        self.body = body\n        self.finish()\n        return self\n\n    def finishPyimport(self, imp):\n        self.type = 'PyimportStatement'\n        self.imp = imp\n        self.finish()\n        return self\n\n    def finishProperty(self, kind, key, computed, value, method, shorthand):\n        self.type = Syntax.Property\n        self.key = key\n        self.computed = computed\n        self.value = value\n        self.kind = kind\n        self.method = method\n        self.shorthand = shorthand\n        self.finish()\n        return self\n\n    def finishRestElement(self, argument):\n        self.type = Syntax.RestElement\n        self.argument = argument\n        self.finish()\n        return self\n\n    def finishReturnStatement(self, argument):\n        self.type = Syntax.ReturnStatement\n        self.argument = argument\n        self.finish()\n        return self\n\n    def finishSequenceExpression(self, expressions):\n        self.type = Syntax.SequenceExpression\n        self.expressions = expressions\n        self.finish()\n        return self\n\n    def finishSpreadElement(self, argument):\n        self.type = Syntax.SpreadElement\n        self.argument = argument\n        self.finish()\n        return self\n\n    def finishSwitchCase(self, test, consequent):\n        self.type = Syntax.SwitchCase\n        self.test = test\n        self.consequent = consequent\n        self.finish()\n        return self\n\n    def finishSuper(self, ):\n        self.type = Syntax.Super\n        self.finish()\n        return self\n\n    def finishSwitchStatement(self, discriminant, cases):\n        self.type = Syntax.SwitchStatement\n        self.discriminant = discriminant\n        self.cases = cases\n        self.finish()\n        return self\n\n    def finishTaggedTemplateExpression(self, tag, quasi):\n        self.type = Syntax.TaggedTemplateExpression\n        self.tag = tag\n        self.quasi = quasi\n        self.finish()\n        return self\n\n    def finishTemplateElement(self, value, tail):\n        self.type = Syntax.TemplateElement\n        self.value = value\n        self.tail = tail\n        self.finish()\n        return self\n\n    def finishTemplateLiteral(self, quasis, expressions):\n        self.type = Syntax.TemplateLiteral\n        self.quasis = quasis\n        self.expressions = expressions\n        self.finish()\n        return self\n\n    def finishThisExpression(self, ):\n        self.type = Syntax.ThisExpression\n        self.finish()\n        return self\n\n    def finishThrowStatement(self, argument):\n        self.type = Syntax.ThrowStatement\n        self.argument = argument\n        self.finish()\n        return self\n\n    def finishTryStatement(self, block, handler, finalizer):\n        self.type = Syntax.TryStatement\n        self.block = block\n        self.guardedHandlers = []\n        self.handlers = [handler] if handler else []\n        self.handler = handler\n        self.finalizer = finalizer\n        self.finish()\n        return self\n\n    def finishUnaryExpression(self, operator, argument):\n        self.type = Syntax.UpdateExpression if (operator == '++' or operator == '--') else Syntax.UnaryExpression\n        self.operator = operator\n        self.argument = argument\n        self.prefix = True\n        self.finish()\n        return self\n\n    def finishVariableDeclaration(self, declarations):\n        self.type = Syntax.VariableDeclaration\n        self.declarations = declarations\n        self.kind = 'var'\n        self.finish()\n        return self\n\n    def finishLexicalDeclaration(self, declarations, kind):\n        self.type = Syntax.VariableDeclaration\n        self.declarations = declarations\n        self.kind = kind\n        self.finish()\n        return self\n\n    def finishVariableDeclarator(self, id, init):\n        self.type = Syntax.VariableDeclarator\n        self.id = id\n        self.init = init\n        self.finish()\n        return self\n\n    def finishWhileStatement(self, test, body):\n        self.type = Syntax.WhileStatement\n        self.test = test\n        self.body = body\n        self.finish()\n        return self\n\n    def finishWithStatement(self, object, body):\n        self.type = Syntax.WithStatement\n        self.object = object\n        self.body = body\n        self.finish()\n        return self\n\n    def finishExportSpecifier(self, local, exported):\n        self.type = Syntax.ExportSpecifier\n        self.exported = exported or local\n        self.local = local\n        self.finish()\n        return self\n\n    def finishImportDefaultSpecifier(self, local):\n        self.type = Syntax.ImportDefaultSpecifier\n        self.local = local\n        self.finish()\n        return self\n\n    def finishImportNamespaceSpecifier(self, local):\n        self.type = Syntax.ImportNamespaceSpecifier\n        self.local = local\n        self.finish()\n        return self\n\n    def finishExportNamedDeclaration(self, declaration, specifiers, src):\n        self.type = Syntax.ExportNamedDeclaration\n        self.declaration = declaration\n        self.specifiers = specifiers\n        self.source = src\n        self.finish()\n        return self\n\n    def finishExportDefaultDeclaration(self, declaration):\n        self.type = Syntax.ExportDefaultDeclaration\n        self.declaration = declaration\n        self.finish()\n        return self\n\n    def finishExportAllDeclaration(self, src):\n        self.type = Syntax.ExportAllDeclaration\n        self.source = src\n        self.finish()\n        return self\n\n    def finishImportSpecifier(self, local, imported):\n        self.type = Syntax.ImportSpecifier\n        self.local = local or imported\n        self.imported = imported\n        self.finish()\n        return self\n\n    def finishImportDeclaration(self, specifiers, src):\n        self.type = Syntax.ImportDeclaration\n        self.specifiers = specifiers\n        self.source = src\n        self.finish()\n        return self\n\n    def __getitem__(self, item):\n        return getattr(self, item)\n\n    def __setitem__(self, key, value):\n        setattr(self, key, value)\n\nclass Node(BaseNode):\n    pass\n\n\nclass WrappingNode(BaseNode):\n    def __init__(self, startToken=None):\n        pass\n\n\ndef node_to_dict(node):  \n    if isinstance(node, list):\n        return [node_to_dict(e) for e in node]\n    elif isinstance(node, dict):\n        return dict((k, node_to_dict(v)) for k, v in node.items())\n    elif not isinstance(node, BaseNode):\n        return node\n    return dict((k, node_to_dict(v)) for k, v in node.__dict__.items())\n", "comments": "  todo fix     extremely important translation speed ", "content": "from .pyjsparserdata import *\n\n\nclass BaseNode:\n    def finish(self):\n        pass\n\n    def finishArrayExpression(self, elements):\n        self.type = Syntax.ArrayExpression\n        self.elements = elements\n        self.finish()\n        return self\n\n    def finishArrayPattern(self, elements):\n        self.type = Syntax.ArrayPattern\n        self.elements = elements\n        self.finish()\n        return self\n\n    def finishArrowFunctionExpression(self, params, defaults, body, expression):\n        self.type = Syntax.ArrowFunctionExpression\n        self.id = None\n        self.params = params\n        self.defaults = defaults\n        self.body = body\n        self.generator = False\n        self.expression = expression\n        self.finish()\n        return self\n\n    def finishAssignmentExpression(self, operator, left, right):\n        self.type = Syntax.AssignmentExpression\n        self.operator = operator\n        self.left = left\n        self.right = right\n        self.finish()\n        return self\n\n    def finishAssignmentPattern(self, left, right):\n        self.type = Syntax.AssignmentPattern\n        self.left = left\n        self.right = right\n        self.finish()\n        return self\n\n    def finishBinaryExpression(self, operator, left, right):\n        self.type = Syntax.LogicalExpression if (operator == '||' or operator == '&&') else Syntax.BinaryExpression\n        self.operator = operator\n        self.left = left\n        self.right = right\n        self.finish()\n        return self\n\n    def finishBlockStatement(self, body):\n        self.type = Syntax.BlockStatement\n        self.body = body\n        self.finish()\n        return self\n\n    def finishBreakStatement(self, label):\n        self.type = Syntax.BreakStatement\n        self.label = label\n        self.finish()\n        return self\n\n    def finishCallExpression(self, callee, args):\n        self.type = Syntax.CallExpression\n        self.callee = callee\n        self.arguments = args\n        self.finish()\n        return self\n\n    def finishCatchClause(self, param, body):\n        self.type = Syntax.CatchClause\n        self.param = param\n        self.body = body\n        self.finish()\n        return self\n\n    def finishClassBody(self, body):\n        self.type = Syntax.ClassBody\n        self.body = body\n        self.finish()\n        return self\n\n    def finishClassDeclaration(self, id, superClass, body):\n        self.type = Syntax.ClassDeclaration\n        self.id = id\n        self.superClass = superClass\n        self.body = body\n        self.finish()\n        return self\n\n    def finishClassExpression(self, id, superClass, body):\n        self.type = Syntax.ClassExpression\n        self.id = id\n        self.superClass = superClass\n        self.body = body\n        self.finish()\n        return self\n\n    def finishConditionalExpression(self, test, consequent, alternate):\n        self.type = Syntax.ConditionalExpression\n        self.test = test\n        self.consequent = consequent\n        self.alternate = alternate\n        self.finish()\n        return self\n\n    def finishContinueStatement(self, label):\n        self.type = Syntax.ContinueStatement\n        self.label = label\n        self.finish()\n        return self\n\n    def finishDebuggerStatement(self, ):\n        self.type = Syntax.DebuggerStatement\n        self.finish()\n        return self\n\n    def finishDoWhileStatement(self, body, test):\n        self.type = Syntax.DoWhileStatement\n        self.body = body\n        self.test = test\n        self.finish()\n        return self\n\n    def finishEmptyStatement(self, ):\n        self.type = Syntax.EmptyStatement\n        self.finish()\n        return self\n\n    def finishExpressionStatement(self, expression):\n        self.type = Syntax.ExpressionStatement\n        self.expression = expression\n        self.finish()\n        return self\n\n    def finishForStatement(self, init, test, update, body):\n        self.type = Syntax.ForStatement\n        self.init = init\n        self.test = test\n        self.update = update\n        self.body = body\n        self.finish()\n        return self\n\n    def finishForInStatement(self, left, right, body):\n        self.type = Syntax.ForInStatement\n        self.left = left\n        self.right = right\n        self.body = body\n        self.each = False\n        self.finish()\n        return self\n\n    def finishFunctionDeclaration(self, id, params, defaults, body):\n        self.type = Syntax.FunctionDeclaration\n        self.id = id\n        self.params = params\n        self.defaults = defaults\n        self.body = body\n        self.generator = False\n        self.expression = False\n        self.finish()\n        return self\n\n    def finishFunctionExpression(self, id, params, defaults, body):\n        self.type = Syntax.FunctionExpression\n        self.id = id\n        self.params = params\n        self.defaults = defaults\n        self.body = body\n        self.generator = False\n        self.expression = False\n        self.finish()\n        return self\n\n    def finishIdentifier(self, name):\n        self.type = Syntax.Identifier\n        self.name = name\n        self.finish()\n        return self\n\n    def finishIfStatement(self, test, consequent, alternate):\n        self.type = Syntax.IfStatement\n        self.test = test\n        self.consequent = consequent\n        self.alternate = alternate\n        self.finish()\n        return self\n\n    def finishLabeledStatement(self, label, body):\n        self.type = Syntax.LabeledStatement\n        self.label = label\n        self.body = body\n        self.finish()\n        return self\n\n    def finishLiteral(self, token):\n        self.type = Syntax.Literal\n        self.value = token['value']\n        self.raw = None  # todo fix it?\n        if token.get('regex'):\n            self.regex = token['regex']\n        self.finish()\n        return self\n\n    def finishMemberExpression(self, accessor, object, property):\n        self.type = Syntax.MemberExpression\n        self.computed = accessor == '['\n        self.object = object\n        self.property = property\n        self.finish()\n        return self\n\n    def finishNewExpression(self, callee, args):\n        self.type = Syntax.NewExpression\n        self.callee = callee\n        self.arguments = args\n        self.finish()\n        return self\n\n    def finishObjectExpression(self, properties):\n        self.type = Syntax.ObjectExpression\n        self.properties = properties\n        self.finish()\n        return self\n\n    def finishObjectPattern(self, properties):\n        self.type = Syntax.ObjectPattern\n        self.properties = properties\n        self.finish()\n        return self\n\n    def finishPostfixExpression(self, operator, argument):\n        self.type = Syntax.UpdateExpression\n        self.operator = operator\n        self.argument = argument\n        self.prefix = False\n        self.finish()\n        return self\n\n    def finishProgram(self, body):\n        self.type = Syntax.Program\n        self.body = body\n        self.finish()\n        return self\n\n    def finishPyimport(self, imp):\n        self.type = 'PyimportStatement'\n        self.imp = imp\n        self.finish()\n        return self\n\n    def finishProperty(self, kind, key, computed, value, method, shorthand):\n        self.type = Syntax.Property\n        self.key = key\n        self.computed = computed\n        self.value = value\n        self.kind = kind\n        self.method = method\n        self.shorthand = shorthand\n        self.finish()\n        return self\n\n    def finishRestElement(self, argument):\n        self.type = Syntax.RestElement\n        self.argument = argument\n        self.finish()\n        return self\n\n    def finishReturnStatement(self, argument):\n        self.type = Syntax.ReturnStatement\n        self.argument = argument\n        self.finish()\n        return self\n\n    def finishSequenceExpression(self, expressions):\n        self.type = Syntax.SequenceExpression\n        self.expressions = expressions\n        self.finish()\n        return self\n\n    def finishSpreadElement(self, argument):\n        self.type = Syntax.SpreadElement\n        self.argument = argument\n        self.finish()\n        return self\n\n    def finishSwitchCase(self, test, consequent):\n        self.type = Syntax.SwitchCase\n        self.test = test\n        self.consequent = consequent\n        self.finish()\n        return self\n\n    def finishSuper(self, ):\n        self.type = Syntax.Super\n        self.finish()\n        return self\n\n    def finishSwitchStatement(self, discriminant, cases):\n        self.type = Syntax.SwitchStatement\n        self.discriminant = discriminant\n        self.cases = cases\n        self.finish()\n        return self\n\n    def finishTaggedTemplateExpression(self, tag, quasi):\n        self.type = Syntax.TaggedTemplateExpression\n        self.tag = tag\n        self.quasi = quasi\n        self.finish()\n        return self\n\n    def finishTemplateElement(self, value, tail):\n        self.type = Syntax.TemplateElement\n        self.value = value\n        self.tail = tail\n        self.finish()\n        return self\n\n    def finishTemplateLiteral(self, quasis, expressions):\n        self.type = Syntax.TemplateLiteral\n        self.quasis = quasis\n        self.expressions = expressions\n        self.finish()\n        return self\n\n    def finishThisExpression(self, ):\n        self.type = Syntax.ThisExpression\n        self.finish()\n        return self\n\n    def finishThrowStatement(self, argument):\n        self.type = Syntax.ThrowStatement\n        self.argument = argument\n        self.finish()\n        return self\n\n    def finishTryStatement(self, block, handler, finalizer):\n        self.type = Syntax.TryStatement\n        self.block = block\n        self.guardedHandlers = []\n        self.handlers = [handler] if handler else []\n        self.handler = handler\n        self.finalizer = finalizer\n        self.finish()\n        return self\n\n    def finishUnaryExpression(self, operator, argument):\n        self.type = Syntax.UpdateExpression if (operator == '++' or operator == '--') else Syntax.UnaryExpression\n        self.operator = operator\n        self.argument = argument\n        self.prefix = True\n        self.finish()\n        return self\n\n    def finishVariableDeclaration(self, declarations):\n        self.type = Syntax.VariableDeclaration\n        self.declarations = declarations\n        self.kind = 'var'\n        self.finish()\n        return self\n\n    def finishLexicalDeclaration(self, declarations, kind):\n        self.type = Syntax.VariableDeclaration\n        self.declarations = declarations\n        self.kind = kind\n        self.finish()\n        return self\n\n    def finishVariableDeclarator(self, id, init):\n        self.type = Syntax.VariableDeclarator\n        self.id = id\n        self.init = init\n        self.finish()\n        return self\n\n    def finishWhileStatement(self, test, body):\n        self.type = Syntax.WhileStatement\n        self.test = test\n        self.body = body\n        self.finish()\n        return self\n\n    def finishWithStatement(self, object, body):\n        self.type = Syntax.WithStatement\n        self.object = object\n        self.body = body\n        self.finish()\n        return self\n\n    def finishExportSpecifier(self, local, exported):\n        self.type = Syntax.ExportSpecifier\n        self.exported = exported or local\n        self.local = local\n        self.finish()\n        return self\n\n    def finishImportDefaultSpecifier(self, local):\n        self.type = Syntax.ImportDefaultSpecifier\n        self.local = local\n        self.finish()\n        return self\n\n    def finishImportNamespaceSpecifier(self, local):\n        self.type = Syntax.ImportNamespaceSpecifier\n        self.local = local\n        self.finish()\n        return self\n\n    def finishExportNamedDeclaration(self, declaration, specifiers, src):\n        self.type = Syntax.ExportNamedDeclaration\n        self.declaration = declaration\n        self.specifiers = specifiers\n        self.source = src\n        self.finish()\n        return self\n\n    def finishExportDefaultDeclaration(self, declaration):\n        self.type = Syntax.ExportDefaultDeclaration\n        self.declaration = declaration\n        self.finish()\n        return self\n\n    def finishExportAllDeclaration(self, src):\n        self.type = Syntax.ExportAllDeclaration\n        self.source = src\n        self.finish()\n        return self\n\n    def finishImportSpecifier(self, local, imported):\n        self.type = Syntax.ImportSpecifier\n        self.local = local or imported\n        self.imported = imported\n        self.finish()\n        return self\n\n    def finishImportDeclaration(self, specifiers, src):\n        self.type = Syntax.ImportDeclaration\n        self.specifiers = specifiers\n        self.source = src\n        self.finish()\n        return self\n\n    def __getitem__(self, item):\n        return getattr(self, item)\n\n    def __setitem__(self, key, value):\n        setattr(self, key, value)\n\nclass Node(BaseNode):\n    pass\n\n\nclass WrappingNode(BaseNode):\n    def __init__(self, startToken=None):\n        pass\n\n\ndef node_to_dict(node):  # extremely important for translation speed\n    if isinstance(node, list):\n        return [node_to_dict(e) for e in node]\n    elif isinstance(node, dict):\n        return dict((k, node_to_dict(v)) for k, v in node.items())\n    elif not isinstance(node, BaseNode):\n        return node\n    return dict((k, node_to_dict(v)) for k, v in node.__dict__.items())\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "std_nodes.py", "id": "63cde37b2e38527e5dee1392d6ec5553", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/doc/_extensions/pyjsparser/std_nodes.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}