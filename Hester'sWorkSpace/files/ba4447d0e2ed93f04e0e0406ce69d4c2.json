{"author": "certbot", "code": "\"\"\"Tests to ensure the lock order is preserved.\"\"\"\nimport atexit\nimport functools\nimport logging\nimport os\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\n\nfrom certbot import lock\nfrom certbot import util\n\nfrom certbot.tests import util as test_util\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef main():\n    \"\"\"Run the lock tests.\"\"\"\n    dirs, base_cmd = set_up()\n    for subcommand in ('certonly', 'install', 'renew', 'run',):\n        logger.info('Testing subcommand: %s', subcommand)\n        test_command(base_cmd + [subcommand], dirs)\n    logger.info('Lock test ran successfully.')\n\n\ndef set_up():\n    \"\"\"Prepare tests to be run.\n\n    Logging is set up and temporary directories are set up to contain a\n    basic Certbot and Nginx configuration. The directories are returned\n    in the order they should be locked by Certbot. If the Nginx plugin\n    is expected to work on the system, the Nginx directory is included,\n    otherwise, it is not.\n\n    A Certbot command is also created that uses the temporary\n    directories. The returned command can be used to test different\n    subcommands by appending the desired command to the end.\n\n    :returns: directories and command\n    :rtype: `tuple` of `list`\n\n    \"\"\"\n    logging.basicConfig(format='%(message)s', level=logging.INFO)\n    config_dir, logs_dir, work_dir, nginx_dir = set_up_dirs()\n    command = set_up_command(config_dir, logs_dir, work_dir, nginx_dir)\n\n    dirs = [logs_dir, config_dir, work_dir]\n    \n    \n    if os.environ.get('CI') == 'true' or util.exe_exists('nginx'):\n        dirs.append(nginx_dir)\n    else:\n        logger.warning('Skipping Nginx lock tests')\n\n    return dirs, command\n\n\ndef set_up_dirs():\n    \"\"\"Set up directories for tests.\n\n    A temporary directory is created to contain the config, log, work,\n    and nginx directories. A sample renewal configuration is created in\n    the config directory and a basic Nginx config is placed in the Nginx\n    directory. The temporary directory containing all of these\n    directories is deleted when the program exits.\n\n    :return value: config, log, work, and nginx directories\n    :rtype: `tuple` of `str`\n\n    \"\"\"\n    temp_dir = tempfile.mkdtemp()\n    logger.debug('Created temporary directory: %s', temp_dir)\n    atexit.register(functools.partial(shutil.rmtree, temp_dir))\n\n    config_dir = os.path.join(temp_dir, 'config')\n    logs_dir = os.path.join(temp_dir, 'logs')\n    work_dir = os.path.join(temp_dir, 'work')\n    nginx_dir = os.path.join(temp_dir, 'nginx')\n\n    for directory in (config_dir, logs_dir, work_dir, nginx_dir,):\n        os.mkdir(directory)\n\n    test_util.make_lineage(config_dir, 'sample-renewal.conf')\n    set_up_nginx_dir(nginx_dir)\n\n    return config_dir, logs_dir, work_dir, nginx_dir\n\n\ndef set_up_nginx_dir(root_path):\n    \"\"\"Create a basic Nginx configuration in nginx_dir.\n\n    :param str root_path: where the Nginx server root should be placed\n\n    \"\"\"\n    \n    repo_root = check_call('git rev-parse --show-toplevel'.split()).strip()\n    conf_script = os.path.join(\n        repo_root, 'certbot-nginx', 'tests', 'boulder-integration.conf.sh')\n    \n    \n    os.environ['root'] = root_path\n    with open(os.path.join(root_path, 'nginx.conf'), 'w') as f:\n        f.write(check_call(['/bin/sh', conf_script]))\n    del os.environ['root']\n\n\ndef set_up_command(config_dir, logs_dir, work_dir, nginx_dir):\n    \"\"\"Build the Certbot command to run for testing.\n\n    You can test different subcommands by appending the desired command\n    to the returned list.\n\n    :param str config_dir: path to the configuration directory\n    :param str logs_dir: path to the logs directory\n    :param str work_dir: path to the work directory\n    :param str nginx_dir: path to the nginx directory\n\n    :returns: certbot command to execute for testing\n    :rtype: `list` of `str`\n\n    \"\"\"\n    return (\n        'certbot --cert-path {0} --key-path {1} --config-dir {2} '\n        '--logs-dir {3} --work-dir {4} --nginx-server-root {5} --debug '\n        '--force-renewal --nginx --verbose '.format(\n            test_util.vector_path('cert.pem'),\n            test_util.vector_path('rsa512_key.pem'),\n            config_dir, logs_dir, work_dir, nginx_dir).split())\n\n\ndef test_command(command, directories):\n    \"\"\"Assert Certbot acquires locks in a specific order.\n\n    command is run repeatedly testing that Certbot acquires locks on\n    directories in the order they appear in the parameter directories.\n\n    :param list command: Certbot command to execute\n    :param list directories: list of directories Certbot should fail\n        to acquire the lock on in sorted order\n\n    \"\"\"\n    locks = [lock.lock_dir(directory) for directory in directories]\n    for dir_path, dir_lock in zip(directories, locks):\n        check_error(command, dir_path)\n        dir_lock.release()\n\n\ndef check_error(command, dir_path):\n    \"\"\"Run command and verify it fails to acquire the lock for dir_path.\n\n    :param str command: certbot command to run\n    :param str dir_path: path to directory containing the lock Certbot\n        should fail on\n\n    \"\"\"\n    ret, out, err = subprocess_call(command)\n    if ret == 0:\n        report_failure(\"Certbot didn't exit with a nonzero status!\", out, err)\n\n    match = re.search(\"Please see the logfile '(.*)' for more details\", err)\n    if match is not None:\n        \n        with open(match.group(1)) as f:\n            err = f.read()\n\n    pattern = 'A lock on {0}.* is held by another process'.format(dir_path)\n    if not re.search(pattern, err):\n        err_msg = 'Directory path {0} not in error output!'.format(dir_path)\n        report_failure(err_msg, out, err)\n\n\ndef check_call(args):\n    \"\"\"Simple imitation of subprocess.check_call.\n\n    This function is only available in subprocess in Python 2.7+.\n\n    :param list args: program and it's arguments to be run\n\n    :returns: stdout output\n    :rtype: str\n\n    \"\"\"\n    exit_code, out, err = subprocess_call(args)\n    if exit_code:\n        report_failure('Command exited with a nonzero status!', out, err)\n    return out\n\n\ndef report_failure(err_msg, out, err):\n    \"\"\"Report a subprocess failure and exit.\n\n    :param str err_msg: error message to report\n    :param str out: stdout output\n    :param str err: stderr output\n\n    \"\"\"\n    logger.fatal(err_msg)\n    log_output(logging.INFO, out, err)\n    sys.exit(err_msg)\n\n\ndef subprocess_call(args):\n    \"\"\"Run a command with subprocess and return the result.\n\n    :param list args: program and it's arguments to be run\n\n    :returns: return code, stdout output, stderr output\n    :rtype: tuple\n\n    \"\"\"\n    process = subprocess.Popen(args, stdout=subprocess.PIPE,\n                               stderr=subprocess.PIPE, universal_newlines=True)\n    out, err = process.communicate()\n    logger.debug('Return code was %d', process.returncode)\n    log_output(logging.DEBUG, out, err)\n    return process.returncode, out, err\n\n\ndef log_output(level, out, err):\n    \"\"\"Logs stdout and stderr output at the requested level.\n\n    :param int level: logging level to use\n    :param str out: stdout output\n    :param str err: stderr output\n\n    \"\"\"\n    if out:\n        logger.log(level, 'Stdout output was:\\n%s', out)\n    if err:\n        logger.log(level, 'Stderr output was:\\n%s', err)\n\n\nif __name__ == \"__main__\":\n    main()\n", "comments": "   tests ensure lock order preserved     import atexit import functools import logging import os import import shutil import subprocess import sys import tempfile  certbot import lock certbot import util  certbot tests import util test util   logger   logging getlogger(  name  )   def main()         run lock tests         dirs  base cmd   set up()     subcommand ( certonly    install    renew    run  )          logger info( testing subcommand     subcommand)         test command(base cmd    subcommand   dirs)     logger info( lock test ran successfully  )   def set up()         prepare tests run       logging set temporary directories set contain     basic certbot nginx configuration  the directories returned     order locked certbot  if nginx plugin     expected work system  nginx directory included      otherwise        a certbot command also created uses temporary     directories  the returned command used test different     subcommands appending desired command end        returns  directories command      rtype   tuple   list               logging basicconfig(format   (message)s   level logging info)     config dir  logs dir  work dir  nginx dir   set dirs()     command   set command(config dir  logs dir  work dir  nginx dir)      dirs    logs dir  config dir  work dir        travis circle ci set ci true       always test nginx lock ci     os environ get( ci )     true  util exe exists( nginx )          dirs append(nginx dir)     else          logger warning( skipping nginx lock tests )      return dirs  command   def set dirs()         set directories tests       a temporary directory created contain config  log  work      nginx directories  a sample renewal configuration created     config directory basic nginx config placed nginx     directory  the temporary directory containing     directories deleted program exits        return value  config  log  work  nginx directories      rtype   tuple   str               temp dir   tempfile mkdtemp()     logger debug( created temporary directory     temp dir)     atexit register(functools partial(shutil rmtree  temp dir))      config dir   os path join(temp dir   config )     logs dir   os path join(temp dir   logs )     work dir   os path join(temp dir   work )     nginx dir   os path join(temp dir   nginx )      directory (config dir  logs dir  work dir  nginx dir )          os mkdir(directory)      test util make lineage(config dir   sample renewal conf )     set nginx dir(nginx dir)      return config dir  logs dir  work dir  nginx dir   def set nginx dir(root path)         create basic nginx configuration nginx dir        param str root path  nginx server root placed                get root git repository     repo root   check call( git rev parse   show toplevel  split()) strip()     conf script   os path join(         repo root   certbot nginx    tests    boulder integration conf sh )       boulder integration conf sh uses root environment variable       nginx server root writing paths     os environ  root     root path     open(os path join(root path   nginx conf )   w ) f          f write(check call(   bin sh   conf script ))     del os environ  root     def set command(config dir  logs dir  work dir  nginx dir)         build certbot command run testing       you test different subcommands appending desired command     returned list        param str config dir  path configuration directory      param str logs dir  path logs directory      param str work dir  path work directory      param str nginx dir  path nginx directory       returns  certbot command execute testing      rtype   list   str               return (          certbot   cert path  0    key path  1    config dir  2               logs dir  3    work dir  4    nginx server root  5    debug              force renewal   nginx   verbose   format(             test util vector path( cert pem )              test util vector path( rsa512 key pem )              config dir  logs dir  work dir  nginx dir) split())   def test command(command  directories)         assert certbot acquires locks specific order       command run repeatedly testing certbot acquires locks     directories order appear parameter directories        param list command  certbot command execute      param list directories  list directories certbot fail         acquire lock sorted order              locks    lock lock dir(directory) directory directories      dir path  dir lock zip(directories  locks)          check error(command  dir path)         dir lock release()   def check error(command  dir path)         run command verify fails acquire lock dir path        param str command  certbot command run      param str dir path  path directory containing lock certbot         fail              ret   err   subprocess call(command)     ret    0          report failure( certbot exit nonzero status     err)      match   search( please see logfile  (  )  details   err)     match none            get error output verbose logfile         open(match group(1)) f              err   f read()      pattern    a lock  0    held another process  format(dir path)     search(pattern  err)          err msg    directory path  0  error output   format(dir path)         report failure(err msg   err)   def check call(args)         simple imitation subprocess check call       this function available subprocess python 2 7         param list args  program arguments run       returns  stdout output      rtype  str              exit code   err   subprocess call(args)     exit code          report failure( command exited nonzero status     err)     return   def report failure(err msg   err)         report subprocess failure exit        param str err msg  error message report      param str  stdout output      param str err  stderr output              logger fatal(err msg)     log output(logging info   err)     sys exit(err msg)   def subprocess call(args)         run command subprocess return result        param list args  program arguments run       returns  return code  stdout output  stderr output      rtype  tuple              process   subprocess popen(args  stdout subprocess pipe                                 stderr subprocess pipe  universal newlines true)      err   process communicate()     logger debug( return code    process returncode)     log output(logging debug   err)     return process returncode   err   def log output(level   err)         logs stdout stderr output requested level        param int level  logging level use      param str  stdout output      param str err  stderr output             travis circle ci set ci true    always test nginx lock ci    get root git repository    boulder integration conf sh uses root environment variable    nginx server root writing paths    get error output verbose logfile ", "content": "\"\"\"Tests to ensure the lock order is preserved.\"\"\"\nimport atexit\nimport functools\nimport logging\nimport os\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\n\nfrom certbot import lock\nfrom certbot import util\n\nfrom certbot.tests import util as test_util\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef main():\n    \"\"\"Run the lock tests.\"\"\"\n    dirs, base_cmd = set_up()\n    for subcommand in ('certonly', 'install', 'renew', 'run',):\n        logger.info('Testing subcommand: %s', subcommand)\n        test_command(base_cmd + [subcommand], dirs)\n    logger.info('Lock test ran successfully.')\n\n\ndef set_up():\n    \"\"\"Prepare tests to be run.\n\n    Logging is set up and temporary directories are set up to contain a\n    basic Certbot and Nginx configuration. The directories are returned\n    in the order they should be locked by Certbot. If the Nginx plugin\n    is expected to work on the system, the Nginx directory is included,\n    otherwise, it is not.\n\n    A Certbot command is also created that uses the temporary\n    directories. The returned command can be used to test different\n    subcommands by appending the desired command to the end.\n\n    :returns: directories and command\n    :rtype: `tuple` of `list`\n\n    \"\"\"\n    logging.basicConfig(format='%(message)s', level=logging.INFO)\n    config_dir, logs_dir, work_dir, nginx_dir = set_up_dirs()\n    command = set_up_command(config_dir, logs_dir, work_dir, nginx_dir)\n\n    dirs = [logs_dir, config_dir, work_dir]\n    # Travis and Circle CI set CI to true so we\n    # will always test Nginx's lock during CI\n    if os.environ.get('CI') == 'true' or util.exe_exists('nginx'):\n        dirs.append(nginx_dir)\n    else:\n        logger.warning('Skipping Nginx lock tests')\n\n    return dirs, command\n\n\ndef set_up_dirs():\n    \"\"\"Set up directories for tests.\n\n    A temporary directory is created to contain the config, log, work,\n    and nginx directories. A sample renewal configuration is created in\n    the config directory and a basic Nginx config is placed in the Nginx\n    directory. The temporary directory containing all of these\n    directories is deleted when the program exits.\n\n    :return value: config, log, work, and nginx directories\n    :rtype: `tuple` of `str`\n\n    \"\"\"\n    temp_dir = tempfile.mkdtemp()\n    logger.debug('Created temporary directory: %s', temp_dir)\n    atexit.register(functools.partial(shutil.rmtree, temp_dir))\n\n    config_dir = os.path.join(temp_dir, 'config')\n    logs_dir = os.path.join(temp_dir, 'logs')\n    work_dir = os.path.join(temp_dir, 'work')\n    nginx_dir = os.path.join(temp_dir, 'nginx')\n\n    for directory in (config_dir, logs_dir, work_dir, nginx_dir,):\n        os.mkdir(directory)\n\n    test_util.make_lineage(config_dir, 'sample-renewal.conf')\n    set_up_nginx_dir(nginx_dir)\n\n    return config_dir, logs_dir, work_dir, nginx_dir\n\n\ndef set_up_nginx_dir(root_path):\n    \"\"\"Create a basic Nginx configuration in nginx_dir.\n\n    :param str root_path: where the Nginx server root should be placed\n\n    \"\"\"\n    # Get the root of the git repository\n    repo_root = check_call('git rev-parse --show-toplevel'.split()).strip()\n    conf_script = os.path.join(\n        repo_root, 'certbot-nginx', 'tests', 'boulder-integration.conf.sh')\n    # boulder-integration.conf.sh uses the root environment variable as\n    # the Nginx server root when writing paths\n    os.environ['root'] = root_path\n    with open(os.path.join(root_path, 'nginx.conf'), 'w') as f:\n        f.write(check_call(['/bin/sh', conf_script]))\n    del os.environ['root']\n\n\ndef set_up_command(config_dir, logs_dir, work_dir, nginx_dir):\n    \"\"\"Build the Certbot command to run for testing.\n\n    You can test different subcommands by appending the desired command\n    to the returned list.\n\n    :param str config_dir: path to the configuration directory\n    :param str logs_dir: path to the logs directory\n    :param str work_dir: path to the work directory\n    :param str nginx_dir: path to the nginx directory\n\n    :returns: certbot command to execute for testing\n    :rtype: `list` of `str`\n\n    \"\"\"\n    return (\n        'certbot --cert-path {0} --key-path {1} --config-dir {2} '\n        '--logs-dir {3} --work-dir {4} --nginx-server-root {5} --debug '\n        '--force-renewal --nginx --verbose '.format(\n            test_util.vector_path('cert.pem'),\n            test_util.vector_path('rsa512_key.pem'),\n            config_dir, logs_dir, work_dir, nginx_dir).split())\n\n\ndef test_command(command, directories):\n    \"\"\"Assert Certbot acquires locks in a specific order.\n\n    command is run repeatedly testing that Certbot acquires locks on\n    directories in the order they appear in the parameter directories.\n\n    :param list command: Certbot command to execute\n    :param list directories: list of directories Certbot should fail\n        to acquire the lock on in sorted order\n\n    \"\"\"\n    locks = [lock.lock_dir(directory) for directory in directories]\n    for dir_path, dir_lock in zip(directories, locks):\n        check_error(command, dir_path)\n        dir_lock.release()\n\n\ndef check_error(command, dir_path):\n    \"\"\"Run command and verify it fails to acquire the lock for dir_path.\n\n    :param str command: certbot command to run\n    :param str dir_path: path to directory containing the lock Certbot\n        should fail on\n\n    \"\"\"\n    ret, out, err = subprocess_call(command)\n    if ret == 0:\n        report_failure(\"Certbot didn't exit with a nonzero status!\", out, err)\n\n    match = re.search(\"Please see the logfile '(.*)' for more details\", err)\n    if match is not None:\n        # Get error output from more verbose logfile\n        with open(match.group(1)) as f:\n            err = f.read()\n\n    pattern = 'A lock on {0}.* is held by another process'.format(dir_path)\n    if not re.search(pattern, err):\n        err_msg = 'Directory path {0} not in error output!'.format(dir_path)\n        report_failure(err_msg, out, err)\n\n\ndef check_call(args):\n    \"\"\"Simple imitation of subprocess.check_call.\n\n    This function is only available in subprocess in Python 2.7+.\n\n    :param list args: program and it's arguments to be run\n\n    :returns: stdout output\n    :rtype: str\n\n    \"\"\"\n    exit_code, out, err = subprocess_call(args)\n    if exit_code:\n        report_failure('Command exited with a nonzero status!', out, err)\n    return out\n\n\ndef report_failure(err_msg, out, err):\n    \"\"\"Report a subprocess failure and exit.\n\n    :param str err_msg: error message to report\n    :param str out: stdout output\n    :param str err: stderr output\n\n    \"\"\"\n    logger.fatal(err_msg)\n    log_output(logging.INFO, out, err)\n    sys.exit(err_msg)\n\n\ndef subprocess_call(args):\n    \"\"\"Run a command with subprocess and return the result.\n\n    :param list args: program and it's arguments to be run\n\n    :returns: return code, stdout output, stderr output\n    :rtype: tuple\n\n    \"\"\"\n    process = subprocess.Popen(args, stdout=subprocess.PIPE,\n                               stderr=subprocess.PIPE, universal_newlines=True)\n    out, err = process.communicate()\n    logger.debug('Return code was %d', process.returncode)\n    log_output(logging.DEBUG, out, err)\n    return process.returncode, out, err\n\n\ndef log_output(level, out, err):\n    \"\"\"Logs stdout and stderr output at the requested level.\n\n    :param int level: logging level to use\n    :param str out: stdout output\n    :param str err: stderr output\n\n    \"\"\"\n    if out:\n        logger.log(level, 'Stdout output was:\\n%s', out)\n    if err:\n        logger.log(level, 'Stderr output was:\\n%s', err)\n\n\nif __name__ == \"__main__\":\n    main()\n", "description": "Certbot is EFF's tool to obtain certs from Let's Encrypt and (optionally) auto-enable HTTPS on your server.  It can also act as a client for any other CA that uses the ACME protocol.", "file_name": "lock_test.py", "id": "ba4447d0e2ed93f04e0e0406ce69d4c2", "language": "Python", "project_name": "certbot", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/certbot-certbot/certbot-certbot-3077b51/tests/lock_test.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:52:22Z", "url": "https://github.com/certbot/certbot", "wiki": false}