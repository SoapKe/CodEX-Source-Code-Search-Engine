{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    xpath_text,\n    find_xpath_attr,\n    determine_ext,\n    int_or_none,\n    unified_strdate,\n    xpath_element,\n    ExtractorError,\n    determine_protocol,\n    unsmuggle_url,\n)\n\n\nclass RadioCanadaIE(InfoExtractor):\n    IE_NAME = 'radiocanada'\n    _VALID_URL = r'(?:radiocanada:|https?://ici\\.radio-canada\\.ca/widgets/mediaconsole/)(?P<app_code>[^:/]+)[:/](?P<id>[0-9]+)'\n    _TESTS = [\n        {\n            'url': 'http://ici.radio-canada.ca/widgets/mediaconsole/medianet/7184272',\n            'info_dict': {\n                'id': '7184272',\n                'ext': 'mp4',\n                'title': 'Le parcours du tireur capt\u00e9 sur vid\u00e9o',\n                'description': 'Images des cam\u00e9ras de surveillance fournies par la GRC montrant le parcours du tireur d\\'Ottawa',\n                'upload_date': '20141023',\n            },\n            'params': {\n                \n                'skip_download': True,\n            }\n        },\n        {\n            \n            'url': 'http://ici.radio-canada.ca/widgets/mediaconsole/medianet/7754998/',\n            'info_dict': {\n                'id': '7754998',\n                'ext': 'mp4',\n                'title': 'letelejournal22h',\n                'description': 'INTEGRALE WEB 22H-TJ',\n                'upload_date': '20170720',\n            },\n            'params': {\n                \n                'skip_download': True,\n            },\n        }\n    ]\n\n    def _real_extract(self, url):\n        url, smuggled_data = unsmuggle_url(url, {})\n        app_code, video_id = re.match(self._VALID_URL, url).groups()\n\n        metadata = self._download_xml(\n            'http://api.radio-canada.ca/metaMedia/v1/index.ashx',\n            video_id, note='Downloading metadata XML', query={\n                'appCode': app_code,\n                'idMedia': video_id,\n            })\n\n        def get_meta(name):\n            el = find_xpath_attr(metadata, './/Meta', 'name', name)\n            return el.text if el is not None else None\n\n        if get_meta('protectionType'):\n            raise ExtractorError('This video is DRM protected.', expected=True)\n\n        device_types = ['ipad']\n        if not smuggled_data:\n            device_types.append('flash')\n            device_types.append('android')\n\n        formats = []\n        error = None\n        \n        \n        for device_type in device_types:\n            validation_url = 'http://api.radio-canada.ca/validationMedia/v1/Validation.ashx'\n            query = {\n                'appCode': app_code,\n                'idMedia': video_id,\n                'connectionType': 'broadband',\n                'multibitrate': 'true',\n                'deviceType': device_type,\n            }\n            if smuggled_data:\n                validation_url = 'https://services.radio-canada.ca/media/validation/v2/'\n                query.update(smuggled_data)\n            else:\n                query.update({\n                    \n                    'paysJ391wsHjbOJwvCs26toz': 'CA',\n                    'bypasslock': 'NZt5K62gRqfc',\n                })\n            v_data = self._download_xml(validation_url, video_id, note='Downloading %s XML' % device_type, query=query, fatal=False)\n            v_url = xpath_text(v_data, 'url')\n            if not v_url:\n                continue\n            if v_url == 'null':\n                error = xpath_text(v_data, 'message')\n                continue\n            ext = determine_ext(v_url)\n            if ext == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    v_url, video_id, 'mp4', m3u8_id='hls', fatal=False))\n            elif ext == 'f4m':\n                formats.extend(self._extract_f4m_formats(\n                    v_url, video_id, f4m_id='hds', fatal=False))\n            else:\n                ext = determine_ext(v_url)\n                bitrates = xpath_element(v_data, 'bitrates')\n                for url_e in bitrates.findall('url'):\n                    tbr = int_or_none(url_e.get('bitrate'))\n                    if not tbr:\n                        continue\n                    f_url = re.sub(r'\\d+\\.%s' % ext, '%d.%s' % (tbr, ext), v_url)\n                    protocol = determine_protocol({'url': f_url})\n                    f = {\n                        'format_id': '%s-%d' % (protocol, tbr),\n                        'url': f_url,\n                        'ext': 'flv' if protocol == 'rtmp' else ext,\n                        'protocol': protocol,\n                        'width': int_or_none(url_e.get('width')),\n                        'height': int_or_none(url_e.get('height')),\n                        'tbr': tbr,\n                    }\n                    mobj = re.match(r'(?P<url>rtmp://[^/]+/[^/]+)/(?P<playpath>[^?]+)(?P<auth>\\?.+)', f_url)\n                    if mobj:\n                        f.update({\n                            'url': mobj.group('url') + mobj.group('auth'),\n                            'play_path': mobj.group('playpath'),\n                        })\n                    formats.append(f)\n                    if protocol == 'rtsp':\n                        base_url = self._search_regex(\n                            r'rtsp://([^?]+)', f_url, 'base url', default=None)\n                        if base_url:\n                            base_url = 'http://' + base_url\n                            formats.extend(self._extract_m3u8_formats(\n                                base_url + '/playlist.m3u8', video_id, 'mp4',\n                                'm3u8_native', m3u8_id='hls', fatal=False))\n                            formats.extend(self._extract_f4m_formats(\n                                base_url + '/manifest.f4m', video_id,\n                                f4m_id='hds', fatal=False))\n        if not formats and error:\n            raise ExtractorError(\n                '%s said: %s' % (self.IE_NAME, error), expected=True)\n        self._sort_formats(formats)\n\n        subtitles = {}\n        closed_caption_url = get_meta('closedCaption') or get_meta('closedCaptionHTML5')\n        if closed_caption_url:\n            subtitles['fr'] = [{\n                'url': closed_caption_url,\n                'ext': determine_ext(closed_caption_url, 'vtt'),\n            }]\n\n        return {\n            'id': video_id,\n            'title': get_meta('Title') or get_meta('AV-nomEmission'),\n            'description': get_meta('Description') or get_meta('ShortDescription'),\n            'thumbnail': get_meta('imageHR') or get_meta('imageMR') or get_meta('imageBR'),\n            'duration': int_or_none(get_meta('length')),\n            'series': get_meta('Emission'),\n            'season_number': int_or_none('SrcSaison'),\n            'episode_number': int_or_none('SrcEpisode'),\n            'upload_date': unified_strdate(get_meta('Date')),\n            'subtitles': subtitles,\n            'formats': formats,\n        }\n\n\nclass RadioCanadaAudioVideoIE(InfoExtractor):\n    'radiocanada:audiovideo'\n    _VALID_URL = r'https?://ici\\.radio-canada\\.ca/audio-video/media-(?P<id>[0-9]+)'\n    _TEST = {\n        'url': 'http://ici.radio-canada.ca/audio-video/media-7527184/barack-obama-au-vietnam',\n        'info_dict': {\n            'id': '7527184',\n            'ext': 'mp4',\n            'title': 'Barack Obama au Vietnam',\n            'description': 'Les \u00c9tats-Unis l\u00e8vent l\\'embargo sur la vente d\\'armes qui datait de la guerre du Vietnam',\n            'upload_date': '20160523',\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }\n\n    def _real_extract(self, url):\n        return self.url_result('radiocanada:medianet:%s' % self._match_id(url))\n", "comments": "# coding: utf-8\n# m3u8 download\n# empty Title\n# m3u8 download\n# TODO: extract f4m formats\n# f4m formats can be extracted using flashhd device_type but they produce unplayable file\n# paysJ391wsHjbOJwvCs26toz and bypasslock are used to bypass geo-restriction\n# m3u8 download\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    xpath_text,\n    find_xpath_attr,\n    determine_ext,\n    int_or_none,\n    unified_strdate,\n    xpath_element,\n    ExtractorError,\n    determine_protocol,\n    unsmuggle_url,\n)\n\n\nclass RadioCanadaIE(InfoExtractor):\n    IE_NAME = 'radiocanada'\n    _VALID_URL = r'(?:radiocanada:|https?://ici\\.radio-canada\\.ca/widgets/mediaconsole/)(?P<app_code>[^:/]+)[:/](?P<id>[0-9]+)'\n    _TESTS = [\n        {\n            'url': 'http://ici.radio-canada.ca/widgets/mediaconsole/medianet/7184272',\n            'info_dict': {\n                'id': '7184272',\n                'ext': 'mp4',\n                'title': 'Le parcours du tireur capt\u00e9 sur vid\u00e9o',\n                'description': 'Images des cam\u00e9ras de surveillance fournies par la GRC montrant le parcours du tireur d\\'Ottawa',\n                'upload_date': '20141023',\n            },\n            'params': {\n                # m3u8 download\n                'skip_download': True,\n            }\n        },\n        {\n            # empty Title\n            'url': 'http://ici.radio-canada.ca/widgets/mediaconsole/medianet/7754998/',\n            'info_dict': {\n                'id': '7754998',\n                'ext': 'mp4',\n                'title': 'letelejournal22h',\n                'description': 'INTEGRALE WEB 22H-TJ',\n                'upload_date': '20170720',\n            },\n            'params': {\n                # m3u8 download\n                'skip_download': True,\n            },\n        }\n    ]\n\n    def _real_extract(self, url):\n        url, smuggled_data = unsmuggle_url(url, {})\n        app_code, video_id = re.match(self._VALID_URL, url).groups()\n\n        metadata = self._download_xml(\n            'http://api.radio-canada.ca/metaMedia/v1/index.ashx',\n            video_id, note='Downloading metadata XML', query={\n                'appCode': app_code,\n                'idMedia': video_id,\n            })\n\n        def get_meta(name):\n            el = find_xpath_attr(metadata, './/Meta', 'name', name)\n            return el.text if el is not None else None\n\n        if get_meta('protectionType'):\n            raise ExtractorError('This video is DRM protected.', expected=True)\n\n        device_types = ['ipad']\n        if not smuggled_data:\n            device_types.append('flash')\n            device_types.append('android')\n\n        formats = []\n        error = None\n        # TODO: extract f4m formats\n        # f4m formats can be extracted using flashhd device_type but they produce unplayable file\n        for device_type in device_types:\n            validation_url = 'http://api.radio-canada.ca/validationMedia/v1/Validation.ashx'\n            query = {\n                'appCode': app_code,\n                'idMedia': video_id,\n                'connectionType': 'broadband',\n                'multibitrate': 'true',\n                'deviceType': device_type,\n            }\n            if smuggled_data:\n                validation_url = 'https://services.radio-canada.ca/media/validation/v2/'\n                query.update(smuggled_data)\n            else:\n                query.update({\n                    # paysJ391wsHjbOJwvCs26toz and bypasslock are used to bypass geo-restriction\n                    'paysJ391wsHjbOJwvCs26toz': 'CA',\n                    'bypasslock': 'NZt5K62gRqfc',\n                })\n            v_data = self._download_xml(validation_url, video_id, note='Downloading %s XML' % device_type, query=query, fatal=False)\n            v_url = xpath_text(v_data, 'url')\n            if not v_url:\n                continue\n            if v_url == 'null':\n                error = xpath_text(v_data, 'message')\n                continue\n            ext = determine_ext(v_url)\n            if ext == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    v_url, video_id, 'mp4', m3u8_id='hls', fatal=False))\n            elif ext == 'f4m':\n                formats.extend(self._extract_f4m_formats(\n                    v_url, video_id, f4m_id='hds', fatal=False))\n            else:\n                ext = determine_ext(v_url)\n                bitrates = xpath_element(v_data, 'bitrates')\n                for url_e in bitrates.findall('url'):\n                    tbr = int_or_none(url_e.get('bitrate'))\n                    if not tbr:\n                        continue\n                    f_url = re.sub(r'\\d+\\.%s' % ext, '%d.%s' % (tbr, ext), v_url)\n                    protocol = determine_protocol({'url': f_url})\n                    f = {\n                        'format_id': '%s-%d' % (protocol, tbr),\n                        'url': f_url,\n                        'ext': 'flv' if protocol == 'rtmp' else ext,\n                        'protocol': protocol,\n                        'width': int_or_none(url_e.get('width')),\n                        'height': int_or_none(url_e.get('height')),\n                        'tbr': tbr,\n                    }\n                    mobj = re.match(r'(?P<url>rtmp://[^/]+/[^/]+)/(?P<playpath>[^?]+)(?P<auth>\\?.+)', f_url)\n                    if mobj:\n                        f.update({\n                            'url': mobj.group('url') + mobj.group('auth'),\n                            'play_path': mobj.group('playpath'),\n                        })\n                    formats.append(f)\n                    if protocol == 'rtsp':\n                        base_url = self._search_regex(\n                            r'rtsp://([^?]+)', f_url, 'base url', default=None)\n                        if base_url:\n                            base_url = 'http://' + base_url\n                            formats.extend(self._extract_m3u8_formats(\n                                base_url + '/playlist.m3u8', video_id, 'mp4',\n                                'm3u8_native', m3u8_id='hls', fatal=False))\n                            formats.extend(self._extract_f4m_formats(\n                                base_url + '/manifest.f4m', video_id,\n                                f4m_id='hds', fatal=False))\n        if not formats and error:\n            raise ExtractorError(\n                '%s said: %s' % (self.IE_NAME, error), expected=True)\n        self._sort_formats(formats)\n\n        subtitles = {}\n        closed_caption_url = get_meta('closedCaption') or get_meta('closedCaptionHTML5')\n        if closed_caption_url:\n            subtitles['fr'] = [{\n                'url': closed_caption_url,\n                'ext': determine_ext(closed_caption_url, 'vtt'),\n            }]\n\n        return {\n            'id': video_id,\n            'title': get_meta('Title') or get_meta('AV-nomEmission'),\n            'description': get_meta('Description') or get_meta('ShortDescription'),\n            'thumbnail': get_meta('imageHR') or get_meta('imageMR') or get_meta('imageBR'),\n            'duration': int_or_none(get_meta('length')),\n            'series': get_meta('Emission'),\n            'season_number': int_or_none('SrcSaison'),\n            'episode_number': int_or_none('SrcEpisode'),\n            'upload_date': unified_strdate(get_meta('Date')),\n            'subtitles': subtitles,\n            'formats': formats,\n        }\n\n\nclass RadioCanadaAudioVideoIE(InfoExtractor):\n    'radiocanada:audiovideo'\n    _VALID_URL = r'https?://ici\\.radio-canada\\.ca/audio-video/media-(?P<id>[0-9]+)'\n    _TEST = {\n        'url': 'http://ici.radio-canada.ca/audio-video/media-7527184/barack-obama-au-vietnam',\n        'info_dict': {\n            'id': '7527184',\n            'ext': 'mp4',\n            'title': 'Barack Obama au Vietnam',\n            'description': 'Les \u00c9tats-Unis l\u00e8vent l\\'embargo sur la vente d\\'armes qui datait de la guerre du Vietnam',\n            'upload_date': '20160523',\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n    }\n\n    def _real_extract(self, url):\n        return self.url_result('radiocanada:medianet:%s' % self._match_id(url))\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "radiocanada.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/radiocanada.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}