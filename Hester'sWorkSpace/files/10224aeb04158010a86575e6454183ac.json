{"author": "USArmyResearchLab", "code": "import dshell\nimport util\nimport binascii\nimport json\nfrom struct import unpack\n\n\n\nMAGIC_VALS = {'F9 BE B4 D9': 'BITCOIN-MAIN',\n              'FA BF B5 DA': 'BITCOIN-TESTNET',\n              '0B 11 09 07': 'BITCOIN-TESTNET3'}\n\n\nclass DshellDecoder(dshell.TCPDecoder):\n\n    def __init__(self):\n        dshell.TCPDecoder.__init__(self,\n                            name='bitcoin',\n                            description='Extract Bitcoin traffic, including Stratum mining protocol (pooled) traffic',\n                            longdescription='''\nThe bitcoin decoder will extract any Bitcoin traffic attempting to find and output: \n    Client/server IP addresses, src/dst port numbers, MAC addresses of the machines\n    used in the Bitcoin communication/transactions, timestamps of the packets,\n    packet payload sizes in KB, and the Network type \n    ('Bitcoin Main' if Bitcoin data traffic)  \n\nAdditionally for Stratum mining, it will attempt to extract:\n    Bitcoin miner being used, transaction methods used in each connection \n    (mining.notify, mining.authorize, mining.get_transaction, mining.submit, etc.), \n    User ID (Auth ID) used to access the Bitcoin mining pool, and possibly the password \n    used to connect to the pool if it is stored in the JSON of the payload.\n\n    Also, the: \n    range of job IDs (per connection), previous block hash, generation transaction (part 1), \n    generation transaction (part 2), merkle tree branches (hashes), block version, \n    and the hash difficulty (n-bits)\n    (The generation transactions and merkle tree branches are only optionally outputted \n     to a file: See Example (3) below)\n \n    Note (1): The first time that all of this Stratum mining information is \n              collected (per connection), all of the packets decoded after this \n              point from within the same connection (same exact sip, dip, sport, dport) \n              will continue to output the same collection of information since it \n              will be the same.\n\n    Note (2): The gen_tx1 and gen_tx2 fields enable the miner to build the coinbase\n              transaction for the block by concatentating gen_tx1, the extranonce1 \n              at the start of gen_tx1, the extranonce2 generated by the miner, and \n              gen_tx2 (hashes with scriptPubKeys)\n\n    Note (3): Some pools recommend miners use their Bitcoin wallet ID \n              (address used for payment) as their 'Auth ID'. This will be easily \n              spotted as it is an address consisting of 26-35 alphanumeric characters, \n              and it always begins with either the number '1' or '3'\n\n\n    For additional information: \n        Bitcoin Protocol:        <https://en.bitcoin.it/wiki/Protocol_documentation>\n        Stratum Mining Protocol: <https://en.bitcoin.it/wiki/Stratum_mining_protocol>\n\n\n--------Main ports / Some secondary ports used for Bitcoin Traffic---------\n    Bitcoin Main traffic uses port 8333\n    Bitcoin Testnet uses port 18333\n    Several pools use ports 3333, 8332, 8337\n    The other ports checked are known ports used by specific BTC mining pools\n    Other Bitcoin pools utilize alternate ports (even 80 / 443)\n\n\nExamples:\n    \n    (1) Basic usage:\n\n        decode -d bitcoin <pcap>\n\n    (2) If pcap starts in middle of connection (then we need to ignore TCP handshake):\n        \n        decode -d bitcoin <pcap> --bitcoin_ignore_handshake\n\n    (3) Saving Generation Transaction Data and Merkle Branches to a specified file:\n\n        decode -d bitcoin <pcap> --bitcoin_gentx='foo.txt.'\n''',\n                            filter='''tcp and port (3332 or 3333 or 3334 or 3335 or\n                                                    4008 or 4012 or 4016 or 4024 or\n                                                    4032 or 4048 or 4064 or 4096 or\n                                                    4128 or 4256 or 5050 or 7033 or\n                                                    7065 or 7129 or 7777 or 8332 or\n                                                    8333 or 8334 or 8336 or 8337 or \n                                                    8344 or 8347 or 8361 or 8888 or \n                                                    9332 or 9337 or 9999 or 11111 or \n                                                    12222 or 17777 or 18333)''',\n                            author='dek',\n                            optiondict={\n                                    'gentx' : {'type' : 'str', 'default' : '', 'help' : 'The name of the file to output the fields used to generate the block transaction (gen_tx1, gen_tx2, merkle_branches).'},\n                            }\n                            )\n        self.auth_ids = {}\n        self.notify_params = {}\n        self.methods = {}\n        self.miners = {} \n        self.job_ids = {}\n        self.smac = None\n        self.dmac = None\n        self.bc_net = None\n        self.size = 0\n        self.JSON = False\n        self.NOTIFY = False\n\n        \n    \n    \n    def blobHandler(self, conn, blob):\n\n        try:\n            data = blob.data()\n        except:\n            self.warn('could not parse session data')\n            return\n        \n        \n        if not data:\n            return\n\n        \n        job_id = None \n        prev_blk_hash = None \n        gen_tx1 = None  \n        gen_tx2 = None \n        merkle_branches = None\n        blk_ver = None \n        difficulty = None \n        curr_time = None \n        clean_jobs = None \n        \n        \n        if data.startswith('{\"'):\n            self.JSON = True\n            try:\n                \n                for rawjs in data.split(\"\\n\"):\n                    if rawjs:\n                        js = json.loads(rawjs)\n                        try:\n                            if \"method\" in js and js[\"method\"]:\n                                \n                                #   indexed by their associated conn.addr (sip, dip, sport, dport) \n                                self.methods.setdefault(conn.addr, set([])).add(js[\"method\"])\n\n                                if js[\"method\"] == \"mining.subscribe\":\n                                    self.miners[conn.addr] = js[\"params\"][0]\n                            \n                                if js[\"method\"] == \"mining.authorize\":\n                                    if \"params\" in js and js['params'][0]:\n                                        # Grab the Bitcoin User ID (sometimes a wallet id) \n                                        \n                                        self.auth_ids[conn.addr] = js[\"params\"][0]\n\n                                        if js['params'][1]:\n                                            self.auth_ids[conn.addr] = \"\".join(( \n                                                self.auth_ids[conn.addr], \" / \",  str(js['params'][1]) ))\n                                            \n                                if js[\"method\"] == \"mining.notify\":\n                                    self.NOTIFY = True\n                                    if \"params\" in js and js['params']:\n                                        job_id, prev_blk_hash, gen_tx1, gen_tx2, merkle_branches, blk_ver, difficulty, curr_time, clean_jobs = js['params']\n                                        self.job_ids.setdefault(conn.addr, []).append(job_id)\n                                        self.notify_params[conn.addr] = [self.job_ids, prev_blk_hash, gen_tx1,\n                                                                         gen_tx2, merkle_branches,\n                                                                         blk_ver, difficulty, curr_time,\n                                                                         clean_jobs]\n\n                        except KeyError as e:\n                            self.warn(\"{} - Error extracting auth ID\".format(str(e)))\n            except ValueError as e:\n                self.warn('{} - json data not found'.format(str(e)))\n                return\n         \n        \n        \n        \n        try:\n            magic_val = binascii.hexlify(data[0:4]).upper()\n            magic_val = ' '.join([magic_val[i:i+2] for i in range(0, len(magic_val), 2)])\n        except:\n            self.warn('could not parse session data')\n            return \n\n        \n        #   into a Bitcoin (bc) network type\n        try:\n            self.bc_net = str(MAGIC_VALS[magic_val])  \n        except:\n            self.bc_net = 'N/A'\n\n\n        \n        self.size = '{0:.2f}'.format((len(blob.data())/1024.0))\n        self.smac = conn.smac\n        self.dmac = conn.dmac\n\n\n        \n        \n        if self.JSON and self.NOTIFY:\n            jids_end = (len(self.notify_params[conn.addr][0][conn.addr]) - 1)\n            if jids_end >= 1:\n                self.notify_params[conn.addr][0][conn.addr] = [ self.notify_params[conn.addr][0][conn.addr][0], \n                                                                '...',\n                                                                self.notify_params[conn.addr][0][conn.addr][jids_end] ]\n            elif jids_end >= 0:\n                self.notify_params[conn.addr][0][conn.addr] = [self.notify_params[conn.addr][0][conn.addr][0]] \n\n            \n            \n            self.JSON = False\n            self.NOTIFY = False\n\n        # If able to pull the Bitcoin Pool User ID (sometimes a wallet ID)\n        # Also if the transcation is mining.notify (seen in Stratum mining)\n        \n        if (self.size and self.smac and self.dmac and \n                self.miners.get(conn.addr, None) and self.methods.get(conn.addr, None) and self.auth_ids.get(conn.addr, None)\n                and self.notify_params.get(conn.addr, None) and not self.gentx): \n            self.alert(\"\\n\\tSRC_MAC: \\t{0:<20} \\n\\tDST_MAC: \\t{1:<20} \\n\\tSIZE: \\t\\t{2:>3}KB\\n\\t\" \n                       \"MINER: \\t\\t{3:<20} \\n\\tMETHODS: \\t{4:<25} \\n\\tUSER ID/PW: \\t{5:<50}\\n\\t\"\n                       \"JOB IDs: \\t{6:<20} \\n\\tPREV BLK HASH: \\t{7:<65} \\n\\tBLOCK VER: \\t{8:<15}\\n\\t\"\n                       \"HASH DIFF: \\t{9:<10}\\n\\n\".format(\n                self.smac, self.dmac, self.size, \n                self.miners[conn.addr], self.methods[conn.addr], self.auth_ids[conn.addr],\n                self.notify_params[conn.addr][0][conn.addr], self.notify_params[conn.addr][1], \n                self.notify_params[conn.addr][5], self.notify_params[conn.addr][6]), \n                ts=blob.starttime, sip=conn.sip, dip=conn.dip, sport=conn.sport, \n                dport=conn.dport, direction=blob.direction)\n\n\n        # If able to pull the Bitcoin Pool User ID (sometimes a wallet ID)\n        # Also if the transcation is mining.notify (seen in Stratum mining) and the user\n        \n        #   (gen_tx1, gen_tx2 (hashes with scriptPubKeys), merkle tree branches), then\n        \n        elif (self.size and self.smac and self.dmac and \n                self.miners.get(conn.addr, None) and self.methods.get(conn.addr, None) and self.auth_ids.get(conn.addr, None)\n                and self.notify_params.get(conn.addr, None) and self.gentx): \n            self.alert(\"\\n\\tSRC_MAC: \\t{0:<20} \\n\\tDST_MAC: \\t{1:<20} \\n\\tSIZE: \\t\\t{2:>3}KB\\n\\t\" \n                       \"MINER: \\t\\t{3:<20} \\n\\tMETHODS: \\t{4:<25} \\n\\tUSER ID/PW: \\t{5:<50}\\n\\t\"\n                       \"JOB IDs: \\t{6:<20} \\n\\tPREV BLK HASH: \\t{7:<65} \\n\\tBLOCK VER: \\t{8:<15}\\n\\t\"\n                       \"HASH DIFF: \\t{9:<10}\\n\\n\".format(\n                self.smac, self.dmac, self.size, \n                self.miners[conn.addr], self.methods[conn.addr], self.auth_ids[conn.addr],\n                self.notify_params[conn.addr][0][conn.addr], self.notify_params[conn.addr][1], \n                self.notify_params[conn.addr][5], self.notify_params[conn.addr][6]), \n                ts=blob.starttime, sip=conn.sip, dip=conn.dip, sport=conn.sport, \n                dport=conn.dport, direction=blob.direction)\n\n            # Write the verbose block information (gen tx1/2, merkle branches) gathered \n            \n            # The extra information (JOB ID, BLOCK VER, etc.) will be useful in matching the \n            \n            \n            fout = open(self.gentx, \"a+\") \n            fout.write((\"\\nJOB IDs: \\t\\t{0:<20} \\nPREV BLK HASH: \\t{1:<65} \\n\\nGEN TX1: \\t\\t{2:<20}\" \n                        \"\\n\\nGEN TX2: \\t\\t{3:<20} \\n\\nMERKLE BRANCHES: {4:<20} \\n\\nBLOCK VER: \\t\\t{5:<20}\" \n                        \"\\nHASH DIFF: \\t\\t{6:<10}\\n\").format(\n                        self.notify_params[conn.addr][0][conn.addr], self.notify_params[conn.addr][1],\n                        self.notify_params[conn.addr][2], self.notify_params[conn.addr][3],\n                        self.notify_params[conn.addr][4], self.notify_params[conn.addr][5],\n                        self.notify_params[conn.addr][6]))\n            fout.write((\"\\n\" + \"-\"*100)*2)\n\n\n        \n        #   and the user doesn't want verbose block information (gentx)\n        elif (self.size and self.smac and self.dmac and self.bc_net): \n            self.alert(\"\\n\\tNETWORK: \\t{0:<15} \\n\\tSRC_MAC: \\t{1:<20} \\n\\tDST_MAC: \\t{2:<20} \\n\\tSIZE: \\t\\t{3:>3}KB\\n\\n\".format(\n            self.bc_net, self.smac, self.dmac, self.size), ts=blob.starttime, sip=conn.sip, \n            dip=conn.dip, sport=conn.sport, dport=conn.dport, direction=blob.direction)\n        \n\nif __name__ == '__main__':\n    dObj = DshellDecoder()\n    print dObj\nelse:\n    dObj = DshellDecoder()\n", "comments": "    the bitcoin decoder extract bitcoin traffic attempting find output       client server ip addresses  src dst port numbers  mac addresses machines     used bitcoin communication transactions  timestamps packets      packet payload sizes kb  network type      ( bitcoin main  bitcoin data traffic)    additionally stratum mining  attempt extract      bitcoin miner used  transaction methods used connection      (mining notify  mining authorize  mining get transaction  mining submit  etc )       user id (auth id) used access bitcoin mining pool  possibly password      used connect pool stored json payload       also        range job ids (per connection)  previous block hash  generation transaction (part 1)       generation transaction (part 2)  merkle tree branches (hashes)  block version       hash difficulty (n bits)     (the generation transactions merkle tree branches optionally outputted       file  see example (3) below)       note (1)  the first time stratum mining information                collected (per connection)  packets decoded                point within connection (same exact sip  dip  sport  dport)                continue output collection information since                      note (2)  the gen tx1 gen tx2 fields enable miner build coinbase               transaction block concatentating gen tx1  extranonce1                start gen tx1  extranonce2 generated miner                 gen tx2 (hashes scriptpubkeys)      note (3)  some pools recommend miners use bitcoin wallet id                (address used payment)  auth id   this easily                spotted address consisting 26 35 alphanumeric characters                 always begins either number  1   3        for additional information           bitcoin protocol          https   en bitcoin wiki protocol documentation          stratum mining protocol   https   en bitcoin wiki stratum mining protocol            main ports   some secondary ports used bitcoin traffic              bitcoin main traffic uses port 8333     bitcoin testnet uses port 18333     several pools use ports 3333  8332  8337     the ports checked known ports used specific btc mining pools     other bitcoin pools utilize alternate ports (even 80   443)   examples           (1) basic usage           decode  bitcoin  pcap       (2) if pcap starts middle connection (then need ignore tcp handshake)                   decode  bitcoin  pcap    bitcoin ignore handshake      (3) saving generation transaction data merkle branches specified file           decode  bitcoin  pcap    bitcoin gentx  foo txt                                    filter    tcp port (3332 3333 3334 3335                                                     4008 4012 4016 4024                                                     4032 4048 4064 4096                                                     4128 4256 5050 7033                                                     7065 7129 7777 8332                                                     8333 8334 8336 8337                                                      8344 8347 8361 8888                                                      9332 9337 9999 11111                                                      12222 17777 18333)       magic values used determine bitcoin network type    bitcoin testnet alternative blockchain used testing    blobhandler reassemble packets traffic    bitcoin traffic uses tcp    only continue packet contains data     default mining notify fields none    if payload contains json    split json objects newline    create dictionary sets mining methods       indexed associated conn addr (sip  dip  sport  dport)     grab bitcoin user id (sometimes wallet id)       authorized    grab first 4 bytes payload search magic values      used determine bitcoin network accessed    additionally  reformat bytes    attempt translate first 4 bytes payload       bitcoin (bc) network type    pull pertinent information packet contents    truncate list job ids per connection printing purposes json       data found blob    reset json data found current blob boolean      mining notify method type found payload boolean     if able pull bitcoin pool user id (sometimes wallet id)    also transcation mining notify (seen stratum mining)      output current block information    if able pull bitcoin pool user id (sometimes wallet id)    also transcation mining notify (seen stratum mining) user      specifies want save fields used generate block transaction       (gen tx1  gen tx2 (hashes scriptpubkeys)  merkle tree branches)     output information possible  write gentx information specified file    write verbose block information (gen tx1 2  merkle branches) gathered       mining notify payloads command line specified output file    the extra information (job id  block ver  etc ) useful matching       information outputted alerts payload containing       generation transaction info merkle branches    else dont bitcoin user ids  block information       user want verbose block information (gentx) ", "content": "import dshell\nimport util\nimport binascii\nimport json\nfrom struct import unpack\n\n# Magic values used to determine Bitcoin Network Type\n# Bitcoin Testnet is an alternative blockchain used for testing\nMAGIC_VALS = {'F9 BE B4 D9': 'BITCOIN-MAIN',\n              'FA BF B5 DA': 'BITCOIN-TESTNET',\n              '0B 11 09 07': 'BITCOIN-TESTNET3'}\n\n\nclass DshellDecoder(dshell.TCPDecoder):\n\n    def __init__(self):\n        dshell.TCPDecoder.__init__(self,\n                            name='bitcoin',\n                            description='Extract Bitcoin traffic, including Stratum mining protocol (pooled) traffic',\n                            longdescription='''\nThe bitcoin decoder will extract any Bitcoin traffic attempting to find and output: \n    Client/server IP addresses, src/dst port numbers, MAC addresses of the machines\n    used in the Bitcoin communication/transactions, timestamps of the packets,\n    packet payload sizes in KB, and the Network type \n    ('Bitcoin Main' if Bitcoin data traffic)  \n\nAdditionally for Stratum mining, it will attempt to extract:\n    Bitcoin miner being used, transaction methods used in each connection \n    (mining.notify, mining.authorize, mining.get_transaction, mining.submit, etc.), \n    User ID (Auth ID) used to access the Bitcoin mining pool, and possibly the password \n    used to connect to the pool if it is stored in the JSON of the payload.\n\n    Also, the: \n    range of job IDs (per connection), previous block hash, generation transaction (part 1), \n    generation transaction (part 2), merkle tree branches (hashes), block version, \n    and the hash difficulty (n-bits)\n    (The generation transactions and merkle tree branches are only optionally outputted \n     to a file: See Example (3) below)\n \n    Note (1): The first time that all of this Stratum mining information is \n              collected (per connection), all of the packets decoded after this \n              point from within the same connection (same exact sip, dip, sport, dport) \n              will continue to output the same collection of information since it \n              will be the same.\n\n    Note (2): The gen_tx1 and gen_tx2 fields enable the miner to build the coinbase\n              transaction for the block by concatentating gen_tx1, the extranonce1 \n              at the start of gen_tx1, the extranonce2 generated by the miner, and \n              gen_tx2 (hashes with scriptPubKeys)\n\n    Note (3): Some pools recommend miners use their Bitcoin wallet ID \n              (address used for payment) as their 'Auth ID'. This will be easily \n              spotted as it is an address consisting of 26-35 alphanumeric characters, \n              and it always begins with either the number '1' or '3'\n\n\n    For additional information: \n        Bitcoin Protocol:        <https://en.bitcoin.it/wiki/Protocol_documentation>\n        Stratum Mining Protocol: <https://en.bitcoin.it/wiki/Stratum_mining_protocol>\n\n\n--------Main ports / Some secondary ports used for Bitcoin Traffic---------\n    Bitcoin Main traffic uses port 8333\n    Bitcoin Testnet uses port 18333\n    Several pools use ports 3333, 8332, 8337\n    The other ports checked are known ports used by specific BTC mining pools\n    Other Bitcoin pools utilize alternate ports (even 80 / 443)\n\n\nExamples:\n    \n    (1) Basic usage:\n\n        decode -d bitcoin <pcap>\n\n    (2) If pcap starts in middle of connection (then we need to ignore TCP handshake):\n        \n        decode -d bitcoin <pcap> --bitcoin_ignore_handshake\n\n    (3) Saving Generation Transaction Data and Merkle Branches to a specified file:\n\n        decode -d bitcoin <pcap> --bitcoin_gentx='foo.txt.'\n''',\n                            filter='''tcp and port (3332 or 3333 or 3334 or 3335 or\n                                                    4008 or 4012 or 4016 or 4024 or\n                                                    4032 or 4048 or 4064 or 4096 or\n                                                    4128 or 4256 or 5050 or 7033 or\n                                                    7065 or 7129 or 7777 or 8332 or\n                                                    8333 or 8334 or 8336 or 8337 or \n                                                    8344 or 8347 or 8361 or 8888 or \n                                                    9332 or 9337 or 9999 or 11111 or \n                                                    12222 or 17777 or 18333)''',\n                            author='dek',\n                            optiondict={\n                                    'gentx' : {'type' : 'str', 'default' : '', 'help' : 'The name of the file to output the fields used to generate the block transaction (gen_tx1, gen_tx2, merkle_branches).'},\n                            }\n                            )\n        self.auth_ids = {}\n        self.notify_params = {}\n        self.methods = {}\n        self.miners = {} \n        self.job_ids = {}\n        self.smac = None\n        self.dmac = None\n        self.bc_net = None\n        self.size = 0\n        self.JSON = False\n        self.NOTIFY = False\n\n        \n    # blobHandler to reassemble the packets in the traffic\n    # Bitcoin traffic uses TCP\n    def blobHandler(self, conn, blob):\n\n        try:\n            data = blob.data()\n        except:\n            self.warn('could not parse session data')\n            return\n        \n        # Only continue if the packet contains data \n        if not data:\n            return\n\n        # Default mining.notify fields to None\n        job_id = None \n        prev_blk_hash = None \n        gen_tx1 = None  \n        gen_tx2 = None \n        merkle_branches = None\n        blk_ver = None \n        difficulty = None \n        curr_time = None \n        clean_jobs = None \n        \n        # If the payload contains JSON\n        if data.startswith('{\"'):\n            self.JSON = True\n            try:\n                # split JSON objects by newline\n                for rawjs in data.split(\"\\n\"):\n                    if rawjs:\n                        js = json.loads(rawjs)\n                        try:\n                            if \"method\" in js and js[\"method\"]:\n                                # Create a dictionary of sets of mining methods \n                                #   indexed by their associated conn.addr (sip, dip, sport, dport) \n                                self.methods.setdefault(conn.addr, set([])).add(js[\"method\"])\n\n                                if js[\"method\"] == \"mining.subscribe\":\n                                    self.miners[conn.addr] = js[\"params\"][0]\n                            \n                                if js[\"method\"] == \"mining.authorize\":\n                                    if \"params\" in js and js['params'][0]:\n                                        # Grab the Bitcoin User ID (sometimes a wallet id) \n                                        #   which is being authorized\n                                        self.auth_ids[conn.addr] = js[\"params\"][0]\n\n                                        if js['params'][1]:\n                                            self.auth_ids[conn.addr] = \"\".join(( \n                                                self.auth_ids[conn.addr], \" / \",  str(js['params'][1]) ))\n                                            \n                                if js[\"method\"] == \"mining.notify\":\n                                    self.NOTIFY = True\n                                    if \"params\" in js and js['params']:\n                                        job_id, prev_blk_hash, gen_tx1, gen_tx2, merkle_branches, blk_ver, difficulty, curr_time, clean_jobs = js['params']\n                                        self.job_ids.setdefault(conn.addr, []).append(job_id)\n                                        self.notify_params[conn.addr] = [self.job_ids, prev_blk_hash, gen_tx1,\n                                                                         gen_tx2, merkle_branches,\n                                                                         blk_ver, difficulty, curr_time,\n                                                                         clean_jobs]\n\n                        except KeyError as e:\n                            self.warn(\"{} - Error extracting auth ID\".format(str(e)))\n            except ValueError as e:\n                self.warn('{} - json data not found'.format(str(e)))\n                return\n         \n        # Grab the first 4 bytes of the payload to search for the magic values\n        #   used to determine which Bitcoin network is being accessed\n        # Additionally, reformat bytes\n        try:\n            magic_val = binascii.hexlify(data[0:4]).upper()\n            magic_val = ' '.join([magic_val[i:i+2] for i in range(0, len(magic_val), 2)])\n        except:\n            self.warn('could not parse session data')\n            return \n\n        # Attempt to translate first 4 bytes of payload \n        #   into a Bitcoin (bc) network type\n        try:\n            self.bc_net = str(MAGIC_VALS[magic_val])  \n        except:\n            self.bc_net = 'N/A'\n\n\n        # Pull pertinent information from packet's contents\n        self.size = '{0:.2f}'.format((len(blob.data())/1024.0))\n        self.smac = conn.smac\n        self.dmac = conn.dmac\n\n\n        # Truncate the list Job IDs per connection for printing purposes if JSON \n        #   data was found in the blob\n        if self.JSON and self.NOTIFY:\n            jids_end = (len(self.notify_params[conn.addr][0][conn.addr]) - 1)\n            if jids_end >= 1:\n                self.notify_params[conn.addr][0][conn.addr] = [ self.notify_params[conn.addr][0][conn.addr][0], \n                                                                '...',\n                                                                self.notify_params[conn.addr][0][conn.addr][jids_end] ]\n            elif jids_end >= 0:\n                self.notify_params[conn.addr][0][conn.addr] = [self.notify_params[conn.addr][0][conn.addr][0]] \n\n            # Reset the JSON data found in the current blob boolean\n            #   and the mining.notify method type found in payload boolean \n            self.JSON = False\n            self.NOTIFY = False\n\n        # If able to pull the Bitcoin Pool User ID (sometimes a wallet ID)\n        # Also if the transcation is mining.notify (seen in Stratum mining)\n        #   then output the current Block information\n        if (self.size and self.smac and self.dmac and \n                self.miners.get(conn.addr, None) and self.methods.get(conn.addr, None) and self.auth_ids.get(conn.addr, None)\n                and self.notify_params.get(conn.addr, None) and not self.gentx): \n            self.alert(\"\\n\\tSRC_MAC: \\t{0:<20} \\n\\tDST_MAC: \\t{1:<20} \\n\\tSIZE: \\t\\t{2:>3}KB\\n\\t\" \n                       \"MINER: \\t\\t{3:<20} \\n\\tMETHODS: \\t{4:<25} \\n\\tUSER ID/PW: \\t{5:<50}\\n\\t\"\n                       \"JOB IDs: \\t{6:<20} \\n\\tPREV BLK HASH: \\t{7:<65} \\n\\tBLOCK VER: \\t{8:<15}\\n\\t\"\n                       \"HASH DIFF: \\t{9:<10}\\n\\n\".format(\n                self.smac, self.dmac, self.size, \n                self.miners[conn.addr], self.methods[conn.addr], self.auth_ids[conn.addr],\n                self.notify_params[conn.addr][0][conn.addr], self.notify_params[conn.addr][1], \n                self.notify_params[conn.addr][5], self.notify_params[conn.addr][6]), \n                ts=blob.starttime, sip=conn.sip, dip=conn.dip, sport=conn.sport, \n                dport=conn.dport, direction=blob.direction)\n\n\n        # If able to pull the Bitcoin Pool User ID (sometimes a wallet ID)\n        # Also if the transcation is mining.notify (seen in Stratum mining) and the user\n        #   specifies that they want to save the fields used to generate the block transaction \n        #   (gen_tx1, gen_tx2 (hashes with scriptPubKeys), merkle tree branches), then\n        # output all information possible, and write the gentx information to the specified file\n        elif (self.size and self.smac and self.dmac and \n                self.miners.get(conn.addr, None) and self.methods.get(conn.addr, None) and self.auth_ids.get(conn.addr, None)\n                and self.notify_params.get(conn.addr, None) and self.gentx): \n            self.alert(\"\\n\\tSRC_MAC: \\t{0:<20} \\n\\tDST_MAC: \\t{1:<20} \\n\\tSIZE: \\t\\t{2:>3}KB\\n\\t\" \n                       \"MINER: \\t\\t{3:<20} \\n\\tMETHODS: \\t{4:<25} \\n\\tUSER ID/PW: \\t{5:<50}\\n\\t\"\n                       \"JOB IDs: \\t{6:<20} \\n\\tPREV BLK HASH: \\t{7:<65} \\n\\tBLOCK VER: \\t{8:<15}\\n\\t\"\n                       \"HASH DIFF: \\t{9:<10}\\n\\n\".format(\n                self.smac, self.dmac, self.size, \n                self.miners[conn.addr], self.methods[conn.addr], self.auth_ids[conn.addr],\n                self.notify_params[conn.addr][0][conn.addr], self.notify_params[conn.addr][1], \n                self.notify_params[conn.addr][5], self.notify_params[conn.addr][6]), \n                ts=blob.starttime, sip=conn.sip, dip=conn.dip, sport=conn.sport, \n                dport=conn.dport, direction=blob.direction)\n\n            # Write the verbose block information (gen tx1/2, merkle branches) gathered \n            #   from mining.notify payloads to the command-line specified output file\n            # The extra information (JOB ID, BLOCK VER, etc.) will be useful in matching the \n            #   information outputted by the alerts to the payload containing the \n            #   generation transaction info and merkle branches\n            fout = open(self.gentx, \"a+\") \n            fout.write((\"\\nJOB IDs: \\t\\t{0:<20} \\nPREV BLK HASH: \\t{1:<65} \\n\\nGEN TX1: \\t\\t{2:<20}\" \n                        \"\\n\\nGEN TX2: \\t\\t{3:<20} \\n\\nMERKLE BRANCHES: {4:<20} \\n\\nBLOCK VER: \\t\\t{5:<20}\" \n                        \"\\nHASH DIFF: \\t\\t{6:<10}\\n\").format(\n                        self.notify_params[conn.addr][0][conn.addr], self.notify_params[conn.addr][1],\n                        self.notify_params[conn.addr][2], self.notify_params[conn.addr][3],\n                        self.notify_params[conn.addr][4], self.notify_params[conn.addr][5],\n                        self.notify_params[conn.addr][6]))\n            fout.write((\"\\n\" + \"-\"*100)*2)\n\n\n        # Else if we dont have Bitcoin User IDs, or Block information \n        #   and the user doesn't want verbose block information (gentx)\n        elif (self.size and self.smac and self.dmac and self.bc_net): \n            self.alert(\"\\n\\tNETWORK: \\t{0:<15} \\n\\tSRC_MAC: \\t{1:<20} \\n\\tDST_MAC: \\t{2:<20} \\n\\tSIZE: \\t\\t{3:>3}KB\\n\\n\".format(\n            self.bc_net, self.smac, self.dmac, self.size), ts=blob.starttime, sip=conn.sip, \n            dip=conn.dip, sport=conn.sport, dport=conn.dport, direction=blob.direction)\n        \n\nif __name__ == '__main__':\n    dObj = DshellDecoder()\n    print dObj\nelse:\n    dObj = DshellDecoder()\n", "description": "Dshell is a network forensic analysis framework.", "file_name": "bitcoin.py", "id": "10224aeb04158010a86575e6454183ac", "language": "Python", "project_name": "Dshell", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/USArmyResearchLab-Dshell/USArmyResearchLab-Dshell-5850adf/decoders/protocol/bitcoin.py", "save_time": "", "source": "", "update_at": "2018-03-18T10:01:29Z", "url": "https://github.com/USArmyResearchLab/Dshell", "wiki": true}