{"author": "sympy", "code": "from __future__ import print_function, division\n\nfrom sympy.core import oo, Tuple\n\nfrom sympy.assumptions.assume import global_assumptions, AppliedPredicate\nfrom sympy.logic.inference import satisfiable\nfrom sympy.logic.boolalg import And\nfrom sympy.assumptions.ask_generated import get_known_facts_cnf\nfrom sympy.assumptions.sathandlers import fact_registry\n\n\ndef satask(proposition, assumptions=True, context=global_assumptions,\n    use_known_facts=True, iterations=oo):\n    relevant_facts = get_all_relevant_facts(proposition, assumptions, context,\n        use_known_facts=use_known_facts, iterations=iterations)\n\n    can_be_true = satisfiable(And(proposition, assumptions,\n        relevant_facts, *context))\n    can_be_false = satisfiable(And(~proposition, assumptions,\n        relevant_facts, *context))\n\n    if can_be_true and can_be_false:\n        return None\n\n    if can_be_true and not can_be_false:\n        return True\n\n    if not can_be_true and can_be_false:\n        return False\n\n    if not can_be_true and not can_be_false:\n        \n        \n        \n        raise ValueError(\"Inconsistent assumptions\")\n\n\ndef get_relevant_facts(proposition, assumptions=(True,),\n    context=global_assumptions, use_known_facts=True, exprs=None,\n    relevant_facts=None):\n\n    newexprs = set()\n    if not exprs:\n        keys = proposition.atoms(AppliedPredicate)\n        \n        keys |= Tuple(*assumptions).atoms(AppliedPredicate)\n        if context:\n            keys |= And(*context).atoms(AppliedPredicate)\n\n        exprs = {key.args[0] for key in keys}\n\n    if not relevant_facts:\n        relevant_facts = set([])\n\n    if use_known_facts:\n        for expr in exprs:\n            relevant_facts.add(get_known_facts_cnf().rcall(expr))\n\n    for expr in exprs:\n        for fact in fact_registry[expr.func]:\n            newfact = fact.rcall(expr)\n            relevant_facts.add(newfact)\n            newexprs |= set([key.args[0] for key in\n                newfact.atoms(AppliedPredicate)])\n\n    return relevant_facts, newexprs - exprs\n\n\ndef get_all_relevant_facts(proposition, assumptions=True,\n    context=global_assumptions, use_known_facts=True, iterations=oo):\n    # The relevant facts might introduce new keys, e.g., Q.zero(x*y) will\n    # introduce the keys Q.zero(x) and Q.zero(y), so we need to run it until\n    \n    \n    i = 0\n    relevant_facts = set()\n    exprs = None\n    while exprs != set():\n        (relevant_facts, exprs) = get_relevant_facts(proposition,\n                And.make_args(assumptions), context,\n                use_known_facts=use_known_facts, exprs=exprs,\n                relevant_facts=relevant_facts)\n        i += 1\n        if i >= iterations:\n            return And(*relevant_facts)\n\n    return And(*relevant_facts)\n", "comments": "  todo  run additional checks see combination    assumptions  global assumptions  relevant facts    inconsistent     xxx  we need since true false basic    the relevant facts might introduce new keys  e g   q zero(x y)    introduce keys q zero(x) q zero(y)  need run    stop getting new things  hopefully strategy lead    infinite loop future  ", "content": "from __future__ import print_function, division\n\nfrom sympy.core import oo, Tuple\n\nfrom sympy.assumptions.assume import global_assumptions, AppliedPredicate\nfrom sympy.logic.inference import satisfiable\nfrom sympy.logic.boolalg import And\nfrom sympy.assumptions.ask_generated import get_known_facts_cnf\nfrom sympy.assumptions.sathandlers import fact_registry\n\n\ndef satask(proposition, assumptions=True, context=global_assumptions,\n    use_known_facts=True, iterations=oo):\n    relevant_facts = get_all_relevant_facts(proposition, assumptions, context,\n        use_known_facts=use_known_facts, iterations=iterations)\n\n    can_be_true = satisfiable(And(proposition, assumptions,\n        relevant_facts, *context))\n    can_be_false = satisfiable(And(~proposition, assumptions,\n        relevant_facts, *context))\n\n    if can_be_true and can_be_false:\n        return None\n\n    if can_be_true and not can_be_false:\n        return True\n\n    if not can_be_true and can_be_false:\n        return False\n\n    if not can_be_true and not can_be_false:\n        # TODO: Run additional checks to see which combination of the\n        # assumptions, global_assumptions, and relevant_facts are\n        # inconsistent.\n        raise ValueError(\"Inconsistent assumptions\")\n\n\ndef get_relevant_facts(proposition, assumptions=(True,),\n    context=global_assumptions, use_known_facts=True, exprs=None,\n    relevant_facts=None):\n\n    newexprs = set()\n    if not exprs:\n        keys = proposition.atoms(AppliedPredicate)\n        # XXX: We need this since True/False are not Basic\n        keys |= Tuple(*assumptions).atoms(AppliedPredicate)\n        if context:\n            keys |= And(*context).atoms(AppliedPredicate)\n\n        exprs = {key.args[0] for key in keys}\n\n    if not relevant_facts:\n        relevant_facts = set([])\n\n    if use_known_facts:\n        for expr in exprs:\n            relevant_facts.add(get_known_facts_cnf().rcall(expr))\n\n    for expr in exprs:\n        for fact in fact_registry[expr.func]:\n            newfact = fact.rcall(expr)\n            relevant_facts.add(newfact)\n            newexprs |= set([key.args[0] for key in\n                newfact.atoms(AppliedPredicate)])\n\n    return relevant_facts, newexprs - exprs\n\n\ndef get_all_relevant_facts(proposition, assumptions=True,\n    context=global_assumptions, use_known_facts=True, iterations=oo):\n    # The relevant facts might introduce new keys, e.g., Q.zero(x*y) will\n    # introduce the keys Q.zero(x) and Q.zero(y), so we need to run it until\n    # we stop getting new things. Hopefully this strategy won't lead to an\n    # infinite loop in the future.\n    i = 0\n    relevant_facts = set()\n    exprs = None\n    while exprs != set():\n        (relevant_facts, exprs) = get_relevant_facts(proposition,\n                And.make_args(assumptions), context,\n                use_known_facts=use_known_facts, exprs=exprs,\n                relevant_facts=relevant_facts)\n        i += 1\n        if i >= iterations:\n            return And(*relevant_facts)\n\n    return And(*relevant_facts)\n", "description": "A computer algebra system written in pure Python", "file_name": "satask.py", "id": "cdfdc3319c8d665df7da6afa00ab166f", "language": "Python", "project_name": "sympy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/sympy-sympy/sympy-sympy-205da79/sympy/assumptions/satask.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:35:56Z", "url": "https://github.com/sympy/sympy", "wiki": true}