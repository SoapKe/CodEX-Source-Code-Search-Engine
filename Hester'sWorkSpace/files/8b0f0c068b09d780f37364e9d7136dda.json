{"author": "tornadoweb", "code": "\n\nfrom __future__ import print_function\n\nimport gc\nimport traceback\nimport types\nfrom tornado import web, ioloop, gen, httpclient\n\n\ndef find_circular_references(garbage=None):\n    def inner(level):\n        for item in level:\n            item_id = id(item)\n            if item_id not in garbage_ids:\n                continue\n            if item_id in visited_ids:\n                continue\n            if item_id in stack_ids:\n                candidate = stack[stack.index(item):]\n                candidate.append(item)\n                found.append(candidate)\n                continue\n\n            stack.append(item)\n            stack_ids.add(item_id)\n            inner(gc.get_referents(item))\n            stack.pop()\n            stack_ids.remove(item_id)\n            visited_ids.add(item_id)\n\n    garbage = garbage or gc.garbage\n    found = []\n    stack = []\n    stack_ids = set()\n    garbage_ids = set(map(id, garbage))\n    visited_ids = set()\n\n    inner(garbage)\n    inner = None\n    return found\n\n\nclass CollectHandler(web.RequestHandler):\n    @gen.coroutine\n    def get(self):\n        self.write(\"Collected: {}\\n\".format(gc.collect()))\n        self.write(\"Garbage: {}\\n\".format(len(gc.garbage)))\n        for circular in find_circular_references():\n            print('\\n==========\\n Circular \\n==========')\n            for item in circular:\n                print('    ', repr(item))\n            for item in circular:\n                if isinstance(item, types.FrameType):\n                    print('\\nLocals:', item.f_locals)\n                    print('\\nTraceback:', repr(item))\n                    traceback.print_stack(item)\n\n\nclass DummyHandler(web.RequestHandler):\n    @gen.coroutine\n    def get(self):\n        self.write('ok\\n')\n\n\nclass DummyAsyncHandler(web.RequestHandler):\n    @gen.coroutine\n    def get(self):\n        raise web.Finish('ok\\n')\n\n\napplication = web.Application([\n    (r'/dummy/', DummyHandler),\n    (r'/dummyasync/', DummyAsyncHandler),\n    (r'/collect/', CollectHandler),\n], debug=True)\n\n\n@gen.coroutine\ndef main():\n    gc.disable()\n    gc.collect()\n    gc.set_debug(gc.DEBUG_STATS | gc.DEBUG_SAVEALL)\n    print('GC disabled')\n\n    print(\"Start on 8888\")\n    application.listen(8888, '127.0.0.1')\n\n    \n    \n    client = httpclient.AsyncHTTPClient()\n    yield client.fetch('http://127.0.0.1:8888/dummy/')\n    yield client.fetch('http://127.0.0.1:8888/dummyasync/', raise_error=False)\n\n    \n    resp = yield client.fetch('http://127.0.0.1:8888/collect/')\n    print(resp.body)\n\n\nif __name__ == \"__main__\":\n    ioloop.IOLoop.current().run_sync(main)\n", "comments": "   test script find circular references   circular references leaks per se  eventually gc  however  cpython  prevent reference counting fast path used instead rely slower full gc  this increases memory footprint cpu overhead  try eliminate circular references created normal operation          usr bin env python    do little work  alternately  could leave script running    poke browser     now report results  ", "content": "#!/usr/bin/env python\n\"\"\"Test script to find circular references.\n\nCircular references are not leaks per se, because they will eventually\nbe GC'd. However, on CPython, they prevent the reference-counting fast\npath from being used and instead rely on the slower full GC. This\nincreases memory footprint and CPU overhead, so we try to eliminate\ncircular references created by normal operation.\n\"\"\"\nfrom __future__ import print_function\n\nimport gc\nimport traceback\nimport types\nfrom tornado import web, ioloop, gen, httpclient\n\n\ndef find_circular_references(garbage=None):\n    def inner(level):\n        for item in level:\n            item_id = id(item)\n            if item_id not in garbage_ids:\n                continue\n            if item_id in visited_ids:\n                continue\n            if item_id in stack_ids:\n                candidate = stack[stack.index(item):]\n                candidate.append(item)\n                found.append(candidate)\n                continue\n\n            stack.append(item)\n            stack_ids.add(item_id)\n            inner(gc.get_referents(item))\n            stack.pop()\n            stack_ids.remove(item_id)\n            visited_ids.add(item_id)\n\n    garbage = garbage or gc.garbage\n    found = []\n    stack = []\n    stack_ids = set()\n    garbage_ids = set(map(id, garbage))\n    visited_ids = set()\n\n    inner(garbage)\n    inner = None\n    return found\n\n\nclass CollectHandler(web.RequestHandler):\n    @gen.coroutine\n    def get(self):\n        self.write(\"Collected: {}\\n\".format(gc.collect()))\n        self.write(\"Garbage: {}\\n\".format(len(gc.garbage)))\n        for circular in find_circular_references():\n            print('\\n==========\\n Circular \\n==========')\n            for item in circular:\n                print('    ', repr(item))\n            for item in circular:\n                if isinstance(item, types.FrameType):\n                    print('\\nLocals:', item.f_locals)\n                    print('\\nTraceback:', repr(item))\n                    traceback.print_stack(item)\n\n\nclass DummyHandler(web.RequestHandler):\n    @gen.coroutine\n    def get(self):\n        self.write('ok\\n')\n\n\nclass DummyAsyncHandler(web.RequestHandler):\n    @gen.coroutine\n    def get(self):\n        raise web.Finish('ok\\n')\n\n\napplication = web.Application([\n    (r'/dummy/', DummyHandler),\n    (r'/dummyasync/', DummyAsyncHandler),\n    (r'/collect/', CollectHandler),\n], debug=True)\n\n\n@gen.coroutine\ndef main():\n    gc.disable()\n    gc.collect()\n    gc.set_debug(gc.DEBUG_STATS | gc.DEBUG_SAVEALL)\n    print('GC disabled')\n\n    print(\"Start on 8888\")\n    application.listen(8888, '127.0.0.1')\n\n    # Do a little work. Alternately, could leave this script running and\n    # poke at it with a browser.\n    client = httpclient.AsyncHTTPClient()\n    yield client.fetch('http://127.0.0.1:8888/dummy/')\n    yield client.fetch('http://127.0.0.1:8888/dummyasync/', raise_error=False)\n\n    # Now report on the results.\n    resp = yield client.fetch('http://127.0.0.1:8888/collect/')\n    print(resp.body)\n\n\nif __name__ == \"__main__\":\n    ioloop.IOLoop.current().run_sync(main)\n", "description": "Tornado is a Python web framework and asynchronous networking library, originally developed at FriendFeed.", "file_name": "circlerefs.py", "id": "8b0f0c068b09d780f37364e9d7136dda", "language": "Python", "project_name": "tornado", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tornadoweb-tornado/tornadoweb-tornado-9a97ffb/maint/circlerefs/circlerefs.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:52:45Z", "url": "https://github.com/tornadoweb/tornado", "wiki": true}