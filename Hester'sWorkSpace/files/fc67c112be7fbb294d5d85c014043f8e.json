{"author": "odoo", "code": " -*- coding: utf-8 -*-\n\nimport json\n\nfrom odoo import fields\n\n\ndef monkey_patch(cls):\n    \"\"\" Return a method decorator to monkey-patch the given class. \"\"\"\n    def decorate(func):\n        name = func.__name__\n        func.super = getattr(cls, name, None)\n        setattr(cls, name, func)\n        return func\n    return decorate\n\n\n\n Implement sparse fields by monkey-patching fields.Field\n\n\nfields.Field.__doc__ += \"\"\"\n\n        .. _field-sparse:\n\n        .. rubric:: Sparse fields\n\n        Sparse fields have a very small probability of being not null. Therefore\n        many such fields can be serialized compactly into a common location, the\n        latter being a so-called \"serialized\" field.\n\n        :param sparse: the name of the field where the value of this field must\n            be stored.\n\"\"\"\n\n@monkey_patch(fields.Field)\ndef _get_attrs(self, model, name):\n    attrs = _get_attrs.super(self, model, name)\n    if attrs.get('sparse'):\n         by default, sparse fields are not stored and not copied\n        attrs['store'] = False\n        attrs['copy'] = attrs.get('copy', False)\n        attrs['compute'] = self._compute_sparse\n        if not attrs.get('readonly'):\n            attrs['inverse'] = self._inverse_sparse\n    return attrs\n\n@monkey_patch(fields.Field)\ndef _compute_sparse(self, records):\n    for record in records:\n        values = record[self.sparse]\n        record[self.name] = values.get(self.name)\n    if self.relational:\n        for record in records:\n            record[self.name] = record[self.name].exists()\n\n@monkey_patch(fields.Field)\ndef _inverse_sparse(self, records):\n    for record in records:\n        values = record[self.sparse]\n        value = self.convert_to_read(record[self.name], record, use_name_get=False)\n        if value:\n            if values.get(self.name) != value:\n                values[self.name] = value\n                record[self.sparse] = values\n        else:\n            if self.name in values:\n                values.pop(self.name)\n                record[self.sparse] = values\n\n\n\n Definition and implementation of serialized fields\n\n\nclass Serialized(fields.Field):\n    \"\"\" Serialized fields provide the storage for sparse fields. \"\"\"\n    type = 'serialized'\n    _slots = {\n        'prefetch': False,               not prefetched by default\n    }\n    column_type = ('text', 'text')\n\n    def convert_to_column(self, value, record, values=None):\n        return json.dumps(value)\n\n    def convert_to_cache(self, value, record, validate=True):\n         cache format: dict\n        value = value or {}\n        return value if isinstance(value, dict) else json.loads(value)\n\nfields.Serialized = Serialized\n", "comments": "    return method decorator monkey patch given class          def decorate(func)          name   func   name           func super   getattr(cls  name  none)         setattr(cls  name  func)         return func     return decorate       implement sparse fields monkey patching fields field    fields field   doc                       field sparse              rubric   sparse fields          sparse fields small probability null  therefore         many fields serialized compactly common location          latter called  serialized  field            param sparse  name field value field must             stored        monkey patch(fields field) def  get attrs(self  model  name)      attrs    get attrs super(self  model  name)     attrs get( sparse )            default  sparse fields stored copied         attrs  store     false         attrs  copy     attrs get( copy   false)         attrs  compute     self  compute sparse         attrs get( readonly )              attrs  inverse     self  inverse sparse     return attrs   monkey patch(fields field) def  compute sparse(self  records)      record records          values   record self sparse          record self name    values get(self name)     self relational          record records              record self name    record self name  exists()   monkey patch(fields field) def  inverse sparse(self  records)      record records          values   record self sparse          value   self convert read(record self name   record  use name get false)         value              values get(self name)    value                  values self name    value                 record self sparse    values         else              self name values                  values pop(self name)                 record self sparse    values       definition implementation serialized fields    class serialized(fields field)          serialized fields provide storage sparse fields             coding  utf 8           implement sparse fields monkey patching fields field       default  sparse fields stored copied       definition implementation serialized fields       prefetched default    cache format  dict ", "content": "# -*- coding: utf-8 -*-\n\nimport json\n\nfrom odoo import fields\n\n\ndef monkey_patch(cls):\n    \"\"\" Return a method decorator to monkey-patch the given class. \"\"\"\n    def decorate(func):\n        name = func.__name__\n        func.super = getattr(cls, name, None)\n        setattr(cls, name, func)\n        return func\n    return decorate\n\n\n#\n# Implement sparse fields by monkey-patching fields.Field\n#\n\nfields.Field.__doc__ += \"\"\"\n\n        .. _field-sparse:\n\n        .. rubric:: Sparse fields\n\n        Sparse fields have a very small probability of being not null. Therefore\n        many such fields can be serialized compactly into a common location, the\n        latter being a so-called \"serialized\" field.\n\n        :param sparse: the name of the field where the value of this field must\n            be stored.\n\"\"\"\n\n@monkey_patch(fields.Field)\ndef _get_attrs(self, model, name):\n    attrs = _get_attrs.super(self, model, name)\n    if attrs.get('sparse'):\n        # by default, sparse fields are not stored and not copied\n        attrs['store'] = False\n        attrs['copy'] = attrs.get('copy', False)\n        attrs['compute'] = self._compute_sparse\n        if not attrs.get('readonly'):\n            attrs['inverse'] = self._inverse_sparse\n    return attrs\n\n@monkey_patch(fields.Field)\ndef _compute_sparse(self, records):\n    for record in records:\n        values = record[self.sparse]\n        record[self.name] = values.get(self.name)\n    if self.relational:\n        for record in records:\n            record[self.name] = record[self.name].exists()\n\n@monkey_patch(fields.Field)\ndef _inverse_sparse(self, records):\n    for record in records:\n        values = record[self.sparse]\n        value = self.convert_to_read(record[self.name], record, use_name_get=False)\n        if value:\n            if values.get(self.name) != value:\n                values[self.name] = value\n                record[self.sparse] = values\n        else:\n            if self.name in values:\n                values.pop(self.name)\n                record[self.sparse] = values\n\n\n#\n# Definition and implementation of serialized fields\n#\n\nclass Serialized(fields.Field):\n    \"\"\" Serialized fields provide the storage for sparse fields. \"\"\"\n    type = 'serialized'\n    _slots = {\n        'prefetch': False,              # not prefetched by default\n    }\n    column_type = ('text', 'text')\n\n    def convert_to_column(self, value, record, values=None):\n        return json.dumps(value)\n\n    def convert_to_cache(self, value, record, validate=True):\n        # cache format: dict\n        value = value or {}\n        return value if isinstance(value, dict) else json.loads(value)\n\nfields.Serialized = Serialized\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "fields.py", "id": "fc67c112be7fbb294d5d85c014043f8e", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/base_sparse_field/models/fields.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}