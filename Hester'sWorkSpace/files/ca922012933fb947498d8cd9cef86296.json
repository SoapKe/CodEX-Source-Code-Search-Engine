{"author": "ansible", "code": "\n\n (c) 2015, Yannig Perre <yannig.perre@gmail.com>\n\n This file is part of Ansible,\n\n Ansible is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Ansible is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Ansible. If not, see <http://www.gnu.org/licenses/>.\n\n'''\nNagios livestatus inventory script. Before using this script, please\nupdate nagios_livestatus.ini file.\n\nLivestatus is a nagios/naemon/shinken module which let you retrieve\ninformations stored in the monitoring core.\n\nThis plugin inventory need livestatus API for python. Please install it\nbefore using this script (apt/pip/yum/...).\n\nCheckmk livestatus: https://mathias-kettner.de/checkmk_livestatus.html\nLivestatus API: http://www.naemon.org/documentation/usersguide/livestatus.html\n'''\n\nimport os\nimport re\nimport argparse\nimport sys\n\ntry:\n    import configparser\nexcept ImportError:\n    import ConfigParser\n    configparser = ConfigParser\nimport json\n\ntry:\n    from mk_livestatus import Socket\nexcept ImportError:\n    sys.exit(\"Error: mk_livestatus is needed. Try something like: pip install python-mk-livestatus\")\n\n\nclass NagiosLivestatusInventory(object):\n\n    def parse_ini_file(self):\n        config = configparser.SafeConfigParser()\n        config.read(os.path.dirname(os.path.realpath(__file__)) + '/nagios_livestatus.ini')\n        for section in config.sections():\n            if not config.has_option(section, 'livestatus_uri'):\n                continue\n\n             If fields_to_retrieve is not set, using default fields\n            fields_to_retrieve = self.default_fields_to_retrieve\n            if config.has_option(section, 'fields_to_retrieve'):\n                fields_to_retrieve = [field.strip() for field in config.get(section, 'fields_to_retrieve').split(',')]\n                fields_to_retrieve = tuple(fields_to_retrieve)\n\n             default section values\n            section_values = {\n                'var_prefix': 'livestatus_',\n                'host_filter': None,\n                'host_field': 'name',\n                'group_field': 'groups'\n            }\n            for key, value in section_values.items():\n                if config.has_option(section, key):\n                    section_values[key] = config.get(section, key).strip()\n\n             Retrieving livestatus string connection\n            livestatus_uri = config.get(section, 'livestatus_uri')\n            backend_definition = None\n\n             Local unix socket\n            unix_match = re.match('unix:(.*)', livestatus_uri)\n            if unix_match is not None:\n                backend_definition = {'connection': unix_match.group(1)}\n\n             Remote tcp connection\n            tcp_match = re.match('tcp:(.*):([^:]*)', livestatus_uri)\n            if tcp_match is not None:\n                backend_definition = {'connection': (tcp_match.group(1), int(tcp_match.group(2)))}\n\n             No valid livestatus_uri => exiting\n            if backend_definition is None:\n                raise Exception('livestatus_uri field is invalid (%s). Expected: unix:/path/to/live or tcp:host:port' % livestatus_uri)\n\n             Updating backend_definition with current value\n            backend_definition['name'] = section\n            backend_definition['fields'] = fields_to_retrieve\n            for key, value in section_values.items():\n                backend_definition[key] = value\n\n            self.backends.append(backend_definition)\n\n    def parse_options(self):\n        parser = argparse.ArgumentParser()\n        parser.add_argument('--host', nargs=1)\n        parser.add_argument('--list', action='store_true')\n        parser.add_argument('--pretty', action='store_true')\n        self.options = parser.parse_args()\n\n    def add_host(self, hostname, group):\n        if group not in self.result:\n            self.result[group] = {}\n            self.result[group]['hosts'] = []\n        if hostname not in self.result[group]['hosts']:\n            self.result[group]['hosts'].append(hostname)\n\n    def query_backend(self, backend, host=None):\n        '''Query a livestatus backend'''\n        hosts_request = Socket(backend['connection']).hosts.columns(backend['host_field'], backend['group_field'])\n\n        if backend['host_filter'] is not None:\n            hosts_request = hosts_request.filter(backend['host_filter'])\n\n        if host is not None:\n            hosts_request = hosts_request.filter('name = ' + host[0])\n\n        hosts_request._columns += backend['fields']\n\n        hosts = hosts_request.call()\n        for host in hosts:\n            hostname = host[backend['host_field']]\n            hostgroups = host[backend['group_field']]\n            if not isinstance(hostgroups, list):\n                hostgroups = [hostgroups]\n            self.add_host(hostname, 'all')\n            self.add_host(hostname, backend['name'])\n            for group in hostgroups:\n                self.add_host(hostname, group)\n            for field in backend['fields']:\n                var_name = backend['var_prefix'] + field\n                if hostname not in self.result['_meta']['hostvars']:\n                    self.result['_meta']['hostvars'][hostname] = {}\n                self.result['_meta']['hostvars'][hostname][var_name] = host[field]\n\n    def __init__(self):\n\n        self.defaultgroup = 'group_all'\n        self.default_fields_to_retrieve = ('address', 'alias', 'display_name', 'childs', 'parents')\n        self.backends = []\n        self.options = None\n\n        self.parse_ini_file()\n        self.parse_options()\n\n        self.result = {}\n        self.result['_meta'] = {}\n        self.result['_meta']['hostvars'] = {}\n        self.json_indent = None\n        if self.options.pretty:\n            self.json_indent = 2\n\n        if len(self.backends) == 0:\n            sys.exit(\"Error: Livestatus configuration is missing. See nagios_livestatus.ini.\")\n\n        for backend in self.backends:\n            self.query_backend(backend, self.options.host)\n\n        if self.options.host:\n            print(json.dumps(self.result['_meta']['hostvars'][self.options.host[0]], indent=self.json_indent))\n        elif self.options.list:\n            print(json.dumps(self.result, indent=self.json_indent))\n        else:\n            sys.exit(\"usage: --list or --host HOSTNAME [--pretty]\")\n\nNagiosLivestatusInventory()\n", "comments": "    nagios livestatus inventory script  before using script  please update nagios livestatus ini file   livestatus nagios naemon shinken module let retrieve informations stored monitoring core   this plugin inventory need livestatus api python  please install using script (apt pip yum    )   checkmk livestatus  https   mathias kettner de checkmk livestatus html livestatus api  http   www naemon org documentation usersguide livestatus html      import os import import argparse import sys  try      import configparser except importerror      import configparser     configparser   configparser import json  try      mk livestatus import socket except importerror      sys exit( error  mk livestatus needed  try something like  pip install python mk livestatus )   class nagioslivestatusinventory(object)       def parse ini file(self)          config   configparser safeconfigparser()         config read(os path dirname(os path realpath(  file  ))     nagios livestatus ini )         section config sections()              config option(section   livestatus uri )                  continue                if fields retrieve set  using default fields             fields retrieve   self default fields retrieve             config option(section   fields retrieve )                  fields retrieve    field strip() field config get(section   fields retrieve ) split(   )                  fields retrieve   tuple(fields retrieve)                default section values             section values                      var prefix    livestatus                     host filter   none                   host field    name                    group field    groups                            key  value section values items()                  config option(section  key)                      section values key    config get(section  key) strip()                retrieving livestatus string connection             livestatus uri   config get(section   livestatus uri )             backend definition   none                local unix socket             unix match   match( unix (  )   livestatus uri)             unix match none                  backend definition     connection   unix match group(1)                 remote tcp connection             tcp match   match( tcp (  ) (     )   livestatus uri)             tcp match none                  backend definition     connection   (tcp match group(1)  int(tcp match group(2)))                 no valid livestatus uri    exiting             backend definition none                  raise exception( livestatus uri field invalid ( s)  expected  unix  path live tcp host port    livestatus uri)                updating backend definition current value             backend definition  name     section             backend definition  fields     fields retrieve             key  value section values items()                  backend definition key    value              self backends append(backend definition)      def parse options(self)          parser   argparse argumentparser()         parser add argument(   host   nargs 1)         parser add argument(   list   action  store true )         parser add argument(   pretty   action  store true )         self options   parser parse args()      def add host(self  hostname  group)          group self result              self result group                   self result group   hosts                hostname self result group   hosts                self result group   hosts   append(hostname)      def query backend(self  backend  host none)             query livestatus backend        usr bin env python    (c) 2015  yannig perre  yannig perre gmail com        this file part ansible        ansible free software  redistribute modify    terms gnu general public license published    free software foundation  either version 3 license     (at option) later version        ansible distributed hope useful     without any warranty  without even implied warranty    merchantability fitness for a particular purpose  see    gnu general public license details        you received copy gnu general public license    along ansible  if  see  http   www gnu org licenses       if fields retrieve set  using default fields    default section values    retrieving livestatus string connection    local unix socket    remote tcp connection    no valid livestatus uri    exiting    updating backend definition current value ", "content": "#!/usr/bin/env python\n\n# (c) 2015, Yannig Perre <yannig.perre@gmail.com>\n#\n# This file is part of Ansible,\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible. If not, see <http://www.gnu.org/licenses/>.\n\n'''\nNagios livestatus inventory script. Before using this script, please\nupdate nagios_livestatus.ini file.\n\nLivestatus is a nagios/naemon/shinken module which let you retrieve\ninformations stored in the monitoring core.\n\nThis plugin inventory need livestatus API for python. Please install it\nbefore using this script (apt/pip/yum/...).\n\nCheckmk livestatus: https://mathias-kettner.de/checkmk_livestatus.html\nLivestatus API: http://www.naemon.org/documentation/usersguide/livestatus.html\n'''\n\nimport os\nimport re\nimport argparse\nimport sys\n\ntry:\n    import configparser\nexcept ImportError:\n    import ConfigParser\n    configparser = ConfigParser\nimport json\n\ntry:\n    from mk_livestatus import Socket\nexcept ImportError:\n    sys.exit(\"Error: mk_livestatus is needed. Try something like: pip install python-mk-livestatus\")\n\n\nclass NagiosLivestatusInventory(object):\n\n    def parse_ini_file(self):\n        config = configparser.SafeConfigParser()\n        config.read(os.path.dirname(os.path.realpath(__file__)) + '/nagios_livestatus.ini')\n        for section in config.sections():\n            if not config.has_option(section, 'livestatus_uri'):\n                continue\n\n            # If fields_to_retrieve is not set, using default fields\n            fields_to_retrieve = self.default_fields_to_retrieve\n            if config.has_option(section, 'fields_to_retrieve'):\n                fields_to_retrieve = [field.strip() for field in config.get(section, 'fields_to_retrieve').split(',')]\n                fields_to_retrieve = tuple(fields_to_retrieve)\n\n            # default section values\n            section_values = {\n                'var_prefix': 'livestatus_',\n                'host_filter': None,\n                'host_field': 'name',\n                'group_field': 'groups'\n            }\n            for key, value in section_values.items():\n                if config.has_option(section, key):\n                    section_values[key] = config.get(section, key).strip()\n\n            # Retrieving livestatus string connection\n            livestatus_uri = config.get(section, 'livestatus_uri')\n            backend_definition = None\n\n            # Local unix socket\n            unix_match = re.match('unix:(.*)', livestatus_uri)\n            if unix_match is not None:\n                backend_definition = {'connection': unix_match.group(1)}\n\n            # Remote tcp connection\n            tcp_match = re.match('tcp:(.*):([^:]*)', livestatus_uri)\n            if tcp_match is not None:\n                backend_definition = {'connection': (tcp_match.group(1), int(tcp_match.group(2)))}\n\n            # No valid livestatus_uri => exiting\n            if backend_definition is None:\n                raise Exception('livestatus_uri field is invalid (%s). Expected: unix:/path/to/live or tcp:host:port' % livestatus_uri)\n\n            # Updating backend_definition with current value\n            backend_definition['name'] = section\n            backend_definition['fields'] = fields_to_retrieve\n            for key, value in section_values.items():\n                backend_definition[key] = value\n\n            self.backends.append(backend_definition)\n\n    def parse_options(self):\n        parser = argparse.ArgumentParser()\n        parser.add_argument('--host', nargs=1)\n        parser.add_argument('--list', action='store_true')\n        parser.add_argument('--pretty', action='store_true')\n        self.options = parser.parse_args()\n\n    def add_host(self, hostname, group):\n        if group not in self.result:\n            self.result[group] = {}\n            self.result[group]['hosts'] = []\n        if hostname not in self.result[group]['hosts']:\n            self.result[group]['hosts'].append(hostname)\n\n    def query_backend(self, backend, host=None):\n        '''Query a livestatus backend'''\n        hosts_request = Socket(backend['connection']).hosts.columns(backend['host_field'], backend['group_field'])\n\n        if backend['host_filter'] is not None:\n            hosts_request = hosts_request.filter(backend['host_filter'])\n\n        if host is not None:\n            hosts_request = hosts_request.filter('name = ' + host[0])\n\n        hosts_request._columns += backend['fields']\n\n        hosts = hosts_request.call()\n        for host in hosts:\n            hostname = host[backend['host_field']]\n            hostgroups = host[backend['group_field']]\n            if not isinstance(hostgroups, list):\n                hostgroups = [hostgroups]\n            self.add_host(hostname, 'all')\n            self.add_host(hostname, backend['name'])\n            for group in hostgroups:\n                self.add_host(hostname, group)\n            for field in backend['fields']:\n                var_name = backend['var_prefix'] + field\n                if hostname not in self.result['_meta']['hostvars']:\n                    self.result['_meta']['hostvars'][hostname] = {}\n                self.result['_meta']['hostvars'][hostname][var_name] = host[field]\n\n    def __init__(self):\n\n        self.defaultgroup = 'group_all'\n        self.default_fields_to_retrieve = ('address', 'alias', 'display_name', 'childs', 'parents')\n        self.backends = []\n        self.options = None\n\n        self.parse_ini_file()\n        self.parse_options()\n\n        self.result = {}\n        self.result['_meta'] = {}\n        self.result['_meta']['hostvars'] = {}\n        self.json_indent = None\n        if self.options.pretty:\n            self.json_indent = 2\n\n        if len(self.backends) == 0:\n            sys.exit(\"Error: Livestatus configuration is missing. See nagios_livestatus.ini.\")\n\n        for backend in self.backends:\n            self.query_backend(backend, self.options.host)\n\n        if self.options.host:\n            print(json.dumps(self.result['_meta']['hostvars'][self.options.host[0]], indent=self.json_indent))\n        elif self.options.list:\n            print(json.dumps(self.result, indent=self.json_indent))\n        else:\n            sys.exit(\"usage: --list or --host HOSTNAME [--pretty]\")\n\nNagiosLivestatusInventory()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "nagios_livestatus.py", "id": "ca922012933fb947498d8cd9cef86296", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/contrib/inventory/nagios_livestatus.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}