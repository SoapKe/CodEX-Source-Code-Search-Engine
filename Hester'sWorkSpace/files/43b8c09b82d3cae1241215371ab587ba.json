{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom datetime import datetime, timedelta\n\nfrom odoo import api, fields, models, _\nfrom odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, float_compare\nfrom odoo.exceptions import UserError\n\n\nclass SaleOrder(models.Model):\n    _inherit = \"sale.order\"\n\n    @api.model\n    def _default_warehouse_id(self):\n        company = self.env.user.company_id.id\n        warehouse_ids = self.env['stock.warehouse'].search([('company_id', '=', company)], limit=1)\n        return warehouse_ids\n\n    incoterm = fields.Many2one(\n        'stock.incoterms', 'Incoterms',\n        help=\"International Commercial Terms are a series of predefined commercial terms used in international transactions.\")\n    picking_policy = fields.Selection([\n        ('direct', 'Deliver each product when available'),\n        ('one', 'Deliver all products at once')],\n        string='Shipping Policy', required=True, readonly=True, default='direct',\n        states={'draft': [('readonly', False)], 'sent': [('readonly', False)]})\n    warehouse_id = fields.Many2one(\n        'stock.warehouse', string='Warehouse',\n        required=True, readonly=True, states={'draft': [('readonly', False)], 'sent': [('readonly', False)]},\n        default=_default_warehouse_id)\n    picking_ids = fields.One2many('stock.picking', 'sale_id', string='Pickings')\n    delivery_count = fields.Integer(string='Delivery Orders', compute='_compute_picking_ids')\n    procurement_group_id = fields.Many2one('procurement.group', 'Procurement Group', copy=False)\n\n    @api.multi\n    def _action_confirm(self):\n        super(SaleOrder, self)._action_confirm()\n        for order in self:\n            order.order_line._action_launch_procurement_rule()\n\n    @api.depends('picking_ids')\n    def _compute_picking_ids(self):\n        for order in self:\n            order.delivery_count = len(order.picking_ids)\n\n    @api.onchange('warehouse_id')\n    def _onchange_warehouse_id(self):\n        if self.warehouse_id.company_id:\n            self.company_id = self.warehouse_id.company_id.id\n\n    @api.multi\n    def action_view_delivery(self):\n        \n        action = self.env.ref('stock.action_picking_tree_all').read()[0]\n\n        pickings = self.mapped('picking_ids')\n        if len(pickings) > 1:\n            action['domain'] = [('id', 'in', pickings.ids)]\n        elif pickings:\n            action['views'] = [(self.env.ref('stock.view_picking_form').id, 'form')]\n            action['res_id'] = pickings.id\n        return action\n\n    @api.multi\n    def action_cancel(self):\n        self.mapped('picking_ids').action_cancel()\n        return super(SaleOrder, self).action_cancel()\n\n    @api.multi\n    def _prepare_invoice(self):\n        invoice_vals = super(SaleOrder, self)._prepare_invoice()\n        invoice_vals['incoterms_id'] = self.incoterm.id or False\n        return invoice_vals\n\n    @api.model\n    def _get_customer_lead(self, product_tmpl_id):\n        super(SaleOrder, self)._get_customer_lead(product_tmpl_id)\n        return product_tmpl_id.sale_delay\n\n\nclass SaleOrderLine(models.Model):\n    _inherit = 'sale.order.line'\n\n    product_packaging = fields.Many2one('product.packaging', string='Package', default=False)\n    route_id = fields.Many2one('stock.location.route', string='Route', domain=[('sale_selectable', '=', True)], ondelete='restrict')\n    move_ids = fields.One2many('stock.move', 'sale_line_id', string='Stock Moves')\n\n    @api.model\n    def create(self, values):\n        line = super(SaleOrderLine, self).create(values)\n        if line.state == 'sale':\n            line._action_launch_procurement_rule()\n        return line\n\n    @api.multi\n    def write(self, values):\n        lines = False\n        if 'product_uom_qty' in values:\n            precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')\n            lines = self.filtered(\n                lambda r: r.state == 'sale' and float_compare(r.product_uom_qty, values['product_uom_qty'], precision_digits=precision) == -1)\n        res = super(SaleOrderLine, self).write(values)\n        if lines:\n            lines._action_launch_procurement_rule()\n        return res\n    \n\n    @api.depends('order_id.state')\n    def _compute_invoice_status(self):\n        super(SaleOrderLine, self)._compute_invoice_status()\n        for line in self:\n            \n            \n            \n            \n            if line.order_id.state == 'done'\\\n                    and line.invoice_status == 'no'\\\n                    and line.product_id.type in ['consu', 'product']\\\n                    and line.product_id.invoice_policy == 'delivery'\\\n                    and line.move_ids \\\n                    and all(move.state in ['done', 'cancel'] for move in line.move_ids):\n                line.invoice_status = 'invoiced'\n\n    @api.depends('move_ids')\n    def _compute_product_updatable(self):\n        for line in self:\n            if not line.move_ids.filtered(lambda m: m.state != 'cancel'):\n                super(SaleOrderLine, line)._compute_product_updatable()\n            else:\n                line.product_updatable = False\n\n    @api.multi\n    @api.depends('product_id')\n    def _compute_qty_delivered_updateable(self):\n        \n        self.mapped('product_id')\n        \n        \n        lines = self.filtered(lambda line: line.product_id.type not in ('consu', 'product'))\n        lines = lines.with_prefetch(self._prefetch)\n        super(SaleOrderLine, lines)._compute_qty_delivered_updateable()\n\n    @api.onchange('product_id')\n    def _onchange_product_id_set_customer_lead(self):\n        self.customer_lead = self.product_id.sale_delay\n\n    @api.onchange('product_packaging')\n    def _onchange_product_packaging(self):\n        if self.product_packaging:\n            return self._check_package()\n\n    @api.onchange('product_id')\n    def _onchange_product_id_uom_check_availability(self):\n        if not self.product_uom or (self.product_id.uom_id.category_id.id != self.product_uom.category_id.id):\n            self.product_uom = self.product_id.uom_id\n        self._onchange_product_id_check_availability()\n\n    @api.onchange('product_uom_qty', 'product_uom', 'route_id')\n    def _onchange_product_id_check_availability(self):\n        if not self.product_id or not self.product_uom_qty or not self.product_uom:\n            self.product_packaging = False\n            return {}\n        if self.product_id.type == 'product':\n            precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')\n            product = self.product_id.with_context(warehouse=self.order_id.warehouse_id.id)\n            product_qty = self.product_uom._compute_quantity(self.product_uom_qty, self.product_id.uom_id)\n            if float_compare(product.virtual_available, product_qty, precision_digits=precision) == -1:\n                is_available = self._check_routing()\n                if not is_available:\n                    message =  _('You plan to sell %s %s but you only have %s %s available in %s warehouse.') % \\\n                            (self.product_uom_qty, self.product_uom.name, product.virtual_available, product.uom_id.name, self.order_id.warehouse_id.name)\n                    \n                    if float_compare(product.virtual_available, self.product_id.virtual_available, precision_digits=precision) == -1:\n                        message += _('\\nThere are %s %s available accross all warehouses.') % \\\n                                (self.product_id.virtual_available, product.uom_id.name)\n\n                    warning_mess = {\n                        'title': _('Not enough inventory!'),\n                        'message' : message\n                    }\n                    return {'warning': warning_mess}\n        return {}\n\n    @api.onchange('product_uom_qty')\n    def _onchange_product_uom_qty(self):\n        if self.state == 'sale' and self.product_id.type in ['product', 'consu'] and self.product_uom_qty < self._origin.product_uom_qty:\n            \n            \n            if self.product_uom_qty < self.qty_delivered:\n                return {}\n            warning_mess = {\n                'title': _('Ordered quantity decreased!'),\n                'message' : _('You are decreasing the ordered quantity! Do not forget to manually update the delivery order if needed.'),\n            }\n            return {'warning': warning_mess}\n        return {}\n\n    @api.multi\n    def _prepare_procurement_values(self, group_id=False):\n        \"\"\" Prepare specific key for moves or other components that will be created from a procurement rule\n        comming from a sale order line. This method could be override in order to add other custom key that could\n        be used in move/po creation.\n        \"\"\"\n        values = super(SaleOrderLine, self)._prepare_procurement_values(group_id)\n        self.ensure_one()\n        date_planned = datetime.strptime(self.order_id.confirmation_date, DEFAULT_SERVER_DATETIME_FORMAT)\\\n            + timedelta(days=self.customer_lead or 0.0) - timedelta(days=self.order_id.company_id.security_lead)\n        values.update({\n            'company_id': self.order_id.company_id,\n            'group_id': group_id,\n            'sale_line_id': self.id,\n            'date_planned': date_planned.strftime(DEFAULT_SERVER_DATETIME_FORMAT),\n            'route_ids': self.route_id,\n            'warehouse_id': self.order_id.warehouse_id or False,\n            'partner_dest_id': self.order_id.partner_shipping_id\n        })\n        return values\n\n    @api.multi\n    def _action_launch_procurement_rule(self):\n        \"\"\"\n        Launch procurement group run method with required/custom fields genrated by a\n        sale order line. procurement group will launch '_run_move', '_run_buy' or '_run_manufacture'\n        depending on the sale order line product rule.\n        \"\"\"\n        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')\n        errors = []\n        for line in self:\n            if line.state != 'sale' or not line.product_id.type in ('consu','product'):\n                continue\n            qty = 0.0\n            for move in line.move_ids.filtered(lambda r: r.state != 'cancel'):\n                qty += move.product_uom._compute_quantity(move.product_uom_qty, line.product_uom, rounding_method='HALF-UP')\n            if float_compare(qty, line.product_uom_qty, precision_digits=precision) >= 0:\n                continue\n\n            group_id = line.order_id.procurement_group_id\n            if not group_id:\n                group_id = self.env['procurement.group'].create({\n                    'name': line.order_id.name, 'move_type': line.order_id.picking_policy,\n                    'sale_id': line.order_id.id,\n                    'partner_id': line.order_id.partner_shipping_id.id,\n                })\n                line.order_id.procurement_group_id = group_id\n            else:\n                \n                \n                updated_vals = {}\n                if group_id.partner_id != line.order_id.partner_shipping_id:\n                    updated_vals.update({'partner_id': line.order_id.partner_shipping_id.id})\n                if group_id.move_type != line.order_id.picking_policy:\n                    updated_vals.update({'move_type': line.order_id.picking_policy})\n                if updated_vals:\n                    group_id.write(updated_vals)\n\n            values = line._prepare_procurement_values(group_id=group_id)\n            product_qty = line.product_uom_qty - qty\n\n            procurement_uom = line.product_uom\n            quant_uom = line.product_id.uom_id\n            get_param = self.env['ir.config_parameter'].sudo().get_param\n            if procurement_uom.id != quant_uom.id and get_param('stock.propagate_uom') != '1':\n                product_qty = line.product_uom._compute_quantity(product_qty, quant_uom, rounding_method='HALF-UP')\n                procurement_uom = quant_uom\n\n            try:\n                self.env['procurement.group'].run(line.product_id, product_qty, procurement_uom, line.order_id.partner_shipping_id.property_stock_customer, line.name, line.order_id.name, values)\n            except UserError as error:\n                errors.append(error.name)\n        if errors:\n            raise UserError('\\n'.join(errors))\n        return True\n\n    @api.multi\n    def _get_delivered_qty(self):\n        self.ensure_one()\n        super(SaleOrderLine, self)._get_delivered_qty()\n        qty = 0.0\n        for move in self.move_ids.filtered(lambda r: r.state == 'done' and not r.scrapped):\n            if move.location_dest_id.usage == \"customer\":\n                if not move.origin_returned_move_id:\n                    qty += move.product_uom._compute_quantity(move.product_uom_qty, self.product_uom)\n            elif move.location_dest_id.usage != \"customer\" and move.to_refund:\n                qty -= move.product_uom._compute_quantity(move.product_uom_qty, self.product_uom)\n        return qty\n\n    @api.multi\n    def _check_package(self):\n        default_uom = self.product_id.uom_id\n        pack = self.product_packaging\n        qty = self.product_uom_qty\n        q = default_uom._compute_quantity(pack.qty, self.product_uom)\n        if qty and q and (qty % q):\n            newqty = qty - (qty % q) + q\n            return {\n                'warning': {\n                    'title': _('Warning'),\n                    'message': _(\"This product is packaged by %.2f %s. You should sell %.2f %s.\") % (pack.qty, default_uom.name, newqty, self.product_uom.name),\n                },\n            }\n        return {}\n\n\n    def _check_routing(self):\n        \"\"\" Verify the route of the product based on the warehouse\n            return True if the product availibility in stock does not need to be verified,\n            which is the case in MTO, Cross-Dock or Drop-Shipping\n        \"\"\"\n        is_available = False\n        product_routes = self.route_id or (self.product_id.route_ids + self.product_id.categ_id.total_route_ids)\n\n        \n        wh_mto_route = self.order_id.warehouse_id.mto_pull_id.route_id\n        if wh_mto_route and wh_mto_route <= product_routes:\n            is_available = True\n        else:\n            mto_route = False\n            try:\n                mto_route = self.env['stock.warehouse']._get_mto_route()\n            except UserError:\n                \n                pass\n            if mto_route and mto_route in product_routes:\n                is_available = True\n\n        \n        if not is_available:\n            for pull_rule in product_routes.mapped('pull_ids'):\n                if pull_rule.picking_type_id.sudo().default_location_src_id.usage == 'supplier' and\\\n                        pull_rule.picking_type_id.sudo().default_location_dest_id.usage == 'customer':\n                    is_available = True\n                    break\n\n        return is_available\n\n    def _update_line_quantity(self, values):\n        if self.mapped('qty_delivered') and values['product_uom_qty'] < max(self.mapped('qty_delivered')):\n            raise UserError('You cannot decrease the ordered quantity below the delivered quantity.\\n'\n                            'Create a return first.')\n        for line in self:\n            pickings = self.order_id.picking_ids.filtered(lambda p: p.state not in ('done', 'cancel'))\n            for picking in pickings:\n                picking.message_post(\"The quantity of %s has been updated from %d to %d in %s\" %\n                                      (line.product_id.name, line.product_uom_qty, values['product_uom_qty'], self.order_id.name))\n        super(SaleOrderLine, self)._update_line_quantity(values)\n", "comments": "    prepare specific key moves components created procurement rule         comming sale order line  this method could override order add custom key could         used move po creation                      values   super(saleorderline  self)  prepare procurement values(group id)         self ensure one()         date planned   datetime strptime(self order id confirmation date  default server datetime format)                timedelta(days self customer lead 0 0)   timedelta(days self order id company id security lead)         values update(               company id   self order id company id               group id   group id               sale line id   self id               date planned   date planned strftime(default server datetime format)               route ids   self route id               warehouse id   self order id warehouse id false               partner dest id   self order id partner shipping id          )         return values       api multi     def  action launch procurement rule(self)                      launch procurement group run method required custom fields genrated         sale order line  procurement group launch   run move     run buy    run manufacture          depending sale order line product rule                      precision   self env  decimal precision   precision get( product unit measure )         errors              line self              line state     sale  line product id type ( consu   product )                  continue             qty   0 0             move line move ids filtered(lambda r  r state     cancel )                  qty    move product uom  compute quantity(move product uom qty  line product uom  rounding method  half up )             float compare(qty  line product uom qty  precision digits precision)    0                  continue              group id   line order id procurement group id             group id                  group id   self env  procurement group   create(                       name   line order id name   move type   line order id picking policy                       sale id   line order id id                       partner id   line order id partner shipping id id                   )                 line order id procurement group id   group id             else                    in case procurement group already created order                   cancelled  need update certain values group                  updated vals                      group id partner id    line order id partner shipping id                      updated vals update(  partner id   line order id partner shipping id id )                 group id move type    line order id picking policy                      updated vals update(  move type   line order id picking policy )                 updated vals                      group id write(updated vals)              values   line  prepare procurement values(group id group id)             product qty   line product uom qty   qty              procurement uom   line product uom             quant uom   line product id uom id             get param   self env  ir config parameter   sudo() get param             procurement uom id    quant uom id get param( stock propagate uom )     1                   product qty   line product uom  compute quantity(product qty  quant uom  rounding method  half up )                 procurement uom   quant uom              try                  self env  procurement group   run(line product id  product qty  procurement uom  line order id partner shipping id property stock customer  line name  line order id name  values)             except usererror error                  errors append(error name)         errors              raise usererror(  n  join(errors))         return true       api multi     def  get delivered qty(self)          self ensure one()         super(saleorderline  self)  get delivered qty()         qty   0 0         move self move ids filtered(lambda r  r state     done  r scrapped)              move location dest id usage     customer                   move origin returned move id                      qty    move product uom  compute quantity(move product uom qty  self product uom)             elif move location dest id usage     customer  move refund                  qty    move product uom  compute quantity(move product uom qty  self product uom)         return qty       api multi     def  check package(self)          default uom   self product id uom id         pack   self product packaging         qty   self product uom qty         q   default uom  compute quantity(pack qty  self product uom)         qty q (qty   q)              newqty   qty   (qty   q)   q             return                    warning                          title    ( warning )                       message    ( this product packaged   2f   you sell   2f   )   (pack qty  default uom name  newqty  self product uom name)                                           return          def  check routing(self)              verify route product based warehouse             return true product availibility stock need verified              case mto  cross dock drop shipping                          this function returns action display existing delivery orders         given sales order ids  it either list form         view  one delivery order show                     coding  utf 8        part odoo  see license file full copyright licensing details     we handle following specific situation  physical product partially delivered     would like set invoice status  fully invoiced   the use case    products sold weight  delivered quantity rarely matches exactly    quantity ordered     prefetch field filtering    consumable stockable products  qty delivered updateable defaults    false  lines use original computation    we check products available warehouses     do display warning new quantity delivered    one   write  raise  usererror  anyway     in case procurement group already created order    cancelled  need update certain values group     check mto    route mto found ir model data  treat product mts    check drop shipping ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom datetime import datetime, timedelta\n\nfrom odoo import api, fields, models, _\nfrom odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, float_compare\nfrom odoo.exceptions import UserError\n\n\nclass SaleOrder(models.Model):\n    _inherit = \"sale.order\"\n\n    @api.model\n    def _default_warehouse_id(self):\n        company = self.env.user.company_id.id\n        warehouse_ids = self.env['stock.warehouse'].search([('company_id', '=', company)], limit=1)\n        return warehouse_ids\n\n    incoterm = fields.Many2one(\n        'stock.incoterms', 'Incoterms',\n        help=\"International Commercial Terms are a series of predefined commercial terms used in international transactions.\")\n    picking_policy = fields.Selection([\n        ('direct', 'Deliver each product when available'),\n        ('one', 'Deliver all products at once')],\n        string='Shipping Policy', required=True, readonly=True, default='direct',\n        states={'draft': [('readonly', False)], 'sent': [('readonly', False)]})\n    warehouse_id = fields.Many2one(\n        'stock.warehouse', string='Warehouse',\n        required=True, readonly=True, states={'draft': [('readonly', False)], 'sent': [('readonly', False)]},\n        default=_default_warehouse_id)\n    picking_ids = fields.One2many('stock.picking', 'sale_id', string='Pickings')\n    delivery_count = fields.Integer(string='Delivery Orders', compute='_compute_picking_ids')\n    procurement_group_id = fields.Many2one('procurement.group', 'Procurement Group', copy=False)\n\n    @api.multi\n    def _action_confirm(self):\n        super(SaleOrder, self)._action_confirm()\n        for order in self:\n            order.order_line._action_launch_procurement_rule()\n\n    @api.depends('picking_ids')\n    def _compute_picking_ids(self):\n        for order in self:\n            order.delivery_count = len(order.picking_ids)\n\n    @api.onchange('warehouse_id')\n    def _onchange_warehouse_id(self):\n        if self.warehouse_id.company_id:\n            self.company_id = self.warehouse_id.company_id.id\n\n    @api.multi\n    def action_view_delivery(self):\n        '''\n        This function returns an action that display existing delivery orders\n        of given sales order ids. It can either be a in a list or in a form\n        view, if there is only one delivery order to show.\n        '''\n        action = self.env.ref('stock.action_picking_tree_all').read()[0]\n\n        pickings = self.mapped('picking_ids')\n        if len(pickings) > 1:\n            action['domain'] = [('id', 'in', pickings.ids)]\n        elif pickings:\n            action['views'] = [(self.env.ref('stock.view_picking_form').id, 'form')]\n            action['res_id'] = pickings.id\n        return action\n\n    @api.multi\n    def action_cancel(self):\n        self.mapped('picking_ids').action_cancel()\n        return super(SaleOrder, self).action_cancel()\n\n    @api.multi\n    def _prepare_invoice(self):\n        invoice_vals = super(SaleOrder, self)._prepare_invoice()\n        invoice_vals['incoterms_id'] = self.incoterm.id or False\n        return invoice_vals\n\n    @api.model\n    def _get_customer_lead(self, product_tmpl_id):\n        super(SaleOrder, self)._get_customer_lead(product_tmpl_id)\n        return product_tmpl_id.sale_delay\n\n\nclass SaleOrderLine(models.Model):\n    _inherit = 'sale.order.line'\n\n    product_packaging = fields.Many2one('product.packaging', string='Package', default=False)\n    route_id = fields.Many2one('stock.location.route', string='Route', domain=[('sale_selectable', '=', True)], ondelete='restrict')\n    move_ids = fields.One2many('stock.move', 'sale_line_id', string='Stock Moves')\n\n    @api.model\n    def create(self, values):\n        line = super(SaleOrderLine, self).create(values)\n        if line.state == 'sale':\n            line._action_launch_procurement_rule()\n        return line\n\n    @api.multi\n    def write(self, values):\n        lines = False\n        if 'product_uom_qty' in values:\n            precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')\n            lines = self.filtered(\n                lambda r: r.state == 'sale' and float_compare(r.product_uom_qty, values['product_uom_qty'], precision_digits=precision) == -1)\n        res = super(SaleOrderLine, self).write(values)\n        if lines:\n            lines._action_launch_procurement_rule()\n        return res\n    \n\n    @api.depends('order_id.state')\n    def _compute_invoice_status(self):\n        super(SaleOrderLine, self)._compute_invoice_status()\n        for line in self:\n            # We handle the following specific situation: a physical product is partially delivered,\n            # but we would like to set its invoice status to 'Fully Invoiced'. The use case is for\n            # products sold by weight, where the delivered quantity rarely matches exactly the\n            # quantity ordered.\n            if line.order_id.state == 'done'\\\n                    and line.invoice_status == 'no'\\\n                    and line.product_id.type in ['consu', 'product']\\\n                    and line.product_id.invoice_policy == 'delivery'\\\n                    and line.move_ids \\\n                    and all(move.state in ['done', 'cancel'] for move in line.move_ids):\n                line.invoice_status = 'invoiced'\n\n    @api.depends('move_ids')\n    def _compute_product_updatable(self):\n        for line in self:\n            if not line.move_ids.filtered(lambda m: m.state != 'cancel'):\n                super(SaleOrderLine, line)._compute_product_updatable()\n            else:\n                line.product_updatable = False\n\n    @api.multi\n    @api.depends('product_id')\n    def _compute_qty_delivered_updateable(self):\n        # prefetch field before filtering\n        self.mapped('product_id')\n        # on consumable or stockable products, qty_delivered_updateable defaults\n        # to False; on other lines use the original computation\n        lines = self.filtered(lambda line: line.product_id.type not in ('consu', 'product'))\n        lines = lines.with_prefetch(self._prefetch)\n        super(SaleOrderLine, lines)._compute_qty_delivered_updateable()\n\n    @api.onchange('product_id')\n    def _onchange_product_id_set_customer_lead(self):\n        self.customer_lead = self.product_id.sale_delay\n\n    @api.onchange('product_packaging')\n    def _onchange_product_packaging(self):\n        if self.product_packaging:\n            return self._check_package()\n\n    @api.onchange('product_id')\n    def _onchange_product_id_uom_check_availability(self):\n        if not self.product_uom or (self.product_id.uom_id.category_id.id != self.product_uom.category_id.id):\n            self.product_uom = self.product_id.uom_id\n        self._onchange_product_id_check_availability()\n\n    @api.onchange('product_uom_qty', 'product_uom', 'route_id')\n    def _onchange_product_id_check_availability(self):\n        if not self.product_id or not self.product_uom_qty or not self.product_uom:\n            self.product_packaging = False\n            return {}\n        if self.product_id.type == 'product':\n            precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')\n            product = self.product_id.with_context(warehouse=self.order_id.warehouse_id.id)\n            product_qty = self.product_uom._compute_quantity(self.product_uom_qty, self.product_id.uom_id)\n            if float_compare(product.virtual_available, product_qty, precision_digits=precision) == -1:\n                is_available = self._check_routing()\n                if not is_available:\n                    message =  _('You plan to sell %s %s but you only have %s %s available in %s warehouse.') % \\\n                            (self.product_uom_qty, self.product_uom.name, product.virtual_available, product.uom_id.name, self.order_id.warehouse_id.name)\n                    # We check if some products are available in other warehouses.\n                    if float_compare(product.virtual_available, self.product_id.virtual_available, precision_digits=precision) == -1:\n                        message += _('\\nThere are %s %s available accross all warehouses.') % \\\n                                (self.product_id.virtual_available, product.uom_id.name)\n\n                    warning_mess = {\n                        'title': _('Not enough inventory!'),\n                        'message' : message\n                    }\n                    return {'warning': warning_mess}\n        return {}\n\n    @api.onchange('product_uom_qty')\n    def _onchange_product_uom_qty(self):\n        if self.state == 'sale' and self.product_id.type in ['product', 'consu'] and self.product_uom_qty < self._origin.product_uom_qty:\n            # Do not display this warning if the new quantity is below the delivered\n            # one; the `write` will raise an `UserError` anyway.\n            if self.product_uom_qty < self.qty_delivered:\n                return {}\n            warning_mess = {\n                'title': _('Ordered quantity decreased!'),\n                'message' : _('You are decreasing the ordered quantity! Do not forget to manually update the delivery order if needed.'),\n            }\n            return {'warning': warning_mess}\n        return {}\n\n    @api.multi\n    def _prepare_procurement_values(self, group_id=False):\n        \"\"\" Prepare specific key for moves or other components that will be created from a procurement rule\n        comming from a sale order line. This method could be override in order to add other custom key that could\n        be used in move/po creation.\n        \"\"\"\n        values = super(SaleOrderLine, self)._prepare_procurement_values(group_id)\n        self.ensure_one()\n        date_planned = datetime.strptime(self.order_id.confirmation_date, DEFAULT_SERVER_DATETIME_FORMAT)\\\n            + timedelta(days=self.customer_lead or 0.0) - timedelta(days=self.order_id.company_id.security_lead)\n        values.update({\n            'company_id': self.order_id.company_id,\n            'group_id': group_id,\n            'sale_line_id': self.id,\n            'date_planned': date_planned.strftime(DEFAULT_SERVER_DATETIME_FORMAT),\n            'route_ids': self.route_id,\n            'warehouse_id': self.order_id.warehouse_id or False,\n            'partner_dest_id': self.order_id.partner_shipping_id\n        })\n        return values\n\n    @api.multi\n    def _action_launch_procurement_rule(self):\n        \"\"\"\n        Launch procurement group run method with required/custom fields genrated by a\n        sale order line. procurement group will launch '_run_move', '_run_buy' or '_run_manufacture'\n        depending on the sale order line product rule.\n        \"\"\"\n        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')\n        errors = []\n        for line in self:\n            if line.state != 'sale' or not line.product_id.type in ('consu','product'):\n                continue\n            qty = 0.0\n            for move in line.move_ids.filtered(lambda r: r.state != 'cancel'):\n                qty += move.product_uom._compute_quantity(move.product_uom_qty, line.product_uom, rounding_method='HALF-UP')\n            if float_compare(qty, line.product_uom_qty, precision_digits=precision) >= 0:\n                continue\n\n            group_id = line.order_id.procurement_group_id\n            if not group_id:\n                group_id = self.env['procurement.group'].create({\n                    'name': line.order_id.name, 'move_type': line.order_id.picking_policy,\n                    'sale_id': line.order_id.id,\n                    'partner_id': line.order_id.partner_shipping_id.id,\n                })\n                line.order_id.procurement_group_id = group_id\n            else:\n                # In case the procurement group is already created and the order was\n                # cancelled, we need to update certain values of the group.\n                updated_vals = {}\n                if group_id.partner_id != line.order_id.partner_shipping_id:\n                    updated_vals.update({'partner_id': line.order_id.partner_shipping_id.id})\n                if group_id.move_type != line.order_id.picking_policy:\n                    updated_vals.update({'move_type': line.order_id.picking_policy})\n                if updated_vals:\n                    group_id.write(updated_vals)\n\n            values = line._prepare_procurement_values(group_id=group_id)\n            product_qty = line.product_uom_qty - qty\n\n            procurement_uom = line.product_uom\n            quant_uom = line.product_id.uom_id\n            get_param = self.env['ir.config_parameter'].sudo().get_param\n            if procurement_uom.id != quant_uom.id and get_param('stock.propagate_uom') != '1':\n                product_qty = line.product_uom._compute_quantity(product_qty, quant_uom, rounding_method='HALF-UP')\n                procurement_uom = quant_uom\n\n            try:\n                self.env['procurement.group'].run(line.product_id, product_qty, procurement_uom, line.order_id.partner_shipping_id.property_stock_customer, line.name, line.order_id.name, values)\n            except UserError as error:\n                errors.append(error.name)\n        if errors:\n            raise UserError('\\n'.join(errors))\n        return True\n\n    @api.multi\n    def _get_delivered_qty(self):\n        self.ensure_one()\n        super(SaleOrderLine, self)._get_delivered_qty()\n        qty = 0.0\n        for move in self.move_ids.filtered(lambda r: r.state == 'done' and not r.scrapped):\n            if move.location_dest_id.usage == \"customer\":\n                if not move.origin_returned_move_id:\n                    qty += move.product_uom._compute_quantity(move.product_uom_qty, self.product_uom)\n            elif move.location_dest_id.usage != \"customer\" and move.to_refund:\n                qty -= move.product_uom._compute_quantity(move.product_uom_qty, self.product_uom)\n        return qty\n\n    @api.multi\n    def _check_package(self):\n        default_uom = self.product_id.uom_id\n        pack = self.product_packaging\n        qty = self.product_uom_qty\n        q = default_uom._compute_quantity(pack.qty, self.product_uom)\n        if qty and q and (qty % q):\n            newqty = qty - (qty % q) + q\n            return {\n                'warning': {\n                    'title': _('Warning'),\n                    'message': _(\"This product is packaged by %.2f %s. You should sell %.2f %s.\") % (pack.qty, default_uom.name, newqty, self.product_uom.name),\n                },\n            }\n        return {}\n\n\n    def _check_routing(self):\n        \"\"\" Verify the route of the product based on the warehouse\n            return True if the product availibility in stock does not need to be verified,\n            which is the case in MTO, Cross-Dock or Drop-Shipping\n        \"\"\"\n        is_available = False\n        product_routes = self.route_id or (self.product_id.route_ids + self.product_id.categ_id.total_route_ids)\n\n        # Check MTO\n        wh_mto_route = self.order_id.warehouse_id.mto_pull_id.route_id\n        if wh_mto_route and wh_mto_route <= product_routes:\n            is_available = True\n        else:\n            mto_route = False\n            try:\n                mto_route = self.env['stock.warehouse']._get_mto_route()\n            except UserError:\n                # if route MTO not found in ir_model_data, we treat the product as in MTS\n                pass\n            if mto_route and mto_route in product_routes:\n                is_available = True\n\n        # Check Drop-Shipping\n        if not is_available:\n            for pull_rule in product_routes.mapped('pull_ids'):\n                if pull_rule.picking_type_id.sudo().default_location_src_id.usage == 'supplier' and\\\n                        pull_rule.picking_type_id.sudo().default_location_dest_id.usage == 'customer':\n                    is_available = True\n                    break\n\n        return is_available\n\n    def _update_line_quantity(self, values):\n        if self.mapped('qty_delivered') and values['product_uom_qty'] < max(self.mapped('qty_delivered')):\n            raise UserError('You cannot decrease the ordered quantity below the delivered quantity.\\n'\n                            'Create a return first.')\n        for line in self:\n            pickings = self.order_id.picking_ids.filtered(lambda p: p.state not in ('done', 'cancel'))\n            for picking in pickings:\n                picking.message_post(\"The quantity of %s has been updated from %d to %d in %s\" %\n                                      (line.product_id.name, line.product_uom_qty, values['product_uom_qty'], self.order_id.name))\n        super(SaleOrderLine, self)._update_line_quantity(values)\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "sale_order.py", "id": "43b8c09b82d3cae1241215371ab587ba", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/sale_stock/models/sale_order.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}