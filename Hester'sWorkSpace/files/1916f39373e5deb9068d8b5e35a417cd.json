{"author": "keon", "code": "\"\"\"\nGiven two words (beginWord and endWord), and a dictionary's word list,\nfind the length of shortest transformation sequence\nfrom beginWord to endWord, such that:\n\nOnly one letter can be changed at a time\nEach intermediate word must exist in the word list\nFor example,\n\nGiven:\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nAs one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\nreturn its length 5.\n.\nNote:\nReturn 0 if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters.\n\"\"\"\ndef ladderLength(beginWord, endWord, wordList):\n    \"\"\"\n    Bidirectional BFS!!!\n    :type beginWord: str\n    :type endWord: str\n    :type wordList: Set[str]\n    :rtype: int\n    \"\"\"\n    beginSet = set()\n    endSet = set()\n    beginSet.add(beginWord)\n    endSet.add(endWord)\n    result = 2\n    while len(beginSet) != 0 and len(endSet) != 0:\n        if len(beginSet) > len(endSet):\n            beginSet, endSet = endSet, beginSet\n        nextBeginSet = set()\n        for word in beginSet:\n            for ladderWord in wordRange(word):\n                if ladderWord in endSet:\n                    return result\n                if ladderWord in wordList:\n                    nextBeginSet.add(ladderWord)\n                    wordList.remove(ladderWord)\n        beginSet = nextBeginSet\n        result += 1\n        print(beginSet)\n        print(result)\n    return 0\n\ndef wordRange(word):\n    for ind in range(len(word)):\n        tempC = word[ind]\n        for c in [chr(x) for x in range(ord('a'), ord('z')+1)]:\n            if c != tempC:\n                yield word[:ind] + c + word[ind+1:]\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nprint(ladderLength(beginWord, endWord, wordList))\n", "comments": "    given two words (beginword endword)  dictionary word list  find length shortest transformation sequence beginword endword    only one letter changed time each intermediate word must exist word list for example   given  beginword    hit  endword    cog  wordlist     hot   dot   dog   lot   log   as one shortest transformation  hit      hot      dot      dog      cog   return length 5    note  return 0 transformation sequence  all words length  all words contain lowercase alphabetic characters      def ladderlength(beginword  endword  wordlist)              bidirectional bfs         type beginword  str      type endword  str      type wordlist  set str       rtype  int         ", "content": "\"\"\"\nGiven two words (beginWord and endWord), and a dictionary's word list,\nfind the length of shortest transformation sequence\nfrom beginWord to endWord, such that:\n\nOnly one letter can be changed at a time\nEach intermediate word must exist in the word list\nFor example,\n\nGiven:\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nAs one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\nreturn its length 5.\n.\nNote:\nReturn 0 if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters.\n\"\"\"\ndef ladderLength(beginWord, endWord, wordList):\n    \"\"\"\n    Bidirectional BFS!!!\n    :type beginWord: str\n    :type endWord: str\n    :type wordList: Set[str]\n    :rtype: int\n    \"\"\"\n    beginSet = set()\n    endSet = set()\n    beginSet.add(beginWord)\n    endSet.add(endWord)\n    result = 2\n    while len(beginSet) != 0 and len(endSet) != 0:\n        if len(beginSet) > len(endSet):\n            beginSet, endSet = endSet, beginSet\n        nextBeginSet = set()\n        for word in beginSet:\n            for ladderWord in wordRange(word):\n                if ladderWord in endSet:\n                    return result\n                if ladderWord in wordList:\n                    nextBeginSet.add(ladderWord)\n                    wordList.remove(ladderWord)\n        beginSet = nextBeginSet\n        result += 1\n        print(beginSet)\n        print(result)\n    return 0\n\ndef wordRange(word):\n    for ind in range(len(word)):\n        tempC = word[ind]\n        for c in [chr(x) for x in range(ord('a'), ord('z')+1)]:\n            if c != tempC:\n                yield word[:ind] + c + word[ind+1:]\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nprint(ladderLength(beginWord, endWord, wordList))\n", "description": "Minimal examples of data structures and algorithms in Python", "file_name": "word_ladder.py", "id": "1916f39373e5deb9068d8b5e35a417cd", "language": "Python", "project_name": "algorithms", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/keon-algorithms/keon-algorithms-abe4cb1/bfs/word_ladder.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:56:36Z", "url": "https://github.com/keon/algorithms", "wiki": true}