{"author": "p-e-w", "code": "\n\n Copyright (c) 2016-2017 Philipp Emanuel Weidmann <pew@worldwidemann.com>\n\n Nemo vir est qui mundum non reddat meliorem.\n\n Released under the terms of the GNU General Public License, version 3\n (https://gnu.org/licenses/gpl.html)\n\n\nfrom __future__ import unicode_literals, print_function\n\nimport sys\nimport subprocess\nfrom imp import load_source\nfrom ast import literal_eval\nfrom argparse import ArgumentParser\nfrom logging import getLogger, NullHandler\nfrom os.path import splitext, basename\n\nfrom six import PY2\nfrom six.moves import input\nfrom ptrace.tools import locateProgram\nfrom ptrace.debugger import ProcessSignal, NewProcessEvent, ProcessExecution, ProcessExit\nfrom ptrace.debugger.child import createChild\nfrom ptrace.debugger.debugger import PtraceDebugger\nfrom ptrace.func_call import FunctionCallOptions\nfrom ptrace.syscall import SYSCALL_REGISTER, RETURN_VALUE_REGISTER, DIRFD_ARGUMENTS\nfrom ptrace.syscall.posix_constants import SYSCALL_ARG_DICT\nfrom ptrace.syscall.syscall_argument import ARGUMENT_CALLBACK\n\nfrom . import SYSCALL_FILTERS, T, initialize_terminal\nfrom .process import Process\n Filter modules are imported not to use them as symbols, but to execute their top-level code\nfrom .filters import (delete, move, change_permissions, change_owner,     noqa\n                      create_directory, create_link, create_write_file)   noqa\n\n\ndef parse_argument(argument):\n     createText() uses repr() to render the argument,\n     for which literal_eval() acts as an inverse function\n     (see http://stackoverflow.com/a/24886425)\n    argument = literal_eval(argument.createText())\n    if PY2 and isinstance(argument, str):\n        argument = unicode(argument, sys.getfilesystemencoding())   noqa\n    return argument\n\n\ndef get_operations(debugger, syscall_filters, verbose):\n    format_options = FunctionCallOptions(\n        replace_socketcall=False,\n        string_max_length=4096,\n    )\n\n    processes = {}\n    operations = []\n\n    while True:\n        if not debugger:\n             All processes have exited\n            break\n\n         This logic is mostly based on python-ptrace's \"strace\" example\n        try:\n            syscall_event = debugger.waitSyscall()\n        except ProcessSignal as event:\n            event.process.syscall(event.signum)\n            continue\n        except NewProcessEvent as event:\n            event.process.syscall()\n            event.process.parent.syscall()\n            continue\n        except ProcessExecution as event:\n            event.process.syscall()\n            continue\n        except ProcessExit as event:\n            continue\n\n        process = syscall_event.process\n        syscall_state = process.syscall_state\n\n        syscall = syscall_state.event(format_options)\n\n        if syscall and syscall_state.next_event == \"exit\":\n             Syscall is about to be executed (just switched from \"enter\" to \"exit\")\n            if syscall.name in syscall_filters:\n                if verbose == 1:\n                    print(syscall.format())\n                elif verbose == 2:\n                    print(T.bold(syscall.format()))\n\n                filter_function = syscall_filters[syscall.name]\n                if process.pid not in processes:\n                    processes[process.pid] = Process(process)\n                arguments = [parse_argument(argument) for argument in syscall.arguments]\n\n                operation, return_value = filter_function(processes[process.pid], arguments)\n\n                if operation is not None:\n                    operations.append(operation)\n\n                if return_value is not None:\n                     Set invalid syscall number to prevent call execution\n                    process.setreg(SYSCALL_REGISTER, -1)\n                     Substitute return value to make syscall appear to have succeeded\n                    process.setreg(RETURN_VALUE_REGISTER, return_value)\n\n            elif verbose == 2:\n                print(syscall.format())\n\n        process.syscall()\n\n    return operations\n\n\ndef main(argv=sys.argv[1:]):\n    if PY2:\n        argv = [unicode(arg, sys.getfilesystemencoding()) for arg in argv]   noqa\n\n     Insert positional argument separator, if not already present\n    if \"--\" not in argv:\n        for i, argument in enumerate(argv):\n            if not argument.startswith(\"-\"):\n                argv.insert(i, \"--\")\n                break\n\n    arg_parser = ArgumentParser(\n        prog=\"maybe\",\n        usage=\"%(prog)s [options] command [argument ...]\",\n        description=\"Run a command without the ability to make changes to your system \" +\n                    \"and list the changes it would have made.\",\n        epilog=\"For more information, to report issues or to contribute, \" +\n               \"visit https://github.com/p-e-w/maybe.\",\n    )\n    arg_parser.add_argument(\"command\", nargs=\"+\", help=\"the command to run under maybe's control\")\n    arg_group = arg_parser.add_mutually_exclusive_group()\n    arg_group.add_argument(\"-a\", \"--allow\", nargs=\"+\", metavar=\"OPERATION\",\n                           help=\"allow the command to perform the specified operation(s). \" +\n                                \"all other operations will be denied. \" +\n                                \"possible values for %(metavar)s are: \" +\n                                \", \".join(sorted(SYSCALL_FILTERS.keys())) +\n                                \"; as well as any filter scopes defined by loaded plugins\")\n    arg_group.add_argument(\"-d\", \"--deny\", nargs=\"+\", metavar=\"OPERATION\",\n                           help=\"deny the command the specified operation(s). \" +\n                                \"all other operations will be allowed. \" +\n                                \"see --allow for a list of possible values for %(metavar)s. \" +\n                                \"--allow and --deny cannot be combined\")\n    arg_parser.add_argument(\"-p\", \"--plugin\", nargs=\"+\", metavar=\"FILE\",\n                            help=\"load the specified plugin script(s). \" +\n                                 \"see the README for details and plugin API documentation\")\n    arg_parser.add_argument(\"-l\", \"--list-only\", action=\"store_true\",\n                            help=\"list operations without header, indentation and rerun prompt\")\n    arg_parser.add_argument(\"--style-output\", choices=[\"yes\", \"no\", \"auto\"], default=\"auto\",\n                            help=\"colorize output using ANSI escape sequences (yes/no) \" +\n                                 \"or automatically decide based on whether stdout is a terminal (auto, default)\")\n    arg_parser.add_argument(\"-v\", \"--verbose\", action=\"count\",\n                            help=\"if specified once, print every filtered syscall. \" +\n                                 \"if specified twice, print every syscall, highlighting filtered syscalls\")\n    arg_parser.add_argument(\"--version\", action=\"version\", version=\"%(prog)s 0.4.0\")\n    args = arg_parser.parse_args(argv)\n\n    initialize_terminal(args.style_output)\n\n    if args.plugin is not None:\n        for plugin_path in args.plugin:\n            try:\n                module_name = splitext(basename(plugin_path))[0]\n                 Note: imp.load_source is *long* deprecated and not even documented\n                 in Python 3 anymore, but it still seems to work and the \"alternatives\"\n                 (see http://stackoverflow.com/a/67692) are simply too insane to use\n                load_source(module_name, plugin_path)\n            except Exception as error:\n                print(T.red(\"Error loading %s: %s.\" % (T.bold(plugin_path) + T.red, error)))\n                return 1\n\n    if args.allow is not None:\n        for filter_scope in args.allow:\n            if filter_scope not in SYSCALL_FILTERS:\n                print(T.red(\"Unknown operation in --allow: %s.\" % (T.bold(filter_scope) + T.red)))\n                return 1\n        filter_scopes = set(SYSCALL_FILTERS.keys()) - set(args.allow)\n    elif args.deny is not None:\n        for filter_scope in args.deny:\n            if filter_scope not in SYSCALL_FILTERS:\n                print(T.red(\"Unknown operation in --deny: %s.\" % (T.bold(filter_scope) + T.red)))\n                return 1\n        filter_scopes = args.deny\n    else:\n        filter_scopes = SYSCALL_FILTERS.keys()\n\n    syscall_filters = {}\n\n    for filter_scope in SYSCALL_FILTERS:\n        if filter_scope in filter_scopes:\n            for syscall in SYSCALL_FILTERS[filter_scope]:\n                syscall_filters[syscall] = SYSCALL_FILTERS[filter_scope][syscall]\n\n     Suppress logging output from python-ptrace\n    getLogger().addHandler(NullHandler())\n\n     Prevent python-ptrace from decoding arguments to keep raw numerical values\n    DIRFD_ARGUMENTS.clear()\n    SYSCALL_ARG_DICT.clear()\n    ARGUMENT_CALLBACK.clear()\n\n     This is basically \"shlex.join\"\n    command = \" \".join([((\"'%s'\" % arg) if (\" \" in arg) else arg) for arg in args.command])\n\n    try:\n        args.command[0] = locateProgram(args.command[0])\n        pid = createChild(args.command, False)\n    except Exception as error:\n        print(T.red(\"Error executing %s: %s.\" % (T.bold(command) + T.red, error)))\n        return 1\n\n    debugger = PtraceDebugger()\n    debugger.traceFork()\n    debugger.traceExec()\n\n    process = debugger.addProcess(pid, True)\n    process.syscall()\n\n    try:\n        operations = get_operations(debugger, syscall_filters, args.verbose)\n    except Exception as error:\n        print(T.red(\"Error tracing process: %s.\" % error))\n        return 1\n    except KeyboardInterrupt:\n        print(T.yellow(\"%s terminated by keyboard interrupt.\" % (T.bold(command) + T.yellow)))\n        return 2\n    finally:\n         Cut down all processes no matter what happens\n         to prevent them from doing any damage\n        debugger.quit()\n\n    if operations:\n        if not args.list_only:\n            print(\"%s has prevented %s from performing %d file system operations:\\n\" %\n                  (T.bold(\"maybe\"), T.bold(command), len(operations)))\n        for operation in operations:\n            print((\"\" if args.list_only else \"  \") + operation)\n        if not args.list_only:\n            print(\"\\nDo you want to rerun %s and permit these operations? [y/N] \" % T.bold(command), end=\"\")\n            try:\n                choice = input()\n            except KeyboardInterrupt:\n                choice = \"\"\n                 Ctrl+C does not print a newline automatically\n                print(\"\")\n            if choice.lower() == \"y\":\n                subprocess.call(args.command)\n    else:\n        print(\"%s has not detected any file system operations from %s.\" %\n              (T.bold(\"maybe\"), T.bold(command)))\n", "comments": "  maybe   see program deciding whether really want happen       copyright (c) 2016 2017 philipp emanuel weidmann  pew worldwidemann com        nemo vir est qui mundum non reddat meliorem        released terms gnu general public license  version 3    (https   gnu org licenses gpl html)    filter modules imported use symbols  execute top level code    noqa    noqa    createtext() uses repr() render argument     literal eval() acts inverse function    (see http   stackoverflow com 24886425)    noqa    all processes exited    this logic mostly based python ptrace  strace  example    syscall executed (just switched  enter   exit )    set invalid syscall number prevent call execution    substitute return value make syscall appear succeeded    noqa    insert positional argument separator  already present    note  imp load source  long  deprecated even documented    python 3 anymore  still seems work  alternatives     (see http   stackoverflow com 67692) simply insane use    suppress logging output python ptrace    prevent python ptrace decoding arguments keep raw numerical values    this basically  shlex join     cut processes matter happens    prevent damage    ctrl c print newline automatically ", "content": "# maybe - see what a program does before deciding whether you really want it to happen\n#\n# Copyright (c) 2016-2017 Philipp Emanuel Weidmann <pew@worldwidemann.com>\n#\n# Nemo vir est qui mundum non reddat meliorem.\n#\n# Released under the terms of the GNU General Public License, version 3\n# (https://gnu.org/licenses/gpl.html)\n\n\nfrom __future__ import unicode_literals, print_function\n\nimport sys\nimport subprocess\nfrom imp import load_source\nfrom ast import literal_eval\nfrom argparse import ArgumentParser\nfrom logging import getLogger, NullHandler\nfrom os.path import splitext, basename\n\nfrom six import PY2\nfrom six.moves import input\nfrom ptrace.tools import locateProgram\nfrom ptrace.debugger import ProcessSignal, NewProcessEvent, ProcessExecution, ProcessExit\nfrom ptrace.debugger.child import createChild\nfrom ptrace.debugger.debugger import PtraceDebugger\nfrom ptrace.func_call import FunctionCallOptions\nfrom ptrace.syscall import SYSCALL_REGISTER, RETURN_VALUE_REGISTER, DIRFD_ARGUMENTS\nfrom ptrace.syscall.posix_constants import SYSCALL_ARG_DICT\nfrom ptrace.syscall.syscall_argument import ARGUMENT_CALLBACK\n\nfrom . import SYSCALL_FILTERS, T, initialize_terminal\nfrom .process import Process\n# Filter modules are imported not to use them as symbols, but to execute their top-level code\nfrom .filters import (delete, move, change_permissions, change_owner,    # noqa\n                      create_directory, create_link, create_write_file)  # noqa\n\n\ndef parse_argument(argument):\n    # createText() uses repr() to render the argument,\n    # for which literal_eval() acts as an inverse function\n    # (see http://stackoverflow.com/a/24886425)\n    argument = literal_eval(argument.createText())\n    if PY2 and isinstance(argument, str):\n        argument = unicode(argument, sys.getfilesystemencoding())  # noqa\n    return argument\n\n\ndef get_operations(debugger, syscall_filters, verbose):\n    format_options = FunctionCallOptions(\n        replace_socketcall=False,\n        string_max_length=4096,\n    )\n\n    processes = {}\n    operations = []\n\n    while True:\n        if not debugger:\n            # All processes have exited\n            break\n\n        # This logic is mostly based on python-ptrace's \"strace\" example\n        try:\n            syscall_event = debugger.waitSyscall()\n        except ProcessSignal as event:\n            event.process.syscall(event.signum)\n            continue\n        except NewProcessEvent as event:\n            event.process.syscall()\n            event.process.parent.syscall()\n            continue\n        except ProcessExecution as event:\n            event.process.syscall()\n            continue\n        except ProcessExit as event:\n            continue\n\n        process = syscall_event.process\n        syscall_state = process.syscall_state\n\n        syscall = syscall_state.event(format_options)\n\n        if syscall and syscall_state.next_event == \"exit\":\n            # Syscall is about to be executed (just switched from \"enter\" to \"exit\")\n            if syscall.name in syscall_filters:\n                if verbose == 1:\n                    print(syscall.format())\n                elif verbose == 2:\n                    print(T.bold(syscall.format()))\n\n                filter_function = syscall_filters[syscall.name]\n                if process.pid not in processes:\n                    processes[process.pid] = Process(process)\n                arguments = [parse_argument(argument) for argument in syscall.arguments]\n\n                operation, return_value = filter_function(processes[process.pid], arguments)\n\n                if operation is not None:\n                    operations.append(operation)\n\n                if return_value is not None:\n                    # Set invalid syscall number to prevent call execution\n                    process.setreg(SYSCALL_REGISTER, -1)\n                    # Substitute return value to make syscall appear to have succeeded\n                    process.setreg(RETURN_VALUE_REGISTER, return_value)\n\n            elif verbose == 2:\n                print(syscall.format())\n\n        process.syscall()\n\n    return operations\n\n\ndef main(argv=sys.argv[1:]):\n    if PY2:\n        argv = [unicode(arg, sys.getfilesystemencoding()) for arg in argv]  # noqa\n\n    # Insert positional argument separator, if not already present\n    if \"--\" not in argv:\n        for i, argument in enumerate(argv):\n            if not argument.startswith(\"-\"):\n                argv.insert(i, \"--\")\n                break\n\n    arg_parser = ArgumentParser(\n        prog=\"maybe\",\n        usage=\"%(prog)s [options] command [argument ...]\",\n        description=\"Run a command without the ability to make changes to your system \" +\n                    \"and list the changes it would have made.\",\n        epilog=\"For more information, to report issues or to contribute, \" +\n               \"visit https://github.com/p-e-w/maybe.\",\n    )\n    arg_parser.add_argument(\"command\", nargs=\"+\", help=\"the command to run under maybe's control\")\n    arg_group = arg_parser.add_mutually_exclusive_group()\n    arg_group.add_argument(\"-a\", \"--allow\", nargs=\"+\", metavar=\"OPERATION\",\n                           help=\"allow the command to perform the specified operation(s). \" +\n                                \"all other operations will be denied. \" +\n                                \"possible values for %(metavar)s are: \" +\n                                \", \".join(sorted(SYSCALL_FILTERS.keys())) +\n                                \"; as well as any filter scopes defined by loaded plugins\")\n    arg_group.add_argument(\"-d\", \"--deny\", nargs=\"+\", metavar=\"OPERATION\",\n                           help=\"deny the command the specified operation(s). \" +\n                                \"all other operations will be allowed. \" +\n                                \"see --allow for a list of possible values for %(metavar)s. \" +\n                                \"--allow and --deny cannot be combined\")\n    arg_parser.add_argument(\"-p\", \"--plugin\", nargs=\"+\", metavar=\"FILE\",\n                            help=\"load the specified plugin script(s). \" +\n                                 \"see the README for details and plugin API documentation\")\n    arg_parser.add_argument(\"-l\", \"--list-only\", action=\"store_true\",\n                            help=\"list operations without header, indentation and rerun prompt\")\n    arg_parser.add_argument(\"--style-output\", choices=[\"yes\", \"no\", \"auto\"], default=\"auto\",\n                            help=\"colorize output using ANSI escape sequences (yes/no) \" +\n                                 \"or automatically decide based on whether stdout is a terminal (auto, default)\")\n    arg_parser.add_argument(\"-v\", \"--verbose\", action=\"count\",\n                            help=\"if specified once, print every filtered syscall. \" +\n                                 \"if specified twice, print every syscall, highlighting filtered syscalls\")\n    arg_parser.add_argument(\"--version\", action=\"version\", version=\"%(prog)s 0.4.0\")\n    args = arg_parser.parse_args(argv)\n\n    initialize_terminal(args.style_output)\n\n    if args.plugin is not None:\n        for plugin_path in args.plugin:\n            try:\n                module_name = splitext(basename(plugin_path))[0]\n                # Note: imp.load_source is *long* deprecated and not even documented\n                # in Python 3 anymore, but it still seems to work and the \"alternatives\"\n                # (see http://stackoverflow.com/a/67692) are simply too insane to use\n                load_source(module_name, plugin_path)\n            except Exception as error:\n                print(T.red(\"Error loading %s: %s.\" % (T.bold(plugin_path) + T.red, error)))\n                return 1\n\n    if args.allow is not None:\n        for filter_scope in args.allow:\n            if filter_scope not in SYSCALL_FILTERS:\n                print(T.red(\"Unknown operation in --allow: %s.\" % (T.bold(filter_scope) + T.red)))\n                return 1\n        filter_scopes = set(SYSCALL_FILTERS.keys()) - set(args.allow)\n    elif args.deny is not None:\n        for filter_scope in args.deny:\n            if filter_scope not in SYSCALL_FILTERS:\n                print(T.red(\"Unknown operation in --deny: %s.\" % (T.bold(filter_scope) + T.red)))\n                return 1\n        filter_scopes = args.deny\n    else:\n        filter_scopes = SYSCALL_FILTERS.keys()\n\n    syscall_filters = {}\n\n    for filter_scope in SYSCALL_FILTERS:\n        if filter_scope in filter_scopes:\n            for syscall in SYSCALL_FILTERS[filter_scope]:\n                syscall_filters[syscall] = SYSCALL_FILTERS[filter_scope][syscall]\n\n    # Suppress logging output from python-ptrace\n    getLogger().addHandler(NullHandler())\n\n    # Prevent python-ptrace from decoding arguments to keep raw numerical values\n    DIRFD_ARGUMENTS.clear()\n    SYSCALL_ARG_DICT.clear()\n    ARGUMENT_CALLBACK.clear()\n\n    # This is basically \"shlex.join\"\n    command = \" \".join([((\"'%s'\" % arg) if (\" \" in arg) else arg) for arg in args.command])\n\n    try:\n        args.command[0] = locateProgram(args.command[0])\n        pid = createChild(args.command, False)\n    except Exception as error:\n        print(T.red(\"Error executing %s: %s.\" % (T.bold(command) + T.red, error)))\n        return 1\n\n    debugger = PtraceDebugger()\n    debugger.traceFork()\n    debugger.traceExec()\n\n    process = debugger.addProcess(pid, True)\n    process.syscall()\n\n    try:\n        operations = get_operations(debugger, syscall_filters, args.verbose)\n    except Exception as error:\n        print(T.red(\"Error tracing process: %s.\" % error))\n        return 1\n    except KeyboardInterrupt:\n        print(T.yellow(\"%s terminated by keyboard interrupt.\" % (T.bold(command) + T.yellow)))\n        return 2\n    finally:\n        # Cut down all processes no matter what happens\n        # to prevent them from doing any damage\n        debugger.quit()\n\n    if operations:\n        if not args.list_only:\n            print(\"%s has prevented %s from performing %d file system operations:\\n\" %\n                  (T.bold(\"maybe\"), T.bold(command), len(operations)))\n        for operation in operations:\n            print((\"\" if args.list_only else \"  \") + operation)\n        if not args.list_only:\n            print(\"\\nDo you want to rerun %s and permit these operations? [y/N] \" % T.bold(command), end=\"\")\n            try:\n                choice = input()\n            except KeyboardInterrupt:\n                choice = \"\"\n                # Ctrl+C does not print a newline automatically\n                print(\"\")\n            if choice.lower() == \"y\":\n                subprocess.call(args.command)\n    else:\n        print(\"%s has not detected any file system operations from %s.\" %\n              (T.bold(\"maybe\"), T.bold(command)))\n", "description": " :open_file_folder: :rabbit2: :tophat: See what a program does before deciding whether you really want it to happen.", "file_name": "maybe.py", "id": "e84a5a1bd6dda52ebd074ded1744cd05", "language": "Python", "project_name": "maybe", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/p-e-w-maybe/p-e-w-maybe-ec58230/maybe/maybe.py", "save_time": "", "source": "", "update_at": "2018-03-16T19:18:43Z", "url": "https://github.com/p-e-w/maybe", "wiki": true}