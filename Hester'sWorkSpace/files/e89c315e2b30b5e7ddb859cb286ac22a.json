{"author": "sympy", "code": "from sympy import (Interval, Intersection, Set, EmptySet,\n        FiniteSet, Union, ComplexRegion, ProductSet)\nfrom sympy.sets.fancysets import Integers, Naturals, Reals, Range, ImageSet\nfrom sympy.sets.sets import UniversalSet, imageset\nfrom sympy.sets.conditionset import ConditionSet\nfrom sympy import S, sympify, Dummy, Lambda, symbols\nfrom sympy.multipledispatch import dispatch\n\n\n@dispatch(ConditionSet, ConditionSet)\ndef intersection_sets(a, b):\n    return None\n\n@dispatch(ConditionSet, Set)\ndef intersection_sets(a, b):\n    return ConditionSet(a.sym, a.condition, Intersection(a.base_set, b))\n\n@dispatch(Naturals, Interval)\ndef intersection_sets(a, b):\n    return Intersection(S.Integers, b, Interval(a._inf, S.Infinity))\n\n@dispatch(Interval, Naturals)\ndef intersection_sets(a, b):\n    return intersection_sets(b, a)\n\n@dispatch(Integers, Interval)\ndef intersection_sets(a, b):\n    from sympy.functions.elementary.integers import floor, ceiling\n    if b._inf == S.NegativeInfinity and b._sup == S.Infinity:\n        return a\n    s = Range(ceiling(b.left), floor(b.right) + 1)\n    return intersection_sets(s, b)  \n\n@dispatch(ComplexRegion, Set)\ndef intersection_sets(self, other):\n    if other.is_ComplexRegion:\n        \n        if (not self.polar) and (not other.polar):\n            return ComplexRegion(Intersection(self.sets, other.sets))\n\n        \n        elif self.polar and other.polar:\n            r1, theta1 = self.a_interval, self.b_interval\n            r2, theta2 = other.a_interval, other.b_interval\n            new_r_interval = Intersection(r1, r2)\n            new_theta_interval = Intersection(theta1, theta2)\n\n            # 0 and 2*Pi means the same\n            if ((2*S.Pi in theta1 and S.Zero in theta2) or\n               (2*S.Pi in theta2 and S.Zero in theta1)):\n                new_theta_interval = Union(new_theta_interval,\n                                           FiniteSet(0))\n            return ComplexRegion(new_r_interval*new_theta_interval,\n                                polar=True)\n\n\n    if other.is_subset(S.Reals):\n        new_interval = []\n        x = symbols(\"x\", cls=Dummy, real=True)\n\n        \n        if not self.polar:\n            for element in self.psets:\n                if S.Zero in element.args[1]:\n                    new_interval.append(element.args[0])\n            new_interval = Union(*new_interval)\n            return Intersection(new_interval, other)\n\n        \n        elif self.polar:\n            for element in self.psets:\n                if S.Zero in element.args[1]:\n                    new_interval.append(element.args[0])\n                if S.Pi in element.args[1]:\n                    new_interval.append(ImageSet(Lambda(x, -x), element.args[0]))\n                if S.Zero in element.args[0]:\n                    new_interval.append(FiniteSet(0))\n            new_interval = Union(*new_interval)\n            return Intersection(new_interval, other)\n\n@dispatch(Integers, Reals)\ndef intersection_sets(a, b):\n    return a\n\n@dispatch(Range, Interval)\ndef intersection_sets(a, b):\n    from sympy.functions.elementary.integers import floor, ceiling\n    from sympy.functions.elementary.miscellaneous import Min, Max\n    if not all(i.is_number for i in b.args[:2]):\n        return\n\n    \n    if a.size == 0:\n        return S.EmptySet\n\n    \n    \n    start = ceiling(max(b.inf, a.inf))\n    if start not in b:\n        start += 1\n    end = floor(min(b.sup, a.sup))\n    if end not in b:\n        end -= 1\n    return intersection_sets(a, Range(start, end + 1))\n\n@dispatch(Range, Naturals)\ndef intersection_sets(a, b):\n    return intersection_sets(a, Interval(1, S.Infinity))\n\n@dispatch(Naturals, Range)\ndef intersection_sets(a, b):\n    return intersection_sets(b, a)\n\n@dispatch(Range, Range)\ndef intersection_sets(a, b):\n    from sympy.solvers.diophantine import diop_linear\n    from sympy.core.numbers import ilcm\n    from sympy import sign\n\n    \n    if not b:\n        return S.EmptySet\n    if not a:\n        return S.EmptySet\n    if b.sup < a.inf:\n        return S.EmptySet\n    if b.inf > a.sup:\n        return S.EmptySet\n\n    \n    r1 = a\n    if r1.start.is_infinite:\n        r1 = r1.reversed\n    r2 = b\n    if r2.start.is_infinite:\n        r2 = r2.reversed\n\n    \n    \n    eq = lambda r, i: r.start + i*r.step\n\n    \n    \n    \n    va, vb = diop_linear(eq(r1, Dummy()) - eq(r2, Dummy()))\n\n    \n    no_solution = va is None and vb is None\n    if no_solution:\n        return S.EmptySet\n\n    \n    \n\n    \n    a0 = va.as_coeff_Add()[0]\n    c = eq(r1, a0)\n\n    \n    \n    def _first_finite_point(r1, c):\n        if c == r1.start:\n            return c\n        \n        \n        st = sign(r1.start - c)*step\n        \n        \n        \n        \n        s1 = Range(c, r1.start + st, st)[-1]\n        if s1 == r1.start:\n            pass\n        else:\n            \n            \n            \n            if sign(r1.step) != sign(st):\n                s1 -= st\n        if s1 not in r1:\n            return\n        return s1\n\n    \n    step = abs(ilcm(r1.step, r2.step))\n    s1 = _first_finite_point(r1, c)\n    if s1 is None:\n        return S.EmptySet\n    s2 = _first_finite_point(r2, c)\n    if s2 is None:\n        return S.EmptySet\n\n    \n    \n    \n    \n    def _updated_range(r, first):\n        st = sign(r.step)*step\n        if r.start.is_finite:\n            rv = Range(first, r.stop, st)\n        else:\n            rv = Range(r.start, first + st, st)\n        return rv\n    r1 = _updated_range(a, s1)\n    r2 = _updated_range(b, s2)\n\n    \n    if sign(r1.step) < 0:\n        r1 = r1.reversed\n    if sign(r2.step) < 0:\n        r2 = r2.reversed\n\n    \n    \n    start = max(r1.start, r2.start)\n    stop = min(r1.stop, r2.stop)\n    return Range(start, stop, step)\n\n\n@dispatch(Range, Integers)\ndef intersection_sets(a, b):\n    return a\n\n\n@dispatch(ImageSet, Set)\ndef intersection_sets(self, other):\n    from sympy.solvers.diophantine import diophantine\n    if self.base_set is S.Integers:\n        g = None\n        if isinstance(other, ImageSet) and other.base_set is S.Integers:\n            g = other.lamda.expr\n            m = other.lamda.variables[0]\n        elif other is S.Integers:\n            m = g = Dummy('x')\n        if g is not None:\n            f = self.lamda.expr\n            n = self.lamda.variables[0]\n            \n            \n            \n            \n            a, b = Dummy('a'), Dummy('b')\n            f, g = f.subs(n, a), g.subs(m, b)\n            solns_set = diophantine(f - g)\n            if solns_set == set():\n                return EmptySet()\n            solns = list(diophantine(f - g))\n\n            if len(solns) != 1:\n                return\n\n            \n            nsol = solns[0][0]\n            t = nsol.free_symbols.pop()\n            return imageset(Lambda(n, f.subs(a, nsol.subs(t, n))), S.Integers)\n\n    if other == S.Reals:\n        from sympy.solvers.solveset import solveset_real\n        from sympy.core.function import expand_complex\n        if len(self.lamda.variables) > 1:\n            return None\n\n        f = self.lamda.expr\n        n = self.lamda.variables[0]\n\n        n_ = Dummy(n.name, real=True)\n        f_ = f.subs(n, n_)\n\n        re, im = f_.as_real_imag()\n        im = expand_complex(im)\n\n        return imageset(Lambda(n_, re),\n                        self.base_set.intersect(\n                            solveset_real(im, n_)))\n\n    elif isinstance(other, Interval):\n        from sympy.solvers.solveset import (invert_real, invert_complex,\n                                            solveset)\n\n        f = self.lamda.expr\n        n = self.lamda.variables[0]\n        base_set = self.base_set\n        new_inf, new_sup = None, None\n        new_lopen, new_ropen = other.left_open, other.right_open\n\n        if f.is_real:\n            inverter = invert_real\n        else:\n            inverter = invert_complex\n\n        g1, h1 = inverter(f, other.inf, n)\n        g2, h2 = inverter(f, other.sup, n)\n\n        if all(isinstance(i, FiniteSet) for i in (h1, h2)):\n            if g1 == n:\n                if len(h1) == 1:\n                    new_inf = h1.args[0]\n            if g2 == n:\n                if len(h2) == 1:\n                    new_sup = h2.args[0]\n            \n            \n\n            \n            if any(i is None for i in (new_sup, new_inf)):\n                return\n\n\n            range_set = S.EmptySet\n\n            if all(i.is_real for i in (new_sup, new_inf)):\n                \n                \n                if new_inf > new_sup:\n                    new_inf, new_sup = new_sup, new_inf\n                new_interval = Interval(new_inf, new_sup, new_lopen, new_ropen)\n                range_set = base_set.intersect(new_interval)\n            else:\n                if other.is_subset(S.Reals):\n                    solutions = solveset(f, n, S.Reals)\n                    if not isinstance(range_set, (ImageSet, ConditionSet)):\n                        range_set = solutions.intersect(other)\n                    else:\n                        return\n\n            if range_set is S.EmptySet:\n                return S.EmptySet\n            elif isinstance(range_set, Range) and range_set.size is not S.Infinity:\n                range_set = FiniteSet(*list(range_set))\n\n            if range_set is not None:\n                return imageset(Lambda(n, f), range_set)\n            return\n        else:\n            return\n\n\n@dispatch(ProductSet, ProductSet)\ndef intersection_sets(a, b):\n    if len(b.args) != len(a.args):\n        return S.EmptySet\n    return ProductSet(i.intersect(j)\n            for i, j in zip(a.sets, b.sets))\n\n@dispatch(Interval, Interval)\ndef intersection_sets(a, b):\n    # handle (-oo, oo)\n    infty = S.NegativeInfinity, S.Infinity\n    if a == Interval(*infty):\n        l, r = a.left, a.right\n        if l.is_real or l in infty or r.is_real or r in infty:\n            return b\n\n    # We can't intersect [0,3] with [x,6] -- we don't know if x>0 or x<0\n    if not a._is_comparable(b):\n        return None\n\n    empty = False\n\n    if a.start <= b.end and b.start <= a.end:\n        \n        if a.start < b.start:\n            start = b.start\n            left_open = b.left_open\n        elif a.start > b.start:\n            start = a.start\n            left_open = a.left_open\n        else:\n            start = a.start\n            left_open = a.left_open or b.left_open\n\n        if a.end < b.end:\n            end = a.end\n            right_open = a.right_open\n        elif a.end > b.end:\n            end = b.end\n            right_open = b.right_open\n        else:\n            end = a.end\n            right_open = a.right_open or b.right_open\n\n        if end - start == 0 and (left_open or right_open):\n            empty = True\n    else:\n        empty = True\n\n    if empty:\n        return S.EmptySet\n\n    return Interval(start, end, left_open, right_open)\n\n@dispatch(EmptySet, Set)\ndef intersection_sets(a, b):\n    return S.EmptySet\n\n@dispatch(UniversalSet, Set)\ndef intersection_sets(a, b):\n    return b\n\n@dispatch(FiniteSet, FiniteSet)\ndef intersection_sets(a, b):\n    return FiniteSet(*(a._elements & b._elements))\n\n@dispatch(FiniteSet, Set)\ndef intersection_sets(a, b):\n    try:\n        return FiniteSet(*[el for el in a if el in b])\n    except TypeError:\n        return None  \n\n@dispatch(Set, Set)\ndef intersection_sets(a, b):\n    return None\n", "comments": "  take endpoints open interval    self rectangular form    self polar form    0 2 pi means    self rectangular form    self polar form    in case null range  return emptyset     trim self size  represent    range step 1     non overlap quick exits    work finite end start    equation represents values range     linear equation    want know two equations might    integer solutions use diophantine    solver    check solution    solution                           find coincident point  c    find first point  possible  range    since c may point    st signed step need take    get c r1 start    use range calculate first point     want get close possible    r1 start  range null since    least contain c    hit r1 start     sign st match sign r1 step    one s1 r1    calculate step size new range    replace corresponding start stop    original ranges points     result must least one point since    know s1 s2 ranges    work increasing direction    return clipped range positive step     empty point    diophantine sorts solutions according alphabetic    order variable names  since result depend    variable name  replaced dummy variables       since      b   select soln n    todo  design technique handle multiple inverse    functions    any new boundary values cannot determined    assumes continuity underlying function    however fixes case decreasing    handle ( oo  oo)    we intersect  0 3   x 6     know x 0 x 0    get topology right     could evaluate  el b  due symbolic ranges  ", "content": "from sympy import (Interval, Intersection, Set, EmptySet,\n        FiniteSet, Union, ComplexRegion, ProductSet)\nfrom sympy.sets.fancysets import Integers, Naturals, Reals, Range, ImageSet\nfrom sympy.sets.sets import UniversalSet, imageset\nfrom sympy.sets.conditionset import ConditionSet\nfrom sympy import S, sympify, Dummy, Lambda, symbols\nfrom sympy.multipledispatch import dispatch\n\n\n@dispatch(ConditionSet, ConditionSet)\ndef intersection_sets(a, b):\n    return None\n\n@dispatch(ConditionSet, Set)\ndef intersection_sets(a, b):\n    return ConditionSet(a.sym, a.condition, Intersection(a.base_set, b))\n\n@dispatch(Naturals, Interval)\ndef intersection_sets(a, b):\n    return Intersection(S.Integers, b, Interval(a._inf, S.Infinity))\n\n@dispatch(Interval, Naturals)\ndef intersection_sets(a, b):\n    return intersection_sets(b, a)\n\n@dispatch(Integers, Interval)\ndef intersection_sets(a, b):\n    from sympy.functions.elementary.integers import floor, ceiling\n    if b._inf == S.NegativeInfinity and b._sup == S.Infinity:\n        return a\n    s = Range(ceiling(b.left), floor(b.right) + 1)\n    return intersection_sets(s, b)  # take out endpoints if open interval\n\n@dispatch(ComplexRegion, Set)\ndef intersection_sets(self, other):\n    if other.is_ComplexRegion:\n        # self in rectangular form\n        if (not self.polar) and (not other.polar):\n            return ComplexRegion(Intersection(self.sets, other.sets))\n\n        # self in polar form\n        elif self.polar and other.polar:\n            r1, theta1 = self.a_interval, self.b_interval\n            r2, theta2 = other.a_interval, other.b_interval\n            new_r_interval = Intersection(r1, r2)\n            new_theta_interval = Intersection(theta1, theta2)\n\n            # 0 and 2*Pi means the same\n            if ((2*S.Pi in theta1 and S.Zero in theta2) or\n               (2*S.Pi in theta2 and S.Zero in theta1)):\n                new_theta_interval = Union(new_theta_interval,\n                                           FiniteSet(0))\n            return ComplexRegion(new_r_interval*new_theta_interval,\n                                polar=True)\n\n\n    if other.is_subset(S.Reals):\n        new_interval = []\n        x = symbols(\"x\", cls=Dummy, real=True)\n\n        # self in rectangular form\n        if not self.polar:\n            for element in self.psets:\n                if S.Zero in element.args[1]:\n                    new_interval.append(element.args[0])\n            new_interval = Union(*new_interval)\n            return Intersection(new_interval, other)\n\n        # self in polar form\n        elif self.polar:\n            for element in self.psets:\n                if S.Zero in element.args[1]:\n                    new_interval.append(element.args[0])\n                if S.Pi in element.args[1]:\n                    new_interval.append(ImageSet(Lambda(x, -x), element.args[0]))\n                if S.Zero in element.args[0]:\n                    new_interval.append(FiniteSet(0))\n            new_interval = Union(*new_interval)\n            return Intersection(new_interval, other)\n\n@dispatch(Integers, Reals)\ndef intersection_sets(a, b):\n    return a\n\n@dispatch(Range, Interval)\ndef intersection_sets(a, b):\n    from sympy.functions.elementary.integers import floor, ceiling\n    from sympy.functions.elementary.miscellaneous import Min, Max\n    if not all(i.is_number for i in b.args[:2]):\n        return\n\n    # In case of null Range, return an EmptySet.\n    if a.size == 0:\n        return S.EmptySet\n\n    # trim down to self's size, and represent\n    # as a Range with step 1.\n    start = ceiling(max(b.inf, a.inf))\n    if start not in b:\n        start += 1\n    end = floor(min(b.sup, a.sup))\n    if end not in b:\n        end -= 1\n    return intersection_sets(a, Range(start, end + 1))\n\n@dispatch(Range, Naturals)\ndef intersection_sets(a, b):\n    return intersection_sets(a, Interval(1, S.Infinity))\n\n@dispatch(Naturals, Range)\ndef intersection_sets(a, b):\n    return intersection_sets(b, a)\n\n@dispatch(Range, Range)\ndef intersection_sets(a, b):\n    from sympy.solvers.diophantine import diop_linear\n    from sympy.core.numbers import ilcm\n    from sympy import sign\n\n    # non-overlap quick exits\n    if not b:\n        return S.EmptySet\n    if not a:\n        return S.EmptySet\n    if b.sup < a.inf:\n        return S.EmptySet\n    if b.inf > a.sup:\n        return S.EmptySet\n\n    # work with finite end at the start\n    r1 = a\n    if r1.start.is_infinite:\n        r1 = r1.reversed\n    r2 = b\n    if r2.start.is_infinite:\n        r2 = r2.reversed\n\n    # this equation represents the values of the Range;\n    # it's a linear equation\n    eq = lambda r, i: r.start + i*r.step\n\n    # we want to know when the two equations might\n    # have integer solutions so we use the diophantine\n    # solver\n    va, vb = diop_linear(eq(r1, Dummy()) - eq(r2, Dummy()))\n\n    # check for no solution\n    no_solution = va is None and vb is None\n    if no_solution:\n        return S.EmptySet\n\n    # there is a solution\n    # -------------------\n\n    # find the coincident point, c\n    a0 = va.as_coeff_Add()[0]\n    c = eq(r1, a0)\n\n    # find the first point, if possible, in each range\n    # since c may not be that point\n    def _first_finite_point(r1, c):\n        if c == r1.start:\n            return c\n        # st is the signed step we need to take to\n        # get from c to r1.start\n        st = sign(r1.start - c)*step\n        # use Range to calculate the first point:\n        # we want to get as close as possible to\n        # r1.start; the Range will not be null since\n        # it will at least contain c\n        s1 = Range(c, r1.start + st, st)[-1]\n        if s1 == r1.start:\n            pass\n        else:\n            # if we didn't hit r1.start then, if the\n            # sign of st didn't match the sign of r1.step\n            # we are off by one and s1 is not in r1\n            if sign(r1.step) != sign(st):\n                s1 -= st\n        if s1 not in r1:\n            return\n        return s1\n\n    # calculate the step size of the new Range\n    step = abs(ilcm(r1.step, r2.step))\n    s1 = _first_finite_point(r1, c)\n    if s1 is None:\n        return S.EmptySet\n    s2 = _first_finite_point(r2, c)\n    if s2 is None:\n        return S.EmptySet\n\n    # replace the corresponding start or stop in\n    # the original Ranges with these points; the\n    # result must have at least one point since\n    # we know that s1 and s2 are in the Ranges\n    def _updated_range(r, first):\n        st = sign(r.step)*step\n        if r.start.is_finite:\n            rv = Range(first, r.stop, st)\n        else:\n            rv = Range(r.start, first + st, st)\n        return rv\n    r1 = _updated_range(a, s1)\n    r2 = _updated_range(b, s2)\n\n    # work with them both in the increasing direction\n    if sign(r1.step) < 0:\n        r1 = r1.reversed\n    if sign(r2.step) < 0:\n        r2 = r2.reversed\n\n    # return clipped Range with positive step; it\n    # can't be empty at this point\n    start = max(r1.start, r2.start)\n    stop = min(r1.stop, r2.stop)\n    return Range(start, stop, step)\n\n\n@dispatch(Range, Integers)\ndef intersection_sets(a, b):\n    return a\n\n\n@dispatch(ImageSet, Set)\ndef intersection_sets(self, other):\n    from sympy.solvers.diophantine import diophantine\n    if self.base_set is S.Integers:\n        g = None\n        if isinstance(other, ImageSet) and other.base_set is S.Integers:\n            g = other.lamda.expr\n            m = other.lamda.variables[0]\n        elif other is S.Integers:\n            m = g = Dummy('x')\n        if g is not None:\n            f = self.lamda.expr\n            n = self.lamda.variables[0]\n            # Diophantine sorts the solutions according to the alphabetic\n            # order of the variable names, since the result should not depend\n            # on the variable name, they are replaced by the dummy variables\n            # below\n            a, b = Dummy('a'), Dummy('b')\n            f, g = f.subs(n, a), g.subs(m, b)\n            solns_set = diophantine(f - g)\n            if solns_set == set():\n                return EmptySet()\n            solns = list(diophantine(f - g))\n\n            if len(solns) != 1:\n                return\n\n            # since 'a' < 'b', select soln for n\n            nsol = solns[0][0]\n            t = nsol.free_symbols.pop()\n            return imageset(Lambda(n, f.subs(a, nsol.subs(t, n))), S.Integers)\n\n    if other == S.Reals:\n        from sympy.solvers.solveset import solveset_real\n        from sympy.core.function import expand_complex\n        if len(self.lamda.variables) > 1:\n            return None\n\n        f = self.lamda.expr\n        n = self.lamda.variables[0]\n\n        n_ = Dummy(n.name, real=True)\n        f_ = f.subs(n, n_)\n\n        re, im = f_.as_real_imag()\n        im = expand_complex(im)\n\n        return imageset(Lambda(n_, re),\n                        self.base_set.intersect(\n                            solveset_real(im, n_)))\n\n    elif isinstance(other, Interval):\n        from sympy.solvers.solveset import (invert_real, invert_complex,\n                                            solveset)\n\n        f = self.lamda.expr\n        n = self.lamda.variables[0]\n        base_set = self.base_set\n        new_inf, new_sup = None, None\n        new_lopen, new_ropen = other.left_open, other.right_open\n\n        if f.is_real:\n            inverter = invert_real\n        else:\n            inverter = invert_complex\n\n        g1, h1 = inverter(f, other.inf, n)\n        g2, h2 = inverter(f, other.sup, n)\n\n        if all(isinstance(i, FiniteSet) for i in (h1, h2)):\n            if g1 == n:\n                if len(h1) == 1:\n                    new_inf = h1.args[0]\n            if g2 == n:\n                if len(h2) == 1:\n                    new_sup = h2.args[0]\n            # TODO: Design a technique to handle multiple-inverse\n            # functions\n\n            # Any of the new boundary values cannot be determined\n            if any(i is None for i in (new_sup, new_inf)):\n                return\n\n\n            range_set = S.EmptySet\n\n            if all(i.is_real for i in (new_sup, new_inf)):\n                # this assumes continuity of underlying function\n                # however fixes the case when it is decreasing\n                if new_inf > new_sup:\n                    new_inf, new_sup = new_sup, new_inf\n                new_interval = Interval(new_inf, new_sup, new_lopen, new_ropen)\n                range_set = base_set.intersect(new_interval)\n            else:\n                if other.is_subset(S.Reals):\n                    solutions = solveset(f, n, S.Reals)\n                    if not isinstance(range_set, (ImageSet, ConditionSet)):\n                        range_set = solutions.intersect(other)\n                    else:\n                        return\n\n            if range_set is S.EmptySet:\n                return S.EmptySet\n            elif isinstance(range_set, Range) and range_set.size is not S.Infinity:\n                range_set = FiniteSet(*list(range_set))\n\n            if range_set is not None:\n                return imageset(Lambda(n, f), range_set)\n            return\n        else:\n            return\n\n\n@dispatch(ProductSet, ProductSet)\ndef intersection_sets(a, b):\n    if len(b.args) != len(a.args):\n        return S.EmptySet\n    return ProductSet(i.intersect(j)\n            for i, j in zip(a.sets, b.sets))\n\n@dispatch(Interval, Interval)\ndef intersection_sets(a, b):\n    # handle (-oo, oo)\n    infty = S.NegativeInfinity, S.Infinity\n    if a == Interval(*infty):\n        l, r = a.left, a.right\n        if l.is_real or l in infty or r.is_real or r in infty:\n            return b\n\n    # We can't intersect [0,3] with [x,6] -- we don't know if x>0 or x<0\n    if not a._is_comparable(b):\n        return None\n\n    empty = False\n\n    if a.start <= b.end and b.start <= a.end:\n        # Get topology right.\n        if a.start < b.start:\n            start = b.start\n            left_open = b.left_open\n        elif a.start > b.start:\n            start = a.start\n            left_open = a.left_open\n        else:\n            start = a.start\n            left_open = a.left_open or b.left_open\n\n        if a.end < b.end:\n            end = a.end\n            right_open = a.right_open\n        elif a.end > b.end:\n            end = b.end\n            right_open = b.right_open\n        else:\n            end = a.end\n            right_open = a.right_open or b.right_open\n\n        if end - start == 0 and (left_open or right_open):\n            empty = True\n    else:\n        empty = True\n\n    if empty:\n        return S.EmptySet\n\n    return Interval(start, end, left_open, right_open)\n\n@dispatch(EmptySet, Set)\ndef intersection_sets(a, b):\n    return S.EmptySet\n\n@dispatch(UniversalSet, Set)\ndef intersection_sets(a, b):\n    return b\n\n@dispatch(FiniteSet, FiniteSet)\ndef intersection_sets(a, b):\n    return FiniteSet(*(a._elements & b._elements))\n\n@dispatch(FiniteSet, Set)\ndef intersection_sets(a, b):\n    try:\n        return FiniteSet(*[el for el in a if el in b])\n    except TypeError:\n        return None  # could not evaluate `el in b` due to symbolic ranges.\n\n@dispatch(Set, Set)\ndef intersection_sets(a, b):\n    return None\n", "description": "A computer algebra system written in pure Python", "file_name": "intersection.py", "id": "e89c315e2b30b5e7ddb859cb286ac22a", "language": "Python", "project_name": "sympy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/sympy-sympy/sympy-sympy-205da79/sympy/sets/handlers/intersection.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:35:56Z", "url": "https://github.com/sympy/sympy", "wiki": true}