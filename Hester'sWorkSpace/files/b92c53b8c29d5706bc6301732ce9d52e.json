{"author": "scikit-learn", "code": "from itertools import product\n\nimport numpy as np\nfrom numpy.testing import assert_almost_equal, assert_array_almost_equal\nfrom scipy import linalg\n\nfrom sklearn import neighbors, manifold\nfrom sklearn.manifold.locally_linear import barycenter_kneighbors_graph\nfrom sklearn.utils.testing import assert_less\nfrom sklearn.utils.testing import ignore_warnings\nfrom sklearn.utils.testing import assert_raise_message\nfrom sklearn.utils.testing import assert_raises\nfrom sklearn.utils.testing import assert_true\n\neigen_solvers = ['dense', 'arpack']\n\n\n\n\ndef test_barycenter_kneighbors_graph():\n    X = np.array([[0, 1], [1.01, 1.], [2, 0]])\n\n    A = barycenter_kneighbors_graph(X, 1)\n    assert_array_almost_equal(\n        A.toarray(),\n        [[0.,  1.,  0.],\n         [1.,  0.,  0.],\n         [0.,  1.,  0.]])\n\n    A = barycenter_kneighbors_graph(X, 2)\n    \n    assert_array_almost_equal(np.sum(A.toarray(), 1), np.ones(3))\n    pred = np.dot(A.toarray(), X)\n    assert_less(linalg.norm(pred - X) / X.shape[0], 1)\n\n\n\n\n\ndef test_lle_simple_grid():\n    \n    \n    rng = np.random.RandomState(2)\n\n    \n    X = np.array(list(product(range(5), repeat=2)))\n    X = X + 1e-10 * rng.uniform(size=X.shape)\n    n_components = 2\n    clf = manifold.LocallyLinearEmbedding(n_neighbors=5,\n                                          n_components=n_components,\n                                          random_state=rng)\n    tol = 0.1\n\n    N = barycenter_kneighbors_graph(X, clf.n_neighbors).toarray()\n    reconstruction_error = linalg.norm(np.dot(N, X) - X, 'fro')\n    assert_less(reconstruction_error, tol)\n\n    for solver in eigen_solvers:\n        clf.set_params(eigen_solver=solver)\n        clf.fit(X)\n        assert_true(clf.embedding_.shape[1] == n_components)\n        reconstruction_error = linalg.norm(\n            np.dot(N, clf.embedding_) - clf.embedding_, 'fro') ** 2\n\n        assert_less(reconstruction_error, tol)\n        assert_almost_equal(clf.reconstruction_error_,\n                            reconstruction_error, decimal=1)\n\n    \n    noise = rng.randn(*X.shape) / 100\n    X_reembedded = clf.transform(X + noise)\n    assert_less(linalg.norm(X_reembedded - clf.embedding_), tol)\n\n\ndef test_lle_manifold():\n    rng = np.random.RandomState(0)\n    \n    X = np.array(list(product(np.arange(18), repeat=2)))\n    X = np.c_[X, X[:, 0] ** 2 / 18]\n    X = X + 1e-10 * rng.uniform(size=X.shape)\n    n_components = 2\n    for method in [\"standard\", \"hessian\", \"modified\", \"ltsa\"]:\n        clf = manifold.LocallyLinearEmbedding(n_neighbors=6,\n                                              n_components=n_components,\n                                              method=method, random_state=0)\n        tol = 1.5 if method == \"standard\" else 3\n\n        N = barycenter_kneighbors_graph(X, clf.n_neighbors).toarray()\n        reconstruction_error = linalg.norm(np.dot(N, X) - X)\n        assert_less(reconstruction_error, tol)\n\n        for solver in eigen_solvers:\n            clf.set_params(eigen_solver=solver)\n            clf.fit(X)\n            assert_true(clf.embedding_.shape[1] == n_components)\n            reconstruction_error = linalg.norm(\n                np.dot(N, clf.embedding_) - clf.embedding_, 'fro') ** 2\n            details = (\"solver: %s, method: %s\" % (solver, method))\n            assert_less(reconstruction_error, tol, msg=details)\n            assert_less(np.abs(clf.reconstruction_error_ -\n                               reconstruction_error),\n                        tol * reconstruction_error, msg=details)\n\n\n\ndef test_lle_init_parameters():\n    X = np.random.rand(5, 3)\n\n    clf = manifold.LocallyLinearEmbedding(eigen_solver=\"error\")\n    msg = \"unrecognized eigen_solver 'error'\"\n    assert_raise_message(ValueError, msg, clf.fit, X)\n\n    clf = manifold.LocallyLinearEmbedding(method=\"error\")\n    msg = \"unrecognized method 'error'\"\n    assert_raise_message(ValueError, msg, clf.fit, X)\n\n\ndef test_pipeline():\n    \n    \n    \n    from sklearn import pipeline, datasets\n    X, y = datasets.make_blobs(random_state=0)\n    clf = pipeline.Pipeline(\n        [('filter', manifold.LocallyLinearEmbedding(random_state=0)),\n         ('clf', neighbors.KNeighborsClassifier())])\n    clf.fit(X, y)\n    assert_less(.9, clf.score(X, y))\n\n\n\ndef test_singular_matrix():\n    M = np.ones((10, 3))\n    f = ignore_warnings\n    assert_raises(ValueError, f(manifold.locally_linear_embedding),\n                  M, 2, 1, method='standard', eigen_solver='arpack')\n\n\n\ndef test_integer_input():\n    rand = np.random.RandomState(0)\n    X = rand.randint(0, 100, size=(20, 3))\n\n    for method in [\"standard\", \"hessian\", \"modified\", \"ltsa\"]:\n        clf = manifold.LocallyLinearEmbedding(method=method, n_neighbors=10)\n        clf.fit(X)  \n", "comments": "                                                                            test utility routines    check columns sum one                                                                              test lle computing reconstruction error manifolds     note  arpack numerically unstable  test fail          random seeds   we choose 2 tests pass     grid equidistant points 2d  n components   n dim    embed noisy version x using transform method    similar test slightly complex manifold    test error raised parameter passed lle invalid    check locallylinearembedding works fine pipeline    checks error raised     todo check actually something useful    test error raised weight matrix singular    regression test  6033    previously raised typeerror ", "content": "from itertools import product\n\nimport numpy as np\nfrom numpy.testing import assert_almost_equal, assert_array_almost_equal\nfrom scipy import linalg\n\nfrom sklearn import neighbors, manifold\nfrom sklearn.manifold.locally_linear import barycenter_kneighbors_graph\nfrom sklearn.utils.testing import assert_less\nfrom sklearn.utils.testing import ignore_warnings\nfrom sklearn.utils.testing import assert_raise_message\nfrom sklearn.utils.testing import assert_raises\nfrom sklearn.utils.testing import assert_true\n\neigen_solvers = ['dense', 'arpack']\n\n\n# ----------------------------------------------------------------------\n# Test utility routines\ndef test_barycenter_kneighbors_graph():\n    X = np.array([[0, 1], [1.01, 1.], [2, 0]])\n\n    A = barycenter_kneighbors_graph(X, 1)\n    assert_array_almost_equal(\n        A.toarray(),\n        [[0.,  1.,  0.],\n         [1.,  0.,  0.],\n         [0.,  1.,  0.]])\n\n    A = barycenter_kneighbors_graph(X, 2)\n    # check that columns sum to one\n    assert_array_almost_equal(np.sum(A.toarray(), 1), np.ones(3))\n    pred = np.dot(A.toarray(), X)\n    assert_less(linalg.norm(pred - X) / X.shape[0], 1)\n\n\n# ----------------------------------------------------------------------\n# Test LLE by computing the reconstruction error on some manifolds.\n\ndef test_lle_simple_grid():\n    # note: ARPACK is numerically unstable, so this test will fail for\n    #       some random seeds.  We choose 2 because the tests pass.\n    rng = np.random.RandomState(2)\n\n    # grid of equidistant points in 2D, n_components = n_dim\n    X = np.array(list(product(range(5), repeat=2)))\n    X = X + 1e-10 * rng.uniform(size=X.shape)\n    n_components = 2\n    clf = manifold.LocallyLinearEmbedding(n_neighbors=5,\n                                          n_components=n_components,\n                                          random_state=rng)\n    tol = 0.1\n\n    N = barycenter_kneighbors_graph(X, clf.n_neighbors).toarray()\n    reconstruction_error = linalg.norm(np.dot(N, X) - X, 'fro')\n    assert_less(reconstruction_error, tol)\n\n    for solver in eigen_solvers:\n        clf.set_params(eigen_solver=solver)\n        clf.fit(X)\n        assert_true(clf.embedding_.shape[1] == n_components)\n        reconstruction_error = linalg.norm(\n            np.dot(N, clf.embedding_) - clf.embedding_, 'fro') ** 2\n\n        assert_less(reconstruction_error, tol)\n        assert_almost_equal(clf.reconstruction_error_,\n                            reconstruction_error, decimal=1)\n\n    # re-embed a noisy version of X using the transform method\n    noise = rng.randn(*X.shape) / 100\n    X_reembedded = clf.transform(X + noise)\n    assert_less(linalg.norm(X_reembedded - clf.embedding_), tol)\n\n\ndef test_lle_manifold():\n    rng = np.random.RandomState(0)\n    # similar test on a slightly more complex manifold\n    X = np.array(list(product(np.arange(18), repeat=2)))\n    X = np.c_[X, X[:, 0] ** 2 / 18]\n    X = X + 1e-10 * rng.uniform(size=X.shape)\n    n_components = 2\n    for method in [\"standard\", \"hessian\", \"modified\", \"ltsa\"]:\n        clf = manifold.LocallyLinearEmbedding(n_neighbors=6,\n                                              n_components=n_components,\n                                              method=method, random_state=0)\n        tol = 1.5 if method == \"standard\" else 3\n\n        N = barycenter_kneighbors_graph(X, clf.n_neighbors).toarray()\n        reconstruction_error = linalg.norm(np.dot(N, X) - X)\n        assert_less(reconstruction_error, tol)\n\n        for solver in eigen_solvers:\n            clf.set_params(eigen_solver=solver)\n            clf.fit(X)\n            assert_true(clf.embedding_.shape[1] == n_components)\n            reconstruction_error = linalg.norm(\n                np.dot(N, clf.embedding_) - clf.embedding_, 'fro') ** 2\n            details = (\"solver: %s, method: %s\" % (solver, method))\n            assert_less(reconstruction_error, tol, msg=details)\n            assert_less(np.abs(clf.reconstruction_error_ -\n                               reconstruction_error),\n                        tol * reconstruction_error, msg=details)\n\n\n# Test the error raised when parameter passed to lle is invalid\ndef test_lle_init_parameters():\n    X = np.random.rand(5, 3)\n\n    clf = manifold.LocallyLinearEmbedding(eigen_solver=\"error\")\n    msg = \"unrecognized eigen_solver 'error'\"\n    assert_raise_message(ValueError, msg, clf.fit, X)\n\n    clf = manifold.LocallyLinearEmbedding(method=\"error\")\n    msg = \"unrecognized method 'error'\"\n    assert_raise_message(ValueError, msg, clf.fit, X)\n\n\ndef test_pipeline():\n    # check that LocallyLinearEmbedding works fine as a Pipeline\n    # only checks that no error is raised.\n    # TODO check that it actually does something useful\n    from sklearn import pipeline, datasets\n    X, y = datasets.make_blobs(random_state=0)\n    clf = pipeline.Pipeline(\n        [('filter', manifold.LocallyLinearEmbedding(random_state=0)),\n         ('clf', neighbors.KNeighborsClassifier())])\n    clf.fit(X, y)\n    assert_less(.9, clf.score(X, y))\n\n\n# Test the error raised when the weight matrix is singular\ndef test_singular_matrix():\n    M = np.ones((10, 3))\n    f = ignore_warnings\n    assert_raises(ValueError, f(manifold.locally_linear_embedding),\n                  M, 2, 1, method='standard', eigen_solver='arpack')\n\n\n# regression test for #6033\ndef test_integer_input():\n    rand = np.random.RandomState(0)\n    X = rand.randint(0, 100, size=(20, 3))\n\n    for method in [\"standard\", \"hessian\", \"modified\", \"ltsa\"]:\n        clf = manifold.LocallyLinearEmbedding(method=method, n_neighbors=10)\n        clf.fit(X)  # this previously raised a TypeError\n", "description": "scikit-learn: machine learning in Python", "file_name": "test_locally_linear.py", "id": "b92c53b8c29d5706bc6301732ce9d52e", "language": "Python", "project_name": "scikit-learn", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/scikit-learn-scikit-learn/scikit-learn-scikit-learn-94ed5a8/sklearn/manifold/tests/test_locally_linear.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:58:59Z", "url": "https://github.com/scikit-learn/scikit-learn", "wiki": true}