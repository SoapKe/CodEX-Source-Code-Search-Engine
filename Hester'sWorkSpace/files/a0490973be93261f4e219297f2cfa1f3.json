{"author": "nvbn", "code": "\n\nimport pytest\nimport warnings\nfrom mock import Mock\nfrom thefuck.utils import default_settings, \\\n    memoize, get_closest, get_all_executables, replace_argument, \\\n    get_all_matched_commands, is_app, for_app, cache, \\\n    get_valid_history_without_current, _cache\nfrom thefuck.types import Command\n\n\n@pytest.mark.parametrize('override, old, new', [\n    ({'key': 'val'}, {}, {'key': 'val'}),\n    ({'key': 'new-val'}, {'key': 'val'}, {'key': 'val'}),\n    ({'key': 'new-val', 'unset': 'unset'}, {'key': 'val'}, {'key': 'val', 'unset': 'unset'})])\ndef test_default_settings(settings, override, old, new):\n    settings.clear()\n    settings.update(old)\n    default_settings(override)(lambda _: _)(None)\n    assert settings == new\n\n\ndef test_memoize():\n    fn = Mock(__name__='fn')\n    memoized = memoize(fn)\n    memoized()\n    memoized()\n    fn.assert_called_once_with()\n\n\n@pytest.mark.usefixtures('no_memoize')\ndef test_no_memoize():\n    fn = Mock(__name__='fn')\n    memoized = memoize(fn)\n    memoized()\n    memoized()\n    assert fn.call_count == 2\n\n\nclass TestGetClosest(object):\n    def test_when_can_match(self):\n        assert 'branch' == get_closest('brnch', ['branch', 'status'])\n\n    def test_when_cant_match(self):\n        assert 'status' == get_closest('st', ['status', 'reset'])\n\n    def test_without_fallback(self):\n        assert get_closest('st', ['status', 'reset'],\n                           fallback_to_first=False) is None\n\n\n@pytest.fixture\ndef get_aliases(mocker):\n    mocker.patch('thefuck.shells.shell.get_aliases',\n                 return_value=['vim', 'apt-get', 'fsck', 'fuck'])\n\n\n@pytest.mark.usefixtures('no_memoize', 'get_aliases')\ndef test_get_all_executables():\n    all_callables = get_all_executables()\n    assert 'vim' in all_callables\n    assert 'fsck' in all_callables\n    assert 'fuck' not in all_callables\n\n\n@pytest.mark.parametrize('args, result', [\n    (('apt-get instol vim', 'instol', 'install'), 'apt-get install vim'),\n    (('git brnch', 'brnch', 'branch'), 'git branch')])\ndef test_replace_argument(args, result):\n    assert replace_argument(*args) == result\n\n\n@pytest.mark.parametrize('stderr, result', [\n    ((\"git: 'cone' is not a git command. See 'git --help'.\\n\"\n      '\\n'\n      'Did you mean one of these?\\n'\n      '\\tclone'), ['clone']),\n    ((\"git: 're' is not a git command. See 'git --help'.\\n\"\n      '\\n'\n      'Did you mean one of these?\\n'\n      '\\trebase\\n'\n      '\\treset\\n'\n      '\\tgrep\\n'\n      '\\trm'), ['rebase', 'reset', 'grep', 'rm']),\n    (('tsuru: \"target\" is not a tsuru command. See \"tsuru help\".\\n'\n      '\\n'\n      'Did you mean one of these?\\n'\n      '\\tservice-add\\n'\n      '\\tservice-bind\\n'\n      '\\tservice-doc\\n'\n      '\\tservice-info\\n'\n      '\\tservice-list\\n'\n      '\\tservice-remove\\n'\n      '\\tservice-status\\n'\n      '\\tservice-unbind'), ['service-add', 'service-bind', 'service-doc',\n                            'service-info', 'service-list', 'service-remove',\n                            'service-status', 'service-unbind'])])\ndef test_get_all_matched_commands(stderr, result):\n    assert list(get_all_matched_commands(stderr)) == result\n\n\n@pytest.mark.usefixtures('no_memoize')\n@pytest.mark.parametrize('script, names, result', [\n    ('git diff', ['git', 'hub'], True),\n    ('hub diff', ['git', 'hub'], True),\n    ('hg diff', ['git', 'hub'], False)])\ndef test_is_app(script, names, result):\n    assert is_app(Command(script, ''), *names) == result\n\n\n@pytest.mark.usefixtures('no_memoize')\n@pytest.mark.parametrize('script, names, result', [\n    ('git diff', ['git', 'hub'], True),\n    ('hub diff', ['git', 'hub'], True),\n    ('hg diff', ['git', 'hub'], False)])\ndef test_for_app(script, names, result):\n    @for_app(*names)\n    def match(command):\n        return True\n\n    assert match(Command(script, '')) == result\n\n\nclass TestCache(object):\n    @pytest.fixture\n    def shelve(self, mocker):\n        value = {}\n\n        class _Shelve(object):\n            def __init__(self, path):\n                pass\n\n            def __setitem__(self, k, v):\n                value[k] = v\n\n            def __getitem__(self, k):\n                return value[k]\n\n            def get(self, k, v=None):\n                return value.get(k, v)\n\n            def close(self):\n                return\n\n        mocker.patch('thefuck.utils.shelve.open', new_callable=lambda: _Shelve)\n        return value\n\n    @pytest.fixture(autouse=True)\n    def enable_cache(self, monkeypatch, shelve):\n        monkeypatch.setattr('thefuck.utils.cache.disabled', False)\n        _cache._init_db()\n\n    @pytest.fixture(autouse=True)\n    def mtime(self, mocker):\n        mocker.patch('thefuck.utils.os.path.getmtime', return_value=0)\n\n    @pytest.fixture\n    def fn(self):\n        @cache('~/.bashrc')\n        def fn():\n            return 'test'\n\n        return fn\n\n    @pytest.fixture\n    def key(self, monkeypatch):\n        monkeypatch.setattr('thefuck.utils.Cache._get_key',\n                            lambda *_: 'key')\n        return 'key'\n\n    def test_with_blank_cache(self, shelve, fn, key):\n        assert shelve == {}\n        assert fn() == 'test'\n        assert shelve == {key: {'etag': '0', 'value': 'test'}}\n\n    def test_with_filled_cache(self, shelve, fn, key):\n        cache_value = {key: {'etag': '0', 'value': 'new-value'}}\n        shelve.update(cache_value)\n        assert fn() == 'new-value'\n        assert shelve == cache_value\n\n    def test_when_etag_changed(self, shelve, fn, key):\n        shelve.update({key: {'etag': '-1', 'value': 'old-value'}})\n        assert fn() == 'test'\n        assert shelve == {key: {'etag': '0', 'value': 'test'}}\n\n\nclass TestGetValidHistoryWithoutCurrent(object):\n    @pytest.yield_fixture(autouse=True)\n    def fail_on_warning(self):\n        warnings.simplefilter('error')\n        yield\n        warnings.resetwarnings()\n\n    @pytest.fixture(autouse=True)\n    def history(self, mocker):\n        return mocker.patch('thefuck.shells.shell.get_history',\n                            return_value=['le cat', 'fuck', 'ls cat',\n                                          'diff x', 'nocommand x', u'caf\u00e9 \u00f4'])\n\n    @pytest.fixture(autouse=True)\n    def alias(self, mocker):\n        return mocker.patch('thefuck.utils.get_alias',\n                            return_value='fuck')\n\n    @pytest.fixture(autouse=True)\n    def bins(self, mocker):\n        callables = list()\n        for name in ['diff', 'ls', 'caf\u00e9']:\n            bin_mock = mocker.Mock(name=name)\n            bin_mock.configure_mock(name=name, is_dir=lambda: False)\n            callables.append(bin_mock)\n        path_mock = mocker.Mock(iterdir=mocker.Mock(return_value=callables))\n        return mocker.patch('thefuck.utils.Path', return_value=path_mock)\n\n    @pytest.mark.parametrize('script, result', [\n        ('le cat', ['ls cat', 'diff x', u'caf\u00e9 \u00f4']),\n        ('diff x', ['ls cat', u'caf\u00e9 \u00f4']),\n        ('fuck', ['ls cat', 'diff x', u'caf\u00e9 \u00f4']),\n        (u'cafe \u00f4', ['ls cat', 'diff x', u'caf\u00e9 \u00f4']),\n    ])\n    def test_get_valid_history_without_current(self, script, result):\n        command = Command(script, '')\n        assert get_valid_history_without_current(command) == result\n", "comments": "# -*- coding: utf-8 -*-\n", "content": "# -*- coding: utf-8 -*-\n\nimport pytest\nimport warnings\nfrom mock import Mock\nfrom thefuck.utils import default_settings, \\\n    memoize, get_closest, get_all_executables, replace_argument, \\\n    get_all_matched_commands, is_app, for_app, cache, \\\n    get_valid_history_without_current, _cache\nfrom thefuck.types import Command\n\n\n@pytest.mark.parametrize('override, old, new', [\n    ({'key': 'val'}, {}, {'key': 'val'}),\n    ({'key': 'new-val'}, {'key': 'val'}, {'key': 'val'}),\n    ({'key': 'new-val', 'unset': 'unset'}, {'key': 'val'}, {'key': 'val', 'unset': 'unset'})])\ndef test_default_settings(settings, override, old, new):\n    settings.clear()\n    settings.update(old)\n    default_settings(override)(lambda _: _)(None)\n    assert settings == new\n\n\ndef test_memoize():\n    fn = Mock(__name__='fn')\n    memoized = memoize(fn)\n    memoized()\n    memoized()\n    fn.assert_called_once_with()\n\n\n@pytest.mark.usefixtures('no_memoize')\ndef test_no_memoize():\n    fn = Mock(__name__='fn')\n    memoized = memoize(fn)\n    memoized()\n    memoized()\n    assert fn.call_count == 2\n\n\nclass TestGetClosest(object):\n    def test_when_can_match(self):\n        assert 'branch' == get_closest('brnch', ['branch', 'status'])\n\n    def test_when_cant_match(self):\n        assert 'status' == get_closest('st', ['status', 'reset'])\n\n    def test_without_fallback(self):\n        assert get_closest('st', ['status', 'reset'],\n                           fallback_to_first=False) is None\n\n\n@pytest.fixture\ndef get_aliases(mocker):\n    mocker.patch('thefuck.shells.shell.get_aliases',\n                 return_value=['vim', 'apt-get', 'fsck', 'fuck'])\n\n\n@pytest.mark.usefixtures('no_memoize', 'get_aliases')\ndef test_get_all_executables():\n    all_callables = get_all_executables()\n    assert 'vim' in all_callables\n    assert 'fsck' in all_callables\n    assert 'fuck' not in all_callables\n\n\n@pytest.mark.parametrize('args, result', [\n    (('apt-get instol vim', 'instol', 'install'), 'apt-get install vim'),\n    (('git brnch', 'brnch', 'branch'), 'git branch')])\ndef test_replace_argument(args, result):\n    assert replace_argument(*args) == result\n\n\n@pytest.mark.parametrize('stderr, result', [\n    ((\"git: 'cone' is not a git command. See 'git --help'.\\n\"\n      '\\n'\n      'Did you mean one of these?\\n'\n      '\\tclone'), ['clone']),\n    ((\"git: 're' is not a git command. See 'git --help'.\\n\"\n      '\\n'\n      'Did you mean one of these?\\n'\n      '\\trebase\\n'\n      '\\treset\\n'\n      '\\tgrep\\n'\n      '\\trm'), ['rebase', 'reset', 'grep', 'rm']),\n    (('tsuru: \"target\" is not a tsuru command. See \"tsuru help\".\\n'\n      '\\n'\n      'Did you mean one of these?\\n'\n      '\\tservice-add\\n'\n      '\\tservice-bind\\n'\n      '\\tservice-doc\\n'\n      '\\tservice-info\\n'\n      '\\tservice-list\\n'\n      '\\tservice-remove\\n'\n      '\\tservice-status\\n'\n      '\\tservice-unbind'), ['service-add', 'service-bind', 'service-doc',\n                            'service-info', 'service-list', 'service-remove',\n                            'service-status', 'service-unbind'])])\ndef test_get_all_matched_commands(stderr, result):\n    assert list(get_all_matched_commands(stderr)) == result\n\n\n@pytest.mark.usefixtures('no_memoize')\n@pytest.mark.parametrize('script, names, result', [\n    ('git diff', ['git', 'hub'], True),\n    ('hub diff', ['git', 'hub'], True),\n    ('hg diff', ['git', 'hub'], False)])\ndef test_is_app(script, names, result):\n    assert is_app(Command(script, ''), *names) == result\n\n\n@pytest.mark.usefixtures('no_memoize')\n@pytest.mark.parametrize('script, names, result', [\n    ('git diff', ['git', 'hub'], True),\n    ('hub diff', ['git', 'hub'], True),\n    ('hg diff', ['git', 'hub'], False)])\ndef test_for_app(script, names, result):\n    @for_app(*names)\n    def match(command):\n        return True\n\n    assert match(Command(script, '')) == result\n\n\nclass TestCache(object):\n    @pytest.fixture\n    def shelve(self, mocker):\n        value = {}\n\n        class _Shelve(object):\n            def __init__(self, path):\n                pass\n\n            def __setitem__(self, k, v):\n                value[k] = v\n\n            def __getitem__(self, k):\n                return value[k]\n\n            def get(self, k, v=None):\n                return value.get(k, v)\n\n            def close(self):\n                return\n\n        mocker.patch('thefuck.utils.shelve.open', new_callable=lambda: _Shelve)\n        return value\n\n    @pytest.fixture(autouse=True)\n    def enable_cache(self, monkeypatch, shelve):\n        monkeypatch.setattr('thefuck.utils.cache.disabled', False)\n        _cache._init_db()\n\n    @pytest.fixture(autouse=True)\n    def mtime(self, mocker):\n        mocker.patch('thefuck.utils.os.path.getmtime', return_value=0)\n\n    @pytest.fixture\n    def fn(self):\n        @cache('~/.bashrc')\n        def fn():\n            return 'test'\n\n        return fn\n\n    @pytest.fixture\n    def key(self, monkeypatch):\n        monkeypatch.setattr('thefuck.utils.Cache._get_key',\n                            lambda *_: 'key')\n        return 'key'\n\n    def test_with_blank_cache(self, shelve, fn, key):\n        assert shelve == {}\n        assert fn() == 'test'\n        assert shelve == {key: {'etag': '0', 'value': 'test'}}\n\n    def test_with_filled_cache(self, shelve, fn, key):\n        cache_value = {key: {'etag': '0', 'value': 'new-value'}}\n        shelve.update(cache_value)\n        assert fn() == 'new-value'\n        assert shelve == cache_value\n\n    def test_when_etag_changed(self, shelve, fn, key):\n        shelve.update({key: {'etag': '-1', 'value': 'old-value'}})\n        assert fn() == 'test'\n        assert shelve == {key: {'etag': '0', 'value': 'test'}}\n\n\nclass TestGetValidHistoryWithoutCurrent(object):\n    @pytest.yield_fixture(autouse=True)\n    def fail_on_warning(self):\n        warnings.simplefilter('error')\n        yield\n        warnings.resetwarnings()\n\n    @pytest.fixture(autouse=True)\n    def history(self, mocker):\n        return mocker.patch('thefuck.shells.shell.get_history',\n                            return_value=['le cat', 'fuck', 'ls cat',\n                                          'diff x', 'nocommand x', u'caf\u00e9 \u00f4'])\n\n    @pytest.fixture(autouse=True)\n    def alias(self, mocker):\n        return mocker.patch('thefuck.utils.get_alias',\n                            return_value='fuck')\n\n    @pytest.fixture(autouse=True)\n    def bins(self, mocker):\n        callables = list()\n        for name in ['diff', 'ls', 'caf\u00e9']:\n            bin_mock = mocker.Mock(name=name)\n            bin_mock.configure_mock(name=name, is_dir=lambda: False)\n            callables.append(bin_mock)\n        path_mock = mocker.Mock(iterdir=mocker.Mock(return_value=callables))\n        return mocker.patch('thefuck.utils.Path', return_value=path_mock)\n\n    @pytest.mark.parametrize('script, result', [\n        ('le cat', ['ls cat', 'diff x', u'caf\u00e9 \u00f4']),\n        ('diff x', ['ls cat', u'caf\u00e9 \u00f4']),\n        ('fuck', ['ls cat', 'diff x', u'caf\u00e9 \u00f4']),\n        (u'cafe \u00f4', ['ls cat', 'diff x', u'caf\u00e9 \u00f4']),\n    ])\n    def test_get_valid_history_without_current(self, script, result):\n        command = Command(script, '')\n        assert get_valid_history_without_current(command) == result\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "test_utils.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/tests/test_utils.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}