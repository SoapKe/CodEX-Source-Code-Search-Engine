{"author": "scikit-learn", "code": "from itertools import product\nimport numpy as np\nfrom numpy.testing import (assert_almost_equal, assert_array_almost_equal,\n                           assert_equal)\n\nfrom sklearn import datasets\nfrom sklearn import manifold\nfrom sklearn import neighbors\nfrom sklearn import pipeline\nfrom sklearn import preprocessing\nfrom sklearn.utils.testing import assert_less\n\neigen_solvers = ['auto', 'dense', 'arpack']\npath_methods = ['auto', 'FW', 'D']\n\n\ndef test_isomap_simple_grid():\n    \n    N_per_side = 5\n    Npts = N_per_side ** 2\n    n_neighbors = Npts - 1\n\n    \n    X = np.array(list(product(range(N_per_side), repeat=2)))\n\n    \n    G = neighbors.kneighbors_graph(X, n_neighbors,\n                                   mode='distance').toarray()\n\n    for eigen_solver in eigen_solvers:\n        for path_method in path_methods:\n            clf = manifold.Isomap(n_neighbors=n_neighbors, n_components=2,\n                                  eigen_solver=eigen_solver,\n                                  path_method=path_method)\n            clf.fit(X)\n\n            G_iso = neighbors.kneighbors_graph(clf.embedding_,\n                                               n_neighbors,\n                                               mode='distance').toarray()\n            assert_array_almost_equal(G, G_iso)\n\n\ndef test_isomap_reconstruction_error():\n    \n    N_per_side = 5\n    Npts = N_per_side ** 2\n    n_neighbors = Npts - 1\n\n    \n    X = np.array(list(product(range(N_per_side), repeat=2)))\n\n    \n    rng = np.random.RandomState(0)\n    noise = 0.1 * rng.randn(Npts, 1)\n    X = np.concatenate((X, noise), 1)\n\n    \n    G = neighbors.kneighbors_graph(X, n_neighbors,\n                                   mode='distance').toarray()\n\n    centerer = preprocessing.KernelCenterer()\n    K = centerer.fit_transform(-0.5 * G ** 2)\n\n    for eigen_solver in eigen_solvers:\n        for path_method in path_methods:\n            clf = manifold.Isomap(n_neighbors=n_neighbors, n_components=2,\n                                  eigen_solver=eigen_solver,\n                                  path_method=path_method)\n            clf.fit(X)\n\n            \n            G_iso = neighbors.kneighbors_graph(clf.embedding_,\n                                               n_neighbors,\n                                               mode='distance').toarray()\n\n            K_iso = centerer.fit_transform(-0.5 * G_iso ** 2)\n\n            \n            reconstruction_error = np.linalg.norm(K - K_iso) / Npts\n            assert_almost_equal(reconstruction_error,\n                                clf.reconstruction_error())\n\n\ndef test_transform():\n    n_samples = 200\n    n_components = 10\n    noise_scale = 0.01\n\n    \n    X, y = datasets.samples_generator.make_s_curve(n_samples, random_state=0)\n\n    \n    iso = manifold.Isomap(n_components, 2)\n    X_iso = iso.fit_transform(X)\n\n    \n    rng = np.random.RandomState(0)\n    noise = noise_scale * rng.randn(*X.shape)\n    X_iso2 = iso.transform(X + noise)\n\n    \n    assert_less(np.sqrt(np.mean((X_iso - X_iso2) ** 2)), 2 * noise_scale)\n\n\ndef test_pipeline():\n    \n    \n    \n    X, y = datasets.make_blobs(random_state=0)\n    clf = pipeline.Pipeline(\n        [('isomap', manifold.Isomap()),\n         ('clf', neighbors.KNeighborsClassifier())])\n    clf.fit(X, y)\n    assert_less(.9, clf.score(X, y))\n\n\ndef test_isomap_clone_bug():\n    \n    model = manifold.Isomap()\n    for n_neighbors in [10, 15, 20]:\n        model.set_params(n_neighbors=n_neighbors)\n        model.fit(np.random.rand(50, 2))\n        assert_equal(model.nbrs_.n_neighbors,\n                     n_neighbors)\n", "comments": "  isomap preserve distances neighbors used    grid equidistant points 2d  n components   n dim    distances point others    same setup test isomap simple grid  added dimension    grid equidistant points 2d  n components   n dim    add noise third dimension    compute input kernel    compute output kernel    make sure error agrees    create s curve dataset    compute isomap embedding    re embed noisy version points    make sure rms error embedding comparable noise scale    check isomap works fine transformer pipeline    checks error raised     todo check actually something useful    regression test bug reported  6062 ", "content": "from itertools import product\nimport numpy as np\nfrom numpy.testing import (assert_almost_equal, assert_array_almost_equal,\n                           assert_equal)\n\nfrom sklearn import datasets\nfrom sklearn import manifold\nfrom sklearn import neighbors\nfrom sklearn import pipeline\nfrom sklearn import preprocessing\nfrom sklearn.utils.testing import assert_less\n\neigen_solvers = ['auto', 'dense', 'arpack']\npath_methods = ['auto', 'FW', 'D']\n\n\ndef test_isomap_simple_grid():\n    # Isomap should preserve distances when all neighbors are used\n    N_per_side = 5\n    Npts = N_per_side ** 2\n    n_neighbors = Npts - 1\n\n    # grid of equidistant points in 2D, n_components = n_dim\n    X = np.array(list(product(range(N_per_side), repeat=2)))\n\n    # distances from each point to all others\n    G = neighbors.kneighbors_graph(X, n_neighbors,\n                                   mode='distance').toarray()\n\n    for eigen_solver in eigen_solvers:\n        for path_method in path_methods:\n            clf = manifold.Isomap(n_neighbors=n_neighbors, n_components=2,\n                                  eigen_solver=eigen_solver,\n                                  path_method=path_method)\n            clf.fit(X)\n\n            G_iso = neighbors.kneighbors_graph(clf.embedding_,\n                                               n_neighbors,\n                                               mode='distance').toarray()\n            assert_array_almost_equal(G, G_iso)\n\n\ndef test_isomap_reconstruction_error():\n    # Same setup as in test_isomap_simple_grid, with an added dimension\n    N_per_side = 5\n    Npts = N_per_side ** 2\n    n_neighbors = Npts - 1\n\n    # grid of equidistant points in 2D, n_components = n_dim\n    X = np.array(list(product(range(N_per_side), repeat=2)))\n\n    # add noise in a third dimension\n    rng = np.random.RandomState(0)\n    noise = 0.1 * rng.randn(Npts, 1)\n    X = np.concatenate((X, noise), 1)\n\n    # compute input kernel\n    G = neighbors.kneighbors_graph(X, n_neighbors,\n                                   mode='distance').toarray()\n\n    centerer = preprocessing.KernelCenterer()\n    K = centerer.fit_transform(-0.5 * G ** 2)\n\n    for eigen_solver in eigen_solvers:\n        for path_method in path_methods:\n            clf = manifold.Isomap(n_neighbors=n_neighbors, n_components=2,\n                                  eigen_solver=eigen_solver,\n                                  path_method=path_method)\n            clf.fit(X)\n\n            # compute output kernel\n            G_iso = neighbors.kneighbors_graph(clf.embedding_,\n                                               n_neighbors,\n                                               mode='distance').toarray()\n\n            K_iso = centerer.fit_transform(-0.5 * G_iso ** 2)\n\n            # make sure error agrees\n            reconstruction_error = np.linalg.norm(K - K_iso) / Npts\n            assert_almost_equal(reconstruction_error,\n                                clf.reconstruction_error())\n\n\ndef test_transform():\n    n_samples = 200\n    n_components = 10\n    noise_scale = 0.01\n\n    # Create S-curve dataset\n    X, y = datasets.samples_generator.make_s_curve(n_samples, random_state=0)\n\n    # Compute isomap embedding\n    iso = manifold.Isomap(n_components, 2)\n    X_iso = iso.fit_transform(X)\n\n    # Re-embed a noisy version of the points\n    rng = np.random.RandomState(0)\n    noise = noise_scale * rng.randn(*X.shape)\n    X_iso2 = iso.transform(X + noise)\n\n    # Make sure the rms error on re-embedding is comparable to noise_scale\n    assert_less(np.sqrt(np.mean((X_iso - X_iso2) ** 2)), 2 * noise_scale)\n\n\ndef test_pipeline():\n    # check that Isomap works fine as a transformer in a Pipeline\n    # only checks that no error is raised.\n    # TODO check that it actually does something useful\n    X, y = datasets.make_blobs(random_state=0)\n    clf = pipeline.Pipeline(\n        [('isomap', manifold.Isomap()),\n         ('clf', neighbors.KNeighborsClassifier())])\n    clf.fit(X, y)\n    assert_less(.9, clf.score(X, y))\n\n\ndef test_isomap_clone_bug():\n    # regression test for bug reported in #6062\n    model = manifold.Isomap()\n    for n_neighbors in [10, 15, 20]:\n        model.set_params(n_neighbors=n_neighbors)\n        model.fit(np.random.rand(50, 2))\n        assert_equal(model.nbrs_.n_neighbors,\n                     n_neighbors)\n", "description": "scikit-learn: machine learning in Python", "file_name": "test_isomap.py", "id": "1d626c20e2d95c38429564a62fcaa30b", "language": "Python", "project_name": "scikit-learn", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/scikit-learn-scikit-learn/scikit-learn-scikit-learn-94ed5a8/sklearn/manifold/tests/test_isomap.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:58:59Z", "url": "https://github.com/scikit-learn/scikit-learn", "wiki": true}