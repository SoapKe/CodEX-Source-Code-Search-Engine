{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\nimport json\n\nfrom .common import InfoExtractor\nfrom .adobepass import AdobePassIE\nfrom ..compat import (\n    compat_etree_fromstring,\n    compat_parse_qs,\n    compat_str,\n    compat_urllib_parse_urlparse,\n    compat_urlparse,\n    compat_xml_parse_error,\n    compat_HTTPError,\n)\nfrom ..utils import (\n    determine_ext,\n    ExtractorError,\n    extract_attributes,\n    find_xpath_attr,\n    fix_xml_ampersands,\n    float_or_none,\n    js_to_json,\n    int_or_none,\n    parse_iso8601,\n    unescapeHTML,\n    unsmuggle_url,\n    update_url_query,\n    clean_html,\n    mimetype2ext,\n)\n\n\nclass BrightcoveLegacyIE(InfoExtractor):\n    IE_NAME = 'brightcove:legacy'\n    _VALID_URL = r'(?:https?://.*brightcove\\.com/(services|viewer).*?\\?|brightcove:)(?P<query>.*)'\n    _FEDERATED_URL = 'http://c.brightcove.com/services/viewer/htmlFederated'\n\n    _TESTS = [\n        {\n            \n            'url': 'http://c.brightcove.com/services/viewer/htmlFederated?playerID=1654948606001&flashID=myExperience&%40videoPlayer=2371591881001',\n            'md5': '5423e113865d26e40624dce2e4b45d95',\n            'note': 'Test Brightcove downloads and detection in GenericIE',\n            'info_dict': {\n                'id': '2371591881001',\n                'ext': 'mp4',\n                'title': 'Xavier Sala i Mart\u00edn: \u201cUn banc que no presta \u00e9s un banc zombi que no serveix per a res\u201d',\n                'uploader': '8TV',\n                'description': 'md5:a950cc4285c43e44d763d036710cd9cd',\n                'timestamp': 1368213670,\n                'upload_date': '20130510',\n                'uploader_id': '1589608506001',\n            }\n        },\n        {\n            \n            'url': 'http://c.brightcove.com/services/viewer/htmlFederated?playerID=1217746023001&flashID=myPlayer&%40videoPlayer=1785452137001',\n            'info_dict': {\n                'id': '1785452137001',\n                'ext': 'flv',\n                'title': 'JVMLS 2012: Arrays 2.0 - Opportunities and Challenges',\n                'description': 'John Rose speaks at the JVM Language Summit, August 1, 2012.',\n                'uploader': 'Oracle',\n                'timestamp': 1344975024,\n                'upload_date': '20120814',\n                'uploader_id': '1460825906',\n            },\n        },\n        {\n            \n            'url': 'http://c.brightcove.com/services/viewer/federated_f9?&playerID=1265504713001&publisherID=AQ%7E%7E%2CAAABBzUwv1E%7E%2CxP-xFHVUstiMFlNYfvF4G9yFnNaqCw_9&videoID=2750934548001',\n            'info_dict': {\n                'id': '2750934548001',\n                'ext': 'mp4',\n                'title': 'This Bracelet Acts as a Personal Thermostat',\n                'description': 'md5:547b78c64f4112766ccf4e151c20b6a0',\n                'uploader': 'Mashable',\n                'timestamp': 1382041798,\n                'upload_date': '20131017',\n                'uploader_id': '1130468786001',\n            },\n        },\n        {\n            \n            \n            'url': 'http://link.brightcove.com/services/player/bcpid756015033001?bckey=AQ~~,AAAApYJi_Ck~,GxhXCegT1Dp39ilhXuxMJxasUhVNZiil&bctid=2878862109001',\n            'info_dict': {\n                'id': '2878862109001',\n                'ext': 'mp4',\n                'title': 'Lost in Motion II',\n                'description': 'md5:363109c02998fee92ec02211bd8000df',\n                'uploader': 'National Ballet of Canada',\n            },\n            'skip': 'Video gone',\n        },\n        {\n            \n            \n            'url': 'http://c.brightcove.com/services/viewer/htmlFederated?%40videoPlayer=ref%3Aevent-stream-356&linkBaseURL=http%3A%2F%2Fwww.redbull.com%2Fen%2Fbike%2Fvideos%2F1331655630249%2Freplay-uci-fort-william-2014-dh&playerKey=AQ%7E%7E%2CAAAApYJ7UqE%7E%2Cxqr_zXk0I-zzNndy8NlHogrCb5QdyZRf&playerID=1398061561001\n            \n            'info_dict': {\n                'id': '3750436379001',\n                'ext': 'flv',\n                'title': 'UCI MTB World Cup 2014: Fort William, UK - Downhill Finals',\n                'uploader': 'RBTV Old (do not use)',\n                'description': 'UCI MTB World Cup 2014: Fort William, UK - Downhill Finals',\n                'timestamp': 1409122195,\n                'upload_date': '20140827',\n                'uploader_id': '710858724001',\n            },\n            'skip': 'Video gone',\n        },\n        {\n            \n            \n            'url': 'http://c.brightcove.com/services/viewer/htmlFederated?playerID=3550052898001&playerKey=AQ%7E%7E%2CAAABmA9XpXk%7E%2C-Kp7jNgisre1fG5OdqpAFUTcs0lP_ZoL',\n            'info_dict': {\n                'title': 'Sealife',\n                'id': '3550319591001',\n            },\n            'playlist_mincount': 7,\n        },\n        {\n            \n            'url': 'http://c.brightcove.com/services/json/experience/runtime/?command=get_programming_for_experience&playerKey=AQ%7E%7E,AAABXlLMdok%7E,NJ4EoMlZ4rZdx9eU1rkMVd8EaYPBBUlg',\n            'info_dict': {\n                'id': '1522758701001',\n                'title': 'Lesson 08',\n            },\n            'playlist_mincount': 10,\n        },\n        {\n            \n            \n            'url': 'https://link.brightcove.com/services/player/bcpid1722935254001/?bctid=5360463607001&autoStart=false&secureConnections=true&width=650&height=350',\n            'only_matching': True,  \n        }\n    ]\n    FLV_VCODECS = {\n        1: 'SORENSON',\n        2: 'ON2',\n        3: 'H264',\n        4: 'VP8',\n    }\n\n    @classmethod\n    def _build_brighcove_url(cls, object_str):\n        \n\n        url_m = re.search(\n            r, webpage):\n            attrs = extract_attributes(video)\n\n            \n            \n            video_id = attrs.get('data-video-id')\n            if not video_id:\n                continue\n\n            account_id = account_id or attrs.get('data-account')\n            if not account_id:\n                continue\n\n            player_id = player_id or attrs.get('data-player') or 'default'\n            embed = embed or attrs.get('data-embed') or 'default'\n\n            bc_url = 'http://players.brightcove.net/%s/%s_%s/index.html?videoId=%s' % (\n                account_id, player_id, embed, video_id)\n\n            \n            \n            \n            \n            \n            \n            \n            if not script_tag and not ie._is_valid_url(\n                    bc_url, video_id, 'possible brightcove video'):\n                continue\n\n            entries.append(bc_url)\n\n        return entries\n\n    def _parse_brightcove_metadata(self, json_data, video_id, headers={}):\n        title = json_data['name'].strip()\n\n        formats = []\n        for source in json_data.get('sources', []):\n            container = source.get('container')\n            ext = mimetype2ext(source.get('type'))\n            src = source.get('src')\n            if ext == 'ism' or container == 'WVM':\n                continue\n            elif ext == 'm3u8' or container == 'M2TS':\n                if not src:\n                    continue\n                formats.extend(self._extract_m3u8_formats(\n                    src, video_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False))\n            elif ext == 'mpd':\n                if not src:\n                    continue\n                formats.extend(self._extract_mpd_formats(src, video_id, 'dash', fatal=False))\n            else:\n                streaming_src = source.get('streaming_src')\n                stream_name, app_name = source.get('stream_name'), source.get('app_name')\n                if not src and not streaming_src and (not stream_name or not app_name):\n                    continue\n                tbr = float_or_none(source.get('avg_bitrate'), 1000)\n                height = int_or_none(source.get('height'))\n                width = int_or_none(source.get('width'))\n                f = {\n                    'tbr': tbr,\n                    'filesize': int_or_none(source.get('size')),\n                    'container': container,\n                    'ext': ext or container.lower(),\n                }\n                if width == 0 and height == 0:\n                    f.update({\n                        'vcodec': 'none',\n                    })\n                else:\n                    f.update({\n                        'width': width,\n                        'height': height,\n                        'vcodec': source.get('codec'),\n                    })\n\n                def build_format_id(kind):\n                    format_id = kind\n                    if tbr:\n                        format_id += '-%dk' % int(tbr)\n                    if height:\n                        format_id += '-%dp' % height\n                    return format_id\n\n                if src or streaming_src:\n                    f.update({\n                        'url': src or streaming_src,\n                        'format_id': build_format_id('http' if src else 'http-streaming'),\n                        'source_preference': 0 if src else -1,\n                    })\n                else:\n                    f.update({\n                        'url': app_name,\n                        'play_path': stream_name,\n                        'format_id': build_format_id('rtmp'),\n                    })\n                formats.append(f)\n\n        errors = json_data.get('errors')\n        if not formats and errors:\n            error = errors[0]\n            raise ExtractorError(\n                error.get('message') or error.get('error_subcode') or error['error_code'], expected=True)\n\n        self._sort_formats(formats)\n\n        for f in formats:\n            f.setdefault('http_headers', {}).update(headers)\n\n        subtitles = {}\n        for text_track in json_data.get('text_tracks', []):\n            if text_track.get('src'):\n                subtitles.setdefault(text_track.get('srclang'), []).append({\n                    'url': text_track['src'],\n                })\n\n        is_live = False\n        duration = float_or_none(json_data.get('duration'), 1000)\n        if duration is not None and duration <= 0:\n            is_live = True\n\n        return {\n            'id': video_id,\n            'title': self._live_title(title) if is_live else title,\n            'description': clean_html(json_data.get('description')),\n            'thumbnail': json_data.get('thumbnail') or json_data.get('poster'),\n            'duration': duration,\n            'timestamp': parse_iso8601(json_data.get('published_at')),\n            'uploader_id': json_data.get('account_id'),\n            'formats': formats,\n            'subtitles': subtitles,\n            'tags': json_data.get('tags', []),\n            'is_live': is_live,\n        }\n\n    def _real_extract(self, url):\n        url, smuggled_data = unsmuggle_url(url, {})\n        self._initialize_geo_bypass(smuggled_data.get('geo_countries'))\n\n        account_id, player_id, embed, video_id = re.match(self._VALID_URL, url).groups()\n\n        webpage = self._download_webpage(\n            'http://players.brightcove.net/%s/%s_%s/index.min.js'\n            % (account_id, player_id, embed), video_id)\n\n        policy_key = None\n\n        catalog = self._search_regex(\n            r'catalog\\(({.+?})\\);', webpage, 'catalog', default=None)\n        if catalog:\n            catalog = self._parse_json(\n                js_to_json(catalog), video_id, fatal=False)\n            if catalog:\n                policy_key = catalog.get('policyKey')\n\n        if not policy_key:\n            policy_key = self._search_regex(\n                r'policyKey\\s*:\\s*([\"\\'])(?P<pk>.+?)\\1',\n                webpage, 'policy key', group='pk')\n\n        api_url = 'https://edge.api.brightcove.com/playback/v1/accounts/%s/videos/%s' % (account_id, video_id)\n        headers = {\n            'Accept': 'application/json;pk=%s' % policy_key,\n        }\n        referrer = smuggled_data.get('referrer')\n        if referrer:\n            headers.update({\n                'Referer': referrer,\n                'Origin': re.search(r'https?://[^/]+', referrer).group(0),\n            })\n        try:\n            json_data = self._download_json(api_url, video_id, headers=headers)\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError) and e.cause.code == 403:\n                json_data = self._parse_json(e.cause.read().decode(), video_id)[0]\n                message = json_data.get('message') or json_data['error_code']\n                if json_data.get('error_subcode') == 'CLIENT_GEO':\n                    self.raise_geo_restricted(msg=message)\n                raise ExtractorError(message, expected=True)\n            raise\n\n        errors = json_data.get('errors')\n        if errors and errors[0].get('error_subcode') == 'TVE_AUTH':\n            custom_fields = json_data['custom_fields']\n            tve_token = self._extract_mvpd_auth(\n                smuggled_data['source_url'], video_id,\n                custom_fields['bcadobepassrequestorid'],\n                custom_fields['bcadobepassresourceid'])\n            json_data = self._download_json(\n                api_url, video_id, headers={\n                    'Accept': 'application/json;pk=%s' % policy_key\n                }, query={\n                    'tveToken': tve_token,\n                })\n\n        return self._parse_brightcove_metadata(\n            json_data, video_id, headers=headers)\n", "comments": "\n        Build a Brightcove url from a xml string containing\n        <object class=\"BrightcoveExperience\">{params}</object>\n        \"\"\"\n\n        # Fix up some stupid HTML, see https://github.com/rg3/youtube-dl/issues/1553\n        object_str = re.sub(r'(<param(?:\\s+[a-zA-Z0-9_]+=\"[^\"]*\")*)>',\n                            lambda m: m.group(1) + '/>', object_str)\n        # Fix up some stupid XML, see https://github.com/rg3/youtube-dl/issues/1608\n        object_str = object_str.replace('<--', '<!--')\n        # remove namespace to simplify extraction\n        object_str = re.sub(r'(<object[^>]*)(xmlns=\".*?\")', r'\\1', object_str)\n        object_str = fix_xml_ampersands(object_str)\n\n        try:\n            object_doc = compat_etree_fromstring(object_str.encode('utf-8'))\n        except compat_xml_parse_error:\n            return\n\n        fv_el = find_xpath_attr(object_doc, './param', 'name', 'flashVars')\n        if fv_el is not None:\n            flashvars = dict(\n                (k, v[0])\n                for k, v in compat_parse_qs(fv_el.attrib['value']).items())\n        else:\n            flashvars = {}\n\n        data_url = object_doc.attrib.get('data', '')\n        data_url_params = compat_parse_qs(compat_urllib_parse_urlparse(data_url).query)\n\n        def find_param(name):\n            if name in flashvars:\n                return flashvars[name]\n            node = find_xpath_attr(object_doc, './param', 'name', name)\n            if node is not None:\n                return node.attrib['value']\n            return data_url_params.get(name)\n\n        params = {}\n\n        playerID = find_param('playerID') or find_param('playerId')\n        if playerID is None:\n            raise ExtractorError('Cannot find player ID')\n        params['playerID'] = playerID\n\n        playerKey = find_param('playerKey')\n        # Not all pages define this value\n        if playerKey is not None:\n            params['playerKey'] = playerKey\n        # These fields hold the id of the video\n        videoPlayer = find_param('@videoPlayer') or find_param('videoId') or find_param('videoID') or find_param('@videoList')\n        if videoPlayer is not None:\n            if isinstance(videoPlayer, list):\n                videoPlayer = videoPlayer[0]\n            videoPlayer = videoPlayer.strip()\n            # UUID is also possible for videoPlayer (e.g.\n            # http://www.popcornflix.com/hoodies-vs-hooligans/7f2d2b87-bbf2-4623-acfb-ea942b4f01dd\n            # or http://www8.hp.com/cn/zh/home.html)\n            if not (re.match(\n                    r'^(?:\\d+|[\\da-fA-F]{8}-?[\\da-fA-F]{4}-?[\\da-fA-F]{4}-?[\\da-fA-F]{4}-?[\\da-fA-F]{12})$',\n                    videoPlayer) or videoPlayer.startswith('ref:')):\n                return None\n            params['@videoPlayer'] = videoPlayer\n        linkBase = find_param('linkBaseURL')\n        if linkBase is not None:\n            params['linkBaseURL'] = linkBase\n        return cls._make_brightcove_url(params)\n\n    @classmethod\n    def _build_brighcove_url_from_js(cls, object_js):\n        # The layout of JS is as follows:\n        # customBC.createVideo = function (width, height, playerID, playerKey, videoPlayer, VideoRandomID) {\n        #   // build Brightcove <object /> XML\n        # }\n        m = re.search(\n            r'''(?x)customBC\\.createVideo\\(\n                .*?                                                  # skipping width and height\n                [\"\\'](?P<playerID>\\d+)[\"\\']\\s*,\\s*                   # playerID\n                [\"\\'](?P<playerKey>AQ[^\"\\']{48})[^\"\\']*[\"\\']\\s*,\\s*  # playerKey begins with AQ and is 50 characters\n                                                                     # in length, however it's appended to itself\n                                                                     # in places, so truncate\n                [\"\\'](?P<videoID>\\d+)[\"\\']                           # @videoPlayer\n            ''', object_js)\n        if m:\n            return cls._make_brightcove_url(m.groupdict())\n\n    @classmethod\n    def _make_brightcove_url(cls, params):\n        return update_url_query(cls._FEDERATED_URL, params)\n\n    @classmethod\n    def _extract_brightcove_url(cls, webpage):\n        \"\"\"Try to extract the brightcove url from the webpage, returns None\n        if it can't be found\n        \"\"\"\n        urls = cls._extract_brightcove_urls(webpage)\n        return urls[0] if urls else None\n\n    @classmethod\n    def _extract_brightcove_urls(cls, webpage):\n        \"\"\"Return a list of all Brightcove URLs from the webpage \n \n(?x)\n                <meta\\s+\n                    (?:property|itemprop)=([\\'\"])(?:og:video|embedURL)\\1[^>]+\n                    content=([\\'\"])(?P<url>https?://(?:secure|c)\\.brightcove.com/(?:(?!\\2).)+)\\2\n            ''', webpage)\n        if url_m:\n            url = unescapeHTML(url_m.group('url'))\n            # Some sites don't add it, we can't download with this url, for example:\n            # http://www.ktvu.com/videos/news/raw-video-caltrain-releases-video-of-man-almost/vCTZdY/\n            if 'playerKey' in url or 'videoId' in url or 'idVideo' in url:\n                return [url]\n\n        matches = re.findall(\n            r'''(?sx)<object\n            (?:\n                [^>]+?class=[\\'\"][^>]*?BrightcoveExperience.*?[\\'\"] |\n                [^>]*?>\\s*<param\\s+name=\"movie\"\\s+value=\"https?://[^/]*brightcove\\.com/\n            ).+?>\\s*</object>''',\n            webpage)\n        if matches:\n            return list(filter(None, [cls._build_brighcove_url(m) for m in matches]))\n\n        matches = re.findall(r'(customBC\\.createVideo\\(.+?\\);)', webpage)\n        if matches:\n            return list(filter(None, [\n                cls._build_brighcove_url_from_js(custom_bc)\n                for custom_bc in matches]))\n        return [src for _, src in re.findall(\n            r'<iframe[^>]+src=([\\'\"])((?:https?:)?//link\\.brightcove\\.com/services/player/(?!\\1).+)\\1', webpage)]\n\n    def _real_extract(self, url):\n        url, smuggled_data = unsmuggle_url(url, {})\n\n        # Change the 'videoId' and others field to '@videoPlayer'\n        url = re.sub(r'(?<=[?&])(videoI(d|D)|idVideo|bctid)', '%40videoPlayer', url)\n        # Change bckey (used by bcove.me urls) to playerKey\n        url = re.sub(r'(?<=[?&])bckey', 'playerKey', url)\n        mobj = re.match(self._VALID_URL, url)\n        query_str = mobj.group('query')\n        query = compat_urlparse.parse_qs(query_str)\n\n        videoPlayer = query.get('@videoPlayer')\n        if videoPlayer:\n            # We set the original url as the default 'Referer' header\n            referer = smuggled_data.get('Referer', url)\n            if 'playerID' not in query:\n                mobj = re.search(r'/bcpid(\\d+)', url)\n                if mobj is not None:\n                    query['playerID'] = [mobj.group(1)]\n            return self._get_video_info(\n                videoPlayer[0], query, referer=referer)\n        elif 'playerKey' in query:\n            player_key = query['playerKey']\n            return self._get_playlist_info(player_key[0])\n        else:\n            raise ExtractorError(\n                'Cannot find playerKey= variable. Did you forget quotes in a shell invocation?',\n                expected=True)\n\n    def _get_video_info(self, video_id, query, referer=None):\n        headers = {}\n        linkBase = query.get('linkBaseURL')\n        if linkBase is not None:\n            referer = linkBase[0]\n        if referer is not None:\n            headers['Referer'] = referer\n        webpage = self._download_webpage(self._FEDERATED_URL, video_id, headers=headers, query=query)\n\n        error_msg = self._html_search_regex(\n            r\"<h1>We're sorry.</h1>([\\s\\n]*<p>.*?</p>)+\", webpage,\n            'error message', default=None)\n        if error_msg is not None:\n            raise ExtractorError(\n                'brightcove said: %s' % error_msg, expected=True)\n\n        self.report_extraction(video_id)\n        info = self._search_regex(r'var experienceJSON = ({.*});', webpage, 'json')\n        info = json.loads(info)['data']\n        video_info = info['programmedContent']['videoPlayer']['mediaDTO']\n        video_info['_youtubedl_adServerURL'] = info.get('adServerURL')\n\n        return self._extract_video_info(video_info)\n\n    def _get_playlist_info(self, player_key):\n        info_url = 'http://c.brightcove.com/services/json/experience/runtime/?command=get_programming_for_experience&playerKey=%s' % player_key\n        playlist_info = self._download_webpage(\n            info_url, player_key, 'Downloading playlist information')\n\n        json_data = json.loads(playlist_info)\n        if 'videoList' in json_data:\n            playlist_info = json_data['videoList']\n            playlist_dto = playlist_info['mediaCollectionDTO']\n        elif 'playlistTabs' in json_data:\n            playlist_info = json_data['playlistTabs']\n            playlist_dto = playlist_info['lineupListDTO']['playlistDTOs'][0]\n        else:\n            raise ExtractorError('Empty playlist')\n\n        videos = [self._extract_video_info(video_info) for video_info in playlist_dto['videoDTOs']]\n\n        return self.playlist_result(videos, playlist_id='%s' % playlist_info['id'],\n                                    playlist_title=playlist_dto['displayName'])\n\n    def _extract_video_info(self, video_info):\n        video_id = compat_str(video_info['id'])\n        publisher_id = video_info.get('publisherId')\n        info = {\n            'id': video_id,\n            'title': video_info['displayName'].strip(),\n            'description': video_info.get('shortDescription'),\n            'thumbnail': video_info.get('videoStillURL') or video_info.get('thumbnailURL'),\n            'uploader': video_info.get('publisherName'),\n            'uploader_id': compat_str(publisher_id) if publisher_id else None,\n            'duration': float_or_none(video_info.get('length'), 1000),\n            'timestamp': int_or_none(video_info.get('creationDate'), 1000),\n        }\n\n        renditions = video_info.get('renditions', []) + video_info.get('IOSRenditions', [])\n        if renditions:\n            formats = []\n            for rend in renditions:\n                url = rend['defaultURL']\n                if not url:\n                    continue\n                ext = None\n                if rend['remote']:\n                    url_comp = compat_urllib_parse_urlparse(url)\n                    if url_comp.path.endswith('.m3u8'):\n                        formats.extend(\n                            self._extract_m3u8_formats(\n                                url, video_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False))\n                        continue\n                    elif 'akamaihd.net' in url_comp.netloc:\n                        # This type of renditions are served through\n                        # akamaihd.net, but they don't use f4m manifests\n                        url = url.replace('control/', '') + '?&v=3.3.0&fp=13&r=FEEFJ&g=RTSJIMBMPFPB'\n                        ext = 'flv'\n                if ext is None:\n                    ext = determine_ext(url)\n                tbr = int_or_none(rend.get('encodingRate'), 1000)\n                a_format = {\n                    'format_id': 'http%s' % ('-%s' % tbr if tbr else ''),\n                    'url': url,\n                    'ext': ext,\n                    'filesize': int_or_none(rend.get('size')) or None,\n                    'tbr': tbr,\n                }\n                if rend.get('audioOnly'):\n                    a_format.update({\n                        'vcodec': 'none',\n                    })\n                else:\n                    a_format.update({\n                        'height': int_or_none(rend.get('frameHeight')),\n                        'width': int_or_none(rend.get('frameWidth')),\n                        'vcodec': rend.get('videoCodec'),\n                    })\n\n                # m3u8 manifests with remote == false are media playlists\n                # Not calling _extract_m3u8_formats here to save network traffic\n                if ext == 'm3u8':\n                    a_format.update({\n                        'format_id': 'hls%s' % ('-%s' % tbr if tbr else ''),\n                        'ext': 'mp4',\n                        'protocol': 'm3u8_native',\n                    })\n\n                formats.append(a_format)\n            self._sort_formats(formats)\n            info['formats'] = formats\n        elif video_info.get('FLVFullLengthURL') is not None:\n            info.update({\n                'url': video_info['FLVFullLengthURL'],\n                'vcodec': self.FLV_VCODECS.get(video_info.get('FLVFullCodec')),\n                'filesize': int_or_none(video_info.get('FLVFullSize')),\n            })\n\n        if self._downloader.params.get('include_ads', False):\n            adServerURL = video_info.get('_youtubedl_adServerURL')\n            if adServerURL:\n                ad_info = {\n                    '_type': 'url',\n                    'url': adServerURL,\n                }\n                if 'url' in info:\n                    return {\n                        '_type': 'playlist',\n                        'title': info['title'],\n                        'entries': [ad_info, info],\n                    }\n                else:\n                    return ad_info\n\n        if 'url' not in info and not info.get('formats'):\n            raise ExtractorError('Unable to extract video url for %s' % video_id)\n        return info\n\n\nclass BrightcoveNewIE(AdobePassIE):\n    IE_NAME = 'brightcove:new'\n    _VALID_URL = r'https?://players\\.brightcove\\.net/(?P<account_id>\\d+)/(?P<player_id>[^/]+)_(?P<embed>[^/]+)/index\\.html\\?.*videoId=(?P<video_id>\\d+|ref:[^&]+)'\n    _TESTS = [{\n        'url': 'http://players.brightcove.net/929656772001/e41d32dc-ec74-459e-a845-6c69f7b724ea_default/index.html?videoId=4463358922001',\n        'md5': 'c8100925723840d4b0d243f7025703be',\n        'info_dict': {\n            'id': '4463358922001',\n            'ext': 'mp4',\n            'title': 'Meet the man behind Popcorn Time',\n            'description': 'md5:eac376a4fe366edc70279bfb681aea16',\n            'duration': 165.768,\n            'timestamp': 1441391203,\n            'upload_date': '20150904',\n            'uploader_id': '929656772001',\n            'formats': 'mincount:20',\n        },\n    }, {\n        # with rtmp streams\n        'url': 'http://players.brightcove.net/4036320279001/5d112ed9-283f-485f-a7f9-33f42e8bc042_default/index.html?videoId=4279049078001',\n        'info_dict': {\n            'id': '4279049078001',\n            'ext': 'mp4',\n            'title': 'Titansgrave: Chapter 0',\n            'description': 'Titansgrave: Chapter 0',\n            'duration': 1242.058,\n            'timestamp': 1433556729,\n            'upload_date': '20150606',\n            'uploader_id': '4036320279001',\n            'formats': 'mincount:39',\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        }\n    }, {\n        # ref: prefixed video id\n        'url': 'http://players.brightcove.net/3910869709001/21519b5c-4b3b-4363-accb-bdc8f358f823_default/index.html?videoId=ref:7069442',\n        'only_matching': True,\n    }, {\n        # non numeric ref: prefixed video id\n        'url': 'http://players.brightcove.net/710858724001/default_default/index.html?videoId=ref:event-stream-356',\n        'only_matching': True,\n    }, {\n        # unavailable video without message but with error_code\n        'url': 'http://players.brightcove.net/1305187701/c832abfb-641b-44eb-9da0-2fe76786505f_default/index.html?videoId=4377407326001',\n        'only_matching': True,\n    }]\n\n    @staticmethod\n    def _extract_url(ie, webpage):\n        urls = BrightcoveNewIE._extract_urls(ie, webpage)\n        return urls[0] if urls else None\n\n    @staticmethod\n    def _extract_urls(ie, webpage):\n        # Reference:\n        # 1. http://docs.brightcove.com/en/video-cloud/brightcove-player/guides/publish-video.html#setvideoiniframe\n        # 2. http://docs.brightcove.com/en/video-cloud/brightcove-player/guides/publish-video.html#tag\n        # 3. http://docs.brightcove.com/en/video-cloud/brightcove-player/guides/publish-video.html#setvideousingjavascript\n        # 4. http://docs.brightcove.com/en/video-cloud/brightcove-player/guides/in-page-embed-player-implementation.html\n        # 5. https://support.brightcove.com/en/video-cloud/docs/dynamically-assigning-videos-player\n\n        entries = []\n\n        # Look for iframe embeds [1]\n        for _, url in re.findall(\n                r'<iframe[^>]+src=([\"\\'])((?:https?:)?//players\\.brightcove\\.net/\\d+/[^/]+/index\\.html.+?)\\1', webpage):\n            entries.append(url if url.startswith('http') else 'http:' + url)\n\n        # Look for <video> tags [2] and embed_in_page embeds [3]\n        # [2] looks like:\n        for video, script_tag, account_id, player_id, embed in re.findall(\n                r'''(?isx)\n                    (<video\\s+[^>]*\\bdata-video-id\\s*=\\s*['\"]?[^>]+>)\n                    (?:.*?\n                        (<script[^>]+\n                            src=[\"\\'](?:https?:)?//players\\.brightcove\\.net/\n                            (\\d+)/([^/]+)_([^/]+)/index(?:\\.min)?\\.js\n                        )\n                    )?\n                \n \n# coding: utf-8\n# From http://www.8tv.cat/8aldia/videos/xavier-sala-i-martin-aquesta-tarda-a-8-al-dia/\n# From http://medianetwork.oracle.com/video/player/1785452137001\n# From http://mashable.com/2013/10/26/thermoelectric-bracelet-lets-you-control-your-body-temperature/\n# test that the default referer works\n# from http://national.ballet.ca/interact/video/Lost_in_Motion_II/\n# test flv videos served by akamaihd.net\n# From http://www.redbull.com/en/bike/stories/1331655643987/replay-uci-dh-world-cup-2014-from-fort-william\n#__youtubedl_smuggle=%7B%22Referer%22%3A+%22http%3A%2F%2Fwww.redbull.com%2Fen%2Fbike%2Fstories%2F1331655643987%2Freplay-uci-dh-world-cup-2014-from-fort-william%22%7D',\n# The md5 checksum changes on each download\n# playlist with 'videoList'\n# from http://support.brightcove.com/en/video-cloud/docs/playlist-support-single-video-players\n# playlist with 'playlistTab' (https://github.com/rg3/youtube-dl/issues/9965)\n# playerID inferred from bcpid\n# from http://www.un.org/chinese/News/story.asp?NewsID=27724\n# Tested in GenericIE\n# According to examples from [4] it's unclear whether video id\n# may be optional and what to do when it is\n# Some brightcove videos may be embedded with video tag only and\n# without script tag or any mentioning of brightcove at all. Such\n# embeds are considered ambiguous since they are matched based only\n# on data-video-id and data-account attributes and in the wild may\n# not be brightcove embeds at all. Let's check reconstructed\n# brightcove URLs in case of such embeds and only process valid\n# ones. By this we ensure there is indeed a brightcove embed.\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\nimport json\n\nfrom .common import InfoExtractor\nfrom .adobepass import AdobePassIE\nfrom ..compat import (\n    compat_etree_fromstring,\n    compat_parse_qs,\n    compat_str,\n    compat_urllib_parse_urlparse,\n    compat_urlparse,\n    compat_xml_parse_error,\n    compat_HTTPError,\n)\nfrom ..utils import (\n    determine_ext,\n    ExtractorError,\n    extract_attributes,\n    find_xpath_attr,\n    fix_xml_ampersands,\n    float_or_none,\n    js_to_json,\n    int_or_none,\n    parse_iso8601,\n    unescapeHTML,\n    unsmuggle_url,\n    update_url_query,\n    clean_html,\n    mimetype2ext,\n)\n\n\nclass BrightcoveLegacyIE(InfoExtractor):\n    IE_NAME = 'brightcove:legacy'\n    _VALID_URL = r'(?:https?://.*brightcove\\.com/(services|viewer).*?\\?|brightcove:)(?P<query>.*)'\n    _FEDERATED_URL = 'http://c.brightcove.com/services/viewer/htmlFederated'\n\n    _TESTS = [\n        {\n            # From http://www.8tv.cat/8aldia/videos/xavier-sala-i-martin-aquesta-tarda-a-8-al-dia/\n            'url': 'http://c.brightcove.com/services/viewer/htmlFederated?playerID=1654948606001&flashID=myExperience&%40videoPlayer=2371591881001',\n            'md5': '5423e113865d26e40624dce2e4b45d95',\n            'note': 'Test Brightcove downloads and detection in GenericIE',\n            'info_dict': {\n                'id': '2371591881001',\n                'ext': 'mp4',\n                'title': 'Xavier Sala i Mart\u00edn: \u201cUn banc que no presta \u00e9s un banc zombi que no serveix per a res\u201d',\n                'uploader': '8TV',\n                'description': 'md5:a950cc4285c43e44d763d036710cd9cd',\n                'timestamp': 1368213670,\n                'upload_date': '20130510',\n                'uploader_id': '1589608506001',\n            }\n        },\n        {\n            # From http://medianetwork.oracle.com/video/player/1785452137001\n            'url': 'http://c.brightcove.com/services/viewer/htmlFederated?playerID=1217746023001&flashID=myPlayer&%40videoPlayer=1785452137001',\n            'info_dict': {\n                'id': '1785452137001',\n                'ext': 'flv',\n                'title': 'JVMLS 2012: Arrays 2.0 - Opportunities and Challenges',\n                'description': 'John Rose speaks at the JVM Language Summit, August 1, 2012.',\n                'uploader': 'Oracle',\n                'timestamp': 1344975024,\n                'upload_date': '20120814',\n                'uploader_id': '1460825906',\n            },\n        },\n        {\n            # From http://mashable.com/2013/10/26/thermoelectric-bracelet-lets-you-control-your-body-temperature/\n            'url': 'http://c.brightcove.com/services/viewer/federated_f9?&playerID=1265504713001&publisherID=AQ%7E%7E%2CAAABBzUwv1E%7E%2CxP-xFHVUstiMFlNYfvF4G9yFnNaqCw_9&videoID=2750934548001',\n            'info_dict': {\n                'id': '2750934548001',\n                'ext': 'mp4',\n                'title': 'This Bracelet Acts as a Personal Thermostat',\n                'description': 'md5:547b78c64f4112766ccf4e151c20b6a0',\n                'uploader': 'Mashable',\n                'timestamp': 1382041798,\n                'upload_date': '20131017',\n                'uploader_id': '1130468786001',\n            },\n        },\n        {\n            # test that the default referer works\n            # from http://national.ballet.ca/interact/video/Lost_in_Motion_II/\n            'url': 'http://link.brightcove.com/services/player/bcpid756015033001?bckey=AQ~~,AAAApYJi_Ck~,GxhXCegT1Dp39ilhXuxMJxasUhVNZiil&bctid=2878862109001',\n            'info_dict': {\n                'id': '2878862109001',\n                'ext': 'mp4',\n                'title': 'Lost in Motion II',\n                'description': 'md5:363109c02998fee92ec02211bd8000df',\n                'uploader': 'National Ballet of Canada',\n            },\n            'skip': 'Video gone',\n        },\n        {\n            # test flv videos served by akamaihd.net\n            # From http://www.redbull.com/en/bike/stories/1331655643987/replay-uci-dh-world-cup-2014-from-fort-william\n            'url': 'http://c.brightcove.com/services/viewer/htmlFederated?%40videoPlayer=ref%3Aevent-stream-356&linkBaseURL=http%3A%2F%2Fwww.redbull.com%2Fen%2Fbike%2Fvideos%2F1331655630249%2Freplay-uci-fort-william-2014-dh&playerKey=AQ%7E%7E%2CAAAApYJ7UqE%7E%2Cxqr_zXk0I-zzNndy8NlHogrCb5QdyZRf&playerID=1398061561001#__youtubedl_smuggle=%7B%22Referer%22%3A+%22http%3A%2F%2Fwww.redbull.com%2Fen%2Fbike%2Fstories%2F1331655643987%2Freplay-uci-dh-world-cup-2014-from-fort-william%22%7D',\n            # The md5 checksum changes on each download\n            'info_dict': {\n                'id': '3750436379001',\n                'ext': 'flv',\n                'title': 'UCI MTB World Cup 2014: Fort William, UK - Downhill Finals',\n                'uploader': 'RBTV Old (do not use)',\n                'description': 'UCI MTB World Cup 2014: Fort William, UK - Downhill Finals',\n                'timestamp': 1409122195,\n                'upload_date': '20140827',\n                'uploader_id': '710858724001',\n            },\n            'skip': 'Video gone',\n        },\n        {\n            # playlist with 'videoList'\n            # from http://support.brightcove.com/en/video-cloud/docs/playlist-support-single-video-players\n            'url': 'http://c.brightcove.com/services/viewer/htmlFederated?playerID=3550052898001&playerKey=AQ%7E%7E%2CAAABmA9XpXk%7E%2C-Kp7jNgisre1fG5OdqpAFUTcs0lP_ZoL',\n            'info_dict': {\n                'title': 'Sealife',\n                'id': '3550319591001',\n            },\n            'playlist_mincount': 7,\n        },\n        {\n            # playlist with 'playlistTab' (https://github.com/rg3/youtube-dl/issues/9965)\n            'url': 'http://c.brightcove.com/services/json/experience/runtime/?command=get_programming_for_experience&playerKey=AQ%7E%7E,AAABXlLMdok%7E,NJ4EoMlZ4rZdx9eU1rkMVd8EaYPBBUlg',\n            'info_dict': {\n                'id': '1522758701001',\n                'title': 'Lesson 08',\n            },\n            'playlist_mincount': 10,\n        },\n        {\n            # playerID inferred from bcpid\n            # from http://www.un.org/chinese/News/story.asp?NewsID=27724\n            'url': 'https://link.brightcove.com/services/player/bcpid1722935254001/?bctid=5360463607001&autoStart=false&secureConnections=true&width=650&height=350',\n            'only_matching': True,  # Tested in GenericIE\n        }\n    ]\n    FLV_VCODECS = {\n        1: 'SORENSON',\n        2: 'ON2',\n        3: 'H264',\n        4: 'VP8',\n    }\n\n    @classmethod\n    def _build_brighcove_url(cls, object_str):\n        \"\"\"\n        Build a Brightcove url from a xml string containing\n        <object class=\"BrightcoveExperience\">{params}</object>\n        \"\"\"\n\n        # Fix up some stupid HTML, see https://github.com/rg3/youtube-dl/issues/1553\n        object_str = re.sub(r'(<param(?:\\s+[a-zA-Z0-9_]+=\"[^\"]*\")*)>',\n                            lambda m: m.group(1) + '/>', object_str)\n        # Fix up some stupid XML, see https://github.com/rg3/youtube-dl/issues/1608\n        object_str = object_str.replace('<--', '<!--')\n        # remove namespace to simplify extraction\n        object_str = re.sub(r'(<object[^>]*)(xmlns=\".*?\")', r'\\1', object_str)\n        object_str = fix_xml_ampersands(object_str)\n\n        try:\n            object_doc = compat_etree_fromstring(object_str.encode('utf-8'))\n        except compat_xml_parse_error:\n            return\n\n        fv_el = find_xpath_attr(object_doc, './param', 'name', 'flashVars')\n        if fv_el is not None:\n            flashvars = dict(\n                (k, v[0])\n                for k, v in compat_parse_qs(fv_el.attrib['value']).items())\n        else:\n            flashvars = {}\n\n        data_url = object_doc.attrib.get('data', '')\n        data_url_params = compat_parse_qs(compat_urllib_parse_urlparse(data_url).query)\n\n        def find_param(name):\n            if name in flashvars:\n                return flashvars[name]\n            node = find_xpath_attr(object_doc, './param', 'name', name)\n            if node is not None:\n                return node.attrib['value']\n            return data_url_params.get(name)\n\n        params = {}\n\n        playerID = find_param('playerID') or find_param('playerId')\n        if playerID is None:\n            raise ExtractorError('Cannot find player ID')\n        params['playerID'] = playerID\n\n        playerKey = find_param('playerKey')\n        # Not all pages define this value\n        if playerKey is not None:\n            params['playerKey'] = playerKey\n        # These fields hold the id of the video\n        videoPlayer = find_param('@videoPlayer') or find_param('videoId') or find_param('videoID') or find_param('@videoList')\n        if videoPlayer is not None:\n            if isinstance(videoPlayer, list):\n                videoPlayer = videoPlayer[0]\n            videoPlayer = videoPlayer.strip()\n            # UUID is also possible for videoPlayer (e.g.\n            # http://www.popcornflix.com/hoodies-vs-hooligans/7f2d2b87-bbf2-4623-acfb-ea942b4f01dd\n            # or http://www8.hp.com/cn/zh/home.html)\n            if not (re.match(\n                    r'^(?:\\d+|[\\da-fA-F]{8}-?[\\da-fA-F]{4}-?[\\da-fA-F]{4}-?[\\da-fA-F]{4}-?[\\da-fA-F]{12})$',\n                    videoPlayer) or videoPlayer.startswith('ref:')):\n                return None\n            params['@videoPlayer'] = videoPlayer\n        linkBase = find_param('linkBaseURL')\n        if linkBase is not None:\n            params['linkBaseURL'] = linkBase\n        return cls._make_brightcove_url(params)\n\n    @classmethod\n    def _build_brighcove_url_from_js(cls, object_js):\n        # The layout of JS is as follows:\n        # customBC.createVideo = function (width, height, playerID, playerKey, videoPlayer, VideoRandomID) {\n        #   // build Brightcove <object /> XML\n        # }\n        m = re.search(\n            r'''(?x)customBC\\.createVideo\\(\n                .*?                                                  # skipping width and height\n                [\"\\'](?P<playerID>\\d+)[\"\\']\\s*,\\s*                   # playerID\n                [\"\\'](?P<playerKey>AQ[^\"\\']{48})[^\"\\']*[\"\\']\\s*,\\s*  # playerKey begins with AQ and is 50 characters\n                                                                     # in length, however it's appended to itself\n                                                                     # in places, so truncate\n                [\"\\'](?P<videoID>\\d+)[\"\\']                           # @videoPlayer\n            ''', object_js)\n        if m:\n            return cls._make_brightcove_url(m.groupdict())\n\n    @classmethod\n    def _make_brightcove_url(cls, params):\n        return update_url_query(cls._FEDERATED_URL, params)\n\n    @classmethod\n    def _extract_brightcove_url(cls, webpage):\n        \"\"\"Try to extract the brightcove url from the webpage, returns None\n        if it can't be found\n        \"\"\"\n        urls = cls._extract_brightcove_urls(webpage)\n        return urls[0] if urls else None\n\n    @classmethod\n    def _extract_brightcove_urls(cls, webpage):\n        \"\"\"Return a list of all Brightcove URLs from the webpage \"\"\"\n\n        url_m = re.search(\n            r'''(?x)\n                <meta\\s+\n                    (?:property|itemprop)=([\\'\"])(?:og:video|embedURL)\\1[^>]+\n                    content=([\\'\"])(?P<url>https?://(?:secure|c)\\.brightcove.com/(?:(?!\\2).)+)\\2\n            ''', webpage)\n        if url_m:\n            url = unescapeHTML(url_m.group('url'))\n            # Some sites don't add it, we can't download with this url, for example:\n            # http://www.ktvu.com/videos/news/raw-video-caltrain-releases-video-of-man-almost/vCTZdY/\n            if 'playerKey' in url or 'videoId' in url or 'idVideo' in url:\n                return [url]\n\n        matches = re.findall(\n            r'''(?sx)<object\n            (?:\n                [^>]+?class=[\\'\"][^>]*?BrightcoveExperience.*?[\\'\"] |\n                [^>]*?>\\s*<param\\s+name=\"movie\"\\s+value=\"https?://[^/]*brightcove\\.com/\n            ).+?>\\s*</object>''',\n            webpage)\n        if matches:\n            return list(filter(None, [cls._build_brighcove_url(m) for m in matches]))\n\n        matches = re.findall(r'(customBC\\.createVideo\\(.+?\\);)', webpage)\n        if matches:\n            return list(filter(None, [\n                cls._build_brighcove_url_from_js(custom_bc)\n                for custom_bc in matches]))\n        return [src for _, src in re.findall(\n            r'<iframe[^>]+src=([\\'\"])((?:https?:)?//link\\.brightcove\\.com/services/player/(?!\\1).+)\\1', webpage)]\n\n    def _real_extract(self, url):\n        url, smuggled_data = unsmuggle_url(url, {})\n\n        # Change the 'videoId' and others field to '@videoPlayer'\n        url = re.sub(r'(?<=[?&])(videoI(d|D)|idVideo|bctid)', '%40videoPlayer', url)\n        # Change bckey (used by bcove.me urls) to playerKey\n        url = re.sub(r'(?<=[?&])bckey', 'playerKey', url)\n        mobj = re.match(self._VALID_URL, url)\n        query_str = mobj.group('query')\n        query = compat_urlparse.parse_qs(query_str)\n\n        videoPlayer = query.get('@videoPlayer')\n        if videoPlayer:\n            # We set the original url as the default 'Referer' header\n            referer = smuggled_data.get('Referer', url)\n            if 'playerID' not in query:\n                mobj = re.search(r'/bcpid(\\d+)', url)\n                if mobj is not None:\n                    query['playerID'] = [mobj.group(1)]\n            return self._get_video_info(\n                videoPlayer[0], query, referer=referer)\n        elif 'playerKey' in query:\n            player_key = query['playerKey']\n            return self._get_playlist_info(player_key[0])\n        else:\n            raise ExtractorError(\n                'Cannot find playerKey= variable. Did you forget quotes in a shell invocation?',\n                expected=True)\n\n    def _get_video_info(self, video_id, query, referer=None):\n        headers = {}\n        linkBase = query.get('linkBaseURL')\n        if linkBase is not None:\n            referer = linkBase[0]\n        if referer is not None:\n            headers['Referer'] = referer\n        webpage = self._download_webpage(self._FEDERATED_URL, video_id, headers=headers, query=query)\n\n        error_msg = self._html_search_regex(\n            r\"<h1>We're sorry.</h1>([\\s\\n]*<p>.*?</p>)+\", webpage,\n            'error message', default=None)\n        if error_msg is not None:\n            raise ExtractorError(\n                'brightcove said: %s' % error_msg, expected=True)\n\n        self.report_extraction(video_id)\n        info = self._search_regex(r'var experienceJSON = ({.*});', webpage, 'json')\n        info = json.loads(info)['data']\n        video_info = info['programmedContent']['videoPlayer']['mediaDTO']\n        video_info['_youtubedl_adServerURL'] = info.get('adServerURL')\n\n        return self._extract_video_info(video_info)\n\n    def _get_playlist_info(self, player_key):\n        info_url = 'http://c.brightcove.com/services/json/experience/runtime/?command=get_programming_for_experience&playerKey=%s' % player_key\n        playlist_info = self._download_webpage(\n            info_url, player_key, 'Downloading playlist information')\n\n        json_data = json.loads(playlist_info)\n        if 'videoList' in json_data:\n            playlist_info = json_data['videoList']\n            playlist_dto = playlist_info['mediaCollectionDTO']\n        elif 'playlistTabs' in json_data:\n            playlist_info = json_data['playlistTabs']\n            playlist_dto = playlist_info['lineupListDTO']['playlistDTOs'][0]\n        else:\n            raise ExtractorError('Empty playlist')\n\n        videos = [self._extract_video_info(video_info) for video_info in playlist_dto['videoDTOs']]\n\n        return self.playlist_result(videos, playlist_id='%s' % playlist_info['id'],\n                                    playlist_title=playlist_dto['displayName'])\n\n    def _extract_video_info(self, video_info):\n        video_id = compat_str(video_info['id'])\n        publisher_id = video_info.get('publisherId')\n        info = {\n            'id': video_id,\n            'title': video_info['displayName'].strip(),\n            'description': video_info.get('shortDescription'),\n            'thumbnail': video_info.get('videoStillURL') or video_info.get('thumbnailURL'),\n            'uploader': video_info.get('publisherName'),\n            'uploader_id': compat_str(publisher_id) if publisher_id else None,\n            'duration': float_or_none(video_info.get('length'), 1000),\n            'timestamp': int_or_none(video_info.get('creationDate'), 1000),\n        }\n\n        renditions = video_info.get('renditions', []) + video_info.get('IOSRenditions', [])\n        if renditions:\n            formats = []\n            for rend in renditions:\n                url = rend['defaultURL']\n                if not url:\n                    continue\n                ext = None\n                if rend['remote']:\n                    url_comp = compat_urllib_parse_urlparse(url)\n                    if url_comp.path.endswith('.m3u8'):\n                        formats.extend(\n                            self._extract_m3u8_formats(\n                                url, video_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False))\n                        continue\n                    elif 'akamaihd.net' in url_comp.netloc:\n                        # This type of renditions are served through\n                        # akamaihd.net, but they don't use f4m manifests\n                        url = url.replace('control/', '') + '?&v=3.3.0&fp=13&r=FEEFJ&g=RTSJIMBMPFPB'\n                        ext = 'flv'\n                if ext is None:\n                    ext = determine_ext(url)\n                tbr = int_or_none(rend.get('encodingRate'), 1000)\n                a_format = {\n                    'format_id': 'http%s' % ('-%s' % tbr if tbr else ''),\n                    'url': url,\n                    'ext': ext,\n                    'filesize': int_or_none(rend.get('size')) or None,\n                    'tbr': tbr,\n                }\n                if rend.get('audioOnly'):\n                    a_format.update({\n                        'vcodec': 'none',\n                    })\n                else:\n                    a_format.update({\n                        'height': int_or_none(rend.get('frameHeight')),\n                        'width': int_or_none(rend.get('frameWidth')),\n                        'vcodec': rend.get('videoCodec'),\n                    })\n\n                # m3u8 manifests with remote == false are media playlists\n                # Not calling _extract_m3u8_formats here to save network traffic\n                if ext == 'm3u8':\n                    a_format.update({\n                        'format_id': 'hls%s' % ('-%s' % tbr if tbr else ''),\n                        'ext': 'mp4',\n                        'protocol': 'm3u8_native',\n                    })\n\n                formats.append(a_format)\n            self._sort_formats(formats)\n            info['formats'] = formats\n        elif video_info.get('FLVFullLengthURL') is not None:\n            info.update({\n                'url': video_info['FLVFullLengthURL'],\n                'vcodec': self.FLV_VCODECS.get(video_info.get('FLVFullCodec')),\n                'filesize': int_or_none(video_info.get('FLVFullSize')),\n            })\n\n        if self._downloader.params.get('include_ads', False):\n            adServerURL = video_info.get('_youtubedl_adServerURL')\n            if adServerURL:\n                ad_info = {\n                    '_type': 'url',\n                    'url': adServerURL,\n                }\n                if 'url' in info:\n                    return {\n                        '_type': 'playlist',\n                        'title': info['title'],\n                        'entries': [ad_info, info],\n                    }\n                else:\n                    return ad_info\n\n        if 'url' not in info and not info.get('formats'):\n            raise ExtractorError('Unable to extract video url for %s' % video_id)\n        return info\n\n\nclass BrightcoveNewIE(AdobePassIE):\n    IE_NAME = 'brightcove:new'\n    _VALID_URL = r'https?://players\\.brightcove\\.net/(?P<account_id>\\d+)/(?P<player_id>[^/]+)_(?P<embed>[^/]+)/index\\.html\\?.*videoId=(?P<video_id>\\d+|ref:[^&]+)'\n    _TESTS = [{\n        'url': 'http://players.brightcove.net/929656772001/e41d32dc-ec74-459e-a845-6c69f7b724ea_default/index.html?videoId=4463358922001',\n        'md5': 'c8100925723840d4b0d243f7025703be',\n        'info_dict': {\n            'id': '4463358922001',\n            'ext': 'mp4',\n            'title': 'Meet the man behind Popcorn Time',\n            'description': 'md5:eac376a4fe366edc70279bfb681aea16',\n            'duration': 165.768,\n            'timestamp': 1441391203,\n            'upload_date': '20150904',\n            'uploader_id': '929656772001',\n            'formats': 'mincount:20',\n        },\n    }, {\n        # with rtmp streams\n        'url': 'http://players.brightcove.net/4036320279001/5d112ed9-283f-485f-a7f9-33f42e8bc042_default/index.html?videoId=4279049078001',\n        'info_dict': {\n            'id': '4279049078001',\n            'ext': 'mp4',\n            'title': 'Titansgrave: Chapter 0',\n            'description': 'Titansgrave: Chapter 0',\n            'duration': 1242.058,\n            'timestamp': 1433556729,\n            'upload_date': '20150606',\n            'uploader_id': '4036320279001',\n            'formats': 'mincount:39',\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        }\n    }, {\n        # ref: prefixed video id\n        'url': 'http://players.brightcove.net/3910869709001/21519b5c-4b3b-4363-accb-bdc8f358f823_default/index.html?videoId=ref:7069442',\n        'only_matching': True,\n    }, {\n        # non numeric ref: prefixed video id\n        'url': 'http://players.brightcove.net/710858724001/default_default/index.html?videoId=ref:event-stream-356',\n        'only_matching': True,\n    }, {\n        # unavailable video without message but with error_code\n        'url': 'http://players.brightcove.net/1305187701/c832abfb-641b-44eb-9da0-2fe76786505f_default/index.html?videoId=4377407326001',\n        'only_matching': True,\n    }]\n\n    @staticmethod\n    def _extract_url(ie, webpage):\n        urls = BrightcoveNewIE._extract_urls(ie, webpage)\n        return urls[0] if urls else None\n\n    @staticmethod\n    def _extract_urls(ie, webpage):\n        # Reference:\n        # 1. http://docs.brightcove.com/en/video-cloud/brightcove-player/guides/publish-video.html#setvideoiniframe\n        # 2. http://docs.brightcove.com/en/video-cloud/brightcove-player/guides/publish-video.html#tag\n        # 3. http://docs.brightcove.com/en/video-cloud/brightcove-player/guides/publish-video.html#setvideousingjavascript\n        # 4. http://docs.brightcove.com/en/video-cloud/brightcove-player/guides/in-page-embed-player-implementation.html\n        # 5. https://support.brightcove.com/en/video-cloud/docs/dynamically-assigning-videos-player\n\n        entries = []\n\n        # Look for iframe embeds [1]\n        for _, url in re.findall(\n                r'<iframe[^>]+src=([\"\\'])((?:https?:)?//players\\.brightcove\\.net/\\d+/[^/]+/index\\.html.+?)\\1', webpage):\n            entries.append(url if url.startswith('http') else 'http:' + url)\n\n        # Look for <video> tags [2] and embed_in_page embeds [3]\n        # [2] looks like:\n        for video, script_tag, account_id, player_id, embed in re.findall(\n                r'''(?isx)\n                    (<video\\s+[^>]*\\bdata-video-id\\s*=\\s*['\"]?[^>]+>)\n                    (?:.*?\n                        (<script[^>]+\n                            src=[\"\\'](?:https?:)?//players\\.brightcove\\.net/\n                            (\\d+)/([^/]+)_([^/]+)/index(?:\\.min)?\\.js\n                        )\n                    )?\n                ''', webpage):\n            attrs = extract_attributes(video)\n\n            # According to examples from [4] it's unclear whether video id\n            # may be optional and what to do when it is\n            video_id = attrs.get('data-video-id')\n            if not video_id:\n                continue\n\n            account_id = account_id or attrs.get('data-account')\n            if not account_id:\n                continue\n\n            player_id = player_id or attrs.get('data-player') or 'default'\n            embed = embed or attrs.get('data-embed') or 'default'\n\n            bc_url = 'http://players.brightcove.net/%s/%s_%s/index.html?videoId=%s' % (\n                account_id, player_id, embed, video_id)\n\n            # Some brightcove videos may be embedded with video tag only and\n            # without script tag or any mentioning of brightcove at all. Such\n            # embeds are considered ambiguous since they are matched based only\n            # on data-video-id and data-account attributes and in the wild may\n            # not be brightcove embeds at all. Let's check reconstructed\n            # brightcove URLs in case of such embeds and only process valid\n            # ones. By this we ensure there is indeed a brightcove embed.\n            if not script_tag and not ie._is_valid_url(\n                    bc_url, video_id, 'possible brightcove video'):\n                continue\n\n            entries.append(bc_url)\n\n        return entries\n\n    def _parse_brightcove_metadata(self, json_data, video_id, headers={}):\n        title = json_data['name'].strip()\n\n        formats = []\n        for source in json_data.get('sources', []):\n            container = source.get('container')\n            ext = mimetype2ext(source.get('type'))\n            src = source.get('src')\n            if ext == 'ism' or container == 'WVM':\n                continue\n            elif ext == 'm3u8' or container == 'M2TS':\n                if not src:\n                    continue\n                formats.extend(self._extract_m3u8_formats(\n                    src, video_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False))\n            elif ext == 'mpd':\n                if not src:\n                    continue\n                formats.extend(self._extract_mpd_formats(src, video_id, 'dash', fatal=False))\n            else:\n                streaming_src = source.get('streaming_src')\n                stream_name, app_name = source.get('stream_name'), source.get('app_name')\n                if not src and not streaming_src and (not stream_name or not app_name):\n                    continue\n                tbr = float_or_none(source.get('avg_bitrate'), 1000)\n                height = int_or_none(source.get('height'))\n                width = int_or_none(source.get('width'))\n                f = {\n                    'tbr': tbr,\n                    'filesize': int_or_none(source.get('size')),\n                    'container': container,\n                    'ext': ext or container.lower(),\n                }\n                if width == 0 and height == 0:\n                    f.update({\n                        'vcodec': 'none',\n                    })\n                else:\n                    f.update({\n                        'width': width,\n                        'height': height,\n                        'vcodec': source.get('codec'),\n                    })\n\n                def build_format_id(kind):\n                    format_id = kind\n                    if tbr:\n                        format_id += '-%dk' % int(tbr)\n                    if height:\n                        format_id += '-%dp' % height\n                    return format_id\n\n                if src or streaming_src:\n                    f.update({\n                        'url': src or streaming_src,\n                        'format_id': build_format_id('http' if src else 'http-streaming'),\n                        'source_preference': 0 if src else -1,\n                    })\n                else:\n                    f.update({\n                        'url': app_name,\n                        'play_path': stream_name,\n                        'format_id': build_format_id('rtmp'),\n                    })\n                formats.append(f)\n\n        errors = json_data.get('errors')\n        if not formats and errors:\n            error = errors[0]\n            raise ExtractorError(\n                error.get('message') or error.get('error_subcode') or error['error_code'], expected=True)\n\n        self._sort_formats(formats)\n\n        for f in formats:\n            f.setdefault('http_headers', {}).update(headers)\n\n        subtitles = {}\n        for text_track in json_data.get('text_tracks', []):\n            if text_track.get('src'):\n                subtitles.setdefault(text_track.get('srclang'), []).append({\n                    'url': text_track['src'],\n                })\n\n        is_live = False\n        duration = float_or_none(json_data.get('duration'), 1000)\n        if duration is not None and duration <= 0:\n            is_live = True\n\n        return {\n            'id': video_id,\n            'title': self._live_title(title) if is_live else title,\n            'description': clean_html(json_data.get('description')),\n            'thumbnail': json_data.get('thumbnail') or json_data.get('poster'),\n            'duration': duration,\n            'timestamp': parse_iso8601(json_data.get('published_at')),\n            'uploader_id': json_data.get('account_id'),\n            'formats': formats,\n            'subtitles': subtitles,\n            'tags': json_data.get('tags', []),\n            'is_live': is_live,\n        }\n\n    def _real_extract(self, url):\n        url, smuggled_data = unsmuggle_url(url, {})\n        self._initialize_geo_bypass(smuggled_data.get('geo_countries'))\n\n        account_id, player_id, embed, video_id = re.match(self._VALID_URL, url).groups()\n\n        webpage = self._download_webpage(\n            'http://players.brightcove.net/%s/%s_%s/index.min.js'\n            % (account_id, player_id, embed), video_id)\n\n        policy_key = None\n\n        catalog = self._search_regex(\n            r'catalog\\(({.+?})\\);', webpage, 'catalog', default=None)\n        if catalog:\n            catalog = self._parse_json(\n                js_to_json(catalog), video_id, fatal=False)\n            if catalog:\n                policy_key = catalog.get('policyKey')\n\n        if not policy_key:\n            policy_key = self._search_regex(\n                r'policyKey\\s*:\\s*([\"\\'])(?P<pk>.+?)\\1',\n                webpage, 'policy key', group='pk')\n\n        api_url = 'https://edge.api.brightcove.com/playback/v1/accounts/%s/videos/%s' % (account_id, video_id)\n        headers = {\n            'Accept': 'application/json;pk=%s' % policy_key,\n        }\n        referrer = smuggled_data.get('referrer')\n        if referrer:\n            headers.update({\n                'Referer': referrer,\n                'Origin': re.search(r'https?://[^/]+', referrer).group(0),\n            })\n        try:\n            json_data = self._download_json(api_url, video_id, headers=headers)\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError) and e.cause.code == 403:\n                json_data = self._parse_json(e.cause.read().decode(), video_id)[0]\n                message = json_data.get('message') or json_data['error_code']\n                if json_data.get('error_subcode') == 'CLIENT_GEO':\n                    self.raise_geo_restricted(msg=message)\n                raise ExtractorError(message, expected=True)\n            raise\n\n        errors = json_data.get('errors')\n        if errors and errors[0].get('error_subcode') == 'TVE_AUTH':\n            custom_fields = json_data['custom_fields']\n            tve_token = self._extract_mvpd_auth(\n                smuggled_data['source_url'], video_id,\n                custom_fields['bcadobepassrequestorid'],\n                custom_fields['bcadobepassresourceid'])\n            json_data = self._download_json(\n                api_url, video_id, headers={\n                    'Accept': 'application/json;pk=%s' % policy_key\n                }, query={\n                    'tveToken': tve_token,\n                })\n\n        return self._parse_brightcove_metadata(\n            json_data, video_id, headers=headers)\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "brightcove.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/brightcove.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}