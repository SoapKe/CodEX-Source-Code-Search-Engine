{"author": "ansible", "code": "\n\n Copyright: Ansible Project\n GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = \"\"\"\n---\nmodule: ironware_config\nversion_added: \"2.5\"\nauthor: \"Paul Baker (@paulquack)\"\nshort_description: Manage configuration sections on Brocade Ironware devices\ndescription:\n  - Brocade Ironware configurations use a simple block indent file syntax\n    for segmenting configuration into sections.  This module provides\n    an implementation for working with Ironware configuration sections in\n    a deterministic way.\nextends_documentation_fragment: ironware\noptions:\n  lines:\n    description:\n      - The ordered set of commands that should be configured in the\n        section.  The commands must be the exact same commands as found\n        in the device running-config.  Be sure to note the configuration\n        command syntax as some commands are automatically modified by the\n        device config parser.\n    aliases: ['commands']\n  parents:\n    description:\n      - The ordered set of parents that uniquely identify the section\n        the commands should be checked against.  If the parents argument\n        is omitted, the commands are checked against the set of top\n        level or global commands.\n  src:\n    description:\n      - Specifies the source path to the file that contains the configuration\n        or configuration template to load.  The path to the source file can\n        either be the full path on the Ansible control host or a relative\n        path from the playbook or role root directory.  This argument is mutually\n        exclusive with I(lines), I(parents).\n  before:\n    description:\n      - The ordered set of commands to push on to the command stack if\n        a change needs to be made.  This allows the playbook designer\n        the opportunity to perform configuration commands prior to pushing\n        any changes without affecting how the set of commands are matched\n        against the system\n  after:\n    description:\n      - The ordered set of commands to append to the end of the command\n        stack if a change needs to be made.  Just like with I(before) this\n        allows the playbook designer to append a set of commands to be\n        executed after the command set.\n  match:\n    description:\n      - Instructs the module on the way to perform the matching of\n        the set of commands against the current device config.  If\n        match is set to I(line), commands are matched line by line.  If\n        match is set to I(strict), command lines are matched with respect\n        to position.  If match is set to I(exact), command lines\n        must be an equal match.  Finally, if match is set to I(none), the\n        module will not attempt to compare the source configuration with\n        the running configuration on the remote device.\n    default: line\n    choices: ['line', 'strict', 'exact', 'none']\n  replace:\n    description:\n      - Instructs the module on the way to perform the configuration\n        on the device.  If the replace argument is set to I(line) then\n        the modified lines are pushed to the device in configuration\n        mode.  If the replace argument is set to I(block) then the entire\n        command block is pushed to the device in configuration mode if any\n        line is not correct\n    default: line\n    choices: ['line', 'block']\n  update:\n    description:\n      - The I(update) argument controls how the configuration statements\n        are processed on the remote device.  Valid choices for the I(update)\n        argument are I(merge) and I(check).  When the argument is set to\n        I(merge), the configuration changes are merged with the current\n        device running configuration.  When the argument is set to I(check)\n        the configuration updates are determined but not actually configured\n        on the remote device.\n    default: merge\n    choices: ['merge', 'check']\n  commit:\n    description:\n      - This argument specifies the update method to use when applying the\n        configuration changes to the remote node.  If the value is set to\n        I(merge) the configuration updates are merged with the running-\n        config.  If the value is set to I(check), no changes are made to\n        the remote host.\n    default: merge\n    choices: ['merge', 'check']\n  backup:\n    description:\n      - This argument will cause the module to create a full backup of\n        the current C(running-config) from the remote device before any\n        changes are made.  The backup file is written to the C(backup)\n        folder in the playbook root directory.  If the directory does not\n        exist, it is created.\n    type: bool\n    default: 'no'\n  config:\n    description:\n      - The C(config) argument allows the playbook designer to supply\n        the base configuration to be used to validate configuration\n        changes necessary.  If this argument is provided, the module\n        will not download the running-config from the remote node.\n  save_when:\n    description:\n      - When changes are made to the device running-configuration, the\n        changes are not copied to non-volatile storage by default.  Using\n        this argument will change that before.  If the argument is set to\n        I(always), then the running-config will always be copied to the\n        startup-config and the I(modified) flag will always be set to\n        True.  If the argument is set to I(modified), then the running-config\n        will only be copied to the startup-config if it has changed since\n        the last save to startup-config.  If the argument is set to\n        I(never), the running-config will never be copied to the\n        startup-config\n    default: never\n    choices: ['always', 'never', 'modified']\n    version_added: \"2.4\"\n\"\"\"\n\nEXAMPLES = \"\"\"\n- ironware_config:\n    lines:\n      - port-name test\n      - enable\n      - load-interval 30\n      - rate-limit input broadcast unknown-unicast multicast 521216 64000\n    parents: ['interface ethernet 1/2']\n\"\"\"\n\nRETURN = \"\"\"\nupdates:\n  description: The set of commands that will be pushed to the remote device\n  returned: always\n  type: list\n  sample: ['...', '...']\nbackup_path:\n  description: The full path to the backup file\n  returned: when backup is yes\n  type: string\n  sample: /playbooks/ansible/backup/ironware_config.2016-07-16@22:28:34\n\"\"\"\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.network.ironware.ironware import ironware_argument_spec, check_args\nfrom ansible.module_utils.network.ironware.ironware import get_config, load_config, run_commands\nfrom ansible.module_utils.network.common.config import NetworkConfig, dumps, ConfigLine\nfrom ansible.module_utils._text import to_native\n\n\ndef get_candidate(module):\n    candidate = NetworkConfig(indent=1)\n    if module.params['src']:\n        candidate.load(module.params['src'])\n    elif module.params['lines']:\n        parents = module.params['parents'] or list()\n        candidate.add(module.params['lines'], parents=parents)\n    return candidate\n\n\ndef run(module, result):\n    match = module.params['match']\n    replace = module.params['replace']\n    path = module.params['parents']\n    configobjs = None\n\n    candidate = get_candidate(module)\n    if match != 'none':\n        contents = module.params['config']\n        if not contents:\n            contents = get_config(module)\n        config = NetworkConfig(indent=1, contents=contents)\n        configobjs = candidate.difference(config, path=path, match=match,\n                                          replace=replace)\n\n    else:\n        configobjs = candidate.items\n    if configobjs:\n        commands = dumps(configobjs, 'commands').split('\\n')\n\n        if module.params['lines']:\n            if module.params['before']:\n                commands[:0] = module.params['before']\n\n            if module.params['after']:\n                commands.extend(module.params['after'])\n\n        result['updates'] = commands\n\n         send the configuration commands to the device and merge\n         them with the current running config\n        if not module.check_mode:\n            load_config(module, commands)\n        result['changed'] = True\n\n    if result['changed'] or module.params['save_when'] == 'always':\n        result['changed'] = True\n        if not module.check_mode:\n            cmd = {'command': 'write memory'}\n            run_commands(module, [cmd])\n\n\ndef main():\n    \"\"\" main entry point for module execution\n    \"\"\"\n    argument_spec = dict(\n        src=dict(type='path'),\n\n        lines=dict(aliases=['commands'], type='list'),\n        parents=dict(type='list'),\n\n        before=dict(type='list'),\n        after=dict(type='list'),\n\n        match=dict(default='line', choices=['line', 'strict', 'exact', 'none']),\n        replace=dict(default='line', choices=['line', 'block']),\n\n        config=dict(),\n\n        backup=dict(type='bool', default=False),\n        save_when=dict(choices=['always', 'never', 'modified'], default='never')\n\n    )\n\n    argument_spec.update(ironware_argument_spec)\n\n    mutually_exclusive = [('lines', 'src'),\n                          ('parents', 'src')]\n\n    required_if = [('match', 'strict', ['lines']),\n                   ('match', 'exact', ['lines']),\n                   ('replace', 'block', ['lines'])]\n\n    module = AnsibleModule(argument_spec=argument_spec,\n                           mutually_exclusive=mutually_exclusive,\n                           required_if=required_if,\n                           supports_check_mode=True)\n\n    result = {'changed': False}\n\n    check_args(module)\n\n    config = None\n\n    if module.params['backup']:\n        result['__backup__'] = get_config(module)\n\n    run(module, result)\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  ironware config version added   2 5  author   paul baker ( paulquack)  short description  manage configuration sections brocade ironware devices description      brocade ironware configurations use simple block indent file syntax     segmenting configuration sections   this module provides     implementation working ironware configuration sections     deterministic way  extends documentation fragment  ironware options    lines      description          the ordered set commands configured         section   the commands must exact commands found         device running config   be sure note configuration         command syntax commands automatically modified         device config parser      aliases    commands     parents      description          the ordered set parents uniquely identify section         commands checked   if parents argument         omitted  commands checked set top         level global commands    src      description          specifies source path file contains configuration         configuration template load   the path source file         either full path ansible control host relative         path playbook role root directory   this argument mutually         exclusive i(lines)  i(parents)         description          the ordered set commands push command stack         change needs made   this allows playbook designer         opportunity perform configuration commands prior pushing         changes without affecting set commands matched         system        description          the ordered set commands append end command         stack change needs made   just like i(before)         allows playbook designer append set commands         executed command set    match      description          instructs module way perform matching         set commands current device config   if         match set i(line)  commands matched line line   if         match set i(strict)  command lines matched respect         position   if match set i(exact)  command lines         must equal match   finally  match set i(none)          module attempt compare source configuration         running configuration remote device      default  line     choices    line    strict    exact    none     replace      description          instructs module way perform configuration         device   if replace argument set i(line)         modified lines pushed device configuration         mode   if replace argument set i(block) entire         command block pushed device configuration mode         line correct     default  line     choices    line    block     update      description          the i(update) argument controls configuration statements         processed remote device   valid choices i(update)         argument i(merge) i(check)   when argument set         i(merge)  configuration changes merged current         device running configuration   when argument set i(check)         configuration updates determined actually configured         remote device      default  merge     choices    merge    check     commit      description          this argument specifies update method use applying         configuration changes remote node   if value set         i(merge) configuration updates merged running          config   if value set i(check)  changes made         remote host      default  merge     choices    merge    check     backup      description          this argument cause module create full backup         current c(running config) remote device         changes made   the backup file written c(backup)         folder playbook root directory   if directory         exist  created      type  bool     default      config      description          the c(config) argument allows playbook designer supply         base configuration used validate configuration         changes necessary   if argument provided  module         download running config remote node    save      description          when changes made device running configuration          changes copied non volatile storage default   using         argument change   if argument set         i(always)  running config always copied         startup config i(modified) flag always set         true   if argument set i(modified)  running config         copied startup config changed since         last save startup config   if argument set         i(never)  running config never copied         startup config     default  never     choices    always    never    modified       version added   2 4       examples         ironware config      lines          port name test         enable         load interval 30         rate limit input broadcast unknown unicast multicast 521216 64000     parents    interface ethernet 1 2        return       updates    description  the set commands pushed remote device   returned  always   type  list   sample                 backup path    description  the full path backup file   returned  backup yes   type  string   sample   playbooks ansible backup ironware config 2016 07 16 22 28 34     ansible module utils basic import ansiblemodule ansible module utils network ironware ironware import ironware argument spec  check args ansible module utils network ironware ironware import get config  load config  run commands ansible module utils network common config import networkconfig  dumps  configline ansible module utils  text import native   def get candidate(module)      candidate   networkconfig(indent 1)     module params  src            candidate load(module params  src  )     elif module params  lines            parents   module params  parents   list()         candidate add(module params  lines    parents parents)     return candidate   def run(module  result)      match   module params  match       replace   module params  replace       path   module params  parents       configobjs   none      candidate   get candidate(module)     match     none           contents   module params  config           contents              contents   get config(module)         config   networkconfig(indent 1  contents contents)         configobjs   candidate difference(config  path path  match match                                            replace replace)      else          configobjs   candidate items     configobjs          commands   dumps(configobjs   commands ) split(  n )          module params  lines                module params                     commands  0    module params                 module params                     commands extend(module params   )          result  updates     commands            send configuration commands device merge           current running config         module check mode              load config(module  commands)         result  changed     true      result  changed   module params  save       always           result  changed     true         module check mode              cmd     command    write memory               run commands(module   cmd )   def main()          main entry point module execution             usr bin python       copyright  ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    send configuration commands device merge    current running config ", "content": "#!/usr/bin/python\n#\n# Copyright: Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = \"\"\"\n---\nmodule: ironware_config\nversion_added: \"2.5\"\nauthor: \"Paul Baker (@paulquack)\"\nshort_description: Manage configuration sections on Brocade Ironware devices\ndescription:\n  - Brocade Ironware configurations use a simple block indent file syntax\n    for segmenting configuration into sections.  This module provides\n    an implementation for working with Ironware configuration sections in\n    a deterministic way.\nextends_documentation_fragment: ironware\noptions:\n  lines:\n    description:\n      - The ordered set of commands that should be configured in the\n        section.  The commands must be the exact same commands as found\n        in the device running-config.  Be sure to note the configuration\n        command syntax as some commands are automatically modified by the\n        device config parser.\n    aliases: ['commands']\n  parents:\n    description:\n      - The ordered set of parents that uniquely identify the section\n        the commands should be checked against.  If the parents argument\n        is omitted, the commands are checked against the set of top\n        level or global commands.\n  src:\n    description:\n      - Specifies the source path to the file that contains the configuration\n        or configuration template to load.  The path to the source file can\n        either be the full path on the Ansible control host or a relative\n        path from the playbook or role root directory.  This argument is mutually\n        exclusive with I(lines), I(parents).\n  before:\n    description:\n      - The ordered set of commands to push on to the command stack if\n        a change needs to be made.  This allows the playbook designer\n        the opportunity to perform configuration commands prior to pushing\n        any changes without affecting how the set of commands are matched\n        against the system\n  after:\n    description:\n      - The ordered set of commands to append to the end of the command\n        stack if a change needs to be made.  Just like with I(before) this\n        allows the playbook designer to append a set of commands to be\n        executed after the command set.\n  match:\n    description:\n      - Instructs the module on the way to perform the matching of\n        the set of commands against the current device config.  If\n        match is set to I(line), commands are matched line by line.  If\n        match is set to I(strict), command lines are matched with respect\n        to position.  If match is set to I(exact), command lines\n        must be an equal match.  Finally, if match is set to I(none), the\n        module will not attempt to compare the source configuration with\n        the running configuration on the remote device.\n    default: line\n    choices: ['line', 'strict', 'exact', 'none']\n  replace:\n    description:\n      - Instructs the module on the way to perform the configuration\n        on the device.  If the replace argument is set to I(line) then\n        the modified lines are pushed to the device in configuration\n        mode.  If the replace argument is set to I(block) then the entire\n        command block is pushed to the device in configuration mode if any\n        line is not correct\n    default: line\n    choices: ['line', 'block']\n  update:\n    description:\n      - The I(update) argument controls how the configuration statements\n        are processed on the remote device.  Valid choices for the I(update)\n        argument are I(merge) and I(check).  When the argument is set to\n        I(merge), the configuration changes are merged with the current\n        device running configuration.  When the argument is set to I(check)\n        the configuration updates are determined but not actually configured\n        on the remote device.\n    default: merge\n    choices: ['merge', 'check']\n  commit:\n    description:\n      - This argument specifies the update method to use when applying the\n        configuration changes to the remote node.  If the value is set to\n        I(merge) the configuration updates are merged with the running-\n        config.  If the value is set to I(check), no changes are made to\n        the remote host.\n    default: merge\n    choices: ['merge', 'check']\n  backup:\n    description:\n      - This argument will cause the module to create a full backup of\n        the current C(running-config) from the remote device before any\n        changes are made.  The backup file is written to the C(backup)\n        folder in the playbook root directory.  If the directory does not\n        exist, it is created.\n    type: bool\n    default: 'no'\n  config:\n    description:\n      - The C(config) argument allows the playbook designer to supply\n        the base configuration to be used to validate configuration\n        changes necessary.  If this argument is provided, the module\n        will not download the running-config from the remote node.\n  save_when:\n    description:\n      - When changes are made to the device running-configuration, the\n        changes are not copied to non-volatile storage by default.  Using\n        this argument will change that before.  If the argument is set to\n        I(always), then the running-config will always be copied to the\n        startup-config and the I(modified) flag will always be set to\n        True.  If the argument is set to I(modified), then the running-config\n        will only be copied to the startup-config if it has changed since\n        the last save to startup-config.  If the argument is set to\n        I(never), the running-config will never be copied to the\n        startup-config\n    default: never\n    choices: ['always', 'never', 'modified']\n    version_added: \"2.4\"\n\"\"\"\n\nEXAMPLES = \"\"\"\n- ironware_config:\n    lines:\n      - port-name test\n      - enable\n      - load-interval 30\n      - rate-limit input broadcast unknown-unicast multicast 521216 64000\n    parents: ['interface ethernet 1/2']\n\"\"\"\n\nRETURN = \"\"\"\nupdates:\n  description: The set of commands that will be pushed to the remote device\n  returned: always\n  type: list\n  sample: ['...', '...']\nbackup_path:\n  description: The full path to the backup file\n  returned: when backup is yes\n  type: string\n  sample: /playbooks/ansible/backup/ironware_config.2016-07-16@22:28:34\n\"\"\"\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.network.ironware.ironware import ironware_argument_spec, check_args\nfrom ansible.module_utils.network.ironware.ironware import get_config, load_config, run_commands\nfrom ansible.module_utils.network.common.config import NetworkConfig, dumps, ConfigLine\nfrom ansible.module_utils._text import to_native\n\n\ndef get_candidate(module):\n    candidate = NetworkConfig(indent=1)\n    if module.params['src']:\n        candidate.load(module.params['src'])\n    elif module.params['lines']:\n        parents = module.params['parents'] or list()\n        candidate.add(module.params['lines'], parents=parents)\n    return candidate\n\n\ndef run(module, result):\n    match = module.params['match']\n    replace = module.params['replace']\n    path = module.params['parents']\n    configobjs = None\n\n    candidate = get_candidate(module)\n    if match != 'none':\n        contents = module.params['config']\n        if not contents:\n            contents = get_config(module)\n        config = NetworkConfig(indent=1, contents=contents)\n        configobjs = candidate.difference(config, path=path, match=match,\n                                          replace=replace)\n\n    else:\n        configobjs = candidate.items\n    if configobjs:\n        commands = dumps(configobjs, 'commands').split('\\n')\n\n        if module.params['lines']:\n            if module.params['before']:\n                commands[:0] = module.params['before']\n\n            if module.params['after']:\n                commands.extend(module.params['after'])\n\n        result['updates'] = commands\n\n        # send the configuration commands to the device and merge\n        # them with the current running config\n        if not module.check_mode:\n            load_config(module, commands)\n        result['changed'] = True\n\n    if result['changed'] or module.params['save_when'] == 'always':\n        result['changed'] = True\n        if not module.check_mode:\n            cmd = {'command': 'write memory'}\n            run_commands(module, [cmd])\n\n\ndef main():\n    \"\"\" main entry point for module execution\n    \"\"\"\n    argument_spec = dict(\n        src=dict(type='path'),\n\n        lines=dict(aliases=['commands'], type='list'),\n        parents=dict(type='list'),\n\n        before=dict(type='list'),\n        after=dict(type='list'),\n\n        match=dict(default='line', choices=['line', 'strict', 'exact', 'none']),\n        replace=dict(default='line', choices=['line', 'block']),\n\n        config=dict(),\n\n        backup=dict(type='bool', default=False),\n        save_when=dict(choices=['always', 'never', 'modified'], default='never')\n\n    )\n\n    argument_spec.update(ironware_argument_spec)\n\n    mutually_exclusive = [('lines', 'src'),\n                          ('parents', 'src')]\n\n    required_if = [('match', 'strict', ['lines']),\n                   ('match', 'exact', ['lines']),\n                   ('replace', 'block', ['lines'])]\n\n    module = AnsibleModule(argument_spec=argument_spec,\n                           mutually_exclusive=mutually_exclusive,\n                           required_if=required_if,\n                           supports_check_mode=True)\n\n    result = {'changed': False}\n\n    check_args(module)\n\n    config = None\n\n    if module.params['backup']:\n        result['__backup__'] = get_config(module)\n\n    run(module, result)\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "ironware_config.py", "id": "de1e485cd6504f7b8bcf867a137aed58", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/network/ironware/ironware_config.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}