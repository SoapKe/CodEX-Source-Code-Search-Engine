{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport datetime\nimport hashlib\nimport re\nimport time\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_b64decode,\n    compat_ord,\n    compat_str,\n    compat_urllib_parse_urlencode,\n)\nfrom ..utils import (\n    determine_ext,\n    encode_data_uri,\n    ExtractorError,\n    int_or_none,\n    orderedSet,\n    parse_iso8601,\n    str_or_none,\n    url_basename,\n    urshift,\n)\n\n\nclass LeIE(InfoExtractor):\n    IE_DESC = '\u4e50\u89c6\u7f51'\n    _VALID_URL = r'https?://(?:www\\.le\\.com/ptv/vplay|(?:sports\\.le|(?:www\\.)?lesports)\\.com/(?:match|video))/(?P<id>\\d+)\\.html'\n    _GEO_COUNTRIES = ['CN']\n    _URL_TEMPLATE = 'http://www.le.com/ptv/vplay/%s.html'\n\n    _TESTS = [{\n        'url': 'http://www.le.com/ptv/vplay/22005890.html',\n        'md5': 'edadcfe5406976f42f9f266057ee5e40',\n        'info_dict': {\n            'id': '22005890',\n            'ext': 'mp4',\n            'title': '\u7b2c87\u5c4a\u5965\u65af\u5361\u9881\u5956\u793c\u5b8c\u7f8e\u843d\u5e55 \u300a\u9e1f\u4eba\u300b\u6210\u6700\u5927\u8d62\u5bb6',\n            'description': 'md5:a9cb175fd753e2962176b7beca21a47c',\n        },\n        'params': {\n            'hls_prefer_native': True,\n        },\n    }, {\n        'url': 'http://www.le.com/ptv/vplay/1415246.html',\n        'info_dict': {\n            'id': '1415246',\n            'ext': 'mp4',\n            'title': '\u7f8e\u4eba\u5929\u4e0b01',\n            'description': 'md5:28942e650e82ed4fcc8e4de919ee854d',\n        },\n        'params': {\n            'hls_prefer_native': True,\n        },\n    }, {\n        'note': 'This video is available only in Mainland China, thus a proxy is needed',\n        'url': 'http://www.le.com/ptv/vplay/1118082.html',\n        'md5': '2424c74948a62e5f31988438979c5ad1',\n        'info_dict': {\n            'id': '1118082',\n            'ext': 'mp4',\n            'title': '\u4e0e\u9f99\u5171\u821e \u5b8c\u6574\u7248',\n            'description': 'md5:7506a5eeb1722bb9d4068f85024e3986',\n        },\n        'params': {\n            'hls_prefer_native': True,\n        },\n    }, {\n        'url': 'http://sports.le.com/video/25737697.html',\n        'only_matching': True,\n    }, {\n        'url': 'http://www.lesports.com/match/1023203003.html',\n        'only_matching': True,\n    }, {\n        'url': 'http://sports.le.com/match/1023203003.html',\n        'only_matching': True,\n    }]\n\n    \n    def ror(self, param1, param2):\n        _loc3_ = 0\n        while _loc3_ < param2:\n            param1 = urshift(param1, 1) + ((param1 & 1) << 31)\n            _loc3_ += 1\n        return param1\n\n    def calc_time_key(self, param1):\n        _loc2_ = 185025305\n        return self.ror(param1, _loc2_ % 17) ^ _loc2_\n\n    \n    @staticmethod\n    def decrypt_m3u8(encrypted_data):\n        if encrypted_data[:5].decode('utf-8').lower() != 'vc_01':\n            return encrypted_data\n        encrypted_data = encrypted_data[5:]\n\n        _loc4_ = bytearray(2 * len(encrypted_data))\n        for idx, val in enumerate(encrypted_data):\n            b = compat_ord(val)\n            _loc4_[2 * idx] = b // 16\n            _loc4_[2 * idx + 1] = b % 16\n        idx = len(_loc4_) - 11\n        _loc4_ = _loc4_[idx:] + _loc4_[:idx]\n        _loc7_ = bytearray(len(encrypted_data))\n        for i in range(len(encrypted_data)):\n            _loc7_[i] = _loc4_[2 * i] * 16 + _loc4_[2 * i + 1]\n\n        return bytes(_loc7_)\n\n    def _check_errors(self, play_json):\n        \n        playstatus = play_json['msgs']['playstatus']\n        if playstatus['status'] == 0:\n            flag = playstatus['flag']\n            if flag == 1:\n                self.raise_geo_restricted()\n            else:\n                raise ExtractorError('Generic error. flag = %d' % flag, expected=True)\n\n    def _real_extract(self, url):\n        media_id = self._match_id(url)\n        page = self._download_webpage(url, media_id)\n\n        play_json_flash = self._download_json(\n            'http://player-pc.le.com/mms/out/video/playJson',\n            media_id, 'Downloading flash playJson data', query={\n                'id': media_id,\n                'platid': 1,\n                'splatid': 101,\n                'format': 1,\n                'source': 1000,\n                'tkey': self.calc_time_key(int(time.time())),\n                'domain': 'www.le.com',\n                'region': 'cn',\n            },\n            headers=self.geo_verification_headers())\n        self._check_errors(play_json_flash)\n\n        def get_flash_urls(media_url, format_id):\n            nodes_data = self._download_json(\n                media_url, media_id,\n                'Download JSON metadata for format %s' % format_id,\n                query={\n                    'm3v': 1,\n                    'format': 1,\n                    'expect': 3,\n                    'tss': 'ios',\n                })\n\n            req = self._request_webpage(\n                nodes_data['nodelist'][0]['location'], media_id,\n                note='Downloading m3u8 information for format %s' % format_id)\n\n            m3u8_data = self.decrypt_m3u8(req.read())\n\n            return {\n                'hls': encode_data_uri(m3u8_data, 'application/vnd.apple.mpegurl'),\n            }\n\n        extracted_formats = []\n        formats = []\n        playurl = play_json_flash['msgs']['playurl']\n        play_domain = playurl['domain'][0]\n\n        for format_id, format_data in playurl.get('dispatch', []).items():\n            if format_id in extracted_formats:\n                continue\n            extracted_formats.append(format_id)\n\n            media_url = play_domain + format_data[0]\n            for protocol, format_url in get_flash_urls(media_url, format_id).items():\n                f = {\n                    'url': format_url,\n                    'ext': determine_ext(format_data[1]),\n                    'format_id': '%s-%s' % (protocol, format_id),\n                    'protocol': 'm3u8_native' if protocol == 'hls' else 'http',\n                    'quality': int_or_none(format_id),\n                }\n\n                if format_id[-1:] == 'p':\n                    f['height'] = int_or_none(format_id[:-1])\n\n                formats.append(f)\n        self._sort_formats(formats, ('height', 'quality', 'format_id'))\n\n        publish_time = parse_iso8601(self._html_search_regex(\n            r'\u53d1\u5e03\u65f6\u95f4&nbsp;([^<>]+) ', page, 'publish time', default=None),\n            delimiter=' ', timezone=datetime.timedelta(hours=8))\n        description = self._html_search_meta('description', page, fatal=False)\n\n        return {\n            'id': media_id,\n            'formats': formats,\n            'title': playurl['title'],\n            'thumbnail': playurl['pic'],\n            'description': description,\n            'timestamp': publish_time,\n        }\n\n\nclass LePlaylistIE(InfoExtractor):\n    _VALID_URL = r'https?://[a-z]+\\.le\\.com/(?!video)[a-z]+/(?P<id>[a-z0-9_]+)'\n\n    _TESTS = [{\n        'url': 'http://www.le.com/tv/46177.html',\n        'info_dict': {\n            'id': '46177',\n            'title': '\u7f8e\u4eba\u5929\u4e0b',\n            'description': 'md5:395666ff41b44080396e59570dbac01c'\n        },\n        'playlist_count': 35\n    }, {\n        'url': 'http://tv.le.com/izt/wuzetian/index.html',\n        'info_dict': {\n            'id': 'wuzetian',\n            'title': '\u6b66\u5a9a\u5a18\u4f20\u5947',\n            'description': 'md5:e12499475ab3d50219e5bba00b3cb248'\n        },\n        \n        'playlist_mincount': 96\n    }, {\n        'url': 'http://tv.le.com/pzt/lswjzzjc/index.shtml',\n        \n        'only_matching': True,\n    }, {\n        'url': 'http://www.le.com/comic/92063.html',\n        'only_matching': True,\n    }, {\n        'url': 'http://list.le.com/listn/c1009_sc532002_d2_p1_o1.html',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if LeIE.suitable(url) else super(LePlaylistIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        playlist_id = self._match_id(url)\n        page = self._download_webpage(url, playlist_id)\n\n        \n        media_ids = orderedSet(re.findall(\n            r'<a[^>]+href=\"http://www\\.letv\\.com/ptv/vplay/(\\d+)\\.html', page))\n        entries = [self.url_result(LeIE._URL_TEMPLATE % media_id, ie='Le')\n                   for media_id in media_ids]\n\n        title = self._html_search_meta('keywords', page,\n                                       fatal=False).split('\uff0c')[0]\n        description = self._html_search_meta('description', page, fatal=False)\n\n        return self.playlist_result(entries, playlist_id, playlist_title=title,\n                                    playlist_description=description)\n\n\nclass LetvCloudIE(InfoExtractor):\n    \n    \n    IE_DESC = '\u4e50\u89c6\u4e91'\n    _VALID_URL = r'https?://yuntv\\.letv\\.com/bcloud.html\\?.+'\n\n    _TESTS = [{\n        'url': 'http://yuntv.letv.com/bcloud.html?uu=p7jnfw5hw9&vu=467623dedf',\n        'md5': '26450599afd64c513bc77030ad15db44',\n        'info_dict': {\n            'id': 'p7jnfw5hw9_467623dedf',\n            'ext': 'mp4',\n            'title': 'Video p7jnfw5hw9_467623dedf',\n        },\n    }, {\n        'url': 'http://yuntv.letv.com/bcloud.html?uu=p7jnfw5hw9&vu=ec93197892&pu=2c7cd40209&auto_play=1&gpcflag=1&width=640&height=360',\n        'md5': 'e03d9cc8d9c13191e1caf277e42dbd31',\n        'info_dict': {\n            'id': 'p7jnfw5hw9_ec93197892',\n            'ext': 'mp4',\n            'title': 'Video p7jnfw5hw9_ec93197892',\n        },\n    }, {\n        'url': 'http://yuntv.letv.com/bcloud.html?uu=p7jnfw5hw9&vu=187060b6fd',\n        'md5': 'cb988699a776b22d4a41b9d43acfb3ac',\n        'info_dict': {\n            'id': 'p7jnfw5hw9_187060b6fd',\n            'ext': 'mp4',\n            'title': 'Video p7jnfw5hw9_187060b6fd',\n        },\n    }]\n\n    @staticmethod\n    def sign_data(obj):\n        if obj['cf'] == 'flash':\n            salt = '2f9d6924b33a165a6d8b5d3d42f4f987'\n            items = ['cf', 'format', 'ran', 'uu', 'ver', 'vu']\n        elif obj['cf'] == 'html5':\n            salt = 'fbeh5player12c43eccf2bec3300344'\n            items = ['cf', 'ran', 'uu', 'bver', 'vu']\n        input_data = ''.join([item + obj[item] for item in items]) + salt\n        obj['sign'] = hashlib.md5(input_data.encode('utf-8')).hexdigest()\n\n    def _get_formats(self, cf, uu, vu, media_id):\n        def get_play_json(cf, timestamp):\n            data = {\n                'cf': cf,\n                'ver': '2.2',\n                'bver': 'firefox44.0',\n                'format': 'json',\n                'uu': uu,\n                'vu': vu,\n                'ran': compat_str(timestamp),\n            }\n            self.sign_data(data)\n            return self._download_json(\n                'http://api.letvcloud.com/gpc.php?' + compat_urllib_parse_urlencode(data),\n                media_id, 'Downloading playJson data for type %s' % cf)\n\n        play_json = get_play_json(cf, time.time())\n        \n        if play_json.get('code') == 10071:\n            play_json = get_play_json(cf, play_json['timestamp'])\n\n        if not play_json.get('data'):\n            if play_json.get('message'):\n                raise ExtractorError('Letv cloud said: %s' % play_json['message'], expected=True)\n            elif play_json.get('code'):\n                raise ExtractorError('Letv cloud returned error %d' % play_json['code'], expected=True)\n            else:\n                raise ExtractorError('Letv cloud returned an unknwon error')\n\n        def b64decode(s):\n            return compat_b64decode(s).decode('utf-8')\n\n        formats = []\n        for media in play_json['data']['video_info']['media'].values():\n            play_url = media['play_url']\n            url = b64decode(play_url['main_url'])\n            decoded_url = b64decode(url_basename(url))\n            formats.append({\n                'url': url,\n                'ext': determine_ext(decoded_url),\n                'format_id': str_or_none(play_url.get('vtype')),\n                'format_note': str_or_none(play_url.get('definition')),\n                'width': int_or_none(play_url.get('vwidth')),\n                'height': int_or_none(play_url.get('vheight')),\n            })\n\n        return formats\n\n    def _real_extract(self, url):\n        uu_mobj = re.search(r'uu=([\\w]+)', url)\n        vu_mobj = re.search(r'vu=([\\w]+)', url)\n\n        if not uu_mobj or not vu_mobj:\n            raise ExtractorError('Invalid URL: %s' % url, expected=True)\n\n        uu = uu_mobj.group(1)\n        vu = vu_mobj.group(1)\n        media_id = uu + '_' + vu\n\n        formats = self._get_formats('flash', uu, vu, media_id) + self._get_formats('html5', uu, vu, media_id)\n        self._sort_formats(formats)\n\n        return {\n            'id': media_id,\n            'title': 'Video %s' % media_id,\n            'formats': formats,\n        }\n", "comments": "# coding: utf-8\n# ror() and calc_time_key() are reversed from a embedded swf file in LetvPlayer.swf\n# see M3U8Encryption class in KLetvPlayer.swf\n# Check for errors\n# This playlist contains some extra videos other than the drama itself\n# This series is moved to http://www.le.com/tv/10005297.html\n# Currently old domain names are still used in playlists\n# Most of *.letv.com is changed to *.le.com on 2016/01/02\n# but yuntv.letv.com is kept, so also keep the extractor name\n# The server time may be different from local time\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport datetime\nimport hashlib\nimport re\nimport time\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_b64decode,\n    compat_ord,\n    compat_str,\n    compat_urllib_parse_urlencode,\n)\nfrom ..utils import (\n    determine_ext,\n    encode_data_uri,\n    ExtractorError,\n    int_or_none,\n    orderedSet,\n    parse_iso8601,\n    str_or_none,\n    url_basename,\n    urshift,\n)\n\n\nclass LeIE(InfoExtractor):\n    IE_DESC = '\u4e50\u89c6\u7f51'\n    _VALID_URL = r'https?://(?:www\\.le\\.com/ptv/vplay|(?:sports\\.le|(?:www\\.)?lesports)\\.com/(?:match|video))/(?P<id>\\d+)\\.html'\n    _GEO_COUNTRIES = ['CN']\n    _URL_TEMPLATE = 'http://www.le.com/ptv/vplay/%s.html'\n\n    _TESTS = [{\n        'url': 'http://www.le.com/ptv/vplay/22005890.html',\n        'md5': 'edadcfe5406976f42f9f266057ee5e40',\n        'info_dict': {\n            'id': '22005890',\n            'ext': 'mp4',\n            'title': '\u7b2c87\u5c4a\u5965\u65af\u5361\u9881\u5956\u793c\u5b8c\u7f8e\u843d\u5e55 \u300a\u9e1f\u4eba\u300b\u6210\u6700\u5927\u8d62\u5bb6',\n            'description': 'md5:a9cb175fd753e2962176b7beca21a47c',\n        },\n        'params': {\n            'hls_prefer_native': True,\n        },\n    }, {\n        'url': 'http://www.le.com/ptv/vplay/1415246.html',\n        'info_dict': {\n            'id': '1415246',\n            'ext': 'mp4',\n            'title': '\u7f8e\u4eba\u5929\u4e0b01',\n            'description': 'md5:28942e650e82ed4fcc8e4de919ee854d',\n        },\n        'params': {\n            'hls_prefer_native': True,\n        },\n    }, {\n        'note': 'This video is available only in Mainland China, thus a proxy is needed',\n        'url': 'http://www.le.com/ptv/vplay/1118082.html',\n        'md5': '2424c74948a62e5f31988438979c5ad1',\n        'info_dict': {\n            'id': '1118082',\n            'ext': 'mp4',\n            'title': '\u4e0e\u9f99\u5171\u821e \u5b8c\u6574\u7248',\n            'description': 'md5:7506a5eeb1722bb9d4068f85024e3986',\n        },\n        'params': {\n            'hls_prefer_native': True,\n        },\n    }, {\n        'url': 'http://sports.le.com/video/25737697.html',\n        'only_matching': True,\n    }, {\n        'url': 'http://www.lesports.com/match/1023203003.html',\n        'only_matching': True,\n    }, {\n        'url': 'http://sports.le.com/match/1023203003.html',\n        'only_matching': True,\n    }]\n\n    # ror() and calc_time_key() are reversed from a embedded swf file in LetvPlayer.swf\n    def ror(self, param1, param2):\n        _loc3_ = 0\n        while _loc3_ < param2:\n            param1 = urshift(param1, 1) + ((param1 & 1) << 31)\n            _loc3_ += 1\n        return param1\n\n    def calc_time_key(self, param1):\n        _loc2_ = 185025305\n        return self.ror(param1, _loc2_ % 17) ^ _loc2_\n\n    # see M3U8Encryption class in KLetvPlayer.swf\n    @staticmethod\n    def decrypt_m3u8(encrypted_data):\n        if encrypted_data[:5].decode('utf-8').lower() != 'vc_01':\n            return encrypted_data\n        encrypted_data = encrypted_data[5:]\n\n        _loc4_ = bytearray(2 * len(encrypted_data))\n        for idx, val in enumerate(encrypted_data):\n            b = compat_ord(val)\n            _loc4_[2 * idx] = b // 16\n            _loc4_[2 * idx + 1] = b % 16\n        idx = len(_loc4_) - 11\n        _loc4_ = _loc4_[idx:] + _loc4_[:idx]\n        _loc7_ = bytearray(len(encrypted_data))\n        for i in range(len(encrypted_data)):\n            _loc7_[i] = _loc4_[2 * i] * 16 + _loc4_[2 * i + 1]\n\n        return bytes(_loc7_)\n\n    def _check_errors(self, play_json):\n        # Check for errors\n        playstatus = play_json['msgs']['playstatus']\n        if playstatus['status'] == 0:\n            flag = playstatus['flag']\n            if flag == 1:\n                self.raise_geo_restricted()\n            else:\n                raise ExtractorError('Generic error. flag = %d' % flag, expected=True)\n\n    def _real_extract(self, url):\n        media_id = self._match_id(url)\n        page = self._download_webpage(url, media_id)\n\n        play_json_flash = self._download_json(\n            'http://player-pc.le.com/mms/out/video/playJson',\n            media_id, 'Downloading flash playJson data', query={\n                'id': media_id,\n                'platid': 1,\n                'splatid': 101,\n                'format': 1,\n                'source': 1000,\n                'tkey': self.calc_time_key(int(time.time())),\n                'domain': 'www.le.com',\n                'region': 'cn',\n            },\n            headers=self.geo_verification_headers())\n        self._check_errors(play_json_flash)\n\n        def get_flash_urls(media_url, format_id):\n            nodes_data = self._download_json(\n                media_url, media_id,\n                'Download JSON metadata for format %s' % format_id,\n                query={\n                    'm3v': 1,\n                    'format': 1,\n                    'expect': 3,\n                    'tss': 'ios',\n                })\n\n            req = self._request_webpage(\n                nodes_data['nodelist'][0]['location'], media_id,\n                note='Downloading m3u8 information for format %s' % format_id)\n\n            m3u8_data = self.decrypt_m3u8(req.read())\n\n            return {\n                'hls': encode_data_uri(m3u8_data, 'application/vnd.apple.mpegurl'),\n            }\n\n        extracted_formats = []\n        formats = []\n        playurl = play_json_flash['msgs']['playurl']\n        play_domain = playurl['domain'][0]\n\n        for format_id, format_data in playurl.get('dispatch', []).items():\n            if format_id in extracted_formats:\n                continue\n            extracted_formats.append(format_id)\n\n            media_url = play_domain + format_data[0]\n            for protocol, format_url in get_flash_urls(media_url, format_id).items():\n                f = {\n                    'url': format_url,\n                    'ext': determine_ext(format_data[1]),\n                    'format_id': '%s-%s' % (protocol, format_id),\n                    'protocol': 'm3u8_native' if protocol == 'hls' else 'http',\n                    'quality': int_or_none(format_id),\n                }\n\n                if format_id[-1:] == 'p':\n                    f['height'] = int_or_none(format_id[:-1])\n\n                formats.append(f)\n        self._sort_formats(formats, ('height', 'quality', 'format_id'))\n\n        publish_time = parse_iso8601(self._html_search_regex(\n            r'\u53d1\u5e03\u65f6\u95f4&nbsp;([^<>]+) ', page, 'publish time', default=None),\n            delimiter=' ', timezone=datetime.timedelta(hours=8))\n        description = self._html_search_meta('description', page, fatal=False)\n\n        return {\n            'id': media_id,\n            'formats': formats,\n            'title': playurl['title'],\n            'thumbnail': playurl['pic'],\n            'description': description,\n            'timestamp': publish_time,\n        }\n\n\nclass LePlaylistIE(InfoExtractor):\n    _VALID_URL = r'https?://[a-z]+\\.le\\.com/(?!video)[a-z]+/(?P<id>[a-z0-9_]+)'\n\n    _TESTS = [{\n        'url': 'http://www.le.com/tv/46177.html',\n        'info_dict': {\n            'id': '46177',\n            'title': '\u7f8e\u4eba\u5929\u4e0b',\n            'description': 'md5:395666ff41b44080396e59570dbac01c'\n        },\n        'playlist_count': 35\n    }, {\n        'url': 'http://tv.le.com/izt/wuzetian/index.html',\n        'info_dict': {\n            'id': 'wuzetian',\n            'title': '\u6b66\u5a9a\u5a18\u4f20\u5947',\n            'description': 'md5:e12499475ab3d50219e5bba00b3cb248'\n        },\n        # This playlist contains some extra videos other than the drama itself\n        'playlist_mincount': 96\n    }, {\n        'url': 'http://tv.le.com/pzt/lswjzzjc/index.shtml',\n        # This series is moved to http://www.le.com/tv/10005297.html\n        'only_matching': True,\n    }, {\n        'url': 'http://www.le.com/comic/92063.html',\n        'only_matching': True,\n    }, {\n        'url': 'http://list.le.com/listn/c1009_sc532002_d2_p1_o1.html',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if LeIE.suitable(url) else super(LePlaylistIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        playlist_id = self._match_id(url)\n        page = self._download_webpage(url, playlist_id)\n\n        # Currently old domain names are still used in playlists\n        media_ids = orderedSet(re.findall(\n            r'<a[^>]+href=\"http://www\\.letv\\.com/ptv/vplay/(\\d+)\\.html', page))\n        entries = [self.url_result(LeIE._URL_TEMPLATE % media_id, ie='Le')\n                   for media_id in media_ids]\n\n        title = self._html_search_meta('keywords', page,\n                                       fatal=False).split('\uff0c')[0]\n        description = self._html_search_meta('description', page, fatal=False)\n\n        return self.playlist_result(entries, playlist_id, playlist_title=title,\n                                    playlist_description=description)\n\n\nclass LetvCloudIE(InfoExtractor):\n    # Most of *.letv.com is changed to *.le.com on 2016/01/02\n    # but yuntv.letv.com is kept, so also keep the extractor name\n    IE_DESC = '\u4e50\u89c6\u4e91'\n    _VALID_URL = r'https?://yuntv\\.letv\\.com/bcloud.html\\?.+'\n\n    _TESTS = [{\n        'url': 'http://yuntv.letv.com/bcloud.html?uu=p7jnfw5hw9&vu=467623dedf',\n        'md5': '26450599afd64c513bc77030ad15db44',\n        'info_dict': {\n            'id': 'p7jnfw5hw9_467623dedf',\n            'ext': 'mp4',\n            'title': 'Video p7jnfw5hw9_467623dedf',\n        },\n    }, {\n        'url': 'http://yuntv.letv.com/bcloud.html?uu=p7jnfw5hw9&vu=ec93197892&pu=2c7cd40209&auto_play=1&gpcflag=1&width=640&height=360',\n        'md5': 'e03d9cc8d9c13191e1caf277e42dbd31',\n        'info_dict': {\n            'id': 'p7jnfw5hw9_ec93197892',\n            'ext': 'mp4',\n            'title': 'Video p7jnfw5hw9_ec93197892',\n        },\n    }, {\n        'url': 'http://yuntv.letv.com/bcloud.html?uu=p7jnfw5hw9&vu=187060b6fd',\n        'md5': 'cb988699a776b22d4a41b9d43acfb3ac',\n        'info_dict': {\n            'id': 'p7jnfw5hw9_187060b6fd',\n            'ext': 'mp4',\n            'title': 'Video p7jnfw5hw9_187060b6fd',\n        },\n    }]\n\n    @staticmethod\n    def sign_data(obj):\n        if obj['cf'] == 'flash':\n            salt = '2f9d6924b33a165a6d8b5d3d42f4f987'\n            items = ['cf', 'format', 'ran', 'uu', 'ver', 'vu']\n        elif obj['cf'] == 'html5':\n            salt = 'fbeh5player12c43eccf2bec3300344'\n            items = ['cf', 'ran', 'uu', 'bver', 'vu']\n        input_data = ''.join([item + obj[item] for item in items]) + salt\n        obj['sign'] = hashlib.md5(input_data.encode('utf-8')).hexdigest()\n\n    def _get_formats(self, cf, uu, vu, media_id):\n        def get_play_json(cf, timestamp):\n            data = {\n                'cf': cf,\n                'ver': '2.2',\n                'bver': 'firefox44.0',\n                'format': 'json',\n                'uu': uu,\n                'vu': vu,\n                'ran': compat_str(timestamp),\n            }\n            self.sign_data(data)\n            return self._download_json(\n                'http://api.letvcloud.com/gpc.php?' + compat_urllib_parse_urlencode(data),\n                media_id, 'Downloading playJson data for type %s' % cf)\n\n        play_json = get_play_json(cf, time.time())\n        # The server time may be different from local time\n        if play_json.get('code') == 10071:\n            play_json = get_play_json(cf, play_json['timestamp'])\n\n        if not play_json.get('data'):\n            if play_json.get('message'):\n                raise ExtractorError('Letv cloud said: %s' % play_json['message'], expected=True)\n            elif play_json.get('code'):\n                raise ExtractorError('Letv cloud returned error %d' % play_json['code'], expected=True)\n            else:\n                raise ExtractorError('Letv cloud returned an unknwon error')\n\n        def b64decode(s):\n            return compat_b64decode(s).decode('utf-8')\n\n        formats = []\n        for media in play_json['data']['video_info']['media'].values():\n            play_url = media['play_url']\n            url = b64decode(play_url['main_url'])\n            decoded_url = b64decode(url_basename(url))\n            formats.append({\n                'url': url,\n                'ext': determine_ext(decoded_url),\n                'format_id': str_or_none(play_url.get('vtype')),\n                'format_note': str_or_none(play_url.get('definition')),\n                'width': int_or_none(play_url.get('vwidth')),\n                'height': int_or_none(play_url.get('vheight')),\n            })\n\n        return formats\n\n    def _real_extract(self, url):\n        uu_mobj = re.search(r'uu=([\\w]+)', url)\n        vu_mobj = re.search(r'vu=([\\w]+)', url)\n\n        if not uu_mobj or not vu_mobj:\n            raise ExtractorError('Invalid URL: %s' % url, expected=True)\n\n        uu = uu_mobj.group(1)\n        vu = vu_mobj.group(1)\n        media_id = uu + '_' + vu\n\n        formats = self._get_formats('flash', uu, vu, media_id) + self._get_formats('html5', uu, vu, media_id)\n        self._sort_formats(formats)\n\n        return {\n            'id': media_id,\n            'title': 'Video %s' % media_id,\n            'formats': formats,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "leeco.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/leeco.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}