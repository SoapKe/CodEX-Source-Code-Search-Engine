{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport hashlib\nimport itertools\nimport re\nimport time\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_urllib_parse_urlencode,\n)\nfrom ..utils import (\n    clean_html,\n    decode_packed_codes,\n    get_element_by_id,\n    get_element_by_attribute,\n    ExtractorError,\n    ohdave_rsa_encrypt,\n    remove_start,\n)\n\n\ndef md5_text(text):\n    return hashlib.md5(text.encode('utf-8')).hexdigest()\n\n\nclass IqiyiSDK(object):\n    def __init__(self, target, ip, timestamp):\n        self.target = target\n        self.ip = ip\n        self.timestamp = timestamp\n\n    @staticmethod\n    def split_sum(data):\n        return compat_str(sum(map(lambda p: int(p, 16), list(data))))\n\n    @staticmethod\n    def digit_sum(num):\n        if isinstance(num, int):\n            num = compat_str(num)\n        return compat_str(sum(map(int, num)))\n\n    def even_odd(self):\n        even = self.digit_sum(compat_str(self.timestamp)[::2])\n        odd = self.digit_sum(compat_str(self.timestamp)[1::2])\n        return even, odd\n\n    def preprocess(self, chunksize):\n        self.target = md5_text(self.target)\n        chunks = []\n        for i in range(32 // chunksize):\n            chunks.append(self.target[chunksize * i:chunksize * (i + 1)])\n        if 32 % chunksize:\n            chunks.append(self.target[32 - 32 % chunksize:])\n        return chunks, list(map(int, self.ip.split('.')))\n\n    def mod(self, modulus):\n        chunks, ip = self.preprocess(32)\n        self.target = chunks[0] + ''.join(map(lambda p: compat_str(p % modulus), ip))\n\n    def split(self, chunksize):\n        modulus_map = {\n            4: 256,\n            5: 10,\n            8: 100,\n        }\n\n        chunks, ip = self.preprocess(chunksize)\n        ret = ''\n        for i in range(len(chunks)):\n            ip_part = compat_str(ip[i] % modulus_map[chunksize]) if i < 4 else ''\n            if chunksize == 8:\n                ret += ip_part + chunks[i]\n            else:\n                ret += chunks[i] + ip_part\n        self.target = ret\n\n    def handle_input16(self):\n        self.target = md5_text(self.target)\n        self.target = self.split_sum(self.target[:16]) + self.target + self.split_sum(self.target[16:])\n\n    def handle_input8(self):\n        self.target = md5_text(self.target)\n        ret = ''\n        for i in range(4):\n            part = self.target[8 * i:8 * (i + 1)]\n            ret += self.split_sum(part) + part\n        self.target = ret\n\n    def handleSum(self):\n        self.target = md5_text(self.target)\n        self.target = self.split_sum(self.target) + self.target\n\n    def date(self, scheme):\n        self.target = md5_text(self.target)\n        d = time.localtime(self.timestamp)\n        strings = {\n            'y': compat_str(d.tm_year),\n            'm': '%02d' % d.tm_mon,\n            'd': '%02d' % d.tm_mday,\n        }\n        self.target += ''.join(map(lambda c: strings[c], list(scheme)))\n\n    def split_time_even_odd(self):\n        even, odd = self.even_odd()\n        self.target = odd + md5_text(self.target) + even\n\n    def split_time_odd_even(self):\n        even, odd = self.even_odd()\n        self.target = even + md5_text(self.target) + odd\n\n    def split_ip_time_sum(self):\n        chunks, ip = self.preprocess(32)\n        self.target = compat_str(sum(ip)) + chunks[0] + self.digit_sum(self.timestamp)\n\n    def split_time_ip_sum(self):\n        chunks, ip = self.preprocess(32)\n        self.target = self.digit_sum(self.timestamp) + chunks[0] + compat_str(sum(ip))\n\n\nclass IqiyiSDKInterpreter(object):\n    def __init__(self, sdk_code):\n        self.sdk_code = sdk_code\n\n    def run(self, target, ip, timestamp):\n        self.sdk_code = decode_packed_codes(self.sdk_code)\n\n        functions = re.findall(r'input=([a-zA-Z0-9]+)\\(input', self.sdk_code)\n\n        sdk = IqiyiSDK(target, ip, timestamp)\n\n        other_functions = {\n            'handleSum': sdk.handleSum,\n            'handleInput8': sdk.handle_input8,\n            'handleInput16': sdk.handle_input16,\n            'splitTimeEvenOdd': sdk.split_time_even_odd,\n            'splitTimeOddEven': sdk.split_time_odd_even,\n            'splitIpTimeSum': sdk.split_ip_time_sum,\n            'splitTimeIpSum': sdk.split_time_ip_sum,\n        }\n        for function in functions:\n            if re.match(r'mod\\d+', function):\n                sdk.mod(int(function[3:]))\n            elif re.match(r'date[ymd]{3}', function):\n                sdk.date(function[4:])\n            elif re.match(r'split\\d+', function):\n                sdk.split(int(function[5:]))\n            elif function in other_functions:\n                other_functions[function]()\n            else:\n                raise ExtractorError('Unknown funcion %s' % function)\n\n        return sdk.target\n\n\nclass IqiyiIE(InfoExtractor):\n    IE_NAME = 'iqiyi'\n    IE_DESC = '\u7231\u5947\u827a'\n\n    _VALID_URL = r'https?://(?:(?:[^.]+\\.)?iqiyi\\.com|www\\.pps\\.tv)/.+\\.html'\n\n    _NETRC_MACHINE = 'iqiyi'\n\n    _TESTS = [{\n        'url': 'http://www.iqiyi.com/v_19rrojlavg.html',\n        \n        'info_dict': {\n            'id': '9c1fb1b99d192b21c559e5a1a2cb3c73',\n            'ext': 'mp4',\n            'title': '\u7f8e\u56fd\u5fb7\u5dde\u7a7a\u4e2d\u60ca\u73b0\u5947\u5f02\u4e91\u56e2 \u9177\u4f3cUFO',\n        }\n    }, {\n        'url': 'http://www.iqiyi.com/v_19rrhnnclk.html',\n        'md5': 'b7dc800a4004b1b57749d9abae0472da',\n        'info_dict': {\n            'id': 'e3f585b550a280af23c98b6cb2be19fb',\n            'ext': 'mp4',\n            \n            'title': r're:^(?:\u540d\u4fa6\u63a2\u67ef\u5357 \u56fd\u8bed\u7248\uff1a\u7b2c752\u96c6 \u8feb\u8fd1\u7070\u539f\u79d8\u5bc6\u7684\u9ed1\u5f71 \u4e0b\u7bc7|\u540d\u5075\u63a2\u67ef\u5357 \u570b\u8a9e\u7248\uff1a\u7b2c752\u96c6 \u8feb\u8fd1\u7070\u539f\u79d8\u5bc6\u7684\u9ed1\u5f71 \u4e0b\u7bc7)$',\n        },\n        'skip': 'Geo-restricted to China',\n    }, {\n        'url': 'http://www.iqiyi.com/w_19rt6o8t9p.html',\n        'only_matching': True,\n    }, {\n        'url': 'http://www.iqiyi.com/a_19rrhbc6kt.html',\n        'only_matching': True,\n    }, {\n        'url': 'http://yule.iqiyi.com/pcb.html',\n        'info_dict': {\n            'id': '4a0af228fddb55ec96398a364248ed7f',\n            'ext': 'mp4',\n            'title': '\u7b2c2017-04-21\u671f \u5973\u827a\u4eba\u9891\u906d\u6781\u7aef\u7c89\u4e1d\u9a9a\u6270',\n        },\n    }, {\n        \n        \n        'url': 'http://www.iqiyi.com/v_19rrny4w8w.html',\n        'info_dict': {\n            'id': 'f3cf468b39dddb30d676f89a91200dc1',\n            'ext': 'mp4',\n            'title': '\u6cf0\u5766\u5c3c\u514b\u53f7',\n        },\n        'skip': 'Geo-restricted to China',\n    }, {\n        'url': 'http://www.iqiyi.com/a_19rrhb8ce1.html',\n        'info_dict': {\n            'id': '202918101',\n            'title': '\u704c\u7bee\u9ad8\u624b \u56fd\u8bed\u7248',\n        },\n        'playlist_count': 101,\n    }, {\n        'url': 'http://www.pps.tv/w_19rrbav0ph.html',\n        'only_matching': True,\n    }]\n\n    _FORMATS_MAP = {\n        '96': 1,    \n        '1': 2,     \n        '2': 3,     \n        '21': 4,    \n        '4': 5,     \n        '17': 5,    \n        '5': 6,     \n        '18': 7,    \n    }\n\n    def _real_initialize(self):\n        self._login()\n\n    @staticmethod\n    def _rsa_fun(data):\n        \n        N = 0xab86b6371b5318aaa1d3c9e612a9f1264f372323c8c0f19875b5fc3b3fd3afcc1e5bec527aa94bfa85bffc157e4245aebda05389a5357b75115ac94f074aefcd\n        e = 65537\n\n        return ohdave_rsa_encrypt(data, e, N)\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n\n        \n        if not username:\n            return True\n\n        data = self._download_json(\n            'http://kylin.iqiyi.com/get_token', None,\n            note='Get token for logging', errnote='Unable to get token for logging')\n        sdk = data['sdk']\n        timestamp = int(time.time())\n        target = '/apis/reglogin/login.action?lang=zh_TW&area_code=null&email=%s&passwd=%s&agenttype=1&from=undefined&keeplogin=0&piccode=&fromurl=&_pos=1' % (\n            username, self._rsa_fun(password.encode('utf-8')))\n\n        interp = IqiyiSDKInterpreter(sdk)\n        sign = interp.run(target, data['ip'], timestamp)\n\n        validation_params = {\n            'target': target,\n            'server': 'BEA3AA1908656AABCCFF76582C4C6660',\n            'token': data['token'],\n            'bird_src': 'f8d91d57af224da7893dd397d52d811a',\n            'sign': sign,\n            'bird_t': timestamp,\n        }\n        validation_result = self._download_json(\n            'http://kylin.iqiyi.com/validate?' + compat_urllib_parse_urlencode(validation_params), None,\n            note='Validate credentials', errnote='Unable to validate credentials')\n\n        MSG_MAP = {\n            'P00107': 'please login via the web interface and enter the CAPTCHA code',\n            'P00117': 'bad username or password',\n        }\n\n        code = validation_result['code']\n        if code != 'A00000':\n            msg = MSG_MAP.get(code)\n            if not msg:\n                msg = 'error %s' % code\n                if validation_result.get('msg'):\n                    msg += ': ' + validation_result['msg']\n            self._downloader.report_warning('unable to log in: ' + msg)\n            return False\n\n        return True\n\n    def get_raw_data(self, tvid, video_id):\n        tm = int(time.time() * 1000)\n\n        key = 'd5fb4bd9d50c4be6948c97edd7254b0e'\n        sc = md5_text(compat_str(tm) + key + tvid)\n        params = {\n            'tvid': tvid,\n            'vid': video_id,\n            'src': '76f90cbd92f94a2e925d83e8ccd22cb7',\n            'sc': sc,\n            't': tm,\n        }\n\n        return self._download_json(\n            'http://cache.m.iqiyi.com/jp/tmts/%s/%s/' % (tvid, video_id),\n            video_id, transform_source=lambda s: remove_start(s, 'var tvInfoJs='),\n            query=params, headers=self.geo_verification_headers())\n\n    def _extract_playlist(self, webpage):\n        PAGE_SIZE = 50\n\n        links = re.findall(\n            r'<a[^>]+class=\"site-piclist_pic_link\"[^>]+href=\"(http://www\\.iqiyi\\.com/.+\\.html)\"',\n            webpage)\n        if not links:\n            return\n\n        album_id = self._search_regex(\n            r'albumId\\s*:\\s*(\\d+),', webpage, 'album ID')\n        album_title = self._search_regex(\n            r'data-share-title=\"([^\"]+)\"', webpage, 'album title', fatal=False)\n\n        entries = list(map(self.url_result, links))\n\n        \n        for page_num in itertools.count(2):\n            pagelist_page = self._download_webpage(\n                'http://cache.video.qiyi.com/jp/avlist/%s/%d/%d/' % (album_id, page_num, PAGE_SIZE),\n                album_id,\n                note='Download playlist page %d' % page_num,\n                errnote='Failed to download playlist page %d' % page_num)\n            pagelist = self._parse_json(\n                remove_start(pagelist_page, 'var tvInfoJs='), album_id)\n            vlist = pagelist['data']['vlist']\n            for item in vlist:\n                entries.append(self.url_result(item['vurl']))\n            if len(vlist) < PAGE_SIZE:\n                break\n\n        return self.playlist_result(entries, album_id, album_title)\n\n    def _real_extract(self, url):\n        webpage = self._download_webpage(\n            url, 'temp_id', note='download video page')\n\n        \n        \n        \n        tvid = self._search_regex(\n            r'data-(?:player|shareplattrigger)-tvid\\s*=\\s*[\\'\"](\\d+)', webpage, 'tvid', default=None)\n        if tvid is None:\n            playlist_result = self._extract_playlist(webpage)\n            if playlist_result:\n                return playlist_result\n            raise ExtractorError('Can\\'t find any video')\n\n        video_id = self._search_regex(\n            r'data-(?:player|shareplattrigger)-videoid\\s*=\\s*[\\'\"]([a-f\\d]+)', webpage, 'video_id')\n\n        formats = []\n        for _ in range(5):\n            raw_data = self.get_raw_data(tvid, video_id)\n\n            if raw_data['code'] != 'A00000':\n                if raw_data['code'] == 'A00111':\n                    self.raise_geo_restricted()\n                raise ExtractorError('Unable to load data. Error code: ' + raw_data['code'])\n\n            data = raw_data['data']\n\n            for stream in data['vidl']:\n                if 'm3utx' not in stream:\n                    continue\n                vd = compat_str(stream['vd'])\n                formats.append({\n                    'url': stream['m3utx'],\n                    'format_id': vd,\n                    'ext': 'mp4',\n                    'preference': self._FORMATS_MAP.get(vd, -1),\n                    'protocol': 'm3u8_native',\n                })\n\n            if formats:\n                break\n\n            self._sleep(5, video_id)\n\n        self._sort_formats(formats)\n        title = (get_element_by_id('widget-videotitle', webpage) or\n                 clean_html(get_element_by_attribute('class', 'mod-play-tit', webpage)) or\n                 self._html_search_regex(r'<span[^>]+data-videochanged-title=\"word\"[^>]*>([^<]+)</span>', webpage, 'title'))\n\n        return {\n            'id': video_id,\n            'title': title,\n            'formats': formats,\n        }\n", "comments": "# coding: utf-8\n# MD5 checksum differs on my machine and Travis CI\n# This can be either Simplified Chinese or Traditional Chinese\n# VIP-only video. The first 2 parts (6 minutes) are available without login\n# MD5 sums omitted as values are different on Travis CI and my machine\n# 216p, 240p\n# 336p, 360p\n# 480p, 504p\n# 504p\n# 720p\n# 720p\n# 1072p, 1080p\n# 1080p\n# public key extracted from http://static.iqiyi.com/js/qiyiV2/20160129180840/jobs/i18n/i18nIndex.js\n# No authentication to be performed\n# Start from 2 because links in the first page are already on webpage\n# There's no simple way to determine whether an URL is a playlist or not\n# Sometimes there are playlist links in individual videos, so treat it\n# as a single video first\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport hashlib\nimport itertools\nimport re\nimport time\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_urllib_parse_urlencode,\n)\nfrom ..utils import (\n    clean_html,\n    decode_packed_codes,\n    get_element_by_id,\n    get_element_by_attribute,\n    ExtractorError,\n    ohdave_rsa_encrypt,\n    remove_start,\n)\n\n\ndef md5_text(text):\n    return hashlib.md5(text.encode('utf-8')).hexdigest()\n\n\nclass IqiyiSDK(object):\n    def __init__(self, target, ip, timestamp):\n        self.target = target\n        self.ip = ip\n        self.timestamp = timestamp\n\n    @staticmethod\n    def split_sum(data):\n        return compat_str(sum(map(lambda p: int(p, 16), list(data))))\n\n    @staticmethod\n    def digit_sum(num):\n        if isinstance(num, int):\n            num = compat_str(num)\n        return compat_str(sum(map(int, num)))\n\n    def even_odd(self):\n        even = self.digit_sum(compat_str(self.timestamp)[::2])\n        odd = self.digit_sum(compat_str(self.timestamp)[1::2])\n        return even, odd\n\n    def preprocess(self, chunksize):\n        self.target = md5_text(self.target)\n        chunks = []\n        for i in range(32 // chunksize):\n            chunks.append(self.target[chunksize * i:chunksize * (i + 1)])\n        if 32 % chunksize:\n            chunks.append(self.target[32 - 32 % chunksize:])\n        return chunks, list(map(int, self.ip.split('.')))\n\n    def mod(self, modulus):\n        chunks, ip = self.preprocess(32)\n        self.target = chunks[0] + ''.join(map(lambda p: compat_str(p % modulus), ip))\n\n    def split(self, chunksize):\n        modulus_map = {\n            4: 256,\n            5: 10,\n            8: 100,\n        }\n\n        chunks, ip = self.preprocess(chunksize)\n        ret = ''\n        for i in range(len(chunks)):\n            ip_part = compat_str(ip[i] % modulus_map[chunksize]) if i < 4 else ''\n            if chunksize == 8:\n                ret += ip_part + chunks[i]\n            else:\n                ret += chunks[i] + ip_part\n        self.target = ret\n\n    def handle_input16(self):\n        self.target = md5_text(self.target)\n        self.target = self.split_sum(self.target[:16]) + self.target + self.split_sum(self.target[16:])\n\n    def handle_input8(self):\n        self.target = md5_text(self.target)\n        ret = ''\n        for i in range(4):\n            part = self.target[8 * i:8 * (i + 1)]\n            ret += self.split_sum(part) + part\n        self.target = ret\n\n    def handleSum(self):\n        self.target = md5_text(self.target)\n        self.target = self.split_sum(self.target) + self.target\n\n    def date(self, scheme):\n        self.target = md5_text(self.target)\n        d = time.localtime(self.timestamp)\n        strings = {\n            'y': compat_str(d.tm_year),\n            'm': '%02d' % d.tm_mon,\n            'd': '%02d' % d.tm_mday,\n        }\n        self.target += ''.join(map(lambda c: strings[c], list(scheme)))\n\n    def split_time_even_odd(self):\n        even, odd = self.even_odd()\n        self.target = odd + md5_text(self.target) + even\n\n    def split_time_odd_even(self):\n        even, odd = self.even_odd()\n        self.target = even + md5_text(self.target) + odd\n\n    def split_ip_time_sum(self):\n        chunks, ip = self.preprocess(32)\n        self.target = compat_str(sum(ip)) + chunks[0] + self.digit_sum(self.timestamp)\n\n    def split_time_ip_sum(self):\n        chunks, ip = self.preprocess(32)\n        self.target = self.digit_sum(self.timestamp) + chunks[0] + compat_str(sum(ip))\n\n\nclass IqiyiSDKInterpreter(object):\n    def __init__(self, sdk_code):\n        self.sdk_code = sdk_code\n\n    def run(self, target, ip, timestamp):\n        self.sdk_code = decode_packed_codes(self.sdk_code)\n\n        functions = re.findall(r'input=([a-zA-Z0-9]+)\\(input', self.sdk_code)\n\n        sdk = IqiyiSDK(target, ip, timestamp)\n\n        other_functions = {\n            'handleSum': sdk.handleSum,\n            'handleInput8': sdk.handle_input8,\n            'handleInput16': sdk.handle_input16,\n            'splitTimeEvenOdd': sdk.split_time_even_odd,\n            'splitTimeOddEven': sdk.split_time_odd_even,\n            'splitIpTimeSum': sdk.split_ip_time_sum,\n            'splitTimeIpSum': sdk.split_time_ip_sum,\n        }\n        for function in functions:\n            if re.match(r'mod\\d+', function):\n                sdk.mod(int(function[3:]))\n            elif re.match(r'date[ymd]{3}', function):\n                sdk.date(function[4:])\n            elif re.match(r'split\\d+', function):\n                sdk.split(int(function[5:]))\n            elif function in other_functions:\n                other_functions[function]()\n            else:\n                raise ExtractorError('Unknown funcion %s' % function)\n\n        return sdk.target\n\n\nclass IqiyiIE(InfoExtractor):\n    IE_NAME = 'iqiyi'\n    IE_DESC = '\u7231\u5947\u827a'\n\n    _VALID_URL = r'https?://(?:(?:[^.]+\\.)?iqiyi\\.com|www\\.pps\\.tv)/.+\\.html'\n\n    _NETRC_MACHINE = 'iqiyi'\n\n    _TESTS = [{\n        'url': 'http://www.iqiyi.com/v_19rrojlavg.html',\n        # MD5 checksum differs on my machine and Travis CI\n        'info_dict': {\n            'id': '9c1fb1b99d192b21c559e5a1a2cb3c73',\n            'ext': 'mp4',\n            'title': '\u7f8e\u56fd\u5fb7\u5dde\u7a7a\u4e2d\u60ca\u73b0\u5947\u5f02\u4e91\u56e2 \u9177\u4f3cUFO',\n        }\n    }, {\n        'url': 'http://www.iqiyi.com/v_19rrhnnclk.html',\n        'md5': 'b7dc800a4004b1b57749d9abae0472da',\n        'info_dict': {\n            'id': 'e3f585b550a280af23c98b6cb2be19fb',\n            'ext': 'mp4',\n            # This can be either Simplified Chinese or Traditional Chinese\n            'title': r're:^(?:\u540d\u4fa6\u63a2\u67ef\u5357 \u56fd\u8bed\u7248\uff1a\u7b2c752\u96c6 \u8feb\u8fd1\u7070\u539f\u79d8\u5bc6\u7684\u9ed1\u5f71 \u4e0b\u7bc7|\u540d\u5075\u63a2\u67ef\u5357 \u570b\u8a9e\u7248\uff1a\u7b2c752\u96c6 \u8feb\u8fd1\u7070\u539f\u79d8\u5bc6\u7684\u9ed1\u5f71 \u4e0b\u7bc7)$',\n        },\n        'skip': 'Geo-restricted to China',\n    }, {\n        'url': 'http://www.iqiyi.com/w_19rt6o8t9p.html',\n        'only_matching': True,\n    }, {\n        'url': 'http://www.iqiyi.com/a_19rrhbc6kt.html',\n        'only_matching': True,\n    }, {\n        'url': 'http://yule.iqiyi.com/pcb.html',\n        'info_dict': {\n            'id': '4a0af228fddb55ec96398a364248ed7f',\n            'ext': 'mp4',\n            'title': '\u7b2c2017-04-21\u671f \u5973\u827a\u4eba\u9891\u906d\u6781\u7aef\u7c89\u4e1d\u9a9a\u6270',\n        },\n    }, {\n        # VIP-only video. The first 2 parts (6 minutes) are available without login\n        # MD5 sums omitted as values are different on Travis CI and my machine\n        'url': 'http://www.iqiyi.com/v_19rrny4w8w.html',\n        'info_dict': {\n            'id': 'f3cf468b39dddb30d676f89a91200dc1',\n            'ext': 'mp4',\n            'title': '\u6cf0\u5766\u5c3c\u514b\u53f7',\n        },\n        'skip': 'Geo-restricted to China',\n    }, {\n        'url': 'http://www.iqiyi.com/a_19rrhb8ce1.html',\n        'info_dict': {\n            'id': '202918101',\n            'title': '\u704c\u7bee\u9ad8\u624b \u56fd\u8bed\u7248',\n        },\n        'playlist_count': 101,\n    }, {\n        'url': 'http://www.pps.tv/w_19rrbav0ph.html',\n        'only_matching': True,\n    }]\n\n    _FORMATS_MAP = {\n        '96': 1,    # 216p, 240p\n        '1': 2,     # 336p, 360p\n        '2': 3,     # 480p, 504p\n        '21': 4,    # 504p\n        '4': 5,     # 720p\n        '17': 5,    # 720p\n        '5': 6,     # 1072p, 1080p\n        '18': 7,    # 1080p\n    }\n\n    def _real_initialize(self):\n        self._login()\n\n    @staticmethod\n    def _rsa_fun(data):\n        # public key extracted from http://static.iqiyi.com/js/qiyiV2/20160129180840/jobs/i18n/i18nIndex.js\n        N = 0xab86b6371b5318aaa1d3c9e612a9f1264f372323c8c0f19875b5fc3b3fd3afcc1e5bec527aa94bfa85bffc157e4245aebda05389a5357b75115ac94f074aefcd\n        e = 65537\n\n        return ohdave_rsa_encrypt(data, e, N)\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n\n        # No authentication to be performed\n        if not username:\n            return True\n\n        data = self._download_json(\n            'http://kylin.iqiyi.com/get_token', None,\n            note='Get token for logging', errnote='Unable to get token for logging')\n        sdk = data['sdk']\n        timestamp = int(time.time())\n        target = '/apis/reglogin/login.action?lang=zh_TW&area_code=null&email=%s&passwd=%s&agenttype=1&from=undefined&keeplogin=0&piccode=&fromurl=&_pos=1' % (\n            username, self._rsa_fun(password.encode('utf-8')))\n\n        interp = IqiyiSDKInterpreter(sdk)\n        sign = interp.run(target, data['ip'], timestamp)\n\n        validation_params = {\n            'target': target,\n            'server': 'BEA3AA1908656AABCCFF76582C4C6660',\n            'token': data['token'],\n            'bird_src': 'f8d91d57af224da7893dd397d52d811a',\n            'sign': sign,\n            'bird_t': timestamp,\n        }\n        validation_result = self._download_json(\n            'http://kylin.iqiyi.com/validate?' + compat_urllib_parse_urlencode(validation_params), None,\n            note='Validate credentials', errnote='Unable to validate credentials')\n\n        MSG_MAP = {\n            'P00107': 'please login via the web interface and enter the CAPTCHA code',\n            'P00117': 'bad username or password',\n        }\n\n        code = validation_result['code']\n        if code != 'A00000':\n            msg = MSG_MAP.get(code)\n            if not msg:\n                msg = 'error %s' % code\n                if validation_result.get('msg'):\n                    msg += ': ' + validation_result['msg']\n            self._downloader.report_warning('unable to log in: ' + msg)\n            return False\n\n        return True\n\n    def get_raw_data(self, tvid, video_id):\n        tm = int(time.time() * 1000)\n\n        key = 'd5fb4bd9d50c4be6948c97edd7254b0e'\n        sc = md5_text(compat_str(tm) + key + tvid)\n        params = {\n            'tvid': tvid,\n            'vid': video_id,\n            'src': '76f90cbd92f94a2e925d83e8ccd22cb7',\n            'sc': sc,\n            't': tm,\n        }\n\n        return self._download_json(\n            'http://cache.m.iqiyi.com/jp/tmts/%s/%s/' % (tvid, video_id),\n            video_id, transform_source=lambda s: remove_start(s, 'var tvInfoJs='),\n            query=params, headers=self.geo_verification_headers())\n\n    def _extract_playlist(self, webpage):\n        PAGE_SIZE = 50\n\n        links = re.findall(\n            r'<a[^>]+class=\"site-piclist_pic_link\"[^>]+href=\"(http://www\\.iqiyi\\.com/.+\\.html)\"',\n            webpage)\n        if not links:\n            return\n\n        album_id = self._search_regex(\n            r'albumId\\s*:\\s*(\\d+),', webpage, 'album ID')\n        album_title = self._search_regex(\n            r'data-share-title=\"([^\"]+)\"', webpage, 'album title', fatal=False)\n\n        entries = list(map(self.url_result, links))\n\n        # Start from 2 because links in the first page are already on webpage\n        for page_num in itertools.count(2):\n            pagelist_page = self._download_webpage(\n                'http://cache.video.qiyi.com/jp/avlist/%s/%d/%d/' % (album_id, page_num, PAGE_SIZE),\n                album_id,\n                note='Download playlist page %d' % page_num,\n                errnote='Failed to download playlist page %d' % page_num)\n            pagelist = self._parse_json(\n                remove_start(pagelist_page, 'var tvInfoJs='), album_id)\n            vlist = pagelist['data']['vlist']\n            for item in vlist:\n                entries.append(self.url_result(item['vurl']))\n            if len(vlist) < PAGE_SIZE:\n                break\n\n        return self.playlist_result(entries, album_id, album_title)\n\n    def _real_extract(self, url):\n        webpage = self._download_webpage(\n            url, 'temp_id', note='download video page')\n\n        # There's no simple way to determine whether an URL is a playlist or not\n        # Sometimes there are playlist links in individual videos, so treat it\n        # as a single video first\n        tvid = self._search_regex(\n            r'data-(?:player|shareplattrigger)-tvid\\s*=\\s*[\\'\"](\\d+)', webpage, 'tvid', default=None)\n        if tvid is None:\n            playlist_result = self._extract_playlist(webpage)\n            if playlist_result:\n                return playlist_result\n            raise ExtractorError('Can\\'t find any video')\n\n        video_id = self._search_regex(\n            r'data-(?:player|shareplattrigger)-videoid\\s*=\\s*[\\'\"]([a-f\\d]+)', webpage, 'video_id')\n\n        formats = []\n        for _ in range(5):\n            raw_data = self.get_raw_data(tvid, video_id)\n\n            if raw_data['code'] != 'A00000':\n                if raw_data['code'] == 'A00111':\n                    self.raise_geo_restricted()\n                raise ExtractorError('Unable to load data. Error code: ' + raw_data['code'])\n\n            data = raw_data['data']\n\n            for stream in data['vidl']:\n                if 'm3utx' not in stream:\n                    continue\n                vd = compat_str(stream['vd'])\n                formats.append({\n                    'url': stream['m3utx'],\n                    'format_id': vd,\n                    'ext': 'mp4',\n                    'preference': self._FORMATS_MAP.get(vd, -1),\n                    'protocol': 'm3u8_native',\n                })\n\n            if formats:\n                break\n\n            self._sleep(5, video_id)\n\n        self._sort_formats(formats)\n        title = (get_element_by_id('widget-videotitle', webpage) or\n                 clean_html(get_element_by_attribute('class', 'mod-play-tit', webpage)) or\n                 self._html_search_regex(r'<span[^>]+data-videochanged-title=\"word\"[^>]*>([^<]+)</span>', webpage, 'title'))\n\n        return {\n            'id': video_id,\n            'title': title,\n            'formats': formats,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "iqiyi.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/iqiyi.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}