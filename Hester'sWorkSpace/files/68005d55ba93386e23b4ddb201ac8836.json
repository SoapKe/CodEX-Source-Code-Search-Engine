{"author": "deepfakes", "code": "\n\nimport cv2\nimport numpy\n\nfrom lib.aligner import get_align_mat\n\nclass Convert():\n    def __init__(self, encoder, trainer, blur_size=2, seamless_clone=False, mask_type=\"facehullandrect\", erosion_kernel_size=None, match_histogram=False, sharpen_image=None, **kwargs):\n        self.encoder = encoder\n        self.trainer = trainer\n        self.erosion_kernel = None\n        self.erosion_kernel_size = erosion_kernel_size\n        if erosion_kernel_size is not None:\n            if erosion_kernel_size > 0:\n                self.erosion_kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(erosion_kernel_size,erosion_kernel_size))\n            elif erosion_kernel_size < 0:\n                self.erosion_kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(abs(erosion_kernel_size),abs(erosion_kernel_size)))\n        self.blur_size = blur_size\n        self.seamless_clone = seamless_clone\n        self.sharpen_image = sharpen_image\n        self.match_histogram = match_histogram\n        self.mask_type = mask_type.lower() \n\n    def patch_image( self, image, face_detected, size ):\n\n        image_size = image.shape[1], image.shape[0]\n\n        mat = numpy.array(get_align_mat(face_detected, size, should_align_eyes=False)).reshape(2,3)\n\n        if \"GAN\" not in self.trainer:\n            mat = mat * size\n        else:\n            padding = int(48/256*size)\n            mat = mat * (size - 2 * padding)\n            mat[:,2] += padding\n\n        new_face = self.get_new_face(image,mat,size)\n\n        image_mask = self.get_image_mask( image, new_face, face_detected.landmarksAsXY(), mat, image_size )\n\n        return self.apply_new_face(image, new_face, image_mask, mat, image_size, size)\n\n    def apply_new_face(self, image, new_face, image_mask, mat, image_size, size):\n        base_image = numpy.copy( image )\n        new_image = numpy.copy( image )\n\n        cv2.warpAffine( new_face, mat, image_size, new_image, cv2.WARP_INVERSE_MAP | cv2.INTER_CUBIC, cv2.BORDER_TRANSPARENT )\n        \n        if \"bsharpen\" in self.sharpen_image:\n            \n            kernel = numpy.ones((3, 3)) * (-1)\n            kernel[1, 1] = 9\n            new_image = cv2.filter2D(new_image, -1, kernel)\n        elif \"gsharpen\" in self.sharpen_image:\n            \n            gaussain_blur = cv2.GaussianBlur(new_image, (0, 0), 3.0)\n            new_image = cv2.addWeighted(\n                new_image, 1.5, gaussain_blur, -0.5, 0, new_image)\n        elif \"none\" in self.sharpen_image:\n            pass\n\n        outimage = None\n        if self.seamless_clone:\n            unitMask = numpy.clip( image_mask * 365, 0, 255 ).astype(numpy.uint8)\n\n            maxregion = numpy.argwhere(unitMask==255)\n\n            if maxregion.size > 0:\n              miny,minx = maxregion.min(axis=0)[:2]\n              maxy,maxx = maxregion.max(axis=0)[:2]\n              lenx = maxx - minx;\n              leny = maxy - miny;\n              masky = int(minx+(lenx//2))\n              maskx = int(miny+(leny//2))\n              outimage = cv2.seamlessClone(new_image.astype(numpy.uint8),base_image.astype(numpy.uint8),unitMask,(masky,maskx) , cv2.NORMAL_CLONE )\n\n              return outimage\n\n        foreground = cv2.multiply(image_mask, new_image.astype(float))\n        background = cv2.multiply(1.0 - image_mask, base_image.astype(float))\n        outimage = cv2.add(foreground, background)\n\n        return outimage\n\n    def hist_match(self, source, template, mask=None):\n        \n        \n        masked_source = source\n        masked_template = template\n\n        if mask is not None:\n            masked_source = source * mask\n            masked_template = template * mask\n\n        oldshape = source.shape\n        source = source.ravel()\n        template = template.ravel()\n        masked_source = masked_source.ravel()\n        masked_template = masked_template.ravel()\n        s_values, bin_idx, s_counts = numpy.unique(source, return_inverse=True,\n                                                return_counts=True)\n        t_values, t_counts = numpy.unique(template, return_counts=True)\n        ms_values, mbin_idx, ms_counts = numpy.unique(source, return_inverse=True,\n                                                return_counts=True)\n        mt_values, mt_counts = numpy.unique(template, return_counts=True)\n\n        s_quantiles = numpy.cumsum(s_counts).astype(numpy.float64)\n        s_quantiles /= s_quantiles[-1]\n        t_quantiles = numpy.cumsum(t_counts).astype(numpy.float64)\n        t_quantiles /= t_quantiles[-1]\n        interp_t_values = numpy.interp(s_quantiles, t_quantiles, t_values)\n\n        return interp_t_values[bin_idx].reshape(oldshape)\n\n    def color_hist_match(self, src_im, tar_im, mask):\n        matched_R = self.hist_match(src_im[:,:,0], tar_im[:,:,0], mask)\n        matched_G = self.hist_match(src_im[:,:,1], tar_im[:,:,1], mask)\n        matched_B = self.hist_match(src_im[:,:,2], tar_im[:,:,2], mask)\n        matched = numpy.stack((matched_R, matched_G, matched_B), axis=2).astype(src_im.dtype)\n        return matched\n\n    def get_new_face(self, image, mat, size):\n        face = cv2.warpAffine( image, mat, (size,size) )\n        face = numpy.expand_dims( face, 0 )\n        face_clipped = numpy.clip(face[0], 0, 255).astype( image.dtype )\n        new_face = None\n        mask = None\n\n        if \"GAN\" not in self.trainer:\n            normalized_face = face / 255.0\n            new_face = self.encoder(normalized_face)[0]\n            new_face = numpy.clip( new_face * 255, 0, 255 ).astype( image.dtype )\n        else:\n            normalized_face = face / 255.0 * 2 - 1\n            fake_output = self.encoder(normalized_face)\n            if \"128\" in self.trainer: \n                fake_output = fake_output[0]\n            mask = fake_output[:,:,:, :1]\n            new_face = fake_output[:,:,:, 1:]\n            new_face = mask * new_face + (1 - mask) * normalized_face\n            new_face = numpy.clip((new_face[0] + 1) * 255 / 2, 0, 255).astype( image.dtype )\n\n        if self.match_histogram:\n            new_face = self.color_hist_match(new_face, face_clipped, mask)\n\n        return new_face\n\n    def get_image_mask(self, image, new_face, landmarks, mat, image_size):\n\n        face_mask = numpy.zeros(image.shape,dtype=float)\n        if 'rect' in self.mask_type:\n            face_src = numpy.ones(new_face.shape,dtype=float)\n            cv2.warpAffine( face_src, mat, image_size, face_mask, cv2.WARP_INVERSE_MAP | cv2.INTER_CUBIC, cv2.BORDER_TRANSPARENT )\n\n        hull_mask = numpy.zeros(image.shape,dtype=float)\n        if 'hull' in self.mask_type:\n            hull = cv2.convexHull( numpy.array( landmarks ).reshape((-1,2)).astype(int) ).flatten().reshape( (-1,2) )\n            cv2.fillConvexPoly( hull_mask,hull,(1,1,1) )\n\n        if self.mask_type == 'rect':\n            image_mask = face_mask\n        elif self.mask_type == 'facehull':\n            image_mask = hull_mask\n        else:\n            image_mask = ((face_mask*hull_mask))\n\n\n        if self.erosion_kernel is not None:\n            if self.erosion_kernel_size > 0:\n                image_mask = cv2.erode(image_mask,self.erosion_kernel,iterations = 1)\n            elif self.erosion_kernel_size < 0:\n                dilation_kernel = abs(self.erosion_kernel)\n                image_mask = cv2.dilate(image_mask,dilation_kernel,iterations = 1)\n\n        if self.blur_size!=0:\n            image_mask = cv2.blur(image_mask,(self.blur_size,self.blur_size))\n\n        return image_mask\n", "comments": "  based  https   gist github com anonymous d3815aba83a8f79779451262599b0955 found https   www reddit com r deepfakes     choose  facehullandrect   facehull   rect     sharpening using filter2d    sharpening using weighted method    code borrowed     https   stackoverflow com questions 32655686 histogram matching two images python 2 x    todo  another hack switch 64 128 ", "content": "# Based on: https://gist.github.com/anonymous/d3815aba83a8f79779451262599b0955 found on https://www.reddit.com/r/deepfakes/\n\nimport cv2\nimport numpy\n\nfrom lib.aligner import get_align_mat\n\nclass Convert():\n    def __init__(self, encoder, trainer, blur_size=2, seamless_clone=False, mask_type=\"facehullandrect\", erosion_kernel_size=None, match_histogram=False, sharpen_image=None, **kwargs):\n        self.encoder = encoder\n        self.trainer = trainer\n        self.erosion_kernel = None\n        self.erosion_kernel_size = erosion_kernel_size\n        if erosion_kernel_size is not None:\n            if erosion_kernel_size > 0:\n                self.erosion_kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(erosion_kernel_size,erosion_kernel_size))\n            elif erosion_kernel_size < 0:\n                self.erosion_kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(abs(erosion_kernel_size),abs(erosion_kernel_size)))\n        self.blur_size = blur_size\n        self.seamless_clone = seamless_clone\n        self.sharpen_image = sharpen_image\n        self.match_histogram = match_histogram\n        self.mask_type = mask_type.lower() # Choose in 'FaceHullAndRect','FaceHull','Rect'\n\n    def patch_image( self, image, face_detected, size ):\n\n        image_size = image.shape[1], image.shape[0]\n\n        mat = numpy.array(get_align_mat(face_detected, size, should_align_eyes=False)).reshape(2,3)\n\n        if \"GAN\" not in self.trainer:\n            mat = mat * size\n        else:\n            padding = int(48/256*size)\n            mat = mat * (size - 2 * padding)\n            mat[:,2] += padding\n\n        new_face = self.get_new_face(image,mat,size)\n\n        image_mask = self.get_image_mask( image, new_face, face_detected.landmarksAsXY(), mat, image_size )\n\n        return self.apply_new_face(image, new_face, image_mask, mat, image_size, size)\n\n    def apply_new_face(self, image, new_face, image_mask, mat, image_size, size):\n        base_image = numpy.copy( image )\n        new_image = numpy.copy( image )\n\n        cv2.warpAffine( new_face, mat, image_size, new_image, cv2.WARP_INVERSE_MAP | cv2.INTER_CUBIC, cv2.BORDER_TRANSPARENT )\n        \n        if \"bsharpen\" in self.sharpen_image:\n            # Sharpening using filter2D\n            kernel = numpy.ones((3, 3)) * (-1)\n            kernel[1, 1] = 9\n            new_image = cv2.filter2D(new_image, -1, kernel)\n        elif \"gsharpen\" in self.sharpen_image:\n            # Sharpening using Weighted Method\n            gaussain_blur = cv2.GaussianBlur(new_image, (0, 0), 3.0)\n            new_image = cv2.addWeighted(\n                new_image, 1.5, gaussain_blur, -0.5, 0, new_image)\n        elif \"none\" in self.sharpen_image:\n            pass\n\n        outimage = None\n        if self.seamless_clone:\n            unitMask = numpy.clip( image_mask * 365, 0, 255 ).astype(numpy.uint8)\n\n            maxregion = numpy.argwhere(unitMask==255)\n\n            if maxregion.size > 0:\n              miny,minx = maxregion.min(axis=0)[:2]\n              maxy,maxx = maxregion.max(axis=0)[:2]\n              lenx = maxx - minx;\n              leny = maxy - miny;\n              masky = int(minx+(lenx//2))\n              maskx = int(miny+(leny//2))\n              outimage = cv2.seamlessClone(new_image.astype(numpy.uint8),base_image.astype(numpy.uint8),unitMask,(masky,maskx) , cv2.NORMAL_CLONE )\n\n              return outimage\n\n        foreground = cv2.multiply(image_mask, new_image.astype(float))\n        background = cv2.multiply(1.0 - image_mask, base_image.astype(float))\n        outimage = cv2.add(foreground, background)\n\n        return outimage\n\n    def hist_match(self, source, template, mask=None):\n        # Code borrowed from:\n        # https://stackoverflow.com/questions/32655686/histogram-matching-of-two-images-in-python-2-x\n        masked_source = source\n        masked_template = template\n\n        if mask is not None:\n            masked_source = source * mask\n            masked_template = template * mask\n\n        oldshape = source.shape\n        source = source.ravel()\n        template = template.ravel()\n        masked_source = masked_source.ravel()\n        masked_template = masked_template.ravel()\n        s_values, bin_idx, s_counts = numpy.unique(source, return_inverse=True,\n                                                return_counts=True)\n        t_values, t_counts = numpy.unique(template, return_counts=True)\n        ms_values, mbin_idx, ms_counts = numpy.unique(source, return_inverse=True,\n                                                return_counts=True)\n        mt_values, mt_counts = numpy.unique(template, return_counts=True)\n\n        s_quantiles = numpy.cumsum(s_counts).astype(numpy.float64)\n        s_quantiles /= s_quantiles[-1]\n        t_quantiles = numpy.cumsum(t_counts).astype(numpy.float64)\n        t_quantiles /= t_quantiles[-1]\n        interp_t_values = numpy.interp(s_quantiles, t_quantiles, t_values)\n\n        return interp_t_values[bin_idx].reshape(oldshape)\n\n    def color_hist_match(self, src_im, tar_im, mask):\n        matched_R = self.hist_match(src_im[:,:,0], tar_im[:,:,0], mask)\n        matched_G = self.hist_match(src_im[:,:,1], tar_im[:,:,1], mask)\n        matched_B = self.hist_match(src_im[:,:,2], tar_im[:,:,2], mask)\n        matched = numpy.stack((matched_R, matched_G, matched_B), axis=2).astype(src_im.dtype)\n        return matched\n\n    def get_new_face(self, image, mat, size):\n        face = cv2.warpAffine( image, mat, (size,size) )\n        face = numpy.expand_dims( face, 0 )\n        face_clipped = numpy.clip(face[0], 0, 255).astype( image.dtype )\n        new_face = None\n        mask = None\n\n        if \"GAN\" not in self.trainer:\n            normalized_face = face / 255.0\n            new_face = self.encoder(normalized_face)[0]\n            new_face = numpy.clip( new_face * 255, 0, 255 ).astype( image.dtype )\n        else:\n            normalized_face = face / 255.0 * 2 - 1\n            fake_output = self.encoder(normalized_face)\n            if \"128\" in self.trainer: # TODO: Another hack to switch between 64 and 128\n                fake_output = fake_output[0]\n            mask = fake_output[:,:,:, :1]\n            new_face = fake_output[:,:,:, 1:]\n            new_face = mask * new_face + (1 - mask) * normalized_face\n            new_face = numpy.clip((new_face[0] + 1) * 255 / 2, 0, 255).astype( image.dtype )\n\n        if self.match_histogram:\n            new_face = self.color_hist_match(new_face, face_clipped, mask)\n\n        return new_face\n\n    def get_image_mask(self, image, new_face, landmarks, mat, image_size):\n\n        face_mask = numpy.zeros(image.shape,dtype=float)\n        if 'rect' in self.mask_type:\n            face_src = numpy.ones(new_face.shape,dtype=float)\n            cv2.warpAffine( face_src, mat, image_size, face_mask, cv2.WARP_INVERSE_MAP | cv2.INTER_CUBIC, cv2.BORDER_TRANSPARENT )\n\n        hull_mask = numpy.zeros(image.shape,dtype=float)\n        if 'hull' in self.mask_type:\n            hull = cv2.convexHull( numpy.array( landmarks ).reshape((-1,2)).astype(int) ).flatten().reshape( (-1,2) )\n            cv2.fillConvexPoly( hull_mask,hull,(1,1,1) )\n\n        if self.mask_type == 'rect':\n            image_mask = face_mask\n        elif self.mask_type == 'facehull':\n            image_mask = hull_mask\n        else:\n            image_mask = ((face_mask*hull_mask))\n\n\n        if self.erosion_kernel is not None:\n            if self.erosion_kernel_size > 0:\n                image_mask = cv2.erode(image_mask,self.erosion_kernel,iterations = 1)\n            elif self.erosion_kernel_size < 0:\n                dilation_kernel = abs(self.erosion_kernel)\n                image_mask = cv2.dilate(image_mask,dilation_kernel,iterations = 1)\n\n        if self.blur_size!=0:\n            image_mask = cv2.blur(image_mask,(self.blur_size,self.blur_size))\n\n        return image_mask\n", "description": "Non official project based on original /r/Deepfakes thread. Many thanks to him!", "file_name": "Convert_Masked.py", "id": "68005d55ba93386e23b4ddb201ac8836", "language": "Python", "project_name": "faceswap", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/deepfakes-faceswap/deepfakes-faceswap-6ff64ef/plugins/Convert_Masked.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:27:43Z", "url": "https://github.com/deepfakes/faceswap", "wiki": true}