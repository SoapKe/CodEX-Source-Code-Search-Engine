{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nimport hashlib\n\nfrom datetime import datetime\n\nfrom werkzeug import urls\n\nfrom odoo import api, fields, models\n\n\nclass Users(models.Model):\n    _inherit = 'res.users'\n\n    def __init__(self, pool, cr):\n        init_res = super(Users, self).__init__(pool, cr)\n        type(self).SELF_WRITEABLE_FIELDS = list(\n            set(\n                self.SELF_WRITEABLE_FIELDS +\n                ['country_id', 'city', 'website', 'website_description', 'website_published']))\n        return init_res\n\n    create_date = fields.Datetime('Create Date', readonly=True, copy=False, index=True)\n    karma = fields.Integer('Karma', default=0)\n    badge_ids = fields.One2many('gamification.badge.user', 'user_id', string='Badges', copy=False)\n    gold_badge = fields.Integer('Gold badges count', compute=\"_get_user_badge_level\")\n    silver_badge = fields.Integer('Silver badges count', compute=\"_get_user_badge_level\")\n    bronze_badge = fields.Integer('Bronze badges count', compute=\"_get_user_badge_level\")\n    forum_waiting_posts_count = fields.Integer('Waiting post', compute=\"_get_user_waiting_post\")\n\n    @api.multi\n    @api.depends('badge_ids')\n    def _get_user_badge_level(self):\n        \"\"\" Return total badge per level of users\n        TDE CLEANME: shouldn't check type is forum ? \"\"\"\n        for user in self:\n            user.gold_badge = 0\n            user.silver_badge = 0\n            user.bronze_badge = 0\n\n        self.env.cr.execute(\"\"\"\n            SELECT bu.user_id, b.level, count(1)\n            FROM gamification_badge_user bu, gamification_badge b\n            WHERE bu.user_id IN %s\n              AND bu.badge_id = b.id\n              AND b.level IS NOT NULL\n            GROUP BY bu.user_id, b.level\n            ORDER BY bu.user_id;\n        \"\"\", [tuple(self.ids)])\n\n        for (user_id, level, count) in self.env.cr.fetchall():\n            \n            self.browse(user_id)['{}_badge'.format(level)] = count\n\n    @api.multi\n    def _get_user_waiting_post(self):\n        for user in self:\n            Post = self.env['forum.post']\n            domain = [('parent_id', '=', False), ('state', '=', 'pending'), ('create_uid', '=', user.id)]\n            user.forum_waiting_posts_count = Post.search_count(domain)\n\n    @api.model\n    def _generate_forum_token(self, user_id, email):\n        \"\"\"Return a token for email validation. This token is valid for the day\n        and is a hash based on a (secret) uuid generated by the forum module,\n        the user_id, the email and currently the day (to be updated if necessary). \"\"\"\n        forum_uuid = self.env['ir.config_parameter'].sudo().get_param('website_forum.uuid')\n        return hashlib.sha256((u'%s-%s-%s-%s' % (\n            datetime.now().replace(hour=0, minute=0, second=0, microsecond=0),\n            forum_uuid,\n            user_id,\n            email\n        )).encode('utf-8')).hexdigest()\n\n    @api.one\n    def send_forum_validation_email(self, forum_id=None):\n        if not self.email:\n            return False\n        token = self._generate_forum_token(self.id, self.email)\n        activation_template = self.env.ref('website_forum.validation_email')\n        if activation_template:\n            params = {\n                'token': token,\n                'id': self.id,\n                'email': self.email}\n            if forum_id:\n                params['forum_id'] = forum_id\n            base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')\n            token_url = base_url + '/forum/validate_email?%s' % urls.url_encode(params)\n            activation_template.sudo().with_context(token_url=token_url).send_mail(self.id, force_send=True)\n        return True\n\n    @api.one\n    def process_forum_validation_token(self, token, email, forum_id=None, context=None):\n        validation_token = self._generate_forum_token(self.id, email)\n        if token == validation_token and self.karma == 0:\n            karma = 3\n            forum = None\n            if forum_id:\n                forum = self.env['forum.forum'].browse(forum_id)\n            else:\n                forum_ids = self.env['forum.forum'].search([], limit=1)\n                if forum_ids:\n                    forum = forum_ids[0]\n            if forum:\n                \n                karma = forum.karma_ask + (-2 * forum.karma_gen_question_downvote)\n            return self.write({'karma': karma})\n        return False\n\n    @api.multi\n    def add_karma(self, karma):\n        for user in self:\n            user.karma += karma\n        return True\n\n    \n    @api.multi\n    def open_website_url(self):\n        return self.mapped('partner_id').open_website_url()\n", "comments": "    return total badge per level users         tde cleanme  check type forum               user self              user gold badge   0             user silver badge   0             user bronze badge   0          self env cr execute(                select bu user id  b level  count(1)             from gamification badge user bu  gamification badge b             where bu user id in                and bu badge id   b id               and b level is not null             group by bu user id  b level             order by bu user id                tuple(self ids) )          (user id  level  count) self env cr fetchall()                levels gold  silver  bronze fields  badge postfix             self browse(user id)     badge  format(level)    count       api multi     def  get user waiting post(self)          user self              post   self env  forum post               domain    ( parent id        false)  ( state         pending )  ( create uid        user id)              user forum waiting posts count   post search count(domain)       api model     def  generate forum token(self  user id  email)             return token email validation  this token valid day         hash based (secret) uuid generated forum module          user id  email currently day (to updated necessary)             coding  utf 8        part odoo  see license file full copyright licensing details     levels gold  silver  bronze fields  badge postfix    karma gained  karma ask question 2 downvotes    wrapper call kw inherits ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nimport hashlib\n\nfrom datetime import datetime\n\nfrom werkzeug import urls\n\nfrom odoo import api, fields, models\n\n\nclass Users(models.Model):\n    _inherit = 'res.users'\n\n    def __init__(self, pool, cr):\n        init_res = super(Users, self).__init__(pool, cr)\n        type(self).SELF_WRITEABLE_FIELDS = list(\n            set(\n                self.SELF_WRITEABLE_FIELDS +\n                ['country_id', 'city', 'website', 'website_description', 'website_published']))\n        return init_res\n\n    create_date = fields.Datetime('Create Date', readonly=True, copy=False, index=True)\n    karma = fields.Integer('Karma', default=0)\n    badge_ids = fields.One2many('gamification.badge.user', 'user_id', string='Badges', copy=False)\n    gold_badge = fields.Integer('Gold badges count', compute=\"_get_user_badge_level\")\n    silver_badge = fields.Integer('Silver badges count', compute=\"_get_user_badge_level\")\n    bronze_badge = fields.Integer('Bronze badges count', compute=\"_get_user_badge_level\")\n    forum_waiting_posts_count = fields.Integer('Waiting post', compute=\"_get_user_waiting_post\")\n\n    @api.multi\n    @api.depends('badge_ids')\n    def _get_user_badge_level(self):\n        \"\"\" Return total badge per level of users\n        TDE CLEANME: shouldn't check type is forum ? \"\"\"\n        for user in self:\n            user.gold_badge = 0\n            user.silver_badge = 0\n            user.bronze_badge = 0\n\n        self.env.cr.execute(\"\"\"\n            SELECT bu.user_id, b.level, count(1)\n            FROM gamification_badge_user bu, gamification_badge b\n            WHERE bu.user_id IN %s\n              AND bu.badge_id = b.id\n              AND b.level IS NOT NULL\n            GROUP BY bu.user_id, b.level\n            ORDER BY bu.user_id;\n        \"\"\", [tuple(self.ids)])\n\n        for (user_id, level, count) in self.env.cr.fetchall():\n            # levels are gold, silver, bronze but fields have _badge postfix\n            self.browse(user_id)['{}_badge'.format(level)] = count\n\n    @api.multi\n    def _get_user_waiting_post(self):\n        for user in self:\n            Post = self.env['forum.post']\n            domain = [('parent_id', '=', False), ('state', '=', 'pending'), ('create_uid', '=', user.id)]\n            user.forum_waiting_posts_count = Post.search_count(domain)\n\n    @api.model\n    def _generate_forum_token(self, user_id, email):\n        \"\"\"Return a token for email validation. This token is valid for the day\n        and is a hash based on a (secret) uuid generated by the forum module,\n        the user_id, the email and currently the day (to be updated if necessary). \"\"\"\n        forum_uuid = self.env['ir.config_parameter'].sudo().get_param('website_forum.uuid')\n        return hashlib.sha256((u'%s-%s-%s-%s' % (\n            datetime.now().replace(hour=0, minute=0, second=0, microsecond=0),\n            forum_uuid,\n            user_id,\n            email\n        )).encode('utf-8')).hexdigest()\n\n    @api.one\n    def send_forum_validation_email(self, forum_id=None):\n        if not self.email:\n            return False\n        token = self._generate_forum_token(self.id, self.email)\n        activation_template = self.env.ref('website_forum.validation_email')\n        if activation_template:\n            params = {\n                'token': token,\n                'id': self.id,\n                'email': self.email}\n            if forum_id:\n                params['forum_id'] = forum_id\n            base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')\n            token_url = base_url + '/forum/validate_email?%s' % urls.url_encode(params)\n            activation_template.sudo().with_context(token_url=token_url).send_mail(self.id, force_send=True)\n        return True\n\n    @api.one\n    def process_forum_validation_token(self, token, email, forum_id=None, context=None):\n        validation_token = self._generate_forum_token(self.id, email)\n        if token == validation_token and self.karma == 0:\n            karma = 3\n            forum = None\n            if forum_id:\n                forum = self.env['forum.forum'].browse(forum_id)\n            else:\n                forum_ids = self.env['forum.forum'].search([], limit=1)\n                if forum_ids:\n                    forum = forum_ids[0]\n            if forum:\n                # karma gained: karma to ask a question and have 2 downvotes\n                karma = forum.karma_ask + (-2 * forum.karma_gen_question_downvote)\n            return self.write({'karma': karma})\n        return False\n\n    @api.multi\n    def add_karma(self, karma):\n        for user in self:\n            user.karma += karma\n        return True\n\n    # Wrapper for call_kw with inherits\n    @api.multi\n    def open_website_url(self):\n        return self.mapped('partner_id').open_website_url()\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "res_users.py", "id": "a90f73ff857e41654988f427e0d4ace0", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/website_forum/models/res_users.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}