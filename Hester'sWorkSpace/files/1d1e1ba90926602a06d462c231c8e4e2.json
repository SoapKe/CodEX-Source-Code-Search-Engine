{"author": "tgalal", "code": "from .cli import Cli, clicmd\nfrom yowsup.layers.interface import YowInterfaceLayer, ProtocolEntityCallback\nfrom yowsup.layers.auth import YowAuthenticationProtocolLayer\nfrom yowsup.layers import YowLayerEvent, EventCallback\nfrom yowsup.layers.network import YowNetworkLayer\nimport sys\nfrom yowsup.common import YowConstants\nimport datetime\nimport os\nimport logging\nfrom yowsup.layers.protocol_groups.protocolentities      import *\nfrom yowsup.layers.protocol_presence.protocolentities    import *\nfrom yowsup.layers.protocol_messages.protocolentities    import *\nfrom yowsup.layers.protocol_ib.protocolentities          import *\nfrom yowsup.layers.protocol_iq.protocolentities          import *\nfrom yowsup.layers.protocol_contacts.protocolentities    import *\nfrom yowsup.layers.protocol_chatstate.protocolentities   import *\nfrom yowsup.layers.protocol_privacy.protocolentities     import *\nfrom yowsup.layers.protocol_media.protocolentities       import *\nfrom yowsup.layers.protocol_media.mediauploader import MediaUploader\nfrom yowsup.layers.protocol_profiles.protocolentities    import *\nfrom yowsup.common.tools import Jid\nfrom yowsup.common.optionalmodules import PILOptionalModule, AxolotlOptionalModule\n\nlogger = logging.getLogger(__name__)\nclass YowsupCliLayer(Cli, YowInterfaceLayer):\n    PROP_RECEIPT_AUTO       = \"org.openwhatsapp.yowsup.prop.cli.autoreceipt\"\n    PROP_RECEIPT_KEEPALIVE  = \"org.openwhatsapp.yowsup.prop.cli.keepalive\"\n    PROP_CONTACT_JID        = \"org.openwhatsapp.yowsup.prop.cli.contact.jid\"\n    EVENT_LOGIN             = \"org.openwhatsapp.yowsup.event.cli.login\"\n    EVENT_START             = \"org.openwhatsapp.yowsup.event.cli.start\"\n    EVENT_SENDANDEXIT       = \"org.openwhatsapp.yowsup.event.cli.sendandexit\"\n\n    MESSAGE_FORMAT          = \"[{FROM}({TIME})]:[{MESSAGE_ID}]\\t {MESSAGE}\"\n\n    FAIL_OPT_PILLOW         = \"No PIL library installed, try install pillow\"\n    FAIL_OPT_AXOLOTL        = \"axolotl is not installed, try install python-axolotl\"\n\n    DISCONNECT_ACTION_PROMPT = 0\n    DISCONNECT_ACTION_EXIT   = 1\n\n    ACCOUNT_DEL_WARNINGS = 4\n\n    def __init__(self):\n        super(YowsupCliLayer, self).__init__()\n        YowInterfaceLayer.__init__(self)\n        self.accountDelWarnings = 0\n        self.connected = False\n        self.username = None\n        self.sendReceipts = True\n        self.sendRead = True\n        self.disconnectAction = self.__class__.DISCONNECT_ACTION_PROMPT\n        self.credentials = None\n\n        \n        \n        \n        self.jidAliases = {\n            \n        }\n\n    def aliasToJid(self, calias):\n        for alias, ajid in self.jidAliases.items():\n            if calias.lower() == alias.lower():\n                return Jid.normalize(ajid)\n\n        return Jid.normalize(calias)\n\n    def jidToAlias(self, jid):\n        for alias, ajid in self.jidAliases.items():\n            if ajid == jid:\n                return alias\n        return jid\n\n    def setCredentials(self, username, password):\n        self.getLayerInterface(YowAuthenticationProtocolLayer).setCredentials(username, password)\n\n        return \"%s@s.whatsapp.net\" % username\n\n    @EventCallback(EVENT_START)\n    def onStart(self, layerEvent):\n        self.startInput()\n        return True\n\n    @EventCallback(EVENT_SENDANDEXIT)\n    def onSendAndExit(self, layerEvent):\n        credentials = layerEvent.getArg(\"credentials\")\n        target = layerEvent.getArg(\"target\")\n        message = layerEvent.getArg(\"message\")\n        self.sendMessageAndDisconnect(credentials, target, message)\n        return True\n\n    @EventCallback(YowNetworkLayer.EVENT_STATE_DISCONNECTED)\n    def onStateDisconnected(self,layerEvent):\n        self.output(\"Disconnected: %s\" % layerEvent.getArg(\"reason\"))\n        if self.disconnectAction == self.__class__.DISCONNECT_ACTION_PROMPT:\n           self.connected = False\n           self.notifyInputThread()\n        else:\n           os._exit(os.EX_OK)\n\n    def assertConnected(self):\n        if self.connected:\n            return True\n        else:\n            self.output(\"Not connected\", tag = \"Error\", prompt = False)\n            return False\n\n    \n    def sendMessageAndDisconnect(self, credentials, jid, message):\n        self.disconnectAction = self.__class__.DISCONNECT_ACTION_EXIT\n        self.queueCmd(\"/login %s %s\" % credentials)\n        self.queueCmd(\"/message send %s \\\"%s\\\" wait\" % (jid, message))\n        self.queueCmd(\"/disconnect\")\n        self.startInput()\n\n\n    \n    @clicmd(\"Set presence name\")\n    def presence_name(self, name):\n        if self.assertConnected():\n            entity = PresenceProtocolEntity(name = name)\n            self.toLower(entity)\n\n    @clicmd(\"Set presence as available\")\n    def presence_available(self):\n        if self.assertConnected():\n            entity = AvailablePresenceProtocolEntity()\n            self.toLower(entity)\n\n    @clicmd(\"Set presence as unavailable\")\n    def presence_unavailable(self):\n        if self.assertConnected():\n            entity = UnavailablePresenceProtocolEntity()\n            self.toLower(entity)\n\n    @clicmd(\"Unsubscribe from contact's presence updates\")\n    def presence_unsubscribe(self, contact):\n        if self.assertConnected():\n            entity = UnsubscribePresenceProtocolEntity(self.aliasToJid(contact))\n            self.toLower(entity)\n\n    @clicmd(\"Subscribe to contact's presence updates\")\n    def presence_subscribe(self, contact):\n        if self.assertConnected():\n            entity = SubscribePresenceProtocolEntity(self.aliasToJid(contact))\n            self.toLower(entity)\n\n    \n\n    \n    @clicmd(\"Send clean dirty\")\n    def ib_clean(self, dirtyType):\n        if self.assertConnected():\n            entity = CleanIqProtocolEntity(\"groups\", YowConstants.DOMAIN)\n            self.toLower(entity)\n\n    @clicmd(\"Ping server\")\n    def ping(self):\n        if self.assertConnected():\n            entity = PingIqProtocolEntity(to = YowConstants.DOMAIN)\n            self.toLower(entity)\n\n    \n\n    \n    @clicmd(\"Set status text\")\n    def profile_setStatus(self, text):\n        if self.assertConnected():\n\n            def onSuccess(resultIqEntity, originalIqEntity):\n                self.output(\"Status updated successfully\")\n\n            def onError(errorIqEntity, originalIqEntity):\n                logger.error(\"Error updating status\")\n\n            entity = SetStatusIqProtocolEntity(text)\n            self._sendIq(entity, onSuccess, onError)\n\n    @clicmd(\"Get profile picture for contact\")\n    def contact_picture(self, jid):\n        if self.assertConnected():\n            entity = GetPictureIqProtocolEntity(self.aliasToJid(jid), preview=False)\n            self._sendIq(entity, self.onGetContactPictureResult)\n\n    @clicmd(\"Get profile picture preview for contact\")\n    def contact_picturePreview(self, jid):\n        if self.assertConnected():\n            entity = GetPictureIqProtocolEntity(self.aliasToJid(jid), preview=True)\n            self._sendIq(entity, self.onGetContactPictureResult)\n\n    @clicmd(\"Get lastseen for contact\")\n    def contact_lastseen(self, jid):\n        if self.assertConnected():\n            def onSuccess(resultIqEntity, originalIqEntity):\n                self.output(\"%s lastseen %s seconds ago\" % (resultIqEntity.getFrom(), resultIqEntity.getSeconds()))\n\n            def onError(errorIqEntity, originalIqEntity):\n                logger.error(\"Error getting lastseen information for %s\" % originalIqEntity.getTo())\n\n            entity = LastseenIqProtocolEntity(self.aliasToJid(jid))\n            self._sendIq(entity, onSuccess, onError)\n\n    @clicmd(\"Set profile picture\")\n    def profile_setPicture(self, path):\n        if self.assertConnected():\n            with PILOptionalModule(failMessage = \"No PIL library installed, try install pillow\") as imp:\n                Image = imp(\"Image\")\n                def onSuccess(resultIqEntity, originalIqEntity):\n                    self.output(\"Profile picture updated successfully\")\n\n                def onError(errorIqEntity, originalIqEntity):\n                    logger.error(\"Error updating profile picture\")\n\n                \n                \n                src = Image.open(path)\n                pictureData = src.resize((640, 640)).tobytes(\"jpeg\", \"RGB\")\n                picturePreview = src.resize((96, 96)).tobytes(\"jpeg\", \"RGB\")\n                iq = SetPictureIqProtocolEntity(self.getOwnJid(), picturePreview, pictureData)\n                self._sendIq(iq, onSuccess, onError)\n\n    @clicmd(\"Get profile privacy\")\n    def profile_getPrivacy(self):\n        if self.assertConnected():\n            def onSuccess(resultIqEntity, originalIqEntity):\n                self.output(\"Profile privacy is: %s\" %(resultIqEntity))\n\n            def onError(errorIqEntity, originalIqEntity):\n                logger.error(\"Error getting profile privacy\")\n\n            iq = GetPrivacyIqProtocolEntity()\n            self._sendIq(iq, onSuccess, onError)\n\n    @clicmd(\"Profile privacy. value=all|contacts|none names=profile|status|last. Names are comma separated, defaults to all.\")\n    def profile_setPrivacy(self, value=\"all\", names=None):\n        if self.assertConnected():\n            def onSuccess(resultIqEntity, originalIqEntity):\n                self.output(\"Profile privacy set to: %s\" %(resultIqEntity))\n\n            def onError(errorIqEntity, originalIqEntity):\n                logger.error(\"Error setting profile privacy\")\n            try:\n                names = [name for name in names.split(',')] if names else None\n                iq = SetPrivacyIqProtocolEntity(value, names)\n                self._sendIq(iq, onSuccess, onError)\n            except Exception as inst:\n                self.output(inst.message)\n                return self.print_usage()\n\n\n    \n\n    @clicmd(\"List all groups you belong to\", 5)\n    def groups_list(self):\n        if self.assertConnected():\n            entity = ListGroupsIqProtocolEntity()\n            self.toLower(entity)\n\n    @clicmd(\"Leave a group you belong to\", 4)\n    def group_leave(self, group_jid):\n        if self.assertConnected():\n            entity = LeaveGroupsIqProtocolEntity([self.aliasToJid(group_jid)])\n            self.toLower(entity)\n\n    @clicmd(\"Create a new group with the specified subject and participants. Jids are a comma separated list but optional.\", 3)\n    def groups_create(self, subject, jids = None):\n        if self.assertConnected():\n            jids = [self.aliasToJid(jid) for jid in jids.split(',')] if jids else []\n            entity = CreateGroupsIqProtocolEntity(subject, participants=jids)\n            self.toLower(entity)\n\n    @clicmd(\"Invite to group. Jids are a comma separated list\")\n    def group_invite(self, group_jid, jids):\n        if self.assertConnected():\n            jids = [self.aliasToJid(jid) for jid in jids.split(',')]\n            entity = AddParticipantsIqProtocolEntity(self.aliasToJid(group_jid), jids)\n            self.toLower(entity)\n\n    @clicmd(\"Promote admin of a group. Jids are a comma separated list\")\n    def group_promote(self, group_jid, jids):\n        if self.assertConnected():\n            jids = [self.aliasToJid(jid) for jid in jids.split(',')]\n            entity = PromoteParticipantsIqProtocolEntity(self.aliasToJid(group_jid), jids)\n            self.toLower(entity)\n\n    @clicmd(\"Remove admin of a group. Jids are a comma separated list\")\n    def group_demote(self, group_jid, jids):\n        if self.assertConnected():\n            jids = [self.aliasToJid(jid) for jid in jids.split(',')]\n            entity = DemoteParticipantsIqProtocolEntity(self.aliasToJid(group_jid), jids)\n            self.toLower(entity)\n\n    @clicmd(\"Kick from group. Jids are a comma separated list\")\n    def group_kick(self, group_jid, jids):\n        if self.assertConnected():\n            jids = [self.aliasToJid(jid) for jid in jids.split(',')]\n            entity = RemoveParticipantsIqProtocolEntity(self.aliasToJid(group_jid), jids)\n            self.toLower(entity)\n\n    @clicmd(\"Change group subject\")\n    def group_setSubject(self, group_jid, subject):\n        if self.assertConnected():\n            entity = SubjectGroupsIqProtocolEntity(self.aliasToJid(group_jid), subject)\n            self.toLower(entity)\n\n    @clicmd(\"Set group picture\")\n    def group_picture(self, group_jid, path):\n        if self.assertConnected():\n            with PILOptionalModule(failMessage = self.__class__.FAIL_OPT_PILLOW) as imp:\n                Image = imp(\"Image\")\n\n                def onSuccess(resultIqEntity, originalIqEntity):\n                    self.output(\"Group picture updated successfully\")\n\n                def onError(errorIqEntity, originalIqEntity):\n                    logger.error(\"Error updating Group picture\")\n\n                \n                \n                src = Image.open(path)\n                pictureData = src.resize((640, 640)).tobytes(\"jpeg\", \"RGB\")\n                picturePreview = src.resize((96, 96)).tobytes(\"jpeg\", \"RGB\")\n                iq = SetPictureIqProtocolEntity(self.aliasToJid(group_jid), picturePreview, pictureData)\n                self._sendIq(iq, onSuccess, onError)\n\n\n    @clicmd(\"Get group info\")\n    def group_info(self, group_jid):\n        if self.assertConnected():\n            entity = InfoGroupsIqProtocolEntity(self.aliasToJid(group_jid))\n            self.toLower(entity)\n\n    @clicmd(\"Get shared keys\")\n    def keys_get(self, jids):\n        with AxolotlOptionalModule(failMessage = self.__class__.FAIL_OPT_AXOLOTL) as importFn:\n            importFn()\n            from yowsup.layers.axolotl.protocolentities.iq_key_get import GetKeysIqProtocolEntity\n            if self.assertConnected():\n                jids = [self.aliasToJid(jid) for jid in jids.split(',')]\n                entity = GetKeysIqProtocolEntity(jids)\n                self.toLower(entity)\n\n    @clicmd(\"Send init seq\")\n    def seq(self):\n        priv = PrivacyListIqProtocolEntity()\n        self.toLower(priv)\n        push = PushIqProtocolEntity()\n        self.toLower(push)\n        props = PropsIqProtocolEntity()\n        self.toLower(props)\n        crypto = CryptoIqProtocolEntity()\n        self.toLower(crypto)\n\n    @clicmd(\"Delete your account\")\n    def account_delete(self):\n        if self.assertConnected():\n            if self.accountDelWarnings < self.__class__.ACCOUNT_DEL_WARNINGS:\n                self.accountDelWarnings += 1\n                remaining = self.__class__.ACCOUNT_DEL_WARNINGS - self.accountDelWarnings\n                self.output(\"Repeat delete command another %s times to send the delete request\" % remaining, tag=\"Account delete Warning !!\", prompt = False)\n            else:\n                entity = UnregisterIqProtocolEntity()\n                self.toLower(entity)\n\n    @clicmd(\"Send message to a friend\")\n    def message_send(self, number, content):\n        if self.assertConnected():\n            outgoingMessage = TextMessageProtocolEntity(content.encode(\"utf-8\") if sys.version_info >= (3,0) else content, to = self.aliasToJid(number))\n            self.toLower(outgoingMessage)\n\n    @clicmd(\"Broadcast message. numbers should comma separated phone numbers\")\n    def message_broadcast(self, numbers, content):\n        if self.assertConnected():\n            jids = [self.aliasToJid(number) for number in numbers.split(',')]\n            outgoingMessage = BroadcastTextMessage(jids, content)\n            self.toLower(outgoingMessage)\n\n    #@clicmd(\"Send read receipt\")\n    def message_read(self, message_id):\n        pass\n\n    #@clicmd(\"Send delivered receipt\")\n    def message_delivered(self, message_id):\n        pass\n\n    @clicmd(\"Send a video with optional caption\")\n    def video_send(self, number, path, caption = None):\n        self.media_send(number, path, RequestUploadIqProtocolEntity.MEDIA_TYPE_VIDEO)\n\n    @clicmd(\"Send an image with optional caption\")\n    def image_send(self, number, path, caption = None):\n        self.media_send(number, path, RequestUploadIqProtocolEntity.MEDIA_TYPE_IMAGE)\n\n    @clicmd(\"Send audio file\")\n    def audio_send(self, number, path):\n        self.media_send(number, path, RequestUploadIqProtocolEntity.MEDIA_TYPE_AUDIO)\n\n    def media_send(self, number, path, mediaType, caption = None):\n        if self.assertConnected():\n            jid = self.aliasToJid(number)\n            entity = RequestUploadIqProtocolEntity(mediaType, filePath=path)\n            successFn = lambda successEntity, originalEntity: self.onRequestUploadResult(jid, mediaType, path, successEntity, originalEntity, caption)\n            errorFn = lambda errorEntity, originalEntity: self.onRequestUploadError(jid, path, errorEntity, originalEntity)\n            self._sendIq(entity, successFn, errorFn)\n\n            self._sendIq(entity, successFn, errorFn)\n    @clicmd(\"Send typing state\")\n    def state_typing(self, jid):\n        if self.assertConnected():\n            entity = OutgoingChatstateProtocolEntity(ChatstateProtocolEntity.STATE_TYPING, self.aliasToJid(jid))\n            self.toLower(entity)\n\n    @clicmd(\"Request contacts statuses\")\n    def statuses_get(self, contacts):\n        if self.assertConnected():\n            entity = GetStatusesIqProtocolEntity([self.aliasToJid(c) for c in contacts.split(',')])\n            self.toLower(entity)\n\n    @clicmd(\"Send paused state\")\n    def state_paused(self, jid):\n        if self.assertConnected():\n            entity = OutgoingChatstateProtocolEntity(ChatstateProtocolEntity.STATE_PAUSED, self.aliasToJid(jid))\n            self.toLower(entity)\n\n    @clicmd(\"Sync contacts, contacts should be comma separated phone numbers, with no spaces\")\n    def contacts_sync(self, contacts):\n        if self.assertConnected():\n            entity = GetSyncIqProtocolEntity(contacts.split(','))\n            self.toLower(entity)\n\n    @clicmd(\"Disconnect\")\n    def disconnect(self):\n        if self.assertConnected():\n\n            self.broadcastEvent(YowLayerEvent(YowNetworkLayer.EVENT_STATE_DISCONNECT))\n\n    @clicmd(\"Quick login\")\n    def L(self):\n        if self.connected:\n            return self.output(\"Already connected, disconnect first\")\n        self.getLayerInterface(YowNetworkLayer).connect()\n        return True\n\n    @clicmd(\"Login to WhatsApp\", 0)\n    def login(self, username, b64password):\n        self.setCredentials(username, b64password)\n        return self.L()\n\n    \n\n    @ProtocolEntityCallback(\"chatstate\")\n    def onChatstate(self, entity):\n        print(entity)\n\n    @ProtocolEntityCallback(\"iq\")\n    def onIq(self, entity):\n        print(entity)\n\n    @ProtocolEntityCallback(\"receipt\")\n    def onReceipt(self, entity):\n        self.toLower(entity.ack())\n\n    @ProtocolEntityCallback(\"ack\")\n    def onAck(self, entity):\n        #formattedDate = datetime.datetime.fromtimestamp(self.sentCache[entity.getId()][0]).strftime('%d-%m-%Y %H:%M')\n        #print(\"%s [%s]:%s\"%(self.username, formattedDate, self.sentCache[entity.getId()][1]))\n        if entity.getClass() == \"message\":\n            self.output(entity.getId(), tag = \"Sent\")\n            ()\n\n    @ProtocolEntityCallback(\"success\")\n    def onSuccess(self, entity):\n        self.connected = True\n        self.output(\"Logged in!\", \"Auth\", prompt = False)\n        self.notifyInputThread()\n\n    @ProtocolEntityCallback(\"failure\")\n    def onFailure(self, entity):\n        self.connected = False\n        self.output(\"Login Failed, reason: %s\" % entity.getReason(), prompt = False)\n\n    @ProtocolEntityCallback(\"notification\")\n    def onNotification(self, notification):\n        notificationData = notification.__str__()\n        if notificationData:\n            self.output(notificationData, tag = \"Notification\")\n        else:\n            self.output(\"From :%s, Type: %s\" % (self.jidToAlias(notification.getFrom()), notification.getType()), tag = \"Notification\")\n        if self.sendReceipts:\n            self.toLower(notification.ack())\n\n    @ProtocolEntityCallback(\"message\")\n    def onMessage(self, message):\n        messageOut = \"\"\n        if message.getType() == \"text\":\n            #self.output(message.getBody(), tag = \"%s [%s]\"%(message.getFrom(), formattedDate))\n            messageOut = self.getTextMessageBody(message)\n        elif message.getType() == \"media\":\n            messageOut = self.getMediaMessageBody(message)\n        else:\n            messageOut = \"Unknown message type %s \" % message.getType()\n            print(messageOut.toProtocolTreeNode())\n\n\n        formattedDate = datetime.datetime.fromtimestamp(message.getTimestamp()).strftime('%d-%m-%Y %H:%M')\n        sender = message.getFrom() if not message.isGroupMessage() else \"%s/%s\" % (message.getParticipant(False), message.getFrom())\n        output = self.__class__.MESSAGE_FORMAT.format(\n            FROM = sender,\n            TIME = formattedDate,\n            MESSAGE = messageOut.encode('latin-1').decode() if sys.version_info >= (3, 0) else messageOut,\n            MESSAGE_ID = message.getId()\n            )\n\n        self.output(output, tag = None, prompt = not self.sendReceipts)\n        if self.sendReceipts:\n            self.toLower(message.ack(self.sendRead))\n            self.output(\"Sent delivered receipt\"+\" and Read\" if self.sendRead else \"\", tag = \"Message %s\" % message.getId())\n\n\n    def getTextMessageBody(self, message):\n        return message.getBody()\n\n    def getMediaMessageBody(self, message):\n        if message.getMediaType() in (\"image\", \"audio\", \"video\"):\n            return self.getDownloadableMediaMessageBody(message)\n        else:\n            return \"[Media Type: %s]\" % message.getMediaType()\n\n\n    def getDownloadableMediaMessageBody(self, message):\n         return \"[Media Type:{media_type}, Size:{media_size}, URL:{media_url}]\".format(\n            media_type = message.getMediaType(),\n            media_size = message.getMediaSize(),\n            media_url = message.getMediaUrl()\n            )\n\n    def doSendMedia(self, mediaType, filePath, url, to, ip = None, caption = None):\n        if mediaType == RequestUploadIqProtocolEntity.MEDIA_TYPE_IMAGE:\n        \tentity = ImageDownloadableMediaMessageProtocolEntity.fromFilePath(filePath, url, ip, to, caption = caption)\n        elif mediaType == RequestUploadIqProtocolEntity.MEDIA_TYPE_AUDIO:\n        \tentity = AudioDownloadableMediaMessageProtocolEntity.fromFilePath(filePath, url, ip, to)\n        elif mediaType == RequestUploadIqProtocolEntity.MEDIA_TYPE_VIDEO:\n        \tentity = VideoDownloadableMediaMessageProtocolEntity.fromFilePath(filePath, url, ip, to, caption = caption)\n        self.toLower(entity)\n\n    def __str__(self):\n        return \"CLI Interface Layer\"\n\n    \n\n    def onRequestUploadResult(self, jid, mediaType, filePath, resultRequestUploadIqProtocolEntity, requestUploadIqProtocolEntity, caption = None):\n\n        if resultRequestUploadIqProtocolEntity.isDuplicate():\n            self.doSendMedia(mediaType, filePath, resultRequestUploadIqProtocolEntity.getUrl(), jid,\n                             resultRequestUploadIqProtocolEntity.getIp(), caption)\n        else:\n            successFn = lambda filePath, jid, url: self.doSendMedia(mediaType, filePath, url, jid, resultRequestUploadIqProtocolEntity.getIp(), caption)\n            mediaUploader = MediaUploader(jid, self.getOwnJid(), filePath,\n                                      resultRequestUploadIqProtocolEntity.getUrl(),\n                                      resultRequestUploadIqProtocolEntity.getResumeOffset(),\n                                      successFn, self.onUploadError, self.onUploadProgress, async=False)\n            mediaUploader.start()\n\n    def onRequestUploadError(self, jid, path, errorRequestUploadIqProtocolEntity, requestUploadIqProtocolEntity):\n        logger.error(\"Request upload for file %s for %s failed\" % (path, jid))\n\n    def onUploadError(self, filePath, jid, url):\n        logger.error(\"Upload file %s to %s for %s failed!\" % (filePath, url, jid))\n\n    def onUploadProgress(self, filePath, jid, url, progress):\n        sys.stdout.write(\"%s => %s, %d%% \\r\" % (os.path.basename(filePath), jid, progress))\n        sys.stdout.flush()\n\n    def onGetContactPictureResult(self, resultGetPictureIqProtocolEntiy, getPictureIqProtocolEntity):\n        \n        \n        \n        \n        \n        #resultGetPictureIqProtocolEntiy.writeToFile(\"/tmp/yowpics/%s_%s.jpg\" % (getPictureIqProtocolEntity.getTo(), \"preview\" if resultGetPictureIqProtocolEntiy.isPreview() else \"full\"))\n        pass\n\n    def __str__(self):\n        return \"CLI Interface Layer\"\n\n    @clicmd(\"Print this message\")\n    def help(self):\n        self.print_usage()\n", "comments": " add aliases make user use commands  example      message send foobar  hi     get automaticlaly mapped foobar jid     name    phone whatsapp net        batch cmds                   presence                              end presence                            ib                                                                          contacts  profiles                        example  aesedepece https   github com tgalal yowsup pull 781   modified support python3              groups   example  aesedepece https   github com tgalal yowsup pull 781   modified support python3    clicmd( send read receipt )    clicmd( send delivered receipt )           receive             formatteddate   datetime datetime fromtimestamp(self sentcache entity getid()  0 ) strftime(    y  h  m )   print(       (self username  formatteddate  self sentcache entity getid()  1 ))   self notifyinputthread()   self output(message getbody()  tag         (message getfrom()  formatteddate))              callbacks                 whatever want    write file    open    nothing    write file example    resultgetpictureiqprotocolentiy writetofile(  tmp yowpics   jpg    (getpictureiqprotocolentity getto()   preview  resultgetpictureiqprotocolentiy ispreview() else  full )) ", "content": "from .cli import Cli, clicmd\nfrom yowsup.layers.interface import YowInterfaceLayer, ProtocolEntityCallback\nfrom yowsup.layers.auth import YowAuthenticationProtocolLayer\nfrom yowsup.layers import YowLayerEvent, EventCallback\nfrom yowsup.layers.network import YowNetworkLayer\nimport sys\nfrom yowsup.common import YowConstants\nimport datetime\nimport os\nimport logging\nfrom yowsup.layers.protocol_groups.protocolentities      import *\nfrom yowsup.layers.protocol_presence.protocolentities    import *\nfrom yowsup.layers.protocol_messages.protocolentities    import *\nfrom yowsup.layers.protocol_ib.protocolentities          import *\nfrom yowsup.layers.protocol_iq.protocolentities          import *\nfrom yowsup.layers.protocol_contacts.protocolentities    import *\nfrom yowsup.layers.protocol_chatstate.protocolentities   import *\nfrom yowsup.layers.protocol_privacy.protocolentities     import *\nfrom yowsup.layers.protocol_media.protocolentities       import *\nfrom yowsup.layers.protocol_media.mediauploader import MediaUploader\nfrom yowsup.layers.protocol_profiles.protocolentities    import *\nfrom yowsup.common.tools import Jid\nfrom yowsup.common.optionalmodules import PILOptionalModule, AxolotlOptionalModule\n\nlogger = logging.getLogger(__name__)\nclass YowsupCliLayer(Cli, YowInterfaceLayer):\n    PROP_RECEIPT_AUTO       = \"org.openwhatsapp.yowsup.prop.cli.autoreceipt\"\n    PROP_RECEIPT_KEEPALIVE  = \"org.openwhatsapp.yowsup.prop.cli.keepalive\"\n    PROP_CONTACT_JID        = \"org.openwhatsapp.yowsup.prop.cli.contact.jid\"\n    EVENT_LOGIN             = \"org.openwhatsapp.yowsup.event.cli.login\"\n    EVENT_START             = \"org.openwhatsapp.yowsup.event.cli.start\"\n    EVENT_SENDANDEXIT       = \"org.openwhatsapp.yowsup.event.cli.sendandexit\"\n\n    MESSAGE_FORMAT          = \"[{FROM}({TIME})]:[{MESSAGE_ID}]\\t {MESSAGE}\"\n\n    FAIL_OPT_PILLOW         = \"No PIL library installed, try install pillow\"\n    FAIL_OPT_AXOLOTL        = \"axolotl is not installed, try install python-axolotl\"\n\n    DISCONNECT_ACTION_PROMPT = 0\n    DISCONNECT_ACTION_EXIT   = 1\n\n    ACCOUNT_DEL_WARNINGS = 4\n\n    def __init__(self):\n        super(YowsupCliLayer, self).__init__()\n        YowInterfaceLayer.__init__(self)\n        self.accountDelWarnings = 0\n        self.connected = False\n        self.username = None\n        self.sendReceipts = True\n        self.sendRead = True\n        self.disconnectAction = self.__class__.DISCONNECT_ACTION_PROMPT\n        self.credentials = None\n\n        #add aliases to make it user to use commands. for example you can then do:\n        # /message send foobar \"HI\"\n        # and then it will get automaticlaly mapped to foobar's jid\n        self.jidAliases = {\n            # \"NAME\": \"PHONE@s.whatsapp.net\"\n        }\n\n    def aliasToJid(self, calias):\n        for alias, ajid in self.jidAliases.items():\n            if calias.lower() == alias.lower():\n                return Jid.normalize(ajid)\n\n        return Jid.normalize(calias)\n\n    def jidToAlias(self, jid):\n        for alias, ajid in self.jidAliases.items():\n            if ajid == jid:\n                return alias\n        return jid\n\n    def setCredentials(self, username, password):\n        self.getLayerInterface(YowAuthenticationProtocolLayer).setCredentials(username, password)\n\n        return \"%s@s.whatsapp.net\" % username\n\n    @EventCallback(EVENT_START)\n    def onStart(self, layerEvent):\n        self.startInput()\n        return True\n\n    @EventCallback(EVENT_SENDANDEXIT)\n    def onSendAndExit(self, layerEvent):\n        credentials = layerEvent.getArg(\"credentials\")\n        target = layerEvent.getArg(\"target\")\n        message = layerEvent.getArg(\"message\")\n        self.sendMessageAndDisconnect(credentials, target, message)\n        return True\n\n    @EventCallback(YowNetworkLayer.EVENT_STATE_DISCONNECTED)\n    def onStateDisconnected(self,layerEvent):\n        self.output(\"Disconnected: %s\" % layerEvent.getArg(\"reason\"))\n        if self.disconnectAction == self.__class__.DISCONNECT_ACTION_PROMPT:\n           self.connected = False\n           self.notifyInputThread()\n        else:\n           os._exit(os.EX_OK)\n\n    def assertConnected(self):\n        if self.connected:\n            return True\n        else:\n            self.output(\"Not connected\", tag = \"Error\", prompt = False)\n            return False\n\n    #### batch cmds #####\n    def sendMessageAndDisconnect(self, credentials, jid, message):\n        self.disconnectAction = self.__class__.DISCONNECT_ACTION_EXIT\n        self.queueCmd(\"/login %s %s\" % credentials)\n        self.queueCmd(\"/message send %s \\\"%s\\\" wait\" % (jid, message))\n        self.queueCmd(\"/disconnect\")\n        self.startInput()\n\n\n    ########## PRESENCE ###############\n    @clicmd(\"Set presence name\")\n    def presence_name(self, name):\n        if self.assertConnected():\n            entity = PresenceProtocolEntity(name = name)\n            self.toLower(entity)\n\n    @clicmd(\"Set presence as available\")\n    def presence_available(self):\n        if self.assertConnected():\n            entity = AvailablePresenceProtocolEntity()\n            self.toLower(entity)\n\n    @clicmd(\"Set presence as unavailable\")\n    def presence_unavailable(self):\n        if self.assertConnected():\n            entity = UnavailablePresenceProtocolEntity()\n            self.toLower(entity)\n\n    @clicmd(\"Unsubscribe from contact's presence updates\")\n    def presence_unsubscribe(self, contact):\n        if self.assertConnected():\n            entity = UnsubscribePresenceProtocolEntity(self.aliasToJid(contact))\n            self.toLower(entity)\n\n    @clicmd(\"Subscribe to contact's presence updates\")\n    def presence_subscribe(self, contact):\n        if self.assertConnected():\n            entity = SubscribePresenceProtocolEntity(self.aliasToJid(contact))\n            self.toLower(entity)\n\n    ########### END PRESENCE #############\n\n    ########### ib #######################\n    @clicmd(\"Send clean dirty\")\n    def ib_clean(self, dirtyType):\n        if self.assertConnected():\n            entity = CleanIqProtocolEntity(\"groups\", YowConstants.DOMAIN)\n            self.toLower(entity)\n\n    @clicmd(\"Ping server\")\n    def ping(self):\n        if self.assertConnected():\n            entity = PingIqProtocolEntity(to = YowConstants.DOMAIN)\n            self.toLower(entity)\n\n    ######################################\n\n    ####### contacts/ profiles ####################\n    @clicmd(\"Set status text\")\n    def profile_setStatus(self, text):\n        if self.assertConnected():\n\n            def onSuccess(resultIqEntity, originalIqEntity):\n                self.output(\"Status updated successfully\")\n\n            def onError(errorIqEntity, originalIqEntity):\n                logger.error(\"Error updating status\")\n\n            entity = SetStatusIqProtocolEntity(text)\n            self._sendIq(entity, onSuccess, onError)\n\n    @clicmd(\"Get profile picture for contact\")\n    def contact_picture(self, jid):\n        if self.assertConnected():\n            entity = GetPictureIqProtocolEntity(self.aliasToJid(jid), preview=False)\n            self._sendIq(entity, self.onGetContactPictureResult)\n\n    @clicmd(\"Get profile picture preview for contact\")\n    def contact_picturePreview(self, jid):\n        if self.assertConnected():\n            entity = GetPictureIqProtocolEntity(self.aliasToJid(jid), preview=True)\n            self._sendIq(entity, self.onGetContactPictureResult)\n\n    @clicmd(\"Get lastseen for contact\")\n    def contact_lastseen(self, jid):\n        if self.assertConnected():\n            def onSuccess(resultIqEntity, originalIqEntity):\n                self.output(\"%s lastseen %s seconds ago\" % (resultIqEntity.getFrom(), resultIqEntity.getSeconds()))\n\n            def onError(errorIqEntity, originalIqEntity):\n                logger.error(\"Error getting lastseen information for %s\" % originalIqEntity.getTo())\n\n            entity = LastseenIqProtocolEntity(self.aliasToJid(jid))\n            self._sendIq(entity, onSuccess, onError)\n\n    @clicmd(\"Set profile picture\")\n    def profile_setPicture(self, path):\n        if self.assertConnected():\n            with PILOptionalModule(failMessage = \"No PIL library installed, try install pillow\") as imp:\n                Image = imp(\"Image\")\n                def onSuccess(resultIqEntity, originalIqEntity):\n                    self.output(\"Profile picture updated successfully\")\n\n                def onError(errorIqEntity, originalIqEntity):\n                    logger.error(\"Error updating profile picture\")\n\n                #example by @aesedepece in https://github.com/tgalal/yowsup/pull/781\n                #modified to support python3\n                src = Image.open(path)\n                pictureData = src.resize((640, 640)).tobytes(\"jpeg\", \"RGB\")\n                picturePreview = src.resize((96, 96)).tobytes(\"jpeg\", \"RGB\")\n                iq = SetPictureIqProtocolEntity(self.getOwnJid(), picturePreview, pictureData)\n                self._sendIq(iq, onSuccess, onError)\n\n    @clicmd(\"Get profile privacy\")\n    def profile_getPrivacy(self):\n        if self.assertConnected():\n            def onSuccess(resultIqEntity, originalIqEntity):\n                self.output(\"Profile privacy is: %s\" %(resultIqEntity))\n\n            def onError(errorIqEntity, originalIqEntity):\n                logger.error(\"Error getting profile privacy\")\n\n            iq = GetPrivacyIqProtocolEntity()\n            self._sendIq(iq, onSuccess, onError)\n\n    @clicmd(\"Profile privacy. value=all|contacts|none names=profile|status|last. Names are comma separated, defaults to all.\")\n    def profile_setPrivacy(self, value=\"all\", names=None):\n        if self.assertConnected():\n            def onSuccess(resultIqEntity, originalIqEntity):\n                self.output(\"Profile privacy set to: %s\" %(resultIqEntity))\n\n            def onError(errorIqEntity, originalIqEntity):\n                logger.error(\"Error setting profile privacy\")\n            try:\n                names = [name for name in names.split(',')] if names else None\n                iq = SetPrivacyIqProtocolEntity(value, names)\n                self._sendIq(iq, onSuccess, onError)\n            except Exception as inst:\n                self.output(inst.message)\n                return self.print_usage()\n\n\n    ########### groups\n\n    @clicmd(\"List all groups you belong to\", 5)\n    def groups_list(self):\n        if self.assertConnected():\n            entity = ListGroupsIqProtocolEntity()\n            self.toLower(entity)\n\n    @clicmd(\"Leave a group you belong to\", 4)\n    def group_leave(self, group_jid):\n        if self.assertConnected():\n            entity = LeaveGroupsIqProtocolEntity([self.aliasToJid(group_jid)])\n            self.toLower(entity)\n\n    @clicmd(\"Create a new group with the specified subject and participants. Jids are a comma separated list but optional.\", 3)\n    def groups_create(self, subject, jids = None):\n        if self.assertConnected():\n            jids = [self.aliasToJid(jid) for jid in jids.split(',')] if jids else []\n            entity = CreateGroupsIqProtocolEntity(subject, participants=jids)\n            self.toLower(entity)\n\n    @clicmd(\"Invite to group. Jids are a comma separated list\")\n    def group_invite(self, group_jid, jids):\n        if self.assertConnected():\n            jids = [self.aliasToJid(jid) for jid in jids.split(',')]\n            entity = AddParticipantsIqProtocolEntity(self.aliasToJid(group_jid), jids)\n            self.toLower(entity)\n\n    @clicmd(\"Promote admin of a group. Jids are a comma separated list\")\n    def group_promote(self, group_jid, jids):\n        if self.assertConnected():\n            jids = [self.aliasToJid(jid) for jid in jids.split(',')]\n            entity = PromoteParticipantsIqProtocolEntity(self.aliasToJid(group_jid), jids)\n            self.toLower(entity)\n\n    @clicmd(\"Remove admin of a group. Jids are a comma separated list\")\n    def group_demote(self, group_jid, jids):\n        if self.assertConnected():\n            jids = [self.aliasToJid(jid) for jid in jids.split(',')]\n            entity = DemoteParticipantsIqProtocolEntity(self.aliasToJid(group_jid), jids)\n            self.toLower(entity)\n\n    @clicmd(\"Kick from group. Jids are a comma separated list\")\n    def group_kick(self, group_jid, jids):\n        if self.assertConnected():\n            jids = [self.aliasToJid(jid) for jid in jids.split(',')]\n            entity = RemoveParticipantsIqProtocolEntity(self.aliasToJid(group_jid), jids)\n            self.toLower(entity)\n\n    @clicmd(\"Change group subject\")\n    def group_setSubject(self, group_jid, subject):\n        if self.assertConnected():\n            entity = SubjectGroupsIqProtocolEntity(self.aliasToJid(group_jid), subject)\n            self.toLower(entity)\n\n    @clicmd(\"Set group picture\")\n    def group_picture(self, group_jid, path):\n        if self.assertConnected():\n            with PILOptionalModule(failMessage = self.__class__.FAIL_OPT_PILLOW) as imp:\n                Image = imp(\"Image\")\n\n                def onSuccess(resultIqEntity, originalIqEntity):\n                    self.output(\"Group picture updated successfully\")\n\n                def onError(errorIqEntity, originalIqEntity):\n                    logger.error(\"Error updating Group picture\")\n\n                #example by @aesedepece in https://github.com/tgalal/yowsup/pull/781\n                #modified to support python3\n                src = Image.open(path)\n                pictureData = src.resize((640, 640)).tobytes(\"jpeg\", \"RGB\")\n                picturePreview = src.resize((96, 96)).tobytes(\"jpeg\", \"RGB\")\n                iq = SetPictureIqProtocolEntity(self.aliasToJid(group_jid), picturePreview, pictureData)\n                self._sendIq(iq, onSuccess, onError)\n\n\n    @clicmd(\"Get group info\")\n    def group_info(self, group_jid):\n        if self.assertConnected():\n            entity = InfoGroupsIqProtocolEntity(self.aliasToJid(group_jid))\n            self.toLower(entity)\n\n    @clicmd(\"Get shared keys\")\n    def keys_get(self, jids):\n        with AxolotlOptionalModule(failMessage = self.__class__.FAIL_OPT_AXOLOTL) as importFn:\n            importFn()\n            from yowsup.layers.axolotl.protocolentities.iq_key_get import GetKeysIqProtocolEntity\n            if self.assertConnected():\n                jids = [self.aliasToJid(jid) for jid in jids.split(',')]\n                entity = GetKeysIqProtocolEntity(jids)\n                self.toLower(entity)\n\n    @clicmd(\"Send init seq\")\n    def seq(self):\n        priv = PrivacyListIqProtocolEntity()\n        self.toLower(priv)\n        push = PushIqProtocolEntity()\n        self.toLower(push)\n        props = PropsIqProtocolEntity()\n        self.toLower(props)\n        crypto = CryptoIqProtocolEntity()\n        self.toLower(crypto)\n\n    @clicmd(\"Delete your account\")\n    def account_delete(self):\n        if self.assertConnected():\n            if self.accountDelWarnings < self.__class__.ACCOUNT_DEL_WARNINGS:\n                self.accountDelWarnings += 1\n                remaining = self.__class__.ACCOUNT_DEL_WARNINGS - self.accountDelWarnings\n                self.output(\"Repeat delete command another %s times to send the delete request\" % remaining, tag=\"Account delete Warning !!\", prompt = False)\n            else:\n                entity = UnregisterIqProtocolEntity()\n                self.toLower(entity)\n\n    @clicmd(\"Send message to a friend\")\n    def message_send(self, number, content):\n        if self.assertConnected():\n            outgoingMessage = TextMessageProtocolEntity(content.encode(\"utf-8\") if sys.version_info >= (3,0) else content, to = self.aliasToJid(number))\n            self.toLower(outgoingMessage)\n\n    @clicmd(\"Broadcast message. numbers should comma separated phone numbers\")\n    def message_broadcast(self, numbers, content):\n        if self.assertConnected():\n            jids = [self.aliasToJid(number) for number in numbers.split(',')]\n            outgoingMessage = BroadcastTextMessage(jids, content)\n            self.toLower(outgoingMessage)\n\n    #@clicmd(\"Send read receipt\")\n    def message_read(self, message_id):\n        pass\n\n    #@clicmd(\"Send delivered receipt\")\n    def message_delivered(self, message_id):\n        pass\n\n    @clicmd(\"Send a video with optional caption\")\n    def video_send(self, number, path, caption = None):\n        self.media_send(number, path, RequestUploadIqProtocolEntity.MEDIA_TYPE_VIDEO)\n\n    @clicmd(\"Send an image with optional caption\")\n    def image_send(self, number, path, caption = None):\n        self.media_send(number, path, RequestUploadIqProtocolEntity.MEDIA_TYPE_IMAGE)\n\n    @clicmd(\"Send audio file\")\n    def audio_send(self, number, path):\n        self.media_send(number, path, RequestUploadIqProtocolEntity.MEDIA_TYPE_AUDIO)\n\n    def media_send(self, number, path, mediaType, caption = None):\n        if self.assertConnected():\n            jid = self.aliasToJid(number)\n            entity = RequestUploadIqProtocolEntity(mediaType, filePath=path)\n            successFn = lambda successEntity, originalEntity: self.onRequestUploadResult(jid, mediaType, path, successEntity, originalEntity, caption)\n            errorFn = lambda errorEntity, originalEntity: self.onRequestUploadError(jid, path, errorEntity, originalEntity)\n            self._sendIq(entity, successFn, errorFn)\n\n            self._sendIq(entity, successFn, errorFn)\n    @clicmd(\"Send typing state\")\n    def state_typing(self, jid):\n        if self.assertConnected():\n            entity = OutgoingChatstateProtocolEntity(ChatstateProtocolEntity.STATE_TYPING, self.aliasToJid(jid))\n            self.toLower(entity)\n\n    @clicmd(\"Request contacts statuses\")\n    def statuses_get(self, contacts):\n        if self.assertConnected():\n            entity = GetStatusesIqProtocolEntity([self.aliasToJid(c) for c in contacts.split(',')])\n            self.toLower(entity)\n\n    @clicmd(\"Send paused state\")\n    def state_paused(self, jid):\n        if self.assertConnected():\n            entity = OutgoingChatstateProtocolEntity(ChatstateProtocolEntity.STATE_PAUSED, self.aliasToJid(jid))\n            self.toLower(entity)\n\n    @clicmd(\"Sync contacts, contacts should be comma separated phone numbers, with no spaces\")\n    def contacts_sync(self, contacts):\n        if self.assertConnected():\n            entity = GetSyncIqProtocolEntity(contacts.split(','))\n            self.toLower(entity)\n\n    @clicmd(\"Disconnect\")\n    def disconnect(self):\n        if self.assertConnected():\n\n            self.broadcastEvent(YowLayerEvent(YowNetworkLayer.EVENT_STATE_DISCONNECT))\n\n    @clicmd(\"Quick login\")\n    def L(self):\n        if self.connected:\n            return self.output(\"Already connected, disconnect first\")\n        self.getLayerInterface(YowNetworkLayer).connect()\n        return True\n\n    @clicmd(\"Login to WhatsApp\", 0)\n    def login(self, username, b64password):\n        self.setCredentials(username, b64password)\n        return self.L()\n\n    ######## receive #########\n\n    @ProtocolEntityCallback(\"chatstate\")\n    def onChatstate(self, entity):\n        print(entity)\n\n    @ProtocolEntityCallback(\"iq\")\n    def onIq(self, entity):\n        print(entity)\n\n    @ProtocolEntityCallback(\"receipt\")\n    def onReceipt(self, entity):\n        self.toLower(entity.ack())\n\n    @ProtocolEntityCallback(\"ack\")\n    def onAck(self, entity):\n        #formattedDate = datetime.datetime.fromtimestamp(self.sentCache[entity.getId()][0]).strftime('%d-%m-%Y %H:%M')\n        #print(\"%s [%s]:%s\"%(self.username, formattedDate, self.sentCache[entity.getId()][1]))\n        if entity.getClass() == \"message\":\n            self.output(entity.getId(), tag = \"Sent\")\n            #self.notifyInputThread()\n\n    @ProtocolEntityCallback(\"success\")\n    def onSuccess(self, entity):\n        self.connected = True\n        self.output(\"Logged in!\", \"Auth\", prompt = False)\n        self.notifyInputThread()\n\n    @ProtocolEntityCallback(\"failure\")\n    def onFailure(self, entity):\n        self.connected = False\n        self.output(\"Login Failed, reason: %s\" % entity.getReason(), prompt = False)\n\n    @ProtocolEntityCallback(\"notification\")\n    def onNotification(self, notification):\n        notificationData = notification.__str__()\n        if notificationData:\n            self.output(notificationData, tag = \"Notification\")\n        else:\n            self.output(\"From :%s, Type: %s\" % (self.jidToAlias(notification.getFrom()), notification.getType()), tag = \"Notification\")\n        if self.sendReceipts:\n            self.toLower(notification.ack())\n\n    @ProtocolEntityCallback(\"message\")\n    def onMessage(self, message):\n        messageOut = \"\"\n        if message.getType() == \"text\":\n            #self.output(message.getBody(), tag = \"%s [%s]\"%(message.getFrom(), formattedDate))\n            messageOut = self.getTextMessageBody(message)\n        elif message.getType() == \"media\":\n            messageOut = self.getMediaMessageBody(message)\n        else:\n            messageOut = \"Unknown message type %s \" % message.getType()\n            print(messageOut.toProtocolTreeNode())\n\n\n        formattedDate = datetime.datetime.fromtimestamp(message.getTimestamp()).strftime('%d-%m-%Y %H:%M')\n        sender = message.getFrom() if not message.isGroupMessage() else \"%s/%s\" % (message.getParticipant(False), message.getFrom())\n        output = self.__class__.MESSAGE_FORMAT.format(\n            FROM = sender,\n            TIME = formattedDate,\n            MESSAGE = messageOut.encode('latin-1').decode() if sys.version_info >= (3, 0) else messageOut,\n            MESSAGE_ID = message.getId()\n            )\n\n        self.output(output, tag = None, prompt = not self.sendReceipts)\n        if self.sendReceipts:\n            self.toLower(message.ack(self.sendRead))\n            self.output(\"Sent delivered receipt\"+\" and Read\" if self.sendRead else \"\", tag = \"Message %s\" % message.getId())\n\n\n    def getTextMessageBody(self, message):\n        return message.getBody()\n\n    def getMediaMessageBody(self, message):\n        if message.getMediaType() in (\"image\", \"audio\", \"video\"):\n            return self.getDownloadableMediaMessageBody(message)\n        else:\n            return \"[Media Type: %s]\" % message.getMediaType()\n\n\n    def getDownloadableMediaMessageBody(self, message):\n         return \"[Media Type:{media_type}, Size:{media_size}, URL:{media_url}]\".format(\n            media_type = message.getMediaType(),\n            media_size = message.getMediaSize(),\n            media_url = message.getMediaUrl()\n            )\n\n    def doSendMedia(self, mediaType, filePath, url, to, ip = None, caption = None):\n        if mediaType == RequestUploadIqProtocolEntity.MEDIA_TYPE_IMAGE:\n        \tentity = ImageDownloadableMediaMessageProtocolEntity.fromFilePath(filePath, url, ip, to, caption = caption)\n        elif mediaType == RequestUploadIqProtocolEntity.MEDIA_TYPE_AUDIO:\n        \tentity = AudioDownloadableMediaMessageProtocolEntity.fromFilePath(filePath, url, ip, to)\n        elif mediaType == RequestUploadIqProtocolEntity.MEDIA_TYPE_VIDEO:\n        \tentity = VideoDownloadableMediaMessageProtocolEntity.fromFilePath(filePath, url, ip, to, caption = caption)\n        self.toLower(entity)\n\n    def __str__(self):\n        return \"CLI Interface Layer\"\n\n    ########### callbacks ############\n\n    def onRequestUploadResult(self, jid, mediaType, filePath, resultRequestUploadIqProtocolEntity, requestUploadIqProtocolEntity, caption = None):\n\n        if resultRequestUploadIqProtocolEntity.isDuplicate():\n            self.doSendMedia(mediaType, filePath, resultRequestUploadIqProtocolEntity.getUrl(), jid,\n                             resultRequestUploadIqProtocolEntity.getIp(), caption)\n        else:\n            successFn = lambda filePath, jid, url: self.doSendMedia(mediaType, filePath, url, jid, resultRequestUploadIqProtocolEntity.getIp(), caption)\n            mediaUploader = MediaUploader(jid, self.getOwnJid(), filePath,\n                                      resultRequestUploadIqProtocolEntity.getUrl(),\n                                      resultRequestUploadIqProtocolEntity.getResumeOffset(),\n                                      successFn, self.onUploadError, self.onUploadProgress, async=False)\n            mediaUploader.start()\n\n    def onRequestUploadError(self, jid, path, errorRequestUploadIqProtocolEntity, requestUploadIqProtocolEntity):\n        logger.error(\"Request upload for file %s for %s failed\" % (path, jid))\n\n    def onUploadError(self, filePath, jid, url):\n        logger.error(\"Upload file %s to %s for %s failed!\" % (filePath, url, jid))\n\n    def onUploadProgress(self, filePath, jid, url, progress):\n        sys.stdout.write(\"%s => %s, %d%% \\r\" % (os.path.basename(filePath), jid, progress))\n        sys.stdout.flush()\n\n    def onGetContactPictureResult(self, resultGetPictureIqProtocolEntiy, getPictureIqProtocolEntity):\n        # do here whatever you want\n        # write to a file\n        # or open\n        # or do nothing\n        # write to file example:\n        #resultGetPictureIqProtocolEntiy.writeToFile(\"/tmp/yowpics/%s_%s.jpg\" % (getPictureIqProtocolEntity.getTo(), \"preview\" if resultGetPictureIqProtocolEntiy.isPreview() else \"full\"))\n        pass\n\n    def __str__(self):\n        return \"CLI Interface Layer\"\n\n    @clicmd(\"Print this message\")\n    def help(self):\n        self.print_usage()\n", "description": "The python WhatsApp library", "file_name": "layer.py", "id": "1d1e1ba90926602a06d462c231c8e4e2", "language": "Python", "project_name": "yowsup", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tgalal-yowsup/tgalal-yowsup-03795cc/yowsup/demos/cli/layer.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:01:40Z", "url": "https://github.com/tgalal/yowsup", "wiki": true}