{"author": "facebookresearch", "code": " Copyright (c) 2017-present, Facebook, Inc.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nimport numpy as np\nimport unittest\n\nfrom pycocotools import mask as COCOmask\n\nimport utils.boxes as box_utils\n\n\ndef random_boxes(mean_box, stdev, N):\n    boxes = np.random.randn(N, 4) * stdev + mean_box\n    return boxes.astype(dtype=np.float32)\n\n\nclass TestBboxTransform(unittest.TestCase):\n    def test_bbox_transform_and_inverse(self):\n        weights = (5, 5, 10, 10)\n        src_boxes = random_boxes([10, 10, 20, 20], 1, 10)\n        dst_boxes = random_boxes([10, 10, 20, 20], 1, 10)\n        deltas = box_utils.bbox_transform_inv(\n            src_boxes, dst_boxes, weights=weights\n        )\n        dst_boxes_reconstructed = box_utils.bbox_transform(\n            src_boxes, deltas, weights=weights\n        )\n        np.testing.assert_array_almost_equal(\n            dst_boxes, dst_boxes_reconstructed, decimal=5\n        )\n\n    def test_bbox_dataset_to_prediction_roundtrip(self):\n        \"\"\"Simulate the process of reading a ground-truth box from a dataset,\n        make predictions from proposals, convert the predictions back to the\n        dataset format, and then use the COCO API to compute IoU overlap between\n        the gt box and the predictions. These should have IoU of 1.\n        \"\"\"\n        weights = (5, 5, 10, 10)\n         1/ \"read\" a box from a dataset in the default (x1, y1, w, h) format\n        gt_xywh_box = [10, 20, 100, 150]\n         2/ convert it to our internal (x1, y1, x2, y2) format\n        gt_xyxy_box = box_utils.xywh_to_xyxy(gt_xywh_box)\n         3/ consider nearby proposal boxes\n        prop_xyxy_boxes = random_boxes(gt_xyxy_box, 10, 10)\n         4/ compute proposal-to-gt transformation deltas\n        deltas = box_utils.bbox_transform_inv(\n            prop_xyxy_boxes, np.array([gt_xyxy_box]), weights=weights\n        )\n         5/ use deltas to transform proposals to xyxy predicted box\n        pred_xyxy_boxes = box_utils.bbox_transform(\n            prop_xyxy_boxes, deltas, weights=weights\n        )\n         6/ convert xyxy predicted box to xywh predicted box\n        pred_xywh_boxes = box_utils.xyxy_to_xywh(pred_xyxy_boxes)\n         7/ use COCO API to compute IoU\n        not_crowd = [int(False)] * pred_xywh_boxes.shape[0]\n        ious = COCOmask.iou(pred_xywh_boxes, np.array([gt_xywh_box]), not_crowd)\n        np.testing.assert_array_almost_equal(ious, np.ones(ious.shape))\n\n    def test_cython_bbox_iou_against_coco_api_bbox_iou(self):\n        \"\"\"Check that our cython implementation of bounding box IoU overlap\n        matches the COCO API implementation.\n        \"\"\"\n        def _do_test(b1, b2):\n             Compute IoU overlap with the cython implementation\n            cython_iou = box_utils.bbox_overlaps(b1, b2)\n             Compute IoU overlap with the COCO API implementation\n             (requires converting boxes from xyxy to xywh format)\n            xywh_b1 = box_utils.xyxy_to_xywh(b1)\n            xywh_b2 = box_utils.xyxy_to_xywh(b2)\n            not_crowd = [int(False)] * b2.shape[0]\n            coco_ious = COCOmask.iou(xywh_b1, xywh_b2, not_crowd)\n             IoUs should be similar\n            np.testing.assert_array_almost_equal(\n                cython_iou, coco_ious, decimal=5\n            )\n\n         Test small boxes\n        b1 = random_boxes([10, 10, 20, 20], 5, 10)\n        b2 = random_boxes([10, 10, 20, 20], 5, 10)\n        _do_test(b1, b2)\n\n         Test bigger boxes\n        b1 = random_boxes([10, 10, 110, 20], 20, 10)\n        b2 = random_boxes([10, 10, 110, 20], 20, 10)\n        _do_test(b1, b2)\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "comments": "   simulate process reading ground truth box dataset          make predictions proposals  convert predictions back         dataset format  use coco api compute iou overlap         gt box predictions  these iou 1                      weights   (5  5  10  10)           1   read  box dataset default (x1  y1  w  h) format         gt xywh box    10  20  100  150            2  convert internal (x1  y1  x2  y2) format         gt xyxy box   box utils xywh xyxy(gt xywh box)           3  consider nearby proposal boxes         prop xyxy boxes   random boxes(gt xyxy box  10  10)           4  compute proposal gt transformation deltas         deltas   box utils bbox transform inv(             prop xyxy boxes  np array( gt xyxy box )  weights weights         )           5  use deltas transform proposals xyxy predicted box         pred xyxy boxes   box utils bbox transform(             prop xyxy boxes  deltas  weights weights         )           6  convert xyxy predicted box xywh predicted box         pred xywh boxes   box utils xyxy xywh(pred xyxy boxes)           7  use coco api compute iou         crowd    int(false)    pred xywh boxes shape 0          ious   cocomask iou(pred xywh boxes  np array( gt xywh box )  crowd)         np testing assert array almost equal(ious  np ones(ious shape))      def test cython bbox iou coco api bbox iou(self)             check cython implementation bounding box iou overlap         matches coco api implementation                 copyright (c) 2017 present  facebook  inc        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license           http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license                                                                                     1   read  box dataset default (x1  y1  w  h) format    2  convert internal (x1  y1  x2  y2) format    3  consider nearby proposal boxes    4  compute proposal gt transformation deltas    5  use deltas transform proposals xyxy predicted box    6  convert xyxy predicted box xywh predicted box    7  use coco api compute iou    compute iou overlap cython implementation    compute iou overlap coco api implementation    (requires converting boxes xyxy xywh format)    ious similar    test small boxes    test bigger boxes ", "content": "# Copyright (c) 2017-present, Facebook, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n##############################################################################\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nimport numpy as np\nimport unittest\n\nfrom pycocotools import mask as COCOmask\n\nimport utils.boxes as box_utils\n\n\ndef random_boxes(mean_box, stdev, N):\n    boxes = np.random.randn(N, 4) * stdev + mean_box\n    return boxes.astype(dtype=np.float32)\n\n\nclass TestBboxTransform(unittest.TestCase):\n    def test_bbox_transform_and_inverse(self):\n        weights = (5, 5, 10, 10)\n        src_boxes = random_boxes([10, 10, 20, 20], 1, 10)\n        dst_boxes = random_boxes([10, 10, 20, 20], 1, 10)\n        deltas = box_utils.bbox_transform_inv(\n            src_boxes, dst_boxes, weights=weights\n        )\n        dst_boxes_reconstructed = box_utils.bbox_transform(\n            src_boxes, deltas, weights=weights\n        )\n        np.testing.assert_array_almost_equal(\n            dst_boxes, dst_boxes_reconstructed, decimal=5\n        )\n\n    def test_bbox_dataset_to_prediction_roundtrip(self):\n        \"\"\"Simulate the process of reading a ground-truth box from a dataset,\n        make predictions from proposals, convert the predictions back to the\n        dataset format, and then use the COCO API to compute IoU overlap between\n        the gt box and the predictions. These should have IoU of 1.\n        \"\"\"\n        weights = (5, 5, 10, 10)\n        # 1/ \"read\" a box from a dataset in the default (x1, y1, w, h) format\n        gt_xywh_box = [10, 20, 100, 150]\n        # 2/ convert it to our internal (x1, y1, x2, y2) format\n        gt_xyxy_box = box_utils.xywh_to_xyxy(gt_xywh_box)\n        # 3/ consider nearby proposal boxes\n        prop_xyxy_boxes = random_boxes(gt_xyxy_box, 10, 10)\n        # 4/ compute proposal-to-gt transformation deltas\n        deltas = box_utils.bbox_transform_inv(\n            prop_xyxy_boxes, np.array([gt_xyxy_box]), weights=weights\n        )\n        # 5/ use deltas to transform proposals to xyxy predicted box\n        pred_xyxy_boxes = box_utils.bbox_transform(\n            prop_xyxy_boxes, deltas, weights=weights\n        )\n        # 6/ convert xyxy predicted box to xywh predicted box\n        pred_xywh_boxes = box_utils.xyxy_to_xywh(pred_xyxy_boxes)\n        # 7/ use COCO API to compute IoU\n        not_crowd = [int(False)] * pred_xywh_boxes.shape[0]\n        ious = COCOmask.iou(pred_xywh_boxes, np.array([gt_xywh_box]), not_crowd)\n        np.testing.assert_array_almost_equal(ious, np.ones(ious.shape))\n\n    def test_cython_bbox_iou_against_coco_api_bbox_iou(self):\n        \"\"\"Check that our cython implementation of bounding box IoU overlap\n        matches the COCO API implementation.\n        \"\"\"\n        def _do_test(b1, b2):\n            # Compute IoU overlap with the cython implementation\n            cython_iou = box_utils.bbox_overlaps(b1, b2)\n            # Compute IoU overlap with the COCO API implementation\n            # (requires converting boxes from xyxy to xywh format)\n            xywh_b1 = box_utils.xyxy_to_xywh(b1)\n            xywh_b2 = box_utils.xyxy_to_xywh(b2)\n            not_crowd = [int(False)] * b2.shape[0]\n            coco_ious = COCOmask.iou(xywh_b1, xywh_b2, not_crowd)\n            # IoUs should be similar\n            np.testing.assert_array_almost_equal(\n                cython_iou, coco_ious, decimal=5\n            )\n\n        # Test small boxes\n        b1 = random_boxes([10, 10, 20, 20], 5, 10)\n        b2 = random_boxes([10, 10, 20, 20], 5, 10)\n        _do_test(b1, b2)\n\n        # Test bigger boxes\n        b1 = random_boxes([10, 10, 110, 20], 20, 10)\n        b2 = random_boxes([10, 10, 110, 20], 20, 10)\n        _do_test(b1, b2)\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "description": "FAIR's research platform for object detection research, implementing popular algorithms like Mask R-CNN and RetinaNet.", "file_name": "test_bbox_transform.py", "id": "afe76e837432f857f2d728eca2a14d7c", "language": "Python", "project_name": "Detectron", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/facebookresearch-Detectron/facebookresearch-Detectron-a026d77/tests/test_bbox_transform.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:00:46Z", "url": "https://github.com/facebookresearch/Detectron", "wiki": false}