{"author": "django", "code": "from django.apps import apps\nfrom django.contrib.contenttypes.fields import (\n    GenericForeignKey, GenericRelation,\n)\nfrom django.core.exceptions import FieldDoesNotExist\nfrom django.db.models.fields import CharField, Field, related\nfrom django.db.models.options import EMPTY_RELATION_TREE, IMMUTABLE_WARNING\nfrom django.test import SimpleTestCase\n\nfrom .models import (\n    AbstractPerson, BasePerson, Child, CommonAncestor, FirstParent, Person,\n    ProxyPerson, Relating, Relation, SecondParent,\n)\nfrom .results import TEST_RESULTS\n\n\nclass OptionsBaseTests(SimpleTestCase):\n\n    def _map_related_query_names(self, res):\n        return tuple((o.name, m) for o, m in res)\n\n    def _map_names(self, res):\n        return tuple((f.name, m) for f, m in res)\n\n    def _model(self, current_model, field):\n        model = field.model._meta.concrete_model\n        return None if model == current_model else model\n\n    def _details(self, current_model, relation):\n        direct = isinstance(relation, Field) or isinstance(relation, GenericForeignKey)\n        model = relation.model._meta.concrete_model\n        if model == current_model:\n            model = None\n\n        field = relation if direct else relation.field\n        return relation, model, direct, bool(field.many_to_many)  \n\n\nclass GetFieldsTests(OptionsBaseTests):\n\n    def test_get_fields_is_immutable(self):\n        msg = IMMUTABLE_WARNING % \"get_fields()\"\n        for _ in range(2):\n            \n            \n            fields = Person._meta.get_fields()\n            with self.assertRaisesMessage(AttributeError, msg):\n                fields += [\"errors\"]\n\n\nclass LabelTests(OptionsBaseTests):\n\n    def test_label(self):\n        for model, expected_result in TEST_RESULTS['labels'].items():\n            self.assertEqual(model._meta.label, expected_result)\n\n    def test_label_lower(self):\n        for model, expected_result in TEST_RESULTS['lower_labels'].items():\n            self.assertEqual(model._meta.label_lower, expected_result)\n\n\nclass DataTests(OptionsBaseTests):\n\n    def test_fields(self):\n        for model, expected_result in TEST_RESULTS['fields'].items():\n            fields = model._meta.fields\n            self.assertEqual([f.attname for f in fields], expected_result)\n\n    def test_local_fields(self):\n        def is_data_field(f):\n            return isinstance(f, Field) and not f.many_to_many\n\n        for model, expected_result in TEST_RESULTS['local_fields'].items():\n            fields = model._meta.local_fields\n            self.assertEqual([f.attname for f in fields], expected_result)\n            for f in fields:\n                self.assertEqual(f.model, model)\n                self.assertTrue(is_data_field(f))\n\n    def test_local_concrete_fields(self):\n        for model, expected_result in TEST_RESULTS['local_concrete_fields'].items():\n            fields = model._meta.local_concrete_fields\n            self.assertEqual([f.attname for f in fields], expected_result)\n            for f in fields:\n                self.assertIsNotNone(f.column)\n\n\nclass M2MTests(OptionsBaseTests):\n\n    def test_many_to_many(self):\n        for model, expected_result in TEST_RESULTS['many_to_many'].items():\n            fields = model._meta.many_to_many\n            self.assertEqual([f.attname for f in fields], expected_result)\n            for f in fields:\n                self.assertTrue(f.many_to_many and f.is_relation)\n\n    def test_many_to_many_with_model(self):\n        for model, expected_result in TEST_RESULTS['many_to_many_with_model'].items():\n            models = [self._model(model, field) for field in model._meta.many_to_many]\n            self.assertEqual(models, expected_result)\n\n\nclass RelatedObjectsTests(OptionsBaseTests):\n    def key_name(self, r):\n        return r[0]\n\n    def test_related_objects(self):\n        result_key = 'get_all_related_objects_with_model'\n        for model, expected in TEST_RESULTS[result_key].items():\n            objects = [\n                (field, self._model(model, field))\n                for field in model._meta.get_fields()\n                if field.auto_created and not field.concrete\n            ]\n            self.assertEqual(\n                sorted(self._map_related_query_names(objects), key=self.key_name),\n                sorted(expected, key=self.key_name),\n            )\n\n    def test_related_objects_local(self):\n        result_key = 'get_all_related_objects_with_model_local'\n        for model, expected in TEST_RESULTS[result_key].items():\n            objects = [\n                (field, self._model(model, field))\n                for field in model._meta.get_fields(include_parents=False)\n                if field.auto_created and not field.concrete\n            ]\n            self.assertEqual(\n                sorted(self._map_related_query_names(objects), key=self.key_name),\n                sorted(expected, key=self.key_name),\n            )\n\n    def test_related_objects_include_hidden(self):\n        result_key = 'get_all_related_objects_with_model_hidden'\n        for model, expected in TEST_RESULTS[result_key].items():\n            objects = [\n                (field, self._model(model, field))\n                for field in model._meta.get_fields(include_hidden=True)\n                if field.auto_created and not field.concrete\n            ]\n            self.assertEqual(\n                sorted(self._map_names(objects), key=self.key_name),\n                sorted(expected, key=self.key_name)\n            )\n\n    def test_related_objects_include_hidden_local_only(self):\n        result_key = 'get_all_related_objects_with_model_hidden_local'\n        for model, expected in TEST_RESULTS[result_key].items():\n            objects = [\n                (field, self._model(model, field))\n                for field in model._meta.get_fields(include_hidden=True, include_parents=False)\n                if field.auto_created and not field.concrete\n            ]\n            self.assertEqual(\n                sorted(self._map_names(objects), key=self.key_name),\n                sorted(expected, key=self.key_name)\n            )\n\n\nclass PrivateFieldsTests(OptionsBaseTests):\n\n    def test_private_fields(self):\n        for model, expected_names in TEST_RESULTS['private_fields'].items():\n            objects = model._meta.private_fields\n            self.assertEqual(sorted(f.name for f in objects), sorted(expected_names))\n\n\nclass GetFieldByNameTests(OptionsBaseTests):\n\n    def test_get_data_field(self):\n        field_info = self._details(Person, Person._meta.get_field('data_abstract'))\n        self.assertEqual(field_info[1:], (BasePerson, True, False))\n        self.assertIsInstance(field_info[0], CharField)\n\n    def test_get_m2m_field(self):\n        field_info = self._details(Person, Person._meta.get_field('m2m_base'))\n        self.assertEqual(field_info[1:], (BasePerson, True, True))\n        self.assertIsInstance(field_info[0], related.ManyToManyField)\n\n    def test_get_related_object(self):\n        field_info = self._details(Person, Person._meta.get_field('relating_baseperson'))\n        self.assertEqual(field_info[1:], (BasePerson, False, False))\n        self.assertIsInstance(field_info[0], related.ForeignObjectRel)\n\n    def test_get_related_m2m(self):\n        field_info = self._details(Person, Person._meta.get_field('relating_people'))\n        self.assertEqual(field_info[1:], (None, False, True))\n        self.assertIsInstance(field_info[0], related.ForeignObjectRel)\n\n    def test_get_generic_relation(self):\n        field_info = self._details(Person, Person._meta.get_field('generic_relation_base'))\n        self.assertEqual(field_info[1:], (None, True, False))\n        self.assertIsInstance(field_info[0], GenericRelation)\n\n    def test_get_fields_only_searches_forward_on_apps_not_ready(self):\n        opts = Person._meta\n        # If apps registry is not ready, get_field() searches over only\n        \n        opts.apps.models_ready = False\n        try:\n            \n            self.assertTrue(opts.get_field('data_abstract'))\n            msg = (\n                \"Person has no field named 'relating_baseperson'. The app \"\n                \"cache isn't ready yet, so if this is an auto-created related \"\n                \"field, it won't be available yet.\"\n            )\n            \n            with self.assertRaisesMessage(FieldDoesNotExist, msg):\n                opts.get_field('relating_baseperson')\n        finally:\n            opts.apps.models_ready = True\n\n\nclass RelationTreeTests(SimpleTestCase):\n    all_models = (Relation, AbstractPerson, BasePerson, Person, ProxyPerson, Relating)\n\n    def setUp(self):\n        apps.clear_cache()\n\n    def test_clear_cache_clears_relation_tree(self):\n        # The apps.clear_cache is setUp() should have deleted all trees.\n        \n        \n        all_models_with_cache = (m for m in self.all_models if not m._meta.abstract)\n        for m in all_models_with_cache:\n            self.assertNotIn('_relation_tree', m._meta.__dict__)\n\n    def test_first_relation_tree_access_populates_all(self):\n        \n        self.assertTrue(self.all_models[0]._meta._relation_tree)\n\n        \n        \n        self.assertEqual(AbstractPerson._meta._relation_tree, EMPTY_RELATION_TREE)\n\n        \n        \n        all_models_but_abstractperson = (m for m in self.all_models if m is not AbstractPerson)\n        for m in all_models_but_abstractperson:\n            self.assertIn('_relation_tree', m._meta.__dict__)\n\n    def test_relations_related_objects(self):\n        \n        self.assertEqual(\n            sorted(field.related_query_name() for field in Relation._meta._relation_tree\n                   if not field.remote_field.field.remote_field.is_hidden()),\n            sorted([\n                'fk_abstract_rel', 'fk_base_rel', 'fk_concrete_rel', 'fo_abstract_rel',\n                'fo_base_rel', 'fo_concrete_rel', 'm2m_abstract_rel',\n                'm2m_base_rel', 'm2m_concrete_rel'\n            ])\n        )\n        \n        self.assertEqual(\n            sorted(field.related_query_name() for field in BasePerson._meta._relation_tree),\n            sorted([\n                '+', '_relating_basepeople_hidden_+', 'BasePerson_following_abstract+',\n                'BasePerson_following_abstract+', 'BasePerson_following_base+', 'BasePerson_following_base+',\n                'BasePerson_friends_abstract+', 'BasePerson_friends_abstract+', 'BasePerson_friends_base+',\n                'BasePerson_friends_base+', 'BasePerson_m2m_abstract+', 'BasePerson_m2m_base+', 'Relating_basepeople+',\n                'Relating_basepeople_hidden+', 'followers_abstract', 'followers_base', 'friends_abstract_rel_+',\n                'friends_base_rel_+', 'person', 'relating_basepeople', 'relating_baseperson',\n            ])\n        )\n        self.assertEqual([field.related_query_name() for field in AbstractPerson._meta._relation_tree], [])\n\n\nclass ParentListTests(SimpleTestCase):\n    def test_get_parent_list(self):\n        self.assertEqual(CommonAncestor._meta.get_parent_list(), [])\n        self.assertEqual(FirstParent._meta.get_parent_list(), [CommonAncestor])\n        self.assertEqual(SecondParent._meta.get_parent_list(), [CommonAncestor])\n        self.assertEqual(Child._meta.get_parent_list(), [FirstParent, SecondParent, CommonAncestor])\n\n\nclass PropertyNamesTests(SimpleTestCase):\n    def test_person(self):\n        \n        self.assertEqual(AbstractPerson().test_instance_only_descriptor, 1)\n        self.assertEqual(AbstractPerson._meta._property_names, frozenset(['pk', 'test_property']))\n", "comments": "  many many none    running unit test twice ensure non cached cached result    immutable     if apps registry ready  get field() searches    forward fields      data abstract  forward field  therefore found     data abstract  reverse field  raise exception    the apps clear cache setup() deleted trees     exclude abstract models included apps registry    cache     on first access  relation tree populated cache     abstractperson relations  relation tree    return empty relation tree     all models already relation tree    internal   dict        testing non hidden related objects    testing hidden related objects    instance descriptors appear  property names  ", "content": "from django.apps import apps\nfrom django.contrib.contenttypes.fields import (\n    GenericForeignKey, GenericRelation,\n)\nfrom django.core.exceptions import FieldDoesNotExist\nfrom django.db.models.fields import CharField, Field, related\nfrom django.db.models.options import EMPTY_RELATION_TREE, IMMUTABLE_WARNING\nfrom django.test import SimpleTestCase\n\nfrom .models import (\n    AbstractPerson, BasePerson, Child, CommonAncestor, FirstParent, Person,\n    ProxyPerson, Relating, Relation, SecondParent,\n)\nfrom .results import TEST_RESULTS\n\n\nclass OptionsBaseTests(SimpleTestCase):\n\n    def _map_related_query_names(self, res):\n        return tuple((o.name, m) for o, m in res)\n\n    def _map_names(self, res):\n        return tuple((f.name, m) for f, m in res)\n\n    def _model(self, current_model, field):\n        model = field.model._meta.concrete_model\n        return None if model == current_model else model\n\n    def _details(self, current_model, relation):\n        direct = isinstance(relation, Field) or isinstance(relation, GenericForeignKey)\n        model = relation.model._meta.concrete_model\n        if model == current_model:\n            model = None\n\n        field = relation if direct else relation.field\n        return relation, model, direct, bool(field.many_to_many)  # many_to_many can be None\n\n\nclass GetFieldsTests(OptionsBaseTests):\n\n    def test_get_fields_is_immutable(self):\n        msg = IMMUTABLE_WARNING % \"get_fields()\"\n        for _ in range(2):\n            # Running unit test twice to ensure both non-cached and cached result\n            # are immutable.\n            fields = Person._meta.get_fields()\n            with self.assertRaisesMessage(AttributeError, msg):\n                fields += [\"errors\"]\n\n\nclass LabelTests(OptionsBaseTests):\n\n    def test_label(self):\n        for model, expected_result in TEST_RESULTS['labels'].items():\n            self.assertEqual(model._meta.label, expected_result)\n\n    def test_label_lower(self):\n        for model, expected_result in TEST_RESULTS['lower_labels'].items():\n            self.assertEqual(model._meta.label_lower, expected_result)\n\n\nclass DataTests(OptionsBaseTests):\n\n    def test_fields(self):\n        for model, expected_result in TEST_RESULTS['fields'].items():\n            fields = model._meta.fields\n            self.assertEqual([f.attname for f in fields], expected_result)\n\n    def test_local_fields(self):\n        def is_data_field(f):\n            return isinstance(f, Field) and not f.many_to_many\n\n        for model, expected_result in TEST_RESULTS['local_fields'].items():\n            fields = model._meta.local_fields\n            self.assertEqual([f.attname for f in fields], expected_result)\n            for f in fields:\n                self.assertEqual(f.model, model)\n                self.assertTrue(is_data_field(f))\n\n    def test_local_concrete_fields(self):\n        for model, expected_result in TEST_RESULTS['local_concrete_fields'].items():\n            fields = model._meta.local_concrete_fields\n            self.assertEqual([f.attname for f in fields], expected_result)\n            for f in fields:\n                self.assertIsNotNone(f.column)\n\n\nclass M2MTests(OptionsBaseTests):\n\n    def test_many_to_many(self):\n        for model, expected_result in TEST_RESULTS['many_to_many'].items():\n            fields = model._meta.many_to_many\n            self.assertEqual([f.attname for f in fields], expected_result)\n            for f in fields:\n                self.assertTrue(f.many_to_many and f.is_relation)\n\n    def test_many_to_many_with_model(self):\n        for model, expected_result in TEST_RESULTS['many_to_many_with_model'].items():\n            models = [self._model(model, field) for field in model._meta.many_to_many]\n            self.assertEqual(models, expected_result)\n\n\nclass RelatedObjectsTests(OptionsBaseTests):\n    def key_name(self, r):\n        return r[0]\n\n    def test_related_objects(self):\n        result_key = 'get_all_related_objects_with_model'\n        for model, expected in TEST_RESULTS[result_key].items():\n            objects = [\n                (field, self._model(model, field))\n                for field in model._meta.get_fields()\n                if field.auto_created and not field.concrete\n            ]\n            self.assertEqual(\n                sorted(self._map_related_query_names(objects), key=self.key_name),\n                sorted(expected, key=self.key_name),\n            )\n\n    def test_related_objects_local(self):\n        result_key = 'get_all_related_objects_with_model_local'\n        for model, expected in TEST_RESULTS[result_key].items():\n            objects = [\n                (field, self._model(model, field))\n                for field in model._meta.get_fields(include_parents=False)\n                if field.auto_created and not field.concrete\n            ]\n            self.assertEqual(\n                sorted(self._map_related_query_names(objects), key=self.key_name),\n                sorted(expected, key=self.key_name),\n            )\n\n    def test_related_objects_include_hidden(self):\n        result_key = 'get_all_related_objects_with_model_hidden'\n        for model, expected in TEST_RESULTS[result_key].items():\n            objects = [\n                (field, self._model(model, field))\n                for field in model._meta.get_fields(include_hidden=True)\n                if field.auto_created and not field.concrete\n            ]\n            self.assertEqual(\n                sorted(self._map_names(objects), key=self.key_name),\n                sorted(expected, key=self.key_name)\n            )\n\n    def test_related_objects_include_hidden_local_only(self):\n        result_key = 'get_all_related_objects_with_model_hidden_local'\n        for model, expected in TEST_RESULTS[result_key].items():\n            objects = [\n                (field, self._model(model, field))\n                for field in model._meta.get_fields(include_hidden=True, include_parents=False)\n                if field.auto_created and not field.concrete\n            ]\n            self.assertEqual(\n                sorted(self._map_names(objects), key=self.key_name),\n                sorted(expected, key=self.key_name)\n            )\n\n\nclass PrivateFieldsTests(OptionsBaseTests):\n\n    def test_private_fields(self):\n        for model, expected_names in TEST_RESULTS['private_fields'].items():\n            objects = model._meta.private_fields\n            self.assertEqual(sorted(f.name for f in objects), sorted(expected_names))\n\n\nclass GetFieldByNameTests(OptionsBaseTests):\n\n    def test_get_data_field(self):\n        field_info = self._details(Person, Person._meta.get_field('data_abstract'))\n        self.assertEqual(field_info[1:], (BasePerson, True, False))\n        self.assertIsInstance(field_info[0], CharField)\n\n    def test_get_m2m_field(self):\n        field_info = self._details(Person, Person._meta.get_field('m2m_base'))\n        self.assertEqual(field_info[1:], (BasePerson, True, True))\n        self.assertIsInstance(field_info[0], related.ManyToManyField)\n\n    def test_get_related_object(self):\n        field_info = self._details(Person, Person._meta.get_field('relating_baseperson'))\n        self.assertEqual(field_info[1:], (BasePerson, False, False))\n        self.assertIsInstance(field_info[0], related.ForeignObjectRel)\n\n    def test_get_related_m2m(self):\n        field_info = self._details(Person, Person._meta.get_field('relating_people'))\n        self.assertEqual(field_info[1:], (None, False, True))\n        self.assertIsInstance(field_info[0], related.ForeignObjectRel)\n\n    def test_get_generic_relation(self):\n        field_info = self._details(Person, Person._meta.get_field('generic_relation_base'))\n        self.assertEqual(field_info[1:], (None, True, False))\n        self.assertIsInstance(field_info[0], GenericRelation)\n\n    def test_get_fields_only_searches_forward_on_apps_not_ready(self):\n        opts = Person._meta\n        # If apps registry is not ready, get_field() searches over only\n        # forward fields.\n        opts.apps.models_ready = False\n        try:\n            # 'data_abstract' is a forward field, and therefore will be found\n            self.assertTrue(opts.get_field('data_abstract'))\n            msg = (\n                \"Person has no field named 'relating_baseperson'. The app \"\n                \"cache isn't ready yet, so if this is an auto-created related \"\n                \"field, it won't be available yet.\"\n            )\n            # 'data_abstract' is a reverse field, and will raise an exception\n            with self.assertRaisesMessage(FieldDoesNotExist, msg):\n                opts.get_field('relating_baseperson')\n        finally:\n            opts.apps.models_ready = True\n\n\nclass RelationTreeTests(SimpleTestCase):\n    all_models = (Relation, AbstractPerson, BasePerson, Person, ProxyPerson, Relating)\n\n    def setUp(self):\n        apps.clear_cache()\n\n    def test_clear_cache_clears_relation_tree(self):\n        # The apps.clear_cache is setUp() should have deleted all trees.\n        # Exclude abstract models that are not included in the Apps registry\n        # and have no cache.\n        all_models_with_cache = (m for m in self.all_models if not m._meta.abstract)\n        for m in all_models_with_cache:\n            self.assertNotIn('_relation_tree', m._meta.__dict__)\n\n    def test_first_relation_tree_access_populates_all(self):\n        # On first access, relation tree should have populated cache.\n        self.assertTrue(self.all_models[0]._meta._relation_tree)\n\n        # AbstractPerson does not have any relations, so relation_tree\n        # should just return an EMPTY_RELATION_TREE.\n        self.assertEqual(AbstractPerson._meta._relation_tree, EMPTY_RELATION_TREE)\n\n        # All the other models should already have their relation tree\n        # in the internal __dict__ .\n        all_models_but_abstractperson = (m for m in self.all_models if m is not AbstractPerson)\n        for m in all_models_but_abstractperson:\n            self.assertIn('_relation_tree', m._meta.__dict__)\n\n    def test_relations_related_objects(self):\n        # Testing non hidden related objects\n        self.assertEqual(\n            sorted(field.related_query_name() for field in Relation._meta._relation_tree\n                   if not field.remote_field.field.remote_field.is_hidden()),\n            sorted([\n                'fk_abstract_rel', 'fk_base_rel', 'fk_concrete_rel', 'fo_abstract_rel',\n                'fo_base_rel', 'fo_concrete_rel', 'm2m_abstract_rel',\n                'm2m_base_rel', 'm2m_concrete_rel'\n            ])\n        )\n        # Testing hidden related objects\n        self.assertEqual(\n            sorted(field.related_query_name() for field in BasePerson._meta._relation_tree),\n            sorted([\n                '+', '_relating_basepeople_hidden_+', 'BasePerson_following_abstract+',\n                'BasePerson_following_abstract+', 'BasePerson_following_base+', 'BasePerson_following_base+',\n                'BasePerson_friends_abstract+', 'BasePerson_friends_abstract+', 'BasePerson_friends_base+',\n                'BasePerson_friends_base+', 'BasePerson_m2m_abstract+', 'BasePerson_m2m_base+', 'Relating_basepeople+',\n                'Relating_basepeople_hidden+', 'followers_abstract', 'followers_base', 'friends_abstract_rel_+',\n                'friends_base_rel_+', 'person', 'relating_basepeople', 'relating_baseperson',\n            ])\n        )\n        self.assertEqual([field.related_query_name() for field in AbstractPerson._meta._relation_tree], [])\n\n\nclass ParentListTests(SimpleTestCase):\n    def test_get_parent_list(self):\n        self.assertEqual(CommonAncestor._meta.get_parent_list(), [])\n        self.assertEqual(FirstParent._meta.get_parent_list(), [CommonAncestor])\n        self.assertEqual(SecondParent._meta.get_parent_list(), [CommonAncestor])\n        self.assertEqual(Child._meta.get_parent_list(), [FirstParent, SecondParent, CommonAncestor])\n\n\nclass PropertyNamesTests(SimpleTestCase):\n    def test_person(self):\n        # Instance only descriptors don't appear in _property_names.\n        self.assertEqual(AbstractPerson().test_instance_only_descriptor, 1)\n        self.assertEqual(AbstractPerson._meta._property_names, frozenset(['pk', 'test_property']))\n", "description": "The Web framework for perfectionists with deadlines.", "file_name": "tests.py", "id": "54c7997d355905a0c9817bf71b9d7c55", "language": "Python", "project_name": "django", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/django-django/django-django-acfc650/tests/model_meta/tests.py", "save_time": "", "source": "", "update_at": "2018-03-14T02:00:36Z", "url": "https://github.com/django/django", "wiki": false}