{"author": "HelloZeroNet", "code": "import socket\nimport time\n\nimport gevent\nimport msgpack\nimport msgpack.fallback\ntry:\n    from gevent.coros import RLock\nexcept:\n    from gevent.lock import RLock\n\nfrom Config import config\nfrom Debug import Debug\nfrom util import StreamingMsgpack\nfrom Crypt import CryptConnection\nfrom util import helper\n\n\nclass Connection(object):\n    __slots__ = (\n        \"sock\", \"sock_wrapped\", \"ip\", \"port\", \"cert_pin\", \"target_onion\", \"id\", \"protocol\", \"type\", \"server\", \"unpacker\", \"req_id\",\n        \"handshake\", \"crypt\", \"connected\", \"event_connected\", \"closed\", \"start_time\", \"last_recv_time\", \"is_private_ip\",\n        \"last_message_time\", \"last_send_time\", \"last_sent_time\", \"incomplete_buff_recv\", \"bytes_recv\", \"bytes_sent\", \"cpu_time\", \"send_lock\",\n        \"last_ping_delay\", \"last_req_time\", \"last_cmd_sent\", \"last_cmd_recv\", \"bad_actions\", \"sites\", \"name\", \"updateName\", \"waiting_requests\", \"waiting_streams\"\n    )\n\n    def __init__(self, server, ip, port, sock=None, target_onion=None):\n        self.sock = sock\n        self.ip = ip\n        self.port = port\n        self.cert_pin = None\n        if \"#\" in ip:\n            self.ip, self.cert_pin = ip.split(\"#\")\n        self.target_onion = target_onion  \n        self.id = server.last_connection_id\n        server.last_connection_id += 1\n        self.protocol = \"?\"\n        self.type = \"?\"\n\n        if helper.isPrivateIp(self.ip) and self.ip not in config.ip_local:\n            self.is_private_ip = True\n        else:\n            self.is_private_ip = False\n\n        self.server = server\n        self.unpacker = None  \n        self.req_id = 0  \n        self.handshake = {}  \n        self.crypt = None  \n        self.sock_wrapped = False  \n\n        self.connected = False\n        self.event_connected = gevent.event.AsyncResult()  \n        self.closed = False\n\n        \n        self.start_time = time.time()\n        self.last_recv_time = 0\n        self.last_message_time = 0\n        self.last_send_time = 0\n        self.last_sent_time = 0\n        self.incomplete_buff_recv = 0\n        self.bytes_recv = 0\n        self.bytes_sent = 0\n        self.last_ping_delay = None\n        self.last_req_time = 0\n        self.last_cmd_sent = None\n        self.last_cmd_recv = None\n        self.bad_actions = 0\n        self.sites = 0\n        self.cpu_time = 0.0\n        self.send_lock = RLock()\n\n        self.name = None\n        self.updateName()\n\n        self.waiting_requests = {}  \n        self.waiting_streams = {}  \n\n    def updateName(self):\n        self.name = \"Conn#%2s %-12s [%s]\" % (self.id, self.ip, self.protocol)\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return \"<%s>\" % self.__str__()\n\n    def log(self, text):\n        self.server.log.debug(\"%s > %s\" % (self.name, text.decode(\"utf8\", \"ignore\")))\n\n    def getValidSites(self):\n        return [key for key, val in self.server.tor_manager.site_onions.items() if val == self.target_onion]\n\n    def badAction(self, weight=1):\n        self.bad_actions += weight\n        if self.bad_actions > 40:\n            self.close(\"Too many bad actions\")\n        elif self.bad_actions > 20:\n            time.sleep(5)\n\n    def goodAction(self):\n        self.bad_actions = 0\n\n    \n    def connect(self):\n        self.log(\"Connecting...\")\n        self.type = \"out\"\n        if self.ip.endswith(\".onion\"):\n            if not self.server.tor_manager or not self.server.tor_manager.enabled:\n                raise Exception(\"Can't connect to onion addresses, no Tor controller present\")\n            self.sock = self.server.tor_manager.createSocket(self.ip, self.port)\n        elif config.tor == \"always\" and helper.isPrivateIp(self.ip) and self.ip not in config.ip_local:\n            raise Exception(\"Can't connect to local IPs in Tor: always mode\")\n        else:\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n        if \"TCP_NODELAY\" in dir(socket):\n            self.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n\n        self.sock.connect((self.ip, int(self.port)))\n\n        \n        should_encrypt = not self.ip.endswith(\".onion\") and self.ip not in self.server.broken_ssl_ips and self.ip not in config.ip_local\n        if self.cert_pin:\n            self.sock = CryptConnection.manager.wrapSocket(self.sock, \"tls-rsa\", cert_pin=self.cert_pin)\n            self.sock.do_handshake()\n            self.crypt = \"tls-rsa\"\n            self.sock_wrapped = True\n        elif should_encrypt and \"tsl-rsa\" in CryptConnection.manager.crypt_supported:\n            try:\n                self.sock = CryptConnection.manager.wrapSocket(self.sock, \"tls-rsa\")\n                self.sock.do_handshake()\n                self.crypt = \"tls-rsa\"\n                self.sock_wrapped = True\n            except Exception, err:\n                if not config.force_encryption:\n                    self.log(\"Crypt connection error: %s, adding ip %s as broken ssl.\" % (err, self.ip))\n                    self.server.broken_ssl_ips[self.ip] = True\n                self.sock.close()\n                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                self.sock.connect((self.ip, int(self.port)))\n\n\n        \n        self.send({\"cmd\": \"handshake\", \"req_id\": 0, \"params\": self.getHandshakeInfo()})\n        event_connected = self.event_connected\n        gevent.spawn(self.messageLoop)\n        return event_connected.get()  \n\n    \n    def handleIncomingConnection(self, sock):\n        self.log(\"Incoming connection...\")\n\n        if \"TCP_NODELAY\" in dir(socket):\n            sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n\n        self.type = \"in\"\n        if self.ip not in config.ip_local:   \n            try:\n                if sock.recv(1, gevent.socket.MSG_PEEK) == \"\\x16\":\n                    self.log(\"Crypt in connection using implicit SSL\")\n                    self.sock = CryptConnection.manager.wrapSocket(self.sock, \"tls-rsa\", True)\n                    self.sock_wrapped = True\n                    self.crypt = \"tls-rsa\"\n            except Exception, err:\n                self.log(\"Socket peek error: %s\" % Debug.formatException(err))\n        self.messageLoop()\n\n    \n    def messageLoop(self):\n        if not self.sock:\n            self.log(\"Socket error: No socket found\")\n            return False\n        self.protocol = \"v2\"\n        self.updateName()\n        self.connected = True\n        buff_len = 0\n        req_len = 0\n        unpacker_bytes = 0\n\n        try:\n            while not self.closed:\n                buff = self.sock.recv(64 * 1024)\n                if not buff:\n                    break  \n                buff_len = len(buff)\n\n                \n                self.last_recv_time = time.time()\n                self.incomplete_buff_recv += 1\n                self.bytes_recv += buff_len\n                self.server.bytes_recv += buff_len\n                req_len += buff_len\n\n                if not self.unpacker:\n                    self.unpacker = msgpack.fallback.Unpacker()\n                    unpacker_bytes = 0\n\n                self.unpacker.feed(buff)\n                unpacker_bytes += buff_len\n\n                while True:\n                    try:\n                        message = self.unpacker.next()\n                    except StopIteration:\n                        break\n                    if not type(message) is dict:\n                        raise Exception(\n                            \"Invalid message type: %s, content: %r, buffer: %r\" %\n                            (type(message), message, buff[0:16])\n                        )\n\n                    \n                    self.incomplete_buff_recv = 0\n                    stat_key = message.get(\"cmd\", \"unknown\")\n                    if stat_key == \"response\" and \"to\" in message:\n                        cmd_sent = self.waiting_requests.get(message[\"to\"], {\"cmd\": \"unknown\"})[\"cmd\"]\n                        stat_key = \"response: %s\" % cmd_sent\n                    if stat_key == \"update\":\n                        stat_key = \"update: %s\" % message[\"params\"][\"site\"]\n                    self.server.stat_recv[stat_key][\"bytes\"] += req_len\n                    self.server.stat_recv[stat_key][\"num\"] += 1\n                    if \"stream_bytes\" in message:\n                        self.server.stat_recv[stat_key][\"bytes\"] += message[\"stream_bytes\"]\n                    req_len = 0\n\n                    \n                    if \"stream_bytes\" in message:\n                        buff_left = self.handleStream(message, self.unpacker, buff, unpacker_bytes)\n                        self.unpacker = msgpack.fallback.Unpacker()\n                        self.unpacker.feed(buff_left)\n                        unpacker_bytes = len(buff_left)\n                        if config.debug_socket:\n                            self.log(\"Start new unpacker with buff_left: %r\" % buff_left)\n                    else:\n                        self.handleMessage(message)\n\n                message = None\n        except Exception as err:\n            if not self.closed:\n                self.log(\"Socket error: %s\" % Debug.formatException(err))\n                self.server.stat_recv[\"error: %s\" % err][\"bytes\"] += req_len\n                self.server.stat_recv[\"error: %s\" % err][\"num\"] += 1\n        self.close(\"MessageLoop ended (closed: %s)\" % self.closed)  \n\n    \n    def handleStream(self, message, unpacker, buff, unpacker_bytes):\n        stream_bytes_left = message[\"stream_bytes\"]\n        file = self.waiting_streams[message[\"to\"]]\n\n        if \"tell\" in dir(unpacker):\n            unpacker_unprocessed_bytes = unpacker_bytes - unpacker.tell()\n        else:\n            unpacker_unprocessed_bytes = unpacker._fb_buf_n - unpacker._fb_buf_o\n\n        if unpacker_unprocessed_bytes:  \n            unpacker_stream_bytes = min(unpacker_unprocessed_bytes, stream_bytes_left)\n            buff_stream_start = len(buff) - unpacker_unprocessed_bytes\n            file.write(buff[buff_stream_start:buff_stream_start + unpacker_stream_bytes])\n            stream_bytes_left -= unpacker_stream_bytes\n        else:\n            unpacker_stream_bytes = 0\n\n        if config.debug_socket:\n            self.log(\n                \"Starting stream %s: %s bytes (%s from unpacker, buff size: %s, unprocessed: %s)\" %\n                (message[\"to\"], message[\"stream_bytes\"], unpacker_stream_bytes, len(buff), unpacker_unprocessed_bytes)\n            )\n\n        try:\n            while 1:\n                if stream_bytes_left <= 0:\n                    break\n                stream_buff = self.sock.recv(min(64 * 1024, stream_bytes_left))\n                if not stream_buff:\n                    break\n                buff_len = len(stream_buff)\n                stream_bytes_left -= buff_len\n                file.write(stream_buff)\n\n                \n                self.last_recv_time = time.time()\n                self.incomplete_buff_recv += 1\n                self.bytes_recv += buff_len\n                self.server.bytes_recv += buff_len\n        except Exception, err:\n            self.log(\"Stream read error: %s\" % Debug.formatException(err))\n\n        if config.debug_socket:\n            self.log(\"End stream %s, file pos: %s\" % (message[\"to\"], file.tell()))\n\n        self.incomplete_buff_recv = 0\n        self.waiting_requests[message[\"to\"]][\"evt\"].set(message)  \n        del self.waiting_streams[message[\"to\"]]\n        del self.waiting_requests[message[\"to\"]]\n\n        if unpacker_stream_bytes:\n            return buff[buff_stream_start + unpacker_stream_bytes:]\n        else:\n            return \"\"\n\n    \n    def getHandshakeInfo(self):\n        \n        if self.ip.endswith(\".onion\"):\n            crypt_supported = []\n        else:\n            crypt_supported = CryptConnection.manager.crypt_supported\n        \n        if self.ip.endswith(\".onion\") or self.ip in config.ip_local:\n            peer_id = \"\"\n        else:\n            peer_id = self.server.peer_id\n        \n        if self.handshake and self.handshake.get(\"target_ip\", \"\").endswith(\".onion\") and self.server.tor_manager.start_onions:\n            self.target_onion = self.handshake.get(\"target_ip\").replace(\".onion\", \"\")  \n            if not self.server.tor_manager.site_onions.values():\n                self.server.log.warning(\"Unknown target onion address: %s\" % self.target_onion)\n\n        handshake = {\n            \"version\": config.version,\n            \"protocol\": \"v2\",\n            \"peer_id\": peer_id,\n            \"fileserver_port\": self.server.port,\n            \"port_opened\": self.server.port_opened,\n            \"target_ip\": self.ip,\n            \"rev\": config.rev,\n            \"crypt_supported\": crypt_supported,\n            \"crypt\": self.crypt,\n            \"time\": int(time.time())\n        }\n        if self.target_onion:\n            handshake[\"onion\"] = self.target_onion\n        elif self.ip.endswith(\".onion\"):\n            handshake[\"onion\"] = self.server.tor_manager.getOnion(\"global\")\n\n        if config.debug_socket:\n            self.log(\"My Handshake: %s\" % handshake)\n\n        return handshake\n\n    def setHandshake(self, handshake):\n        if config.debug_socket:\n            self.log(\"Remote Handshake: %s\" % handshake)\n\n        if handshake.get(\"peer_id\") == self.server.peer_id:\n            self.close(\"Same peer id, can't connect to myself\")\n            self.server.peer_blacklist.append((handshake[\"target_ip\"], handshake[\"fileserver_port\"]))\n            return False\n\n        self.handshake = handshake\n        if handshake.get(\"port_opened\", None) is False and \"onion\" not in handshake and not self.is_private_ip:  \n            self.port = 0\n        else:\n            self.port = handshake[\"fileserver_port\"]  \n\n        \n        if handshake.get(\"crypt_supported\") and self.ip not in self.server.broken_ssl_ips:\n            if self.ip.endswith(\".onion\") or self.ip in config.ip_local:\n                crypt = None\n            elif handshake.get(\"crypt\"):  \n                crypt = handshake[\"crypt\"]\n            else:  \n                crypt = CryptConnection.manager.selectCrypt(handshake[\"crypt_supported\"])\n\n            if crypt:\n                self.crypt = crypt\n\n        if self.type == \"in\" and handshake.get(\"onion\") and not self.ip.endswith(\".onion\"):  \n            if self.server.ips.get(self.ip) == self:\n                del self.server.ips[self.ip]\n            self.ip = handshake[\"onion\"] + \".onion\"\n            self.log(\"Changing ip to %s\" % self.ip)\n            self.server.ips[self.ip] = self\n            self.updateName()\n\n        self.event_connected.set(True)  \n        self.event_connected = None\n\n    \n    def handleMessage(self, message):\n        try:\n            cmd = message[\"cmd\"]\n        except TypeError, AttributeError:\n            cmd = None\n\n        self.last_message_time = time.time()\n        self.last_cmd_recv = cmd\n        if cmd == \"response\":  \n            if message[\"to\"] in self.waiting_requests:\n                if self.last_send_time and len(self.waiting_requests) == 1:\n                    ping = time.time() - self.last_send_time\n                    self.last_ping_delay = ping\n                self.waiting_requests[message[\"to\"]][\"evt\"].set(message)  \n                del self.waiting_requests[message[\"to\"]]\n            elif message[\"to\"] == 0:  \n                ping = time.time() - self.start_time\n                if config.debug_socket:\n                    self.log(\"Handshake response: %s, ping: %s\" % (message, ping))\n                self.last_ping_delay = ping\n                \n                if message.get(\"crypt\") and not self.sock_wrapped:\n                    self.crypt = message[\"crypt\"]\n                    server = (self.type == \"in\")\n                    self.log(\"Crypt out connection using: %s (server side: %s, ping: %.3fs)...\" % (self.crypt, server, ping))\n                    self.sock = CryptConnection.manager.wrapSocket(self.sock, self.crypt, server, cert_pin=self.cert_pin)\n                    self.sock.do_handshake()\n                    self.sock_wrapped = True\n\n                if not self.sock_wrapped and self.cert_pin:\n                    self.close(\"Crypt connection error: Socket not encrypted, but certificate pin present\")\n                    return\n\n                self.setHandshake(message)\n            else:\n                self.log(\"Unknown response: %s\" % message)\n        elif cmd:\n            self.server.num_recv += 1\n            if cmd == \"handshake\":\n                self.handleHandshake(message)\n            else:\n                self.server.handleRequest(self, message)\n        else:  \n            self.log(\"Unknown message, waiting: %s\" % self.waiting_requests.keys())\n            if self.waiting_requests:\n                last_req_id = min(self.waiting_requests.keys())  \n                self.waiting_requests[last_req_id][\"evt\"].set(message)\n                del self.waiting_requests[last_req_id]  \n\n    \n    def handleHandshake(self, message):\n        self.setHandshake(message[\"params\"])\n        data = self.getHandshakeInfo()\n        data[\"cmd\"] = \"response\"\n        data[\"to\"] = message[\"req_id\"]\n        self.send(data)  \n        \n        if self.crypt and not self.sock_wrapped:\n            server = (self.type == \"in\")\n            self.log(\"Crypt in connection using: %s (server side: %s)...\" % (self.crypt, server))\n            try:\n                self.sock = CryptConnection.manager.wrapSocket(self.sock, self.crypt, server, cert_pin=self.cert_pin)\n                self.sock_wrapped = True\n            except Exception, err:\n                if not config.force_encryption:\n                    self.log(\"Crypt connection error: %s, adding ip %s as broken ssl.\" % (err, self.ip))\n                    self.server.broken_ssl_ips[self.ip] = True\n                self.close(\"Broken ssl\")\n\n        if not self.sock_wrapped and self.cert_pin:\n            self.close(\"Crypt connection error: Socket not encrypted, but certificate pin present\")\n\n    \n    def send(self, message, streaming=False):\n        self.last_send_time = time.time()\n        if config.debug_socket:\n            self.log(\"Send: %s, to: %s, streaming: %s, site: %s, inner_path: %s, req_id: %s\" % (\n                message.get(\"cmd\"), message.get(\"to\"), streaming,\n                message.get(\"params\", {}).get(\"site\"), message.get(\"params\", {}).get(\"inner_path\"),\n                message.get(\"req_id\"))\n            )\n\n        if not self.sock:\n            self.log(\"Send error: missing socket\")\n            return False\n\n        try:\n            stat_key = message.get(\"cmd\", \"unknown\")\n            if stat_key == \"response\":\n                stat_key = \"response: %s\" % self.last_cmd_recv\n            else:\n                self.server.num_sent += 1\n\n            self.server.stat_sent[stat_key][\"num\"] += 1\n            if streaming:\n                with self.send_lock:\n                    bytes_sent = StreamingMsgpack.stream(message, self.sock.sendall)\n                self.bytes_sent += bytes_sent\n                self.server.bytes_sent += bytes_sent\n                self.server.stat_sent[stat_key][\"bytes\"] += bytes_sent\n                message = None\n            else:\n                data = msgpack.packb(message)\n                self.bytes_sent += len(data)\n                self.server.bytes_sent += len(data)\n                self.server.stat_sent[stat_key][\"bytes\"] += len(data)\n                message = None\n                with self.send_lock:\n                    self.sock.sendall(data)\n        except Exception, err:\n            self.close(\"Send error: %s\" % err)\n            return False\n        self.last_sent_time = time.time()\n        return True\n\n    \n    def sendRawfile(self, file, read_bytes):\n        buff = 64 * 1024\n        bytes_left = read_bytes\n        bytes_sent = 0\n        while True:\n            self.last_send_time = time.time()\n            data = file.read(min(bytes_left, buff))\n            bytes_sent += len(data)\n            with self.send_lock:\n                self.sock.sendall(data)\n            bytes_left -= buff\n            if bytes_left <= 0:\n                break\n        self.bytes_sent += bytes_sent\n        self.server.bytes_sent += bytes_sent\n        self.server.stat_sent[\"raw_file\"][\"num\"] += 1\n        self.server.stat_sent[\"raw_file\"][\"bytes\"] += bytes_sent\n        return True\n\n    \n    def request(self, cmd, params={}, stream_to=None):\n        \n        if self.waiting_requests and self.protocol == \"v2\" and time.time() - max(self.last_req_time, self.last_recv_time) > 10:\n            self.close(\"Request %s timeout: %.3fs\" % (self.last_cmd_sent, time.time() - self.last_send_time))\n            return False\n\n        self.last_req_time = time.time()\n        self.last_cmd_sent = cmd\n        self.req_id += 1\n        data = {\"cmd\": cmd, \"req_id\": self.req_id, \"params\": params}\n        event = gevent.event.AsyncResult()  \n        self.waiting_requests[self.req_id] = {\"evt\": event, \"cmd\": cmd}\n        if stream_to:\n            self.waiting_streams[self.req_id] = stream_to\n        self.send(data)  \n        res = event.get()  \n        return res\n\n    def ping(self):\n        s = time.time()\n        response = None\n        with gevent.Timeout(10.0, False):\n            try:\n                response = self.request(\"ping\")\n            except Exception, err:\n                self.log(\"Ping error: %s\" % Debug.formatException(err))\n        if response and \"body\" in response and response[\"body\"] == \"Pong!\":\n            self.last_ping_delay = time.time() - s\n            return True\n        else:\n            return False\n\n    \n    def close(self, reason=\"Unknown\"):\n        if self.closed:\n            return False  \n        self.closed = True\n        self.connected = False\n        if self.event_connected:\n            self.event_connected.set(False)\n\n        self.log(\n            \"Closing connection: %s, waiting_requests: %s, sites: %s, buff: %s...\" %\n            (reason, len(self.waiting_requests), self.sites, self.incomplete_buff_recv)\n        )\n        for request in self.waiting_requests.values():  \n            request[\"evt\"].set(False)\n        self.waiting_requests = {}\n        self.waiting_streams = {}\n        self.sites = 0\n        self.server.removeConnection(self)  \n        try:\n            if self.sock:\n                self.sock.shutdown(gevent.socket.SHUT_WR)\n                self.sock.close()\n        except Exception, err:\n            if config.debug_socket:\n                self.log(\"Close error: %s\" % err)\n\n        \n        self.sock = None\n        self.unpacker = None\n        self.event_connected = None\n", "comments": "  requested onion adress    stream incoming socket messages    last request id    handshake info got peer    connection encryption method    socket wrapped encryption    solves handshake received    stats    waiting sent requests    waiting response file streams    2s   12s       (self id  self ip  self protocol)    open connection peer wait handshake    implicit ssl    detect protocol    wait handshake    handle incoming connection    clearnet  check implicit ssl    message loop connection    connection closed    statistics    stats    handle message    messageloop ended  close connection    stream socket directly file    found stream bytes unpacker    statistics    set response event    my handshake info    no tls onion connections    no peer id onion connections    setup peer lock requested onion address    my onion address    not connectable    set peer fileserver port    check encrypt connection    recommended crypt server    select best supported sides    set incoming connection onion address    mark handshake done    handle incoming message    new style response    set response event    other peers handshake    server switched crypt  lets also crypted already    old style response  req id defined    get oldest waiting request set true    remove waiting request    incoming handshake set request    send response handshake    sent crypt request client    send data connection    stream file connection without msgpacking    create send request peer    last command sent 10 sec ago  timeout    create new event response    send request    wait event solves    close connection    already closed    mark pending requests failed    remove connection server registry    little cleanup ", "content": "import socket\nimport time\n\nimport gevent\nimport msgpack\nimport msgpack.fallback\ntry:\n    from gevent.coros import RLock\nexcept:\n    from gevent.lock import RLock\n\nfrom Config import config\nfrom Debug import Debug\nfrom util import StreamingMsgpack\nfrom Crypt import CryptConnection\nfrom util import helper\n\n\nclass Connection(object):\n    __slots__ = (\n        \"sock\", \"sock_wrapped\", \"ip\", \"port\", \"cert_pin\", \"target_onion\", \"id\", \"protocol\", \"type\", \"server\", \"unpacker\", \"req_id\",\n        \"handshake\", \"crypt\", \"connected\", \"event_connected\", \"closed\", \"start_time\", \"last_recv_time\", \"is_private_ip\",\n        \"last_message_time\", \"last_send_time\", \"last_sent_time\", \"incomplete_buff_recv\", \"bytes_recv\", \"bytes_sent\", \"cpu_time\", \"send_lock\",\n        \"last_ping_delay\", \"last_req_time\", \"last_cmd_sent\", \"last_cmd_recv\", \"bad_actions\", \"sites\", \"name\", \"updateName\", \"waiting_requests\", \"waiting_streams\"\n    )\n\n    def __init__(self, server, ip, port, sock=None, target_onion=None):\n        self.sock = sock\n        self.ip = ip\n        self.port = port\n        self.cert_pin = None\n        if \"#\" in ip:\n            self.ip, self.cert_pin = ip.split(\"#\")\n        self.target_onion = target_onion  # Requested onion adress\n        self.id = server.last_connection_id\n        server.last_connection_id += 1\n        self.protocol = \"?\"\n        self.type = \"?\"\n\n        if helper.isPrivateIp(self.ip) and self.ip not in config.ip_local:\n            self.is_private_ip = True\n        else:\n            self.is_private_ip = False\n\n        self.server = server\n        self.unpacker = None  # Stream incoming socket messages here\n        self.req_id = 0  # Last request id\n        self.handshake = {}  # Handshake info got from peer\n        self.crypt = None  # Connection encryption method\n        self.sock_wrapped = False  # Socket wrapped to encryption\n\n        self.connected = False\n        self.event_connected = gevent.event.AsyncResult()  # Solves on handshake received\n        self.closed = False\n\n        # Stats\n        self.start_time = time.time()\n        self.last_recv_time = 0\n        self.last_message_time = 0\n        self.last_send_time = 0\n        self.last_sent_time = 0\n        self.incomplete_buff_recv = 0\n        self.bytes_recv = 0\n        self.bytes_sent = 0\n        self.last_ping_delay = None\n        self.last_req_time = 0\n        self.last_cmd_sent = None\n        self.last_cmd_recv = None\n        self.bad_actions = 0\n        self.sites = 0\n        self.cpu_time = 0.0\n        self.send_lock = RLock()\n\n        self.name = None\n        self.updateName()\n\n        self.waiting_requests = {}  # Waiting sent requests\n        self.waiting_streams = {}  # Waiting response file streams\n\n    def updateName(self):\n        self.name = \"Conn#%2s %-12s [%s]\" % (self.id, self.ip, self.protocol)\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return \"<%s>\" % self.__str__()\n\n    def log(self, text):\n        self.server.log.debug(\"%s > %s\" % (self.name, text.decode(\"utf8\", \"ignore\")))\n\n    def getValidSites(self):\n        return [key for key, val in self.server.tor_manager.site_onions.items() if val == self.target_onion]\n\n    def badAction(self, weight=1):\n        self.bad_actions += weight\n        if self.bad_actions > 40:\n            self.close(\"Too many bad actions\")\n        elif self.bad_actions > 20:\n            time.sleep(5)\n\n    def goodAction(self):\n        self.bad_actions = 0\n\n    # Open connection to peer and wait for handshake\n    def connect(self):\n        self.log(\"Connecting...\")\n        self.type = \"out\"\n        if self.ip.endswith(\".onion\"):\n            if not self.server.tor_manager or not self.server.tor_manager.enabled:\n                raise Exception(\"Can't connect to onion addresses, no Tor controller present\")\n            self.sock = self.server.tor_manager.createSocket(self.ip, self.port)\n        elif config.tor == \"always\" and helper.isPrivateIp(self.ip) and self.ip not in config.ip_local:\n            raise Exception(\"Can't connect to local IPs in Tor: always mode\")\n        else:\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n        if \"TCP_NODELAY\" in dir(socket):\n            self.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n\n        self.sock.connect((self.ip, int(self.port)))\n\n        # Implicit SSL\n        should_encrypt = not self.ip.endswith(\".onion\") and self.ip not in self.server.broken_ssl_ips and self.ip not in config.ip_local\n        if self.cert_pin:\n            self.sock = CryptConnection.manager.wrapSocket(self.sock, \"tls-rsa\", cert_pin=self.cert_pin)\n            self.sock.do_handshake()\n            self.crypt = \"tls-rsa\"\n            self.sock_wrapped = True\n        elif should_encrypt and \"tsl-rsa\" in CryptConnection.manager.crypt_supported:\n            try:\n                self.sock = CryptConnection.manager.wrapSocket(self.sock, \"tls-rsa\")\n                self.sock.do_handshake()\n                self.crypt = \"tls-rsa\"\n                self.sock_wrapped = True\n            except Exception, err:\n                if not config.force_encryption:\n                    self.log(\"Crypt connection error: %s, adding ip %s as broken ssl.\" % (err, self.ip))\n                    self.server.broken_ssl_ips[self.ip] = True\n                self.sock.close()\n                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                self.sock.connect((self.ip, int(self.port)))\n\n\n        # Detect protocol\n        self.send({\"cmd\": \"handshake\", \"req_id\": 0, \"params\": self.getHandshakeInfo()})\n        event_connected = self.event_connected\n        gevent.spawn(self.messageLoop)\n        return event_connected.get()  # Wait for handshake\n\n    # Handle incoming connection\n    def handleIncomingConnection(self, sock):\n        self.log(\"Incoming connection...\")\n\n        if \"TCP_NODELAY\" in dir(socket):\n            sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n\n        self.type = \"in\"\n        if self.ip not in config.ip_local:   # Clearnet: Check implicit SSL\n            try:\n                if sock.recv(1, gevent.socket.MSG_PEEK) == \"\\x16\":\n                    self.log(\"Crypt in connection using implicit SSL\")\n                    self.sock = CryptConnection.manager.wrapSocket(self.sock, \"tls-rsa\", True)\n                    self.sock_wrapped = True\n                    self.crypt = \"tls-rsa\"\n            except Exception, err:\n                self.log(\"Socket peek error: %s\" % Debug.formatException(err))\n        self.messageLoop()\n\n    # Message loop for connection\n    def messageLoop(self):\n        if not self.sock:\n            self.log(\"Socket error: No socket found\")\n            return False\n        self.protocol = \"v2\"\n        self.updateName()\n        self.connected = True\n        buff_len = 0\n        req_len = 0\n        unpacker_bytes = 0\n\n        try:\n            while not self.closed:\n                buff = self.sock.recv(64 * 1024)\n                if not buff:\n                    break  # Connection closed\n                buff_len = len(buff)\n\n                # Statistics\n                self.last_recv_time = time.time()\n                self.incomplete_buff_recv += 1\n                self.bytes_recv += buff_len\n                self.server.bytes_recv += buff_len\n                req_len += buff_len\n\n                if not self.unpacker:\n                    self.unpacker = msgpack.fallback.Unpacker()\n                    unpacker_bytes = 0\n\n                self.unpacker.feed(buff)\n                unpacker_bytes += buff_len\n\n                while True:\n                    try:\n                        message = self.unpacker.next()\n                    except StopIteration:\n                        break\n                    if not type(message) is dict:\n                        raise Exception(\n                            \"Invalid message type: %s, content: %r, buffer: %r\" %\n                            (type(message), message, buff[0:16])\n                        )\n\n                    # Stats\n                    self.incomplete_buff_recv = 0\n                    stat_key = message.get(\"cmd\", \"unknown\")\n                    if stat_key == \"response\" and \"to\" in message:\n                        cmd_sent = self.waiting_requests.get(message[\"to\"], {\"cmd\": \"unknown\"})[\"cmd\"]\n                        stat_key = \"response: %s\" % cmd_sent\n                    if stat_key == \"update\":\n                        stat_key = \"update: %s\" % message[\"params\"][\"site\"]\n                    self.server.stat_recv[stat_key][\"bytes\"] += req_len\n                    self.server.stat_recv[stat_key][\"num\"] += 1\n                    if \"stream_bytes\" in message:\n                        self.server.stat_recv[stat_key][\"bytes\"] += message[\"stream_bytes\"]\n                    req_len = 0\n\n                    # Handle message\n                    if \"stream_bytes\" in message:\n                        buff_left = self.handleStream(message, self.unpacker, buff, unpacker_bytes)\n                        self.unpacker = msgpack.fallback.Unpacker()\n                        self.unpacker.feed(buff_left)\n                        unpacker_bytes = len(buff_left)\n                        if config.debug_socket:\n                            self.log(\"Start new unpacker with buff_left: %r\" % buff_left)\n                    else:\n                        self.handleMessage(message)\n\n                message = None\n        except Exception as err:\n            if not self.closed:\n                self.log(\"Socket error: %s\" % Debug.formatException(err))\n                self.server.stat_recv[\"error: %s\" % err][\"bytes\"] += req_len\n                self.server.stat_recv[\"error: %s\" % err][\"num\"] += 1\n        self.close(\"MessageLoop ended (closed: %s)\" % self.closed)  # MessageLoop ended, close connection\n\n    # Stream socket directly to a file\n    def handleStream(self, message, unpacker, buff, unpacker_bytes):\n        stream_bytes_left = message[\"stream_bytes\"]\n        file = self.waiting_streams[message[\"to\"]]\n\n        if \"tell\" in dir(unpacker):\n            unpacker_unprocessed_bytes = unpacker_bytes - unpacker.tell()\n        else:\n            unpacker_unprocessed_bytes = unpacker._fb_buf_n - unpacker._fb_buf_o\n\n        if unpacker_unprocessed_bytes:  # Found stream bytes in unpacker\n            unpacker_stream_bytes = min(unpacker_unprocessed_bytes, stream_bytes_left)\n            buff_stream_start = len(buff) - unpacker_unprocessed_bytes\n            file.write(buff[buff_stream_start:buff_stream_start + unpacker_stream_bytes])\n            stream_bytes_left -= unpacker_stream_bytes\n        else:\n            unpacker_stream_bytes = 0\n\n        if config.debug_socket:\n            self.log(\n                \"Starting stream %s: %s bytes (%s from unpacker, buff size: %s, unprocessed: %s)\" %\n                (message[\"to\"], message[\"stream_bytes\"], unpacker_stream_bytes, len(buff), unpacker_unprocessed_bytes)\n            )\n\n        try:\n            while 1:\n                if stream_bytes_left <= 0:\n                    break\n                stream_buff = self.sock.recv(min(64 * 1024, stream_bytes_left))\n                if not stream_buff:\n                    break\n                buff_len = len(stream_buff)\n                stream_bytes_left -= buff_len\n                file.write(stream_buff)\n\n                # Statistics\n                self.last_recv_time = time.time()\n                self.incomplete_buff_recv += 1\n                self.bytes_recv += buff_len\n                self.server.bytes_recv += buff_len\n        except Exception, err:\n            self.log(\"Stream read error: %s\" % Debug.formatException(err))\n\n        if config.debug_socket:\n            self.log(\"End stream %s, file pos: %s\" % (message[\"to\"], file.tell()))\n\n        self.incomplete_buff_recv = 0\n        self.waiting_requests[message[\"to\"]][\"evt\"].set(message)  # Set the response to event\n        del self.waiting_streams[message[\"to\"]]\n        del self.waiting_requests[message[\"to\"]]\n\n        if unpacker_stream_bytes:\n            return buff[buff_stream_start + unpacker_stream_bytes:]\n        else:\n            return \"\"\n\n    # My handshake info\n    def getHandshakeInfo(self):\n        # No TLS for onion connections\n        if self.ip.endswith(\".onion\"):\n            crypt_supported = []\n        else:\n            crypt_supported = CryptConnection.manager.crypt_supported\n        # No peer id for onion connections\n        if self.ip.endswith(\".onion\") or self.ip in config.ip_local:\n            peer_id = \"\"\n        else:\n            peer_id = self.server.peer_id\n        # Setup peer lock from requested onion address\n        if self.handshake and self.handshake.get(\"target_ip\", \"\").endswith(\".onion\") and self.server.tor_manager.start_onions:\n            self.target_onion = self.handshake.get(\"target_ip\").replace(\".onion\", \"\")  # My onion address\n            if not self.server.tor_manager.site_onions.values():\n                self.server.log.warning(\"Unknown target onion address: %s\" % self.target_onion)\n\n        handshake = {\n            \"version\": config.version,\n            \"protocol\": \"v2\",\n            \"peer_id\": peer_id,\n            \"fileserver_port\": self.server.port,\n            \"port_opened\": self.server.port_opened,\n            \"target_ip\": self.ip,\n            \"rev\": config.rev,\n            \"crypt_supported\": crypt_supported,\n            \"crypt\": self.crypt,\n            \"time\": int(time.time())\n        }\n        if self.target_onion:\n            handshake[\"onion\"] = self.target_onion\n        elif self.ip.endswith(\".onion\"):\n            handshake[\"onion\"] = self.server.tor_manager.getOnion(\"global\")\n\n        if config.debug_socket:\n            self.log(\"My Handshake: %s\" % handshake)\n\n        return handshake\n\n    def setHandshake(self, handshake):\n        if config.debug_socket:\n            self.log(\"Remote Handshake: %s\" % handshake)\n\n        if handshake.get(\"peer_id\") == self.server.peer_id:\n            self.close(\"Same peer id, can't connect to myself\")\n            self.server.peer_blacklist.append((handshake[\"target_ip\"], handshake[\"fileserver_port\"]))\n            return False\n\n        self.handshake = handshake\n        if handshake.get(\"port_opened\", None) is False and \"onion\" not in handshake and not self.is_private_ip:  # Not connectable\n            self.port = 0\n        else:\n            self.port = handshake[\"fileserver_port\"]  # Set peer fileserver port\n\n        # Check if we can encrypt the connection\n        if handshake.get(\"crypt_supported\") and self.ip not in self.server.broken_ssl_ips:\n            if self.ip.endswith(\".onion\") or self.ip in config.ip_local:\n                crypt = None\n            elif handshake.get(\"crypt\"):  # Recommended crypt by server\n                crypt = handshake[\"crypt\"]\n            else:  # Select the best supported on both sides\n                crypt = CryptConnection.manager.selectCrypt(handshake[\"crypt_supported\"])\n\n            if crypt:\n                self.crypt = crypt\n\n        if self.type == \"in\" and handshake.get(\"onion\") and not self.ip.endswith(\".onion\"):  # Set incoming connection's onion address\n            if self.server.ips.get(self.ip) == self:\n                del self.server.ips[self.ip]\n            self.ip = handshake[\"onion\"] + \".onion\"\n            self.log(\"Changing ip to %s\" % self.ip)\n            self.server.ips[self.ip] = self\n            self.updateName()\n\n        self.event_connected.set(True)  # Mark handshake as done\n        self.event_connected = None\n\n    # Handle incoming message\n    def handleMessage(self, message):\n        try:\n            cmd = message[\"cmd\"]\n        except TypeError, AttributeError:\n            cmd = None\n\n        self.last_message_time = time.time()\n        self.last_cmd_recv = cmd\n        if cmd == \"response\":  # New style response\n            if message[\"to\"] in self.waiting_requests:\n                if self.last_send_time and len(self.waiting_requests) == 1:\n                    ping = time.time() - self.last_send_time\n                    self.last_ping_delay = ping\n                self.waiting_requests[message[\"to\"]][\"evt\"].set(message)  # Set the response to event\n                del self.waiting_requests[message[\"to\"]]\n            elif message[\"to\"] == 0:  # Other peers handshake\n                ping = time.time() - self.start_time\n                if config.debug_socket:\n                    self.log(\"Handshake response: %s, ping: %s\" % (message, ping))\n                self.last_ping_delay = ping\n                # Server switched to crypt, lets do it also if not crypted already\n                if message.get(\"crypt\") and not self.sock_wrapped:\n                    self.crypt = message[\"crypt\"]\n                    server = (self.type == \"in\")\n                    self.log(\"Crypt out connection using: %s (server side: %s, ping: %.3fs)...\" % (self.crypt, server, ping))\n                    self.sock = CryptConnection.manager.wrapSocket(self.sock, self.crypt, server, cert_pin=self.cert_pin)\n                    self.sock.do_handshake()\n                    self.sock_wrapped = True\n\n                if not self.sock_wrapped and self.cert_pin:\n                    self.close(\"Crypt connection error: Socket not encrypted, but certificate pin present\")\n                    return\n\n                self.setHandshake(message)\n            else:\n                self.log(\"Unknown response: %s\" % message)\n        elif cmd:\n            self.server.num_recv += 1\n            if cmd == \"handshake\":\n                self.handleHandshake(message)\n            else:\n                self.server.handleRequest(self, message)\n        else:  # Old style response, no req_id defined\n            self.log(\"Unknown message, waiting: %s\" % self.waiting_requests.keys())\n            if self.waiting_requests:\n                last_req_id = min(self.waiting_requests.keys())  # Get the oldest waiting request and set it true\n                self.waiting_requests[last_req_id][\"evt\"].set(message)\n                del self.waiting_requests[last_req_id]  # Remove from waiting request\n\n    # Incoming handshake set request\n    def handleHandshake(self, message):\n        self.setHandshake(message[\"params\"])\n        data = self.getHandshakeInfo()\n        data[\"cmd\"] = \"response\"\n        data[\"to\"] = message[\"req_id\"]\n        self.send(data)  # Send response to handshake\n        # Sent crypt request to client\n        if self.crypt and not self.sock_wrapped:\n            server = (self.type == \"in\")\n            self.log(\"Crypt in connection using: %s (server side: %s)...\" % (self.crypt, server))\n            try:\n                self.sock = CryptConnection.manager.wrapSocket(self.sock, self.crypt, server, cert_pin=self.cert_pin)\n                self.sock_wrapped = True\n            except Exception, err:\n                if not config.force_encryption:\n                    self.log(\"Crypt connection error: %s, adding ip %s as broken ssl.\" % (err, self.ip))\n                    self.server.broken_ssl_ips[self.ip] = True\n                self.close(\"Broken ssl\")\n\n        if not self.sock_wrapped and self.cert_pin:\n            self.close(\"Crypt connection error: Socket not encrypted, but certificate pin present\")\n\n    # Send data to connection\n    def send(self, message, streaming=False):\n        self.last_send_time = time.time()\n        if config.debug_socket:\n            self.log(\"Send: %s, to: %s, streaming: %s, site: %s, inner_path: %s, req_id: %s\" % (\n                message.get(\"cmd\"), message.get(\"to\"), streaming,\n                message.get(\"params\", {}).get(\"site\"), message.get(\"params\", {}).get(\"inner_path\"),\n                message.get(\"req_id\"))\n            )\n\n        if not self.sock:\n            self.log(\"Send error: missing socket\")\n            return False\n\n        try:\n            stat_key = message.get(\"cmd\", \"unknown\")\n            if stat_key == \"response\":\n                stat_key = \"response: %s\" % self.last_cmd_recv\n            else:\n                self.server.num_sent += 1\n\n            self.server.stat_sent[stat_key][\"num\"] += 1\n            if streaming:\n                with self.send_lock:\n                    bytes_sent = StreamingMsgpack.stream(message, self.sock.sendall)\n                self.bytes_sent += bytes_sent\n                self.server.bytes_sent += bytes_sent\n                self.server.stat_sent[stat_key][\"bytes\"] += bytes_sent\n                message = None\n            else:\n                data = msgpack.packb(message)\n                self.bytes_sent += len(data)\n                self.server.bytes_sent += len(data)\n                self.server.stat_sent[stat_key][\"bytes\"] += len(data)\n                message = None\n                with self.send_lock:\n                    self.sock.sendall(data)\n        except Exception, err:\n            self.close(\"Send error: %s\" % err)\n            return False\n        self.last_sent_time = time.time()\n        return True\n\n    # Stream file to connection without msgpacking\n    def sendRawfile(self, file, read_bytes):\n        buff = 64 * 1024\n        bytes_left = read_bytes\n        bytes_sent = 0\n        while True:\n            self.last_send_time = time.time()\n            data = file.read(min(bytes_left, buff))\n            bytes_sent += len(data)\n            with self.send_lock:\n                self.sock.sendall(data)\n            bytes_left -= buff\n            if bytes_left <= 0:\n                break\n        self.bytes_sent += bytes_sent\n        self.server.bytes_sent += bytes_sent\n        self.server.stat_sent[\"raw_file\"][\"num\"] += 1\n        self.server.stat_sent[\"raw_file\"][\"bytes\"] += bytes_sent\n        return True\n\n    # Create and send a request to peer\n    def request(self, cmd, params={}, stream_to=None):\n        # Last command sent more than 10 sec ago, timeout\n        if self.waiting_requests and self.protocol == \"v2\" and time.time() - max(self.last_req_time, self.last_recv_time) > 10:\n            self.close(\"Request %s timeout: %.3fs\" % (self.last_cmd_sent, time.time() - self.last_send_time))\n            return False\n\n        self.last_req_time = time.time()\n        self.last_cmd_sent = cmd\n        self.req_id += 1\n        data = {\"cmd\": cmd, \"req_id\": self.req_id, \"params\": params}\n        event = gevent.event.AsyncResult()  # Create new event for response\n        self.waiting_requests[self.req_id] = {\"evt\": event, \"cmd\": cmd}\n        if stream_to:\n            self.waiting_streams[self.req_id] = stream_to\n        self.send(data)  # Send request\n        res = event.get()  # Wait until event solves\n        return res\n\n    def ping(self):\n        s = time.time()\n        response = None\n        with gevent.Timeout(10.0, False):\n            try:\n                response = self.request(\"ping\")\n            except Exception, err:\n                self.log(\"Ping error: %s\" % Debug.formatException(err))\n        if response and \"body\" in response and response[\"body\"] == \"Pong!\":\n            self.last_ping_delay = time.time() - s\n            return True\n        else:\n            return False\n\n    # Close connection\n    def close(self, reason=\"Unknown\"):\n        if self.closed:\n            return False  # Already closed\n        self.closed = True\n        self.connected = False\n        if self.event_connected:\n            self.event_connected.set(False)\n\n        self.log(\n            \"Closing connection: %s, waiting_requests: %s, sites: %s, buff: %s...\" %\n            (reason, len(self.waiting_requests), self.sites, self.incomplete_buff_recv)\n        )\n        for request in self.waiting_requests.values():  # Mark pending requests failed\n            request[\"evt\"].set(False)\n        self.waiting_requests = {}\n        self.waiting_streams = {}\n        self.sites = 0\n        self.server.removeConnection(self)  # Remove connection from server registry\n        try:\n            if self.sock:\n                self.sock.shutdown(gevent.socket.SHUT_WR)\n                self.sock.close()\n        except Exception, err:\n            if config.debug_socket:\n                self.log(\"Close error: %s\" % err)\n\n        # Little cleanup\n        self.sock = None\n        self.unpacker = None\n        self.event_connected = None\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "Connection.py", "id": "83c68b08422bb874f6ff43ee9bdb69a6", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/Connection/Connection.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}