{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom datetime import datetime\n\nfrom odoo import models, fields, api, exceptions, _\nfrom odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT\n\n\nclass HrAttendance(models.Model):\n    _name = \"hr.attendance\"\n    _description = \"Attendance\"\n    _order = \"check_in desc\"\n\n    def _default_employee(self):\n        return self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)\n\n    employee_id = fields.Many2one('hr.employee', string=\"Employee\", default=_default_employee, required=True, ondelete='cascade', index=True)\n    department_id = fields.Many2one('hr.department', string=\"Department\", related=\"employee_id.department_id\",\n        readonly=True)\n    check_in = fields.Datetime(string=\"Check In\", default=fields.Datetime.now, required=True)\n    check_out = fields.Datetime(string=\"Check Out\")\n    worked_hours = fields.Float(string='Worked Hours', compute='_compute_worked_hours', store=True, readonly=True)\n\n    @api.multi\n    def name_get(self):\n        result = []\n        for attendance in self:\n            if not attendance.check_out:\n                result.append((attendance.id, _(\"%(empl_name)s from %(check_in)s\") % {\n                    'empl_name': attendance.employee_id.name,\n                    'check_in': fields.Datetime.to_string(fields.Datetime.context_timestamp(attendance, fields.Datetime.from_string(attendance.check_in))),\n                }))\n            else:\n                result.append((attendance.id, _(\"%(empl_name)s from %(check_in)s to %(check_out)s\") % {\n                    'empl_name': attendance.employee_id.name,\n                    'check_in': fields.Datetime.to_string(fields.Datetime.context_timestamp(attendance, fields.Datetime.from_string(attendance.check_in))),\n                    'check_out': fields.Datetime.to_string(fields.Datetime.context_timestamp(attendance, fields.Datetime.from_string(attendance.check_out))),\n                }))\n        return result\n\n    @api.depends('check_in', 'check_out')\n    def _compute_worked_hours(self):\n        for attendance in self:\n            if attendance.check_out:\n                delta = datetime.strptime(attendance.check_out, DEFAULT_SERVER_DATETIME_FORMAT) - datetime.strptime(\n                    attendance.check_in, DEFAULT_SERVER_DATETIME_FORMAT)\n                attendance.worked_hours = delta.total_seconds() / 3600.0\n\n    @api.constrains('check_in', 'check_out')\n    def _check_validity_check_in_check_out(self):\n        \"\"\" verifies if check_in is earlier than check_out. \"\"\"\n        for attendance in self:\n            if attendance.check_in and attendance.check_out:\n                if attendance.check_out < attendance.check_in:\n                    raise exceptions.ValidationError(_('\"Check Out\" time cannot be earlier than \"Check In\" time.'))\n\n    @api.constrains('check_in', 'check_out', 'employee_id')\n    def _check_validity(self):\n        \"\"\" Verifies the validity of the attendance record compared to the others from the same employee.\n            For the same employee we must have :\n                * maximum 1 \"open\" attendance record (without check_out)\n                * no overlapping time slices with previous employee records\n        \"\"\"\n        for attendance in self:\n            \n            last_attendance_before_check_in = self.env['hr.attendance'].search([\n                ('employee_id', '=', attendance.employee_id.id),\n                ('check_in', '<=', attendance.check_in),\n                ('id', '!=', attendance.id),\n            ], order='check_in desc', limit=1)\n            if last_attendance_before_check_in and last_attendance_before_check_in.check_out and last_attendance_before_check_in.check_out > attendance.check_in:\n                raise exceptions.ValidationError(_(\"Cannot create new attendance record for %(empl_name)s, the employee was already checked in on %(datetime)s\") % {\n                    'empl_name': attendance.employee_id.name,\n                    'datetime': fields.Datetime.to_string(fields.Datetime.context_timestamp(self, fields.Datetime.from_string(attendance.check_in))),\n                })\n\n            if not attendance.check_out:\n                # if our attendance is \"open\" (no check_out), we verify there is no other \"open\" attendance\n                no_check_out_attendances = self.env['hr.attendance'].search([\n                    ('employee_id', '=', attendance.employee_id.id),\n                    ('check_out', '=', False),\n                    ('id', '!=', attendance.id),\n                ])\n                if no_check_out_attendances:\n                    raise exceptions.ValidationError(_(\"Cannot create new attendance record for %(empl_name)s, the employee hasn't checked out since %(datetime)s\") % {\n                        'empl_name': attendance.employee_id.name,\n                        'datetime': fields.Datetime.to_string(fields.Datetime.context_timestamp(self, fields.Datetime.from_string(no_check_out_attendances.check_in))),\n                    })\n            else:\n                \n                \n                last_attendance_before_check_out = self.env['hr.attendance'].search([\n                    ('employee_id', '=', attendance.employee_id.id),\n                    ('check_in', '<', attendance.check_out),\n                    ('id', '!=', attendance.id),\n                ], order='check_in desc', limit=1)\n                if last_attendance_before_check_out and last_attendance_before_check_in != last_attendance_before_check_out:\n                    raise exceptions.ValidationError(_(\"Cannot create new attendance record for %(empl_name)s, the employee was already checked in on %(datetime)s\") % {\n                        'empl_name': attendance.employee_id.name,\n                        'datetime': fields.Datetime.to_string(fields.Datetime.context_timestamp(self, fields.Datetime.from_string(last_attendance_before_check_out.check_in))),\n                    })\n\n    @api.multi\n    def copy(self):\n        raise exceptions.UserError(_('You cannot duplicate an attendance.'))\n", "comments": "    verifies check earlier check              attendance self              attendance check attendance check                  attendance check   attendance check                      raise exceptions validationerror( (  check out  time cannot earlier  check in  time  ))       api constrains( check    check    employee id )     def  check validity(self)              verifies validity attendance record compared others employee              for employee must                     maximum 1  open  attendance record (without check out)                   overlapping time slices previous employee records                    coding  utf 8        part odoo  see license file full copyright licensing details     take latest attendance check time check overlap    attendance  open  (no check out)  verify  open  attendance    verify latest attendance check time check time    one check time computed  otherwise overlaps ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom datetime import datetime\n\nfrom odoo import models, fields, api, exceptions, _\nfrom odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT\n\n\nclass HrAttendance(models.Model):\n    _name = \"hr.attendance\"\n    _description = \"Attendance\"\n    _order = \"check_in desc\"\n\n    def _default_employee(self):\n        return self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)\n\n    employee_id = fields.Many2one('hr.employee', string=\"Employee\", default=_default_employee, required=True, ondelete='cascade', index=True)\n    department_id = fields.Many2one('hr.department', string=\"Department\", related=\"employee_id.department_id\",\n        readonly=True)\n    check_in = fields.Datetime(string=\"Check In\", default=fields.Datetime.now, required=True)\n    check_out = fields.Datetime(string=\"Check Out\")\n    worked_hours = fields.Float(string='Worked Hours', compute='_compute_worked_hours', store=True, readonly=True)\n\n    @api.multi\n    def name_get(self):\n        result = []\n        for attendance in self:\n            if not attendance.check_out:\n                result.append((attendance.id, _(\"%(empl_name)s from %(check_in)s\") % {\n                    'empl_name': attendance.employee_id.name,\n                    'check_in': fields.Datetime.to_string(fields.Datetime.context_timestamp(attendance, fields.Datetime.from_string(attendance.check_in))),\n                }))\n            else:\n                result.append((attendance.id, _(\"%(empl_name)s from %(check_in)s to %(check_out)s\") % {\n                    'empl_name': attendance.employee_id.name,\n                    'check_in': fields.Datetime.to_string(fields.Datetime.context_timestamp(attendance, fields.Datetime.from_string(attendance.check_in))),\n                    'check_out': fields.Datetime.to_string(fields.Datetime.context_timestamp(attendance, fields.Datetime.from_string(attendance.check_out))),\n                }))\n        return result\n\n    @api.depends('check_in', 'check_out')\n    def _compute_worked_hours(self):\n        for attendance in self:\n            if attendance.check_out:\n                delta = datetime.strptime(attendance.check_out, DEFAULT_SERVER_DATETIME_FORMAT) - datetime.strptime(\n                    attendance.check_in, DEFAULT_SERVER_DATETIME_FORMAT)\n                attendance.worked_hours = delta.total_seconds() / 3600.0\n\n    @api.constrains('check_in', 'check_out')\n    def _check_validity_check_in_check_out(self):\n        \"\"\" verifies if check_in is earlier than check_out. \"\"\"\n        for attendance in self:\n            if attendance.check_in and attendance.check_out:\n                if attendance.check_out < attendance.check_in:\n                    raise exceptions.ValidationError(_('\"Check Out\" time cannot be earlier than \"Check In\" time.'))\n\n    @api.constrains('check_in', 'check_out', 'employee_id')\n    def _check_validity(self):\n        \"\"\" Verifies the validity of the attendance record compared to the others from the same employee.\n            For the same employee we must have :\n                * maximum 1 \"open\" attendance record (without check_out)\n                * no overlapping time slices with previous employee records\n        \"\"\"\n        for attendance in self:\n            # we take the latest attendance before our check_in time and check it doesn't overlap with ours\n            last_attendance_before_check_in = self.env['hr.attendance'].search([\n                ('employee_id', '=', attendance.employee_id.id),\n                ('check_in', '<=', attendance.check_in),\n                ('id', '!=', attendance.id),\n            ], order='check_in desc', limit=1)\n            if last_attendance_before_check_in and last_attendance_before_check_in.check_out and last_attendance_before_check_in.check_out > attendance.check_in:\n                raise exceptions.ValidationError(_(\"Cannot create new attendance record for %(empl_name)s, the employee was already checked in on %(datetime)s\") % {\n                    'empl_name': attendance.employee_id.name,\n                    'datetime': fields.Datetime.to_string(fields.Datetime.context_timestamp(self, fields.Datetime.from_string(attendance.check_in))),\n                })\n\n            if not attendance.check_out:\n                # if our attendance is \"open\" (no check_out), we verify there is no other \"open\" attendance\n                no_check_out_attendances = self.env['hr.attendance'].search([\n                    ('employee_id', '=', attendance.employee_id.id),\n                    ('check_out', '=', False),\n                    ('id', '!=', attendance.id),\n                ])\n                if no_check_out_attendances:\n                    raise exceptions.ValidationError(_(\"Cannot create new attendance record for %(empl_name)s, the employee hasn't checked out since %(datetime)s\") % {\n                        'empl_name': attendance.employee_id.name,\n                        'datetime': fields.Datetime.to_string(fields.Datetime.context_timestamp(self, fields.Datetime.from_string(no_check_out_attendances.check_in))),\n                    })\n            else:\n                # we verify that the latest attendance with check_in time before our check_out time\n                # is the same as the one before our check_in time computed before, otherwise it overlaps\n                last_attendance_before_check_out = self.env['hr.attendance'].search([\n                    ('employee_id', '=', attendance.employee_id.id),\n                    ('check_in', '<', attendance.check_out),\n                    ('id', '!=', attendance.id),\n                ], order='check_in desc', limit=1)\n                if last_attendance_before_check_out and last_attendance_before_check_in != last_attendance_before_check_out:\n                    raise exceptions.ValidationError(_(\"Cannot create new attendance record for %(empl_name)s, the employee was already checked in on %(datetime)s\") % {\n                        'empl_name': attendance.employee_id.name,\n                        'datetime': fields.Datetime.to_string(fields.Datetime.context_timestamp(self, fields.Datetime.from_string(last_attendance_before_check_out.check_in))),\n                    })\n\n    @api.multi\n    def copy(self):\n        raise exceptions.UserError(_('You cannot duplicate an attendance.'))\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "hr_attendance.py", "id": "f513e45bf829d59b24537efa1257ebf9", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/hr_attendance/models/hr_attendance.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}