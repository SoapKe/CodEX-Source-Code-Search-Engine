{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_urllib_parse_urlparse\nfrom ..utils import (\n    ExtractorError,\n    parse_iso8601,\n    qualities,\n)\n\n\nclass SRGSSRIE(InfoExtractor):\n    _VALID_URL = r'(?:https?://tp\\.srgssr\\.ch/p(?:/[^/]+)+\\?urn=urn|srgssr):(?P<bu>srf|rts|rsi|rtr|swi):(?:[^:]+:)?(?P<type>video|audio):(?P<id>[0-9a-f\\-]{36}|\\d+)'\n    _GEO_BYPASS = False\n    _GEO_COUNTRIES = ['CH']\n\n    _ERRORS = {\n        'AGERATING12': 'To protect children under the age of 12, this video is only available between 8 p.m. and 6 a.m.',\n        'AGERATING18': 'To protect children under the age of 18, this video is only available between 11 p.m. and 5 a.m.',\n        \n        'GEOBLOCK': 'For legal reasons, this video is only available in Switzerland.',\n        'LEGAL': 'The video cannot be transmitted for legal reasons.',\n        'STARTDATE': 'This video is not yet available. Please try again later.',\n    }\n\n    def _get_tokenized_src(self, url, video_id, format_id):\n        sp = compat_urllib_parse_urlparse(url).path.split('/')\n        token = self._download_json(\n            'http://tp.srgssr.ch/akahd/token?acl=/%s/%s/*' % (sp[1], sp[2]),\n            video_id, 'Downloading %s token' % format_id, fatal=False) or {}\n        auth_params = token.get('token', {}).get('authparams')\n        if auth_params:\n            url += '?' + auth_params\n        return url\n\n    def get_media_data(self, bu, media_type, media_id):\n        media_data = self._download_json(\n            'http://il.srgssr.ch/integrationlayer/1.0/ue/%s/%s/play/%s.json' % (bu, media_type, media_id),\n            media_id)[media_type.capitalize()]\n\n        if media_data.get('block') and media_data['block'] in self._ERRORS:\n            message = self._ERRORS[media_data['block']]\n            if media_data['block'] == 'GEOBLOCK':\n                self.raise_geo_restricted(\n                    msg=message, countries=self._GEO_COUNTRIES)\n            raise ExtractorError(\n                '%s said: %s' % (self.IE_NAME, message), expected=True)\n\n        return media_data\n\n    def _real_extract(self, url):\n        bu, media_type, media_id = re.match(self._VALID_URL, url).groups()\n\n        media_data = self.get_media_data(bu, media_type, media_id)\n\n        metadata = media_data['AssetMetadatas']['AssetMetadata'][0]\n        title = metadata['title']\n        description = metadata.get('description')\n        created_date = media_data.get('createdDate') or metadata.get('createdDate')\n        timestamp = parse_iso8601(created_date)\n\n        thumbnails = [{\n            'id': image.get('id'),\n            'url': image['url'],\n        } for image in media_data.get('Image', {}).get('ImageRepresentations', {}).get('ImageRepresentation', [])]\n\n        preference = qualities(['LQ', 'MQ', 'SD', 'HQ', 'HD'])\n        formats = []\n        for source in media_data.get('Playlists', {}).get('Playlist', []) + media_data.get('Downloads', {}).get('Download', []):\n            protocol = source.get('@protocol')\n            for asset in source['url']:\n                asset_url = asset['text']\n                quality = asset['@quality']\n                format_id = '%s-%s' % (protocol, quality)\n                if protocol.startswith('HTTP-HDS') or protocol.startswith('HTTP-HLS'):\n                    asset_url = self._get_tokenized_src(asset_url, media_id, format_id)\n                    if protocol.startswith('HTTP-HDS'):\n                        formats.extend(self._extract_f4m_formats(\n                            asset_url + ('?' if '?' not in asset_url else '&') + 'hdcore=3.4.0',\n                            media_id, f4m_id=format_id, fatal=False))\n                    elif protocol.startswith('HTTP-HLS'):\n                        formats.extend(self._extract_m3u8_formats(\n                            asset_url, media_id, 'mp4', 'm3u8_native',\n                            m3u8_id=format_id, fatal=False))\n                else:\n                    formats.append({\n                        'format_id': format_id,\n                        'url': asset_url,\n                        'preference': preference(quality),\n                        'ext': 'flv' if protocol == 'RTMP' else None,\n                    })\n        self._sort_formats(formats)\n\n        return {\n            'id': media_id,\n            'title': title,\n            'description': description,\n            'timestamp': timestamp,\n            'thumbnails': thumbnails,\n            'formats': formats,\n        }\n\n\nclass SRGSSRPlayIE(InfoExtractor):\n    IE_DESC = 'srf.ch, rts.ch, rsi.ch, rtr.ch and swissinfo.ch play sites'\n    _VALID_URL = r'https?://(?:(?:www|play)\\.)?(?P<bu>srf|rts|rsi|rtr|swissinfo)\\.ch/play/(?:tv|radio)/[^/]+/(?P<type>video|audio)/[^?]+\\?id=(?P<id>[0-9a-f\\-]{36}|\\d+)'\n\n    _TESTS = [{\n        'url': 'http://www.srf.ch/play/tv/10vor10/video/snowden-beantragt-asyl-in-russland?id=28e1a57d-5b76-4399-8ab3-9097f071e6c5',\n        'md5': 'da6b5b3ac9fa4761a942331cef20fcb3',\n        'info_dict': {\n            'id': '28e1a57d-5b76-4399-8ab3-9097f071e6c5',\n            'ext': 'mp4',\n            'upload_date': '20130701',\n            'title': 'Snowden beantragt Asyl in Russland',\n            'timestamp': 1372713995,\n        }\n    }, {\n        \n        'url': 'http://www.srf.ch/play/tv/top-gear/video/jaguar-xk120-shadow-und-tornado-dampflokomotive?id=677f5829-e473-4823-ac83-a1087fe97faa',\n        'md5': '0a274ce38fda48c53c01890651985bc6',\n        'info_dict': {\n            'id': '677f5829-e473-4823-ac83-a1087fe97faa',\n            'ext': 'flv',\n            'upload_date': '20130710',\n            'title': 'Jaguar XK120, Shadow und Tornado-Dampflokomotive',\n            'description': 'md5:88604432b60d5a38787f152dec89cd56',\n            'timestamp': 1373493600,\n        },\n    }, {\n        'url': 'http://www.rtr.ch/play/radio/actualitad/audio/saira-tujetsch-tuttina-cuntinuar-cun-sedrun-muster-turissem?id=63cb0778-27f8-49af-9284-8c7a8c6d15fc',\n        'info_dict': {\n            'id': '63cb0778-27f8-49af-9284-8c7a8c6d15fc',\n            'ext': 'mp3',\n            'upload_date': '20151013',\n            'title': 'Saira: Tujetsch - tuttina cuntinuar cun Sedrun Must\u00e9r Turissem',\n            'timestamp': 1444750398,\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }, {\n        'url': 'http://www.rts.ch/play/tv/-/video/le-19h30?id=6348260',\n        'md5': '67a2a9ae4e8e62a68d0e9820cc9782df',\n        'info_dict': {\n            'id': '6348260',\n            'display_id': '6348260',\n            'ext': 'mp4',\n            'duration': 1796,\n            'title': 'Le 19h30',\n            'description': '',\n            'uploader': '19h30',\n            'upload_date': '20141201',\n            'timestamp': 1417458600,\n            'thumbnail': r're:^https?://.*\\.image',\n            'view_count': int,\n        },\n        'params': {\n            \n            'skip_download': True,\n        }\n    }]\n\n    def _real_extract(self, url):\n        bu, media_type, media_id = re.match(self._VALID_URL, url).groups()\n        \n        return self.url_result('srgssr:%s:%s:%s' % (bu[:3], media_type, media_id), 'SRGSSR')\n", "comments": "# coding: utf-8\n# 'ENDDATE': 'For legal reasons, this video was only available for a specified period of time.',\n# No Speichern (Save) button\n# rtmp download\n# m3u8 download\n# other info can be extracted from url + '&layout=json'\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_urllib_parse_urlparse\nfrom ..utils import (\n    ExtractorError,\n    parse_iso8601,\n    qualities,\n)\n\n\nclass SRGSSRIE(InfoExtractor):\n    _VALID_URL = r'(?:https?://tp\\.srgssr\\.ch/p(?:/[^/]+)+\\?urn=urn|srgssr):(?P<bu>srf|rts|rsi|rtr|swi):(?:[^:]+:)?(?P<type>video|audio):(?P<id>[0-9a-f\\-]{36}|\\d+)'\n    _GEO_BYPASS = False\n    _GEO_COUNTRIES = ['CH']\n\n    _ERRORS = {\n        'AGERATING12': 'To protect children under the age of 12, this video is only available between 8 p.m. and 6 a.m.',\n        'AGERATING18': 'To protect children under the age of 18, this video is only available between 11 p.m. and 5 a.m.',\n        # 'ENDDATE': 'For legal reasons, this video was only available for a specified period of time.',\n        'GEOBLOCK': 'For legal reasons, this video is only available in Switzerland.',\n        'LEGAL': 'The video cannot be transmitted for legal reasons.',\n        'STARTDATE': 'This video is not yet available. Please try again later.',\n    }\n\n    def _get_tokenized_src(self, url, video_id, format_id):\n        sp = compat_urllib_parse_urlparse(url).path.split('/')\n        token = self._download_json(\n            'http://tp.srgssr.ch/akahd/token?acl=/%s/%s/*' % (sp[1], sp[2]),\n            video_id, 'Downloading %s token' % format_id, fatal=False) or {}\n        auth_params = token.get('token', {}).get('authparams')\n        if auth_params:\n            url += '?' + auth_params\n        return url\n\n    def get_media_data(self, bu, media_type, media_id):\n        media_data = self._download_json(\n            'http://il.srgssr.ch/integrationlayer/1.0/ue/%s/%s/play/%s.json' % (bu, media_type, media_id),\n            media_id)[media_type.capitalize()]\n\n        if media_data.get('block') and media_data['block'] in self._ERRORS:\n            message = self._ERRORS[media_data['block']]\n            if media_data['block'] == 'GEOBLOCK':\n                self.raise_geo_restricted(\n                    msg=message, countries=self._GEO_COUNTRIES)\n            raise ExtractorError(\n                '%s said: %s' % (self.IE_NAME, message), expected=True)\n\n        return media_data\n\n    def _real_extract(self, url):\n        bu, media_type, media_id = re.match(self._VALID_URL, url).groups()\n\n        media_data = self.get_media_data(bu, media_type, media_id)\n\n        metadata = media_data['AssetMetadatas']['AssetMetadata'][0]\n        title = metadata['title']\n        description = metadata.get('description')\n        created_date = media_data.get('createdDate') or metadata.get('createdDate')\n        timestamp = parse_iso8601(created_date)\n\n        thumbnails = [{\n            'id': image.get('id'),\n            'url': image['url'],\n        } for image in media_data.get('Image', {}).get('ImageRepresentations', {}).get('ImageRepresentation', [])]\n\n        preference = qualities(['LQ', 'MQ', 'SD', 'HQ', 'HD'])\n        formats = []\n        for source in media_data.get('Playlists', {}).get('Playlist', []) + media_data.get('Downloads', {}).get('Download', []):\n            protocol = source.get('@protocol')\n            for asset in source['url']:\n                asset_url = asset['text']\n                quality = asset['@quality']\n                format_id = '%s-%s' % (protocol, quality)\n                if protocol.startswith('HTTP-HDS') or protocol.startswith('HTTP-HLS'):\n                    asset_url = self._get_tokenized_src(asset_url, media_id, format_id)\n                    if protocol.startswith('HTTP-HDS'):\n                        formats.extend(self._extract_f4m_formats(\n                            asset_url + ('?' if '?' not in asset_url else '&') + 'hdcore=3.4.0',\n                            media_id, f4m_id=format_id, fatal=False))\n                    elif protocol.startswith('HTTP-HLS'):\n                        formats.extend(self._extract_m3u8_formats(\n                            asset_url, media_id, 'mp4', 'm3u8_native',\n                            m3u8_id=format_id, fatal=False))\n                else:\n                    formats.append({\n                        'format_id': format_id,\n                        'url': asset_url,\n                        'preference': preference(quality),\n                        'ext': 'flv' if protocol == 'RTMP' else None,\n                    })\n        self._sort_formats(formats)\n\n        return {\n            'id': media_id,\n            'title': title,\n            'description': description,\n            'timestamp': timestamp,\n            'thumbnails': thumbnails,\n            'formats': formats,\n        }\n\n\nclass SRGSSRPlayIE(InfoExtractor):\n    IE_DESC = 'srf.ch, rts.ch, rsi.ch, rtr.ch and swissinfo.ch play sites'\n    _VALID_URL = r'https?://(?:(?:www|play)\\.)?(?P<bu>srf|rts|rsi|rtr|swissinfo)\\.ch/play/(?:tv|radio)/[^/]+/(?P<type>video|audio)/[^?]+\\?id=(?P<id>[0-9a-f\\-]{36}|\\d+)'\n\n    _TESTS = [{\n        'url': 'http://www.srf.ch/play/tv/10vor10/video/snowden-beantragt-asyl-in-russland?id=28e1a57d-5b76-4399-8ab3-9097f071e6c5',\n        'md5': 'da6b5b3ac9fa4761a942331cef20fcb3',\n        'info_dict': {\n            'id': '28e1a57d-5b76-4399-8ab3-9097f071e6c5',\n            'ext': 'mp4',\n            'upload_date': '20130701',\n            'title': 'Snowden beantragt Asyl in Russland',\n            'timestamp': 1372713995,\n        }\n    }, {\n        # No Speichern (Save) button\n        'url': 'http://www.srf.ch/play/tv/top-gear/video/jaguar-xk120-shadow-und-tornado-dampflokomotive?id=677f5829-e473-4823-ac83-a1087fe97faa',\n        'md5': '0a274ce38fda48c53c01890651985bc6',\n        'info_dict': {\n            'id': '677f5829-e473-4823-ac83-a1087fe97faa',\n            'ext': 'flv',\n            'upload_date': '20130710',\n            'title': 'Jaguar XK120, Shadow und Tornado-Dampflokomotive',\n            'description': 'md5:88604432b60d5a38787f152dec89cd56',\n            'timestamp': 1373493600,\n        },\n    }, {\n        'url': 'http://www.rtr.ch/play/radio/actualitad/audio/saira-tujetsch-tuttina-cuntinuar-cun-sedrun-muster-turissem?id=63cb0778-27f8-49af-9284-8c7a8c6d15fc',\n        'info_dict': {\n            'id': '63cb0778-27f8-49af-9284-8c7a8c6d15fc',\n            'ext': 'mp3',\n            'upload_date': '20151013',\n            'title': 'Saira: Tujetsch - tuttina cuntinuar cun Sedrun Must\u00e9r Turissem',\n            'timestamp': 1444750398,\n        },\n        'params': {\n            # rtmp download\n            'skip_download': True,\n        },\n    }, {\n        'url': 'http://www.rts.ch/play/tv/-/video/le-19h30?id=6348260',\n        'md5': '67a2a9ae4e8e62a68d0e9820cc9782df',\n        'info_dict': {\n            'id': '6348260',\n            'display_id': '6348260',\n            'ext': 'mp4',\n            'duration': 1796,\n            'title': 'Le 19h30',\n            'description': '',\n            'uploader': '19h30',\n            'upload_date': '20141201',\n            'timestamp': 1417458600,\n            'thumbnail': r're:^https?://.*\\.image',\n            'view_count': int,\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        }\n    }]\n\n    def _real_extract(self, url):\n        bu, media_type, media_id = re.match(self._VALID_URL, url).groups()\n        # other info can be extracted from url + '&layout=json'\n        return self.url_result('srgssr:%s:%s:%s' % (bu[:3], media_type, media_id), 'SRGSSR')\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "srgssr.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/srgssr.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}