{"author": "mopidy", "code": "from __future__ import absolute_import, unicode_literals\n\nimport unittest\n\nimport pykka\n\nfrom mopidy import core\nfrom mopidy.core import PlaybackState\nfrom mopidy.internal import deprecation\nfrom mopidy.models import Track\nfrom mopidy.mpd import dispatcher\nfrom mopidy.mpd.protocol import status\n\nfrom tests import dummy_audio, dummy_backend, dummy_mixer\n\n\nPAUSED = PlaybackState.PAUSED\nPLAYING = PlaybackState.PLAYING\nSTOPPED = PlaybackState.STOPPED\n\n\n?\n\n\nclass StatusHandlerTest(unittest.TestCase):\n\n    def setUp(self):  \n        config = {\n            'core': {\n                'max_tracklist_length': 10000,\n            }\n        }\n\n        self.audio = dummy_audio.create_proxy()\n        self.mixer = dummy_mixer.create_proxy()\n        self.backend = dummy_backend.create_proxy(audio=self.audio)\n\n        with deprecation.ignore():\n            self.core = core.Core.start(\n                config,\n                audio=self.audio,\n                mixer=self.mixer,\n                backends=[self.backend]).proxy()\n\n        self.dispatcher = dispatcher.MpdDispatcher(core=self.core)\n        self.context = self.dispatcher.context\n\n    def tearDown(self):  \n        pykka.ActorRegistry.stop_all()\n\n    def set_tracklist(self, tracks):\n        self.backend.library.dummy_library = tracks\n        self.core.tracklist.add(uris=[track.uri for track in tracks]).get()\n\n    def test_stats_method(self):\n        result = status.stats(self.context)\n        self.assertIn('artists', result)\n        self.assertGreaterEqual(int(result['artists']), 0)\n        self.assertIn('albums', result)\n        self.assertGreaterEqual(int(result['albums']), 0)\n        self.assertIn('songs', result)\n        self.assertGreaterEqual(int(result['songs']), 0)\n        self.assertIn('uptime', result)\n        self.assertGreaterEqual(int(result['uptime']), 0)\n        self.assertIn('db_playtime', result)\n        self.assertGreaterEqual(int(result['db_playtime']), 0)\n        self.assertIn('db_update', result)\n        self.assertGreaterEqual(int(result['db_update']), 0)\n        self.assertIn('playtime', result)\n        self.assertGreaterEqual(int(result['playtime']), 0)\n\n    def test_status_method_contains_volume_with_na_value(self):\n        result = dict(status.status(self.context))\n        self.assertIn('volume', result)\n        self.assertEqual(int(result['volume']), -1)\n\n    def test_status_method_contains_volume(self):\n        self.core.mixer.set_volume(17)\n        result = dict(status.status(self.context))\n        self.assertIn('volume', result)\n        self.assertEqual(int(result['volume']), 17)\n\n    def test_status_method_contains_repeat_is_0(self):\n        result = dict(status.status(self.context))\n        self.assertIn('repeat', result)\n        self.assertEqual(int(result['repeat']), 0)\n\n    def test_status_method_contains_repeat_is_1(self):\n        self.core.tracklist.set_repeat(True)\n        result = dict(status.status(self.context))\n        self.assertIn('repeat', result)\n        self.assertEqual(int(result['repeat']), 1)\n\n    def test_status_method_contains_random_is_0(self):\n        result = dict(status.status(self.context))\n        self.assertIn('random', result)\n        self.assertEqual(int(result['random']), 0)\n\n    def test_status_method_contains_random_is_1(self):\n        self.core.tracklist.set_random(True)\n        result = dict(status.status(self.context))\n        self.assertIn('random', result)\n        self.assertEqual(int(result['random']), 1)\n\n    def test_status_method_contains_single(self):\n        result = dict(status.status(self.context))\n        self.assertIn('single', result)\n        self.assertIn(int(result['single']), (0, 1))\n\n    def test_status_method_contains_consume_is_0(self):\n        result = dict(status.status(self.context))\n        self.assertIn('consume', result)\n        self.assertEqual(int(result['consume']), 0)\n\n    def test_status_method_contains_consume_is_1(self):\n        self.core.tracklist.set_consume(True)\n        result = dict(status.status(self.context))\n        self.assertIn('consume', result)\n        self.assertEqual(int(result['consume']), 1)\n\n    def test_status_method_contains_playlist(self):\n        result = dict(status.status(self.context))\n        self.assertIn('playlist', result)\n        self.assertGreaterEqual(int(result['playlist']), 0)\n        self.assertLessEqual(int(result['playlist']), 2 ** 31 - 1)\n\n    def test_status_method_contains_playlistlength(self):\n        result = dict(status.status(self.context))\n        self.assertIn('playlistlength', result)\n        self.assertGreaterEqual(int(result['playlistlength']), 0)\n\n    def test_status_method_contains_xfade(self):\n        result = dict(status.status(self.context))\n        self.assertIn('xfade', result)\n        self.assertGreaterEqual(int(result['xfade']), 0)\n\n    def test_status_method_contains_state_is_play(self):\n        self.core.playback.state = PLAYING\n        result = dict(status.status(self.context))\n        self.assertIn('state', result)\n        self.assertEqual(result['state'], 'play')\n\n    def test_status_method_contains_state_is_stop(self):\n        self.core.playback.state = STOPPED\n        result = dict(status.status(self.context))\n        self.assertIn('state', result)\n        self.assertEqual(result['state'], 'stop')\n\n    def test_status_method_contains_state_is_pause(self):\n        self.core.playback.state = PLAYING\n        self.core.playback.state = PAUSED\n        result = dict(status.status(self.context))\n        self.assertIn('state', result)\n        self.assertEqual(result['state'], 'pause')\n\n    def test_status_method_when_playlist_loaded_contains_song(self):\n        self.set_tracklist([Track(uri='dummy:/a')])\n        self.core.playback.play().get()\n        result = dict(status.status(self.context))\n        self.assertIn('song', result)\n        self.assertGreaterEqual(int(result['song']), 0)\n\n    def test_status_method_when_playlist_loaded_contains_tlid_as_songid(self):\n        self.set_tracklist([Track(uri='dummy:/a')])\n        self.core.playback.play().get()\n        result = dict(status.status(self.context))\n        self.assertIn('songid', result)\n        self.assertEqual(int(result['songid']), 1)\n\n    def test_status_method_when_playlist_loaded_contains_nextsong(self):\n        self.set_tracklist([Track(uri='dummy:/a'), Track(uri='dummy:/b')])\n        self.core.playback.play().get()\n        result = dict(status.status(self.context))\n        self.assertIn('nextsong', result)\n        self.assertGreaterEqual(int(result['nextsong']), 0)\n\n    def test_status_method_when_playlist_loaded_contains_nextsongid(self):\n        self.set_tracklist([Track(uri='dummy:/a'), Track(uri='dummy:/b')])\n        self.core.playback.play().get()\n        result = dict(status.status(self.context))\n        self.assertIn('nextsongid', result)\n        self.assertEqual(int(result['nextsongid']), 2)\n\n    def test_status_method_when_playing_contains_time_with_no_length(self):\n        self.set_tracklist([Track(uri='dummy:/a', length=None)])\n        self.core.playback.play().get()\n        result = dict(status.status(self.context))\n        self.assertIn('time', result)\n        (position, total) = result['time'].split(':')\n        position = int(position)\n        total = int(total)\n        self.assertLessEqual(position, total)\n\n    def test_status_method_when_playing_contains_time_with_length(self):\n        self.set_tracklist([Track(uri='dummy:/a', length=10000)])\n        self.core.playback.play()\n        result = dict(status.status(self.context))\n        self.assertIn('time', result)\n        (position, total) = result['time'].split(':')\n        position = int(position)\n        total = int(total)\n        self.assertLessEqual(position, total)\n\n    def test_status_method_when_playing_contains_elapsed(self):\n        self.set_tracklist([Track(uri='dummy:/a', length=60000)])\n        self.core.playback.play().get()\n        self.core.playback.pause()\n        self.core.playback.seek(59123)\n        result = dict(status.status(self.context))\n        self.assertIn('elapsed', result)\n        self.assertEqual(result['elapsed'], '59.123')\n\n    def test_status_method_when_starting_playing_contains_elapsed_zero(self):\n        self.set_tracklist([Track(uri='dummy:/a', length=10000)])\n        self.core.playback.play().get()\n        self.core.playback.pause()\n        result = dict(status.status(self.context))\n        self.assertIn('elapsed', result)\n        self.assertEqual(result['elapsed'], '0.000')\n\n    def test_status_method_when_playing_contains_bitrate(self):\n        self.set_tracklist([Track(uri='dummy:/a', bitrate=3200)])\n        self.core.playback.play().get()\n        result = dict(status.status(self.context))\n        self.assertIn('bitrate', result)\n        self.assertEqual(int(result['bitrate']), 3200)\n", "comments": "  fixme migrate using protocol basetestcase instead status stats    directly     noqa  n802    noqa  n802 ", "content": "from __future__ import absolute_import, unicode_literals\n\nimport unittest\n\nimport pykka\n\nfrom mopidy import core\nfrom mopidy.core import PlaybackState\nfrom mopidy.internal import deprecation\nfrom mopidy.models import Track\nfrom mopidy.mpd import dispatcher\nfrom mopidy.mpd.protocol import status\n\nfrom tests import dummy_audio, dummy_backend, dummy_mixer\n\n\nPAUSED = PlaybackState.PAUSED\nPLAYING = PlaybackState.PLAYING\nSTOPPED = PlaybackState.STOPPED\n\n# FIXME migrate to using protocol.BaseTestCase instead of status.stats\n# directly?\n\n\nclass StatusHandlerTest(unittest.TestCase):\n\n    def setUp(self):  # noqa: N802\n        config = {\n            'core': {\n                'max_tracklist_length': 10000,\n            }\n        }\n\n        self.audio = dummy_audio.create_proxy()\n        self.mixer = dummy_mixer.create_proxy()\n        self.backend = dummy_backend.create_proxy(audio=self.audio)\n\n        with deprecation.ignore():\n            self.core = core.Core.start(\n                config,\n                audio=self.audio,\n                mixer=self.mixer,\n                backends=[self.backend]).proxy()\n\n        self.dispatcher = dispatcher.MpdDispatcher(core=self.core)\n        self.context = self.dispatcher.context\n\n    def tearDown(self):  # noqa: N802\n        pykka.ActorRegistry.stop_all()\n\n    def set_tracklist(self, tracks):\n        self.backend.library.dummy_library = tracks\n        self.core.tracklist.add(uris=[track.uri for track in tracks]).get()\n\n    def test_stats_method(self):\n        result = status.stats(self.context)\n        self.assertIn('artists', result)\n        self.assertGreaterEqual(int(result['artists']), 0)\n        self.assertIn('albums', result)\n        self.assertGreaterEqual(int(result['albums']), 0)\n        self.assertIn('songs', result)\n        self.assertGreaterEqual(int(result['songs']), 0)\n        self.assertIn('uptime', result)\n        self.assertGreaterEqual(int(result['uptime']), 0)\n        self.assertIn('db_playtime', result)\n        self.assertGreaterEqual(int(result['db_playtime']), 0)\n        self.assertIn('db_update', result)\n        self.assertGreaterEqual(int(result['db_update']), 0)\n        self.assertIn('playtime', result)\n        self.assertGreaterEqual(int(result['playtime']), 0)\n\n    def test_status_method_contains_volume_with_na_value(self):\n        result = dict(status.status(self.context))\n        self.assertIn('volume', result)\n        self.assertEqual(int(result['volume']), -1)\n\n    def test_status_method_contains_volume(self):\n        self.core.mixer.set_volume(17)\n        result = dict(status.status(self.context))\n        self.assertIn('volume', result)\n        self.assertEqual(int(result['volume']), 17)\n\n    def test_status_method_contains_repeat_is_0(self):\n        result = dict(status.status(self.context))\n        self.assertIn('repeat', result)\n        self.assertEqual(int(result['repeat']), 0)\n\n    def test_status_method_contains_repeat_is_1(self):\n        self.core.tracklist.set_repeat(True)\n        result = dict(status.status(self.context))\n        self.assertIn('repeat', result)\n        self.assertEqual(int(result['repeat']), 1)\n\n    def test_status_method_contains_random_is_0(self):\n        result = dict(status.status(self.context))\n        self.assertIn('random', result)\n        self.assertEqual(int(result['random']), 0)\n\n    def test_status_method_contains_random_is_1(self):\n        self.core.tracklist.set_random(True)\n        result = dict(status.status(self.context))\n        self.assertIn('random', result)\n        self.assertEqual(int(result['random']), 1)\n\n    def test_status_method_contains_single(self):\n        result = dict(status.status(self.context))\n        self.assertIn('single', result)\n        self.assertIn(int(result['single']), (0, 1))\n\n    def test_status_method_contains_consume_is_0(self):\n        result = dict(status.status(self.context))\n        self.assertIn('consume', result)\n        self.assertEqual(int(result['consume']), 0)\n\n    def test_status_method_contains_consume_is_1(self):\n        self.core.tracklist.set_consume(True)\n        result = dict(status.status(self.context))\n        self.assertIn('consume', result)\n        self.assertEqual(int(result['consume']), 1)\n\n    def test_status_method_contains_playlist(self):\n        result = dict(status.status(self.context))\n        self.assertIn('playlist', result)\n        self.assertGreaterEqual(int(result['playlist']), 0)\n        self.assertLessEqual(int(result['playlist']), 2 ** 31 - 1)\n\n    def test_status_method_contains_playlistlength(self):\n        result = dict(status.status(self.context))\n        self.assertIn('playlistlength', result)\n        self.assertGreaterEqual(int(result['playlistlength']), 0)\n\n    def test_status_method_contains_xfade(self):\n        result = dict(status.status(self.context))\n        self.assertIn('xfade', result)\n        self.assertGreaterEqual(int(result['xfade']), 0)\n\n    def test_status_method_contains_state_is_play(self):\n        self.core.playback.state = PLAYING\n        result = dict(status.status(self.context))\n        self.assertIn('state', result)\n        self.assertEqual(result['state'], 'play')\n\n    def test_status_method_contains_state_is_stop(self):\n        self.core.playback.state = STOPPED\n        result = dict(status.status(self.context))\n        self.assertIn('state', result)\n        self.assertEqual(result['state'], 'stop')\n\n    def test_status_method_contains_state_is_pause(self):\n        self.core.playback.state = PLAYING\n        self.core.playback.state = PAUSED\n        result = dict(status.status(self.context))\n        self.assertIn('state', result)\n        self.assertEqual(result['state'], 'pause')\n\n    def test_status_method_when_playlist_loaded_contains_song(self):\n        self.set_tracklist([Track(uri='dummy:/a')])\n        self.core.playback.play().get()\n        result = dict(status.status(self.context))\n        self.assertIn('song', result)\n        self.assertGreaterEqual(int(result['song']), 0)\n\n    def test_status_method_when_playlist_loaded_contains_tlid_as_songid(self):\n        self.set_tracklist([Track(uri='dummy:/a')])\n        self.core.playback.play().get()\n        result = dict(status.status(self.context))\n        self.assertIn('songid', result)\n        self.assertEqual(int(result['songid']), 1)\n\n    def test_status_method_when_playlist_loaded_contains_nextsong(self):\n        self.set_tracklist([Track(uri='dummy:/a'), Track(uri='dummy:/b')])\n        self.core.playback.play().get()\n        result = dict(status.status(self.context))\n        self.assertIn('nextsong', result)\n        self.assertGreaterEqual(int(result['nextsong']), 0)\n\n    def test_status_method_when_playlist_loaded_contains_nextsongid(self):\n        self.set_tracklist([Track(uri='dummy:/a'), Track(uri='dummy:/b')])\n        self.core.playback.play().get()\n        result = dict(status.status(self.context))\n        self.assertIn('nextsongid', result)\n        self.assertEqual(int(result['nextsongid']), 2)\n\n    def test_status_method_when_playing_contains_time_with_no_length(self):\n        self.set_tracklist([Track(uri='dummy:/a', length=None)])\n        self.core.playback.play().get()\n        result = dict(status.status(self.context))\n        self.assertIn('time', result)\n        (position, total) = result['time'].split(':')\n        position = int(position)\n        total = int(total)\n        self.assertLessEqual(position, total)\n\n    def test_status_method_when_playing_contains_time_with_length(self):\n        self.set_tracklist([Track(uri='dummy:/a', length=10000)])\n        self.core.playback.play()\n        result = dict(status.status(self.context))\n        self.assertIn('time', result)\n        (position, total) = result['time'].split(':')\n        position = int(position)\n        total = int(total)\n        self.assertLessEqual(position, total)\n\n    def test_status_method_when_playing_contains_elapsed(self):\n        self.set_tracklist([Track(uri='dummy:/a', length=60000)])\n        self.core.playback.play().get()\n        self.core.playback.pause()\n        self.core.playback.seek(59123)\n        result = dict(status.status(self.context))\n        self.assertIn('elapsed', result)\n        self.assertEqual(result['elapsed'], '59.123')\n\n    def test_status_method_when_starting_playing_contains_elapsed_zero(self):\n        self.set_tracklist([Track(uri='dummy:/a', length=10000)])\n        self.core.playback.play().get()\n        self.core.playback.pause()\n        result = dict(status.status(self.context))\n        self.assertIn('elapsed', result)\n        self.assertEqual(result['elapsed'], '0.000')\n\n    def test_status_method_when_playing_contains_bitrate(self):\n        self.set_tracklist([Track(uri='dummy:/a', bitrate=3200)])\n        self.core.playback.play().get()\n        result = dict(status.status(self.context))\n        self.assertIn('bitrate', result)\n        self.assertEqual(int(result['bitrate']), 3200)\n", "description": "Mopidy is an extensible music server that plays music from local disk, Spotify, SoundCloud, Google Play Music, and more. You edit the playlist from any phone, tablet, or computer using a range of MPD and web clients.", "file_name": "test_status.py", "id": "2ba72329125644d6d5f4913a622cf261", "language": "Python", "project_name": "mopidy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mopidy-mopidy/mopidy-mopidy-79d42c3/tests/mpd/test_status.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:12:51Z", "url": "https://github.com/mopidy/mopidy", "wiki": false}