{"author": "donnemartin", "code": "\nclass Node (object):\n\tdef __init__ (self, data):\n\t\tself.data = data\n\t\tself.rightChild = None\n\t\tself.leftChild = None\n\nclass BinaryTree (object):\n\tdef __init__ (self):\n\t\tself.root = None\n\n\tdef insert (self, newData):\n\t\tleaf = Node(newData)\n\n\t\tif self.root is None:\n\t\t\tself.root = leaf\n\t\telse:\n\t\t\tcurrent = self.root\n\t\t\tparent = self.root\n\t\t\twhile current is not None:\n\t\t\t\tparent = current\n\t\t\t\tif newData < current.data:\n\t\t\t\t\tcurrent = current.leftChild\n\t\t\t\telse:\n\t\t\t\t\tcurrent = current.rightChild\n\n\t\t\tif newData < parent.data:\n\t\t\t\tparent.leftChild = leaf\n\t\t\telse:\n\t\t\t\tparent.rightChild = leaf\n\n\t\n\tdef delete (self, data):\n\t\tcurrent = self.root\n\t\tparent = self.root\n\t\tisLeft = False\n\n\t\tif current is None:\n\t\t\treturn False\n\n\t\twhile current is not None and current.data is not data:\n\t\t\tparent = current\n\t\t\tif data < current.data:\n\t\t\t\tcurrent = current.leftChild\n\t\t\t\tisLeft = True \n\t\t\telse:\n\t\t\t\tcurrent = current.rightChild\n\t\t\t\tisLeft = False\n\n\t\tif current is None:\n\t\t\treturn False\n\n\t\tif current.leftChild is None and current.rightChild is None:\n\t\t\tif current is self.root:\n\t\t\t\tself.root = None\n\t\t\telif isLeft:\n\t\t\t\tparent.leftChild = None\n\t\t\telse:\n\t\t\t\tparent.rightChild = None\n\n\t\telif current.rightChild is None:\n\t\t\tif current is self.root:\n\t\t\t\tself.root = current.leftChild\n\t\t\telif isLeft:\n\t\t\t\tparent.leftChild = current.leftChild\n\t\t\telse:\n\t\t\t\tparent.rightChild = current.leftChild\n\n\t\telif current.rightChild is None:\n\t\t\tif current is self.root:\n\t\t\t\tself.root = current.rightChild\n\t\t\telif isLeft:\n\t\t\t\tparent.lChild = current.rightChild\n\t\t\telse:\n\t\t\t\tparent.rightChild = current.rightChild\n\n\t\telse:\n\t\t\tsuccessor = current.rightChild\n\t\t\tsuccessorParent = current\n\n\t\t\twhile successor.leftChild is not None:\n\t\t\t\tsuccessorParent = successor\n\t\t\t\tsuccessor = successor.leftChild\n\n\t\t\tif current is self.root:\n\t\t\t\tself.root = successor\n\t\t\telif isLeft:\n\t\t\t\tparent.leftChild = successor\n\t\t\telse:\n\t\t\t\tparent.rightChild = successor\n\n\t\t\tsuccessor.leftChild = current.leftChild\n\n\t\t\tif successor is not current.rightChild:\n\t\t\t\tsuccessorParent.leftChild = successor.rightChild\n\t\t\t\tsuccessor.rightChild = current.rightChild\n\n\t\treturn True \n\n\n\tdef minNode (self):\n\t\tcurrent = self.root\n\t\twhile current.leftChild is not None:\n\t\t\tcurrent = current.leftChild\n\n\t\treturn current.data\n\n\tdef maxNode (self):\n\t\tcurrent = self.root\n\t\twhile current.rightChild is not None:\n\t\t\tcurrent = current.rightChild\n\n\t\treturn current.data\n\n\tdef printPostOrder (self):\n\t\tglobal postOrder\n\t\tpostOrder = []\n\n\t\tdef PostOrder(node):\n\t\t\tif node is not None:\n\t\t\t\tPostOrder(node.leftChild)\n\t\t\t\tPostOrder(node.rightChild)\n\t\t\t\tpostOrder.append(node.data)\n\n\t\tPostOrder(self.root)\n\t\treturn postOrder\n\n\tdef printInOrder (self):\n\t\tglobal inOrder \n\t\tinOrder = []\n\n\t\tdef InOrder (node):\n\t\t\tif node is not None:\n\t\t\t\tInOrder(node.leftChild)\n\t\t\t\tinOrder.append(node.data)\n\t\t\t\tInOrder(node.rightChild)\n\n\t\tInOrder(self.root)\n\t\treturn inOrder\n\n\tdef printPreOrder (self):\n\t\tglobal preOrder\n\t\tpreOrder = []\n\n\t\tdef PreOrder (node):\n\t\t\tif node is not None:\n\t\t\t\tpreOrder.append(node.data)\n\t\t\t\tPreOrder(node.leftChild)\n\t\t\t\tPreOrder(node.rightChild)\n\n\t\tPreOrder(self.root)\n\t\treturn preOrder\n\n\tdef treeIsEmpty (self):\n\t\treturn self.root is None", "comments": "returns false item deleted tree", "content": "\nclass Node (object):\n\tdef __init__ (self, data):\n\t\tself.data = data\n\t\tself.rightChild = None\n\t\tself.leftChild = None\n\nclass BinaryTree (object):\n\tdef __init__ (self):\n\t\tself.root = None\n\n\tdef insert (self, newData):\n\t\tleaf = Node(newData)\n\n\t\tif self.root is None:\n\t\t\tself.root = leaf\n\t\telse:\n\t\t\tcurrent = self.root\n\t\t\tparent = self.root\n\t\t\twhile current is not None:\n\t\t\t\tparent = current\n\t\t\t\tif newData < current.data:\n\t\t\t\t\tcurrent = current.leftChild\n\t\t\t\telse:\n\t\t\t\t\tcurrent = current.rightChild\n\n\t\t\tif newData < parent.data:\n\t\t\t\tparent.leftChild = leaf\n\t\t\telse:\n\t\t\t\tparent.rightChild = leaf\n\n\t# returns false if the item to be deleted is not on the tree\n\tdef delete (self, data):\n\t\tcurrent = self.root\n\t\tparent = self.root\n\t\tisLeft = False\n\n\t\tif current is None:\n\t\t\treturn False\n\n\t\twhile current is not None and current.data is not data:\n\t\t\tparent = current\n\t\t\tif data < current.data:\n\t\t\t\tcurrent = current.leftChild\n\t\t\t\tisLeft = True \n\t\t\telse:\n\t\t\t\tcurrent = current.rightChild\n\t\t\t\tisLeft = False\n\n\t\tif current is None:\n\t\t\treturn False\n\n\t\tif current.leftChild is None and current.rightChild is None:\n\t\t\tif current is self.root:\n\t\t\t\tself.root = None\n\t\t\telif isLeft:\n\t\t\t\tparent.leftChild = None\n\t\t\telse:\n\t\t\t\tparent.rightChild = None\n\n\t\telif current.rightChild is None:\n\t\t\tif current is self.root:\n\t\t\t\tself.root = current.leftChild\n\t\t\telif isLeft:\n\t\t\t\tparent.leftChild = current.leftChild\n\t\t\telse:\n\t\t\t\tparent.rightChild = current.leftChild\n\n\t\telif current.rightChild is None:\n\t\t\tif current is self.root:\n\t\t\t\tself.root = current.rightChild\n\t\t\telif isLeft:\n\t\t\t\tparent.lChild = current.rightChild\n\t\t\telse:\n\t\t\t\tparent.rightChild = current.rightChild\n\n\t\telse:\n\t\t\tsuccessor = current.rightChild\n\t\t\tsuccessorParent = current\n\n\t\t\twhile successor.leftChild is not None:\n\t\t\t\tsuccessorParent = successor\n\t\t\t\tsuccessor = successor.leftChild\n\n\t\t\tif current is self.root:\n\t\t\t\tself.root = successor\n\t\t\telif isLeft:\n\t\t\t\tparent.leftChild = successor\n\t\t\telse:\n\t\t\t\tparent.rightChild = successor\n\n\t\t\tsuccessor.leftChild = current.leftChild\n\n\t\t\tif successor is not current.rightChild:\n\t\t\t\tsuccessorParent.leftChild = successor.rightChild\n\t\t\t\tsuccessor.rightChild = current.rightChild\n\n\t\treturn True \n\n\n\tdef minNode (self):\n\t\tcurrent = self.root\n\t\twhile current.leftChild is not None:\n\t\t\tcurrent = current.leftChild\n\n\t\treturn current.data\n\n\tdef maxNode (self):\n\t\tcurrent = self.root\n\t\twhile current.rightChild is not None:\n\t\t\tcurrent = current.rightChild\n\n\t\treturn current.data\n\n\tdef printPostOrder (self):\n\t\tglobal postOrder\n\t\tpostOrder = []\n\n\t\tdef PostOrder(node):\n\t\t\tif node is not None:\n\t\t\t\tPostOrder(node.leftChild)\n\t\t\t\tPostOrder(node.rightChild)\n\t\t\t\tpostOrder.append(node.data)\n\n\t\tPostOrder(self.root)\n\t\treturn postOrder\n\n\tdef printInOrder (self):\n\t\tglobal inOrder \n\t\tinOrder = []\n\n\t\tdef InOrder (node):\n\t\t\tif node is not None:\n\t\t\t\tInOrder(node.leftChild)\n\t\t\t\tinOrder.append(node.data)\n\t\t\t\tInOrder(node.rightChild)\n\n\t\tInOrder(self.root)\n\t\treturn inOrder\n\n\tdef printPreOrder (self):\n\t\tglobal preOrder\n\t\tpreOrder = []\n\n\t\tdef PreOrder (node):\n\t\t\tif node is not None:\n\t\t\t\tpreOrder.append(node.data)\n\t\t\t\tPreOrder(node.leftChild)\n\t\t\t\tPreOrder(node.rightChild)\n\n\t\tPreOrder(self.root)\n\t\treturn preOrder\n\n\tdef treeIsEmpty (self):\n\t\treturn self.root is None", "description": "Interactive Python coding interview challenges (algorithms and data structures).  Includes Anki flashcards.", "file_name": "binary_search_tree.py", "id": "46bd2d7af4f9369baaa6112f52069c5e", "language": "Python", "project_name": "interactive-coding-challenges", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/donnemartin-interactive-coding-challenges/donnemartin-interactive-coding-challenges-6eb3114/staging/graphs_trees/binary_tree/binary_search_tree.py", "save_time": "", "source": "", "update_at": "2018-03-13T21:01:52Z", "url": "https://github.com/donnemartin/interactive-coding-challenges", "wiki": true}