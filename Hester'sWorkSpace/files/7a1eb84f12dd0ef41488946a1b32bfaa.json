{"author": "ansible", "code": "\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: rax_meta\nshort_description: Manipulate metadata for Rackspace Cloud Servers\ndescription:\n     - Manipulate metadata for Rackspace Cloud Servers\nversion_added: 1.7\noptions:\n  address:\n    description:\n      - Server IP address to modify metadata for, will match any IP assigned to\n        the server\n  id:\n    description:\n      - Server ID to modify metadata for\n  name:\n    description:\n      - Server name to modify metadata for\n  meta:\n    description:\n      - A hash of metadata to associate with the instance\nauthor: \"Matt Martz (@sivel)\"\nextends_documentation_fragment: rackspace.openstack\n'''\n\nEXAMPLES = '''\n- name: Set metadata for a server\n  hosts: all\n  gather_facts: False\n  tasks:\n    - name: Set metadata\n      local_action:\n        module: rax_meta\n        credentials: ~/.raxpub\n        name: \"{{ inventory_hostname }}\"\n        region: DFW\n        meta:\n          group: primary_group\n          groups:\n            - group_two\n            - group_three\n          app: my_app\n\n    - name: Clear metadata\n      local_action:\n        module: rax_meta\n        credentials: ~/.raxpub\n        name: \"{{ inventory_hostname }}\"\n        region: DFW\n'''\n\nimport json\n\ntry:\n    import pyrax\n    HAS_PYRAX = True\nexcept ImportError:\n    HAS_PYRAX = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.rax import rax_argument_spec, rax_required_together, setup_rax_module\nfrom ansible.module_utils.six import string_types\n\n\ndef rax_meta(module, address, name, server_id, meta):\n    changed = False\n\n    cs = pyrax.cloudservers\n\n    if cs is None:\n        module.fail_json(msg='Failed to instantiate client. This '\n                             'typically indicates an invalid region or an '\n                             'incorrectly capitalized region name.')\n\n    search_opts = {}\n    if name:\n        search_opts = dict(name='^%s$' % name)\n        try:\n            servers = cs.servers.list(search_opts=search_opts)\n        except Exception as e:\n            module.fail_json(msg='%s' % e.message)\n    elif address:\n        servers = []\n        try:\n            for server in cs.servers.list():\n                for addresses in server.networks.values():\n                    if address in addresses:\n                        servers.append(server)\n                        break\n        except Exception as e:\n            module.fail_json(msg='%s' % e.message)\n    elif server_id:\n        servers = []\n        try:\n            servers.append(cs.servers.get(server_id))\n        except Exception as e:\n            pass\n\n    if len(servers) > 1:\n        module.fail_json(msg='Multiple servers found matching provided '\n                             'search parameters')\n    elif not servers:\n        module.fail_json(msg='Failed to find a server matching provided '\n                             'search parameters')\n\n    \n    for k, v in meta.items():\n        if isinstance(v, list):\n            meta[k] = ','.join(['%s' % i for i in v])\n        elif isinstance(v, dict):\n            meta[k] = json.dumps(v)\n        elif not isinstance(v, string_types):\n            meta[k] = '%s' % v\n\n    server = servers[0]\n    if server.metadata == meta:\n        changed = False\n    else:\n        changed = True\n        removed = set(server.metadata.keys()).difference(meta.keys())\n        cs.servers.delete_meta(server, list(removed))\n        cs.servers.set_meta(server, meta)\n        server.get()\n\n    module.exit_json(changed=changed, meta=server.metadata)\n\n\ndef main():\n    argument_spec = rax_argument_spec()\n    argument_spec.update(\n        dict(\n            address=dict(),\n            id=dict(),\n            name=dict(),\n            meta=dict(type='dict', default=dict()),\n        )\n    )\n\n    module = AnsibleModule(\n        argument_spec=argument_spec,\n        required_together=rax_required_together(),\n        mutually_exclusive=[['address', 'id', 'name']],\n        required_one_of=[['address', 'id', 'name']],\n    )\n\n    if not HAS_PYRAX:\n        module.fail_json(msg='pyrax is required for this module')\n\n    address = module.params.get('address')\n    server_id = module.params.get('id')\n    name = module.params.get('name')\n    meta = module.params.get('meta')\n\n    setup_rax_module(module, pyrax)\n\n    rax_meta(module, address, name, server_id, meta)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  rax meta short description  manipulate metadata rackspace cloud servers description         manipulate metadata rackspace cloud servers version added  1 7 options    address      description          server ip address modify metadata  match ip assigned         server   id      description          server id modify metadata   name      description          server name modify metadata   meta      description          a hash metadata associate instance author   matt martz ( sivel)  extends documentation fragment  rackspace openstack      examples         name  set metadata server   hosts    gather facts  false   tasks        name  set metadata       local action          module  rax meta         credentials     raxpub         name      inventory hostname             region  dfw         meta            group  primary group           groups                group two               group three           app  app        name  clear metadata       local action          module  rax meta         credentials     raxpub         name      inventory hostname             region  dfw         usr bin python    copyright  ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    normalize ensure metadata values strings ", "content": "#!/usr/bin/python\n# Copyright: Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: rax_meta\nshort_description: Manipulate metadata for Rackspace Cloud Servers\ndescription:\n     - Manipulate metadata for Rackspace Cloud Servers\nversion_added: 1.7\noptions:\n  address:\n    description:\n      - Server IP address to modify metadata for, will match any IP assigned to\n        the server\n  id:\n    description:\n      - Server ID to modify metadata for\n  name:\n    description:\n      - Server name to modify metadata for\n  meta:\n    description:\n      - A hash of metadata to associate with the instance\nauthor: \"Matt Martz (@sivel)\"\nextends_documentation_fragment: rackspace.openstack\n'''\n\nEXAMPLES = '''\n- name: Set metadata for a server\n  hosts: all\n  gather_facts: False\n  tasks:\n    - name: Set metadata\n      local_action:\n        module: rax_meta\n        credentials: ~/.raxpub\n        name: \"{{ inventory_hostname }}\"\n        region: DFW\n        meta:\n          group: primary_group\n          groups:\n            - group_two\n            - group_three\n          app: my_app\n\n    - name: Clear metadata\n      local_action:\n        module: rax_meta\n        credentials: ~/.raxpub\n        name: \"{{ inventory_hostname }}\"\n        region: DFW\n'''\n\nimport json\n\ntry:\n    import pyrax\n    HAS_PYRAX = True\nexcept ImportError:\n    HAS_PYRAX = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.rax import rax_argument_spec, rax_required_together, setup_rax_module\nfrom ansible.module_utils.six import string_types\n\n\ndef rax_meta(module, address, name, server_id, meta):\n    changed = False\n\n    cs = pyrax.cloudservers\n\n    if cs is None:\n        module.fail_json(msg='Failed to instantiate client. This '\n                             'typically indicates an invalid region or an '\n                             'incorrectly capitalized region name.')\n\n    search_opts = {}\n    if name:\n        search_opts = dict(name='^%s$' % name)\n        try:\n            servers = cs.servers.list(search_opts=search_opts)\n        except Exception as e:\n            module.fail_json(msg='%s' % e.message)\n    elif address:\n        servers = []\n        try:\n            for server in cs.servers.list():\n                for addresses in server.networks.values():\n                    if address in addresses:\n                        servers.append(server)\n                        break\n        except Exception as e:\n            module.fail_json(msg='%s' % e.message)\n    elif server_id:\n        servers = []\n        try:\n            servers.append(cs.servers.get(server_id))\n        except Exception as e:\n            pass\n\n    if len(servers) > 1:\n        module.fail_json(msg='Multiple servers found matching provided '\n                             'search parameters')\n    elif not servers:\n        module.fail_json(msg='Failed to find a server matching provided '\n                             'search parameters')\n\n    # Normalize and ensure all metadata values are strings\n    for k, v in meta.items():\n        if isinstance(v, list):\n            meta[k] = ','.join(['%s' % i for i in v])\n        elif isinstance(v, dict):\n            meta[k] = json.dumps(v)\n        elif not isinstance(v, string_types):\n            meta[k] = '%s' % v\n\n    server = servers[0]\n    if server.metadata == meta:\n        changed = False\n    else:\n        changed = True\n        removed = set(server.metadata.keys()).difference(meta.keys())\n        cs.servers.delete_meta(server, list(removed))\n        cs.servers.set_meta(server, meta)\n        server.get()\n\n    module.exit_json(changed=changed, meta=server.metadata)\n\n\ndef main():\n    argument_spec = rax_argument_spec()\n    argument_spec.update(\n        dict(\n            address=dict(),\n            id=dict(),\n            name=dict(),\n            meta=dict(type='dict', default=dict()),\n        )\n    )\n\n    module = AnsibleModule(\n        argument_spec=argument_spec,\n        required_together=rax_required_together(),\n        mutually_exclusive=[['address', 'id', 'name']],\n        required_one_of=[['address', 'id', 'name']],\n    )\n\n    if not HAS_PYRAX:\n        module.fail_json(msg='pyrax is required for this module')\n\n    address = module.params.get('address')\n    server_id = module.params.get('id')\n    name = module.params.get('name')\n    meta = module.params.get('meta')\n\n    setup_rax_module(module, pyrax)\n\n    rax_meta(module, address, name, server_id, meta)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "rax_meta.py", "id": "7a1eb84f12dd0ef41488946a1b32bfaa", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/cloud/rackspace/rax_meta.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}