{"author": "ansible", "code": "\n -*- coding: utf-8 -*-\n\n Copyright (c) 2016 Dimension Data\n Authors:\n   - Aimon Bustardo <aimon.bustardo@dimensiondata.com>\n   - Bert Diwa      <Lamberto.Diwa@dimensiondata.com>\n   - Adam Friedman  <tintoy@tintoy.io>\n\n GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: dimensiondata_network\nshort_description: Create, update, and delete MCP 1.0 & 2.0 networks\nextends_documentation_fragment:\n  - dimensiondata\n  - dimensiondata_wait\ndescription:\n  - Create, update, and delete MCP 1.0 & 2.0 networks\nversion_added: \"2.3\"\nauthor: 'Aimon Bustardo (@aimonb)'\noptions:\n  name:\n    description:\n      - The name of the network domain to create.\n    required: true\n  description:\n    description:\n      - Additional description of the network domain.\n    required: false\n  service_plan:\n    description:\n      - The service plan, either \"ESSENTIALS\" or \"ADVANCED\".\n      - MCP 2.0 Only.\n    choices: [ESSENTIALS, ADVANCED]\n    default: ESSENTIALS\n  state:\n    description:\n      - Should the resource be present or absent.\n    choices: [present, absent]\n    default: present\n'''\n\nEXAMPLES = '''\n Create an MCP 1.0 network\n- dimensiondata_network:\n    region: na\n    location: NA5\n    name: mynet\n Create an MCP 2.0 network\n- dimensiondata_network:\n    region: na\n    mcp_user: my_user\n    mcp_password: my_password\n    location: NA9\n    name: mynet\n    service_plan: ADVANCED\n Delete a network\n- dimensiondata_network:\n    region: na\n    location: NA1\n    name: mynet\n    state: absent\n'''\n\nRETURN = '''\nnetwork:\n    description: Dictionary describing the network.\n    returned: On success when I(state=present).\n    type: complex\n    contains:\n        id:\n            description: Network ID.\n            type: string\n            sample: \"8c787000-a000-4050-a215-280893411a7d\"\n        name:\n            description: Network name.\n            type: string\n            sample: \"My network\"\n        description:\n            description: Network description.\n            type: string\n            sample: \"My network description\"\n        location:\n            description: Datacenter location.\n            type: string\n            sample: NA3\n        status:\n            description: Network status. (MCP 2.0 only)\n            type: string\n            sample: NORMAL\n        private_net:\n            description: Private network subnet. (MCP 1.0 only)\n            type: string\n            sample: \"10.2.3.0\"\n        multicast:\n            description: Multicast enabled? (MCP 1.0 only)\n            type: boolean\n            sample: false\n'''\nimport traceback\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.dimensiondata import HAS_LIBCLOUD, DimensionDataModule\nfrom ansible.module_utils._text import to_native\n\nif HAS_LIBCLOUD:\n    from libcloud.compute.base import NodeLocation\n    from libcloud.common.dimensiondata import DimensionDataAPIException\n\n\nclass DimensionDataNetworkModule(DimensionDataModule):\n    \"\"\"\n    The dimensiondata_network module for Ansible.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Create a new Dimension Data network module.\n        \"\"\"\n\n        super(DimensionDataNetworkModule, self).__init__(\n            module=AnsibleModule(\n                argument_spec=DimensionDataModule.argument_spec_with_wait(\n                    name=dict(type='str', required=True),\n                    description=dict(type='str', required=False),\n                    service_plan=dict(default='ESSENTIALS', choices=['ADVANCED', 'ESSENTIALS']),\n                    state=dict(default='present', choices=['present', 'absent'])\n                ),\n                required_together=DimensionDataModule.required_together()\n            )\n        )\n\n        self.name = self.module.params['name']\n        self.description = self.module.params['description']\n        self.service_plan = self.module.params['service_plan']\n        self.state = self.module.params['state']\n\n    def state_present(self):\n        network = self._get_network()\n\n        if network:\n            self.module.exit_json(\n                changed=False,\n                msg='Network already exists',\n                network=self._network_to_dict(network)\n            )\n\n        network = self._create_network()\n\n        self.module.exit_json(\n            changed=True,\n            msg='Created network \"%s\" in datacenter \"%s\".' % (self.name, self.location),\n            network=self._network_to_dict(network)\n        )\n\n    def state_absent(self):\n        network = self._get_network()\n\n        if not network:\n            self.module.exit_json(\n                changed=False,\n                msg='Network \"%s\" does not exist' % self.name,\n                network=self._network_to_dict(network)\n            )\n\n        self._delete_network(network)\n\n    def _get_network(self):\n        if self.mcp_version == '1.0':\n            networks = self.driver.list_networks(location=self.location)\n        else:\n            networks = self.driver.ex_list_network_domains(location=self.location)\n\n        matched_network = [network for network in networks if network.name == self.name]\n        if matched_network:\n            return matched_network[0]\n\n        return None\n\n    def _network_to_dict(self, network):\n        network_dict = dict(\n            id=network.id,\n            name=network.name,\n            description=network.description\n        )\n\n        if isinstance(network.location, NodeLocation):\n            network_dict['location'] = network.location.id\n        else:\n            network_dict['location'] = network.location\n\n        if self.mcp_version == '1.0':\n            network_dict['private_net'] = network.private_net\n            network_dict['multicast'] = network.multicast\n            network_dict['status'] = None\n        else:\n            network_dict['private_net'] = None\n            network_dict['multicast'] = None\n            network_dict['status'] = network.status\n\n        return network_dict\n\n    def _create_network(self):\n\n         Make sure service_plan argument is defined\n        if self.mcp_version == '2.0' and 'service_plan' not in self.module.params:\n            self.module.fail_json(\n                msg='service_plan required when creating network and location is MCP 2.0'\n            )\n\n         Create network\n        try:\n            if self.mcp_version == '1.0':\n                network = self.driver.ex_create_network(\n                    self.location,\n                    self.name,\n                    description=self.description\n                )\n            else:\n                network = self.driver.ex_create_network_domain(\n                    self.location,\n                    self.name,\n                    self.module.params['service_plan'],\n                    description=self.description\n                )\n        except DimensionDataAPIException as e:\n\n            self.module.fail_json(\n                msg=\"Failed to create new network: %s\" % to_native(e), exception=traceback.format_exc()\n            )\n\n        if self.module.params['wait'] is True:\n            network = self._wait_for_network_state(network.id, 'NORMAL')\n\n        return network\n\n    def _delete_network(self, network):\n        try:\n            if self.mcp_version == '1.0':\n                deleted = self.driver.ex_delete_network(network)\n            else:\n                deleted = self.driver.ex_delete_network_domain(network)\n\n            if deleted:\n                self.module.exit_json(\n                    changed=True,\n                    msg=\"Deleted network with id %s\" % network.id\n                )\n\n            self.module.fail_json(\n                \"Unexpected failure deleting network with id %s\", network.id\n            )\n\n        except DimensionDataAPIException as e:\n            self.module.fail_json(\n                msg=\"Failed to delete network: %s\" % to_native(e), exception=traceback.format_exc()\n            )\n\n    def _wait_for_network_state(self, net_id, state_to_wait_for):\n        try:\n            return self.driver.connection.wait_for_state(\n                state_to_wait_for,\n                self.driver.ex_get_network_domain,\n                self.module.params['wait_poll_interval'],\n                self.module.params['wait_time'],\n                net_id\n            )\n        except DimensionDataAPIException as e:\n            self.module.fail_json(\n                msg='Network did not reach % state in time: %s' % (state_to_wait_for, to_native(e)),\n                exception=traceback.format_exc()\n            )\n\n\ndef main():\n    module = DimensionDataNetworkModule()\n    if module.state == 'present':\n        module.state_present()\n    elif module.state == 'absent':\n        module.state_absent()\n\nif __name__ == '__main__':\n    main()\n", "comments": "        the dimensiondata network module ansible               def   init  (self)                      create new dimension data network module                       module  dimensiondata network short description  create  update  delete mcp 1 0   2 0 networks extends documentation fragment      dimensiondata     dimensiondata wait description      create  update  delete mcp 1 0   2 0 networks version added   2 3  author   aimon bustardo ( aimonb)  options    name      description          the name network domain create      required  true   description      description          additional description network domain      required  false   service plan      description          the service plan  either  essentials   advanced           mcp 2 0 only      choices   essentials  advanced      default  essentials   state      description          should resource present absent      choices   present  absent      default  present      examples         create mcp 1 0 network   dimensiondata network      region  na     location  na5     name  mynet   create mcp 2 0 network   dimensiondata network      region  na     mcp user  user     mcp password  password     location  na9     name  mynet     service plan  advanced   delete network   dimensiondata network      region  na     location  na1     name  mynet     state  absent      return       network      description  dictionary describing network      returned  on success i(state present)      type  complex     contains          id              description  network id              type  string             sample   8c787000 a000 4050 a215 280893411a7d          name              description  network name              type  string             sample   my network          description              description  network description              type  string             sample   my network description          location              description  datacenter location              type  string             sample  na3         status              description  network status  (mcp 2 0 only)             type  string             sample  normal         private net              description  private network subnet  (mcp 1 0 only)             type  string             sample   10 2 3 0          multicast              description  multicast enabled  (mcp 1 0 only)             type  boolean             sample  false         usr bin python        coding  utf 8           copyright (c) 2016 dimension data    authors         aimon bustardo  aimon bustardo dimensiondata com         bert diwa       lamberto diwa dimensiondata com         adam friedman   tintoy tintoy io        gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    create mcp 1 0 network    create mcp 2 0 network    delete network    make sure service plan argument defined    create network ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n#\n# Copyright (c) 2016 Dimension Data\n# Authors:\n#   - Aimon Bustardo <aimon.bustardo@dimensiondata.com>\n#   - Bert Diwa      <Lamberto.Diwa@dimensiondata.com>\n#   - Adam Friedman  <tintoy@tintoy.io>\n#\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: dimensiondata_network\nshort_description: Create, update, and delete MCP 1.0 & 2.0 networks\nextends_documentation_fragment:\n  - dimensiondata\n  - dimensiondata_wait\ndescription:\n  - Create, update, and delete MCP 1.0 & 2.0 networks\nversion_added: \"2.3\"\nauthor: 'Aimon Bustardo (@aimonb)'\noptions:\n  name:\n    description:\n      - The name of the network domain to create.\n    required: true\n  description:\n    description:\n      - Additional description of the network domain.\n    required: false\n  service_plan:\n    description:\n      - The service plan, either \"ESSENTIALS\" or \"ADVANCED\".\n      - MCP 2.0 Only.\n    choices: [ESSENTIALS, ADVANCED]\n    default: ESSENTIALS\n  state:\n    description:\n      - Should the resource be present or absent.\n    choices: [present, absent]\n    default: present\n'''\n\nEXAMPLES = '''\n# Create an MCP 1.0 network\n- dimensiondata_network:\n    region: na\n    location: NA5\n    name: mynet\n# Create an MCP 2.0 network\n- dimensiondata_network:\n    region: na\n    mcp_user: my_user\n    mcp_password: my_password\n    location: NA9\n    name: mynet\n    service_plan: ADVANCED\n# Delete a network\n- dimensiondata_network:\n    region: na\n    location: NA1\n    name: mynet\n    state: absent\n'''\n\nRETURN = '''\nnetwork:\n    description: Dictionary describing the network.\n    returned: On success when I(state=present).\n    type: complex\n    contains:\n        id:\n            description: Network ID.\n            type: string\n            sample: \"8c787000-a000-4050-a215-280893411a7d\"\n        name:\n            description: Network name.\n            type: string\n            sample: \"My network\"\n        description:\n            description: Network description.\n            type: string\n            sample: \"My network description\"\n        location:\n            description: Datacenter location.\n            type: string\n            sample: NA3\n        status:\n            description: Network status. (MCP 2.0 only)\n            type: string\n            sample: NORMAL\n        private_net:\n            description: Private network subnet. (MCP 1.0 only)\n            type: string\n            sample: \"10.2.3.0\"\n        multicast:\n            description: Multicast enabled? (MCP 1.0 only)\n            type: boolean\n            sample: false\n'''\nimport traceback\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.dimensiondata import HAS_LIBCLOUD, DimensionDataModule\nfrom ansible.module_utils._text import to_native\n\nif HAS_LIBCLOUD:\n    from libcloud.compute.base import NodeLocation\n    from libcloud.common.dimensiondata import DimensionDataAPIException\n\n\nclass DimensionDataNetworkModule(DimensionDataModule):\n    \"\"\"\n    The dimensiondata_network module for Ansible.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Create a new Dimension Data network module.\n        \"\"\"\n\n        super(DimensionDataNetworkModule, self).__init__(\n            module=AnsibleModule(\n                argument_spec=DimensionDataModule.argument_spec_with_wait(\n                    name=dict(type='str', required=True),\n                    description=dict(type='str', required=False),\n                    service_plan=dict(default='ESSENTIALS', choices=['ADVANCED', 'ESSENTIALS']),\n                    state=dict(default='present', choices=['present', 'absent'])\n                ),\n                required_together=DimensionDataModule.required_together()\n            )\n        )\n\n        self.name = self.module.params['name']\n        self.description = self.module.params['description']\n        self.service_plan = self.module.params['service_plan']\n        self.state = self.module.params['state']\n\n    def state_present(self):\n        network = self._get_network()\n\n        if network:\n            self.module.exit_json(\n                changed=False,\n                msg='Network already exists',\n                network=self._network_to_dict(network)\n            )\n\n        network = self._create_network()\n\n        self.module.exit_json(\n            changed=True,\n            msg='Created network \"%s\" in datacenter \"%s\".' % (self.name, self.location),\n            network=self._network_to_dict(network)\n        )\n\n    def state_absent(self):\n        network = self._get_network()\n\n        if not network:\n            self.module.exit_json(\n                changed=False,\n                msg='Network \"%s\" does not exist' % self.name,\n                network=self._network_to_dict(network)\n            )\n\n        self._delete_network(network)\n\n    def _get_network(self):\n        if self.mcp_version == '1.0':\n            networks = self.driver.list_networks(location=self.location)\n        else:\n            networks = self.driver.ex_list_network_domains(location=self.location)\n\n        matched_network = [network for network in networks if network.name == self.name]\n        if matched_network:\n            return matched_network[0]\n\n        return None\n\n    def _network_to_dict(self, network):\n        network_dict = dict(\n            id=network.id,\n            name=network.name,\n            description=network.description\n        )\n\n        if isinstance(network.location, NodeLocation):\n            network_dict['location'] = network.location.id\n        else:\n            network_dict['location'] = network.location\n\n        if self.mcp_version == '1.0':\n            network_dict['private_net'] = network.private_net\n            network_dict['multicast'] = network.multicast\n            network_dict['status'] = None\n        else:\n            network_dict['private_net'] = None\n            network_dict['multicast'] = None\n            network_dict['status'] = network.status\n\n        return network_dict\n\n    def _create_network(self):\n\n        # Make sure service_plan argument is defined\n        if self.mcp_version == '2.0' and 'service_plan' not in self.module.params:\n            self.module.fail_json(\n                msg='service_plan required when creating network and location is MCP 2.0'\n            )\n\n        # Create network\n        try:\n            if self.mcp_version == '1.0':\n                network = self.driver.ex_create_network(\n                    self.location,\n                    self.name,\n                    description=self.description\n                )\n            else:\n                network = self.driver.ex_create_network_domain(\n                    self.location,\n                    self.name,\n                    self.module.params['service_plan'],\n                    description=self.description\n                )\n        except DimensionDataAPIException as e:\n\n            self.module.fail_json(\n                msg=\"Failed to create new network: %s\" % to_native(e), exception=traceback.format_exc()\n            )\n\n        if self.module.params['wait'] is True:\n            network = self._wait_for_network_state(network.id, 'NORMAL')\n\n        return network\n\n    def _delete_network(self, network):\n        try:\n            if self.mcp_version == '1.0':\n                deleted = self.driver.ex_delete_network(network)\n            else:\n                deleted = self.driver.ex_delete_network_domain(network)\n\n            if deleted:\n                self.module.exit_json(\n                    changed=True,\n                    msg=\"Deleted network with id %s\" % network.id\n                )\n\n            self.module.fail_json(\n                \"Unexpected failure deleting network with id %s\", network.id\n            )\n\n        except DimensionDataAPIException as e:\n            self.module.fail_json(\n                msg=\"Failed to delete network: %s\" % to_native(e), exception=traceback.format_exc()\n            )\n\n    def _wait_for_network_state(self, net_id, state_to_wait_for):\n        try:\n            return self.driver.connection.wait_for_state(\n                state_to_wait_for,\n                self.driver.ex_get_network_domain,\n                self.module.params['wait_poll_interval'],\n                self.module.params['wait_time'],\n                net_id\n            )\n        except DimensionDataAPIException as e:\n            self.module.fail_json(\n                msg='Network did not reach % state in time: %s' % (state_to_wait_for, to_native(e)),\n                exception=traceback.format_exc()\n            )\n\n\ndef main():\n    module = DimensionDataNetworkModule()\n    if module.state == 'present':\n        module.state_present()\n    elif module.state == 'absent':\n        module.state_absent()\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "dimensiondata_network.py", "id": "1112e1ad1d86cf2d14f1ab7058acc44e", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/cloud/dimensiondata/dimensiondata_network.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}