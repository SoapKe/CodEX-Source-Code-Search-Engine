{"author": "django", "code": "import unittest\n\nfrom django.test import SimpleTestCase\nfrom django.test.runner import RemoteTestResult\nfrom django.utils.version import PY37\n\ntry:\n    import tblib\nexcept ImportError:\n    tblib = None\n\n\nclass ExceptionThatFailsUnpickling(Exception):\n    \"\"\"\n    After pickling, this class fails unpickling with an error about incorrect\n    arguments passed to __init__().\n    \"\"\"\n    def __init__(self, arg):\n        super().__init__()\n\n\nclass ParallelTestRunnerTest(SimpleTestCase):\n    \"\"\"\n    End-to-end tests of the parallel test runner.\n\n    These tests are only meaningful when running tests in parallel using\n    the --parallel option, though it doesn't hurt to run them not in\n    parallel.\n    \"\"\"\n\n    def test_subtest(self):\n        \"\"\"\n        Passing subtests work.\n        \"\"\"\n        for i in range(2):\n            with self.subTest(index=i):\n                self.assertEqual(i, i)\n\n\nclass SampleFailingSubtest(SimpleTestCase):\n\n    \n    \n    def dummy_test(self):\n        \"\"\"\n        A dummy test for testing subTest failures.\n        \"\"\"\n        for i in range(3):\n            with self.subTest(index=i):\n                self.assertEqual(i, 1)\n\n\nclass RemoteTestResultTest(SimpleTestCase):\n\n    def test_pickle_errors_detection(self):\n        picklable_error = RuntimeError('This is fine')\n        not_unpicklable_error = ExceptionThatFailsUnpickling('arg')\n\n        result = RemoteTestResult()\n        result._confirm_picklable(picklable_error)\n\n        msg = '__init__() missing 1 required positional argument'\n        with self.assertRaisesMessage(TypeError, msg):\n            result._confirm_picklable(not_unpicklable_error)\n\n    @unittest.skipUnless(tblib is not None, 'requires tblib to be installed')\n    def test_add_failing_subtests(self):\n        \"\"\"\n        Failing subtests are added correctly using addSubTest().\n        \"\"\"\n        \n        \n        result = RemoteTestResult()\n        subtest_test = SampleFailingSubtest(methodName='dummy_test')\n        subtest_test.run(result=result)\n\n        events = result.events\n        self.assertEqual(len(events), 4)\n\n        event = events[1]\n        self.assertEqual(event[0], 'addSubTest')\n        self.assertEqual(str(event[2]), 'dummy_test (test_runner.test_parallel.SampleFailingSubtest) (index=0)')\n        trailing_comma = '' if PY37 else ','\n        self.assertEqual(repr(event[3][1]), \"AssertionError('0 != 1'%s)\" % trailing_comma)\n\n        event = events[2]\n        self.assertEqual(repr(event[3][1]), \"AssertionError('2 != 1'%s)\" % trailing_comma)\n", "comments": "        after pickling  class fails unpickling error incorrect     arguments passed   init  ()              def   init  (self  arg)          super()   init  ()   class paralleltestrunnertest(simpletestcase)              end end tests parallel test runner       these tests meaningful running tests parallel using       parallel option  though hurt run     parallel               def test subtest(self)                      passing subtests work                      range(2)              self subtest(index i)                  self assertequal(i  i)   class samplefailingsubtest(simpletestcase)         this method name begin  test  prevent test discovery       seeing      def dummy test(self)                      a dummy test testing subtest failures                      range(3)              self subtest(index i)                  self assertequal(i  1)   class remotetestresulttest(simpletestcase)       def test pickle errors detection(self)          picklable error   runtimeerror( this fine )         unpicklable error   exceptionthatfailsunpickling( arg )          result   remotetestresult()         result  confirm picklable(picklable error)          msg      init  () missing 1 required positional argument          self assertraisesmessage(typeerror  msg)              result  confirm picklable(not unpicklable error)       unittest skipunless(tblib none   requires tblib installed )     def test add failing subtests(self)                      failing subtests added correctly using addsubtest()                 this method name begin  test  prevent test discovery    seeing     manually run test failing subtests prevent failures    affecting actual test run  ", "content": "import unittest\n\nfrom django.test import SimpleTestCase\nfrom django.test.runner import RemoteTestResult\nfrom django.utils.version import PY37\n\ntry:\n    import tblib\nexcept ImportError:\n    tblib = None\n\n\nclass ExceptionThatFailsUnpickling(Exception):\n    \"\"\"\n    After pickling, this class fails unpickling with an error about incorrect\n    arguments passed to __init__().\n    \"\"\"\n    def __init__(self, arg):\n        super().__init__()\n\n\nclass ParallelTestRunnerTest(SimpleTestCase):\n    \"\"\"\n    End-to-end tests of the parallel test runner.\n\n    These tests are only meaningful when running tests in parallel using\n    the --parallel option, though it doesn't hurt to run them not in\n    parallel.\n    \"\"\"\n\n    def test_subtest(self):\n        \"\"\"\n        Passing subtests work.\n        \"\"\"\n        for i in range(2):\n            with self.subTest(index=i):\n                self.assertEqual(i, i)\n\n\nclass SampleFailingSubtest(SimpleTestCase):\n\n    # This method name doesn't begin with \"test\" to prevent test discovery\n    # from seeing it.\n    def dummy_test(self):\n        \"\"\"\n        A dummy test for testing subTest failures.\n        \"\"\"\n        for i in range(3):\n            with self.subTest(index=i):\n                self.assertEqual(i, 1)\n\n\nclass RemoteTestResultTest(SimpleTestCase):\n\n    def test_pickle_errors_detection(self):\n        picklable_error = RuntimeError('This is fine')\n        not_unpicklable_error = ExceptionThatFailsUnpickling('arg')\n\n        result = RemoteTestResult()\n        result._confirm_picklable(picklable_error)\n\n        msg = '__init__() missing 1 required positional argument'\n        with self.assertRaisesMessage(TypeError, msg):\n            result._confirm_picklable(not_unpicklable_error)\n\n    @unittest.skipUnless(tblib is not None, 'requires tblib to be installed')\n    def test_add_failing_subtests(self):\n        \"\"\"\n        Failing subtests are added correctly using addSubTest().\n        \"\"\"\n        # Manually run a test with failing subtests to prevent the failures\n        # from affecting the actual test run.\n        result = RemoteTestResult()\n        subtest_test = SampleFailingSubtest(methodName='dummy_test')\n        subtest_test.run(result=result)\n\n        events = result.events\n        self.assertEqual(len(events), 4)\n\n        event = events[1]\n        self.assertEqual(event[0], 'addSubTest')\n        self.assertEqual(str(event[2]), 'dummy_test (test_runner.test_parallel.SampleFailingSubtest) (index=0)')\n        trailing_comma = '' if PY37 else ','\n        self.assertEqual(repr(event[3][1]), \"AssertionError('0 != 1'%s)\" % trailing_comma)\n\n        event = events[2]\n        self.assertEqual(repr(event[3][1]), \"AssertionError('2 != 1'%s)\" % trailing_comma)\n", "description": "The Web framework for perfectionists with deadlines.", "file_name": "test_parallel.py", "id": "18f4f05f3726c47e408a6da59a0b7660", "language": "Python", "project_name": "django", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/django-django/django-django-274e3e2/tests/test_runner/test_parallel.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:39:10Z", "url": "https://github.com/django/django", "wiki": false}