{"author": "getsentry", "code": "from __future__ import absolute_import\n\nimport pytest\n\nfrom collections import OrderedDict\nfrom datetime import datetime\n\nfrom sentry.search.base import ANY\nfrom sentry.testutils import TestCase\nfrom sentry.tagstore import TagKeyStatus\nfrom sentry.tagstore.v2.backend import V2TagStorage\nfrom sentry.tagstore.v2.models import TagKey, TagValue, GroupTagKey, GroupTagValue, EventTag\nfrom sentry.tagstore.exceptions import TagKeyNotFound, TagValueNotFound, GroupTagKeyNotFound, GroupTagValueNotFound\n\n\nclass TagStorage(TestCase):\n    def setUp(self):\n        self.ts = V2TagStorage()\n\n        self.proj1 = self.create_project()\n        self.proj1group1 = self.create_group(self.proj1)\n        self.proj1group2 = self.create_group(self.proj1)\n        self.proj1env1 = self.create_environment(project=self.proj1)\n        self.proj1env2 = self.create_environment(project=self.proj1)\n        self.proj1group1event1 = self.create_event(project=self.proj1, group=self.proj1group1)\n        self.proj1group1event2 = self.create_event(project=self.proj1, group=self.proj1group1)\n        self.proj1group1event3 = self.create_event(project=self.proj1, group=self.proj1group1)\n\n        self.proj2 = self.create_project()\n        self.proj2group1 = self.create_group(self.proj2)\n        self.proj2env1 = self.create_environment(project=self.proj2)\n\n        self.key1 = 'key1'\n        self.value1 = 'value1'\n\n    def test_create_tag_key(self):\n        with pytest.raises(TagKeyNotFound):\n            self.ts.get_tag_key(\n                project_id=self.proj1.id,\n                environment_id=self.proj1env1.id,\n                key=self.key1,\n            )\n\n        assert self.ts.get_tag_keys(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n        ) == []\n\n        tk = self.ts.create_tag_key(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        assert self.ts.get_tag_key(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        ).id == tk.id\n\n        assert self.ts.get_tag_keys(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n        ) == [tk]\n\n        assert TagKey.objects.all().count() == 1\n\n    def test_get_or_create_tag_key(self):\n        tk1, _ = self.ts.get_or_create_tag_key(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        tk2, _ = self.ts.get_or_create_tag_key(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        assert tk1.id == tk2.id\n        assert TagKey.objects.filter(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        ).count() == 1\n        assert TagKey.objects.all().count() == 1\n\n    def test_create_tag_value(self):\n        with pytest.raises(TagValueNotFound):\n            self.ts.get_tag_value(\n                project_id=self.proj1.id,\n                environment_id=self.proj1env1.id,\n                key=self.key1,\n                value=self.value1,\n            )\n\n        assert self.ts.get_tag_values(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        ) == []\n\n        tv = self.ts.create_tag_value(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        )\n\n        assert self.ts.get_tag_values(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        ) == [tv]\n\n        assert self.ts.get_tag_value(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        ).id == tv.id\n        assert TagKey.objects.all().count() == 1\n        assert TagValue.objects.all().count() == 1\n\n    def test_get_or_create_tag_value(self):\n        tv1, _ = self.ts.get_or_create_tag_value(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        )\n\n        tv2, _ = self.ts.get_or_create_tag_value(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        )\n\n        assert tv1.id == tv2.id\n\n        tk = TagKey.objects.get(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        assert TagKey.objects.all().count() == 1\n\n        assert TagValue.objects.filter(\n            project_id=self.proj1.id,\n            _key__environment_id=self.proj1env1.id,\n            _key_id=tk.id,\n            value=self.value1,\n        ).count() == 1\n        assert TagValue.objects.all().count() == 1\n\n    def test_create_group_tag_key(self):\n        with pytest.raises(GroupTagKeyNotFound):\n            self.ts.get_group_tag_key(\n                project_id=self.proj1.id,\n                group_id=self.proj1group1.id,\n                environment_id=self.proj1env1.id,\n                key=self.key1,\n            )\n\n        assert self.ts.get_group_tag_keys(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n        ) == []\n\n        gtk = self.ts.create_group_tag_key(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        self.ts.get_group_tag_keys(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n        ) == [gtk]\n\n        TagKey.objects.get(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n        assert TagKey.objects.all().count() == 1\n\n        assert self.ts.get_group_tag_key(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        ).id == gtk.id\n        assert GroupTagKey.objects.all().count() == 1\n\n    def test_get_or_create_group_tag_key(self):\n        gtk1, _ = self.ts.get_or_create_group_tag_key(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        gtk2, _ = self.ts.get_or_create_group_tag_key(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        assert gtk1.id == gtk2.id\n\n        tk = TagKey.objects.get(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n        assert TagKey.objects.all().count() == 1\n\n        assert GroupTagKey.objects.filter(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            _key__environment_id=self.proj1env1.id,\n            _key_id=tk.id,\n        ).count() == 1\n        assert GroupTagKey.objects.all().count() == 1\n\n    def test_create_group_tag_value(self):\n        with pytest.raises(GroupTagValueNotFound):\n            self.ts.get_group_tag_value(\n                project_id=self.proj1.id,\n                group_id=self.proj1group1.id,\n                environment_id=self.proj1env1.id,\n                key=self.key1,\n                value=self.value1,\n            )\n\n        assert self.ts.get_group_tag_values(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        ) == []\n\n        gtv = self.ts.create_group_tag_value(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        )\n\n        assert self.ts.get_group_tag_values(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        ) == [gtv]\n\n        assert TagKey.objects.all().count() == 1\n        assert TagValue.objects.all().count() == 1\n\n        assert self.ts.get_group_tag_value(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        ).id == gtv.id\n        assert GroupTagValue.objects.all().count() == 1\n\n    def test_get_or_create_group_tag_value(self):\n        gtv1, _ = self.ts.get_or_create_group_tag_value(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        )\n\n        gtv2, _ = self.ts.get_or_create_group_tag_value(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        )\n\n        assert gtv1.id == gtv2.id\n\n        tk = TagKey.objects.get(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n        assert TagKey.objects.all().count() == 1\n\n        tv = TagValue.objects.get(\n            project_id=self.proj1.id,\n            _key__environment_id=self.proj1env1.id,\n            _key_id=tk.id,\n            value=self.value1,\n        )\n        assert TagValue.objects.all().count() == 1\n\n        assert GroupTagValue.objects.filter(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            _key__environment_id=self.proj1env1.id,\n            _key_id=tk.id,\n            _value_id=tv.id,\n        ).count() == 1\n        assert GroupTagValue.objects.all().count() == 1\n\n    def test_create_event_tags(self):\n        v1, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k1', 'v1')\n        v2, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k2', 'v2')\n        v3, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k3', 'v3')\n\n        tags = [(v1._key, v1), (v2._key, v2), (v3._key, v3)]\n        self.ts.create_event_tags(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            event_id=self.proj1group1event1.id,\n            tags=[(k.key, v.value) for k, v in tags]\n        )\n\n        assert EventTag.objects.count() == 3\n        for (k, v) in tags:\n            assert EventTag.objects.get(\n                project_id=self.proj1.id,\n                group_id=self.proj1group1.id,\n                key__environment_id=self.proj1env1.id,\n                event_id=self.proj1group1event1.id,\n                key_id=k.id,\n                value_id=v.id,\n            ) is not None\n\n    def test_delete_tag_key(self):\n        tk1 = self.ts.create_tag_key(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        tk2 = self.ts.create_tag_key(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env2.id,\n            key=self.key1,\n        )\n\n        assert TagKey.objects.filter(\n            project_id=self.proj1.id,\n            status=TagKeyStatus.VISIBLE,\n        ).count() == 2\n\n        deleted = self.ts.delete_tag_key(self.proj1.id, self.key1)\n        assert tk1 in deleted\n        assert tk2 in deleted\n\n        assert TagKey.objects.filter(\n            project_id=self.proj1.id,\n            status=TagKeyStatus.VISIBLE,\n        ).count() == 0\n\n    def test_delete_all_group_tag_keys(self):\n        assert GroupTagKey.objects.count() == 0\n\n        self.ts.create_group_tag_key(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        assert GroupTagKey.objects.count() == 1\n\n        self.ts.delete_all_group_tag_keys(self.proj1.id, self.proj1group1.id)\n\n        assert GroupTagKey.objects.count() == 0\n\n    def test_delete_all_group_tag_values(self):\n        assert GroupTagValue.objects.count() == 0\n\n        self.ts.create_group_tag_value(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        )\n\n        assert GroupTagValue.objects.count() == 1\n\n        self.ts.delete_all_group_tag_values(self.proj1.id, self.proj1group1.id)\n\n        assert GroupTagValue.objects.count() == 0\n\n    def test_get_group_event_ids(self):\n        tags = {\n            'abc': 'xyz',\n            'foo': 'bar',\n            'baz': 'quux',\n        }\n\n        \n        for event in (self.proj1group1event1, self.proj1group1event2):\n            self.ts.create_event_tags(\n                project_id=self.proj1.id,\n                group_id=self.proj1group1.id,\n                environment_id=self.proj1env1.id,\n                event_id=event.id,\n                tags=tags.items(),\n            )\n\n        different_tags = {\n            'abc': 'DIFFERENT',\n            'foo': 'bar',\n            'baz': 'quux',\n        }\n\n        \n        self.ts.create_event_tags(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            event_id=self.proj1group1event3.id,\n            tags=different_tags.items(),\n        )\n\n        assert len(\n            self.ts.get_group_event_ids(\n                self.proj1.id,\n                self.proj1group1.id,\n                self.proj1env1.id,\n                tags)) == 2\n\n    def test_get_groups_user_counts(self):\n        k1, _ = self.ts.get_or_create_group_tag_key(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            'sentry:user')\n        k1.values_seen = 7\n        k1.save()\n\n        k2, _ = self.ts.get_or_create_group_tag_key(\n            self.proj1.id,\n            self.proj1group2.id,\n            self.proj1env1.id,\n            'sentry:user')\n        k2.values_seen = 11\n        k2.save()\n\n        assert dict(\n            self.ts.get_groups_user_counts(\n                self.proj1.id,\n                [self.proj1group1.id, self.proj1group2.id],\n                self.proj1env1.id).items()) == {self.proj1group1.id: 7, self.proj1group2.id: 11}\n\n    def test_get_group_tag_value_count(self):\n        v1, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            self.key1,\n            'value1')\n        v1.times_seen = 7\n        v1.save()\n\n        v2, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            self.key1,\n            'value2')\n        v2.times_seen = 11\n        v2.save()\n\n        assert self.ts.get_group_tag_value_count(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            self.key1,\n        ) == 18\n\n    def test_get_top_group_tag_values(self):\n        v1, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            self.key1,\n            'value1')\n        v1.times_seen = 7\n        v1.save()\n\n        v2, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            self.key1,\n            'value2')\n        v2.times_seen = 11\n        v2.save()\n\n        resp = self.ts.get_top_group_tag_values(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            self.key1,\n        )\n\n        assert resp[0].times_seen == 11\n        assert resp[0].key == self.key1\n        assert resp[0].group_id == self.proj1group1.id\n\n        assert resp[1].times_seen == 7\n        assert resp[1].key == self.key1\n        assert resp[1].group_id == self.proj1group1.id\n\n    def test_get_first_release(self):\n        v1, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            'sentry:release',\n            '1.0')\n        v1.first_seen = datetime(2000, 1, 1)\n        v1.save()\n\n        v2, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            'sentry:release',\n            '2.0')\n        v2.first_seen = datetime(2000, 1, 2)\n        v2.save()\n\n        assert self.ts.get_first_release(\n            self.proj1.id,\n            self.proj1group1.id,\n        ) == '1.0'\n\n    def test_get_last_release(self):\n        v1, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            'sentry:release',\n            '1.0')\n        v1.last_seen = datetime(2000, 1, 1)\n        v1.save()\n\n        v2, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            'sentry:release',\n            '2.0')\n        v2.last_seen = datetime(2000, 1, 2)\n        v2.save()\n\n        assert self.ts.get_last_release(\n            self.proj1.id,\n            self.proj1group1.id,\n        ) == '2.0'\n\n    def test_get_release_tags(self):\n        tv, _ = self.ts.get_or_create_tag_value(\n            self.proj1.id,\n            self.proj1env1.id,\n            'sentry:release',\n            '1.0'\n        )\n\n        assert self.ts.get_release_tags([self.proj1.id], self.proj1env1.id, ['1.0']) == [tv]\n\n    def test_get_group_ids_for_users(self):\n        from sentry.models import EventUser\n\n        v1, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            0,\n            'sentry:user',\n            'email:user@sentry.io')\n\n        eu = EventUser(project_id=self.proj1.id, email='user@sentry.io')\n\n        assert self.ts.get_group_ids_for_users(\n            [self.proj1.id],\n            [eu]) == [self.proj1group1.id]\n\n    def test_get_group_tag_values_for_users(self):\n        from sentry.models import EventUser\n\n        v1, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            0,\n            'sentry:user',\n            'email:user@sentry.io')\n\n        eu = EventUser(project_id=self.proj1.id, email='user@sentry.io')\n\n        assert self.ts.get_group_tag_values_for_users([eu]) == [v1]\n\n    def test_get_group_ids_for_search_filter(self):\n        tags = {\n            'foo': 'bar',\n            'baz': 'quux',\n        }\n\n        for k, v in tags.items():\n            v1, _ = self.ts.get_or_create_group_tag_value(\n                self.proj1.id,\n                self.proj1group1.id,\n                self.proj1env1.id,\n                k,\n                v)\n\n        assert self.ts.get_group_ids_for_search_filter(\n            self.proj1.id, self.proj1env1.id, tags) == [self.proj1group1.id]\n\n    def test_get_group_ids_for_search_filter_predicate_order(self):\n        \n        for i in range(3):\n            self.ts.get_or_create_group_tag_value(\n                self.proj1.id, i, self.proj1env1.id,\n                'foo', 'bar'\n            )\n\n            self.ts.get_or_create_group_tag_value(\n                self.proj1.id, i, self.proj1env1.id,\n                'divides', 'even' if i % 2 == 0 else 'odd'\n            )\n\n        assert len(self.ts.get_group_ids_for_search_filter(\n            self.proj1.id,\n            self.proj1env1.id,\n            OrderedDict([('foo', ANY), ('divides', 'even')]),\n            limit=2\n        )) == 2\n\n    def test_update_group_for_events(self):\n        v1, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k1', 'v1')\n        v2, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k2', 'v2')\n        v3, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k3', 'v3')\n\n        tags = [(v1.key, v1.value), (v2.key, v2.value), (v3.key, v3.value)]\n        self.ts.create_event_tags(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            event_id=self.proj1group1event1.id,\n            tags=tags\n        )\n\n        assert EventTag.objects.filter(group_id=self.proj1group2.id).count() == 0\n\n        self.ts.update_group_for_events(\n            self.proj1.id, [\n                self.proj1group1event1.id], self.proj1group2.id)\n\n        assert EventTag.objects.filter(group_id=self.proj1group2.id).count() == 3\n", "comments": "                since tag matching filter returns limited results              filter returns subset previous filter matches              attempt match selective predicates first               this tests filter selective  divides    even              predicate filtering any predicate therefore return             matching groups instead partial set would returned             filtered limited using any predicate first                 2 events tags    1 event different tags ", "content": "from __future__ import absolute_import\n\nimport pytest\n\nfrom collections import OrderedDict\nfrom datetime import datetime\n\nfrom sentry.search.base import ANY\nfrom sentry.testutils import TestCase\nfrom sentry.tagstore import TagKeyStatus\nfrom sentry.tagstore.v2.backend import V2TagStorage\nfrom sentry.tagstore.v2.models import TagKey, TagValue, GroupTagKey, GroupTagValue, EventTag\nfrom sentry.tagstore.exceptions import TagKeyNotFound, TagValueNotFound, GroupTagKeyNotFound, GroupTagValueNotFound\n\n\nclass TagStorage(TestCase):\n    def setUp(self):\n        self.ts = V2TagStorage()\n\n        self.proj1 = self.create_project()\n        self.proj1group1 = self.create_group(self.proj1)\n        self.proj1group2 = self.create_group(self.proj1)\n        self.proj1env1 = self.create_environment(project=self.proj1)\n        self.proj1env2 = self.create_environment(project=self.proj1)\n        self.proj1group1event1 = self.create_event(project=self.proj1, group=self.proj1group1)\n        self.proj1group1event2 = self.create_event(project=self.proj1, group=self.proj1group1)\n        self.proj1group1event3 = self.create_event(project=self.proj1, group=self.proj1group1)\n\n        self.proj2 = self.create_project()\n        self.proj2group1 = self.create_group(self.proj2)\n        self.proj2env1 = self.create_environment(project=self.proj2)\n\n        self.key1 = 'key1'\n        self.value1 = 'value1'\n\n    def test_create_tag_key(self):\n        with pytest.raises(TagKeyNotFound):\n            self.ts.get_tag_key(\n                project_id=self.proj1.id,\n                environment_id=self.proj1env1.id,\n                key=self.key1,\n            )\n\n        assert self.ts.get_tag_keys(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n        ) == []\n\n        tk = self.ts.create_tag_key(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        assert self.ts.get_tag_key(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        ).id == tk.id\n\n        assert self.ts.get_tag_keys(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n        ) == [tk]\n\n        assert TagKey.objects.all().count() == 1\n\n    def test_get_or_create_tag_key(self):\n        tk1, _ = self.ts.get_or_create_tag_key(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        tk2, _ = self.ts.get_or_create_tag_key(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        assert tk1.id == tk2.id\n        assert TagKey.objects.filter(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        ).count() == 1\n        assert TagKey.objects.all().count() == 1\n\n    def test_create_tag_value(self):\n        with pytest.raises(TagValueNotFound):\n            self.ts.get_tag_value(\n                project_id=self.proj1.id,\n                environment_id=self.proj1env1.id,\n                key=self.key1,\n                value=self.value1,\n            )\n\n        assert self.ts.get_tag_values(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        ) == []\n\n        tv = self.ts.create_tag_value(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        )\n\n        assert self.ts.get_tag_values(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        ) == [tv]\n\n        assert self.ts.get_tag_value(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        ).id == tv.id\n        assert TagKey.objects.all().count() == 1\n        assert TagValue.objects.all().count() == 1\n\n    def test_get_or_create_tag_value(self):\n        tv1, _ = self.ts.get_or_create_tag_value(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        )\n\n        tv2, _ = self.ts.get_or_create_tag_value(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        )\n\n        assert tv1.id == tv2.id\n\n        tk = TagKey.objects.get(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        assert TagKey.objects.all().count() == 1\n\n        assert TagValue.objects.filter(\n            project_id=self.proj1.id,\n            _key__environment_id=self.proj1env1.id,\n            _key_id=tk.id,\n            value=self.value1,\n        ).count() == 1\n        assert TagValue.objects.all().count() == 1\n\n    def test_create_group_tag_key(self):\n        with pytest.raises(GroupTagKeyNotFound):\n            self.ts.get_group_tag_key(\n                project_id=self.proj1.id,\n                group_id=self.proj1group1.id,\n                environment_id=self.proj1env1.id,\n                key=self.key1,\n            )\n\n        assert self.ts.get_group_tag_keys(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n        ) == []\n\n        gtk = self.ts.create_group_tag_key(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        self.ts.get_group_tag_keys(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n        ) == [gtk]\n\n        TagKey.objects.get(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n        assert TagKey.objects.all().count() == 1\n\n        assert self.ts.get_group_tag_key(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        ).id == gtk.id\n        assert GroupTagKey.objects.all().count() == 1\n\n    def test_get_or_create_group_tag_key(self):\n        gtk1, _ = self.ts.get_or_create_group_tag_key(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        gtk2, _ = self.ts.get_or_create_group_tag_key(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        assert gtk1.id == gtk2.id\n\n        tk = TagKey.objects.get(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n        assert TagKey.objects.all().count() == 1\n\n        assert GroupTagKey.objects.filter(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            _key__environment_id=self.proj1env1.id,\n            _key_id=tk.id,\n        ).count() == 1\n        assert GroupTagKey.objects.all().count() == 1\n\n    def test_create_group_tag_value(self):\n        with pytest.raises(GroupTagValueNotFound):\n            self.ts.get_group_tag_value(\n                project_id=self.proj1.id,\n                group_id=self.proj1group1.id,\n                environment_id=self.proj1env1.id,\n                key=self.key1,\n                value=self.value1,\n            )\n\n        assert self.ts.get_group_tag_values(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        ) == []\n\n        gtv = self.ts.create_group_tag_value(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        )\n\n        assert self.ts.get_group_tag_values(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        ) == [gtv]\n\n        assert TagKey.objects.all().count() == 1\n        assert TagValue.objects.all().count() == 1\n\n        assert self.ts.get_group_tag_value(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        ).id == gtv.id\n        assert GroupTagValue.objects.all().count() == 1\n\n    def test_get_or_create_group_tag_value(self):\n        gtv1, _ = self.ts.get_or_create_group_tag_value(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        )\n\n        gtv2, _ = self.ts.get_or_create_group_tag_value(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        )\n\n        assert gtv1.id == gtv2.id\n\n        tk = TagKey.objects.get(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n        assert TagKey.objects.all().count() == 1\n\n        tv = TagValue.objects.get(\n            project_id=self.proj1.id,\n            _key__environment_id=self.proj1env1.id,\n            _key_id=tk.id,\n            value=self.value1,\n        )\n        assert TagValue.objects.all().count() == 1\n\n        assert GroupTagValue.objects.filter(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            _key__environment_id=self.proj1env1.id,\n            _key_id=tk.id,\n            _value_id=tv.id,\n        ).count() == 1\n        assert GroupTagValue.objects.all().count() == 1\n\n    def test_create_event_tags(self):\n        v1, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k1', 'v1')\n        v2, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k2', 'v2')\n        v3, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k3', 'v3')\n\n        tags = [(v1._key, v1), (v2._key, v2), (v3._key, v3)]\n        self.ts.create_event_tags(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            event_id=self.proj1group1event1.id,\n            tags=[(k.key, v.value) for k, v in tags]\n        )\n\n        assert EventTag.objects.count() == 3\n        for (k, v) in tags:\n            assert EventTag.objects.get(\n                project_id=self.proj1.id,\n                group_id=self.proj1group1.id,\n                key__environment_id=self.proj1env1.id,\n                event_id=self.proj1group1event1.id,\n                key_id=k.id,\n                value_id=v.id,\n            ) is not None\n\n    def test_delete_tag_key(self):\n        tk1 = self.ts.create_tag_key(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        tk2 = self.ts.create_tag_key(\n            project_id=self.proj1.id,\n            environment_id=self.proj1env2.id,\n            key=self.key1,\n        )\n\n        assert TagKey.objects.filter(\n            project_id=self.proj1.id,\n            status=TagKeyStatus.VISIBLE,\n        ).count() == 2\n\n        deleted = self.ts.delete_tag_key(self.proj1.id, self.key1)\n        assert tk1 in deleted\n        assert tk2 in deleted\n\n        assert TagKey.objects.filter(\n            project_id=self.proj1.id,\n            status=TagKeyStatus.VISIBLE,\n        ).count() == 0\n\n    def test_delete_all_group_tag_keys(self):\n        assert GroupTagKey.objects.count() == 0\n\n        self.ts.create_group_tag_key(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n        )\n\n        assert GroupTagKey.objects.count() == 1\n\n        self.ts.delete_all_group_tag_keys(self.proj1.id, self.proj1group1.id)\n\n        assert GroupTagKey.objects.count() == 0\n\n    def test_delete_all_group_tag_values(self):\n        assert GroupTagValue.objects.count() == 0\n\n        self.ts.create_group_tag_value(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            key=self.key1,\n            value=self.value1,\n        )\n\n        assert GroupTagValue.objects.count() == 1\n\n        self.ts.delete_all_group_tag_values(self.proj1.id, self.proj1group1.id)\n\n        assert GroupTagValue.objects.count() == 0\n\n    def test_get_group_event_ids(self):\n        tags = {\n            'abc': 'xyz',\n            'foo': 'bar',\n            'baz': 'quux',\n        }\n\n        # 2 events with the same tags\n        for event in (self.proj1group1event1, self.proj1group1event2):\n            self.ts.create_event_tags(\n                project_id=self.proj1.id,\n                group_id=self.proj1group1.id,\n                environment_id=self.proj1env1.id,\n                event_id=event.id,\n                tags=tags.items(),\n            )\n\n        different_tags = {\n            'abc': 'DIFFERENT',\n            'foo': 'bar',\n            'baz': 'quux',\n        }\n\n        # 1 event with different tags\n        self.ts.create_event_tags(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            event_id=self.proj1group1event3.id,\n            tags=different_tags.items(),\n        )\n\n        assert len(\n            self.ts.get_group_event_ids(\n                self.proj1.id,\n                self.proj1group1.id,\n                self.proj1env1.id,\n                tags)) == 2\n\n    def test_get_groups_user_counts(self):\n        k1, _ = self.ts.get_or_create_group_tag_key(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            'sentry:user')\n        k1.values_seen = 7\n        k1.save()\n\n        k2, _ = self.ts.get_or_create_group_tag_key(\n            self.proj1.id,\n            self.proj1group2.id,\n            self.proj1env1.id,\n            'sentry:user')\n        k2.values_seen = 11\n        k2.save()\n\n        assert dict(\n            self.ts.get_groups_user_counts(\n                self.proj1.id,\n                [self.proj1group1.id, self.proj1group2.id],\n                self.proj1env1.id).items()) == {self.proj1group1.id: 7, self.proj1group2.id: 11}\n\n    def test_get_group_tag_value_count(self):\n        v1, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            self.key1,\n            'value1')\n        v1.times_seen = 7\n        v1.save()\n\n        v2, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            self.key1,\n            'value2')\n        v2.times_seen = 11\n        v2.save()\n\n        assert self.ts.get_group_tag_value_count(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            self.key1,\n        ) == 18\n\n    def test_get_top_group_tag_values(self):\n        v1, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            self.key1,\n            'value1')\n        v1.times_seen = 7\n        v1.save()\n\n        v2, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            self.key1,\n            'value2')\n        v2.times_seen = 11\n        v2.save()\n\n        resp = self.ts.get_top_group_tag_values(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            self.key1,\n        )\n\n        assert resp[0].times_seen == 11\n        assert resp[0].key == self.key1\n        assert resp[0].group_id == self.proj1group1.id\n\n        assert resp[1].times_seen == 7\n        assert resp[1].key == self.key1\n        assert resp[1].group_id == self.proj1group1.id\n\n    def test_get_first_release(self):\n        v1, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            'sentry:release',\n            '1.0')\n        v1.first_seen = datetime(2000, 1, 1)\n        v1.save()\n\n        v2, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            'sentry:release',\n            '2.0')\n        v2.first_seen = datetime(2000, 1, 2)\n        v2.save()\n\n        assert self.ts.get_first_release(\n            self.proj1.id,\n            self.proj1group1.id,\n        ) == '1.0'\n\n    def test_get_last_release(self):\n        v1, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            'sentry:release',\n            '1.0')\n        v1.last_seen = datetime(2000, 1, 1)\n        v1.save()\n\n        v2, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            self.proj1env1.id,\n            'sentry:release',\n            '2.0')\n        v2.last_seen = datetime(2000, 1, 2)\n        v2.save()\n\n        assert self.ts.get_last_release(\n            self.proj1.id,\n            self.proj1group1.id,\n        ) == '2.0'\n\n    def test_get_release_tags(self):\n        tv, _ = self.ts.get_or_create_tag_value(\n            self.proj1.id,\n            self.proj1env1.id,\n            'sentry:release',\n            '1.0'\n        )\n\n        assert self.ts.get_release_tags([self.proj1.id], self.proj1env1.id, ['1.0']) == [tv]\n\n    def test_get_group_ids_for_users(self):\n        from sentry.models import EventUser\n\n        v1, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            0,\n            'sentry:user',\n            'email:user@sentry.io')\n\n        eu = EventUser(project_id=self.proj1.id, email='user@sentry.io')\n\n        assert self.ts.get_group_ids_for_users(\n            [self.proj1.id],\n            [eu]) == [self.proj1group1.id]\n\n    def test_get_group_tag_values_for_users(self):\n        from sentry.models import EventUser\n\n        v1, _ = self.ts.get_or_create_group_tag_value(\n            self.proj1.id,\n            self.proj1group1.id,\n            0,\n            'sentry:user',\n            'email:user@sentry.io')\n\n        eu = EventUser(project_id=self.proj1.id, email='user@sentry.io')\n\n        assert self.ts.get_group_tag_values_for_users([eu]) == [v1]\n\n    def test_get_group_ids_for_search_filter(self):\n        tags = {\n            'foo': 'bar',\n            'baz': 'quux',\n        }\n\n        for k, v in tags.items():\n            v1, _ = self.ts.get_or_create_group_tag_value(\n                self.proj1.id,\n                self.proj1group1.id,\n                self.proj1env1.id,\n                k,\n                v)\n\n        assert self.ts.get_group_ids_for_search_filter(\n            self.proj1.id, self.proj1env1.id, tags) == [self.proj1group1.id]\n\n    def test_get_group_ids_for_search_filter_predicate_order(self):\n        \"\"\"\n            Since each tag-matching filter returns limited results, and each\n            filter returns a subset of the previous filter's matches, we\n            attempt to match more selective predicates first.\n\n            This tests that we filter by a more selective \"divides == even\"\n            predicate before filtering by an ANY predicate and therefore return\n            all matching groups instead of the partial set that would be returned\n            if we had filtered and limited using the ANY predicate first.\n        \"\"\"\n        for i in range(3):\n            self.ts.get_or_create_group_tag_value(\n                self.proj1.id, i, self.proj1env1.id,\n                'foo', 'bar'\n            )\n\n            self.ts.get_or_create_group_tag_value(\n                self.proj1.id, i, self.proj1env1.id,\n                'divides', 'even' if i % 2 == 0 else 'odd'\n            )\n\n        assert len(self.ts.get_group_ids_for_search_filter(\n            self.proj1.id,\n            self.proj1env1.id,\n            OrderedDict([('foo', ANY), ('divides', 'even')]),\n            limit=2\n        )) == 2\n\n    def test_update_group_for_events(self):\n        v1, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k1', 'v1')\n        v2, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k2', 'v2')\n        v3, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k3', 'v3')\n\n        tags = [(v1.key, v1.value), (v2.key, v2.value), (v3.key, v3.value)]\n        self.ts.create_event_tags(\n            project_id=self.proj1.id,\n            group_id=self.proj1group1.id,\n            environment_id=self.proj1env1.id,\n            event_id=self.proj1group1event1.id,\n            tags=tags\n        )\n\n        assert EventTag.objects.filter(group_id=self.proj1group2.id).count() == 0\n\n        self.ts.update_group_for_events(\n            self.proj1.id, [\n                self.proj1group1event1.id], self.proj1group2.id)\n\n        assert EventTag.objects.filter(group_id=self.proj1group2.id).count() == 3\n", "description": "Sentry is a cross-platform crash reporting and aggregation platform.", "file_name": "test_backend.py", "id": "733afeaa8b4f535dcb5f313bcc3193ac", "language": "Python", "project_name": "sentry", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/getsentry-sentry/getsentry-sentry-6a9c7e2/tests/sentry/tagstore/v2/test_backend.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:23:24Z", "url": "https://github.com/getsentry/sentry", "wiki": false}