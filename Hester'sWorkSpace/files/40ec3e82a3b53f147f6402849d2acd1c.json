{"author": "odoo", "code": "# -*- coding: utf-8 -*-\nimport contextlib\nimport logging\nimport json\nimport uuid\n\nimport werkzeug.urls\nimport requests\n\nfrom odoo import api, fields, models, exceptions\nfrom odoo.tools import pycompat\n\n_logger = logging.getLogger(__name__)\n\nDEFAULT_ENDPOINT = 'https://iap.odoo.com'\n\n\n\n\n\ndef get_endpoint(env):\n    url = env['ir.config_parameter'].sudo().get_param('iap.endpoint', DEFAULT_ENDPOINT)\n    return url\n\n\n\n\n\nclass InsufficientCreditError(Exception):\n    pass\n\n\nclass AuthenticationError(Exception):\n    pass\n\n\ndef jsonrpc(url, method='call', params=None):\n    \"\"\"\n    Calls the provided JSON-RPC endpoint, unwraps the result and\n    returns JSON-RPC errors as exceptions.\n    \"\"\"\n    payload = {\n        'jsonrpc': '2.0',\n        'method': method,\n        'params': params,\n        'id': uuid.uuid4().hex,\n    }\n\n\n    _logger.info('iap jsonrpc %s', url)\n    try:\n        req = requests.post(url, json=payload)\n        response = req.json()\n        if 'error' in response:\n            name = response['error']['data'].get('name').rpartition('.')[-1]\n            message = response['error']['data'].get('message')\n            if name == 'InsufficientCreditError':\n                e_class = InsufficientCreditError\n            elif name == 'AccessError':\n                e_class = exceptions.AccessError\n            elif name == 'UserError':\n                e_class = exceptions.UserError\n            else:\n                raise requests.exceptions.ConnectionError()\n            e = e_class(message)\n            e.data = response['error']['data']\n            raise e\n        return response.get('result')\n    except (ValueError, requests.exceptions.ConnectionError, requests.exceptions.MissingSchema) as e:\n        raise exceptions.AccessError('The url that this service requested returned an error. Please contact the author the app. The url it tried to contact was ' + url)\n\n\n\n\nclass IapTransaction(object):\n\n    def __init__(self):\n        self.credit = None\n\n@contextlib.contextmanager\ndef charge(env, key, account_token, credit, description=None, credit_template=None):\n    \"\"\"\n    Account charge context manager: takes a hold for ``credit``\n    amount before executing the body, then captures it if there\n    is no error, or cancels it if the body generates an exception.\n\n    :param str key: service identifier\n    :param str account_token: user identifier\n    :param int credit: cost of the body's operation\n    :param description: a description of the purpose of the charge,\n                        the user will be able to see it in their\n                        dashboard\n    :type description: str\n    :param credit_template: a QWeb template to render and show to the\n                            user if their account does not have enough\n                            credits for the requested operation\n    :type credit_template: str\n    \"\"\"\n    endpoint = get_endpoint(env)\n    params = {\n        'account_token': account_token,\n        'credit': credit,\n        'key': key,\n        'description': description,\n    }\n    try:\n        transaction_token = jsonrpc(endpoint + '/iap/1/authorize', params=params)\n    except InsufficientCreditError as e:\n        if credit_template:\n            arguments = json.loads(e.args[0])\n            arguments['body'] = pycompat.to_text(env['ir.qweb'].render(credit_template))\n            e.args = (json.dumps(arguments),)\n        raise e\n    try:\n        transaction = IapTransaction()\n        transaction.credit = credit\n        yield transaction\n    except Exception as e:\n        params = {\n            'token': transaction_token,\n            'key': key,\n        }\n        r = jsonrpc(endpoint + '/iap/1/cancel', params=params)\n        raise e\n    else:\n        params = {\n            'token': transaction_token,\n            'key': key,\n            'credit_to_capture': transaction.credit,\n        }\n        r = jsonrpc(endpoint + '/iap/1/capture', params=params) \n\n\n\n\n\nclass IapAccount(models.Model):\n    _name = 'iap.account'\n    _rec_name = 'service_name'\n\n    service_name = fields.Char()\n    account_token = fields.Char(default=lambda s: uuid.uuid4().hex)\n    company_id = fields.Many2one('res.company', default=lambda self: self.env.user.company_id)\n\n    @api.model\n    def get(self, service_name):\n        account = self.search([('service_name', '=', service_name), ('company_id', 'in', [self.env.user.company_id.id, False])])\n        if not account:\n            account = self.create({'service_name': service_name})\n            \n            \n            \n            self.env.cr.commit()\n        return account\n\n    @api.model\n    def get_credits_url(self, base_url, service_name, credit):\n        dbuuid = self.env['ir.config_parameter'].sudo().get_param('database.uuid')\n        account_token = self.get(service_name).account_token\n        d = {\n            'dbuuid': dbuuid,\n            'service_name': service_name,\n            'account_token': account_token,\n            'credit': credit,\n        }\n        return '%s?%s' % (base_url, werkzeug.urls.url_encode(d))\n\n    @api.model\n    def get_account_url(self):\n        route = '/iap/services'\n        endpoint = get_endpoint(self.env)\n        d = {'dbuuid': self.env['ir.config_parameter'].sudo().get_param('database.uuid')}\n\n        return '%s?%s' % (endpoint + route, werkzeug.urls.url_encode(d))\n", "comments": "        calls provided json rpc endpoint  unwraps result     returns json rpc errors exceptions              payload              jsonrpc    2 0            method   method           params   params           id   uuid uuid4() hex               logger info( iap jsonrpc    url)     try          req   requests post(url  json payload)         response   req json()          error  response              name   response  error    data   get( name ) rpartition(   )  1              message   response  error    data   get( message )             name     insufficientcrediterror                   e class   insufficientcrediterror             elif name     accesserror                   e class   exceptions accesserror             elif name     usererror                   e class   exceptions usererror             else                  raise requests exceptions connectionerror()             e   e class(message)             e data   response  error    data               raise e         return response get( result )     except (valueerror  requests exceptions connectionerror  requests exceptions missingschema) e          raise exceptions accesserror( the url service requested returned error  please contact author app  the url tried contact     url)                                                                helpers proxy                                                             class iaptransaction(object)       def   init  (self)          self credit   none   contextlib contextmanager def charge(env  key  account token  credit  description none  credit template none)              account charge context manager  takes hold   credit       amount executing body  captures     error  cancels body generates exception        param str key  service identifier      param str account token  user identifier      param int credit  cost body operation      param description  description purpose charge                          user able see                         dashboard      type description  str      param credit template  qweb template render show                             user account enough                             credits requested operation      type credit template  str                coding  utf 8                                                                     helpers clients proxy                                                                                                                              helpers clients                                                                                                                              helpers proxy                                                                 noqa                                                                 models client                                                                 since account exist yet  encounter nocrediterror     going rollback database undo account creation     preventing process continue  ", "content": "# -*- coding: utf-8 -*-\nimport contextlib\nimport logging\nimport json\nimport uuid\n\nimport werkzeug.urls\nimport requests\n\nfrom odoo import api, fields, models, exceptions\nfrom odoo.tools import pycompat\n\n_logger = logging.getLogger(__name__)\n\nDEFAULT_ENDPOINT = 'https://iap.odoo.com'\n\n\n#----------------------------------------------------------\n# Helpers for both clients and proxy\n#----------------------------------------------------------\ndef get_endpoint(env):\n    url = env['ir.config_parameter'].sudo().get_param('iap.endpoint', DEFAULT_ENDPOINT)\n    return url\n\n\n#----------------------------------------------------------\n# Helpers for clients\n#----------------------------------------------------------\nclass InsufficientCreditError(Exception):\n    pass\n\n\nclass AuthenticationError(Exception):\n    pass\n\n\ndef jsonrpc(url, method='call', params=None):\n    \"\"\"\n    Calls the provided JSON-RPC endpoint, unwraps the result and\n    returns JSON-RPC errors as exceptions.\n    \"\"\"\n    payload = {\n        'jsonrpc': '2.0',\n        'method': method,\n        'params': params,\n        'id': uuid.uuid4().hex,\n    }\n\n\n    _logger.info('iap jsonrpc %s', url)\n    try:\n        req = requests.post(url, json=payload)\n        response = req.json()\n        if 'error' in response:\n            name = response['error']['data'].get('name').rpartition('.')[-1]\n            message = response['error']['data'].get('message')\n            if name == 'InsufficientCreditError':\n                e_class = InsufficientCreditError\n            elif name == 'AccessError':\n                e_class = exceptions.AccessError\n            elif name == 'UserError':\n                e_class = exceptions.UserError\n            else:\n                raise requests.exceptions.ConnectionError()\n            e = e_class(message)\n            e.data = response['error']['data']\n            raise e\n        return response.get('result')\n    except (ValueError, requests.exceptions.ConnectionError, requests.exceptions.MissingSchema) as e:\n        raise exceptions.AccessError('The url that this service requested returned an error. Please contact the author the app. The url it tried to contact was ' + url)\n\n#----------------------------------------------------------\n# Helpers for proxy\n#----------------------------------------------------------\nclass IapTransaction(object):\n\n    def __init__(self):\n        self.credit = None\n\n@contextlib.contextmanager\ndef charge(env, key, account_token, credit, description=None, credit_template=None):\n    \"\"\"\n    Account charge context manager: takes a hold for ``credit``\n    amount before executing the body, then captures it if there\n    is no error, or cancels it if the body generates an exception.\n\n    :param str key: service identifier\n    :param str account_token: user identifier\n    :param int credit: cost of the body's operation\n    :param description: a description of the purpose of the charge,\n                        the user will be able to see it in their\n                        dashboard\n    :type description: str\n    :param credit_template: a QWeb template to render and show to the\n                            user if their account does not have enough\n                            credits for the requested operation\n    :type credit_template: str\n    \"\"\"\n    endpoint = get_endpoint(env)\n    params = {\n        'account_token': account_token,\n        'credit': credit,\n        'key': key,\n        'description': description,\n    }\n    try:\n        transaction_token = jsonrpc(endpoint + '/iap/1/authorize', params=params)\n    except InsufficientCreditError as e:\n        if credit_template:\n            arguments = json.loads(e.args[0])\n            arguments['body'] = pycompat.to_text(env['ir.qweb'].render(credit_template))\n            e.args = (json.dumps(arguments),)\n        raise e\n    try:\n        transaction = IapTransaction()\n        transaction.credit = credit\n        yield transaction\n    except Exception as e:\n        params = {\n            'token': transaction_token,\n            'key': key,\n        }\n        r = jsonrpc(endpoint + '/iap/1/cancel', params=params)\n        raise e\n    else:\n        params = {\n            'token': transaction_token,\n            'key': key,\n            'credit_to_capture': transaction.credit,\n        }\n        r = jsonrpc(endpoint + '/iap/1/capture', params=params) # noqa\n\n\n#----------------------------------------------------------\n# Models for client\n#----------------------------------------------------------\nclass IapAccount(models.Model):\n    _name = 'iap.account'\n    _rec_name = 'service_name'\n\n    service_name = fields.Char()\n    account_token = fields.Char(default=lambda s: uuid.uuid4().hex)\n    company_id = fields.Many2one('res.company', default=lambda self: self.env.user.company_id)\n\n    @api.model\n    def get(self, service_name):\n        account = self.search([('service_name', '=', service_name), ('company_id', 'in', [self.env.user.company_id.id, False])])\n        if not account:\n            account = self.create({'service_name': service_name})\n            # Since the account did not exist yet, we will encounter a NoCreditError,\n            # which is going to rollback the database and undo the account creation,\n            # preventing the process to continue any further.\n            self.env.cr.commit()\n        return account\n\n    @api.model\n    def get_credits_url(self, base_url, service_name, credit):\n        dbuuid = self.env['ir.config_parameter'].sudo().get_param('database.uuid')\n        account_token = self.get(service_name).account_token\n        d = {\n            'dbuuid': dbuuid,\n            'service_name': service_name,\n            'account_token': account_token,\n            'credit': credit,\n        }\n        return '%s?%s' % (base_url, werkzeug.urls.url_encode(d))\n\n    @api.model\n    def get_account_url(self):\n        route = '/iap/services'\n        endpoint = get_endpoint(self.env)\n        d = {'dbuuid': self.env['ir.config_parameter'].sudo().get_param('database.uuid')}\n\n        return '%s?%s' % (endpoint + route, werkzeug.urls.url_encode(d))\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "iap.py", "id": "40ec3e82a3b53f147f6402849d2acd1c", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/iap/models/iap.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}