{"author": "nvbn", "code": "import atexit\nimport os\nimport pickle\nimport re\nimport shelve\nimport six\nfrom decorator import decorator\nfrom difflib import get_close_matches\nfrom functools import wraps\nfrom .logs import warn\nfrom .conf import settings\nfrom .system import Path\n\nDEVNULL = open(os.devnull, 'w')\n\nif six.PY2:\n    import anydbm\n    shelve_open_error = anydbm.error\nelse:\n    import dbm\n    shelve_open_error = dbm.error\n\n\ndef memoize(fn):\n    \n    if six.PY2:\n        script = ' '.join(arg.decode('utf-8') for arg in raw_script)\n    else:\n        script = ' '.join(raw_script)\n\n    return script.strip()\n", "comments": "Caches previous calls to the function.\"\"\"\n    memo = {}\n\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        if not memoize.disabled:\n            key = pickle.dumps((args, kwargs))\n            if key not in memo:\n                memo[key] = fn(*args, **kwargs)\n            value = memo[key]\n        else:\n            # Memoize is disabled, call the function\n            value = fn(*args, **kwargs)\n\n        return value\n\n    return wrapper\n\n\nmemoize.disabled = False\n\n\n@memoize\ndef which(program):\n    \"\"\"Returns `program` path or `None`.\"\"\"\n    try:\n        from shutil import which\n\n        return which(program)\n    except ImportError:\n        def is_exe(fpath):\n            return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n        fpath, fname = os.path.split(program)\n        if fpath:\n            if is_exe(program):\n                return program\n        else:\n            for path in os.environ[\"PATH\"].split(os.pathsep):\n                path = path.strip('\"')\n                exe_file = os.path.join(path, program)\n                if is_exe(exe_file):\n                    return exe_file\n\n        return None\n\n\ndef default_settings(params):\n    \"\"\"Adds default values to settings if it not presented.\n\n    Usage:\n\n        @default_settings({'apt': '/usr/bin/apt'})\n        def match(command):\n            print(settings.apt)\n\n    \"\"\"\n    def _default_settings(fn, command):\n        for k, w in params.items():\n            settings.setdefault(k, w)\n        return fn(command)\n    return decorator(_default_settings)\n\n\ndef get_closest(word, possibilities, n=3, cutoff=0.6, fallback_to_first=True):\n    \"\"\"Returns closest match or just first from possibilities.\"\"\"\n    possibilities = list(possibilities)\n    try:\n        return get_close_matches(word, possibilities, n, cutoff)[0]\n    except IndexError:\n        if fallback_to_first:\n            return possibilities[0]\n\n\n@memoize\ndef get_all_executables():\n    from thefuck.shells import shell\n\n    def _safe(fn, fallback):\n        try:\n            return fn()\n        except OSError:\n            return fallback\n\n    tf_alias = get_alias()\n    tf_entry_points = ['thefuck', 'fuck']\n\n    bins = [exe.name.decode('utf8') if six.PY2 else exe.name\n            for path in os.environ.get('PATH', '').split(':')\n            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)\n            and exe.name not in tf_entry_points]\n    aliases = [alias.decode('utf8') if six.PY2 else alias\n               for alias in shell.get_aliases() if alias != tf_alias]\n\n    return bins + aliases\n\n\ndef replace_argument(script, from_, to):\n    \"\"\"Replaces command line argument.\"\"\"\n    replaced_in_the_end = re.sub(u' {}$'.format(re.escape(from_)), u' {}'.format(to),\n                                 script, count=1)\n    if replaced_in_the_end != script:\n        return replaced_in_the_end\n    else:\n        return script.replace(\n            u' {} '.format(from_), u' {} '.format(to), 1)\n\n\n@decorator\ndef eager(fn, *args, **kwargs):\n    return list(fn(*args, **kwargs))\n\n\n@eager\ndef get_all_matched_commands(stderr, separator='Did you mean'):\n    if not isinstance(separator, list):\n        separator = [separator]\n    should_yield = False\n    for line in stderr.split('\\n'):\n        for sep in separator:\n            if sep in line:\n                should_yield = True\n                break\n        else:\n            if should_yield and line:\n                yield line.strip()\n\n\ndef replace_command(command, broken, matched):\n    \"\"\"Helper for *_no_command rules.\"\"\"\n    new_cmds = get_close_matches(broken, matched, cutoff=0.1)\n    return [replace_argument(command.script, broken, new_cmd.strip())\n            for new_cmd in new_cmds]\n\n\n@memoize\ndef is_app(command, *app_names, **kwargs):\n    \"\"\"Returns `True` if command is call to one of passed app names.\"\"\"\n\n    at_least = kwargs.pop('at_least', 0)\n    if kwargs:\n        raise TypeError(\"got an unexpected keyword argument '{}'\".format(kwargs.keys()))\n\n    if len(command.script_parts) > at_least:\n        return command.script_parts[0] in app_names\n\n    return False\n\n\ndef for_app(*app_names, **kwargs):\n    \"\"\"Specifies that matching script is for on of app names.\"\"\"\n    def _for_app(fn, command):\n        if is_app(command, *app_names, **kwargs):\n            return fn(command)\n        else:\n            return False\n\n    return decorator(_for_app)\n\n\nclass Cache(object):\n    \"\"\"Lazy read cache and save changes at exit.\"\"\"\n\n    def __init__(self):\n        self._db = None\n\n    def _init_db(self):\n        cache_dir = self._get_cache_dir()\n        cache_path = Path(cache_dir).joinpath('thefuck').as_posix()\n\n        try:\n            self._db = shelve.open(cache_path)\n        except shelve_open_error + (ImportError,):\n            # Caused when switching between Python versions\n            warn(\"Removing possibly out-dated cache\")\n            os.remove(cache_path)\n            self._db = shelve.open(cache_path)\n\n        atexit.register(self._db.close)\n\n    def _get_cache_dir(self):\n        default_xdg_cache_dir = os.path.expanduser(\"~/.cache\")\n        cache_dir = os.getenv(\"XDG_CACHE_HOME\", default_xdg_cache_dir)\n\n        # Ensure the cache_path exists, Python 2 does not have the exist_ok\n        # parameter\n        try:\n            os.makedirs(cache_dir)\n        except OSError:\n            if not os.path.isdir(cache_dir):\n                raise\n\n        return cache_dir\n\n    def _get_mtime(self, path):\n        try:\n            return str(os.path.getmtime(path))\n        except OSError:\n            return '0'\n\n    def _get_key(self, fn, depends_on, args, kwargs):\n        parts = (fn.__module__, repr(fn).split('at')[0],\n                 depends_on, args, kwargs)\n        return str(pickle.dumps(parts))\n\n    def get_value(self, fn, depends_on, args, kwargs):\n        if self._db is None:\n            self._init_db()\n\n        depends_on = [Path(name).expanduser().absolute().as_posix()\n                      for name in depends_on]\n        key = self._get_key(fn, depends_on, args, kwargs)\n        etag = '.'.join(self._get_mtime(path) for path in depends_on)\n\n        if self._db.get(key, {}).get('etag') == etag:\n            return self._db[key]['value']\n        else:\n            value = fn(*args, **kwargs)\n            self._db[key] = {'etag': etag, 'value': value}\n            return value\n\n\n_cache = Cache()\n\n\ndef cache(*depends_on):\n    \"\"\"Caches function result in temporary file.\n\n    Cache will be expired when modification date of files from `depends_on`\n    will be changed.\n\n    Only functions should be wrapped in `cache`, not methods.\n\n    \"\"\"\n    def cache_decorator(fn):\n        @memoize\n        @wraps(fn)\n        def wrapper(*args, **kwargs):\n            if cache.disabled:\n                return fn(*args, **kwargs)\n            else:\n                return _cache.get_value(fn, depends_on, args, kwargs)\n\n        return wrapper\n\n    return cache_decorator\n\n\ncache.disabled = False\n\n\ndef get_installation_info():\n    import pkg_resources\n\n    return pkg_resources.require('thefuck')[0]\n\n\ndef get_alias():\n    return os.environ.get('TF_ALIAS', 'fuck')\n\n\n@memoize\ndef get_valid_history_without_current(command):\n    def _not_corrected(history, tf_alias):\n        \"\"\"Returns all lines from history except that comes before `fuck`.\"\"\"\n        previous = None\n        for line in history:\n            if previous is not None and line != tf_alias:\n                yield previous\n            previous = line\n        if history:\n            yield history[-1]\n\n    from thefuck.shells import shell\n    history = shell.get_history()\n    tf_alias = get_alias()\n    executables = set(get_all_executables())\\\n        .union(shell.get_builtin_commands())\n\n    return [line for line in _not_corrected(history, tf_alias)\n            if not line.startswith(tf_alias) and not line == command.script\n            and line.split(' ')[0] in executables]\n\n\ndef format_raw_script(raw_script):\n    \"\"\"Creates single script from a list of script parts.\n\n    :type raw_script: [basestring]\n    :rtype: basestring\n\n    \n \n", "content": "import atexit\nimport os\nimport pickle\nimport re\nimport shelve\nimport six\nfrom decorator import decorator\nfrom difflib import get_close_matches\nfrom functools import wraps\nfrom .logs import warn\nfrom .conf import settings\nfrom .system import Path\n\nDEVNULL = open(os.devnull, 'w')\n\nif six.PY2:\n    import anydbm\n    shelve_open_error = anydbm.error\nelse:\n    import dbm\n    shelve_open_error = dbm.error\n\n\ndef memoize(fn):\n    \"\"\"Caches previous calls to the function.\"\"\"\n    memo = {}\n\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        if not memoize.disabled:\n            key = pickle.dumps((args, kwargs))\n            if key not in memo:\n                memo[key] = fn(*args, **kwargs)\n            value = memo[key]\n        else:\n            # Memoize is disabled, call the function\n            value = fn(*args, **kwargs)\n\n        return value\n\n    return wrapper\n\n\nmemoize.disabled = False\n\n\n@memoize\ndef which(program):\n    \"\"\"Returns `program` path or `None`.\"\"\"\n    try:\n        from shutil import which\n\n        return which(program)\n    except ImportError:\n        def is_exe(fpath):\n            return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n        fpath, fname = os.path.split(program)\n        if fpath:\n            if is_exe(program):\n                return program\n        else:\n            for path in os.environ[\"PATH\"].split(os.pathsep):\n                path = path.strip('\"')\n                exe_file = os.path.join(path, program)\n                if is_exe(exe_file):\n                    return exe_file\n\n        return None\n\n\ndef default_settings(params):\n    \"\"\"Adds default values to settings if it not presented.\n\n    Usage:\n\n        @default_settings({'apt': '/usr/bin/apt'})\n        def match(command):\n            print(settings.apt)\n\n    \"\"\"\n    def _default_settings(fn, command):\n        for k, w in params.items():\n            settings.setdefault(k, w)\n        return fn(command)\n    return decorator(_default_settings)\n\n\ndef get_closest(word, possibilities, n=3, cutoff=0.6, fallback_to_first=True):\n    \"\"\"Returns closest match or just first from possibilities.\"\"\"\n    possibilities = list(possibilities)\n    try:\n        return get_close_matches(word, possibilities, n, cutoff)[0]\n    except IndexError:\n        if fallback_to_first:\n            return possibilities[0]\n\n\n@memoize\ndef get_all_executables():\n    from thefuck.shells import shell\n\n    def _safe(fn, fallback):\n        try:\n            return fn()\n        except OSError:\n            return fallback\n\n    tf_alias = get_alias()\n    tf_entry_points = ['thefuck', 'fuck']\n\n    bins = [exe.name.decode('utf8') if six.PY2 else exe.name\n            for path in os.environ.get('PATH', '').split(':')\n            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)\n            and exe.name not in tf_entry_points]\n    aliases = [alias.decode('utf8') if six.PY2 else alias\n               for alias in shell.get_aliases() if alias != tf_alias]\n\n    return bins + aliases\n\n\ndef replace_argument(script, from_, to):\n    \"\"\"Replaces command line argument.\"\"\"\n    replaced_in_the_end = re.sub(u' {}$'.format(re.escape(from_)), u' {}'.format(to),\n                                 script, count=1)\n    if replaced_in_the_end != script:\n        return replaced_in_the_end\n    else:\n        return script.replace(\n            u' {} '.format(from_), u' {} '.format(to), 1)\n\n\n@decorator\ndef eager(fn, *args, **kwargs):\n    return list(fn(*args, **kwargs))\n\n\n@eager\ndef get_all_matched_commands(stderr, separator='Did you mean'):\n    if not isinstance(separator, list):\n        separator = [separator]\n    should_yield = False\n    for line in stderr.split('\\n'):\n        for sep in separator:\n            if sep in line:\n                should_yield = True\n                break\n        else:\n            if should_yield and line:\n                yield line.strip()\n\n\ndef replace_command(command, broken, matched):\n    \"\"\"Helper for *_no_command rules.\"\"\"\n    new_cmds = get_close_matches(broken, matched, cutoff=0.1)\n    return [replace_argument(command.script, broken, new_cmd.strip())\n            for new_cmd in new_cmds]\n\n\n@memoize\ndef is_app(command, *app_names, **kwargs):\n    \"\"\"Returns `True` if command is call to one of passed app names.\"\"\"\n\n    at_least = kwargs.pop('at_least', 0)\n    if kwargs:\n        raise TypeError(\"got an unexpected keyword argument '{}'\".format(kwargs.keys()))\n\n    if len(command.script_parts) > at_least:\n        return command.script_parts[0] in app_names\n\n    return False\n\n\ndef for_app(*app_names, **kwargs):\n    \"\"\"Specifies that matching script is for on of app names.\"\"\"\n    def _for_app(fn, command):\n        if is_app(command, *app_names, **kwargs):\n            return fn(command)\n        else:\n            return False\n\n    return decorator(_for_app)\n\n\nclass Cache(object):\n    \"\"\"Lazy read cache and save changes at exit.\"\"\"\n\n    def __init__(self):\n        self._db = None\n\n    def _init_db(self):\n        cache_dir = self._get_cache_dir()\n        cache_path = Path(cache_dir).joinpath('thefuck').as_posix()\n\n        try:\n            self._db = shelve.open(cache_path)\n        except shelve_open_error + (ImportError,):\n            # Caused when switching between Python versions\n            warn(\"Removing possibly out-dated cache\")\n            os.remove(cache_path)\n            self._db = shelve.open(cache_path)\n\n        atexit.register(self._db.close)\n\n    def _get_cache_dir(self):\n        default_xdg_cache_dir = os.path.expanduser(\"~/.cache\")\n        cache_dir = os.getenv(\"XDG_CACHE_HOME\", default_xdg_cache_dir)\n\n        # Ensure the cache_path exists, Python 2 does not have the exist_ok\n        # parameter\n        try:\n            os.makedirs(cache_dir)\n        except OSError:\n            if not os.path.isdir(cache_dir):\n                raise\n\n        return cache_dir\n\n    def _get_mtime(self, path):\n        try:\n            return str(os.path.getmtime(path))\n        except OSError:\n            return '0'\n\n    def _get_key(self, fn, depends_on, args, kwargs):\n        parts = (fn.__module__, repr(fn).split('at')[0],\n                 depends_on, args, kwargs)\n        return str(pickle.dumps(parts))\n\n    def get_value(self, fn, depends_on, args, kwargs):\n        if self._db is None:\n            self._init_db()\n\n        depends_on = [Path(name).expanduser().absolute().as_posix()\n                      for name in depends_on]\n        key = self._get_key(fn, depends_on, args, kwargs)\n        etag = '.'.join(self._get_mtime(path) for path in depends_on)\n\n        if self._db.get(key, {}).get('etag') == etag:\n            return self._db[key]['value']\n        else:\n            value = fn(*args, **kwargs)\n            self._db[key] = {'etag': etag, 'value': value}\n            return value\n\n\n_cache = Cache()\n\n\ndef cache(*depends_on):\n    \"\"\"Caches function result in temporary file.\n\n    Cache will be expired when modification date of files from `depends_on`\n    will be changed.\n\n    Only functions should be wrapped in `cache`, not methods.\n\n    \"\"\"\n    def cache_decorator(fn):\n        @memoize\n        @wraps(fn)\n        def wrapper(*args, **kwargs):\n            if cache.disabled:\n                return fn(*args, **kwargs)\n            else:\n                return _cache.get_value(fn, depends_on, args, kwargs)\n\n        return wrapper\n\n    return cache_decorator\n\n\ncache.disabled = False\n\n\ndef get_installation_info():\n    import pkg_resources\n\n    return pkg_resources.require('thefuck')[0]\n\n\ndef get_alias():\n    return os.environ.get('TF_ALIAS', 'fuck')\n\n\n@memoize\ndef get_valid_history_without_current(command):\n    def _not_corrected(history, tf_alias):\n        \"\"\"Returns all lines from history except that comes before `fuck`.\"\"\"\n        previous = None\n        for line in history:\n            if previous is not None and line != tf_alias:\n                yield previous\n            previous = line\n        if history:\n            yield history[-1]\n\n    from thefuck.shells import shell\n    history = shell.get_history()\n    tf_alias = get_alias()\n    executables = set(get_all_executables())\\\n        .union(shell.get_builtin_commands())\n\n    return [line for line in _not_corrected(history, tf_alias)\n            if not line.startswith(tf_alias) and not line == command.script\n            and line.split(' ')[0] in executables]\n\n\ndef format_raw_script(raw_script):\n    \"\"\"Creates single script from a list of script parts.\n\n    :type raw_script: [basestring]\n    :rtype: basestring\n\n    \"\"\"\n    if six.PY2:\n        script = ' '.join(arg.decode('utf-8') for arg in raw_script)\n    else:\n        script = ' '.join(raw_script)\n\n    return script.strip()\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "utils.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/thefuck/utils.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}