{"author": "ansible", "code": "\n\n Copyright: Ansible Project\n GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = \"\"\"\n---\nmodule: onyx_facts\nversion_added: \"2.5\"\nauthor: \"Waleed Mousa (@waleedym), Samer Deeb (@samerd)\"\nshort_description: Collect facts from Mellanox ONYX network devices\ndescription:\n  - Collects a base set of device facts from a ONYX Mellanox network devices\n    This module prepends all of the base network fact keys with\n    C(ansible_net_<fact>).  The facts module will always collect a base set of\n    facts from the device and can enable or disable collection of additional\n    facts.\nnotes:\n  - Tested against ONYX 3.6\noptions:\n  gather_subset:\n    description:\n      - When supplied, this argument will restrict the facts collected\n        to a given subset.  Possible values for this argument include\n        all, version, module, and interfaces.  Can specify a list of\n        values to include a larger subset.  Values can also be used\n        with an initial C(M(!)) to specify that a specific subset should\n        not be collected.\n    required: false\n    default: version\n\"\"\"\n\nEXAMPLES = \"\"\"\n---\n- name: Collect all facts from the device\n  onyx_facts:\n    gather_subset: all\n\n- name: Collect only the interfaces facts\n  onyx_facts:\n    gather_subset:\n      - interfaces\n\n- name: Do not collect version facts\n  onyx_facts:\n    gather_subset:\n      - \"!version\"\n\"\"\"\n\nRETURN = \"\"\"\nansible_net_gather_subset:\n  description: The list of fact subsets collected from the device\n  returned: always\n  type: list\n\n version\nansible_net_version:\n  description: A hash of all curently running system image information\n  returned: when version is configured or when no gather_subset is provided\n  type: dict\n\n modules\nansible_net_modules:\n  description: A hash of all modules on the systeme with status\n  returned: when modules is configured\n  type: dict\n\n interfaces\nansible_net_interfaces:\n  description: A hash of all interfaces running on the system\n  returned: when interfaces is configured\n  type: dict\n\"\"\"\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.six import iteritems\n\nfrom ansible.module_utils.network.onyx.onyx import BaseOnyxModule\nfrom ansible.module_utils.network.onyx.onyx import show_cmd\n\n\nclass OnyxFactsModule(BaseOnyxModule):\n\n    def get_runable_subset(self, gather_subset):\n        runable_subsets = set()\n        exclude_subsets = set()\n        for subset in gather_subset:\n            if subset == 'all':\n                runable_subsets.update(VALID_SUBSETS)\n                continue\n\n            if subset.startswith('!'):\n                subset = subset[1:]\n                if subset == 'all':\n                    exclude_subsets.update(VALID_SUBSETS)\n                    continue\n                exclude = True\n            else:\n                exclude = False\n\n            if subset not in VALID_SUBSETS:\n                self._module.fail_json(msg='Bad subset')\n\n            if exclude:\n                exclude_subsets.add(subset)\n            else:\n                runable_subsets.add(subset)\n\n        if not runable_subsets:\n            runable_subsets.update(VALID_SUBSETS)\n\n        runable_subsets.difference_update(exclude_subsets)\n        if not runable_subsets:\n            runable_subsets.add('version')\n        return runable_subsets\n\n    def init_module(self):\n        \"\"\" module intialization\n        \"\"\"\n        argument_spec = dict(\n            gather_subset=dict(default=['version'], type='list')\n        )\n        self._module = AnsibleModule(\n            argument_spec=argument_spec,\n            supports_check_mode=True)\n\n    def run(self):\n        self.init_module()\n        gather_subset = self._module.params['gather_subset']\n        runable_subsets = self.get_runable_subset(gather_subset)\n        facts = dict()\n        facts['gather_subset'] = list(runable_subsets)\n\n        instances = list()\n        for key in runable_subsets:\n            facter_cls = FACT_SUBSETS[key]\n            instances.append(facter_cls(self._module))\n\n        for inst in instances:\n            inst.populate()\n            facts.update(inst.facts)\n\n        ansible_facts = dict()\n        for key, value in iteritems(facts):\n            key = 'ansible_net_%s' % key\n            ansible_facts[key] = value\n        self._module.exit_json(ansible_facts=ansible_facts)\n\n\nclass FactsBase(object):\n\n    COMMANDS = ['']\n\n    def __init__(self, module):\n        self.module = module\n        self.facts = dict()\n        self.responses = None\n\n    def _show_cmd(self, cmd):\n        return show_cmd(self.module, cmd, json_fmt=True)\n\n    def populate(self):\n        self.responses = []\n        for cmd in self.COMMANDS:\n            self.responses.append(self._show_cmd(cmd))\n\n\nclass Version(FactsBase):\n\n    COMMANDS = ['show version']\n\n    def populate(self):\n        super(Version, self).populate()\n        data = self.responses[0]\n        if data:\n            self.facts['version'] = data\n\n\nclass Module(FactsBase):\n\n    COMMANDS = ['show module']\n\n    def populate(self):\n        super(Module, self).populate()\n        data = self.responses[0]\n        if data:\n            self.facts['modules'] = data\n\n\nclass Interfaces(FactsBase):\n\n    COMMANDS = ['show interfaces ethernet']\n\n    def populate(self):\n        super(Interfaces, self).populate()\n\n        data = self.responses[0]\n        if data:\n            self.facts['interfaces'] = self.populate_interfaces(data)\n\n    def populate_interfaces(self, interfaces):\n        interfaces_dict = dict()\n        for if_data in interfaces:\n            if_dict = dict()\n            if_dict[\"MAC Address\"] = if_data[\"Mac address\"]\n            if_dict[\"Actual Speed\"] = if_data[\"Actual speed\"]\n            if_dict[\"MTU\"] = if_data[\"MTU\"]\n            if_dict[\"Admin State\"] = if_data[\"Admin state\"]\n            if_dict[\"Operational State\"] = if_data[\"Operational state\"]\n            if_name = if_dict[\"Interface Name\"] = if_data[\"header\"]\n            interfaces_dict[if_name] = if_dict\n        return interfaces_dict\n\n\nFACT_SUBSETS = dict(\n    version=Version,\n    modules=Module,\n    interfaces=Interfaces\n)\n\nVALID_SUBSETS = frozenset(FACT_SUBSETS.keys())\n\n\ndef main():\n    \"\"\" main entry point for module execution\n    \"\"\"\n    OnyxFactsModule.main()\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  onyx facts version added   2 5  author   waleed mousa ( waleedym)  samer deeb ( samerd)  short description  collect facts mellanox onyx network devices description      collects base set device facts onyx mellanox network devices     this module prepends base network fact keys     c(ansible net  fact )   the facts module always collect base set     facts device enable disable collection additional     facts  notes      tested onyx 3 6 options    gather subset      description          when supplied  argument restrict facts collected         given subset   possible values argument include          version  module  interfaces   can specify list         values include larger subset   values also used         initial c(m( )) specify specific subset         collected      required  false     default  version      examples             name  collect facts device   onyx facts      gather subset     name  collect interfaces facts   onyx facts      gather subset          interfaces    name  do collect version facts   onyx facts      gather subset            version       return       ansible net gather subset    description  the list fact subsets collected device   returned  always   type  list    version ansible net version    description  a hash curently running system image information   returned  version configured gather subset provided   type  dict    modules ansible net modules    description  a hash modules systeme status   returned  modules configured   type  dict    interfaces ansible net interfaces    description  a hash interfaces running system   returned  interfaces configured   type  dict      ansible module utils basic import ansiblemodule ansible module utils six import iteritems  ansible module utils network onyx onyx import baseonyxmodule ansible module utils network onyx onyx import show cmd   class onyxfactsmodule(baseonyxmodule)       def get runable subset(self  gather subset)          runable subsets   set()         exclude subsets   set()         subset gather subset              subset                       runable subsets update(valid subsets)                 continue              subset startswith(   )                  subset   subset 1                   subset                           exclude subsets update(valid subsets)                     continue                 exclude   true             else                  exclude   false              subset valid subsets                  self  module fail json(msg  bad subset )              exclude                  exclude subsets add(subset)             else                  runable subsets add(subset)          runable subsets              runable subsets update(valid subsets)          runable subsets difference update(exclude subsets)         runable subsets              runable subsets add( version )         return runable subsets      def init module(self)              module intialization                     argument spec   dict(             gather subset dict(default   version    type  list )         )         self  module   ansiblemodule(             argument spec argument spec              supports check mode true)      def run(self)          self init module()         gather subset   self  module params  gather subset           runable subsets   self get runable subset(gather subset)         facts   dict()         facts  gather subset     list(runable subsets)          instances   list()         key runable subsets              facter cls   fact subsets key              instances append(facter cls(self  module))          inst instances              inst populate()             facts update(inst facts)          ansible facts   dict()         key  value iteritems(facts)              key    ansible net     key             ansible facts key    value         self  module exit json(ansible facts ansible facts)   class factsbase(object)       commands             def   init  (self  module)          self module   module         self facts   dict()         self responses   none      def  show cmd(self  cmd)          return show cmd(self module  cmd  json fmt true)      def populate(self)          self responses              cmd self commands              self responses append(self  show cmd(cmd))   class version(factsbase)       commands     show version        def populate(self)          super(version  self) populate()         data   self responses 0          data              self facts  version     data   class module(factsbase)       commands     show module        def populate(self)          super(module  self) populate()         data   self responses 0          data              self facts  modules     data   class interfaces(factsbase)       commands     show interfaces ethernet        def populate(self)          super(interfaces  self) populate()          data   self responses 0          data              self facts  interfaces     self populate interfaces(data)      def populate interfaces(self  interfaces)          interfaces dict   dict()         data interfaces              dict   dict()             dict  mac address     data  mac address               dict  actual speed     data  actual speed               dict  mtu     data  mtu               dict  admin state     data  admin state               dict  operational state     data  operational state               name   dict  interface name     data  header               interfaces dict name    dict         return interfaces dict   fact subsets   dict(     version version      modules module      interfaces interfaces )  valid subsets   frozenset(fact subsets keys())   def main()          main entry point module execution             usr bin python       copyright  ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    version    modules    interfaces ", "content": "#!/usr/bin/python\n#\n# Copyright: Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = \"\"\"\n---\nmodule: onyx_facts\nversion_added: \"2.5\"\nauthor: \"Waleed Mousa (@waleedym), Samer Deeb (@samerd)\"\nshort_description: Collect facts from Mellanox ONYX network devices\ndescription:\n  - Collects a base set of device facts from a ONYX Mellanox network devices\n    This module prepends all of the base network fact keys with\n    C(ansible_net_<fact>).  The facts module will always collect a base set of\n    facts from the device and can enable or disable collection of additional\n    facts.\nnotes:\n  - Tested against ONYX 3.6\noptions:\n  gather_subset:\n    description:\n      - When supplied, this argument will restrict the facts collected\n        to a given subset.  Possible values for this argument include\n        all, version, module, and interfaces.  Can specify a list of\n        values to include a larger subset.  Values can also be used\n        with an initial C(M(!)) to specify that a specific subset should\n        not be collected.\n    required: false\n    default: version\n\"\"\"\n\nEXAMPLES = \"\"\"\n---\n- name: Collect all facts from the device\n  onyx_facts:\n    gather_subset: all\n\n- name: Collect only the interfaces facts\n  onyx_facts:\n    gather_subset:\n      - interfaces\n\n- name: Do not collect version facts\n  onyx_facts:\n    gather_subset:\n      - \"!version\"\n\"\"\"\n\nRETURN = \"\"\"\nansible_net_gather_subset:\n  description: The list of fact subsets collected from the device\n  returned: always\n  type: list\n\n# version\nansible_net_version:\n  description: A hash of all curently running system image information\n  returned: when version is configured or when no gather_subset is provided\n  type: dict\n\n# modules\nansible_net_modules:\n  description: A hash of all modules on the systeme with status\n  returned: when modules is configured\n  type: dict\n\n# interfaces\nansible_net_interfaces:\n  description: A hash of all interfaces running on the system\n  returned: when interfaces is configured\n  type: dict\n\"\"\"\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.six import iteritems\n\nfrom ansible.module_utils.network.onyx.onyx import BaseOnyxModule\nfrom ansible.module_utils.network.onyx.onyx import show_cmd\n\n\nclass OnyxFactsModule(BaseOnyxModule):\n\n    def get_runable_subset(self, gather_subset):\n        runable_subsets = set()\n        exclude_subsets = set()\n        for subset in gather_subset:\n            if subset == 'all':\n                runable_subsets.update(VALID_SUBSETS)\n                continue\n\n            if subset.startswith('!'):\n                subset = subset[1:]\n                if subset == 'all':\n                    exclude_subsets.update(VALID_SUBSETS)\n                    continue\n                exclude = True\n            else:\n                exclude = False\n\n            if subset not in VALID_SUBSETS:\n                self._module.fail_json(msg='Bad subset')\n\n            if exclude:\n                exclude_subsets.add(subset)\n            else:\n                runable_subsets.add(subset)\n\n        if not runable_subsets:\n            runable_subsets.update(VALID_SUBSETS)\n\n        runable_subsets.difference_update(exclude_subsets)\n        if not runable_subsets:\n            runable_subsets.add('version')\n        return runable_subsets\n\n    def init_module(self):\n        \"\"\" module intialization\n        \"\"\"\n        argument_spec = dict(\n            gather_subset=dict(default=['version'], type='list')\n        )\n        self._module = AnsibleModule(\n            argument_spec=argument_spec,\n            supports_check_mode=True)\n\n    def run(self):\n        self.init_module()\n        gather_subset = self._module.params['gather_subset']\n        runable_subsets = self.get_runable_subset(gather_subset)\n        facts = dict()\n        facts['gather_subset'] = list(runable_subsets)\n\n        instances = list()\n        for key in runable_subsets:\n            facter_cls = FACT_SUBSETS[key]\n            instances.append(facter_cls(self._module))\n\n        for inst in instances:\n            inst.populate()\n            facts.update(inst.facts)\n\n        ansible_facts = dict()\n        for key, value in iteritems(facts):\n            key = 'ansible_net_%s' % key\n            ansible_facts[key] = value\n        self._module.exit_json(ansible_facts=ansible_facts)\n\n\nclass FactsBase(object):\n\n    COMMANDS = ['']\n\n    def __init__(self, module):\n        self.module = module\n        self.facts = dict()\n        self.responses = None\n\n    def _show_cmd(self, cmd):\n        return show_cmd(self.module, cmd, json_fmt=True)\n\n    def populate(self):\n        self.responses = []\n        for cmd in self.COMMANDS:\n            self.responses.append(self._show_cmd(cmd))\n\n\nclass Version(FactsBase):\n\n    COMMANDS = ['show version']\n\n    def populate(self):\n        super(Version, self).populate()\n        data = self.responses[0]\n        if data:\n            self.facts['version'] = data\n\n\nclass Module(FactsBase):\n\n    COMMANDS = ['show module']\n\n    def populate(self):\n        super(Module, self).populate()\n        data = self.responses[0]\n        if data:\n            self.facts['modules'] = data\n\n\nclass Interfaces(FactsBase):\n\n    COMMANDS = ['show interfaces ethernet']\n\n    def populate(self):\n        super(Interfaces, self).populate()\n\n        data = self.responses[0]\n        if data:\n            self.facts['interfaces'] = self.populate_interfaces(data)\n\n    def populate_interfaces(self, interfaces):\n        interfaces_dict = dict()\n        for if_data in interfaces:\n            if_dict = dict()\n            if_dict[\"MAC Address\"] = if_data[\"Mac address\"]\n            if_dict[\"Actual Speed\"] = if_data[\"Actual speed\"]\n            if_dict[\"MTU\"] = if_data[\"MTU\"]\n            if_dict[\"Admin State\"] = if_data[\"Admin state\"]\n            if_dict[\"Operational State\"] = if_data[\"Operational state\"]\n            if_name = if_dict[\"Interface Name\"] = if_data[\"header\"]\n            interfaces_dict[if_name] = if_dict\n        return interfaces_dict\n\n\nFACT_SUBSETS = dict(\n    version=Version,\n    modules=Module,\n    interfaces=Interfaces\n)\n\nVALID_SUBSETS = frozenset(FACT_SUBSETS.keys())\n\n\ndef main():\n    \"\"\" main entry point for module execution\n    \"\"\"\n    OnyxFactsModule.main()\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "onyx_facts.py", "id": "04509c5b087669f20cb17b9143e2c805", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/network/onyx/onyx_facts.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}