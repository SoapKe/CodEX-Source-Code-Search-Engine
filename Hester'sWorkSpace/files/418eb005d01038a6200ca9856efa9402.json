{"author": "python-pillow", "code": "from __future__ import print_function\nimport sys\nfrom helper import unittest, PillowTestCase, hopper\n\nfrom PIL import Image\n\ntry:\n    import site\n    import numpy\n    assert site  \n    assert numpy  \nexcept ImportError:\n    ()\n    pass\n\nTEST_IMAGE_SIZE = (10, 10)\n\n# Numpy on pypy as of pypy 5.3.1 is corrupting the numpy.array(Image)\n\n# the repr is that of a PIL.Image. Size and shape are 1 and (), not the\n\nSKIP_NUMPY_ON_PYPY = hasattr(sys, 'pypy_version_info') and (\n    sys.pypy_version_info <= (5, 3, 1, 'final', 0))\n\n\nclass TestNumpy(PillowTestCase):\n\n    def setUp(self):\n        try:\n            import site\n            import numpy\n            assert site  \n            assert numpy  \n        except ImportError:\n            self.skipTest(\"ImportError\")\n\n    def test_numpy_to_image(self):\n\n        def to_image(dtype, bands=1, boolean=0):\n            if bands == 1:\n                if boolean:\n                    data = [0, 255] * 50\n                else:\n                    data = list(range(100))\n                a = numpy.array(data, dtype=dtype)\n                a.shape = TEST_IMAGE_SIZE\n                i = Image.fromarray(a)\n                if list(i.getdata()) != data:\n                    print(\"data mismatch for\", dtype)\n            else:\n                data = list(range(100))\n                a = numpy.array([[x]*bands for x in data], dtype=dtype)\n                a.shape = TEST_IMAGE_SIZE[0], TEST_IMAGE_SIZE[1], bands\n                i = Image.fromarray(a)\n                if list(i.getchannel(0).getdata()) != list(range(100)):\n                    print(\"data mismatch for\", dtype)\n            # print(dtype, list(i.getdata()))\n            return i\n\n        \n        self.assert_image(to_image(numpy.bool, 1, 1), '1', TEST_IMAGE_SIZE)\n        self.assert_image(to_image(numpy.bool8, 1, 1), '1', TEST_IMAGE_SIZE)\n\n        \n        self.assert_image(to_image(numpy.uint8), \"L\", TEST_IMAGE_SIZE)\n        self.assert_image(to_image(numpy.uint8, 3), \"RGB\", TEST_IMAGE_SIZE)\n        self.assert_image(to_image(numpy.uint8, 4), \"RGBA\", TEST_IMAGE_SIZE)\n        self.assert_image(to_image(numpy.int8), \"I\", TEST_IMAGE_SIZE)\n\n        \n        \n        \n        # self.assert_image(to_image(numpy.uint), \"I\", TEST_IMAGE_SIZE)\n        # self.assert_image(to_image(numpy.int), \"I\", TEST_IMAGE_SIZE)\n\n        \n        if Image._ENDIAN == '<':\n            self.assert_image(to_image(numpy.uint16), \"I;16\", TEST_IMAGE_SIZE)\n        else:\n            self.assert_image(to_image(numpy.uint16), \"I;16B\", TEST_IMAGE_SIZE)\n\n        self.assert_image(to_image(numpy.int16), \"I\", TEST_IMAGE_SIZE)\n\n        \n        self.assert_image(to_image(numpy.uint32), \"I\", TEST_IMAGE_SIZE)\n        self.assert_image(to_image(numpy.int32), \"I\", TEST_IMAGE_SIZE)\n\n        \n        self.assertRaises(TypeError, to_image, numpy.uint64)\n        self.assertRaises(TypeError, to_image, numpy.int64)\n\n        \n        self.assert_image(to_image(numpy.float), \"F\", TEST_IMAGE_SIZE)\n        self.assertRaises(TypeError, to_image, numpy.float16)\n        self.assert_image(to_image(numpy.float32), \"F\", TEST_IMAGE_SIZE)\n        self.assert_image(to_image(numpy.float64), \"F\", TEST_IMAGE_SIZE)\n\n        self.assert_image(to_image(numpy.uint8, 2), \"LA\", (10, 10))\n        self.assert_image(to_image(numpy.uint8, 3), \"RGB\", (10, 10))\n        self.assert_image(to_image(numpy.uint8, 4), \"RGBA\", (10, 10))\n\n    \n    \n    def test_3d_array(self):\n        size = (5, TEST_IMAGE_SIZE[0], TEST_IMAGE_SIZE[1])\n        a = numpy.ones(size, dtype=numpy.uint8)\n        self.assert_image(Image.fromarray(a[1, :, :]), \"L\", TEST_IMAGE_SIZE)\n        size = (TEST_IMAGE_SIZE[0], 5, TEST_IMAGE_SIZE[1])\n        a = numpy.ones(size, dtype=numpy.uint8)\n        self.assert_image(Image.fromarray(a[:, 1, :]), \"L\", TEST_IMAGE_SIZE)\n        size = (TEST_IMAGE_SIZE[0], TEST_IMAGE_SIZE[1], 5)\n        a = numpy.ones(size, dtype=numpy.uint8)\n        self.assert_image(Image.fromarray(a[:, :, 1]), \"L\", TEST_IMAGE_SIZE)\n\n    def _test_img_equals_nparray(self, img, np):\n        self.assertGreaterEqual(len(np.shape), 2)\n        np_size = np.shape[1], np.shape[0]\n        self.assertEqual(img.size, np_size)\n        px = img.load()\n        for x in range(0, img.size[0], int(img.size[0]/10)):\n            for y in range(0, img.size[1], int(img.size[1]/10)):\n                self.assert_deep_equal(px[x, y], np[y, x])\n\n    @unittest.skipIf(SKIP_NUMPY_ON_PYPY, \"numpy.array(Image) is flaky on PyPy\")\n    def test_16bit(self):\n        img = Image.open('Tests/images/16bit.cropped.tif')\n        np_img = numpy.array(img)\n        self._test_img_equals_nparray(img, np_img)\n        self.assertEqual(np_img.dtype, numpy.dtype('<u2'))\n\n    def test_1bit(self):\n        \n        \n        arr = numpy.array([[1, 0, 0, 1, 0], [0, 1, 0, 0, 0]], 'u1')\n        img = Image.fromarray(arr * 255).convert('1')\n        self.assertEqual(img.mode, '1')\n        arr_back = numpy.array(img)\n        # numpy 1.8 and earlier return this as a boolean. (trusty/precise)\n        if arr_back.dtype == numpy.bool:\n            arr_bool = numpy.array([[1, 0, 0, 1, 0], [0, 1, 0, 0, 0]], 'bool')\n            numpy.testing.assert_array_equal(arr_bool, arr_back)\n        else:\n            numpy.testing.assert_array_equal(arr, arr_back)\n\n    def test_save_tiff_uint16(self):\n        \n        pixel_value = 0x1234\n        a = numpy.array([pixel_value] * TEST_IMAGE_SIZE[0] * TEST_IMAGE_SIZE[1], dtype=numpy.uint16)\n        a.shape = TEST_IMAGE_SIZE\n        img = Image.fromarray(a)\n\n        img_px = img.load()\n        self.assertEqual(img_px[0, 0], pixel_value)\n\n    @unittest.skipIf(SKIP_NUMPY_ON_PYPY, \"numpy.array(Image) is flaky on PyPy\")\n    def test_to_array(self):\n\n        def _to_array(mode, dtype):\n            img = hopper(mode)\n\n            \n            img = img.crop((3, 0, 124, 127))\n            self.assertEqual(img.size, (121, 127))\n\n            np_img = numpy.array(img)\n            self._test_img_equals_nparray(img, np_img)\n            self.assertEqual(np_img.dtype, numpy.dtype(dtype))\n\n        modes = [(\"L\", 'uint8'),\n                 (\"I\", 'int32'),\n                 (\"F\", 'float32'),\n                 (\"LA\", 'uint8'),\n                 (\"RGB\", 'uint8'),\n                 (\"RGBA\", 'uint8'),\n                 (\"RGBX\", 'uint8'),\n                 (\"CMYK\", 'uint8'),\n                 (\"YCbCr\", 'uint8'),\n                 (\"I;16\", '<u2'),\n                 (\"I;16B\", '>u2'),\n                 (\"I;16L\", '<u2'),\n                 (\"HSV\", 'uint8'),\n                 ]\n\n        for mode in modes:\n            _to_array(*mode)\n\n    def test_point_lut(self):\n        \n\n        data = list(range(256))*3\n        lut = numpy.array(data, dtype='uint8')\n\n        im = hopper()\n\n        im.point(lut)\n\n    def test_putdata(self):\n        \n        \n\n        im = Image.new('F', (150, 100))\n        arr = numpy.zeros((15000,), numpy.float32)\n        im.putdata(arr)\n\n        self.assertEqual(len(im.getdata()), len(arr))\n\n    def test_zero_size(self):\n        \n        \n\n        im = Image.fromarray(numpy.empty((0, 0), dtype=numpy.uint8))\n\n        self.assertEqual(im.size, (0, 0))\n\n    def test_bool(self):\n        \n        a = numpy.zeros((10, 2), dtype=numpy.bool)\n        a[0][0] = True\n\n        im2 = Image.fromarray(a)\n        self.assertEqual(im2.getdata()[0], 255)\n\n    def test_no_resource_warning_for_numpy_array(self):\n        \n        \n        from numpy import array\n        test_file = 'Tests/images/hopper.png'\n        im = Image.open(test_file)\n\n        \n        self.assert_warning(None, lambda: array(im))\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "comments": "  silence warning    silence warning    skip via setup()    numpy pypy pypy 5 3 1 corrupting numpy array(image)    call returning object type numpy ndarray     repr pil image  size shape 1 ()     size shape array  this causes failures several tests     silence warning    silence warning    print(dtype  list(i getdata()))    check supported 1 bit integer formats    check supported 8 bit integer formats    check non fixed size integer types    these may fail  depending platform  since native    64 bit int image types     self assert image(to image(numpy uint)   i   test image size)    self assert image(to image(numpy int)   i   test image size)    check 16 bit integer formats    check 32 bit integer formats    check 64 bit integer formats    check floating point formats    based erring example    https   stackoverflow com questions 10854903 causing dimension dependent attributeerror pil fromarray function    test 1 bit arrays convert numpy back    see  https   github com python pillow pillow issues 350    numpy 1 8 earlier return boolean  (trusty precise)    tests getting pixel value right byte order     resize non square    see https   github com python pillow pillow issues 439    segfault    see https   github com python pillow pillow issues 1008    shouldn cause floating point exception    see https   github com python pillow pillow issues 2259    https   github com python pillow pillow issues 2044    https   github com python pillow pillow issues 835    arrange    act assert ", "content": "from __future__ import print_function\nimport sys\nfrom helper import unittest, PillowTestCase, hopper\n\nfrom PIL import Image\n\ntry:\n    import site\n    import numpy\n    assert site  # silence warning\n    assert numpy  # silence warning\nexcept ImportError:\n    # Skip via setUp()\n    pass\n\nTEST_IMAGE_SIZE = (10, 10)\n\n# Numpy on pypy as of pypy 5.3.1 is corrupting the numpy.array(Image)\n# call such that it's returning a object of type numpy.ndarray, but\n# the repr is that of a PIL.Image. Size and shape are 1 and (), not the\n# size and shape of the array. This causes failures in several tests.\nSKIP_NUMPY_ON_PYPY = hasattr(sys, 'pypy_version_info') and (\n    sys.pypy_version_info <= (5, 3, 1, 'final', 0))\n\n\nclass TestNumpy(PillowTestCase):\n\n    def setUp(self):\n        try:\n            import site\n            import numpy\n            assert site  # silence warning\n            assert numpy  # silence warning\n        except ImportError:\n            self.skipTest(\"ImportError\")\n\n    def test_numpy_to_image(self):\n\n        def to_image(dtype, bands=1, boolean=0):\n            if bands == 1:\n                if boolean:\n                    data = [0, 255] * 50\n                else:\n                    data = list(range(100))\n                a = numpy.array(data, dtype=dtype)\n                a.shape = TEST_IMAGE_SIZE\n                i = Image.fromarray(a)\n                if list(i.getdata()) != data:\n                    print(\"data mismatch for\", dtype)\n            else:\n                data = list(range(100))\n                a = numpy.array([[x]*bands for x in data], dtype=dtype)\n                a.shape = TEST_IMAGE_SIZE[0], TEST_IMAGE_SIZE[1], bands\n                i = Image.fromarray(a)\n                if list(i.getchannel(0).getdata()) != list(range(100)):\n                    print(\"data mismatch for\", dtype)\n            # print(dtype, list(i.getdata()))\n            return i\n\n        # Check supported 1-bit integer formats\n        self.assert_image(to_image(numpy.bool, 1, 1), '1', TEST_IMAGE_SIZE)\n        self.assert_image(to_image(numpy.bool8, 1, 1), '1', TEST_IMAGE_SIZE)\n\n        # Check supported 8-bit integer formats\n        self.assert_image(to_image(numpy.uint8), \"L\", TEST_IMAGE_SIZE)\n        self.assert_image(to_image(numpy.uint8, 3), \"RGB\", TEST_IMAGE_SIZE)\n        self.assert_image(to_image(numpy.uint8, 4), \"RGBA\", TEST_IMAGE_SIZE)\n        self.assert_image(to_image(numpy.int8), \"I\", TEST_IMAGE_SIZE)\n\n        # Check non-fixed-size integer types\n        # These may fail, depending on the platform, since we have no native\n        # 64 bit int image types.\n        # self.assert_image(to_image(numpy.uint), \"I\", TEST_IMAGE_SIZE)\n        # self.assert_image(to_image(numpy.int), \"I\", TEST_IMAGE_SIZE)\n\n        # Check 16-bit integer formats\n        if Image._ENDIAN == '<':\n            self.assert_image(to_image(numpy.uint16), \"I;16\", TEST_IMAGE_SIZE)\n        else:\n            self.assert_image(to_image(numpy.uint16), \"I;16B\", TEST_IMAGE_SIZE)\n\n        self.assert_image(to_image(numpy.int16), \"I\", TEST_IMAGE_SIZE)\n\n        # Check 32-bit integer formats\n        self.assert_image(to_image(numpy.uint32), \"I\", TEST_IMAGE_SIZE)\n        self.assert_image(to_image(numpy.int32), \"I\", TEST_IMAGE_SIZE)\n\n        # Check 64-bit integer formats\n        self.assertRaises(TypeError, to_image, numpy.uint64)\n        self.assertRaises(TypeError, to_image, numpy.int64)\n\n        # Check floating-point formats\n        self.assert_image(to_image(numpy.float), \"F\", TEST_IMAGE_SIZE)\n        self.assertRaises(TypeError, to_image, numpy.float16)\n        self.assert_image(to_image(numpy.float32), \"F\", TEST_IMAGE_SIZE)\n        self.assert_image(to_image(numpy.float64), \"F\", TEST_IMAGE_SIZE)\n\n        self.assert_image(to_image(numpy.uint8, 2), \"LA\", (10, 10))\n        self.assert_image(to_image(numpy.uint8, 3), \"RGB\", (10, 10))\n        self.assert_image(to_image(numpy.uint8, 4), \"RGBA\", (10, 10))\n\n    # based on an erring example at\n    # https://stackoverflow.com/questions/10854903/what-is-causing-dimension-dependent-attributeerror-in-pil-fromarray-function\n    def test_3d_array(self):\n        size = (5, TEST_IMAGE_SIZE[0], TEST_IMAGE_SIZE[1])\n        a = numpy.ones(size, dtype=numpy.uint8)\n        self.assert_image(Image.fromarray(a[1, :, :]), \"L\", TEST_IMAGE_SIZE)\n        size = (TEST_IMAGE_SIZE[0], 5, TEST_IMAGE_SIZE[1])\n        a = numpy.ones(size, dtype=numpy.uint8)\n        self.assert_image(Image.fromarray(a[:, 1, :]), \"L\", TEST_IMAGE_SIZE)\n        size = (TEST_IMAGE_SIZE[0], TEST_IMAGE_SIZE[1], 5)\n        a = numpy.ones(size, dtype=numpy.uint8)\n        self.assert_image(Image.fromarray(a[:, :, 1]), \"L\", TEST_IMAGE_SIZE)\n\n    def _test_img_equals_nparray(self, img, np):\n        self.assertGreaterEqual(len(np.shape), 2)\n        np_size = np.shape[1], np.shape[0]\n        self.assertEqual(img.size, np_size)\n        px = img.load()\n        for x in range(0, img.size[0], int(img.size[0]/10)):\n            for y in range(0, img.size[1], int(img.size[1]/10)):\n                self.assert_deep_equal(px[x, y], np[y, x])\n\n    @unittest.skipIf(SKIP_NUMPY_ON_PYPY, \"numpy.array(Image) is flaky on PyPy\")\n    def test_16bit(self):\n        img = Image.open('Tests/images/16bit.cropped.tif')\n        np_img = numpy.array(img)\n        self._test_img_equals_nparray(img, np_img)\n        self.assertEqual(np_img.dtype, numpy.dtype('<u2'))\n\n    def test_1bit(self):\n        # Test that 1-bit arrays convert to numpy and back\n        # See: https://github.com/python-pillow/Pillow/issues/350\n        arr = numpy.array([[1, 0, 0, 1, 0], [0, 1, 0, 0, 0]], 'u1')\n        img = Image.fromarray(arr * 255).convert('1')\n        self.assertEqual(img.mode, '1')\n        arr_back = numpy.array(img)\n        # numpy 1.8 and earlier return this as a boolean. (trusty/precise)\n        if arr_back.dtype == numpy.bool:\n            arr_bool = numpy.array([[1, 0, 0, 1, 0], [0, 1, 0, 0, 0]], 'bool')\n            numpy.testing.assert_array_equal(arr_bool, arr_back)\n        else:\n            numpy.testing.assert_array_equal(arr, arr_back)\n\n    def test_save_tiff_uint16(self):\n        # Tests that we're getting the pixel value in the right byte order.\n        pixel_value = 0x1234\n        a = numpy.array([pixel_value] * TEST_IMAGE_SIZE[0] * TEST_IMAGE_SIZE[1], dtype=numpy.uint16)\n        a.shape = TEST_IMAGE_SIZE\n        img = Image.fromarray(a)\n\n        img_px = img.load()\n        self.assertEqual(img_px[0, 0], pixel_value)\n\n    @unittest.skipIf(SKIP_NUMPY_ON_PYPY, \"numpy.array(Image) is flaky on PyPy\")\n    def test_to_array(self):\n\n        def _to_array(mode, dtype):\n            img = hopper(mode)\n\n            # Resize to non-square\n            img = img.crop((3, 0, 124, 127))\n            self.assertEqual(img.size, (121, 127))\n\n            np_img = numpy.array(img)\n            self._test_img_equals_nparray(img, np_img)\n            self.assertEqual(np_img.dtype, numpy.dtype(dtype))\n\n        modes = [(\"L\", 'uint8'),\n                 (\"I\", 'int32'),\n                 (\"F\", 'float32'),\n                 (\"LA\", 'uint8'),\n                 (\"RGB\", 'uint8'),\n                 (\"RGBA\", 'uint8'),\n                 (\"RGBX\", 'uint8'),\n                 (\"CMYK\", 'uint8'),\n                 (\"YCbCr\", 'uint8'),\n                 (\"I;16\", '<u2'),\n                 (\"I;16B\", '>u2'),\n                 (\"I;16L\", '<u2'),\n                 (\"HSV\", 'uint8'),\n                 ]\n\n        for mode in modes:\n            _to_array(*mode)\n\n    def test_point_lut(self):\n        # see https://github.com/python-pillow/Pillow/issues/439\n\n        data = list(range(256))*3\n        lut = numpy.array(data, dtype='uint8')\n\n        im = hopper()\n\n        im.point(lut)\n\n    def test_putdata(self):\n        # shouldn't segfault\n        # see https://github.com/python-pillow/Pillow/issues/1008\n\n        im = Image.new('F', (150, 100))\n        arr = numpy.zeros((15000,), numpy.float32)\n        im.putdata(arr)\n\n        self.assertEqual(len(im.getdata()), len(arr))\n\n    def test_zero_size(self):\n        # Shouldn't cause floating point exception\n        # See https://github.com/python-pillow/Pillow/issues/2259\n\n        im = Image.fromarray(numpy.empty((0, 0), dtype=numpy.uint8))\n\n        self.assertEqual(im.size, (0, 0))\n\n    def test_bool(self):\n        # https://github.com/python-pillow/Pillow/issues/2044\n        a = numpy.zeros((10, 2), dtype=numpy.bool)\n        a[0][0] = True\n\n        im2 = Image.fromarray(a)\n        self.assertEqual(im2.getdata()[0], 255)\n\n    def test_no_resource_warning_for_numpy_array(self):\n        # https://github.com/python-pillow/Pillow/issues/835\n        # Arrange\n        from numpy import array\n        test_file = 'Tests/images/hopper.png'\n        im = Image.open(test_file)\n\n        # Act/Assert\n        self.assert_warning(None, lambda: array(im))\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "description": "The friendly PIL fork (Python Imaging Library)", "file_name": "test_numpy.py", "id": "418eb005d01038a6200ca9856efa9402", "language": "Python", "project_name": "Pillow", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/python-pillow-Pillow/python-pillow-Pillow-4247de3/Tests/test_numpy.py", "save_time": "", "source": "", "update_at": "2018-03-18T09:10:03Z", "url": "https://github.com/python-pillow/Pillow", "wiki": true}