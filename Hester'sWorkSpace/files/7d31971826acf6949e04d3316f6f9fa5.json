{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport collections\nimport json\nimport os\nimport random\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_urlparse,\n)\nfrom ..utils import (\n    dict_get,\n    ExtractorError,\n    float_or_none,\n    int_or_none,\n    parse_duration,\n    qualities,\n    srt_subtitles_timecode,\n    try_get,\n    update_url_query,\n    urlencode_postdata,\n)\n\n\nclass PluralsightBaseIE(InfoExtractor):\n    _API_BASE = 'https://app.pluralsight.com'\n\n    def _download_course(self, course_id, url, display_id):\n        try:\n            return self._download_course_rpc(course_id, url, display_id)\n        except ExtractorError:\n            \n            return self._download_json(\n                'https://app.pluralsight.com/player/user/api/v1/player/payload',\n                display_id, data=urlencode_postdata({'courseId': course_id}),\n                headers={'Referer': url})\n\n    def _download_course_rpc(self, course_id, url, display_id):\n        response = self._download_json(\n            '%s/player/functions/rpc' % self._API_BASE, display_id,\n            'Downloading course JSON',\n            data=json.dumps({\n                'fn': 'bootstrapPlayer',\n                'payload': {\n                    'courseId': course_id,\n                },\n            }).encode('utf-8'),\n            headers={\n                'Content-Type': 'application/json;charset=utf-8',\n                'Referer': url,\n            })\n\n        course = try_get(response, lambda x: x['payload']['course'], dict)\n        if course:\n            return course\n\n        raise ExtractorError(\n            '%s said: %s' % (self.IE_NAME, response['error']['message']),\n            expected=True)\n\n\nclass PluralsightIE(PluralsightBaseIE):\n    IE_NAME = 'pluralsight'\n    _VALID_URL = r'https?://(?:(?:www|app)\\.)?pluralsight\\.com/(?:training/)?player\\?'\n    _LOGIN_URL = 'https://app.pluralsight.com/id/'\n\n    _NETRC_MACHINE = 'pluralsight'\n\n    _TESTS = [{\n        'url': 'http://www.pluralsight.com/training/player?author=mike-mckeown&name=hosting-sql-server-windows-azure-iaas-m7-mgmt&mode=live&clip=3&course=hosting-sql-server-windows-azure-iaas',\n        'md5': '4d458cf5cf4c593788672419a8dd4cf8',\n        'info_dict': {\n            'id': 'hosting-sql-server-windows-azure-iaas-m7-mgmt-04',\n            'ext': 'mp4',\n            'title': 'Demo Monitoring',\n            'duration': 338,\n        },\n        'skip': 'Requires pluralsight account credentials',\n    }, {\n        'url': 'https://app.pluralsight.com/training/player?course=angularjs-get-started&author=scott-allen&name=angularjs-get-started-m1-introduction&clip=0&mode=live',\n        'only_matching': True,\n    }, {\n        \n        'url': 'http://app.pluralsight.com/training/player?author=scott-allen&name=angularjs-get-started-m1-introduction&mode=live&clip=0&course=angularjs-get-started',\n        'only_matching': True,\n    }, {\n        'url': 'https://app.pluralsight.com/player?course=ccna-intro-networking&author=ross-bagurdes&name=ccna-intro-networking-m06&clip=0',\n        'only_matching': True,\n    }]\n\n    def _real_initialize(self):\n        self._login()\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n\n        login_page = self._download_webpage(\n            self._LOGIN_URL, None, 'Downloading login page')\n\n        login_form = self._hidden_inputs(login_page)\n\n        login_form.update({\n            'Username': username,\n            'Password': password,\n        })\n\n        post_url = self._search_regex(\n            r'<form[^>]+action=([\"\\'])(?P<url>.+?)\\1', login_page,\n            'post url', default=self._LOGIN_URL, group='url')\n\n        if not post_url.startswith('http'):\n            post_url = compat_urlparse.urljoin(self._LOGIN_URL, post_url)\n\n        response = self._download_webpage(\n            post_url, None, 'Logging in',\n            data=urlencode_postdata(login_form),\n            headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\n        error = self._search_regex(\n            r'<span[^>]+class=\"field-validation-error\"[^>]*>([^<]+)</span>',\n            response, 'error message', default=None)\n        if error:\n            raise ExtractorError('Unable to login: %s' % error, expected=True)\n\n        if all(p not in response for p in ('__INITIAL_STATE__', '\"currentUser\"')):\n            BLOCKED = 'Your account has been blocked due to suspicious activity'\n            if BLOCKED in response:\n                raise ExtractorError(\n                    'Unable to login: %s' % BLOCKED, expected=True)\n            MUST_AGREE = 'To continue using Pluralsight, you must agree to'\n            if any(p in response for p in (MUST_AGREE, '>Disagree<', '>Agree<')):\n                raise ExtractorError(\n                    'Unable to login: %s some documents. Go to pluralsight.com, '\n                    'log in and agree with what Pluralsight requires.'\n                    % MUST_AGREE, expected=True)\n\n            raise ExtractorError('Unable to log in')\n\n    def _get_subtitles(self, author, clip_id, lang, name, duration, video_id):\n        captions_post = {\n            'a': author,\n            'cn': clip_id,\n            'lc': lang,\n            'm': name,\n        }\n        captions = self._download_json(\n            '%s/player/retrieve-captions' % self._API_BASE, video_id,\n            'Downloading captions JSON', 'Unable to download captions JSON',\n            fatal=False, data=json.dumps(captions_post).encode('utf-8'),\n            headers={'Content-Type': 'application/json;charset=utf-8'})\n        if captions:\n            return {\n                lang: [{\n                    'ext': 'json',\n                    'data': json.dumps(captions),\n                }, {\n                    'ext': 'srt',\n                    'data': self._convert_subtitles(duration, captions),\n                }]\n            }\n\n    @staticmethod\n    def _convert_subtitles(duration, subs):\n        srt = ''\n        TIME_OFFSET_KEYS = ('displayTimeOffset', 'DisplayTimeOffset')\n        TEXT_KEYS = ('text', 'Text')\n        for num, current in enumerate(subs):\n            current = subs[num]\n            start, text = (\n                float_or_none(dict_get(current, TIME_OFFSET_KEYS, skip_false_values=False)),\n                dict_get(current, TEXT_KEYS))\n            if start is None or text is None:\n                continue\n            end = duration if num == len(subs) - 1 else float_or_none(\n                dict_get(subs[num + 1], TIME_OFFSET_KEYS, skip_false_values=False))\n            if end is None:\n                continue\n            srt += os.linesep.join(\n                (\n                    '%d' % num,\n                    '%s --> %s' % (\n                        srt_subtitles_timecode(start),\n                        srt_subtitles_timecode(end)),\n                    text,\n                    os.linesep,\n                ))\n        return srt\n\n    def _real_extract(self, url):\n        qs = compat_urlparse.parse_qs(compat_urlparse.urlparse(url).query)\n\n        author = qs.get('author', [None])[0]\n        name = qs.get('name', [None])[0]\n        clip_id = qs.get('clip', [None])[0]\n        course_name = qs.get('course', [None])[0]\n\n        if any(not f for f in (author, name, clip_id, course_name,)):\n            raise ExtractorError('Invalid URL', expected=True)\n\n        display_id = '%s-%s' % (name, clip_id)\n\n        course = self._download_course(course_name, url, display_id)\n\n        collection = course['modules']\n\n        clip = None\n\n        for module_ in collection:\n            if name in (module_.get('moduleName'), module_.get('name')):\n                for clip_ in module_.get('clips', []):\n                    clip_index = clip_.get('clipIndex')\n                    if clip_index is None:\n                        clip_index = clip_.get('index')\n                    if clip_index is None:\n                        continue\n                    if compat_str(clip_index) == clip_id:\n                        clip = clip_\n                        break\n\n        if not clip:\n            raise ExtractorError('Unable to resolve clip')\n\n        title = clip['title']\n\n        QUALITIES = {\n            'low': {'width': 640, 'height': 480},\n            'medium': {'width': 848, 'height': 640},\n            'high': {'width': 1024, 'height': 768},\n            'high-widescreen': {'width': 1280, 'height': 720},\n        }\n\n        QUALITIES_PREFERENCE = ('low', 'medium', 'high', 'high-widescreen',)\n        quality_key = qualities(QUALITIES_PREFERENCE)\n\n        AllowedQuality = collections.namedtuple('AllowedQuality', ['ext', 'qualities'])\n\n        ALLOWED_QUALITIES = (\n            AllowedQuality('webm', ['high', ]),\n            AllowedQuality('mp4', ['low', 'medium', 'high', ]),\n        )\n\n        \n        \n        widescreen = course.get('supportsWideScreenVideoFormats') is True\n        best_quality = 'high-widescreen' if widescreen else 'high'\n        if widescreen:\n            for allowed_quality in ALLOWED_QUALITIES:\n                allowed_quality.qualities.append(best_quality)\n\n        \n        \n        \n        if self._downloader.params.get('listformats', False):\n            allowed_qualities = ALLOWED_QUALITIES\n        else:\n            def guess_allowed_qualities():\n                req_format = self._downloader.params.get('format') or 'best'\n                req_format_split = req_format.split('-', 1)\n                if len(req_format_split) > 1:\n                    req_ext, req_quality = req_format_split\n                    req_quality = '-'.join(req_quality.split('-')[:2])\n                    for allowed_quality in ALLOWED_QUALITIES:\n                        if req_ext == allowed_quality.ext and req_quality in allowed_quality.qualities:\n                            return (AllowedQuality(req_ext, (req_quality, )), )\n                req_ext = 'webm' if self._downloader.params.get('prefer_free_formats') else 'mp4'\n                return (AllowedQuality(req_ext, (best_quality, )), )\n            allowed_qualities = guess_allowed_qualities()\n\n        formats = []\n        for ext, qualities_ in allowed_qualities:\n            for quality in qualities_:\n                f = QUALITIES[quality].copy()\n                clip_post = {\n                    'author': author,\n                    'includeCaptions': False,\n                    'clipIndex': int(clip_id),\n                    'courseName': course_name,\n                    'locale': 'en',\n                    'moduleName': name,\n                    'mediaType': ext,\n                    'quality': '%dx%d' % (f['width'], f['height']),\n                }\n                format_id = '%s-%s' % (ext, quality)\n                viewclip = self._download_json(\n                    '%s/video/clips/viewclip' % self._API_BASE, display_id,\n                    'Downloading %s viewclip JSON' % format_id, fatal=False,\n                    data=json.dumps(clip_post).encode('utf-8'),\n                    headers={'Content-Type': 'application/json;charset=utf-8'})\n\n                \n                \n                \n                \n                \n                \n                self._sleep(\n                    random.randint(2, 5), display_id,\n                    '%(video_id)s: Waiting for %(timeout)s seconds to avoid throttling')\n\n                if not viewclip:\n                    continue\n\n                clip_urls = viewclip.get('urls')\n                if not isinstance(clip_urls, list):\n                    continue\n\n                for clip_url_data in clip_urls:\n                    clip_url = clip_url_data.get('url')\n                    if not clip_url:\n                        continue\n                    cdn = clip_url_data.get('cdn')\n                    clip_f = f.copy()\n                    clip_f.update({\n                        'url': clip_url,\n                        'ext': ext,\n                        'format_id': '%s-%s' % (format_id, cdn) if cdn else format_id,\n                        'quality': quality_key(quality),\n                        'source_preference': int_or_none(clip_url_data.get('rank')),\n                    })\n                    formats.append(clip_f)\n\n        self._sort_formats(formats)\n\n        duration = int_or_none(\n            clip.get('duration')) or parse_duration(clip.get('formattedDuration'))\n\n        \n        subtitles = self.extract_subtitles(\n            author, clip_id, 'en', name, duration, display_id)\n\n        return {\n            'id': clip.get('clipName') or clip['name'],\n            'title': title,\n            'duration': duration,\n            'creator': author,\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n\n\nclass PluralsightCourseIE(PluralsightBaseIE):\n    IE_NAME = 'pluralsight:course'\n    _VALID_URL = r'https?://(?:(?:www|app)\\.)?pluralsight\\.com/(?:library/)?courses/(?P<id>[^/]+)'\n    _TESTS = [{\n        \n        \n        'url': 'http://www.pluralsight.com/courses/hosting-sql-server-windows-azure-iaas',\n        'info_dict': {\n            'id': 'hosting-sql-server-windows-azure-iaas',\n            'title': 'Hosting SQL Server in Microsoft Azure IaaS Fundamentals',\n            'description': 'md5:61b37e60f21c4b2f91dc621a977d0986',\n        },\n        'playlist_count': 31,\n    }, {\n        \n        'url': 'https://www.pluralsight.com/courses/angularjs-get-started',\n        'only_matching': True,\n    }, {\n        'url': 'https://app.pluralsight.com/library/courses/understanding-microsoft-azure-amazon-aws/table-of-contents',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        course_id = self._match_id(url)\n\n        \n\n        course = self._download_course(course_id, url, course_id)\n\n        title = course['title']\n        course_name = course['name']\n        course_data = course['modules']\n        description = course.get('description') or course.get('shortDescription')\n\n        entries = []\n        for num, module in enumerate(course_data, 1):\n            author = module.get('author')\n            module_name = module.get('name')\n            if not author or not module_name:\n                continue\n            for clip in module.get('clips', []):\n                clip_index = int_or_none(clip.get('index'))\n                if clip_index is None:\n                    continue\n                clip_url = update_url_query(\n                    '%s/player' % self._API_BASE, query={\n                        'mode': 'live',\n                        'course': course_name,\n                        'author': author,\n                        'name': module_name,\n                        'clip': clip_index,\n                    })\n                entries.append({\n                    '_type': 'url_transparent',\n                    'url': clip_url,\n                    'ie_key': PluralsightIE.ie_key(),\n                    'chapter': module.get('title'),\n                    'chapter_number': num,\n                    'chapter_id': module.get('moduleRef'),\n                })\n\n        return self.playlist_result(entries, course_id, title, description)\n", "comments": "# Old API fallback\n# available without pluralsight account\n# Some courses also offer widescreen resolution for high quality (see\n# https://github.com/rg3/youtube-dl/issues/7766)\n# In order to minimize the number of calls to ViewClip API and reduce\n# the probability of being throttled or banned by Pluralsight we will request\n# only single format until formats listing was explicitly requested.\n# Pluralsight tracks multiple sequential calls to ViewClip API and start\n# to return 429 HTTP errors after some time (see\n# https://github.com/rg3/youtube-dl/pull/6989). Moreover it may even lead\n# to account ban (see https://github.com/rg3/youtube-dl/issues/6842).\n# To somewhat reduce the probability of these consequences\n# we will sleep random amount of time before each call to ViewClip.\n# TODO: other languages?\n# Free course from Pluralsight Starter Subscription for Microsoft TechNet\n# https://offers.pluralsight.com/technet?loc=zTS3z&prod=zOTprodz&tech=zOttechz&prog=zOTprogz&type=zSOz&media=zOTmediaz&country=zUSz\n# available without pluralsight account\n# TODO: PSM cookie\n", "content": "from __future__ import unicode_literals\n\nimport collections\nimport json\nimport os\nimport random\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_urlparse,\n)\nfrom ..utils import (\n    dict_get,\n    ExtractorError,\n    float_or_none,\n    int_or_none,\n    parse_duration,\n    qualities,\n    srt_subtitles_timecode,\n    try_get,\n    update_url_query,\n    urlencode_postdata,\n)\n\n\nclass PluralsightBaseIE(InfoExtractor):\n    _API_BASE = 'https://app.pluralsight.com'\n\n    def _download_course(self, course_id, url, display_id):\n        try:\n            return self._download_course_rpc(course_id, url, display_id)\n        except ExtractorError:\n            # Old API fallback\n            return self._download_json(\n                'https://app.pluralsight.com/player/user/api/v1/player/payload',\n                display_id, data=urlencode_postdata({'courseId': course_id}),\n                headers={'Referer': url})\n\n    def _download_course_rpc(self, course_id, url, display_id):\n        response = self._download_json(\n            '%s/player/functions/rpc' % self._API_BASE, display_id,\n            'Downloading course JSON',\n            data=json.dumps({\n                'fn': 'bootstrapPlayer',\n                'payload': {\n                    'courseId': course_id,\n                },\n            }).encode('utf-8'),\n            headers={\n                'Content-Type': 'application/json;charset=utf-8',\n                'Referer': url,\n            })\n\n        course = try_get(response, lambda x: x['payload']['course'], dict)\n        if course:\n            return course\n\n        raise ExtractorError(\n            '%s said: %s' % (self.IE_NAME, response['error']['message']),\n            expected=True)\n\n\nclass PluralsightIE(PluralsightBaseIE):\n    IE_NAME = 'pluralsight'\n    _VALID_URL = r'https?://(?:(?:www|app)\\.)?pluralsight\\.com/(?:training/)?player\\?'\n    _LOGIN_URL = 'https://app.pluralsight.com/id/'\n\n    _NETRC_MACHINE = 'pluralsight'\n\n    _TESTS = [{\n        'url': 'http://www.pluralsight.com/training/player?author=mike-mckeown&name=hosting-sql-server-windows-azure-iaas-m7-mgmt&mode=live&clip=3&course=hosting-sql-server-windows-azure-iaas',\n        'md5': '4d458cf5cf4c593788672419a8dd4cf8',\n        'info_dict': {\n            'id': 'hosting-sql-server-windows-azure-iaas-m7-mgmt-04',\n            'ext': 'mp4',\n            'title': 'Demo Monitoring',\n            'duration': 338,\n        },\n        'skip': 'Requires pluralsight account credentials',\n    }, {\n        'url': 'https://app.pluralsight.com/training/player?course=angularjs-get-started&author=scott-allen&name=angularjs-get-started-m1-introduction&clip=0&mode=live',\n        'only_matching': True,\n    }, {\n        # available without pluralsight account\n        'url': 'http://app.pluralsight.com/training/player?author=scott-allen&name=angularjs-get-started-m1-introduction&mode=live&clip=0&course=angularjs-get-started',\n        'only_matching': True,\n    }, {\n        'url': 'https://app.pluralsight.com/player?course=ccna-intro-networking&author=ross-bagurdes&name=ccna-intro-networking-m06&clip=0',\n        'only_matching': True,\n    }]\n\n    def _real_initialize(self):\n        self._login()\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n\n        login_page = self._download_webpage(\n            self._LOGIN_URL, None, 'Downloading login page')\n\n        login_form = self._hidden_inputs(login_page)\n\n        login_form.update({\n            'Username': username,\n            'Password': password,\n        })\n\n        post_url = self._search_regex(\n            r'<form[^>]+action=([\"\\'])(?P<url>.+?)\\1', login_page,\n            'post url', default=self._LOGIN_URL, group='url')\n\n        if not post_url.startswith('http'):\n            post_url = compat_urlparse.urljoin(self._LOGIN_URL, post_url)\n\n        response = self._download_webpage(\n            post_url, None, 'Logging in',\n            data=urlencode_postdata(login_form),\n            headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\n        error = self._search_regex(\n            r'<span[^>]+class=\"field-validation-error\"[^>]*>([^<]+)</span>',\n            response, 'error message', default=None)\n        if error:\n            raise ExtractorError('Unable to login: %s' % error, expected=True)\n\n        if all(p not in response for p in ('__INITIAL_STATE__', '\"currentUser\"')):\n            BLOCKED = 'Your account has been blocked due to suspicious activity'\n            if BLOCKED in response:\n                raise ExtractorError(\n                    'Unable to login: %s' % BLOCKED, expected=True)\n            MUST_AGREE = 'To continue using Pluralsight, you must agree to'\n            if any(p in response for p in (MUST_AGREE, '>Disagree<', '>Agree<')):\n                raise ExtractorError(\n                    'Unable to login: %s some documents. Go to pluralsight.com, '\n                    'log in and agree with what Pluralsight requires.'\n                    % MUST_AGREE, expected=True)\n\n            raise ExtractorError('Unable to log in')\n\n    def _get_subtitles(self, author, clip_id, lang, name, duration, video_id):\n        captions_post = {\n            'a': author,\n            'cn': clip_id,\n            'lc': lang,\n            'm': name,\n        }\n        captions = self._download_json(\n            '%s/player/retrieve-captions' % self._API_BASE, video_id,\n            'Downloading captions JSON', 'Unable to download captions JSON',\n            fatal=False, data=json.dumps(captions_post).encode('utf-8'),\n            headers={'Content-Type': 'application/json;charset=utf-8'})\n        if captions:\n            return {\n                lang: [{\n                    'ext': 'json',\n                    'data': json.dumps(captions),\n                }, {\n                    'ext': 'srt',\n                    'data': self._convert_subtitles(duration, captions),\n                }]\n            }\n\n    @staticmethod\n    def _convert_subtitles(duration, subs):\n        srt = ''\n        TIME_OFFSET_KEYS = ('displayTimeOffset', 'DisplayTimeOffset')\n        TEXT_KEYS = ('text', 'Text')\n        for num, current in enumerate(subs):\n            current = subs[num]\n            start, text = (\n                float_or_none(dict_get(current, TIME_OFFSET_KEYS, skip_false_values=False)),\n                dict_get(current, TEXT_KEYS))\n            if start is None or text is None:\n                continue\n            end = duration if num == len(subs) - 1 else float_or_none(\n                dict_get(subs[num + 1], TIME_OFFSET_KEYS, skip_false_values=False))\n            if end is None:\n                continue\n            srt += os.linesep.join(\n                (\n                    '%d' % num,\n                    '%s --> %s' % (\n                        srt_subtitles_timecode(start),\n                        srt_subtitles_timecode(end)),\n                    text,\n                    os.linesep,\n                ))\n        return srt\n\n    def _real_extract(self, url):\n        qs = compat_urlparse.parse_qs(compat_urlparse.urlparse(url).query)\n\n        author = qs.get('author', [None])[0]\n        name = qs.get('name', [None])[0]\n        clip_id = qs.get('clip', [None])[0]\n        course_name = qs.get('course', [None])[0]\n\n        if any(not f for f in (author, name, clip_id, course_name,)):\n            raise ExtractorError('Invalid URL', expected=True)\n\n        display_id = '%s-%s' % (name, clip_id)\n\n        course = self._download_course(course_name, url, display_id)\n\n        collection = course['modules']\n\n        clip = None\n\n        for module_ in collection:\n            if name in (module_.get('moduleName'), module_.get('name')):\n                for clip_ in module_.get('clips', []):\n                    clip_index = clip_.get('clipIndex')\n                    if clip_index is None:\n                        clip_index = clip_.get('index')\n                    if clip_index is None:\n                        continue\n                    if compat_str(clip_index) == clip_id:\n                        clip = clip_\n                        break\n\n        if not clip:\n            raise ExtractorError('Unable to resolve clip')\n\n        title = clip['title']\n\n        QUALITIES = {\n            'low': {'width': 640, 'height': 480},\n            'medium': {'width': 848, 'height': 640},\n            'high': {'width': 1024, 'height': 768},\n            'high-widescreen': {'width': 1280, 'height': 720},\n        }\n\n        QUALITIES_PREFERENCE = ('low', 'medium', 'high', 'high-widescreen',)\n        quality_key = qualities(QUALITIES_PREFERENCE)\n\n        AllowedQuality = collections.namedtuple('AllowedQuality', ['ext', 'qualities'])\n\n        ALLOWED_QUALITIES = (\n            AllowedQuality('webm', ['high', ]),\n            AllowedQuality('mp4', ['low', 'medium', 'high', ]),\n        )\n\n        # Some courses also offer widescreen resolution for high quality (see\n        # https://github.com/rg3/youtube-dl/issues/7766)\n        widescreen = course.get('supportsWideScreenVideoFormats') is True\n        best_quality = 'high-widescreen' if widescreen else 'high'\n        if widescreen:\n            for allowed_quality in ALLOWED_QUALITIES:\n                allowed_quality.qualities.append(best_quality)\n\n        # In order to minimize the number of calls to ViewClip API and reduce\n        # the probability of being throttled or banned by Pluralsight we will request\n        # only single format until formats listing was explicitly requested.\n        if self._downloader.params.get('listformats', False):\n            allowed_qualities = ALLOWED_QUALITIES\n        else:\n            def guess_allowed_qualities():\n                req_format = self._downloader.params.get('format') or 'best'\n                req_format_split = req_format.split('-', 1)\n                if len(req_format_split) > 1:\n                    req_ext, req_quality = req_format_split\n                    req_quality = '-'.join(req_quality.split('-')[:2])\n                    for allowed_quality in ALLOWED_QUALITIES:\n                        if req_ext == allowed_quality.ext and req_quality in allowed_quality.qualities:\n                            return (AllowedQuality(req_ext, (req_quality, )), )\n                req_ext = 'webm' if self._downloader.params.get('prefer_free_formats') else 'mp4'\n                return (AllowedQuality(req_ext, (best_quality, )), )\n            allowed_qualities = guess_allowed_qualities()\n\n        formats = []\n        for ext, qualities_ in allowed_qualities:\n            for quality in qualities_:\n                f = QUALITIES[quality].copy()\n                clip_post = {\n                    'author': author,\n                    'includeCaptions': False,\n                    'clipIndex': int(clip_id),\n                    'courseName': course_name,\n                    'locale': 'en',\n                    'moduleName': name,\n                    'mediaType': ext,\n                    'quality': '%dx%d' % (f['width'], f['height']),\n                }\n                format_id = '%s-%s' % (ext, quality)\n                viewclip = self._download_json(\n                    '%s/video/clips/viewclip' % self._API_BASE, display_id,\n                    'Downloading %s viewclip JSON' % format_id, fatal=False,\n                    data=json.dumps(clip_post).encode('utf-8'),\n                    headers={'Content-Type': 'application/json;charset=utf-8'})\n\n                # Pluralsight tracks multiple sequential calls to ViewClip API and start\n                # to return 429 HTTP errors after some time (see\n                # https://github.com/rg3/youtube-dl/pull/6989). Moreover it may even lead\n                # to account ban (see https://github.com/rg3/youtube-dl/issues/6842).\n                # To somewhat reduce the probability of these consequences\n                # we will sleep random amount of time before each call to ViewClip.\n                self._sleep(\n                    random.randint(2, 5), display_id,\n                    '%(video_id)s: Waiting for %(timeout)s seconds to avoid throttling')\n\n                if not viewclip:\n                    continue\n\n                clip_urls = viewclip.get('urls')\n                if not isinstance(clip_urls, list):\n                    continue\n\n                for clip_url_data in clip_urls:\n                    clip_url = clip_url_data.get('url')\n                    if not clip_url:\n                        continue\n                    cdn = clip_url_data.get('cdn')\n                    clip_f = f.copy()\n                    clip_f.update({\n                        'url': clip_url,\n                        'ext': ext,\n                        'format_id': '%s-%s' % (format_id, cdn) if cdn else format_id,\n                        'quality': quality_key(quality),\n                        'source_preference': int_or_none(clip_url_data.get('rank')),\n                    })\n                    formats.append(clip_f)\n\n        self._sort_formats(formats)\n\n        duration = int_or_none(\n            clip.get('duration')) or parse_duration(clip.get('formattedDuration'))\n\n        # TODO: other languages?\n        subtitles = self.extract_subtitles(\n            author, clip_id, 'en', name, duration, display_id)\n\n        return {\n            'id': clip.get('clipName') or clip['name'],\n            'title': title,\n            'duration': duration,\n            'creator': author,\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n\n\nclass PluralsightCourseIE(PluralsightBaseIE):\n    IE_NAME = 'pluralsight:course'\n    _VALID_URL = r'https?://(?:(?:www|app)\\.)?pluralsight\\.com/(?:library/)?courses/(?P<id>[^/]+)'\n    _TESTS = [{\n        # Free course from Pluralsight Starter Subscription for Microsoft TechNet\n        # https://offers.pluralsight.com/technet?loc=zTS3z&prod=zOTprodz&tech=zOttechz&prog=zOTprogz&type=zSOz&media=zOTmediaz&country=zUSz\n        'url': 'http://www.pluralsight.com/courses/hosting-sql-server-windows-azure-iaas',\n        'info_dict': {\n            'id': 'hosting-sql-server-windows-azure-iaas',\n            'title': 'Hosting SQL Server in Microsoft Azure IaaS Fundamentals',\n            'description': 'md5:61b37e60f21c4b2f91dc621a977d0986',\n        },\n        'playlist_count': 31,\n    }, {\n        # available without pluralsight account\n        'url': 'https://www.pluralsight.com/courses/angularjs-get-started',\n        'only_matching': True,\n    }, {\n        'url': 'https://app.pluralsight.com/library/courses/understanding-microsoft-azure-amazon-aws/table-of-contents',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        course_id = self._match_id(url)\n\n        # TODO: PSM cookie\n\n        course = self._download_course(course_id, url, course_id)\n\n        title = course['title']\n        course_name = course['name']\n        course_data = course['modules']\n        description = course.get('description') or course.get('shortDescription')\n\n        entries = []\n        for num, module in enumerate(course_data, 1):\n            author = module.get('author')\n            module_name = module.get('name')\n            if not author or not module_name:\n                continue\n            for clip in module.get('clips', []):\n                clip_index = int_or_none(clip.get('index'))\n                if clip_index is None:\n                    continue\n                clip_url = update_url_query(\n                    '%s/player' % self._API_BASE, query={\n                        'mode': 'live',\n                        'course': course_name,\n                        'author': author,\n                        'name': module_name,\n                        'clip': clip_index,\n                    })\n                entries.append({\n                    '_type': 'url_transparent',\n                    'url': clip_url,\n                    'ie_key': PluralsightIE.ie_key(),\n                    'chapter': module.get('title'),\n                    'chapter_number': num,\n                    'chapter_id': module.get('moduleRef'),\n                })\n\n        return self.playlist_result(entries, course_id, title, description)\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "pluralsight.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/pluralsight.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}