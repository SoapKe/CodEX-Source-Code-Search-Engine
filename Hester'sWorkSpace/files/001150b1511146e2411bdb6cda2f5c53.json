{"author": "pandas-dev", "code": "import numpy as np\nimport pandas.util.testing as tm\nfrom pandas import DataFrame, Series, to_numeric\n\nfrom .pandas_vb_common import numeric_dtypes, lib, setup  \n\n\nclass NumericInferOps(object):\n    \n    goal_time = 0.2\n    params = numeric_dtypes\n    param_names = ['dtype']\n\n    def setup(self, dtype):\n        N = 5 * 10**5\n        self.df = DataFrame({'A': np.arange(N).astype(dtype),\n                             'B': np.arange(N).astype(dtype)})\n\n    def time_add(self, dtype):\n        self.df['A'] + self.df['B']\n\n    def time_subtract(self, dtype):\n        self.df['A'] - self.df['B']\n\n    def time_multiply(self, dtype):\n        self.df['A'] * self.df['B']\n\n    def time_divide(self, dtype):\n        self.df['A'] / self.df['B']\n\n    def time_modulo(self, dtype):\n        self.df['A'] % self.df['B']\n\n\nclass DateInferOps(object):\n    \n    goal_time = 0.2\n\n    def setup_cache(self):\n        N = 5 * 10**5\n        df = DataFrame({'datetime64': np.arange(N).astype('datetime64[ms]')})\n        df['timedelta'] = df['datetime64'] - df['datetime64']\n        return df\n\n    def time_subtract_datetimes(self, df):\n        df['datetime64'] - df['datetime64']\n\n    def time_timedelta_plus_datetime(self, df):\n        df['timedelta'] + df['datetime64']\n\n    def time_add_timedeltas(self, df):\n        df['timedelta'] + df['timedelta']\n\n\nclass ToNumeric(object):\n\n    goal_time = 0.2\n    params = ['ignore', 'coerce']\n    param_names = ['errors']\n\n    def setup(self, errors):\n        N = 10000\n        self.float = Series(np.random.randn(N))\n        self.numstr = self.float.astype('str')\n        self.str = Series(tm.makeStringIndex(N))\n\n    def time_from_float(self, errors):\n        to_numeric(self.float, errors=errors)\n\n    def time_from_numeric_str(self, errors):\n        to_numeric(self.numstr, errors=errors)\n\n    def time_from_str(self, errors):\n        to_numeric(self.str, errors=errors)\n\n\nclass ToNumericDowncast(object):\n\n    param_names = ['dtype', 'downcast']\n    params = [['string-float', 'string-int', 'string-nint', 'datetime64',\n               'int-list', 'int32'],\n              [None, 'integer', 'signed', 'unsigned', 'float']]\n\n    N = 500000\n    N2 = int(N / 2)\n\n    data_dict = {'string-int': ['1'] * N2 + [2] * N2,\n                 'string-nint': ['-1'] * N2 + [2] * N2,\n                 'datetime64': np.repeat(np.array(['1970-01-01', '1970-01-02'],\n                                                  dtype='datetime64[D]'), N),\n                 'string-float': ['1.1'] * N2 + [2] * N2,\n                 'int-list': [1] * N2 + [2] * N2,\n                 'int32': np.repeat(np.int32(1), N)}\n\n    def setup(self, dtype, downcast):\n        self.data = self.data_dict[dtype]\n\n    def time_downcast(self, dtype, downcast):\n        to_numeric(self.data, downcast=downcast)\n\n\nclass MaybeConvertNumeric(object):\n\n    def setup_cache(self):\n        N = 10**6\n        arr = np.repeat([2**63], N) + np.arange(N).astype('uint64')\n        data = arr.astype(object)\n        data[1::2] = arr[1::2].astype(str)\n        data[-1] = -1\n        return data\n\n    def time_convert(self, data):\n        lib.maybe_convert_numeric(data, set(), coerce_numeric=False)\n", "comments": "noqa gh 7332 gh 7332", "content": "import numpy as np\nimport pandas.util.testing as tm\nfrom pandas import DataFrame, Series, to_numeric\n\nfrom .pandas_vb_common import numeric_dtypes, lib, setup  # noqa\n\n\nclass NumericInferOps(object):\n    # from GH 7332\n    goal_time = 0.2\n    params = numeric_dtypes\n    param_names = ['dtype']\n\n    def setup(self, dtype):\n        N = 5 * 10**5\n        self.df = DataFrame({'A': np.arange(N).astype(dtype),\n                             'B': np.arange(N).astype(dtype)})\n\n    def time_add(self, dtype):\n        self.df['A'] + self.df['B']\n\n    def time_subtract(self, dtype):\n        self.df['A'] - self.df['B']\n\n    def time_multiply(self, dtype):\n        self.df['A'] * self.df['B']\n\n    def time_divide(self, dtype):\n        self.df['A'] / self.df['B']\n\n    def time_modulo(self, dtype):\n        self.df['A'] % self.df['B']\n\n\nclass DateInferOps(object):\n    # from GH 7332\n    goal_time = 0.2\n\n    def setup_cache(self):\n        N = 5 * 10**5\n        df = DataFrame({'datetime64': np.arange(N).astype('datetime64[ms]')})\n        df['timedelta'] = df['datetime64'] - df['datetime64']\n        return df\n\n    def time_subtract_datetimes(self, df):\n        df['datetime64'] - df['datetime64']\n\n    def time_timedelta_plus_datetime(self, df):\n        df['timedelta'] + df['datetime64']\n\n    def time_add_timedeltas(self, df):\n        df['timedelta'] + df['timedelta']\n\n\nclass ToNumeric(object):\n\n    goal_time = 0.2\n    params = ['ignore', 'coerce']\n    param_names = ['errors']\n\n    def setup(self, errors):\n        N = 10000\n        self.float = Series(np.random.randn(N))\n        self.numstr = self.float.astype('str')\n        self.str = Series(tm.makeStringIndex(N))\n\n    def time_from_float(self, errors):\n        to_numeric(self.float, errors=errors)\n\n    def time_from_numeric_str(self, errors):\n        to_numeric(self.numstr, errors=errors)\n\n    def time_from_str(self, errors):\n        to_numeric(self.str, errors=errors)\n\n\nclass ToNumericDowncast(object):\n\n    param_names = ['dtype', 'downcast']\n    params = [['string-float', 'string-int', 'string-nint', 'datetime64',\n               'int-list', 'int32'],\n              [None, 'integer', 'signed', 'unsigned', 'float']]\n\n    N = 500000\n    N2 = int(N / 2)\n\n    data_dict = {'string-int': ['1'] * N2 + [2] * N2,\n                 'string-nint': ['-1'] * N2 + [2] * N2,\n                 'datetime64': np.repeat(np.array(['1970-01-01', '1970-01-02'],\n                                                  dtype='datetime64[D]'), N),\n                 'string-float': ['1.1'] * N2 + [2] * N2,\n                 'int-list': [1] * N2 + [2] * N2,\n                 'int32': np.repeat(np.int32(1), N)}\n\n    def setup(self, dtype, downcast):\n        self.data = self.data_dict[dtype]\n\n    def time_downcast(self, dtype, downcast):\n        to_numeric(self.data, downcast=downcast)\n\n\nclass MaybeConvertNumeric(object):\n\n    def setup_cache(self):\n        N = 10**6\n        arr = np.repeat([2**63], N) + np.arange(N).astype('uint64')\n        data = arr.astype(object)\n        data[1::2] = arr[1::2].astype(str)\n        data[-1] = -1\n        return data\n\n    def time_convert(self, data):\n        lib.maybe_convert_numeric(data, set(), coerce_numeric=False)\n", "description": "Flexible and powerful data analysis / manipulation library for Python, providing labeled data structures similar to R data.frame objects, statistical functions, and much more", "file_name": "inference.py", "id": "001150b1511146e2411bdb6cda2f5c53", "language": "Python", "project_name": "pandas", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/pandas-dev-pandas/pandas-dev-pandas-3783ccc/asv_bench/benchmarks/inference.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:47:21Z", "url": "https://github.com/pandas-dev/pandas", "wiki": true}