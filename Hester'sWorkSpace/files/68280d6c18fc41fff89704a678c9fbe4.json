{"author": "ansible", "code": "\n\n Copyright: Ansible Project\n GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = \"\"\"\n---\nmodule: ordnance_facts\nversion_added: \"2.3\"\nauthor: \"Alexander Turner (alex.turner@ordnance.io)\"\nshort_description: Collect facts from Ordnance Virtual Routers over SSH\ndescription:\n  - Collects a base set of device facts from an Ordnance Virtual\n    router over SSH. This module prepends all of the\n    base network fact keys with C(ansible_net_<fact>).  The facts\n    module will always collect a base set of facts from the device\n    and can enable or disable collection of additional facts.\noptions:\n  gather_subset:\n    description:\n      - When supplied, this argument will restrict the facts collected\n        to a given subset.  Possible values for this argument include\n        all, hardware, config, and interfaces.  Can specify a list of\n        values to include a larger subset.  Values can also be used\n        with an initial C(M(!)) to specify that a specific subset should\n        not be collected.\n    required: false\n    default: '!config'\n\"\"\"\n\nEXAMPLES = \"\"\"\n---\n Note: examples below use the following provider dict to handle\n       transport and authentication to the node.\nvars:\n  cli:\n    host: \"{{ inventory_hostname }}\"\n    username: RouterName\n    password: ordnance\n    transport: cli\n\n---\n Collect all facts from the device\n- ordnance_facts:\n    gather_subset: all\n    provider: \"{{ cli }}\"\n\n Collect only the config and default facts\n- ordnance_facts:\n    gather_subset:\n      - config\n    provider: \"{{ cli }}\"\n\n Do not collect hardware facts\n- ordnance_facts:\n    gather_subset:\n      - \"!hardware\"\n    provider: \"{{ cli }}\"\n\"\"\"\n\nRETURN = \"\"\"\nansible_net_gather_subset:\n  description: The list of fact subsets collected from the virtual router\n  returned: always\n  type: list\n\n config\nansible_net_config:\n  description: The current active config from the virtual router\n  returned: when config is configured\n  type: str\n\n interfaces\nansible_net_all_ipv4_addresses:\n  description: All IPv4 addresses configured on the virtual router\n  returned: when interfaces is configured\n  type: list\nansible_net_all_ipv6_addresses:\n  description: All IPv6 addresses configured on the virtual router\n  returned: when interfaces is configured\n  type: list\nansible_net_interfaces:\n  description: A hash of all interfaces running on the virtual router\n  returned: when interfaces is configured\n  type: dict\n\"\"\"\nimport re\nimport traceback\n\nfrom ansible.module_utils.network.common.network import NetworkModule\nfrom ansible.module_utils.six import iteritems\nfrom ansible.module_utils.six.moves import zip\nfrom ansible.module_utils._text import to_native\n\n\nclass FactsBase(object):\n\n    def __init__(self, module):\n        self.module = module\n        self.facts = dict()\n        self.failed_commands = list()\n\n    def run(self, cmd):\n        try:\n            return self.module.cli(cmd)[0]\n        except:\n            self.failed_commands.append(cmd)\n\n\nclass Config(FactsBase):\n\n    def populate(self):\n        data = self.run('show running-config')\n        if data:\n            self.facts['config'] = data\n\n\nclass Interfaces(FactsBase):\n\n    def populate(self):\n        self.facts['all_ipv4_addresses'] = list()\n        self.facts['all_ipv6_addresses'] = list()\n\n        data = self.run('show interfaces')\n        if data:\n            interfaces = self.parse_interfaces(data)\n            self.facts['interfaces'] = self.populate_interfaces(interfaces)\n\n        data = self.run('show ipv6 interface')\n        if data:\n            data = self.parse_interfaces(data)\n            self.populate_ipv6_interfaces(data)\n\n    def populate_interfaces(self, interfaces):\n        facts = dict()\n        for key, value in iteritems(interfaces):\n            intf = dict()\n            intf['description'] = self.parse_description(value)\n            intf['macaddress'] = self.parse_macaddress(value)\n\n            ipv4 = self.parse_ipv4(value)\n            intf['ipv4'] = self.parse_ipv4(value)\n            if ipv4:\n                self.add_ip_address(ipv4['address'], 'ipv4')\n\n            intf['duplex'] = self.parse_duplex(value)\n            intf['operstatus'] = self.parse_operstatus(value)\n            intf['type'] = self.parse_type(value)\n\n            facts[key] = intf\n        return facts\n\n    def populate_ipv6_interfaces(self, data):\n        for key, value in iteritems(data):\n            self.facts['interfaces'][key]['ipv6'] = list()\n            addresses = re.findall(r'\\s+(.+), subnet', value, re.M)\n            subnets = re.findall(r', subnet is (.+)$', value, re.M)\n            for addr, subnet in zip(addresses, subnets):\n                ipv6 = dict(address=addr.strip(), subnet=subnet.strip())\n                self.add_ip_address(addr.strip(), 'ipv6')\n                self.facts['interfaces'][key]['ipv6'].append(ipv6)\n\n    def add_ip_address(self, address, family):\n        if family == 'ipv4':\n            self.facts['all_ipv4_addresses'].append(address)\n        else:\n            self.facts['all_ipv6_addresses'].append(address)\n\n    def parse_interfaces(self, data):\n        parsed = dict()\n        key = ''\n        for line in data.split('\\n'):\n            if len(line) == 0:\n                continue\n            elif line[0] == ' ':\n                parsed[key] += '\\n%s' % line\n            else:\n                match = re.match(r'^(\\S+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed[key] = line\n        return parsed\n\n    def parse_description(self, data):\n        match = re.search(r'Description: (.+)$', data, re.M)\n        if match:\n            return match.group(1)\n\n    def parse_macaddress(self, data):\n        match = re.search(r'address is (\\S+)', data)\n        if match:\n            return match.group(1)\n\n    def parse_ipv4(self, data):\n        match = re.search(r'Internet address is (\\S+)', data)\n        if match:\n            addr, masklen = match.group(1).split('/')\n            return dict(address=addr, masklen=int(masklen))\n\n    def parse_duplex(self, data):\n        match = re.search(r'(\\w+) Duplex', data, re.M)\n        if match:\n            return match.group(1)\n\n    def parse_operstatus(self, data):\n        match = re.search(r'^(?:.+) is (.+),', data, re.M)\n        if match:\n            return match.group(1)\n\nFACT_SUBSETS = dict(\n    interfaces=Interfaces,\n    config=Config,\n)\n\nVALID_SUBSETS = frozenset(FACT_SUBSETS.keys())\n\n\ndef main():\n    spec = dict(\n        gather_subset=dict(default=['!config'], type='list')\n    )\n\n    module = NetworkModule(argument_spec=spec, supports_check_mode=True)\n\n    gather_subset = module.params['gather_subset']\n\n    runable_subsets = set()\n    exclude_subsets = set()\n\n    for subset in gather_subset:\n        if subset == 'all':\n            runable_subsets.update(VALID_SUBSETS)\n            continue\n\n        if subset.startswith('!'):\n            subset = subset[1:]\n            if subset == 'all':\n                exclude_subsets.update(VALID_SUBSETS)\n                continue\n            exclude = True\n        else:\n            exclude = False\n\n        if subset not in VALID_SUBSETS:\n            module.fail_json(msg='Bad subset')\n\n        if exclude:\n            exclude_subsets.add(subset)\n        else:\n            runable_subsets.add(subset)\n\n    if not runable_subsets:\n        runable_subsets.update(VALID_SUBSETS)\n\n    runable_subsets.difference_update(exclude_subsets)\n    runable_subsets.add('default')\n\n    facts = dict()\n    facts['gather_subset'] = list(runable_subsets)\n\n    instances = list()\n    for key in runable_subsets:\n        instances.append(FACT_SUBSETS[key](module))\n\n    failed_commands = list()\n\n    try:\n        for inst in instances:\n            inst.populate()\n            failed_commands.extend(inst.failed_commands)\n            facts.update(inst.facts)\n    except Exception as exc:\n        module.fail_json(msg=to_native(exc), exception=traceback.format_exc())\n\n    ansible_facts = dict()\n    for key, value in iteritems(facts):\n        key = 'ansible_net_%s' % key\n        ansible_facts[key] = value\n\n    module.exit_json(ansible_facts=ansible_facts, failed_commands=failed_commands)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  ordnance facts version added   2 3  author   alexander turner (alex turner ordnance io)  short description  collect facts ordnance virtual routers ssh description      collects base set device facts ordnance virtual     router ssh  this module prepends     base network fact keys c(ansible net  fact )   the facts     module always collect base set facts device     enable disable collection additional facts  options    gather subset      description          when supplied  argument restrict facts collected         given subset   possible values argument include          hardware  config  interfaces   can specify list         values include larger subset   values also used         initial c(m( )) specify specific subset         collected      required  false     default    config       examples             note  examples use following provider dict handle         transport authentication node  vars    cli      host      inventory hostname         username  routername     password  ordnance     transport  cli        collect facts device   ordnance facts      gather subset      provider      cli        collect config default facts   ordnance facts      gather subset          config     provider      cli        do collect hardware facts   ordnance facts      gather subset            hardware      provider      cli          return       ansible net gather subset    description  the list fact subsets collected virtual router   returned  always   type  list    config ansible net config    description  the current active config virtual router   returned  config configured   type  str    interfaces ansible net ipv4 addresses    description  all ipv4 addresses configured virtual router   returned  interfaces configured   type  list ansible net ipv6 addresses    description  all ipv6 addresses configured virtual router   returned  interfaces configured   type  list ansible net interfaces    description  a hash interfaces running virtual router   returned  interfaces configured   type  dict         usr bin python       copyright  ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    note  examples use following provider dict handle          transport authentication node     collect facts device    collect config default facts    do collect hardware facts    config    interfaces ", "content": "#!/usr/bin/python\n#\n# Copyright: Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = \"\"\"\n---\nmodule: ordnance_facts\nversion_added: \"2.3\"\nauthor: \"Alexander Turner (alex.turner@ordnance.io)\"\nshort_description: Collect facts from Ordnance Virtual Routers over SSH\ndescription:\n  - Collects a base set of device facts from an Ordnance Virtual\n    router over SSH. This module prepends all of the\n    base network fact keys with C(ansible_net_<fact>).  The facts\n    module will always collect a base set of facts from the device\n    and can enable or disable collection of additional facts.\noptions:\n  gather_subset:\n    description:\n      - When supplied, this argument will restrict the facts collected\n        to a given subset.  Possible values for this argument include\n        all, hardware, config, and interfaces.  Can specify a list of\n        values to include a larger subset.  Values can also be used\n        with an initial C(M(!)) to specify that a specific subset should\n        not be collected.\n    required: false\n    default: '!config'\n\"\"\"\n\nEXAMPLES = \"\"\"\n---\n# Note: examples below use the following provider dict to handle\n#       transport and authentication to the node.\nvars:\n  cli:\n    host: \"{{ inventory_hostname }}\"\n    username: RouterName\n    password: ordnance\n    transport: cli\n\n---\n# Collect all facts from the device\n- ordnance_facts:\n    gather_subset: all\n    provider: \"{{ cli }}\"\n\n# Collect only the config and default facts\n- ordnance_facts:\n    gather_subset:\n      - config\n    provider: \"{{ cli }}\"\n\n# Do not collect hardware facts\n- ordnance_facts:\n    gather_subset:\n      - \"!hardware\"\n    provider: \"{{ cli }}\"\n\"\"\"\n\nRETURN = \"\"\"\nansible_net_gather_subset:\n  description: The list of fact subsets collected from the virtual router\n  returned: always\n  type: list\n\n# config\nansible_net_config:\n  description: The current active config from the virtual router\n  returned: when config is configured\n  type: str\n\n# interfaces\nansible_net_all_ipv4_addresses:\n  description: All IPv4 addresses configured on the virtual router\n  returned: when interfaces is configured\n  type: list\nansible_net_all_ipv6_addresses:\n  description: All IPv6 addresses configured on the virtual router\n  returned: when interfaces is configured\n  type: list\nansible_net_interfaces:\n  description: A hash of all interfaces running on the virtual router\n  returned: when interfaces is configured\n  type: dict\n\"\"\"\nimport re\nimport traceback\n\nfrom ansible.module_utils.network.common.network import NetworkModule\nfrom ansible.module_utils.six import iteritems\nfrom ansible.module_utils.six.moves import zip\nfrom ansible.module_utils._text import to_native\n\n\nclass FactsBase(object):\n\n    def __init__(self, module):\n        self.module = module\n        self.facts = dict()\n        self.failed_commands = list()\n\n    def run(self, cmd):\n        try:\n            return self.module.cli(cmd)[0]\n        except:\n            self.failed_commands.append(cmd)\n\n\nclass Config(FactsBase):\n\n    def populate(self):\n        data = self.run('show running-config')\n        if data:\n            self.facts['config'] = data\n\n\nclass Interfaces(FactsBase):\n\n    def populate(self):\n        self.facts['all_ipv4_addresses'] = list()\n        self.facts['all_ipv6_addresses'] = list()\n\n        data = self.run('show interfaces')\n        if data:\n            interfaces = self.parse_interfaces(data)\n            self.facts['interfaces'] = self.populate_interfaces(interfaces)\n\n        data = self.run('show ipv6 interface')\n        if data:\n            data = self.parse_interfaces(data)\n            self.populate_ipv6_interfaces(data)\n\n    def populate_interfaces(self, interfaces):\n        facts = dict()\n        for key, value in iteritems(interfaces):\n            intf = dict()\n            intf['description'] = self.parse_description(value)\n            intf['macaddress'] = self.parse_macaddress(value)\n\n            ipv4 = self.parse_ipv4(value)\n            intf['ipv4'] = self.parse_ipv4(value)\n            if ipv4:\n                self.add_ip_address(ipv4['address'], 'ipv4')\n\n            intf['duplex'] = self.parse_duplex(value)\n            intf['operstatus'] = self.parse_operstatus(value)\n            intf['type'] = self.parse_type(value)\n\n            facts[key] = intf\n        return facts\n\n    def populate_ipv6_interfaces(self, data):\n        for key, value in iteritems(data):\n            self.facts['interfaces'][key]['ipv6'] = list()\n            addresses = re.findall(r'\\s+(.+), subnet', value, re.M)\n            subnets = re.findall(r', subnet is (.+)$', value, re.M)\n            for addr, subnet in zip(addresses, subnets):\n                ipv6 = dict(address=addr.strip(), subnet=subnet.strip())\n                self.add_ip_address(addr.strip(), 'ipv6')\n                self.facts['interfaces'][key]['ipv6'].append(ipv6)\n\n    def add_ip_address(self, address, family):\n        if family == 'ipv4':\n            self.facts['all_ipv4_addresses'].append(address)\n        else:\n            self.facts['all_ipv6_addresses'].append(address)\n\n    def parse_interfaces(self, data):\n        parsed = dict()\n        key = ''\n        for line in data.split('\\n'):\n            if len(line) == 0:\n                continue\n            elif line[0] == ' ':\n                parsed[key] += '\\n%s' % line\n            else:\n                match = re.match(r'^(\\S+)', line)\n                if match:\n                    key = match.group(1)\n                    parsed[key] = line\n        return parsed\n\n    def parse_description(self, data):\n        match = re.search(r'Description: (.+)$', data, re.M)\n        if match:\n            return match.group(1)\n\n    def parse_macaddress(self, data):\n        match = re.search(r'address is (\\S+)', data)\n        if match:\n            return match.group(1)\n\n    def parse_ipv4(self, data):\n        match = re.search(r'Internet address is (\\S+)', data)\n        if match:\n            addr, masklen = match.group(1).split('/')\n            return dict(address=addr, masklen=int(masklen))\n\n    def parse_duplex(self, data):\n        match = re.search(r'(\\w+) Duplex', data, re.M)\n        if match:\n            return match.group(1)\n\n    def parse_operstatus(self, data):\n        match = re.search(r'^(?:.+) is (.+),', data, re.M)\n        if match:\n            return match.group(1)\n\nFACT_SUBSETS = dict(\n    interfaces=Interfaces,\n    config=Config,\n)\n\nVALID_SUBSETS = frozenset(FACT_SUBSETS.keys())\n\n\ndef main():\n    spec = dict(\n        gather_subset=dict(default=['!config'], type='list')\n    )\n\n    module = NetworkModule(argument_spec=spec, supports_check_mode=True)\n\n    gather_subset = module.params['gather_subset']\n\n    runable_subsets = set()\n    exclude_subsets = set()\n\n    for subset in gather_subset:\n        if subset == 'all':\n            runable_subsets.update(VALID_SUBSETS)\n            continue\n\n        if subset.startswith('!'):\n            subset = subset[1:]\n            if subset == 'all':\n                exclude_subsets.update(VALID_SUBSETS)\n                continue\n            exclude = True\n        else:\n            exclude = False\n\n        if subset not in VALID_SUBSETS:\n            module.fail_json(msg='Bad subset')\n\n        if exclude:\n            exclude_subsets.add(subset)\n        else:\n            runable_subsets.add(subset)\n\n    if not runable_subsets:\n        runable_subsets.update(VALID_SUBSETS)\n\n    runable_subsets.difference_update(exclude_subsets)\n    runable_subsets.add('default')\n\n    facts = dict()\n    facts['gather_subset'] = list(runable_subsets)\n\n    instances = list()\n    for key in runable_subsets:\n        instances.append(FACT_SUBSETS[key](module))\n\n    failed_commands = list()\n\n    try:\n        for inst in instances:\n            inst.populate()\n            failed_commands.extend(inst.failed_commands)\n            facts.update(inst.facts)\n    except Exception as exc:\n        module.fail_json(msg=to_native(exc), exception=traceback.format_exc())\n\n    ansible_facts = dict()\n    for key, value in iteritems(facts):\n        key = 'ansible_net_%s' % key\n        ansible_facts[key] = value\n\n    module.exit_json(ansible_facts=ansible_facts, failed_commands=failed_commands)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "ordnance_facts.py", "id": "68280d6c18fc41fff89704a678c9fbe4", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/network/ordnance/ordnance_facts.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}