{"author": "sympy", "code": "from sympy import (pi, sin, cos, Symbol, Integral, Sum, sqrt, log,\n                   oo, LambertW, I, meijerg, exp_polar, Max, Piecewise, And)\nfrom sympy.plotting import (plot, plot_parametric, plot3d_parametric_line,\n                            plot3d, plot3d_parametric_surface)\nfrom sympy.plotting.plot import unset_show\nfrom sympy.utilities import lambdify as lambdify_\nfrom sympy.utilities.pytest import skip, raises\nfrom sympy.plotting.experimental_lambdify import lambdify\nfrom sympy.external import import_module\n\nfrom tempfile import NamedTemporaryFile\nimport os\nimport warnings\n\nunset_show()\n\n\n\n# That would need rewriting the plot_and_save() function\n\nclass TmpFileManager:\n\n    tmp_files = []\n\n    @classmethod\n    def tmp_file(cls, name=''):\n        cls.tmp_files.append(NamedTemporaryFile(prefix=name, suffix='.png').name)\n        return cls.tmp_files[-1]\n\n    @classmethod\n    def cleanup(cls):\n        map(os.remove, cls.tmp_files)\n\ndef plot_and_save(name):\n    tmp_file = TmpFileManager.tmp_file\n\n    x = Symbol('x')\n    y = Symbol('y')\n    z = Symbol('z')\n\n    \n    \n    \n\n    p = plot(x)\n    p = plot(x*sin(x), x*cos(x))\n    p.extend(p)\n    p[0].line_color = lambda a: a\n    p[1].line_color = 'b'\n    p.title = 'Big title'\n    p.xlabel = 'the x axis'\n    p[1].label = 'straight line'\n    p.legend = True\n    p.aspect_ratio = (1, 1)\n    p.xlim = (-15, 20)\n    p.save(tmp_file('%s_basic_options_and_colors' % name))\n    p._backend.close()\n\n    p.extend(plot(x + 1))\n    p.append(plot(x + 3, x**2)[1])\n    p.save(tmp_file('%s_plot_extend_append' % name))\n\n    p[2] = plot(x**2, (x, -2, 3))\n    p.save(tmp_file('%s_plot_setitem' % name))\n    p._backend.close()\n\n    p = plot(sin(x), (x, -2*pi, 4*pi))\n    p.save(tmp_file('%s_line_explicit' % name))\n    p._backend.close()\n\n    p = plot(sin(x))\n    p.save(tmp_file('%s_line_default_range' % name))\n    p._backend.close()\n\n    p = plot((x**2, (x, -5, 5)), (x**3, (x, -3, 3)))\n    p.save(tmp_file('%s_line_multiple_range' % name))\n    p._backend.close()\n\n    raises(ValueError, lambda: plot(x, y))\n\n    \n    p = plot(Piecewise((1, x > 0), (0, True)), (x, -1, 1))\n    p.save(tmp_file('%s_plot_piecewise' % name))\n    p._backend.close()\n\n    p = plot(Piecewise((x, x < 1), (x**2, True)), (x, -3, 3))\n    p.save(tmp_file('%s_plot_piecewise_2' % name))\n    p._backend.close()\n\n    \n    p1 = plot(x)\n    p2 = plot(3)\n    p1.extend(p2)\n    p.save(tmp_file('%s_horizontal_line' % name))\n    p._backend.close()\n\n    \n    f = Piecewise((-1, x < -1), (x, And(-1 <= x, x < 0)), \\\n        (x**2, And(0 <= x, x < 1)), (x**3, x >= 1))\n    p = plot(f, (x, -3, 3))\n    p.save(tmp_file('%s_plot_piecewise_3' % name))\n    p._backend.close()\n\n    \n    \n    plot_parametric(sin(x), cos(x)).save(tmp_file())\n\n    \n    p = plot_parametric(sin(x), cos(x), (x, -5, 5))\n    p.save(tmp_file('%s_parametric_range' % name))\n    p._backend.close()\n\n    \n    p = plot_parametric((sin(x), cos(x)), (x, sin(x)))\n    p.save(tmp_file('%s_parametric_multiple' % name))\n    p._backend.close()\n\n    \n    p = plot_parametric((sin(x), cos(x), (x, -3, 3)), (x, sin(x), (x, -5, 5)))\n    p.save(tmp_file('%s_parametric_multiple_ranges' % name))\n    p._backend.close()\n\n    \n    p = plot_parametric(x, sin(x), depth=13)\n    p.save(tmp_file('%s_recursion_depth' % name))\n    p._backend.close()\n\n    \n    p = plot_parametric(cos(x), sin(x), adaptive=False, nb_of_points=500)\n    p.save(tmp_file('%s_adaptive' % name))\n    p._backend.close()\n\n    \n    p = plot3d_parametric_line(sin(x), cos(x), x)\n    p.save(tmp_file('%s_3d_line' % name))\n    p._backend.close()\n\n    p = plot3d_parametric_line(\n        (sin(x), cos(x), x, (x, -5, 5)), (cos(x), sin(x), x, (x, -3, 3)))\n    p.save(tmp_file('%s_3d_line_multiple' % name))\n    p._backend.close()\n\n    p = plot3d_parametric_line(sin(x), cos(x), x, nb_of_points=30)\n    p.save(tmp_file('%s_3d_line_points' % name))\n    p._backend.close()\n\n    \n    p = plot3d(x * y)\n    p.save(tmp_file('%s_surface' % name))\n    p._backend.close()\n\n    \n    p = plot3d(-x * y, x * y, (x, -5, 5))\n    p.save(tmp_file('%s_surface_multiple' % name))\n    p._backend.close()\n\n    \n    p = plot3d(\n        (x * y, (x, -3, 3), (y, -3, 3)), (-x * y, (x, -3, 3), (y, -3, 3)))\n    p.save(tmp_file('%s_surface_multiple_ranges' % name))\n    p._backend.close()\n\n    \n    p = plot3d_parametric_surface(sin(x + y), cos(x - y), x - y)\n    p.save(tmp_file('%s_parametric_surface' % name))\n    p._backend.close()\n\n    \n    p = plot3d_parametric_surface(\n        (x*sin(z), x*cos(z), z, (x, -5, 5), (z, -5, 5)),\n        (sin(x + y), cos(x - y), x - y, (x, -5, 5), (y, -5, 5)))\n    p.save(tmp_file('%s_parametric_surface' % name))\n    p._backend.close()\n\n    \n    \n    \n\n    p = plot(sin(x))\n    p[0].line_color = lambda a: a\n    p.save(tmp_file('%s_colors_line_arity1' % name))\n\n    p[0].line_color = lambda a, b: b\n    p.save(tmp_file('%s_colors_line_arity2' % name))\n    p._backend.close()\n\n    p = plot(x*sin(x), x*cos(x), (x, 0, 10))\n    p[0].line_color = lambda a: a\n    p.save(tmp_file('%s_colors_param_line_arity1' % name))\n\n    p[0].line_color = lambda a, b: a\n    p.save(tmp_file('%s_colors_param_line_arity2a' % name))\n\n    p[0].line_color = lambda a, b: b\n    p.save(tmp_file('%s_colors_param_line_arity2b' % name))\n    p._backend.close()\n\n    p = plot3d_parametric_line(sin(x) + 0.1*sin(x)*cos(7*x),\n             cos(x) + 0.1*cos(x)*cos(7*x),\n        0.1*sin(7*x),\n        (x, 0, 2*pi))\n    p[0].line_color = lambdify_(x, sin(4*x))\n    p.save(tmp_file('%s_colors_3d_line_arity1' % name))\n    p[0].line_color = lambda a, b: b\n    p.save(tmp_file('%s_colors_3d_line_arity2' % name))\n    p[0].line_color = lambda a, b, c: c\n    p.save(tmp_file('%s_colors_3d_line_arity3' % name))\n    p._backend.close()\n\n    p = plot3d(sin(x)*y, (x, 0, 6*pi), (y, -5, 5))\n    p[0].surface_color = lambda a: a\n    p.save(tmp_file('%s_colors_surface_arity1' % name))\n    p[0].surface_color = lambda a, b: b\n    p.save(tmp_file('%s_colors_surface_arity2' % name))\n    p[0].surface_color = lambda a, b, c: c\n    p.save(tmp_file('%s_colors_surface_arity3a' % name))\n    p[0].surface_color = lambdify_((x, y, z), sqrt((x - 3*pi)**2 + y**2))\n    p.save(tmp_file('%s_colors_surface_arity3b' % name))\n    p._backend.close()\n\n    p = plot3d_parametric_surface(x * cos(4 * y), x * sin(4 * y), y,\n             (x, -1, 1), (y, -1, 1))\n    p[0].surface_color = lambda a: a\n    p.save(tmp_file('%s_colors_param_surf_arity1' % name))\n    p[0].surface_color = lambda a, b: a*b\n    p.save(tmp_file('%s_colors_param_surf_arity2' % name))\n    p[0].surface_color = lambdify_((x, y, z), sqrt(x**2 + y**2 + z**2))\n    p.save(tmp_file('%s_colors_param_surf_arity3' % name))\n    p._backend.close()\n\n    \n    \n    \n\n    \n    \n    ()\n    \n    \n\n    with warnings.catch_warnings(record=True) as w:\n        i = Integral(log((sin(x)**2 + 1)*sqrt(x**2 + 1)), (x, 0, y))\n        p = plot(i, (y, 1, 5))\n        p.save(tmp_file('%s_advanced_integral' % name))\n        p._backend.close()\n        \n        for i in w:\n            assert issubclass(i.category, UserWarning)\n            assert \"The evaluation of the expression is problematic\" in str(i.message)\n\n    s = Sum(1/x**y, (x, 1, oo))\n    p = plot(s, (y, 2, 10))\n    p.save(tmp_file('%s_advanced_inf_sum' % name))\n    p._backend.close()\n\n    p = plot(Sum(1/x, (x, 1, y)), (y, 2, 10), show=False)\n    p[0].only_integers = True\n    p[0].steps = True\n    p.save(tmp_file('%s_advanced_fin_sum' % name))\n    p._backend.close()\n\n    \n    \n    \n    \n    plot(sin(x) + I*cos(x)).save(tmp_file())\n    plot(sqrt(sqrt(-x))).save(tmp_file())\n    plot(LambertW(x)).save(tmp_file())\n    plot(sqrt(LambertW(x))).save(tmp_file())\n\n    \n    plot((meijerg(((1 / 2,), ()), ((5, 0, 1 / 2), ()), 5 * x**2 * exp_polar(-I*pi)/2)\n            + meijerg(((1/2,), ()), ((5, 0, 1/2), ()),\n                5*x**2 * exp_polar(I*pi)/2)) / (48 * pi), (x, 1e-6, 1e-2)).save(tmp_file())\n\ndef test_matplotlib():\n\n    matplotlib = import_module('matplotlib', min_module_version='1.1.0', catch=(RuntimeError,))\n    if matplotlib:\n        try:\n            plot_and_save('test')\n        finally:\n            \n            TmpFileManager.cleanup()\n    else:\n        skip(\"Matplotlib not the default backend\")\n\n\ndef test_experimental_lambify():\n    x = Symbol('x')\n    f = lambdify([x], Max(x, 5))\n    # XXX should f be tested? If f(2) is attempted, an\n    \n    \n    assert Max(2, 5) == 5\n    assert Max(5, 7) == 7\n\n    x = Symbol('x-3')\n    f = lambdify([x], x + 1)\n    assert f(1) == 2\n\n\ndef test_append_issue_7140():\n    matplotlib = import_module('matplotlib', min_module_version='1.1.0', catch=(RuntimeError,))\n    if not matplotlib:\n        skip(\"Matplotlib not the default backend\")\n\n    x = Symbol('x')\n    p1 = plot(x)\n    p2 = plot(x**2)\n    p3 = plot(x + 2)\n\n    \n    p2.append(p1[0])\n    assert len(p2._series) == 2\n\n    with raises(TypeError):\n        p1.append(p2)\n\n    with raises(TypeError):\n        p1.append(p2._series)\n", "comments": "  xxx  we could implement context manager instead    that would need rewriting plot save() function    entirely         examples  introduction  notebook        piecewise plots    test issue 7471    test issue 10925   parametric 2d plots    single plot default range    single plot range    multiple plots range    multiple plots different ranges    depth recursion specified    no adaptive sampling    3d parametric plots    3d surface single plot     multiple 3d plots range     multiple 3d plots different ranges     single parametric 3d plot    multiple parametric 3d plots          examples  colors  notebook              examples  advanced  notebook         xxx  this raises warning  the evaluation expression    problematic  we trying failback method may still work  please    report bug   it use fallback using evalf()    way evaluate integral  we perhaps remove    warning     make sure warnings raised         test expressions translated np generate complex    results         characteristic function studentt distribution nu 10    clean    tests exception handling experimental lambdify    xxx f tested  if f(2) attempted     error raised complex produced wrapping arg    compared int     append series ", "content": "from sympy import (pi, sin, cos, Symbol, Integral, Sum, sqrt, log,\n                   oo, LambertW, I, meijerg, exp_polar, Max, Piecewise, And)\nfrom sympy.plotting import (plot, plot_parametric, plot3d_parametric_line,\n                            plot3d, plot3d_parametric_surface)\nfrom sympy.plotting.plot import unset_show\nfrom sympy.utilities import lambdify as lambdify_\nfrom sympy.utilities.pytest import skip, raises\nfrom sympy.plotting.experimental_lambdify import lambdify\nfrom sympy.external import import_module\n\nfrom tempfile import NamedTemporaryFile\nimport os\nimport warnings\n\nunset_show()\n\n\n# XXX: We could implement this as a context manager instead\n# That would need rewriting the plot_and_save() function\n# entirely\nclass TmpFileManager:\n\n    tmp_files = []\n\n    @classmethod\n    def tmp_file(cls, name=''):\n        cls.tmp_files.append(NamedTemporaryFile(prefix=name, suffix='.png').name)\n        return cls.tmp_files[-1]\n\n    @classmethod\n    def cleanup(cls):\n        map(os.remove, cls.tmp_files)\n\ndef plot_and_save(name):\n    tmp_file = TmpFileManager.tmp_file\n\n    x = Symbol('x')\n    y = Symbol('y')\n    z = Symbol('z')\n\n    ###\n    # Examples from the 'introduction' notebook\n    ###\n\n    p = plot(x)\n    p = plot(x*sin(x), x*cos(x))\n    p.extend(p)\n    p[0].line_color = lambda a: a\n    p[1].line_color = 'b'\n    p.title = 'Big title'\n    p.xlabel = 'the x axis'\n    p[1].label = 'straight line'\n    p.legend = True\n    p.aspect_ratio = (1, 1)\n    p.xlim = (-15, 20)\n    p.save(tmp_file('%s_basic_options_and_colors' % name))\n    p._backend.close()\n\n    p.extend(plot(x + 1))\n    p.append(plot(x + 3, x**2)[1])\n    p.save(tmp_file('%s_plot_extend_append' % name))\n\n    p[2] = plot(x**2, (x, -2, 3))\n    p.save(tmp_file('%s_plot_setitem' % name))\n    p._backend.close()\n\n    p = plot(sin(x), (x, -2*pi, 4*pi))\n    p.save(tmp_file('%s_line_explicit' % name))\n    p._backend.close()\n\n    p = plot(sin(x))\n    p.save(tmp_file('%s_line_default_range' % name))\n    p._backend.close()\n\n    p = plot((x**2, (x, -5, 5)), (x**3, (x, -3, 3)))\n    p.save(tmp_file('%s_line_multiple_range' % name))\n    p._backend.close()\n\n    raises(ValueError, lambda: plot(x, y))\n\n    #Piecewise plots\n    p = plot(Piecewise((1, x > 0), (0, True)), (x, -1, 1))\n    p.save(tmp_file('%s_plot_piecewise' % name))\n    p._backend.close()\n\n    p = plot(Piecewise((x, x < 1), (x**2, True)), (x, -3, 3))\n    p.save(tmp_file('%s_plot_piecewise_2' % name))\n    p._backend.close()\n\n    # test issue 7471\n    p1 = plot(x)\n    p2 = plot(3)\n    p1.extend(p2)\n    p.save(tmp_file('%s_horizontal_line' % name))\n    p._backend.close()\n\n    # test issue 10925\n    f = Piecewise((-1, x < -1), (x, And(-1 <= x, x < 0)), \\\n        (x**2, And(0 <= x, x < 1)), (x**3, x >= 1))\n    p = plot(f, (x, -3, 3))\n    p.save(tmp_file('%s_plot_piecewise_3' % name))\n    p._backend.close()\n\n    #parametric 2d plots.\n    #Single plot with default range.\n    plot_parametric(sin(x), cos(x)).save(tmp_file())\n\n    #Single plot with range.\n    p = plot_parametric(sin(x), cos(x), (x, -5, 5))\n    p.save(tmp_file('%s_parametric_range' % name))\n    p._backend.close()\n\n    #Multiple plots with same range.\n    p = plot_parametric((sin(x), cos(x)), (x, sin(x)))\n    p.save(tmp_file('%s_parametric_multiple' % name))\n    p._backend.close()\n\n    #Multiple plots with different ranges.\n    p = plot_parametric((sin(x), cos(x), (x, -3, 3)), (x, sin(x), (x, -5, 5)))\n    p.save(tmp_file('%s_parametric_multiple_ranges' % name))\n    p._backend.close()\n\n    #depth of recursion specified.\n    p = plot_parametric(x, sin(x), depth=13)\n    p.save(tmp_file('%s_recursion_depth' % name))\n    p._backend.close()\n\n    #No adaptive sampling.\n    p = plot_parametric(cos(x), sin(x), adaptive=False, nb_of_points=500)\n    p.save(tmp_file('%s_adaptive' % name))\n    p._backend.close()\n\n    #3d parametric plots\n    p = plot3d_parametric_line(sin(x), cos(x), x)\n    p.save(tmp_file('%s_3d_line' % name))\n    p._backend.close()\n\n    p = plot3d_parametric_line(\n        (sin(x), cos(x), x, (x, -5, 5)), (cos(x), sin(x), x, (x, -3, 3)))\n    p.save(tmp_file('%s_3d_line_multiple' % name))\n    p._backend.close()\n\n    p = plot3d_parametric_line(sin(x), cos(x), x, nb_of_points=30)\n    p.save(tmp_file('%s_3d_line_points' % name))\n    p._backend.close()\n\n    # 3d surface single plot.\n    p = plot3d(x * y)\n    p.save(tmp_file('%s_surface' % name))\n    p._backend.close()\n\n    # Multiple 3D plots with same range.\n    p = plot3d(-x * y, x * y, (x, -5, 5))\n    p.save(tmp_file('%s_surface_multiple' % name))\n    p._backend.close()\n\n    # Multiple 3D plots with different ranges.\n    p = plot3d(\n        (x * y, (x, -3, 3), (y, -3, 3)), (-x * y, (x, -3, 3), (y, -3, 3)))\n    p.save(tmp_file('%s_surface_multiple_ranges' % name))\n    p._backend.close()\n\n    # Single Parametric 3D plot\n    p = plot3d_parametric_surface(sin(x + y), cos(x - y), x - y)\n    p.save(tmp_file('%s_parametric_surface' % name))\n    p._backend.close()\n\n    # Multiple Parametric 3D plots.\n    p = plot3d_parametric_surface(\n        (x*sin(z), x*cos(z), z, (x, -5, 5), (z, -5, 5)),\n        (sin(x + y), cos(x - y), x - y, (x, -5, 5), (y, -5, 5)))\n    p.save(tmp_file('%s_parametric_surface' % name))\n    p._backend.close()\n\n    ###\n    # Examples from the 'colors' notebook\n    ###\n\n    p = plot(sin(x))\n    p[0].line_color = lambda a: a\n    p.save(tmp_file('%s_colors_line_arity1' % name))\n\n    p[0].line_color = lambda a, b: b\n    p.save(tmp_file('%s_colors_line_arity2' % name))\n    p._backend.close()\n\n    p = plot(x*sin(x), x*cos(x), (x, 0, 10))\n    p[0].line_color = lambda a: a\n    p.save(tmp_file('%s_colors_param_line_arity1' % name))\n\n    p[0].line_color = lambda a, b: a\n    p.save(tmp_file('%s_colors_param_line_arity2a' % name))\n\n    p[0].line_color = lambda a, b: b\n    p.save(tmp_file('%s_colors_param_line_arity2b' % name))\n    p._backend.close()\n\n    p = plot3d_parametric_line(sin(x) + 0.1*sin(x)*cos(7*x),\n             cos(x) + 0.1*cos(x)*cos(7*x),\n        0.1*sin(7*x),\n        (x, 0, 2*pi))\n    p[0].line_color = lambdify_(x, sin(4*x))\n    p.save(tmp_file('%s_colors_3d_line_arity1' % name))\n    p[0].line_color = lambda a, b: b\n    p.save(tmp_file('%s_colors_3d_line_arity2' % name))\n    p[0].line_color = lambda a, b, c: c\n    p.save(tmp_file('%s_colors_3d_line_arity3' % name))\n    p._backend.close()\n\n    p = plot3d(sin(x)*y, (x, 0, 6*pi), (y, -5, 5))\n    p[0].surface_color = lambda a: a\n    p.save(tmp_file('%s_colors_surface_arity1' % name))\n    p[0].surface_color = lambda a, b: b\n    p.save(tmp_file('%s_colors_surface_arity2' % name))\n    p[0].surface_color = lambda a, b, c: c\n    p.save(tmp_file('%s_colors_surface_arity3a' % name))\n    p[0].surface_color = lambdify_((x, y, z), sqrt((x - 3*pi)**2 + y**2))\n    p.save(tmp_file('%s_colors_surface_arity3b' % name))\n    p._backend.close()\n\n    p = plot3d_parametric_surface(x * cos(4 * y), x * sin(4 * y), y,\n             (x, -1, 1), (y, -1, 1))\n    p[0].surface_color = lambda a: a\n    p.save(tmp_file('%s_colors_param_surf_arity1' % name))\n    p[0].surface_color = lambda a, b: a*b\n    p.save(tmp_file('%s_colors_param_surf_arity2' % name))\n    p[0].surface_color = lambdify_((x, y, z), sqrt(x**2 + y**2 + z**2))\n    p.save(tmp_file('%s_colors_param_surf_arity3' % name))\n    p._backend.close()\n\n    ###\n    # Examples from the 'advanced' notebook\n    ###\n\n    # XXX: This raises the warning \"The evaluation of the expression is\n    # problematic. We are trying a failback method that may still work. Please\n    # report this as a bug.\" It has to use the fallback because using evalf()\n    # is the only way to evaluate the integral. We should perhaps just remove\n    # that warning.\n\n    with warnings.catch_warnings(record=True) as w:\n        i = Integral(log((sin(x)**2 + 1)*sqrt(x**2 + 1)), (x, 0, y))\n        p = plot(i, (y, 1, 5))\n        p.save(tmp_file('%s_advanced_integral' % name))\n        p._backend.close()\n        # Make sure no other warnings were raised\n        for i in w:\n            assert issubclass(i.category, UserWarning)\n            assert \"The evaluation of the expression is problematic\" in str(i.message)\n\n    s = Sum(1/x**y, (x, 1, oo))\n    p = plot(s, (y, 2, 10))\n    p.save(tmp_file('%s_advanced_inf_sum' % name))\n    p._backend.close()\n\n    p = plot(Sum(1/x, (x, 1, y)), (y, 2, 10), show=False)\n    p[0].only_integers = True\n    p[0].steps = True\n    p.save(tmp_file('%s_advanced_fin_sum' % name))\n    p._backend.close()\n\n    ###\n    # Test expressions that can not be translated to np and generate complex\n    # results.\n    ###\n    plot(sin(x) + I*cos(x)).save(tmp_file())\n    plot(sqrt(sqrt(-x))).save(tmp_file())\n    plot(LambertW(x)).save(tmp_file())\n    plot(sqrt(LambertW(x))).save(tmp_file())\n\n    #Characteristic function of a StudentT distribution with nu=10\n    plot((meijerg(((1 / 2,), ()), ((5, 0, 1 / 2), ()), 5 * x**2 * exp_polar(-I*pi)/2)\n            + meijerg(((1/2,), ()), ((5, 0, 1/2), ()),\n                5*x**2 * exp_polar(I*pi)/2)) / (48 * pi), (x, 1e-6, 1e-2)).save(tmp_file())\n\ndef test_matplotlib():\n\n    matplotlib = import_module('matplotlib', min_module_version='1.1.0', catch=(RuntimeError,))\n    if matplotlib:\n        try:\n            plot_and_save('test')\n        finally:\n            # clean up\n            TmpFileManager.cleanup()\n    else:\n        skip(\"Matplotlib not the default backend\")\n\n# Tests for exception handling in experimental_lambdify\ndef test_experimental_lambify():\n    x = Symbol('x')\n    f = lambdify([x], Max(x, 5))\n    # XXX should f be tested? If f(2) is attempted, an\n    # error is raised because a complex produced during wrapping of the arg\n    # is being compared with an int.\n    assert Max(2, 5) == 5\n    assert Max(5, 7) == 7\n\n    x = Symbol('x-3')\n    f = lambdify([x], x + 1)\n    assert f(1) == 2\n\n\ndef test_append_issue_7140():\n    matplotlib = import_module('matplotlib', min_module_version='1.1.0', catch=(RuntimeError,))\n    if not matplotlib:\n        skip(\"Matplotlib not the default backend\")\n\n    x = Symbol('x')\n    p1 = plot(x)\n    p2 = plot(x**2)\n    p3 = plot(x + 2)\n\n    # append a series\n    p2.append(p1[0])\n    assert len(p2._series) == 2\n\n    with raises(TypeError):\n        p1.append(p2)\n\n    with raises(TypeError):\n        p1.append(p2._series)\n", "description": "A computer algebra system written in pure Python", "file_name": "test_plot.py", "id": "757debdb972aec138b10d54ddcc778cf", "language": "Python", "project_name": "sympy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/sympy-sympy/sympy-sympy-205da79/sympy/plotting/tests/test_plot.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:35:56Z", "url": "https://github.com/sympy/sympy", "wiki": true}