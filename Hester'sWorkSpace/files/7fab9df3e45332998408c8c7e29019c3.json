{"author": "sympy", "code": "from sympy import (Interval, Intersection, Set, EmptySet,\n        FiniteSet, Union, ComplexRegion, ProductSet)\nfrom sympy.sets.fancysets import Integers, Naturals, Reals\nfrom sympy.sets.sets import UniversalSet\nfrom sympy import S, sympify\nfrom sympy.multipledispatch import dispatch\n\n\n@dispatch(Integers, Set)\ndef union_sets(a, b):\n    intersect = Intersection(a, b)\n    if intersect == a:\n        return b\n    elif intersect == b:\n        return a\n\n@dispatch(ComplexRegion, Set)\ndef union_sets(a, b):\n    if b.is_subset(S.Reals):\n        \n        b = ComplexRegion.from_real(b)\n\n    if b.is_ComplexRegion:\n        \n        if (not a.polar) and (not b.polar):\n            return ComplexRegion(Union(a.sets, b.sets))\n        \n        elif a.polar and b.polar:\n            return ComplexRegion(Union(a.sets, b.sets), polar=True)\n    return None\n\n@dispatch(EmptySet, Set)\ndef union_sets(a, b):\n    return b\n\n\n@dispatch(UniversalSet, Set)\ndef union_sets(a, b):\n    return a\n\n@dispatch(ProductSet, ProductSet)\ndef union_sets(a, b):\n    if b.is_subset(a):\n        return a\n    if len(b.args) != len(a.args):\n        return None\n    if a.args[0] == b.args[0]:\n        return a.args[0] * Union(ProductSet(a.args[1:]),\n                                    ProductSet(b.args[1:]))\n    if a.args[-1] == b.args[-1]:\n        return Union(ProductSet(a.args[:-1]),\n                     ProductSet(b.args[:-1])) * a.args[-1]\n    return None\n\n@dispatch(ProductSet, Set)\ndef union_sets(a, b):\n    if b.is_subset(a):\n        return a\n    return None\n\n@dispatch(Interval, Interval)\ndef union_sets(a, b):\n    if a._is_comparable(b):\n        from sympy.functions.elementary.miscellaneous import Min, Max\n        \n        end = Min(a.end, b.end)\n        start = Max(a.start, b.start)\n        if (end < start or\n           (end == start and (end not in a and end not in b))):\n            return None\n        else:\n            start = Min(a.start, b.start)\n            end = Max(a.end, b.end)\n\n            left_open = ((a.start != start or a.left_open) and\n                         (b.start != start or b.left_open))\n            right_open = ((a.end != end or a.right_open) and\n                          (b.end != end or b.right_open))\n            return Interval(start, end, left_open, right_open)\n\n@dispatch(Interval, UniversalSet)\ndef union_sets(a, b):\n    return S.UniversalSet\n\n@dispatch(Interval, Set)\ndef union_sets(a, b):\n    \n    \n    \n    open_left_in_b_and_finite = (a.left_open and\n                                     sympify(b.contains(a.start)) is S.true and\n                                     a.start.is_finite)\n    open_right_in_b_and_finite = (a.right_open and\n                                      sympify(b.contains(a.end)) is S.true and\n                                      a.end.is_finite)\n    if open_left_in_b_and_finite or open_right_in_b_and_finite:\n        \n        open_left = a.left_open and a.start not in b\n        open_right = a.right_open and a.end not in b\n        new_a = Interval(a.start, a.end, open_left, open_right)\n        return set((new_a, b))\n    return None\n\n@dispatch(FiniteSet, FiniteSet)\ndef union_sets(a, b):\n    return FiniteSet(*(a._elements | b._elements))\n\n@dispatch(FiniteSet, Set)\ndef union_sets(a, b):\n    \n    if any(b.contains(x) == True for x in a):\n        return set((\n            FiniteSet(*[x for x in a if b.contains(x) != True]), b))\n    return None\n\n@dispatch(Set, Set)\ndef union_sets(a, b):\n    return None\n", "comments": "  treat subset reals complex region    rectangular form    polar form    non overlapping intervals    if i open end points endpoints contained b    but case  endpoints finite  because    interval contain oo  oo     fill end points return    if  b  set contains one elements  remove   ", "content": "from sympy import (Interval, Intersection, Set, EmptySet,\n        FiniteSet, Union, ComplexRegion, ProductSet)\nfrom sympy.sets.fancysets import Integers, Naturals, Reals\nfrom sympy.sets.sets import UniversalSet\nfrom sympy import S, sympify\nfrom sympy.multipledispatch import dispatch\n\n\n@dispatch(Integers, Set)\ndef union_sets(a, b):\n    intersect = Intersection(a, b)\n    if intersect == a:\n        return b\n    elif intersect == b:\n        return a\n\n@dispatch(ComplexRegion, Set)\ndef union_sets(a, b):\n    if b.is_subset(S.Reals):\n        # treat a subset of reals as a complex region\n        b = ComplexRegion.from_real(b)\n\n    if b.is_ComplexRegion:\n        # a in rectangular form\n        if (not a.polar) and (not b.polar):\n            return ComplexRegion(Union(a.sets, b.sets))\n        # a in polar form\n        elif a.polar and b.polar:\n            return ComplexRegion(Union(a.sets, b.sets), polar=True)\n    return None\n\n@dispatch(EmptySet, Set)\ndef union_sets(a, b):\n    return b\n\n\n@dispatch(UniversalSet, Set)\ndef union_sets(a, b):\n    return a\n\n@dispatch(ProductSet, ProductSet)\ndef union_sets(a, b):\n    if b.is_subset(a):\n        return a\n    if len(b.args) != len(a.args):\n        return None\n    if a.args[0] == b.args[0]:\n        return a.args[0] * Union(ProductSet(a.args[1:]),\n                                    ProductSet(b.args[1:]))\n    if a.args[-1] == b.args[-1]:\n        return Union(ProductSet(a.args[:-1]),\n                     ProductSet(b.args[:-1])) * a.args[-1]\n    return None\n\n@dispatch(ProductSet, Set)\ndef union_sets(a, b):\n    if b.is_subset(a):\n        return a\n    return None\n\n@dispatch(Interval, Interval)\ndef union_sets(a, b):\n    if a._is_comparable(b):\n        from sympy.functions.elementary.miscellaneous import Min, Max\n        # Non-overlapping intervals\n        end = Min(a.end, b.end)\n        start = Max(a.start, b.start)\n        if (end < start or\n           (end == start and (end not in a and end not in b))):\n            return None\n        else:\n            start = Min(a.start, b.start)\n            end = Max(a.end, b.end)\n\n            left_open = ((a.start != start or a.left_open) and\n                         (b.start != start or b.left_open))\n            right_open = ((a.end != end or a.right_open) and\n                          (b.end != end or b.right_open))\n            return Interval(start, end, left_open, right_open)\n\n@dispatch(Interval, UniversalSet)\ndef union_sets(a, b):\n    return S.UniversalSet\n\n@dispatch(Interval, Set)\ndef union_sets(a, b):\n    # If I have open end points and these endpoints are contained in b\n    # But only in case, when endpoints are finite. Because\n    # interval does not contain oo or -oo.\n    open_left_in_b_and_finite = (a.left_open and\n                                     sympify(b.contains(a.start)) is S.true and\n                                     a.start.is_finite)\n    open_right_in_b_and_finite = (a.right_open and\n                                      sympify(b.contains(a.end)) is S.true and\n                                      a.end.is_finite)\n    if open_left_in_b_and_finite or open_right_in_b_and_finite:\n        # Fill in my end points and return\n        open_left = a.left_open and a.start not in b\n        open_right = a.right_open and a.end not in b\n        new_a = Interval(a.start, a.end, open_left, open_right)\n        return set((new_a, b))\n    return None\n\n@dispatch(FiniteSet, FiniteSet)\ndef union_sets(a, b):\n    return FiniteSet(*(a._elements | b._elements))\n\n@dispatch(FiniteSet, Set)\ndef union_sets(a, b):\n    # If `b` set contains one of my elements, remove it from `a`\n    if any(b.contains(x) == True for x in a):\n        return set((\n            FiniteSet(*[x for x in a if b.contains(x) != True]), b))\n    return None\n\n@dispatch(Set, Set)\ndef union_sets(a, b):\n    return None\n", "description": "A computer algebra system written in pure Python", "file_name": "union.py", "id": "7fab9df3e45332998408c8c7e29019c3", "language": "Python", "project_name": "sympy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/sympy-sympy/sympy-sympy-205da79/sympy/sets/handlers/union.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:35:56Z", "url": "https://github.com/sympy/sympy", "wiki": true}