{"author": "thumbor", "code": "\n# -*- coding: utf-8 -*-\n\n\n\n\n\n\n# Copyright (c) 2011 globo.com thumbor@googlegroups.com\n\nfrom unittest import TestCase\nimport mock\n\nfrom preggy import expect\n\nfrom thumbor.app import ThumborServiceApp\nimport thumbor.utils\nfrom thumbor.config import Config\nimport thumbor.server\nfrom thumbor.server import (\n    get_as_integer,\n    get_config,\n    configure_log,\n    get_importer,\n    validate_config,\n    get_context,\n    get_application,\n    run_server,\n    main,\n)\nfrom thumbor.engines import BaseEngine\n\nfrom tests.fixtures.custom_error_handler import ErrorHandler as CustomErrorHandler\n\n\nclass ServerTestCase(TestCase):\n    def test_can_get_value_as_integer(self):\n        expect(get_as_integer(\"1\")).to_equal(1)\n        expect(get_as_integer(\"a\")).to_be_null()\n        expect(get_as_integer(\"\")).to_be_null()\n        expect(get_as_integer(None)).to_be_null()\n\n    def test_can_get_config_from_path(self):\n        config = get_config('./tests/fixtures/thumbor_config_server_test.conf')\n\n        expect(config).not_to_be_null()\n        expect(config.ALLOWED_SOURCES).to_be_like(['mydomain.com'])\n\n    @mock.patch('logging.basicConfig')\n    def test_can_configure_log_from_config(self, basic_config_mock):\n        conf = Config()\n        configure_log(conf, 'DEBUG')\n\n        params = dict(\n            datefmt='%Y-%m-%d %H:%M:%S',\n            level=10,\n            format='%(asctime)s %(name)s:%(levelname)s %(message)s'\n        )\n\n        basic_config_mock.assert_called_with(**params)\n\n    @mock.patch('logging.config.dictConfig')\n    def test_can_configure_log_from_dict_config(self, dict_config_mock):\n        conf = Config(\n            THUMBOR_LOG_CONFIG={\n                \"level\": \"INFO\"\n            }\n        )\n        configure_log(conf, 'DEBUG')\n\n        params = dict(\n            level=\"INFO\",\n        )\n\n        dict_config_mock.assert_called_with(params)\n\n    def test_can_import_default_modules(self):\n        conf = Config()\n        importer = get_importer(conf)\n\n        expect(importer).not_to_be_null()\n        expect(importer.filters).not_to_be_empty()\n\n    def test_can_import_with_custom_error_handler_class(self):\n        conf = Config(\n            USE_CUSTOM_ERROR_HANDLING=True,\n            ERROR_HANDLER_MODULE='tests.fixtures.custom_error_handler',\n        )\n        importer = get_importer(conf)\n\n        expect(importer).not_to_be_null()\n        expect(importer.error_handler_class).not_to_be_null()\n        expect(importer.error_handler_class).to_be_instance_of(CustomErrorHandler)\n\n    def test_validate_config_security_key(self):\n        server_parameters = mock.Mock(security_key=None)\n        conf = Config(SECURITY_KEY=None)\n\n        with expect.error_to_happen(\n            RuntimeError,\n            message=\"No security key was found for this instance of thumbor. \"\n                \"Please provide one using the conf file or a security key file.\"):\n            validate_config(conf, server_parameters)\n\n    def test_validate_config_security_key_from_config(self):\n        server_parameters = mock.Mock(security_key=None)\n        conf = Config(SECURITY_KEY='something')\n\n        validate_config(conf, server_parameters)\n        expect(server_parameters.security_key).to_equal('something')\n\n    @mock.patch.object(thumbor.server, 'which')\n    def test_validate_gifsicle_path(self, which_mock):\n        server_parameters = mock.Mock(security_key=None)\n        conf = Config(SECURITY_KEY='test', USE_GIFSICLE_ENGINE=True)\n\n        which_mock.return_value = '/usr/bin/gifsicle'\n\n        validate_config(conf, server_parameters)\n        expect(server_parameters.gifsicle_path).to_equal('/usr/bin/gifsicle')\n\n    @mock.patch.object(thumbor.server, 'which')\n    def test_validate_null_gifsicle_path(self, which_mock):\n        server_parameters = mock.Mock(security_key=None)\n        conf = Config(SECURITY_KEY='test', USE_GIFSICLE_ENGINE=True)\n\n        which_mock.return_value = None\n\n        with expect.error_to_happen(\n            RuntimeError,\n            message=\"If using USE_GIFSICLE_ENGINE configuration to True, \"\n                \"the `gifsicle` binary must be in the PATH and must be an executable.\"\n        ):\n            validate_config(conf, server_parameters)\n\n    def test_get_context(self):\n        server_parameters = mock.Mock(security_key=None, app_class='thumbor.app.ThumborServiceApp')\n        conf = Config(SECURITY_KEY='test')\n        importer = get_importer(conf)\n        context = get_context(server_parameters, conf, importer)\n\n        expect(context).not_to_be_null()\n\n    def test_get_application(self):\n        server_parameters = mock.Mock(security_key=None, app_class='thumbor.app.ThumborServiceApp')\n        conf = Config(SECURITY_KEY='test')\n        importer = get_importer(conf)\n        context = get_context(server_parameters, conf, importer)\n        app = get_application(context)\n\n        expect(app).not_to_be_null()\n        expect(app).to_be_instance_of(ThumborServiceApp)\n\n    @mock.patch.object(thumbor.server, 'HTTPServer')\n    def test_can_run_server_with_default_params(self, server_mock):\n        application = mock.Mock()\n        context = mock.Mock()\n        context.server = mock.Mock(fd=None, port=1234, ip='0.0.0.0')\n\n        server_instance_mock = mock.Mock()\n        server_mock.return_value = server_instance_mock\n\n        run_server(application, context)\n\n        server_instance_mock.bind.assert_called_with(1234, '0.0.0.0')\n        server_instance_mock.start.assert_called_with(1)\n\n    @mock.patch.object(thumbor.server, 'HTTPServer')\n    @mock.patch.object(thumbor.server, 'socket')\n    def test_can_run_server_with_fd(self, socket_mock, server_mock):\n        application = mock.Mock()\n        context = mock.Mock()\n        context.server = mock.Mock(fd=11, port=1234, ip='0.0.0.0')\n\n        server_instance_mock = mock.Mock()\n        server_mock.return_value = server_instance_mock\n\n        socket_mock.fromfd.return_value = \"socket mock\"\n\n        run_server(application, context)\n        server_instance_mock.add_socket.assert_called_with(\"socket mock\")\n        server_instance_mock.start.assert_called_with(1)\n\n    @mock.patch.object(thumbor.server, 'HTTPServer')\n    @mock.patch('__builtin__.open', create=True)\n    @mock.patch.object(thumbor.server, 'socket')\n    def test_can_run_server_with_null_fd(self, socket_mock, open_mock, server_mock):\n        application = mock.Mock()\n        context = mock.Mock()\n        context.server = mock.Mock(fd=\"/path/bin\", port=1234, ip='0.0.0.0')\n\n        server_instance_mock = mock.Mock()\n        server_mock.return_value = server_instance_mock\n\n        socket_mock.fromfd.return_value = \"socket mock\"\n        socket_mock.fileno.return_value = 12\n\n        open_mock.return_value = socket_mock\n\n        run_server(application, context)\n        server_instance_mock.add_socket.assert_called_with(\"socket mock\")\n        server_instance_mock.start.assert_called_with(1)\n\n    @mock.patch.object(thumbor.server, 'HTTPServer')\n    @mock.patch.object(thumbor.server, 'get_server_parameters')\n    @mock.patch('tornado.ioloop.IOLoop.instance', create=True)\n    def test_can_run_main(self, ioloop_mock, get_server_parameters_mock, server_mock):\n        server_parameters = mock.Mock(\n            config_path='./tests/fixtures/thumbor_config_server_test.conf',\n            log_level='DEBUG',\n            debug=False,\n            security_key='sec',\n            app_class='thumbor.app.ThumborServiceApp',\n            fd=None,\n            ip='0.0.0.0',\n            port=1234,\n        )\n        get_server_parameters_mock.return_value = server_parameters\n\n        ioloop_instance_mock = mock.Mock()\n        ioloop_mock.return_value = ioloop_instance_mock\n        main()\n        ioloop_instance_mock.start.assert_any_call()\n\n    def cleanup(self):\n        ServerTestCase.cleanup_called = True\n\n    @mock.patch.object(thumbor.server, 'HTTPServer')\n    @mock.patch.object(thumbor.server, 'get_server_parameters')\n    @mock.patch('tornado.ioloop.IOLoop.instance', create=True)\n    @mock.patch('sys.stdout')\n    def test_main_exits_on_keyboard_interrupt(self, stdout_mock, ioloop_mock, get_server_parameters_mock, server_mock):\n        server_parameters = mock.Mock(\n            config_path='./tests/fixtures/thumbor_config_server_test.conf',\n            log_level='DEBUG',\n            security_key='sec',\n            debug=False,\n            app_class='thumbor.app.ThumborServiceApp',\n            fd=None,\n            ip='0.0.0.0',\n            port=1234,\n        )\n        get_server_parameters_mock.return_value = server_parameters\n\n        old_cleanup = BaseEngine.cleanup\n        BaseEngine.cleanup = self.cleanup\n        ServerTestCase.cleanup_called = False\n\n        ioloop_instance_mock = mock.Mock()\n        ioloop_mock.return_value = ioloop_instance_mock\n        ioloop_instance_mock.start.side_effect = KeyboardInterrupt()\n\n        main()\n\n        stdout_mock.write.assert_called_with('-- thumbor closed by user interruption --\\n')\n        self.assertTrue(ServerTestCase.cleanup_called)\n\n        BaseEngine.cleanup = old_cleanup\n", "comments": "   usr bin python        coding  utf 8        thumbor imaging service    https   github com thumbor thumbor wiki    licensed mit license     http   www opensource org licenses mit license    copyright (c) 2011 globo com thumbor googlegroups com ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# thumbor imaging service\n# https://github.com/thumbor/thumbor/wiki\n\n# Licensed under the MIT license:\n# http://www.opensource.org/licenses/mit-license\n# Copyright (c) 2011 globo.com thumbor@googlegroups.com\n\nfrom unittest import TestCase\nimport mock\n\nfrom preggy import expect\n\nfrom thumbor.app import ThumborServiceApp\nimport thumbor.utils\nfrom thumbor.config import Config\nimport thumbor.server\nfrom thumbor.server import (\n    get_as_integer,\n    get_config,\n    configure_log,\n    get_importer,\n    validate_config,\n    get_context,\n    get_application,\n    run_server,\n    main,\n)\nfrom thumbor.engines import BaseEngine\n\nfrom tests.fixtures.custom_error_handler import ErrorHandler as CustomErrorHandler\n\n\nclass ServerTestCase(TestCase):\n    def test_can_get_value_as_integer(self):\n        expect(get_as_integer(\"1\")).to_equal(1)\n        expect(get_as_integer(\"a\")).to_be_null()\n        expect(get_as_integer(\"\")).to_be_null()\n        expect(get_as_integer(None)).to_be_null()\n\n    def test_can_get_config_from_path(self):\n        config = get_config('./tests/fixtures/thumbor_config_server_test.conf')\n\n        expect(config).not_to_be_null()\n        expect(config.ALLOWED_SOURCES).to_be_like(['mydomain.com'])\n\n    @mock.patch('logging.basicConfig')\n    def test_can_configure_log_from_config(self, basic_config_mock):\n        conf = Config()\n        configure_log(conf, 'DEBUG')\n\n        params = dict(\n            datefmt='%Y-%m-%d %H:%M:%S',\n            level=10,\n            format='%(asctime)s %(name)s:%(levelname)s %(message)s'\n        )\n\n        basic_config_mock.assert_called_with(**params)\n\n    @mock.patch('logging.config.dictConfig')\n    def test_can_configure_log_from_dict_config(self, dict_config_mock):\n        conf = Config(\n            THUMBOR_LOG_CONFIG={\n                \"level\": \"INFO\"\n            }\n        )\n        configure_log(conf, 'DEBUG')\n\n        params = dict(\n            level=\"INFO\",\n        )\n\n        dict_config_mock.assert_called_with(params)\n\n    def test_can_import_default_modules(self):\n        conf = Config()\n        importer = get_importer(conf)\n\n        expect(importer).not_to_be_null()\n        expect(importer.filters).not_to_be_empty()\n\n    def test_can_import_with_custom_error_handler_class(self):\n        conf = Config(\n            USE_CUSTOM_ERROR_HANDLING=True,\n            ERROR_HANDLER_MODULE='tests.fixtures.custom_error_handler',\n        )\n        importer = get_importer(conf)\n\n        expect(importer).not_to_be_null()\n        expect(importer.error_handler_class).not_to_be_null()\n        expect(importer.error_handler_class).to_be_instance_of(CustomErrorHandler)\n\n    def test_validate_config_security_key(self):\n        server_parameters = mock.Mock(security_key=None)\n        conf = Config(SECURITY_KEY=None)\n\n        with expect.error_to_happen(\n            RuntimeError,\n            message=\"No security key was found for this instance of thumbor. \"\n                \"Please provide one using the conf file or a security key file.\"):\n            validate_config(conf, server_parameters)\n\n    def test_validate_config_security_key_from_config(self):\n        server_parameters = mock.Mock(security_key=None)\n        conf = Config(SECURITY_KEY='something')\n\n        validate_config(conf, server_parameters)\n        expect(server_parameters.security_key).to_equal('something')\n\n    @mock.patch.object(thumbor.server, 'which')\n    def test_validate_gifsicle_path(self, which_mock):\n        server_parameters = mock.Mock(security_key=None)\n        conf = Config(SECURITY_KEY='test', USE_GIFSICLE_ENGINE=True)\n\n        which_mock.return_value = '/usr/bin/gifsicle'\n\n        validate_config(conf, server_parameters)\n        expect(server_parameters.gifsicle_path).to_equal('/usr/bin/gifsicle')\n\n    @mock.patch.object(thumbor.server, 'which')\n    def test_validate_null_gifsicle_path(self, which_mock):\n        server_parameters = mock.Mock(security_key=None)\n        conf = Config(SECURITY_KEY='test', USE_GIFSICLE_ENGINE=True)\n\n        which_mock.return_value = None\n\n        with expect.error_to_happen(\n            RuntimeError,\n            message=\"If using USE_GIFSICLE_ENGINE configuration to True, \"\n                \"the `gifsicle` binary must be in the PATH and must be an executable.\"\n        ):\n            validate_config(conf, server_parameters)\n\n    def test_get_context(self):\n        server_parameters = mock.Mock(security_key=None, app_class='thumbor.app.ThumborServiceApp')\n        conf = Config(SECURITY_KEY='test')\n        importer = get_importer(conf)\n        context = get_context(server_parameters, conf, importer)\n\n        expect(context).not_to_be_null()\n\n    def test_get_application(self):\n        server_parameters = mock.Mock(security_key=None, app_class='thumbor.app.ThumborServiceApp')\n        conf = Config(SECURITY_KEY='test')\n        importer = get_importer(conf)\n        context = get_context(server_parameters, conf, importer)\n        app = get_application(context)\n\n        expect(app).not_to_be_null()\n        expect(app).to_be_instance_of(ThumborServiceApp)\n\n    @mock.patch.object(thumbor.server, 'HTTPServer')\n    def test_can_run_server_with_default_params(self, server_mock):\n        application = mock.Mock()\n        context = mock.Mock()\n        context.server = mock.Mock(fd=None, port=1234, ip='0.0.0.0')\n\n        server_instance_mock = mock.Mock()\n        server_mock.return_value = server_instance_mock\n\n        run_server(application, context)\n\n        server_instance_mock.bind.assert_called_with(1234, '0.0.0.0')\n        server_instance_mock.start.assert_called_with(1)\n\n    @mock.patch.object(thumbor.server, 'HTTPServer')\n    @mock.patch.object(thumbor.server, 'socket')\n    def test_can_run_server_with_fd(self, socket_mock, server_mock):\n        application = mock.Mock()\n        context = mock.Mock()\n        context.server = mock.Mock(fd=11, port=1234, ip='0.0.0.0')\n\n        server_instance_mock = mock.Mock()\n        server_mock.return_value = server_instance_mock\n\n        socket_mock.fromfd.return_value = \"socket mock\"\n\n        run_server(application, context)\n        server_instance_mock.add_socket.assert_called_with(\"socket mock\")\n        server_instance_mock.start.assert_called_with(1)\n\n    @mock.patch.object(thumbor.server, 'HTTPServer')\n    @mock.patch('__builtin__.open', create=True)\n    @mock.patch.object(thumbor.server, 'socket')\n    def test_can_run_server_with_null_fd(self, socket_mock, open_mock, server_mock):\n        application = mock.Mock()\n        context = mock.Mock()\n        context.server = mock.Mock(fd=\"/path/bin\", port=1234, ip='0.0.0.0')\n\n        server_instance_mock = mock.Mock()\n        server_mock.return_value = server_instance_mock\n\n        socket_mock.fromfd.return_value = \"socket mock\"\n        socket_mock.fileno.return_value = 12\n\n        open_mock.return_value = socket_mock\n\n        run_server(application, context)\n        server_instance_mock.add_socket.assert_called_with(\"socket mock\")\n        server_instance_mock.start.assert_called_with(1)\n\n    @mock.patch.object(thumbor.server, 'HTTPServer')\n    @mock.patch.object(thumbor.server, 'get_server_parameters')\n    @mock.patch('tornado.ioloop.IOLoop.instance', create=True)\n    def test_can_run_main(self, ioloop_mock, get_server_parameters_mock, server_mock):\n        server_parameters = mock.Mock(\n            config_path='./tests/fixtures/thumbor_config_server_test.conf',\n            log_level='DEBUG',\n            debug=False,\n            security_key='sec',\n            app_class='thumbor.app.ThumborServiceApp',\n            fd=None,\n            ip='0.0.0.0',\n            port=1234,\n        )\n        get_server_parameters_mock.return_value = server_parameters\n\n        ioloop_instance_mock = mock.Mock()\n        ioloop_mock.return_value = ioloop_instance_mock\n        main()\n        ioloop_instance_mock.start.assert_any_call()\n\n    def cleanup(self):\n        ServerTestCase.cleanup_called = True\n\n    @mock.patch.object(thumbor.server, 'HTTPServer')\n    @mock.patch.object(thumbor.server, 'get_server_parameters')\n    @mock.patch('tornado.ioloop.IOLoop.instance', create=True)\n    @mock.patch('sys.stdout')\n    def test_main_exits_on_keyboard_interrupt(self, stdout_mock, ioloop_mock, get_server_parameters_mock, server_mock):\n        server_parameters = mock.Mock(\n            config_path='./tests/fixtures/thumbor_config_server_test.conf',\n            log_level='DEBUG',\n            security_key='sec',\n            debug=False,\n            app_class='thumbor.app.ThumborServiceApp',\n            fd=None,\n            ip='0.0.0.0',\n            port=1234,\n        )\n        get_server_parameters_mock.return_value = server_parameters\n\n        old_cleanup = BaseEngine.cleanup\n        BaseEngine.cleanup = self.cleanup\n        ServerTestCase.cleanup_called = False\n\n        ioloop_instance_mock = mock.Mock()\n        ioloop_mock.return_value = ioloop_instance_mock\n        ioloop_instance_mock.start.side_effect = KeyboardInterrupt()\n\n        main()\n\n        stdout_mock.write.assert_called_with('-- thumbor closed by user interruption --\\n')\n        self.assertTrue(ServerTestCase.cleanup_called)\n\n        BaseEngine.cleanup = old_cleanup\n", "description": "thumbor is an open-source photo thumbnail service by globo.com", "file_name": "test_server.py", "id": "739a9f57aa645d51fb41c2ba9a258b2c", "language": "Python", "project_name": "thumbor", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/thumbor-thumbor/thumbor-thumbor-991f13c/tests/test_server.py", "save_time": "", "source": "", "update_at": "2018-03-18T09:16:11Z", "url": "https://github.com/thumbor/thumbor", "wiki": true}