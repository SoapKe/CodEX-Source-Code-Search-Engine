{"author": "ansible", "code": "\n\nfrom collections import namedtuple\n\nfrom ansible.executor.task_queue_manager import TaskQueueManager\nfrom ansible.inventory.manager import InventoryManager\nfrom ansible.parsing.dataloader import DataLoader\nfrom ansible.playbook.play import Play\nfrom ansible.plugins.callback import CallbackBase\nfrom ansible.vars.manager import VariableManager\n\n\n\nclass ResultsCollector(CallbackBase):\n\n    def __init__(self, *args, **kwargs):\n        super(ResultsCollector, self).__init__(*args, **kwargs)\n        self.host_ok = {}\n        self.host_unreachable = {}\n        self.host_failed = {}\n\n    def v2_runner_on_unreachable(self, result):\n        self.host_unreachable[result._host.get_name()] = result\n\n    def v2_runner_on_ok(self, result, *args, **kwargs):\n        self.host_ok[result._host.get_name()] = result\n\n    def v2_runner_on_failed(self, result, *args, **kwargs):\n        self.host_failed[result._host.get_name()] = result\n\n\ndef main():\n    host_list = ['localhost', 'www.example.com', 'www.google.com']\n    Options = namedtuple('Options', ['connection', 'module_path', 'forks', 'remote_user',\n                                     'private_key_file', 'ssh_common_args', 'ssh_extra_args', 'sftp_extra_args',\n                                     'scp_extra_args', 'become', 'become_method', 'become_user', 'verbosity', 'check',\n                                     'diff'])\n    \n    \n    sources = ','.join(host_list)\n    if len(host_list) == 1:\n        sources += ','\n\n    \n    loader = DataLoader()\n    options = Options(connection='smart', module_path=['/usr/share/ansible'], forks=100,\n                      remote_user=None, private_key_file=None, ssh_common_args=None, ssh_extra_args=None,\n                      sftp_extra_args=None, scp_extra_args=None, become=None, become_method=None,\n                      become_user=None, verbosity=None, check=False, diff=False)\n\n    passwords = dict()\n\n    \n    inventory = InventoryManager(loader=loader, sources=sources)\n    variable_manager = VariableManager(loader=loader, inventory=inventory)\n\n    \n    play_source = dict(\n        name=\"Ansible Play\",\n        hosts=host_list,\n        gather_facts='no',\n        tasks=[dict(action=dict(module='command', args=dict(cmd='/usr/bin/uptime')))]\n    )\n    play = Play().load(play_source, variable_manager=variable_manager, loader=loader)\n\n    \n    tqm = None\n    callback = ResultsCollector()\n    try:\n        tqm = TaskQueueManager(\n            inventory=inventory,\n            variable_manager=variable_manager,\n            loader=loader,\n            options=options,\n            passwords=passwords,\n        )\n        tqm._stdout_callback = callback\n        result = tqm.run(play)\n    finally:\n        if tqm is not None:\n            tqm.cleanup()\n\n    print(\"UP ***********\")\n    for host, result in callback.host_ok.items():\n        print('{0} >>> {1}'.format(host, result._result['stdout']))\n\n    print(\"FAILED *******\")\n    for host, result in callback.host_failed.items():\n        print('{0} >>> {1}'.format(host, result._result['msg']))\n\n    print(\"DOWN *********\")\n    for host, result in callback.host_unreachable.items():\n        print('{0} >>> {1}'.format(host, result._result['msg']))\n\nif __name__ == '__main__':\n    main()\n", "comments": "   usr bin env python    create callback object capture output    required    https   github com ansible ansible blob devel lib ansible inventory manager py l204    initialize needed objects    create inventory pass var manager    create play tasks    actually run ", "content": "#!/usr/bin/env python\n\nfrom collections import namedtuple\n\nfrom ansible.executor.task_queue_manager import TaskQueueManager\nfrom ansible.inventory.manager import InventoryManager\nfrom ansible.parsing.dataloader import DataLoader\nfrom ansible.playbook.play import Play\nfrom ansible.plugins.callback import CallbackBase\nfrom ansible.vars.manager import VariableManager\n\n\n# Create a callback object so we can capture the output\nclass ResultsCollector(CallbackBase):\n\n    def __init__(self, *args, **kwargs):\n        super(ResultsCollector, self).__init__(*args, **kwargs)\n        self.host_ok = {}\n        self.host_unreachable = {}\n        self.host_failed = {}\n\n    def v2_runner_on_unreachable(self, result):\n        self.host_unreachable[result._host.get_name()] = result\n\n    def v2_runner_on_ok(self, result, *args, **kwargs):\n        self.host_ok[result._host.get_name()] = result\n\n    def v2_runner_on_failed(self, result, *args, **kwargs):\n        self.host_failed[result._host.get_name()] = result\n\n\ndef main():\n    host_list = ['localhost', 'www.example.com', 'www.google.com']\n    Options = namedtuple('Options', ['connection', 'module_path', 'forks', 'remote_user',\n                                     'private_key_file', 'ssh_common_args', 'ssh_extra_args', 'sftp_extra_args',\n                                     'scp_extra_args', 'become', 'become_method', 'become_user', 'verbosity', 'check',\n                                     'diff'])\n    # required for\n    # https://github.com/ansible/ansible/blob/devel/lib/ansible/inventory/manager.py#L204\n    sources = ','.join(host_list)\n    if len(host_list) == 1:\n        sources += ','\n\n    # initialize needed objects\n    loader = DataLoader()\n    options = Options(connection='smart', module_path=['/usr/share/ansible'], forks=100,\n                      remote_user=None, private_key_file=None, ssh_common_args=None, ssh_extra_args=None,\n                      sftp_extra_args=None, scp_extra_args=None, become=None, become_method=None,\n                      become_user=None, verbosity=None, check=False, diff=False)\n\n    passwords = dict()\n\n    # create inventory and pass to var manager\n    inventory = InventoryManager(loader=loader, sources=sources)\n    variable_manager = VariableManager(loader=loader, inventory=inventory)\n\n    # create play with tasks\n    play_source = dict(\n        name=\"Ansible Play\",\n        hosts=host_list,\n        gather_facts='no',\n        tasks=[dict(action=dict(module='command', args=dict(cmd='/usr/bin/uptime')))]\n    )\n    play = Play().load(play_source, variable_manager=variable_manager, loader=loader)\n\n    # actually run it\n    tqm = None\n    callback = ResultsCollector()\n    try:\n        tqm = TaskQueueManager(\n            inventory=inventory,\n            variable_manager=variable_manager,\n            loader=loader,\n            options=options,\n            passwords=passwords,\n        )\n        tqm._stdout_callback = callback\n        result = tqm.run(play)\n    finally:\n        if tqm is not None:\n            tqm.cleanup()\n\n    print(\"UP ***********\")\n    for host, result in callback.host_ok.items():\n        print('{0} >>> {1}'.format(host, result._result['stdout']))\n\n    print(\"FAILED *******\")\n    for host, result in callback.host_failed.items():\n        print('{0} >>> {1}'.format(host, result._result['msg']))\n\n    print(\"DOWN *********\")\n    for host, result in callback.host_unreachable.items():\n        print('{0} >>> {1}'.format(host, result._result['msg']))\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "uptime.py", "id": "165d1da4afed8ca26fc634000d824754", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/examples/scripts/uptime.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}