{"author": "tensorflow", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================\n\n\"\"\"Utilities for processing depth images.\n\"\"\"\nimport numpy as np\nimport src.rotation_utils as ru\nimport src.utils as utils\n\ndef get_camera_matrix(width, height, fov):\n  \"\"\"Returns a camera matrix from image size and fov.\"\"\"\n  xc = (width-1.) / 2.\n  zc = (height-1.) / 2.\n  f = (width / 2.) / np.tan(np.deg2rad(fov / 2.))\n  camera_matrix = utils.Foo(xc=xc, zc=zc, f=f)\n  return camera_matrix\n\ndef get_point_cloud_from_z(Y, camera_matrix):\n  \"\"\"Projects the depth image Y into a 3D point cloud.\n  Inputs:\n    Y is ...xHxW\n    camera_matrix\n  Outputs:\n    X is positive going right\n    Y is positive into the image\n    Z is positive up in the image\n    XYZ is ...xHxWx3\n  \"\"\"\n  x, z = np.meshgrid(np.arange(Y.shape[-1]),\n                     np.arange(Y.shape[-2]-1, -1, -1))\n  for i in range(Y.ndim-2):\n    x = np.expand_dims(x, axis=0)\n    z = np.expand_dims(z, axis=0)\n  X = (x-camera_matrix.xc) * Y / camera_matrix.f\n  Z = (z-camera_matrix.zc) * Y / camera_matrix.f\n  XYZ = np.concatenate((X[...,np.newaxis], Y[...,np.newaxis],\n                        Z[...,np.newaxis]), axis=X.ndim)\n  return XYZ\n\ndef make_geocentric(XYZ, sensor_height, camera_elevation_degree):\n  \"\"\"Transforms the point cloud into geocentric coordinate frame.\n  Input:\n    XYZ                     : ...x3\n    sensor_height           : height of the sensor\n    camera_elevation_degree : camera elevation to rectify.\n  Output:\n    XYZ : ...x3\n  \"\"\"\n  R = ru.get_r_matrix([1.,0.,0.], angle=np.deg2rad(camera_elevation_degree))\n  XYZ = np.matmul(XYZ.reshape(-1,3), R.T).reshape(XYZ.shape)\n  XYZ[...,2] = XYZ[...,2] + sensor_height\n  return XYZ\n\ndef bin_points(XYZ_cms, map_size, z_bins, xy_resolution):\n  \"\"\"Bins points into xy-z bins\n  XYZ_cms is ... x H x W x3\n  Outputs is ... x map_size x map_size x (len(z_bins)+1)\n  \"\"\"\n  sh = XYZ_cms.shape\n  XYZ_cms = XYZ_cms.reshape([-1, sh[-3], sh[-2], sh[-1]])\n  n_z_bins = len(z_bins)+1\n  map_center = (map_size-1.)/2.\n  counts = []\n  isvalids = []\n  for XYZ_cm in XYZ_cms:\n    isnotnan = np.logical_not(np.isnan(XYZ_cm[:,:,0]))\n    X_bin = np.round(XYZ_cm[:,:,0] / xy_resolution + map_center).astype(np.int32)\n    Y_bin = np.round(XYZ_cm[:,:,1] / xy_resolution + map_center).astype(np.int32)\n    Z_bin = np.digitize(XYZ_cm[:,:,2], bins=z_bins).astype(np.int32)\n\n    isvalid = np.array([X_bin >= 0, X_bin < map_size, Y_bin >= 0, Y_bin < map_size,\n                        Z_bin >= 0, Z_bin < n_z_bins, isnotnan])\n    isvalid = np.all(isvalid, axis=0)\n\n    ind = (Y_bin * map_size + X_bin) * n_z_bins + Z_bin\n    ind[np.logical_not(isvalid)] = 0\n    count = np.bincount(ind.ravel(), isvalid.ravel().astype(np.int32),\n                         minlength=map_size*map_size*n_z_bins)\n    count = np.reshape(count, [map_size, map_size, n_z_bins])\n    counts.append(count)\n    isvalids.append(isvalid)\n  counts = np.array(counts).reshape(list(sh[:-3]) + [map_size, map_size, n_z_bins])\n  isvalids = np.array(isvalids).reshape(list(sh[:-3]) + [sh[-3], sh[-2], 1])\n  return counts, isvalids\n", "comments": "   utilities processing depth images      import numpy np import src rotation utils ru import src utils utils  def get camera matrix(width  height  fov)       returns camera matrix image size fov       xc   (width 1 )   2    zc   (height 1 )   2    f   (width   2 )   np tan(np deg2rad(fov   2 ))   camera matrix   utils foo(xc xc  zc zc  f f)   return camera matrix  def get point cloud z(y  camera matrix)       projects depth image y 3d point cloud    inputs      y    xhxw     camera matrix   outputs      x positive going right     y positive image     z positive image     xyz    xhxwx3         x  z   np meshgrid(np arange(y shape  1 )                       np arange(y shape  2  1   1   1))   range(y ndim 2)      x   np expand dims(x  axis 0)     z   np expand dims(z  axis 0)   x   (x camera matrix xc)   y   camera matrix f   z   (z camera matrix zc)   y   camera matrix f   xyz   np concatenate((x     np newaxis   y     np newaxis                           z     np newaxis )  axis x ndim)   return xyz  def make geocentric(xyz  sensor height  camera elevation degree)       transforms point cloud geocentric coordinate frame    input      xyz                          x3     sensor height             height sensor     camera elevation degree   camera elevation rectify    output      xyz      x3         r   ru get r matrix( 1  0  0    angle np deg2rad(camera elevation degree))   xyz   np matmul(xyz reshape( 1 3)  r t) reshape(xyz shape)   xyz     2    xyz     2    sensor height   return xyz  def bin points(xyz cms  map size  z bins  xy resolution)       bins points xy z bins   xyz cms     x h x w x3   outputs     x map size x map size x (len(z bins) 1)          copyright 2016 the tensorflow authors all rights reserved        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license           http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license                                                                                    ", "content": "# Copyright 2016 The TensorFlow Authors All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Utilities for processing depth images.\n\"\"\"\nimport numpy as np\nimport src.rotation_utils as ru\nimport src.utils as utils\n\ndef get_camera_matrix(width, height, fov):\n  \"\"\"Returns a camera matrix from image size and fov.\"\"\"\n  xc = (width-1.) / 2.\n  zc = (height-1.) / 2.\n  f = (width / 2.) / np.tan(np.deg2rad(fov / 2.))\n  camera_matrix = utils.Foo(xc=xc, zc=zc, f=f)\n  return camera_matrix\n\ndef get_point_cloud_from_z(Y, camera_matrix):\n  \"\"\"Projects the depth image Y into a 3D point cloud.\n  Inputs:\n    Y is ...xHxW\n    camera_matrix\n  Outputs:\n    X is positive going right\n    Y is positive into the image\n    Z is positive up in the image\n    XYZ is ...xHxWx3\n  \"\"\"\n  x, z = np.meshgrid(np.arange(Y.shape[-1]),\n                     np.arange(Y.shape[-2]-1, -1, -1))\n  for i in range(Y.ndim-2):\n    x = np.expand_dims(x, axis=0)\n    z = np.expand_dims(z, axis=0)\n  X = (x-camera_matrix.xc) * Y / camera_matrix.f\n  Z = (z-camera_matrix.zc) * Y / camera_matrix.f\n  XYZ = np.concatenate((X[...,np.newaxis], Y[...,np.newaxis],\n                        Z[...,np.newaxis]), axis=X.ndim)\n  return XYZ\n\ndef make_geocentric(XYZ, sensor_height, camera_elevation_degree):\n  \"\"\"Transforms the point cloud into geocentric coordinate frame.\n  Input:\n    XYZ                     : ...x3\n    sensor_height           : height of the sensor\n    camera_elevation_degree : camera elevation to rectify.\n  Output:\n    XYZ : ...x3\n  \"\"\"\n  R = ru.get_r_matrix([1.,0.,0.], angle=np.deg2rad(camera_elevation_degree))\n  XYZ = np.matmul(XYZ.reshape(-1,3), R.T).reshape(XYZ.shape)\n  XYZ[...,2] = XYZ[...,2] + sensor_height\n  return XYZ\n\ndef bin_points(XYZ_cms, map_size, z_bins, xy_resolution):\n  \"\"\"Bins points into xy-z bins\n  XYZ_cms is ... x H x W x3\n  Outputs is ... x map_size x map_size x (len(z_bins)+1)\n  \"\"\"\n  sh = XYZ_cms.shape\n  XYZ_cms = XYZ_cms.reshape([-1, sh[-3], sh[-2], sh[-1]])\n  n_z_bins = len(z_bins)+1\n  map_center = (map_size-1.)/2.\n  counts = []\n  isvalids = []\n  for XYZ_cm in XYZ_cms:\n    isnotnan = np.logical_not(np.isnan(XYZ_cm[:,:,0]))\n    X_bin = np.round(XYZ_cm[:,:,0] / xy_resolution + map_center).astype(np.int32)\n    Y_bin = np.round(XYZ_cm[:,:,1] / xy_resolution + map_center).astype(np.int32)\n    Z_bin = np.digitize(XYZ_cm[:,:,2], bins=z_bins).astype(np.int32)\n\n    isvalid = np.array([X_bin >= 0, X_bin < map_size, Y_bin >= 0, Y_bin < map_size,\n                        Z_bin >= 0, Z_bin < n_z_bins, isnotnan])\n    isvalid = np.all(isvalid, axis=0)\n\n    ind = (Y_bin * map_size + X_bin) * n_z_bins + Z_bin\n    ind[np.logical_not(isvalid)] = 0\n    count = np.bincount(ind.ravel(), isvalid.ravel().astype(np.int32),\n                         minlength=map_size*map_size*n_z_bins)\n    count = np.reshape(count, [map_size, map_size, n_z_bins])\n    counts.append(count)\n    isvalids.append(isvalid)\n  counts = np.array(counts).reshape(list(sh[:-3]) + [map_size, map_size, n_z_bins])\n  isvalids = np.array(isvalids).reshape(list(sh[:-3]) + [sh[-3], sh[-2], 1])\n  return counts, isvalids\n", "description": "Models and examples built with TensorFlow", "file_name": "depth_utils.py", "id": "474de086bd53fd87fa276d97521eac2b", "language": "Python", "project_name": "models", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/tensorflow-models/tensorflow-models-086d914/research/cognitive_mapping_and_planning/src/depth_utils.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:59:19Z", "url": "https://github.com/tensorflow/models", "wiki": true}