{"author": "sympy", "code": "from sympy import (\n    Abs, adjoint, arg, atan, atan2, conjugate, cos, DiracDelta, E, exp, expand,\n    Expr, Function, Heaviside, I, im, log, nan, oo, pi, Rational, re, S,\n    sign, sin, sqrt, Symbol, symbols, transpose, zoo, exp_polar, Piecewise,\n    Interval, comp, Integral, Matrix, ImmutableMatrix, SparseMatrix,\n    ImmutableSparseMatrix, MatrixSymbol, FunctionMatrix, Lambda)\nfrom sympy.utilities.pytest import XFAIL, raises\n\n\ndef N_equals(a, b):\n    \n    return comp(a.n(), b.n(), 1.e-6)\n\n\ndef test_re():\n    x, y = symbols('x,y')\n    a, b = symbols('a,b', real=True)\n\n    r = Symbol('r', real=True)\n    i = Symbol('i', imaginary=True)\n\n    assert re(nan) == nan\n\n    assert re(oo) == oo\n    assert re(-oo) == -oo\n\n    assert re(0) == 0\n\n    assert re(1) == 1\n    assert re(-1) == -1\n\n    assert re(E) == E\n    assert re(-E) == -E\n\n    assert re(x) == re(x)\n    assert re(x*I) == -im(x)\n    assert re(r*I) == 0\n    assert re(r) == r\n    assert re(i*I) == I * i\n    assert re(i) == 0\n\n    assert re(x + y) == re(x + y)\n    assert re(x + r) == re(x) + r\n\n    assert re(re(x)) == re(x)\n\n    assert re(2 + I) == 2\n    assert re(x + I) == re(x)\n\n    assert re(x + y*I) == re(x) - im(y)\n    assert re(x + r*I) == re(x)\n\n    assert re(log(2*I)) == log(2)\n\n    assert re((2 + I)**2).expand(complex=True) == 3\n\n    assert re(conjugate(x)) == re(x)\n    assert conjugate(re(x)) == re(x)\n\n    assert re(x).as_real_imag() == (re(x), 0)\n\n    assert re(i*r*x).diff(r) == re(i*x)\n    assert re(i*r*x).diff(i) == I*r*im(x)\n\n    assert re(\n        sqrt(a + b*I)) == (a**2 + b**2)**Rational(1, 4)*cos(atan2(b, a)/2)\n    assert re(a * (2 + b*I)) == 2*a\n\n    assert re((1 + sqrt(a + b*I))/2) == \\\n        (a**2 + b**2)**Rational(1, 4)*cos(atan2(b, a)/2)/2 + Rational(1, 2)\n\n    assert re(x).rewrite(im) == x - S.ImaginaryUnit*im(x)\n    assert (x + re(y)).rewrite(re, im) == x + y - S.ImaginaryUnit*im(y)\n\n    a = Symbol('a', algebraic=True)\n    t = Symbol('t', transcendental=True)\n    x = Symbol('x')\n    assert re(a).is_algebraic\n    assert re(x).is_algebraic is None\n    assert re(t).is_algebraic is False\n\n    assert re(S.ComplexInfinity) == S.NaN\n\n    n, m, l = symbols('n m l')\n    A = MatrixSymbol('A',n,m)\n    assert re(A) == (S(1)/2) * (A + conjugate(A))\n\n    A = Matrix([[1 + 4*I,2],[0, -3*I]])\n    assert re(A) == Matrix([[1, 2],[0, 0]])\n\n    A = ImmutableMatrix([[1 + 3*I, 3-2*I],[0, 2*I]])\n    assert re(A) == ImmutableMatrix([[1, 3],[0, 0]])\n\n    X = SparseMatrix([[2*j + i*I for i in range(5)] for j in range(5)])\n    assert re(X) - Matrix([[0, 0, 0, 0, 0],\n                           [2, 2, 2, 2, 2],\n                           [4, 4, 4, 4, 4],\n                           [6, 6, 6, 6, 6],\n                           [8, 8, 8, 8, 8]]) == Matrix.zeros(5)\n\n    assert im(X) - Matrix([[0, 1, 2, 3, 4],\n                           [0, 1, 2, 3, 4],\n                           [0, 1, 2, 3, 4],\n                           [0, 1, 2, 3, 4],\n                           [0, 1, 2, 3, 4]]) == Matrix.zeros(5)\n\n    X = FunctionMatrix(3, 3, Lambda((n, m), n + m*I))\n    assert re(X) == Matrix([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\n\n\ndef test_im():\n    x, y = symbols('x,y')\n    a, b = symbols('a,b', real=True)\n\n    r = Symbol('r', real=True)\n    i = Symbol('i', imaginary=True)\n\n    assert im(nan) == nan\n\n    assert im(oo*I) == oo\n    assert im(-oo*I) == -oo\n\n    assert im(0) == 0\n\n    assert im(1) == 0\n    assert im(-1) == 0\n\n    assert im(E*I) == E\n    assert im(-E*I) == -E\n\n    assert im(x) == im(x)\n    assert im(x*I) == re(x)\n    assert im(r*I) == r\n    assert im(r) == 0\n    assert im(i*I) == 0\n    assert im(i) == -I * i\n\n    assert im(x + y) == im(x + y)\n    assert im(x + r) == im(x)\n    assert im(x + r*I) == im(x) + r\n\n    assert im(im(x)*I) == im(x)\n\n    assert im(2 + I) == 1\n    assert im(x + I) == im(x) + 1\n\n    assert im(x + y*I) == im(x) + re(y)\n    assert im(x + r*I) == im(x) + r\n\n    assert im(log(2*I)) == pi/2\n\n    assert im((2 + I)**2).expand(complex=True) == 4\n\n    assert im(conjugate(x)) == -im(x)\n    assert conjugate(im(x)) == im(x)\n\n    assert im(x).as_real_imag() == (im(x), 0)\n\n    assert im(i*r*x).diff(r) == im(i*x)\n    assert im(i*r*x).diff(i) == -I * re(r*x)\n\n    assert im(\n        sqrt(a + b*I)) == (a**2 + b**2)**Rational(1, 4)*sin(atan2(b, a)/2)\n    assert im(a * (2 + b*I)) == a*b\n\n    assert im((1 + sqrt(a + b*I))/2) == \\\n        (a**2 + b**2)**Rational(1, 4)*sin(atan2(b, a)/2)/2\n\n    assert im(x).rewrite(re) == -S.ImaginaryUnit * (x - re(x))\n    assert (x + im(y)).rewrite(im, re) == x - S.ImaginaryUnit * (y - re(y))\n\n    a = Symbol('a', algebraic=True)\n    t = Symbol('t', transcendental=True)\n    x = Symbol('x')\n    assert re(a).is_algebraic\n    assert re(x).is_algebraic is None\n    assert re(t).is_algebraic is False\n\n    assert im(S.ComplexInfinity) == S.NaN\n\n    n, m, l = symbols('n m l')\n    A = MatrixSymbol('A',n,m)\n\n    assert im(A) == (S(1)/(2*I)) * (A - conjugate(A))\n\n    A = Matrix([[1 + 4*I, 2],[0, -3*I]])\n    assert im(A) == Matrix([[4, 0],[0, -3]])\n\n    A = ImmutableMatrix([[1 + 3*I, 3-2*I],[0, 2*I]])\n    assert im(A) == ImmutableMatrix([[3, -2],[0, 2]])\n\n    X = ImmutableSparseMatrix(\n            [[i*I + i for i in range(5)] for i in range(5)])\n    Y = SparseMatrix([[i for i in range(5)] for i in range(5)])\n    assert im(X).as_immutable() == Y\n\n    X = FunctionMatrix(3, 3, Lambda((n, m), n + m*I))\n    assert im(X) == Matrix([[0, 1, 2], [0, 1, 2], [0, 1, 2]])\n\ndef test_sign():\n    assert sign(1.2) == 1\n    assert sign(-1.2) == -1\n    assert sign(3*I) == I\n    assert sign(-3*I) == -I\n    assert sign(0) == 0\n    assert sign(nan) == nan\n    assert sign(2 + 2*I).doit() == sqrt(2)*(2 + 2*I)/4\n    assert sign(2 + 3*I).simplify() == sign(2 + 3*I)\n    assert sign(2 + 2*I).simplify() == sign(1 + I)\n    assert sign(im(sqrt(1 - sqrt(3)))) == 1\n    assert sign(sqrt(1 - sqrt(3))) == I\n\n    x = Symbol('x')\n    assert sign(x).is_finite is True\n    assert sign(x).is_complex is True\n    assert sign(x).is_imaginary is None\n    assert sign(x).is_integer is None\n    assert sign(x).is_real is None\n    assert sign(x).is_zero is None\n    assert sign(x).doit() == sign(x)\n    assert sign(1.2*x) == sign(x)\n    assert sign(2*x) == sign(x)\n    assert sign(I*x) == I*sign(x)\n    assert sign(-2*I*x) == -I*sign(x)\n    assert sign(conjugate(x)) == conjugate(sign(x))\n\n    p = Symbol('p', positive=True)\n    n = Symbol('n', negative=True)\n    m = Symbol('m', negative=True)\n    assert sign(2*p*x) == sign(x)\n    assert sign(n*x) == -sign(x)\n    assert sign(n*m*x) == sign(x)\n\n    x = Symbol('x', imaginary=True)\n    assert sign(x).is_imaginary is True\n    assert sign(x).is_integer is False\n    assert sign(x).is_real is False\n    assert sign(x).is_zero is False\n    assert sign(x).diff(x) == 2*DiracDelta(-I*x)\n    assert sign(x).doit() == x / Abs(x)\n    assert conjugate(sign(x)) == -sign(x)\n\n    x = Symbol('x', real=True)\n    assert sign(x).is_imaginary is False\n    assert sign(x).is_integer is True\n    assert sign(x).is_real is True\n    assert sign(x).is_zero is None\n    assert sign(x).diff(x) == 2*DiracDelta(x)\n    assert sign(x).doit() == sign(x)\n    assert conjugate(sign(x)) == sign(x)\n\n    x = Symbol('x', nonzero=True)\n    assert sign(x).is_imaginary is False\n    assert sign(x).is_integer is True\n    assert sign(x).is_real is True\n    assert sign(x).is_zero is False\n    assert sign(x).doit() == x / Abs(x)\n    assert sign(Abs(x)) == 1\n    assert Abs(sign(x)) == 1\n\n    x = Symbol('x', positive=True)\n    assert sign(x).is_imaginary is False\n    assert sign(x).is_integer is True\n    assert sign(x).is_real is True\n    assert sign(x).is_zero is False\n    assert sign(x).doit() == x / Abs(x)\n    assert sign(Abs(x)) == 1\n    assert Abs(sign(x)) == 1\n\n    x = 0\n    assert sign(x).is_imaginary is False\n    assert sign(x).is_integer is True\n    assert sign(x).is_real is True\n    assert sign(x).is_zero is True\n    assert sign(x).doit() == 0\n    assert sign(Abs(x)) == 0\n    assert Abs(sign(x)) == 0\n\n    nz = Symbol('nz', nonzero=True, integer=True)\n    assert sign(nz).is_imaginary is False\n    assert sign(nz).is_integer is True\n    assert sign(nz).is_real is True\n    assert sign(nz).is_zero is False\n    assert sign(nz)**2 == 1\n    assert (sign(nz)**3).args == (sign(nz), 3)\n\n    assert sign(Symbol('x', nonnegative=True)).is_nonnegative\n    assert sign(Symbol('x', nonnegative=True)).is_nonpositive is None\n    assert sign(Symbol('x', nonpositive=True)).is_nonnegative is None\n    assert sign(Symbol('x', nonpositive=True)).is_nonpositive\n    assert sign(Symbol('x', real=True)).is_nonnegative is None\n    assert sign(Symbol('x', real=True)).is_nonpositive is None\n    assert sign(Symbol('x', real=True, zero=False)).is_nonpositive is None\n\n    x, y = Symbol('x', real=True), Symbol('y')\n    assert sign(x).rewrite(Piecewise) == \\\n        Piecewise((1, x > 0), (-1, x < 0), (0, True))\n    assert sign(y).rewrite(Piecewise) == sign(y)\n    assert sign(x).rewrite(Heaviside) == 2*Heaviside(x)-1\n    assert sign(y).rewrite(Heaviside) == sign(y)\n\n    \n    assert sign(exp_polar(I*pi)*pi) is S.NegativeOne\n\n    eq = -sqrt(10 + 6*sqrt(3)) + sqrt(1 + sqrt(3)) + sqrt(3 + 3*sqrt(3))\n    \n    \n    assert sign(eq).func is sign or sign(eq) == 0\n    \n    \n    q = 1 + sqrt(2) - 2*sqrt(3) + 1331*sqrt(6)\n    p = expand(q**3)**Rational(1, 3)\n    d = p - q\n    assert sign(d).func is sign or sign(d) == 0\n\n\ndef test_as_real_imag():\n    n = pi**1000\n    \n    \n    \n    \n    assert n.as_real_imag() == (n, 0)\n\n    \n    x = Symbol('x')\n    assert sqrt(x).as_real_imag() == \\\n        ((re(x)**2 + im(x)**2)**(S(1)/4)*cos(atan2(im(x), re(x))/2),\n     (re(x)**2 + im(x)**2)**(S(1)/4)*sin(atan2(im(x), re(x))/2))\n\n    \n    a, b = symbols('a,b', real=True)\n    assert ((1 + sqrt(a + b*I))/2).as_real_imag() == \\\n           (\n               (a**2 + b**2)**Rational(\n                   1, 4)*cos(atan2(b, a)/2)/2 + Rational(1, 2),\n               (a**2 + b**2)**Rational(1, 4)*sin(atan2(b, a)/2)/2)\n\n    assert sqrt(a**2).as_real_imag() == (sqrt(a**2), 0)\n    i = symbols('i', imaginary=True)\n    assert sqrt(i**2).as_real_imag() == (0, abs(i))\n\n    assert ((1 + I)/(1 - I)).as_real_imag() == (0, 1)\n    assert ((1 + I)**3/(1 - I)).as_real_imag() == (-2, 0)\n\n\n@XFAIL\ndef test_sign_issue_3068():\n    n = pi**1000\n    i = int(n)\n    assert (n - i).round() == 1  \n    assert sign(n - i) == 1\n    \n    \n    \n    assert (n - x).n(1, subs={x: i}) > 0\n    assert (n - x).n(2, subs={x: i}) > 0\n\n\ndef test_Abs():\n    raises(TypeError, lambda: Abs(Interval(2, 3)))  \n\n    x, y = symbols('x,y')\n    assert sign(sign(x)) == sign(x)\n    assert sign(x*y).func is sign\n    assert Abs(0) == 0\n    assert Abs(1) == 1\n    assert Abs(-1) == 1\n    assert Abs(I) == 1\n    assert Abs(-I) == 1\n    assert Abs(nan) == nan\n    assert Abs(zoo) == oo\n    assert Abs(I * pi) == pi\n    assert Abs(-I * pi) == pi\n    assert Abs(I * x) == Abs(x)\n    assert Abs(-I * x) == Abs(x)\n    assert Abs(-2*x) == 2*Abs(x)\n    assert Abs(-2.0*x) == 2.0*Abs(x)\n    assert Abs(2*pi*x*y) == 2*pi*Abs(x*y)\n    assert Abs(conjugate(x)) == Abs(x)\n    assert conjugate(Abs(x)) == Abs(x)\n    assert Abs(x).expand(complex=True) == sqrt(re(x)**2 + im(x)**2)\n\n    a = Symbol('a', positive=True)\n    assert Abs(2*pi*x*a) == 2*pi*a*Abs(x)\n    assert Abs(2*pi*I*x*a) == 2*pi*a*Abs(x)\n\n    x = Symbol('x', real=True)\n    n = Symbol('n', integer=True)\n    assert Abs((-1)**n) == 1\n    assert x**(2*n) == Abs(x)**(2*n)\n    assert Abs(x).diff(x) == sign(x)\n    assert abs(x) == Abs(x)  \n    assert Abs(x)**3 == x**2*Abs(x)\n    assert Abs(x)**4 == x**4\n    assert (\n        Abs(x)**(3*n)).args == (Abs(x), 3*n)  \n    assert (1/Abs(x)).args == (Abs(x), -1)\n    assert 1/Abs(x)**3 == 1/(x**2*Abs(x))\n    assert Abs(x)**-3 == Abs(x)/(x**4)\n    assert Abs(x**3) == x**2*Abs(x)\n    assert Abs(I**I) == exp(-pi/2)\n    assert Abs((4 + 5*I)**(6 + 7*I)) == 68921*exp(-7*atan(S(5)/4))\n    y = Symbol('y', real=True)\n    assert Abs(I**y) == 1\n    y = Symbol('y')\n    assert Abs(I**y) == exp(-pi*im(y)/2)\n\n    x = Symbol('x', imaginary=True)\n    assert Abs(x).diff(x) == -sign(x)\n\n    eq = -sqrt(10 + 6*sqrt(3)) + sqrt(1 + sqrt(3)) + sqrt(3 + 3*sqrt(3))\n    \n    \n    assert abs(eq).func is Abs or abs(eq) == 0\n    \n    \n    q = 1 + sqrt(2) - 2*sqrt(3) + 1331*sqrt(6)\n    p = expand(q**3)**Rational(1, 3)\n    d = p - q\n    assert abs(d).func is Abs or abs(d) == 0\n\n    assert Abs(4*exp(pi*I/4)) == 4\n    assert Abs(3**(2 + I)) == 9\n    assert Abs((-3)**(1 - I)) == 3*exp(pi)\n\n    assert Abs(oo) is oo\n    assert Abs(-oo) is oo\n    assert Abs(oo + I) is oo\n    assert Abs(oo + I*oo) is oo\n\n    a = Symbol('a', algebraic=True)\n    t = Symbol('t', transcendental=True)\n    x = Symbol('x')\n    assert re(a).is_algebraic\n    assert re(x).is_algebraic is None\n    assert re(t).is_algebraic is False\n\n\ndef test_Abs_rewrite():\n    x = Symbol('x', real=True)\n    a = Abs(x).rewrite(Heaviside).expand()\n    assert a == x*Heaviside(x) - x*Heaviside(-x)\n    for i in [-2, -1, 0, 1, 2]:\n        assert a.subs(x, i) == abs(i)\n    y = Symbol('y')\n    assert Abs(y).rewrite(Heaviside) == Abs(y)\n\n    x, y = Symbol('x', real=True), Symbol('y')\n    assert Abs(x).rewrite(Piecewise) == Piecewise((x, x >= 0), (-x, True))\n    assert Abs(y).rewrite(Piecewise) == Abs(y)\n    assert Abs(y).rewrite(sign) == y/sign(y)\n\n\ndef test_Abs_real():\n    \n    \n    x = Symbol('x', complex=True)\n    assert sqrt(x**2) != Abs(x)\n    assert Abs(x**2) != x**2\n\n    x = Symbol('x', real=True)\n    assert sqrt(x**2) == Abs(x)\n    assert Abs(x**2) == x**2\n\n    \n    nn = Symbol('nn', nonnegative=True, real=True)\n    np = Symbol('np', nonpositive=True, real=True)\n    assert Abs(nn) == nn\n    assert Abs(np) == -np\n\n\ndef test_Abs_properties():\n    x = Symbol('x')\n    assert Abs(x).is_real is True\n    assert Abs(x).is_rational is None\n    assert Abs(x).is_positive is None\n    assert Abs(x).is_nonnegative is True\n\n    z = Symbol('z', complex=True, zero=False)\n    assert Abs(z).is_real is True\n    assert Abs(z).is_rational is None\n    assert Abs(z).is_positive is True\n    assert Abs(z).is_zero is False\n\n    p = Symbol('p', positive=True)\n    assert Abs(p).is_real is True\n    assert Abs(p).is_rational is None\n    assert Abs(p).is_positive is True\n    assert Abs(p).is_zero is False\n\n    q = Symbol('q', rational=True)\n    assert Abs(q).is_rational is True\n    assert Abs(q).is_integer is None\n    assert Abs(q).is_positive is None\n    assert Abs(q).is_nonnegative is True\n\n    i = Symbol('i', integer=True)\n    assert Abs(i).is_integer is True\n    assert Abs(i).is_positive is None\n    assert Abs(i).is_nonnegative is True\n\n    e = Symbol('n', even=True)\n    ne = Symbol('ne', real=True, even=False)\n    assert Abs(e).is_even\n    assert Abs(ne).is_even is False\n    assert Abs(i).is_even is None\n\n    o = Symbol('n', odd=True)\n    no = Symbol('no', real=True, odd=False)\n    assert Abs(o).is_odd\n    assert Abs(no).is_odd is False\n    assert Abs(i).is_odd is None\n\n\ndef test_abs():\n    \n    \n    a = Symbol('a', positive=True)\n    assert abs(I*(1 + a)**2) == (1 + a)**2\n\n\ndef test_arg():\n    assert arg(0) == nan\n    assert arg(1) == 0\n    assert arg(-1) == pi\n    assert arg(I) == pi/2\n    assert arg(-I) == -pi/2\n    assert arg(1 + I) == pi/4\n    assert arg(-1 + I) == 3*pi/4\n    assert arg(1 - I) == -pi/4\n    assert arg(exp_polar(4*pi*I)) == 4*pi\n    assert arg(exp_polar(-7*pi*I)) == -7*pi\n    assert arg(exp_polar(5 - 3*pi*I/4)) == -3*pi/4\n    f = Function('f')\n    assert not arg(f(0) + I*f(1)).atoms(re)\n\n    p = Symbol('p', positive=True)\n    assert arg(p) == 0\n\n    n = Symbol('n', negative=True)\n    assert arg(n) == pi\n\n    x = Symbol('x')\n    assert conjugate(arg(x)) == arg(x)\n\n    e = p + I*p**2\n    assert arg(e) == arg(1 + p*I)\n    \n    e = -2*p + 4*I*p**2\n    assert arg(e) == arg(-1 + 2*p*I)\n    \n    x = symbols('x', real=True)  \n    e = x + I*x\n    assert arg(e) == arg(x*(1 + I))\n    assert arg(e/p) == arg(x*(1 + I))\n    e = p*cos(p) + I*log(p)*exp(p)\n    assert arg(e).args[0] == e\n    \n    e = (p + 1) + I*(p**2 - 1)\n    assert arg(e).args[0] == e\n\n    f = Function('f')\n    e = 2*x*(f(0) - 1) - 2*x*f(0)\n    assert arg(e) == arg(-2*x)\n    assert arg(f(0)).func == arg and arg(f(0)).args == (f(0),)\n\n\ndef test_arg_rewrite():\n    assert arg(1 + I) == atan2(1, 1)\n\n    x = Symbol('x', real=True)\n    y = Symbol('y', real=True)\n    assert arg(x + I*y).rewrite(atan2) == atan2(y, x)\n\n\ndef test_adjoint():\n    a = Symbol('a', antihermitian=True)\n    b = Symbol('b', hermitian=True)\n    assert adjoint(a) == -a\n    assert adjoint(I*a) == I*a\n    assert adjoint(b) == b\n    assert adjoint(I*b) == -I*b\n    assert adjoint(a*b) == -b*a\n    assert adjoint(I*a*b) == I*b*a\n\n    x, y = symbols('x y')\n    assert adjoint(adjoint(x)) == x\n    assert adjoint(x + y) == adjoint(x) + adjoint(y)\n    assert adjoint(x - y) == adjoint(x) - adjoint(y)\n    assert adjoint(x * y) == adjoint(x) * adjoint(y)\n    assert adjoint(x / y) == adjoint(x) / adjoint(y)\n    assert adjoint(-x) == -adjoint(x)\n\n    x, y = symbols('x y', commutative=False)\n    assert adjoint(adjoint(x)) == x\n    assert adjoint(x + y) == adjoint(x) + adjoint(y)\n    assert adjoint(x - y) == adjoint(x) - adjoint(y)\n    assert adjoint(x * y) == adjoint(y) * adjoint(x)\n    assert adjoint(x / y) == 1 / adjoint(y) * adjoint(x)\n    assert adjoint(-x) == -adjoint(x)\n\n\ndef test_conjugate():\n    a = Symbol('a', real=True)\n    b = Symbol('b', imaginary=True)\n    assert conjugate(a) == a\n    assert conjugate(I*a) == -I*a\n    assert conjugate(b) == -b\n    assert conjugate(I*b) == I*b\n    assert conjugate(a*b) == -a*b\n    assert conjugate(I*a*b) == I*a*b\n\n    x, y = symbols('x y')\n    assert conjugate(conjugate(x)) == x\n    assert conjugate(x + y) == conjugate(x) + conjugate(y)\n    assert conjugate(x - y) == conjugate(x) - conjugate(y)\n    assert conjugate(x * y) == conjugate(x) * conjugate(y)\n    assert conjugate(x / y) == conjugate(x) / conjugate(y)\n    assert conjugate(-x) == -conjugate(x)\n\n    a = Symbol('a', algebraic=True)\n    t = Symbol('t', transcendental=True)\n    assert re(a).is_algebraic\n    assert re(x).is_algebraic is None\n    assert re(t).is_algebraic is False\n\n\ndef test_conjugate_transpose():\n    x = Symbol('x')\n    assert conjugate(transpose(x)) == adjoint(x)\n    assert transpose(conjugate(x)) == adjoint(x)\n    assert adjoint(transpose(x)) == conjugate(x)\n    assert transpose(adjoint(x)) == conjugate(x)\n    assert adjoint(conjugate(x)) == transpose(x)\n    assert conjugate(adjoint(x)) == transpose(x)\n\n    class Symmetric(Expr):\n        def _eval_adjoint(self):\n            return None\n\n        def _eval_conjugate(self):\n            return None\n\n        def _eval_transpose(self):\n            return self\n    x = Symmetric()\n    assert conjugate(x) == adjoint(x)\n    assert transpose(x) == x\n\n\ndef test_transpose():\n    a = Symbol('a', complex=True)\n    assert transpose(a) == a\n    assert transpose(I*a) == I*a\n\n    x, y = symbols('x y')\n    assert transpose(transpose(x)) == x\n    assert transpose(x + y) == transpose(x) + transpose(y)\n    assert transpose(x - y) == transpose(x) - transpose(y)\n    assert transpose(x * y) == transpose(x) * transpose(y)\n    assert transpose(x / y) == transpose(x) / transpose(y)\n    assert transpose(-x) == -transpose(x)\n\n    x, y = symbols('x y', commutative=False)\n    assert transpose(transpose(x)) == x\n    assert transpose(x + y) == transpose(x) + transpose(y)\n    assert transpose(x - y) == transpose(x) - transpose(y)\n    assert transpose(x * y) == transpose(y) * transpose(x)\n    assert transpose(x / y) == 1 / transpose(y) * transpose(x)\n    assert transpose(-x) == -transpose(x)\n\n\ndef test_polarify():\n    from sympy import polar_lift, polarify\n    x = Symbol('x')\n    z = Symbol('z', polar=True)\n    f = Function('f')\n    ES = {}\n\n    assert polarify(-1) == (polar_lift(-1), ES)\n    assert polarify(1 + I) == (polar_lift(1 + I), ES)\n\n    assert polarify(exp(x), subs=False) == exp(x)\n    assert polarify(1 + x, subs=False) == 1 + x\n    assert polarify(f(I) + x, subs=False) == f(polar_lift(I)) + x\n\n    assert polarify(x, lift=True) == polar_lift(x)\n    assert polarify(z, lift=True) == z\n    assert polarify(f(x), lift=True) == f(polar_lift(x))\n    assert polarify(1 + x, lift=True) == polar_lift(1 + x)\n    assert polarify(1 + f(x), lift=True) == polar_lift(1 + f(polar_lift(x)))\n\n    newex, subs = polarify(f(x) + z)\n    assert newex.subs(subs) == f(x) + z\n\n    mu = Symbol(\"mu\")\n    sigma = Symbol(\"sigma\", positive=True)\n\n    # Make sure polarify(lift=True) doesn't try to lift the integration\n    \n    assert polarify(\n        Integral(sqrt(2)*x*exp(-(-mu + x)**2/(2*sigma**2))/(2*sqrt(pi)*sigma),\n        (x, -oo, oo)), lift=True) == Integral(sqrt(2)*(sigma*exp_polar(0))**exp_polar(I*pi)*\n        exp((sigma*exp_polar(0))**(2*exp_polar(I*pi))*exp_polar(I*pi)*polar_lift(-mu + x)**\n        (2*exp_polar(0))/2)*exp_polar(0)*polar_lift(x)/(2*sqrt(pi)), (x, -oo, oo))\n\n\ndef test_unpolarify():\n    from sympy import (exp_polar, polar_lift, exp, unpolarify,\n                       principal_branch)\n    from sympy import gamma, erf, sin, tanh, uppergamma, Eq, Ne\n    from sympy.abc import x\n    p = exp_polar(7*I) + 1\n    u = exp(7*I) + 1\n\n    assert unpolarify(1) == 1\n    assert unpolarify(p) == u\n    assert unpolarify(p**2) == u**2\n    assert unpolarify(p**x) == p**x\n    assert unpolarify(p*x) == u*x\n    assert unpolarify(p + x) == u + x\n    assert unpolarify(sqrt(sin(p))) == sqrt(sin(u))\n\n    # Test reduction to principal branch 2*pi.\n    t = principal_branch(x, 2*pi)\n    assert unpolarify(t) == x\n    assert unpolarify(sqrt(t)) == sqrt(t)\n\n    \n    assert unpolarify(p**p, exponents_only=True) == p**u\n    assert unpolarify(uppergamma(x, p**p)) == uppergamma(x, p**u)\n\n    \n    assert unpolarify(sin(p)) == sin(u)\n    assert unpolarify(tanh(p)) == tanh(u)\n    assert unpolarify(gamma(p)) == gamma(u)\n    assert unpolarify(erf(p)) == erf(u)\n    assert unpolarify(uppergamma(x, p)) == uppergamma(x, p)\n\n    assert unpolarify(uppergamma(sin(p), sin(p + exp_polar(0)))) == \\\n        uppergamma(sin(u), sin(u + 1))\n    assert unpolarify(uppergamma(polar_lift(0), 2*exp_polar(0))) == \\\n        uppergamma(0, 2)\n\n    assert unpolarify(Eq(p, 0)) == Eq(u, 0)\n    assert unpolarify(Ne(p, 0)) == Ne(u, 0)\n    assert unpolarify(polar_lift(x) > 0) == (x > 0)\n\n    \n    assert unpolarify(True) is True\n\n\ndef test_issue_4035():\n    x = Symbol('x')\n    assert Abs(x).expand(trig=True) == Abs(x)\n    assert sign(x).expand(trig=True) == sign(x)\n    assert arg(x).expand(trig=True) == arg(x)\n\n\ndef test_issue_3206():\n    x = Symbol('x')\n    assert Abs(Abs(x)) == Abs(x)\n\n\ndef test_issue_4754_derivative_conjugate():\n    x = Symbol('x', real=True)\n    y = Symbol('y', imaginary=True)\n    f = Function('f')\n    assert (f(x).conjugate()).diff(x) == (f(x).diff(x)).conjugate()\n    assert (f(y).conjugate()).diff(y) == -(f(y).diff(y)).conjugate()\n\n\ndef test_derivatives_issue_4757():\n    x = Symbol('x', real=True)\n    y = Symbol('y', imaginary=True)\n    f = Function('f')\n    assert re(f(x)).diff(x) == re(f(x).diff(x))\n    assert im(f(x)).diff(x) == im(f(x).diff(x))\n    assert re(f(y)).diff(y) == -I*im(f(y).diff(y))\n    assert im(f(y)).diff(y) == -I*re(f(y).diff(y))\n    assert Abs(f(x)).diff(x).subs(f(x), 1 + I*x).doit() == x/sqrt(1 + x**2)\n    assert arg(f(x)).diff(x).subs(f(x), 1 + I*x**2).doit() == 2*x/(1 + x**4)\n    assert Abs(f(y)).diff(y).subs(f(y), 1 + y).doit() == -y/sqrt(1 - y**2)\n    assert arg(f(y)).diff(y).subs(f(y), I + y**2).doit() == 2*y/(1 + y**4)\n\n\ndef test_issue_11413():\n    from sympy import symbols, Matrix, simplify\n    v0 = Symbol('v0')\n    v1 = Symbol('v1')\n    v2 = Symbol('v2')\n    V = Matrix([[v0],[v1],[v2]])\n    U = V.normalized()\n    assert U == Matrix([\n    [v0/sqrt(Abs(v0)**2 + Abs(v1)**2 + Abs(v2)**2)],\n    [v1/sqrt(Abs(v0)**2 + Abs(v1)**2 + Abs(v2)**2)],\n    [v2/sqrt(Abs(v0)**2 + Abs(v1)**2 + Abs(v2)**2)]])\n    U.norm = sqrt(v0**2/(v0**2 + v1**2 + v2**2) + v1**2/(v0**2 + v1**2 + v2**2) + v2**2/(v0**2 + v1**2 + v2**2))\n    assert simplify(U.norm) == 1\n\ndef test_periodic_argument():\n    from sympy import (periodic_argument, unbranched_argument, oo,\n                       principal_branch, polar_lift, pi)\n    x = Symbol('x')\n    p = Symbol('p', positive=True)\n\n    assert unbranched_argument(2 + I) == periodic_argument(2 + I, oo)\n    assert unbranched_argument(1 + x) == periodic_argument(1 + x, oo)\n    assert N_equals(unbranched_argument((1 + I)**2), pi/2)\n    assert N_equals(unbranched_argument((1 - I)**2), -pi/2)\n    assert N_equals(periodic_argument((1 + I)**2, 3*pi), pi/2)\n    assert N_equals(periodic_argument((1 - I)**2, 3*pi), -pi/2)\n\n    assert unbranched_argument(principal_branch(x, pi)) == \\\n        periodic_argument(x, pi)\n\n    assert unbranched_argument(polar_lift(2 + I)) == unbranched_argument(2 + I)\n    assert periodic_argument(polar_lift(2 + I), 2*pi) == \\\n        periodic_argument(2 + I, 2*pi)\n    assert periodic_argument(polar_lift(2 + I), 3*pi) == \\\n        periodic_argument(2 + I, 3*pi)\n    assert periodic_argument(polar_lift(2 + I), pi) == \\\n        periodic_argument(polar_lift(2 + I), pi)\n\n    assert unbranched_argument(polar_lift(1 + I)) == pi/4\n    assert periodic_argument(2*p, p) == periodic_argument(p, p)\n    assert periodic_argument(pi*p, p) == periodic_argument(p, p)\n\n    assert Abs(polar_lift(1 + I)) == Abs(1 + I)\n\n\n@XFAIL\ndef test_principal_branch_fail():\n    # TODO XXX why does abs(x)._eval_evalf() not fall back to global evalf?\n    assert N_equals(principal_branch((1 + I)**2, pi/2), 0)\n\n\ndef test_principal_branch():\n    from sympy import principal_branch, polar_lift, exp_polar\n    p = Symbol('p', positive=True)\n    x = Symbol('x')\n    neg = Symbol('x', negative=True)\n\n    assert principal_branch(polar_lift(x), p) == principal_branch(x, p)\n    assert principal_branch(polar_lift(2 + I), p) == principal_branch(2 + I, p)\n    assert principal_branch(2*x, p) == 2*principal_branch(x, p)\n    assert principal_branch(1, pi) == exp_polar(0)\n    assert principal_branch(-1, 2*pi) == exp_polar(I*pi)\n    assert principal_branch(-1, pi) == exp_polar(0)\n    assert principal_branch(exp_polar(3*pi*I)*x, 2*pi) == \\\n        principal_branch(exp_polar(I*pi)*x, 2*pi)\n    assert principal_branch(neg*exp_polar(pi*I), 2*pi) == neg*exp_polar(-I*pi)\n\n    assert N_equals(principal_branch((1 + I)**2, 2*pi), 2*I)\n    assert N_equals(principal_branch((1 + I)**2, 3*pi), 2*I)\n    assert N_equals(principal_branch((1 + I)**2, 1*pi), 2*I)\n\n    \n    assert principal_branch(x, I).func is principal_branch\n    assert principal_branch(x, -4).func is principal_branch\n    assert principal_branch(x, -oo).func is principal_branch\n    assert principal_branch(x, zoo).func is principal_branch\n\n\n@XFAIL\ndef test_issue_6167_6151():\n    n = pi**1000\n    i = int(n)\n    assert sign(n - i) == 1\n    assert abs(n - i) == n - i\n    eps = pi**-1500\n    big = pi**1000\n    one = cos(x)**2 + sin(x)**2\n    e = big*one - big + eps\n    assert sign(simplify(e)) == 1\n    for xi in (111, 11, 1, S(1)/10):\n        assert sign(e.subs(x, xi)) == 1\n\n\ndef test_issue_14216():\n    from sympy.functions.elementary.complexes import unpolarify\n    A = MatrixSymbol(\"A\", 2, 2)\n    assert unpolarify(A[0, 0]) == A[0, 0]\n    assert unpolarify(A[0, 0]*A[1, 0]) == A[0, 0]*A[1, 0]\n\n\ndef test_issue_14238():\n    \n    r = Symbol('r', real=True)\n    assert Abs(r + Piecewise((0, r > 0), (1 - r, True)))\n", "comments": "   check whether two complex numbers numerically close       evaluate evaluated    fast way know cannot prove    expression like zero equality zero ok    sometimes hard better load    abs tests slow    special code working real    complex parts power integer exponent    run imaginary part  hence    hang    issue 6261    issue 3853    hang    perhaps possible get sign right    1 digit requested situation     2 digits works    issue 8717    python built    leave symbolic odd unchanged    fast way know cannot prove    expression like zero equality zero ok    sometimes hard better load    abs tests slow    test properties abs apply    real numbers    symbol zero  following still apply    tests abs calls abs  rename    test abs since test already    make sure sign swap    make sure sign lost    could zero    keep simple    let user advanced cancellation    make sure polarify(lift true) try lift integration    variable    test reduction principal branch 2 pi     test exponents     test functions     test bools    todo xxx abs(x)  eval evalf() fall back global evalf     test argument sanitization    cause recursion error ", "content": "from sympy import (\n    Abs, adjoint, arg, atan, atan2, conjugate, cos, DiracDelta, E, exp, expand,\n    Expr, Function, Heaviside, I, im, log, nan, oo, pi, Rational, re, S,\n    sign, sin, sqrt, Symbol, symbols, transpose, zoo, exp_polar, Piecewise,\n    Interval, comp, Integral, Matrix, ImmutableMatrix, SparseMatrix,\n    ImmutableSparseMatrix, MatrixSymbol, FunctionMatrix, Lambda)\nfrom sympy.utilities.pytest import XFAIL, raises\n\n\ndef N_equals(a, b):\n    \"\"\"Check whether two complex numbers are numerically close\"\"\"\n    return comp(a.n(), b.n(), 1.e-6)\n\n\ndef test_re():\n    x, y = symbols('x,y')\n    a, b = symbols('a,b', real=True)\n\n    r = Symbol('r', real=True)\n    i = Symbol('i', imaginary=True)\n\n    assert re(nan) == nan\n\n    assert re(oo) == oo\n    assert re(-oo) == -oo\n\n    assert re(0) == 0\n\n    assert re(1) == 1\n    assert re(-1) == -1\n\n    assert re(E) == E\n    assert re(-E) == -E\n\n    assert re(x) == re(x)\n    assert re(x*I) == -im(x)\n    assert re(r*I) == 0\n    assert re(r) == r\n    assert re(i*I) == I * i\n    assert re(i) == 0\n\n    assert re(x + y) == re(x + y)\n    assert re(x + r) == re(x) + r\n\n    assert re(re(x)) == re(x)\n\n    assert re(2 + I) == 2\n    assert re(x + I) == re(x)\n\n    assert re(x + y*I) == re(x) - im(y)\n    assert re(x + r*I) == re(x)\n\n    assert re(log(2*I)) == log(2)\n\n    assert re((2 + I)**2).expand(complex=True) == 3\n\n    assert re(conjugate(x)) == re(x)\n    assert conjugate(re(x)) == re(x)\n\n    assert re(x).as_real_imag() == (re(x), 0)\n\n    assert re(i*r*x).diff(r) == re(i*x)\n    assert re(i*r*x).diff(i) == I*r*im(x)\n\n    assert re(\n        sqrt(a + b*I)) == (a**2 + b**2)**Rational(1, 4)*cos(atan2(b, a)/2)\n    assert re(a * (2 + b*I)) == 2*a\n\n    assert re((1 + sqrt(a + b*I))/2) == \\\n        (a**2 + b**2)**Rational(1, 4)*cos(atan2(b, a)/2)/2 + Rational(1, 2)\n\n    assert re(x).rewrite(im) == x - S.ImaginaryUnit*im(x)\n    assert (x + re(y)).rewrite(re, im) == x + y - S.ImaginaryUnit*im(y)\n\n    a = Symbol('a', algebraic=True)\n    t = Symbol('t', transcendental=True)\n    x = Symbol('x')\n    assert re(a).is_algebraic\n    assert re(x).is_algebraic is None\n    assert re(t).is_algebraic is False\n\n    assert re(S.ComplexInfinity) == S.NaN\n\n    n, m, l = symbols('n m l')\n    A = MatrixSymbol('A',n,m)\n    assert re(A) == (S(1)/2) * (A + conjugate(A))\n\n    A = Matrix([[1 + 4*I,2],[0, -3*I]])\n    assert re(A) == Matrix([[1, 2],[0, 0]])\n\n    A = ImmutableMatrix([[1 + 3*I, 3-2*I],[0, 2*I]])\n    assert re(A) == ImmutableMatrix([[1, 3],[0, 0]])\n\n    X = SparseMatrix([[2*j + i*I for i in range(5)] for j in range(5)])\n    assert re(X) - Matrix([[0, 0, 0, 0, 0],\n                           [2, 2, 2, 2, 2],\n                           [4, 4, 4, 4, 4],\n                           [6, 6, 6, 6, 6],\n                           [8, 8, 8, 8, 8]]) == Matrix.zeros(5)\n\n    assert im(X) - Matrix([[0, 1, 2, 3, 4],\n                           [0, 1, 2, 3, 4],\n                           [0, 1, 2, 3, 4],\n                           [0, 1, 2, 3, 4],\n                           [0, 1, 2, 3, 4]]) == Matrix.zeros(5)\n\n    X = FunctionMatrix(3, 3, Lambda((n, m), n + m*I))\n    assert re(X) == Matrix([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\n\n\ndef test_im():\n    x, y = symbols('x,y')\n    a, b = symbols('a,b', real=True)\n\n    r = Symbol('r', real=True)\n    i = Symbol('i', imaginary=True)\n\n    assert im(nan) == nan\n\n    assert im(oo*I) == oo\n    assert im(-oo*I) == -oo\n\n    assert im(0) == 0\n\n    assert im(1) == 0\n    assert im(-1) == 0\n\n    assert im(E*I) == E\n    assert im(-E*I) == -E\n\n    assert im(x) == im(x)\n    assert im(x*I) == re(x)\n    assert im(r*I) == r\n    assert im(r) == 0\n    assert im(i*I) == 0\n    assert im(i) == -I * i\n\n    assert im(x + y) == im(x + y)\n    assert im(x + r) == im(x)\n    assert im(x + r*I) == im(x) + r\n\n    assert im(im(x)*I) == im(x)\n\n    assert im(2 + I) == 1\n    assert im(x + I) == im(x) + 1\n\n    assert im(x + y*I) == im(x) + re(y)\n    assert im(x + r*I) == im(x) + r\n\n    assert im(log(2*I)) == pi/2\n\n    assert im((2 + I)**2).expand(complex=True) == 4\n\n    assert im(conjugate(x)) == -im(x)\n    assert conjugate(im(x)) == im(x)\n\n    assert im(x).as_real_imag() == (im(x), 0)\n\n    assert im(i*r*x).diff(r) == im(i*x)\n    assert im(i*r*x).diff(i) == -I * re(r*x)\n\n    assert im(\n        sqrt(a + b*I)) == (a**2 + b**2)**Rational(1, 4)*sin(atan2(b, a)/2)\n    assert im(a * (2 + b*I)) == a*b\n\n    assert im((1 + sqrt(a + b*I))/2) == \\\n        (a**2 + b**2)**Rational(1, 4)*sin(atan2(b, a)/2)/2\n\n    assert im(x).rewrite(re) == -S.ImaginaryUnit * (x - re(x))\n    assert (x + im(y)).rewrite(im, re) == x - S.ImaginaryUnit * (y - re(y))\n\n    a = Symbol('a', algebraic=True)\n    t = Symbol('t', transcendental=True)\n    x = Symbol('x')\n    assert re(a).is_algebraic\n    assert re(x).is_algebraic is None\n    assert re(t).is_algebraic is False\n\n    assert im(S.ComplexInfinity) == S.NaN\n\n    n, m, l = symbols('n m l')\n    A = MatrixSymbol('A',n,m)\n\n    assert im(A) == (S(1)/(2*I)) * (A - conjugate(A))\n\n    A = Matrix([[1 + 4*I, 2],[0, -3*I]])\n    assert im(A) == Matrix([[4, 0],[0, -3]])\n\n    A = ImmutableMatrix([[1 + 3*I, 3-2*I],[0, 2*I]])\n    assert im(A) == ImmutableMatrix([[3, -2],[0, 2]])\n\n    X = ImmutableSparseMatrix(\n            [[i*I + i for i in range(5)] for i in range(5)])\n    Y = SparseMatrix([[i for i in range(5)] for i in range(5)])\n    assert im(X).as_immutable() == Y\n\n    X = FunctionMatrix(3, 3, Lambda((n, m), n + m*I))\n    assert im(X) == Matrix([[0, 1, 2], [0, 1, 2], [0, 1, 2]])\n\ndef test_sign():\n    assert sign(1.2) == 1\n    assert sign(-1.2) == -1\n    assert sign(3*I) == I\n    assert sign(-3*I) == -I\n    assert sign(0) == 0\n    assert sign(nan) == nan\n    assert sign(2 + 2*I).doit() == sqrt(2)*(2 + 2*I)/4\n    assert sign(2 + 3*I).simplify() == sign(2 + 3*I)\n    assert sign(2 + 2*I).simplify() == sign(1 + I)\n    assert sign(im(sqrt(1 - sqrt(3)))) == 1\n    assert sign(sqrt(1 - sqrt(3))) == I\n\n    x = Symbol('x')\n    assert sign(x).is_finite is True\n    assert sign(x).is_complex is True\n    assert sign(x).is_imaginary is None\n    assert sign(x).is_integer is None\n    assert sign(x).is_real is None\n    assert sign(x).is_zero is None\n    assert sign(x).doit() == sign(x)\n    assert sign(1.2*x) == sign(x)\n    assert sign(2*x) == sign(x)\n    assert sign(I*x) == I*sign(x)\n    assert sign(-2*I*x) == -I*sign(x)\n    assert sign(conjugate(x)) == conjugate(sign(x))\n\n    p = Symbol('p', positive=True)\n    n = Symbol('n', negative=True)\n    m = Symbol('m', negative=True)\n    assert sign(2*p*x) == sign(x)\n    assert sign(n*x) == -sign(x)\n    assert sign(n*m*x) == sign(x)\n\n    x = Symbol('x', imaginary=True)\n    assert sign(x).is_imaginary is True\n    assert sign(x).is_integer is False\n    assert sign(x).is_real is False\n    assert sign(x).is_zero is False\n    assert sign(x).diff(x) == 2*DiracDelta(-I*x)\n    assert sign(x).doit() == x / Abs(x)\n    assert conjugate(sign(x)) == -sign(x)\n\n    x = Symbol('x', real=True)\n    assert sign(x).is_imaginary is False\n    assert sign(x).is_integer is True\n    assert sign(x).is_real is True\n    assert sign(x).is_zero is None\n    assert sign(x).diff(x) == 2*DiracDelta(x)\n    assert sign(x).doit() == sign(x)\n    assert conjugate(sign(x)) == sign(x)\n\n    x = Symbol('x', nonzero=True)\n    assert sign(x).is_imaginary is False\n    assert sign(x).is_integer is True\n    assert sign(x).is_real is True\n    assert sign(x).is_zero is False\n    assert sign(x).doit() == x / Abs(x)\n    assert sign(Abs(x)) == 1\n    assert Abs(sign(x)) == 1\n\n    x = Symbol('x', positive=True)\n    assert sign(x).is_imaginary is False\n    assert sign(x).is_integer is True\n    assert sign(x).is_real is True\n    assert sign(x).is_zero is False\n    assert sign(x).doit() == x / Abs(x)\n    assert sign(Abs(x)) == 1\n    assert Abs(sign(x)) == 1\n\n    x = 0\n    assert sign(x).is_imaginary is False\n    assert sign(x).is_integer is True\n    assert sign(x).is_real is True\n    assert sign(x).is_zero is True\n    assert sign(x).doit() == 0\n    assert sign(Abs(x)) == 0\n    assert Abs(sign(x)) == 0\n\n    nz = Symbol('nz', nonzero=True, integer=True)\n    assert sign(nz).is_imaginary is False\n    assert sign(nz).is_integer is True\n    assert sign(nz).is_real is True\n    assert sign(nz).is_zero is False\n    assert sign(nz)**2 == 1\n    assert (sign(nz)**3).args == (sign(nz), 3)\n\n    assert sign(Symbol('x', nonnegative=True)).is_nonnegative\n    assert sign(Symbol('x', nonnegative=True)).is_nonpositive is None\n    assert sign(Symbol('x', nonpositive=True)).is_nonnegative is None\n    assert sign(Symbol('x', nonpositive=True)).is_nonpositive\n    assert sign(Symbol('x', real=True)).is_nonnegative is None\n    assert sign(Symbol('x', real=True)).is_nonpositive is None\n    assert sign(Symbol('x', real=True, zero=False)).is_nonpositive is None\n\n    x, y = Symbol('x', real=True), Symbol('y')\n    assert sign(x).rewrite(Piecewise) == \\\n        Piecewise((1, x > 0), (-1, x < 0), (0, True))\n    assert sign(y).rewrite(Piecewise) == sign(y)\n    assert sign(x).rewrite(Heaviside) == 2*Heaviside(x)-1\n    assert sign(y).rewrite(Heaviside) == sign(y)\n\n    # evaluate what can be evaluated\n    assert sign(exp_polar(I*pi)*pi) is S.NegativeOne\n\n    eq = -sqrt(10 + 6*sqrt(3)) + sqrt(1 + sqrt(3)) + sqrt(3 + 3*sqrt(3))\n    # if there is a fast way to know when and when you cannot prove an\n    # expression like this is zero then the equality to zero is ok\n    assert sign(eq).func is sign or sign(eq) == 0\n    # but sometimes it's hard to do this so it's better not to load\n    # abs down with tests that will be very slow\n    q = 1 + sqrt(2) - 2*sqrt(3) + 1331*sqrt(6)\n    p = expand(q**3)**Rational(1, 3)\n    d = p - q\n    assert sign(d).func is sign or sign(d) == 0\n\n\ndef test_as_real_imag():\n    n = pi**1000\n    # the special code for working out the real\n    # and complex parts of a power with Integer exponent\n    # should not run if there is no imaginary part, hence\n    # this should not hang\n    assert n.as_real_imag() == (n, 0)\n\n    # issue 6261\n    x = Symbol('x')\n    assert sqrt(x).as_real_imag() == \\\n        ((re(x)**2 + im(x)**2)**(S(1)/4)*cos(atan2(im(x), re(x))/2),\n     (re(x)**2 + im(x)**2)**(S(1)/4)*sin(atan2(im(x), re(x))/2))\n\n    # issue 3853\n    a, b = symbols('a,b', real=True)\n    assert ((1 + sqrt(a + b*I))/2).as_real_imag() == \\\n           (\n               (a**2 + b**2)**Rational(\n                   1, 4)*cos(atan2(b, a)/2)/2 + Rational(1, 2),\n               (a**2 + b**2)**Rational(1, 4)*sin(atan2(b, a)/2)/2)\n\n    assert sqrt(a**2).as_real_imag() == (sqrt(a**2), 0)\n    i = symbols('i', imaginary=True)\n    assert sqrt(i**2).as_real_imag() == (0, abs(i))\n\n    assert ((1 + I)/(1 - I)).as_real_imag() == (0, 1)\n    assert ((1 + I)**3/(1 - I)).as_real_imag() == (-2, 0)\n\n\n@XFAIL\ndef test_sign_issue_3068():\n    n = pi**1000\n    i = int(n)\n    assert (n - i).round() == 1  # doesn't hang\n    assert sign(n - i) == 1\n    # perhaps it's not possible to get the sign right when\n    # only 1 digit is being requested for this situation;\n    # 2 digits works\n    assert (n - x).n(1, subs={x: i}) > 0\n    assert (n - x).n(2, subs={x: i}) > 0\n\n\ndef test_Abs():\n    raises(TypeError, lambda: Abs(Interval(2, 3)))  # issue 8717\n\n    x, y = symbols('x,y')\n    assert sign(sign(x)) == sign(x)\n    assert sign(x*y).func is sign\n    assert Abs(0) == 0\n    assert Abs(1) == 1\n    assert Abs(-1) == 1\n    assert Abs(I) == 1\n    assert Abs(-I) == 1\n    assert Abs(nan) == nan\n    assert Abs(zoo) == oo\n    assert Abs(I * pi) == pi\n    assert Abs(-I * pi) == pi\n    assert Abs(I * x) == Abs(x)\n    assert Abs(-I * x) == Abs(x)\n    assert Abs(-2*x) == 2*Abs(x)\n    assert Abs(-2.0*x) == 2.0*Abs(x)\n    assert Abs(2*pi*x*y) == 2*pi*Abs(x*y)\n    assert Abs(conjugate(x)) == Abs(x)\n    assert conjugate(Abs(x)) == Abs(x)\n    assert Abs(x).expand(complex=True) == sqrt(re(x)**2 + im(x)**2)\n\n    a = Symbol('a', positive=True)\n    assert Abs(2*pi*x*a) == 2*pi*a*Abs(x)\n    assert Abs(2*pi*I*x*a) == 2*pi*a*Abs(x)\n\n    x = Symbol('x', real=True)\n    n = Symbol('n', integer=True)\n    assert Abs((-1)**n) == 1\n    assert x**(2*n) == Abs(x)**(2*n)\n    assert Abs(x).diff(x) == sign(x)\n    assert abs(x) == Abs(x)  # Python built-in\n    assert Abs(x)**3 == x**2*Abs(x)\n    assert Abs(x)**4 == x**4\n    assert (\n        Abs(x)**(3*n)).args == (Abs(x), 3*n)  # leave symbolic odd unchanged\n    assert (1/Abs(x)).args == (Abs(x), -1)\n    assert 1/Abs(x)**3 == 1/(x**2*Abs(x))\n    assert Abs(x)**-3 == Abs(x)/(x**4)\n    assert Abs(x**3) == x**2*Abs(x)\n    assert Abs(I**I) == exp(-pi/2)\n    assert Abs((4 + 5*I)**(6 + 7*I)) == 68921*exp(-7*atan(S(5)/4))\n    y = Symbol('y', real=True)\n    assert Abs(I**y) == 1\n    y = Symbol('y')\n    assert Abs(I**y) == exp(-pi*im(y)/2)\n\n    x = Symbol('x', imaginary=True)\n    assert Abs(x).diff(x) == -sign(x)\n\n    eq = -sqrt(10 + 6*sqrt(3)) + sqrt(1 + sqrt(3)) + sqrt(3 + 3*sqrt(3))\n    # if there is a fast way to know when you can and when you cannot prove an\n    # expression like this is zero then the equality to zero is ok\n    assert abs(eq).func is Abs or abs(eq) == 0\n    # but sometimes it's hard to do this so it's better not to load\n    # abs down with tests that will be very slow\n    q = 1 + sqrt(2) - 2*sqrt(3) + 1331*sqrt(6)\n    p = expand(q**3)**Rational(1, 3)\n    d = p - q\n    assert abs(d).func is Abs or abs(d) == 0\n\n    assert Abs(4*exp(pi*I/4)) == 4\n    assert Abs(3**(2 + I)) == 9\n    assert Abs((-3)**(1 - I)) == 3*exp(pi)\n\n    assert Abs(oo) is oo\n    assert Abs(-oo) is oo\n    assert Abs(oo + I) is oo\n    assert Abs(oo + I*oo) is oo\n\n    a = Symbol('a', algebraic=True)\n    t = Symbol('t', transcendental=True)\n    x = Symbol('x')\n    assert re(a).is_algebraic\n    assert re(x).is_algebraic is None\n    assert re(t).is_algebraic is False\n\n\ndef test_Abs_rewrite():\n    x = Symbol('x', real=True)\n    a = Abs(x).rewrite(Heaviside).expand()\n    assert a == x*Heaviside(x) - x*Heaviside(-x)\n    for i in [-2, -1, 0, 1, 2]:\n        assert a.subs(x, i) == abs(i)\n    y = Symbol('y')\n    assert Abs(y).rewrite(Heaviside) == Abs(y)\n\n    x, y = Symbol('x', real=True), Symbol('y')\n    assert Abs(x).rewrite(Piecewise) == Piecewise((x, x >= 0), (-x, True))\n    assert Abs(y).rewrite(Piecewise) == Abs(y)\n    assert Abs(y).rewrite(sign) == y/sign(y)\n\n\ndef test_Abs_real():\n    # test some properties of abs that only apply\n    # to real numbers\n    x = Symbol('x', complex=True)\n    assert sqrt(x**2) != Abs(x)\n    assert Abs(x**2) != x**2\n\n    x = Symbol('x', real=True)\n    assert sqrt(x**2) == Abs(x)\n    assert Abs(x**2) == x**2\n\n    # if the symbol is zero, the following will still apply\n    nn = Symbol('nn', nonnegative=True, real=True)\n    np = Symbol('np', nonpositive=True, real=True)\n    assert Abs(nn) == nn\n    assert Abs(np) == -np\n\n\ndef test_Abs_properties():\n    x = Symbol('x')\n    assert Abs(x).is_real is True\n    assert Abs(x).is_rational is None\n    assert Abs(x).is_positive is None\n    assert Abs(x).is_nonnegative is True\n\n    z = Symbol('z', complex=True, zero=False)\n    assert Abs(z).is_real is True\n    assert Abs(z).is_rational is None\n    assert Abs(z).is_positive is True\n    assert Abs(z).is_zero is False\n\n    p = Symbol('p', positive=True)\n    assert Abs(p).is_real is True\n    assert Abs(p).is_rational is None\n    assert Abs(p).is_positive is True\n    assert Abs(p).is_zero is False\n\n    q = Symbol('q', rational=True)\n    assert Abs(q).is_rational is True\n    assert Abs(q).is_integer is None\n    assert Abs(q).is_positive is None\n    assert Abs(q).is_nonnegative is True\n\n    i = Symbol('i', integer=True)\n    assert Abs(i).is_integer is True\n    assert Abs(i).is_positive is None\n    assert Abs(i).is_nonnegative is True\n\n    e = Symbol('n', even=True)\n    ne = Symbol('ne', real=True, even=False)\n    assert Abs(e).is_even\n    assert Abs(ne).is_even is False\n    assert Abs(i).is_even is None\n\n    o = Symbol('n', odd=True)\n    no = Symbol('no', real=True, odd=False)\n    assert Abs(o).is_odd\n    assert Abs(no).is_odd is False\n    assert Abs(i).is_odd is None\n\n\ndef test_abs():\n    # this tests that abs calls Abs; don't rename to\n    # test_Abs since that test is already above\n    a = Symbol('a', positive=True)\n    assert abs(I*(1 + a)**2) == (1 + a)**2\n\n\ndef test_arg():\n    assert arg(0) == nan\n    assert arg(1) == 0\n    assert arg(-1) == pi\n    assert arg(I) == pi/2\n    assert arg(-I) == -pi/2\n    assert arg(1 + I) == pi/4\n    assert arg(-1 + I) == 3*pi/4\n    assert arg(1 - I) == -pi/4\n    assert arg(exp_polar(4*pi*I)) == 4*pi\n    assert arg(exp_polar(-7*pi*I)) == -7*pi\n    assert arg(exp_polar(5 - 3*pi*I/4)) == -3*pi/4\n    f = Function('f')\n    assert not arg(f(0) + I*f(1)).atoms(re)\n\n    p = Symbol('p', positive=True)\n    assert arg(p) == 0\n\n    n = Symbol('n', negative=True)\n    assert arg(n) == pi\n\n    x = Symbol('x')\n    assert conjugate(arg(x)) == arg(x)\n\n    e = p + I*p**2\n    assert arg(e) == arg(1 + p*I)\n    # make sure sign doesn't swap\n    e = -2*p + 4*I*p**2\n    assert arg(e) == arg(-1 + 2*p*I)\n    # make sure sign isn't lost\n    x = symbols('x', real=True)  # could be zero\n    e = x + I*x\n    assert arg(e) == arg(x*(1 + I))\n    assert arg(e/p) == arg(x*(1 + I))\n    e = p*cos(p) + I*log(p)*exp(p)\n    assert arg(e).args[0] == e\n    # keep it simple -- let the user do more advanced cancellation\n    e = (p + 1) + I*(p**2 - 1)\n    assert arg(e).args[0] == e\n\n    f = Function('f')\n    e = 2*x*(f(0) - 1) - 2*x*f(0)\n    assert arg(e) == arg(-2*x)\n    assert arg(f(0)).func == arg and arg(f(0)).args == (f(0),)\n\n\ndef test_arg_rewrite():\n    assert arg(1 + I) == atan2(1, 1)\n\n    x = Symbol('x', real=True)\n    y = Symbol('y', real=True)\n    assert arg(x + I*y).rewrite(atan2) == atan2(y, x)\n\n\ndef test_adjoint():\n    a = Symbol('a', antihermitian=True)\n    b = Symbol('b', hermitian=True)\n    assert adjoint(a) == -a\n    assert adjoint(I*a) == I*a\n    assert adjoint(b) == b\n    assert adjoint(I*b) == -I*b\n    assert adjoint(a*b) == -b*a\n    assert adjoint(I*a*b) == I*b*a\n\n    x, y = symbols('x y')\n    assert adjoint(adjoint(x)) == x\n    assert adjoint(x + y) == adjoint(x) + adjoint(y)\n    assert adjoint(x - y) == adjoint(x) - adjoint(y)\n    assert adjoint(x * y) == adjoint(x) * adjoint(y)\n    assert adjoint(x / y) == adjoint(x) / adjoint(y)\n    assert adjoint(-x) == -adjoint(x)\n\n    x, y = symbols('x y', commutative=False)\n    assert adjoint(adjoint(x)) == x\n    assert adjoint(x + y) == adjoint(x) + adjoint(y)\n    assert adjoint(x - y) == adjoint(x) - adjoint(y)\n    assert adjoint(x * y) == adjoint(y) * adjoint(x)\n    assert adjoint(x / y) == 1 / adjoint(y) * adjoint(x)\n    assert adjoint(-x) == -adjoint(x)\n\n\ndef test_conjugate():\n    a = Symbol('a', real=True)\n    b = Symbol('b', imaginary=True)\n    assert conjugate(a) == a\n    assert conjugate(I*a) == -I*a\n    assert conjugate(b) == -b\n    assert conjugate(I*b) == I*b\n    assert conjugate(a*b) == -a*b\n    assert conjugate(I*a*b) == I*a*b\n\n    x, y = symbols('x y')\n    assert conjugate(conjugate(x)) == x\n    assert conjugate(x + y) == conjugate(x) + conjugate(y)\n    assert conjugate(x - y) == conjugate(x) - conjugate(y)\n    assert conjugate(x * y) == conjugate(x) * conjugate(y)\n    assert conjugate(x / y) == conjugate(x) / conjugate(y)\n    assert conjugate(-x) == -conjugate(x)\n\n    a = Symbol('a', algebraic=True)\n    t = Symbol('t', transcendental=True)\n    assert re(a).is_algebraic\n    assert re(x).is_algebraic is None\n    assert re(t).is_algebraic is False\n\n\ndef test_conjugate_transpose():\n    x = Symbol('x')\n    assert conjugate(transpose(x)) == adjoint(x)\n    assert transpose(conjugate(x)) == adjoint(x)\n    assert adjoint(transpose(x)) == conjugate(x)\n    assert transpose(adjoint(x)) == conjugate(x)\n    assert adjoint(conjugate(x)) == transpose(x)\n    assert conjugate(adjoint(x)) == transpose(x)\n\n    class Symmetric(Expr):\n        def _eval_adjoint(self):\n            return None\n\n        def _eval_conjugate(self):\n            return None\n\n        def _eval_transpose(self):\n            return self\n    x = Symmetric()\n    assert conjugate(x) == adjoint(x)\n    assert transpose(x) == x\n\n\ndef test_transpose():\n    a = Symbol('a', complex=True)\n    assert transpose(a) == a\n    assert transpose(I*a) == I*a\n\n    x, y = symbols('x y')\n    assert transpose(transpose(x)) == x\n    assert transpose(x + y) == transpose(x) + transpose(y)\n    assert transpose(x - y) == transpose(x) - transpose(y)\n    assert transpose(x * y) == transpose(x) * transpose(y)\n    assert transpose(x / y) == transpose(x) / transpose(y)\n    assert transpose(-x) == -transpose(x)\n\n    x, y = symbols('x y', commutative=False)\n    assert transpose(transpose(x)) == x\n    assert transpose(x + y) == transpose(x) + transpose(y)\n    assert transpose(x - y) == transpose(x) - transpose(y)\n    assert transpose(x * y) == transpose(y) * transpose(x)\n    assert transpose(x / y) == 1 / transpose(y) * transpose(x)\n    assert transpose(-x) == -transpose(x)\n\n\ndef test_polarify():\n    from sympy import polar_lift, polarify\n    x = Symbol('x')\n    z = Symbol('z', polar=True)\n    f = Function('f')\n    ES = {}\n\n    assert polarify(-1) == (polar_lift(-1), ES)\n    assert polarify(1 + I) == (polar_lift(1 + I), ES)\n\n    assert polarify(exp(x), subs=False) == exp(x)\n    assert polarify(1 + x, subs=False) == 1 + x\n    assert polarify(f(I) + x, subs=False) == f(polar_lift(I)) + x\n\n    assert polarify(x, lift=True) == polar_lift(x)\n    assert polarify(z, lift=True) == z\n    assert polarify(f(x), lift=True) == f(polar_lift(x))\n    assert polarify(1 + x, lift=True) == polar_lift(1 + x)\n    assert polarify(1 + f(x), lift=True) == polar_lift(1 + f(polar_lift(x)))\n\n    newex, subs = polarify(f(x) + z)\n    assert newex.subs(subs) == f(x) + z\n\n    mu = Symbol(\"mu\")\n    sigma = Symbol(\"sigma\", positive=True)\n\n    # Make sure polarify(lift=True) doesn't try to lift the integration\n    # variable\n    assert polarify(\n        Integral(sqrt(2)*x*exp(-(-mu + x)**2/(2*sigma**2))/(2*sqrt(pi)*sigma),\n        (x, -oo, oo)), lift=True) == Integral(sqrt(2)*(sigma*exp_polar(0))**exp_polar(I*pi)*\n        exp((sigma*exp_polar(0))**(2*exp_polar(I*pi))*exp_polar(I*pi)*polar_lift(-mu + x)**\n        (2*exp_polar(0))/2)*exp_polar(0)*polar_lift(x)/(2*sqrt(pi)), (x, -oo, oo))\n\n\ndef test_unpolarify():\n    from sympy import (exp_polar, polar_lift, exp, unpolarify,\n                       principal_branch)\n    from sympy import gamma, erf, sin, tanh, uppergamma, Eq, Ne\n    from sympy.abc import x\n    p = exp_polar(7*I) + 1\n    u = exp(7*I) + 1\n\n    assert unpolarify(1) == 1\n    assert unpolarify(p) == u\n    assert unpolarify(p**2) == u**2\n    assert unpolarify(p**x) == p**x\n    assert unpolarify(p*x) == u*x\n    assert unpolarify(p + x) == u + x\n    assert unpolarify(sqrt(sin(p))) == sqrt(sin(u))\n\n    # Test reduction to principal branch 2*pi.\n    t = principal_branch(x, 2*pi)\n    assert unpolarify(t) == x\n    assert unpolarify(sqrt(t)) == sqrt(t)\n\n    # Test exponents_only.\n    assert unpolarify(p**p, exponents_only=True) == p**u\n    assert unpolarify(uppergamma(x, p**p)) == uppergamma(x, p**u)\n\n    # Test functions.\n    assert unpolarify(sin(p)) == sin(u)\n    assert unpolarify(tanh(p)) == tanh(u)\n    assert unpolarify(gamma(p)) == gamma(u)\n    assert unpolarify(erf(p)) == erf(u)\n    assert unpolarify(uppergamma(x, p)) == uppergamma(x, p)\n\n    assert unpolarify(uppergamma(sin(p), sin(p + exp_polar(0)))) == \\\n        uppergamma(sin(u), sin(u + 1))\n    assert unpolarify(uppergamma(polar_lift(0), 2*exp_polar(0))) == \\\n        uppergamma(0, 2)\n\n    assert unpolarify(Eq(p, 0)) == Eq(u, 0)\n    assert unpolarify(Ne(p, 0)) == Ne(u, 0)\n    assert unpolarify(polar_lift(x) > 0) == (x > 0)\n\n    # Test bools\n    assert unpolarify(True) is True\n\n\ndef test_issue_4035():\n    x = Symbol('x')\n    assert Abs(x).expand(trig=True) == Abs(x)\n    assert sign(x).expand(trig=True) == sign(x)\n    assert arg(x).expand(trig=True) == arg(x)\n\n\ndef test_issue_3206():\n    x = Symbol('x')\n    assert Abs(Abs(x)) == Abs(x)\n\n\ndef test_issue_4754_derivative_conjugate():\n    x = Symbol('x', real=True)\n    y = Symbol('y', imaginary=True)\n    f = Function('f')\n    assert (f(x).conjugate()).diff(x) == (f(x).diff(x)).conjugate()\n    assert (f(y).conjugate()).diff(y) == -(f(y).diff(y)).conjugate()\n\n\ndef test_derivatives_issue_4757():\n    x = Symbol('x', real=True)\n    y = Symbol('y', imaginary=True)\n    f = Function('f')\n    assert re(f(x)).diff(x) == re(f(x).diff(x))\n    assert im(f(x)).diff(x) == im(f(x).diff(x))\n    assert re(f(y)).diff(y) == -I*im(f(y).diff(y))\n    assert im(f(y)).diff(y) == -I*re(f(y).diff(y))\n    assert Abs(f(x)).diff(x).subs(f(x), 1 + I*x).doit() == x/sqrt(1 + x**2)\n    assert arg(f(x)).diff(x).subs(f(x), 1 + I*x**2).doit() == 2*x/(1 + x**4)\n    assert Abs(f(y)).diff(y).subs(f(y), 1 + y).doit() == -y/sqrt(1 - y**2)\n    assert arg(f(y)).diff(y).subs(f(y), I + y**2).doit() == 2*y/(1 + y**4)\n\n\ndef test_issue_11413():\n    from sympy import symbols, Matrix, simplify\n    v0 = Symbol('v0')\n    v1 = Symbol('v1')\n    v2 = Symbol('v2')\n    V = Matrix([[v0],[v1],[v2]])\n    U = V.normalized()\n    assert U == Matrix([\n    [v0/sqrt(Abs(v0)**2 + Abs(v1)**2 + Abs(v2)**2)],\n    [v1/sqrt(Abs(v0)**2 + Abs(v1)**2 + Abs(v2)**2)],\n    [v2/sqrt(Abs(v0)**2 + Abs(v1)**2 + Abs(v2)**2)]])\n    U.norm = sqrt(v0**2/(v0**2 + v1**2 + v2**2) + v1**2/(v0**2 + v1**2 + v2**2) + v2**2/(v0**2 + v1**2 + v2**2))\n    assert simplify(U.norm) == 1\n\ndef test_periodic_argument():\n    from sympy import (periodic_argument, unbranched_argument, oo,\n                       principal_branch, polar_lift, pi)\n    x = Symbol('x')\n    p = Symbol('p', positive=True)\n\n    assert unbranched_argument(2 + I) == periodic_argument(2 + I, oo)\n    assert unbranched_argument(1 + x) == periodic_argument(1 + x, oo)\n    assert N_equals(unbranched_argument((1 + I)**2), pi/2)\n    assert N_equals(unbranched_argument((1 - I)**2), -pi/2)\n    assert N_equals(periodic_argument((1 + I)**2, 3*pi), pi/2)\n    assert N_equals(periodic_argument((1 - I)**2, 3*pi), -pi/2)\n\n    assert unbranched_argument(principal_branch(x, pi)) == \\\n        periodic_argument(x, pi)\n\n    assert unbranched_argument(polar_lift(2 + I)) == unbranched_argument(2 + I)\n    assert periodic_argument(polar_lift(2 + I), 2*pi) == \\\n        periodic_argument(2 + I, 2*pi)\n    assert periodic_argument(polar_lift(2 + I), 3*pi) == \\\n        periodic_argument(2 + I, 3*pi)\n    assert periodic_argument(polar_lift(2 + I), pi) == \\\n        periodic_argument(polar_lift(2 + I), pi)\n\n    assert unbranched_argument(polar_lift(1 + I)) == pi/4\n    assert periodic_argument(2*p, p) == periodic_argument(p, p)\n    assert periodic_argument(pi*p, p) == periodic_argument(p, p)\n\n    assert Abs(polar_lift(1 + I)) == Abs(1 + I)\n\n\n@XFAIL\ndef test_principal_branch_fail():\n    # TODO XXX why does abs(x)._eval_evalf() not fall back to global evalf?\n    assert N_equals(principal_branch((1 + I)**2, pi/2), 0)\n\n\ndef test_principal_branch():\n    from sympy import principal_branch, polar_lift, exp_polar\n    p = Symbol('p', positive=True)\n    x = Symbol('x')\n    neg = Symbol('x', negative=True)\n\n    assert principal_branch(polar_lift(x), p) == principal_branch(x, p)\n    assert principal_branch(polar_lift(2 + I), p) == principal_branch(2 + I, p)\n    assert principal_branch(2*x, p) == 2*principal_branch(x, p)\n    assert principal_branch(1, pi) == exp_polar(0)\n    assert principal_branch(-1, 2*pi) == exp_polar(I*pi)\n    assert principal_branch(-1, pi) == exp_polar(0)\n    assert principal_branch(exp_polar(3*pi*I)*x, 2*pi) == \\\n        principal_branch(exp_polar(I*pi)*x, 2*pi)\n    assert principal_branch(neg*exp_polar(pi*I), 2*pi) == neg*exp_polar(-I*pi)\n\n    assert N_equals(principal_branch((1 + I)**2, 2*pi), 2*I)\n    assert N_equals(principal_branch((1 + I)**2, 3*pi), 2*I)\n    assert N_equals(principal_branch((1 + I)**2, 1*pi), 2*I)\n\n    # test argument sanitization\n    assert principal_branch(x, I).func is principal_branch\n    assert principal_branch(x, -4).func is principal_branch\n    assert principal_branch(x, -oo).func is principal_branch\n    assert principal_branch(x, zoo).func is principal_branch\n\n\n@XFAIL\ndef test_issue_6167_6151():\n    n = pi**1000\n    i = int(n)\n    assert sign(n - i) == 1\n    assert abs(n - i) == n - i\n    eps = pi**-1500\n    big = pi**1000\n    one = cos(x)**2 + sin(x)**2\n    e = big*one - big + eps\n    assert sign(simplify(e)) == 1\n    for xi in (111, 11, 1, S(1)/10):\n        assert sign(e.subs(x, xi)) == 1\n\n\ndef test_issue_14216():\n    from sympy.functions.elementary.complexes import unpolarify\n    A = MatrixSymbol(\"A\", 2, 2)\n    assert unpolarify(A[0, 0]) == A[0, 0]\n    assert unpolarify(A[0, 0]*A[1, 0]) == A[0, 0]*A[1, 0]\n\n\ndef test_issue_14238():\n    # doesn't cause recursion error\n    r = Symbol('r', real=True)\n    assert Abs(r + Piecewise((0, r > 0), (1 - r, True)))\n", "description": "A computer algebra system written in pure Python", "file_name": "test_complexes.py", "id": "e6ba02aaec5aa8ab37d7620e8d12f666", "language": "Python", "project_name": "sympy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/sympy-sympy/sympy-sympy-205da79/sympy/functions/elementary/tests/test_complexes.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:35:56Z", "url": "https://github.com/sympy/sympy", "wiki": true}