{"author": "powerline", "code": "\nfrom __future__ import (unicode_literals, division, absolute_import, print_function)\n\nimport os\nimport json\n\nfrom subprocess import check_call\nfrom shutil import rmtree\nfrom itertools import chain\n\nfrom powerline import Powerline\n\n\nCONFIG_DIR = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'config')\n\n\nclass TestPowerline(Powerline):\n\tdef __init__(self, _paths, *args, **kwargs):\n\t\tsuper(TestPowerline, self).__init__(*args, **kwargs)\n\t\tself._paths = _paths\n\n\tdef get_config_paths(self):\n\t\treturn self._paths\n\n\ndef mkdir_recursive(directory):\n\tif os.path.isdir(directory):\n\t\treturn\n\tmkdir_recursive(os.path.dirname(directory))\n\tos.mkdir(directory)\n\n\nclass FSTree(object):\n\t__slots__ = ('tree', 'p', 'p_kwargs', 'create_p', 'get_config_paths', 'root')\n\n\tdef __init__(\n\t\tself,\n\t\ttree,\n\t\tp_kwargs={'run_once': True},\n\t\troot=CONFIG_DIR,\n\t\tget_config_paths=lambda p: (p,),\n\t\tcreate_p=False\n\t):\n\t\tself.tree = tree\n\t\tself.root = root\n\t\tself.get_config_paths = get_config_paths\n\t\tself.create_p = create_p\n\t\tself.p = None\n\t\tself.p_kwargs = p_kwargs\n\n\tdef __enter__(self, *args):\n\t\tos.mkdir(self.root)\n\t\tfor k, v in self.tree.items():\n\t\t\tfname = os.path.join(self.root, k) + '.json'\n\t\t\tmkdir_recursive(os.path.dirname(fname))\n\t\t\twith open(fname, 'w') as F:\n\t\t\t\tjson.dump(v, F)\n\t\tif self.create_p:\n\t\t\tself.p = TestPowerline(\n\t\t\t\t_paths=self.get_config_paths(self.root),\n\t\t\t\text='test',\n\t\t\t\trenderer_module='tests.modules.lib.config_mock',\n\t\t\t\t**self.p_kwargs\n\t\t\t)\n\t\tif os.environ.get('POWERLINE_RUN_LINT_DURING_TESTS'):\n\t\t\ttry:\n\t\t\t\tcheck_call(chain(['scripts/powerline-lint'], *[\n\t\t\t\t\t('-p', d) for d in (\n\t\t\t\t\t\tself.p.get_config_paths() if self.p\n\t\t\t\t\t\telse self.get_config_paths(self.root)\n\t\t\t\t\t)\n\t\t\t\t]))\n\t\t\texcept:\n\t\t\t\tself.__exit__()\n\t\t\t\traise\n\t\treturn self.p and self.p.__enter__(*args)\n\n\tdef __exit__(self, *args):\n\t\ttry:\n\t\t\trmtree(self.root)\n\t\tfinally:\n\t\t\tif self.p:\n\t\t\t\tself.p.__exit__(*args)\n", "comments": "  vim fileencoding utf 8 noet ", "content": "# vim:fileencoding=utf-8:noet\nfrom __future__ import (unicode_literals, division, absolute_import, print_function)\n\nimport os\nimport json\n\nfrom subprocess import check_call\nfrom shutil import rmtree\nfrom itertools import chain\n\nfrom powerline import Powerline\n\n\nCONFIG_DIR = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'config')\n\n\nclass TestPowerline(Powerline):\n\tdef __init__(self, _paths, *args, **kwargs):\n\t\tsuper(TestPowerline, self).__init__(*args, **kwargs)\n\t\tself._paths = _paths\n\n\tdef get_config_paths(self):\n\t\treturn self._paths\n\n\ndef mkdir_recursive(directory):\n\tif os.path.isdir(directory):\n\t\treturn\n\tmkdir_recursive(os.path.dirname(directory))\n\tos.mkdir(directory)\n\n\nclass FSTree(object):\n\t__slots__ = ('tree', 'p', 'p_kwargs', 'create_p', 'get_config_paths', 'root')\n\n\tdef __init__(\n\t\tself,\n\t\ttree,\n\t\tp_kwargs={'run_once': True},\n\t\troot=CONFIG_DIR,\n\t\tget_config_paths=lambda p: (p,),\n\t\tcreate_p=False\n\t):\n\t\tself.tree = tree\n\t\tself.root = root\n\t\tself.get_config_paths = get_config_paths\n\t\tself.create_p = create_p\n\t\tself.p = None\n\t\tself.p_kwargs = p_kwargs\n\n\tdef __enter__(self, *args):\n\t\tos.mkdir(self.root)\n\t\tfor k, v in self.tree.items():\n\t\t\tfname = os.path.join(self.root, k) + '.json'\n\t\t\tmkdir_recursive(os.path.dirname(fname))\n\t\t\twith open(fname, 'w') as F:\n\t\t\t\tjson.dump(v, F)\n\t\tif self.create_p:\n\t\t\tself.p = TestPowerline(\n\t\t\t\t_paths=self.get_config_paths(self.root),\n\t\t\t\text='test',\n\t\t\t\trenderer_module='tests.modules.lib.config_mock',\n\t\t\t\t**self.p_kwargs\n\t\t\t)\n\t\tif os.environ.get('POWERLINE_RUN_LINT_DURING_TESTS'):\n\t\t\ttry:\n\t\t\t\tcheck_call(chain(['scripts/powerline-lint'], *[\n\t\t\t\t\t('-p', d) for d in (\n\t\t\t\t\t\tself.p.get_config_paths() if self.p\n\t\t\t\t\t\telse self.get_config_paths(self.root)\n\t\t\t\t\t)\n\t\t\t\t]))\n\t\t\texcept:\n\t\t\t\tself.__exit__()\n\t\t\t\traise\n\t\treturn self.p and self.p.__enter__(*args)\n\n\tdef __exit__(self, *args):\n\t\ttry:\n\t\t\trmtree(self.root)\n\t\tfinally:\n\t\t\tif self.p:\n\t\t\t\tself.p.__exit__(*args)\n", "description": "Powerline is a statusline plugin for vim, and provides statuslines and prompts for several other applications, including zsh, bash, tmux, IPython, Awesome and Qtile.", "file_name": "fsconfig.py", "id": "c99c6e28dc9ad39d29f84e646857bbf3", "language": "Python", "project_name": "powerline", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/powerline-powerline/powerline-powerline-d36850f/tests/modules/lib/fsconfig.py", "save_time": "", "source": "", "update_at": "2018-03-18T09:00:33Z", "url": "https://github.com/powerline/powerline", "wiki": false}