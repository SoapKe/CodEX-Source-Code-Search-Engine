{"author": "jakubroztocil", "code": "from httpie.compat import urlsplit, str\n\n\nclass HTTPMessage(object):\n    \n\n    def iter_body(self, chunk_size):\n        yield self.body\n\n    def iter_lines(self, chunk_size):\n        yield self.body, b''\n\n    @property\n    def headers(self):\n        url = urlsplit(self._orig.url)\n\n        request_line = '{method} {path}{query} HTTP/1.1'.format(\n            method=self._orig.method,\n            path=url.path or '/',\n            query='?' + url.query if url.query else ''\n        )\n\n        headers = dict(self._orig.headers)\n        if 'Host' not in self._orig.headers:\n            headers['Host'] = url.netloc.split('@')[-1]\n\n        headers = [\n            '%s: %s' % (\n                name,\n                value if isinstance(value, str) else value.decode('utf8')\n            )\n            for name, value in headers.items()\n        ]\n\n        headers.insert(0, request_line)\n        headers = '\\r\\n'.join(headers).strip()\n\n        if isinstance(headers, bytes):\n            \n            headers = headers.decode('utf8')\n        return headers\n\n    @property\n    def encoding(self):\n        return 'utf8'\n\n    @property\n    def body(self):\n        body = self._orig.body\n        if isinstance(body, str):\n            \n            body = body.encode('utf8')\n        return body or b''\n", "comments": "Abstract class for HTTP messages.\"\"\"\n\n    def __init__(self, orig):\n        self._orig = orig\n\n    def iter_body(self, chunk_size):\n        \"\"\"Return an iterator over the body.\"\"\"\n        raise NotImplementedError()\n\n    def iter_lines(self, chunk_size):\n        \"\"\"Return an iterator over the body yielding (`line`, `line_feed`).\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def headers(self):\n        \"\"\"Return a `str` with the message's headers.\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def encoding(self):\n        \"\"\"Return a `str` with the message's encoding, if known.\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def body(self):\n        \"\"\"Return a `bytes` with the message's body.\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def content_type(self):\n        \"\"\"Return the message content type.\"\"\"\n        ct = self._orig.headers.get('Content-Type', '')\n        if not isinstance(ct, str):\n            ct = ct.decode('utf8')\n        return ct\n\n\nclass HTTPResponse(HTTPMessage):\n    \"\"\"A :class:`requests.models.Response` wrapper.\"\"\"\n\n    def iter_body(self, chunk_size=1):\n        return self._orig.iter_content(chunk_size=chunk_size)\n\n    def iter_lines(self, chunk_size):\n        return ((line, b'\\n') for line in self._orig.iter_lines(chunk_size))\n\n    # noinspection PyProtectedMember\n    @property\n    def headers(self):\n        original = self._orig.raw._original_response\n\n        version = {\n            9: '0.9',\n            10: '1.0',\n            11: '1.1',\n            20: '2',\n        }[original.version]\n\n        status_line = 'HTTP/{version} {status} {reason}'.format(\n            version=version,\n            status=original.status,\n            reason=original.reason\n        )\n        headers = [status_line]\n        try:\n            # `original.msg` is a `http.client.HTTPMessage` on Python 3\n            # `_headers` is a 2-tuple\n            headers.extend(\n                '%s: %s' % header for header in original.msg._headers)\n        except AttributeError:\n            # and a `httplib.HTTPMessage` on Python 2.x\n            # `headers` is a list of `name: val<CRLF>`.\n            headers.extend(h.strip() for h in original.msg.headers)\n\n        return '\\r\\n'.join(headers)\n\n    @property\n    def encoding(self):\n        return self._orig.encoding or 'utf8'\n\n    @property\n    def body(self):\n        # Only now the response body is fetched.\n        # Shouldn't be touched unless the body is actually needed.\n        return self._orig.content\n\n\nclass HTTPRequest(HTTPMessage):\n    \"\"\"A :class:`requests.models.Request` wrapper.\n.\n# Python < 3\n# Happens with JSON/form request data parsed from the command line.\n", "content": "from httpie.compat import urlsplit, str\n\n\nclass HTTPMessage(object):\n    \"\"\"Abstract class for HTTP messages.\"\"\"\n\n    def __init__(self, orig):\n        self._orig = orig\n\n    def iter_body(self, chunk_size):\n        \"\"\"Return an iterator over the body.\"\"\"\n        raise NotImplementedError()\n\n    def iter_lines(self, chunk_size):\n        \"\"\"Return an iterator over the body yielding (`line`, `line_feed`).\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def headers(self):\n        \"\"\"Return a `str` with the message's headers.\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def encoding(self):\n        \"\"\"Return a `str` with the message's encoding, if known.\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def body(self):\n        \"\"\"Return a `bytes` with the message's body.\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def content_type(self):\n        \"\"\"Return the message content type.\"\"\"\n        ct = self._orig.headers.get('Content-Type', '')\n        if not isinstance(ct, str):\n            ct = ct.decode('utf8')\n        return ct\n\n\nclass HTTPResponse(HTTPMessage):\n    \"\"\"A :class:`requests.models.Response` wrapper.\"\"\"\n\n    def iter_body(self, chunk_size=1):\n        return self._orig.iter_content(chunk_size=chunk_size)\n\n    def iter_lines(self, chunk_size):\n        return ((line, b'\\n') for line in self._orig.iter_lines(chunk_size))\n\n    # noinspection PyProtectedMember\n    @property\n    def headers(self):\n        original = self._orig.raw._original_response\n\n        version = {\n            9: '0.9',\n            10: '1.0',\n            11: '1.1',\n            20: '2',\n        }[original.version]\n\n        status_line = 'HTTP/{version} {status} {reason}'.format(\n            version=version,\n            status=original.status,\n            reason=original.reason\n        )\n        headers = [status_line]\n        try:\n            # `original.msg` is a `http.client.HTTPMessage` on Python 3\n            # `_headers` is a 2-tuple\n            headers.extend(\n                '%s: %s' % header for header in original.msg._headers)\n        except AttributeError:\n            # and a `httplib.HTTPMessage` on Python 2.x\n            # `headers` is a list of `name: val<CRLF>`.\n            headers.extend(h.strip() for h in original.msg.headers)\n\n        return '\\r\\n'.join(headers)\n\n    @property\n    def encoding(self):\n        return self._orig.encoding or 'utf8'\n\n    @property\n    def body(self):\n        # Only now the response body is fetched.\n        # Shouldn't be touched unless the body is actually needed.\n        return self._orig.content\n\n\nclass HTTPRequest(HTTPMessage):\n    \"\"\"A :class:`requests.models.Request` wrapper.\"\"\"\n\n    def iter_body(self, chunk_size):\n        yield self.body\n\n    def iter_lines(self, chunk_size):\n        yield self.body, b''\n\n    @property\n    def headers(self):\n        url = urlsplit(self._orig.url)\n\n        request_line = '{method} {path}{query} HTTP/1.1'.format(\n            method=self._orig.method,\n            path=url.path or '/',\n            query='?' + url.query if url.query else ''\n        )\n\n        headers = dict(self._orig.headers)\n        if 'Host' not in self._orig.headers:\n            headers['Host'] = url.netloc.split('@')[-1]\n\n        headers = [\n            '%s: %s' % (\n                name,\n                value if isinstance(value, str) else value.decode('utf8')\n            )\n            for name, value in headers.items()\n        ]\n\n        headers.insert(0, request_line)\n        headers = '\\r\\n'.join(headers).strip()\n\n        if isinstance(headers, bytes):\n            # Python < 3\n            headers = headers.decode('utf8')\n        return headers\n\n    @property\n    def encoding(self):\n        return 'utf8'\n\n    @property\n    def body(self):\n        body = self._orig.body\n        if isinstance(body, str):\n            # Happens with JSON/form request data parsed from the command line.\n            body = body.encode('utf8')\n        return body or b''\n", "description": "Modern command line HTTP client \u2013 user-friendly curl alternative with intuitive UI, JSON support, syntax highlighting, wget-like downloads, extensions, etc.  https://httpie.org", "file_name": "models.py", "language": "Python", "project_name": "httpie", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/jakubroztocil_httpie/jakubroztocil-httpie-0f4dce9/httpie/models.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:20:06Z", "url": "https://github.com/jakubroztocil/httpie", "wiki": false}