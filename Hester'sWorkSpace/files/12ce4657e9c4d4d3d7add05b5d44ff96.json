{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom werkzeug.exceptions import NotFound, Forbidden\n\nfrom odoo import http\nfrom odoo.http import request\nfrom odoo.osv import expression\nfrom odoo.tools import consteq, plaintext2html\n\n\ndef _has_token_access(res_model, res_id, token=''):\n    record = request.env[res_model].browse(res_id).sudo()\n    token_field = request.env[res_model]._mail_post_token_field\n    return (token and record and consteq(record[token_field], token))\n\ndef _message_post_helper(res_model='', res_id=None, message='', token='', nosubscribe=True, **kw):\n    \"\"\" Generic chatter function, allowing to write on *any* object that inherits mail.thread.\n        If a token is specified, all logged in users will be able to write a message regardless\n        of access rights; if the user is the public user, the message will be posted under the name\n        of the partner_id of the object (or the public user if there is no partner_id on the object).\n\n        :param string res_model: model name of the object\n        :param int res_id: id of the object\n        :param string message: content of the message\n\n        optional keywords arguments:\n        :param string token: access token if the object's model uses some kind of public access\n                             using tokens (usually a uuid4) to bypass access rules\n        :param bool nosubscribe: set False if you want the partner to be set as follower of the object when posting (default to True)\n\n        The rest of the kwargs are passed on to message_post()\n    \"\"\"\n    record = request.env[res_model].browse(res_id)\n    author_id = request.env.user.partner_id.id if request.env.user.partner_id else False\n    if token:\n        access_as_sudo = _has_token_access(res_model, res_id, token=token)\n        if access_as_sudo:\n            record = record.sudo()\n            if request.env.user == request.env.ref('base.public_user'):\n                author_id = record.partner_id.id if hasattr(record, 'partner_id') else author_id\n            else:\n                if not author_id:\n                    raise NotFound()\n        else:\n            raise Forbidden()\n    kw.pop('csrf_token', None)\n    kw.pop('attachment_ids', None)\n    return record.with_context(mail_create_nosubscribe=nosubscribe).message_post(body=message,\n                                                                                   message_type=kw.pop('message_type', \"comment\"),\n                                                                                   subtype=kw.pop('subtype', \"mt_comment\"),\n                                                                                   author_id=author_id,\n                                                                                   **kw)\n\n\nclass PortalChatter(http.Controller):\n\n    @http.route(['/mail/chatter_post'], type='http', methods=['POST'], auth='public', website=True)\n    def portal_chatter_post(self, res_model, res_id, message, **kw):\n        url = request.httprequest.referrer\n        if message:\n            \n            message = plaintext2html(message)\n            _message_post_helper(res_model, int(res_id), message, **kw)\n            url = url + \"#discussion\"\n        return request.redirect(url)\n\n    @http.route('/mail/chatter_init', type='json', auth='public', website=True)\n    def portal_chatter_init(self, res_model, res_id, domain=False, limit=False, **kwargs):\n        is_user_public = request.env.user.has_group('base.group_public')\n        message_data = self.portal_message_fetch(res_model, res_id, domain=domain, limit=limit, **kwargs)\n        display_composer = False\n        if kwargs.get('allow_composer'):\n            display_composer = kwargs.get('token') or not is_user_public\n        return {\n            'messages': message_data['messages'],\n            'options': {\n                'message_count': message_data['message_count'],\n                'is_user_public': is_user_public,\n                'is_user_publisher': request.env.user.has_group('website.group_website_publisher'),\n                'display_composer': display_composer,\n                'partner_id': request.env.user.partner_id.id\n            }\n        }\n\n    @http.route('/mail/chatter_fetch', type='json', auth='public', website=True)\n    def portal_message_fetch(self, res_model, res_id, domain=False, limit=10, offset=0, **kw):\n        if not domain:\n            domain = []\n        \n        \n        field_domain = request.env[res_model]._fields['website_message_ids'].domain\n        domain += field_domain(request.env[res_model]) if callable(field_domain) else field_domain\n        domain += [('res_id', '=', res_id)]\n        \n        Message = request.env['mail.message']\n        if kw.get('token'):\n            access_as_sudo = _has_token_access(res_model, res_id, token=kw.get('token'))\n            if not access_as_sudo:  \n                raise Forbidden()\n            # Non-employee see only messages with not internal subtype (aka, no internal logs)\n            if not request.env['res.users'].has_group('base.group_user'):\n                domain = expression.AND([['&', '&', ('subtype_id', '!=', False), ('subtype_id.internal', '=', False)], domain])\n            Message = request.env['mail.message'].sudo()\n        return {\n            'messages': Message.search(domain, limit=limit, offset=offset).portal_message_format(),\n            'message_count': Message.search_count(domain)\n        }\n", "comments": "    generic chatter function  allowing write   object inherits mail thread          if token specified  logged users able write message regardless         access rights  user public user  message posted name         partner id object (or public user partner id object)            param string res model  model name object          param int res id  id object          param string message  content message          optional keywords arguments           param string token  access token object model uses kind public access                              using tokens (usually uuid4) bypass access rules          param bool nosubscribe  set false want partner set follower object posting (default true)          the rest kwargs passed message post()                coding  utf 8        part odoo  see license file full copyright licensing details     message received plaintext saved html    only search website message ids  apply domain perform one search    extract domain  website message ids  field    check access    token correct  raise forbidden    non employee see messages internal subtype (aka  internal logs) ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom werkzeug.exceptions import NotFound, Forbidden\n\nfrom odoo import http\nfrom odoo.http import request\nfrom odoo.osv import expression\nfrom odoo.tools import consteq, plaintext2html\n\n\ndef _has_token_access(res_model, res_id, token=''):\n    record = request.env[res_model].browse(res_id).sudo()\n    token_field = request.env[res_model]._mail_post_token_field\n    return (token and record and consteq(record[token_field], token))\n\ndef _message_post_helper(res_model='', res_id=None, message='', token='', nosubscribe=True, **kw):\n    \"\"\" Generic chatter function, allowing to write on *any* object that inherits mail.thread.\n        If a token is specified, all logged in users will be able to write a message regardless\n        of access rights; if the user is the public user, the message will be posted under the name\n        of the partner_id of the object (or the public user if there is no partner_id on the object).\n\n        :param string res_model: model name of the object\n        :param int res_id: id of the object\n        :param string message: content of the message\n\n        optional keywords arguments:\n        :param string token: access token if the object's model uses some kind of public access\n                             using tokens (usually a uuid4) to bypass access rules\n        :param bool nosubscribe: set False if you want the partner to be set as follower of the object when posting (default to True)\n\n        The rest of the kwargs are passed on to message_post()\n    \"\"\"\n    record = request.env[res_model].browse(res_id)\n    author_id = request.env.user.partner_id.id if request.env.user.partner_id else False\n    if token:\n        access_as_sudo = _has_token_access(res_model, res_id, token=token)\n        if access_as_sudo:\n            record = record.sudo()\n            if request.env.user == request.env.ref('base.public_user'):\n                author_id = record.partner_id.id if hasattr(record, 'partner_id') else author_id\n            else:\n                if not author_id:\n                    raise NotFound()\n        else:\n            raise Forbidden()\n    kw.pop('csrf_token', None)\n    kw.pop('attachment_ids', None)\n    return record.with_context(mail_create_nosubscribe=nosubscribe).message_post(body=message,\n                                                                                   message_type=kw.pop('message_type', \"comment\"),\n                                                                                   subtype=kw.pop('subtype', \"mt_comment\"),\n                                                                                   author_id=author_id,\n                                                                                   **kw)\n\n\nclass PortalChatter(http.Controller):\n\n    @http.route(['/mail/chatter_post'], type='http', methods=['POST'], auth='public', website=True)\n    def portal_chatter_post(self, res_model, res_id, message, **kw):\n        url = request.httprequest.referrer\n        if message:\n            # message is received in plaintext and saved in html\n            message = plaintext2html(message)\n            _message_post_helper(res_model, int(res_id), message, **kw)\n            url = url + \"#discussion\"\n        return request.redirect(url)\n\n    @http.route('/mail/chatter_init', type='json', auth='public', website=True)\n    def portal_chatter_init(self, res_model, res_id, domain=False, limit=False, **kwargs):\n        is_user_public = request.env.user.has_group('base.group_public')\n        message_data = self.portal_message_fetch(res_model, res_id, domain=domain, limit=limit, **kwargs)\n        display_composer = False\n        if kwargs.get('allow_composer'):\n            display_composer = kwargs.get('token') or not is_user_public\n        return {\n            'messages': message_data['messages'],\n            'options': {\n                'message_count': message_data['message_count'],\n                'is_user_public': is_user_public,\n                'is_user_publisher': request.env.user.has_group('website.group_website_publisher'),\n                'display_composer': display_composer,\n                'partner_id': request.env.user.partner_id.id\n            }\n        }\n\n    @http.route('/mail/chatter_fetch', type='json', auth='public', website=True)\n    def portal_message_fetch(self, res_model, res_id, domain=False, limit=10, offset=0, **kw):\n        if not domain:\n            domain = []\n        # Only search into website_message_ids, so apply the same domain to perform only one search\n        # extract domain from the 'website_message_ids' field\n        field_domain = request.env[res_model]._fields['website_message_ids'].domain\n        domain += field_domain(request.env[res_model]) if callable(field_domain) else field_domain\n        domain += [('res_id', '=', res_id)]\n        # Check access\n        Message = request.env['mail.message']\n        if kw.get('token'):\n            access_as_sudo = _has_token_access(res_model, res_id, token=kw.get('token'))\n            if not access_as_sudo:  # if token is not correct, raise Forbidden\n                raise Forbidden()\n            # Non-employee see only messages with not internal subtype (aka, no internal logs)\n            if not request.env['res.users'].has_group('base.group_user'):\n                domain = expression.AND([['&', '&', ('subtype_id', '!=', False), ('subtype_id.internal', '=', False)], domain])\n            Message = request.env['mail.message'].sudo()\n        return {\n            'messages': Message.search(domain, limit=limit, offset=offset).portal_message_format(),\n            'message_count': Message.search_count(domain)\n        }\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "mail.py", "id": "12ce4657e9c4d4d3d7add05b5d44ff96", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/portal/controllers/mail.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}