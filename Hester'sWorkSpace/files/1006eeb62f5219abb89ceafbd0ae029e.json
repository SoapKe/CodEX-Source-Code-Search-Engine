{"author": "jakubroztocil", "code": "from itertools import chain\nfrom functools import partial\n\nfrom httpie.compat import str\nfrom httpie.context import Environment\nfrom httpie.models import HTTPRequest, HTTPResponse\nfrom httpie.input import (OUT_REQ_BODY, OUT_REQ_HEAD,\n                          OUT_RESP_HEAD, OUT_RESP_BODY)\nfrom httpie.output.processing import Formatting, Conversion\n\n\nBINARY_SUPPRESSED_NOTICE = (\n    b'\\n'\n    b'+-----------------------------------------+\\n'\n    b'| NOTE: binary data not shown in terminal |\\n'\n    b'+-----------------------------------------+'\n)\n\n\nclass BinarySuppressedError(Exception):\n    \n\n    CHUNK_SIZE = 1024 * 10\n\n    def iter_body(self):\n        \n        \n        converter = None\n        body = bytearray()\n\n        for chunk in self.msg.iter_body(self.CHUNK_SIZE):\n            if not converter and b'\\0' in chunk:\n                converter = self.conversion.get_converter(self.mime)\n                if not converter:\n                    raise BinarySuppressedError()\n            body.extend(chunk)\n\n        if converter:\n            self.mime, body = converter.convert(body)\n\n        yield self.process_body(body)\n", "comments": "An error indicating that the body is binary and won't be written,\n     e.g., for terminal output).\"\"\"\n\n    message = BINARY_SUPPRESSED_NOTICE\n\n\ndef write_stream(stream, outfile, flush):\n    \"\"\"Write the output stream.\"\"\"\n    try:\n        # Writing bytes so we use the buffer interface (Python 3).\n        buf = outfile.buffer\n    except AttributeError:\n        buf = outfile\n\n    for chunk in stream:\n        buf.write(chunk)\n        if flush:\n            outfile.flush()\n\n\ndef write_stream_with_colors_win_py3(stream, outfile, flush):\n    \"\"\"Like `write`, but colorized chunks are written as text\n    directly to `outfile` to ensure it gets processed by colorama.\n    Applies only to Windows with Python 3 and colorized terminal output.\n\n    \"\"\"\n    color = b'\\x1b['\n    encoding = outfile.encoding\n    for chunk in stream:\n        if color in chunk:\n            outfile.write(chunk.decode(encoding))\n        else:\n            outfile.buffer.write(chunk)\n        if flush:\n            outfile.flush()\n\n\ndef build_output_stream(args, env, request, response, output_options):\n    \"\"\"Build and return a chain of iterators over the `request`-`response`\n    exchange each of which yields `bytes` chunks.\n\n    \"\"\"\n    req_h = OUT_REQ_HEAD in output_options\n    req_b = OUT_REQ_BODY in output_options\n    resp_h = OUT_RESP_HEAD in output_options\n    resp_b = OUT_RESP_BODY in output_options\n    req = req_h or req_b\n    resp = resp_h or resp_b\n\n    output = []\n    Stream = get_stream_type(env, args)\n\n    if req:\n        output.append(Stream(\n            msg=HTTPRequest(request),\n            with_headers=req_h,\n            with_body=req_b))\n\n    if req_b and resp:\n        # Request/Response separator.\n        output.append([b'\\n\\n'])\n\n    if resp:\n        output.append(Stream(\n            msg=HTTPResponse(response),\n            with_headers=resp_h,\n            with_body=resp_b))\n\n    if env.stdout_isatty and resp_b:\n        # Ensure a blank line after the response body.\n        # For terminal output only.\n        output.append([b'\\n\\n'])\n\n    return chain(*output)\n\n\ndef get_stream_type(env, args):\n    \"\"\"Pick the right stream type based on `env` and `args`.\n    Wrap it in a partial with the type-specific args so that\n    we don't need to think what stream we are dealing with.\n\n    \"\"\"\n    if not env.stdout_isatty and not args.prettify:\n        Stream = partial(\n            RawStream,\n            chunk_size=RawStream.CHUNK_SIZE_BY_LINE\n            if args.stream\n            else RawStream.CHUNK_SIZE\n        )\n    elif args.prettify:\n        Stream = partial(\n            PrettyStream if args.stream else BufferedPrettyStream,\n            env=env,\n            conversion=Conversion(),\n            formatting=Formatting(\n                env=env,\n                groups=args.prettify,\n                color_scheme=args.style,\n                explicit_json=args.json,\n            ),\n        )\n    else:\n        Stream = partial(EncodedStream, env=env)\n\n    return Stream\n\n\nclass BaseStream(object):\n    \"\"\"Base HTTP message output stream class.\"\"\"\n\n    def __init__(self, msg, with_headers=True, with_body=True,\n                 on_body_chunk_downloaded=None):\n        \"\"\"\n        :param msg: a :class:`models.HTTPMessage` subclass\n        :param with_headers: if `True`, headers will be included\n        :param with_body: if `True`, body will be included\n\n        \"\"\"\n        assert with_headers or with_body\n        self.msg = msg\n        self.with_headers = with_headers\n        self.with_body = with_body\n        self.on_body_chunk_downloaded = on_body_chunk_downloaded\n\n    def get_headers(self):\n        \"\"\"Return the headers' bytes.\"\"\"\n        return self.msg.headers.encode('utf8')\n\n    def iter_body(self):\n        \"\"\"Return an iterator over the message body.\"\"\"\n        raise NotImplementedError()\n\n    def __iter__(self):\n        \"\"\"Return an iterator over `self.msg`.\"\"\"\n        if self.with_headers:\n            yield self.get_headers()\n            yield b'\\r\\n\\r\\n'\n\n        if self.with_body:\n            try:\n                for chunk in self.iter_body():\n                    yield chunk\n                    if self.on_body_chunk_downloaded:\n                        self.on_body_chunk_downloaded(chunk)\n            except BinarySuppressedError as e:\n                if self.with_headers:\n                    yield b'\\n'\n                yield e.message\n\n\nclass RawStream(BaseStream):\n    \"\"\"The message is streamed in chunks with no processing.\"\"\"\n\n    CHUNK_SIZE = 1024 * 100\n    CHUNK_SIZE_BY_LINE = 1\n\n    def __init__(self, chunk_size=CHUNK_SIZE, **kwargs):\n        super(RawStream, self).__init__(**kwargs)\n        self.chunk_size = chunk_size\n\n    def iter_body(self):\n        return self.msg.iter_body(self.chunk_size)\n\n\nclass EncodedStream(BaseStream):\n    \"\"\"Encoded HTTP message stream.\n\n    The message bytes are converted to an encoding suitable for\n    `self.env.stdout`. Unicode errors are replaced and binary data\n    is suppressed. The body is always streamed by line.\n\n    \"\"\"\n    CHUNK_SIZE = 1\n\n    def __init__(self, env=Environment(), **kwargs):\n\n        super(EncodedStream, self).__init__(**kwargs)\n\n        if env.stdout_isatty:\n            # Use the encoding supported by the terminal.\n            output_encoding = env.stdout_encoding\n        else:\n            # Preserve the message encoding.\n            output_encoding = self.msg.encoding\n\n        # Default to utf8 when unsure.\n        self.output_encoding = output_encoding or 'utf8'\n\n    def iter_body(self):\n\n        for line, lf in self.msg.iter_lines(self.CHUNK_SIZE):\n\n            if b'\\0' in line:\n                raise BinarySuppressedError()\n\n            yield line.decode(self.msg.encoding) \\\n                      .encode(self.output_encoding, 'replace') + lf\n\n\nclass PrettyStream(EncodedStream):\n    \"\"\"In addition to :class:`EncodedStream` behaviour, this stream applies\n    content processing.\n\n    Useful for long-lived HTTP responses that stream by lines\n    such as the Twitter streaming API.\n\n    \"\"\"\n\n    CHUNK_SIZE = 1\n\n    def __init__(self, conversion, formatting, **kwargs):\n        super(PrettyStream, self).__init__(**kwargs)\n        self.formatting = formatting\n        self.conversion = conversion\n        self.mime = self.msg.content_type.split(';')[0]\n\n    def get_headers(self):\n        return self.formatting.format_headers(\n            self.msg.headers).encode(self.output_encoding)\n\n    def iter_body(self):\n        first_chunk = True\n        iter_lines = self.msg.iter_lines(self.CHUNK_SIZE)\n        for line, lf in iter_lines:\n            if b'\\0' in line:\n                if first_chunk:\n                    converter = self.conversion.get_converter(self.mime)\n                    if converter:\n                        body = bytearray()\n                        # noinspection PyAssignmentToLoopOrWithParameter\n                        for line, lf in chain([(line, lf)], iter_lines):\n                            body.extend(line)\n                            body.extend(lf)\n                        self.mime, body = converter.convert(body)\n                        assert isinstance(body, str)\n                        yield self.process_body(body)\n                        return\n                raise BinarySuppressedError()\n            yield self.process_body(line) + lf\n            first_chunk = False\n\n    def process_body(self, chunk):\n        if not isinstance(chunk, str):\n            # Text when a converter has been used,\n            # otherwise it will always be bytes.\n            chunk = chunk.decode(self.msg.encoding, 'replace')\n        chunk = self.formatting.format_body(content=chunk, mime=self.mime)\n        return chunk.encode(self.output_encoding, 'replace')\n\n\nclass BufferedPrettyStream(PrettyStream):\n    \"\"\"The same as :class:`PrettyStream` except that the body is fully\n    fetched before it's processed.\n\n    Suitable regular HTTP responses.\n\n    \n \n# Read the whole body before prettifying it,\n# but bail out immediately if the body is binary.\n", "content": "from itertools import chain\nfrom functools import partial\n\nfrom httpie.compat import str\nfrom httpie.context import Environment\nfrom httpie.models import HTTPRequest, HTTPResponse\nfrom httpie.input import (OUT_REQ_BODY, OUT_REQ_HEAD,\n                          OUT_RESP_HEAD, OUT_RESP_BODY)\nfrom httpie.output.processing import Formatting, Conversion\n\n\nBINARY_SUPPRESSED_NOTICE = (\n    b'\\n'\n    b'+-----------------------------------------+\\n'\n    b'| NOTE: binary data not shown in terminal |\\n'\n    b'+-----------------------------------------+'\n)\n\n\nclass BinarySuppressedError(Exception):\n    \"\"\"An error indicating that the body is binary and won't be written,\n     e.g., for terminal output).\"\"\"\n\n    message = BINARY_SUPPRESSED_NOTICE\n\n\ndef write_stream(stream, outfile, flush):\n    \"\"\"Write the output stream.\"\"\"\n    try:\n        # Writing bytes so we use the buffer interface (Python 3).\n        buf = outfile.buffer\n    except AttributeError:\n        buf = outfile\n\n    for chunk in stream:\n        buf.write(chunk)\n        if flush:\n            outfile.flush()\n\n\ndef write_stream_with_colors_win_py3(stream, outfile, flush):\n    \"\"\"Like `write`, but colorized chunks are written as text\n    directly to `outfile` to ensure it gets processed by colorama.\n    Applies only to Windows with Python 3 and colorized terminal output.\n\n    \"\"\"\n    color = b'\\x1b['\n    encoding = outfile.encoding\n    for chunk in stream:\n        if color in chunk:\n            outfile.write(chunk.decode(encoding))\n        else:\n            outfile.buffer.write(chunk)\n        if flush:\n            outfile.flush()\n\n\ndef build_output_stream(args, env, request, response, output_options):\n    \"\"\"Build and return a chain of iterators over the `request`-`response`\n    exchange each of which yields `bytes` chunks.\n\n    \"\"\"\n    req_h = OUT_REQ_HEAD in output_options\n    req_b = OUT_REQ_BODY in output_options\n    resp_h = OUT_RESP_HEAD in output_options\n    resp_b = OUT_RESP_BODY in output_options\n    req = req_h or req_b\n    resp = resp_h or resp_b\n\n    output = []\n    Stream = get_stream_type(env, args)\n\n    if req:\n        output.append(Stream(\n            msg=HTTPRequest(request),\n            with_headers=req_h,\n            with_body=req_b))\n\n    if req_b and resp:\n        # Request/Response separator.\n        output.append([b'\\n\\n'])\n\n    if resp:\n        output.append(Stream(\n            msg=HTTPResponse(response),\n            with_headers=resp_h,\n            with_body=resp_b))\n\n    if env.stdout_isatty and resp_b:\n        # Ensure a blank line after the response body.\n        # For terminal output only.\n        output.append([b'\\n\\n'])\n\n    return chain(*output)\n\n\ndef get_stream_type(env, args):\n    \"\"\"Pick the right stream type based on `env` and `args`.\n    Wrap it in a partial with the type-specific args so that\n    we don't need to think what stream we are dealing with.\n\n    \"\"\"\n    if not env.stdout_isatty and not args.prettify:\n        Stream = partial(\n            RawStream,\n            chunk_size=RawStream.CHUNK_SIZE_BY_LINE\n            if args.stream\n            else RawStream.CHUNK_SIZE\n        )\n    elif args.prettify:\n        Stream = partial(\n            PrettyStream if args.stream else BufferedPrettyStream,\n            env=env,\n            conversion=Conversion(),\n            formatting=Formatting(\n                env=env,\n                groups=args.prettify,\n                color_scheme=args.style,\n                explicit_json=args.json,\n            ),\n        )\n    else:\n        Stream = partial(EncodedStream, env=env)\n\n    return Stream\n\n\nclass BaseStream(object):\n    \"\"\"Base HTTP message output stream class.\"\"\"\n\n    def __init__(self, msg, with_headers=True, with_body=True,\n                 on_body_chunk_downloaded=None):\n        \"\"\"\n        :param msg: a :class:`models.HTTPMessage` subclass\n        :param with_headers: if `True`, headers will be included\n        :param with_body: if `True`, body will be included\n\n        \"\"\"\n        assert with_headers or with_body\n        self.msg = msg\n        self.with_headers = with_headers\n        self.with_body = with_body\n        self.on_body_chunk_downloaded = on_body_chunk_downloaded\n\n    def get_headers(self):\n        \"\"\"Return the headers' bytes.\"\"\"\n        return self.msg.headers.encode('utf8')\n\n    def iter_body(self):\n        \"\"\"Return an iterator over the message body.\"\"\"\n        raise NotImplementedError()\n\n    def __iter__(self):\n        \"\"\"Return an iterator over `self.msg`.\"\"\"\n        if self.with_headers:\n            yield self.get_headers()\n            yield b'\\r\\n\\r\\n'\n\n        if self.with_body:\n            try:\n                for chunk in self.iter_body():\n                    yield chunk\n                    if self.on_body_chunk_downloaded:\n                        self.on_body_chunk_downloaded(chunk)\n            except BinarySuppressedError as e:\n                if self.with_headers:\n                    yield b'\\n'\n                yield e.message\n\n\nclass RawStream(BaseStream):\n    \"\"\"The message is streamed in chunks with no processing.\"\"\"\n\n    CHUNK_SIZE = 1024 * 100\n    CHUNK_SIZE_BY_LINE = 1\n\n    def __init__(self, chunk_size=CHUNK_SIZE, **kwargs):\n        super(RawStream, self).__init__(**kwargs)\n        self.chunk_size = chunk_size\n\n    def iter_body(self):\n        return self.msg.iter_body(self.chunk_size)\n\n\nclass EncodedStream(BaseStream):\n    \"\"\"Encoded HTTP message stream.\n\n    The message bytes are converted to an encoding suitable for\n    `self.env.stdout`. Unicode errors are replaced and binary data\n    is suppressed. The body is always streamed by line.\n\n    \"\"\"\n    CHUNK_SIZE = 1\n\n    def __init__(self, env=Environment(), **kwargs):\n\n        super(EncodedStream, self).__init__(**kwargs)\n\n        if env.stdout_isatty:\n            # Use the encoding supported by the terminal.\n            output_encoding = env.stdout_encoding\n        else:\n            # Preserve the message encoding.\n            output_encoding = self.msg.encoding\n\n        # Default to utf8 when unsure.\n        self.output_encoding = output_encoding or 'utf8'\n\n    def iter_body(self):\n\n        for line, lf in self.msg.iter_lines(self.CHUNK_SIZE):\n\n            if b'\\0' in line:\n                raise BinarySuppressedError()\n\n            yield line.decode(self.msg.encoding) \\\n                      .encode(self.output_encoding, 'replace') + lf\n\n\nclass PrettyStream(EncodedStream):\n    \"\"\"In addition to :class:`EncodedStream` behaviour, this stream applies\n    content processing.\n\n    Useful for long-lived HTTP responses that stream by lines\n    such as the Twitter streaming API.\n\n    \"\"\"\n\n    CHUNK_SIZE = 1\n\n    def __init__(self, conversion, formatting, **kwargs):\n        super(PrettyStream, self).__init__(**kwargs)\n        self.formatting = formatting\n        self.conversion = conversion\n        self.mime = self.msg.content_type.split(';')[0]\n\n    def get_headers(self):\n        return self.formatting.format_headers(\n            self.msg.headers).encode(self.output_encoding)\n\n    def iter_body(self):\n        first_chunk = True\n        iter_lines = self.msg.iter_lines(self.CHUNK_SIZE)\n        for line, lf in iter_lines:\n            if b'\\0' in line:\n                if first_chunk:\n                    converter = self.conversion.get_converter(self.mime)\n                    if converter:\n                        body = bytearray()\n                        # noinspection PyAssignmentToLoopOrWithParameter\n                        for line, lf in chain([(line, lf)], iter_lines):\n                            body.extend(line)\n                            body.extend(lf)\n                        self.mime, body = converter.convert(body)\n                        assert isinstance(body, str)\n                        yield self.process_body(body)\n                        return\n                raise BinarySuppressedError()\n            yield self.process_body(line) + lf\n            first_chunk = False\n\n    def process_body(self, chunk):\n        if not isinstance(chunk, str):\n            # Text when a converter has been used,\n            # otherwise it will always be bytes.\n            chunk = chunk.decode(self.msg.encoding, 'replace')\n        chunk = self.formatting.format_body(content=chunk, mime=self.mime)\n        return chunk.encode(self.output_encoding, 'replace')\n\n\nclass BufferedPrettyStream(PrettyStream):\n    \"\"\"The same as :class:`PrettyStream` except that the body is fully\n    fetched before it's processed.\n\n    Suitable regular HTTP responses.\n\n    \"\"\"\n\n    CHUNK_SIZE = 1024 * 10\n\n    def iter_body(self):\n        # Read the whole body before prettifying it,\n        # but bail out immediately if the body is binary.\n        converter = None\n        body = bytearray()\n\n        for chunk in self.msg.iter_body(self.CHUNK_SIZE):\n            if not converter and b'\\0' in chunk:\n                converter = self.conversion.get_converter(self.mime)\n                if not converter:\n                    raise BinarySuppressedError()\n            body.extend(chunk)\n\n        if converter:\n            self.mime, body = converter.convert(body)\n\n        yield self.process_body(body)\n", "description": "Modern command line HTTP client \u2013 user-friendly curl alternative with intuitive UI, JSON support, syntax highlighting, wget-like downloads, extensions, etc.  https://httpie.org", "file_name": "streams.py", "language": "Python", "project_name": "httpie", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/jakubroztocil_httpie/jakubroztocil-httpie-0f4dce9/httpie/output/streams.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:20:06Z", "url": "https://github.com/jakubroztocil/httpie", "wiki": false}