{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\nimport base64\nimport json\nfrom ast import literal_eval\n\nfrom odoo import models, fields, api\n\n\nclass pos_cache(models.Model):\n    _name = 'pos.cache'\n\n    cache = fields.Binary(attachment=True)\n    product_domain = fields.Text(required=True)\n    product_fields = fields.Text(required=True)\n\n    config_id = fields.Many2one('pos.config', ondelete='cascade', required=True)\n    compute_user_id = fields.Many2one('res.users', 'Cache compute user', required=True)\n\n    @api.model\n    def refresh_all_caches(self):\n        self.env['pos.cache'].search([]).refresh_cache()\n\n    @api.one\n    def refresh_cache(self):\n        Product = self.env['product.product'].sudo(self.compute_user_id.id)\n        products = Product.search(self.get_product_domain())\n        prod_ctx = products.with_context(pricelist=self.config_id.pricelist_id.id, display_default_code=False,\n                                         lang=self.compute_user_id.lang)\n        res = prod_ctx.read(self.get_product_fields())\n        datas = {\n            'cache': base64.encodestring(json.dumps(res).encode('utf-8')),\n        }\n\n        self.write(datas)\n\n    @api.model\n    def get_product_domain(self):\n        return literal_eval(self.product_domain)\n\n    @api.model\n    def get_product_fields(self):\n        return literal_eval(self.product_fields)\n\n    @api.model\n    def get_cache(self, domain, fields):\n        if not self.cache or domain != self.get_product_domain() or fields != self.get_product_fields():\n            self.product_domain = str(domain)\n            self.product_fields = str(fields)\n            self.refresh_cache()\n\n        return json.loads(base64.decodestring(self.cache).decode('utf-8'))\n\n\nclass pos_config(models.Model):\n    _inherit = 'pos.config'\n\n    @api.one\n    @api.depends('cache_ids')\n    def _get_oldest_cache_time(self):\n        pos_cache = self.env['pos.cache']\n        oldest_cache = pos_cache.search([('config_id', '=', self.id)], order='write_date', limit=1)\n        if oldest_cache:\n            self.oldest_cache_time = oldest_cache.write_date\n\n    \n    cache_ids = fields.One2many('pos.cache', 'config_id')\n    oldest_cache_time = fields.Datetime(compute='_get_oldest_cache_time', string='Oldest cache time', readonly=True)\n\n    def _get_cache_for_user(self):\n        pos_cache = self.env['pos.cache']\n        cache_for_user = pos_cache.search([('id', 'in', self.cache_ids.ids), ('compute_user_id', '=', self.env.uid)])\n\n        if cache_for_user:\n            return cache_for_user[0]\n        else:\n            return None\n\n    @api.multi\n    def get_products_from_cache(self, fields, domain):\n        cache_for_user = self._get_cache_for_user()\n\n        if cache_for_user:\n            return cache_for_user.get_cache(domain, fields)\n        else:\n            pos_cache = self.env['pos.cache']\n            pos_cache.create({\n                'config_id': self.id,\n                'product_domain': str(domain),\n                'product_fields': str(fields),\n                'compute_user_id': self.env.uid\n            })\n            new_cache = self._get_cache_for_user()\n            return new_cache.get_cache(domain, fields)\n\n    @api.one\n    def delete_cache(self):\n        \n        self.cache_ids.unlink()\n", "comments": "      coding  utf 8        part odoo  see license file full copyright licensing details     use related model avoid load cache pos load config    throw away old caches ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\nimport base64\nimport json\nfrom ast import literal_eval\n\nfrom odoo import models, fields, api\n\n\nclass pos_cache(models.Model):\n    _name = 'pos.cache'\n\n    cache = fields.Binary(attachment=True)\n    product_domain = fields.Text(required=True)\n    product_fields = fields.Text(required=True)\n\n    config_id = fields.Many2one('pos.config', ondelete='cascade', required=True)\n    compute_user_id = fields.Many2one('res.users', 'Cache compute user', required=True)\n\n    @api.model\n    def refresh_all_caches(self):\n        self.env['pos.cache'].search([]).refresh_cache()\n\n    @api.one\n    def refresh_cache(self):\n        Product = self.env['product.product'].sudo(self.compute_user_id.id)\n        products = Product.search(self.get_product_domain())\n        prod_ctx = products.with_context(pricelist=self.config_id.pricelist_id.id, display_default_code=False,\n                                         lang=self.compute_user_id.lang)\n        res = prod_ctx.read(self.get_product_fields())\n        datas = {\n            'cache': base64.encodestring(json.dumps(res).encode('utf-8')),\n        }\n\n        self.write(datas)\n\n    @api.model\n    def get_product_domain(self):\n        return literal_eval(self.product_domain)\n\n    @api.model\n    def get_product_fields(self):\n        return literal_eval(self.product_fields)\n\n    @api.model\n    def get_cache(self, domain, fields):\n        if not self.cache or domain != self.get_product_domain() or fields != self.get_product_fields():\n            self.product_domain = str(domain)\n            self.product_fields = str(fields)\n            self.refresh_cache()\n\n        return json.loads(base64.decodestring(self.cache).decode('utf-8'))\n\n\nclass pos_config(models.Model):\n    _inherit = 'pos.config'\n\n    @api.one\n    @api.depends('cache_ids')\n    def _get_oldest_cache_time(self):\n        pos_cache = self.env['pos.cache']\n        oldest_cache = pos_cache.search([('config_id', '=', self.id)], order='write_date', limit=1)\n        if oldest_cache:\n            self.oldest_cache_time = oldest_cache.write_date\n\n    # Use a related model to avoid the load of the cache when the pos load his config\n    cache_ids = fields.One2many('pos.cache', 'config_id')\n    oldest_cache_time = fields.Datetime(compute='_get_oldest_cache_time', string='Oldest cache time', readonly=True)\n\n    def _get_cache_for_user(self):\n        pos_cache = self.env['pos.cache']\n        cache_for_user = pos_cache.search([('id', 'in', self.cache_ids.ids), ('compute_user_id', '=', self.env.uid)])\n\n        if cache_for_user:\n            return cache_for_user[0]\n        else:\n            return None\n\n    @api.multi\n    def get_products_from_cache(self, fields, domain):\n        cache_for_user = self._get_cache_for_user()\n\n        if cache_for_user:\n            return cache_for_user.get_cache(domain, fields)\n        else:\n            pos_cache = self.env['pos.cache']\n            pos_cache.create({\n                'config_id': self.id,\n                'product_domain': str(domain),\n                'product_fields': str(fields),\n                'compute_user_id': self.env.uid\n            })\n            new_cache = self._get_cache_for_user()\n            return new_cache.get_cache(domain, fields)\n\n    @api.one\n    def delete_cache(self):\n        # throw away the old caches\n        self.cache_ids.unlink()\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "pos_cache.py", "id": "d4067e6e904268ea6d5984f9d17f24e8", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/pos_cache/models/pos_cache.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}