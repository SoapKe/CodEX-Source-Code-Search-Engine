{"author": "sympy", "code": "import inspect\n\nfrom .dispatcher import Dispatcher, MethodDispatcher, ambiguity_warn\n\nglobal_namespace = dict()\n\n\ndef dispatch(*types, **kwargs):\n    \"\"\" Dispatch function on the types of the inputs\n\n    Supports dispatch on all non-keyword arguments.\n\n    Collects implementations based on the function name.  Ignores namespaces.\n\n    If ambiguous type signatures occur a warning is raised when the function is\n    defined suggesting the additional method to break the ambiguity.\n\n    Examples\n    --------\n\n    >>> from sympy.multipledispatch import dispatch\n    >>> @dispatch(int)\n    ... def f(x):\n    ...     return x + 1\n\n    >>> @dispatch(float)\n    ... def f(x):\n    ...     return x - 1\n\n    >>> f(3)\n    4\n    >>> f(3.0)\n    2.0\n\n    Specify an isolated namespace with the namespace keyword argument\n\n    >>> my_namespace = dict()\n    >>> @dispatch(int, namespace=my_namespace)\n    ... def foo(x):\n    ...     return x + 1\n\n    Dispatch on instance methods within classes\n\n    >>> class MyClass(object):\n    ...     @dispatch(list)\n    ...     def __init__(self, data):\n    ...         self.data = data\n    ...     @dispatch(int)\n    ...     def __init__(self, datum):\n    ...         self.data = [datum]\n    \"\"\"\n    namespace = kwargs.get('namespace', global_namespace)\n    on_ambiguity = kwargs.get('on_ambiguity', ambiguity_warn)\n\n    types = tuple(types)\n\n    def _(func):\n        name = func.__name__\n\n        if ismethod(func):\n            dispatcher = inspect.currentframe().f_back.f_locals.get(\n                name,\n                MethodDispatcher(name))\n        else:\n            if name not in namespace:\n                namespace[name] = Dispatcher(name)\n            dispatcher = namespace[name]\n\n        dispatcher.add(types, func, on_ambiguity=on_ambiguity)\n        return dispatcher\n    return _\n\n\ndef ismethod(func):\n    \"\"\" Is func a method?\n\n    Note that this has to work as the method is defined but before the class is\n    defined.  At this stage methods look like functions.\n    \"\"\"\n    if hasattr(inspect, \"signature\"):\n        signature = inspect.signature(func)\n        return signature.parameters.get('self', None) != None\n    else:\n        spec = inspect.getargspec(func)\n        return spec and spec.args and spec.args[0] == 'self'\n", "comments": "    dispatch function types inputs      supports dispatch non keyword arguments       collects implementations based function name   ignores namespaces       if ambiguous type signatures occur warning raised function     defined suggesting additional method break ambiguity       examples                       sympy multipledispatch import dispatch          dispatch(int)         def f(x)              return x   1           dispatch(float)         def f(x)              return x   1          f(3)     4         f(3 0)     2 0      specify isolated namespace namespace keyword argument          namespace   dict()          dispatch(int  namespace namespace)         def foo(x)              return x   1      dispatch instance methods within classes          class myclass(object)               dispatch(list)             def   init  (self  data)                  self data   data              dispatch(int)             def   init  (self  datum)                  self data    datum              namespace   kwargs get( namespace   global namespace)     ambiguity   kwargs get( ambiguity   ambiguity warn)      types   tuple(types)      def  (func)          name   func   name            ismethod(func)              dispatcher   inspect currentframe() f back f locals get(                 name                  methoddispatcher(name))         else              name namespace                  namespace name    dispatcher(name)             dispatcher   namespace name           dispatcher add(types  func  ambiguity ambiguity)         return dispatcher     return     def ismethod(func)          is func method       note work method defined class     defined   at stage methods look like functions          ", "content": "import inspect\n\nfrom .dispatcher import Dispatcher, MethodDispatcher, ambiguity_warn\n\nglobal_namespace = dict()\n\n\ndef dispatch(*types, **kwargs):\n    \"\"\" Dispatch function on the types of the inputs\n\n    Supports dispatch on all non-keyword arguments.\n\n    Collects implementations based on the function name.  Ignores namespaces.\n\n    If ambiguous type signatures occur a warning is raised when the function is\n    defined suggesting the additional method to break the ambiguity.\n\n    Examples\n    --------\n\n    >>> from sympy.multipledispatch import dispatch\n    >>> @dispatch(int)\n    ... def f(x):\n    ...     return x + 1\n\n    >>> @dispatch(float)\n    ... def f(x):\n    ...     return x - 1\n\n    >>> f(3)\n    4\n    >>> f(3.0)\n    2.0\n\n    Specify an isolated namespace with the namespace keyword argument\n\n    >>> my_namespace = dict()\n    >>> @dispatch(int, namespace=my_namespace)\n    ... def foo(x):\n    ...     return x + 1\n\n    Dispatch on instance methods within classes\n\n    >>> class MyClass(object):\n    ...     @dispatch(list)\n    ...     def __init__(self, data):\n    ...         self.data = data\n    ...     @dispatch(int)\n    ...     def __init__(self, datum):\n    ...         self.data = [datum]\n    \"\"\"\n    namespace = kwargs.get('namespace', global_namespace)\n    on_ambiguity = kwargs.get('on_ambiguity', ambiguity_warn)\n\n    types = tuple(types)\n\n    def _(func):\n        name = func.__name__\n\n        if ismethod(func):\n            dispatcher = inspect.currentframe().f_back.f_locals.get(\n                name,\n                MethodDispatcher(name))\n        else:\n            if name not in namespace:\n                namespace[name] = Dispatcher(name)\n            dispatcher = namespace[name]\n\n        dispatcher.add(types, func, on_ambiguity=on_ambiguity)\n        return dispatcher\n    return _\n\n\ndef ismethod(func):\n    \"\"\" Is func a method?\n\n    Note that this has to work as the method is defined but before the class is\n    defined.  At this stage methods look like functions.\n    \"\"\"\n    if hasattr(inspect, \"signature\"):\n        signature = inspect.signature(func)\n        return signature.parameters.get('self', None) != None\n    else:\n        spec = inspect.getargspec(func)\n        return spec and spec.args and spec.args[0] == 'self'\n", "description": "A computer algebra system written in pure Python", "file_name": "core.py", "id": "70db482556cf7e96b7c269cd21f9a273", "language": "Python", "project_name": "sympy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/sympy-sympy/sympy-sympy-205da79/sympy/multipledispatch/core.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:35:56Z", "url": "https://github.com/sympy/sympy", "wiki": true}