{"author": "keon", "code": "graph = {'A': set(['B', 'C', 'F']),\n         'B': set(['A', 'D', 'E']),\n         'C': set(['A', 'F']),\n         'D': set(['B']),\n         'E': set(['B', 'F']),\n         'F': set(['A', 'C', 'E'])}\n\n\n\n\n\n\ndef dfs_traverse(graph, start):\n    visited, stack = set(), [start]\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            for nextNode in graph[node]:\n                if nextNode not in visited:\n                    stack.append(nextNode)\n    return visited\n\n\n\n\ndef bfs_traverse(graph, start):\n    visited, queue = set(), [start]\n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.add(node)\n            for nextNode in graph[node]:\n                if nextNode not in visited:\n                    queue.append(nextNode)\n    return visited\n\n\n\ndef dfs_traverse_recursive(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    for nextNode in graph[start]:\n        if nextNode not in visited:\n            dfs_traverse_recursive(graph, nextNode, visited)\n    return visited\n\n\n\n\n    \n    \n    \n        \n    \n        \n    \n        \n            \n            \n    \n\n\n\n\n", "comments": "dfs bfs ultimately except visiting nodes different order to simulate ordering would use stack dfs queue bfs print(dfs_traverse(graph 'a')) print(bfs_traverse(graph 'a')) print(dfs_traverse_recursive(graph 'a')) def find_path(graph start end visited=[]): basecase visitied = visited + [start] start == end: return visited start graph: return none node graph[start]: node visited: new_visited = find_path(graph node end visited) return new_visited return none print(find_path(graph 'a' 'f'))", "content": "graph = {'A': set(['B', 'C', 'F']),\n         'B': set(['A', 'D', 'E']),\n         'C': set(['A', 'F']),\n         'D': set(['B']),\n         'E': set(['B', 'F']),\n         'F': set(['A', 'C', 'E'])}\n\n# dfs and bfs are the ultimately same except that they are visiting nodes in\n# different order. To simulate this ordering we would use stack for dfs and\n# queue for bfs.\n#\n\ndef dfs_traverse(graph, start):\n    visited, stack = set(), [start]\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            for nextNode in graph[node]:\n                if nextNode not in visited:\n                    stack.append(nextNode)\n    return visited\n\n# print(dfs_traverse(graph, 'A'))\n\n\ndef bfs_traverse(graph, start):\n    visited, queue = set(), [start]\n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.add(node)\n            for nextNode in graph[node]:\n                if nextNode not in visited:\n                    queue.append(nextNode)\n    return visited\n\n# print(bfs_traverse(graph, 'A'))\n\ndef dfs_traverse_recursive(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    for nextNode in graph[start]:\n        if nextNode not in visited:\n            dfs_traverse_recursive(graph, nextNode, visited)\n    return visited\n\n# print(dfs_traverse_recursive(graph, 'A'))\n\n# def find_path(graph, start, end, visited=[]):\n    # # basecase\n    # visitied = visited + [start]\n    # if start == end:\n        # return visited\n    # if start not in graph:\n        # return None\n    # for node in graph[start]:\n        # if node not in visited:\n            # new_visited = find_path(graph, node, end, visited)\n            # return new_visited\n    # return None\n\n# print(find_path(graph, 'A', 'F'))\n\n\n", "description": "Minimal examples of data structures and algorithms in Python", "file_name": "traversal.py", "id": "0ece714b9c1b05f06b8be092e9a5015d", "language": "Python", "project_name": "algorithms", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/keon-algorithms/keon-algorithms-abe4cb1/graph/traversal.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:56:36Z", "url": "https://github.com/keon/algorithms", "wiki": true}