{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nimport math\n\nfrom werkzeug import urls\n\nfrom odoo import fields as odoo_fields, tools, _\nfrom odoo.exceptions import ValidationError\nfrom odoo.http import Controller, request, route\n\n\n\n\n\ndef pager(url, total, page=1, step=30, scope=5, url_args=None):\n    \"\"\" Generate a dict with required value to render `website.pager` template. This method compute\n        url, page range to display, ... in the pager.\n        :param url : base url of the page link\n        :param total : number total of item to be splitted into pages\n        :param page : current page\n        :param step : item per page\n        :param scope : number of page to display on pager\n        :param url_args : additionnal parameters to add as query params to page url\n        :type url_args : dict\n        :returns dict\n    \"\"\"\n    \n    page_count = int(math.ceil(float(total) / step))\n\n    page = max(1, min(int(page if str(page).isdigit() else 1), page_count))\n    scope -= 1\n\n    pmin = max(page - int(math.floor(scope/2)), 1)\n    pmax = min(pmin + scope, page_count)\n\n    if pmax - pmin < scope:\n        pmin = pmax - scope if pmax - scope > 0 else 1\n\n    def get_url(page):\n        _url = \"%s/page/%s\" % (url, page) if page > 1 else url\n        if url_args:\n            _url = \"%s?%s\" % (_url, urls.url_encode(url_args))\n        return _url\n\n    return {\n        \"page_count\": page_count,\n        \"offset\": (page - 1) * step,\n        \"page\": {\n            'url': get_url(page),\n            'num': page\n        },\n        \"page_start\": {\n            'url': get_url(pmin),\n            'num': pmin\n        },\n        \"page_previous\": {\n            'url': get_url(max(pmin, page - 1)),\n            'num': max(pmin, page - 1)\n        },\n        \"page_next\": {\n            'url': get_url(min(pmax, page + 1)),\n            'num': min(pmax, page + 1)\n        },\n        \"page_end\": {\n            'url': get_url(pmax),\n            'num': pmax\n        },\n        \"pages\": [\n            {'url': get_url(page_num), 'num': page_num} for page_num in range(pmin, pmax+1)\n        ]\n    }\n\n\ndef get_records_pager(ids, current):\n    if current.id in ids and (hasattr(current, 'website_url') or hasattr(current, 'portal_url')):\n        attr_name = 'portal_url' if hasattr(current, 'portal_url') else 'website_url'\n        idx = ids.index(current.id)\n        return {\n            'prev_record': idx != 0 and getattr(current.browse(ids[idx - 1]), attr_name),\n            'next_record': idx < len(ids) - 1 and getattr(current.browse(ids[idx + 1]), attr_name),\n        }\n    return {}\n\n\ndef _build_url_w_params(url_string, query_params, remove_duplicates=True):\n    \"\"\" Rebuild a string url based on url_string and correctly compute query parameters\n    using those present in the url and those given by query_params. Having duplicates in\n    the final url is optional. For example:\n\n     * url_string = '/my?foo=bar&error=pay'\n     * query_params = {'foo': 'bar2', 'alice': 'bob'}\n     * if remove duplicates: result = '/my?foo=bar2&error=pay&alice=bob'\n     * else: result = '/my?foo=bar&foo=bar2&error=pay&alice=bob'\n    \"\"\"\n    url = urls.url_parse(url_string)\n    url_params = url.decode_query()\n    if remove_duplicates:  \n        url_params = url_params.to_dict()\n    url_params.update(query_params)\n    return url.replace(query=urls.url_encode(url_params)).to_url()\n\n\nclass CustomerPortal(Controller):\n\n    MANDATORY_BILLING_FIELDS = [\"name\", \"phone\", \"email\", \"street\", \"city\", \"country_id\"]\n    OPTIONAL_BILLING_FIELDS = [\"zipcode\", \"state_id\", \"vat\", \"company_name\"]\n\n    _items_per_page = 20\n\n    def _get_archive_groups(self, model, domain=None, fields=None, groupby=\"create_date\", order=\"create_date desc\"):\n        if not model:\n            return []\n        if domain is None:\n            domain = []\n        if fields is None:\n            fields = ['name', 'create_date']\n        groups = []\n        for group in request.env[model]._read_group_raw(domain, fields=fields, groupby=groupby, orderby=order):\n            dates, label = group[groupby]\n            date_begin, date_end = dates.split('/')\n            groups.append({\n                'date_begin': odoo_fields.Date.to_string(odoo_fields.Date.from_string(date_begin)),\n                'date_end': odoo_fields.Date.to_string(odoo_fields.Date.from_string(date_end)),\n                'name': label,\n                'item_count': group[groupby + '_count']\n            })\n        return groups\n\n    def _prepare_portal_layout_values(self):\n        \n        sales_user = False\n        partner = request.env.user.partner_id\n        if partner.user_id and not partner.user_id._is_public():\n            sales_user = partner.user_id\n\n        return {\n            'sales_user': sales_user,\n            'page_name': 'home',\n            'archive_groups': [],\n        }\n\n    @route(['/my', '/my/home'], type='http', auth=\"user\", website=True)\n    def home(self, **kw):\n        values = self._prepare_portal_layout_values()\n        return request.render(\"portal.portal_my_home\", values)\n\n    @route(['/my/account'], type='http', auth='user', website=True)\n    def account(self, redirect=None, **post):\n        values = self._prepare_portal_layout_values()\n        partner = request.env.user.partner_id\n        values.update({\n            'error': {},\n            'error_message': [],\n        })\n\n        if post:\n            error, error_message = self.details_form_validate(post)\n            values.update({'error': error, 'error_message': error_message})\n            values.update(post)\n            if not error:\n                values = {key: post[key] for key in self.MANDATORY_BILLING_FIELDS}\n                values.update({key: post[key] for key in self.OPTIONAL_BILLING_FIELDS if key in post})\n                values.update({'zip': values.pop('zipcode', '')})\n                partner.sudo().write(values)\n                if redirect:\n                    return request.redirect(redirect)\n                return request.redirect('/my/home')\n\n        countries = request.env['res.country'].sudo().search([])\n        states = request.env['res.country.state'].sudo().search([])\n\n        values.update({\n            'partner': partner,\n            'countries': countries,\n            'states': states,\n            'has_check_vat': hasattr(request.env['res.partner'], 'check_vat'),\n            'redirect': redirect,\n            'page_name': 'my_details',\n        })\n\n        response = request.render(\"portal.portal_my_details\", values)\n        response.headers['X-Frame-Options'] = 'DENY'\n        return response\n\n    def details_form_validate(self, data):\n        error = dict()\n        error_message = []\n\n        \n        for field_name in self.MANDATORY_BILLING_FIELDS:\n            if not data.get(field_name):\n                error[field_name] = 'missing'\n\n        \n        if data.get('email') and not tools.single_email_re.match(data.get('email')):\n            error[\"email\"] = 'error'\n            error_message.append(_('Invalid Email! Please enter a valid email address.'))\n\n        \n        partner = request.env[\"res.partner\"]\n        if data.get(\"vat\") and hasattr(partner, \"check_vat\"):\n            if data.get(\"country_id\"):\n                data[\"vat\"] = request.env[\"res.partner\"].fix_eu_vat_number(int(data.get(\"country_id\")), data.get(\"vat\"))\n            partner_dummy = partner.new({\n                'vat': data['vat'],\n                'country_id': (int(data['country_id'])\n                               if data.get('country_id') else False),\n            })\n            try:\n                partner_dummy.check_vat()\n            except ValidationError:\n                error[\"vat\"] = 'error'\n\n        \n        if [err for err in error.values() if err == 'missing']:\n            error_message.append(_('Some required fields are empty.'))\n\n        unknown = [k for k in data if k not in self.MANDATORY_BILLING_FIELDS + self.OPTIONAL_BILLING_FIELDS]\n        if unknown:\n            error['common'] = 'Unknown field'\n            error_message.append(\"Unknown field '%s'\" % ','.join(unknown))\n\n        return error, error_message\n", "comments": "    generate dict required value render  website pager  template  this method compute         url  page range display      pager           param url   base url page link          param total   number total item splitted pages          param page   current page          param step   item per page          param scope   number page display pager          param url args   additionnal parameters add query params page url          type url args   dict          returns dict               compute pager     page count   int(math ceil(float(total)   step))      page   max(1  min(int(page str(page) isdigit() else 1)  page count))     scope    1      pmin   max(page   int(math floor(scope 2))  1)     pmax   min(pmin   scope  page count)      pmax   pmin   scope          pmin   pmax   scope pmax   scope   0 else 1      def get url(page)           url     page     (url  page) page   1 else url         url args               url         ( url  urls url encode(url args))         return  url      return            page count   page count           offset   (page   1)   step           page                  url   get url(page)               num   page                     page start                  url   get url(pmin)               num   pmin                     page previous                  url   get url(max(pmin  page   1))               num   max(pmin  page   1)                     page next                  url   get url(min(pmax  page   1))               num   min(pmax  page   1)                     page end                  url   get url(pmax)               num   pmax                     pages                   url   get url(page num)   num   page num  page num range(pmin  pmax 1)                   def get records pager(ids  current)      current id ids (hasattr(current   website url ) hasattr(current   portal url ))          attr name    portal url  hasattr(current   portal url ) else  website url          idx   ids index(current id)         return                prev record   idx    0 getattr(current browse(ids idx   1 )  attr name)               next record   idx   len(ids)   1 getattr(current browse(ids idx   1 )  attr name)                return      def  build url w params(url string  query params  remove duplicates true)          rebuild string url based url string correctly compute query parameters     using present url given query params  having duplicates     final url optional  for example          url string     foo bar error pay         query params     foo    bar2    alice    bob          remove duplicates  result     foo bar2 error pay alice bob         else  result     foo bar foo bar2 error pay alice bob                 coding  utf 8        part odoo  see license file full copyright licensing details                                                           misc tools                                                          compute pager    convert standard dict instead werkzeug multidict remove duplicates automatically    get customer sales rep    validation    email validation    vat validation    error message empty required fields ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nimport math\n\nfrom werkzeug import urls\n\nfrom odoo import fields as odoo_fields, tools, _\nfrom odoo.exceptions import ValidationError\nfrom odoo.http import Controller, request, route\n\n# --------------------------------------------------\n# Misc tools\n# --------------------------------------------------\n\ndef pager(url, total, page=1, step=30, scope=5, url_args=None):\n    \"\"\" Generate a dict with required value to render `website.pager` template. This method compute\n        url, page range to display, ... in the pager.\n        :param url : base url of the page link\n        :param total : number total of item to be splitted into pages\n        :param page : current page\n        :param step : item per page\n        :param scope : number of page to display on pager\n        :param url_args : additionnal parameters to add as query params to page url\n        :type url_args : dict\n        :returns dict\n    \"\"\"\n    # Compute Pager\n    page_count = int(math.ceil(float(total) / step))\n\n    page = max(1, min(int(page if str(page).isdigit() else 1), page_count))\n    scope -= 1\n\n    pmin = max(page - int(math.floor(scope/2)), 1)\n    pmax = min(pmin + scope, page_count)\n\n    if pmax - pmin < scope:\n        pmin = pmax - scope if pmax - scope > 0 else 1\n\n    def get_url(page):\n        _url = \"%s/page/%s\" % (url, page) if page > 1 else url\n        if url_args:\n            _url = \"%s?%s\" % (_url, urls.url_encode(url_args))\n        return _url\n\n    return {\n        \"page_count\": page_count,\n        \"offset\": (page - 1) * step,\n        \"page\": {\n            'url': get_url(page),\n            'num': page\n        },\n        \"page_start\": {\n            'url': get_url(pmin),\n            'num': pmin\n        },\n        \"page_previous\": {\n            'url': get_url(max(pmin, page - 1)),\n            'num': max(pmin, page - 1)\n        },\n        \"page_next\": {\n            'url': get_url(min(pmax, page + 1)),\n            'num': min(pmax, page + 1)\n        },\n        \"page_end\": {\n            'url': get_url(pmax),\n            'num': pmax\n        },\n        \"pages\": [\n            {'url': get_url(page_num), 'num': page_num} for page_num in range(pmin, pmax+1)\n        ]\n    }\n\n\ndef get_records_pager(ids, current):\n    if current.id in ids and (hasattr(current, 'website_url') or hasattr(current, 'portal_url')):\n        attr_name = 'portal_url' if hasattr(current, 'portal_url') else 'website_url'\n        idx = ids.index(current.id)\n        return {\n            'prev_record': idx != 0 and getattr(current.browse(ids[idx - 1]), attr_name),\n            'next_record': idx < len(ids) - 1 and getattr(current.browse(ids[idx + 1]), attr_name),\n        }\n    return {}\n\n\ndef _build_url_w_params(url_string, query_params, remove_duplicates=True):\n    \"\"\" Rebuild a string url based on url_string and correctly compute query parameters\n    using those present in the url and those given by query_params. Having duplicates in\n    the final url is optional. For example:\n\n     * url_string = '/my?foo=bar&error=pay'\n     * query_params = {'foo': 'bar2', 'alice': 'bob'}\n     * if remove duplicates: result = '/my?foo=bar2&error=pay&alice=bob'\n     * else: result = '/my?foo=bar&foo=bar2&error=pay&alice=bob'\n    \"\"\"\n    url = urls.url_parse(url_string)\n    url_params = url.decode_query()\n    if remove_duplicates:  # convert to standard dict instead of werkzeug multidict to remove duplicates automatically\n        url_params = url_params.to_dict()\n    url_params.update(query_params)\n    return url.replace(query=urls.url_encode(url_params)).to_url()\n\n\nclass CustomerPortal(Controller):\n\n    MANDATORY_BILLING_FIELDS = [\"name\", \"phone\", \"email\", \"street\", \"city\", \"country_id\"]\n    OPTIONAL_BILLING_FIELDS = [\"zipcode\", \"state_id\", \"vat\", \"company_name\"]\n\n    _items_per_page = 20\n\n    def _get_archive_groups(self, model, domain=None, fields=None, groupby=\"create_date\", order=\"create_date desc\"):\n        if not model:\n            return []\n        if domain is None:\n            domain = []\n        if fields is None:\n            fields = ['name', 'create_date']\n        groups = []\n        for group in request.env[model]._read_group_raw(domain, fields=fields, groupby=groupby, orderby=order):\n            dates, label = group[groupby]\n            date_begin, date_end = dates.split('/')\n            groups.append({\n                'date_begin': odoo_fields.Date.to_string(odoo_fields.Date.from_string(date_begin)),\n                'date_end': odoo_fields.Date.to_string(odoo_fields.Date.from_string(date_end)),\n                'name': label,\n                'item_count': group[groupby + '_count']\n            })\n        return groups\n\n    def _prepare_portal_layout_values(self):\n        # get customer sales rep\n        sales_user = False\n        partner = request.env.user.partner_id\n        if partner.user_id and not partner.user_id._is_public():\n            sales_user = partner.user_id\n\n        return {\n            'sales_user': sales_user,\n            'page_name': 'home',\n            'archive_groups': [],\n        }\n\n    @route(['/my', '/my/home'], type='http', auth=\"user\", website=True)\n    def home(self, **kw):\n        values = self._prepare_portal_layout_values()\n        return request.render(\"portal.portal_my_home\", values)\n\n    @route(['/my/account'], type='http', auth='user', website=True)\n    def account(self, redirect=None, **post):\n        values = self._prepare_portal_layout_values()\n        partner = request.env.user.partner_id\n        values.update({\n            'error': {},\n            'error_message': [],\n        })\n\n        if post:\n            error, error_message = self.details_form_validate(post)\n            values.update({'error': error, 'error_message': error_message})\n            values.update(post)\n            if not error:\n                values = {key: post[key] for key in self.MANDATORY_BILLING_FIELDS}\n                values.update({key: post[key] for key in self.OPTIONAL_BILLING_FIELDS if key in post})\n                values.update({'zip': values.pop('zipcode', '')})\n                partner.sudo().write(values)\n                if redirect:\n                    return request.redirect(redirect)\n                return request.redirect('/my/home')\n\n        countries = request.env['res.country'].sudo().search([])\n        states = request.env['res.country.state'].sudo().search([])\n\n        values.update({\n            'partner': partner,\n            'countries': countries,\n            'states': states,\n            'has_check_vat': hasattr(request.env['res.partner'], 'check_vat'),\n            'redirect': redirect,\n            'page_name': 'my_details',\n        })\n\n        response = request.render(\"portal.portal_my_details\", values)\n        response.headers['X-Frame-Options'] = 'DENY'\n        return response\n\n    def details_form_validate(self, data):\n        error = dict()\n        error_message = []\n\n        # Validation\n        for field_name in self.MANDATORY_BILLING_FIELDS:\n            if not data.get(field_name):\n                error[field_name] = 'missing'\n\n        # email validation\n        if data.get('email') and not tools.single_email_re.match(data.get('email')):\n            error[\"email\"] = 'error'\n            error_message.append(_('Invalid Email! Please enter a valid email address.'))\n\n        # vat validation\n        partner = request.env[\"res.partner\"]\n        if data.get(\"vat\") and hasattr(partner, \"check_vat\"):\n            if data.get(\"country_id\"):\n                data[\"vat\"] = request.env[\"res.partner\"].fix_eu_vat_number(int(data.get(\"country_id\")), data.get(\"vat\"))\n            partner_dummy = partner.new({\n                'vat': data['vat'],\n                'country_id': (int(data['country_id'])\n                               if data.get('country_id') else False),\n            })\n            try:\n                partner_dummy.check_vat()\n            except ValidationError:\n                error[\"vat\"] = 'error'\n\n        # error message for empty required fields\n        if [err for err in error.values() if err == 'missing']:\n            error_message.append(_('Some required fields are empty.'))\n\n        unknown = [k for k in data if k not in self.MANDATORY_BILLING_FIELDS + self.OPTIONAL_BILLING_FIELDS]\n        if unknown:\n            error['common'] = 'Unknown field'\n            error_message.append(\"Unknown field '%s'\" % ','.join(unknown))\n\n        return error, error_message\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "portal.py", "id": "99fd7d1462f6b9226d82777c6baf2e0e", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/portal/controllers/portal.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}