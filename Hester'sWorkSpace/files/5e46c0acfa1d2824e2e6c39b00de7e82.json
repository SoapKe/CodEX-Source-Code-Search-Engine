{"author": "HelloZeroNet", "code": "import logging\nimport urllib2\nimport re\nimport time\nimport random\n\nimport gevent\n\nimport util\nfrom Config import config\nfrom FileRequest import FileRequest\nfrom Site import SiteManager\nfrom Debug import Debug\nfrom Connection import ConnectionServer\nfrom util import UpnpPunch\nfrom Plugin import PluginManager\n\n\n@PluginManager.acceptPlugins\nclass FileServer(ConnectionServer):\n\n    def __init__(self, ip=config.fileserver_ip, port=config.fileserver_port):\n        ConnectionServer.__init__(self, ip, port, self.handleRequest)\n\n        self.site_manager = SiteManager.site_manager\n        self.log = logging.getLogger(\"FileServer\")\n\n        if config.ip_external:  \n            self.port_opened = True\n            SiteManager.peer_blacklist.append((config.ip_external, self.port))  \n        else:\n            self.port_opened = None  \n        self.upnp_port_opened = False\n        self.sites = {}\n        self.last_request = time.time()\n        self.files_parsing = {}\n        self.ui_server = None\n\n    \n    def handleRequest(self, connection, message):\n        if config.verbose:\n            if \"params\" in message:\n                self.log.debug(\n                    \"FileRequest: %s %s %s %s\" %\n                    (str(connection), message[\"cmd\"], message[\"params\"].get(\"site\"), message[\"params\"].get(\"inner_path\"))\n                )\n            else:\n                self.log.debug(\"FileRequest: %s %s\" % (str(connection), message[\"cmd\"]))\n        req = FileRequest(self, connection)\n        req.route(message[\"cmd\"], message.get(\"req_id\"), message.get(\"params\"))\n        if not self.has_internet and not connection.is_private_ip:\n            self.has_internet = True\n            self.onInternetOnline()\n\n    def onInternetOnline(self):\n        self.log.info(\"Internet online\")\n        gevent.spawn(self.checkSites, check_files=False, force_port_check=True)\n\n    \n    def reload(self):\n        global FileRequest\n        import imp\n        FileRequest = imp.load_source(\"FileRequest\", \"src/File/FileRequest.py\").FileRequest\n\n    \n    def openport(self, port=None, check=True):\n        if not port:\n            port = self.port\n        if self.port_opened:\n            return True  \n        if check:  \n            time.sleep(1)  \n            if self.testOpenport(port, use_alternative=False)[\"result\"] is True:\n                return True  \n\n        if config.tor == \"always\":  \n            return False\n\n        self.log.info(\"Trying to open port using UpnpPunch...\")\n        try:\n            UpnpPunch.ask_to_open_port(self.port, 'ZeroNet', retries=3, protos=[\"TCP\"])\n        except Exception as err:\n            self.log.warning(\"UpnpPunch run error: %s\" % Debug.formatException(err))\n            return False\n\n        if self.testOpenport(port)[\"result\"] is True:\n            self.upnp_port_opened = True\n            return True\n        else:\n            self.log.info(\"Upnp mapping failed :( Please forward port %s on your router to your ipaddress\" % port)\n            return False\n\n    \n    def testOpenport(self, port=None, use_alternative=True):\n        if not port:\n            port = self.port\n        back = self.testOpenportPortchecker(port)\n        if (back[\"result\"] is not True and use_alternative) or back[\"result\"] is None:  \n            back = self.testOpenportCanyouseeme(port)\n\n        if self.ui_server:\n            self.ui_server.updateWebsocket()\n\n        return back\n\n    def testOpenportP2P(self, port=None):\n        self.log.info(\"Checking port %s using P2P...\" % port)\n        site = self.site_manager.get(config.homepage)\n        peers = []\n        res = None\n        if not site:    \n            return self.testOpenportPortchecker(port)  \n        peers = [peer for peer in site.getRecentPeers(10) if not peer.ip.endswith(\".onion\")]\n        if len(peers) < 3:   \n            return self.testOpenportPortchecker(port)  \n        for retry in range(0, 3):  \n            random_peer = random.choice(peers)\n            with gevent.Timeout(10.0, False):  \n                if not random_peer.connection:\n                    random_peer.connect()\n                if random_peer.connection and random_peer.connection.handshake.get(\"rev\") >= 2186:\n                    res = random_peer.request(\"checkport\", {\"port\": port})\n                    if res is not None:\n                        break  \n\n        if res is None:  \n            return self.testOpenportPortchecker(port)  \n        if res[\"status\"] == \"closed\":\n            if config.tor != \"always\":\n                self.log.info(\"[BAD :(] %s says that your port %s is closed\" % (random_peer.ip, port))\n            if port == self.port:\n                self.port_opened = False  \n                config.ip_external = res[\"ip_external\"]\n                SiteManager.peer_blacklist.append((config.ip_external, self.port))  \n            return {\"result\": False}\n        else:\n            self.log.info(\"[OK :)] %s says that your port %s is open\" % (random_peer.ip, port))\n            if port == self.port:  \n                self.port_opened = True\n                config.ip_external = res[\"ip_external\"]\n                SiteManager.peer_blacklist.append((config.ip_external, self.port))  \n            return {\"result\": True}\n\n    def testOpenportPortchecker(self, port=None):\n        self.log.info(\"Checking port %s using portchecker.co...\" % port)\n        try:\n            data = urllib2.urlopen(\"https://portchecker.co/check\", \"port=%s\" % port, timeout=20.0).read()\n            message = re.match('.*<div id=\"results-wrapper\">(.*?)</div>', data, re.DOTALL).group(1)\n            message = re.sub(\"<.*?>\", \"\", message.replace(\"<br>\", \" \").replace(\"&nbsp;\", \" \").strip())  \n        except Exception, err:\n            return {\"result\": None, \"message\": Debug.formatException(err)}\n\n        if \"open\" not in message:\n            if config.tor != \"always\":\n                self.log.info(\"[BAD :(] Port closed: %s\" % message)\n            if port == self.port:\n                self.port_opened = False  \n                match = re.match(\".*targetIP.*?value=\\\"(.*?)\\\"\", data, re.DOTALL)  \n                if match:  \n                    config.ip_external = match.group(1)\n                    SiteManager.peer_blacklist.append((config.ip_external, self.port))  \n                else:\n                    config.ip_external = False\n            return {\"result\": False, \"message\": message}\n        else:\n            self.log.info(\"[OK :)] Port open: %s\" % message)\n            if port == self.port:  \n                self.port_opened = True\n                match = re.match(\".*targetIP.*?value=\\\"(.*?)\\\"\", data, re.DOTALL)  \n                if match:  \n                    config.ip_external = match.group(1)\n                    SiteManager.peer_blacklist.append((config.ip_external, self.port))  \n                else:\n                    config.ip_external = False\n            return {\"result\": True, \"message\": message}\n\n    def testOpenportCanyouseeme(self, port=None):\n        self.log.info(\"Checking port %s using canyouseeme.org...\" % port)\n        try:\n            data = urllib2.urlopen(\"http://www.canyouseeme.org/\", \"port=%s\" % port, timeout=20.0).read()\n            message = re.match('.*<p style=\"padding-left:15px\">(.*?)</p>', data, re.DOTALL).group(1)\n            message = re.sub(\"<.*?>\", \"\", message.replace(\"<br>\", \" \").replace(\"&nbsp;\", \" \"))  \n        except Exception, err:\n            return {\"result\": None, \"message\": Debug.formatException(err)}\n\n        if \"Success\" not in message:\n            if config.tor != \"always\":\n                self.log.info(\"[BAD :(] Port closed: %s\" % message)\n            if port == self.port:\n                self.port_opened = False  \n                match = re.match(\".*?([0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+)\", message)  \n                if match:  \n                    config.ip_external = match.group(1)\n                    SiteManager.peer_blacklist.append((config.ip_external, self.port))  \n                else:\n                    config.ip_external = False\n            return {\"result\": False, \"message\": message}\n        else:\n            self.log.info(\"[OK :)] Port open: %s\" % message)\n            if port == self.port:  \n                self.port_opened = True\n                match = re.match(\".*?([0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+)\", message)  \n                if match:  \n                    config.ip_external = match.group(1)\n                    SiteManager.peer_blacklist.append((config.ip_external, self.port))  \n                else:\n                    config.ip_external = False\n            return {\"result\": True, \"message\": message}\n\n    \n    def setIpExternal(self, ip_external):\n        logging.info(\"Setting external ip without testing: %s...\" % ip_external)\n        config.ip_external = ip_external\n        self.port_opened = True\n\n    \n    def checkSite(self, site, check_files=False):\n        if site.settings[\"serving\"]:\n            site.announce(mode=\"startup\")  \n            site.update(check_files=check_files)  \n            site.sendMyHashfield()\n            site.updateHashfield()\n            if len(site.peers) > 5:  \n                site.needConnections()\n\n    \n    @util.Noparallel()\n    def checkSites(self, check_files=False, force_port_check=False):\n        self.log.debug(\"Checking sites...\")\n        sites_checking = False\n        if self.port_opened is None or force_port_check:  \n            if len(self.sites) <= 2:  \n                sites_checking = True\n                for address, site in self.sites.items():\n                    gevent.spawn(self.checkSite, site, check_files)\n\n            if force_port_check:\n                self.port_opened = None\n            self.openport()\n            if self.port_opened is False:\n                self.tor_manager.startOnions()\n\n        if not sites_checking:\n            for site in sorted(self.sites.values(), key=lambda site: site.settings.get(\"modified\", 0), reverse=True):  \n                check_thread = gevent.spawn(self.checkSite, site, check_files)  \n                time.sleep(2)\n                if site.settings.get(\"modified\", 0) < time.time() - 60 * 60 * 24:  \n                    check_thread.join(timeout=5)\n\n    def cleanupSites(self):\n        import gc\n        startup = True\n        time.sleep(5 * 60)  \n        peers_protected = set([])\n        while 1:\n            \n            self.log.debug(\"Running site cleanup, connections: %s, internet: %s, protected peers: %s\" % (len(self.connections), self.has_internet, peers_protected))\n\n            for address, site in self.sites.items():\n                if not site.settings[\"serving\"]:\n                    continue\n\n                if not startup:\n                    site.cleanupPeers(peers_protected)\n\n                time.sleep(1)  \n\n            peers_protected = set([])\n            for address, site in self.sites.items():\n                if not site.settings[\"serving\"]:\n                    continue\n\n                if site.peers:\n                    with gevent.Timeout(10, exception=False):\n                        site.announcePex()\n\n                \n                if site.bad_files:\n                    site.retryBadFiles()\n\n                if time.time() - site.settings.get(\"modified\", 0) < 60 * 60 * 24 * 7:\n                    \n                    connected_num = site.needConnections(check_site_on_reconnect=True)\n\n                    if connected_num < config.connected_limit:  \n                        peers_protected.update([peer.key for peer in site.getConnectedPeers()])\n\n                time.sleep(1)  \n\n            site = None\n            gc.collect()  \n            startup = False\n            time.sleep(60 * 20)\n\n    def trackersFileReloader(self):\n        while 1:\n            config.loadTrackersFile()\n            time.sleep(60)\n\n    \n    def announceSites(self):\n        if config.trackers_file:\n            gevent.spawn(self.trackersFileReloader)\n\n        time.sleep(5 * 60)  \n        while 1:\n            s = time.time()\n            for address, site in self.sites.items():\n                if not site.settings[\"serving\"]:\n                    continue\n                site.announce(mode=\"update\", pex=False)\n                active_site = time.time() - site.settings.get(\"modified\", 0) < 24 * 60 * 60\n                if site.settings[\"own\"] or active_site:  \n                    site.needConnections(check_site_on_reconnect=True)\n                site.sendMyHashfield(3)\n                site.updateHashfield(3)\n                time.sleep(1)\n            taken = time.time() - s\n\n            sleep = max(0, 60 * 20 / len(config.trackers) - taken)  \n            self.log.debug(\"Site announce tracker done in %.3fs, sleeping for %ss...\" % (taken, sleep))\n            time.sleep(sleep)\n\n    \n    def wakeupWatcher(self):\n        last_time = time.time()\n        while 1:\n            time.sleep(30)\n            if time.time() - max(self.last_request, last_time) > 60 * 3:\n                \n                self.log.info(\n                    \"Wakeup detected: time warp from %s to %s (%s sleep seconds), acting like startup...\" %\n                    (last_time, time.time(), time.time() - last_time)\n                )\n                self.checkSites(check_files=False, force_port_check=True)\n            last_time = time.time()\n\n    \n    def start(self, check_sites=True):\n        self.sites = self.site_manager.list()\n        if config.debug:\n            \n            from Debug import DebugReloader\n            DebugReloader(self.reload)\n\n        if check_sites:  \n            gevent.spawn(self.checkSites)\n\n        thread_announce_sites = gevent.spawn(self.announceSites)\n        thread_cleanup_sites = gevent.spawn(self.cleanupSites)\n        thread_wakeup_watcher = gevent.spawn(self.wakeupWatcher)\n\n        ConnectionServer.start(self)\n\n        self.log.debug(\"Stopped.\")\n\n    def stop(self):\n        if self.running and self.upnp_port_opened:\n            self.log.debug('Closing port %d' % self.port)\n            try:\n                UpnpPunch.ask_to_close_port(self.port, protos=[\"TCP\"])\n                self.log.info('Closed port via upnp.')\n            except (UpnpPunch.UpnpError, UpnpPunch.IGDError), err:\n                self.log.info(\"Failed at attempt to use upnp to close port: %s\" % err)\n\n        return ConnectionServer.stop(self)\n", "comments": "  ip external defined arguments    add peer blacklist    is file server opened router    handle request fileserver    reload filerequest class prevent restarts debug mode    try open port using upnp    port already opened    check first already opened    wait port open    port already opened    port opening work tor mode    test port open    if success try alternative checker    first run  peers    fallback centralized service    not enough peers    fallback centralized service    try 3 peers    10 sec timeout  raise exception    all fine  exit loop    nobody answered    fallback centralized service    self port  update port opened status    add peer blacklist    self port  update port opened status    add peer blacklist    strip http tags    self port  update port opened status    try find external ip message    found ip message    add peer blacklist    self port  update port opened status    try find external ip message    found ip message    add peer blacklist    strip http tags    self port  update port opened status    try find external ip message    found ip message    add peer blacklist    self port  update port opened status    try find external ip message    found ip message    add peer blacklist    set external ip without testing    check site file integrity    announce site tracker    update site content json download changed files    keep active connections site 5 peers    check sites integrity    test open port tested yet    don wait port opening first startup    check sites integrity    check new thread    not active site  wait sec finish    sites already cleaned startup    sites health care every 20 min    prevent quick request    retry failed files    keep active connections site modified witin 7 days    this site small amount peers  protect closing    prevent quick request    implicit garbage collection    announce sites every 20 min    sites already announced startup    check connections frequently active sites speed first connections    query trackers one one 20 minutes evenly distributed    detects computer back wakeup    if taken 3 minute computer sleep mode    bind start serving sites    auto reload filerequest change    open port  update sites  check files integrity ", "content": "import logging\nimport urllib2\nimport re\nimport time\nimport random\n\nimport gevent\n\nimport util\nfrom Config import config\nfrom FileRequest import FileRequest\nfrom Site import SiteManager\nfrom Debug import Debug\nfrom Connection import ConnectionServer\nfrom util import UpnpPunch\nfrom Plugin import PluginManager\n\n\n@PluginManager.acceptPlugins\nclass FileServer(ConnectionServer):\n\n    def __init__(self, ip=config.fileserver_ip, port=config.fileserver_port):\n        ConnectionServer.__init__(self, ip, port, self.handleRequest)\n\n        self.site_manager = SiteManager.site_manager\n        self.log = logging.getLogger(\"FileServer\")\n\n        if config.ip_external:  # Ip external defined in arguments\n            self.port_opened = True\n            SiteManager.peer_blacklist.append((config.ip_external, self.port))  # Add myself to peer blacklist\n        else:\n            self.port_opened = None  # Is file server opened on router\n        self.upnp_port_opened = False\n        self.sites = {}\n        self.last_request = time.time()\n        self.files_parsing = {}\n        self.ui_server = None\n\n    # Handle request to fileserver\n    def handleRequest(self, connection, message):\n        if config.verbose:\n            if \"params\" in message:\n                self.log.debug(\n                    \"FileRequest: %s %s %s %s\" %\n                    (str(connection), message[\"cmd\"], message[\"params\"].get(\"site\"), message[\"params\"].get(\"inner_path\"))\n                )\n            else:\n                self.log.debug(\"FileRequest: %s %s\" % (str(connection), message[\"cmd\"]))\n        req = FileRequest(self, connection)\n        req.route(message[\"cmd\"], message.get(\"req_id\"), message.get(\"params\"))\n        if not self.has_internet and not connection.is_private_ip:\n            self.has_internet = True\n            self.onInternetOnline()\n\n    def onInternetOnline(self):\n        self.log.info(\"Internet online\")\n        gevent.spawn(self.checkSites, check_files=False, force_port_check=True)\n\n    # Reload the FileRequest class to prevent restarts in debug mode\n    def reload(self):\n        global FileRequest\n        import imp\n        FileRequest = imp.load_source(\"FileRequest\", \"src/File/FileRequest.py\").FileRequest\n\n    # Try to open the port using upnp\n    def openport(self, port=None, check=True):\n        if not port:\n            port = self.port\n        if self.port_opened:\n            return True  # Port already opened\n        if check:  # Check first if its already opened\n            time.sleep(1)  # Wait for port open\n            if self.testOpenport(port, use_alternative=False)[\"result\"] is True:\n                return True  # Port already opened\n\n        if config.tor == \"always\":  # Port opening won't work in Tor mode\n            return False\n\n        self.log.info(\"Trying to open port using UpnpPunch...\")\n        try:\n            UpnpPunch.ask_to_open_port(self.port, 'ZeroNet', retries=3, protos=[\"TCP\"])\n        except Exception as err:\n            self.log.warning(\"UpnpPunch run error: %s\" % Debug.formatException(err))\n            return False\n\n        if self.testOpenport(port)[\"result\"] is True:\n            self.upnp_port_opened = True\n            return True\n        else:\n            self.log.info(\"Upnp mapping failed :( Please forward port %s on your router to your ipaddress\" % port)\n            return False\n\n    # Test if the port is open\n    def testOpenport(self, port=None, use_alternative=True):\n        if not port:\n            port = self.port\n        back = self.testOpenportPortchecker(port)\n        if (back[\"result\"] is not True and use_alternative) or back[\"result\"] is None:  # If no success try alternative checker\n            back = self.testOpenportCanyouseeme(port)\n\n        if self.ui_server:\n            self.ui_server.updateWebsocket()\n\n        return back\n\n    def testOpenportP2P(self, port=None):\n        self.log.info(\"Checking port %s using P2P...\" % port)\n        site = self.site_manager.get(config.homepage)\n        peers = []\n        res = None\n        if not site:    # First run, has no any peers\n            return self.testOpenportPortchecker(port)  # Fallback to centralized service\n        peers = [peer for peer in site.getRecentPeers(10) if not peer.ip.endswith(\".onion\")]\n        if len(peers) < 3:   # Not enough peers\n            return self.testOpenportPortchecker(port)  # Fallback to centralized service\n        for retry in range(0, 3):  # Try 3 peers\n            random_peer = random.choice(peers)\n            with gevent.Timeout(10.0, False):  # 10 sec timeout, don't raise exception\n                if not random_peer.connection:\n                    random_peer.connect()\n                if random_peer.connection and random_peer.connection.handshake.get(\"rev\") >= 2186:\n                    res = random_peer.request(\"checkport\", {\"port\": port})\n                    if res is not None:\n                        break  # All fine, exit from for loop\n\n        if res is None:  # Nobody answered\n            return self.testOpenportPortchecker(port)  # Fallback to centralized service\n        if res[\"status\"] == \"closed\":\n            if config.tor != \"always\":\n                self.log.info(\"[BAD :(] %s says that your port %s is closed\" % (random_peer.ip, port))\n            if port == self.port:\n                self.port_opened = False  # Self port, update port_opened status\n                config.ip_external = res[\"ip_external\"]\n                SiteManager.peer_blacklist.append((config.ip_external, self.port))  # Add myself to peer blacklist\n            return {\"result\": False}\n        else:\n            self.log.info(\"[OK :)] %s says that your port %s is open\" % (random_peer.ip, port))\n            if port == self.port:  # Self port, update port_opened status\n                self.port_opened = True\n                config.ip_external = res[\"ip_external\"]\n                SiteManager.peer_blacklist.append((config.ip_external, self.port))  # Add myself to peer blacklist\n            return {\"result\": True}\n\n    def testOpenportPortchecker(self, port=None):\n        self.log.info(\"Checking port %s using portchecker.co...\" % port)\n        try:\n            data = urllib2.urlopen(\"https://portchecker.co/check\", \"port=%s\" % port, timeout=20.0).read()\n            message = re.match('.*<div id=\"results-wrapper\">(.*?)</div>', data, re.DOTALL).group(1)\n            message = re.sub(\"<.*?>\", \"\", message.replace(\"<br>\", \" \").replace(\"&nbsp;\", \" \").strip())  # Strip http tags\n        except Exception, err:\n            return {\"result\": None, \"message\": Debug.formatException(err)}\n\n        if \"open\" not in message:\n            if config.tor != \"always\":\n                self.log.info(\"[BAD :(] Port closed: %s\" % message)\n            if port == self.port:\n                self.port_opened = False  # Self port, update port_opened status\n                match = re.match(\".*targetIP.*?value=\\\"(.*?)\\\"\", data, re.DOTALL)  # Try find my external ip in message\n                if match:  # Found my ip in message\n                    config.ip_external = match.group(1)\n                    SiteManager.peer_blacklist.append((config.ip_external, self.port))  # Add myself to peer blacklist\n                else:\n                    config.ip_external = False\n            return {\"result\": False, \"message\": message}\n        else:\n            self.log.info(\"[OK :)] Port open: %s\" % message)\n            if port == self.port:  # Self port, update port_opened status\n                self.port_opened = True\n                match = re.match(\".*targetIP.*?value=\\\"(.*?)\\\"\", data, re.DOTALL)  # Try find my external ip in message\n                if match:  # Found my ip in message\n                    config.ip_external = match.group(1)\n                    SiteManager.peer_blacklist.append((config.ip_external, self.port))  # Add myself to peer blacklist\n                else:\n                    config.ip_external = False\n            return {\"result\": True, \"message\": message}\n\n    def testOpenportCanyouseeme(self, port=None):\n        self.log.info(\"Checking port %s using canyouseeme.org...\" % port)\n        try:\n            data = urllib2.urlopen(\"http://www.canyouseeme.org/\", \"port=%s\" % port, timeout=20.0).read()\n            message = re.match('.*<p style=\"padding-left:15px\">(.*?)</p>', data, re.DOTALL).group(1)\n            message = re.sub(\"<.*?>\", \"\", message.replace(\"<br>\", \" \").replace(\"&nbsp;\", \" \"))  # Strip http tags\n        except Exception, err:\n            return {\"result\": None, \"message\": Debug.formatException(err)}\n\n        if \"Success\" not in message:\n            if config.tor != \"always\":\n                self.log.info(\"[BAD :(] Port closed: %s\" % message)\n            if port == self.port:\n                self.port_opened = False  # Self port, update port_opened status\n                match = re.match(\".*?([0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+)\", message)  # Try find my external ip in message\n                if match:  # Found my ip in message\n                    config.ip_external = match.group(1)\n                    SiteManager.peer_blacklist.append((config.ip_external, self.port))  # Add myself to peer blacklist\n                else:\n                    config.ip_external = False\n            return {\"result\": False, \"message\": message}\n        else:\n            self.log.info(\"[OK :)] Port open: %s\" % message)\n            if port == self.port:  # Self port, update port_opened status\n                self.port_opened = True\n                match = re.match(\".*?([0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+)\", message)  # Try find my external ip in message\n                if match:  # Found my ip in message\n                    config.ip_external = match.group(1)\n                    SiteManager.peer_blacklist.append((config.ip_external, self.port))  # Add myself to peer blacklist\n                else:\n                    config.ip_external = False\n            return {\"result\": True, \"message\": message}\n\n    # Set external ip without testing\n    def setIpExternal(self, ip_external):\n        logging.info(\"Setting external ip without testing: %s...\" % ip_external)\n        config.ip_external = ip_external\n        self.port_opened = True\n\n    # Check site file integrity\n    def checkSite(self, site, check_files=False):\n        if site.settings[\"serving\"]:\n            site.announce(mode=\"startup\")  # Announce site to tracker\n            site.update(check_files=check_files)  # Update site's content.json and download changed files\n            site.sendMyHashfield()\n            site.updateHashfield()\n            if len(site.peers) > 5:  # Keep active connections if site having 5 or more peers\n                site.needConnections()\n\n    # Check sites integrity\n    @util.Noparallel()\n    def checkSites(self, check_files=False, force_port_check=False):\n        self.log.debug(\"Checking sites...\")\n        sites_checking = False\n        if self.port_opened is None or force_port_check:  # Test and open port if not tested yet\n            if len(self.sites) <= 2:  # Don't wait port opening on first startup\n                sites_checking = True\n                for address, site in self.sites.items():\n                    gevent.spawn(self.checkSite, site, check_files)\n\n            if force_port_check:\n                self.port_opened = None\n            self.openport()\n            if self.port_opened is False:\n                self.tor_manager.startOnions()\n\n        if not sites_checking:\n            for site in sorted(self.sites.values(), key=lambda site: site.settings.get(\"modified\", 0), reverse=True):  # Check sites integrity\n                check_thread = gevent.spawn(self.checkSite, site, check_files)  # Check in new thread\n                time.sleep(2)\n                if site.settings.get(\"modified\", 0) < time.time() - 60 * 60 * 24:  # Not so active site, wait some sec to finish\n                    check_thread.join(timeout=5)\n\n    def cleanupSites(self):\n        import gc\n        startup = True\n        time.sleep(5 * 60)  # Sites already cleaned up on startup\n        peers_protected = set([])\n        while 1:\n            # Sites health care every 20 min\n            self.log.debug(\"Running site cleanup, connections: %s, internet: %s, protected peers: %s\" % (len(self.connections), self.has_internet, peers_protected))\n\n            for address, site in self.sites.items():\n                if not site.settings[\"serving\"]:\n                    continue\n\n                if not startup:\n                    site.cleanupPeers(peers_protected)\n\n                time.sleep(1)  # Prevent too quick request\n\n            peers_protected = set([])\n            for address, site in self.sites.items():\n                if not site.settings[\"serving\"]:\n                    continue\n\n                if site.peers:\n                    with gevent.Timeout(10, exception=False):\n                        site.announcePex()\n\n                # Retry failed files\n                if site.bad_files:\n                    site.retryBadFiles()\n\n                if time.time() - site.settings.get(\"modified\", 0) < 60 * 60 * 24 * 7:\n                    # Keep active connections if site has been modified witin 7 days\n                    connected_num = site.needConnections(check_site_on_reconnect=True)\n\n                    if connected_num < config.connected_limit:  # This site has small amount of peers, protect them from closing\n                        peers_protected.update([peer.key for peer in site.getConnectedPeers()])\n\n                time.sleep(1)  # Prevent too quick request\n\n            site = None\n            gc.collect()  # Implicit garbage collection\n            startup = False\n            time.sleep(60 * 20)\n\n    def trackersFileReloader(self):\n        while 1:\n            config.loadTrackersFile()\n            time.sleep(60)\n\n    # Announce sites every 20 min\n    def announceSites(self):\n        if config.trackers_file:\n            gevent.spawn(self.trackersFileReloader)\n\n        time.sleep(5 * 60)  # Sites already announced on startup\n        while 1:\n            s = time.time()\n            for address, site in self.sites.items():\n                if not site.settings[\"serving\"]:\n                    continue\n                site.announce(mode=\"update\", pex=False)\n                active_site = time.time() - site.settings.get(\"modified\", 0) < 24 * 60 * 60\n                if site.settings[\"own\"] or active_site:  # Check connections more frequently on own and active sites to speed-up first connections\n                    site.needConnections(check_site_on_reconnect=True)\n                site.sendMyHashfield(3)\n                site.updateHashfield(3)\n                time.sleep(1)\n            taken = time.time() - s\n\n            sleep = max(0, 60 * 20 / len(config.trackers) - taken)  # Query all trackers one-by-one in 20 minutes evenly distributed\n            self.log.debug(\"Site announce tracker done in %.3fs, sleeping for %ss...\" % (taken, sleep))\n            time.sleep(sleep)\n\n    # Detects if computer back from wakeup\n    def wakeupWatcher(self):\n        last_time = time.time()\n        while 1:\n            time.sleep(30)\n            if time.time() - max(self.last_request, last_time) > 60 * 3:\n                # If taken more than 3 minute then the computer was in sleep mode\n                self.log.info(\n                    \"Wakeup detected: time warp from %s to %s (%s sleep seconds), acting like startup...\" %\n                    (last_time, time.time(), time.time() - last_time)\n                )\n                self.checkSites(check_files=False, force_port_check=True)\n            last_time = time.time()\n\n    # Bind and start serving sites\n    def start(self, check_sites=True):\n        self.sites = self.site_manager.list()\n        if config.debug:\n            # Auto reload FileRequest on change\n            from Debug import DebugReloader\n            DebugReloader(self.reload)\n\n        if check_sites:  # Open port, Update sites, Check files integrity\n            gevent.spawn(self.checkSites)\n\n        thread_announce_sites = gevent.spawn(self.announceSites)\n        thread_cleanup_sites = gevent.spawn(self.cleanupSites)\n        thread_wakeup_watcher = gevent.spawn(self.wakeupWatcher)\n\n        ConnectionServer.start(self)\n\n        self.log.debug(\"Stopped.\")\n\n    def stop(self):\n        if self.running and self.upnp_port_opened:\n            self.log.debug('Closing port %d' % self.port)\n            try:\n                UpnpPunch.ask_to_close_port(self.port, protos=[\"TCP\"])\n                self.log.info('Closed port via upnp.')\n            except (UpnpPunch.UpnpError, UpnpPunch.IGDError), err:\n                self.log.info(\"Failed at attempt to use upnp to close port: %s\" % err)\n\n        return ConnectionServer.stop(self)\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "FileServer.py", "id": "5e46c0acfa1d2824e2e6c39b00de7e82", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/File/FileServer.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}