{"author": "facebook", "code": " Copyright (c) 2017-present, Facebook, Inc.\n\n\n This source code is licensed under the BSD-style license found in the\n LICENSE file in the root directory of this source tree. An additional grant\n of patent rights can be found in the PATENTS file in the same directory.\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nimport numpy as np\nimport pandas as pd\n\n fb-block 1 start\nimport os\nfrom unittest import TestCase\nfrom fbprophet import Prophet\nfrom fbprophet import diagnostics\n\nDATA = pd.read_csv(\n    os.path.join(os.path.dirname(__file__), 'data.csv'), parse_dates=['ds']\n).head(100)\n fb-block 1 end\n fb-block 2\n\n\nclass TestDiagnostics(TestCase):\n\n    def __init__(self, *args, **kwargs):\n        super(TestDiagnostics, self).__init__(*args, **kwargs)\n         Use first 100 record in data.csv\n        self.__df = DATA\n\n    def test_simulated_historical_forecasts(self):\n        m = Prophet()\n        m.fit(self.__df)\n        k = 2\n        for p in [1, 10]:\n            for h in [1, 3]:\n                period = '{} days'.format(p)\n                horizon = '{} days'.format(h)\n                df_shf = diagnostics.simulated_historical_forecasts(\n                    m, horizon=horizon, k=k, period=period)\n                 All cutoff dates should be less than ds dates\n                self.assertTrue((df_shf['cutoff'] < df_shf['ds']).all())\n                 The unique size of output cutoff should be equal to 'k'\n                self.assertEqual(len(np.unique(df_shf['cutoff'])), k)\n                self.assertEqual(\n                    max(df_shf['ds'] - df_shf['cutoff']),\n                    pd.Timedelta(horizon),\n                )\n                dc = df_shf['cutoff'].diff()\n                dc = dc[dc > pd.Timedelta(0)].min()\n                self.assertTrue(dc >= pd.Timedelta(period))\n                 Each y in df_shf and self.__df with same ds should be equal\n                df_merged = pd.merge(df_shf, self.__df, 'left', on='ds')\n                self.assertAlmostEqual(\n                    np.sum((df_merged['y_x'] - df_merged['y_y']) ** 2), 0.0)\n\n    def test_simulated_historical_forecasts_logistic(self):\n        m = Prophet(growth='logistic')\n        df = self.__df.copy()\n        df['cap'] = 40\n        m.fit(df)\n        df_shf = diagnostics.simulated_historical_forecasts(\n            m, horizon='3 days', k=2, period='3 days')\n         All cutoff dates should be less than ds dates\n        self.assertTrue((df_shf['cutoff'] < df_shf['ds']).all())\n         The unique size of output cutoff should be equal to 'k'\n        self.assertEqual(len(np.unique(df_shf['cutoff'])), 2)\n         Each y in df_shf and self.__df with same ds should be equal\n        df_merged = pd.merge(df_shf, df, 'left', on='ds')\n        self.assertAlmostEqual(\n            np.sum((df_merged['y_x'] - df_merged['y_y']) ** 2), 0.0)\n\n    def test_simulated_historical_forecasts_extra_regressors(self):\n        m = Prophet()\n        m.add_seasonality(name='monthly', period=30.5, fourier_order=5)\n        m.add_regressor('extra')\n        df = self.__df.copy()\n        df['cap'] = 40\n        df['extra'] = range(df.shape[0])\n        m.fit(df)\n        df_shf = diagnostics.simulated_historical_forecasts(\n            m, horizon='3 days', k=2, period='3 days')\n         All cutoff dates should be less than ds dates\n        self.assertTrue((df_shf['cutoff'] < df_shf['ds']).all())\n         The unique size of output cutoff should be equal to 'k'\n        self.assertEqual(len(np.unique(df_shf['cutoff'])), 2)\n         Each y in df_shf and self.__df with same ds should be equal\n        df_merged = pd.merge(df_shf, df, 'left', on='ds')\n        self.assertAlmostEqual(\n            np.sum((df_merged['y_x'] - df_merged['y_y']) ** 2), 0.0)\n\n    def test_simulated_historical_forecasts_default_value_check(self):\n        m = Prophet()\n        m.fit(self.__df)\n         Default value of period should be equal to 0.5 * horizon\n        df_shf1 = diagnostics.simulated_historical_forecasts(\n            m, horizon='10 days', k=1)\n        df_shf2 = diagnostics.simulated_historical_forecasts(\n            m, horizon='10 days', k=1, period='5 days')\n        self.assertAlmostEqual(\n            ((df_shf1['y'] - df_shf2['y']) ** 2).sum(), 0.0)\n        self.assertAlmostEqual(\n            ((df_shf1['yhat'] - df_shf2['yhat']) ** 2).sum(), 0.0)\n\n    def test_cross_validation(self):\n        m = Prophet()\n        m.fit(self.__df)\n         Calculate the number of cutoff points(k)\n        horizon = pd.Timedelta('4 days')\n        period = pd.Timedelta('10 days')\n        k = 5\n        df_cv = diagnostics.cross_validation(\n            m, horizon='4 days', period='10 days', initial='90 days')\n         The unique size of output cutoff should be equal to 'k'\n        self.assertEqual(len(np.unique(df_cv['cutoff'])), k)\n        self.assertEqual(max(df_cv['ds'] - df_cv['cutoff']), horizon)\n        dc = df_cv['cutoff'].diff()\n        dc = dc[dc > pd.Timedelta(0)].min()\n        self.assertTrue(dc >= period)\n\n    def test_cross_validation_default_value_check(self):\n        m = Prophet()\n        m.fit(self.__df)\n         Default value of initial should be equal to 3 * horizon\n        df_cv1 = diagnostics.cross_validation(\n            m, horizon='32 days', period='10 days')\n        df_cv2 = diagnostics.cross_validation(\n            m, horizon='32 days', period='10 days', initial='96 days')\n        self.assertAlmostEqual(\n            ((df_cv1['y'] - df_cv2['y']) ** 2).sum(), 0.0)\n        self.assertAlmostEqual(\n            ((df_cv1['yhat'] - df_cv2['yhat']) ** 2).sum(), 0.0)\n", "comments": "  copyright (c) 2017 present  facebook  inc     all rights reserved        this source code licensed bsd style license found    license file root directory source tree  an additional grant    patent rights found patents file directory     fb block 1 start    fb block 1 end    fb block 2    use first 100 record data csv    all cutoff dates less ds dates    the unique size output cutoff equal  k     each df shf self   df ds equal    all cutoff dates less ds dates    the unique size output cutoff equal  k     each df shf self   df ds equal    all cutoff dates less ds dates    the unique size output cutoff equal  k     each df shf self   df ds equal    default value period equal 0 5   horizon    calculate number cutoff points(k)    the unique size output cutoff equal  k     default value initial equal 3   horizon ", "content": "# Copyright (c) 2017-present, Facebook, Inc.\n# All rights reserved.\n#\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree. An additional grant\n# of patent rights can be found in the PATENTS file in the same directory.\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nimport numpy as np\nimport pandas as pd\n\n# fb-block 1 start\nimport os\nfrom unittest import TestCase\nfrom fbprophet import Prophet\nfrom fbprophet import diagnostics\n\nDATA = pd.read_csv(\n    os.path.join(os.path.dirname(__file__), 'data.csv'), parse_dates=['ds']\n).head(100)\n# fb-block 1 end\n# fb-block 2\n\n\nclass TestDiagnostics(TestCase):\n\n    def __init__(self, *args, **kwargs):\n        super(TestDiagnostics, self).__init__(*args, **kwargs)\n        # Use first 100 record in data.csv\n        self.__df = DATA\n\n    def test_simulated_historical_forecasts(self):\n        m = Prophet()\n        m.fit(self.__df)\n        k = 2\n        for p in [1, 10]:\n            for h in [1, 3]:\n                period = '{} days'.format(p)\n                horizon = '{} days'.format(h)\n                df_shf = diagnostics.simulated_historical_forecasts(\n                    m, horizon=horizon, k=k, period=period)\n                # All cutoff dates should be less than ds dates\n                self.assertTrue((df_shf['cutoff'] < df_shf['ds']).all())\n                # The unique size of output cutoff should be equal to 'k'\n                self.assertEqual(len(np.unique(df_shf['cutoff'])), k)\n                self.assertEqual(\n                    max(df_shf['ds'] - df_shf['cutoff']),\n                    pd.Timedelta(horizon),\n                )\n                dc = df_shf['cutoff'].diff()\n                dc = dc[dc > pd.Timedelta(0)].min()\n                self.assertTrue(dc >= pd.Timedelta(period))\n                # Each y in df_shf and self.__df with same ds should be equal\n                df_merged = pd.merge(df_shf, self.__df, 'left', on='ds')\n                self.assertAlmostEqual(\n                    np.sum((df_merged['y_x'] - df_merged['y_y']) ** 2), 0.0)\n\n    def test_simulated_historical_forecasts_logistic(self):\n        m = Prophet(growth='logistic')\n        df = self.__df.copy()\n        df['cap'] = 40\n        m.fit(df)\n        df_shf = diagnostics.simulated_historical_forecasts(\n            m, horizon='3 days', k=2, period='3 days')\n        # All cutoff dates should be less than ds dates\n        self.assertTrue((df_shf['cutoff'] < df_shf['ds']).all())\n        # The unique size of output cutoff should be equal to 'k'\n        self.assertEqual(len(np.unique(df_shf['cutoff'])), 2)\n        # Each y in df_shf and self.__df with same ds should be equal\n        df_merged = pd.merge(df_shf, df, 'left', on='ds')\n        self.assertAlmostEqual(\n            np.sum((df_merged['y_x'] - df_merged['y_y']) ** 2), 0.0)\n\n    def test_simulated_historical_forecasts_extra_regressors(self):\n        m = Prophet()\n        m.add_seasonality(name='monthly', period=30.5, fourier_order=5)\n        m.add_regressor('extra')\n        df = self.__df.copy()\n        df['cap'] = 40\n        df['extra'] = range(df.shape[0])\n        m.fit(df)\n        df_shf = diagnostics.simulated_historical_forecasts(\n            m, horizon='3 days', k=2, period='3 days')\n        # All cutoff dates should be less than ds dates\n        self.assertTrue((df_shf['cutoff'] < df_shf['ds']).all())\n        # The unique size of output cutoff should be equal to 'k'\n        self.assertEqual(len(np.unique(df_shf['cutoff'])), 2)\n        # Each y in df_shf and self.__df with same ds should be equal\n        df_merged = pd.merge(df_shf, df, 'left', on='ds')\n        self.assertAlmostEqual(\n            np.sum((df_merged['y_x'] - df_merged['y_y']) ** 2), 0.0)\n\n    def test_simulated_historical_forecasts_default_value_check(self):\n        m = Prophet()\n        m.fit(self.__df)\n        # Default value of period should be equal to 0.5 * horizon\n        df_shf1 = diagnostics.simulated_historical_forecasts(\n            m, horizon='10 days', k=1)\n        df_shf2 = diagnostics.simulated_historical_forecasts(\n            m, horizon='10 days', k=1, period='5 days')\n        self.assertAlmostEqual(\n            ((df_shf1['y'] - df_shf2['y']) ** 2).sum(), 0.0)\n        self.assertAlmostEqual(\n            ((df_shf1['yhat'] - df_shf2['yhat']) ** 2).sum(), 0.0)\n\n    def test_cross_validation(self):\n        m = Prophet()\n        m.fit(self.__df)\n        # Calculate the number of cutoff points(k)\n        horizon = pd.Timedelta('4 days')\n        period = pd.Timedelta('10 days')\n        k = 5\n        df_cv = diagnostics.cross_validation(\n            m, horizon='4 days', period='10 days', initial='90 days')\n        # The unique size of output cutoff should be equal to 'k'\n        self.assertEqual(len(np.unique(df_cv['cutoff'])), k)\n        self.assertEqual(max(df_cv['ds'] - df_cv['cutoff']), horizon)\n        dc = df_cv['cutoff'].diff()\n        dc = dc[dc > pd.Timedelta(0)].min()\n        self.assertTrue(dc >= period)\n\n    def test_cross_validation_default_value_check(self):\n        m = Prophet()\n        m.fit(self.__df)\n        # Default value of initial should be equal to 3 * horizon\n        df_cv1 = diagnostics.cross_validation(\n            m, horizon='32 days', period='10 days')\n        df_cv2 = diagnostics.cross_validation(\n            m, horizon='32 days', period='10 days', initial='96 days')\n        self.assertAlmostEqual(\n            ((df_cv1['y'] - df_cv2['y']) ** 2).sum(), 0.0)\n        self.assertAlmostEqual(\n            ((df_cv1['yhat'] - df_cv2['yhat']) ** 2).sum(), 0.0)\n", "description": "Tool for producing high quality forecasts for time series data that has multiple seasonality with linear or non-linear growth.", "file_name": "test_diagnostics.py", "id": "d3f4ae2f0b15bf0217e5485eb7265317", "language": "Python", "project_name": "prophet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/facebook-prophet/facebook-prophet-792278f/python/fbprophet/tests/test_diagnostics.py", "save_time": "", "source": "", "update_at": "2018-03-18T17:15:21Z", "url": "https://github.com/facebook/prophet", "wiki": false}