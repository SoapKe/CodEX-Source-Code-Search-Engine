{"author": "tensorflow", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\nr\"\"\"\"Converts music files to NoteSequence protos and writes TFRecord file.\n\nCurrently supports MIDI (.mid, .midi) and MusicXML (.xml, .mxl) files.\n\nExample usage:\n  $ bazel build magenta/scripts:convert_dir_to_note_sequences\n\n  $ ./bazel-bin/magenta/scripts/convert_dir_to_note_sequences \\\n    --input_dir=/path/to/input/dir \\\n    --output_file=/path/to/tfrecord/file \\\n    --num_threads=4 \\\n    --log=INFO\n\"\"\"\n\nimport os\n\n internal imports\nimport tensorflow as tf\n\nfrom magenta.music import abc_parser\nfrom magenta.music import midi_io\nfrom magenta.music import musicxml_reader\nfrom magenta.music import note_sequence_io\n\nFLAGS = tf.app.flags.FLAGS\n\ntf.app.flags.DEFINE_string('input_dir', None,\n                           'Directory containing files to convert.')\ntf.app.flags.DEFINE_string('output_file', None,\n                           'Path to output TFRecord file. Will be overwritten '\n                           'if it already exists.')\ntf.app.flags.DEFINE_bool('recursive', False,\n                         'Whether or not to recurse into subdirectories.')\ntf.app.flags.DEFINE_integer('num_threads', 1,\n                            'Number of worker threads to run in parallel.')\ntf.app.flags.DEFINE_string('log', 'INFO',\n                           'The threshold for what messages will be logged '\n                           'DEBUG, INFO, WARN, ERROR, or FATAL.')\n\n\ndef convert_files(root_dir, sub_dir, writer, recursive=False):\n  \"\"\"Converts files.\n\n  Args:\n    root_dir: A string specifying a root directory.\n    sub_dir: A string specifying a path to a directory under `root_dir` in which\n        to convert contents.\n    writer: A TFRecord writer\n    recursive: A boolean specifying whether or not recursively convert files\n        contained in subdirectories of the specified directory.\n\n  Returns:\n    A map from the resulting Futures to the file paths being converted.\n  \"\"\"\n  dir_to_convert = os.path.join(root_dir, sub_dir)\n  tf.logging.info(\"Converting files in '%s'.\", dir_to_convert)\n  files_in_dir = tf.gfile.ListDirectory(os.path.join(dir_to_convert))\n  recurse_sub_dirs = []\n  written_count = 0\n  for file_in_dir in files_in_dir:\n    tf.logging.log_every_n(tf.logging.INFO, '%d files converted.',\n                           1000, written_count)\n    full_file_path = os.path.join(dir_to_convert, file_in_dir)\n    if (full_file_path.lower().endswith('.mid') or\n        full_file_path.lower().endswith('.midi')):\n      try:\n        sequence = convert_midi(root_dir, sub_dir, full_file_path)\n      except Exception as exc:   pylint: disable=broad-except\n        tf.logging.fatal('%r generated an exception: %s', full_file_path, exc)\n        continue\n      if sequence:\n        writer.write(sequence)\n    elif (full_file_path.lower().endswith('.xml') or\n          full_file_path.lower().endswith('.mxl')):\n      try:\n        sequence = convert_musicxml(root_dir, sub_dir, full_file_path)\n      except Exception as exc:   pylint: disable=broad-except\n        tf.logging.fatal('%r generated an exception: %s', full_file_path, exc)\n        continue\n      if sequence:\n        writer.write(sequence)\n    elif full_file_path.lower().endswith('.abc'):\n      try:\n        sequences = convert_abc(root_dir, sub_dir, full_file_path)\n      except Exception as exc:   pylint: disable=broad-except\n        tf.logging.fatal('%r generated an exception: %s', full_file_path, exc)\n        continue\n      if sequences:\n        for sequence in sequences:\n          writer.write(sequence)\n    else:\n      if recursive and tf.gfile.IsDirectory(full_file_path):\n        recurse_sub_dirs.append(os.path.join(sub_dir, file_in_dir))\n      else:\n        tf.logging.warning(\n            'Unable to find a converter for file %s', full_file_path)\n\n  for recurse_sub_dir in recurse_sub_dirs:\n    convert_files(root_dir, recurse_sub_dir, writer, recursive)\n\n\ndef convert_midi(root_dir, sub_dir, full_file_path):\n  \"\"\"Converts a midi file to a sequence proto.\n\n  Args:\n    root_dir: A string specifying the root directory for the files being\n        converted.\n    sub_dir: The directory being converted currently.\n    full_file_path: the full path to the file to convert.\n\n  Returns:\n    Either a NoteSequence proto or None if the file could not be converted.\n  \"\"\"\n  try:\n    sequence = midi_io.midi_to_sequence_proto(\n        tf.gfile.FastGFile(full_file_path, 'rb').read())\n  except midi_io.MIDIConversionError as e:\n    tf.logging.warning(\n        'Could not parse MIDI file %s. It will be skipped. Error was: %s',\n        full_file_path, e)\n    return None\n  sequence.collection_name = os.path.basename(root_dir)\n  sequence.filename = os.path.join(sub_dir, os.path.basename(full_file_path))\n  sequence.id = note_sequence_io.generate_note_sequence_id(\n      sequence.filename, sequence.collection_name, 'midi')\n  tf.logging.info('Converted MIDI file %s.', full_file_path)\n  return sequence\n\n\ndef convert_musicxml(root_dir, sub_dir, full_file_path):\n  \"\"\"Converts a musicxml file to a sequence proto.\n\n  Args:\n    root_dir: A string specifying the root directory for the files being\n        converted.\n    sub_dir: The directory being converted currently.\n    full_file_path: the full path to the file to convert.\n\n  Returns:\n    Either a NoteSequence proto or None if the file could not be converted.\n  \"\"\"\n  try:\n    sequence = musicxml_reader.musicxml_file_to_sequence_proto(full_file_path)\n  except musicxml_reader.MusicXMLConversionError as e:\n    tf.logging.warning(\n        'Could not parse MusicXML file %s. It will be skipped. Error was: %s',\n        full_file_path, e)\n    return None\n  sequence.collection_name = os.path.basename(root_dir)\n  sequence.filename = os.path.join(sub_dir, os.path.basename(full_file_path))\n  sequence.id = note_sequence_io.generate_note_sequence_id(\n      sequence.filename, sequence.collection_name, 'musicxml')\n  tf.logging.info('Converted MusicXML file %s.', full_file_path)\n  return sequence\n\n\ndef convert_abc(root_dir, sub_dir, full_file_path):\n  \"\"\"Converts an abc file to a sequence proto.\n\n  Args:\n    root_dir: A string specifying the root directory for the files being\n        converted.\n    sub_dir: The directory being converted currently.\n    full_file_path: the full path to the file to convert.\n\n  Returns:\n    Either a NoteSequence proto or None if the file could not be converted.\n  \"\"\"\n  try:\n    tunes, exceptions = abc_parser.parse_abc_tunebook(\n        tf.gfile.FastGFile(full_file_path, 'rb').read())\n  except abc_parser.ABCParseException as e:\n    tf.logging.warning(\n        'Could not parse ABC file %s. It will be skipped. Error was: %s',\n        full_file_path, e)\n    return None\n\n  for exception in exceptions:\n    tf.logging.warning(\n        'Could not parse tune in ABC file %s. It will be skipped. Error was: '\n        '%s', full_file_path, exception)\n\n  sequences = []\n  for idx, tune in tunes.iteritems():\n    tune.collection_name = os.path.basename(root_dir)\n    tune.filename = os.path.join(sub_dir, os.path.basename(full_file_path))\n    tune.id = note_sequence_io.generate_note_sequence_id(\n        '{}_{}'.format(tune.filename, idx), tune.collection_name, 'abc')\n    sequences.append(tune)\n    tf.logging.info('Converted ABC file %s.', full_file_path)\n  return sequences\n\n\ndef convert_directory(root_dir, output_file, recursive=False):\n  \"\"\"Converts files to NoteSequences and writes to `output_file`.\n\n  Input files found in `root_dir` are converted to NoteSequence protos with the\n  basename of `root_dir` as the collection_name, and the relative path to the\n  file from `root_dir` as the filename. If `recursive` is true, recursively\n  converts any subdirectories of the specified directory.\n\n  Args:\n    root_dir: A string specifying a root directory.\n    output_file: Path to TFRecord file to write results to.\n    recursive: A boolean specifying whether or not recursively convert files\n        contained in subdirectories of the specified directory.\n  \"\"\"\n  with note_sequence_io.NoteSequenceRecordWriter(output_file) as writer:\n    convert_files(root_dir, '', writer, recursive)\n\n\ndef main(unused_argv):\n  tf.logging.set_verbosity(FLAGS.log)\n\n  if not FLAGS.input_dir:\n    tf.logging.fatal('--input_dir required')\n    return\n  if not FLAGS.output_file:\n    tf.logging.fatal('--output_file required')\n    return\n\n  input_dir = os.path.expanduser(FLAGS.input_dir)\n  output_file = os.path.expanduser(FLAGS.output_file)\n  output_dir = os.path.dirname(output_file)\n\n  if output_dir:\n    tf.gfile.MakeDirs(output_dir)\n\n  convert_directory(input_dir, output_file, FLAGS.recursive)\n\n\ndef console_entry_point():\n  tf.app.run(main)\n\n\nif __name__ == '__main__':\n  console_entry_point()\n", "comments": "    converts music files notesequence protos writes tfrecord file   currently supports midi ( mid   midi) musicxml ( xml   mxl) files   example usage      bazel build magenta scripts convert dir note sequences        bazel bin magenta scripts convert dir note sequences         input dir  path input dir         output file  path tfrecord file         num threads 4         log info      import os    internal imports import tensorflow tf  magenta music import abc parser magenta music import midi io magenta music import musicxml reader magenta music import note sequence io  flags   tf app flags flags  tf app flags define string( input dir   none                              directory containing files convert  ) tf app flags define string( output file   none                              path output tfrecord file  will overwritten                               already exists  ) tf app flags define bool( recursive   false                            whether recurse subdirectories  ) tf app flags define integer( num threads   1                               number worker threads run parallel  ) tf app flags define string( log    info                               the threshold messages logged                               debug  info  warn  error  fatal  )   def convert files(root dir  sub dir  writer  recursive false)       converts files     args      root dir  a string specifying root directory      sub dir  a string specifying path directory  root dir          convert contents      writer  a tfrecord writer     recursive  a boolean specifying whether recursively convert files         contained subdirectories specified directory     returns      a map resulting futures file paths converted          dir convert   os path join(root dir  sub dir)   tf logging info( converting files       dir convert)   files dir   tf gfile listdirectory(os path join(dir convert))   recurse sub dirs        written count   0   file dir files dir      tf logging log every n(tf logging info    files converted                               1000  written count)     full file path   os path join(dir convert  file dir)     (full file path lower() endswith(  mid )         full file path lower() endswith(  midi ))        try          sequence   convert midi(root dir  sub dir  full file path)       except exception exc     pylint  disable broad except         tf logging fatal(  r generated exception     full file path  exc)         continue       sequence          writer write(sequence)     elif (full file path lower() endswith(  xml )           full file path lower() endswith(  mxl ))        try          sequence   convert musicxml(root dir  sub dir  full file path)       except exception exc     pylint  disable broad except         tf logging fatal(  r generated exception     full file path  exc)         continue       sequence          writer write(sequence)     elif full file path lower() endswith(  abc )        try          sequences   convert abc(root dir  sub dir  full file path)       except exception exc     pylint  disable broad except         tf logging fatal(  r generated exception     full file path  exc)         continue       sequences          sequence sequences            writer write(sequence)     else        recursive tf gfile isdirectory(full file path)          recurse sub dirs append(os path join(sub dir  file dir))       else          tf logging warning(              unable find converter file    full file path)    recurse sub dir recurse sub dirs      convert files(root dir  recurse sub dir  writer  recursive)   def convert midi(root dir  sub dir  full file path)       converts midi file sequence proto     args      root dir  a string specifying root directory files         converted      sub dir  the directory converted currently      full file path  full path file convert     returns      either notesequence proto none file could converted          try      sequence   midi io midi sequence proto(         tf gfile fastgfile(full file path   rb ) read())   except midi io midiconversionerror e      tf logging warning(          could parse midi file   it skipped  error             full file path  e)     return none   sequence collection name   os path basename(root dir)   sequence filename   os path join(sub dir  os path basename(full file path))   sequence id   note sequence io generate note sequence id(       sequence filename  sequence collection name   midi )   tf logging info( converted midi file     full file path)   return sequence   def convert musicxml(root dir  sub dir  full file path)       converts musicxml file sequence proto     args      root dir  a string specifying root directory files         converted      sub dir  the directory converted currently      full file path  full path file convert     returns      either notesequence proto none file could converted          try      sequence   musicxml reader musicxml file sequence proto(full file path)   except musicxml reader musicxmlconversionerror e      tf logging warning(          could parse musicxml file   it skipped  error             full file path  e)     return none   sequence collection name   os path basename(root dir)   sequence filename   os path join(sub dir  os path basename(full file path))   sequence id   note sequence io generate note sequence id(       sequence filename  sequence collection name   musicxml )   tf logging info( converted musicxml file     full file path)   return sequence   def convert abc(root dir  sub dir  full file path)       converts abc file sequence proto     args      root dir  a string specifying root directory files         converted      sub dir  the directory converted currently      full file path  full path file convert     returns      either notesequence proto none file could converted          try      tunes  exceptions   abc parser parse abc tunebook(         tf gfile fastgfile(full file path   rb ) read())   except abc parser abcparseexception e      tf logging warning(          could parse abc file   it skipped  error             full file path  e)     return none    exception exceptions      tf logging warning(          could parse tune abc file   it skipped  error                full file path  exception)    sequences        idx  tune tunes iteritems()      tune collection name   os path basename(root dir)     tune filename   os path join(sub dir  os path basename(full file path))     tune id   note sequence io generate note sequence id(                 format(tune filename  idx)  tune collection name   abc )     sequences append(tune)     tf logging info( converted abc file     full file path)   return sequences   def convert directory(root dir  output file  recursive false)       converts files notesequences writes  output file      input files found  root dir  converted notesequence protos   basename  root dir  collection name  relative path   file  root dir  filename  if  recursive  true  recursively   converts subdirectories specified directory     args      root dir  a string specifying root directory      output file  path tfrecord file write results      recursive  a boolean specifying whether recursively convert files         contained subdirectories specified directory           copyright 2016 google inc  all rights reserved        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license          http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license     internal imports    pylint  disable broad except    pylint  disable broad except    pylint  disable broad except ", "content": "# Copyright 2016 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nr\"\"\"\"Converts music files to NoteSequence protos and writes TFRecord file.\n\nCurrently supports MIDI (.mid, .midi) and MusicXML (.xml, .mxl) files.\n\nExample usage:\n  $ bazel build magenta/scripts:convert_dir_to_note_sequences\n\n  $ ./bazel-bin/magenta/scripts/convert_dir_to_note_sequences \\\n    --input_dir=/path/to/input/dir \\\n    --output_file=/path/to/tfrecord/file \\\n    --num_threads=4 \\\n    --log=INFO\n\"\"\"\n\nimport os\n\n# internal imports\nimport tensorflow as tf\n\nfrom magenta.music import abc_parser\nfrom magenta.music import midi_io\nfrom magenta.music import musicxml_reader\nfrom magenta.music import note_sequence_io\n\nFLAGS = tf.app.flags.FLAGS\n\ntf.app.flags.DEFINE_string('input_dir', None,\n                           'Directory containing files to convert.')\ntf.app.flags.DEFINE_string('output_file', None,\n                           'Path to output TFRecord file. Will be overwritten '\n                           'if it already exists.')\ntf.app.flags.DEFINE_bool('recursive', False,\n                         'Whether or not to recurse into subdirectories.')\ntf.app.flags.DEFINE_integer('num_threads', 1,\n                            'Number of worker threads to run in parallel.')\ntf.app.flags.DEFINE_string('log', 'INFO',\n                           'The threshold for what messages will be logged '\n                           'DEBUG, INFO, WARN, ERROR, or FATAL.')\n\n\ndef convert_files(root_dir, sub_dir, writer, recursive=False):\n  \"\"\"Converts files.\n\n  Args:\n    root_dir: A string specifying a root directory.\n    sub_dir: A string specifying a path to a directory under `root_dir` in which\n        to convert contents.\n    writer: A TFRecord writer\n    recursive: A boolean specifying whether or not recursively convert files\n        contained in subdirectories of the specified directory.\n\n  Returns:\n    A map from the resulting Futures to the file paths being converted.\n  \"\"\"\n  dir_to_convert = os.path.join(root_dir, sub_dir)\n  tf.logging.info(\"Converting files in '%s'.\", dir_to_convert)\n  files_in_dir = tf.gfile.ListDirectory(os.path.join(dir_to_convert))\n  recurse_sub_dirs = []\n  written_count = 0\n  for file_in_dir in files_in_dir:\n    tf.logging.log_every_n(tf.logging.INFO, '%d files converted.',\n                           1000, written_count)\n    full_file_path = os.path.join(dir_to_convert, file_in_dir)\n    if (full_file_path.lower().endswith('.mid') or\n        full_file_path.lower().endswith('.midi')):\n      try:\n        sequence = convert_midi(root_dir, sub_dir, full_file_path)\n      except Exception as exc:  # pylint: disable=broad-except\n        tf.logging.fatal('%r generated an exception: %s', full_file_path, exc)\n        continue\n      if sequence:\n        writer.write(sequence)\n    elif (full_file_path.lower().endswith('.xml') or\n          full_file_path.lower().endswith('.mxl')):\n      try:\n        sequence = convert_musicxml(root_dir, sub_dir, full_file_path)\n      except Exception as exc:  # pylint: disable=broad-except\n        tf.logging.fatal('%r generated an exception: %s', full_file_path, exc)\n        continue\n      if sequence:\n        writer.write(sequence)\n    elif full_file_path.lower().endswith('.abc'):\n      try:\n        sequences = convert_abc(root_dir, sub_dir, full_file_path)\n      except Exception as exc:  # pylint: disable=broad-except\n        tf.logging.fatal('%r generated an exception: %s', full_file_path, exc)\n        continue\n      if sequences:\n        for sequence in sequences:\n          writer.write(sequence)\n    else:\n      if recursive and tf.gfile.IsDirectory(full_file_path):\n        recurse_sub_dirs.append(os.path.join(sub_dir, file_in_dir))\n      else:\n        tf.logging.warning(\n            'Unable to find a converter for file %s', full_file_path)\n\n  for recurse_sub_dir in recurse_sub_dirs:\n    convert_files(root_dir, recurse_sub_dir, writer, recursive)\n\n\ndef convert_midi(root_dir, sub_dir, full_file_path):\n  \"\"\"Converts a midi file to a sequence proto.\n\n  Args:\n    root_dir: A string specifying the root directory for the files being\n        converted.\n    sub_dir: The directory being converted currently.\n    full_file_path: the full path to the file to convert.\n\n  Returns:\n    Either a NoteSequence proto or None if the file could not be converted.\n  \"\"\"\n  try:\n    sequence = midi_io.midi_to_sequence_proto(\n        tf.gfile.FastGFile(full_file_path, 'rb').read())\n  except midi_io.MIDIConversionError as e:\n    tf.logging.warning(\n        'Could not parse MIDI file %s. It will be skipped. Error was: %s',\n        full_file_path, e)\n    return None\n  sequence.collection_name = os.path.basename(root_dir)\n  sequence.filename = os.path.join(sub_dir, os.path.basename(full_file_path))\n  sequence.id = note_sequence_io.generate_note_sequence_id(\n      sequence.filename, sequence.collection_name, 'midi')\n  tf.logging.info('Converted MIDI file %s.', full_file_path)\n  return sequence\n\n\ndef convert_musicxml(root_dir, sub_dir, full_file_path):\n  \"\"\"Converts a musicxml file to a sequence proto.\n\n  Args:\n    root_dir: A string specifying the root directory for the files being\n        converted.\n    sub_dir: The directory being converted currently.\n    full_file_path: the full path to the file to convert.\n\n  Returns:\n    Either a NoteSequence proto or None if the file could not be converted.\n  \"\"\"\n  try:\n    sequence = musicxml_reader.musicxml_file_to_sequence_proto(full_file_path)\n  except musicxml_reader.MusicXMLConversionError as e:\n    tf.logging.warning(\n        'Could not parse MusicXML file %s. It will be skipped. Error was: %s',\n        full_file_path, e)\n    return None\n  sequence.collection_name = os.path.basename(root_dir)\n  sequence.filename = os.path.join(sub_dir, os.path.basename(full_file_path))\n  sequence.id = note_sequence_io.generate_note_sequence_id(\n      sequence.filename, sequence.collection_name, 'musicxml')\n  tf.logging.info('Converted MusicXML file %s.', full_file_path)\n  return sequence\n\n\ndef convert_abc(root_dir, sub_dir, full_file_path):\n  \"\"\"Converts an abc file to a sequence proto.\n\n  Args:\n    root_dir: A string specifying the root directory for the files being\n        converted.\n    sub_dir: The directory being converted currently.\n    full_file_path: the full path to the file to convert.\n\n  Returns:\n    Either a NoteSequence proto or None if the file could not be converted.\n  \"\"\"\n  try:\n    tunes, exceptions = abc_parser.parse_abc_tunebook(\n        tf.gfile.FastGFile(full_file_path, 'rb').read())\n  except abc_parser.ABCParseException as e:\n    tf.logging.warning(\n        'Could not parse ABC file %s. It will be skipped. Error was: %s',\n        full_file_path, e)\n    return None\n\n  for exception in exceptions:\n    tf.logging.warning(\n        'Could not parse tune in ABC file %s. It will be skipped. Error was: '\n        '%s', full_file_path, exception)\n\n  sequences = []\n  for idx, tune in tunes.iteritems():\n    tune.collection_name = os.path.basename(root_dir)\n    tune.filename = os.path.join(sub_dir, os.path.basename(full_file_path))\n    tune.id = note_sequence_io.generate_note_sequence_id(\n        '{}_{}'.format(tune.filename, idx), tune.collection_name, 'abc')\n    sequences.append(tune)\n    tf.logging.info('Converted ABC file %s.', full_file_path)\n  return sequences\n\n\ndef convert_directory(root_dir, output_file, recursive=False):\n  \"\"\"Converts files to NoteSequences and writes to `output_file`.\n\n  Input files found in `root_dir` are converted to NoteSequence protos with the\n  basename of `root_dir` as the collection_name, and the relative path to the\n  file from `root_dir` as the filename. If `recursive` is true, recursively\n  converts any subdirectories of the specified directory.\n\n  Args:\n    root_dir: A string specifying a root directory.\n    output_file: Path to TFRecord file to write results to.\n    recursive: A boolean specifying whether or not recursively convert files\n        contained in subdirectories of the specified directory.\n  \"\"\"\n  with note_sequence_io.NoteSequenceRecordWriter(output_file) as writer:\n    convert_files(root_dir, '', writer, recursive)\n\n\ndef main(unused_argv):\n  tf.logging.set_verbosity(FLAGS.log)\n\n  if not FLAGS.input_dir:\n    tf.logging.fatal('--input_dir required')\n    return\n  if not FLAGS.output_file:\n    tf.logging.fatal('--output_file required')\n    return\n\n  input_dir = os.path.expanduser(FLAGS.input_dir)\n  output_file = os.path.expanduser(FLAGS.output_file)\n  output_dir = os.path.dirname(output_file)\n\n  if output_dir:\n    tf.gfile.MakeDirs(output_dir)\n\n  convert_directory(input_dir, output_file, FLAGS.recursive)\n\n\ndef console_entry_point():\n  tf.app.run(main)\n\n\nif __name__ == '__main__':\n  console_entry_point()\n", "description": "Magenta: Music and Art Generation with Machine Intelligence", "file_name": "convert_dir_to_note_sequences.py", "id": "8d570b21d681abd17d56b0c8d02f3117", "language": "Python", "project_name": "magenta", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tensorflow-magenta/tensorflow-magenta-ca73164/magenta/scripts/convert_dir_to_note_sequences.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:00:14Z", "url": "https://github.com/tensorflow/magenta", "wiki": false}