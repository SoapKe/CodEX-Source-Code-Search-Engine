{"author": "python", "code": "import argparse\nimport py_compile\nimport re\nimport sys\nimport shutil\nimport stat\nimport os\nimport tempfile\n\nfrom itertools import chain\nfrom pathlib import Path\nfrom zipfile import ZipFile, ZIP_DEFLATED\n\n\nTKTCL_RE = re.compile(r'^(_?tk|tcl).+\\.(pyd|dll)', re.IGNORECASE)\nDEBUG_RE = re.compile(r'_d\\.(pyd|dll|exe|pdb|lib)$', re.IGNORECASE)\nPYTHON_DLL_RE = re.compile(r'python\\d\\d?\\.dll$', re.IGNORECASE)\n\nDEBUG_FILES = {\n    '_ctypes_test',\n    '_testbuffer',\n    '_testcapi',\n    '_testconsole',\n    '_testimportmultiple',\n    '_testmultiphase',\n    'xxlimited',\n    'python3_dstub',\n}\n\nEXCLUDE_FROM_LIBRARY = {\n    '__pycache__',\n    'idlelib',\n    'pydoc_data',\n    'site-packages',\n    'tkinter',\n    'turtledemo',\n}\n\nEXCLUDE_FROM_EMBEDDABLE_LIBRARY = {\n    'ensurepip',\n    'venv',\n}\n\nEXCLUDE_FILE_FROM_LIBRARY = {\n    'bdist_wininst.py',\n}\n\nEXCLUDE_FILE_FROM_LIBS = {\n    'liblzma',\n    'python3stub',\n}\n\nEXCLUDED_FILES = {\n    'pyshellext',\n}\n\ndef is_not_debug(p):\n    if DEBUG_RE.search(p.name):\n        return False\n\n    if TKTCL_RE.search(p.name):\n        return False\n\n    return p.stem.lower() not in DEBUG_FILES and p.stem.lower() not in EXCLUDED_FILES\n\ndef is_not_debug_or_python(p):\n    return is_not_debug(p) and not PYTHON_DLL_RE.search(p.name)\n\ndef include_in_lib(p):\n    name = p.name.lower()\n    if p.is_dir():\n        if name in EXCLUDE_FROM_LIBRARY:\n            return False\n        if name == 'test' and p.parts[-2].lower() == 'lib':\n            return False\n        if name in {'test', 'tests'} and p.parts[-3].lower() == 'lib':\n            return False\n        return True\n\n    if name in EXCLUDE_FILE_FROM_LIBRARY:\n        return False\n\n    suffix = p.suffix.lower()\n    return suffix not in {'.pyc', '.pyo', '.exe'}\n\ndef include_in_embeddable_lib(p):\n    if p.is_dir() and p.name.lower() in EXCLUDE_FROM_EMBEDDABLE_LIBRARY:\n        return False\n\n    return include_in_lib(p)\n\ndef include_in_libs(p):\n    if not is_not_debug(p):\n        return False\n\n    return p.stem.lower() not in EXCLUDE_FILE_FROM_LIBS\n\ndef include_in_tools(p):\n    if p.is_dir() and p.name.lower() in {'scripts', 'i18n', 'pynche', 'demo', 'parser'}:\n        return True\n\n    return p.suffix.lower() in {'.py', '.pyw', '.txt'}\n\nBASE_NAME = 'python{0.major}{0.minor}'.format(sys.version_info)\n\nFULL_LAYOUT = [\n    ('/', '$build', 'python.exe', is_not_debug),\n    ('/', '$build', 'pythonw.exe', is_not_debug),\n    ('/', '$build', 'python{}.dll'.format(sys.version_info.major), is_not_debug),\n    ('/', '$build', '{}.dll'.format(BASE_NAME), is_not_debug),\n    ('DLLs/', '$build', '*.pyd', is_not_debug),\n    ('DLLs/', '$build', '*.dll', is_not_debug_or_python),\n    ('include/', 'include', '*.h', None),\n    ('include/', 'PC', 'pyconfig.h', None),\n    ('Lib/', 'Lib', '**/*', include_in_lib),\n    ('libs/', '$build', '*.lib', include_in_libs),\n    ('Tools/', 'Tools', '**/*', include_in_tools),\n]\n\nEMBED_LAYOUT = [\n    ('/', '$build', 'python*.exe', is_not_debug),\n    ('/', '$build', '*.pyd', is_not_debug),\n    ('/', '$build', '*.dll', is_not_debug),\n    ('{}.zip'.format(BASE_NAME), 'Lib', '**/*', include_in_embeddable_lib),\n]\n\nif os.getenv('DOC_FILENAME'):\n    FULL_LAYOUT.append(('Doc/', 'Doc/build/htmlhelp', os.getenv('DOC_FILENAME'), None))\nif os.getenv('VCREDIST_PATH'):\n    FULL_LAYOUT.append(('/', os.getenv('VCREDIST_PATH'), 'vcruntime*.dll', None))\n    EMBED_LAYOUT.append(('/', os.getenv('VCREDIST_PATH'), 'vcruntime*.dll', None))\n\ndef copy_to_layout(target, rel_sources):\n    count = 0\n\n    if target.suffix.lower() == '.zip':\n        if target.exists():\n            target.unlink()\n\n        with ZipFile(str(target), 'w', ZIP_DEFLATED) as f:\n            with tempfile.TemporaryDirectory() as tmpdir:\n                for s, rel in rel_sources:\n                    if rel.suffix.lower() == '.py':\n                        pyc = Path(tmpdir) / rel.with_suffix('.pyc').name\n                        try:\n                            py_compile.compile(str(s), str(pyc), str(rel), doraise=True, optimize=2)\n                        except py_compile.PyCompileError:\n                            f.write(str(s), str(rel))\n                        else:\n                            f.write(str(pyc), str(rel.with_suffix('.pyc')))\n                    else:\n                        f.write(str(s), str(rel))\n                    count += 1\n\n    else:\n        for s, rel in rel_sources:\n            dest = target / rel\n            try:\n                dest.parent.mkdir(parents=True)\n            except FileExistsError:\n                pass\n            if dest.is_file():\n                dest.chmod(stat.S_IWRITE)\n            shutil.copy(str(s), str(dest))\n            if dest.is_file():\n                dest.chmod(stat.S_IWRITE)\n            count += 1\n\n    return count\n\ndef rglob(root, pattern, condition):\n    dirs = [root]\n    recurse = pattern[:3] in {'**/', '**\\\\'}\n    while dirs:\n        d = dirs.pop(0)\n        for f in d.glob(pattern[3:] if recurse else pattern):\n            if recurse and f.is_dir() and (not condition or condition(f)):\n                dirs.append(f)\n            elif f.is_file() and (not condition or condition(f)):\n                yield f, f.relative_to(root)\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-s', '--source', metavar='dir', help='The directory containing the repository root', type=Path)\n    parser.add_argument('-o', '--out', metavar='file', help='The name of the output archive', type=Path, default=None)\n    parser.add_argument('-t', '--temp', metavar='dir', help='A directory to temporarily extract files into', type=Path, default=None)\n    parser.add_argument('-e', '--embed', help='Create an embedding layout', action='store_true', default=False)\n    parser.add_argument('-b', '--build', help='Specify the build directory', type=Path, default=None)\n    ns = parser.parse_args()\n\n    source = ns.source or (Path(__file__).resolve().parent.parent.parent)\n    out = ns.out\n    build = ns.build or Path(sys.exec_prefix)\n    assert isinstance(source, Path)\n    assert not out or isinstance(out, Path)\n    assert isinstance(build, Path)\n\n    if ns.temp:\n        temp = ns.temp\n        delete_temp = False\n    else:\n        temp = Path(tempfile.mkdtemp())\n        delete_temp = True\n\n    if out:\n        try:\n            out.parent.mkdir(parents=True)\n        except FileExistsError:\n            pass\n    try:\n        temp.mkdir(parents=True)\n    except FileExistsError:\n        pass\n\n    layout = EMBED_LAYOUT if ns.embed else FULL_LAYOUT\n\n    try:\n        for t, s, p, c in layout:\n            if s == '$build':\n                fs = build\n            else:\n                fs = source / s\n            files = rglob(fs, p, c)\n            extra_files = []\n            if s == 'Lib' and p == '**/*':\n                extra_files.append((\n                    source / 'tools' / 'msi' / 'distutils.command.bdist_wininst.py',\n                    Path('distutils') / 'command' / 'bdist_wininst.py'\n                ))\n            copied = copy_to_layout(temp / t.rstrip('/'), chain(files, extra_files))\n            print('Copied {} files'.format(copied))\n\n        if ns.embed:\n            with open(str(temp / (BASE_NAME + '._pth')), 'w') as f:\n                print(BASE_NAME + '.zip', file=f)\n                print('.', file=f)\n                print('', file=f)\n                print('# Uncomment to run site.main() automatically', file=f)\n                print('#import site', file=f)\n\n        if out:\n            total = copy_to_layout(out, rglob(temp, '**/*', None))\n            print('Wrote {} files to {}'.format(total, out))\n    finally:\n        if delete_temp:\n            shutil.rmtree(temp, True)\n\n\nif __name__ == \"__main__\":\n    sys.exit(int(main() or 0))\n", "comments": "", "content": "import argparse\nimport py_compile\nimport re\nimport sys\nimport shutil\nimport stat\nimport os\nimport tempfile\n\nfrom itertools import chain\nfrom pathlib import Path\nfrom zipfile import ZipFile, ZIP_DEFLATED\n\n\nTKTCL_RE = re.compile(r'^(_?tk|tcl).+\\.(pyd|dll)', re.IGNORECASE)\nDEBUG_RE = re.compile(r'_d\\.(pyd|dll|exe|pdb|lib)$', re.IGNORECASE)\nPYTHON_DLL_RE = re.compile(r'python\\d\\d?\\.dll$', re.IGNORECASE)\n\nDEBUG_FILES = {\n    '_ctypes_test',\n    '_testbuffer',\n    '_testcapi',\n    '_testconsole',\n    '_testimportmultiple',\n    '_testmultiphase',\n    'xxlimited',\n    'python3_dstub',\n}\n\nEXCLUDE_FROM_LIBRARY = {\n    '__pycache__',\n    'idlelib',\n    'pydoc_data',\n    'site-packages',\n    'tkinter',\n    'turtledemo',\n}\n\nEXCLUDE_FROM_EMBEDDABLE_LIBRARY = {\n    'ensurepip',\n    'venv',\n}\n\nEXCLUDE_FILE_FROM_LIBRARY = {\n    'bdist_wininst.py',\n}\n\nEXCLUDE_FILE_FROM_LIBS = {\n    'liblzma',\n    'python3stub',\n}\n\nEXCLUDED_FILES = {\n    'pyshellext',\n}\n\ndef is_not_debug(p):\n    if DEBUG_RE.search(p.name):\n        return False\n\n    if TKTCL_RE.search(p.name):\n        return False\n\n    return p.stem.lower() not in DEBUG_FILES and p.stem.lower() not in EXCLUDED_FILES\n\ndef is_not_debug_or_python(p):\n    return is_not_debug(p) and not PYTHON_DLL_RE.search(p.name)\n\ndef include_in_lib(p):\n    name = p.name.lower()\n    if p.is_dir():\n        if name in EXCLUDE_FROM_LIBRARY:\n            return False\n        if name == 'test' and p.parts[-2].lower() == 'lib':\n            return False\n        if name in {'test', 'tests'} and p.parts[-3].lower() == 'lib':\n            return False\n        return True\n\n    if name in EXCLUDE_FILE_FROM_LIBRARY:\n        return False\n\n    suffix = p.suffix.lower()\n    return suffix not in {'.pyc', '.pyo', '.exe'}\n\ndef include_in_embeddable_lib(p):\n    if p.is_dir() and p.name.lower() in EXCLUDE_FROM_EMBEDDABLE_LIBRARY:\n        return False\n\n    return include_in_lib(p)\n\ndef include_in_libs(p):\n    if not is_not_debug(p):\n        return False\n\n    return p.stem.lower() not in EXCLUDE_FILE_FROM_LIBS\n\ndef include_in_tools(p):\n    if p.is_dir() and p.name.lower() in {'scripts', 'i18n', 'pynche', 'demo', 'parser'}:\n        return True\n\n    return p.suffix.lower() in {'.py', '.pyw', '.txt'}\n\nBASE_NAME = 'python{0.major}{0.minor}'.format(sys.version_info)\n\nFULL_LAYOUT = [\n    ('/', '$build', 'python.exe', is_not_debug),\n    ('/', '$build', 'pythonw.exe', is_not_debug),\n    ('/', '$build', 'python{}.dll'.format(sys.version_info.major), is_not_debug),\n    ('/', '$build', '{}.dll'.format(BASE_NAME), is_not_debug),\n    ('DLLs/', '$build', '*.pyd', is_not_debug),\n    ('DLLs/', '$build', '*.dll', is_not_debug_or_python),\n    ('include/', 'include', '*.h', None),\n    ('include/', 'PC', 'pyconfig.h', None),\n    ('Lib/', 'Lib', '**/*', include_in_lib),\n    ('libs/', '$build', '*.lib', include_in_libs),\n    ('Tools/', 'Tools', '**/*', include_in_tools),\n]\n\nEMBED_LAYOUT = [\n    ('/', '$build', 'python*.exe', is_not_debug),\n    ('/', '$build', '*.pyd', is_not_debug),\n    ('/', '$build', '*.dll', is_not_debug),\n    ('{}.zip'.format(BASE_NAME), 'Lib', '**/*', include_in_embeddable_lib),\n]\n\nif os.getenv('DOC_FILENAME'):\n    FULL_LAYOUT.append(('Doc/', 'Doc/build/htmlhelp', os.getenv('DOC_FILENAME'), None))\nif os.getenv('VCREDIST_PATH'):\n    FULL_LAYOUT.append(('/', os.getenv('VCREDIST_PATH'), 'vcruntime*.dll', None))\n    EMBED_LAYOUT.append(('/', os.getenv('VCREDIST_PATH'), 'vcruntime*.dll', None))\n\ndef copy_to_layout(target, rel_sources):\n    count = 0\n\n    if target.suffix.lower() == '.zip':\n        if target.exists():\n            target.unlink()\n\n        with ZipFile(str(target), 'w', ZIP_DEFLATED) as f:\n            with tempfile.TemporaryDirectory() as tmpdir:\n                for s, rel in rel_sources:\n                    if rel.suffix.lower() == '.py':\n                        pyc = Path(tmpdir) / rel.with_suffix('.pyc').name\n                        try:\n                            py_compile.compile(str(s), str(pyc), str(rel), doraise=True, optimize=2)\n                        except py_compile.PyCompileError:\n                            f.write(str(s), str(rel))\n                        else:\n                            f.write(str(pyc), str(rel.with_suffix('.pyc')))\n                    else:\n                        f.write(str(s), str(rel))\n                    count += 1\n\n    else:\n        for s, rel in rel_sources:\n            dest = target / rel\n            try:\n                dest.parent.mkdir(parents=True)\n            except FileExistsError:\n                pass\n            if dest.is_file():\n                dest.chmod(stat.S_IWRITE)\n            shutil.copy(str(s), str(dest))\n            if dest.is_file():\n                dest.chmod(stat.S_IWRITE)\n            count += 1\n\n    return count\n\ndef rglob(root, pattern, condition):\n    dirs = [root]\n    recurse = pattern[:3] in {'**/', '**\\\\'}\n    while dirs:\n        d = dirs.pop(0)\n        for f in d.glob(pattern[3:] if recurse else pattern):\n            if recurse and f.is_dir() and (not condition or condition(f)):\n                dirs.append(f)\n            elif f.is_file() and (not condition or condition(f)):\n                yield f, f.relative_to(root)\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-s', '--source', metavar='dir', help='The directory containing the repository root', type=Path)\n    parser.add_argument('-o', '--out', metavar='file', help='The name of the output archive', type=Path, default=None)\n    parser.add_argument('-t', '--temp', metavar='dir', help='A directory to temporarily extract files into', type=Path, default=None)\n    parser.add_argument('-e', '--embed', help='Create an embedding layout', action='store_true', default=False)\n    parser.add_argument('-b', '--build', help='Specify the build directory', type=Path, default=None)\n    ns = parser.parse_args()\n\n    source = ns.source or (Path(__file__).resolve().parent.parent.parent)\n    out = ns.out\n    build = ns.build or Path(sys.exec_prefix)\n    assert isinstance(source, Path)\n    assert not out or isinstance(out, Path)\n    assert isinstance(build, Path)\n\n    if ns.temp:\n        temp = ns.temp\n        delete_temp = False\n    else:\n        temp = Path(tempfile.mkdtemp())\n        delete_temp = True\n\n    if out:\n        try:\n            out.parent.mkdir(parents=True)\n        except FileExistsError:\n            pass\n    try:\n        temp.mkdir(parents=True)\n    except FileExistsError:\n        pass\n\n    layout = EMBED_LAYOUT if ns.embed else FULL_LAYOUT\n\n    try:\n        for t, s, p, c in layout:\n            if s == '$build':\n                fs = build\n            else:\n                fs = source / s\n            files = rglob(fs, p, c)\n            extra_files = []\n            if s == 'Lib' and p == '**/*':\n                extra_files.append((\n                    source / 'tools' / 'msi' / 'distutils.command.bdist_wininst.py',\n                    Path('distutils') / 'command' / 'bdist_wininst.py'\n                ))\n            copied = copy_to_layout(temp / t.rstrip('/'), chain(files, extra_files))\n            print('Copied {} files'.format(copied))\n\n        if ns.embed:\n            with open(str(temp / (BASE_NAME + '._pth')), 'w') as f:\n                print(BASE_NAME + '.zip', file=f)\n                print('.', file=f)\n                print('', file=f)\n                print('# Uncomment to run site.main() automatically', file=f)\n                print('#import site', file=f)\n\n        if out:\n            total = copy_to_layout(out, rglob(temp, '**/*', None))\n            print('Wrote {} files to {}'.format(total, out))\n    finally:\n        if delete_temp:\n            shutil.rmtree(temp, True)\n\n\nif __name__ == \"__main__\":\n    sys.exit(int(main() or 0))\n", "description": "The Python programming language", "file_name": "make_zip.py", "id": "47d54176f5b11c5f65222df3e3a5a195", "language": "Python", "project_name": "cpython", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/python-cpython/python-cpython-fe2bbb1/Tools/msi/make_zip.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:51:39Z", "url": "https://github.com/python/cpython", "wiki": false}