{"author": "aws", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\"). You\n may not use this file except in compliance with the License. A copy of\n the License is located at\n\n     http://aws.amazon.com/apache2.0/\n\n or in the \"license\" file accompanying this file. This file is\n distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n ANY KIND, either express or implied. See the License for the specific\n language governing permissions and limitations under the License.\nimport os\nimport shutil\nimport tempfile\nimport json\nimport time\n\nfrom botocore.session import Session\nfrom botocore.exceptions import ClientError\n\nfrom awscli.testutils import unittest, aws, random_chars\n\nS3_READ_POLICY_ARN = 'arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess'\n\n\nclass TestAssumeRoleCredentials(unittest.TestCase):\n    def setUp(self):\n        super(TestAssumeRoleCredentials, self).setUp()\n        self.environ = os.environ.copy()\n        self.parent_session = Session()\n        self.iam = self.parent_session.create_client('iam')\n        self.sts = self.parent_session.create_client('sts')\n        self.tempdir = tempfile.mkdtemp()\n        self.config_file = os.path.join(self.tempdir, 'config')\n\n         A role trust policy that allows the current account to call assume\n         role on itself.\n        account_id = self.sts.get_caller_identity()['Account']\n        self.role_policy = {\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n                {\n                    \"Effect\": \"Allow\",\n                    \"Principal\": {\n                        \"AWS\": \"arn:aws:iam::%s:root\" % account_id\n                    },\n                    \"Action\": \"sts:AssumeRole\"\n                }\n            ]\n        }\n\n    def tearDown(self):\n        super(TestAssumeRoleCredentials, self).tearDown()\n        shutil.rmtree(self.tempdir)\n\n    def random_name(self):\n        return 'clitest-' + random_chars(10)\n\n    def create_role(self, policy_document, policy_arn=None):\n        name = self.random_name()\n        response = self.iam.create_role(\n            RoleName=name,\n            AssumeRolePolicyDocument=json.dumps(policy_document)\n        )\n        self.addCleanup(self.iam.delete_role, RoleName=name)\n        if policy_arn:\n            self.iam.attach_role_policy(RoleName=name, PolicyArn=policy_arn)\n            self.addCleanup(\n                self.iam.detach_role_policy, RoleName=name,\n                PolicyArn=policy_arn\n            )\n        return response['Role']\n\n    def create_user(self, policy_arns):\n        name = self.random_name()\n        user = self.iam.create_user(UserName=name)['User']\n        self.addCleanup(self.iam.delete_user, UserName=name)\n\n        for arn in policy_arns:\n            self.iam.attach_user_policy(\n                UserName=name,\n                PolicyArn=arn\n            )\n            self.addCleanup(\n                self.iam.detach_user_policy,\n                UserName=name, PolicyArn=arn\n            )\n\n        return user\n\n    def create_creds(self, user_name):\n        creds = self.iam.create_access_key(UserName=user_name)['AccessKey']\n        self.addCleanup(\n            self.iam.delete_access_key,\n            UserName=user_name, AccessKeyId=creds['AccessKeyId']\n        )\n        return creds\n\n    def wait_for_assume_role(self, role_arn, access_key, secret_key,\n                             token=None, attempts=30, delay=10):\n         \"Why not use the policy simulator?\" you might ask. The answer is\n         that the policy simulator will return success far before you can\n         actually make the calls.\n        client = self.parent_session.create_client(\n            'sts', aws_access_key_id=access_key,\n            aws_secret_access_key=secret_key, aws_session_token=token\n        )\n        attempts_remaining = attempts\n        role_session_name = random_chars(10)\n        while attempts_remaining > 0:\n            attempts_remaining -= 1\n            try:\n                result = client.assume_role(\n                    RoleArn=role_arn, RoleSessionName=role_session_name)\n                return result['Credentials']\n            except ClientError as e:\n                code = e.response.get('Error', {}).get('Code')\n                if code in [\"InvalidClientTokenId\", \"AccessDenied\"]:\n                    time.sleep(delay)\n                else:\n                    raise\n\n        raise Exception(\"Unable to assume role %s\" % role_arn)\n\n    def create_assume_policy(self, role_arn):\n        policy_document = {\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n                {\n                    \"Effect\": \"Allow\",\n                    \"Resource\": role_arn,\n                    \"Action\": \"sts:AssumeRole\"\n                }\n            ]\n        }\n        name = self.random_name()\n        response = self.iam.create_policy(\n            PolicyName=name,\n            PolicyDocument=json.dumps(policy_document)\n        )\n        self.addCleanup(\n            self.iam.delete_policy, PolicyArn=response['Policy']['Arn']\n        )\n        return response['Policy']['Arn']\n\n    def assert_s3_read_only_profile(self, profile_name):\n         Calls to S3 should succeed\n        command = 's3api list-buckets --profile %s' % profile_name\n        result = aws(command, env_vars=self.environ)\n        self.assertEqual(result.rc, 0, result.stderr)\n\n         Calls to other services should not\n        command = 'iam list-groups --profile %s' % profile_name\n        result = aws(command, env_vars=self.environ)\n        self.assertNotEqual(result.rc, 0, result.stdout)\n        self.assertIn('AccessDenied', result.stderr)\n\n    def test_recursive_assume_role(self):\n         Create the final role, the one that will actually have access to s3\n        final_role = self.create_role(self.role_policy, S3_READ_POLICY_ARN)\n\n         Create the role that can assume the final role\n        middle_policy_arn = self.create_assume_policy(final_role['Arn'])\n        middle_role = self.create_role(self.role_policy, middle_policy_arn)\n\n         Create a user that can only assume the middle-man role, and then get\n         static credentials for it.\n        user_policy_arn = self.create_assume_policy(middle_role['Arn'])\n        user = self.create_user([user_policy_arn])\n        user_creds = self.create_creds(user['UserName'])\n\n         Setup the config file with the profiles we'll be using. For\n         convenience static credentials are placed here instead of putting\n         them in the credentials file.\n        config = (\n            '[default]\\n'\n            'aws_access_key_id = %s\\n'\n            'aws_secret_access_key = %s\\n'\n            '[profile middle]\\n'\n            'source_profile = default\\n'\n            'role_arn = %s\\n'\n            '[profile final]\\n'\n            'source_profile = middle\\n'\n            'role_arn = %s\\n'\n        )\n        config = config % (\n            user_creds['AccessKeyId'], user_creds['SecretAccessKey'],\n            middle_role['Arn'], final_role['Arn']\n        )\n        with open(self.config_file, 'w') as f:\n            f.write(config)\n\n         Wait for IAM permissions to propagate\n        middle_creds = self.wait_for_assume_role(\n            role_arn=middle_role['Arn'],\n            access_key=user_creds['AccessKeyId'],\n            secret_key=user_creds['SecretAccessKey'],\n        )\n        self.wait_for_assume_role(\n            role_arn=final_role['Arn'],\n            access_key=middle_creds['AccessKeyId'],\n            secret_key=middle_creds['SecretAccessKey'],\n            token=middle_creds['SessionToken'],\n        )\n\n         Configure our credentials file to be THE credentials file\n        self.environ['AWS_CONFIG_FILE'] = self.config_file\n\n        self.assert_s3_read_only_profile(profile_name='final')\n\n    def test_assume_role_with_credential_source(self):\n         Create a role with read access to S3\n        role = self.create_role(self.role_policy, S3_READ_POLICY_ARN)\n\n         Create a user that can assume the role and get static credentials\n         for it.\n        user_policy_arn = self.create_assume_policy(role['Arn'])\n        user = self.create_user([user_policy_arn])\n        user_creds = self.create_creds(user['UserName'])\n\n         Setup the config file with the profile we'll be using.\n        config = (\n            '[profile assume]\\n'\n            'role_arn = %s\\n'\n            'credential_source = Environment\\n'\n        )\n        config = config % role['Arn']\n        with open(self.config_file, 'w') as f:\n            f.write(config)\n\n         Wait for IAM permissions to propagate\n        self.wait_for_assume_role(\n            role_arn=role['Arn'],\n            access_key=user_creds['AccessKeyId'],\n            secret_key=user_creds['SecretAccessKey'],\n        )\n\n         Setup the environment so that our new config file is THE config\n         file and add the expected credentials since we're using the\n         environment as our credential source.\n        self.environ['AWS_CONFIG_FILE'] = self.config_file\n        self.environ['AWS_SECRET_ACCESS_KEY'] = user_creds['SecretAccessKey']\n        self.environ['AWS_ACCESS_KEY_ID'] = user_creds['AccessKeyId']\n\n        self.assert_s3_read_only_profile(profile_name='assume')\n", "comments": "  copyright 2017 amazon com  inc  affiliates  all rights reserved        licensed apache license  version 2 0 (the  license )  you    may use file except compliance license  a copy    license located           http   aws amazon com apache2 0         license  file accompanying file  this file    distributed  as is  basis  without warranties or conditions of    any kind  either express implied  see license specific    language governing permissions limitations license     a role trust policy allows current account call assume    role      why use policy simulator   might ask  the answer    policy simulator return success far    actually make calls     calls s3 succeed    calls services    create final role  one actually access s3    create role assume final role    create user assume middle man role  get    static credentials     setup config file profiles using  for    convenience static credentials placed instead putting    credentials file     wait iam permissions propagate    configure credentials file the credentials file    create role read access s3    create user assume role get static credentials        setup config file profile using     wait iam permissions propagate    setup environment new config file the config    file add expected credentials since using    environment credential source  ", "content": "# Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"). You\n# may not use this file except in compliance with the License. A copy of\n# the License is located at\n#\n#     http://aws.amazon.com/apache2.0/\n#\n# or in the \"license\" file accompanying this file. This file is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n# ANY KIND, either express or implied. See the License for the specific\n# language governing permissions and limitations under the License.\nimport os\nimport shutil\nimport tempfile\nimport json\nimport time\n\nfrom botocore.session import Session\nfrom botocore.exceptions import ClientError\n\nfrom awscli.testutils import unittest, aws, random_chars\n\nS3_READ_POLICY_ARN = 'arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess'\n\n\nclass TestAssumeRoleCredentials(unittest.TestCase):\n    def setUp(self):\n        super(TestAssumeRoleCredentials, self).setUp()\n        self.environ = os.environ.copy()\n        self.parent_session = Session()\n        self.iam = self.parent_session.create_client('iam')\n        self.sts = self.parent_session.create_client('sts')\n        self.tempdir = tempfile.mkdtemp()\n        self.config_file = os.path.join(self.tempdir, 'config')\n\n        # A role trust policy that allows the current account to call assume\n        # role on itself.\n        account_id = self.sts.get_caller_identity()['Account']\n        self.role_policy = {\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n                {\n                    \"Effect\": \"Allow\",\n                    \"Principal\": {\n                        \"AWS\": \"arn:aws:iam::%s:root\" % account_id\n                    },\n                    \"Action\": \"sts:AssumeRole\"\n                }\n            ]\n        }\n\n    def tearDown(self):\n        super(TestAssumeRoleCredentials, self).tearDown()\n        shutil.rmtree(self.tempdir)\n\n    def random_name(self):\n        return 'clitest-' + random_chars(10)\n\n    def create_role(self, policy_document, policy_arn=None):\n        name = self.random_name()\n        response = self.iam.create_role(\n            RoleName=name,\n            AssumeRolePolicyDocument=json.dumps(policy_document)\n        )\n        self.addCleanup(self.iam.delete_role, RoleName=name)\n        if policy_arn:\n            self.iam.attach_role_policy(RoleName=name, PolicyArn=policy_arn)\n            self.addCleanup(\n                self.iam.detach_role_policy, RoleName=name,\n                PolicyArn=policy_arn\n            )\n        return response['Role']\n\n    def create_user(self, policy_arns):\n        name = self.random_name()\n        user = self.iam.create_user(UserName=name)['User']\n        self.addCleanup(self.iam.delete_user, UserName=name)\n\n        for arn in policy_arns:\n            self.iam.attach_user_policy(\n                UserName=name,\n                PolicyArn=arn\n            )\n            self.addCleanup(\n                self.iam.detach_user_policy,\n                UserName=name, PolicyArn=arn\n            )\n\n        return user\n\n    def create_creds(self, user_name):\n        creds = self.iam.create_access_key(UserName=user_name)['AccessKey']\n        self.addCleanup(\n            self.iam.delete_access_key,\n            UserName=user_name, AccessKeyId=creds['AccessKeyId']\n        )\n        return creds\n\n    def wait_for_assume_role(self, role_arn, access_key, secret_key,\n                             token=None, attempts=30, delay=10):\n        # \"Why not use the policy simulator?\" you might ask. The answer is\n        # that the policy simulator will return success far before you can\n        # actually make the calls.\n        client = self.parent_session.create_client(\n            'sts', aws_access_key_id=access_key,\n            aws_secret_access_key=secret_key, aws_session_token=token\n        )\n        attempts_remaining = attempts\n        role_session_name = random_chars(10)\n        while attempts_remaining > 0:\n            attempts_remaining -= 1\n            try:\n                result = client.assume_role(\n                    RoleArn=role_arn, RoleSessionName=role_session_name)\n                return result['Credentials']\n            except ClientError as e:\n                code = e.response.get('Error', {}).get('Code')\n                if code in [\"InvalidClientTokenId\", \"AccessDenied\"]:\n                    time.sleep(delay)\n                else:\n                    raise\n\n        raise Exception(\"Unable to assume role %s\" % role_arn)\n\n    def create_assume_policy(self, role_arn):\n        policy_document = {\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n                {\n                    \"Effect\": \"Allow\",\n                    \"Resource\": role_arn,\n                    \"Action\": \"sts:AssumeRole\"\n                }\n            ]\n        }\n        name = self.random_name()\n        response = self.iam.create_policy(\n            PolicyName=name,\n            PolicyDocument=json.dumps(policy_document)\n        )\n        self.addCleanup(\n            self.iam.delete_policy, PolicyArn=response['Policy']['Arn']\n        )\n        return response['Policy']['Arn']\n\n    def assert_s3_read_only_profile(self, profile_name):\n        # Calls to S3 should succeed\n        command = 's3api list-buckets --profile %s' % profile_name\n        result = aws(command, env_vars=self.environ)\n        self.assertEqual(result.rc, 0, result.stderr)\n\n        # Calls to other services should not\n        command = 'iam list-groups --profile %s' % profile_name\n        result = aws(command, env_vars=self.environ)\n        self.assertNotEqual(result.rc, 0, result.stdout)\n        self.assertIn('AccessDenied', result.stderr)\n\n    def test_recursive_assume_role(self):\n        # Create the final role, the one that will actually have access to s3\n        final_role = self.create_role(self.role_policy, S3_READ_POLICY_ARN)\n\n        # Create the role that can assume the final role\n        middle_policy_arn = self.create_assume_policy(final_role['Arn'])\n        middle_role = self.create_role(self.role_policy, middle_policy_arn)\n\n        # Create a user that can only assume the middle-man role, and then get\n        # static credentials for it.\n        user_policy_arn = self.create_assume_policy(middle_role['Arn'])\n        user = self.create_user([user_policy_arn])\n        user_creds = self.create_creds(user['UserName'])\n\n        # Setup the config file with the profiles we'll be using. For\n        # convenience static credentials are placed here instead of putting\n        # them in the credentials file.\n        config = (\n            '[default]\\n'\n            'aws_access_key_id = %s\\n'\n            'aws_secret_access_key = %s\\n'\n            '[profile middle]\\n'\n            'source_profile = default\\n'\n            'role_arn = %s\\n'\n            '[profile final]\\n'\n            'source_profile = middle\\n'\n            'role_arn = %s\\n'\n        )\n        config = config % (\n            user_creds['AccessKeyId'], user_creds['SecretAccessKey'],\n            middle_role['Arn'], final_role['Arn']\n        )\n        with open(self.config_file, 'w') as f:\n            f.write(config)\n\n        # Wait for IAM permissions to propagate\n        middle_creds = self.wait_for_assume_role(\n            role_arn=middle_role['Arn'],\n            access_key=user_creds['AccessKeyId'],\n            secret_key=user_creds['SecretAccessKey'],\n        )\n        self.wait_for_assume_role(\n            role_arn=final_role['Arn'],\n            access_key=middle_creds['AccessKeyId'],\n            secret_key=middle_creds['SecretAccessKey'],\n            token=middle_creds['SessionToken'],\n        )\n\n        # Configure our credentials file to be THE credentials file\n        self.environ['AWS_CONFIG_FILE'] = self.config_file\n\n        self.assert_s3_read_only_profile(profile_name='final')\n\n    def test_assume_role_with_credential_source(self):\n        # Create a role with read access to S3\n        role = self.create_role(self.role_policy, S3_READ_POLICY_ARN)\n\n        # Create a user that can assume the role and get static credentials\n        # for it.\n        user_policy_arn = self.create_assume_policy(role['Arn'])\n        user = self.create_user([user_policy_arn])\n        user_creds = self.create_creds(user['UserName'])\n\n        # Setup the config file with the profile we'll be using.\n        config = (\n            '[profile assume]\\n'\n            'role_arn = %s\\n'\n            'credential_source = Environment\\n'\n        )\n        config = config % role['Arn']\n        with open(self.config_file, 'w') as f:\n            f.write(config)\n\n        # Wait for IAM permissions to propagate\n        self.wait_for_assume_role(\n            role_arn=role['Arn'],\n            access_key=user_creds['AccessKeyId'],\n            secret_key=user_creds['SecretAccessKey'],\n        )\n\n        # Setup the environment so that our new config file is THE config\n        # file and add the expected credentials since we're using the\n        # environment as our credential source.\n        self.environ['AWS_CONFIG_FILE'] = self.config_file\n        self.environ['AWS_SECRET_ACCESS_KEY'] = user_creds['SecretAccessKey']\n        self.environ['AWS_ACCESS_KEY_ID'] = user_creds['AccessKeyId']\n\n        self.assert_s3_read_only_profile(profile_name='assume')\n", "description": "Universal Command Line Interface for Amazon Web Services", "file_name": "test_assume_role.py", "id": "2d311e0dd3bb7c5fc98c68cce23c469e", "language": "Python", "project_name": "aws-cli", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/aws-aws-cli/aws-aws-cli-d705c60/tests/integration/test_assume_role.py", "save_time": "", "source": "", "update_at": "2018-03-18T15:33:26Z", "url": "https://github.com/aws/aws-cli", "wiki": false}