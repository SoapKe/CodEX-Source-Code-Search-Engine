{"author": "HelloZeroNet", "code": "import base64\nimport os\n\nfrom Plugin import PluginManager\nfrom Crypt import CryptBitcoin\nfrom lib.pybitcointools import bitcoin as btctools\n\nimport CryptMessage\n\n\n@PluginManager.registerTo(\"UiWebsocket\")\nclass UiWebsocketPlugin(object):\n    def encrypt(self, text, publickey):\n        encrypted = CryptMessage.encrypt(text, CryptMessage.toOpensslPublickey(publickey))\n        return encrypted\n\n    def decrypt(self, encrypted, privatekey):\n        back = CryptMessage.getEcc(privatekey).decrypt(encrypted)\n        return back.decode(\"utf8\")\n\n    \n\n    \n    \n    def actionUserPublickey(self, to, index=0):\n        publickey = self.user.getEncryptPublickey(self.site.address, index)\n        self.response(to, publickey)\n\n    \n    \n    def actionEciesEncrypt(self, to, text, publickey=0, return_aes_key=False):\n        if type(publickey) is int:  \n            publickey = self.user.getEncryptPublickey(self.site.address, publickey)\n        aes_key, encrypted = self.encrypt(text.encode(\"utf8\"), publickey.decode(\"base64\"))\n        if return_aes_key:\n            self.response(to, [base64.b64encode(encrypted), base64.b64encode(aes_key)])\n        else:\n            self.response(to, base64.b64encode(encrypted))\n\n    \n    \n    def actionEciesDecrypt(self, to, param, privatekey=0):\n        if type(privatekey) is int:  \n            privatekey = self.user.getEncryptPrivatekey(self.site.address, privatekey)\n\n        if type(param) == list:\n            encrypted_texts = param\n        else:\n            encrypted_texts = [param]\n\n        texts = []  \n        for encrypted_text in encrypted_texts:\n            try:\n                text = self.decrypt(encrypted_text.decode(\"base64\"), privatekey)\n                texts.append(text)\n            except Exception as err:\n                texts.append(None)\n\n        if type(param) == list:\n            self.response(to, texts)\n        else:\n            self.response(to, texts[0])\n\n    \n    \n    def actionAesEncrypt(self, to, text, key=None, iv=None):\n        from lib import pyelliptic\n\n        if key:\n            key = key.decode(\"base64\")\n        else:\n            key = os.urandom(32)\n\n        if iv:  \n            iv = iv.decode(\"base64\")\n        else:\n            iv = pyelliptic.Cipher.gen_IV('aes-256-cbc')\n\n        if text:\n            encrypted = pyelliptic.Cipher(key, iv, 1, ciphername='aes-256-cbc').ciphering(text.encode(\"utf8\"))\n        else:\n            encrypted = \"\"\n\n        self.response(to, [base64.b64encode(key), base64.b64encode(iv), base64.b64encode(encrypted)])\n\n    \n    \n    def actionAesDecrypt(self, to, *args):\n        from lib import pyelliptic\n\n        if len(args) == 3:  \n            encrypted_texts = [(args[0], args[1])]\n            keys = [args[2]]\n        else:  \n            encrypted_texts, keys = args\n\n        texts = []  \n        for iv, encrypted_text in encrypted_texts:\n            encrypted_text = encrypted_text.decode(\"base64\")\n            iv = iv.decode(\"base64\")\n            text = None\n            for key in keys:\n                ctx = pyelliptic.Cipher(key.decode(\"base64\"), iv, 0, ciphername='aes-256-cbc')\n                try:\n                    decrypted = ctx.ciphering(encrypted_text)\n                    if decrypted and decrypted.decode(\"utf8\"):  \n                        text = decrypted\n                except Exception, err:\n                    pass\n            texts.append(text)\n\n        if len(args) == 3:\n            self.response(to, texts[0])\n        else:\n            self.response(to, texts)\n\n\n@PluginManager.registerTo(\"User\")\nclass UserPlugin(object):\n    def getEncryptPrivatekey(self, address, param_index=0):\n        assert param_index >= 0 and param_index <= 1000\n        site_data = self.getSiteData(address)\n\n        if site_data.get(\"cert\"):  \n            index = param_index + self.getAddressAuthIndex(site_data[\"cert\"])\n        else:\n            index = param_index\n\n        if \"encrypt_privatekey_%s\" % index not in site_data:\n            address_index = self.getAddressAuthIndex(address)\n            crypt_index = address_index + 1000 + index\n            site_data[\"encrypt_privatekey_%s\" % index] = CryptBitcoin.hdPrivatekey(self.master_seed, crypt_index)\n            self.log.debug(\"New encrypt privatekey generated for %s:%s\" % (address, index))\n        return site_data[\"encrypt_privatekey_%s\" % index]\n\n    def getEncryptPublickey(self, address, param_index=0):\n        assert param_index >= 0 and param_index <= 1000\n        site_data = self.getSiteData(address)\n\n        if site_data.get(\"cert\"):  \n            index = param_index + self.getAddressAuthIndex(site_data[\"cert\"])\n        else:\n            index = param_index\n\n        if \"encrypt_publickey_%s\" % index not in site_data:\n            privatekey = self.getEncryptPrivatekey(address, param_index)\n            publickey = btctools.encode_pubkey(btctools.privtopub(privatekey), \"bin_compressed\")\n            site_data[\"encrypt_publickey_%s\" % index] = base64.b64encode(publickey)\n        return site_data[\"encrypt_publickey_%s\" % index]\n", "comments": "    actions      returns user public key unique site    return  public key    encrypt text using publickey user sites unique publickey    return  encrypted text using base64 encoding    encrypt using user publickey    decrypt text using privatekey user site unique private key    return  decrypted text list decrypted texts    decrypt using user privatekey    decoded texts    encrypt text using aes    return  iv  aes key  encrypted text    generate new aes key definied    decrypt text using aes    return  decrypted text    single decrypt    batch decrypt    decoded texts    valid text decoded    different privatekey different cert provider    different privatekey different cert provider ", "content": "import base64\nimport os\n\nfrom Plugin import PluginManager\nfrom Crypt import CryptBitcoin\nfrom lib.pybitcointools import bitcoin as btctools\n\nimport CryptMessage\n\n\n@PluginManager.registerTo(\"UiWebsocket\")\nclass UiWebsocketPlugin(object):\n    def encrypt(self, text, publickey):\n        encrypted = CryptMessage.encrypt(text, CryptMessage.toOpensslPublickey(publickey))\n        return encrypted\n\n    def decrypt(self, encrypted, privatekey):\n        back = CryptMessage.getEcc(privatekey).decrypt(encrypted)\n        return back.decode(\"utf8\")\n\n    # - Actions -\n\n    # Returns user's public key unique to site\n    # Return: Public key\n    def actionUserPublickey(self, to, index=0):\n        publickey = self.user.getEncryptPublickey(self.site.address, index)\n        self.response(to, publickey)\n\n    # Encrypt a text using the publickey or user's sites unique publickey\n    # Return: Encrypted text using base64 encoding\n    def actionEciesEncrypt(self, to, text, publickey=0, return_aes_key=False):\n        if type(publickey) is int:  # Encrypt using user's publickey\n            publickey = self.user.getEncryptPublickey(self.site.address, publickey)\n        aes_key, encrypted = self.encrypt(text.encode(\"utf8\"), publickey.decode(\"base64\"))\n        if return_aes_key:\n            self.response(to, [base64.b64encode(encrypted), base64.b64encode(aes_key)])\n        else:\n            self.response(to, base64.b64encode(encrypted))\n\n    # Decrypt a text using privatekey or the user's site unique private key\n    # Return: Decrypted text or list of decrypted texts\n    def actionEciesDecrypt(self, to, param, privatekey=0):\n        if type(privatekey) is int:  # Decrypt using user's privatekey\n            privatekey = self.user.getEncryptPrivatekey(self.site.address, privatekey)\n\n        if type(param) == list:\n            encrypted_texts = param\n        else:\n            encrypted_texts = [param]\n\n        texts = []  # Decoded texts\n        for encrypted_text in encrypted_texts:\n            try:\n                text = self.decrypt(encrypted_text.decode(\"base64\"), privatekey)\n                texts.append(text)\n            except Exception as err:\n                texts.append(None)\n\n        if type(param) == list:\n            self.response(to, texts)\n        else:\n            self.response(to, texts[0])\n\n    # Encrypt a text using AES\n    # Return: Iv, AES key, Encrypted text\n    def actionAesEncrypt(self, to, text, key=None, iv=None):\n        from lib import pyelliptic\n\n        if key:\n            key = key.decode(\"base64\")\n        else:\n            key = os.urandom(32)\n\n        if iv:  # Generate new AES key if not definied\n            iv = iv.decode(\"base64\")\n        else:\n            iv = pyelliptic.Cipher.gen_IV('aes-256-cbc')\n\n        if text:\n            encrypted = pyelliptic.Cipher(key, iv, 1, ciphername='aes-256-cbc').ciphering(text.encode(\"utf8\"))\n        else:\n            encrypted = \"\"\n\n        self.response(to, [base64.b64encode(key), base64.b64encode(iv), base64.b64encode(encrypted)])\n\n    # Decrypt a text using AES\n    # Return: Decrypted text\n    def actionAesDecrypt(self, to, *args):\n        from lib import pyelliptic\n\n        if len(args) == 3:  # Single decrypt\n            encrypted_texts = [(args[0], args[1])]\n            keys = [args[2]]\n        else:  # Batch decrypt\n            encrypted_texts, keys = args\n\n        texts = []  # Decoded texts\n        for iv, encrypted_text in encrypted_texts:\n            encrypted_text = encrypted_text.decode(\"base64\")\n            iv = iv.decode(\"base64\")\n            text = None\n            for key in keys:\n                ctx = pyelliptic.Cipher(key.decode(\"base64\"), iv, 0, ciphername='aes-256-cbc')\n                try:\n                    decrypted = ctx.ciphering(encrypted_text)\n                    if decrypted and decrypted.decode(\"utf8\"):  # Valid text decoded\n                        text = decrypted\n                except Exception, err:\n                    pass\n            texts.append(text)\n\n        if len(args) == 3:\n            self.response(to, texts[0])\n        else:\n            self.response(to, texts)\n\n\n@PluginManager.registerTo(\"User\")\nclass UserPlugin(object):\n    def getEncryptPrivatekey(self, address, param_index=0):\n        assert param_index >= 0 and param_index <= 1000\n        site_data = self.getSiteData(address)\n\n        if site_data.get(\"cert\"):  # Different privatekey for different cert provider\n            index = param_index + self.getAddressAuthIndex(site_data[\"cert\"])\n        else:\n            index = param_index\n\n        if \"encrypt_privatekey_%s\" % index not in site_data:\n            address_index = self.getAddressAuthIndex(address)\n            crypt_index = address_index + 1000 + index\n            site_data[\"encrypt_privatekey_%s\" % index] = CryptBitcoin.hdPrivatekey(self.master_seed, crypt_index)\n            self.log.debug(\"New encrypt privatekey generated for %s:%s\" % (address, index))\n        return site_data[\"encrypt_privatekey_%s\" % index]\n\n    def getEncryptPublickey(self, address, param_index=0):\n        assert param_index >= 0 and param_index <= 1000\n        site_data = self.getSiteData(address)\n\n        if site_data.get(\"cert\"):  # Different privatekey for different cert provider\n            index = param_index + self.getAddressAuthIndex(site_data[\"cert\"])\n        else:\n            index = param_index\n\n        if \"encrypt_publickey_%s\" % index not in site_data:\n            privatekey = self.getEncryptPrivatekey(address, param_index)\n            publickey = btctools.encode_pubkey(btctools.privtopub(privatekey), \"bin_compressed\")\n            site_data[\"encrypt_publickey_%s\" % index] = base64.b64encode(publickey)\n        return site_data[\"encrypt_publickey_%s\" % index]\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "CryptMessagePlugin.py", "id": "2848c19ded08b3eb010091d61e4340fc", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/plugins/CryptMessage/CryptMessagePlugin.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}