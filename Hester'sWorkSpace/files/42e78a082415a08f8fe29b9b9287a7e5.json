{"author": "ansible", "code": "\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: profitbricks\nshort_description: Create, destroy, start, stop, and reboot a ProfitBricks virtual machine.\ndescription:\n     - Create, destroy, update, start, stop, and reboot a ProfitBricks virtual machine. When the virtual machine is created it can optionally wait\n       for it to be 'running' before returning. This module has a dependency on profitbricks >= 1.0.0\nversion_added: \"2.0\"\noptions:\n  auto_increment:\n    description:\n      - Whether or not to increment a single number in the name for created virtual machines.\n    type: bool\n    default: 'yes'\n  name:\n    description:\n      - The name of the virtual machine.\n    required: true\n  image:\n    description:\n      - The system image ID for creating the virtual machine, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8.\n    required: true\n  image_password:\n    description:\n      - Password set for the administrative user.\n    version_added: '2.2'\n  ssh_keys:\n    description:\n      - Public SSH keys allowing access to the virtual machine.\n    version_added: '2.2'\n  datacenter:\n    description:\n      - The datacenter to provision this virtual machine.\n  cores:\n    description:\n      - The number of CPU cores to allocate to the virtual machine.\n    default: 2\n  ram:\n    description:\n      - The amount of memory to allocate to the virtual machine.\n    default: 2048\n  cpu_family:\n    description:\n      - The CPU family type to allocate to the virtual machine.\n    default: AMD_OPTERON\n    choices: [ \"AMD_OPTERON\", \"INTEL_XEON\" ]\n    version_added: '2.2'\n  volume_size:\n    description:\n      - The size in GB of the boot volume.\n    default: 10\n  bus:\n    description:\n      - The bus type for the volume.\n    default: VIRTIO\n    choices: [ \"IDE\", \"VIRTIO\"]\n  instance_ids:\n    description:\n      - list of instance ids, currently only used when state='absent' to remove instances.\n  count:\n    description:\n      - The number of virtual machines to create.\n    default: 1\n  location:\n    description:\n      - The datacenter location. Use only if you want to create the Datacenter or else this value is ignored.\n    default: us/las\n    choices: [ \"us/las\", \"de/fra\", \"de/fkb\" ]\n  assign_public_ip:\n    description:\n      - This will assign the machine to the public LAN. If no LAN exists with public Internet access it is created.\n    type: bool\n    default: 'no'\n  lan:\n    description:\n      - The ID of the LAN you wish to add the servers to.\n    default: 1\n  subscription_user:\n    description:\n      - The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.\n  subscription_password:\n    description:\n      - THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.\n  wait:\n    description:\n      - wait for the instance to be in state 'running' before returning\n    type: bool\n    default: 'yes'\n  wait_timeout:\n    description:\n      - how long before wait gives up, in seconds\n    default: 600\n  remove_boot_volume:\n    description:\n      - remove the bootVolume of the virtual machine you're destroying.\n    type: bool\n    default: 'yes'\n  state:\n    description:\n      - create or terminate instances\n    default: 'present'\n    choices: [ \"running\", \"stopped\", \"absent\", \"present\" ]\n\nrequirements:\n     - \"profitbricks\"\n     - \"python >= 2.6\"\nauthor: Matt Baldwin (baldwin@stackpointcloud.com)\n'''\n\nEXAMPLES = '''\n\n\n\n\n\n- profitbricks:\n    datacenter: Tardis One\n    name: web%02d.stackpointcloud.com\n    cores: 4\n    ram: 2048\n    volume_size: 50\n    cpu_family: INTEL_XEON\n    image: a3eae284-a2fe-11e4-b187-5f1f641608c8\n    location: us/las\n    count: 3\n    assign_public_ip: true\n\n\n\n- profitbricks:\n    datacenter: Tardis One\n    instance_ids:\n      - 'web001.stackpointcloud.com'\n      - 'web002.stackpointcloud.com'\n      - 'web003.stackpointcloud.com'\n    wait_timeout: 500\n    state: absent\n\n\n\n- profitbricks:\n    datacenter: Tardis One\n    instance_ids:\n      - 'web001.stackpointcloud.com'\n      - 'web002.stackpointcloud.com'\n      - 'web003.stackpointcloud.com'\n    wait_timeout: 500\n    state: running\n\n\n\n- profitbricks:\n    datacenter: Tardis One\n    instance_ids:\n      - 'web001.stackpointcloud.com'\n      - 'web002.stackpointcloud.com'\n      - 'web003.stackpointcloud.com'\n    wait_timeout: 500\n    state: stopped\n\n'''\n\nimport re\nimport uuid\nimport time\nimport traceback\n\nHAS_PB_SDK = True\n\ntry:\n    from profitbricks.client import ProfitBricksService, Volume, Server, Datacenter, NIC, LAN\nexcept ImportError:\n    HAS_PB_SDK = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.six.moves import xrange\nfrom ansible.module_utils._text import to_native\n\n\nLOCATIONS = ['us/las',\n             'de/fra',\n             'de/fkb']\n\nuuid_match = re.compile(\n    r'[\\w]{8}-[\\w]{4}-[\\w]{4}-[\\w]{4}-[\\w]{12}', re.I)\n\n\ndef _wait_for_completion(profitbricks, promise, wait_timeout, msg):\n    if not promise:\n        return\n    wait_timeout = time.time() + wait_timeout\n    while wait_timeout > time.time():\n        time.sleep(5)\n        operation_result = profitbricks.get_request(\n            request_id=promise['requestId'],\n            status=True)\n\n        if operation_result['metadata']['status'] == \"DONE\":\n            return\n        elif operation_result['metadata']['status'] == \"FAILED\":\n            raise Exception(\n                'Request failed to complete ' + msg + ' \"' + str(\n                    promise['requestId']) + '\" to complete.')\n\n    raise Exception(\n        'Timed out waiting for async operation ' + msg + ' \"' + str(\n            promise['requestId']\n        ) + '\" to complete.')\n\n\ndef _create_machine(module, profitbricks, datacenter, name):\n    cores = module.params.get('cores')\n    ram = module.params.get('ram')\n    cpu_family = module.params.get('cpu_family')\n    volume_size = module.params.get('volume_size')\n    disk_type = module.params.get('disk_type')\n    image_password = module.params.get('image_password')\n    ssh_keys = module.params.get('ssh_keys')\n    bus = module.params.get('bus')\n    lan = module.params.get('lan')\n    assign_public_ip = module.params.get('assign_public_ip')\n    subscription_user = module.params.get('subscription_user')\n    subscription_password = module.params.get('subscription_password')\n    location = module.params.get('location')\n    image = module.params.get('image')\n    assign_public_ip = module.boolean(module.params.get('assign_public_ip'))\n    wait = module.params.get('wait')\n    wait_timeout = module.params.get('wait_timeout')\n\n    if assign_public_ip:\n        public_found = False\n\n        lans = profitbricks.list_lans(datacenter)\n        for lan in lans['items']:\n            if lan['properties']['public']:\n                public_found = True\n                lan = lan['id']\n\n        if not public_found:\n            i = LAN(\n                name='public',\n                public=True)\n\n            lan_response = profitbricks.create_lan(datacenter, i)\n            _wait_for_completion(profitbricks, lan_response,\n                                 wait_timeout, \"_create_machine\")\n            lan = lan_response['id']\n\n    v = Volume(\n        name=str(uuid.uuid4()).replace('-', '')[:10],\n        size=volume_size,\n        image=image,\n        image_password=image_password,\n        ssh_keys=ssh_keys,\n        disk_type=disk_type,\n        bus=bus)\n\n    n = NIC(\n        lan=int(lan)\n    )\n\n    s = Server(\n        name=name,\n        ram=ram,\n        cores=cores,\n        cpu_family=cpu_family,\n        create_volumes=[v],\n        nics=[n],\n    )\n\n    try:\n        create_server_response = profitbricks.create_server(\n            datacenter_id=datacenter, server=s)\n\n        _wait_for_completion(profitbricks, create_server_response,\n                             wait_timeout, \"create_virtual_machine\")\n\n        server_response = profitbricks.get_server(\n            datacenter_id=datacenter,\n            server_id=create_server_response['id'],\n            depth=3\n        )\n    except Exception as e:\n        module.fail_json(msg=\"failed to create the new server: %s\" % str(e))\n    else:\n        return server_response\n\n\ndef _startstop_machine(module, profitbricks, datacenter_id, server_id):\n    state = module.params.get('state')\n\n    try:\n        if state == 'running':\n            profitbricks.start_server(datacenter_id, server_id)\n        else:\n            profitbricks.stop_server(datacenter_id, server_id)\n\n        return True\n    except Exception as e:\n        module.fail_json(msg=\"failed to start or stop the virtual machine %s at %s: %s\" % (server_id, datacenter_id, str(e)))\n\n\ndef _create_datacenter(module, profitbricks):\n    datacenter = module.params.get('datacenter')\n    location = module.params.get('location')\n    wait_timeout = module.params.get('wait_timeout')\n\n    i = Datacenter(\n        name=datacenter,\n        location=location\n    )\n\n    try:\n        datacenter_response = profitbricks.create_datacenter(datacenter=i)\n\n        _wait_for_completion(profitbricks, datacenter_response,\n                             wait_timeout, \"_create_datacenter\")\n\n        return datacenter_response\n    except Exception as e:\n        module.fail_json(msg=\"failed to create the new server(s): %s\" % str(e))\n\n\ndef create_virtual_machine(module, profitbricks):\n    \"\"\"\n    Create new virtual machine\n\n    module : AnsibleModule object\n    profitbricks: authenticated profitbricks object\n\n    Returns:\n        True if a new virtual machine was created, false otherwise\n    \"\"\"\n    datacenter = module.params.get('datacenter')\n    name = module.params.get('name')\n    auto_increment = module.params.get('auto_increment')\n    count = module.params.get('count')\n    lan = module.params.get('lan')\n    wait_timeout = module.params.get('wait_timeout')\n    failed = True\n    datacenter_found = False\n\n    virtual_machines = []\n    virtual_machine_ids = []\n\n    \n    datacenter_list = profitbricks.list_datacenters()\n    datacenter_id = _get_datacenter_id(datacenter_list, datacenter)\n    if datacenter_id:\n        datacenter_found = True\n\n    if not datacenter_found:\n        datacenter_response = _create_datacenter(module, profitbricks)\n        datacenter_id = datacenter_response['id']\n\n        _wait_for_completion(profitbricks, datacenter_response,\n                             wait_timeout, \"create_virtual_machine\")\n\n    if auto_increment:\n        numbers = set()\n        count_offset = 1\n\n        try:\n            name % 0\n        except TypeError as e:\n            if e.message.startswith('not all'):\n                name = '%s%%d' % name\n            else:\n                module.fail_json(msg=e.message, exception=traceback.format_exc())\n\n        number_range = xrange(count_offset, count_offset + count + len(numbers))\n        available_numbers = list(set(number_range).difference(numbers))\n        names = []\n        numbers_to_use = available_numbers[:count]\n        for number in numbers_to_use:\n            names.append(name % number)\n    else:\n        names = [name]\n\n    \n    server_list = profitbricks.list_servers(datacenter_id)\n    for name in names:\n        \n        if _get_server_id(server_list, name):\n            continue\n\n        create_response = _create_machine(module, profitbricks, str(datacenter_id), name)\n        nics = profitbricks.list_nics(datacenter_id, create_response['id'])\n        for n in nics['items']:\n            if lan == n['properties']['lan']:\n                create_response.update({'public_ip': n['properties']['ips'][0]})\n\n        virtual_machines.append(create_response)\n\n    failed = False\n\n    results = {\n        'failed': failed,\n        'machines': virtual_machines,\n        'action': 'create',\n        'instance_ids': {\n            'instances': [i['id'] for i in virtual_machines],\n        }\n    }\n\n    return results\n\n\ndef remove_virtual_machine(module, profitbricks):\n    \"\"\"\n    Removes a virtual machine.\n\n    This will remove the virtual machine along with the bootVolume.\n\n    module : AnsibleModule object\n    profitbricks: authenticated profitbricks object.\n\n    Not yet supported: handle deletion of attached data disks.\n\n    Returns:\n        True if a new virtual server was deleted, false otherwise\n    \"\"\"\n    datacenter = module.params.get('datacenter')\n    instance_ids = module.params.get('instance_ids')\n    remove_boot_volume = module.params.get('remove_boot_volume')\n    changed = False\n\n    if not isinstance(module.params.get('instance_ids'), list) or len(module.params.get('instance_ids')) < 1:\n        module.fail_json(msg='instance_ids should be a list of virtual machine ids or names, aborting')\n\n    \n    datacenter_list = profitbricks.list_datacenters()\n    datacenter_id = _get_datacenter_id(datacenter_list, datacenter)\n    if not datacenter_id:\n        module.fail_json(msg='Virtual data center \\'%s\\' not found.' % str(datacenter))\n\n    \n    server_list = profitbricks.list_servers(datacenter_id)\n    for instance in instance_ids:\n        \n        server_id = _get_server_id(server_list, instance)\n        if server_id:\n            \n            if remove_boot_volume:\n                _remove_boot_volume(module, profitbricks, datacenter_id, server_id)\n\n            \n            try:\n                server_response = profitbricks.delete_server(datacenter_id, server_id)\n            except Exception as e:\n                module.fail_json(msg=\"failed to terminate the virtual server: %s\" % to_native(e), exception=traceback.format_exc())\n            else:\n                changed = True\n\n    return changed\n\n\ndef _remove_boot_volume(module, profitbricks, datacenter_id, server_id):\n    \"\"\"\n    Remove the boot volume from the server\n    \"\"\"\n    try:\n        server = profitbricks.get_server(datacenter_id, server_id)\n        volume_id = server['properties']['bootVolume']['id']\n        volume_response = profitbricks.delete_volume(datacenter_id, volume_id)\n    except Exception as e:\n        module.fail_json(msg=\"failed to remove the server's boot volume: %s\" % to_native(e), exception=traceback.format_exc())\n\n\ndef startstop_machine(module, profitbricks, state):\n    \"\"\"\n    Starts or Stops a virtual machine.\n\n    module : AnsibleModule object\n    profitbricks: authenticated profitbricks object.\n\n    Returns:\n        True when the servers process the action successfully, false otherwise.\n    \"\"\"\n    if not isinstance(module.params.get('instance_ids'), list) or len(module.params.get('instance_ids')) < 1:\n        module.fail_json(msg='instance_ids should be a list of virtual machine ids or names, aborting')\n\n    wait = module.params.get('wait')\n    wait_timeout = module.params.get('wait_timeout')\n    changed = False\n\n    datacenter = module.params.get('datacenter')\n    instance_ids = module.params.get('instance_ids')\n\n    \n    datacenter_list = profitbricks.list_datacenters()\n    datacenter_id = _get_datacenter_id(datacenter_list, datacenter)\n    if not datacenter_id:\n        module.fail_json(msg='Virtual data center \\'%s\\' not found.' % str(datacenter))\n\n    \n    server_list = profitbricks.list_servers(datacenter_id)\n    for instance in instance_ids:\n        \n        server_id = _get_server_id(server_list, instance)\n        if server_id:\n            _startstop_machine(module, profitbricks, datacenter_id, server_id)\n            changed = True\n\n    if wait:\n        wait_timeout = time.time() + wait_timeout\n        while wait_timeout > time.time():\n            matched_instances = []\n            for res in profitbricks.list_servers(datacenter_id)['items']:\n                if state == 'running':\n                    if res['properties']['vmState'].lower() == state:\n                        matched_instances.append(res)\n                elif state == 'stopped':\n                    if res['properties']['vmState'].lower() == 'shutoff':\n                        matched_instances.append(res)\n\n            if len(matched_instances) < len(instance_ids):\n                time.sleep(5)\n            else:\n                break\n\n        if wait_timeout <= time.time():\n            \n            module.fail_json(msg=\"wait for virtual machine state timeout on %s\" % time.asctime())\n\n    return (changed)\n\n\ndef _get_datacenter_id(datacenters, identity):\n    \"\"\"\n    Fetch and return datacenter UUID by datacenter name if found.\n    \"\"\"\n    for datacenter in datacenters['items']:\n        if identity in (datacenter['properties']['name'], datacenter['id']):\n            return datacenter['id']\n    return None\n\n\ndef _get_server_id(servers, identity):\n    \"\"\"\n    Fetch and return server UUID by server name if found.\n    \"\"\"\n    for server in servers['items']:\n        if identity in (server['properties']['name'], server['id']):\n            return server['id']\n    return None\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            datacenter=dict(),\n            name=dict(),\n            image=dict(),\n            cores=dict(type='int', default=2),\n            ram=dict(type='int', default=2048),\n            cpu_family=dict(choices=['AMD_OPTERON', 'INTEL_XEON'],\n                            default='AMD_OPTERON'),\n            volume_size=dict(type='int', default=10),\n            disk_type=dict(choices=['HDD', 'SSD'], default='HDD'),\n            image_password=dict(default=None, no_log=True),\n            ssh_keys=dict(type='list', default=[]),\n            bus=dict(choices=['VIRTIO', 'IDE'], default='VIRTIO'),\n            lan=dict(type='int', default=1),\n            count=dict(type='int', default=1),\n            auto_increment=dict(type='bool', default=True),\n            instance_ids=dict(type='list', default=[]),\n            subscription_user=dict(),\n            subscription_password=dict(no_log=True),\n            location=dict(choices=LOCATIONS, default='us/las'),\n            assign_public_ip=dict(type='bool', default=False),\n            wait=dict(type='bool', default=True),\n            wait_timeout=dict(type='int', default=600),\n            remove_boot_volume=dict(type='bool', default=True),\n            state=dict(default='present'),\n        )\n    )\n\n    if not HAS_PB_SDK:\n        module.fail_json(msg='profitbricks required for this module')\n\n    subscription_user = module.params.get('subscription_user')\n    subscription_password = module.params.get('subscription_password')\n\n    profitbricks = ProfitBricksService(\n        username=subscription_user,\n        password=subscription_password)\n\n    state = module.params.get('state')\n\n    if state == 'absent':\n        if not module.params.get('datacenter'):\n            module.fail_json(msg='datacenter parameter is required ' +\n                             'for running or stopping machines.')\n\n        try:\n            (changed) = remove_virtual_machine(module, profitbricks)\n            module.exit_json(changed=changed)\n        except Exception as e:\n            module.fail_json(msg='failed to set instance state: %s' % to_native(e), exception=traceback.format_exc())\n\n    elif state in ('running', 'stopped'):\n        if not module.params.get('datacenter'):\n            module.fail_json(msg='datacenter parameter is required for ' +\n                             'running or stopping machines.')\n        try:\n            (changed) = startstop_machine(module, profitbricks, state)\n            module.exit_json(changed=changed)\n        except Exception as e:\n            module.fail_json(msg='failed to set instance state: %s' % to_native(e), exception=traceback.format_exc())\n\n    elif state == 'present':\n        if not module.params.get('name'):\n            module.fail_json(msg='name parameter is required for new instance')\n        if not module.params.get('image'):\n            module.fail_json(msg='image parameter is required for new instance')\n        if not module.params.get('subscription_user'):\n            module.fail_json(msg='subscription_user parameter is ' +\n                             'required for new instance')\n        if not module.params.get('subscription_password'):\n            module.fail_json(msg='subscription_password parameter is ' +\n                             'required for new instance')\n\n        try:\n            (machine_dict_array) = create_virtual_machine(module, profitbricks)\n            module.exit_json(**machine_dict_array)\n        except Exception as e:\n            module.fail_json(msg='failed to set instance state: %s' % to_native(e), exception=traceback.format_exc())\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        create new virtual machine      module   ansiblemodule object     profitbricks  authenticated profitbricks object      returns          true new virtual machine created  false otherwise             datacenter   module params get( datacenter )     name   module params get( name )     auto increment   module params get( auto increment )     count   module params get( count )     lan   module params get( lan )     wait timeout   module params get( wait timeout )     failed   true     datacenter found   false      virtual machines          virtual machine ids             locate uuid datacenter referenced name      datacenter list   profitbricks list datacenters()     datacenter id    get datacenter id(datacenter list  datacenter)     datacenter id          datacenter found   true      datacenter found          datacenter response    create datacenter(module  profitbricks)         datacenter id   datacenter response  id             wait completion(profitbricks  datacenter response                               wait timeout   create virtual machine )      auto increment          numbers   set()         count offset   1          try              name   0         except typeerror e              e message startswith( )                  name         name             else                  module fail json(msg e message  exception traceback format exc())          number range   xrange(count offset  count offset   count   len(numbers))         available numbers   list(set(number range) difference(numbers))         names              numbers use   available numbers  count          number numbers use              names append(name   number)     else          names    name         prefetch list servers later comparison      server list   profitbricks list servers(datacenter id)     name names            skip server creation server already exists           get server id(server list  name)              continue          create response    create machine(module  profitbricks  str(datacenter id)  name)         nics   profitbricks list nics(datacenter id  create response  id  )         n nics  items                lan    n  properties    lan                    create response update(  public ip   n  properties    ips   0  )          virtual machines append(create response)      failed   false      results              failed   failed           machines   virtual machines           action    create            instance ids                  instances     id   virtual machines                        return results   def remove virtual machine(module  profitbricks)              removes virtual machine       this remove virtual machine along bootvolume       module   ansiblemodule object     profitbricks  authenticated profitbricks object       not yet supported  handle deletion attached data disks       returns          true new virtual server deleted  false otherwise             datacenter   module params get( datacenter )     instance ids   module params get( instance ids )     remove boot volume   module params get( remove boot volume )     changed   false      isinstance(module params get( instance ids )  list) len(module params get( instance ids ))   1          module fail json(msg  instance ids list virtual machine ids names  aborting )        locate uuid datacenter referenced name      datacenter list   profitbricks list datacenters()     datacenter id    get datacenter id(datacenter list  datacenter)     datacenter id          module fail json(msg  virtual data center      found     str(datacenter))        prefetch server list later comparison      server list   profitbricks list servers(datacenter id)     instance instance ids            locate uuid server referenced name          server id    get server id(server list  instance)         server id                remove server boot volume             remove boot volume                   remove boot volume(module  profitbricks  datacenter id  server id)                remove server             try                  server response   profitbricks delete server(datacenter id  server id)             except exception e                  module fail json(msg  failed terminate virtual server      native(e)  exception traceback format exc())             else                  changed   true      return changed   def  remove boot volume(module  profitbricks  datacenter id  server id)              remove boot volume server             try          server   profitbricks get server(datacenter id  server id)         volume id   server  properties    bootvolume    id           volume response   profitbricks delete volume(datacenter id  volume id)     except exception e          module fail json(msg  failed remove server boot volume      native(e)  exception traceback format exc())   def startstop machine(module  profitbricks  state)              starts stops virtual machine       module   ansiblemodule object     profitbricks  authenticated profitbricks object       returns          true servers process action successfully  false otherwise              isinstance(module params get( instance ids )  list) len(module params get( instance ids ))   1          module fail json(msg  instance ids list virtual machine ids names  aborting )      wait   module params get( wait )     wait timeout   module params get( wait timeout )     changed   false      datacenter   module params get( datacenter )     instance ids   module params get( instance ids )        locate uuid datacenter referenced name      datacenter list   profitbricks list datacenters()     datacenter id    get datacenter id(datacenter list  datacenter)     datacenter id          module fail json(msg  virtual data center      found     str(datacenter))        prefetch server list later comparison      server list   profitbricks list servers(datacenter id)     instance instance ids            locate uuid server referenced name          server id    get server id(server list  instance)         server id               startstop machine(module  profitbricks  datacenter id  server id)             changed   true      wait          wait timeout   time time()   wait timeout         wait timeout   time time()              matched instances                  res profitbricks list servers(datacenter id)  items                    state     running                       res  properties    vmstate   lower()    state                          matched instances append(res)                 elif state     stopped                       res  properties    vmstate   lower()     shutoff                           matched instances append(res)              len(matched instances)   len(instance ids)                  time sleep(5)             else                  break          wait timeout    time time()                waiting took long             module fail json(msg  wait virtual machine state timeout     time asctime())      return (changed)   def  get datacenter id(datacenters  identity)              fetch return datacenter uuid datacenter name found              datacenter datacenters  items            identity (datacenter  properties    name    datacenter  id  )              return datacenter  id       return none   def  get server id(servers  identity)              fetch return server uuid server name found                   module  profitbricks short description  create  destroy  start  stop  reboot profitbricks virtual machine  description         create  destroy  update  start  stop  reboot profitbricks virtual machine  when virtual machine created optionally wait         running  returning  this module dependency profitbricks    1 0 0 version added   2 0  options    auto increment      description          whether increment single number name created virtual machines      type  bool     default   yes    name      description          the name virtual machine      required  true   image      description          the system image id creating virtual machine  e g  a3eae284 a2fe 11e4 b187 5f1f641608c8      required  true   image password      description          password set administrative user      version added   2 2    ssh keys      description          public ssh keys allowing access virtual machine      version added   2 2    datacenter      description          the datacenter provision virtual machine    cores      description          the number cpu cores allocate virtual machine      default  2   ram      description          the amount memory allocate virtual machine      default  2048   cpu family      description          the cpu family type allocate virtual machine      default  amd opteron     choices     amd opteron    intel xeon        version added   2 2    volume size      description          the size gb boot volume      default  10   bus      description          the bus type volume      default  virtio     choices     ide    virtio     instance ids      description          list instance ids  currently used state  absent  remove instances    count      description          the number virtual machines create      default  1   location      description          the datacenter location  use want create datacenter else value ignored      default  us las     choices     us las    de fra    de fkb      assign public ip      description          this assign machine public lan  if lan exists public internet access created      type  bool     default      lan      description          the id lan wish add servers      default  1   subscription user      description          the profitbricks username  overrides pb subscription id environment variable    subscription password      description          the profitbricks password  overrides pb password environment variable    wait      description          wait instance state  running  returning     type  bool     default   yes    wait timeout      description          long wait gives  seconds     default  600   remove boot volume      description          remove bootvolume virtual machine destroying      type  bool     default   yes    state      description          create terminate instances     default   present      choices     running    stopped    absent    present     requirements          profitbricks          python    2 6  author  matt baldwin (baldwin stackpointcloud com)      examples          note  these examples set authentication details  see aws guide details     provisioning example  this create three servers enumerate names     profitbricks      datacenter  tardis one     name  web 02d stackpointcloud com     cores  4     ram  2048     volume size  50     cpu family  intel xeon     image  a3eae284 a2fe 11e4 b187 5f1f641608c8     location  us las     count  3     assign public ip  true    removing virtual machines    profitbricks      datacenter  tardis one     instance ids           web001 stackpointcloud com           web002 stackpointcloud com           web003 stackpointcloud com      wait timeout  500     state  absent    starting virtual machines     profitbricks      datacenter  tardis one     instance ids           web001 stackpointcloud com           web002 stackpointcloud com           web003 stackpointcloud com      wait timeout  500     state  running    stopping virtual machines    profitbricks      datacenter  tardis one     instance ids           web001 stackpointcloud com           web002 stackpointcloud com           web003 stackpointcloud com      wait timeout  500     state  stopped          usr bin python    copyright  ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    note  these examples set authentication details  see aws guide details     provisioning example  this create three servers enumerate names     removing virtual machines    starting virtual machines     stopping virtual machines    locate uuid datacenter referenced name     prefetch list servers later comparison     skip server creation server already exists     locate uuid datacenter referenced name     prefetch server list later comparison     locate uuid server referenced name     remove server boot volume    remove server    locate uuid datacenter referenced name     prefetch server list later comparison     locate uuid server referenced name     waiting took long ", "content": "#!/usr/bin/python\n# Copyright: Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: profitbricks\nshort_description: Create, destroy, start, stop, and reboot a ProfitBricks virtual machine.\ndescription:\n     - Create, destroy, update, start, stop, and reboot a ProfitBricks virtual machine. When the virtual machine is created it can optionally wait\n       for it to be 'running' before returning. This module has a dependency on profitbricks >= 1.0.0\nversion_added: \"2.0\"\noptions:\n  auto_increment:\n    description:\n      - Whether or not to increment a single number in the name for created virtual machines.\n    type: bool\n    default: 'yes'\n  name:\n    description:\n      - The name of the virtual machine.\n    required: true\n  image:\n    description:\n      - The system image ID for creating the virtual machine, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8.\n    required: true\n  image_password:\n    description:\n      - Password set for the administrative user.\n    version_added: '2.2'\n  ssh_keys:\n    description:\n      - Public SSH keys allowing access to the virtual machine.\n    version_added: '2.2'\n  datacenter:\n    description:\n      - The datacenter to provision this virtual machine.\n  cores:\n    description:\n      - The number of CPU cores to allocate to the virtual machine.\n    default: 2\n  ram:\n    description:\n      - The amount of memory to allocate to the virtual machine.\n    default: 2048\n  cpu_family:\n    description:\n      - The CPU family type to allocate to the virtual machine.\n    default: AMD_OPTERON\n    choices: [ \"AMD_OPTERON\", \"INTEL_XEON\" ]\n    version_added: '2.2'\n  volume_size:\n    description:\n      - The size in GB of the boot volume.\n    default: 10\n  bus:\n    description:\n      - The bus type for the volume.\n    default: VIRTIO\n    choices: [ \"IDE\", \"VIRTIO\"]\n  instance_ids:\n    description:\n      - list of instance ids, currently only used when state='absent' to remove instances.\n  count:\n    description:\n      - The number of virtual machines to create.\n    default: 1\n  location:\n    description:\n      - The datacenter location. Use only if you want to create the Datacenter or else this value is ignored.\n    default: us/las\n    choices: [ \"us/las\", \"de/fra\", \"de/fkb\" ]\n  assign_public_ip:\n    description:\n      - This will assign the machine to the public LAN. If no LAN exists with public Internet access it is created.\n    type: bool\n    default: 'no'\n  lan:\n    description:\n      - The ID of the LAN you wish to add the servers to.\n    default: 1\n  subscription_user:\n    description:\n      - The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.\n  subscription_password:\n    description:\n      - THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.\n  wait:\n    description:\n      - wait for the instance to be in state 'running' before returning\n    type: bool\n    default: 'yes'\n  wait_timeout:\n    description:\n      - how long before wait gives up, in seconds\n    default: 600\n  remove_boot_volume:\n    description:\n      - remove the bootVolume of the virtual machine you're destroying.\n    type: bool\n    default: 'yes'\n  state:\n    description:\n      - create or terminate instances\n    default: 'present'\n    choices: [ \"running\", \"stopped\", \"absent\", \"present\" ]\n\nrequirements:\n     - \"profitbricks\"\n     - \"python >= 2.6\"\nauthor: Matt Baldwin (baldwin@stackpointcloud.com)\n'''\n\nEXAMPLES = '''\n\n# Note: These examples do not set authentication details, see the AWS Guide for details.\n\n# Provisioning example. This will create three servers and enumerate their names.\n\n- profitbricks:\n    datacenter: Tardis One\n    name: web%02d.stackpointcloud.com\n    cores: 4\n    ram: 2048\n    volume_size: 50\n    cpu_family: INTEL_XEON\n    image: a3eae284-a2fe-11e4-b187-5f1f641608c8\n    location: us/las\n    count: 3\n    assign_public_ip: true\n\n# Removing Virtual machines\n\n- profitbricks:\n    datacenter: Tardis One\n    instance_ids:\n      - 'web001.stackpointcloud.com'\n      - 'web002.stackpointcloud.com'\n      - 'web003.stackpointcloud.com'\n    wait_timeout: 500\n    state: absent\n\n# Starting Virtual Machines.\n\n- profitbricks:\n    datacenter: Tardis One\n    instance_ids:\n      - 'web001.stackpointcloud.com'\n      - 'web002.stackpointcloud.com'\n      - 'web003.stackpointcloud.com'\n    wait_timeout: 500\n    state: running\n\n# Stopping Virtual Machines\n\n- profitbricks:\n    datacenter: Tardis One\n    instance_ids:\n      - 'web001.stackpointcloud.com'\n      - 'web002.stackpointcloud.com'\n      - 'web003.stackpointcloud.com'\n    wait_timeout: 500\n    state: stopped\n\n'''\n\nimport re\nimport uuid\nimport time\nimport traceback\n\nHAS_PB_SDK = True\n\ntry:\n    from profitbricks.client import ProfitBricksService, Volume, Server, Datacenter, NIC, LAN\nexcept ImportError:\n    HAS_PB_SDK = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.six.moves import xrange\nfrom ansible.module_utils._text import to_native\n\n\nLOCATIONS = ['us/las',\n             'de/fra',\n             'de/fkb']\n\nuuid_match = re.compile(\n    r'[\\w]{8}-[\\w]{4}-[\\w]{4}-[\\w]{4}-[\\w]{12}', re.I)\n\n\ndef _wait_for_completion(profitbricks, promise, wait_timeout, msg):\n    if not promise:\n        return\n    wait_timeout = time.time() + wait_timeout\n    while wait_timeout > time.time():\n        time.sleep(5)\n        operation_result = profitbricks.get_request(\n            request_id=promise['requestId'],\n            status=True)\n\n        if operation_result['metadata']['status'] == \"DONE\":\n            return\n        elif operation_result['metadata']['status'] == \"FAILED\":\n            raise Exception(\n                'Request failed to complete ' + msg + ' \"' + str(\n                    promise['requestId']) + '\" to complete.')\n\n    raise Exception(\n        'Timed out waiting for async operation ' + msg + ' \"' + str(\n            promise['requestId']\n        ) + '\" to complete.')\n\n\ndef _create_machine(module, profitbricks, datacenter, name):\n    cores = module.params.get('cores')\n    ram = module.params.get('ram')\n    cpu_family = module.params.get('cpu_family')\n    volume_size = module.params.get('volume_size')\n    disk_type = module.params.get('disk_type')\n    image_password = module.params.get('image_password')\n    ssh_keys = module.params.get('ssh_keys')\n    bus = module.params.get('bus')\n    lan = module.params.get('lan')\n    assign_public_ip = module.params.get('assign_public_ip')\n    subscription_user = module.params.get('subscription_user')\n    subscription_password = module.params.get('subscription_password')\n    location = module.params.get('location')\n    image = module.params.get('image')\n    assign_public_ip = module.boolean(module.params.get('assign_public_ip'))\n    wait = module.params.get('wait')\n    wait_timeout = module.params.get('wait_timeout')\n\n    if assign_public_ip:\n        public_found = False\n\n        lans = profitbricks.list_lans(datacenter)\n        for lan in lans['items']:\n            if lan['properties']['public']:\n                public_found = True\n                lan = lan['id']\n\n        if not public_found:\n            i = LAN(\n                name='public',\n                public=True)\n\n            lan_response = profitbricks.create_lan(datacenter, i)\n            _wait_for_completion(profitbricks, lan_response,\n                                 wait_timeout, \"_create_machine\")\n            lan = lan_response['id']\n\n    v = Volume(\n        name=str(uuid.uuid4()).replace('-', '')[:10],\n        size=volume_size,\n        image=image,\n        image_password=image_password,\n        ssh_keys=ssh_keys,\n        disk_type=disk_type,\n        bus=bus)\n\n    n = NIC(\n        lan=int(lan)\n    )\n\n    s = Server(\n        name=name,\n        ram=ram,\n        cores=cores,\n        cpu_family=cpu_family,\n        create_volumes=[v],\n        nics=[n],\n    )\n\n    try:\n        create_server_response = profitbricks.create_server(\n            datacenter_id=datacenter, server=s)\n\n        _wait_for_completion(profitbricks, create_server_response,\n                             wait_timeout, \"create_virtual_machine\")\n\n        server_response = profitbricks.get_server(\n            datacenter_id=datacenter,\n            server_id=create_server_response['id'],\n            depth=3\n        )\n    except Exception as e:\n        module.fail_json(msg=\"failed to create the new server: %s\" % str(e))\n    else:\n        return server_response\n\n\ndef _startstop_machine(module, profitbricks, datacenter_id, server_id):\n    state = module.params.get('state')\n\n    try:\n        if state == 'running':\n            profitbricks.start_server(datacenter_id, server_id)\n        else:\n            profitbricks.stop_server(datacenter_id, server_id)\n\n        return True\n    except Exception as e:\n        module.fail_json(msg=\"failed to start or stop the virtual machine %s at %s: %s\" % (server_id, datacenter_id, str(e)))\n\n\ndef _create_datacenter(module, profitbricks):\n    datacenter = module.params.get('datacenter')\n    location = module.params.get('location')\n    wait_timeout = module.params.get('wait_timeout')\n\n    i = Datacenter(\n        name=datacenter,\n        location=location\n    )\n\n    try:\n        datacenter_response = profitbricks.create_datacenter(datacenter=i)\n\n        _wait_for_completion(profitbricks, datacenter_response,\n                             wait_timeout, \"_create_datacenter\")\n\n        return datacenter_response\n    except Exception as e:\n        module.fail_json(msg=\"failed to create the new server(s): %s\" % str(e))\n\n\ndef create_virtual_machine(module, profitbricks):\n    \"\"\"\n    Create new virtual machine\n\n    module : AnsibleModule object\n    profitbricks: authenticated profitbricks object\n\n    Returns:\n        True if a new virtual machine was created, false otherwise\n    \"\"\"\n    datacenter = module.params.get('datacenter')\n    name = module.params.get('name')\n    auto_increment = module.params.get('auto_increment')\n    count = module.params.get('count')\n    lan = module.params.get('lan')\n    wait_timeout = module.params.get('wait_timeout')\n    failed = True\n    datacenter_found = False\n\n    virtual_machines = []\n    virtual_machine_ids = []\n\n    # Locate UUID for datacenter if referenced by name.\n    datacenter_list = profitbricks.list_datacenters()\n    datacenter_id = _get_datacenter_id(datacenter_list, datacenter)\n    if datacenter_id:\n        datacenter_found = True\n\n    if not datacenter_found:\n        datacenter_response = _create_datacenter(module, profitbricks)\n        datacenter_id = datacenter_response['id']\n\n        _wait_for_completion(profitbricks, datacenter_response,\n                             wait_timeout, \"create_virtual_machine\")\n\n    if auto_increment:\n        numbers = set()\n        count_offset = 1\n\n        try:\n            name % 0\n        except TypeError as e:\n            if e.message.startswith('not all'):\n                name = '%s%%d' % name\n            else:\n                module.fail_json(msg=e.message, exception=traceback.format_exc())\n\n        number_range = xrange(count_offset, count_offset + count + len(numbers))\n        available_numbers = list(set(number_range).difference(numbers))\n        names = []\n        numbers_to_use = available_numbers[:count]\n        for number in numbers_to_use:\n            names.append(name % number)\n    else:\n        names = [name]\n\n    # Prefetch a list of servers for later comparison.\n    server_list = profitbricks.list_servers(datacenter_id)\n    for name in names:\n        # Skip server creation if the server already exists.\n        if _get_server_id(server_list, name):\n            continue\n\n        create_response = _create_machine(module, profitbricks, str(datacenter_id), name)\n        nics = profitbricks.list_nics(datacenter_id, create_response['id'])\n        for n in nics['items']:\n            if lan == n['properties']['lan']:\n                create_response.update({'public_ip': n['properties']['ips'][0]})\n\n        virtual_machines.append(create_response)\n\n    failed = False\n\n    results = {\n        'failed': failed,\n        'machines': virtual_machines,\n        'action': 'create',\n        'instance_ids': {\n            'instances': [i['id'] for i in virtual_machines],\n        }\n    }\n\n    return results\n\n\ndef remove_virtual_machine(module, profitbricks):\n    \"\"\"\n    Removes a virtual machine.\n\n    This will remove the virtual machine along with the bootVolume.\n\n    module : AnsibleModule object\n    profitbricks: authenticated profitbricks object.\n\n    Not yet supported: handle deletion of attached data disks.\n\n    Returns:\n        True if a new virtual server was deleted, false otherwise\n    \"\"\"\n    datacenter = module.params.get('datacenter')\n    instance_ids = module.params.get('instance_ids')\n    remove_boot_volume = module.params.get('remove_boot_volume')\n    changed = False\n\n    if not isinstance(module.params.get('instance_ids'), list) or len(module.params.get('instance_ids')) < 1:\n        module.fail_json(msg='instance_ids should be a list of virtual machine ids or names, aborting')\n\n    # Locate UUID for datacenter if referenced by name.\n    datacenter_list = profitbricks.list_datacenters()\n    datacenter_id = _get_datacenter_id(datacenter_list, datacenter)\n    if not datacenter_id:\n        module.fail_json(msg='Virtual data center \\'%s\\' not found.' % str(datacenter))\n\n    # Prefetch server list for later comparison.\n    server_list = profitbricks.list_servers(datacenter_id)\n    for instance in instance_ids:\n        # Locate UUID for server if referenced by name.\n        server_id = _get_server_id(server_list, instance)\n        if server_id:\n            # Remove the server's boot volume\n            if remove_boot_volume:\n                _remove_boot_volume(module, profitbricks, datacenter_id, server_id)\n\n            # Remove the server\n            try:\n                server_response = profitbricks.delete_server(datacenter_id, server_id)\n            except Exception as e:\n                module.fail_json(msg=\"failed to terminate the virtual server: %s\" % to_native(e), exception=traceback.format_exc())\n            else:\n                changed = True\n\n    return changed\n\n\ndef _remove_boot_volume(module, profitbricks, datacenter_id, server_id):\n    \"\"\"\n    Remove the boot volume from the server\n    \"\"\"\n    try:\n        server = profitbricks.get_server(datacenter_id, server_id)\n        volume_id = server['properties']['bootVolume']['id']\n        volume_response = profitbricks.delete_volume(datacenter_id, volume_id)\n    except Exception as e:\n        module.fail_json(msg=\"failed to remove the server's boot volume: %s\" % to_native(e), exception=traceback.format_exc())\n\n\ndef startstop_machine(module, profitbricks, state):\n    \"\"\"\n    Starts or Stops a virtual machine.\n\n    module : AnsibleModule object\n    profitbricks: authenticated profitbricks object.\n\n    Returns:\n        True when the servers process the action successfully, false otherwise.\n    \"\"\"\n    if not isinstance(module.params.get('instance_ids'), list) or len(module.params.get('instance_ids')) < 1:\n        module.fail_json(msg='instance_ids should be a list of virtual machine ids or names, aborting')\n\n    wait = module.params.get('wait')\n    wait_timeout = module.params.get('wait_timeout')\n    changed = False\n\n    datacenter = module.params.get('datacenter')\n    instance_ids = module.params.get('instance_ids')\n\n    # Locate UUID for datacenter if referenced by name.\n    datacenter_list = profitbricks.list_datacenters()\n    datacenter_id = _get_datacenter_id(datacenter_list, datacenter)\n    if not datacenter_id:\n        module.fail_json(msg='Virtual data center \\'%s\\' not found.' % str(datacenter))\n\n    # Prefetch server list for later comparison.\n    server_list = profitbricks.list_servers(datacenter_id)\n    for instance in instance_ids:\n        # Locate UUID of server if referenced by name.\n        server_id = _get_server_id(server_list, instance)\n        if server_id:\n            _startstop_machine(module, profitbricks, datacenter_id, server_id)\n            changed = True\n\n    if wait:\n        wait_timeout = time.time() + wait_timeout\n        while wait_timeout > time.time():\n            matched_instances = []\n            for res in profitbricks.list_servers(datacenter_id)['items']:\n                if state == 'running':\n                    if res['properties']['vmState'].lower() == state:\n                        matched_instances.append(res)\n                elif state == 'stopped':\n                    if res['properties']['vmState'].lower() == 'shutoff':\n                        matched_instances.append(res)\n\n            if len(matched_instances) < len(instance_ids):\n                time.sleep(5)\n            else:\n                break\n\n        if wait_timeout <= time.time():\n            # waiting took too long\n            module.fail_json(msg=\"wait for virtual machine state timeout on %s\" % time.asctime())\n\n    return (changed)\n\n\ndef _get_datacenter_id(datacenters, identity):\n    \"\"\"\n    Fetch and return datacenter UUID by datacenter name if found.\n    \"\"\"\n    for datacenter in datacenters['items']:\n        if identity in (datacenter['properties']['name'], datacenter['id']):\n            return datacenter['id']\n    return None\n\n\ndef _get_server_id(servers, identity):\n    \"\"\"\n    Fetch and return server UUID by server name if found.\n    \"\"\"\n    for server in servers['items']:\n        if identity in (server['properties']['name'], server['id']):\n            return server['id']\n    return None\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            datacenter=dict(),\n            name=dict(),\n            image=dict(),\n            cores=dict(type='int', default=2),\n            ram=dict(type='int', default=2048),\n            cpu_family=dict(choices=['AMD_OPTERON', 'INTEL_XEON'],\n                            default='AMD_OPTERON'),\n            volume_size=dict(type='int', default=10),\n            disk_type=dict(choices=['HDD', 'SSD'], default='HDD'),\n            image_password=dict(default=None, no_log=True),\n            ssh_keys=dict(type='list', default=[]),\n            bus=dict(choices=['VIRTIO', 'IDE'], default='VIRTIO'),\n            lan=dict(type='int', default=1),\n            count=dict(type='int', default=1),\n            auto_increment=dict(type='bool', default=True),\n            instance_ids=dict(type='list', default=[]),\n            subscription_user=dict(),\n            subscription_password=dict(no_log=True),\n            location=dict(choices=LOCATIONS, default='us/las'),\n            assign_public_ip=dict(type='bool', default=False),\n            wait=dict(type='bool', default=True),\n            wait_timeout=dict(type='int', default=600),\n            remove_boot_volume=dict(type='bool', default=True),\n            state=dict(default='present'),\n        )\n    )\n\n    if not HAS_PB_SDK:\n        module.fail_json(msg='profitbricks required for this module')\n\n    subscription_user = module.params.get('subscription_user')\n    subscription_password = module.params.get('subscription_password')\n\n    profitbricks = ProfitBricksService(\n        username=subscription_user,\n        password=subscription_password)\n\n    state = module.params.get('state')\n\n    if state == 'absent':\n        if not module.params.get('datacenter'):\n            module.fail_json(msg='datacenter parameter is required ' +\n                             'for running or stopping machines.')\n\n        try:\n            (changed) = remove_virtual_machine(module, profitbricks)\n            module.exit_json(changed=changed)\n        except Exception as e:\n            module.fail_json(msg='failed to set instance state: %s' % to_native(e), exception=traceback.format_exc())\n\n    elif state in ('running', 'stopped'):\n        if not module.params.get('datacenter'):\n            module.fail_json(msg='datacenter parameter is required for ' +\n                             'running or stopping machines.')\n        try:\n            (changed) = startstop_machine(module, profitbricks, state)\n            module.exit_json(changed=changed)\n        except Exception as e:\n            module.fail_json(msg='failed to set instance state: %s' % to_native(e), exception=traceback.format_exc())\n\n    elif state == 'present':\n        if not module.params.get('name'):\n            module.fail_json(msg='name parameter is required for new instance')\n        if not module.params.get('image'):\n            module.fail_json(msg='image parameter is required for new instance')\n        if not module.params.get('subscription_user'):\n            module.fail_json(msg='subscription_user parameter is ' +\n                             'required for new instance')\n        if not module.params.get('subscription_password'):\n            module.fail_json(msg='subscription_password parameter is ' +\n                             'required for new instance')\n\n        try:\n            (machine_dict_array) = create_virtual_machine(module, profitbricks)\n            module.exit_json(**machine_dict_array)\n        except Exception as e:\n            module.fail_json(msg='failed to set instance state: %s' % to_native(e), exception=traceback.format_exc())\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "profitbricks.py", "id": "42e78a082415a08f8fe29b9b9287a7e5", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/cloud/profitbricks/profitbricks.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}