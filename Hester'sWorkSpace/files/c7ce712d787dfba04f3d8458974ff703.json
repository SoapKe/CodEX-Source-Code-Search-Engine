{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\n\nfrom odoo import fields, models, api, _\nfrom odoo.addons import decimal_precision as dp\nfrom odoo.exceptions import UserError\n\n\nclass AccountVoucher(models.Model):\n    _name = 'account.voucher'\n    _description = 'Accounting Voucher'\n    _inherit = ['mail.thread']\n    _order = \"date desc, id desc\"\n\n    @api.model\n    def _default_journal(self):\n        voucher_type = self._context.get('voucher_type', 'sale')\n        company_id = self._context.get('company_id', self.env.user.company_id.id)\n        domain = [\n            ('type', '=', voucher_type),\n            ('company_id', '=', company_id),\n        ]\n        return self.env['account.journal'].search(domain, limit=1)\n\n    voucher_type = fields.Selection([\n        ('sale', 'Sale'),\n        ('purchase', 'Purchase')\n        ], string='Type', readonly=True, states={'draft': [('readonly', False)]}, oldname=\"type\")\n    name = fields.Char('Payment Reference',\n        readonly=True, states={'draft': [('readonly', False)]}, default='')\n    date = fields.Date(\"Bill Date\", readonly=True,\n        index=True, states={'draft': [('readonly', False)]},\n        copy=False, default=fields.Date.context_today)\n    account_date = fields.Date(\"Accounting Date\",\n        readonly=True, index=True, states={'draft': [('readonly', False)]},\n        help=\"Effective date for accounting entries\", copy=False, default=fields.Date.context_today)\n    journal_id = fields.Many2one('account.journal', 'Journal',\n        required=True, readonly=True, states={'draft': [('readonly', False)]}, default=_default_journal)\n    payment_journal_id = fields.Many2one('account.journal', string='Payment Method', readonly=True, store=False,\n        states={'draft': [('readonly', False)]}, domain=\"[('type', 'in', ['cash', 'bank'])]\",\n        compute='_compute_payment_journal_id', inverse='_inverse_payment_journal_id')\n    account_id = fields.Many2one('account.account', 'Account',\n        required=True, readonly=True, states={'draft': [('readonly', False)]},\n        domain=\"[('deprecated', '=', False), ('internal_type','=', (pay_now == 'pay_now' and 'liquidity' or voucher_type == 'purchase' and 'payable' or 'receivable'))]\")\n    line_ids = fields.One2many('account.voucher.line', 'voucher_id', 'Voucher Lines',\n        readonly=True, copy=True,\n        states={'draft': [('readonly', False)]})\n    narration = fields.Text('Notes', readonly=True, states={'draft': [('readonly', False)]})\n    currency_id = fields.Many2one('res.currency', compute='_get_journal_currency',\n        string='Currency', readonly=True, required=True, default=lambda self: self._get_currency())\n    company_id = fields.Many2one('res.company', 'Company',\n        required=True, readonly=True, states={'draft': [('readonly', False)]},\n        related='journal_id.company_id', default=lambda self: self._get_company())\n    state = fields.Selection([\n        ('draft', 'Draft'),\n        ('cancel', 'Cancelled'),\n        ('proforma', 'Pro-forma'),\n        ('posted', 'Posted')\n        ], 'Status', readonly=True, track_visibility='onchange', copy=False, default='draft',\n        help=\" * The 'Draft' status is used when a user is encoding a new and unconfirmed Voucher.\\n\"\n             \" * The 'Pro-forma' status is used when the voucher does not have a voucher number.\\n\"\n             \" * The 'Posted' status is used when user create voucher,a voucher number is generated and voucher entries are created in account.\\n\"\n             \" * The 'Cancelled' status is used when user cancel voucher.\")\n    reference = fields.Char('Bill Reference', readonly=True, states={'draft': [('readonly', False)]},\n                                 help=\"The partner reference of this document.\", copy=False)\n    amount = fields.Monetary(string='Total', store=True, readonly=True, compute='_compute_total')\n    tax_amount = fields.Monetary(readonly=True, store=True, compute='_compute_total')\n    tax_correction = fields.Monetary(readonly=True, states={'draft': [('readonly', False)]},\n        help='In case we have a rounding problem in the tax, use this field to correct it')\n    number = fields.Char(readonly=True, copy=False)\n    move_id = fields.Many2one('account.move', 'Journal Entry', copy=False)\n    partner_id = fields.Many2one('res.partner', 'Partner', change_default=1, readonly=True, states={'draft': [('readonly', False)]})\n    paid = fields.Boolean(compute='_check_paid', help=\"The Voucher has been totally paid.\")\n    pay_now = fields.Selection([\n            ('pay_now', 'Pay Directly'),\n            ('pay_later', 'Pay Later'),\n        ], 'Payment', index=True, readonly=True, states={'draft': [('readonly', False)]}, default='pay_later')\n    date_due = fields.Date('Due Date', readonly=True, index=True, states={'draft': [('readonly', False)]})\n\n    @api.one\n    @api.depends('move_id.line_ids.reconciled', 'move_id.line_ids.account_id.internal_type')\n    def _check_paid(self):\n        self.paid = any([((line.account_id.internal_type, 'in', ('receivable', 'payable')) and line.reconciled) for line in self.move_id.line_ids])\n\n    @api.model\n    def _get_currency(self):\n        journal = self.env['account.journal'].browse(self.env.context.get('default_journal_id', False))\n        if journal.currency_id:\n            return journal.currency_id.id\n        return self.env.user.company_id.currency_id.id\n\n    @api.model\n    def _get_company(self):\n        return self._context.get('company_id', self.env.user.company_id.id)\n\n    @api.multi\n    @api.depends('name', 'number')\n    def name_get(self):\n        return [(r.id, (r.number or _('Voucher'))) for r in self]\n\n    @api.one\n    @api.depends('journal_id', 'company_id')\n    def _get_journal_currency(self):\n        self.currency_id = self.journal_id.currency_id.id or self.company_id.currency_id.id\n\n    @api.depends('company_id', 'pay_now', 'account_id')\n    def _compute_payment_journal_id(self):\n        for voucher in self:\n            if voucher.pay_now != 'pay_now':\n                continue\n            domain = [\n                ('type', 'in', ('bank', 'cash')),\n                ('company_id', '=', voucher.company_id.id),\n            ]\n            if voucher.account_id and voucher.account_id.internal_type == 'liquidity':\n                field = 'default_debit_account_id' if voucher.voucher_type == 'sale' else 'default_credit_account_id'\n                domain.append((field, '=', voucher.account_id.id))\n            voucher.payment_journal_id = self.env['account.journal'].search(domain, limit=1)\n\n    def _inverse_payment_journal_id(self):\n        for voucher in self:\n            if voucher.pay_now != 'pay_now':\n                continue\n            if voucher.voucher_type == 'sale':\n                voucher.account_id = voucher.payment_journal_id.default_debit_account_id\n            else:\n                voucher.account_id = voucher.payment_journal_id.default_credit_account_id\n\n    @api.multi\n    @api.depends('tax_correction', 'line_ids.price_subtotal')\n    def _compute_total(self):\n        for voucher in self:\n            total = 0\n            tax_amount = 0\n            for line in voucher.line_ids:\n                tax_info = line.tax_ids.compute_all(line.price_unit, voucher.currency_id, line.quantity, line.product_id, voucher.partner_id)\n                total += tax_info.get('total_included', 0.0)\n                tax_amount += sum([t.get('amount',0.0) for t in tax_info.get('taxes', False)]) \n            voucher.amount = total + voucher.tax_correction\n            voucher.tax_amount = tax_amount\n\n    @api.onchange('date')\n    def onchange_date(self):\n        self.account_date = self.date\n\n    @api.onchange('partner_id', 'pay_now')\n    def onchange_partner_id(self):\n        if self.pay_now != 'pay_now':\n            if self.partner_id:\n                self.account_id = self.partner_id.property_account_receivable_id \\\n                    if self.voucher_type == 'sale' else self.partner_id.property_account_payable_id\n            else:\n                account_type = self.voucher_type == 'purchase' and 'payable' or 'receivable'\n                domain = [('deprecated', '=', False), ('internal_type', '=', account_type)]\n\n                self.account_id = self.env['account.account'].search(domain, limit=1)\n\n    @api.multi\n    def proforma_voucher(self):\n        self.action_move_line_create()\n\n    @api.multi\n    def action_cancel_draft(self):\n        self.write({'state': 'draft'})\n\n    @api.multi\n    def cancel_voucher(self):\n        for voucher in self:\n            voucher.move_id.button_cancel()\n            voucher.move_id.unlink()\n        self.write({'state': 'cancel', 'move_id': False})\n\n    @api.multi\n    def unlink(self):\n        for voucher in self:\n            if voucher.state not in ('draft', 'cancel'):\n                raise UserError(_('Cannot delete voucher(s) which are already opened or paid.'))\n        return super(AccountVoucher, self).unlink()\n\n    @api.multi\n    def first_move_line_get(self, move_id, company_currency, current_currency):\n        debit = credit = 0.0\n        if self.voucher_type == 'purchase':\n            credit = self._convert_amount(self.amount)\n        elif self.voucher_type == 'sale':\n            debit = self._convert_amount(self.amount)\n        if debit < 0.0: debit = 0.0\n        if credit < 0.0: credit = 0.0\n        sign = debit - credit < 0 and -1 or 1\n        \n        move_line = {\n                'name': self.name or '/',\n                'debit': debit,\n                'credit': credit,\n                'account_id': self.account_id.id,\n                'move_id': move_id,\n                'journal_id': self.journal_id.id,\n                'partner_id': self.partner_id.commercial_partner_id.id,\n                'currency_id': company_currency != current_currency and current_currency or False,\n                'amount_currency': (sign * abs(self.amount)  \n                    if company_currency != current_currency else 0.0),\n                'date': self.account_date,\n                'date_maturity': self.date_due,\n                'payment_id': self._context.get('payment_id'),\n            }\n        return move_line\n\n    @api.multi\n    def account_move_get(self):\n        if self.number:\n            name = self.number\n        elif self.journal_id.sequence_id:\n            if not self.journal_id.sequence_id.active:\n                raise UserError(_('Please activate the sequence of selected journal !'))\n            name = self.journal_id.sequence_id.with_context(ir_sequence_date=self.date).next_by_id()\n        else:\n            raise UserError(_('Please define a sequence on the journal.'))\n\n        move = {\n            'name': name,\n            'journal_id': self.journal_id.id,\n            'narration': self.narration,\n            'date': self.account_date,\n            'ref': self.reference,\n        }\n        return move\n\n    @api.multi\n    def _convert_amount(self, amount):\n        '''\n        This function convert the amount given in company currency. It takes either the rate in the voucher (if the\n        payment_rate_currency_id is relevant) either the rate encoded in the system.\n        :param amount: float. The amount to convert\n        :param voucher: id of the voucher on which we want the conversion\n        :param context: to context to use for the conversion. It may contain the key 'date' set to the voucher date\n            field in order to select the good rate to use.\n        :return: the amount in the currency of the voucher's company\n        :rtype: float\n        '''\n        for voucher in self:\n            return voucher.currency_id.compute(amount, voucher.company_id.currency_id)\n\n    @api.multi\n    def voucher_pay_now_payment_create(self):\n        if self.voucher_type == 'sale':\n            payment_methods = self.journal_id.inbound_payment_method_ids\n            payment_type = 'inbound'\n            partner_type = 'customer'\n            sequence_code = 'account.payment.customer.invoice'\n        else:\n            payment_methods = self.journal_id.outbound_payment_method_ids\n            payment_type = 'outbound'\n            partner_type = 'supplier'\n            sequence_code = 'account.payment.supplier.invoice'\n        name = self.env['ir.sequence'].with_context(ir_sequence_date=self.date).next_by_code(sequence_code)\n        return {\n            'name': name,\n            'payment_type': payment_type,\n            'payment_method_id': payment_methods and payment_methods[0].id or False,\n            'partner_type': partner_type,\n            'partner_id': self.partner_id.commercial_partner_id.id,\n            'amount': self.amount,\n            'currency_id': self.currency_id.id,\n            'payment_date': self.date,\n            'journal_id': self.payment_journal_id.id,\n            'company_id': self.company_id.id,\n            'communication': self.name,\n            'state': 'reconciled',\n        }\n\n    @api.multi\n    def voucher_move_line_create(self, line_total, move_id, company_currency, current_currency):\n        '''\n        Create one account move line, on the given account move, per voucher line where amount is not 0.0.\n        It returns Tuple with tot_line what is total of difference between debit and credit and\n        a list of lists with ids to be reconciled with this format (total_deb_cred,list_of_lists).\n\n        :param voucher_id: Voucher id what we are working with\n        :param line_total: Amount of the first line, which correspond to the amount we should totally split among all voucher lines.\n        :param move_id: Account move wher those lines will be joined.\n        :param company_currency: id of currency of the company to which the voucher belong\n        :param current_currency: id of currency of the voucher\n        :return: Tuple build as (remaining amount not allocated on voucher lines, list of account_move_line created in this method)\n        :rtype: tuple(float, list of int)\n        '''\n        for line in self.line_ids:\n            \n            if not line.price_subtotal:\n                continue\n            \n            # this calls res_curreny.compute() with the right context,\n            \n            amount = self._convert_amount(line.price_unit*line.quantity)\n            move_line = {\n                'journal_id': self.journal_id.id,\n                'name': line.name or '/',\n                'account_id': line.account_id.id,\n                'move_id': move_id,\n                'partner_id': self.partner_id.commercial_partner_id.id,\n                'analytic_account_id': line.account_analytic_id and line.account_analytic_id.id or False,\n                'quantity': 1,\n                'credit': abs(amount) if self.voucher_type == 'sale' else 0.0,\n                'debit': abs(amount) if self.voucher_type == 'purchase' else 0.0,\n                'date': self.account_date,\n                'tax_ids': [(4,t.id) for t in line.tax_ids],\n                'amount_currency': line.price_subtotal if current_currency != company_currency else 0.0,\n                'currency_id': company_currency != current_currency and current_currency or False,\n                'payment_id': self._context.get('payment_id'),\n            }\n            self.env['account.move.line'].with_context(apply_taxes=True).create(move_line)\n        return line_total\n\n    @api.multi\n    def action_move_line_create(self):\n        '''\n        Confirm the vouchers given in ids and create the journal entries for each of them\n        '''\n        for voucher in self:\n            local_context = dict(self._context, force_company=voucher.journal_id.company_id.id)\n            if voucher.move_id:\n                continue\n            company_currency = voucher.journal_id.company_id.currency_id.id\n            current_currency = voucher.currency_id.id or company_currency\n            \n            \n            ctx = local_context.copy()\n            ctx['date'] = voucher.account_date\n            ctx['check_move_validity'] = False\n            \n            if self.pay_now == 'pay_now' and self.amount > 0:\n                ctx['payment_id'] = self.env['account.payment'].create(self.voucher_pay_now_payment_create()).id\n            \n            move = self.env['account.move'].create(voucher.account_move_get())\n            \n            \n            move_line = self.env['account.move.line'].with_context(ctx).create(voucher.with_context(ctx).first_move_line_get(move.id, company_currency, current_currency))\n            line_total = move_line.debit - move_line.credit\n            if voucher.voucher_type == 'sale':\n                line_total = line_total - voucher._convert_amount(voucher.tax_amount)\n            elif voucher.voucher_type == 'purchase':\n                line_total = line_total + voucher._convert_amount(voucher.tax_amount)\n            \n            line_total = voucher.with_context(ctx).voucher_move_line_create(line_total, move.id, company_currency, current_currency)\n\n            \n            if voucher.tax_correction != 0.0:\n                tax_move_line = self.env['account.move.line'].search([('move_id', '=', move.id), ('tax_line_id', '!=', False)], limit=1)\n                if len(tax_move_line):\n                    tax_move_line.write({'debit': tax_move_line.debit + voucher.tax_correction if tax_move_line.debit > 0 else 0,\n                        'credit': tax_move_line.credit + voucher.tax_correction if tax_move_line.credit > 0 else 0})\n\n            \n            voucher.write({\n                'move_id': move.id,\n                'state': 'posted',\n                'number': move.name\n            })\n            move.post()\n        return True\n\n    @api.multi\n    def _track_subtype(self, init_values):\n        if 'state' in init_values:\n            return 'account_voucher.mt_voucher_state_change'\n        return super(AccountVoucher, self)._track_subtype(init_values)\n\n\nclass AccountVoucherLine(models.Model):\n    _name = 'account.voucher.line'\n    _description = 'Voucher Lines'\n\n    name = fields.Text(string='Description', required=True)\n    sequence = fields.Integer(default=10,\n        help=\"Gives the sequence of this line when displaying the voucher.\")\n    voucher_id = fields.Many2one('account.voucher', 'Voucher', required=1, ondelete='cascade')\n    product_id = fields.Many2one('product.product', string='Product',\n        ondelete='set null', index=True)\n    account_id = fields.Many2one('account.account', string='Account',\n        required=True, domain=[('deprecated', '=', False)],\n        help=\"The income or expense account related to the selected product.\")\n    price_unit = fields.Float(string='Unit Price', required=True, digits=dp.get_precision('Product Price'), oldname='amount')\n    price_subtotal = fields.Monetary(string='Amount',\n        store=True, readonly=True, compute='_compute_subtotal')\n    quantity = fields.Float(digits=dp.get_precision('Product Unit of Measure'),\n        required=True, default=1)\n    account_analytic_id = fields.Many2one('account.analytic.account', 'Analytic Account')\n    company_id = fields.Many2one('res.company', related='voucher_id.company_id', string='Company', store=True, readonly=True)\n    tax_ids = fields.Many2many('account.tax', string='Tax', help=\"Only for tax excluded from price\")\n    currency_id = fields.Many2one('res.currency', related='voucher_id.currency_id')\n\n    @api.one\n    @api.depends('price_unit', 'tax_ids', 'quantity', 'product_id', 'voucher_id.currency_id')\n    def _compute_subtotal(self):\n        self.price_subtotal = self.quantity * self.price_unit\n        if self.tax_ids:\n            taxes = self.tax_ids.compute_all(self.price_unit, self.voucher_id.currency_id, self.quantity, product=self.product_id, partner=self.voucher_id.partner_id)\n            self.price_subtotal = taxes['total_excluded']\n\n    @api.onchange('product_id', 'voucher_id', 'price_unit', 'company_id')\n    def _onchange_line_details(self):\n        if not self.voucher_id or not self.product_id or not self.voucher_id.partner_id:\n            return\n        onchange_res = self.product_id_change(\n            self.product_id.id,\n            self.voucher_id.partner_id.id,\n            self.price_unit,\n            self.company_id.id,\n            self.voucher_id.currency_id.id,\n            self.voucher_id.voucher_type)\n        for fname, fvalue in onchange_res['value'].items():\n            setattr(self, fname, fvalue)\n\n    def _get_account(self, product, fpos, type):\n        accounts = product.product_tmpl_id.get_product_accounts(fpos)\n        if type == 'sale':\n            return accounts['income']\n        return accounts['expense']\n\n    @api.multi\n    def product_id_change(self, product_id, partner_id=False, price_unit=False, company_id=None, currency_id=None, type=None):\n        \n        context = self._context\n        company_id = company_id if company_id is not None else context.get('company_id', False)\n        company = self.env['res.company'].browse(company_id)\n        currency = self.env['res.currency'].browse(currency_id)\n        if not partner_id:\n            raise UserError(_(\"You must first select a partner!\"))\n        part = self.env['res.partner'].browse(partner_id)\n        if part.lang:\n            self = self.with_context(lang=part.lang)\n\n        product = self.env['product.product'].browse(product_id)\n        fpos = part.property_account_position_id\n        account = self._get_account(product, fpos, type)\n        values = {\n            'name': product.partner_ref,\n            'account_id': account.id,\n        }\n\n        if type == 'purchase':\n            values['price_unit'] = price_unit or product.standard_price\n            taxes = product.supplier_taxes_id or account.tax_ids\n            if product.description_purchase:\n                values['name'] += '\\n' + product.description_purchase\n        else:\n            values['price_unit'] = price_unit or product.lst_price\n            taxes = product.taxes_id or account.tax_ids\n            if product.description_sale:\n                values['name'] += '\\n' + product.description_sale\n\n        values['tax_ids'] = taxes.ids\n\n        if company and currency:\n            if company.currency_id != currency:\n                if type == 'purchase':\n                    values['price_unit'] = price_unit or product.standard_price\n                values['price_unit'] = values['price_unit'] * currency.rate\n\n        return {'value': values, 'domain': {}}\n", "comments": "            this function convert amount given company currency  it takes either rate voucher (if         payment rate currency id relevant) either rate encoded system           param amount  float  the amount convert          param voucher  id voucher want conversion          param context  context use conversion  it may contain key  date  set voucher date             field order select good rate use           return  amount currency voucher company          rtype  float                     voucher self              return voucher currency id compute(amount  voucher company id currency id)       api multi     def voucher pay payment create(self)          self voucher type     sale               payment methods   self journal id inbound payment method ids             payment type    inbound              partner type    customer              sequence code    account payment customer invoice          else              payment methods   self journal id outbound payment method ids             payment type    outbound              partner type    supplier              sequence code    account payment supplier invoice          name   self env  ir sequence   context(ir sequence date self date) next code(sequence code)         return                name   name               payment type   payment type               payment method id   payment methods payment methods 0  id false               partner type   partner type               partner id   self partner id commercial partner id id               amount   self amount               currency id   self currency id id               payment date   self date               journal id   self payment journal id id               company id   self company id id               communication   self name               state    reconciled                   api multi     def voucher move line create(self  line total  move id  company currency  current currency)                      create one account move line  given account move  per voucher line amount 0 0          it returns tuple tot line total difference debit credit         list lists ids reconciled format (total deb cred list lists)            param voucher id  voucher id working          param line total  amount first line  correspond amount totally split among voucher lines           param move id  account move wher lines joined           param company currency  id currency company voucher belong          param current currency  id currency voucher          return  tuple build (remaining amount allocated voucher lines  list account move line created method)          rtype  tuple(float  list int)                     line self line ids               create one move line per voucher line amount 0 0             line price subtotal                  continue               convert amount set voucher line currency voucher company               calls res curreny compute() right context                take either rate voucher relevant use default behaviour             amount   self  convert amount(line price unit line quantity)             move line                      journal id   self journal id id                   name   line name                       account id   line account id id                   move id   move id                   partner id   self partner id commercial partner id id                   analytic account id   line account analytic id line account analytic id id false                   quantity   1                   credit   abs(amount) self voucher type     sale  else 0 0                   debit   abs(amount) self voucher type     purchase  else 0 0                   date   self account date                   tax ids    (4 id) line tax ids                    amount currency   line price subtotal current currency    company currency else 0 0                   currency id   company currency    current currency current currency false                   payment id   self  context get( payment id )                            self env  account move line   context(apply taxes true) create(move line)         return line total       api multi     def action move line create(self)                      confirm vouchers given ids create journal entries                    coding  utf 8        part odoo  see license file full copyright licensing details    set first line voucher    amount   0 refunds   create one move line per voucher line amount 0 0    convert amount set voucher line currency voucher company    calls res curreny compute() right context     take either rate voucher relevant use default behaviour    select context use accordingly multicurrency case    but operations made  convert amount  always need give date context    create payment allow reconciliation pay    pay      create account move record     get name account move created    create first line voucher    create one move line per voucher line amount 0 0    add tax correction move line tax correction specified    we post voucher     tde note  mix old new onchange badly written 9  multi use record set ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\n\nfrom odoo import fields, models, api, _\nfrom odoo.addons import decimal_precision as dp\nfrom odoo.exceptions import UserError\n\n\nclass AccountVoucher(models.Model):\n    _name = 'account.voucher'\n    _description = 'Accounting Voucher'\n    _inherit = ['mail.thread']\n    _order = \"date desc, id desc\"\n\n    @api.model\n    def _default_journal(self):\n        voucher_type = self._context.get('voucher_type', 'sale')\n        company_id = self._context.get('company_id', self.env.user.company_id.id)\n        domain = [\n            ('type', '=', voucher_type),\n            ('company_id', '=', company_id),\n        ]\n        return self.env['account.journal'].search(domain, limit=1)\n\n    voucher_type = fields.Selection([\n        ('sale', 'Sale'),\n        ('purchase', 'Purchase')\n        ], string='Type', readonly=True, states={'draft': [('readonly', False)]}, oldname=\"type\")\n    name = fields.Char('Payment Reference',\n        readonly=True, states={'draft': [('readonly', False)]}, default='')\n    date = fields.Date(\"Bill Date\", readonly=True,\n        index=True, states={'draft': [('readonly', False)]},\n        copy=False, default=fields.Date.context_today)\n    account_date = fields.Date(\"Accounting Date\",\n        readonly=True, index=True, states={'draft': [('readonly', False)]},\n        help=\"Effective date for accounting entries\", copy=False, default=fields.Date.context_today)\n    journal_id = fields.Many2one('account.journal', 'Journal',\n        required=True, readonly=True, states={'draft': [('readonly', False)]}, default=_default_journal)\n    payment_journal_id = fields.Many2one('account.journal', string='Payment Method', readonly=True, store=False,\n        states={'draft': [('readonly', False)]}, domain=\"[('type', 'in', ['cash', 'bank'])]\",\n        compute='_compute_payment_journal_id', inverse='_inverse_payment_journal_id')\n    account_id = fields.Many2one('account.account', 'Account',\n        required=True, readonly=True, states={'draft': [('readonly', False)]},\n        domain=\"[('deprecated', '=', False), ('internal_type','=', (pay_now == 'pay_now' and 'liquidity' or voucher_type == 'purchase' and 'payable' or 'receivable'))]\")\n    line_ids = fields.One2many('account.voucher.line', 'voucher_id', 'Voucher Lines',\n        readonly=True, copy=True,\n        states={'draft': [('readonly', False)]})\n    narration = fields.Text('Notes', readonly=True, states={'draft': [('readonly', False)]})\n    currency_id = fields.Many2one('res.currency', compute='_get_journal_currency',\n        string='Currency', readonly=True, required=True, default=lambda self: self._get_currency())\n    company_id = fields.Many2one('res.company', 'Company',\n        required=True, readonly=True, states={'draft': [('readonly', False)]},\n        related='journal_id.company_id', default=lambda self: self._get_company())\n    state = fields.Selection([\n        ('draft', 'Draft'),\n        ('cancel', 'Cancelled'),\n        ('proforma', 'Pro-forma'),\n        ('posted', 'Posted')\n        ], 'Status', readonly=True, track_visibility='onchange', copy=False, default='draft',\n        help=\" * The 'Draft' status is used when a user is encoding a new and unconfirmed Voucher.\\n\"\n             \" * The 'Pro-forma' status is used when the voucher does not have a voucher number.\\n\"\n             \" * The 'Posted' status is used when user create voucher,a voucher number is generated and voucher entries are created in account.\\n\"\n             \" * The 'Cancelled' status is used when user cancel voucher.\")\n    reference = fields.Char('Bill Reference', readonly=True, states={'draft': [('readonly', False)]},\n                                 help=\"The partner reference of this document.\", copy=False)\n    amount = fields.Monetary(string='Total', store=True, readonly=True, compute='_compute_total')\n    tax_amount = fields.Monetary(readonly=True, store=True, compute='_compute_total')\n    tax_correction = fields.Monetary(readonly=True, states={'draft': [('readonly', False)]},\n        help='In case we have a rounding problem in the tax, use this field to correct it')\n    number = fields.Char(readonly=True, copy=False)\n    move_id = fields.Many2one('account.move', 'Journal Entry', copy=False)\n    partner_id = fields.Many2one('res.partner', 'Partner', change_default=1, readonly=True, states={'draft': [('readonly', False)]})\n    paid = fields.Boolean(compute='_check_paid', help=\"The Voucher has been totally paid.\")\n    pay_now = fields.Selection([\n            ('pay_now', 'Pay Directly'),\n            ('pay_later', 'Pay Later'),\n        ], 'Payment', index=True, readonly=True, states={'draft': [('readonly', False)]}, default='pay_later')\n    date_due = fields.Date('Due Date', readonly=True, index=True, states={'draft': [('readonly', False)]})\n\n    @api.one\n    @api.depends('move_id.line_ids.reconciled', 'move_id.line_ids.account_id.internal_type')\n    def _check_paid(self):\n        self.paid = any([((line.account_id.internal_type, 'in', ('receivable', 'payable')) and line.reconciled) for line in self.move_id.line_ids])\n\n    @api.model\n    def _get_currency(self):\n        journal = self.env['account.journal'].browse(self.env.context.get('default_journal_id', False))\n        if journal.currency_id:\n            return journal.currency_id.id\n        return self.env.user.company_id.currency_id.id\n\n    @api.model\n    def _get_company(self):\n        return self._context.get('company_id', self.env.user.company_id.id)\n\n    @api.multi\n    @api.depends('name', 'number')\n    def name_get(self):\n        return [(r.id, (r.number or _('Voucher'))) for r in self]\n\n    @api.one\n    @api.depends('journal_id', 'company_id')\n    def _get_journal_currency(self):\n        self.currency_id = self.journal_id.currency_id.id or self.company_id.currency_id.id\n\n    @api.depends('company_id', 'pay_now', 'account_id')\n    def _compute_payment_journal_id(self):\n        for voucher in self:\n            if voucher.pay_now != 'pay_now':\n                continue\n            domain = [\n                ('type', 'in', ('bank', 'cash')),\n                ('company_id', '=', voucher.company_id.id),\n            ]\n            if voucher.account_id and voucher.account_id.internal_type == 'liquidity':\n                field = 'default_debit_account_id' if voucher.voucher_type == 'sale' else 'default_credit_account_id'\n                domain.append((field, '=', voucher.account_id.id))\n            voucher.payment_journal_id = self.env['account.journal'].search(domain, limit=1)\n\n    def _inverse_payment_journal_id(self):\n        for voucher in self:\n            if voucher.pay_now != 'pay_now':\n                continue\n            if voucher.voucher_type == 'sale':\n                voucher.account_id = voucher.payment_journal_id.default_debit_account_id\n            else:\n                voucher.account_id = voucher.payment_journal_id.default_credit_account_id\n\n    @api.multi\n    @api.depends('tax_correction', 'line_ids.price_subtotal')\n    def _compute_total(self):\n        for voucher in self:\n            total = 0\n            tax_amount = 0\n            for line in voucher.line_ids:\n                tax_info = line.tax_ids.compute_all(line.price_unit, voucher.currency_id, line.quantity, line.product_id, voucher.partner_id)\n                total += tax_info.get('total_included', 0.0)\n                tax_amount += sum([t.get('amount',0.0) for t in tax_info.get('taxes', False)]) \n            voucher.amount = total + voucher.tax_correction\n            voucher.tax_amount = tax_amount\n\n    @api.onchange('date')\n    def onchange_date(self):\n        self.account_date = self.date\n\n    @api.onchange('partner_id', 'pay_now')\n    def onchange_partner_id(self):\n        if self.pay_now != 'pay_now':\n            if self.partner_id:\n                self.account_id = self.partner_id.property_account_receivable_id \\\n                    if self.voucher_type == 'sale' else self.partner_id.property_account_payable_id\n            else:\n                account_type = self.voucher_type == 'purchase' and 'payable' or 'receivable'\n                domain = [('deprecated', '=', False), ('internal_type', '=', account_type)]\n\n                self.account_id = self.env['account.account'].search(domain, limit=1)\n\n    @api.multi\n    def proforma_voucher(self):\n        self.action_move_line_create()\n\n    @api.multi\n    def action_cancel_draft(self):\n        self.write({'state': 'draft'})\n\n    @api.multi\n    def cancel_voucher(self):\n        for voucher in self:\n            voucher.move_id.button_cancel()\n            voucher.move_id.unlink()\n        self.write({'state': 'cancel', 'move_id': False})\n\n    @api.multi\n    def unlink(self):\n        for voucher in self:\n            if voucher.state not in ('draft', 'cancel'):\n                raise UserError(_('Cannot delete voucher(s) which are already opened or paid.'))\n        return super(AccountVoucher, self).unlink()\n\n    @api.multi\n    def first_move_line_get(self, move_id, company_currency, current_currency):\n        debit = credit = 0.0\n        if self.voucher_type == 'purchase':\n            credit = self._convert_amount(self.amount)\n        elif self.voucher_type == 'sale':\n            debit = self._convert_amount(self.amount)\n        if debit < 0.0: debit = 0.0\n        if credit < 0.0: credit = 0.0\n        sign = debit - credit < 0 and -1 or 1\n        #set the first line of the voucher\n        move_line = {\n                'name': self.name or '/',\n                'debit': debit,\n                'credit': credit,\n                'account_id': self.account_id.id,\n                'move_id': move_id,\n                'journal_id': self.journal_id.id,\n                'partner_id': self.partner_id.commercial_partner_id.id,\n                'currency_id': company_currency != current_currency and current_currency or False,\n                'amount_currency': (sign * abs(self.amount)  # amount < 0 for refunds\n                    if company_currency != current_currency else 0.0),\n                'date': self.account_date,\n                'date_maturity': self.date_due,\n                'payment_id': self._context.get('payment_id'),\n            }\n        return move_line\n\n    @api.multi\n    def account_move_get(self):\n        if self.number:\n            name = self.number\n        elif self.journal_id.sequence_id:\n            if not self.journal_id.sequence_id.active:\n                raise UserError(_('Please activate the sequence of selected journal !'))\n            name = self.journal_id.sequence_id.with_context(ir_sequence_date=self.date).next_by_id()\n        else:\n            raise UserError(_('Please define a sequence on the journal.'))\n\n        move = {\n            'name': name,\n            'journal_id': self.journal_id.id,\n            'narration': self.narration,\n            'date': self.account_date,\n            'ref': self.reference,\n        }\n        return move\n\n    @api.multi\n    def _convert_amount(self, amount):\n        '''\n        This function convert the amount given in company currency. It takes either the rate in the voucher (if the\n        payment_rate_currency_id is relevant) either the rate encoded in the system.\n        :param amount: float. The amount to convert\n        :param voucher: id of the voucher on which we want the conversion\n        :param context: to context to use for the conversion. It may contain the key 'date' set to the voucher date\n            field in order to select the good rate to use.\n        :return: the amount in the currency of the voucher's company\n        :rtype: float\n        '''\n        for voucher in self:\n            return voucher.currency_id.compute(amount, voucher.company_id.currency_id)\n\n    @api.multi\n    def voucher_pay_now_payment_create(self):\n        if self.voucher_type == 'sale':\n            payment_methods = self.journal_id.inbound_payment_method_ids\n            payment_type = 'inbound'\n            partner_type = 'customer'\n            sequence_code = 'account.payment.customer.invoice'\n        else:\n            payment_methods = self.journal_id.outbound_payment_method_ids\n            payment_type = 'outbound'\n            partner_type = 'supplier'\n            sequence_code = 'account.payment.supplier.invoice'\n        name = self.env['ir.sequence'].with_context(ir_sequence_date=self.date).next_by_code(sequence_code)\n        return {\n            'name': name,\n            'payment_type': payment_type,\n            'payment_method_id': payment_methods and payment_methods[0].id or False,\n            'partner_type': partner_type,\n            'partner_id': self.partner_id.commercial_partner_id.id,\n            'amount': self.amount,\n            'currency_id': self.currency_id.id,\n            'payment_date': self.date,\n            'journal_id': self.payment_journal_id.id,\n            'company_id': self.company_id.id,\n            'communication': self.name,\n            'state': 'reconciled',\n        }\n\n    @api.multi\n    def voucher_move_line_create(self, line_total, move_id, company_currency, current_currency):\n        '''\n        Create one account move line, on the given account move, per voucher line where amount is not 0.0.\n        It returns Tuple with tot_line what is total of difference between debit and credit and\n        a list of lists with ids to be reconciled with this format (total_deb_cred,list_of_lists).\n\n        :param voucher_id: Voucher id what we are working with\n        :param line_total: Amount of the first line, which correspond to the amount we should totally split among all voucher lines.\n        :param move_id: Account move wher those lines will be joined.\n        :param company_currency: id of currency of the company to which the voucher belong\n        :param current_currency: id of currency of the voucher\n        :return: Tuple build as (remaining amount not allocated on voucher lines, list of account_move_line created in this method)\n        :rtype: tuple(float, list of int)\n        '''\n        for line in self.line_ids:\n            #create one move line per voucher line where amount is not 0.0\n            if not line.price_subtotal:\n                continue\n            # convert the amount set on the voucher line into the currency of the voucher's company\n            # this calls res_curreny.compute() with the right context,\n            # so that it will take either the rate on the voucher if it is relevant or will use the default behaviour\n            amount = self._convert_amount(line.price_unit*line.quantity)\n            move_line = {\n                'journal_id': self.journal_id.id,\n                'name': line.name or '/',\n                'account_id': line.account_id.id,\n                'move_id': move_id,\n                'partner_id': self.partner_id.commercial_partner_id.id,\n                'analytic_account_id': line.account_analytic_id and line.account_analytic_id.id or False,\n                'quantity': 1,\n                'credit': abs(amount) if self.voucher_type == 'sale' else 0.0,\n                'debit': abs(amount) if self.voucher_type == 'purchase' else 0.0,\n                'date': self.account_date,\n                'tax_ids': [(4,t.id) for t in line.tax_ids],\n                'amount_currency': line.price_subtotal if current_currency != company_currency else 0.0,\n                'currency_id': company_currency != current_currency and current_currency or False,\n                'payment_id': self._context.get('payment_id'),\n            }\n            self.env['account.move.line'].with_context(apply_taxes=True).create(move_line)\n        return line_total\n\n    @api.multi\n    def action_move_line_create(self):\n        '''\n        Confirm the vouchers given in ids and create the journal entries for each of them\n        '''\n        for voucher in self:\n            local_context = dict(self._context, force_company=voucher.journal_id.company_id.id)\n            if voucher.move_id:\n                continue\n            company_currency = voucher.journal_id.company_id.currency_id.id\n            current_currency = voucher.currency_id.id or company_currency\n            # we select the context to use accordingly if it's a multicurrency case or not\n            # But for the operations made by _convert_amount, we always need to give the date in the context\n            ctx = local_context.copy()\n            ctx['date'] = voucher.account_date\n            ctx['check_move_validity'] = False\n            # Create a payment to allow the reconciliation when pay_now = 'pay_now'.\n            if self.pay_now == 'pay_now' and self.amount > 0:\n                ctx['payment_id'] = self.env['account.payment'].create(self.voucher_pay_now_payment_create()).id\n            # Create the account move record.\n            move = self.env['account.move'].create(voucher.account_move_get())\n            # Get the name of the account_move just created\n            # Create the first line of the voucher\n            move_line = self.env['account.move.line'].with_context(ctx).create(voucher.with_context(ctx).first_move_line_get(move.id, company_currency, current_currency))\n            line_total = move_line.debit - move_line.credit\n            if voucher.voucher_type == 'sale':\n                line_total = line_total - voucher._convert_amount(voucher.tax_amount)\n            elif voucher.voucher_type == 'purchase':\n                line_total = line_total + voucher._convert_amount(voucher.tax_amount)\n            # Create one move line per voucher line where amount is not 0.0\n            line_total = voucher.with_context(ctx).voucher_move_line_create(line_total, move.id, company_currency, current_currency)\n\n            # Add tax correction to move line if any tax correction specified\n            if voucher.tax_correction != 0.0:\n                tax_move_line = self.env['account.move.line'].search([('move_id', '=', move.id), ('tax_line_id', '!=', False)], limit=1)\n                if len(tax_move_line):\n                    tax_move_line.write({'debit': tax_move_line.debit + voucher.tax_correction if tax_move_line.debit > 0 else 0,\n                        'credit': tax_move_line.credit + voucher.tax_correction if tax_move_line.credit > 0 else 0})\n\n            # We post the voucher.\n            voucher.write({\n                'move_id': move.id,\n                'state': 'posted',\n                'number': move.name\n            })\n            move.post()\n        return True\n\n    @api.multi\n    def _track_subtype(self, init_values):\n        if 'state' in init_values:\n            return 'account_voucher.mt_voucher_state_change'\n        return super(AccountVoucher, self)._track_subtype(init_values)\n\n\nclass AccountVoucherLine(models.Model):\n    _name = 'account.voucher.line'\n    _description = 'Voucher Lines'\n\n    name = fields.Text(string='Description', required=True)\n    sequence = fields.Integer(default=10,\n        help=\"Gives the sequence of this line when displaying the voucher.\")\n    voucher_id = fields.Many2one('account.voucher', 'Voucher', required=1, ondelete='cascade')\n    product_id = fields.Many2one('product.product', string='Product',\n        ondelete='set null', index=True)\n    account_id = fields.Many2one('account.account', string='Account',\n        required=True, domain=[('deprecated', '=', False)],\n        help=\"The income or expense account related to the selected product.\")\n    price_unit = fields.Float(string='Unit Price', required=True, digits=dp.get_precision('Product Price'), oldname='amount')\n    price_subtotal = fields.Monetary(string='Amount',\n        store=True, readonly=True, compute='_compute_subtotal')\n    quantity = fields.Float(digits=dp.get_precision('Product Unit of Measure'),\n        required=True, default=1)\n    account_analytic_id = fields.Many2one('account.analytic.account', 'Analytic Account')\n    company_id = fields.Many2one('res.company', related='voucher_id.company_id', string='Company', store=True, readonly=True)\n    tax_ids = fields.Many2many('account.tax', string='Tax', help=\"Only for tax excluded from price\")\n    currency_id = fields.Many2one('res.currency', related='voucher_id.currency_id')\n\n    @api.one\n    @api.depends('price_unit', 'tax_ids', 'quantity', 'product_id', 'voucher_id.currency_id')\n    def _compute_subtotal(self):\n        self.price_subtotal = self.quantity * self.price_unit\n        if self.tax_ids:\n            taxes = self.tax_ids.compute_all(self.price_unit, self.voucher_id.currency_id, self.quantity, product=self.product_id, partner=self.voucher_id.partner_id)\n            self.price_subtotal = taxes['total_excluded']\n\n    @api.onchange('product_id', 'voucher_id', 'price_unit', 'company_id')\n    def _onchange_line_details(self):\n        if not self.voucher_id or not self.product_id or not self.voucher_id.partner_id:\n            return\n        onchange_res = self.product_id_change(\n            self.product_id.id,\n            self.voucher_id.partner_id.id,\n            self.price_unit,\n            self.company_id.id,\n            self.voucher_id.currency_id.id,\n            self.voucher_id.voucher_type)\n        for fname, fvalue in onchange_res['value'].items():\n            setattr(self, fname, fvalue)\n\n    def _get_account(self, product, fpos, type):\n        accounts = product.product_tmpl_id.get_product_accounts(fpos)\n        if type == 'sale':\n            return accounts['income']\n        return accounts['expense']\n\n    @api.multi\n    def product_id_change(self, product_id, partner_id=False, price_unit=False, company_id=None, currency_id=None, type=None):\n        # TDE note: mix of old and new onchange badly written in 9, multi but does not use record set\n        context = self._context\n        company_id = company_id if company_id is not None else context.get('company_id', False)\n        company = self.env['res.company'].browse(company_id)\n        currency = self.env['res.currency'].browse(currency_id)\n        if not partner_id:\n            raise UserError(_(\"You must first select a partner!\"))\n        part = self.env['res.partner'].browse(partner_id)\n        if part.lang:\n            self = self.with_context(lang=part.lang)\n\n        product = self.env['product.product'].browse(product_id)\n        fpos = part.property_account_position_id\n        account = self._get_account(product, fpos, type)\n        values = {\n            'name': product.partner_ref,\n            'account_id': account.id,\n        }\n\n        if type == 'purchase':\n            values['price_unit'] = price_unit or product.standard_price\n            taxes = product.supplier_taxes_id or account.tax_ids\n            if product.description_purchase:\n                values['name'] += '\\n' + product.description_purchase\n        else:\n            values['price_unit'] = price_unit or product.lst_price\n            taxes = product.taxes_id or account.tax_ids\n            if product.description_sale:\n                values['name'] += '\\n' + product.description_sale\n\n        values['tax_ids'] = taxes.ids\n\n        if company and currency:\n            if company.currency_id != currency:\n                if type == 'purchase':\n                    values['price_unit'] = price_unit or product.standard_price\n                values['price_unit'] = values['price_unit'] * currency.rate\n\n        return {'value': values, 'domain': {}}\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "account_voucher.py", "id": "c7ce712d787dfba04f3d8458974ff703", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/account_voucher/models/account_voucher.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}