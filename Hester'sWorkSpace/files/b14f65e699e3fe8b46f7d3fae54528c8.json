{"author": "mailpile", "code": "import re\nimport time\n\nfrom mailpile.i18n import gettext as _\nfrom mailpile.i18n import ngettext as _n\nfrom mailpile.commands import Command\nfrom mailpile.mailutils import Email\nfrom mailpile.util import truthy\n\n\n\n\n  SELECT from,to,body=Regards\\,(.*) FROM search=to:bre\n\n\n\nclass dataDigCommand(Command):\n    \n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'datadig', 'datadig', '<terms ...> -- <messages ...>')\n    HTTP_CALLABLE = ('GET', )\n    HTTP_QUERY_VARS = {\n        'track-id': 'tracking ID for event log',\n        'timeout': 'runtime in seconds',\n        'header': 'include header',\n        'no-mid': 'omit metadata-ID column',\n        'term': 'extraction term',\n        'mid': 'metadata-ID'\n    }\n\n    class CommandResult(Command.CommandResult):\n        def as_text(self):\n            if self.result:\n                return '\\n'.join(['\\t'.join([unicode(cell) for cell in row])\n                                  for row in self.result])\n            else:\n                return _(\"Nothing Happened\")\n\n    def _filter(self, idx, e, celldata, filters):\n        if not isinstance(celldata, (list, tuple)):\n            celldata = [celldata]\n        for fltr in filters:\n             FIXME!\n            celldata = celldata\n        return celldata\n\n    def _cell(self, idx, e, cellspec):\n        filters = cellspec.split('||')\n        cspec, lcspec = filters[0], filters[0].lower()\n        lcspec = lcspec.split(':', 1)[0].split('=', 1)[-1]\n\n        if lcspec == 'sender':\n            return self._filter(idx, e, e.get_msg_info(field=idx.MSG_FROM),\n                                filters)\n\n        if lcspec == 'subject':\n            return self._filter(idx, e, e.get_msg_info(field=idx.MSG_SUBJECT),\n                                filters)\n\n        if lcspec in ('from', 'to', 'cc', 'bcc', 'date'):\n            return self._filter(idx, e, e.get_msg()[lcspec], filters)\n\n        if lcspec in ('text', ):\n            rxp = cspec.split(':', 1)[1]\n            if lcspec == 'text':\n                body = e.get_editing_strings()['body']\n                mobj = re.search(rxp, body)\n            if mobj:\n                return self._filter(idx, e, list(mobj.groups()), filters)\n\n        return ['']\n\n    def command(self):\n        session, config, idx = self.session, self.session.config, self._idx()\n\n         Command-line arguments...\n        msgs = list(self.args)\n        timeout = -1\n        tracking_id = None\n        with_header = False\n        without_mid = False\n        columns = []\n        while msgs and msgs[0].lower() != '--':\n            arg = msgs.pop(0)\n            if arg.startswith('--timeout='):\n                timeout = float(arg[10:])\n            elif arg.startswith('--header'):\n                with_header = True\n            elif arg.startswith('--no-mid'):\n                without_mid = True\n            else:\n                columns.append(arg)\n        if msgs and msgs[0].lower() == '--':\n            msgs.pop(0)\n\n         Form arguments...\n        timeout = float(self.data.get('timeout', [timeout])[0])\n        with_header |= truthy(self.data.get('header', [''])[0])\n        without_mid |= truthy(self.data.get('no-mid', [''])[0])\n        tracking_id = self.data.get('track-id', [tracking_id])[0]\n        columns.extend(self.data.get('term', []))\n        msgs.extend(['=%s' % mid.replace('=', '')\n                     for mid in self.data.get('mid', [])])\n\n         Add a header to the CSV if requested\n        if with_header:\n            results = [[col.split('||')[0].split(':', 1)[0].split('=', 1)[0]\n                        for col in columns]]\n            if not without_mid:\n                results[0] = ['MID'] + results[0]\n        else:\n            results = []\n\n        deadline = (time.time() + timeout) if (timeout > 0) else None\n        msg_idxs = self._choose_messages(msgs)\n        progress = []\n        for msg_idx in msg_idxs:\n            e = Email(idx, msg_idx)\n            if self.event and tracking_id:\n                progress.append(msg_idx)\n                self.event.private_data = {\"progress\": len(progress),\n                                           \"track-id\": tracking_id,\n                                           \"total\": len(msg_idxs),\n                                           \"reading\": e.msg_mid()}\n                self.event.message = _('Digging into =%s') % e.msg_mid()\n                self._update_event_state(self.event.RUNNING, log=True)\n            else:\n                session.ui.mark(_('Digging into =%s') % e.msg_mid())\n            row = [] if without_mid else ['%s' % e.msg_mid()]\n            for cellspec in columns:\n                row.extend(self._cell(idx, e, cellspec))\n            results.append(row)\n            if deadline and deadline < time.time():\n                break\n\n        return self._success(_('Found %d rows in %d messages'\n                               ) % (len(results), len(msg_idxs)), results)\n\n", "comments": "   extract tables structured data e mail content       fixme  perhaps plugin named esql implement sql           syntax extracting data e mails           select body regards  (  ) from search bre       fixme     command line arguments       form arguments       add header csv requested ", "content": "import re\nimport time\n\nfrom mailpile.i18n import gettext as _\nfrom mailpile.i18n import ngettext as _n\nfrom mailpile.commands import Command\nfrom mailpile.mailutils import Email\nfrom mailpile.util import truthy\n\n# FIXME: Perhaps this plugin should be named ESQL and implement an SQL\n#        syntax for extracting data from e-mails...\n#\n#  SELECT from,to,body=Regards\\,(.*) FROM search=to:bre\n#\n\n\nclass dataDigCommand(Command):\n    \"\"\"Extract tables of structured data from e-mail content\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'datadig', 'datadig', '<terms ...> -- <messages ...>')\n    HTTP_CALLABLE = ('GET', )\n    HTTP_QUERY_VARS = {\n        'track-id': 'tracking ID for event log',\n        'timeout': 'runtime in seconds',\n        'header': 'include header',\n        'no-mid': 'omit metadata-ID column',\n        'term': 'extraction term',\n        'mid': 'metadata-ID'\n    }\n\n    class CommandResult(Command.CommandResult):\n        def as_text(self):\n            if self.result:\n                return '\\n'.join(['\\t'.join([unicode(cell) for cell in row])\n                                  for row in self.result])\n            else:\n                return _(\"Nothing Happened\")\n\n    def _filter(self, idx, e, celldata, filters):\n        if not isinstance(celldata, (list, tuple)):\n            celldata = [celldata]\n        for fltr in filters:\n            # FIXME!\n            celldata = celldata\n        return celldata\n\n    def _cell(self, idx, e, cellspec):\n        filters = cellspec.split('||')\n        cspec, lcspec = filters[0], filters[0].lower()\n        lcspec = lcspec.split(':', 1)[0].split('=', 1)[-1]\n\n        if lcspec == 'sender':\n            return self._filter(idx, e, e.get_msg_info(field=idx.MSG_FROM),\n                                filters)\n\n        if lcspec == 'subject':\n            return self._filter(idx, e, e.get_msg_info(field=idx.MSG_SUBJECT),\n                                filters)\n\n        if lcspec in ('from', 'to', 'cc', 'bcc', 'date'):\n            return self._filter(idx, e, e.get_msg()[lcspec], filters)\n\n        if lcspec in ('text', ):\n            rxp = cspec.split(':', 1)[1]\n            if lcspec == 'text':\n                body = e.get_editing_strings()['body']\n                mobj = re.search(rxp, body)\n            if mobj:\n                return self._filter(idx, e, list(mobj.groups()), filters)\n\n        return ['']\n\n    def command(self):\n        session, config, idx = self.session, self.session.config, self._idx()\n\n        # Command-line arguments...\n        msgs = list(self.args)\n        timeout = -1\n        tracking_id = None\n        with_header = False\n        without_mid = False\n        columns = []\n        while msgs and msgs[0].lower() != '--':\n            arg = msgs.pop(0)\n            if arg.startswith('--timeout='):\n                timeout = float(arg[10:])\n            elif arg.startswith('--header'):\n                with_header = True\n            elif arg.startswith('--no-mid'):\n                without_mid = True\n            else:\n                columns.append(arg)\n        if msgs and msgs[0].lower() == '--':\n            msgs.pop(0)\n\n        # Form arguments...\n        timeout = float(self.data.get('timeout', [timeout])[0])\n        with_header |= truthy(self.data.get('header', [''])[0])\n        without_mid |= truthy(self.data.get('no-mid', [''])[0])\n        tracking_id = self.data.get('track-id', [tracking_id])[0]\n        columns.extend(self.data.get('term', []))\n        msgs.extend(['=%s' % mid.replace('=', '')\n                     for mid in self.data.get('mid', [])])\n\n        # Add a header to the CSV if requested\n        if with_header:\n            results = [[col.split('||')[0].split(':', 1)[0].split('=', 1)[0]\n                        for col in columns]]\n            if not without_mid:\n                results[0] = ['MID'] + results[0]\n        else:\n            results = []\n\n        deadline = (time.time() + timeout) if (timeout > 0) else None\n        msg_idxs = self._choose_messages(msgs)\n        progress = []\n        for msg_idx in msg_idxs:\n            e = Email(idx, msg_idx)\n            if self.event and tracking_id:\n                progress.append(msg_idx)\n                self.event.private_data = {\"progress\": len(progress),\n                                           \"track-id\": tracking_id,\n                                           \"total\": len(msg_idxs),\n                                           \"reading\": e.msg_mid()}\n                self.event.message = _('Digging into =%s') % e.msg_mid()\n                self._update_event_state(self.event.RUNNING, log=True)\n            else:\n                session.ui.mark(_('Digging into =%s') % e.msg_mid())\n            row = [] if without_mid else ['%s' % e.msg_mid()]\n            for cellspec in columns:\n                row.extend(self._cell(idx, e, cellspec))\n            results.append(row)\n            if deadline and deadline < time.time():\n                break\n\n        return self._success(_('Found %d rows in %d messages'\n                               ) % (len(results), len(msg_idxs)), results)\n\n", "description": "A free & open modern, fast email client with user-friendly encryption and privacy features", "file_name": "datadig.py", "id": "b14f65e699e3fe8b46f7d3fae54528c8", "language": "Python", "project_name": "Mailpile", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mailpile-Mailpile/mailpile-Mailpile-8ebc5fe/external-plugins/datadig/datadig.py", "save_time": "", "source": "", "update_at": "2018-03-17T23:54:52Z", "url": "https://github.com/mailpile/Mailpile", "wiki": true}