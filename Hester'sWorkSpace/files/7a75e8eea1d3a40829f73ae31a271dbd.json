{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    ExtractorError,\n    int_or_none,\n    update_url_query,\n)\n\n\nclass NaverIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:m\\.)?tv(?:cast)?\\.naver\\.com/v/(?P<id>\\d+)'\n\n    _TESTS = [{\n        'url': 'http://tv.naver.com/v/81652',\n        'info_dict': {\n            'id': '81652',\n            'ext': 'mp4',\n            'title': '[9\uc6d4 \ubaa8\uc758\uace0\uc0ac \ud574\uc124\uac15\uc758][\uc218\ud559_\uae40\uc0c1\ud76c] \uc218\ud559 A\ud615 16~20\ubc88',\n            'description': '\ud569\uaca9\ubd88\ubcc0\uc758 \ubc95\uce59 \uba54\uac00\uc2a4\ud130\ub514 | \uba54\uac00\uc2a4\ud130\ub514 \uc218\ud559 \uae40\uc0c1\ud76c \uc120\uc0dd\ub2d8\uc774 9\uc6d4 \ubaa8\uc758\uace0\uc0ac \uc218\ud559A\ud615 16\ubc88\uc5d0\uc11c 20\ubc88\uae4c\uc9c0 \ud574\uc124\uac15\uc758\ub97c \uacf5\uac1c\ud569\ub2c8\ub2e4.',\n            'upload_date': '20130903',\n        },\n    }, {\n        'url': 'http://tv.naver.com/v/395837',\n        'md5': '638ed4c12012c458fefcddfd01f173cd',\n        'info_dict': {\n            'id': '395837',\n            'ext': 'mp4',\n            'title': '9\ub144\uc774 \uc9c0\ub098\ub3c4 \uc544\ud508 \uae30\uc5b5, \uc804\ud6a8\uc131\uc758 \uc544\ubc84\uc9c0',\n            'description': 'md5:5bf200dcbf4b66eb1b350d1eb9c753f7',\n            'upload_date': '20150519',\n        },\n        'skip': 'Georestricted',\n    }, {\n        'url': 'http://tvcast.naver.com/v/81652',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        webpage = self._download_webpage(url, video_id)\n\n        m_id = re.search(r'var rmcPlayer = new nhn\\.rmcnmv\\.RMCVideoPlayer\\(\"(.+?)\", \"(.+?)\"',\n                         webpage)\n        if m_id is None:\n            error = self._html_search_regex(\n                r'(?s)<div class=\"(?:nation_error|nation_box|error_box)\">\\s*(?:<!--.*?-->)?\\s*<p class=\"[^\"]+\">(?P<msg>.+?)</p>\\s*</div>',\n                webpage, 'error', default=None)\n            if error:\n                raise ExtractorError(error, expected=True)\n            raise ExtractorError('couldn\\'t extract vid and key')\n        video_data = self._download_json(\n            'http://play.rmcnmv.naver.com/vod/play/v2.0/' + m_id.group(1),\n            video_id, query={\n                'key': m_id.group(2),\n            })\n        meta = video_data['meta']\n        title = meta['subject']\n        formats = []\n\n        def extract_formats(streams, stream_type, query={}):\n            for stream in streams:\n                stream_url = stream.get('source')\n                if not stream_url:\n                    continue\n                stream_url = update_url_query(stream_url, query)\n                encoding_option = stream.get('encodingOption', {})\n                bitrate = stream.get('bitrate', {})\n                formats.append({\n                    'format_id': '%s_%s' % (stream.get('type') or stream_type, encoding_option.get('id') or encoding_option.get('name')),\n                    'url': stream_url,\n                    'width': int_or_none(encoding_option.get('width')),\n                    'height': int_or_none(encoding_option.get('height')),\n                    'vbr': int_or_none(bitrate.get('video')),\n                    'abr': int_or_none(bitrate.get('audio')),\n                    'filesize': int_or_none(stream.get('size')),\n                    'protocol': 'm3u8_native' if stream_type == 'HLS' else None,\n                })\n\n        extract_formats(video_data.get('videos', {}).get('list', []), 'H264')\n        for stream_set in video_data.get('streams', []):\n            query = {}\n            for param in stream_set.get('keys', []):\n                query[param['name']] = param['value']\n            stream_type = stream_set.get('type')\n            videos = stream_set.get('videos')\n            if videos:\n                extract_formats(videos, stream_type, query)\n            elif stream_type == 'HLS':\n                stream_url = stream_set.get('source')\n                if not stream_url:\n                    continue\n                formats.extend(self._extract_m3u8_formats(\n                    update_url_query(stream_url, query), video_id,\n                    'mp4', 'm3u8_native', m3u8_id=stream_type, fatal=False))\n        self._sort_formats(formats)\n\n        subtitles = {}\n        for caption in video_data.get('captions', {}).get('list', []):\n            caption_url = caption.get('source')\n            if not caption_url:\n                continue\n            subtitles.setdefault(caption.get('language') or caption.get('locale'), []).append({\n                'url': caption_url,\n            })\n\n        upload_date = self._search_regex(\n            r'<span[^>]+class=\"date\".*?(\\d{4}\\.\\d{2}\\.\\d{2})',\n            webpage, 'upload date', fatal=False)\n        if upload_date:\n            upload_date = upload_date.replace('.', '')\n\n        return {\n            'id': video_id,\n            'title': title,\n            'formats': formats,\n            'subtitles': subtitles,\n            'description': self._og_search_description(webpage),\n            'thumbnail': meta.get('cover', {}).get('source') or self._og_search_thumbnail(webpage),\n            'view_count': int_or_none(meta.get('count')),\n            'upload_date': upload_date,\n        }\n", "comments": "# coding: utf-8\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    ExtractorError,\n    int_or_none,\n    update_url_query,\n)\n\n\nclass NaverIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:m\\.)?tv(?:cast)?\\.naver\\.com/v/(?P<id>\\d+)'\n\n    _TESTS = [{\n        'url': 'http://tv.naver.com/v/81652',\n        'info_dict': {\n            'id': '81652',\n            'ext': 'mp4',\n            'title': '[9\uc6d4 \ubaa8\uc758\uace0\uc0ac \ud574\uc124\uac15\uc758][\uc218\ud559_\uae40\uc0c1\ud76c] \uc218\ud559 A\ud615 16~20\ubc88',\n            'description': '\ud569\uaca9\ubd88\ubcc0\uc758 \ubc95\uce59 \uba54\uac00\uc2a4\ud130\ub514 | \uba54\uac00\uc2a4\ud130\ub514 \uc218\ud559 \uae40\uc0c1\ud76c \uc120\uc0dd\ub2d8\uc774 9\uc6d4 \ubaa8\uc758\uace0\uc0ac \uc218\ud559A\ud615 16\ubc88\uc5d0\uc11c 20\ubc88\uae4c\uc9c0 \ud574\uc124\uac15\uc758\ub97c \uacf5\uac1c\ud569\ub2c8\ub2e4.',\n            'upload_date': '20130903',\n        },\n    }, {\n        'url': 'http://tv.naver.com/v/395837',\n        'md5': '638ed4c12012c458fefcddfd01f173cd',\n        'info_dict': {\n            'id': '395837',\n            'ext': 'mp4',\n            'title': '9\ub144\uc774 \uc9c0\ub098\ub3c4 \uc544\ud508 \uae30\uc5b5, \uc804\ud6a8\uc131\uc758 \uc544\ubc84\uc9c0',\n            'description': 'md5:5bf200dcbf4b66eb1b350d1eb9c753f7',\n            'upload_date': '20150519',\n        },\n        'skip': 'Georestricted',\n    }, {\n        'url': 'http://tvcast.naver.com/v/81652',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        webpage = self._download_webpage(url, video_id)\n\n        m_id = re.search(r'var rmcPlayer = new nhn\\.rmcnmv\\.RMCVideoPlayer\\(\"(.+?)\", \"(.+?)\"',\n                         webpage)\n        if m_id is None:\n            error = self._html_search_regex(\n                r'(?s)<div class=\"(?:nation_error|nation_box|error_box)\">\\s*(?:<!--.*?-->)?\\s*<p class=\"[^\"]+\">(?P<msg>.+?)</p>\\s*</div>',\n                webpage, 'error', default=None)\n            if error:\n                raise ExtractorError(error, expected=True)\n            raise ExtractorError('couldn\\'t extract vid and key')\n        video_data = self._download_json(\n            'http://play.rmcnmv.naver.com/vod/play/v2.0/' + m_id.group(1),\n            video_id, query={\n                'key': m_id.group(2),\n            })\n        meta = video_data['meta']\n        title = meta['subject']\n        formats = []\n\n        def extract_formats(streams, stream_type, query={}):\n            for stream in streams:\n                stream_url = stream.get('source')\n                if not stream_url:\n                    continue\n                stream_url = update_url_query(stream_url, query)\n                encoding_option = stream.get('encodingOption', {})\n                bitrate = stream.get('bitrate', {})\n                formats.append({\n                    'format_id': '%s_%s' % (stream.get('type') or stream_type, encoding_option.get('id') or encoding_option.get('name')),\n                    'url': stream_url,\n                    'width': int_or_none(encoding_option.get('width')),\n                    'height': int_or_none(encoding_option.get('height')),\n                    'vbr': int_or_none(bitrate.get('video')),\n                    'abr': int_or_none(bitrate.get('audio')),\n                    'filesize': int_or_none(stream.get('size')),\n                    'protocol': 'm3u8_native' if stream_type == 'HLS' else None,\n                })\n\n        extract_formats(video_data.get('videos', {}).get('list', []), 'H264')\n        for stream_set in video_data.get('streams', []):\n            query = {}\n            for param in stream_set.get('keys', []):\n                query[param['name']] = param['value']\n            stream_type = stream_set.get('type')\n            videos = stream_set.get('videos')\n            if videos:\n                extract_formats(videos, stream_type, query)\n            elif stream_type == 'HLS':\n                stream_url = stream_set.get('source')\n                if not stream_url:\n                    continue\n                formats.extend(self._extract_m3u8_formats(\n                    update_url_query(stream_url, query), video_id,\n                    'mp4', 'm3u8_native', m3u8_id=stream_type, fatal=False))\n        self._sort_formats(formats)\n\n        subtitles = {}\n        for caption in video_data.get('captions', {}).get('list', []):\n            caption_url = caption.get('source')\n            if not caption_url:\n                continue\n            subtitles.setdefault(caption.get('language') or caption.get('locale'), []).append({\n                'url': caption_url,\n            })\n\n        upload_date = self._search_regex(\n            r'<span[^>]+class=\"date\".*?(\\d{4}\\.\\d{2}\\.\\d{2})',\n            webpage, 'upload date', fatal=False)\n        if upload_date:\n            upload_date = upload_date.replace('.', '')\n\n        return {\n            'id': video_id,\n            'title': title,\n            'formats': formats,\n            'subtitles': subtitles,\n            'description': self._og_search_description(webpage),\n            'thumbnail': meta.get('cover', {}).get('source') or self._og_search_thumbnail(webpage),\n            'view_count': int_or_none(meta.get('count')),\n            'upload_date': upload_date,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "naver.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/naver.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}