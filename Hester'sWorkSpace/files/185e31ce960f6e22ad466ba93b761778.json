{"author": "ansible", "code": "\n -*- coding: utf-8 -*-\n\n Copyright: Ansible Project\n GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: digital_ocean\nshort_description: Create/delete a droplet/SSH_key in DigitalOcean\ndescription:\n     - Create/delete a droplet in DigitalOcean and optionally wait for it to be 'running', or deploy an SSH key.\nversion_added: \"1.3\"\nauthor: \"Vincent Viallet (@zbal)\"\noptions:\n  command:\n    description:\n     - Which target you want to operate on.\n    default: droplet\n    choices: ['droplet', 'ssh']\n  state:\n    description:\n     - Indicate desired state of the target.\n    default: present\n    choices: ['present', 'active', 'absent', 'deleted']\n  api_token:\n    description:\n     - DigitalOcean api token.\n    version_added: \"1.9.5\"\n  id:\n    description:\n     - Numeric, the droplet id you want to operate on.\n    aliases: ['droplet_id']\n  name:\n    description:\n     - String, this is the name of the droplet - must be formatted by hostname rules, or the name of a SSH key.\n  unique_name:\n    description:\n     - Bool, require unique hostnames.  By default, DigitalOcean allows multiple hosts with the same name.  Setting this to \"yes\" allows only one host\n       per name.  Useful for idempotence.\n    type: bool\n    default: 'no'\n    version_added: \"1.4\"\n  size_id:\n    description:\n     - This is the slug of the size you would like the droplet created with.\n  image_id:\n    description:\n     - This is the slug of the image you would like the droplet created with.\n  region_id:\n    description:\n     - This is the slug of the region you would like your server to be created in.\n  ssh_key_ids:\n    description:\n     - Optional, array of SSH key (numeric) ID that you would like to be added to the server.\n  virtio:\n    description:\n     - \"Bool, turn on virtio driver in droplet for improved network and storage I/O.\"\n    type: bool\n    default: 'yes'\n    version_added: \"1.4\"\n  private_networking:\n    description:\n     - \"Bool, add an additional, private network interface to droplet for inter-droplet communication.\"\n    type: bool\n    default: 'no'\n    version_added: \"1.4\"\n  backups_enabled:\n    description:\n     - Optional, Boolean, enables backups for your droplet.\n    type: bool\n    default: 'no'\n    version_added: \"1.6\"\n  user_data:\n    description:\n      - opaque blob of data which is made available to the droplet\n    version_added: \"2.0\"\n  ipv6:\n    description:\n      - Optional, Boolean, enable IPv6 for your droplet.\n    type: bool\n    default: 'no'\n    version_added: \"2.2\"\n  wait:\n    description:\n     - Wait for the droplet to be in state 'running' before returning.  If wait is \"no\" an ip_address may not be returned.\n    type: bool\n    default: 'yes'\n  wait_timeout:\n    description:\n     - How long before wait gives up, in seconds.\n    default: 300\n  ssh_pub_key:\n    description:\n     - The public SSH key you want to add to your account.\n\nnotes:\n  - Two environment variables can be used, DO_API_KEY and DO_API_TOKEN. They both refer to the v2 token.\n  - As of Ansible 1.9.5 and 2.0, Version 2 of the DigitalOcean API is used, this removes C(client_id) and C(api_key) options in favor of C(api_token).\n  - If you are running Ansible 1.9.4 or earlier you might not be able to use the included version of this module as the API version used has been retired.\n    Upgrade Ansible or, if unable to, try downloading the latest version of this module from github and putting it into a 'library' directory.\nrequirements:\n  - \"python >= 2.6\"\n  - dopy\n'''\n\n\nEXAMPLES = '''\n Ensure a SSH key is present\n If a key matches this name, will return the ssh key id and changed = False\n If no existing key matches this name, a new key is created, the ssh key id is returned and changed = False\n\n- digital_ocean:\n    state: present\n    command: ssh\n    name: my_ssh_key\n    ssh_pub_key: 'ssh-rsa AAAA...'\n    api_token: XXX\n\n Create a new Droplet\n Will return the droplet details including the droplet id (used for idempotence)\n\n- digital_ocean:\n    state: present\n    command: droplet\n    name: mydroplet\n    api_token: XXX\n    size_id: 2gb\n    region_id: ams2\n    image_id: fedora-19-x64\n    wait_timeout: 500\n  register: my_droplet\n\n- debug:\n    msg: \"ID is {{ my_droplet.droplet.id }}\"\n\n- debug:\n    msg: \"IP is {{ my_droplet.droplet.ip_address }}\"\n\n Ensure a droplet is present\n If droplet id already exist, will return the droplet details and changed = False\n If no droplet matches the id, a new droplet will be created and the droplet details (including the new id) are returned, changed = True.\n\n- digital_ocean:\n    state: present\n    command: droplet\n    id: 123\n    name: mydroplet\n    api_token: XXX\n    size_id: 2gb\n    region_id: ams2\n    image_id: fedora-19-x64\n    wait_timeout: 500\n\n Create a droplet with ssh key\n The ssh key id can be passed as argument at the creation of a droplet (see ssh_key_ids).\n Several keys can be added to ssh_key_ids as id1,id2,id3\n The keys are used to connect as root to the droplet.\n\n- digital_ocean:\n    state: present\n    ssh_key_ids: 123,456\n    name: mydroplet\n    api_token: XXX\n    size_id: 2gb\n    region_id: ams2\n    image_id: fedora-19-x64\n\n'''\n\nimport os\nimport time\nimport traceback\n\nfrom distutils.version import LooseVersion\n\ntry:\n     Imported as a dependency for dopy\n    import six\n    HAS_SIX = True\nexcept ImportError:\n    HAS_SIX = False\n\nHAS_DOPY = False\ntry:\n    import dopy\n    from dopy.manager import DoError, DoManager\n    if LooseVersion(dopy.__version__) >= LooseVersion('0.3.2'):\n        HAS_DOPY = True\nexcept ImportError:\n    pass\n\nfrom ansible.module_utils.basic import AnsibleModule, env_fallback\n\n\nclass TimeoutError(Exception):\n\n    def __init__(self, msg, id_):\n        super(TimeoutError, self).__init__(msg)\n        self.id = id_\n\n\nclass JsonfyMixIn(object):\n\n    def to_json(self):\n        return self.__dict__\n\n\nclass Droplet(JsonfyMixIn):\n    manager = None\n\n    def __init__(self, droplet_json):\n        self.status = 'new'\n        self.__dict__.update(droplet_json)\n\n    def is_powered_on(self):\n        return self.status == 'active'\n\n    def update_attr(self, attrs=None):\n        if attrs:\n            for k, v in attrs.items():\n                setattr(self, k, v)\n            networks = attrs.get('networks', {})\n            for network in networks.get('v6', []):\n                if network['type'] == 'public':\n                    setattr(self, 'public_ipv6_address', network['ip_address'])\n                else:\n                    setattr(self, 'private_ipv6_address', network['ip_address'])\n        else:\n            json = self.manager.show_droplet(self.id)\n            if json['ip_address']:\n                self.update_attr(json)\n\n    def power_on(self):\n        if self.status != 'off':\n            raise AssertionError('Can only power on a closed one.')\n        json = self.manager.power_on_droplet(self.id)\n        self.update_attr(json)\n\n    def ensure_powered_on(self, wait=True, wait_timeout=300):\n        if self.is_powered_on():\n            return\n        if self.status == 'off':   powered off\n            self.power_on()\n\n        if wait:\n            end_time = time.time() + wait_timeout\n            while time.time() < end_time:\n                time.sleep(min(20, end_time - time.time()))\n                self.update_attr()\n                if self.is_powered_on():\n                    if not self.ip_address:\n                        raise TimeoutError('No ip is found.', self.id)\n                    return\n            raise TimeoutError('Wait for droplet running timeout', self.id)\n\n    def destroy(self):\n        return self.manager.destroy_droplet(self.id, scrub_data=True)\n\n    @classmethod\n    def setup(cls, api_token):\n        cls.manager = DoManager(None, api_token, api_version=2)\n\n    @classmethod\n    def add(cls, name, size_id, image_id, region_id, ssh_key_ids=None, virtio=True, private_networking=False, backups_enabled=False, user_data=None,\n            ipv6=False):\n        private_networking_lower = str(private_networking).lower()\n        backups_enabled_lower = str(backups_enabled).lower()\n        ipv6_lower = str(ipv6).lower()\n        json = cls.manager.new_droplet(name, size_id, image_id, region_id,\n                                       ssh_key_ids=ssh_key_ids, virtio=virtio, private_networking=private_networking_lower,\n                                       backups_enabled=backups_enabled_lower, user_data=user_data, ipv6=ipv6_lower)\n        droplet = cls(json)\n        return droplet\n\n    @classmethod\n    def find(cls, id=None, name=None):\n        if not id and not name:\n            return False\n\n        droplets = cls.list_all()\n\n         Check first by id.  digital ocean requires that it be unique\n        for droplet in droplets:\n            if droplet.id == id:\n                return droplet\n\n         Failing that, check by hostname.\n        for droplet in droplets:\n            if droplet.name == name:\n                return droplet\n\n        return False\n\n    @classmethod\n    def list_all(cls):\n        json = cls.manager.all_active_droplets()\n        return list(map(cls, json))\n\n\nclass SSH(JsonfyMixIn):\n    manager = None\n\n    def __init__(self, ssh_key_json):\n        self.__dict__.update(ssh_key_json)\n    update_attr = __init__\n\n    def destroy(self):\n        self.manager.destroy_ssh_key(self.id)\n        return True\n\n    @classmethod\n    def setup(cls, api_token):\n        cls.manager = DoManager(None, api_token, api_version=2)\n\n    @classmethod\n    def find(cls, name):\n        if not name:\n            return False\n        keys = cls.list_all()\n        for key in keys:\n            if key.name == name:\n                return key\n        return False\n\n    @classmethod\n    def list_all(cls):\n        json = cls.manager.all_ssh_keys()\n        return list(map(cls, json))\n\n    @classmethod\n    def add(cls, name, key_pub):\n        json = cls.manager.new_ssh_key(name, key_pub)\n        return cls(json)\n\n\ndef core(module):\n    def getkeyordie(k):\n        v = module.params[k]\n        if v is None:\n            module.fail_json(msg='Unable to load %s' % k)\n        return v\n\n    api_token = module.params['api_token']\n    changed = True\n    command = module.params['command']\n    state = module.params['state']\n\n    if command == 'droplet':\n        Droplet.setup(api_token)\n        if state in ('active', 'present'):\n\n             First, try to find a droplet by id.\n            droplet = Droplet.find(id=module.params['id'])\n\n             If we couldn't find the droplet and the user is allowing unique\n             hostnames, then check to see if a droplet with the specified\n             hostname already exists.\n            if not droplet and module.params['unique_name']:\n                droplet = Droplet.find(name=getkeyordie('name'))\n\n             If both of those attempts failed, then create a new droplet.\n            if not droplet:\n                droplet = Droplet.add(\n                    name=getkeyordie('name'),\n                    size_id=getkeyordie('size_id'),\n                    image_id=getkeyordie('image_id'),\n                    region_id=getkeyordie('region_id'),\n                    ssh_key_ids=module.params['ssh_key_ids'],\n                    virtio=module.params['virtio'],\n                    private_networking=module.params['private_networking'],\n                    backups_enabled=module.params['backups_enabled'],\n                    user_data=module.params.get('user_data'),\n                    ipv6=module.params['ipv6'],\n                )\n\n            if droplet.is_powered_on():\n                changed = False\n\n            droplet.ensure_powered_on(\n                wait=getkeyordie('wait'),\n                wait_timeout=getkeyordie('wait_timeout')\n            )\n\n            module.exit_json(changed=changed, droplet=droplet.to_json())\n\n        elif state in ('absent', 'deleted'):\n             First, try to find a droplet by id.\n            droplet = Droplet.find(module.params['id'])\n\n             If we couldn't find the droplet and the user is allowing unique\n             hostnames, then check to see if a droplet with the specified\n             hostname already exists.\n            if not droplet and module.params['unique_name']:\n                droplet = Droplet.find(name=getkeyordie('name'))\n\n            if not droplet:\n                module.exit_json(changed=False, msg='The droplet is not found.')\n\n            droplet.destroy()\n            module.exit_json(changed=True)\n\n    elif command == 'ssh':\n        SSH.setup(api_token)\n        name = getkeyordie('name')\n        if state in ('active', 'present'):\n            key = SSH.find(name)\n            if key:\n                module.exit_json(changed=False, ssh_key=key.to_json())\n            key = SSH.add(name, getkeyordie('ssh_pub_key'))\n            module.exit_json(changed=True, ssh_key=key.to_json())\n\n        elif state in ('absent', 'deleted'):\n            key = SSH.find(name)\n            if not key:\n                module.exit_json(changed=False, msg='SSH key with the name of %s is not found.' % name)\n            key.destroy()\n            module.exit_json(changed=True)\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            command=dict(choices=['droplet', 'ssh'], default='droplet'),\n            state=dict(choices=['active', 'present', 'absent', 'deleted'], default='present'),\n            api_token=dict(\n                aliases=['API_TOKEN'],\n                no_log=True,\n                fallback=(env_fallback, ['DO_API_TOKEN', 'DO_API_KEY'])\n            ),\n            name=dict(type='str'),\n            size_id=dict(),\n            image_id=dict(),\n            region_id=dict(),\n            ssh_key_ids=dict(type='list'),\n            virtio=dict(type='bool', default='yes'),\n            private_networking=dict(type='bool', default='no'),\n            backups_enabled=dict(type='bool', default='no'),\n            id=dict(aliases=['droplet_id'], type='int'),\n            unique_name=dict(type='bool', default='no'),\n            user_data=dict(default=None),\n            ipv6=dict(type='bool', default='no'),\n            wait=dict(type='bool', default=True),\n            wait_timeout=dict(default=300, type='int'),\n            ssh_pub_key=dict(type='str'),\n        ),\n        required_together=(\n            ['size_id', 'image_id', 'region_id'],\n        ),\n        mutually_exclusive=(\n            ['size_id', 'ssh_pub_key'],\n            ['image_id', 'ssh_pub_key'],\n            ['region_id', 'ssh_pub_key'],\n        ),\n        required_one_of=(\n            ['id', 'name'],\n        ),\n    )\n    if not HAS_DOPY and not HAS_SIX:\n        module.fail_json(msg='dopy >= 0.3.2 is required for this module. dopy requires six but six is not installed. '\n                             'Make sure both dopy and six are installed.')\n    if not HAS_DOPY:\n        module.fail_json(msg='dopy >= 0.3.2 required for this module')\n\n    try:\n        core(module)\n    except TimeoutError as e:\n        module.fail_json(msg=str(e), id=e.id)\n    except (DoError, Exception) as e:\n        module.fail_json(msg=str(e), exception=traceback.format_exc())\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  digital ocean short description  create delete droplet ssh key digitalocean description         create delete droplet digitalocean optionally wait  running   deploy ssh key  version added   1 3  author   vincent viallet ( zbal)  options    command      description         which target want operate      default  droplet     choices    droplet    ssh     state      description         indicate desired state target      default  present     choices    present    active    absent    deleted     api token      description         digitalocean api token      version added   1 9 5    id      description         numeric  droplet id want operate      aliases    droplet id     name      description         string  name droplet   must formatted hostname rules  name ssh key    unique name      description         bool  require unique hostnames   by default  digitalocean allows multiple hosts name   setting  yes  allows one host        per name   useful idempotence      type  bool     default        version added   1 4    size id      description         this slug size would like droplet created    image id      description         this slug image would like droplet created    region id      description         this slug region would like server created    ssh key ids      description         optional  array ssh key (numeric) id would like added server    virtio      description          bool  turn virtio driver droplet improved network storage i o       type  bool     default   yes      version added   1 4    private networking      description          bool  add additional  private network interface droplet inter droplet communication       type  bool     default        version added   1 4    backups enabled      description         optional  boolean  enables backups droplet      type  bool     default        version added   1 6    user data      description          opaque blob data made available droplet     version added   2 0    ipv6      description          optional  boolean  enable ipv6 droplet      type  bool     default        version added   2 2    wait      description         wait droplet state  running  returning   if wait   ip address may returned      type  bool     default   yes    wait timeout      description         how long wait gives  seconds      default  300   ssh pub key      description         the public ssh key want add account   notes      two environment variables used  do api key do api token  they refer v2 token      as ansible 1 9 5 2 0  version 2 digitalocean api used  removes c(client id) c(api key) options favor c(api token)      if running ansible 1 9 4 earlier might able use included version module api version used retired      upgrade ansible  unable  try downloading latest version module github putting  library  directory  requirements       python    2 6      dopy       examples         ensure ssh key present   if key matches name  return ssh key id changed   false   if existing key matches name  new key created  ssh key id returned changed   false    digital ocean      state  present     command  ssh     name  ssh key     ssh pub key   ssh rsa aaaa         api token  xxx    create new droplet   will return droplet details including droplet id (used idempotence)    digital ocean      state  present     command  droplet     name  mydroplet     api token  xxx     size id  2gb     region id  ams2     image id  fedora 19 x64     wait timeout  500   register  droplet    debug      msg   id    droplet droplet id        debug      msg   ip    droplet droplet ip address        ensure droplet present   if droplet id already exist  return droplet details changed   false   if droplet matches id  new droplet created droplet details (including new id) returned  changed   true     digital ocean      state  present     command  droplet     id  123     name  mydroplet     api token  xxx     size id  2gb     region id  ams2     image id  fedora 19 x64     wait timeout  500    create droplet ssh key   the ssh key id passed argument creation droplet (see ssh key ids)    several keys added ssh key ids id1 id2 id3   the keys used connect root droplet     digital ocean      state  present     ssh key ids  123 456     name  mydroplet     api token  xxx     size id  2gb     region id  ams2     image id  fedora 19 x64          usr bin python        coding  utf 8           copyright  ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    ensure ssh key present    if key matches name  return ssh key id changed   false    if existing key matches name  new key created  ssh key id returned changed   false    create new droplet    will return droplet details including droplet id (used idempotence)    ensure droplet present    if droplet id already exist  return droplet details changed   false    if droplet matches id  new droplet created droplet details (including new id) returned  changed   true     create droplet ssh key    the ssh key id passed argument creation droplet (see ssh key ids)     several keys added ssh key ids id1 id2 id3    the keys used connect root droplet     imported dependency dopy    powered    check first id   digital ocean requires unique    failing  check hostname     first  try find droplet id     if find droplet user allowing unique    hostnames  check see droplet specified    hostname already exists     if attempts failed  create new droplet     first  try find droplet id     if find droplet user allowing unique    hostnames  check see droplet specified    hostname already exists  ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n#\n# Copyright: Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: digital_ocean\nshort_description: Create/delete a droplet/SSH_key in DigitalOcean\ndescription:\n     - Create/delete a droplet in DigitalOcean and optionally wait for it to be 'running', or deploy an SSH key.\nversion_added: \"1.3\"\nauthor: \"Vincent Viallet (@zbal)\"\noptions:\n  command:\n    description:\n     - Which target you want to operate on.\n    default: droplet\n    choices: ['droplet', 'ssh']\n  state:\n    description:\n     - Indicate desired state of the target.\n    default: present\n    choices: ['present', 'active', 'absent', 'deleted']\n  api_token:\n    description:\n     - DigitalOcean api token.\n    version_added: \"1.9.5\"\n  id:\n    description:\n     - Numeric, the droplet id you want to operate on.\n    aliases: ['droplet_id']\n  name:\n    description:\n     - String, this is the name of the droplet - must be formatted by hostname rules, or the name of a SSH key.\n  unique_name:\n    description:\n     - Bool, require unique hostnames.  By default, DigitalOcean allows multiple hosts with the same name.  Setting this to \"yes\" allows only one host\n       per name.  Useful for idempotence.\n    type: bool\n    default: 'no'\n    version_added: \"1.4\"\n  size_id:\n    description:\n     - This is the slug of the size you would like the droplet created with.\n  image_id:\n    description:\n     - This is the slug of the image you would like the droplet created with.\n  region_id:\n    description:\n     - This is the slug of the region you would like your server to be created in.\n  ssh_key_ids:\n    description:\n     - Optional, array of SSH key (numeric) ID that you would like to be added to the server.\n  virtio:\n    description:\n     - \"Bool, turn on virtio driver in droplet for improved network and storage I/O.\"\n    type: bool\n    default: 'yes'\n    version_added: \"1.4\"\n  private_networking:\n    description:\n     - \"Bool, add an additional, private network interface to droplet for inter-droplet communication.\"\n    type: bool\n    default: 'no'\n    version_added: \"1.4\"\n  backups_enabled:\n    description:\n     - Optional, Boolean, enables backups for your droplet.\n    type: bool\n    default: 'no'\n    version_added: \"1.6\"\n  user_data:\n    description:\n      - opaque blob of data which is made available to the droplet\n    version_added: \"2.0\"\n  ipv6:\n    description:\n      - Optional, Boolean, enable IPv6 for your droplet.\n    type: bool\n    default: 'no'\n    version_added: \"2.2\"\n  wait:\n    description:\n     - Wait for the droplet to be in state 'running' before returning.  If wait is \"no\" an ip_address may not be returned.\n    type: bool\n    default: 'yes'\n  wait_timeout:\n    description:\n     - How long before wait gives up, in seconds.\n    default: 300\n  ssh_pub_key:\n    description:\n     - The public SSH key you want to add to your account.\n\nnotes:\n  - Two environment variables can be used, DO_API_KEY and DO_API_TOKEN. They both refer to the v2 token.\n  - As of Ansible 1.9.5 and 2.0, Version 2 of the DigitalOcean API is used, this removes C(client_id) and C(api_key) options in favor of C(api_token).\n  - If you are running Ansible 1.9.4 or earlier you might not be able to use the included version of this module as the API version used has been retired.\n    Upgrade Ansible or, if unable to, try downloading the latest version of this module from github and putting it into a 'library' directory.\nrequirements:\n  - \"python >= 2.6\"\n  - dopy\n'''\n\n\nEXAMPLES = '''\n# Ensure a SSH key is present\n# If a key matches this name, will return the ssh key id and changed = False\n# If no existing key matches this name, a new key is created, the ssh key id is returned and changed = False\n\n- digital_ocean:\n    state: present\n    command: ssh\n    name: my_ssh_key\n    ssh_pub_key: 'ssh-rsa AAAA...'\n    api_token: XXX\n\n# Create a new Droplet\n# Will return the droplet details including the droplet id (used for idempotence)\n\n- digital_ocean:\n    state: present\n    command: droplet\n    name: mydroplet\n    api_token: XXX\n    size_id: 2gb\n    region_id: ams2\n    image_id: fedora-19-x64\n    wait_timeout: 500\n  register: my_droplet\n\n- debug:\n    msg: \"ID is {{ my_droplet.droplet.id }}\"\n\n- debug:\n    msg: \"IP is {{ my_droplet.droplet.ip_address }}\"\n\n# Ensure a droplet is present\n# If droplet id already exist, will return the droplet details and changed = False\n# If no droplet matches the id, a new droplet will be created and the droplet details (including the new id) are returned, changed = True.\n\n- digital_ocean:\n    state: present\n    command: droplet\n    id: 123\n    name: mydroplet\n    api_token: XXX\n    size_id: 2gb\n    region_id: ams2\n    image_id: fedora-19-x64\n    wait_timeout: 500\n\n# Create a droplet with ssh key\n# The ssh key id can be passed as argument at the creation of a droplet (see ssh_key_ids).\n# Several keys can be added to ssh_key_ids as id1,id2,id3\n# The keys are used to connect as root to the droplet.\n\n- digital_ocean:\n    state: present\n    ssh_key_ids: 123,456\n    name: mydroplet\n    api_token: XXX\n    size_id: 2gb\n    region_id: ams2\n    image_id: fedora-19-x64\n\n'''\n\nimport os\nimport time\nimport traceback\n\nfrom distutils.version import LooseVersion\n\ntry:\n    # Imported as a dependency for dopy\n    import six\n    HAS_SIX = True\nexcept ImportError:\n    HAS_SIX = False\n\nHAS_DOPY = False\ntry:\n    import dopy\n    from dopy.manager import DoError, DoManager\n    if LooseVersion(dopy.__version__) >= LooseVersion('0.3.2'):\n        HAS_DOPY = True\nexcept ImportError:\n    pass\n\nfrom ansible.module_utils.basic import AnsibleModule, env_fallback\n\n\nclass TimeoutError(Exception):\n\n    def __init__(self, msg, id_):\n        super(TimeoutError, self).__init__(msg)\n        self.id = id_\n\n\nclass JsonfyMixIn(object):\n\n    def to_json(self):\n        return self.__dict__\n\n\nclass Droplet(JsonfyMixIn):\n    manager = None\n\n    def __init__(self, droplet_json):\n        self.status = 'new'\n        self.__dict__.update(droplet_json)\n\n    def is_powered_on(self):\n        return self.status == 'active'\n\n    def update_attr(self, attrs=None):\n        if attrs:\n            for k, v in attrs.items():\n                setattr(self, k, v)\n            networks = attrs.get('networks', {})\n            for network in networks.get('v6', []):\n                if network['type'] == 'public':\n                    setattr(self, 'public_ipv6_address', network['ip_address'])\n                else:\n                    setattr(self, 'private_ipv6_address', network['ip_address'])\n        else:\n            json = self.manager.show_droplet(self.id)\n            if json['ip_address']:\n                self.update_attr(json)\n\n    def power_on(self):\n        if self.status != 'off':\n            raise AssertionError('Can only power on a closed one.')\n        json = self.manager.power_on_droplet(self.id)\n        self.update_attr(json)\n\n    def ensure_powered_on(self, wait=True, wait_timeout=300):\n        if self.is_powered_on():\n            return\n        if self.status == 'off':  # powered off\n            self.power_on()\n\n        if wait:\n            end_time = time.time() + wait_timeout\n            while time.time() < end_time:\n                time.sleep(min(20, end_time - time.time()))\n                self.update_attr()\n                if self.is_powered_on():\n                    if not self.ip_address:\n                        raise TimeoutError('No ip is found.', self.id)\n                    return\n            raise TimeoutError('Wait for droplet running timeout', self.id)\n\n    def destroy(self):\n        return self.manager.destroy_droplet(self.id, scrub_data=True)\n\n    @classmethod\n    def setup(cls, api_token):\n        cls.manager = DoManager(None, api_token, api_version=2)\n\n    @classmethod\n    def add(cls, name, size_id, image_id, region_id, ssh_key_ids=None, virtio=True, private_networking=False, backups_enabled=False, user_data=None,\n            ipv6=False):\n        private_networking_lower = str(private_networking).lower()\n        backups_enabled_lower = str(backups_enabled).lower()\n        ipv6_lower = str(ipv6).lower()\n        json = cls.manager.new_droplet(name, size_id, image_id, region_id,\n                                       ssh_key_ids=ssh_key_ids, virtio=virtio, private_networking=private_networking_lower,\n                                       backups_enabled=backups_enabled_lower, user_data=user_data, ipv6=ipv6_lower)\n        droplet = cls(json)\n        return droplet\n\n    @classmethod\n    def find(cls, id=None, name=None):\n        if not id and not name:\n            return False\n\n        droplets = cls.list_all()\n\n        # Check first by id.  digital ocean requires that it be unique\n        for droplet in droplets:\n            if droplet.id == id:\n                return droplet\n\n        # Failing that, check by hostname.\n        for droplet in droplets:\n            if droplet.name == name:\n                return droplet\n\n        return False\n\n    @classmethod\n    def list_all(cls):\n        json = cls.manager.all_active_droplets()\n        return list(map(cls, json))\n\n\nclass SSH(JsonfyMixIn):\n    manager = None\n\n    def __init__(self, ssh_key_json):\n        self.__dict__.update(ssh_key_json)\n    update_attr = __init__\n\n    def destroy(self):\n        self.manager.destroy_ssh_key(self.id)\n        return True\n\n    @classmethod\n    def setup(cls, api_token):\n        cls.manager = DoManager(None, api_token, api_version=2)\n\n    @classmethod\n    def find(cls, name):\n        if not name:\n            return False\n        keys = cls.list_all()\n        for key in keys:\n            if key.name == name:\n                return key\n        return False\n\n    @classmethod\n    def list_all(cls):\n        json = cls.manager.all_ssh_keys()\n        return list(map(cls, json))\n\n    @classmethod\n    def add(cls, name, key_pub):\n        json = cls.manager.new_ssh_key(name, key_pub)\n        return cls(json)\n\n\ndef core(module):\n    def getkeyordie(k):\n        v = module.params[k]\n        if v is None:\n            module.fail_json(msg='Unable to load %s' % k)\n        return v\n\n    api_token = module.params['api_token']\n    changed = True\n    command = module.params['command']\n    state = module.params['state']\n\n    if command == 'droplet':\n        Droplet.setup(api_token)\n        if state in ('active', 'present'):\n\n            # First, try to find a droplet by id.\n            droplet = Droplet.find(id=module.params['id'])\n\n            # If we couldn't find the droplet and the user is allowing unique\n            # hostnames, then check to see if a droplet with the specified\n            # hostname already exists.\n            if not droplet and module.params['unique_name']:\n                droplet = Droplet.find(name=getkeyordie('name'))\n\n            # If both of those attempts failed, then create a new droplet.\n            if not droplet:\n                droplet = Droplet.add(\n                    name=getkeyordie('name'),\n                    size_id=getkeyordie('size_id'),\n                    image_id=getkeyordie('image_id'),\n                    region_id=getkeyordie('region_id'),\n                    ssh_key_ids=module.params['ssh_key_ids'],\n                    virtio=module.params['virtio'],\n                    private_networking=module.params['private_networking'],\n                    backups_enabled=module.params['backups_enabled'],\n                    user_data=module.params.get('user_data'),\n                    ipv6=module.params['ipv6'],\n                )\n\n            if droplet.is_powered_on():\n                changed = False\n\n            droplet.ensure_powered_on(\n                wait=getkeyordie('wait'),\n                wait_timeout=getkeyordie('wait_timeout')\n            )\n\n            module.exit_json(changed=changed, droplet=droplet.to_json())\n\n        elif state in ('absent', 'deleted'):\n            # First, try to find a droplet by id.\n            droplet = Droplet.find(module.params['id'])\n\n            # If we couldn't find the droplet and the user is allowing unique\n            # hostnames, then check to see if a droplet with the specified\n            # hostname already exists.\n            if not droplet and module.params['unique_name']:\n                droplet = Droplet.find(name=getkeyordie('name'))\n\n            if not droplet:\n                module.exit_json(changed=False, msg='The droplet is not found.')\n\n            droplet.destroy()\n            module.exit_json(changed=True)\n\n    elif command == 'ssh':\n        SSH.setup(api_token)\n        name = getkeyordie('name')\n        if state in ('active', 'present'):\n            key = SSH.find(name)\n            if key:\n                module.exit_json(changed=False, ssh_key=key.to_json())\n            key = SSH.add(name, getkeyordie('ssh_pub_key'))\n            module.exit_json(changed=True, ssh_key=key.to_json())\n\n        elif state in ('absent', 'deleted'):\n            key = SSH.find(name)\n            if not key:\n                module.exit_json(changed=False, msg='SSH key with the name of %s is not found.' % name)\n            key.destroy()\n            module.exit_json(changed=True)\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            command=dict(choices=['droplet', 'ssh'], default='droplet'),\n            state=dict(choices=['active', 'present', 'absent', 'deleted'], default='present'),\n            api_token=dict(\n                aliases=['API_TOKEN'],\n                no_log=True,\n                fallback=(env_fallback, ['DO_API_TOKEN', 'DO_API_KEY'])\n            ),\n            name=dict(type='str'),\n            size_id=dict(),\n            image_id=dict(),\n            region_id=dict(),\n            ssh_key_ids=dict(type='list'),\n            virtio=dict(type='bool', default='yes'),\n            private_networking=dict(type='bool', default='no'),\n            backups_enabled=dict(type='bool', default='no'),\n            id=dict(aliases=['droplet_id'], type='int'),\n            unique_name=dict(type='bool', default='no'),\n            user_data=dict(default=None),\n            ipv6=dict(type='bool', default='no'),\n            wait=dict(type='bool', default=True),\n            wait_timeout=dict(default=300, type='int'),\n            ssh_pub_key=dict(type='str'),\n        ),\n        required_together=(\n            ['size_id', 'image_id', 'region_id'],\n        ),\n        mutually_exclusive=(\n            ['size_id', 'ssh_pub_key'],\n            ['image_id', 'ssh_pub_key'],\n            ['region_id', 'ssh_pub_key'],\n        ),\n        required_one_of=(\n            ['id', 'name'],\n        ),\n    )\n    if not HAS_DOPY and not HAS_SIX:\n        module.fail_json(msg='dopy >= 0.3.2 is required for this module. dopy requires six but six is not installed. '\n                             'Make sure both dopy and six are installed.')\n    if not HAS_DOPY:\n        module.fail_json(msg='dopy >= 0.3.2 required for this module')\n\n    try:\n        core(module)\n    except TimeoutError as e:\n        module.fail_json(msg=str(e), id=e.id)\n    except (DoError, Exception) as e:\n        module.fail_json(msg=str(e), exception=traceback.format_exc())\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "digital_ocean.py", "id": "185e31ce960f6e22ad466ba93b761778", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/cloud/digital_ocean/digital_ocean.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}