{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport json\nimport os\nimport re\nimport subprocess\nimport tempfile\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_urlparse,\n    compat_kwargs,\n)\nfrom ..utils import (\n    check_executable,\n    determine_ext,\n    encodeArgument,\n    ExtractorError,\n    get_element_by_id,\n    get_exe_version,\n    is_outdated_version,\n    std_headers,\n)\n\n\ndef cookie_to_dict(cookie):\n    cookie_dict = {\n        'name': cookie.name,\n        'value': cookie.value,\n    }\n    if cookie.port_specified:\n        cookie_dict['port'] = cookie.port\n    if cookie.domain_specified:\n        cookie_dict['domain'] = cookie.domain\n    if cookie.path_specified:\n        cookie_dict['path'] = cookie.path\n    if cookie.expires is not None:\n        cookie_dict['expires'] = cookie.expires\n    if cookie.secure is not None:\n        cookie_dict['secure'] = cookie.secure\n    if cookie.discard is not None:\n        cookie_dict['discard'] = cookie.discard\n    try:\n        if (cookie.has_nonstandard_attr('httpOnly') or\n                cookie.has_nonstandard_attr('httponly') or\n                cookie.has_nonstandard_attr('HttpOnly')):\n            cookie_dict['httponly'] = True\n    except TypeError:\n        pass\n    return cookie_dict\n\n\ndef cookie_jar_to_list(cookie_jar):\n    return [cookie_to_dict(cookie) for cookie in cookie_jar]\n\n\nclass PhantomJSwrapper(object):\n    \n        if 'saveAndExit();' not in jscode:\n            raise ExtractorError('`saveAndExit();` not found in `jscode`')\n        if not html:\n            html = self.extractor._download_webpage(url, video_id, note=note, headers=headers)\n        with open(self._TMP_FILES['html'].name, 'wb') as f:\n            f.write(html.encode('utf-8'))\n\n        self._save_cookies(url)\n\n        replaces = self.options\n        replaces['url'] = url\n        user_agent = headers.get('User-Agent') or std_headers['User-Agent']\n        replaces['ua'] = user_agent.replace('\"', '\\\\\"')\n        replaces['jscode'] = jscode\n\n        for x in self._TMP_FILE_NAMES:\n            replaces[x] = self._TMP_FILES[x].name.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')\n\n        with open(self._TMP_FILES['script'].name, 'wb') as f:\n            f.write(self._TEMPLATE.format(**replaces).encode('utf-8'))\n\n        if video_id is None:\n            self.extractor.to_screen('%s' % (note2,))\n        else:\n            self.extractor.to_screen('%s: %s' % (video_id, note2))\n\n        p = subprocess.Popen([\n            self.exe, '--ssl-protocol=any',\n            self._TMP_FILES['script'].name\n        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        out, err = p.communicate()\n        if p.returncode != 0:\n            raise ExtractorError(\n                'Executing JS failed\\n:' + encodeArgument(err))\n        with open(self._TMP_FILES['html'].name, 'rb') as f:\n            html = f.read().decode('utf-8')\n\n        self._load_cookies()\n\n        return (html, encodeArgument(out))\n\n\nclass OpenloadIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?(?:openload\\.(?:co|io|link)|oload\\.(?:tv|stream))/(?:f|embed)/(?P<id>[a-zA-Z0-9-_]+)'\n\n    _TESTS = [{\n        'url': 'https://openload.co/f/kUEfGclsU9o',\n        'md5': 'bf1c059b004ebc7a256f89408e65c36e',\n        'info_dict': {\n            'id': 'kUEfGclsU9o',\n            'ext': 'mp4',\n            'title': 'skyrim_no-audio_1080.mp4',\n            'thumbnail': r're:^https?://.*\\.jpg$',\n        },\n    }, {\n        'url': 'https://openload.co/embed/rjC09fkPLYs',\n        'info_dict': {\n            'id': 'rjC09fkPLYs',\n            'ext': 'mp4',\n            'title': 'movie.mp4',\n            'thumbnail': r're:^https?://.*\\.jpg$',\n            'subtitles': {\n                'en': [{\n                    'ext': 'vtt',\n                }],\n            },\n        },\n        'params': {\n            'skip_download': True,  \n        },\n    }, {\n        'url': 'https://openload.co/embed/kUEfGclsU9o/skyrim_no-audio_1080.mp4',\n        'only_matching': True,\n    }, {\n        'url': 'https://openload.io/f/ZAn6oz-VZGE/',\n        'only_matching': True,\n    }, {\n        'url': 'https://openload.co/f/_-ztPaZtMhM/',\n        'only_matching': True,\n    }, {\n        \n        \n        'url': 'https://openload.co/embed/Sxz5sADo82g/',\n        'only_matching': True,\n    }, {\n        \n        \n        'url': 'https://openload.co/f/e-Ixz9ZR5L0/',\n        'only_matching': True,\n    }, {\n        'url': 'https://oload.tv/embed/KnG-kKZdcfY/',\n        'only_matching': True,\n    }, {\n        'url': 'http://www.openload.link/f/KnG-kKZdcfY',\n        'only_matching': True,\n    }, {\n        'url': 'https://oload.stream/f/KnG-kKZdcfY',\n        'only_matching': True,\n    }]\n\n    _USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'\n\n    @staticmethod\n    def _extract_urls(webpage):\n        return re.findall(\n            r'<iframe[^>]+src=[\"\\']((?:https?://)?(?:openload\\.(?:co|io)|oload\\.tv)/embed/[a-zA-Z0-9-_]+)',\n            webpage)\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        url_pattern = 'https://openload.co/%%s/%s/' % video_id\n        headers = {\n            'User-Agent': self._USER_AGENT,\n        }\n\n        for path in ('embed', 'f'):\n            page_url = url_pattern % path\n            last = path == 'f'\n            webpage = self._download_webpage(\n                page_url, video_id, 'Downloading %s webpage' % path,\n                headers=headers, fatal=last)\n            if not webpage:\n                continue\n            if 'File not found' in webpage or 'deleted by the owner' in webpage:\n                if not last:\n                    continue\n                raise ExtractorError('File not found', expected=True, video_id=video_id)\n            break\n\n        phantom = PhantomJSwrapper(self, required_version='2.0')\n        webpage, _ = phantom.get(page_url, html=webpage, video_id=video_id, headers=headers)\n\n        decoded_id = (get_element_by_id('streamurl', webpage) or\n                      get_element_by_id('streamuri', webpage) or\n                      get_element_by_id('streamurj', webpage))\n\n        if not decoded_id:\n            raise ExtractorError('Can\\'t find stream URL', video_id=video_id)\n\n        video_url = 'https://openload.co/stream/%s?mime=true' % decoded_id\n\n        title = self._og_search_title(webpage, default=None) or self._search_regex(\n            r'<span[^>]+class=[\"\\']title[\"\\'][^>]*>([^<]+)', webpage,\n            'title', default=None) or self._html_search_meta(\n            'description', webpage, 'title', fatal=True)\n\n        entries = self._parse_html5_media_entries(page_url, webpage, video_id)\n        entry = entries[0] if entries else {}\n        subtitles = entry.get('subtitles')\n\n        info_dict = {\n            'id': video_id,\n            'title': title,\n            'thumbnail': entry.get('thumbnail') or self._og_search_thumbnail(webpage, default=None),\n            'url': video_url,\n            \n            'ext': determine_ext(title, 'mp4'),\n            'subtitles': subtitles,\n            'http_headers': headers,\n        }\n        return info_dict\n", "comments": "PhantomJS wrapper class\n\n    This class is experimental.\n    \"\"\"\n\n    _TEMPLATE = r'''\n        phantom.onError = function(msg, trace) {{\n          var msgStack = ['PHANTOM ERROR: ' + msg];\n          if(trace && trace.length) {{\n            msgStack.push('TRACE:');\n            trace.forEach(function(t) {{\n              msgStack.push(' -> ' + (t.file || t.sourceURL) + ': ' + t.line\n                + (t.function ? ' (in function ' + t.function +')' : ''));\n            }});\n          }}\n          console.error(msgStack.join('\\n'));\n          phantom.exit(1);\n        }};\n        var page = require('webpage').create();\n        var fs = require('fs');\n        var read = {{ mode: 'r', charset: 'utf-8' }};\n        var write = {{ mode: 'w', charset: 'utf-8' }};\n        JSON.parse(fs.read(\"{cookies}\", read)).forEach(function(x) {{\n          phantom.addCookie(x);\n        }});\n        page.settings.resourceTimeout = {timeout};\n        page.settings.userAgent = \"{ua}\";\n        page.onLoadStarted = function() {{\n          page.evaluate(function() {{\n            delete window._phantom;\n            delete window.callPhantom;\n          }});\n        }};\n        var saveAndExit = function() {{\n          fs.write(\"{html}\", page.content, write);\n          fs.write(\"{cookies}\", JSON.stringify(phantom.cookies), write);\n          phantom.exit();\n        }};\n        page.onLoadFinished = function(status) {{\n          if(page.url === \"\") {{\n            page.setContent(fs.read(\"{html}\", read), \"{url}\");\n          }}\n          else {{\n            {jscode}\n          }}\n        }};\n        page.open(\"\");\n    '''\n\n    _TMP_FILE_NAMES = ['script', 'html', 'cookies']\n\n    @staticmethod\n    def _version():\n        return get_exe_version('phantomjs', version_re=r'([0-9.]+)')\n\n    def __init__(self, extractor, required_version=None, timeout=10000):\n        self._TMP_FILES = {}\n\n        self.exe = check_executable('phantomjs', ['-v'])\n        if not self.exe:\n            raise ExtractorError('PhantomJS executable not found in PATH, '\n                                 'download it from http://phantomjs.org',\n                                 expected=True)\n\n        self.extractor = extractor\n\n        if required_version:\n            version = self._version()\n            if is_outdated_version(version, required_version):\n                self.extractor._downloader.report_warning(\n                    'Your copy of PhantomJS is outdated, update it to version '\n                    '%s or newer if you encounter any errors.' % required_version)\n\n        self.options = {\n            'timeout': timeout,\n        }\n        for name in self._TMP_FILE_NAMES:\n            tmp = tempfile.NamedTemporaryFile(delete=False)\n            tmp.close()\n            self._TMP_FILES[name] = tmp\n\n    def __del__(self):\n        for name in self._TMP_FILE_NAMES:\n            try:\n                os.remove(self._TMP_FILES[name].name)\n            except (IOError, OSError, KeyError):\n                pass\n\n    def _save_cookies(self, url):\n        cookies = cookie_jar_to_list(self.extractor._downloader.cookiejar)\n        for cookie in cookies:\n            if 'path' not in cookie:\n                cookie['path'] = '/'\n            if 'domain' not in cookie:\n                cookie['domain'] = compat_urlparse.urlparse(url).netloc\n        with open(self._TMP_FILES['cookies'].name, 'wb') as f:\n            f.write(json.dumps(cookies).encode('utf-8'))\n\n    def _load_cookies(self):\n        with open(self._TMP_FILES['cookies'].name, 'rb') as f:\n            cookies = json.loads(f.read().decode('utf-8'))\n        for cookie in cookies:\n            if cookie['httponly'] is True:\n                cookie['rest'] = {'httpOnly': None}\n            if 'expiry' in cookie:\n                cookie['expire_time'] = cookie['expiry']\n            self.extractor._set_cookie(**compat_kwargs(cookie))\n\n    def get(self, url, html=None, video_id=None, note=None, note2='Executing JS on webpage', headers={}, jscode='saveAndExit();'):\n        \"\"\"\n        Downloads webpage (if needed) and executes JS\n\n        Params:\n            url: website url\n            html: optional, html code of website\n            video_id: video id\n            note: optional, displayed when downloading webpage\n            note2: optional, displayed when executing JS\n            headers: custom http headers\n            jscode: code to be executed when page is loaded\n\n        Returns tuple with:\n            * downloaded website (after JS execution)\n            * anything you print with `console.log` (but not inside `page.execute`!)\n\n        In most cases you don't need to add any `jscode`.\n        It is executed in `page.onLoadFinished`.\n        `saveAndExit();` is mandatory, use it instead of `phantom.exit()`\n        It is possible to wait for some element on the webpage, for example:\n            var check = function() {\n              var elementFound = page.evaluate(function() {\n                return document.querySelector('#b.done') !== null;\n              });\n              if(elementFound)\n                saveAndExit();\n              else\n                window.setTimeout(check, 500);\n            }\n\n            page.evaluate(function(){\n              document.querySelector('#a').click();\n            });\n            check();\n        \n \n# coding: utf-8\n# test subtitles only\n# unavailable via https://openload.co/f/Sxz5sADo82g/, different layout\n# for title and ext\n# unavailable via https://openload.co/embed/e-Ixz9ZR5L0/ but available\n# via https://openload.co/f/e-Ixz9ZR5L0/\n# Seems all videos have extensions in their titles\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport json\nimport os\nimport re\nimport subprocess\nimport tempfile\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_urlparse,\n    compat_kwargs,\n)\nfrom ..utils import (\n    check_executable,\n    determine_ext,\n    encodeArgument,\n    ExtractorError,\n    get_element_by_id,\n    get_exe_version,\n    is_outdated_version,\n    std_headers,\n)\n\n\ndef cookie_to_dict(cookie):\n    cookie_dict = {\n        'name': cookie.name,\n        'value': cookie.value,\n    }\n    if cookie.port_specified:\n        cookie_dict['port'] = cookie.port\n    if cookie.domain_specified:\n        cookie_dict['domain'] = cookie.domain\n    if cookie.path_specified:\n        cookie_dict['path'] = cookie.path\n    if cookie.expires is not None:\n        cookie_dict['expires'] = cookie.expires\n    if cookie.secure is not None:\n        cookie_dict['secure'] = cookie.secure\n    if cookie.discard is not None:\n        cookie_dict['discard'] = cookie.discard\n    try:\n        if (cookie.has_nonstandard_attr('httpOnly') or\n                cookie.has_nonstandard_attr('httponly') or\n                cookie.has_nonstandard_attr('HttpOnly')):\n            cookie_dict['httponly'] = True\n    except TypeError:\n        pass\n    return cookie_dict\n\n\ndef cookie_jar_to_list(cookie_jar):\n    return [cookie_to_dict(cookie) for cookie in cookie_jar]\n\n\nclass PhantomJSwrapper(object):\n    \"\"\"PhantomJS wrapper class\n\n    This class is experimental.\n    \"\"\"\n\n    _TEMPLATE = r'''\n        phantom.onError = function(msg, trace) {{\n          var msgStack = ['PHANTOM ERROR: ' + msg];\n          if(trace && trace.length) {{\n            msgStack.push('TRACE:');\n            trace.forEach(function(t) {{\n              msgStack.push(' -> ' + (t.file || t.sourceURL) + ': ' + t.line\n                + (t.function ? ' (in function ' + t.function +')' : ''));\n            }});\n          }}\n          console.error(msgStack.join('\\n'));\n          phantom.exit(1);\n        }};\n        var page = require('webpage').create();\n        var fs = require('fs');\n        var read = {{ mode: 'r', charset: 'utf-8' }};\n        var write = {{ mode: 'w', charset: 'utf-8' }};\n        JSON.parse(fs.read(\"{cookies}\", read)).forEach(function(x) {{\n          phantom.addCookie(x);\n        }});\n        page.settings.resourceTimeout = {timeout};\n        page.settings.userAgent = \"{ua}\";\n        page.onLoadStarted = function() {{\n          page.evaluate(function() {{\n            delete window._phantom;\n            delete window.callPhantom;\n          }});\n        }};\n        var saveAndExit = function() {{\n          fs.write(\"{html}\", page.content, write);\n          fs.write(\"{cookies}\", JSON.stringify(phantom.cookies), write);\n          phantom.exit();\n        }};\n        page.onLoadFinished = function(status) {{\n          if(page.url === \"\") {{\n            page.setContent(fs.read(\"{html}\", read), \"{url}\");\n          }}\n          else {{\n            {jscode}\n          }}\n        }};\n        page.open(\"\");\n    '''\n\n    _TMP_FILE_NAMES = ['script', 'html', 'cookies']\n\n    @staticmethod\n    def _version():\n        return get_exe_version('phantomjs', version_re=r'([0-9.]+)')\n\n    def __init__(self, extractor, required_version=None, timeout=10000):\n        self._TMP_FILES = {}\n\n        self.exe = check_executable('phantomjs', ['-v'])\n        if not self.exe:\n            raise ExtractorError('PhantomJS executable not found in PATH, '\n                                 'download it from http://phantomjs.org',\n                                 expected=True)\n\n        self.extractor = extractor\n\n        if required_version:\n            version = self._version()\n            if is_outdated_version(version, required_version):\n                self.extractor._downloader.report_warning(\n                    'Your copy of PhantomJS is outdated, update it to version '\n                    '%s or newer if you encounter any errors.' % required_version)\n\n        self.options = {\n            'timeout': timeout,\n        }\n        for name in self._TMP_FILE_NAMES:\n            tmp = tempfile.NamedTemporaryFile(delete=False)\n            tmp.close()\n            self._TMP_FILES[name] = tmp\n\n    def __del__(self):\n        for name in self._TMP_FILE_NAMES:\n            try:\n                os.remove(self._TMP_FILES[name].name)\n            except (IOError, OSError, KeyError):\n                pass\n\n    def _save_cookies(self, url):\n        cookies = cookie_jar_to_list(self.extractor._downloader.cookiejar)\n        for cookie in cookies:\n            if 'path' not in cookie:\n                cookie['path'] = '/'\n            if 'domain' not in cookie:\n                cookie['domain'] = compat_urlparse.urlparse(url).netloc\n        with open(self._TMP_FILES['cookies'].name, 'wb') as f:\n            f.write(json.dumps(cookies).encode('utf-8'))\n\n    def _load_cookies(self):\n        with open(self._TMP_FILES['cookies'].name, 'rb') as f:\n            cookies = json.loads(f.read().decode('utf-8'))\n        for cookie in cookies:\n            if cookie['httponly'] is True:\n                cookie['rest'] = {'httpOnly': None}\n            if 'expiry' in cookie:\n                cookie['expire_time'] = cookie['expiry']\n            self.extractor._set_cookie(**compat_kwargs(cookie))\n\n    def get(self, url, html=None, video_id=None, note=None, note2='Executing JS on webpage', headers={}, jscode='saveAndExit();'):\n        \"\"\"\n        Downloads webpage (if needed) and executes JS\n\n        Params:\n            url: website url\n            html: optional, html code of website\n            video_id: video id\n            note: optional, displayed when downloading webpage\n            note2: optional, displayed when executing JS\n            headers: custom http headers\n            jscode: code to be executed when page is loaded\n\n        Returns tuple with:\n            * downloaded website (after JS execution)\n            * anything you print with `console.log` (but not inside `page.execute`!)\n\n        In most cases you don't need to add any `jscode`.\n        It is executed in `page.onLoadFinished`.\n        `saveAndExit();` is mandatory, use it instead of `phantom.exit()`\n        It is possible to wait for some element on the webpage, for example:\n            var check = function() {\n              var elementFound = page.evaluate(function() {\n                return document.querySelector('#b.done') !== null;\n              });\n              if(elementFound)\n                saveAndExit();\n              else\n                window.setTimeout(check, 500);\n            }\n\n            page.evaluate(function(){\n              document.querySelector('#a').click();\n            });\n            check();\n        \"\"\"\n        if 'saveAndExit();' not in jscode:\n            raise ExtractorError('`saveAndExit();` not found in `jscode`')\n        if not html:\n            html = self.extractor._download_webpage(url, video_id, note=note, headers=headers)\n        with open(self._TMP_FILES['html'].name, 'wb') as f:\n            f.write(html.encode('utf-8'))\n\n        self._save_cookies(url)\n\n        replaces = self.options\n        replaces['url'] = url\n        user_agent = headers.get('User-Agent') or std_headers['User-Agent']\n        replaces['ua'] = user_agent.replace('\"', '\\\\\"')\n        replaces['jscode'] = jscode\n\n        for x in self._TMP_FILE_NAMES:\n            replaces[x] = self._TMP_FILES[x].name.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')\n\n        with open(self._TMP_FILES['script'].name, 'wb') as f:\n            f.write(self._TEMPLATE.format(**replaces).encode('utf-8'))\n\n        if video_id is None:\n            self.extractor.to_screen('%s' % (note2,))\n        else:\n            self.extractor.to_screen('%s: %s' % (video_id, note2))\n\n        p = subprocess.Popen([\n            self.exe, '--ssl-protocol=any',\n            self._TMP_FILES['script'].name\n        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        out, err = p.communicate()\n        if p.returncode != 0:\n            raise ExtractorError(\n                'Executing JS failed\\n:' + encodeArgument(err))\n        with open(self._TMP_FILES['html'].name, 'rb') as f:\n            html = f.read().decode('utf-8')\n\n        self._load_cookies()\n\n        return (html, encodeArgument(out))\n\n\nclass OpenloadIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?(?:openload\\.(?:co|io|link)|oload\\.(?:tv|stream))/(?:f|embed)/(?P<id>[a-zA-Z0-9-_]+)'\n\n    _TESTS = [{\n        'url': 'https://openload.co/f/kUEfGclsU9o',\n        'md5': 'bf1c059b004ebc7a256f89408e65c36e',\n        'info_dict': {\n            'id': 'kUEfGclsU9o',\n            'ext': 'mp4',\n            'title': 'skyrim_no-audio_1080.mp4',\n            'thumbnail': r're:^https?://.*\\.jpg$',\n        },\n    }, {\n        'url': 'https://openload.co/embed/rjC09fkPLYs',\n        'info_dict': {\n            'id': 'rjC09fkPLYs',\n            'ext': 'mp4',\n            'title': 'movie.mp4',\n            'thumbnail': r're:^https?://.*\\.jpg$',\n            'subtitles': {\n                'en': [{\n                    'ext': 'vtt',\n                }],\n            },\n        },\n        'params': {\n            'skip_download': True,  # test subtitles only\n        },\n    }, {\n        'url': 'https://openload.co/embed/kUEfGclsU9o/skyrim_no-audio_1080.mp4',\n        'only_matching': True,\n    }, {\n        'url': 'https://openload.io/f/ZAn6oz-VZGE/',\n        'only_matching': True,\n    }, {\n        'url': 'https://openload.co/f/_-ztPaZtMhM/',\n        'only_matching': True,\n    }, {\n        # unavailable via https://openload.co/f/Sxz5sADo82g/, different layout\n        # for title and ext\n        'url': 'https://openload.co/embed/Sxz5sADo82g/',\n        'only_matching': True,\n    }, {\n        # unavailable via https://openload.co/embed/e-Ixz9ZR5L0/ but available\n        # via https://openload.co/f/e-Ixz9ZR5L0/\n        'url': 'https://openload.co/f/e-Ixz9ZR5L0/',\n        'only_matching': True,\n    }, {\n        'url': 'https://oload.tv/embed/KnG-kKZdcfY/',\n        'only_matching': True,\n    }, {\n        'url': 'http://www.openload.link/f/KnG-kKZdcfY',\n        'only_matching': True,\n    }, {\n        'url': 'https://oload.stream/f/KnG-kKZdcfY',\n        'only_matching': True,\n    }]\n\n    _USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'\n\n    @staticmethod\n    def _extract_urls(webpage):\n        return re.findall(\n            r'<iframe[^>]+src=[\"\\']((?:https?://)?(?:openload\\.(?:co|io)|oload\\.tv)/embed/[a-zA-Z0-9-_]+)',\n            webpage)\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        url_pattern = 'https://openload.co/%%s/%s/' % video_id\n        headers = {\n            'User-Agent': self._USER_AGENT,\n        }\n\n        for path in ('embed', 'f'):\n            page_url = url_pattern % path\n            last = path == 'f'\n            webpage = self._download_webpage(\n                page_url, video_id, 'Downloading %s webpage' % path,\n                headers=headers, fatal=last)\n            if not webpage:\n                continue\n            if 'File not found' in webpage or 'deleted by the owner' in webpage:\n                if not last:\n                    continue\n                raise ExtractorError('File not found', expected=True, video_id=video_id)\n            break\n\n        phantom = PhantomJSwrapper(self, required_version='2.0')\n        webpage, _ = phantom.get(page_url, html=webpage, video_id=video_id, headers=headers)\n\n        decoded_id = (get_element_by_id('streamurl', webpage) or\n                      get_element_by_id('streamuri', webpage) or\n                      get_element_by_id('streamurj', webpage))\n\n        if not decoded_id:\n            raise ExtractorError('Can\\'t find stream URL', video_id=video_id)\n\n        video_url = 'https://openload.co/stream/%s?mime=true' % decoded_id\n\n        title = self._og_search_title(webpage, default=None) or self._search_regex(\n            r'<span[^>]+class=[\"\\']title[\"\\'][^>]*>([^<]+)', webpage,\n            'title', default=None) or self._html_search_meta(\n            'description', webpage, 'title', fatal=True)\n\n        entries = self._parse_html5_media_entries(page_url, webpage, video_id)\n        entry = entries[0] if entries else {}\n        subtitles = entry.get('subtitles')\n\n        info_dict = {\n            'id': video_id,\n            'title': title,\n            'thumbnail': entry.get('thumbnail') or self._og_search_thumbnail(webpage, default=None),\n            'url': video_url,\n            # Seems all videos have extensions in their titles\n            'ext': determine_ext(title, 'mp4'),\n            'subtitles': subtitles,\n            'http_headers': headers,\n        }\n        return info_dict\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "openload.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/openload.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}