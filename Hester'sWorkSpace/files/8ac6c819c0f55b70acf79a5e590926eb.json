{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_xpath,\n)\nfrom ..utils import (\n    ExtractorError,\n    find_xpath_attr,\n    fix_xml_ampersands,\n    float_or_none,\n    HEADRequest,\n    RegexNotFoundError,\n    sanitized_Request,\n    strip_or_none,\n    timeconvert,\n    try_get,\n    unescapeHTML,\n    update_url_query,\n    url_basename,\n    xpath_text,\n)\n\n\ndef _media_xml_tag(tag):\n    return '{http://search.yahoo.com/mrss/}%s' % tag\n\n\nclass MTVServicesInfoExtractor(InfoExtractor):\n    _MOBILE_TEMPLATE = None\n    _LANG = None\n\n    @staticmethod\n    def _id_from_uri(uri):\n        return uri.split(':')[-1]\n\n    @staticmethod\n    def _remove_template_parameter(url):\n        \n        return re.sub(r'&[^=]*?={.*?}(?=(&|$))', '', url)\n\n    def _get_feed_url(self, uri):\n        return self._FEED_URL\n\n    def _get_thumbnail_url(self, uri, itemdoc):\n        search_path = '%s/%s' % (_media_xml_tag('group'), _media_xml_tag('thumbnail'))\n        thumb_node = itemdoc.find(search_path)\n        if thumb_node is None:\n            return None\n        return thumb_node.get('url') or thumb_node.text or None\n\n    def _extract_mobile_video_formats(self, mtvn_id):\n        webpage_url = self._MOBILE_TEMPLATE % mtvn_id\n        req = sanitized_Request(webpage_url)\n        \n        req.add_header('User-Agent', 'curl/7')\n        webpage = self._download_webpage(req, mtvn_id,\n                                         'Downloading mobile page')\n        metrics_url = unescapeHTML(self._search_regex(r'<a href=\"(http://metrics.+?)\"', webpage, 'url'))\n        req = HEADRequest(metrics_url)\n        response = self._request_webpage(req, mtvn_id, 'Resolving url')\n        url = response.geturl()\n        \n        url = re.sub(r'.+pxE=mp4', 'http://mtvnmobile.vo.llnwd.net/kip0/_pxn=0+_pxK=18639+_pxE=mp4', url, 1)\n        return [{'url': url, 'ext': 'mp4'}]\n\n    def _extract_video_formats(self, mdoc, mtvn_id, video_id):\n        if re.match(r'.*/(error_country_block\\.swf|geoblock\\.mp4|copyright_error\\.flv(?:\\?geo\\b.+?)?)$', mdoc.find('.//src').text) is not None:\n            if mtvn_id is not None and self._MOBILE_TEMPLATE is not None:\n                self.to_screen('The normal version is not available from your '\n                               'country, trying with the mobile version')\n                return self._extract_mobile_video_formats(mtvn_id)\n            raise ExtractorError('This video is not available from your country.',\n                                 expected=True)\n\n        formats = []\n        for rendition in mdoc.findall('.//rendition'):\n            if rendition.get('method') == 'hls':\n                hls_url = rendition.find('./src').text\n                formats.extend(self._extract_m3u8_formats(\n                    hls_url, video_id, ext='mp4', entry_protocol='m3u8_native',\n                    m3u8_id='hls', fatal=False))\n            else:\n                \n                try:\n                    _, _, ext = rendition.attrib['type'].partition('/')\n                    rtmp_video_url = rendition.find('./src').text\n                    if 'error_not_available.swf' in rtmp_video_url:\n                        raise ExtractorError(\n                            '%s said: video is not available' % self.IE_NAME,\n                            expected=True)\n                    if rtmp_video_url.endswith('siteunavail.png'):\n                        continue\n                    formats.extend([{\n                        'ext': 'flv' if rtmp_video_url.startswith('rtmp') else ext,\n                        'url': rtmp_video_url,\n                        'format_id': '-'.join(filter(None, [\n                            'rtmp' if rtmp_video_url.startswith('rtmp') else None,\n                            rendition.get('bitrate')])),\n                        'width': int(rendition.get('width')),\n                        'height': int(rendition.get('height')),\n                    }])\n                except (KeyError, TypeError):\n                    raise ExtractorError('Invalid rendition field.')\n        if formats:\n            self._sort_formats(formats)\n        return formats\n\n    def _extract_subtitles(self, mdoc, mtvn_id):\n        subtitles = {}\n        for transcript in mdoc.findall('.//transcript'):\n            if transcript.get('kind') != 'captions':\n                continue\n            lang = transcript.get('srclang')\n            for typographic in transcript.findall('./typographic'):\n                sub_src = typographic.get('src')\n                if not sub_src:\n                    continue\n                ext = typographic.get('format')\n                if ext == 'cea-608':\n                    ext = 'scc'\n                subtitles.setdefault(lang, []).append({\n                    'url': compat_str(sub_src),\n                    'ext': ext\n                })\n        return subtitles\n\n    def _get_video_info(self, itemdoc, use_hls=True):\n        uri = itemdoc.find('guid').text\n        video_id = self._id_from_uri(uri)\n        self.report_extraction(video_id)\n        content_el = itemdoc.find('%s/%s' % (_media_xml_tag('group'), _media_xml_tag('content')))\n        mediagen_url = self._remove_template_parameter(content_el.attrib['url'])\n        mediagen_url = mediagen_url.replace('device={device}', '')\n        if 'acceptMethods' not in mediagen_url:\n            mediagen_url += '&' if '?' in mediagen_url else '?'\n            mediagen_url += 'acceptMethods='\n            mediagen_url += 'hls' if use_hls else 'fms'\n\n        mediagen_doc = self._download_xml(\n            mediagen_url, video_id, 'Downloading video urls', fatal=False)\n\n        if mediagen_doc is False:\n            return None\n\n        item = mediagen_doc.find('./video/item')\n        if item is not None and item.get('type') == 'text':\n            message = '%s returned error: ' % self.IE_NAME\n            if item.get('code') is not None:\n                message += '%s - ' % item.get('code')\n            message += item.text\n            raise ExtractorError(message, expected=True)\n\n        description = strip_or_none(xpath_text(itemdoc, 'description'))\n\n        timestamp = timeconvert(xpath_text(itemdoc, 'pubDate'))\n\n        title_el = None\n        if title_el is None:\n            title_el = find_xpath_attr(\n                itemdoc, './/{http://search.yahoo.com/mrss/}category',\n                'scheme', 'urn:mtvn:video_title')\n        if title_el is None:\n            title_el = itemdoc.find(compat_xpath('.//{http://search.yahoo.com/mrss/}title'))\n        if title_el is None:\n            title_el = itemdoc.find(compat_xpath('.//title'))\n            if title_el.text is None:\n                title_el = None\n\n        title = title_el.text\n        if title is None:\n            raise ExtractorError('Could not find video title')\n        title = title.strip()\n\n        \n        mtvn_id = None\n        mtvn_id_node = find_xpath_attr(itemdoc, './/{http://search.yahoo.com/mrss/}category',\n                                       'scheme', 'urn:mtvn:id')\n        if mtvn_id_node is not None:\n            mtvn_id = mtvn_id_node.text\n\n        formats = self._extract_video_formats(mediagen_doc, mtvn_id, video_id)\n\n        \n        \n        if not formats:\n            return None\n\n        self._sort_formats(formats)\n\n        return {\n            'title': title,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(mediagen_doc, mtvn_id),\n            'id': video_id,\n            'thumbnail': self._get_thumbnail_url(uri, itemdoc),\n            'description': description,\n            'duration': float_or_none(content_el.attrib.get('duration')),\n            'timestamp': timestamp,\n        }\n\n    def _get_feed_query(self, uri):\n        data = {'uri': uri}\n        if self._LANG:\n            data['lang'] = self._LANG\n        return data\n\n    def _get_videos_info(self, uri, use_hls=True):\n        video_id = self._id_from_uri(uri)\n        feed_url = self._get_feed_url(uri)\n        info_url = update_url_query(feed_url, self._get_feed_query(uri))\n        return self._get_videos_info_from_url(info_url, video_id, use_hls)\n\n    def _get_videos_info_from_url(self, url, video_id, use_hls=True):\n        idoc = self._download_xml(\n            url, video_id,\n            'Downloading info', transform_source=fix_xml_ampersands)\n\n        title = xpath_text(idoc, './channel/title')\n        description = xpath_text(idoc, './channel/description')\n\n        entries = []\n        for item in idoc.findall('.//item'):\n            info = self._get_video_info(item, use_hls)\n            if info:\n                entries.append(info)\n\n        return self.playlist_result(\n            entries, playlist_title=title, playlist_description=description)\n\n    def _extract_triforce_mgid(self, webpage, data_zone=None, video_id=None):\n        triforce_feed = self._parse_json(self._search_regex(\n            r'triforceManifestFeed\\s*=\\s*({.+?})\\s*;\\s*\\n', webpage,\n            'triforce feed', default='{}'), video_id, fatal=False)\n\n        data_zone = self._search_regex(\n            r'data-zone=([\"\\'])(?P<zone>.+?_lc_promo.*?)\\1', webpage,\n            'data zone', default=data_zone, group='zone')\n\n        feed_url = try_get(\n            triforce_feed, lambda x: x['manifest']['zones'][data_zone]['feed'],\n            compat_str)\n        if not feed_url:\n            return\n\n        feed = self._download_json(feed_url, video_id, fatal=False)\n        if not feed:\n            return\n\n        return try_get(feed, lambda x: x['result']['data']['id'], compat_str)\n\n    def _extract_mgid(self, webpage):\n        try:\n            \n            \n            og_url = self._og_search_video_url(webpage)\n            mgid = url_basename(og_url)\n            if mgid.endswith('.swf'):\n                mgid = mgid[:-4]\n        except RegexNotFoundError:\n            mgid = None\n\n        if mgid is None or ':' not in mgid:\n            mgid = self._search_regex(\n                [r'data-mgid=\"(.*?)\"', r'swfobject\\.embedSWF\\(\".*?(mgid:.*?)\"'],\n                webpage, 'mgid', default=None)\n\n        if not mgid:\n            sm4_embed = self._html_search_meta(\n                'sm4:video:embed', webpage, 'sm4 embed', default='')\n            mgid = self._search_regex(\n                r'embed/(mgid:.+?)[\"\\'&?/]', sm4_embed, 'mgid', default=None)\n\n        if not mgid:\n            mgid = self._extract_triforce_mgid(webpage)\n\n        return mgid\n\n    def _real_extract(self, url):\n        title = url_basename(url)\n        webpage = self._download_webpage(url, title)\n        mgid = self._extract_mgid(webpage)\n        videos_info = self._get_videos_info(mgid)\n        return videos_info\n\n\nclass MTVServicesEmbeddedIE(MTVServicesInfoExtractor):\n    IE_NAME = 'mtvservices:embedded'\n    _VALID_URL = r'https?://media\\.mtvnservices\\.com/embed/(?P<mgid>.+?)(\\?|/|$)'\n\n    _TEST = {\n        \n        'url': 'http://media.mtvnservices.com/embed/mgid:uma:video:mtv.com:1043906/cp~vid%3D1043906%26uri%3Dmgid%3Auma%3Avideo%3Amtv.com%3A1043906',\n        'md5': 'cb349b21a7897164cede95bd7bf3fbb9',\n        'info_dict': {\n            'id': '1043906',\n            'ext': 'mp4',\n            'title': 'Peter Dinklage Sums Up \\'Game Of Thrones\\' In 45 Seconds',\n            'description': '\"Sexy sexy sexy, stabby stabby stabby, beautiful language,\" says Peter Dinklage as he tries summarizing \"Game of Thrones\" in under a minute.',\n            'timestamp': 1400126400,\n            'upload_date': '20140515',\n        },\n    }\n\n    @staticmethod\n    def _extract_url(webpage):\n        mobj = re.search(\n            r'<iframe[^>]+?src=([\"\\'])(?P<url>(?:https?:)?//media.mtvnservices.com/embed/.+?)\\1', webpage)\n        if mobj:\n            return mobj.group('url')\n\n    def _get_feed_url(self, uri):\n        video_id = self._id_from_uri(uri)\n        config = self._download_json(\n            'http://media.mtvnservices.com/pmt/e1/access/index.html?uri=%s&configtype=edge' % uri, video_id)\n        return self._remove_template_parameter(config['feedWithQueryParams'])\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        mgid = mobj.group('mgid')\n        return self._get_videos_info(mgid)\n\n\nclass MTVIE(MTVServicesInfoExtractor):\n    IE_NAME = 'mtv'\n    _VALID_URL = r'https?://(?:www\\.)?mtv\\.com/(?:video-clips|(?:full-)?episodes)/(?P<id>[^/?\n    _FEED_URL = 'http://www.mtv.com/feeds/mrss/'\n\n    _TESTS = [{\n        'url': 'http://www.mtv.com/video-clips/vl8qof/unlocking-the-truth-trailer',\n        'md5': '1edbcdf1e7628e414a8c5dcebca3d32b',\n        'info_dict': {\n            'id': '5e14040d-18a4-47c4-a582-43ff602de88e',\n            'ext': 'mp4',\n            'title': 'Unlocking The Truth|July 18, 2016|1|101|Trailer',\n            'description': '\"Unlocking the Truth\" premieres August 17th at 11/10c.',\n            'timestamp': 1468846800,\n            'upload_date': '20160718',\n        },\n    }, {\n        'url': 'http://www.mtv.com/full-episodes/94tujl/unlocking-the-truth-gates-of-hell-season-1-ep-101',\n        'only_matching': True,\n    }, {\n        'url': 'http://www.mtv.com/episodes/g8xu7q/teen-mom-2-breaking-the-wall-season-7-ep-713',\n        'only_matching': True,\n    }]\n\n\nclass MTV81IE(InfoExtractor):\n    IE_NAME = 'mtv81'\n    _VALID_URL = r'https?://(?:www\\.)?mtv81\\.com/videos/(?P<id>[^/?\n\n    _TEST = {\n        'url': 'http://www.mtv81.com/videos/artist-to-watch/the-godfather-of-japanese-hip-hop-segment-1/',\n        'md5': '1edbcdf1e7628e414a8c5dcebca3d32b',\n        'info_dict': {\n            'id': '5e14040d-18a4-47c4-a582-43ff602de88e',\n            'ext': 'mp4',\n            'title': 'Unlocking The Truth|July 18, 2016|1|101|Trailer',\n            'description': '\"Unlocking the Truth\" premieres August 17th at 11/10c.',\n            'timestamp': 1468846800,\n            'upload_date': '20160718',\n        },\n    }\n\n    def _extract_mgid(self, webpage):\n        return self._search_regex(\n            r'getTheVideo\\(([\"\\'])(?P<id>mgid:.+?)\\1', webpage,\n            'mgid', group='id')\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        webpage = self._download_webpage(url, video_id)\n        mgid = self._extract_mgid(webpage)\n        return self.url_result('http://media.mtvnservices.com/embed/%s' % mgid)\n\n\nclass MTVVideoIE(MTVServicesInfoExtractor):\n    IE_NAME = 'mtv:video'\n    _VALID_URL = r\n\n    _FEED_URL = 'http://www.mtv.com/player/embed/AS3/rss/'\n\n    _TESTS = [\n        {\n            'url': 'http://www.mtv.com/videos/misc/853555/ours-vh1-storytellers.jhtml',\n            'md5': '850f3f143316b1e71fa56a4edfd6e0f8',\n            'info_dict': {\n                'id': '853555',\n                'ext': 'mp4',\n                'title': 'Taylor Swift - \"Ours (VH1 Storytellers)\"',\n                'description': 'Album: Taylor Swift performs \"Ours\" for VH1 Storytellers at Harvey Mudd College.',\n                'timestamp': 1352610000,\n                'upload_date': '20121111',\n            },\n        },\n    ]\n\n    def _get_thumbnail_url(self, uri, itemdoc):\n        return 'http://mtv.mtvnimages.com/uri/' + uri\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        video_id = mobj.group('videoid')\n        uri = mobj.groupdict().get('mgid')\n        if uri is None:\n            webpage = self._download_webpage(url, video_id)\n\n            \n            m_vevo = re.search(\n                r'(?s)isVevoVideo = true;.*?vevoVideoId = \"(.*?)\";', webpage)\n            if m_vevo:\n                vevo_id = m_vevo.group(1)\n                self.to_screen('Vevo video detected: %s' % vevo_id)\n                return self.url_result('vevo:%s' % vevo_id, ie='Vevo')\n\n            uri = self._html_search_regex(r'/uri/(.*?)\\?', webpage, 'uri')\n        return self._get_videos_info(uri)\n\n\nclass MTVDEIE(MTVServicesInfoExtractor):\n    IE_NAME = 'mtv.de'\n    _VALID_URL = r'https?://(?:www\\.)?mtv\\.de/(?:artists|shows|news)/(?:[^/]+/)*(?P<id>\\d+)-[^/\n    _TESTS = [{\n        'url': 'http://www.mtv.de/artists/10571-cro/videos/61131-traum',\n        'info_dict': {\n            'id': 'music_video-a50bc5f0b3aa4b3190aa',\n            'ext': 'flv',\n            'title': 'MusicVideo_cro-traum',\n            'description': 'Cro - Traum',\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n        'skip': 'Blocked at Travis CI',\n    }, {\n        \n        'url': 'http://www.mtv.de/shows/933-teen-mom-2/staffeln/5353/folgen/63565-enthullungen',\n        'info_dict': {\n            'id': 'local_playlist-f5ae778b9832cc837189',\n            'ext': 'flv',\n            'title': 'Episode_teen-mom-2_shows_season-5_episode-1_full-episode_part1',\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n        'skip': 'Blocked at Travis CI',\n    }, {\n        'url': 'http://www.mtv.de/news/77491-mtv-movies-spotlight-pixels-teil-3',\n        'info_dict': {\n            'id': 'local_playlist-4e760566473c4c8c5344',\n            'ext': 'mp4',\n            'title': 'Article_mtv-movies-spotlight-pixels-teil-3_short-clips_part1',\n            'description': 'MTV Movies Supercut',\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n        'skip': 'Das Video kann zur Zeit nicht abgespielt werden.',\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id)\n\n        playlist = self._parse_json(\n            self._search_regex(\n                r'window\\.pagePlaylist\\s*=\\s*(\\[.+?\\]);\\n', webpage, 'page playlist'),\n            video_id)\n\n        def _mrss_url(item):\n            return item['mrss'] + item.get('mrssvars', '')\n\n        \n        if len(playlist) == 1:\n            return self._get_videos_info_from_url(_mrss_url(playlist[0]), video_id)\n\n        for item in playlist:\n            item_id = item.get('id')\n            if item_id and compat_str(item_id) == video_id:\n                return self._get_videos_info_from_url(_mrss_url(item), video_id)\n", "comments": "(?x)^https?://\n        (?:(?:www\\.)?mtv\\.com/videos/.+?/(?P<videoid>[0-9]+)/[^/]+$|\n           m\\.mtv\\.com/videos/video\\.rbml\\?.*?id=(?P<mgid>[^&]+))\n)\n# Remove the templates, like &device={device}\n# Otherwise we get a webpage that would execute some javascript\n# Transform the url to get the best quality:\n# fms\n# This a short id that's used in the webpage urls\n# Some parts of complete video may be missing (e.g. missing Act 3 in\n# http://www.southpark.de/alle-episoden/s14e01-sexual-healing)\n# the url can be http://media.mtvnservices.com/fb/{mgid}.swf\n# or http://media.mtvnservices.com/{mgid}\n# From http://www.thewrap.com/peter-dinklage-sums-up-game-of-thrones-in-45-seconds-video/\n#.]+)'\n#.]+)'\n# Some videos come from Vevo.com\n#?]+/*(?:[#?].*)?$'\n# rtmp download\n# mediagen URL without query (e.g. http://videos.mtvnn.com/mediagen/e865da714c166d18d6f80893195fcb97)\n# rtmp download\n# rtmp download\n# news pages contain single video in playlist with different id\n", "content": "from __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_xpath,\n)\nfrom ..utils import (\n    ExtractorError,\n    find_xpath_attr,\n    fix_xml_ampersands,\n    float_or_none,\n    HEADRequest,\n    RegexNotFoundError,\n    sanitized_Request,\n    strip_or_none,\n    timeconvert,\n    try_get,\n    unescapeHTML,\n    update_url_query,\n    url_basename,\n    xpath_text,\n)\n\n\ndef _media_xml_tag(tag):\n    return '{http://search.yahoo.com/mrss/}%s' % tag\n\n\nclass MTVServicesInfoExtractor(InfoExtractor):\n    _MOBILE_TEMPLATE = None\n    _LANG = None\n\n    @staticmethod\n    def _id_from_uri(uri):\n        return uri.split(':')[-1]\n\n    @staticmethod\n    def _remove_template_parameter(url):\n        # Remove the templates, like &device={device}\n        return re.sub(r'&[^=]*?={.*?}(?=(&|$))', '', url)\n\n    def _get_feed_url(self, uri):\n        return self._FEED_URL\n\n    def _get_thumbnail_url(self, uri, itemdoc):\n        search_path = '%s/%s' % (_media_xml_tag('group'), _media_xml_tag('thumbnail'))\n        thumb_node = itemdoc.find(search_path)\n        if thumb_node is None:\n            return None\n        return thumb_node.get('url') or thumb_node.text or None\n\n    def _extract_mobile_video_formats(self, mtvn_id):\n        webpage_url = self._MOBILE_TEMPLATE % mtvn_id\n        req = sanitized_Request(webpage_url)\n        # Otherwise we get a webpage that would execute some javascript\n        req.add_header('User-Agent', 'curl/7')\n        webpage = self._download_webpage(req, mtvn_id,\n                                         'Downloading mobile page')\n        metrics_url = unescapeHTML(self._search_regex(r'<a href=\"(http://metrics.+?)\"', webpage, 'url'))\n        req = HEADRequest(metrics_url)\n        response = self._request_webpage(req, mtvn_id, 'Resolving url')\n        url = response.geturl()\n        # Transform the url to get the best quality:\n        url = re.sub(r'.+pxE=mp4', 'http://mtvnmobile.vo.llnwd.net/kip0/_pxn=0+_pxK=18639+_pxE=mp4', url, 1)\n        return [{'url': url, 'ext': 'mp4'}]\n\n    def _extract_video_formats(self, mdoc, mtvn_id, video_id):\n        if re.match(r'.*/(error_country_block\\.swf|geoblock\\.mp4|copyright_error\\.flv(?:\\?geo\\b.+?)?)$', mdoc.find('.//src').text) is not None:\n            if mtvn_id is not None and self._MOBILE_TEMPLATE is not None:\n                self.to_screen('The normal version is not available from your '\n                               'country, trying with the mobile version')\n                return self._extract_mobile_video_formats(mtvn_id)\n            raise ExtractorError('This video is not available from your country.',\n                                 expected=True)\n\n        formats = []\n        for rendition in mdoc.findall('.//rendition'):\n            if rendition.get('method') == 'hls':\n                hls_url = rendition.find('./src').text\n                formats.extend(self._extract_m3u8_formats(\n                    hls_url, video_id, ext='mp4', entry_protocol='m3u8_native',\n                    m3u8_id='hls', fatal=False))\n            else:\n                # fms\n                try:\n                    _, _, ext = rendition.attrib['type'].partition('/')\n                    rtmp_video_url = rendition.find('./src').text\n                    if 'error_not_available.swf' in rtmp_video_url:\n                        raise ExtractorError(\n                            '%s said: video is not available' % self.IE_NAME,\n                            expected=True)\n                    if rtmp_video_url.endswith('siteunavail.png'):\n                        continue\n                    formats.extend([{\n                        'ext': 'flv' if rtmp_video_url.startswith('rtmp') else ext,\n                        'url': rtmp_video_url,\n                        'format_id': '-'.join(filter(None, [\n                            'rtmp' if rtmp_video_url.startswith('rtmp') else None,\n                            rendition.get('bitrate')])),\n                        'width': int(rendition.get('width')),\n                        'height': int(rendition.get('height')),\n                    }])\n                except (KeyError, TypeError):\n                    raise ExtractorError('Invalid rendition field.')\n        if formats:\n            self._sort_formats(formats)\n        return formats\n\n    def _extract_subtitles(self, mdoc, mtvn_id):\n        subtitles = {}\n        for transcript in mdoc.findall('.//transcript'):\n            if transcript.get('kind') != 'captions':\n                continue\n            lang = transcript.get('srclang')\n            for typographic in transcript.findall('./typographic'):\n                sub_src = typographic.get('src')\n                if not sub_src:\n                    continue\n                ext = typographic.get('format')\n                if ext == 'cea-608':\n                    ext = 'scc'\n                subtitles.setdefault(lang, []).append({\n                    'url': compat_str(sub_src),\n                    'ext': ext\n                })\n        return subtitles\n\n    def _get_video_info(self, itemdoc, use_hls=True):\n        uri = itemdoc.find('guid').text\n        video_id = self._id_from_uri(uri)\n        self.report_extraction(video_id)\n        content_el = itemdoc.find('%s/%s' % (_media_xml_tag('group'), _media_xml_tag('content')))\n        mediagen_url = self._remove_template_parameter(content_el.attrib['url'])\n        mediagen_url = mediagen_url.replace('device={device}', '')\n        if 'acceptMethods' not in mediagen_url:\n            mediagen_url += '&' if '?' in mediagen_url else '?'\n            mediagen_url += 'acceptMethods='\n            mediagen_url += 'hls' if use_hls else 'fms'\n\n        mediagen_doc = self._download_xml(\n            mediagen_url, video_id, 'Downloading video urls', fatal=False)\n\n        if mediagen_doc is False:\n            return None\n\n        item = mediagen_doc.find('./video/item')\n        if item is not None and item.get('type') == 'text':\n            message = '%s returned error: ' % self.IE_NAME\n            if item.get('code') is not None:\n                message += '%s - ' % item.get('code')\n            message += item.text\n            raise ExtractorError(message, expected=True)\n\n        description = strip_or_none(xpath_text(itemdoc, 'description'))\n\n        timestamp = timeconvert(xpath_text(itemdoc, 'pubDate'))\n\n        title_el = None\n        if title_el is None:\n            title_el = find_xpath_attr(\n                itemdoc, './/{http://search.yahoo.com/mrss/}category',\n                'scheme', 'urn:mtvn:video_title')\n        if title_el is None:\n            title_el = itemdoc.find(compat_xpath('.//{http://search.yahoo.com/mrss/}title'))\n        if title_el is None:\n            title_el = itemdoc.find(compat_xpath('.//title'))\n            if title_el.text is None:\n                title_el = None\n\n        title = title_el.text\n        if title is None:\n            raise ExtractorError('Could not find video title')\n        title = title.strip()\n\n        # This a short id that's used in the webpage urls\n        mtvn_id = None\n        mtvn_id_node = find_xpath_attr(itemdoc, './/{http://search.yahoo.com/mrss/}category',\n                                       'scheme', 'urn:mtvn:id')\n        if mtvn_id_node is not None:\n            mtvn_id = mtvn_id_node.text\n\n        formats = self._extract_video_formats(mediagen_doc, mtvn_id, video_id)\n\n        # Some parts of complete video may be missing (e.g. missing Act 3 in\n        # http://www.southpark.de/alle-episoden/s14e01-sexual-healing)\n        if not formats:\n            return None\n\n        self._sort_formats(formats)\n\n        return {\n            'title': title,\n            'formats': formats,\n            'subtitles': self._extract_subtitles(mediagen_doc, mtvn_id),\n            'id': video_id,\n            'thumbnail': self._get_thumbnail_url(uri, itemdoc),\n            'description': description,\n            'duration': float_or_none(content_el.attrib.get('duration')),\n            'timestamp': timestamp,\n        }\n\n    def _get_feed_query(self, uri):\n        data = {'uri': uri}\n        if self._LANG:\n            data['lang'] = self._LANG\n        return data\n\n    def _get_videos_info(self, uri, use_hls=True):\n        video_id = self._id_from_uri(uri)\n        feed_url = self._get_feed_url(uri)\n        info_url = update_url_query(feed_url, self._get_feed_query(uri))\n        return self._get_videos_info_from_url(info_url, video_id, use_hls)\n\n    def _get_videos_info_from_url(self, url, video_id, use_hls=True):\n        idoc = self._download_xml(\n            url, video_id,\n            'Downloading info', transform_source=fix_xml_ampersands)\n\n        title = xpath_text(idoc, './channel/title')\n        description = xpath_text(idoc, './channel/description')\n\n        entries = []\n        for item in idoc.findall('.//item'):\n            info = self._get_video_info(item, use_hls)\n            if info:\n                entries.append(info)\n\n        return self.playlist_result(\n            entries, playlist_title=title, playlist_description=description)\n\n    def _extract_triforce_mgid(self, webpage, data_zone=None, video_id=None):\n        triforce_feed = self._parse_json(self._search_regex(\n            r'triforceManifestFeed\\s*=\\s*({.+?})\\s*;\\s*\\n', webpage,\n            'triforce feed', default='{}'), video_id, fatal=False)\n\n        data_zone = self._search_regex(\n            r'data-zone=([\"\\'])(?P<zone>.+?_lc_promo.*?)\\1', webpage,\n            'data zone', default=data_zone, group='zone')\n\n        feed_url = try_get(\n            triforce_feed, lambda x: x['manifest']['zones'][data_zone]['feed'],\n            compat_str)\n        if not feed_url:\n            return\n\n        feed = self._download_json(feed_url, video_id, fatal=False)\n        if not feed:\n            return\n\n        return try_get(feed, lambda x: x['result']['data']['id'], compat_str)\n\n    def _extract_mgid(self, webpage):\n        try:\n            # the url can be http://media.mtvnservices.com/fb/{mgid}.swf\n            # or http://media.mtvnservices.com/{mgid}\n            og_url = self._og_search_video_url(webpage)\n            mgid = url_basename(og_url)\n            if mgid.endswith('.swf'):\n                mgid = mgid[:-4]\n        except RegexNotFoundError:\n            mgid = None\n\n        if mgid is None or ':' not in mgid:\n            mgid = self._search_regex(\n                [r'data-mgid=\"(.*?)\"', r'swfobject\\.embedSWF\\(\".*?(mgid:.*?)\"'],\n                webpage, 'mgid', default=None)\n\n        if not mgid:\n            sm4_embed = self._html_search_meta(\n                'sm4:video:embed', webpage, 'sm4 embed', default='')\n            mgid = self._search_regex(\n                r'embed/(mgid:.+?)[\"\\'&?/]', sm4_embed, 'mgid', default=None)\n\n        if not mgid:\n            mgid = self._extract_triforce_mgid(webpage)\n\n        return mgid\n\n    def _real_extract(self, url):\n        title = url_basename(url)\n        webpage = self._download_webpage(url, title)\n        mgid = self._extract_mgid(webpage)\n        videos_info = self._get_videos_info(mgid)\n        return videos_info\n\n\nclass MTVServicesEmbeddedIE(MTVServicesInfoExtractor):\n    IE_NAME = 'mtvservices:embedded'\n    _VALID_URL = r'https?://media\\.mtvnservices\\.com/embed/(?P<mgid>.+?)(\\?|/|$)'\n\n    _TEST = {\n        # From http://www.thewrap.com/peter-dinklage-sums-up-game-of-thrones-in-45-seconds-video/\n        'url': 'http://media.mtvnservices.com/embed/mgid:uma:video:mtv.com:1043906/cp~vid%3D1043906%26uri%3Dmgid%3Auma%3Avideo%3Amtv.com%3A1043906',\n        'md5': 'cb349b21a7897164cede95bd7bf3fbb9',\n        'info_dict': {\n            'id': '1043906',\n            'ext': 'mp4',\n            'title': 'Peter Dinklage Sums Up \\'Game Of Thrones\\' In 45 Seconds',\n            'description': '\"Sexy sexy sexy, stabby stabby stabby, beautiful language,\" says Peter Dinklage as he tries summarizing \"Game of Thrones\" in under a minute.',\n            'timestamp': 1400126400,\n            'upload_date': '20140515',\n        },\n    }\n\n    @staticmethod\n    def _extract_url(webpage):\n        mobj = re.search(\n            r'<iframe[^>]+?src=([\"\\'])(?P<url>(?:https?:)?//media.mtvnservices.com/embed/.+?)\\1', webpage)\n        if mobj:\n            return mobj.group('url')\n\n    def _get_feed_url(self, uri):\n        video_id = self._id_from_uri(uri)\n        config = self._download_json(\n            'http://media.mtvnservices.com/pmt/e1/access/index.html?uri=%s&configtype=edge' % uri, video_id)\n        return self._remove_template_parameter(config['feedWithQueryParams'])\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        mgid = mobj.group('mgid')\n        return self._get_videos_info(mgid)\n\n\nclass MTVIE(MTVServicesInfoExtractor):\n    IE_NAME = 'mtv'\n    _VALID_URL = r'https?://(?:www\\.)?mtv\\.com/(?:video-clips|(?:full-)?episodes)/(?P<id>[^/?#.]+)'\n    _FEED_URL = 'http://www.mtv.com/feeds/mrss/'\n\n    _TESTS = [{\n        'url': 'http://www.mtv.com/video-clips/vl8qof/unlocking-the-truth-trailer',\n        'md5': '1edbcdf1e7628e414a8c5dcebca3d32b',\n        'info_dict': {\n            'id': '5e14040d-18a4-47c4-a582-43ff602de88e',\n            'ext': 'mp4',\n            'title': 'Unlocking The Truth|July 18, 2016|1|101|Trailer',\n            'description': '\"Unlocking the Truth\" premieres August 17th at 11/10c.',\n            'timestamp': 1468846800,\n            'upload_date': '20160718',\n        },\n    }, {\n        'url': 'http://www.mtv.com/full-episodes/94tujl/unlocking-the-truth-gates-of-hell-season-1-ep-101',\n        'only_matching': True,\n    }, {\n        'url': 'http://www.mtv.com/episodes/g8xu7q/teen-mom-2-breaking-the-wall-season-7-ep-713',\n        'only_matching': True,\n    }]\n\n\nclass MTV81IE(InfoExtractor):\n    IE_NAME = 'mtv81'\n    _VALID_URL = r'https?://(?:www\\.)?mtv81\\.com/videos/(?P<id>[^/?#.]+)'\n\n    _TEST = {\n        'url': 'http://www.mtv81.com/videos/artist-to-watch/the-godfather-of-japanese-hip-hop-segment-1/',\n        'md5': '1edbcdf1e7628e414a8c5dcebca3d32b',\n        'info_dict': {\n            'id': '5e14040d-18a4-47c4-a582-43ff602de88e',\n            'ext': 'mp4',\n            'title': 'Unlocking The Truth|July 18, 2016|1|101|Trailer',\n            'description': '\"Unlocking the Truth\" premieres August 17th at 11/10c.',\n            'timestamp': 1468846800,\n            'upload_date': '20160718',\n        },\n    }\n\n    def _extract_mgid(self, webpage):\n        return self._search_regex(\n            r'getTheVideo\\(([\"\\'])(?P<id>mgid:.+?)\\1', webpage,\n            'mgid', group='id')\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        webpage = self._download_webpage(url, video_id)\n        mgid = self._extract_mgid(webpage)\n        return self.url_result('http://media.mtvnservices.com/embed/%s' % mgid)\n\n\nclass MTVVideoIE(MTVServicesInfoExtractor):\n    IE_NAME = 'mtv:video'\n    _VALID_URL = r'''(?x)^https?://\n        (?:(?:www\\.)?mtv\\.com/videos/.+?/(?P<videoid>[0-9]+)/[^/]+$|\n           m\\.mtv\\.com/videos/video\\.rbml\\?.*?id=(?P<mgid>[^&]+))'''\n\n    _FEED_URL = 'http://www.mtv.com/player/embed/AS3/rss/'\n\n    _TESTS = [\n        {\n            'url': 'http://www.mtv.com/videos/misc/853555/ours-vh1-storytellers.jhtml',\n            'md5': '850f3f143316b1e71fa56a4edfd6e0f8',\n            'info_dict': {\n                'id': '853555',\n                'ext': 'mp4',\n                'title': 'Taylor Swift - \"Ours (VH1 Storytellers)\"',\n                'description': 'Album: Taylor Swift performs \"Ours\" for VH1 Storytellers at Harvey Mudd College.',\n                'timestamp': 1352610000,\n                'upload_date': '20121111',\n            },\n        },\n    ]\n\n    def _get_thumbnail_url(self, uri, itemdoc):\n        return 'http://mtv.mtvnimages.com/uri/' + uri\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        video_id = mobj.group('videoid')\n        uri = mobj.groupdict().get('mgid')\n        if uri is None:\n            webpage = self._download_webpage(url, video_id)\n\n            # Some videos come from Vevo.com\n            m_vevo = re.search(\n                r'(?s)isVevoVideo = true;.*?vevoVideoId = \"(.*?)\";', webpage)\n            if m_vevo:\n                vevo_id = m_vevo.group(1)\n                self.to_screen('Vevo video detected: %s' % vevo_id)\n                return self.url_result('vevo:%s' % vevo_id, ie='Vevo')\n\n            uri = self._html_search_regex(r'/uri/(.*?)\\?', webpage, 'uri')\n        return self._get_videos_info(uri)\n\n\nclass MTVDEIE(MTVServicesInfoExtractor):\n    IE_NAME = 'mtv.de'\n    _VALID_URL = r'https?://(?:www\\.)?mtv\\.de/(?:artists|shows|news)/(?:[^/]+/)*(?P<id>\\d+)-[^/#?]+/*(?:[#?].*)?$'\n    _TESTS = [{\n        'url': 'http://www.mtv.de/artists/10571-cro/videos/61131-traum',\n        'info_dict': {\n            'id': 'music_video-a50bc5f0b3aa4b3190aa',\n            'ext': 'flv',\n            'title': 'MusicVideo_cro-traum',\n            'description': 'Cro - Traum',\n        },\n        'params': {\n            # rtmp download\n            'skip_download': True,\n        },\n        'skip': 'Blocked at Travis CI',\n    }, {\n        # mediagen URL without query (e.g. http://videos.mtvnn.com/mediagen/e865da714c166d18d6f80893195fcb97)\n        'url': 'http://www.mtv.de/shows/933-teen-mom-2/staffeln/5353/folgen/63565-enthullungen',\n        'info_dict': {\n            'id': 'local_playlist-f5ae778b9832cc837189',\n            'ext': 'flv',\n            'title': 'Episode_teen-mom-2_shows_season-5_episode-1_full-episode_part1',\n        },\n        'params': {\n            # rtmp download\n            'skip_download': True,\n        },\n        'skip': 'Blocked at Travis CI',\n    }, {\n        'url': 'http://www.mtv.de/news/77491-mtv-movies-spotlight-pixels-teil-3',\n        'info_dict': {\n            'id': 'local_playlist-4e760566473c4c8c5344',\n            'ext': 'mp4',\n            'title': 'Article_mtv-movies-spotlight-pixels-teil-3_short-clips_part1',\n            'description': 'MTV Movies Supercut',\n        },\n        'params': {\n            # rtmp download\n            'skip_download': True,\n        },\n        'skip': 'Das Video kann zur Zeit nicht abgespielt werden.',\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id)\n\n        playlist = self._parse_json(\n            self._search_regex(\n                r'window\\.pagePlaylist\\s*=\\s*(\\[.+?\\]);\\n', webpage, 'page playlist'),\n            video_id)\n\n        def _mrss_url(item):\n            return item['mrss'] + item.get('mrssvars', '')\n\n        # news pages contain single video in playlist with different id\n        if len(playlist) == 1:\n            return self._get_videos_info_from_url(_mrss_url(playlist[0]), video_id)\n\n        for item in playlist:\n            item_id = item.get('id')\n            if item_id and compat_str(item_id) == video_id:\n                return self._get_videos_info_from_url(_mrss_url(item), video_id)\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "mtv.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/mtv.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}