{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_chr\nfrom ..utils import (\n    determine_ext,\n    ExtractorError,\n    int_or_none,\n    js_to_json,\n)\n\n\nclass StreamangoIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?streamango\\.com/(?:f|embed)/(?P<id>[^/?\n    _TESTS = [{\n        'url': 'https://streamango.com/f/clapasobsptpkdfe/20170315_150006_mp4',\n        'md5': 'e992787515a182f55e38fc97588d802a',\n        'info_dict': {\n            'id': 'clapasobsptpkdfe',\n            'ext': 'mp4',\n            'title': '20170315_150006.mp4',\n        }\n    }, {\n        \n        'url': 'https://streamango.com/embed/foqebrpftarclpob/asdf_asd_2_mp4',\n        'info_dict': {\n            'id': 'foqebrpftarclpob',\n            'ext': 'mp4',\n            'title': 'foqebrpftarclpob',\n        },\n        'params': {\n            'skip_download': True,\n        },\n        'skip': 'gone',\n    }, {\n        'url': 'https://streamango.com/embed/clapasobsptpkdfe/20170315_150006_mp4',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        def decrypt_src(encoded, val):\n            ALPHABET = '=/+9876543210zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA'\n            encoded = re.sub(r'[^A-Za-z0-9+/=]', '', encoded)\n            decoded = ''\n            sm = [None] * 4\n            i = 0\n            str_len = len(encoded)\n            while i < str_len:\n                for j in range(4):\n                    sm[j % 4] = ALPHABET.index(encoded[i])\n                    i += 1\n                char_code = ((sm[0] << 0x2) | (sm[1] >> 0x4)) ^ val\n                decoded += compat_chr(char_code)\n                if sm[2] != 0x40:\n                    char_code = ((sm[1] & 0xf) << 0x4) | (sm[2] >> 0x2)\n                    decoded += compat_chr(char_code)\n                if sm[3] != 0x40:\n                    char_code = ((sm[2] & 0x3) << 0x6) | sm[3]\n                    decoded += compat_chr(char_code)\n            return decoded\n\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id)\n\n        title = self._og_search_title(webpage, default=video_id)\n\n        formats = []\n        for format_ in re.findall(r'({[^}]*\\bsrc\\s*:\\s*[^}]*})', webpage):\n            mobj = re.search(r'(src\\s*:\\s*[^(]+\\(([^)]*)\\)[\\s,]*)', format_)\n            if mobj is None:\n                continue\n\n            format_ = format_.replace(mobj.group(0), '')\n\n            video = self._parse_json(\n                format_, video_id, transform_source=js_to_json,\n                fatal=False) or {}\n\n            mobj = re.search(\n                r'([\\'\"])(?P<src>(?:(?!\\1).)+)\\1\\s*,\\s*(?P<val>\\d+)',\n                mobj.group(1))\n            if mobj is None:\n                continue\n\n            src = decrypt_src(mobj.group('src'), int_or_none(mobj.group('val')))\n            if not src:\n                continue\n\n            ext = determine_ext(src, default_ext=None)\n            if video.get('type') == 'application/dash+xml' or ext == 'mpd':\n                formats.extend(self._extract_mpd_formats(\n                    src, video_id, mpd_id='dash', fatal=False))\n            else:\n                formats.append({\n                    'url': src,\n                    'ext': ext or 'mp4',\n                    'width': int_or_none(video.get('width')),\n                    'height': int_or_none(video.get('height')),\n                    'tbr': int_or_none(video.get('bitrate')),\n                })\n\n        if not formats:\n            error = self._search_regex(\n                r'<p[^>]+\\bclass=[\"\\']lead[^>]+>(.+?)</p>', webpage,\n                'error', default=None)\n            if not error and '>Sorry' in webpage:\n                error = 'Video %s is not available' % video_id\n            if error:\n                raise ExtractorError(error, expected=True)\n\n        self._sort_formats(formats)\n\n        return {\n            'id': video_id,\n            'url': url,\n            'title': title,\n            'formats': formats,\n        }\n", "comments": "# coding: utf-8\n#&]+)'\n# no og:title\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_chr\nfrom ..utils import (\n    determine_ext,\n    ExtractorError,\n    int_or_none,\n    js_to_json,\n)\n\n\nclass StreamangoIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?streamango\\.com/(?:f|embed)/(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://streamango.com/f/clapasobsptpkdfe/20170315_150006_mp4',\n        'md5': 'e992787515a182f55e38fc97588d802a',\n        'info_dict': {\n            'id': 'clapasobsptpkdfe',\n            'ext': 'mp4',\n            'title': '20170315_150006.mp4',\n        }\n    }, {\n        # no og:title\n        'url': 'https://streamango.com/embed/foqebrpftarclpob/asdf_asd_2_mp4',\n        'info_dict': {\n            'id': 'foqebrpftarclpob',\n            'ext': 'mp4',\n            'title': 'foqebrpftarclpob',\n        },\n        'params': {\n            'skip_download': True,\n        },\n        'skip': 'gone',\n    }, {\n        'url': 'https://streamango.com/embed/clapasobsptpkdfe/20170315_150006_mp4',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        def decrypt_src(encoded, val):\n            ALPHABET = '=/+9876543210zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA'\n            encoded = re.sub(r'[^A-Za-z0-9+/=]', '', encoded)\n            decoded = ''\n            sm = [None] * 4\n            i = 0\n            str_len = len(encoded)\n            while i < str_len:\n                for j in range(4):\n                    sm[j % 4] = ALPHABET.index(encoded[i])\n                    i += 1\n                char_code = ((sm[0] << 0x2) | (sm[1] >> 0x4)) ^ val\n                decoded += compat_chr(char_code)\n                if sm[2] != 0x40:\n                    char_code = ((sm[1] & 0xf) << 0x4) | (sm[2] >> 0x2)\n                    decoded += compat_chr(char_code)\n                if sm[3] != 0x40:\n                    char_code = ((sm[2] & 0x3) << 0x6) | sm[3]\n                    decoded += compat_chr(char_code)\n            return decoded\n\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id)\n\n        title = self._og_search_title(webpage, default=video_id)\n\n        formats = []\n        for format_ in re.findall(r'({[^}]*\\bsrc\\s*:\\s*[^}]*})', webpage):\n            mobj = re.search(r'(src\\s*:\\s*[^(]+\\(([^)]*)\\)[\\s,]*)', format_)\n            if mobj is None:\n                continue\n\n            format_ = format_.replace(mobj.group(0), '')\n\n            video = self._parse_json(\n                format_, video_id, transform_source=js_to_json,\n                fatal=False) or {}\n\n            mobj = re.search(\n                r'([\\'\"])(?P<src>(?:(?!\\1).)+)\\1\\s*,\\s*(?P<val>\\d+)',\n                mobj.group(1))\n            if mobj is None:\n                continue\n\n            src = decrypt_src(mobj.group('src'), int_or_none(mobj.group('val')))\n            if not src:\n                continue\n\n            ext = determine_ext(src, default_ext=None)\n            if video.get('type') == 'application/dash+xml' or ext == 'mpd':\n                formats.extend(self._extract_mpd_formats(\n                    src, video_id, mpd_id='dash', fatal=False))\n            else:\n                formats.append({\n                    'url': src,\n                    'ext': ext or 'mp4',\n                    'width': int_or_none(video.get('width')),\n                    'height': int_or_none(video.get('height')),\n                    'tbr': int_or_none(video.get('bitrate')),\n                })\n\n        if not formats:\n            error = self._search_regex(\n                r'<p[^>]+\\bclass=[\"\\']lead[^>]+>(.+?)</p>', webpage,\n                'error', default=None)\n            if not error and '>Sorry' in webpage:\n                error = 'Video %s is not available' % video_id\n            if error:\n                raise ExtractorError(error, expected=True)\n\n        self._sort_formats(formats)\n\n        return {\n            'id': video_id,\n            'url': url,\n            'title': title,\n            'formats': formats,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "streamango.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/streamango.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}