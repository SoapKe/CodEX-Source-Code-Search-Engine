{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport itertools\nimport re\n\nfrom .common import (\n    InfoExtractor,\n    SearchInfoExtractor\n)\nfrom ..compat import (\n    compat_str,\n    compat_urlparse,\n    compat_urllib_parse_urlencode,\n)\nfrom ..utils import (\n    ExtractorError,\n    int_or_none,\n    unified_strdate,\n    update_url_query,\n)\n\n\nclass SoundcloudIE(InfoExtractor):\n    \n        self.to_screen('%s: Resolving id' % video_id)\n\n    @classmethod\n    def _resolv_url(cls, url):\n        return 'https://api.soundcloud.com/resolve.json?url=' + url + '&client_id=' + cls._CLIENT_ID\n\n    def _extract_info_dict(self, info, full_title=None, quiet=False, secret_token=None):\n        track_id = compat_str(info['id'])\n        name = full_title or track_id\n        if quiet:\n            self.report_extraction(name)\n        thumbnail = info.get('artwork_url') or info.get('user', {}).get('avatar_url')\n        if isinstance(thumbnail, compat_str):\n            thumbnail = thumbnail.replace('-large', '-t500x500')\n        ext = 'mp3'\n        result = {\n            'id': track_id,\n            'uploader': info.get('user', {}).get('username'),\n            'upload_date': unified_strdate(info.get('created_at')),\n            'title': info['title'],\n            'description': info.get('description'),\n            'thumbnail': thumbnail,\n            'duration': int_or_none(info.get('duration'), 1000),\n            'webpage_url': info.get('permalink_url'),\n            'license': info.get('license'),\n        }\n        formats = []\n        query = {'client_id': self._CLIENT_ID}\n        if secret_token is not None:\n            query['secret_token'] = secret_token\n        if info.get('downloadable', False):\n            \n            format_url = update_url_query(\n                'https://api.soundcloud.com/tracks/%s/download' % track_id, query)\n            formats.append({\n                'format_id': 'download',\n                'ext': info.get('original_format', 'mp3'),\n                'url': format_url,\n                'vcodec': 'none',\n                'preference': 10,\n            })\n\n        \n        format_dict = self._download_json(\n            'https://api.soundcloud.com/i1/tracks/%s/streams' % track_id,\n            track_id, 'Downloading track url', query=query)\n\n        for key, stream_url in format_dict.items():\n            abr = int_or_none(self._search_regex(\n                r'_(\\d+)_url', key, 'audio bitrate', default=None))\n            if key.startswith('http'):\n                stream_formats = [{\n                    'format_id': key,\n                    'ext': ext,\n                    'url': stream_url,\n                }]\n            elif key.startswith('rtmp'):\n                \n                url, path = stream_url.split('mp3:', 1)\n                stream_formats = [{\n                    'format_id': key,\n                    'url': url,\n                    'play_path': 'mp3:' + path,\n                    'ext': 'flv',\n                }]\n            elif key.startswith('hls'):\n                stream_formats = self._extract_m3u8_formats(\n                    stream_url, track_id, 'mp3', entry_protocol='m3u8_native',\n                    m3u8_id=key, fatal=False)\n            else:\n                continue\n\n            for f in stream_formats:\n                f['abr'] = abr\n\n            formats.extend(stream_formats)\n\n        if not formats:\n            \n            \n            formats.append({\n                'format_id': 'fallback',\n                'url': update_url_query(info['stream_url'], query),\n                'ext': ext,\n            })\n\n        for f in formats:\n            f['vcodec'] = 'none'\n\n        self._check_formats(formats, track_id)\n        self._sort_formats(formats)\n        result['formats'] = formats\n\n        return result\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url, flags=re.VERBOSE)\n        if mobj is None:\n            raise ExtractorError('Invalid URL: %s' % url)\n\n        track_id = mobj.group('track_id')\n\n        if track_id is not None:\n            info_json_url = 'https://api.soundcloud.com/tracks/' + track_id + '.json?client_id=' + self._CLIENT_ID\n            full_title = track_id\n            token = mobj.group('secret_token')\n            if token:\n                info_json_url += '&secret_token=' + token\n        elif mobj.group('player'):\n            query = compat_urlparse.parse_qs(compat_urlparse.urlparse(url).query)\n            real_url = query['url'][0]\n            \n            \n            if 'secret_token' in query:\n                real_url += '?secret_token=' + query['secret_token'][0]\n            return self.url_result(real_url)\n        else:\n            \n            uploader = mobj.group('uploader')\n            \n            slug_title = mobj.group('title')\n            token = mobj.group('token')\n            full_title = resolve_title = '%s/%s' % (uploader, slug_title)\n            if token:\n                resolve_title += '/%s' % token\n\n            self.report_resolve(full_title)\n\n            url = 'https://soundcloud.com/%s' % resolve_title\n            info_json_url = self._resolv_url(url)\n        info = self._download_json(info_json_url, full_title, 'Downloading info JSON')\n\n        return self._extract_info_dict(info, full_title, secret_token=token)\n\n\nclass SoundcloudPlaylistBaseIE(SoundcloudIE):\n    @staticmethod\n    def _extract_id(e):\n        return compat_str(e['id']) if e.get('id') else None\n\n    def _extract_track_entries(self, tracks):\n        return [\n            self.url_result(\n                track['permalink_url'], SoundcloudIE.ie_key(),\n                video_id=self._extract_id(track))\n            for track in tracks if track.get('permalink_url')]\n\n\nclass SoundcloudSetIE(SoundcloudPlaylistBaseIE):\n    _VALID_URL = r'https?://(?:(?:www|m)\\.)?soundcloud\\.com/(?P<uploader>[\\w\\d-]+)/sets/(?P<slug_title>[\\w\\d-]+)(?:/(?P<token>[^?/]+))?'\n    IE_NAME = 'soundcloud:set'\n    _TESTS = [{\n        'url': 'https://soundcloud.com/the-concept-band/sets/the-royal-concept-ep',\n        'info_dict': {\n            'id': '2284613',\n            'title': 'The Royal Concept EP',\n        },\n        'playlist_mincount': 5,\n    }, {\n        'url': 'https://soundcloud.com/the-concept-band/sets/the-royal-concept-ep/token',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n\n        \n        uploader = mobj.group('uploader')\n        \n        slug_title = mobj.group('slug_title')\n        full_title = '%s/sets/%s' % (uploader, slug_title)\n        url = 'https://soundcloud.com/%s/sets/%s' % (uploader, slug_title)\n\n        token = mobj.group('token')\n        if token:\n            full_title += '/' + token\n            url += '/' + token\n\n        self.report_resolve(full_title)\n\n        resolv_url = self._resolv_url(url)\n        info = self._download_json(resolv_url, full_title)\n\n        if 'errors' in info:\n            msgs = (compat_str(err['error_message']) for err in info['errors'])\n            raise ExtractorError('unable to download video webpage: %s' % ','.join(msgs))\n\n        entries = self._extract_track_entries(info['tracks'])\n\n        return {\n            '_type': 'playlist',\n            'entries': entries,\n            'id': '%s' % info['id'],\n            'title': info['title'],\n        }\n\n\nclass SoundcloudPagedPlaylistBaseIE(SoundcloudPlaylistBaseIE):\n    _API_BASE = 'https://api.soundcloud.com'\n    _API_V2_BASE = 'https://api-v2.soundcloud.com'\n\n    def _extract_playlist(self, base_url, playlist_id, playlist_title):\n        COMMON_QUERY = {\n            'limit': 50,\n            'client_id': self._CLIENT_ID,\n            'linked_partitioning': '1',\n        }\n\n        query = COMMON_QUERY.copy()\n        query['offset'] = 0\n\n        next_href = base_url + '?' + compat_urllib_parse_urlencode(query)\n\n        entries = []\n        for i in itertools.count():\n            response = self._download_json(\n                next_href, playlist_id, 'Downloading track page %s' % (i + 1))\n\n            collection = response['collection']\n            if not collection:\n                break\n\n            def resolve_permalink_url(candidates):\n                for cand in candidates:\n                    if isinstance(cand, dict):\n                        permalink_url = cand.get('permalink_url')\n                        entry_id = self._extract_id(cand)\n                        if permalink_url and permalink_url.startswith('http'):\n                            return permalink_url, entry_id\n\n            for e in collection:\n                permalink_url, entry_id = resolve_permalink_url((e, e.get('track'), e.get('playlist')))\n                if permalink_url:\n                    entries.append(self.url_result(permalink_url, video_id=entry_id))\n\n            next_href = response.get('next_href')\n            if not next_href:\n                break\n\n            parsed_next_href = compat_urlparse.urlparse(response['next_href'])\n            qs = compat_urlparse.parse_qs(parsed_next_href.query)\n            qs.update(COMMON_QUERY)\n            next_href = compat_urlparse.urlunparse(\n                parsed_next_href._replace(query=compat_urllib_parse_urlencode(qs, True)))\n\n        return {\n            '_type': 'playlist',\n            'id': playlist_id,\n            'title': playlist_title,\n            'entries': entries,\n        }\n\n\nclass SoundcloudUserIE(SoundcloudPagedPlaylistBaseIE):\n    _VALID_URL = r\n    IE_NAME = 'soundcloud:user'\n    _TESTS = [{\n        'url': 'https://soundcloud.com/the-akashic-chronicler',\n        'info_dict': {\n            'id': '114582580',\n            'title': 'The Akashic Chronicler (All)',\n        },\n        'playlist_mincount': 74,\n    }, {\n        'url': 'https://soundcloud.com/the-akashic-chronicler/tracks',\n        'info_dict': {\n            'id': '114582580',\n            'title': 'The Akashic Chronicler (Tracks)',\n        },\n        'playlist_mincount': 37,\n    }, {\n        'url': 'https://soundcloud.com/the-akashic-chronicler/sets',\n        'info_dict': {\n            'id': '114582580',\n            'title': 'The Akashic Chronicler (Playlists)',\n        },\n        'playlist_mincount': 2,\n    }, {\n        'url': 'https://soundcloud.com/the-akashic-chronicler/reposts',\n        'info_dict': {\n            'id': '114582580',\n            'title': 'The Akashic Chronicler (Reposts)',\n        },\n        'playlist_mincount': 7,\n    }, {\n        'url': 'https://soundcloud.com/the-akashic-chronicler/likes',\n        'info_dict': {\n            'id': '114582580',\n            'title': 'The Akashic Chronicler (Likes)',\n        },\n        'playlist_mincount': 321,\n    }, {\n        'url': 'https://soundcloud.com/grynpyret/spotlight',\n        'info_dict': {\n            'id': '7098329',\n            'title': 'Grynpyret (Spotlight)',\n        },\n        'playlist_mincount': 1,\n    }]\n\n    _BASE_URL_MAP = {\n        'all': '%s/profile/soundcloud:users:%%s' % SoundcloudPagedPlaylistBaseIE._API_V2_BASE,\n        'tracks': '%s/users/%%s/tracks' % SoundcloudPagedPlaylistBaseIE._API_BASE,\n        'sets': '%s/users/%%s/playlists' % SoundcloudPagedPlaylistBaseIE._API_V2_BASE,\n        'reposts': '%s/profile/soundcloud:users:%%s/reposts' % SoundcloudPagedPlaylistBaseIE._API_V2_BASE,\n        'likes': '%s/users/%%s/likes' % SoundcloudPagedPlaylistBaseIE._API_V2_BASE,\n        'spotlight': '%s/users/%%s/spotlight' % SoundcloudPagedPlaylistBaseIE._API_V2_BASE,\n    }\n\n    _TITLE_MAP = {\n        'all': 'All',\n        'tracks': 'Tracks',\n        'sets': 'Playlists',\n        'reposts': 'Reposts',\n        'likes': 'Likes',\n        'spotlight': 'Spotlight',\n    }\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        uploader = mobj.group('user')\n\n        url = 'https://soundcloud.com/%s/' % uploader\n        resolv_url = self._resolv_url(url)\n        user = self._download_json(\n            resolv_url, uploader, 'Downloading user info')\n\n        resource = mobj.group('rsrc') or 'all'\n\n        return self._extract_playlist(\n            self._BASE_URL_MAP[resource] % user['id'], compat_str(user['id']),\n            '%s (%s)' % (user['username'], self._TITLE_MAP[resource]))\n\n\nclass SoundcloudTrackStationIE(SoundcloudPagedPlaylistBaseIE):\n    _VALID_URL = r'https?://(?:(?:www|m)\\.)?soundcloud\\.com/stations/track/[^/]+/(?P<id>[^/?\n    IE_NAME = 'soundcloud:trackstation'\n    _TESTS = [{\n        'url': 'https://soundcloud.com/stations/track/officialsundial/your-text',\n        'info_dict': {\n            'id': '286017854',\n            'title': 'Track station: your-text',\n        },\n        'playlist_mincount': 47,\n    }]\n\n    def _real_extract(self, url):\n        track_name = self._match_id(url)\n\n        webpage = self._download_webpage(url, track_name)\n\n        track_id = self._search_regex(\n            r'soundcloud:track-stations:(\\d+)', webpage, 'track id')\n\n        return self._extract_playlist(\n            '%s/stations/soundcloud:track-stations:%s/tracks'\n            % (self._API_V2_BASE, track_id),\n            track_id, 'Track station: %s' % track_name)\n\n\nclass SoundcloudPlaylistIE(SoundcloudPlaylistBaseIE):\n    _VALID_URL = r'https?://api\\.soundcloud\\.com/playlists/(?P<id>[0-9]+)(?:/?\\?secret_token=(?P<token>[^&]+?))?$'\n    IE_NAME = 'soundcloud:playlist'\n    _TESTS = [{\n        'url': 'https://api.soundcloud.com/playlists/4110309',\n        'info_dict': {\n            'id': '4110309',\n            'title': 'TILT Brass - Bowery Poetry Club, August \\'03 [Non-Site SCR 02]',\n            'description': 're:.*?TILT Brass - Bowery Poetry Club',\n        },\n        'playlist_count': 6,\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        playlist_id = mobj.group('id')\n        base_url = '%s//api.soundcloud.com/playlists/%s.json?' % (self.http_scheme(), playlist_id)\n\n        data_dict = {\n            'client_id': self._CLIENT_ID,\n        }\n        token = mobj.group('token')\n\n        if token:\n            data_dict['secret_token'] = token\n\n        data = compat_urllib_parse_urlencode(data_dict)\n        data = self._download_json(\n            base_url + data, playlist_id, 'Downloading playlist')\n\n        entries = self._extract_track_entries(data['tracks'])\n\n        return {\n            '_type': 'playlist',\n            'id': playlist_id,\n            'title': data.get('title'),\n            'description': data.get('description'),\n            'entries': entries,\n        }\n\n\nclass SoundcloudSearchIE(SearchInfoExtractor, SoundcloudIE):\n    IE_NAME = 'soundcloud:search'\n    IE_DESC = 'Soundcloud search'\n    _MAX_RESULTS = float('inf')\n    _TESTS = [{\n        'url': 'scsearch15:post-avant jazzcore',\n        'info_dict': {\n            'title': 'post-avant jazzcore',\n        },\n        'playlist_count': 15,\n    }]\n\n    _SEARCH_KEY = 'scsearch'\n    _MAX_RESULTS_PER_PAGE = 200\n    _DEFAULT_RESULTS_PER_PAGE = 50\n    _API_V2_BASE = 'https://api-v2.soundcloud.com'\n\n    def _get_collection(self, endpoint, collection_id, **query):\n        limit = min(\n            query.get('limit', self._DEFAULT_RESULTS_PER_PAGE),\n            self._MAX_RESULTS_PER_PAGE)\n        query['limit'] = limit\n        query['client_id'] = self._CLIENT_ID\n        query['linked_partitioning'] = '1'\n        query['offset'] = 0\n        data = compat_urllib_parse_urlencode(query)\n        next_url = '{0}{1}?{2}'.format(self._API_V2_BASE, endpoint, data)\n\n        collected_results = 0\n\n        for i in itertools.count(1):\n            response = self._download_json(\n                next_url, collection_id, 'Downloading page {0}'.format(i),\n                'Unable to download API page')\n\n            collection = response.get('collection', [])\n            if not collection:\n                break\n\n            collection = list(filter(bool, collection))\n            collected_results += len(collection)\n\n            for item in collection:\n                yield self.url_result(item['uri'], SoundcloudIE.ie_key())\n\n            if not collection or collected_results >= limit:\n                break\n\n            next_url = response.get('next_href')\n            if not next_url:\n                break\n\n    def _get_n_results(self, query, n):\n        tracks = self._get_collection('/search/tracks', query, limit=n, q=query)\n        return self.playlist_result(tracks, playlist_title=query)\n", "comments": "Information extractor for soundcloud.com\n       To access the media, the uid of the song and a stream token\n       must be extracted from the page source and the script must make\n       a request to media.soundcloud.com/crossdomain.xml. Then\n       the media can be grabbed by requesting from an url composed\n       of the stream token and uid\n     \"\"\"\n\n    _VALID_URL = r'''(?x)^(?:https?://)?\n                    (?:(?:(?:www\\.|m\\.)?soundcloud\\.com/\n                            (?!stations/track)\n                            (?P<uploader>[\\w\\d-]+)/\n                            (?!(?:tracks|sets(?:/.+?)?|reposts|likes|spotlight)/?(?:$|[?#]))\n                            (?P<title>[\\w\\d-]+)/?\n                            (?P<token>[^?]+?)?(?:[?].*)?$)\n                       |(?:api\\.soundcloud\\.com/tracks/(?P<track_id>\\d+)\n                          (?:/?\\?secret_token=(?P<secret_token>[^&]+))?)\n                       |(?P<player>(?:w|player|p.)\\.soundcloud\\.com/player/?.*?url=.*)\n                    )\n                    '''\n    IE_NAME = 'soundcloud'\n    _TESTS = [\n        {\n            'url': 'http://soundcloud.com/ethmusic/lostin-powers-she-so-heavy',\n            'md5': 'ebef0a451b909710ed1d7787dddbf0d7',\n            'info_dict': {\n                'id': '62986583',\n                'ext': 'mp3',\n                'upload_date': '20121011',\n                'description': 'No Downloads untill we record the finished version this weekend, i was too pumped n i had to post it , earl is prolly gonna b hella p.o\\'d',\n                'uploader': 'E.T. ExTerrestrial Music',\n                'title': 'Lostin Powers - She so Heavy (SneakPreview) Adrian Ackers Blueprint 1',\n                'duration': 143,\n                'license': 'all-rights-reserved',\n            }\n        },\n        # not streamable song\n        {\n            'url': 'https://soundcloud.com/the-concept-band/goldrushed-mastered?in=the-concept-band/sets/the-royal-concept-ep',\n            'info_dict': {\n                'id': '47127627',\n                'ext': 'mp3',\n                'title': 'Goldrushed',\n                'description': 'From Stockholm Sweden\\r\\nPovel / Magnus / Filip / David\\r\\nwww.theroyalconcept.com',\n                'uploader': 'The Royal Concept',\n                'upload_date': '20120521',\n                'duration': 227,\n                'license': 'all-rights-reserved',\n            },\n            'params': {\n                # rtmp\n                'skip_download': True,\n            },\n        },\n        # private link\n        {\n            'url': 'https://soundcloud.com/jaimemf/youtube-dl-test-video-a-y-baw/s-8Pjrp',\n            'md5': 'aa0dd32bfea9b0c5ef4f02aacd080604',\n            'info_dict': {\n                'id': '123998367',\n                'ext': 'mp3',\n                'title': 'Youtube - Dl Test Video \\'\\' A\u0308\u21ad',\n                'uploader': 'jaimeMF',\n                'description': 'test chars:  \\\"\\'/\\\\\u00e4\u21ad',\n                'upload_date': '20131209',\n                'duration': 9,\n                'license': 'all-rights-reserved',\n            },\n        },\n        # private link (alt format)\n        {\n            'url': 'https://api.soundcloud.com/tracks/123998367?secret_token=s-8Pjrp',\n            'md5': 'aa0dd32bfea9b0c5ef4f02aacd080604',\n            'info_dict': {\n                'id': '123998367',\n                'ext': 'mp3',\n                'title': 'Youtube - Dl Test Video \\'\\' A\u0308\u21ad',\n                'uploader': 'jaimeMF',\n                'description': 'test chars:  \\\"\\'/\\\\\u00e4\u21ad',\n                'upload_date': '20131209',\n                'duration': 9,\n                'license': 'all-rights-reserved',\n            },\n        },\n        # downloadable song\n        {\n            'url': 'https://soundcloud.com/oddsamples/bus-brakes',\n            'md5': '7624f2351f8a3b2e7cd51522496e7631',\n            'info_dict': {\n                'id': '128590877',\n                'ext': 'mp3',\n                'title': 'Bus Brakes',\n                'description': 'md5:0053ca6396e8d2fd7b7e1595ef12ab66',\n                'uploader': 'oddsamples',\n                'upload_date': '20140109',\n                'duration': 17,\n                'license': 'cc-by-sa',\n            },\n        },\n        # private link, downloadable format\n        {\n            'url': 'https://soundcloud.com/oriuplift/uponly-238-no-talking-wav/s-AyZUd',\n            'md5': '64a60b16e617d41d0bef032b7f55441e',\n            'info_dict': {\n                'id': '340344461',\n                'ext': 'wav',\n                'title': 'Uplifting Only 238 [No Talking] (incl. Alex Feed Guestmix) (Aug 31, 2017) [wav]',\n                'description': 'md5:fa20ee0fca76a3d6df8c7e57f3715366',\n                'uploader': 'Ori Uplift Music',\n                'upload_date': '20170831',\n                'duration': 7449,\n                'license': 'all-rights-reserved',\n            },\n        },\n        # no album art, use avatar pic for thumbnail\n        {\n            'url': 'https://soundcloud.com/garyvee/sideways-prod-mad-real',\n            'md5': '59c7872bc44e5d99b7211891664760c2',\n            'info_dict': {\n                'id': '309699954',\n                'ext': 'mp3',\n                'title': 'Sideways (Prod. Mad Real)',\n                'description': 'md5:d41d8cd98f00b204e9800998ecf8427e',\n                'uploader': 'garyvee',\n                'upload_date': '20170226',\n                'duration': 207,\n                'thumbnail': r're:https?://.*\\.jpg',\n                'license': 'all-rights-reserved',\n            },\n            'params': {\n                'skip_download': True,\n            },\n        },\n    ]\n\n    _CLIENT_ID = 'DQskPX1pntALRzMp4HSxya3Mc0AO66Ro'\n\n    @staticmethod\n    def _extract_urls(webpage):\n        return [m.group('url') for m in re.finditer(\n            r'<iframe[^>]+src=([\"\\'])(?P<url>(?:https?://)?(?:w\\.)?soundcloud\\.com/player.+?)\\1',\n            webpage)]\n\n    def report_resolve(self, video_id):\n        \"\"\"Report information extraction.\n.\n(?x)\n                        https?://\n                            (?:(?:www|m)\\.)?soundcloud\\.com/\n                            (?P<user>[^/]+)\n                            (?:/\n                                (?P<rsrc>tracks|sets|reposts|likes|spotlight)\n                            )?\n                            /?(?:[?#].*)?$\n                    \n \n# coding: utf-8\n# We can build a direct link to the song\n# We have to retrieve the url\n# The url doesn't have an rtmp app, we have to extract the playpath\n# We fallback to the stream_url in the original info, this\n# cannot be always used, sometimes it can give an HTTP 404 error\n# If the token is in the query of the original url we have to\n# manually add it\n# extract uploader (which is in the url)\n# extract simple title (uploader + slug of song title)\n# extract uploader (which is in the url)\n# extract simple title (uploader + slug of song title)\n#&]+)'\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport itertools\nimport re\n\nfrom .common import (\n    InfoExtractor,\n    SearchInfoExtractor\n)\nfrom ..compat import (\n    compat_str,\n    compat_urlparse,\n    compat_urllib_parse_urlencode,\n)\nfrom ..utils import (\n    ExtractorError,\n    int_or_none,\n    unified_strdate,\n    update_url_query,\n)\n\n\nclass SoundcloudIE(InfoExtractor):\n    \"\"\"Information extractor for soundcloud.com\n       To access the media, the uid of the song and a stream token\n       must be extracted from the page source and the script must make\n       a request to media.soundcloud.com/crossdomain.xml. Then\n       the media can be grabbed by requesting from an url composed\n       of the stream token and uid\n     \"\"\"\n\n    _VALID_URL = r'''(?x)^(?:https?://)?\n                    (?:(?:(?:www\\.|m\\.)?soundcloud\\.com/\n                            (?!stations/track)\n                            (?P<uploader>[\\w\\d-]+)/\n                            (?!(?:tracks|sets(?:/.+?)?|reposts|likes|spotlight)/?(?:$|[?#]))\n                            (?P<title>[\\w\\d-]+)/?\n                            (?P<token>[^?]+?)?(?:[?].*)?$)\n                       |(?:api\\.soundcloud\\.com/tracks/(?P<track_id>\\d+)\n                          (?:/?\\?secret_token=(?P<secret_token>[^&]+))?)\n                       |(?P<player>(?:w|player|p.)\\.soundcloud\\.com/player/?.*?url=.*)\n                    )\n                    '''\n    IE_NAME = 'soundcloud'\n    _TESTS = [\n        {\n            'url': 'http://soundcloud.com/ethmusic/lostin-powers-she-so-heavy',\n            'md5': 'ebef0a451b909710ed1d7787dddbf0d7',\n            'info_dict': {\n                'id': '62986583',\n                'ext': 'mp3',\n                'upload_date': '20121011',\n                'description': 'No Downloads untill we record the finished version this weekend, i was too pumped n i had to post it , earl is prolly gonna b hella p.o\\'d',\n                'uploader': 'E.T. ExTerrestrial Music',\n                'title': 'Lostin Powers - She so Heavy (SneakPreview) Adrian Ackers Blueprint 1',\n                'duration': 143,\n                'license': 'all-rights-reserved',\n            }\n        },\n        # not streamable song\n        {\n            'url': 'https://soundcloud.com/the-concept-band/goldrushed-mastered?in=the-concept-band/sets/the-royal-concept-ep',\n            'info_dict': {\n                'id': '47127627',\n                'ext': 'mp3',\n                'title': 'Goldrushed',\n                'description': 'From Stockholm Sweden\\r\\nPovel / Magnus / Filip / David\\r\\nwww.theroyalconcept.com',\n                'uploader': 'The Royal Concept',\n                'upload_date': '20120521',\n                'duration': 227,\n                'license': 'all-rights-reserved',\n            },\n            'params': {\n                # rtmp\n                'skip_download': True,\n            },\n        },\n        # private link\n        {\n            'url': 'https://soundcloud.com/jaimemf/youtube-dl-test-video-a-y-baw/s-8Pjrp',\n            'md5': 'aa0dd32bfea9b0c5ef4f02aacd080604',\n            'info_dict': {\n                'id': '123998367',\n                'ext': 'mp3',\n                'title': 'Youtube - Dl Test Video \\'\\' A\u0308\u21ad',\n                'uploader': 'jaimeMF',\n                'description': 'test chars:  \\\"\\'/\\\\\u00e4\u21ad',\n                'upload_date': '20131209',\n                'duration': 9,\n                'license': 'all-rights-reserved',\n            },\n        },\n        # private link (alt format)\n        {\n            'url': 'https://api.soundcloud.com/tracks/123998367?secret_token=s-8Pjrp',\n            'md5': 'aa0dd32bfea9b0c5ef4f02aacd080604',\n            'info_dict': {\n                'id': '123998367',\n                'ext': 'mp3',\n                'title': 'Youtube - Dl Test Video \\'\\' A\u0308\u21ad',\n                'uploader': 'jaimeMF',\n                'description': 'test chars:  \\\"\\'/\\\\\u00e4\u21ad',\n                'upload_date': '20131209',\n                'duration': 9,\n                'license': 'all-rights-reserved',\n            },\n        },\n        # downloadable song\n        {\n            'url': 'https://soundcloud.com/oddsamples/bus-brakes',\n            'md5': '7624f2351f8a3b2e7cd51522496e7631',\n            'info_dict': {\n                'id': '128590877',\n                'ext': 'mp3',\n                'title': 'Bus Brakes',\n                'description': 'md5:0053ca6396e8d2fd7b7e1595ef12ab66',\n                'uploader': 'oddsamples',\n                'upload_date': '20140109',\n                'duration': 17,\n                'license': 'cc-by-sa',\n            },\n        },\n        # private link, downloadable format\n        {\n            'url': 'https://soundcloud.com/oriuplift/uponly-238-no-talking-wav/s-AyZUd',\n            'md5': '64a60b16e617d41d0bef032b7f55441e',\n            'info_dict': {\n                'id': '340344461',\n                'ext': 'wav',\n                'title': 'Uplifting Only 238 [No Talking] (incl. Alex Feed Guestmix) (Aug 31, 2017) [wav]',\n                'description': 'md5:fa20ee0fca76a3d6df8c7e57f3715366',\n                'uploader': 'Ori Uplift Music',\n                'upload_date': '20170831',\n                'duration': 7449,\n                'license': 'all-rights-reserved',\n            },\n        },\n        # no album art, use avatar pic for thumbnail\n        {\n            'url': 'https://soundcloud.com/garyvee/sideways-prod-mad-real',\n            'md5': '59c7872bc44e5d99b7211891664760c2',\n            'info_dict': {\n                'id': '309699954',\n                'ext': 'mp3',\n                'title': 'Sideways (Prod. Mad Real)',\n                'description': 'md5:d41d8cd98f00b204e9800998ecf8427e',\n                'uploader': 'garyvee',\n                'upload_date': '20170226',\n                'duration': 207,\n                'thumbnail': r're:https?://.*\\.jpg',\n                'license': 'all-rights-reserved',\n            },\n            'params': {\n                'skip_download': True,\n            },\n        },\n    ]\n\n    _CLIENT_ID = 'DQskPX1pntALRzMp4HSxya3Mc0AO66Ro'\n\n    @staticmethod\n    def _extract_urls(webpage):\n        return [m.group('url') for m in re.finditer(\n            r'<iframe[^>]+src=([\"\\'])(?P<url>(?:https?://)?(?:w\\.)?soundcloud\\.com/player.+?)\\1',\n            webpage)]\n\n    def report_resolve(self, video_id):\n        \"\"\"Report information extraction.\"\"\"\n        self.to_screen('%s: Resolving id' % video_id)\n\n    @classmethod\n    def _resolv_url(cls, url):\n        return 'https://api.soundcloud.com/resolve.json?url=' + url + '&client_id=' + cls._CLIENT_ID\n\n    def _extract_info_dict(self, info, full_title=None, quiet=False, secret_token=None):\n        track_id = compat_str(info['id'])\n        name = full_title or track_id\n        if quiet:\n            self.report_extraction(name)\n        thumbnail = info.get('artwork_url') or info.get('user', {}).get('avatar_url')\n        if isinstance(thumbnail, compat_str):\n            thumbnail = thumbnail.replace('-large', '-t500x500')\n        ext = 'mp3'\n        result = {\n            'id': track_id,\n            'uploader': info.get('user', {}).get('username'),\n            'upload_date': unified_strdate(info.get('created_at')),\n            'title': info['title'],\n            'description': info.get('description'),\n            'thumbnail': thumbnail,\n            'duration': int_or_none(info.get('duration'), 1000),\n            'webpage_url': info.get('permalink_url'),\n            'license': info.get('license'),\n        }\n        formats = []\n        query = {'client_id': self._CLIENT_ID}\n        if secret_token is not None:\n            query['secret_token'] = secret_token\n        if info.get('downloadable', False):\n            # We can build a direct link to the song\n            format_url = update_url_query(\n                'https://api.soundcloud.com/tracks/%s/download' % track_id, query)\n            formats.append({\n                'format_id': 'download',\n                'ext': info.get('original_format', 'mp3'),\n                'url': format_url,\n                'vcodec': 'none',\n                'preference': 10,\n            })\n\n        # We have to retrieve the url\n        format_dict = self._download_json(\n            'https://api.soundcloud.com/i1/tracks/%s/streams' % track_id,\n            track_id, 'Downloading track url', query=query)\n\n        for key, stream_url in format_dict.items():\n            abr = int_or_none(self._search_regex(\n                r'_(\\d+)_url', key, 'audio bitrate', default=None))\n            if key.startswith('http'):\n                stream_formats = [{\n                    'format_id': key,\n                    'ext': ext,\n                    'url': stream_url,\n                }]\n            elif key.startswith('rtmp'):\n                # The url doesn't have an rtmp app, we have to extract the playpath\n                url, path = stream_url.split('mp3:', 1)\n                stream_formats = [{\n                    'format_id': key,\n                    'url': url,\n                    'play_path': 'mp3:' + path,\n                    'ext': 'flv',\n                }]\n            elif key.startswith('hls'):\n                stream_formats = self._extract_m3u8_formats(\n                    stream_url, track_id, 'mp3', entry_protocol='m3u8_native',\n                    m3u8_id=key, fatal=False)\n            else:\n                continue\n\n            for f in stream_formats:\n                f['abr'] = abr\n\n            formats.extend(stream_formats)\n\n        if not formats:\n            # We fallback to the stream_url in the original info, this\n            # cannot be always used, sometimes it can give an HTTP 404 error\n            formats.append({\n                'format_id': 'fallback',\n                'url': update_url_query(info['stream_url'], query),\n                'ext': ext,\n            })\n\n        for f in formats:\n            f['vcodec'] = 'none'\n\n        self._check_formats(formats, track_id)\n        self._sort_formats(formats)\n        result['formats'] = formats\n\n        return result\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url, flags=re.VERBOSE)\n        if mobj is None:\n            raise ExtractorError('Invalid URL: %s' % url)\n\n        track_id = mobj.group('track_id')\n\n        if track_id is not None:\n            info_json_url = 'https://api.soundcloud.com/tracks/' + track_id + '.json?client_id=' + self._CLIENT_ID\n            full_title = track_id\n            token = mobj.group('secret_token')\n            if token:\n                info_json_url += '&secret_token=' + token\n        elif mobj.group('player'):\n            query = compat_urlparse.parse_qs(compat_urlparse.urlparse(url).query)\n            real_url = query['url'][0]\n            # If the token is in the query of the original url we have to\n            # manually add it\n            if 'secret_token' in query:\n                real_url += '?secret_token=' + query['secret_token'][0]\n            return self.url_result(real_url)\n        else:\n            # extract uploader (which is in the url)\n            uploader = mobj.group('uploader')\n            # extract simple title (uploader + slug of song title)\n            slug_title = mobj.group('title')\n            token = mobj.group('token')\n            full_title = resolve_title = '%s/%s' % (uploader, slug_title)\n            if token:\n                resolve_title += '/%s' % token\n\n            self.report_resolve(full_title)\n\n            url = 'https://soundcloud.com/%s' % resolve_title\n            info_json_url = self._resolv_url(url)\n        info = self._download_json(info_json_url, full_title, 'Downloading info JSON')\n\n        return self._extract_info_dict(info, full_title, secret_token=token)\n\n\nclass SoundcloudPlaylistBaseIE(SoundcloudIE):\n    @staticmethod\n    def _extract_id(e):\n        return compat_str(e['id']) if e.get('id') else None\n\n    def _extract_track_entries(self, tracks):\n        return [\n            self.url_result(\n                track['permalink_url'], SoundcloudIE.ie_key(),\n                video_id=self._extract_id(track))\n            for track in tracks if track.get('permalink_url')]\n\n\nclass SoundcloudSetIE(SoundcloudPlaylistBaseIE):\n    _VALID_URL = r'https?://(?:(?:www|m)\\.)?soundcloud\\.com/(?P<uploader>[\\w\\d-]+)/sets/(?P<slug_title>[\\w\\d-]+)(?:/(?P<token>[^?/]+))?'\n    IE_NAME = 'soundcloud:set'\n    _TESTS = [{\n        'url': 'https://soundcloud.com/the-concept-band/sets/the-royal-concept-ep',\n        'info_dict': {\n            'id': '2284613',\n            'title': 'The Royal Concept EP',\n        },\n        'playlist_mincount': 5,\n    }, {\n        'url': 'https://soundcloud.com/the-concept-band/sets/the-royal-concept-ep/token',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n\n        # extract uploader (which is in the url)\n        uploader = mobj.group('uploader')\n        # extract simple title (uploader + slug of song title)\n        slug_title = mobj.group('slug_title')\n        full_title = '%s/sets/%s' % (uploader, slug_title)\n        url = 'https://soundcloud.com/%s/sets/%s' % (uploader, slug_title)\n\n        token = mobj.group('token')\n        if token:\n            full_title += '/' + token\n            url += '/' + token\n\n        self.report_resolve(full_title)\n\n        resolv_url = self._resolv_url(url)\n        info = self._download_json(resolv_url, full_title)\n\n        if 'errors' in info:\n            msgs = (compat_str(err['error_message']) for err in info['errors'])\n            raise ExtractorError('unable to download video webpage: %s' % ','.join(msgs))\n\n        entries = self._extract_track_entries(info['tracks'])\n\n        return {\n            '_type': 'playlist',\n            'entries': entries,\n            'id': '%s' % info['id'],\n            'title': info['title'],\n        }\n\n\nclass SoundcloudPagedPlaylistBaseIE(SoundcloudPlaylistBaseIE):\n    _API_BASE = 'https://api.soundcloud.com'\n    _API_V2_BASE = 'https://api-v2.soundcloud.com'\n\n    def _extract_playlist(self, base_url, playlist_id, playlist_title):\n        COMMON_QUERY = {\n            'limit': 50,\n            'client_id': self._CLIENT_ID,\n            'linked_partitioning': '1',\n        }\n\n        query = COMMON_QUERY.copy()\n        query['offset'] = 0\n\n        next_href = base_url + '?' + compat_urllib_parse_urlencode(query)\n\n        entries = []\n        for i in itertools.count():\n            response = self._download_json(\n                next_href, playlist_id, 'Downloading track page %s' % (i + 1))\n\n            collection = response['collection']\n            if not collection:\n                break\n\n            def resolve_permalink_url(candidates):\n                for cand in candidates:\n                    if isinstance(cand, dict):\n                        permalink_url = cand.get('permalink_url')\n                        entry_id = self._extract_id(cand)\n                        if permalink_url and permalink_url.startswith('http'):\n                            return permalink_url, entry_id\n\n            for e in collection:\n                permalink_url, entry_id = resolve_permalink_url((e, e.get('track'), e.get('playlist')))\n                if permalink_url:\n                    entries.append(self.url_result(permalink_url, video_id=entry_id))\n\n            next_href = response.get('next_href')\n            if not next_href:\n                break\n\n            parsed_next_href = compat_urlparse.urlparse(response['next_href'])\n            qs = compat_urlparse.parse_qs(parsed_next_href.query)\n            qs.update(COMMON_QUERY)\n            next_href = compat_urlparse.urlunparse(\n                parsed_next_href._replace(query=compat_urllib_parse_urlencode(qs, True)))\n\n        return {\n            '_type': 'playlist',\n            'id': playlist_id,\n            'title': playlist_title,\n            'entries': entries,\n        }\n\n\nclass SoundcloudUserIE(SoundcloudPagedPlaylistBaseIE):\n    _VALID_URL = r'''(?x)\n                        https?://\n                            (?:(?:www|m)\\.)?soundcloud\\.com/\n                            (?P<user>[^/]+)\n                            (?:/\n                                (?P<rsrc>tracks|sets|reposts|likes|spotlight)\n                            )?\n                            /?(?:[?#].*)?$\n                    '''\n    IE_NAME = 'soundcloud:user'\n    _TESTS = [{\n        'url': 'https://soundcloud.com/the-akashic-chronicler',\n        'info_dict': {\n            'id': '114582580',\n            'title': 'The Akashic Chronicler (All)',\n        },\n        'playlist_mincount': 74,\n    }, {\n        'url': 'https://soundcloud.com/the-akashic-chronicler/tracks',\n        'info_dict': {\n            'id': '114582580',\n            'title': 'The Akashic Chronicler (Tracks)',\n        },\n        'playlist_mincount': 37,\n    }, {\n        'url': 'https://soundcloud.com/the-akashic-chronicler/sets',\n        'info_dict': {\n            'id': '114582580',\n            'title': 'The Akashic Chronicler (Playlists)',\n        },\n        'playlist_mincount': 2,\n    }, {\n        'url': 'https://soundcloud.com/the-akashic-chronicler/reposts',\n        'info_dict': {\n            'id': '114582580',\n            'title': 'The Akashic Chronicler (Reposts)',\n        },\n        'playlist_mincount': 7,\n    }, {\n        'url': 'https://soundcloud.com/the-akashic-chronicler/likes',\n        'info_dict': {\n            'id': '114582580',\n            'title': 'The Akashic Chronicler (Likes)',\n        },\n        'playlist_mincount': 321,\n    }, {\n        'url': 'https://soundcloud.com/grynpyret/spotlight',\n        'info_dict': {\n            'id': '7098329',\n            'title': 'Grynpyret (Spotlight)',\n        },\n        'playlist_mincount': 1,\n    }]\n\n    _BASE_URL_MAP = {\n        'all': '%s/profile/soundcloud:users:%%s' % SoundcloudPagedPlaylistBaseIE._API_V2_BASE,\n        'tracks': '%s/users/%%s/tracks' % SoundcloudPagedPlaylistBaseIE._API_BASE,\n        'sets': '%s/users/%%s/playlists' % SoundcloudPagedPlaylistBaseIE._API_V2_BASE,\n        'reposts': '%s/profile/soundcloud:users:%%s/reposts' % SoundcloudPagedPlaylistBaseIE._API_V2_BASE,\n        'likes': '%s/users/%%s/likes' % SoundcloudPagedPlaylistBaseIE._API_V2_BASE,\n        'spotlight': '%s/users/%%s/spotlight' % SoundcloudPagedPlaylistBaseIE._API_V2_BASE,\n    }\n\n    _TITLE_MAP = {\n        'all': 'All',\n        'tracks': 'Tracks',\n        'sets': 'Playlists',\n        'reposts': 'Reposts',\n        'likes': 'Likes',\n        'spotlight': 'Spotlight',\n    }\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        uploader = mobj.group('user')\n\n        url = 'https://soundcloud.com/%s/' % uploader\n        resolv_url = self._resolv_url(url)\n        user = self._download_json(\n            resolv_url, uploader, 'Downloading user info')\n\n        resource = mobj.group('rsrc') or 'all'\n\n        return self._extract_playlist(\n            self._BASE_URL_MAP[resource] % user['id'], compat_str(user['id']),\n            '%s (%s)' % (user['username'], self._TITLE_MAP[resource]))\n\n\nclass SoundcloudTrackStationIE(SoundcloudPagedPlaylistBaseIE):\n    _VALID_URL = r'https?://(?:(?:www|m)\\.)?soundcloud\\.com/stations/track/[^/]+/(?P<id>[^/?#&]+)'\n    IE_NAME = 'soundcloud:trackstation'\n    _TESTS = [{\n        'url': 'https://soundcloud.com/stations/track/officialsundial/your-text',\n        'info_dict': {\n            'id': '286017854',\n            'title': 'Track station: your-text',\n        },\n        'playlist_mincount': 47,\n    }]\n\n    def _real_extract(self, url):\n        track_name = self._match_id(url)\n\n        webpage = self._download_webpage(url, track_name)\n\n        track_id = self._search_regex(\n            r'soundcloud:track-stations:(\\d+)', webpage, 'track id')\n\n        return self._extract_playlist(\n            '%s/stations/soundcloud:track-stations:%s/tracks'\n            % (self._API_V2_BASE, track_id),\n            track_id, 'Track station: %s' % track_name)\n\n\nclass SoundcloudPlaylistIE(SoundcloudPlaylistBaseIE):\n    _VALID_URL = r'https?://api\\.soundcloud\\.com/playlists/(?P<id>[0-9]+)(?:/?\\?secret_token=(?P<token>[^&]+?))?$'\n    IE_NAME = 'soundcloud:playlist'\n    _TESTS = [{\n        'url': 'https://api.soundcloud.com/playlists/4110309',\n        'info_dict': {\n            'id': '4110309',\n            'title': 'TILT Brass - Bowery Poetry Club, August \\'03 [Non-Site SCR 02]',\n            'description': 're:.*?TILT Brass - Bowery Poetry Club',\n        },\n        'playlist_count': 6,\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        playlist_id = mobj.group('id')\n        base_url = '%s//api.soundcloud.com/playlists/%s.json?' % (self.http_scheme(), playlist_id)\n\n        data_dict = {\n            'client_id': self._CLIENT_ID,\n        }\n        token = mobj.group('token')\n\n        if token:\n            data_dict['secret_token'] = token\n\n        data = compat_urllib_parse_urlencode(data_dict)\n        data = self._download_json(\n            base_url + data, playlist_id, 'Downloading playlist')\n\n        entries = self._extract_track_entries(data['tracks'])\n\n        return {\n            '_type': 'playlist',\n            'id': playlist_id,\n            'title': data.get('title'),\n            'description': data.get('description'),\n            'entries': entries,\n        }\n\n\nclass SoundcloudSearchIE(SearchInfoExtractor, SoundcloudIE):\n    IE_NAME = 'soundcloud:search'\n    IE_DESC = 'Soundcloud search'\n    _MAX_RESULTS = float('inf')\n    _TESTS = [{\n        'url': 'scsearch15:post-avant jazzcore',\n        'info_dict': {\n            'title': 'post-avant jazzcore',\n        },\n        'playlist_count': 15,\n    }]\n\n    _SEARCH_KEY = 'scsearch'\n    _MAX_RESULTS_PER_PAGE = 200\n    _DEFAULT_RESULTS_PER_PAGE = 50\n    _API_V2_BASE = 'https://api-v2.soundcloud.com'\n\n    def _get_collection(self, endpoint, collection_id, **query):\n        limit = min(\n            query.get('limit', self._DEFAULT_RESULTS_PER_PAGE),\n            self._MAX_RESULTS_PER_PAGE)\n        query['limit'] = limit\n        query['client_id'] = self._CLIENT_ID\n        query['linked_partitioning'] = '1'\n        query['offset'] = 0\n        data = compat_urllib_parse_urlencode(query)\n        next_url = '{0}{1}?{2}'.format(self._API_V2_BASE, endpoint, data)\n\n        collected_results = 0\n\n        for i in itertools.count(1):\n            response = self._download_json(\n                next_url, collection_id, 'Downloading page {0}'.format(i),\n                'Unable to download API page')\n\n            collection = response.get('collection', [])\n            if not collection:\n                break\n\n            collection = list(filter(bool, collection))\n            collected_results += len(collection)\n\n            for item in collection:\n                yield self.url_result(item['uri'], SoundcloudIE.ie_key())\n\n            if not collection or collected_results >= limit:\n                break\n\n            next_url = response.get('next_href')\n            if not next_url:\n                break\n\n    def _get_n_results(self, query, n):\n        tracks = self._get_collection('/search/tracks', query, limit=n, q=query)\n        return self.playlist_result(tracks, playlist_title=query)\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "soundcloud.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/soundcloud.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}