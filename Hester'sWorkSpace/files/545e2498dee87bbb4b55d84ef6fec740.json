{"author": "yunjey", "code": "import torch \nimport torch.nn as nn\nimport torchvision.datasets as dsets\nimport torchvision.transforms as transforms\nfrom torch.autograd import Variable\n\n\n\nnum_epochs = 5\nbatch_size = 100\nlearning_rate = 0.001\n\n\ntrain_dataset = dsets.MNIST(root='./data/',\n                            train=True, \n                            transform=transforms.ToTensor(),\n                            download=True)\n\ntest_dataset = dsets.MNIST(root='./data/',\n                           train=False, \n                           transform=transforms.ToTensor())\n\n# Data Loader (Input Pipeline)\ntrain_loader = torch.utils.data.DataLoader(dataset=train_dataset,\n                                           batch_size=batch_size, \n                                           shuffle=True)\n\ntest_loader = torch.utils.data.DataLoader(dataset=test_dataset,\n                                          batch_size=batch_size, \n                                          shuffle=False)\n\n# CNN Model (2 conv layer)\nclass CNN(nn.Module):\n    def __init__(self):\n        super(CNN, self).__init__()\n        self.layer1 = nn.Sequential(\n            nn.Conv2d(1, 16, kernel_size=5, padding=2),\n            nn.BatchNorm2d(16),\n            nn.ReLU(),\n            nn.MaxPool2d(2))\n        self.layer2 = nn.Sequential(\n            nn.Conv2d(16, 32, kernel_size=5, padding=2),\n            nn.BatchNorm2d(32),\n            nn.ReLU(),\n            nn.MaxPool2d(2))\n        self.fc = nn.Linear(7*7*32, 10)\n        \n    def forward(self, x):\n        out = self.layer1(x)\n        out = self.layer2(out)\n        out = out.view(out.size(0), -1)\n        out = self.fc(out)\n        return out\n        \ncnn = CNN()\ncnn.cuda()\n\n\ncriterion = nn.CrossEntropyLoss()\noptimizer = torch.optim.Adam(cnn.parameters(), lr=learning_rate)\n\n\nfor epoch in range(num_epochs):\n    for i, (images, labels) in enumerate(train_loader):\n        images = Variable(images).cuda()\n        labels = Variable(labels).cuda()\n        \n        # Forward + Backward + Optimize\n        optimizer.zero_grad()\n        outputs = cnn(images)\n        loss = criterion(outputs, labels)\n        loss.backward()\n        optimizer.step()\n        \n        if (i+1) % 100 == 0:\n            print ('Epoch [%d/%d], Iter [%d/%d] Loss: %.4f' \n                   %(epoch+1, num_epochs, i+1, len(train_dataset)//batch_size, loss.data[0]))\n\n\ncnn.eval()    # Change model to 'eval' mode (BN uses moving mean/var).\ncorrect = 0\ntotal = 0\nfor images, labels in test_loader:\n    images = Variable(images).cuda()\n    outputs = cnn(images)\n    _, predicted = torch.max(outputs.data, 1)\n    total += labels.size(0)\n    correct += (predicted.cpu() == labels).sum()\n\nprint('Test Accuracy of the model on the 10000 test images: %d %%' % (100 * correct / total))\n\n\ntorch.save(cnn.state_dict(), 'cnn.pkl')", "comments": "  hyper parameters    mnist dataset    data loader (input pipeline)    cnn model (2 conv layer)    loss optimizer    train model    forward   backward   optimize    test model    change model  eval  mode (bn uses moving mean var)     save trained model ", "content": "import torch \nimport torch.nn as nn\nimport torchvision.datasets as dsets\nimport torchvision.transforms as transforms\nfrom torch.autograd import Variable\n\n\n# Hyper Parameters\nnum_epochs = 5\nbatch_size = 100\nlearning_rate = 0.001\n\n# MNIST Dataset\ntrain_dataset = dsets.MNIST(root='./data/',\n                            train=True, \n                            transform=transforms.ToTensor(),\n                            download=True)\n\ntest_dataset = dsets.MNIST(root='./data/',\n                           train=False, \n                           transform=transforms.ToTensor())\n\n# Data Loader (Input Pipeline)\ntrain_loader = torch.utils.data.DataLoader(dataset=train_dataset,\n                                           batch_size=batch_size, \n                                           shuffle=True)\n\ntest_loader = torch.utils.data.DataLoader(dataset=test_dataset,\n                                          batch_size=batch_size, \n                                          shuffle=False)\n\n# CNN Model (2 conv layer)\nclass CNN(nn.Module):\n    def __init__(self):\n        super(CNN, self).__init__()\n        self.layer1 = nn.Sequential(\n            nn.Conv2d(1, 16, kernel_size=5, padding=2),\n            nn.BatchNorm2d(16),\n            nn.ReLU(),\n            nn.MaxPool2d(2))\n        self.layer2 = nn.Sequential(\n            nn.Conv2d(16, 32, kernel_size=5, padding=2),\n            nn.BatchNorm2d(32),\n            nn.ReLU(),\n            nn.MaxPool2d(2))\n        self.fc = nn.Linear(7*7*32, 10)\n        \n    def forward(self, x):\n        out = self.layer1(x)\n        out = self.layer2(out)\n        out = out.view(out.size(0), -1)\n        out = self.fc(out)\n        return out\n        \ncnn = CNN()\ncnn.cuda()\n\n# Loss and Optimizer\ncriterion = nn.CrossEntropyLoss()\noptimizer = torch.optim.Adam(cnn.parameters(), lr=learning_rate)\n\n# Train the Model\nfor epoch in range(num_epochs):\n    for i, (images, labels) in enumerate(train_loader):\n        images = Variable(images).cuda()\n        labels = Variable(labels).cuda()\n        \n        # Forward + Backward + Optimize\n        optimizer.zero_grad()\n        outputs = cnn(images)\n        loss = criterion(outputs, labels)\n        loss.backward()\n        optimizer.step()\n        \n        if (i+1) % 100 == 0:\n            print ('Epoch [%d/%d], Iter [%d/%d] Loss: %.4f' \n                   %(epoch+1, num_epochs, i+1, len(train_dataset)//batch_size, loss.data[0]))\n\n# Test the Model\ncnn.eval()    # Change model to 'eval' mode (BN uses moving mean/var).\ncorrect = 0\ntotal = 0\nfor images, labels in test_loader:\n    images = Variable(images).cuda()\n    outputs = cnn(images)\n    _, predicted = torch.max(outputs.data, 1)\n    total += labels.size(0)\n    correct += (predicted.cpu() == labels).sum()\n\nprint('Test Accuracy of the model on the 10000 test images: %d %%' % (100 * correct / total))\n\n# Save the Trained Model\ntorch.save(cnn.state_dict(), 'cnn.pkl')", "description": "PyTorch Tutorial for Deep Learning Researchers", "file_name": "main-gpu.py", "id": "545e2498dee87bbb4b55d84ef6fec740", "language": "Python", "project_name": "pytorch-tutorial", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/yunjey-pytorch-tutorial/yunjey-pytorch-tutorial-6c785eb/tutorials/02-intermediate/convolutional_neural_network/main-gpu.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:24:45Z", "url": "https://github.com/yunjey/pytorch-tutorial", "wiki": true}