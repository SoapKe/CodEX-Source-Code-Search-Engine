{"author": "bitcoinbook", "code": "from __future__ import print_function\nimport bitcoin\n\n\nvalid_private_key = False\nwhile not valid_private_key:\n    private_key = bitcoin.random_key()\n    decoded_private_key = bitcoin.decode_privkey(private_key, 'hex')\n    valid_private_key = 0 < decoded_private_key < bitcoin.N\n\nprint(\"Private Key (hex) is: \", private_key)\nprint(\"Private Key (decimal) is: \", decoded_private_key)\n\n\nwif_encoded_private_key = bitcoin.encode_privkey(decoded_private_key, 'wif')\nprint(\"Private Key (WIF) is: \", wif_encoded_private_key)\n\n\ncompressed_private_key = private_key + '01'\nprint(\"Private Key Compressed (hex) is: \", compressed_private_key)\n\n# Generate a WIF format from the compressed private key (WIF-compressed)\nwif_compressed_private_key = bitcoin.encode_privkey(\n    bitcoin.decode_privkey(compressed_private_key, 'hex'), 'wif_compressed')\nprint(\"Private Key (WIF-Compressed) is: \", wif_compressed_private_key)\n\n\npublic_key = bitcoin.fast_multiply(bitcoin.G, decoded_private_key)\nprint(\"Public Key (x,y) coordinates is:\", public_key)\n\n\nhex_encoded_public_key = bitcoin.encode_pubkey(public_key, 'hex')\nprint(\"Public Key (hex) is:\", hex_encoded_public_key)\n\n\n(public_key_x, public_key_y) = public_key\ncompressed_prefix = '02' if (public_key_y % 2) == 0 else '03'\nhex_compressed_public_key = compressed_prefix + (bitcoin.encode(public_key_x, 16).zfill(64))\nprint(\"Compressed Public Key (hex) is:\", hex_compressed_public_key)\n\n\nprint(\"Bitcoin Address (b58check) is:\", bitcoin.pubkey_to_address(public_key))\n\n\nprint(\"Compressed Bitcoin Address (b58check) is:\",\n      bitcoin.pubkey_to_address(hex_compressed_public_key))\n", "comments": "  generate random private key    convert private key wif format    add suffix  01  indicate compressed private key    generate wif format compressed private key (wif compressed)    multiply ec generator point g private key get public key point    encode hex  prefix 04    compress public key  adjust prefix depending whether even odd    generate bitcoin address public key    generate compressed bitcoin address compressed public key ", "content": "from __future__ import print_function\nimport bitcoin\n\n# Generate a random private key\nvalid_private_key = False\nwhile not valid_private_key:\n    private_key = bitcoin.random_key()\n    decoded_private_key = bitcoin.decode_privkey(private_key, 'hex')\n    valid_private_key = 0 < decoded_private_key < bitcoin.N\n\nprint(\"Private Key (hex) is: \", private_key)\nprint(\"Private Key (decimal) is: \", decoded_private_key)\n\n# Convert private key to WIF format\nwif_encoded_private_key = bitcoin.encode_privkey(decoded_private_key, 'wif')\nprint(\"Private Key (WIF) is: \", wif_encoded_private_key)\n\n# Add suffix \"01\" to indicate a compressed private key\ncompressed_private_key = private_key + '01'\nprint(\"Private Key Compressed (hex) is: \", compressed_private_key)\n\n# Generate a WIF format from the compressed private key (WIF-compressed)\nwif_compressed_private_key = bitcoin.encode_privkey(\n    bitcoin.decode_privkey(compressed_private_key, 'hex'), 'wif_compressed')\nprint(\"Private Key (WIF-Compressed) is: \", wif_compressed_private_key)\n\n# Multiply the EC generator point G with the private key to get a public key point\npublic_key = bitcoin.fast_multiply(bitcoin.G, decoded_private_key)\nprint(\"Public Key (x,y) coordinates is:\", public_key)\n\n# Encode as hex, prefix 04\nhex_encoded_public_key = bitcoin.encode_pubkey(public_key, 'hex')\nprint(\"Public Key (hex) is:\", hex_encoded_public_key)\n\n# Compress public key, adjust prefix depending on whether y is even or odd\n(public_key_x, public_key_y) = public_key\ncompressed_prefix = '02' if (public_key_y % 2) == 0 else '03'\nhex_compressed_public_key = compressed_prefix + (bitcoin.encode(public_key_x, 16).zfill(64))\nprint(\"Compressed Public Key (hex) is:\", hex_compressed_public_key)\n\n# Generate bitcoin address from public key\nprint(\"Bitcoin Address (b58check) is:\", bitcoin.pubkey_to_address(public_key))\n\n# Generate compressed bitcoin address from compressed public key\nprint(\"Compressed Bitcoin Address (b58check) is:\",\n      bitcoin.pubkey_to_address(hex_compressed_public_key))\n", "description": "Mastering Bitcoin 2nd Edition - Programming the Open Blockchain", "file_name": "key-to-address-ecc-example.py", "id": "2312c15bddbe54e8c74ffbb6a2434336", "language": "Python", "project_name": "bitcoinbook", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/bitcoinbook-bitcoinbook/bitcoinbook-bitcoinbook-f8b883d/code/key-to-address-ecc-example.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:38:06Z", "url": "https://github.com/bitcoinbook/bitcoinbook", "wiki": false}