{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport itertools\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    get_element_by_attribute,\n    int_or_none,\n    lowercase_escape,\n    try_get,\n)\n\n\nclass InstagramIE(InfoExtractor):\n    _VALID_URL = r'(?P<url>https?://(?:www\\.)?instagram\\.com/p/(?P<id>[^/?\n    _TESTS = [{\n        'url': 'https://instagram.com/p/aye83DjauH/?foo=bar\n        'md5': '0d2da106a9d2631273e192b372806516',\n        'info_dict': {\n            'id': 'aye83DjauH',\n            'ext': 'mp4',\n            'title': 'Video by naomipq',\n            'description': 'md5:1f17f0ab29bd6fe2bfad705f58de3cb8',\n            'thumbnail': r're:^https?://.*\\.jpg',\n            'timestamp': 1371748545,\n            'upload_date': '20130620',\n            'uploader_id': 'naomipq',\n            'uploader': 'Naomi Leonor Phan-Quang',\n            'like_count': int,\n            'comment_count': int,\n            'comments': list,\n        },\n    }, {\n        \n        'url': 'https://www.instagram.com/p/BA-pQFBG8HZ/?taken-by=britneyspears',\n        'info_dict': {\n            'id': 'BA-pQFBG8HZ',\n            'ext': 'mp4',\n            'title': 'Video by britneyspears',\n            'thumbnail': r're:^https?://.*\\.jpg',\n            'timestamp': 1453760977,\n            'upload_date': '20160125',\n            'uploader_id': 'britneyspears',\n            'uploader': 'Britney Spears',\n            'like_count': int,\n            'comment_count': int,\n            'comments': list,\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }, {\n        \n        'url': 'https://www.instagram.com/p/BQ0eAlwhDrw/',\n        'playlist': [{\n            'info_dict': {\n                'id': 'BQ0dSaohpPW',\n                'ext': 'mp4',\n                'title': 'Video 1',\n            },\n        }, {\n            'info_dict': {\n                'id': 'BQ0dTpOhuHT',\n                'ext': 'mp4',\n                'title': 'Video 2',\n            },\n        }, {\n            'info_dict': {\n                'id': 'BQ0dT7RBFeF',\n                'ext': 'mp4',\n                'title': 'Video 3',\n            },\n        }],\n        'info_dict': {\n            'id': 'BQ0eAlwhDrw',\n            'title': 'Post by instagram',\n            'description': 'md5:0f9203fc6a2ce4d228da5754bcf54957',\n        },\n    }, {\n        'url': 'https://instagram.com/p/-Cmh1cukG2/',\n        'only_matching': True,\n    }, {\n        'url': 'http://instagram.com/p/9o6LshA7zy/embed/',\n        'only_matching': True,\n    }]\n\n    @staticmethod\n    def _extract_embed_url(webpage):\n        mobj = re.search(\n            r'<iframe[^>]+src=([\"\\'])(?P<url>(?:https?:)?//(?:www\\.)?instagram\\.com/p/[^/]+/embed.*?)\\1',\n            webpage)\n        if mobj:\n            return mobj.group('url')\n\n        blockquote_el = get_element_by_attribute(\n            'class', 'instagram-media', webpage)\n        if blockquote_el is None:\n            return\n\n        mobj = re.search(\n            r'<a[^>]+href=([\\'\"])(?P<link>[^\\'\"]+)\\1', blockquote_el)\n        if mobj:\n            return mobj.group('link')\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        video_id = mobj.group('id')\n        url = mobj.group('url')\n\n        webpage = self._download_webpage(url, video_id)\n\n        (video_url, description, thumbnail, timestamp, uploader,\n         uploader_id, like_count, comment_count, comments, height,\n         width) = [None] * 11\n\n        shared_data = self._parse_json(\n            self._search_regex(\n                r'window\\._sharedData\\s*=\\s*({.+?});',\n                webpage, 'shared data', default='{}'),\n            video_id, fatal=False)\n        if shared_data:\n            media = try_get(\n                shared_data,\n                (lambda x: x['entry_data']['PostPage'][0]['graphql']['shortcode_media'],\n                 lambda x: x['entry_data']['PostPage'][0]['media']),\n                dict)\n            if media:\n                video_url = media.get('video_url')\n                height = int_or_none(media.get('dimensions', {}).get('height'))\n                width = int_or_none(media.get('dimensions', {}).get('width'))\n                description = try_get(\n                    media, lambda x: x['edge_media_to_caption']['edges'][0]['node']['text'],\n                    compat_str) or media.get('caption')\n                thumbnail = media.get('display_src')\n                timestamp = int_or_none(media.get('taken_at_timestamp') or media.get('date'))\n                uploader = media.get('owner', {}).get('full_name')\n                uploader_id = media.get('owner', {}).get('username')\n\n                def get_count(key, kind):\n                    return int_or_none(try_get(\n                        media, (lambda x: x['edge_media_%s' % key]['count'],\n                                lambda x: x['%ss' % kind]['count'])))\n                like_count = get_count('preview_like', 'like')\n                comment_count = get_count('to_comment', 'comment')\n\n                comments = [{\n                    'author': comment.get('user', {}).get('username'),\n                    'author_id': comment.get('user', {}).get('id'),\n                    'id': comment.get('id'),\n                    'text': comment.get('text'),\n                    'timestamp': int_or_none(comment.get('created_at')),\n                } for comment in media.get(\n                    'comments', {}).get('nodes', []) if comment.get('text')]\n                if not video_url:\n                    edges = try_get(\n                        media, lambda x: x['edge_sidecar_to_children']['edges'],\n                        list) or []\n                    if edges:\n                        entries = []\n                        for edge_num, edge in enumerate(edges, start=1):\n                            node = try_get(edge, lambda x: x['node'], dict)\n                            if not node:\n                                continue\n                            node_video_url = try_get(node, lambda x: x['video_url'], compat_str)\n                            if not node_video_url:\n                                continue\n                            entries.append({\n                                'id': node.get('shortcode') or node['id'],\n                                'title': 'Video %d' % edge_num,\n                                'url': node_video_url,\n                                'thumbnail': node.get('display_url'),\n                                'width': int_or_none(try_get(node, lambda x: x['dimensions']['width'])),\n                                'height': int_or_none(try_get(node, lambda x: x['dimensions']['height'])),\n                                'view_count': int_or_none(node.get('video_view_count')),\n                            })\n                        return self.playlist_result(\n                            entries, video_id,\n                            'Post by %s' % uploader_id if uploader_id else None,\n                            description)\n\n        if not video_url:\n            video_url = self._og_search_video_url(webpage, secure=False)\n\n        formats = [{\n            'url': video_url,\n            'width': width,\n            'height': height,\n        }]\n\n        if not uploader_id:\n            uploader_id = self._search_regex(\n                r'\"owner\"\\s*:\\s*{\\s*\"username\"\\s*:\\s*\"(.+?)\"',\n                webpage, 'uploader id', fatal=False)\n\n        if not description:\n            description = self._search_regex(\n                r'\"caption\"\\s*:\\s*\"(.+?)\"', webpage, 'description', default=None)\n            if description is not None:\n                description = lowercase_escape(description)\n\n        if not thumbnail:\n            thumbnail = self._og_search_thumbnail(webpage)\n\n        return {\n            'id': video_id,\n            'formats': formats,\n            'ext': 'mp4',\n            'title': 'Video by %s' % uploader_id,\n            'description': description,\n            'thumbnail': thumbnail,\n            'timestamp': timestamp,\n            'uploader_id': uploader_id,\n            'uploader': uploader,\n            'like_count': like_count,\n            'comment_count': comment_count,\n            'comments': comments,\n        }\n\n\nclass InstagramUserIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?instagram\\.com/(?P<id>[^/]{2,})/?(?:$|[?\n    IE_DESC = 'Instagram user profile'\n    IE_NAME = 'instagram:user'\n    _TEST = {\n        'url': 'https://instagram.com/porsche',\n        'info_dict': {\n            'id': 'porsche',\n            'title': 'porsche',\n        },\n        'playlist_count': 5,\n        'params': {\n            'extract_flat': True,\n            'skip_download': True,\n            'playlistend': 5,\n        }\n    }\n\n    def _entries(self, uploader_id):\n        query = {\n            '__a': 1,\n        }\n\n        def get_count(kind):\n            return int_or_none(try_get(\n                node, lambda x: x['%ss' % kind]['count']))\n\n        for page_num in itertools.count(1):\n            page = self._download_json(\n                'https://instagram.com/%s/' % uploader_id, uploader_id,\n                note='Downloading page %d' % page_num,\n                fatal=False, query=query)\n            if not page:\n                break\n\n            nodes = try_get(page, lambda x: x['user']['media']['nodes'], list)\n            if not nodes:\n                break\n\n            max_id = None\n\n            for node in nodes:\n                node_id = node.get('id')\n                if node_id:\n                    max_id = node_id\n\n                if node.get('__typename') != 'GraphVideo' and node.get('is_video') is not True:\n                    continue\n                video_id = node.get('code')\n                if not video_id:\n                    continue\n\n                info = self.url_result(\n                    'https://instagram.com/p/%s/' % video_id,\n                    ie=InstagramIE.ie_key(), video_id=video_id)\n\n                description = try_get(\n                    node, [lambda x: x['caption'], lambda x: x['text']['id']],\n                    compat_str)\n                thumbnail = node.get('thumbnail_src') or node.get('display_src')\n                timestamp = int_or_none(node.get('date'))\n\n                comment_count = get_count('comment')\n                like_count = get_count('like')\n                view_count = int_or_none(node.get('video_views'))\n\n                info.update({\n                    'description': description,\n                    'thumbnail': thumbnail,\n                    'timestamp': timestamp,\n                    'comment_count': comment_count,\n                    'like_count': like_count,\n                    'view_count': view_count,\n                })\n\n                yield info\n\n            if not max_id:\n                break\n\n            query['max_id'] = max_id\n\n    def _real_extract(self, url):\n        uploader_id = self._match_id(url)\n        return self.playlist_result(\n            self._entries(uploader_id), uploader_id, uploader_id)\n", "comments": "#&]+))'\n#abc',\n# missing description\n# multi video post\n#])'\n", "content": "from __future__ import unicode_literals\n\nimport itertools\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    get_element_by_attribute,\n    int_or_none,\n    lowercase_escape,\n    try_get,\n)\n\n\nclass InstagramIE(InfoExtractor):\n    _VALID_URL = r'(?P<url>https?://(?:www\\.)?instagram\\.com/p/(?P<id>[^/?#&]+))'\n    _TESTS = [{\n        'url': 'https://instagram.com/p/aye83DjauH/?foo=bar#abc',\n        'md5': '0d2da106a9d2631273e192b372806516',\n        'info_dict': {\n            'id': 'aye83DjauH',\n            'ext': 'mp4',\n            'title': 'Video by naomipq',\n            'description': 'md5:1f17f0ab29bd6fe2bfad705f58de3cb8',\n            'thumbnail': r're:^https?://.*\\.jpg',\n            'timestamp': 1371748545,\n            'upload_date': '20130620',\n            'uploader_id': 'naomipq',\n            'uploader': 'Naomi Leonor Phan-Quang',\n            'like_count': int,\n            'comment_count': int,\n            'comments': list,\n        },\n    }, {\n        # missing description\n        'url': 'https://www.instagram.com/p/BA-pQFBG8HZ/?taken-by=britneyspears',\n        'info_dict': {\n            'id': 'BA-pQFBG8HZ',\n            'ext': 'mp4',\n            'title': 'Video by britneyspears',\n            'thumbnail': r're:^https?://.*\\.jpg',\n            'timestamp': 1453760977,\n            'upload_date': '20160125',\n            'uploader_id': 'britneyspears',\n            'uploader': 'Britney Spears',\n            'like_count': int,\n            'comment_count': int,\n            'comments': list,\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }, {\n        # multi video post\n        'url': 'https://www.instagram.com/p/BQ0eAlwhDrw/',\n        'playlist': [{\n            'info_dict': {\n                'id': 'BQ0dSaohpPW',\n                'ext': 'mp4',\n                'title': 'Video 1',\n            },\n        }, {\n            'info_dict': {\n                'id': 'BQ0dTpOhuHT',\n                'ext': 'mp4',\n                'title': 'Video 2',\n            },\n        }, {\n            'info_dict': {\n                'id': 'BQ0dT7RBFeF',\n                'ext': 'mp4',\n                'title': 'Video 3',\n            },\n        }],\n        'info_dict': {\n            'id': 'BQ0eAlwhDrw',\n            'title': 'Post by instagram',\n            'description': 'md5:0f9203fc6a2ce4d228da5754bcf54957',\n        },\n    }, {\n        'url': 'https://instagram.com/p/-Cmh1cukG2/',\n        'only_matching': True,\n    }, {\n        'url': 'http://instagram.com/p/9o6LshA7zy/embed/',\n        'only_matching': True,\n    }]\n\n    @staticmethod\n    def _extract_embed_url(webpage):\n        mobj = re.search(\n            r'<iframe[^>]+src=([\"\\'])(?P<url>(?:https?:)?//(?:www\\.)?instagram\\.com/p/[^/]+/embed.*?)\\1',\n            webpage)\n        if mobj:\n            return mobj.group('url')\n\n        blockquote_el = get_element_by_attribute(\n            'class', 'instagram-media', webpage)\n        if blockquote_el is None:\n            return\n\n        mobj = re.search(\n            r'<a[^>]+href=([\\'\"])(?P<link>[^\\'\"]+)\\1', blockquote_el)\n        if mobj:\n            return mobj.group('link')\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        video_id = mobj.group('id')\n        url = mobj.group('url')\n\n        webpage = self._download_webpage(url, video_id)\n\n        (video_url, description, thumbnail, timestamp, uploader,\n         uploader_id, like_count, comment_count, comments, height,\n         width) = [None] * 11\n\n        shared_data = self._parse_json(\n            self._search_regex(\n                r'window\\._sharedData\\s*=\\s*({.+?});',\n                webpage, 'shared data', default='{}'),\n            video_id, fatal=False)\n        if shared_data:\n            media = try_get(\n                shared_data,\n                (lambda x: x['entry_data']['PostPage'][0]['graphql']['shortcode_media'],\n                 lambda x: x['entry_data']['PostPage'][0]['media']),\n                dict)\n            if media:\n                video_url = media.get('video_url')\n                height = int_or_none(media.get('dimensions', {}).get('height'))\n                width = int_or_none(media.get('dimensions', {}).get('width'))\n                description = try_get(\n                    media, lambda x: x['edge_media_to_caption']['edges'][0]['node']['text'],\n                    compat_str) or media.get('caption')\n                thumbnail = media.get('display_src')\n                timestamp = int_or_none(media.get('taken_at_timestamp') or media.get('date'))\n                uploader = media.get('owner', {}).get('full_name')\n                uploader_id = media.get('owner', {}).get('username')\n\n                def get_count(key, kind):\n                    return int_or_none(try_get(\n                        media, (lambda x: x['edge_media_%s' % key]['count'],\n                                lambda x: x['%ss' % kind]['count'])))\n                like_count = get_count('preview_like', 'like')\n                comment_count = get_count('to_comment', 'comment')\n\n                comments = [{\n                    'author': comment.get('user', {}).get('username'),\n                    'author_id': comment.get('user', {}).get('id'),\n                    'id': comment.get('id'),\n                    'text': comment.get('text'),\n                    'timestamp': int_or_none(comment.get('created_at')),\n                } for comment in media.get(\n                    'comments', {}).get('nodes', []) if comment.get('text')]\n                if not video_url:\n                    edges = try_get(\n                        media, lambda x: x['edge_sidecar_to_children']['edges'],\n                        list) or []\n                    if edges:\n                        entries = []\n                        for edge_num, edge in enumerate(edges, start=1):\n                            node = try_get(edge, lambda x: x['node'], dict)\n                            if not node:\n                                continue\n                            node_video_url = try_get(node, lambda x: x['video_url'], compat_str)\n                            if not node_video_url:\n                                continue\n                            entries.append({\n                                'id': node.get('shortcode') or node['id'],\n                                'title': 'Video %d' % edge_num,\n                                'url': node_video_url,\n                                'thumbnail': node.get('display_url'),\n                                'width': int_or_none(try_get(node, lambda x: x['dimensions']['width'])),\n                                'height': int_or_none(try_get(node, lambda x: x['dimensions']['height'])),\n                                'view_count': int_or_none(node.get('video_view_count')),\n                            })\n                        return self.playlist_result(\n                            entries, video_id,\n                            'Post by %s' % uploader_id if uploader_id else None,\n                            description)\n\n        if not video_url:\n            video_url = self._og_search_video_url(webpage, secure=False)\n\n        formats = [{\n            'url': video_url,\n            'width': width,\n            'height': height,\n        }]\n\n        if not uploader_id:\n            uploader_id = self._search_regex(\n                r'\"owner\"\\s*:\\s*{\\s*\"username\"\\s*:\\s*\"(.+?)\"',\n                webpage, 'uploader id', fatal=False)\n\n        if not description:\n            description = self._search_regex(\n                r'\"caption\"\\s*:\\s*\"(.+?)\"', webpage, 'description', default=None)\n            if description is not None:\n                description = lowercase_escape(description)\n\n        if not thumbnail:\n            thumbnail = self._og_search_thumbnail(webpage)\n\n        return {\n            'id': video_id,\n            'formats': formats,\n            'ext': 'mp4',\n            'title': 'Video by %s' % uploader_id,\n            'description': description,\n            'thumbnail': thumbnail,\n            'timestamp': timestamp,\n            'uploader_id': uploader_id,\n            'uploader': uploader,\n            'like_count': like_count,\n            'comment_count': comment_count,\n            'comments': comments,\n        }\n\n\nclass InstagramUserIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?instagram\\.com/(?P<id>[^/]{2,})/?(?:$|[?#])'\n    IE_DESC = 'Instagram user profile'\n    IE_NAME = 'instagram:user'\n    _TEST = {\n        'url': 'https://instagram.com/porsche',\n        'info_dict': {\n            'id': 'porsche',\n            'title': 'porsche',\n        },\n        'playlist_count': 5,\n        'params': {\n            'extract_flat': True,\n            'skip_download': True,\n            'playlistend': 5,\n        }\n    }\n\n    def _entries(self, uploader_id):\n        query = {\n            '__a': 1,\n        }\n\n        def get_count(kind):\n            return int_or_none(try_get(\n                node, lambda x: x['%ss' % kind]['count']))\n\n        for page_num in itertools.count(1):\n            page = self._download_json(\n                'https://instagram.com/%s/' % uploader_id, uploader_id,\n                note='Downloading page %d' % page_num,\n                fatal=False, query=query)\n            if not page:\n                break\n\n            nodes = try_get(page, lambda x: x['user']['media']['nodes'], list)\n            if not nodes:\n                break\n\n            max_id = None\n\n            for node in nodes:\n                node_id = node.get('id')\n                if node_id:\n                    max_id = node_id\n\n                if node.get('__typename') != 'GraphVideo' and node.get('is_video') is not True:\n                    continue\n                video_id = node.get('code')\n                if not video_id:\n                    continue\n\n                info = self.url_result(\n                    'https://instagram.com/p/%s/' % video_id,\n                    ie=InstagramIE.ie_key(), video_id=video_id)\n\n                description = try_get(\n                    node, [lambda x: x['caption'], lambda x: x['text']['id']],\n                    compat_str)\n                thumbnail = node.get('thumbnail_src') or node.get('display_src')\n                timestamp = int_or_none(node.get('date'))\n\n                comment_count = get_count('comment')\n                like_count = get_count('like')\n                view_count = int_or_none(node.get('video_views'))\n\n                info.update({\n                    'description': description,\n                    'thumbnail': thumbnail,\n                    'timestamp': timestamp,\n                    'comment_count': comment_count,\n                    'like_count': like_count,\n                    'view_count': view_count,\n                })\n\n                yield info\n\n            if not max_id:\n                break\n\n            query['max_id'] = max_id\n\n    def _real_extract(self, url):\n        uploader_id = self._match_id(url)\n        return self.playlist_result(\n            self._entries(uploader_id), uploader_id, uploader_id)\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "instagram.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/instagram.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}