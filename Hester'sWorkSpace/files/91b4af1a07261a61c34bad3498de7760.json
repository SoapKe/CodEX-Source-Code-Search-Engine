{"author": "python", "code": "\nfrom collections import namedtuple\nimport glob\nimport os.path\nimport re\nimport shutil\nimport sys\nimport subprocess\n\n\nVERBOSITY = 2\n\nC_GLOBALS_DIR = os.path.abspath(os.path.dirname(__file__))\nTOOLS_DIR = os.path.dirname(C_GLOBALS_DIR)\nROOT_DIR = os.path.dirname(TOOLS_DIR)\nGLOBALS_FILE = os.path.join(C_GLOBALS_DIR, 'ignored-globals.txt')\n\nSOURCE_DIRS = ['Include', 'Objects', 'Modules', 'Parser', 'Python']\n\nCAPI_REGEX = re.compile(r'^ *PyAPI_DATA\\([^)]*\\) \\W*(_?Py\\w+(?:, \\w+)*\\w).*;.*$')\n\n\nIGNORED_VARS = {\n        '_DYNAMIC',\n        '_GLOBAL_OFFSET_TABLE_',\n        '__JCR_LIST__',\n        '__JCR_END__',\n        '__TMC_END__',\n        '__bss_start',\n        '__data_start',\n        '__dso_handle',\n        '_edata',\n        '_end',\n        }\n\n\ndef find_capi_vars(root):\n    capi_vars = {}\n    for dirname in SOURCE_DIRS:\n        for filename in glob.glob(os.path.join(ROOT_DIR, dirname, '**/*.[hc]'),\n                                  recursive=True):\n            with open(filename) as file:\n                for name in _find_capi_vars(file):\n                    if name in capi_vars:\n                        assert not filename.endswith('.c')\n                        assert capi_vars[name].endswith('.c')\n                    capi_vars[name] = filename\n    return capi_vars\n\n\ndef _find_capi_vars(lines):\n    for line in lines:\n        if not line.startswith('PyAPI_DATA'):\n            continue\n        assert '{' not in line\n        match = CAPI_REGEX.match(line)\n        assert match\n        names, = match.groups()\n        for name in names.split(', '):\n            yield name\n\n\ndef _read_global_names(filename):\n    \n    with open(filename) as file:\n        return {line.partition('#')[0].strip()\n                for line in file\n                if line.strip() and not line.startswith('#')}\n\n\ndef _is_global_var(name, globalnames):\n    if _is_autogen_var(name):\n        return True\n    if _is_type_var(name):\n        return True\n    if _is_module(name):\n        return True\n    if _is_exception(name):\n        return True\n    if _is_compiler(name):\n        return True\n    return name in globalnames\n\n\ndef _is_autogen_var(name):\n    return (\n        name.startswith('PyId_') or\n        '.' in name or\n        \n        name.startswith('op_id.') or\n        name.startswith('rop_id.') or\n        \n        name.startswith('arcs_') or\n        name.startswith('states_')\n        )\n\n\ndef _is_type_var(name):\n    if name.endswith(('Type', '_Type', '_type')):  ?\n        return True\n    if name.endswith('_desc'):  \n        return True\n    return (\n        name.startswith('doc_') or\n        name.endswith(('_doc', '__doc__', '_docstring')) or\n        name.endswith('_methods') or\n        name.endswith('_fields') or\n        name.endswith(('_memberlist', '_members')) or\n        name.endswith('_slots') or\n        name.endswith(('_getset', '_getsets', '_getsetlist')) or\n        name.endswith('_as_mapping') or\n        name.endswith('_as_number') or\n        name.endswith('_as_sequence') or\n        name.endswith('_as_buffer') or\n        name.endswith('_as_async')\n        )\n\n\ndef _is_module(name):\n    if name.endswith(('_functions', 'Methods', '_Methods')):\n        return True\n    if name == 'module_def':\n        return True\n    if name == 'initialized':\n        return True\n    return name.endswith(('module', '_Module'))\n\n\ndef _is_exception(name):\n    \n    if not name.startswith(('PyExc_', '_PyExc_')):\n        return False\n    return name.endswith(('Error', 'Warning'))\n\n\ndef _is_compiler(name):\n    return (\n        \n        name.endswith('_type') or\n        name.endswith('_singleton') or\n        name.endswith('_attributes')\n        )\n\n\nclass Var(namedtuple('Var', 'name kind scope capi filename')):\n\n    @classmethod\n    def parse_nm(cls, line, expected, ignored, capi_vars, globalnames):\n        _, _, line = line.partition(' ')  \n        line = line.strip()\n        kind, _, line = line.partition(' ')\n        if kind in ignored or ():\n            return None\n        elif kind not in expected or ():\n            raise RuntimeError('unsupported NM type {!r}'.format(kind))\n\n        name, _, filename = line.partition('\\t')\n        name = name.strip()\n        if _is_autogen_var(name):\n            return None\n        if _is_global_var(name, globalnames):\n            scope = 'global'\n        else:\n            scope = None\n        capi = (name in capi_vars or ())\n        if filename:\n            filename = os.path.relpath(filename.partition(':')[0])\n        return cls(name, kind, scope, capi, filename or '~???~')\n\n    @property\n    def external(self):\n        return self.kind.isupper()\n\n\ndef find_vars(root, globals_filename=GLOBALS_FILE):\n    python = os.path.join(root, 'python')\n    if not os.path.exists(python):\n        raise RuntimeError('python binary missing (need to build it first?)')\n    capi_vars = find_capi_vars(root)\n    globalnames = _read_global_names(globals_filename)\n\n    nm = shutil.which('nm')\n    if nm is None:\n        \n        raise NotImplementedError\n    else:\n        yield from (var\n                    for var in _find_var_symbols(python, nm, capi_vars,\n                                                 globalnames)\n                    if var.name not in IGNORED_VARS)\n\n\nNM_FUNCS = set('Tt')\nNM_PUBLIC_VARS = set('BD')\nNM_PRIVATE_VARS = set('bd')\nNM_VARS = NM_PUBLIC_VARS | NM_PRIVATE_VARS\nNM_DATA = set('Rr')\nNM_OTHER = set('ACGgiINpSsuUVvWw-?')\nNM_IGNORED = NM_FUNCS | NM_DATA | NM_OTHER\n\n\ndef _find_var_symbols(python, nm, capi_vars, globalnames):\n    args = [nm,\n            '--line-numbers',\n            python]\n    out = subprocess.check_output(args)\n    for line in out.decode('utf-8').splitlines():\n        var = Var.parse_nm(line, NM_VARS, NM_IGNORED, capi_vars, globalnames)\n        if var is None:\n            continue\n        yield var\n\n\n\n\nclass Filter(namedtuple('Filter', 'name op value action')):\n\n    @classmethod\n    def parse(cls, raw):\n        action = '+'\n        if raw.startswith(('+', '-')):\n            action = raw[0]\n            raw = raw[1:]\n        ?\n        name, op, value = raw.partition('=')\n        return cls(name, op, value, action)\n\n    def check(self, var):\n        value = getattr(var, self.name, None)\n        if not self.op:\n            matched = bool(value)\n        elif self.op == '=':\n            matched = (value == self.value)\n        else:\n            raise NotImplementedError\n\n        if self.action == '+':\n            return matched\n        elif self.action == '-':\n            return not matched\n        else:\n            raise NotImplementedError\n\n\ndef filter_var(var, filters):\n    for filter in filters:\n        if not filter.check(var):\n            return False\n    return True\n\n\ndef make_sort_key(spec):\n    columns = [(col.strip('_'), '_' if col.startswith('_') else '')\n               for col in spec]\n    def sort_key(var):\n        return tuple(getattr(var, col).lstrip(prefix)\n                     for col, prefix in columns)\n    return sort_key\n\n\ndef make_groups(allvars, spec):\n    group = spec\n    groups = {}\n    for var in allvars:\n        value = getattr(var, group)\n        key = '{}: {}'.format(group, value)\n        try:\n            groupvars = groups[key]\n        except KeyError:\n            groupvars = groups[key] = []\n        groupvars.append(var)\n    return groups\n\n\ndef format_groups(groups, columns, fmts, widths):\n    for group in sorted(groups):\n        groupvars = groups[group]\n        yield '', 0\n        yield '  # {}'.format(group), 0\n        yield from format_vars(groupvars, columns, fmts, widths)\n\n\ndef format_vars(allvars, columns, fmts, widths):\n    fmt = ' '.join(fmts[col] for col in columns)\n    fmt = ' ' + fmt.replace(' ', '   ') + ' '  \n    header = fmt.replace(':', ':^').format(*(col.upper() for col in columns))\n    yield header, 0\n    div = ' '.join('-'*(widths[col]+2) for col in columns)\n    yield div, 0\n    for var in allvars:\n        values = (getattr(var, col) for col in columns)\n        row = fmt.format(*('X' if val is True else val or ''\n                           for val in values))\n        yield row, 1\n    yield div, 0\n\n\n\n\nCOLUMNS = 'name,external,capi,scope,filename'\nCOLUMN_NAMES = COLUMNS.split(',')\n\nCOLUMN_WIDTHS = {col: len(col)\n                 for col in COLUMN_NAMES}\nCOLUMN_WIDTHS.update({\n        'name': 50,\n        'scope': 7,\n        'filename': 40,\n        })\nCOLUMN_FORMATS = {col: '{:%s}' % width\n                  for col, width in COLUMN_WIDTHS.items()}\nfor col in COLUMN_FORMATS:\n    if COLUMN_WIDTHS[col] == len(col):\n        COLUMN_FORMATS[col] = COLUMN_FORMATS[col].replace(':', ':^')\n\n\ndef _parse_filters_arg(raw, error):\n    filters = []\n    for value in raw.split(','):\n        value=value.strip()\n        if not value:\n            continue\n        try:\n            filter = Filter.parse(value)\n            if filter.name not in COLUMN_NAMES:\n                raise Exception('unsupported column {!r}'.format(filter.name))\n        except Exception as e:\n            error('bad filter {!r}: {}'.format(raw, e))\n        filters.append(filter)\n    return filters\n\n\ndef _parse_columns_arg(raw, error):\n    columns = raw.split(',')\n    for column in columns:\n        if column not in COLUMN_NAMES:\n            error('unsupported column {!r}'.format(column))\n    return columns\n\n\ndef _parse_sort_arg(raw, error):\n    sort = raw.split(',')\n    for column in sort:\n        if column.lstrip('_') not in COLUMN_NAMES:\n            error('unsupported column {!r}'.format(column))\n    return sort\n\n\ndef _parse_group_arg(raw, error):\n    if not raw:\n        return raw\n    group = raw\n    if group not in COLUMN_NAMES:\n        error('unsupported column {!r}'.format(group))\n    if group != 'filename':\n        error('unsupported group {!r}'.format(group))\n    return group\n\n\ndef parse_args(argv=None):\n    if argv is None:\n        argv = sys.argv[1:]\n\n    import argparse\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument('-v', '--verbose', action='count', default=0)\n    parser.add_argument('-q', '--quiet', action='count', default=0)\n\n    parser.add_argument('--filters', default='-scope',\n                        help='[[-]<COLUMN>[=<GLOB>]] ...')\n\n    parser.add_argument('--columns', default=COLUMNS,\n                        help='a comma-separated list of columns to show')\n    parser.add_argument('--sort', default='filename,_name',\n                        help='a comma-separated list of columns to sort')\n    parser.add_argument('--group',\n                        help='group by the given column name (- to not group)')\n\n    parser.add_argument('--rc-on-match', dest='rc', type=int)\n\n    parser.add_argument('filename', nargs='?', default=GLOBALS_FILE)\n\n    args = parser.parse_args(argv)\n\n    verbose = vars(args).pop('verbose', 0)\n    quiet = vars(args).pop('quiet', 0)\n    args.verbosity = max(0, VERBOSITY + verbose - quiet)\n\n    if args.sort.startswith('filename') and not args.group:\n        args.group = 'filename'\n\n    if args.rc is None:\n        if '-scope=core' in args.filters or 'core' not in args.filters:\n            args.rc = 0\n        else:\n            args.rc = 1\n\n    args.filters = _parse_filters_arg(args.filters, parser.error)\n    args.columns = _parse_columns_arg(args.columns, parser.error)\n    args.sort = _parse_sort_arg(args.sort, parser.error)\n    args.group = _parse_group_arg(args.group, parser.error)\n\n    return args\n\n\ndef main(root=ROOT_DIR, filename=GLOBALS_FILE,\n         filters=None, columns=COLUMN_NAMES, sort=None, group=None,\n         verbosity=VERBOSITY, rc=1):\n\n    log = lambda msg: ...\n    if verbosity >= 2:\n        log = lambda msg: print(msg)\n\n    allvars = (var\n               for var in find_vars(root, filename)\n               if filter_var(var, filters))\n    if sort:\n        allvars = sorted(allvars, key=make_sort_key(sort))\n\n    if group:\n        try:\n            columns.remove(group)\n        except ValueError:\n            pass\n        grouped = make_groups(allvars, group)\n        lines = format_groups(grouped, columns, COLUMN_FORMATS, COLUMN_WIDTHS)\n    else:\n        lines = format_vars(allvars, columns, COLUMN_FORMATS, COLUMN_WIDTHS)\n\n    total = 0\n    for line, count in lines:\n        total += count\n        log(line)\n    log('\\ntotal: {}'.format(total))\n\n    if total and rc:\n        print('ERROR: found unsafe globals', file=sys.stderr)\n        return rc\n    return 0\n\n\nif __name__ == '__main__':\n    args = parse_args()\n    sys.exit(\n            main(**vars(args)))\n", "comments": "  these variables shared interpreters process     objects typeobject c    python graminit c    xxx always static type     structseq types    other vars enumerated globals core txt     python python ast c    strip address    xxx use dumpbin exe  symbols windows                                              xxx support             format(group)  0    div margin                                          ", "content": "\nfrom collections import namedtuple\nimport glob\nimport os.path\nimport re\nimport shutil\nimport sys\nimport subprocess\n\n\nVERBOSITY = 2\n\nC_GLOBALS_DIR = os.path.abspath(os.path.dirname(__file__))\nTOOLS_DIR = os.path.dirname(C_GLOBALS_DIR)\nROOT_DIR = os.path.dirname(TOOLS_DIR)\nGLOBALS_FILE = os.path.join(C_GLOBALS_DIR, 'ignored-globals.txt')\n\nSOURCE_DIRS = ['Include', 'Objects', 'Modules', 'Parser', 'Python']\n\nCAPI_REGEX = re.compile(r'^ *PyAPI_DATA\\([^)]*\\) \\W*(_?Py\\w+(?:, \\w+)*\\w).*;.*$')\n\n\nIGNORED_VARS = {\n        '_DYNAMIC',\n        '_GLOBAL_OFFSET_TABLE_',\n        '__JCR_LIST__',\n        '__JCR_END__',\n        '__TMC_END__',\n        '__bss_start',\n        '__data_start',\n        '__dso_handle',\n        '_edata',\n        '_end',\n        }\n\n\ndef find_capi_vars(root):\n    capi_vars = {}\n    for dirname in SOURCE_DIRS:\n        for filename in glob.glob(os.path.join(ROOT_DIR, dirname, '**/*.[hc]'),\n                                  recursive=True):\n            with open(filename) as file:\n                for name in _find_capi_vars(file):\n                    if name in capi_vars:\n                        assert not filename.endswith('.c')\n                        assert capi_vars[name].endswith('.c')\n                    capi_vars[name] = filename\n    return capi_vars\n\n\ndef _find_capi_vars(lines):\n    for line in lines:\n        if not line.startswith('PyAPI_DATA'):\n            continue\n        assert '{' not in line\n        match = CAPI_REGEX.match(line)\n        assert match\n        names, = match.groups()\n        for name in names.split(', '):\n            yield name\n\n\ndef _read_global_names(filename):\n    # These variables are shared between all interpreters in the process.\n    with open(filename) as file:\n        return {line.partition('#')[0].strip()\n                for line in file\n                if line.strip() and not line.startswith('#')}\n\n\ndef _is_global_var(name, globalnames):\n    if _is_autogen_var(name):\n        return True\n    if _is_type_var(name):\n        return True\n    if _is_module(name):\n        return True\n    if _is_exception(name):\n        return True\n    if _is_compiler(name):\n        return True\n    return name in globalnames\n\n\ndef _is_autogen_var(name):\n    return (\n        name.startswith('PyId_') or\n        '.' in name or\n        # Objects/typeobject.c\n        name.startswith('op_id.') or\n        name.startswith('rop_id.') or\n        # Python/graminit.c\n        name.startswith('arcs_') or\n        name.startswith('states_')\n        )\n\n\ndef _is_type_var(name):\n    if name.endswith(('Type', '_Type', '_type')):  # XXX Always a static type?\n        return True\n    if name.endswith('_desc'):  # for structseq types\n        return True\n    return (\n        name.startswith('doc_') or\n        name.endswith(('_doc', '__doc__', '_docstring')) or\n        name.endswith('_methods') or\n        name.endswith('_fields') or\n        name.endswith(('_memberlist', '_members')) or\n        name.endswith('_slots') or\n        name.endswith(('_getset', '_getsets', '_getsetlist')) or\n        name.endswith('_as_mapping') or\n        name.endswith('_as_number') or\n        name.endswith('_as_sequence') or\n        name.endswith('_as_buffer') or\n        name.endswith('_as_async')\n        )\n\n\ndef _is_module(name):\n    if name.endswith(('_functions', 'Methods', '_Methods')):\n        return True\n    if name == 'module_def':\n        return True\n    if name == 'initialized':\n        return True\n    return name.endswith(('module', '_Module'))\n\n\ndef _is_exception(name):\n    # Other vars are enumerated in globals-core.txt.\n    if not name.startswith(('PyExc_', '_PyExc_')):\n        return False\n    return name.endswith(('Error', 'Warning'))\n\n\ndef _is_compiler(name):\n    return (\n        # Python/Python-ast.c\n        name.endswith('_type') or\n        name.endswith('_singleton') or\n        name.endswith('_attributes')\n        )\n\n\nclass Var(namedtuple('Var', 'name kind scope capi filename')):\n\n    @classmethod\n    def parse_nm(cls, line, expected, ignored, capi_vars, globalnames):\n        _, _, line = line.partition(' ')  # strip off the address\n        line = line.strip()\n        kind, _, line = line.partition(' ')\n        if kind in ignored or ():\n            return None\n        elif kind not in expected or ():\n            raise RuntimeError('unsupported NM type {!r}'.format(kind))\n\n        name, _, filename = line.partition('\\t')\n        name = name.strip()\n        if _is_autogen_var(name):\n            return None\n        if _is_global_var(name, globalnames):\n            scope = 'global'\n        else:\n            scope = None\n        capi = (name in capi_vars or ())\n        if filename:\n            filename = os.path.relpath(filename.partition(':')[0])\n        return cls(name, kind, scope, capi, filename or '~???~')\n\n    @property\n    def external(self):\n        return self.kind.isupper()\n\n\ndef find_vars(root, globals_filename=GLOBALS_FILE):\n    python = os.path.join(root, 'python')\n    if not os.path.exists(python):\n        raise RuntimeError('python binary missing (need to build it first?)')\n    capi_vars = find_capi_vars(root)\n    globalnames = _read_global_names(globals_filename)\n\n    nm = shutil.which('nm')\n    if nm is None:\n        # XXX Use dumpbin.exe /SYMBOLS on Windows.\n        raise NotImplementedError\n    else:\n        yield from (var\n                    for var in _find_var_symbols(python, nm, capi_vars,\n                                                 globalnames)\n                    if var.name not in IGNORED_VARS)\n\n\nNM_FUNCS = set('Tt')\nNM_PUBLIC_VARS = set('BD')\nNM_PRIVATE_VARS = set('bd')\nNM_VARS = NM_PUBLIC_VARS | NM_PRIVATE_VARS\nNM_DATA = set('Rr')\nNM_OTHER = set('ACGgiINpSsuUVvWw-?')\nNM_IGNORED = NM_FUNCS | NM_DATA | NM_OTHER\n\n\ndef _find_var_symbols(python, nm, capi_vars, globalnames):\n    args = [nm,\n            '--line-numbers',\n            python]\n    out = subprocess.check_output(args)\n    for line in out.decode('utf-8').splitlines():\n        var = Var.parse_nm(line, NM_VARS, NM_IGNORED, capi_vars, globalnames)\n        if var is None:\n            continue\n        yield var\n\n\n#######################################\n\nclass Filter(namedtuple('Filter', 'name op value action')):\n\n    @classmethod\n    def parse(cls, raw):\n        action = '+'\n        if raw.startswith(('+', '-')):\n            action = raw[0]\n            raw = raw[1:]\n        # XXX Support < and >?\n        name, op, value = raw.partition('=')\n        return cls(name, op, value, action)\n\n    def check(self, var):\n        value = getattr(var, self.name, None)\n        if not self.op:\n            matched = bool(value)\n        elif self.op == '=':\n            matched = (value == self.value)\n        else:\n            raise NotImplementedError\n\n        if self.action == '+':\n            return matched\n        elif self.action == '-':\n            return not matched\n        else:\n            raise NotImplementedError\n\n\ndef filter_var(var, filters):\n    for filter in filters:\n        if not filter.check(var):\n            return False\n    return True\n\n\ndef make_sort_key(spec):\n    columns = [(col.strip('_'), '_' if col.startswith('_') else '')\n               for col in spec]\n    def sort_key(var):\n        return tuple(getattr(var, col).lstrip(prefix)\n                     for col, prefix in columns)\n    return sort_key\n\n\ndef make_groups(allvars, spec):\n    group = spec\n    groups = {}\n    for var in allvars:\n        value = getattr(var, group)\n        key = '{}: {}'.format(group, value)\n        try:\n            groupvars = groups[key]\n        except KeyError:\n            groupvars = groups[key] = []\n        groupvars.append(var)\n    return groups\n\n\ndef format_groups(groups, columns, fmts, widths):\n    for group in sorted(groups):\n        groupvars = groups[group]\n        yield '', 0\n        yield '  # {}'.format(group), 0\n        yield from format_vars(groupvars, columns, fmts, widths)\n\n\ndef format_vars(allvars, columns, fmts, widths):\n    fmt = ' '.join(fmts[col] for col in columns)\n    fmt = ' ' + fmt.replace(' ', '   ') + ' '  # for div margin\n    header = fmt.replace(':', ':^').format(*(col.upper() for col in columns))\n    yield header, 0\n    div = ' '.join('-'*(widths[col]+2) for col in columns)\n    yield div, 0\n    for var in allvars:\n        values = (getattr(var, col) for col in columns)\n        row = fmt.format(*('X' if val is True else val or ''\n                           for val in values))\n        yield row, 1\n    yield div, 0\n\n\n#######################################\n\nCOLUMNS = 'name,external,capi,scope,filename'\nCOLUMN_NAMES = COLUMNS.split(',')\n\nCOLUMN_WIDTHS = {col: len(col)\n                 for col in COLUMN_NAMES}\nCOLUMN_WIDTHS.update({\n        'name': 50,\n        'scope': 7,\n        'filename': 40,\n        })\nCOLUMN_FORMATS = {col: '{:%s}' % width\n                  for col, width in COLUMN_WIDTHS.items()}\nfor col in COLUMN_FORMATS:\n    if COLUMN_WIDTHS[col] == len(col):\n        COLUMN_FORMATS[col] = COLUMN_FORMATS[col].replace(':', ':^')\n\n\ndef _parse_filters_arg(raw, error):\n    filters = []\n    for value in raw.split(','):\n        value=value.strip()\n        if not value:\n            continue\n        try:\n            filter = Filter.parse(value)\n            if filter.name not in COLUMN_NAMES:\n                raise Exception('unsupported column {!r}'.format(filter.name))\n        except Exception as e:\n            error('bad filter {!r}: {}'.format(raw, e))\n        filters.append(filter)\n    return filters\n\n\ndef _parse_columns_arg(raw, error):\n    columns = raw.split(',')\n    for column in columns:\n        if column not in COLUMN_NAMES:\n            error('unsupported column {!r}'.format(column))\n    return columns\n\n\ndef _parse_sort_arg(raw, error):\n    sort = raw.split(',')\n    for column in sort:\n        if column.lstrip('_') not in COLUMN_NAMES:\n            error('unsupported column {!r}'.format(column))\n    return sort\n\n\ndef _parse_group_arg(raw, error):\n    if not raw:\n        return raw\n    group = raw\n    if group not in COLUMN_NAMES:\n        error('unsupported column {!r}'.format(group))\n    if group != 'filename':\n        error('unsupported group {!r}'.format(group))\n    return group\n\n\ndef parse_args(argv=None):\n    if argv is None:\n        argv = sys.argv[1:]\n\n    import argparse\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument('-v', '--verbose', action='count', default=0)\n    parser.add_argument('-q', '--quiet', action='count', default=0)\n\n    parser.add_argument('--filters', default='-scope',\n                        help='[[-]<COLUMN>[=<GLOB>]] ...')\n\n    parser.add_argument('--columns', default=COLUMNS,\n                        help='a comma-separated list of columns to show')\n    parser.add_argument('--sort', default='filename,_name',\n                        help='a comma-separated list of columns to sort')\n    parser.add_argument('--group',\n                        help='group by the given column name (- to not group)')\n\n    parser.add_argument('--rc-on-match', dest='rc', type=int)\n\n    parser.add_argument('filename', nargs='?', default=GLOBALS_FILE)\n\n    args = parser.parse_args(argv)\n\n    verbose = vars(args).pop('verbose', 0)\n    quiet = vars(args).pop('quiet', 0)\n    args.verbosity = max(0, VERBOSITY + verbose - quiet)\n\n    if args.sort.startswith('filename') and not args.group:\n        args.group = 'filename'\n\n    if args.rc is None:\n        if '-scope=core' in args.filters or 'core' not in args.filters:\n            args.rc = 0\n        else:\n            args.rc = 1\n\n    args.filters = _parse_filters_arg(args.filters, parser.error)\n    args.columns = _parse_columns_arg(args.columns, parser.error)\n    args.sort = _parse_sort_arg(args.sort, parser.error)\n    args.group = _parse_group_arg(args.group, parser.error)\n\n    return args\n\n\ndef main(root=ROOT_DIR, filename=GLOBALS_FILE,\n         filters=None, columns=COLUMN_NAMES, sort=None, group=None,\n         verbosity=VERBOSITY, rc=1):\n\n    log = lambda msg: ...\n    if verbosity >= 2:\n        log = lambda msg: print(msg)\n\n    allvars = (var\n               for var in find_vars(root, filename)\n               if filter_var(var, filters))\n    if sort:\n        allvars = sorted(allvars, key=make_sort_key(sort))\n\n    if group:\n        try:\n            columns.remove(group)\n        except ValueError:\n            pass\n        grouped = make_groups(allvars, group)\n        lines = format_groups(grouped, columns, COLUMN_FORMATS, COLUMN_WIDTHS)\n    else:\n        lines = format_vars(allvars, columns, COLUMN_FORMATS, COLUMN_WIDTHS)\n\n    total = 0\n    for line, count in lines:\n        total += count\n        log(line)\n    log('\\ntotal: {}'.format(total))\n\n    if total and rc:\n        print('ERROR: found unsafe globals', file=sys.stderr)\n        return rc\n    return 0\n\n\nif __name__ == '__main__':\n    args = parse_args()\n    sys.exit(\n            main(**vars(args)))\n", "description": "The Python programming language", "file_name": "check-c-globals.py", "id": "91b4af1a07261a61c34bad3498de7760", "language": "Python", "project_name": "cpython", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/python-cpython/python-cpython-74f5687/Tools/c-globals/check-c-globals.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:20:38Z", "url": "https://github.com/python/cpython", "wiki": false}