{"author": "faif", "code": "\n# -*- coding : utf-8 -*-\n\n\"\"\"\n*What is this pattern about?\nIt decouples the creation of a complex object and its representation,\nso that the same process can be reused to build objects from the same\nfamily.\nThis is useful when you must separate the specification of an object\nfrom its actual representation (generally for abstraction).\n\n*What does this example do?\nThis particular example uses a director function to abtract the\nconstruction of a building. The user specifies a Builder (House or\nFlat) and the director specifies the methods in the order necessary\ncreating a different building depending on the specified\nspecification (through the Builder class).\n\n@author: Diogenes Augusto Fernandes Herminio <diofeher@gmail.com>\nhttps://gist.github.com/420905\n\n*Where is the pattern used practically?\n\n*References:\nhttps://sourcemaking.com/design_patterns/builder\n\n*TL;DR80\nDecouples the creation of a complex object and its representation.\n\"\"\"\n\n\ndef construct_building(builder):\n    builder.new_building()\n    builder.build_floor()\n    builder.build_size()\n    return builder.building\n\n\n\nclass Builder(object):\n\n    def __init__(self):\n        self.building = None\n\n    def new_building(self):\n        self.building = Building()\n\n    def build_floor(self):\n        raise NotImplementedError\n\n    def build_size(self):\n        raise NotImplementedError\n\n\n\n\nclass BuilderHouse(Builder):\n\n    def build_floor(self):\n        self.building.floor = 'One'\n\n    def build_size(self):\n        self.building.size = 'Big'\n\n\nclass BuilderFlat(Builder):\n\n    def build_floor(self):\n        self.building.floor = 'More than One'\n\n    def build_size(self):\n        self.building.size = 'Small'\n\n\n\nclass Building(object):\n\n    def __init__(self):\n        self.floor = None\n        self.size = None\n\n    def __repr__(self):\n        return 'Floor: {0.floor} | Size: {0.size}'.format(self)\n\n\n\nif __name__ == \"__main__\":\n    building = construct_building(BuilderHouse())\n    print(building)\n    building = construct_building(BuilderFlat())\n    print(building)\n\n\n|\n|\n", "comments": "     what pattern  it decouples creation complex object representation  process reused build objects family  this useful must separate specification object actual representation (generally abstraction)    what example  this particular example uses director function abtract construction building  the user specifies builder (house flat) director specifies methods order necessary creating different building depending specified specification (through builder class)    author  diogenes augusto fernandes herminio  diofeher gmail com  https   gist github com 420905 file builder python py   where pattern used practically    references  https   sourcemaking com design patterns builder   tl dr80 decouples creation complex object representation          usr bin python        coding   utf 8       file builder python py    abstract builder    concrete builder    product    client      output        floor  one   size  big    floor  more one   size  small ", "content": "#!/usr/bin/python\n# -*- coding : utf-8 -*-\n\n\"\"\"\n*What is this pattern about?\nIt decouples the creation of a complex object and its representation,\nso that the same process can be reused to build objects from the same\nfamily.\nThis is useful when you must separate the specification of an object\nfrom its actual representation (generally for abstraction).\n\n*What does this example do?\nThis particular example uses a director function to abtract the\nconstruction of a building. The user specifies a Builder (House or\nFlat) and the director specifies the methods in the order necessary\ncreating a different building depending on the specified\nspecification (through the Builder class).\n\n@author: Diogenes Augusto Fernandes Herminio <diofeher@gmail.com>\nhttps://gist.github.com/420905#file_builder_python.py\n\n*Where is the pattern used practically?\n\n*References:\nhttps://sourcemaking.com/design_patterns/builder\n\n*TL;DR80\nDecouples the creation of a complex object and its representation.\n\"\"\"\n\n\ndef construct_building(builder):\n    builder.new_building()\n    builder.build_floor()\n    builder.build_size()\n    return builder.building\n\n\n# Abstract Builder\nclass Builder(object):\n\n    def __init__(self):\n        self.building = None\n\n    def new_building(self):\n        self.building = Building()\n\n    def build_floor(self):\n        raise NotImplementedError\n\n    def build_size(self):\n        raise NotImplementedError\n\n# Concrete Builder\n\n\nclass BuilderHouse(Builder):\n\n    def build_floor(self):\n        self.building.floor = 'One'\n\n    def build_size(self):\n        self.building.size = 'Big'\n\n\nclass BuilderFlat(Builder):\n\n    def build_floor(self):\n        self.building.floor = 'More than One'\n\n    def build_size(self):\n        self.building.size = 'Small'\n\n\n# Product\nclass Building(object):\n\n    def __init__(self):\n        self.floor = None\n        self.size = None\n\n    def __repr__(self):\n        return 'Floor: {0.floor} | Size: {0.size}'.format(self)\n\n\n# Client\nif __name__ == \"__main__\":\n    building = construct_building(BuilderHouse())\n    print(building)\n    building = construct_building(BuilderFlat())\n    print(building)\n\n### OUTPUT ###\n# Floor: One | Size: Big\n# Floor: More than One | Size: Small\n", "description": "A collection of design patterns/idioms in Python", "file_name": "builder.py", "id": "36f4fbb919baca887b71ad373f730a15", "language": "Python", "project_name": "python-patterns", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/faif-python-patterns/faif-python-patterns-e9a08d0/creational/builder.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:55:31Z", "url": "https://github.com/faif/python-patterns", "wiki": true}