{"author": "HelloZeroNet", "code": "import logging\nimport time\nimport sys\n\nimport gevent\n\nfrom cStringIO import StringIO\nfrom Debug import Debug\nfrom Config import config\nfrom util import helper\nfrom PeerHashfield import PeerHashfield\nfrom Plugin import PluginManager\n\nif config.use_tempfiles:\n    import tempfile\n\n\n\n@PluginManager.acceptPlugins\nclass Peer(object):\n    __slots__ = (\n        \"ip\", \"port\", \"site\", \"key\", \"connection\", \"connection_server\", \"time_found\", \"time_response\", \"time_hashfield\", \"time_added\", \"has_hashfield\",\n        \"time_my_hashfield_sent\", \"last_ping\", \"reputation\", \"last_content_json_update\", \"hashfield\", \"connection_error\", \"hash_failed\", \"download_bytes\", \"download_time\"\n    )\n\n    def __init__(self, ip, port, site=None, connection_server=None):\n        self.ip = ip\n        self.port = port\n        self.site = site\n        self.key = \"%s:%s\" % (ip, port)\n\n        self.connection = None\n        self.connection_server = connection_server\n        self.has_hashfield = False  \n        self.time_hashfield = None  \n        self.time_my_hashfield_sent = None  \n        self.time_found = time.time()  \n        self.time_response = None  \n        self.time_added = time.time()\n        self.last_ping = None  \n        self.reputation = 0  \n        self.last_content_json_update = 0.0  \n\n        self.connection_error = 0  \n        self.hash_failed = 0  \n        self.download_bytes = 0  \n        self.download_time = 0  \n\n    def __getattr__(self, key):\n        if key == \"hashfield\":\n            self.has_hashfield = True\n            self.hashfield = PeerHashfield()\n            return self.hashfield\n        else:\n            return getattr(self, key)\n\n    def log(self, text):\n        if not config.verbose:\n            return  \n        if self.site:\n            self.site.log.debug(\"%s:%s %s\" % (self.ip, self.port, text))\n        else:\n            logging.debug(\"%s:%s %s\" % (self.ip, self.port, text))\n\n    \n    def connect(self, connection=None):\n        if self.connection:\n            self.log(\"Getting connection (Closing %s)...\" % self.connection)\n            self.connection.close(\"Connection change\")\n        else:\n            self.log(\"Getting connection...\")\n\n        if connection:  \n            self.log(\"Assigning connection %s\" % connection)\n            self.connection = connection\n            self.connection.sites += 1\n        else:  \n            self.connection = None\n\n            try:\n                if self.connection_server:\n                    self.connection = self.connection_server.getConnection(self.ip, self.port, site=self.site)\n                elif self.site:\n                    self.connection = self.site.connection_server.getConnection(self.ip, self.port, site=self.site)\n                else:\n                    self.connection = sys.modules[\"main\"].file_server.getConnection(self.ip, self.port, site=self.site)\n                self.connection.sites += 1\n\n            except Exception, err:\n                self.onConnectionError(\"Getting connection error\")\n                self.log(\"Getting connection error: %s (connection_error: %s, hash_failed: %s)\" %\n                         (Debug.formatException(err), self.connection_error, self.hash_failed))\n                self.connection = None\n\n    \n    def findConnection(self):\n        if self.connection and self.connection.connected:  \n            return self.connection\n        else:  \n            self.connection = self.site.connection_server.getConnection(self.ip, self.port, create=False, site=self.site)\n            if self.connection:\n                self.connection.sites += 1\n        return self.connection\n\n    def __str__(self):\n        return \"Peer:%-12s\" % self.ip\n\n    def __repr__(self):\n        return \"<%s>\" % self.__str__()\n\n    def packMyAddress(self):\n        if self.ip.endswith(\".onion\"):\n            return helper.packOnionAddress(self.ip, self.port)\n        else:\n            return helper.packAddress(self.ip, self.port)\n\n    \n    def found(self, source=\"other\"):\n        if source == \"tracker\":\n            self.reputation += 10\n        elif source == \"local\":\n            self.reputation += 30\n        if source in (\"tracker\", \"local\"):\n            self.site.peers_recent.appendleft(self)\n        self.time_found = time.time()\n\n    \n    def request(self, cmd, params={}, stream_to=None):\n        if not self.connection or self.connection.closed:\n            self.connect()\n            if not self.connection:\n                self.onConnectionError(\"Reconnect error\")\n                return None  \n\n        self.log(\"Send request: %s %s %s %s\" % (params.get(\"site\", \"\"), cmd, params.get(\"inner_path\", \"\"), params.get(\"location\", \"\")))\n\n        for retry in range(1, 4):  \n            try:\n                if not self.connection:\n                    raise Exception(\"No connection found\")\n                res = self.connection.request(cmd, params, stream_to)\n                if not res:\n                    raise Exception(\"Send error\")\n                if \"error\" in res:\n                    self.log(\"%s error: %s\" % (cmd, res[\"error\"]))\n                    self.onConnectionError(\"Response error\")\n                    break\n                else:  \n                    self.connection_error = 0\n                self.time_response = time.time()\n                if res:\n                    return res\n                else:\n                    raise Exception(\"Invalid response: %s\" % res)\n            except Exception, err:\n                if type(err).__name__ == \"Notify\":  \n                    self.log(\"Peer worker got killed: %s, aborting cmd: %s\" % (err.message, cmd))\n                    break\n                else:\n                    self.onConnectionError(\"Request error\")\n                    self.log(\n                        \"%s (connection_error: %s, hash_failed: %s, retry: %s)\" %\n                        (Debug.formatException(err), self.connection_error, self.hash_failed, retry)\n                    )\n                    time.sleep(1 * retry)\n                    self.connect()\n        return None  \n\n    \n    def getFile(self, site, inner_path, file_size=None, pos_from=0, pos_to=None, streaming=False):\n        if file_size and file_size > 5 * 1024 * 1024:\n            max_read_size = 1024 * 1024\n        else:\n            max_read_size = 512 * 1024\n\n        if pos_to:\n            read_bytes = min(max_read_size, pos_to - pos_from)\n        else:\n            read_bytes = max_read_size\n\n        location = pos_from\n\n        if config.use_tempfiles:\n            buff = tempfile.SpooledTemporaryFile(max_size=16 * 1024, mode='w+b')\n        else:\n            buff = StringIO()\n\n        s = time.time()\n        while True:  \n            if config.stream_downloads or read_bytes > 256 * 1024 or streaming:\n                res = self.request(\"streamFile\", {\"site\": site, \"inner_path\": inner_path, \"location\": location, \"read_bytes\": read_bytes, \"file_size\": file_size}, stream_to=buff)\n                if not res or \"location\" not in res:  \n                    return False\n            else:\n                self.log(\"Send: %s\" % inner_path)\n                res = self.request(\"getFile\", {\"site\": site, \"inner_path\": inner_path, \"location\": location, \"read_bytes\": read_bytes, \"file_size\": file_size})\n                if not res or \"location\" not in res:  \n                    return False\n                self.log(\"Recv: %s\" % inner_path)\n                buff.write(res[\"body\"])\n                res[\"body\"] = None  \n\n            if res[\"location\"] == res[\"size\"] or res[\"location\"] == pos_to:  \n                break\n            else:\n                location = res[\"location\"]\n                if pos_to:\n                    read_bytes = min(max_read_size, pos_to - location)\n\n        if pos_to:\n            recv = pos_to - pos_from\n        else:\n            recv = res[\"location\"]\n\n        self.download_bytes += recv\n        self.download_time += (time.time() - s)\n        if self.site:\n            self.site.settings[\"bytes_recv\"] = self.site.settings.get(\"bytes_recv\", 0) + recv\n        self.log(\"Downloaded: %s, pos: %s, read_bytes: %s\" % (inner_path, buff.tell(), read_bytes))\n        buff.seek(0)\n        return buff\n\n    \n    def ping(self):\n        response_time = None\n        for retry in range(1, 3):  \n            s = time.time()\n            with gevent.Timeout(10.0, False):  \n                res = self.request(\"ping\")\n\n                if res and \"body\" in res and res[\"body\"] == \"Pong!\":\n                    response_time = time.time() - s\n                    break  \n            \n            self.onConnectionError(\"Ping timeout\")\n            self.connect()\n            time.sleep(1)\n\n        if response_time:\n            self.log(\"Ping: %.3f\" % response_time)\n        else:\n            self.log(\"Ping failed\")\n        self.last_ping = response_time\n        return response_time\n\n    \n    def pex(self, site=None, need_num=5):\n        if not site:\n            site = self.site  \n\n        \n        packed_peers = helper.packPeers(self.site.getConnectablePeers(5, allow_private=False))\n        request = {\"site\": site.address, \"peers\": packed_peers[\"ip4\"], \"need\": need_num}\n        if packed_peers[\"onion\"]:\n            request[\"peers_onion\"] = packed_peers[\"onion\"]\n        res = self.request(\"pex\", request)\n        if not res or \"error\" in res:\n            return False\n        added = 0\n        \n        for peer in res.get(\"peers\", []):\n            address = helper.unpackAddress(peer)\n            if site.addPeer(*address, source=\"pex\"):\n                added += 1\n        \n        for peer in res.get(\"peers_onion\", []):\n            address = helper.unpackOnionAddress(peer)\n            if site.addPeer(*address, source=\"pex\"):\n                added += 1\n\n        if added:\n            self.log(\"Added peers using pex: %s\" % added)\n\n        return added\n\n    \n    \n    def listModified(self, since):\n        return self.request(\"listModified\", {\"since\": since, \"site\": self.site.address})\n\n    def updateHashfield(self, force=False):\n        \n        if self.time_hashfield and time.time() - self.time_hashfield < 5 * 60 and not force:\n            return False\n\n        self.time_hashfield = time.time()\n        res = self.request(\"getHashfield\", {\"site\": self.site.address})\n        if not res or \"error\" in res or not \"hashfield_raw\" in res:\n            return False\n        self.hashfield.replaceFromString(res[\"hashfield_raw\"])\n\n        return self.hashfield\n\n    \n    \n    def findHashIds(self, hash_ids):\n        res = self.request(\"findHashIds\", {\"site\": self.site.address, \"hash_ids\": hash_ids})\n        if not res or \"error\" in res or type(res) is not dict:\n            return False\n        \n        back = {key: map(helper.unpackAddress, val) for key, val in res[\"peers\"].items()[0:30]}\n        \n        for hash, onion_peers in res.get(\"peers_onion\", {}).items()[0:30]:\n            if hash not in back:\n                back[hash] = []\n            back[hash] += map(helper.unpackOnionAddress, onion_peers)\n\n        return back\n\n    \n    \n    def sendMyHashfield(self):\n        if self.connection and self.connection.handshake.get(\"rev\", 0) < 510:\n            return False  \n        if self.time_my_hashfield_sent and self.site.content_manager.hashfield.time_changed <= self.time_my_hashfield_sent:\n            return False  \n\n        res = self.request(\"setHashfield\", {\"site\": self.site.address, \"hashfield_raw\": self.site.content_manager.hashfield.tostring()})\n        if not res or \"error\" in res:\n            return False\n        else:\n            self.time_my_hashfield_sent = time.time()\n            return True\n\n    \n    def remove(self, reason=\"Removing\"):\n        self.log(\"Removing peer...Connection error: %s, Hash failed: %s\" % (self.connection_error, self.hash_failed))\n        if self.site and self.key in self.site.peers:\n            del(self.site.peers[self.key])\n\n        if self.site and self in self.site.peers_recent:\n            self.site.peers_recent.remove(self)\n\n        if self.connection:\n            self.connection.close(reason)\n\n    \n\n    \n    def onConnectionError(self, reason=\"Unknown\"):\n        self.connection_error += 1\n        if self.site and len(self.site.peers) > 200:\n            limit = 3\n        else:\n            limit = 6\n        if self.connection_error >= limit:  \n            self.remove(\"Peer connection: %s\" % reason)\n\n    \n    def onWorkerDone(self):\n        pass\n", "comments": "communicate remote peers lazy hashfield object created yet last time peer's hashfiled downloaded last time hashfield sent peer time last found torrent tracker time last successful response peer last response time ping more likely connect larger modify date last received content.json series connection error number bad files peer bytes downloaded time spent download only log debug mode connect host connection specified try find connection pool create new connection check connection peer we connection peer try find sites connections found peer source send command peer return response value connection failed retry 3 times successful request reset connection error num greenlet killed worker failed 4 retry get file content peer read smaller parts error error save memory end file send ping request retry 3 times 10 sec timeout raise exception all fine exit loop timeout reached bad response request peer exchange peer if site defined request peers site give back 5 connectible peers ip4 onion list modified files since date return: {inner_path: modification date,...} don't update hashfield 5 min find peers hashids return: {hash1: [\"ip:port\" \"ip:port\",...],...} unpack ip4 unpack onion send hashfield peer return: true sent not supported peer already latest hashfield stop remove site - events - on connection error dead peer done working peer", "content": "import logging\nimport time\nimport sys\n\nimport gevent\n\nfrom cStringIO import StringIO\nfrom Debug import Debug\nfrom Config import config\nfrom util import helper\nfrom PeerHashfield import PeerHashfield\nfrom Plugin import PluginManager\n\nif config.use_tempfiles:\n    import tempfile\n\n\n# Communicate remote peers\n@PluginManager.acceptPlugins\nclass Peer(object):\n    __slots__ = (\n        \"ip\", \"port\", \"site\", \"key\", \"connection\", \"connection_server\", \"time_found\", \"time_response\", \"time_hashfield\", \"time_added\", \"has_hashfield\",\n        \"time_my_hashfield_sent\", \"last_ping\", \"reputation\", \"last_content_json_update\", \"hashfield\", \"connection_error\", \"hash_failed\", \"download_bytes\", \"download_time\"\n    )\n\n    def __init__(self, ip, port, site=None, connection_server=None):\n        self.ip = ip\n        self.port = port\n        self.site = site\n        self.key = \"%s:%s\" % (ip, port)\n\n        self.connection = None\n        self.connection_server = connection_server\n        self.has_hashfield = False  # Lazy hashfield object not created yet\n        self.time_hashfield = None  # Last time peer's hashfiled downloaded\n        self.time_my_hashfield_sent = None  # Last time my hashfield sent to peer\n        self.time_found = time.time()  # Time of last found in the torrent tracker\n        self.time_response = None  # Time of last successful response from peer\n        self.time_added = time.time()\n        self.last_ping = None  # Last response time for ping\n        self.reputation = 0  # More likely to connect if larger\n        self.last_content_json_update = 0.0  # Modify date of last received content.json\n\n        self.connection_error = 0  # Series of connection error\n        self.hash_failed = 0  # Number of bad files from peer\n        self.download_bytes = 0  # Bytes downloaded\n        self.download_time = 0  # Time spent to download\n\n    def __getattr__(self, key):\n        if key == \"hashfield\":\n            self.has_hashfield = True\n            self.hashfield = PeerHashfield()\n            return self.hashfield\n        else:\n            return getattr(self, key)\n\n    def log(self, text):\n        if not config.verbose:\n            return  # Only log if we are in debug mode\n        if self.site:\n            self.site.log.debug(\"%s:%s %s\" % (self.ip, self.port, text))\n        else:\n            logging.debug(\"%s:%s %s\" % (self.ip, self.port, text))\n\n    # Connect to host\n    def connect(self, connection=None):\n        if self.connection:\n            self.log(\"Getting connection (Closing %s)...\" % self.connection)\n            self.connection.close(\"Connection change\")\n        else:\n            self.log(\"Getting connection...\")\n\n        if connection:  # Connection specified\n            self.log(\"Assigning connection %s\" % connection)\n            self.connection = connection\n            self.connection.sites += 1\n        else:  # Try to find from connection pool or create new connection\n            self.connection = None\n\n            try:\n                if self.connection_server:\n                    self.connection = self.connection_server.getConnection(self.ip, self.port, site=self.site)\n                elif self.site:\n                    self.connection = self.site.connection_server.getConnection(self.ip, self.port, site=self.site)\n                else:\n                    self.connection = sys.modules[\"main\"].file_server.getConnection(self.ip, self.port, site=self.site)\n                self.connection.sites += 1\n\n            except Exception, err:\n                self.onConnectionError(\"Getting connection error\")\n                self.log(\"Getting connection error: %s (connection_error: %s, hash_failed: %s)\" %\n                         (Debug.formatException(err), self.connection_error, self.hash_failed))\n                self.connection = None\n\n    # Check if we have connection to peer\n    def findConnection(self):\n        if self.connection and self.connection.connected:  # We have connection to peer\n            return self.connection\n        else:  # Try to find from other sites connections\n            self.connection = self.site.connection_server.getConnection(self.ip, self.port, create=False, site=self.site)\n            if self.connection:\n                self.connection.sites += 1\n        return self.connection\n\n    def __str__(self):\n        return \"Peer:%-12s\" % self.ip\n\n    def __repr__(self):\n        return \"<%s>\" % self.__str__()\n\n    def packMyAddress(self):\n        if self.ip.endswith(\".onion\"):\n            return helper.packOnionAddress(self.ip, self.port)\n        else:\n            return helper.packAddress(self.ip, self.port)\n\n    # Found a peer from a source\n    def found(self, source=\"other\"):\n        if source == \"tracker\":\n            self.reputation += 10\n        elif source == \"local\":\n            self.reputation += 30\n        if source in (\"tracker\", \"local\"):\n            self.site.peers_recent.appendleft(self)\n        self.time_found = time.time()\n\n    # Send a command to peer and return response value\n    def request(self, cmd, params={}, stream_to=None):\n        if not self.connection or self.connection.closed:\n            self.connect()\n            if not self.connection:\n                self.onConnectionError(\"Reconnect error\")\n                return None  # Connection failed\n\n        self.log(\"Send request: %s %s %s %s\" % (params.get(\"site\", \"\"), cmd, params.get(\"inner_path\", \"\"), params.get(\"location\", \"\")))\n\n        for retry in range(1, 4):  # Retry 3 times\n            try:\n                if not self.connection:\n                    raise Exception(\"No connection found\")\n                res = self.connection.request(cmd, params, stream_to)\n                if not res:\n                    raise Exception(\"Send error\")\n                if \"error\" in res:\n                    self.log(\"%s error: %s\" % (cmd, res[\"error\"]))\n                    self.onConnectionError(\"Response error\")\n                    break\n                else:  # Successful request, reset connection error num\n                    self.connection_error = 0\n                self.time_response = time.time()\n                if res:\n                    return res\n                else:\n                    raise Exception(\"Invalid response: %s\" % res)\n            except Exception, err:\n                if type(err).__name__ == \"Notify\":  # Greenlet killed by worker\n                    self.log(\"Peer worker got killed: %s, aborting cmd: %s\" % (err.message, cmd))\n                    break\n                else:\n                    self.onConnectionError(\"Request error\")\n                    self.log(\n                        \"%s (connection_error: %s, hash_failed: %s, retry: %s)\" %\n                        (Debug.formatException(err), self.connection_error, self.hash_failed, retry)\n                    )\n                    time.sleep(1 * retry)\n                    self.connect()\n        return None  # Failed after 4 retry\n\n    # Get a file content from peer\n    def getFile(self, site, inner_path, file_size=None, pos_from=0, pos_to=None, streaming=False):\n        if file_size and file_size > 5 * 1024 * 1024:\n            max_read_size = 1024 * 1024\n        else:\n            max_read_size = 512 * 1024\n\n        if pos_to:\n            read_bytes = min(max_read_size, pos_to - pos_from)\n        else:\n            read_bytes = max_read_size\n\n        location = pos_from\n\n        if config.use_tempfiles:\n            buff = tempfile.SpooledTemporaryFile(max_size=16 * 1024, mode='w+b')\n        else:\n            buff = StringIO()\n\n        s = time.time()\n        while True:  # Read in smaller parts\n            if config.stream_downloads or read_bytes > 256 * 1024 or streaming:\n                res = self.request(\"streamFile\", {\"site\": site, \"inner_path\": inner_path, \"location\": location, \"read_bytes\": read_bytes, \"file_size\": file_size}, stream_to=buff)\n                if not res or \"location\" not in res:  # Error\n                    return False\n            else:\n                self.log(\"Send: %s\" % inner_path)\n                res = self.request(\"getFile\", {\"site\": site, \"inner_path\": inner_path, \"location\": location, \"read_bytes\": read_bytes, \"file_size\": file_size})\n                if not res or \"location\" not in res:  # Error\n                    return False\n                self.log(\"Recv: %s\" % inner_path)\n                buff.write(res[\"body\"])\n                res[\"body\"] = None  # Save memory\n\n            if res[\"location\"] == res[\"size\"] or res[\"location\"] == pos_to:  # End of file\n                break\n            else:\n                location = res[\"location\"]\n                if pos_to:\n                    read_bytes = min(max_read_size, pos_to - location)\n\n        if pos_to:\n            recv = pos_to - pos_from\n        else:\n            recv = res[\"location\"]\n\n        self.download_bytes += recv\n        self.download_time += (time.time() - s)\n        if self.site:\n            self.site.settings[\"bytes_recv\"] = self.site.settings.get(\"bytes_recv\", 0) + recv\n        self.log(\"Downloaded: %s, pos: %s, read_bytes: %s\" % (inner_path, buff.tell(), read_bytes))\n        buff.seek(0)\n        return buff\n\n    # Send a ping request\n    def ping(self):\n        response_time = None\n        for retry in range(1, 3):  # Retry 3 times\n            s = time.time()\n            with gevent.Timeout(10.0, False):  # 10 sec timeout, don't raise exception\n                res = self.request(\"ping\")\n\n                if res and \"body\" in res and res[\"body\"] == \"Pong!\":\n                    response_time = time.time() - s\n                    break  # All fine, exit from for loop\n            # Timeout reached or bad response\n            self.onConnectionError(\"Ping timeout\")\n            self.connect()\n            time.sleep(1)\n\n        if response_time:\n            self.log(\"Ping: %.3f\" % response_time)\n        else:\n            self.log(\"Ping failed\")\n        self.last_ping = response_time\n        return response_time\n\n    # Request peer exchange from peer\n    def pex(self, site=None, need_num=5):\n        if not site:\n            site = self.site  # If no site defined request peers for this site\n\n        # give back 5 connectible peers\n        packed_peers = helper.packPeers(self.site.getConnectablePeers(5, allow_private=False))\n        request = {\"site\": site.address, \"peers\": packed_peers[\"ip4\"], \"need\": need_num}\n        if packed_peers[\"onion\"]:\n            request[\"peers_onion\"] = packed_peers[\"onion\"]\n        res = self.request(\"pex\", request)\n        if not res or \"error\" in res:\n            return False\n        added = 0\n        # Ip4\n        for peer in res.get(\"peers\", []):\n            address = helper.unpackAddress(peer)\n            if site.addPeer(*address, source=\"pex\"):\n                added += 1\n        # Onion\n        for peer in res.get(\"peers_onion\", []):\n            address = helper.unpackOnionAddress(peer)\n            if site.addPeer(*address, source=\"pex\"):\n                added += 1\n\n        if added:\n            self.log(\"Added peers using pex: %s\" % added)\n\n        return added\n\n    # List modified files since the date\n    # Return: {inner_path: modification date,...}\n    def listModified(self, since):\n        return self.request(\"listModified\", {\"since\": since, \"site\": self.site.address})\n\n    def updateHashfield(self, force=False):\n        # Don't update hashfield again in 5 min\n        if self.time_hashfield and time.time() - self.time_hashfield < 5 * 60 and not force:\n            return False\n\n        self.time_hashfield = time.time()\n        res = self.request(\"getHashfield\", {\"site\": self.site.address})\n        if not res or \"error\" in res or not \"hashfield_raw\" in res:\n            return False\n        self.hashfield.replaceFromString(res[\"hashfield_raw\"])\n\n        return self.hashfield\n\n    # Find peers for hashids\n    # Return: {hash1: [\"ip:port\", \"ip:port\",...],...}\n    def findHashIds(self, hash_ids):\n        res = self.request(\"findHashIds\", {\"site\": self.site.address, \"hash_ids\": hash_ids})\n        if not res or \"error\" in res or type(res) is not dict:\n            return False\n        # Unpack IP4\n        back = {key: map(helper.unpackAddress, val) for key, val in res[\"peers\"].items()[0:30]}\n        # Unpack onion\n        for hash, onion_peers in res.get(\"peers_onion\", {}).items()[0:30]:\n            if hash not in back:\n                back[hash] = []\n            back[hash] += map(helper.unpackOnionAddress, onion_peers)\n\n        return back\n\n    # Send my hashfield to peer\n    # Return: True if sent\n    def sendMyHashfield(self):\n        if self.connection and self.connection.handshake.get(\"rev\", 0) < 510:\n            return False  # Not supported\n        if self.time_my_hashfield_sent and self.site.content_manager.hashfield.time_changed <= self.time_my_hashfield_sent:\n            return False  # Peer already has the latest hashfield\n\n        res = self.request(\"setHashfield\", {\"site\": self.site.address, \"hashfield_raw\": self.site.content_manager.hashfield.tostring()})\n        if not res or \"error\" in res:\n            return False\n        else:\n            self.time_my_hashfield_sent = time.time()\n            return True\n\n    # Stop and remove from site\n    def remove(self, reason=\"Removing\"):\n        self.log(\"Removing peer...Connection error: %s, Hash failed: %s\" % (self.connection_error, self.hash_failed))\n        if self.site and self.key in self.site.peers:\n            del(self.site.peers[self.key])\n\n        if self.site and self in self.site.peers_recent:\n            self.site.peers_recent.remove(self)\n\n        if self.connection:\n            self.connection.close(reason)\n\n    # - EVENTS -\n\n    # On connection error\n    def onConnectionError(self, reason=\"Unknown\"):\n        self.connection_error += 1\n        if self.site and len(self.site.peers) > 200:\n            limit = 3\n        else:\n            limit = 6\n        if self.connection_error >= limit:  # Dead peer\n            self.remove(\"Peer connection: %s\" % reason)\n\n    # Done working with peer\n    def onWorkerDone(self):\n        pass\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "Peer.py", "id": "296339b7aacbcb92532e748c49d8c085", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-3bdb6a2/src/Peer/Peer.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:21:08Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}