{"author": "tensorflow", "code": "\"\"\"Functions for computing normalization splines for Kepler light curves.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport itertools\nimport warnings\n\nimport numpy as np\nfrom pydl.pydlutils import bspline\n\nfrom third_party.robust_mean import robust_mean\n\n\nclass SplineError(Exception):\n  \"\"\"Error when fitting a Kepler spline.\"\"\"\n  pass\n\n\ndef kepler_spline(time, flux, bkspace=1.5, maxiter=5, outlier_cut=3):\n  \"\"\"Computes a best-fit spline curve for a light curve segment.\n\n  The spline is fit using an iterative process to remove outliers that may cause\n  the spline to be \"pulled\" by discrepent points. In each iteration the spline\n  is fit, and if there are any points where the absolute deviation from the\n  median residual is at least 3*sigma (where sigma is a robust estimate of the\n  standard deviation of the residuals), those points are removed and the spline\n  is re-fit.\n\n  Args:\n    time: Numpy array; the time values of the light curve.\n    flux: Numpy array; the flux (brightness) values of the light curve.\n    bkspace: Spline break point spacing in time units.\n    maxiter: Maximum number of attempts to fit the spline after removing badly\n        fit points.\n    outlier_cut: The maximum number of standard deviations from the median\n        spline residual before a point is considered an outlier.\n\n  Returns:\n    spline: The values of the fitted spline corresponding to the input time\n        values.\n    mask: Boolean mask indicating the points used to fit the final spline.\n  \"\"\"\n  # Rescale time into [0, 1].\n  t_min = np.min(time)\n  t_max = np.max(time)\n  time = (time - t_min) / (t_max - t_min)\n  bkspace /= (t_max - t_min)  \n\n  \n  spline = None\n\n  \n  mask = None\n\n  for _ in range(maxiter):\n    if spline is None:\n      mask = np.ones_like(time, dtype=np.bool)  \n    else:\n      \n      # less than 3*sigma, where sigma is a robust estimate of the standard\n      \n      residuals = flux - spline\n      _, _, new_mask = robust_mean.robust_mean(residuals, cut=outlier_cut)\n\n      if np.all(new_mask == mask):\n        break  \n\n      mask = new_mask\n\n    try:\n      with warnings.catch_warnings():\n        \n        \n        warnings.simplefilter(\"ignore\")\n\n        \n        curve = bspline.iterfit(time[mask], flux[mask], bkspace=bkspace)[0]\n\n      \n      spline = curve.value(time)[0]\n    except (IndexError, TypeError) as e:\n      raise SplineError(\n          \"Fitting spline failed with error: '%s'. This might be caused by the \"\n          \"breakpoint spacing being too small, and/or there being insufficient \"\n          \"points to fit the spline in one of the intervals.\" % e)\n\n  return spline, mask\n\n\ndef choose_kepler_spline(all_time,\n                         all_flux,\n                         bkspaces,\n                         maxiter=5,\n                         penalty_coeff=1.0,\n                         verbose=True):\n  \"\"\"Computes the best-fit Kepler spline across a break-point spacings.\n\n  Some Kepler light curves have low-frequency variability, while others have\n  very high-frequency variability (e.g. due to rapid rotation). Therefore, it is\n  suboptimal to use the same break-point spacing for every star. This function\n  computes the best-fit spline by fitting splines with different break-point\n  spacings, calculating the Bayesian Information Criterion (BIC) for each\n  spline, and choosing the break-point spacing that minimizes the BIC.\n\n  This function assumes a piecewise light curve, that is, a light curve that is\n  divided into different segments (e.g. split by quarter breaks or gaps in the\n  in the data). A separate spline is fit for each segment.\n\n  Args:\n    all_time: List of 1D numpy arrays; the time values of the light curve.\n    all_flux: List of 1D numpy arrays; the flux (brightness) values of the light\n        curve.\n    bkspaces: List of break-point spacings to try.\n    maxiter: Maximum number of attempts to fit each spline after removing badly\n        fit points.\n    penalty_coeff: Coefficient of the penalty term for using more parameters in\n        the Bayesian Information Criterion. Decreasing this value will allow\n        more parameters to be used (i.e. smaller break-point spacing), and\n        vice-versa.\n    verbose: Whether to log individual spline errors. Note that if bkspaces\n        contains many values (particularly small ones) then this may cause\n        logging pollution if calling this function for many light curves.\n\n  Returns:\n    spline: List of numpy arrays; values of the best-fit spline corresponding to\n        to the input flux arrays.\n    spline_mask: List of boolean numpy arrays indicating which points in the\n        flux arrays were used to fit the best-fit spline.\n    bkspace: The break-point spacing used for the best-fit spline.\n    bad_bkspaces: List of break-point spacing values that failed.\n  \"\"\"\n  \n  \n  abs_deviations = np.concatenate([np.abs(f[1:] - f[:-1]) for f in all_flux])\n  sigma = np.median(abs_deviations) * 1.48 / np.sqrt(2)\n\n  best_bic = None\n  best_spline = None\n  best_spline_mask = None\n  best_bkspace = None\n  bad_bkspaces = []\n  for bkspace in bkspaces:\n    nparams = 0  \n    npoints = 0  \n    ssr = 0  \n\n    spline = []\n    spline_mask = []\n    bad_bkspace = False  \n    for time, flux in itertools.izip(all_time, all_flux):\n      \n      if len(time) < 4:\n        spline.append(flux)\n        spline_mask.append(np.ones_like(flux), dtype=np.bool)\n        continue\n\n      \n      try:\n        spline_piece, mask = kepler_spline(\n            time, flux, bkspace=bkspace, maxiter=maxiter)\n\n      \n      \n      except SplineError as e:\n        if verbose:\n          warnings.warn(\"Bad bkspace %.4f: %s\" % (bkspace, e))\n        bad_bkspaces.append(bkspace)\n        bad_bkspace = True\n        break\n\n      spline.append(spline_piece)\n      spline_mask.append(mask)\n\n      \n      total_time = np.max(time) - np.min(time)\n      nknots = int(total_time / bkspace) + 1  \n      nparams += nknots + 3 - 1  # number of knots + degree of spline - 1\n\n      \n      npoints += np.sum(mask)\n      ssr += np.sum((flux[mask] - spline_piece[mask])**2)\n\n    if bad_bkspace:\n      continue\n\n    # The following term is -2*ln(L), where L is the likelihood of the data\n    \n    \n    likelihood_term = npoints * np.log(2 * np.pi * sigma**2) + ssr / sigma**2\n\n    \n    bic = likelihood_term + penalty_coeff * nparams * np.log(npoints)\n\n    if best_bic is None or bic < best_bic:\n      best_bic = bic\n      best_spline = spline\n      best_spline_mask = spline_mask\n      best_bkspace = bkspace\n\n  return best_spline, best_spline_mask, best_bkspace, bad_bkspaces\n", "comments": "   functions computing normalization splines kepler light curves        future   import absolute import   future   import division   future   import print function  import itertools import warnings  import numpy np pydl pydlutils import bspline  third party robust mean import robust mean   class splineerror(exception)       error fitting kepler spline       pass   def kepler spline(time  flux  bkspace 1 5  maxiter 5  outlier cut 3)       computes best fit spline curve light curve segment     the spline fit using iterative process remove outliers may cause   spline  pulled  discrepent points  in iteration spline   fit  points absolute deviation   median residual least 3 sigma (where sigma robust estimate   standard deviation residuals)  points removed spline   fit     args      time  numpy array  time values light curve      flux  numpy array  flux (brightness) values light curve      bkspace  spline break point spacing time units      maxiter  maximum number attempts fit spline removing badly         fit points      outlier cut  the maximum number standard deviations median         spline residual point considered outlier     returns      spline  the values fitted spline corresponding input time         values      mask  boolean mask indicating points used fit final spline            rescale time  0  1     min   np min(time)   max   np max(time)   time   (time   min)   (t max   min)   bkspace    (t max   min)    rescale bucket spacing       values best fitting spline evaluated time points    spline   none      mask indicating points used fit spline    mask   none      range(maxiter)      spline none        mask   np ones like(time  dtype np bool)    try fit points      else          choose points absolute deviation median residual         less 3 sigma  sigma robust estimate standard         deviation residuals previous spline        residuals   flux   spline             new mask   robust mean robust mean(residuals  cut outlier cut)        np all(new mask    mask)          break    spline converged         mask   new mask      try        warnings catch warnings()            suppress warning messages printed pydlutils bspline  instead           catch exception raise informative error          warnings simplefilter( ignore )            fit spline non outlier points          curve   bspline iterfit(time mask   flux mask   bkspace bkspace) 0           evaluate spline time points        spline   curve value(time) 0      except (indexerror  typeerror) e        raise splineerror(            fitting spline failed error      this might caused              breakpoint spacing small  insufficient              points fit spline one intervals     e)    return spline  mask   def choose kepler spline(all time                           flux                           bkspaces                           maxiter 5                           penalty coeff 1 0                           verbose true)       computes best fit kepler spline across break point spacings     some kepler light curves low frequency variability  others   high frequency variability (e g  due rapid rotation)  therefore    suboptimal use break point spacing every star  this function   computes best fit spline fitting splines different break point   spacings  calculating bayesian information criterion (bic)   spline  choosing break point spacing minimizes bic     this function assumes piecewise light curve   light curve   divided different segments (e g  split quarter breaks gaps   data)  a separate spline fit segment     args      time  list 1d numpy arrays  time values light curve      flux  list 1d numpy arrays  flux (brightness) values light         curve      bkspaces  list break point spacings try      maxiter  maximum number attempts fit spline removing badly         fit points      penalty coeff  coefficient penalty term using parameters         bayesian information criterion  decreasing value allow         parameters used (i e  smaller break point spacing)          vice versa      verbose  whether log individual spline errors  note bkspaces         contains many values (particularly small ones) may cause         logging pollution calling function many light curves     returns      spline  list numpy arrays  values best fit spline corresponding         input flux arrays      spline mask  list boolean numpy arrays indicating points         flux arrays used fit best fit spline      bkspace  the break point spacing used best fit spline      bad bkspaces  list break point spacing values failed           rescale time  0  1      rescale bucket spacing     values best fitting spline evaluated time points     mask indicating points used fit spline     try fit points     choose points absolute deviation median residual    less 3 sigma  sigma robust estimate standard    deviation residuals previous spline     spline converged     suppress warning messages printed pydlutils bspline  instead    catch exception raise informative error     fit spline non outlier points     evaluate spline time points     compute assumed standard deviation gaussian white noise    spline model     total number free parameters piecewise spline     total number data points used fit piecewise spline     sum squared residuals model spline     indicates current bkspace skipped     don fit spline less 4 points     fit b spline light curve segment     it expected get splineerror occasionally small values    bkspace     accumulate number free parameters     from bspline implementation     number knots   degree spline   1    accumulate number points squared residuals     the following term  2 ln(l)  l likelihood data    given model  assumption model errors iid    gaussian mean 0 standard deviation sigma     bayesian information criterion  ", "content": "\"\"\"Functions for computing normalization splines for Kepler light curves.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport itertools\nimport warnings\n\nimport numpy as np\nfrom pydl.pydlutils import bspline\n\nfrom third_party.robust_mean import robust_mean\n\n\nclass SplineError(Exception):\n  \"\"\"Error when fitting a Kepler spline.\"\"\"\n  pass\n\n\ndef kepler_spline(time, flux, bkspace=1.5, maxiter=5, outlier_cut=3):\n  \"\"\"Computes a best-fit spline curve for a light curve segment.\n\n  The spline is fit using an iterative process to remove outliers that may cause\n  the spline to be \"pulled\" by discrepent points. In each iteration the spline\n  is fit, and if there are any points where the absolute deviation from the\n  median residual is at least 3*sigma (where sigma is a robust estimate of the\n  standard deviation of the residuals), those points are removed and the spline\n  is re-fit.\n\n  Args:\n    time: Numpy array; the time values of the light curve.\n    flux: Numpy array; the flux (brightness) values of the light curve.\n    bkspace: Spline break point spacing in time units.\n    maxiter: Maximum number of attempts to fit the spline after removing badly\n        fit points.\n    outlier_cut: The maximum number of standard deviations from the median\n        spline residual before a point is considered an outlier.\n\n  Returns:\n    spline: The values of the fitted spline corresponding to the input time\n        values.\n    mask: Boolean mask indicating the points used to fit the final spline.\n  \"\"\"\n  # Rescale time into [0, 1].\n  t_min = np.min(time)\n  t_max = np.max(time)\n  time = (time - t_min) / (t_max - t_min)\n  bkspace /= (t_max - t_min)  # Rescale bucket spacing.\n\n  # Values of the best fitting spline evaluated at the time points.\n  spline = None\n\n  # Mask indicating the points used to fit the spline.\n  mask = None\n\n  for _ in range(maxiter):\n    if spline is None:\n      mask = np.ones_like(time, dtype=np.bool)  # Try to fit all points.\n    else:\n      # Choose points where the absolute deviation from the median residual is\n      # less than 3*sigma, where sigma is a robust estimate of the standard\n      # deviation of the residuals from the previous spline.\n      residuals = flux - spline\n      _, _, new_mask = robust_mean.robust_mean(residuals, cut=outlier_cut)\n\n      if np.all(new_mask == mask):\n        break  # Spline converged.\n\n      mask = new_mask\n\n    try:\n      with warnings.catch_warnings():\n        # Suppress warning messages printed by pydlutils.bspline. Instead we\n        # catch any exception and raise a more informative error.\n        warnings.simplefilter(\"ignore\")\n\n        # Fit the spline on non-outlier points.\n        curve = bspline.iterfit(time[mask], flux[mask], bkspace=bkspace)[0]\n\n      # Evaluate spline at the time points.\n      spline = curve.value(time)[0]\n    except (IndexError, TypeError) as e:\n      raise SplineError(\n          \"Fitting spline failed with error: '%s'. This might be caused by the \"\n          \"breakpoint spacing being too small, and/or there being insufficient \"\n          \"points to fit the spline in one of the intervals.\" % e)\n\n  return spline, mask\n\n\ndef choose_kepler_spline(all_time,\n                         all_flux,\n                         bkspaces,\n                         maxiter=5,\n                         penalty_coeff=1.0,\n                         verbose=True):\n  \"\"\"Computes the best-fit Kepler spline across a break-point spacings.\n\n  Some Kepler light curves have low-frequency variability, while others have\n  very high-frequency variability (e.g. due to rapid rotation). Therefore, it is\n  suboptimal to use the same break-point spacing for every star. This function\n  computes the best-fit spline by fitting splines with different break-point\n  spacings, calculating the Bayesian Information Criterion (BIC) for each\n  spline, and choosing the break-point spacing that minimizes the BIC.\n\n  This function assumes a piecewise light curve, that is, a light curve that is\n  divided into different segments (e.g. split by quarter breaks or gaps in the\n  in the data). A separate spline is fit for each segment.\n\n  Args:\n    all_time: List of 1D numpy arrays; the time values of the light curve.\n    all_flux: List of 1D numpy arrays; the flux (brightness) values of the light\n        curve.\n    bkspaces: List of break-point spacings to try.\n    maxiter: Maximum number of attempts to fit each spline after removing badly\n        fit points.\n    penalty_coeff: Coefficient of the penalty term for using more parameters in\n        the Bayesian Information Criterion. Decreasing this value will allow\n        more parameters to be used (i.e. smaller break-point spacing), and\n        vice-versa.\n    verbose: Whether to log individual spline errors. Note that if bkspaces\n        contains many values (particularly small ones) then this may cause\n        logging pollution if calling this function for many light curves.\n\n  Returns:\n    spline: List of numpy arrays; values of the best-fit spline corresponding to\n        to the input flux arrays.\n    spline_mask: List of boolean numpy arrays indicating which points in the\n        flux arrays were used to fit the best-fit spline.\n    bkspace: The break-point spacing used for the best-fit spline.\n    bad_bkspaces: List of break-point spacing values that failed.\n  \"\"\"\n  # Compute the assumed standard deviation of Gaussian white noise about the\n  # spline model.\n  abs_deviations = np.concatenate([np.abs(f[1:] - f[:-1]) for f in all_flux])\n  sigma = np.median(abs_deviations) * 1.48 / np.sqrt(2)\n\n  best_bic = None\n  best_spline = None\n  best_spline_mask = None\n  best_bkspace = None\n  bad_bkspaces = []\n  for bkspace in bkspaces:\n    nparams = 0  # Total number of free parameters in the piecewise spline.\n    npoints = 0  # Total number of data points used to fit the piecewise spline.\n    ssr = 0  # Sum of squared residuals between the model and the spline.\n\n    spline = []\n    spline_mask = []\n    bad_bkspace = False  # Indicates that the current bkspace should be skipped.\n    for time, flux in itertools.izip(all_time, all_flux):\n      # Don't fit a spline on less than 4 points.\n      if len(time) < 4:\n        spline.append(flux)\n        spline_mask.append(np.ones_like(flux), dtype=np.bool)\n        continue\n\n      # Fit B-spline to this light-curve segment.\n      try:\n        spline_piece, mask = kepler_spline(\n            time, flux, bkspace=bkspace, maxiter=maxiter)\n\n      # It's expected to get a SplineError occasionally for small values of\n      # bkspace.\n      except SplineError as e:\n        if verbose:\n          warnings.warn(\"Bad bkspace %.4f: %s\" % (bkspace, e))\n        bad_bkspaces.append(bkspace)\n        bad_bkspace = True\n        break\n\n      spline.append(spline_piece)\n      spline_mask.append(mask)\n\n      # Accumulate the number of free parameters.\n      total_time = np.max(time) - np.min(time)\n      nknots = int(total_time / bkspace) + 1  # From the bspline implementation.\n      nparams += nknots + 3 - 1  # number of knots + degree of spline - 1\n\n      # Accumulate the number of points and the squared residuals.\n      npoints += np.sum(mask)\n      ssr += np.sum((flux[mask] - spline_piece[mask])**2)\n\n    if bad_bkspace:\n      continue\n\n    # The following term is -2*ln(L), where L is the likelihood of the data\n    # given the model, under the assumption that the model errors are iid\n    # Gaussian with mean 0 and standard deviation sigma.\n    likelihood_term = npoints * np.log(2 * np.pi * sigma**2) + ssr / sigma**2\n\n    # Bayesian information criterion.\n    bic = likelihood_term + penalty_coeff * nparams * np.log(npoints)\n\n    if best_bic is None or bic < best_bic:\n      best_bic = bic\n      best_spline = spline\n      best_spline_mask = spline_mask\n      best_bkspace = bkspace\n\n  return best_spline, best_spline_mask, best_bkspace, bad_bkspaces\n", "description": "Models and examples built with TensorFlow", "file_name": "kepler_spline.py", "id": "15846c136673f4c73172250feb5c1f99", "language": "Python", "project_name": "models", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/tensorflow-models/tensorflow-models-086d914/research/astronet/third_party/kepler_spline/kepler_spline.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:59:19Z", "url": "https://github.com/tensorflow/models", "wiki": true}