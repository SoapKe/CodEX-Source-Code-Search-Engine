{"author": "pypa", "code": "\nimport re\nimport sys\nimport os\n\nfrom .ansi import AnsiFore, AnsiBack, AnsiStyle, Style\nfrom .winterm import WinTerm, WinColor, WinStyle\nfrom .win32 import windll, winapi_test\n\n\nwinterm = None\nif windll is not None:\n    winterm = WinTerm()\n\n\ndef is_stream_closed(stream):\n    return not hasattr(stream, 'closed') or stream.closed\n\n\ndef is_a_tty(stream):\n    return hasattr(stream, 'isatty') and stream.isatty()\n\n\nclass StreamWrapper(object):\n    '''\n    Wraps a stream (such as stdout), acting as a transparent proxy for all\n    attribute access apart from method 'write()', which is delegated to our\n    Converter instance.\n    '''\n    def __init__(self, wrapped, converter):\n        \n        \n        self.__wrapped = wrapped\n        self.__convertor = converter\n\n    def __getattr__(self, name):\n        return getattr(self.__wrapped, name)\n\n    def write(self, text):\n        self.__convertor.write(text)\n\n\nclass AnsiToWin32(object):\n    '''\n    Implements a 'write()' method which, on Windows, will strip ANSI character\n    sequences from the text, and if outputting to a tty, will convert them into\n    win32 function calls.\n    '''\n    ANSI_CSI_RE = re.compile('\\001?\\033\\[((?:\\d|;)*)([a-zA-Z])\\002?')     \n    ANSI_OSC_RE = re.compile('\\001?\\033\\]((?:.|;)*?)(\\x07)\\002?')         \n\n    def __init__(self, wrapped, convert=None, strip=None, autoreset=False):\n        # The wrapped stream (normally sys.stdout or sys.stderr)\n        self.wrapped = wrapped\n\n        ()\n        self.autoreset = autoreset\n\n        \n        self.stream = StreamWrapper(wrapped, self)\n\n        on_windows = os.name == 'nt'\n        \n        \n        # (e.g. Cygwin Terminal). In this case it's up to the terminal\n        \n        conversion_supported = on_windows and winapi_test()\n\n        ?\n        if strip is None:\n            strip = conversion_supported or (not is_stream_closed(wrapped) and not is_a_tty(wrapped))\n        self.strip = strip\n\n        ?\n        if convert is None:\n            convert = conversion_supported and not is_stream_closed(wrapped) and is_a_tty(wrapped)\n        self.convert = convert\n\n        \n        self.win32_calls = self.get_win32_calls()\n\n        ?\n        self.on_stderr = self.wrapped is sys.stderr\n\n    def should_wrap(self):\n        '''\n        True if this class is actually needed. If false, then the output\n        stream will not be affected, nor will win32 calls be issued, so\n        wrapping stdout is not actually required. This will generally be\n        False on non-Windows platforms, unless optional functionality like\n        autoreset has been requested using kwargs to init()\n        '''\n        return self.convert or self.strip or self.autoreset\n\n    def get_win32_calls(self):\n        if self.convert and winterm:\n            return {\n                AnsiStyle.RESET_ALL: (winterm.reset_all, ),\n                AnsiStyle.BRIGHT: (winterm.style, WinStyle.BRIGHT),\n                AnsiStyle.DIM: (winterm.style, WinStyle.NORMAL),\n                AnsiStyle.NORMAL: (winterm.style, WinStyle.NORMAL),\n                AnsiFore.BLACK: (winterm.fore, WinColor.BLACK),\n                AnsiFore.RED: (winterm.fore, WinColor.RED),\n                AnsiFore.GREEN: (winterm.fore, WinColor.GREEN),\n                AnsiFore.YELLOW: (winterm.fore, WinColor.YELLOW),\n                AnsiFore.BLUE: (winterm.fore, WinColor.BLUE),\n                AnsiFore.MAGENTA: (winterm.fore, WinColor.MAGENTA),\n                AnsiFore.CYAN: (winterm.fore, WinColor.CYAN),\n                AnsiFore.WHITE: (winterm.fore, WinColor.GREY),\n                AnsiFore.RESET: (winterm.fore, ),\n                AnsiFore.LIGHTBLACK_EX: (winterm.fore, WinColor.BLACK, True),\n                AnsiFore.LIGHTRED_EX: (winterm.fore, WinColor.RED, True),\n                AnsiFore.LIGHTGREEN_EX: (winterm.fore, WinColor.GREEN, True),\n                AnsiFore.LIGHTYELLOW_EX: (winterm.fore, WinColor.YELLOW, True),\n                AnsiFore.LIGHTBLUE_EX: (winterm.fore, WinColor.BLUE, True),\n                AnsiFore.LIGHTMAGENTA_EX: (winterm.fore, WinColor.MAGENTA, True),\n                AnsiFore.LIGHTCYAN_EX: (winterm.fore, WinColor.CYAN, True),\n                AnsiFore.LIGHTWHITE_EX: (winterm.fore, WinColor.GREY, True),\n                AnsiBack.BLACK: (winterm.back, WinColor.BLACK),\n                AnsiBack.RED: (winterm.back, WinColor.RED),\n                AnsiBack.GREEN: (winterm.back, WinColor.GREEN),\n                AnsiBack.YELLOW: (winterm.back, WinColor.YELLOW),\n                AnsiBack.BLUE: (winterm.back, WinColor.BLUE),\n                AnsiBack.MAGENTA: (winterm.back, WinColor.MAGENTA),\n                AnsiBack.CYAN: (winterm.back, WinColor.CYAN),\n                AnsiBack.WHITE: (winterm.back, WinColor.GREY),\n                AnsiBack.RESET: (winterm.back, ),\n                AnsiBack.LIGHTBLACK_EX: (winterm.back, WinColor.BLACK, True),\n                AnsiBack.LIGHTRED_EX: (winterm.back, WinColor.RED, True),\n                AnsiBack.LIGHTGREEN_EX: (winterm.back, WinColor.GREEN, True),\n                AnsiBack.LIGHTYELLOW_EX: (winterm.back, WinColor.YELLOW, True),\n                AnsiBack.LIGHTBLUE_EX: (winterm.back, WinColor.BLUE, True),\n                AnsiBack.LIGHTMAGENTA_EX: (winterm.back, WinColor.MAGENTA, True),\n                AnsiBack.LIGHTCYAN_EX: (winterm.back, WinColor.CYAN, True),\n                AnsiBack.LIGHTWHITE_EX: (winterm.back, WinColor.GREY, True),\n            }\n        return dict()\n\n    def write(self, text):\n        if self.strip or self.convert:\n            self.write_and_convert(text)\n        else:\n            self.wrapped.write(text)\n            self.wrapped.flush()\n        if self.autoreset:\n            self.reset_all()\n\n\n    def reset_all(self):\n        if self.convert:\n            self.call_win32('m', (0,))\n        elif not self.strip and not is_stream_closed(self.wrapped):\n            self.wrapped.write(Style.RESET_ALL)\n\n\n    def write_and_convert(self, text):\n        '''\n        Write the given text to our wrapped stream, stripping any ANSI\n        sequences from the text, and optionally converting them into win32\n        calls.\n        '''\n        cursor = 0\n        text = self.convert_osc(text)\n        for match in self.ANSI_CSI_RE.finditer(text):\n            start, end = match.span()\n            self.write_plain_text(text, cursor, start)\n            self.convert_ansi(*match.groups())\n            cursor = end\n        self.write_plain_text(text, cursor, len(text))\n\n\n    def write_plain_text(self, text, start, end):\n        if start < end:\n            self.wrapped.write(text[start:end])\n            self.wrapped.flush()\n\n\n    def convert_ansi(self, paramstring, command):\n        if self.convert:\n            params = self.extract_params(command, paramstring)\n            self.call_win32(command, params)\n\n\n    def extract_params(self, command, paramstring):\n        if command in 'Hf':\n            params = tuple(int(p) if len(p) != 0 else 1 for p in paramstring.split(';'))\n            while len(params) < 2:\n                \n                params = params + (1,)\n        else:\n            params = tuple(int(p) for p in paramstring.split(';') if len(p) != 0)\n            if len(params) == 0:\n                \n                if command in 'JKm':\n                    params = (0,)\n                elif command in 'ABCD':\n                    params = (1,)\n\n        return params\n\n\n    def call_win32(self, command, params):\n        if command == 'm':\n            for param in params:\n                if param in self.win32_calls:\n                    func_args = self.win32_calls[param]\n                    func = func_args[0]\n                    args = func_args[1:]\n                    kwargs = dict(on_stderr=self.on_stderr)\n                    func(*args, **kwargs)\n        elif command in 'J':\n            winterm.erase_screen(params[0], on_stderr=self.on_stderr)\n        elif command in 'K':\n            winterm.erase_line(params[0], on_stderr=self.on_stderr)\n        elif command in 'Hf':     \n            winterm.set_cursor_position(params, on_stderr=self.on_stderr)\n        elif command in 'ABCD':   \n            n = params[0]\n            \n            x, y = {'A': (0, -n), 'B': (0, n), 'C': (n, 0), 'D': (-n, 0)}[command]\n            winterm.cursor_adjust(x, y, on_stderr=self.on_stderr)\n\n\n    def convert_osc(self, text):\n        for match in self.ANSI_OSC_RE.finditer(text):\n            start, end = match.span()\n            text = text[:start] + text[end:]\n            paramstring, command = match.groups()\n            if command in '\\x07':       # \\x07 = BEL\n                params = paramstring.split(\";\")\n                # 0 - change title and icon (we will only change title)\n                # 1 - change icon (we don't support this)\n                \n                if params[0] in '02':\n                    winterm.set_title(params[1])\n        return text\n", "comments": "        wraps stream (such stdout)  acting transparent proxy     attribute access apart method  write()   delegated     converter instance              def   init  (self  wrapped  converter)            double underscore everything prevent clashes names           attributes wrapped stream object          self   wrapped   wrapped         self   convertor   converter      def   getattr  (self  name)          return getattr(self   wrapped  name)      def write(self  text)          self   convertor write(text)   class ansitowin32(object)              implements  write()  method  windows  strip ansi character     sequences text  outputting tty  convert     win32 function calls              ansi csi re   compile(  001  033  ((    ) )( za z ) 002  )       control sequence introducer     ansi osc re   compile(  001  033  ((     )  )( x07) 002  )           operating system command      def   init  (self  wrapped  convert none  strip none  autoreset false)            the wrapped stream (normally sys stdout sys stderr)         self wrapped   wrapped            reset colors defaults every  write()         self autoreset   autoreset            create proxy wrapping output stream         self stream   streamwrapper(wrapped  self)          windows   os name     nt            we test winapi works  even windows           may using terminal support winapi           (e g  cygwin terminal)  in case terminal           support ansi codes          conversion supported   windows winapi test()            strip ansi sequences output          strip none              strip   conversion supported (not stream closed(wrapped) tty(wrapped))         self strip   strip            convert ansi sequences win32 calls          convert none              convert   conversion supported stream closed(wrapped) tty(wrapped)         self convert   convert            dict ansi codes win32 functions parameters         self win32 calls   self get win32 calls()            wrapping stderr          self stderr   self wrapped sys stderr      def wrap(self)                      true class actually needed  if false  output         stream affected  win32 calls issued          wrapping stdout actually required  this generally         false non windows platforms  unless optional functionality like         autoreset requested using kwargs init()                     return self convert self strip self autoreset      def get win32 calls(self)          self convert winterm              return                   ansistyle reset all  (winterm reset  )                  ansistyle bright  (winterm style  winstyle bright)                  ansistyle dim  (winterm style  winstyle normal)                  ansistyle normal  (winterm style  winstyle normal)                  ansifore black  (winterm fore  wincolor black)                  ansifore red  (winterm fore  wincolor red)                  ansifore green  (winterm fore  wincolor green)                  ansifore yellow  (winterm fore  wincolor yellow)                  ansifore blue  (winterm fore  wincolor blue)                  ansifore magenta  (winterm fore  wincolor magenta)                  ansifore cyan  (winterm fore  wincolor cyan)                  ansifore white  (winterm fore  wincolor grey)                  ansifore reset  (winterm fore  )                  ansifore lightblack ex  (winterm fore  wincolor black  true)                  ansifore lightred ex  (winterm fore  wincolor red  true)                  ansifore lightgreen ex  (winterm fore  wincolor green  true)                  ansifore lightyellow ex  (winterm fore  wincolor yellow  true)                  ansifore lightblue ex  (winterm fore  wincolor blue  true)                  ansifore lightmagenta ex  (winterm fore  wincolor magenta  true)                  ansifore lightcyan ex  (winterm fore  wincolor cyan  true)                  ansifore lightwhite ex  (winterm fore  wincolor grey  true)                  ansiback black  (winterm back  wincolor black)                  ansiback red  (winterm back  wincolor red)                  ansiback green  (winterm back  wincolor green)                  ansiback yellow  (winterm back  wincolor yellow)                  ansiback blue  (winterm back  wincolor blue)                  ansiback magenta  (winterm back  wincolor magenta)                  ansiback cyan  (winterm back  wincolor cyan)                  ansiback white  (winterm back  wincolor grey)                  ansiback reset  (winterm back  )                  ansiback lightblack ex  (winterm back  wincolor black  true)                  ansiback lightred ex  (winterm back  wincolor red  true)                  ansiback lightgreen ex  (winterm back  wincolor green  true)                  ansiback lightyellow ex  (winterm back  wincolor yellow  true)                  ansiback lightblue ex  (winterm back  wincolor blue  true)                  ansiback lightmagenta ex  (winterm back  wincolor magenta  true)                  ansiback lightcyan ex  (winterm back  wincolor cyan  true)                  ansiback lightwhite ex  (winterm back  wincolor grey  true)                        return dict()      def write(self  text)          self strip self convert              self write convert(text)         else              self wrapped write(text)             self wrapped flush()         self autoreset              self reset all()       def reset all(self)          self convert              self call win32(   (0 ))         elif self strip stream closed(self wrapped)              self wrapped write(style reset all)       def write convert(self  text)                      write given text wrapped stream  stripping ansi         sequences text  optionally converting win32         calls                 copyright jonathan hartley 2013  bsd 3 clause license  see license file     double underscore everything prevent clashes names    attributes wrapped stream object     control sequence introducer    operating system command    the wrapped stream (normally sys stdout sys stderr)    reset colors defaults every  write()    create proxy wrapping output stream    we test winapi works  even windows    may using terminal support winapi    (e g  cygwin terminal)  in case terminal    support ansi codes     strip ansi sequences output     convert ansi sequences win32 calls     dict ansi codes win32 functions parameters    wrapping stderr     defaults     defaults     cursor position   absolute    cursor position   relative    a    b    c   forward  d   back     x07   bel    0   change title icon (we change title)    1   change icon (we support this)    2   change title ", "content": "# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\nimport re\nimport sys\nimport os\n\nfrom .ansi import AnsiFore, AnsiBack, AnsiStyle, Style\nfrom .winterm import WinTerm, WinColor, WinStyle\nfrom .win32 import windll, winapi_test\n\n\nwinterm = None\nif windll is not None:\n    winterm = WinTerm()\n\n\ndef is_stream_closed(stream):\n    return not hasattr(stream, 'closed') or stream.closed\n\n\ndef is_a_tty(stream):\n    return hasattr(stream, 'isatty') and stream.isatty()\n\n\nclass StreamWrapper(object):\n    '''\n    Wraps a stream (such as stdout), acting as a transparent proxy for all\n    attribute access apart from method 'write()', which is delegated to our\n    Converter instance.\n    '''\n    def __init__(self, wrapped, converter):\n        # double-underscore everything to prevent clashes with names of\n        # attributes on the wrapped stream object.\n        self.__wrapped = wrapped\n        self.__convertor = converter\n\n    def __getattr__(self, name):\n        return getattr(self.__wrapped, name)\n\n    def write(self, text):\n        self.__convertor.write(text)\n\n\nclass AnsiToWin32(object):\n    '''\n    Implements a 'write()' method which, on Windows, will strip ANSI character\n    sequences from the text, and if outputting to a tty, will convert them into\n    win32 function calls.\n    '''\n    ANSI_CSI_RE = re.compile('\\001?\\033\\[((?:\\d|;)*)([a-zA-Z])\\002?')     # Control Sequence Introducer\n    ANSI_OSC_RE = re.compile('\\001?\\033\\]((?:.|;)*?)(\\x07)\\002?')         # Operating System Command\n\n    def __init__(self, wrapped, convert=None, strip=None, autoreset=False):\n        # The wrapped stream (normally sys.stdout or sys.stderr)\n        self.wrapped = wrapped\n\n        # should we reset colors to defaults after every .write()\n        self.autoreset = autoreset\n\n        # create the proxy wrapping our output stream\n        self.stream = StreamWrapper(wrapped, self)\n\n        on_windows = os.name == 'nt'\n        # We test if the WinAPI works, because even if we are on Windows\n        # we may be using a terminal that doesn't support the WinAPI\n        # (e.g. Cygwin Terminal). In this case it's up to the terminal\n        # to support the ANSI codes.\n        conversion_supported = on_windows and winapi_test()\n\n        # should we strip ANSI sequences from our output?\n        if strip is None:\n            strip = conversion_supported or (not is_stream_closed(wrapped) and not is_a_tty(wrapped))\n        self.strip = strip\n\n        # should we should convert ANSI sequences into win32 calls?\n        if convert is None:\n            convert = conversion_supported and not is_stream_closed(wrapped) and is_a_tty(wrapped)\n        self.convert = convert\n\n        # dict of ansi codes to win32 functions and parameters\n        self.win32_calls = self.get_win32_calls()\n\n        # are we wrapping stderr?\n        self.on_stderr = self.wrapped is sys.stderr\n\n    def should_wrap(self):\n        '''\n        True if this class is actually needed. If false, then the output\n        stream will not be affected, nor will win32 calls be issued, so\n        wrapping stdout is not actually required. This will generally be\n        False on non-Windows platforms, unless optional functionality like\n        autoreset has been requested using kwargs to init()\n        '''\n        return self.convert or self.strip or self.autoreset\n\n    def get_win32_calls(self):\n        if self.convert and winterm:\n            return {\n                AnsiStyle.RESET_ALL: (winterm.reset_all, ),\n                AnsiStyle.BRIGHT: (winterm.style, WinStyle.BRIGHT),\n                AnsiStyle.DIM: (winterm.style, WinStyle.NORMAL),\n                AnsiStyle.NORMAL: (winterm.style, WinStyle.NORMAL),\n                AnsiFore.BLACK: (winterm.fore, WinColor.BLACK),\n                AnsiFore.RED: (winterm.fore, WinColor.RED),\n                AnsiFore.GREEN: (winterm.fore, WinColor.GREEN),\n                AnsiFore.YELLOW: (winterm.fore, WinColor.YELLOW),\n                AnsiFore.BLUE: (winterm.fore, WinColor.BLUE),\n                AnsiFore.MAGENTA: (winterm.fore, WinColor.MAGENTA),\n                AnsiFore.CYAN: (winterm.fore, WinColor.CYAN),\n                AnsiFore.WHITE: (winterm.fore, WinColor.GREY),\n                AnsiFore.RESET: (winterm.fore, ),\n                AnsiFore.LIGHTBLACK_EX: (winterm.fore, WinColor.BLACK, True),\n                AnsiFore.LIGHTRED_EX: (winterm.fore, WinColor.RED, True),\n                AnsiFore.LIGHTGREEN_EX: (winterm.fore, WinColor.GREEN, True),\n                AnsiFore.LIGHTYELLOW_EX: (winterm.fore, WinColor.YELLOW, True),\n                AnsiFore.LIGHTBLUE_EX: (winterm.fore, WinColor.BLUE, True),\n                AnsiFore.LIGHTMAGENTA_EX: (winterm.fore, WinColor.MAGENTA, True),\n                AnsiFore.LIGHTCYAN_EX: (winterm.fore, WinColor.CYAN, True),\n                AnsiFore.LIGHTWHITE_EX: (winterm.fore, WinColor.GREY, True),\n                AnsiBack.BLACK: (winterm.back, WinColor.BLACK),\n                AnsiBack.RED: (winterm.back, WinColor.RED),\n                AnsiBack.GREEN: (winterm.back, WinColor.GREEN),\n                AnsiBack.YELLOW: (winterm.back, WinColor.YELLOW),\n                AnsiBack.BLUE: (winterm.back, WinColor.BLUE),\n                AnsiBack.MAGENTA: (winterm.back, WinColor.MAGENTA),\n                AnsiBack.CYAN: (winterm.back, WinColor.CYAN),\n                AnsiBack.WHITE: (winterm.back, WinColor.GREY),\n                AnsiBack.RESET: (winterm.back, ),\n                AnsiBack.LIGHTBLACK_EX: (winterm.back, WinColor.BLACK, True),\n                AnsiBack.LIGHTRED_EX: (winterm.back, WinColor.RED, True),\n                AnsiBack.LIGHTGREEN_EX: (winterm.back, WinColor.GREEN, True),\n                AnsiBack.LIGHTYELLOW_EX: (winterm.back, WinColor.YELLOW, True),\n                AnsiBack.LIGHTBLUE_EX: (winterm.back, WinColor.BLUE, True),\n                AnsiBack.LIGHTMAGENTA_EX: (winterm.back, WinColor.MAGENTA, True),\n                AnsiBack.LIGHTCYAN_EX: (winterm.back, WinColor.CYAN, True),\n                AnsiBack.LIGHTWHITE_EX: (winterm.back, WinColor.GREY, True),\n            }\n        return dict()\n\n    def write(self, text):\n        if self.strip or self.convert:\n            self.write_and_convert(text)\n        else:\n            self.wrapped.write(text)\n            self.wrapped.flush()\n        if self.autoreset:\n            self.reset_all()\n\n\n    def reset_all(self):\n        if self.convert:\n            self.call_win32('m', (0,))\n        elif not self.strip and not is_stream_closed(self.wrapped):\n            self.wrapped.write(Style.RESET_ALL)\n\n\n    def write_and_convert(self, text):\n        '''\n        Write the given text to our wrapped stream, stripping any ANSI\n        sequences from the text, and optionally converting them into win32\n        calls.\n        '''\n        cursor = 0\n        text = self.convert_osc(text)\n        for match in self.ANSI_CSI_RE.finditer(text):\n            start, end = match.span()\n            self.write_plain_text(text, cursor, start)\n            self.convert_ansi(*match.groups())\n            cursor = end\n        self.write_plain_text(text, cursor, len(text))\n\n\n    def write_plain_text(self, text, start, end):\n        if start < end:\n            self.wrapped.write(text[start:end])\n            self.wrapped.flush()\n\n\n    def convert_ansi(self, paramstring, command):\n        if self.convert:\n            params = self.extract_params(command, paramstring)\n            self.call_win32(command, params)\n\n\n    def extract_params(self, command, paramstring):\n        if command in 'Hf':\n            params = tuple(int(p) if len(p) != 0 else 1 for p in paramstring.split(';'))\n            while len(params) < 2:\n                # defaults:\n                params = params + (1,)\n        else:\n            params = tuple(int(p) for p in paramstring.split(';') if len(p) != 0)\n            if len(params) == 0:\n                # defaults:\n                if command in 'JKm':\n                    params = (0,)\n                elif command in 'ABCD':\n                    params = (1,)\n\n        return params\n\n\n    def call_win32(self, command, params):\n        if command == 'm':\n            for param in params:\n                if param in self.win32_calls:\n                    func_args = self.win32_calls[param]\n                    func = func_args[0]\n                    args = func_args[1:]\n                    kwargs = dict(on_stderr=self.on_stderr)\n                    func(*args, **kwargs)\n        elif command in 'J':\n            winterm.erase_screen(params[0], on_stderr=self.on_stderr)\n        elif command in 'K':\n            winterm.erase_line(params[0], on_stderr=self.on_stderr)\n        elif command in 'Hf':     # cursor position - absolute\n            winterm.set_cursor_position(params, on_stderr=self.on_stderr)\n        elif command in 'ABCD':   # cursor position - relative\n            n = params[0]\n            # A - up, B - down, C - forward, D - back\n            x, y = {'A': (0, -n), 'B': (0, n), 'C': (n, 0), 'D': (-n, 0)}[command]\n            winterm.cursor_adjust(x, y, on_stderr=self.on_stderr)\n\n\n    def convert_osc(self, text):\n        for match in self.ANSI_OSC_RE.finditer(text):\n            start, end = match.span()\n            text = text[:start] + text[end:]\n            paramstring, command = match.groups()\n            if command in '\\x07':       # \\x07 = BEL\n                params = paramstring.split(\";\")\n                # 0 - change title and icon (we will only change title)\n                # 1 - change icon (we don't support this)\n                # 2 - change title\n                if params[0] in '02':\n                    winterm.set_title(params[1])\n        return text\n", "description": " Python Development Workflow for Humans.", "file_name": "ansitowin32.py", "id": "ada916ac222453efb6cfea2ccebe5a9e", "language": "Python", "project_name": "pipenv", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/pypa-pipenv/pypa-pipenv-9a87a9a/pipenv/vendor/colorama/ansitowin32.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:53:13Z", "url": "https://github.com/pypa/pipenv", "wiki": true}