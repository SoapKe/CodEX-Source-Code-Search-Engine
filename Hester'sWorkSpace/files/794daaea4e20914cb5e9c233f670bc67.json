{"author": "nvbn", "code": "import array\nimport fcntl\nfrom functools import partial\nimport os\nimport pty\nimport signal\nimport sys\nimport termios\nimport tty\nfrom ..logs import warn\n\n\ndef _read(f, fd):\n    data = os.read(fd, 1024)\n    f.write(data)\n    f.flush()\n    return data\n\n\ndef _set_pty_size(master_fd):\n    buf = array.array('h', [0, 0, 0, 0])\n    fcntl.ioctl(pty.STDOUT_FILENO, termios.TIOCGWINSZ, buf, True)\n    fcntl.ioctl(master_fd, termios.TIOCSWINSZ, buf)\n\n\ndef _spawn(shell, master_read):\n    \n    if not os.environ.get('SHELL'):\n        warn(\"Shell logger doesn't support your platform.\")\n        sys.exit(1)\n\n    with open(output, 'wb') as f:\n        return_code = _spawn(os.environ['SHELL'], partial(_read, f))\n\n    sys.exit(return_code)\n", "comments": "Create a spawned process.\n\n    Modified version of pty.spawn with terminal size support.\n\n    \"\"\"\n    pid, master_fd = pty.fork()\n\n    if pid == pty.CHILD:\n        os.execlp(shell, shell)\n\n    try:\n        mode = tty.tcgetattr(pty.STDIN_FILENO)\n        tty.setraw(pty.STDIN_FILENO)\n        restore = True\n    except tty.error:    # This is the same as termios.error\n        restore = False\n\n    _set_pty_size(master_fd)\n    signal.signal(signal.SIGWINCH, lambda *_: _set_pty_size(master_fd))\n\n    try:\n        pty._copy(master_fd, master_read, pty._read)\n    except OSError:\n        if restore:\n            tty.tcsetattr(pty.STDIN_FILENO, tty.TCSAFLUSH, mode)\n\n    os.close(master_fd)\n    return os.waitpid(pid, 0)[1]\n\n\ndef shell_logger(output):\n    \"\"\"Logs shell output to the `output`.\n\n    Works like unix script command with `-f` flag.\n\n    \n \n", "content": "import array\nimport fcntl\nfrom functools import partial\nimport os\nimport pty\nimport signal\nimport sys\nimport termios\nimport tty\nfrom ..logs import warn\n\n\ndef _read(f, fd):\n    data = os.read(fd, 1024)\n    f.write(data)\n    f.flush()\n    return data\n\n\ndef _set_pty_size(master_fd):\n    buf = array.array('h', [0, 0, 0, 0])\n    fcntl.ioctl(pty.STDOUT_FILENO, termios.TIOCGWINSZ, buf, True)\n    fcntl.ioctl(master_fd, termios.TIOCSWINSZ, buf)\n\n\ndef _spawn(shell, master_read):\n    \"\"\"Create a spawned process.\n\n    Modified version of pty.spawn with terminal size support.\n\n    \"\"\"\n    pid, master_fd = pty.fork()\n\n    if pid == pty.CHILD:\n        os.execlp(shell, shell)\n\n    try:\n        mode = tty.tcgetattr(pty.STDIN_FILENO)\n        tty.setraw(pty.STDIN_FILENO)\n        restore = True\n    except tty.error:    # This is the same as termios.error\n        restore = False\n\n    _set_pty_size(master_fd)\n    signal.signal(signal.SIGWINCH, lambda *_: _set_pty_size(master_fd))\n\n    try:\n        pty._copy(master_fd, master_read, pty._read)\n    except OSError:\n        if restore:\n            tty.tcsetattr(pty.STDIN_FILENO, tty.TCSAFLUSH, mode)\n\n    os.close(master_fd)\n    return os.waitpid(pid, 0)[1]\n\n\ndef shell_logger(output):\n    \"\"\"Logs shell output to the `output`.\n\n    Works like unix script command with `-f` flag.\n\n    \"\"\"\n    if not os.environ.get('SHELL'):\n        warn(\"Shell logger doesn't support your platform.\")\n        sys.exit(1)\n\n    with open(output, 'wb') as f:\n        return_code = _spawn(os.environ['SHELL'], partial(_read, f))\n\n    sys.exit(return_code)\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "shell_logger.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/thefuck/entrypoints/shell_logger.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}