{"author": "HelloZeroNet", "code": "\n This file is part of pyasn1 software.\n\n Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>\n License: http://pyasn1.sf.net/license.html\n\nfrom pyasn1.type import univ\nfrom pyasn1.codec.ber import decoder\nfrom pyasn1.compat.octets import oct2int\nfrom pyasn1 import error\n\n__all__ = ['decode']\n\n\nclass BooleanDecoder(decoder.AbstractSimpleDecoder):\n    protoComponent = univ.Boolean(0)\n\n    def valueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet, length,\n                     state, decodeFun, substrateFun):\n        head, tail = substrate[:length], substrate[length:]\n        if not head or length != 1:\n            raise error.PyAsn1Error('Not single-octet Boolean payload')\n        byte = oct2int(head[0])\n         CER/DER specifies encoding of TRUE as 0xFF and FALSE as 0x0, while\n         BER allows any non-zero value as TRUE; cf. sections 8.2.2. and 11.1 \n         in http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf\n        if byte == 0xff:\n            value = 1\n        elif byte == 0x00:\n            value = 0\n        else:\n            raise error.PyAsn1Error('Unexpected Boolean payload: %s' % byte)\n        return self._createComponent(asn1Spec, tagSet, value), tail\n\n TODO: prohibit non-canonical encoding\nBitStringDecoder = decoder.BitStringDecoder\nOctetStringDecoder = decoder.OctetStringDecoder\nRealDecoder = decoder.RealDecoder\n\ntagMap = decoder.tagMap.copy()\ntagMap.update(\n    {univ.Boolean.tagSet: BooleanDecoder(),\n     univ.BitString.tagSet: BitStringDecoder(),\n     univ.OctetString.tagSet: OctetStringDecoder(),\n     univ.Real.tagSet: RealDecoder()}\n)\n\ntypeMap = decoder.typeMap.copy()\n\n Put in non-ambiguous types for faster codec lookup\nfor typeDecoder in tagMap.values():\n    typeId = typeDecoder.protoComponent.__class__.typeId\n    if typeId is not None and typeId not in typeMap:\n        typeMap[typeId] = typeDecoder\n\n\nclass Decoder(decoder.Decoder):\n    pass\n\n\n: Turns CER octet stream into an ASN.1 object.\n:\n: Takes CER octetstream and decode it into an ASN.1 object\n: (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which\n: may be a scalar or an arbitrary nested structure.\n:\n: Parameters\n: ----------\n: substrate: :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n:     CER octetstream\n:\n: asn1Spec: any pyasn1 type object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n:     A pyasn1 type object to act as a template guiding the decoder. Depending on the ASN.1 structure\n:     being decoded, *asn1Spec* may or may not be required. Most common reason for\n:     it to require is that ASN.1 structure is encoded in *IMPLICIT* tagging mode.\n:\n: Returns\n: -------\n: : :py:class:`tuple`\n:     A tuple of pyasn1 object recovered from CER substrate (:py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n:     and the unprocessed trailing portion of the *substrate* (may be empty)\n:\n: Raises\n: ------\n: : :py:class:`pyasn1.error.PyAsn1Error`\n:     On decoding errors\ndecode = Decoder(tagMap, decoder.typeMap)\n", "comments": "     this file part pyasn1 software        copyright (c) 2005 2017  ilya etingof  etingof gmail com     license  http   pyasn1 sf net license html       cer der specifies encoding true 0xff false 0x0     ber allows non zero value true  cf  sections 8 2 2  11 1     http   www itu int itu t studygroups com17 languages x 690 0207 pdf    todo  prohibit non canonical encoding    put non ambiguous types faster codec lookup     turns cer octet stream asn 1 object          takes cer octetstream decode asn 1 object     (e g   py class   pyasn1 type base pyasn1item  derivative)     may scalar arbitrary nested structure          parameters                    substrate   py class  bytes  (python 3)  py class  str  (python 2)         cer octetstream         asn1spec  pyasn1 type object e g   py class   pyasn1 type base pyasn1item  derivative         a pyasn1 type object act template guiding decoder  depending asn 1 structure         decoded   asn1spec  may may required  most common reason         require asn 1 structure encoded  implicit  tagging mode          returns                    py class  tuple          a tuple pyasn1 object recovered cer substrate ( py class   pyasn1 type base pyasn1item  derivative)         unprocessed trailing portion  substrate  (may empty)         raises                   py class  pyasn1 error pyasn1error          on decoding errors ", "content": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>\n# License: http://pyasn1.sf.net/license.html\n#\nfrom pyasn1.type import univ\nfrom pyasn1.codec.ber import decoder\nfrom pyasn1.compat.octets import oct2int\nfrom pyasn1 import error\n\n__all__ = ['decode']\n\n\nclass BooleanDecoder(decoder.AbstractSimpleDecoder):\n    protoComponent = univ.Boolean(0)\n\n    def valueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet, length,\n                     state, decodeFun, substrateFun):\n        head, tail = substrate[:length], substrate[length:]\n        if not head or length != 1:\n            raise error.PyAsn1Error('Not single-octet Boolean payload')\n        byte = oct2int(head[0])\n        # CER/DER specifies encoding of TRUE as 0xFF and FALSE as 0x0, while\n        # BER allows any non-zero value as TRUE; cf. sections 8.2.2. and 11.1 \n        # in http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf\n        if byte == 0xff:\n            value = 1\n        elif byte == 0x00:\n            value = 0\n        else:\n            raise error.PyAsn1Error('Unexpected Boolean payload: %s' % byte)\n        return self._createComponent(asn1Spec, tagSet, value), tail\n\n# TODO: prohibit non-canonical encoding\nBitStringDecoder = decoder.BitStringDecoder\nOctetStringDecoder = decoder.OctetStringDecoder\nRealDecoder = decoder.RealDecoder\n\ntagMap = decoder.tagMap.copy()\ntagMap.update(\n    {univ.Boolean.tagSet: BooleanDecoder(),\n     univ.BitString.tagSet: BitStringDecoder(),\n     univ.OctetString.tagSet: OctetStringDecoder(),\n     univ.Real.tagSet: RealDecoder()}\n)\n\ntypeMap = decoder.typeMap.copy()\n\n# Put in non-ambiguous types for faster codec lookup\nfor typeDecoder in tagMap.values():\n    typeId = typeDecoder.protoComponent.__class__.typeId\n    if typeId is not None and typeId not in typeMap:\n        typeMap[typeId] = typeDecoder\n\n\nclass Decoder(decoder.Decoder):\n    pass\n\n\n#: Turns CER octet stream into an ASN.1 object.\n#:\n#: Takes CER octetstream and decode it into an ASN.1 object\n#: (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which\n#: may be a scalar or an arbitrary nested structure.\n#:\n#: Parameters\n#: ----------\n#: substrate: :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n#:     CER octetstream\n#:\n#: asn1Spec: any pyasn1 type object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:     A pyasn1 type object to act as a template guiding the decoder. Depending on the ASN.1 structure\n#:     being decoded, *asn1Spec* may or may not be required. Most common reason for\n#:     it to require is that ASN.1 structure is encoded in *IMPLICIT* tagging mode.\n#:\n#: Returns\n#: -------\n#: : :py:class:`tuple`\n#:     A tuple of pyasn1 object recovered from CER substrate (:py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     and the unprocessed trailing portion of the *substrate* (may be empty)\n#:\n#: Raises\n#: ------\n#: : :py:class:`pyasn1.error.PyAsn1Error`\n#:     On decoding errors\ndecode = Decoder(tagMap, decoder.typeMap)\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "decoder.py", "id": "74c604959ad034348cb7dbe8e0d680e1", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/lib/pyasn1/codec/cer/decoder.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}