{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom odoo import fields, models\n\n\nclass AccountInvoice(models.Model):\n    _inherit = 'account.invoice'\n\n    incoterms_id = fields.Many2one('stock.incoterms', string=\"Incoterms\",\n        help=\"Incoterms are series of sales terms. They are used to divide transaction costs and responsibilities between buyer and seller and reflect state-of-the-art transportation practices.\",\n        readonly=True, states={'draft': [('readonly', False)]})\n\n\nclass AccountInvoiceLine(models.Model):\n    _inherit = \"account.invoice.line\"\n\n    def _get_anglo_saxon_price_unit(self):\n        price_unit = super(AccountInvoiceLine,self)._get_anglo_saxon_price_unit()\n        \n        \n        if self.product_id.invoice_policy == \"delivery\":\n            for s_line in self.sale_line_ids:\n                \n                qty_done = sum([x.uom_id._compute_quantity(x.quantity, x.product_id.uom_id) for x in s_line.invoice_lines if x.invoice_id.state in ('open', 'paid')])\n                quantity = self.uom_id._compute_quantity(self.quantity, self.product_id.uom_id)\n                \n                moves = self.env['stock.move']\n                moves |= s_line.move_ids\n                moves.sorted(lambda x: x.date)\n                \n                \n                \n                average_price_unit = self._compute_average_price(qty_done, quantity, moves)\n                price_unit = average_price_unit or price_unit\n                price_unit = self.product_id.uom_id._compute_price(price_unit, self.uom_id)\n        return price_unit\n\n    def _compute_average_price(self, qty_done, quantity, moves):\n        average_price_unit = 0\n        qty_delivered = 0\n        invoiced_qty = 0\n        for move in moves:\n            if move.state != 'done':\n                continue\n            invoiced_qty += move.product_qty\n            if invoiced_qty <= qty_done:\n                continue\n            qty_to_consider = move.product_qty\n            if invoiced_qty - move.product_qty < qty_done:\n                qty_to_consider = invoiced_qty - qty_done\n            qty_to_consider = min(qty_to_consider, quantity - qty_delivered)\n            qty_delivered += qty_to_consider\n            \n            \n            average_price_unit = (average_price_unit * (qty_delivered - qty_to_consider) + abs(move.price_unit) * qty_to_consider) / qty_delivered\n            if qty_delivered == quantity:\n                break\n        return average_price_unit\n", "comments": "      coding  utf 8        part odoo  see license file full copyright licensing details     case anglo saxon product configured invoiced based delivery  perpetual    valuation real price costing method  must find real price cost good sold    qtys already invoiced    put moves fixed order date executed    go moves nothing get qty done    beyond qty done need calculate average price unit    moves encounter      move price unit  negative move positive move    dropshipped  use absolute value compute average price unit  ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom odoo import fields, models\n\n\nclass AccountInvoice(models.Model):\n    _inherit = 'account.invoice'\n\n    incoterms_id = fields.Many2one('stock.incoterms', string=\"Incoterms\",\n        help=\"Incoterms are series of sales terms. They are used to divide transaction costs and responsibilities between buyer and seller and reflect state-of-the-art transportation practices.\",\n        readonly=True, states={'draft': [('readonly', False)]})\n\n\nclass AccountInvoiceLine(models.Model):\n    _inherit = \"account.invoice.line\"\n\n    def _get_anglo_saxon_price_unit(self):\n        price_unit = super(AccountInvoiceLine,self)._get_anglo_saxon_price_unit()\n        # in case of anglo saxon with a product configured as invoiced based on delivery, with perpetual\n        # valuation and real price costing method, we must find the real price for the cost of good sold\n        if self.product_id.invoice_policy == \"delivery\":\n            for s_line in self.sale_line_ids:\n                # qtys already invoiced\n                qty_done = sum([x.uom_id._compute_quantity(x.quantity, x.product_id.uom_id) for x in s_line.invoice_lines if x.invoice_id.state in ('open', 'paid')])\n                quantity = self.uom_id._compute_quantity(self.quantity, self.product_id.uom_id)\n                # Put moves in fixed order by date executed\n                moves = self.env['stock.move']\n                moves |= s_line.move_ids\n                moves.sorted(lambda x: x.date)\n                # Go through all the moves and do nothing until you get to qty_done\n                # Beyond qty_done we need to calculate the average of the price_unit\n                # on the moves we encounter.\n                average_price_unit = self._compute_average_price(qty_done, quantity, moves)\n                price_unit = average_price_unit or price_unit\n                price_unit = self.product_id.uom_id._compute_price(price_unit, self.uom_id)\n        return price_unit\n\n    def _compute_average_price(self, qty_done, quantity, moves):\n        average_price_unit = 0\n        qty_delivered = 0\n        invoiced_qty = 0\n        for move in moves:\n            if move.state != 'done':\n                continue\n            invoiced_qty += move.product_qty\n            if invoiced_qty <= qty_done:\n                continue\n            qty_to_consider = move.product_qty\n            if invoiced_qty - move.product_qty < qty_done:\n                qty_to_consider = invoiced_qty - qty_done\n            qty_to_consider = min(qty_to_consider, quantity - qty_delivered)\n            qty_delivered += qty_to_consider\n            # `move.price_unit` is negative if the move is out and positive if the move is\n            # dropshipped. Use its absolute value to compute the average price unit.\n            average_price_unit = (average_price_unit * (qty_delivered - qty_to_consider) + abs(move.price_unit) * qty_to_consider) / qty_delivered\n            if qty_delivered == quantity:\n                break\n        return average_price_unit\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "account_invoice.py", "id": "d546afb67526536ab40e5cc617ac9b54", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/sale_stock/models/account_invoice.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}