{"author": "jakubroztocil", "code": "from httpie.compat import urlsplit, str\n\n\nclass HTTPMessage(object):\n    \"\"\"Abstract class for HTTP messages.\"\"\"\n\n    def __init__(self, orig):\n        self._orig = orig\n\n    def iter_body(self, chunk_size):\n        \"\"\"Return an iterator over the body.\"\"\"\n        raise NotImplementedError()\n\n    def iter_lines(self, chunk_size):\n        \"\"\"Return an iterator over the body yielding (`line`, `line_feed`).\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def headers(self):\n        \"\"\"Return a `str` with the message's headers.\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def encoding(self):\n        \"\"\"Return a `str` with the message's encoding, if known.\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def body(self):\n        \"\"\"Return a `bytes` with the message's body.\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def content_type(self):\n        \"\"\"Return the message content type.\"\"\"\n        ct = self._orig.headers.get('Content-Type', '')\n        if not isinstance(ct, str):\n            ct = ct.decode('utf8')\n        return ct\n\n\nclass HTTPResponse(HTTPMessage):\n    \"\"\"A :class:`requests.models.Response` wrapper.\"\"\"\n\n    def iter_body(self, chunk_size=1):\n        return self._orig.iter_content(chunk_size=chunk_size)\n\n    def iter_lines(self, chunk_size):\n        return ((line, b'\\n') for line in self._orig.iter_lines(chunk_size))\n\n    \n    @property\n    def headers(self):\n        original = self._orig.raw._original_response\n\n        version = {\n            9: '0.9',\n            10: '1.0',\n            11: '1.1',\n            20: '2',\n        }[original.version]\n\n        status_line = 'HTTP/{version} {status} {reason}'.format(\n            version=version,\n            status=original.status,\n            reason=original.reason\n        )\n        headers = [status_line]\n        try:\n            \n            \n            headers.extend(\n                '%s: %s' % header for header in original.msg._headers)\n        except AttributeError:\n            \n            \n            headers.extend(h.strip() for h in original.msg.headers)\n\n        return '\\r\\n'.join(headers)\n\n    @property\n    def encoding(self):\n        return self._orig.encoding or 'utf8'\n\n    @property\n    def body(self):\n        \n        \n        return self._orig.content\n\n\nclass HTTPRequest(HTTPMessage):\n    \"\"\"A :class:`requests.models.Request` wrapper.\"\"\"\n\n    def iter_body(self, chunk_size):\n        yield self.body\n\n    def iter_lines(self, chunk_size):\n        yield self.body, b''\n\n    @property\n    def headers(self):\n        url = urlsplit(self._orig.url)\n\n        request_line = '{method} {path}{query} HTTP/1.1'.format(\n            method=self._orig.method,\n            path=url.path or '/',\n            query='?' + url.query if url.query else ''\n        )\n\n        headers = dict(self._orig.headers)\n        if 'Host' not in self._orig.headers:\n            headers['Host'] = url.netloc.split('@')[-1]\n\n        headers = [\n            '%s: %s' % (\n                name,\n                value if isinstance(value, str) else value.decode('utf8')\n            )\n            for name, value in headers.items()\n        ]\n\n        headers.insert(0, request_line)\n        headers = '\\r\\n'.join(headers).strip()\n\n        if isinstance(headers, bytes):\n            \n            headers = headers.decode('utf8')\n        return headers\n\n    @property\n    def encoding(self):\n        return 'utf8'\n\n    @property\n    def body(self):\n        body = self._orig.body\n        if isinstance(body, str):\n            \n            body = body.encode('utf8')\n        return body or b''\n", "comments": "   abstract class http messages          def   init  (self  orig)          self  orig   orig      def iter body(self  chunk size)             return iterator body             raise notimplementederror()      def iter lines(self  chunk size)             return iterator body yielding ( line    line feed )             raise notimplementederror()       property     def headers(self)             return  str  message headers             raise notimplementederror()       property     def encoding(self)             return  str  message encoding  known             raise notimplementederror()       property     def body(self)             return  bytes  message body             raise notimplementederror()       property     def content type(self)             return message content type             ct   self  orig headers get( content type     )         isinstance(ct  str)              ct   ct decode( utf8 )         return ct   class httpresponse(httpmessage)         a  class  requests models response  wrapper          def iter body(self  chunk size 1)          return self  orig iter content(chunk size chunk size)      def iter lines(self  chunk size)          return ((line  b  n ) line self  orig iter lines(chunk size))        noinspection pyprotectedmember      property     def headers(self)          original   self  orig raw  original response          version                 9   0 9               10   1 0               11   1 1               20   2             original version           status line    http  version   status   reason   format(             version version              status original status              reason original reason         )         headers    status line          try                 original msg   http client httpmessage  python 3                 headers  2 tuple             headers extend(                        header header original msg  headers)         except attributeerror                 httplib httpmessage  python 2 x                headers  list  name  val crlf                headers extend(h strip() h original msg headers)          return   r n  join(headers)       property     def encoding(self)          return self  orig encoding  utf8        property     def body(self)            only response body fetched            shouldn touched unless body actually needed          return self  orig content   class httprequest(httpmessage)         a  class  requests models request  wrapper        noinspection pyprotectedmember     original msg   http client httpmessage  python 3      headers  2 tuple     httplib httpmessage  python 2 x     headers  list  name  val crlf       only response body fetched     shouldn touched unless body actually needed     python   3    happens json form request data parsed command line  ", "content": "from httpie.compat import urlsplit, str\n\n\nclass HTTPMessage(object):\n    \"\"\"Abstract class for HTTP messages.\"\"\"\n\n    def __init__(self, orig):\n        self._orig = orig\n\n    def iter_body(self, chunk_size):\n        \"\"\"Return an iterator over the body.\"\"\"\n        raise NotImplementedError()\n\n    def iter_lines(self, chunk_size):\n        \"\"\"Return an iterator over the body yielding (`line`, `line_feed`).\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def headers(self):\n        \"\"\"Return a `str` with the message's headers.\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def encoding(self):\n        \"\"\"Return a `str` with the message's encoding, if known.\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def body(self):\n        \"\"\"Return a `bytes` with the message's body.\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def content_type(self):\n        \"\"\"Return the message content type.\"\"\"\n        ct = self._orig.headers.get('Content-Type', '')\n        if not isinstance(ct, str):\n            ct = ct.decode('utf8')\n        return ct\n\n\nclass HTTPResponse(HTTPMessage):\n    \"\"\"A :class:`requests.models.Response` wrapper.\"\"\"\n\n    def iter_body(self, chunk_size=1):\n        return self._orig.iter_content(chunk_size=chunk_size)\n\n    def iter_lines(self, chunk_size):\n        return ((line, b'\\n') for line in self._orig.iter_lines(chunk_size))\n\n    # noinspection PyProtectedMember\n    @property\n    def headers(self):\n        original = self._orig.raw._original_response\n\n        version = {\n            9: '0.9',\n            10: '1.0',\n            11: '1.1',\n            20: '2',\n        }[original.version]\n\n        status_line = 'HTTP/{version} {status} {reason}'.format(\n            version=version,\n            status=original.status,\n            reason=original.reason\n        )\n        headers = [status_line]\n        try:\n            # `original.msg` is a `http.client.HTTPMessage` on Python 3\n            # `_headers` is a 2-tuple\n            headers.extend(\n                '%s: %s' % header for header in original.msg._headers)\n        except AttributeError:\n            # and a `httplib.HTTPMessage` on Python 2.x\n            # `headers` is a list of `name: val<CRLF>`.\n            headers.extend(h.strip() for h in original.msg.headers)\n\n        return '\\r\\n'.join(headers)\n\n    @property\n    def encoding(self):\n        return self._orig.encoding or 'utf8'\n\n    @property\n    def body(self):\n        # Only now the response body is fetched.\n        # Shouldn't be touched unless the body is actually needed.\n        return self._orig.content\n\n\nclass HTTPRequest(HTTPMessage):\n    \"\"\"A :class:`requests.models.Request` wrapper.\"\"\"\n\n    def iter_body(self, chunk_size):\n        yield self.body\n\n    def iter_lines(self, chunk_size):\n        yield self.body, b''\n\n    @property\n    def headers(self):\n        url = urlsplit(self._orig.url)\n\n        request_line = '{method} {path}{query} HTTP/1.1'.format(\n            method=self._orig.method,\n            path=url.path or '/',\n            query='?' + url.query if url.query else ''\n        )\n\n        headers = dict(self._orig.headers)\n        if 'Host' not in self._orig.headers:\n            headers['Host'] = url.netloc.split('@')[-1]\n\n        headers = [\n            '%s: %s' % (\n                name,\n                value if isinstance(value, str) else value.decode('utf8')\n            )\n            for name, value in headers.items()\n        ]\n\n        headers.insert(0, request_line)\n        headers = '\\r\\n'.join(headers).strip()\n\n        if isinstance(headers, bytes):\n            # Python < 3\n            headers = headers.decode('utf8')\n        return headers\n\n    @property\n    def encoding(self):\n        return 'utf8'\n\n    @property\n    def body(self):\n        body = self._orig.body\n        if isinstance(body, str):\n            # Happens with JSON/form request data parsed from the command line.\n            body = body.encode('utf8')\n        return body or b''\n", "description": "Modern command line HTTP client \u2013 user-friendly curl alternative with intuitive UI, JSON support, syntax highlighting, wget-like downloads, extensions, etc.  https://httpie.org", "file_name": "models.py", "id": "869fc9816ab800fabfcac1a194212afd", "language": "Python", "project_name": "httpie", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/jakubroztocil-httpie/jakubroztocil-httpie-0f4dce9/httpie/models.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:48:16Z", "url": "https://github.com/jakubroztocil/httpie", "wiki": false}