{"author": "ansible", "code": "\n# -*- coding: utf-8 -*-\n\n# (c) 2013, Chatham Financial <oss@chathamfinancial.com>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: rabbitmq_user\nshort_description: Adds or removes users to RabbitMQ\ndescription:\n  - Add or remove users to RabbitMQ and assign permissions\nversion_added: \"1.1\"\nauthor: '\"Chris Hoffman (@chrishoffman)\"'\noptions:\n  user:\n    description:\n      - Name of user to add\n    required: true\n    aliases: [username, name]\n  password:\n    description:\n      - Password of user to add.\n      - To change the password of an existing user, you must also specify\n        C(force=yes).\n  tags:\n    description:\n      - User tags specified as comma delimited\n  permissions:\n    description:\n      - a list of dicts, each dict contains vhost, configure_priv, write_priv, and read_priv,\n        and represents a permission rule for that vhost.\n      - This option should be preferable when you care about all permissions of the user.\n      - You should use vhost, configure_priv, write_priv, and read_priv options instead\n        if you care about permissions for just some vhosts.\n    default: []\n  vhost:\n    description:\n      - vhost to apply access privileges.\n      - This option will be ignored when permissions option is used.\n    default: /\n  node:\n    description:\n      - erlang node name of the rabbit we wish to configure\n    default: rabbit\n    version_added: \"1.2\"\n  configure_priv:\n    description:\n      - Regular expression to restrict configure actions on a resource\n        for the specified vhost.\n      - By default all actions are restricted.\n      - This option will be ignored when permissions option is used.\n    default: ^$\n  write_priv:\n    description:\n      - Regular expression to restrict configure actions on a resource\n        for the specified vhost.\n      - By default all actions are restricted.\n      - This option will be ignored when permissions option is used.\n    default: ^$\n  read_priv:\n    description:\n      - Regular expression to restrict configure actions on a resource\n        for the specified vhost.\n      - By default all actions are restricted.\n      - This option will be ignored when permissions option is used.\n    default: ^$\n  force:\n    description:\n      - Deletes and recreates the user.\n    type: bool\n    default: 'no'\n  state:\n    description:\n      - Specify if user is to be added or removed\n    default: present\n    choices: [present, absent]\n'''\n\nEXAMPLES = '''\n\n\n- rabbitmq_user:\n    user: joe\n    password: changeme\n    vhost: /\n    configure_priv: .*\n    read_priv: .*\n    write_priv: .*\n    state: present\n\n\n\n- rabbitmq_user:\n    user: joe\n    password: changeme\n    permissions:\n      - vhost: /\n        configure_priv: .*\n        read_priv: .*\n        write_priv: .*\n    state: present\n'''\n\nfrom ansible.module_utils.basic import AnsibleModule\n\n\nclass RabbitMqUser(object):\n    def __init__(self, module, username, password, tags, permissions,\n                 node, bulk_permissions=False):\n        self.module = module\n        self.username = username\n        self.password = password\n        self.node = node\n        if not tags:\n            self.tags = list()\n        else:\n            self.tags = tags.split(',')\n\n        self.permissions = permissions\n        self.bulk_permissions = bulk_permissions\n\n        self._tags = None\n        self._permissions = []\n        self._rabbitmqctl = module.get_bin_path('rabbitmqctl', True)\n\n    def _exec(self, args, run_in_check_mode=False):\n        if not self.module.check_mode or run_in_check_mode:\n            cmd = [self._rabbitmqctl, '-q']\n            if self.node is not None:\n                cmd.extend(['-n', self.node])\n            rc, out, err = self.module.run_command(cmd + args, check_rc=True)\n            return out.splitlines()\n        return list()\n\n    def get(self):\n        users = self._exec(['list_users'], True)\n\n        for user_tag in users:\n            if '\\t' not in user_tag:\n                continue\n\n            user, tags = user_tag.split('\\t')\n\n            if user == self.username:\n                for c in ['[', ']', ' ']:\n                    tags = tags.replace(c, '')\n\n                if tags != '':\n                    self._tags = tags.split(',')\n                else:\n                    self._tags = list()\n\n                self._permissions = self._get_permissions()\n                return True\n        return False\n\n    def _get_permissions(self):\n        perms_out = self._exec(['list_user_permissions', self.username], True)\n\n        perms_list = list()\n        for perm in perms_out:\n            vhost, configure_priv, write_priv, read_priv = perm.split('\\t')\n            if not self.bulk_permissions:\n                if vhost == self.permissions[0]['vhost']:\n                    perms_list.append(dict(vhost=vhost, configure_priv=configure_priv,\n                                           write_priv=write_priv, read_priv=read_priv))\n                    break\n            else:\n                perms_list.append(dict(vhost=vhost, configure_priv=configure_priv,\n                                       write_priv=write_priv, read_priv=read_priv))\n        return perms_list\n\n    def add(self):\n        if self.password is not None:\n            self._exec(['add_user', self.username, self.password])\n        else:\n            self._exec(['add_user', self.username, ''])\n            self._exec(['clear_password', self.username])\n\n    def delete(self):\n        self._exec(['delete_user', self.username])\n\n    def set_tags(self):\n        self._exec(['set_user_tags', self.username] + self.tags)\n\n    def set_permissions(self):\n        for permission in self._permissions:\n            if permission not in self.permissions:\n                cmd = ['clear_permissions', '-p']\n                cmd.append(permission['vhost'])\n                cmd.append(self.username)\n                self._exec(cmd)\n        for permission in self.permissions:\n            if permission not in self._permissions:\n                cmd = ['set_permissions', '-p']\n                cmd.append(permission['vhost'])\n                cmd.append(self.username)\n                cmd.append(permission['configure_priv'])\n                cmd.append(permission['write_priv'])\n                cmd.append(permission['read_priv'])\n                self._exec(cmd)\n\n    def has_tags_modifications(self):\n        return set(self.tags) != set(self._tags)\n\n    def has_permissions_modifications(self):\n        return sorted(self._permissions) != sorted(self.permissions)\n\n\ndef main():\n    arg_spec = dict(\n        user=dict(required=True, aliases=['username', 'name']),\n        password=dict(default=None, no_log=True),\n        tags=dict(default=None),\n        permissions=dict(default=list(), type='list'),\n        vhost=dict(default='/'),\n        configure_priv=dict(default='^$'),\n        write_priv=dict(default='^$'),\n        read_priv=dict(default='^$'),\n        force=dict(default='no', type='bool'),\n        state=dict(default='present', choices=['present', 'absent']),\n        node=dict(default=None)\n    )\n    module = AnsibleModule(\n        argument_spec=arg_spec,\n        supports_check_mode=True\n    )\n\n    username = module.params['user']\n    password = module.params['password']\n    tags = module.params['tags']\n    permissions = module.params['permissions']\n    vhost = module.params['vhost']\n    configure_priv = module.params['configure_priv']\n    write_priv = module.params['write_priv']\n    read_priv = module.params['read_priv']\n    force = module.params['force']\n    state = module.params['state']\n    node = module.params['node']\n\n    bulk_permissions = True\n    if not permissions:\n        perm = {\n            'vhost': vhost,\n            'configure_priv': configure_priv,\n            'write_priv': write_priv,\n            'read_priv': read_priv\n        }\n        permissions.append(perm)\n        bulk_permissions = False\n\n    rabbitmq_user = RabbitMqUser(module, username, password, tags, permissions,\n                                 node, bulk_permissions=bulk_permissions)\n\n    result = dict(changed=False, user=username, state=state)\n\n    if rabbitmq_user.get():\n        if state == 'absent':\n            rabbitmq_user.delete()\n            result['changed'] = True\n        else:\n            if force:\n                rabbitmq_user.delete()\n                rabbitmq_user.add()\n                rabbitmq_user.get()\n                result['changed'] = True\n\n            if rabbitmq_user.has_tags_modifications():\n                rabbitmq_user.set_tags()\n                result['changed'] = True\n\n            if rabbitmq_user.has_permissions_modifications():\n                rabbitmq_user.set_permissions()\n                result['changed'] = True\n    elif state == 'present':\n        rabbitmq_user.add()\n        rabbitmq_user.set_tags()\n        rabbitmq_user.set_permissions()\n        result['changed'] = True\n\n    module.exit_json(**result)\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  rabbitmq user short description  adds removes users rabbitmq description      add remove users rabbitmq assign permissions version added   1 1  author    chris hoffman ( chrishoffman)   options    user      description          name user add     required  true     aliases   username  name    password      description          password user add          to change password existing user  must also specify         c(force yes)    tags      description          user tags specified comma delimited   permissions      description          list dicts  dict contains vhost  configure priv  write priv  read priv          represents permission rule vhost          this option preferable care permissions user          you use vhost  configure priv  write priv  read priv options instead         care permissions vhosts      default       vhost      description          vhost apply access privileges          this option ignored permissions option used      default      node      description          erlang node name rabbit wish configure     default  rabbit     version added   1 2    configure priv      description          regular expression restrict configure actions resource         specified vhost          by default actions restricted          this option ignored permissions option used      default       write priv      description          regular expression restrict configure actions resource         specified vhost          by default actions restricted          this option ignored permissions option used      default       read priv      description          regular expression restrict configure actions resource         specified vhost          by default actions restricted          this option ignored permissions option used      default       force      description          deletes recreates user      type  bool     default      state      description          specify user added removed     default  present     choices   present  absent       examples         add user server assign full access control   vhost    the user might permission rules vhost care    rabbitmq user      user  joe     password  changeme     vhost        configure priv         read priv         write priv         state  present    add user server assign full access control   vhost    the user permission rules vhosts   rabbitmq user      user  joe     password  changeme     permissions          vhost            configure priv             read priv             write priv         state  present         usr bin python        coding  utf 8        (c) 2013  chatham financial  oss chathamfinancial com     gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    add user server assign full access control   vhost     the user might permission rules vhost care     add user server assign full access control   vhost     the user permission rules vhosts ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# (c) 2013, Chatham Financial <oss@chathamfinancial.com>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: rabbitmq_user\nshort_description: Adds or removes users to RabbitMQ\ndescription:\n  - Add or remove users to RabbitMQ and assign permissions\nversion_added: \"1.1\"\nauthor: '\"Chris Hoffman (@chrishoffman)\"'\noptions:\n  user:\n    description:\n      - Name of user to add\n    required: true\n    aliases: [username, name]\n  password:\n    description:\n      - Password of user to add.\n      - To change the password of an existing user, you must also specify\n        C(force=yes).\n  tags:\n    description:\n      - User tags specified as comma delimited\n  permissions:\n    description:\n      - a list of dicts, each dict contains vhost, configure_priv, write_priv, and read_priv,\n        and represents a permission rule for that vhost.\n      - This option should be preferable when you care about all permissions of the user.\n      - You should use vhost, configure_priv, write_priv, and read_priv options instead\n        if you care about permissions for just some vhosts.\n    default: []\n  vhost:\n    description:\n      - vhost to apply access privileges.\n      - This option will be ignored when permissions option is used.\n    default: /\n  node:\n    description:\n      - erlang node name of the rabbit we wish to configure\n    default: rabbit\n    version_added: \"1.2\"\n  configure_priv:\n    description:\n      - Regular expression to restrict configure actions on a resource\n        for the specified vhost.\n      - By default all actions are restricted.\n      - This option will be ignored when permissions option is used.\n    default: ^$\n  write_priv:\n    description:\n      - Regular expression to restrict configure actions on a resource\n        for the specified vhost.\n      - By default all actions are restricted.\n      - This option will be ignored when permissions option is used.\n    default: ^$\n  read_priv:\n    description:\n      - Regular expression to restrict configure actions on a resource\n        for the specified vhost.\n      - By default all actions are restricted.\n      - This option will be ignored when permissions option is used.\n    default: ^$\n  force:\n    description:\n      - Deletes and recreates the user.\n    type: bool\n    default: 'no'\n  state:\n    description:\n      - Specify if user is to be added or removed\n    default: present\n    choices: [present, absent]\n'''\n\nEXAMPLES = '''\n# Add user to server and assign full access control on / vhost.\n# The user might have permission rules for other vhost but you don't care.\n- rabbitmq_user:\n    user: joe\n    password: changeme\n    vhost: /\n    configure_priv: .*\n    read_priv: .*\n    write_priv: .*\n    state: present\n\n# Add user to server and assign full access control on / vhost.\n# The user doesn't have permission rules for other vhosts\n- rabbitmq_user:\n    user: joe\n    password: changeme\n    permissions:\n      - vhost: /\n        configure_priv: .*\n        read_priv: .*\n        write_priv: .*\n    state: present\n'''\n\nfrom ansible.module_utils.basic import AnsibleModule\n\n\nclass RabbitMqUser(object):\n    def __init__(self, module, username, password, tags, permissions,\n                 node, bulk_permissions=False):\n        self.module = module\n        self.username = username\n        self.password = password\n        self.node = node\n        if not tags:\n            self.tags = list()\n        else:\n            self.tags = tags.split(',')\n\n        self.permissions = permissions\n        self.bulk_permissions = bulk_permissions\n\n        self._tags = None\n        self._permissions = []\n        self._rabbitmqctl = module.get_bin_path('rabbitmqctl', True)\n\n    def _exec(self, args, run_in_check_mode=False):\n        if not self.module.check_mode or run_in_check_mode:\n            cmd = [self._rabbitmqctl, '-q']\n            if self.node is not None:\n                cmd.extend(['-n', self.node])\n            rc, out, err = self.module.run_command(cmd + args, check_rc=True)\n            return out.splitlines()\n        return list()\n\n    def get(self):\n        users = self._exec(['list_users'], True)\n\n        for user_tag in users:\n            if '\\t' not in user_tag:\n                continue\n\n            user, tags = user_tag.split('\\t')\n\n            if user == self.username:\n                for c in ['[', ']', ' ']:\n                    tags = tags.replace(c, '')\n\n                if tags != '':\n                    self._tags = tags.split(',')\n                else:\n                    self._tags = list()\n\n                self._permissions = self._get_permissions()\n                return True\n        return False\n\n    def _get_permissions(self):\n        perms_out = self._exec(['list_user_permissions', self.username], True)\n\n        perms_list = list()\n        for perm in perms_out:\n            vhost, configure_priv, write_priv, read_priv = perm.split('\\t')\n            if not self.bulk_permissions:\n                if vhost == self.permissions[0]['vhost']:\n                    perms_list.append(dict(vhost=vhost, configure_priv=configure_priv,\n                                           write_priv=write_priv, read_priv=read_priv))\n                    break\n            else:\n                perms_list.append(dict(vhost=vhost, configure_priv=configure_priv,\n                                       write_priv=write_priv, read_priv=read_priv))\n        return perms_list\n\n    def add(self):\n        if self.password is not None:\n            self._exec(['add_user', self.username, self.password])\n        else:\n            self._exec(['add_user', self.username, ''])\n            self._exec(['clear_password', self.username])\n\n    def delete(self):\n        self._exec(['delete_user', self.username])\n\n    def set_tags(self):\n        self._exec(['set_user_tags', self.username] + self.tags)\n\n    def set_permissions(self):\n        for permission in self._permissions:\n            if permission not in self.permissions:\n                cmd = ['clear_permissions', '-p']\n                cmd.append(permission['vhost'])\n                cmd.append(self.username)\n                self._exec(cmd)\n        for permission in self.permissions:\n            if permission not in self._permissions:\n                cmd = ['set_permissions', '-p']\n                cmd.append(permission['vhost'])\n                cmd.append(self.username)\n                cmd.append(permission['configure_priv'])\n                cmd.append(permission['write_priv'])\n                cmd.append(permission['read_priv'])\n                self._exec(cmd)\n\n    def has_tags_modifications(self):\n        return set(self.tags) != set(self._tags)\n\n    def has_permissions_modifications(self):\n        return sorted(self._permissions) != sorted(self.permissions)\n\n\ndef main():\n    arg_spec = dict(\n        user=dict(required=True, aliases=['username', 'name']),\n        password=dict(default=None, no_log=True),\n        tags=dict(default=None),\n        permissions=dict(default=list(), type='list'),\n        vhost=dict(default='/'),\n        configure_priv=dict(default='^$'),\n        write_priv=dict(default='^$'),\n        read_priv=dict(default='^$'),\n        force=dict(default='no', type='bool'),\n        state=dict(default='present', choices=['present', 'absent']),\n        node=dict(default=None)\n    )\n    module = AnsibleModule(\n        argument_spec=arg_spec,\n        supports_check_mode=True\n    )\n\n    username = module.params['user']\n    password = module.params['password']\n    tags = module.params['tags']\n    permissions = module.params['permissions']\n    vhost = module.params['vhost']\n    configure_priv = module.params['configure_priv']\n    write_priv = module.params['write_priv']\n    read_priv = module.params['read_priv']\n    force = module.params['force']\n    state = module.params['state']\n    node = module.params['node']\n\n    bulk_permissions = True\n    if not permissions:\n        perm = {\n            'vhost': vhost,\n            'configure_priv': configure_priv,\n            'write_priv': write_priv,\n            'read_priv': read_priv\n        }\n        permissions.append(perm)\n        bulk_permissions = False\n\n    rabbitmq_user = RabbitMqUser(module, username, password, tags, permissions,\n                                 node, bulk_permissions=bulk_permissions)\n\n    result = dict(changed=False, user=username, state=state)\n\n    if rabbitmq_user.get():\n        if state == 'absent':\n            rabbitmq_user.delete()\n            result['changed'] = True\n        else:\n            if force:\n                rabbitmq_user.delete()\n                rabbitmq_user.add()\n                rabbitmq_user.get()\n                result['changed'] = True\n\n            if rabbitmq_user.has_tags_modifications():\n                rabbitmq_user.set_tags()\n                result['changed'] = True\n\n            if rabbitmq_user.has_permissions_modifications():\n                rabbitmq_user.set_permissions()\n                result['changed'] = True\n    elif state == 'present':\n        rabbitmq_user.add()\n        rabbitmq_user.set_tags()\n        rabbitmq_user.set_permissions()\n        result['changed'] = True\n\n    module.exit_json(**result)\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "rabbitmq_user.py", "id": "02078a398123986e767ea367b583bc70", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/messaging/rabbitmq_user.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}