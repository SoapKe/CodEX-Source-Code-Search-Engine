{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_parse_qs,\n    compat_str,\n    compat_urllib_parse_urlparse,\n)\nfrom ..utils import (\n    determine_ext,\n    int_or_none,\n    try_get,\n    qualities,\n)\n\n\nclass SixPlayIE(InfoExtractor):\n    IE_NAME = '6play'\n    _VALID_URL = r'(?:6play:|https?://(?:www\\.)?6play\\.fr/.+?-c_)(?P<id>[0-9]+)'\n    _TEST = {\n        'url': 'http://www.6play.fr/le-meilleur-patissier-p_1807/le-meilleur-patissier-special-fetes-mercredi-a-21-00-sur-m6-c_11638450',\n        'md5': '42310bffe4ba3982db112b9cd3467328',\n        'info_dict': {\n            'id': '11638450',\n            'ext': 'mp4',\n            'title': 'Le Meilleur P\u00e2tissier, sp\u00e9cial f\u00eates mercredi \u00e0 21:00 sur M6',\n            'description': 'md5:308853f6a5f9e2d55a30fc0654de415f',\n            'duration': 39,\n            'series': 'Le meilleur p\u00e2tissier',\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        data = self._download_json(\n            'https://pc.middleware.6play.fr/6play/v2/platforms/m6group_web/services/6play/videos/clip_%s' % video_id,\n            video_id, query={\n                'csa': 5,\n                'with': 'clips',\n            })\n\n        clip_data = data['clips'][0]\n        title = clip_data['title']\n\n        urls = []\n        quality_key = qualities(['lq', 'sd', 'hq', 'hd'])\n        formats = []\n        subtitles = {}\n        for asset in clip_data['assets']:\n            asset_url = asset.get('full_physical_path')\n            protocol = asset.get('protocol')\n            if not asset_url or protocol == 'primetime' or asset_url in urls:\n                continue\n            urls.append(asset_url)\n            container = asset.get('video_container')\n            ext = determine_ext(asset_url)\n            if protocol == 'http_subtitle' or ext == 'vtt':\n                subtitles.setdefault('fr', []).append({'url': asset_url})\n                continue\n            if container == 'm3u8' or ext == 'm3u8':\n                if protocol == 'usp' and not compat_parse_qs(compat_urllib_parse_urlparse(asset_url).query).get('token', [None])[0]:\n                    asset_url = re.sub(r'/([^/]+)\\.ism/[^/]*\\.m3u8', r'/\\1.ism/\\1.m3u8', asset_url)\n                    formats.extend(self._extract_m3u8_formats(\n                        asset_url, video_id, 'mp4', 'm3u8_native',\n                        m3u8_id='hls', fatal=False))\n                    formats.extend(self._extract_f4m_formats(\n                        asset_url.replace('.m3u8', '.f4m'),\n                        video_id, f4m_id='hds', fatal=False))\n                    formats.extend(self._extract_mpd_formats(\n                        asset_url.replace('.m3u8', '.mpd'),\n                        video_id, mpd_id='dash', fatal=False))\n                    formats.extend(self._extract_ism_formats(\n                        re.sub(r'/[^/]+\\.m3u8', '/Manifest', asset_url),\n                        video_id, ism_id='mss', fatal=False))\n                else:\n                    formats.extend(self._extract_m3u8_formats(\n                        asset_url, video_id, 'mp4', 'm3u8_native',\n                        m3u8_id='hls', fatal=False))\n            elif container == 'mp4' or ext == 'mp4':\n                quality = asset.get('video_quality')\n                formats.append({\n                    'url': asset_url,\n                    'format_id': quality,\n                    'quality': quality_key(quality),\n                    'ext': ext,\n                })\n        self._sort_formats(formats)\n\n        def get(getter):\n            for src in (data, clip_data):\n                v = try_get(src, getter, compat_str)\n                if v:\n                    return v\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': get(lambda x: x['description']),\n            'duration': int_or_none(clip_data.get('duration')),\n            'series': get(lambda x: x['program']['title']),\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n", "comments": "# coding: utf-8\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_parse_qs,\n    compat_str,\n    compat_urllib_parse_urlparse,\n)\nfrom ..utils import (\n    determine_ext,\n    int_or_none,\n    try_get,\n    qualities,\n)\n\n\nclass SixPlayIE(InfoExtractor):\n    IE_NAME = '6play'\n    _VALID_URL = r'(?:6play:|https?://(?:www\\.)?6play\\.fr/.+?-c_)(?P<id>[0-9]+)'\n    _TEST = {\n        'url': 'http://www.6play.fr/le-meilleur-patissier-p_1807/le-meilleur-patissier-special-fetes-mercredi-a-21-00-sur-m6-c_11638450',\n        'md5': '42310bffe4ba3982db112b9cd3467328',\n        'info_dict': {\n            'id': '11638450',\n            'ext': 'mp4',\n            'title': 'Le Meilleur P\u00e2tissier, sp\u00e9cial f\u00eates mercredi \u00e0 21:00 sur M6',\n            'description': 'md5:308853f6a5f9e2d55a30fc0654de415f',\n            'duration': 39,\n            'series': 'Le meilleur p\u00e2tissier',\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        data = self._download_json(\n            'https://pc.middleware.6play.fr/6play/v2/platforms/m6group_web/services/6play/videos/clip_%s' % video_id,\n            video_id, query={\n                'csa': 5,\n                'with': 'clips',\n            })\n\n        clip_data = data['clips'][0]\n        title = clip_data['title']\n\n        urls = []\n        quality_key = qualities(['lq', 'sd', 'hq', 'hd'])\n        formats = []\n        subtitles = {}\n        for asset in clip_data['assets']:\n            asset_url = asset.get('full_physical_path')\n            protocol = asset.get('protocol')\n            if not asset_url or protocol == 'primetime' or asset_url in urls:\n                continue\n            urls.append(asset_url)\n            container = asset.get('video_container')\n            ext = determine_ext(asset_url)\n            if protocol == 'http_subtitle' or ext == 'vtt':\n                subtitles.setdefault('fr', []).append({'url': asset_url})\n                continue\n            if container == 'm3u8' or ext == 'm3u8':\n                if protocol == 'usp' and not compat_parse_qs(compat_urllib_parse_urlparse(asset_url).query).get('token', [None])[0]:\n                    asset_url = re.sub(r'/([^/]+)\\.ism/[^/]*\\.m3u8', r'/\\1.ism/\\1.m3u8', asset_url)\n                    formats.extend(self._extract_m3u8_formats(\n                        asset_url, video_id, 'mp4', 'm3u8_native',\n                        m3u8_id='hls', fatal=False))\n                    formats.extend(self._extract_f4m_formats(\n                        asset_url.replace('.m3u8', '.f4m'),\n                        video_id, f4m_id='hds', fatal=False))\n                    formats.extend(self._extract_mpd_formats(\n                        asset_url.replace('.m3u8', '.mpd'),\n                        video_id, mpd_id='dash', fatal=False))\n                    formats.extend(self._extract_ism_formats(\n                        re.sub(r'/[^/]+\\.m3u8', '/Manifest', asset_url),\n                        video_id, ism_id='mss', fatal=False))\n                else:\n                    formats.extend(self._extract_m3u8_formats(\n                        asset_url, video_id, 'mp4', 'm3u8_native',\n                        m3u8_id='hls', fatal=False))\n            elif container == 'mp4' or ext == 'mp4':\n                quality = asset.get('video_quality')\n                formats.append({\n                    'url': asset_url,\n                    'format_id': quality,\n                    'quality': quality_key(quality),\n                    'ext': ext,\n                })\n        self._sort_formats(formats)\n\n        def get(getter):\n            for src in (data, clip_data):\n                v = try_get(src, getter, compat_str)\n                if v:\n                    return v\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': get(lambda x: x['description']),\n            'duration': int_or_none(clip_data.get('duration')),\n            'series': get(lambda x: x['program']['title']),\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "sixplay.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/sixplay.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}