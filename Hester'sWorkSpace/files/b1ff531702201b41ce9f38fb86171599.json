{"author": "apache", "code": "# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nfrom datetime import date, datetime, time, timedelta\nfrom decimal import Decimal\nimport unittest\nimport uuid\n\nfrom mock import patch\nimport numpy\n\nfrom superset.exceptions import SupersetException\nfrom superset.utils import (\n    base_json_conv, datetime_f, json_int_dttm_ser, json_iso_dttm_ser,\n    JSONEncodedDict, memoized, merge_extra_filters, merge_request_params,\n    parse_human_timedelta, validate_json, zlib_compress, zlib_decompress_to_string,\n)\n\n\nclass UtilsTestCase(unittest.TestCase):\n    def test_json_int_dttm_ser(self):\n        dttm = datetime(2020, 1, 1)\n        ts = 1577836800000.0\n        assert json_int_dttm_ser(dttm) == ts\n        assert json_int_dttm_ser(date(2020, 1, 1)) == ts\n        assert json_int_dttm_ser(datetime(1970, 1, 1)) == 0\n        assert json_int_dttm_ser(date(1970, 1, 1)) == 0\n        assert json_int_dttm_ser(dttm + timedelta(milliseconds=1)) == (ts + 1)\n\n        with self.assertRaises(TypeError):\n            json_int_dttm_ser('this is not a date')\n\n    def test_json_iso_dttm_ser(self):\n        dttm = datetime(2020, 1, 1)\n        dt = date(2020, 1, 1)\n        t = time()\n        assert json_iso_dttm_ser(dttm) == dttm.isoformat()\n        assert json_iso_dttm_ser(dt) == dt.isoformat()\n        assert json_iso_dttm_ser(t) == t.isoformat()\n\n        with self.assertRaises(TypeError):\n            json_iso_dttm_ser('this is not a date')\n\n    def test_base_json_conv(self):\n        assert isinstance(base_json_conv(numpy.bool_(1)), bool) is True\n        assert isinstance(base_json_conv(numpy.int64(1)), int) is True\n        assert isinstance(base_json_conv(set([1])), list) is True\n        assert isinstance(base_json_conv(Decimal('1.0')), float) is True\n        assert isinstance(base_json_conv(uuid.uuid4()), str) is True\n\n    @patch('superset.utils.datetime')\n    def test_parse_human_timedelta(self, mock_now):\n        mock_now.return_value = datetime(2016, 12, 1)\n        self.assertEquals(parse_human_timedelta('now'), timedelta(0))\n\n    def test_zlib_compression(self):\n        json_str = '{\"test\": 1}'\n        blob = zlib_compress(json_str)\n        got_str = zlib_decompress_to_string(blob)\n        self.assertEquals(json_str, got_str)\n\n    def test_merge_extra_filters(self):\n        \n        form_data = {'A': 1, 'B': 2, 'c': 'test'}\n        expected = {'A': 1, 'B': 2, 'c': 'test'}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n        \n        form_data = {'A': 1, 'B': 2, 'c': 'test', 'extra_filters': []}\n        expected = {'A': 1, 'B': 2, 'c': 'test', 'filters': []}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n        \n        form_data = {'extra_filters': [\n            {'col': 'a', 'op': 'in', 'val': 'someval'},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n        ]}\n        expected = {'filters': [\n            {'col': 'a', 'op': 'in', 'val': 'someval'},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n        ]}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n        \n        form_data = {'extra_filters': [\n            {'col': 'a', 'op': 'in', 'val': 'someval'},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n        ], 'filters': [{'col': 'D', 'op': '!=', 'val': ['G1', 'g2']}]}\n        expected = {'filters': [\n            {'col': 'D', 'op': '!=', 'val': ['G1', 'g2']},\n            {'col': 'a', 'op': 'in', 'val': 'someval'},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n        ]}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n         and sets time options\n        form_data = {'extra_filters': [\n            {'col': '__from', 'op': 'in', 'val': '1 year ago'},\n            {'col': '__to', 'op': 'in', 'val': None},\n            {'col': '__time_col', 'op': 'in', 'val': 'birth_year'},\n            {'col': '__time_grain', 'op': 'in', 'val': 'years'},\n            {'col': 'A', 'op': 'like', 'val': 'hello'},\n            {'col': '__time_origin', 'op': 'in', 'val': 'now'},\n            {'col': '__granularity', 'op': 'in', 'val': '90 seconds'},\n        ]}\n        expected = {\n            'filters': [{'col': 'A', 'op': 'like', 'val': 'hello'}],\n            'since': '1 year ago',\n            'granularity_sqla': 'birth_year',\n            'time_grain_sqla': 'years',\n            'granularity': '90 seconds',\n            'druid_time_origin': 'now',\n        }\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n\n    def test_merge_extra_filters_ignores_empty_filters(self):\n        form_data = {'extra_filters': [\n            {'col': 'a', 'op': 'in', 'val': ''},\n            {'col': 'B', 'op': '==', 'val': []},\n        ]}\n        expected = {'filters': []}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n\n    def test_merge_extra_filters_ignores_nones(self):\n        form_data = {\n            'filters': [\n                {'col': None, 'op': 'in', 'val': ''},\n            ],\n            'extra_filters': [\n                {'col': 'B', 'op': '==', 'val': []},\n            ],\n        }\n        expected = {\n            'filters': [\n                {'col': None, 'op': 'in', 'val': ''},\n            ],\n        }\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n\n    def test_merge_extra_filters_ignores_equal_filters(self):\n        form_data = {\n            'extra_filters': [\n                {'col': 'a', 'op': 'in', 'val': 'someval'},\n                {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            ],\n            'filters': [\n                {'col': 'a', 'op': 'in', 'val': 'someval'},\n                {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            ],\n        }\n        expected = {'filters': [\n            {'col': 'a', 'op': 'in', 'val': 'someval'},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n        ]}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n\n    def test_merge_extra_filters_merges_different_val_types(self):\n        form_data = {\n            'extra_filters': [\n                {'col': 'a', 'op': 'in', 'val': ['g1', 'g2']},\n                {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            ],\n            'filters': [\n                {'col': 'a', 'op': 'in', 'val': 'someval'},\n                {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            ],\n        }\n        expected = {'filters': [\n            {'col': 'a', 'op': 'in', 'val': 'someval'},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            {'col': 'a', 'op': 'in', 'val': ['g1', 'g2']},\n        ]}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n        form_data = {\n            'extra_filters': [\n                {'col': 'a', 'op': 'in', 'val': 'someval'},\n                {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            ],\n            'filters': [\n                {'col': 'a', 'op': 'in', 'val': ['g1', 'g2']},\n                {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            ],\n        }\n        expected = {'filters': [\n            {'col': 'a', 'op': 'in', 'val': ['g1', 'g2']},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            {'col': 'a', 'op': 'in', 'val': 'someval'},\n        ]}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n\n    def test_merge_extra_filters_adds_unequal_lists(self):\n        form_data = {\n            'extra_filters': [\n                {'col': 'a', 'op': 'in', 'val': ['g1', 'g2', 'g3']},\n                {'col': 'B', 'op': '==', 'val': ['c1', 'c2', 'c3']},\n            ],\n            'filters': [\n                {'col': 'a', 'op': 'in', 'val': ['g1', 'g2']},\n                {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            ],\n        }\n        expected = {'filters': [\n            {'col': 'a', 'op': 'in', 'val': ['g1', 'g2']},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            {'col': 'a', 'op': 'in', 'val': ['g1', 'g2', 'g3']},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2', 'c3']},\n        ]}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n\n    def test_merge_request_params(self):\n        form_data = {\n            'since': '2000',\n            'until': 'now',\n        }\n        url_params = {\n            'form_data': form_data,\n            'dashboard_ids': '(1,2,3,4,5)',\n        }\n        merge_request_params(form_data, url_params)\n        self.assertIn('url_params', form_data.keys())\n        self.assertIn('dashboard_ids', form_data['url_params'])\n        self.assertNotIn('form_data', form_data.keys())\n\n    def test_datetime_f(self):\n        self.assertEquals(\n            datetime_f(datetime(1990, 9, 21, 19, 11, 19, 626096)),\n            '<nobr>1990-09-21T19:11:19.626096</nobr>',\n        )\n        self.assertEquals(len(datetime_f(datetime.now())), 28)\n        self.assertEquals(datetime_f(None), '<nobr>None</nobr>')\n        iso = datetime.now().isoformat()[:10].split('-')\n        [a, b, c] = [int(v) for v in iso]\n        self.assertEquals(\n            datetime_f(datetime(a, b, c)), '<nobr>00:00:00</nobr>',\n        )\n\n    def test_json_encoded_obj(self):\n        obj = {'a': 5, 'b': ['a', 'g', 5]}\n        val = '{\"a\": 5, \"b\": [\"a\", \"g\", 5]}'\n        jsonObj = JSONEncodedDict()\n        resp = jsonObj.process_bind_param(obj, 'dialect')\n        self.assertIn('\"a\": 5', resp)\n        self.assertIn('\"b\": [\"a\", \"g\", 5]', resp)\n        self.assertEquals(jsonObj.process_result_value(val, 'dialect'), obj)\n\n    def test_validate_json(self):\n        invalid = '{\"a\": 5, \"b\": [1, 5, [\"g\", \"h]]}'\n        with self.assertRaises(SupersetException):\n            validate_json(invalid)\n\n    def test_memoized_on_functions(self):\n        watcher = {'val': 0}\n\n        @memoized\n        def test_function(a, b, c):\n            watcher['val'] += 1\n            return a * b * c\n        result1 = test_function(1, 2, 3)\n        result2 = test_function(1, 2, 3)\n        self.assertEquals(result1, result2)\n        self.assertEquals(watcher['val'], 1)\n\n    def test_memoized_on_methods(self):\n\n        class test_class:\n            def __init__(self, num):\n                self.num = num\n                self.watcher = 0\n\n            @memoized\n            def test_method(self, a, b, c):\n                self.watcher += 1\n                return a * b * c * self.num\n\n        instance = test_class(5)\n        result1 = instance.test_method(1, 2, 3)\n        result2 = instance.test_method(1, 2, 3)\n        self.assertEquals(result1, result2)\n        self.assertEquals(instance.watcher, 1)\n        instance.num = 10\n        self.assertEquals(result2, instance.test_method(1, 2, 3))\n\n    def test_memoized_on_methods_with_watches(self):\n\n        class test_class:\n            def __init__(self, x, y):\n                self.x = x\n                self.y = y\n                self.watcher = 0\n\n            @memoized(watch=('x', 'y'))\n            def test_method(self, a, b, c):\n                self.watcher += 1\n                return a * b * c * self.x * self.y\n\n        instance = test_class(3, 12)\n        result1 = instance.test_method(1, 2, 3)\n        result2 = instance.test_method(1, 2, 3)\n        self.assertEquals(result1, result2)\n        self.assertEquals(instance.watcher, 1)\n        result3 = instance.test_method(2, 3, 4)\n        self.assertEquals(instance.watcher, 2)\n        result4 = instance.test_method(2, 3, 4)\n        self.assertEquals(instance.watcher, 2)\n        self.assertEquals(result3, result4)\n        self.assertNotEqual(result3, result1)\n        instance.x = 1\n        result5 = instance.test_method(2, 3, 4)\n        self.assertEqual(instance.watcher, 3)\n        self.assertNotEqual(result5, result4)\n        result6 = instance.test_method(2, 3, 4)\n        self.assertEqual(instance.watcher, 3)\n        self.assertEqual(result6, result5)\n        instance.x = 10\n        instance.y = 10\n        result7 = instance.test_method(2, 3, 4)\n        self.assertEqual(instance.watcher, 4)\n        self.assertNotEqual(result7, result6)\n        instance.x = 3\n        instance.y = 12\n        result8 = instance.test_method(1, 2, 3)\n        self.assertEqual(instance.watcher, 4)\n        self.assertEqual(result1, result8)\n", "comments": "      coding  utf 8        nothing extra filters    empty extra filters    copy extra filters empty filters    adds extra filters existing filters    adds extra filters existing filters sets time options ", "content": "# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nfrom datetime import date, datetime, time, timedelta\nfrom decimal import Decimal\nimport unittest\nimport uuid\n\nfrom mock import patch\nimport numpy\n\nfrom superset.exceptions import SupersetException\nfrom superset.utils import (\n    base_json_conv, datetime_f, json_int_dttm_ser, json_iso_dttm_ser,\n    JSONEncodedDict, memoized, merge_extra_filters, merge_request_params,\n    parse_human_timedelta, validate_json, zlib_compress, zlib_decompress_to_string,\n)\n\n\nclass UtilsTestCase(unittest.TestCase):\n    def test_json_int_dttm_ser(self):\n        dttm = datetime(2020, 1, 1)\n        ts = 1577836800000.0\n        assert json_int_dttm_ser(dttm) == ts\n        assert json_int_dttm_ser(date(2020, 1, 1)) == ts\n        assert json_int_dttm_ser(datetime(1970, 1, 1)) == 0\n        assert json_int_dttm_ser(date(1970, 1, 1)) == 0\n        assert json_int_dttm_ser(dttm + timedelta(milliseconds=1)) == (ts + 1)\n\n        with self.assertRaises(TypeError):\n            json_int_dttm_ser('this is not a date')\n\n    def test_json_iso_dttm_ser(self):\n        dttm = datetime(2020, 1, 1)\n        dt = date(2020, 1, 1)\n        t = time()\n        assert json_iso_dttm_ser(dttm) == dttm.isoformat()\n        assert json_iso_dttm_ser(dt) == dt.isoformat()\n        assert json_iso_dttm_ser(t) == t.isoformat()\n\n        with self.assertRaises(TypeError):\n            json_iso_dttm_ser('this is not a date')\n\n    def test_base_json_conv(self):\n        assert isinstance(base_json_conv(numpy.bool_(1)), bool) is True\n        assert isinstance(base_json_conv(numpy.int64(1)), int) is True\n        assert isinstance(base_json_conv(set([1])), list) is True\n        assert isinstance(base_json_conv(Decimal('1.0')), float) is True\n        assert isinstance(base_json_conv(uuid.uuid4()), str) is True\n\n    @patch('superset.utils.datetime')\n    def test_parse_human_timedelta(self, mock_now):\n        mock_now.return_value = datetime(2016, 12, 1)\n        self.assertEquals(parse_human_timedelta('now'), timedelta(0))\n\n    def test_zlib_compression(self):\n        json_str = '{\"test\": 1}'\n        blob = zlib_compress(json_str)\n        got_str = zlib_decompress_to_string(blob)\n        self.assertEquals(json_str, got_str)\n\n    def test_merge_extra_filters(self):\n        # does nothing if no extra filters\n        form_data = {'A': 1, 'B': 2, 'c': 'test'}\n        expected = {'A': 1, 'B': 2, 'c': 'test'}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n        # empty extra_filters\n        form_data = {'A': 1, 'B': 2, 'c': 'test', 'extra_filters': []}\n        expected = {'A': 1, 'B': 2, 'c': 'test', 'filters': []}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n        # copy over extra filters into empty filters\n        form_data = {'extra_filters': [\n            {'col': 'a', 'op': 'in', 'val': 'someval'},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n        ]}\n        expected = {'filters': [\n            {'col': 'a', 'op': 'in', 'val': 'someval'},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n        ]}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n        # adds extra filters to existing filters\n        form_data = {'extra_filters': [\n            {'col': 'a', 'op': 'in', 'val': 'someval'},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n        ], 'filters': [{'col': 'D', 'op': '!=', 'val': ['G1', 'g2']}]}\n        expected = {'filters': [\n            {'col': 'D', 'op': '!=', 'val': ['G1', 'g2']},\n            {'col': 'a', 'op': 'in', 'val': 'someval'},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n        ]}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n        # adds extra filters to existing filters and sets time options\n        form_data = {'extra_filters': [\n            {'col': '__from', 'op': 'in', 'val': '1 year ago'},\n            {'col': '__to', 'op': 'in', 'val': None},\n            {'col': '__time_col', 'op': 'in', 'val': 'birth_year'},\n            {'col': '__time_grain', 'op': 'in', 'val': 'years'},\n            {'col': 'A', 'op': 'like', 'val': 'hello'},\n            {'col': '__time_origin', 'op': 'in', 'val': 'now'},\n            {'col': '__granularity', 'op': 'in', 'val': '90 seconds'},\n        ]}\n        expected = {\n            'filters': [{'col': 'A', 'op': 'like', 'val': 'hello'}],\n            'since': '1 year ago',\n            'granularity_sqla': 'birth_year',\n            'time_grain_sqla': 'years',\n            'granularity': '90 seconds',\n            'druid_time_origin': 'now',\n        }\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n\n    def test_merge_extra_filters_ignores_empty_filters(self):\n        form_data = {'extra_filters': [\n            {'col': 'a', 'op': 'in', 'val': ''},\n            {'col': 'B', 'op': '==', 'val': []},\n        ]}\n        expected = {'filters': []}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n\n    def test_merge_extra_filters_ignores_nones(self):\n        form_data = {\n            'filters': [\n                {'col': None, 'op': 'in', 'val': ''},\n            ],\n            'extra_filters': [\n                {'col': 'B', 'op': '==', 'val': []},\n            ],\n        }\n        expected = {\n            'filters': [\n                {'col': None, 'op': 'in', 'val': ''},\n            ],\n        }\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n\n    def test_merge_extra_filters_ignores_equal_filters(self):\n        form_data = {\n            'extra_filters': [\n                {'col': 'a', 'op': 'in', 'val': 'someval'},\n                {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            ],\n            'filters': [\n                {'col': 'a', 'op': 'in', 'val': 'someval'},\n                {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            ],\n        }\n        expected = {'filters': [\n            {'col': 'a', 'op': 'in', 'val': 'someval'},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n        ]}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n\n    def test_merge_extra_filters_merges_different_val_types(self):\n        form_data = {\n            'extra_filters': [\n                {'col': 'a', 'op': 'in', 'val': ['g1', 'g2']},\n                {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            ],\n            'filters': [\n                {'col': 'a', 'op': 'in', 'val': 'someval'},\n                {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            ],\n        }\n        expected = {'filters': [\n            {'col': 'a', 'op': 'in', 'val': 'someval'},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            {'col': 'a', 'op': 'in', 'val': ['g1', 'g2']},\n        ]}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n        form_data = {\n            'extra_filters': [\n                {'col': 'a', 'op': 'in', 'val': 'someval'},\n                {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            ],\n            'filters': [\n                {'col': 'a', 'op': 'in', 'val': ['g1', 'g2']},\n                {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            ],\n        }\n        expected = {'filters': [\n            {'col': 'a', 'op': 'in', 'val': ['g1', 'g2']},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            {'col': 'a', 'op': 'in', 'val': 'someval'},\n        ]}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n\n    def test_merge_extra_filters_adds_unequal_lists(self):\n        form_data = {\n            'extra_filters': [\n                {'col': 'a', 'op': 'in', 'val': ['g1', 'g2', 'g3']},\n                {'col': 'B', 'op': '==', 'val': ['c1', 'c2', 'c3']},\n            ],\n            'filters': [\n                {'col': 'a', 'op': 'in', 'val': ['g1', 'g2']},\n                {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            ],\n        }\n        expected = {'filters': [\n            {'col': 'a', 'op': 'in', 'val': ['g1', 'g2']},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2']},\n            {'col': 'a', 'op': 'in', 'val': ['g1', 'g2', 'g3']},\n            {'col': 'B', 'op': '==', 'val': ['c1', 'c2', 'c3']},\n        ]}\n        merge_extra_filters(form_data)\n        self.assertEquals(form_data, expected)\n\n    def test_merge_request_params(self):\n        form_data = {\n            'since': '2000',\n            'until': 'now',\n        }\n        url_params = {\n            'form_data': form_data,\n            'dashboard_ids': '(1,2,3,4,5)',\n        }\n        merge_request_params(form_data, url_params)\n        self.assertIn('url_params', form_data.keys())\n        self.assertIn('dashboard_ids', form_data['url_params'])\n        self.assertNotIn('form_data', form_data.keys())\n\n    def test_datetime_f(self):\n        self.assertEquals(\n            datetime_f(datetime(1990, 9, 21, 19, 11, 19, 626096)),\n            '<nobr>1990-09-21T19:11:19.626096</nobr>',\n        )\n        self.assertEquals(len(datetime_f(datetime.now())), 28)\n        self.assertEquals(datetime_f(None), '<nobr>None</nobr>')\n        iso = datetime.now().isoformat()[:10].split('-')\n        [a, b, c] = [int(v) for v in iso]\n        self.assertEquals(\n            datetime_f(datetime(a, b, c)), '<nobr>00:00:00</nobr>',\n        )\n\n    def test_json_encoded_obj(self):\n        obj = {'a': 5, 'b': ['a', 'g', 5]}\n        val = '{\"a\": 5, \"b\": [\"a\", \"g\", 5]}'\n        jsonObj = JSONEncodedDict()\n        resp = jsonObj.process_bind_param(obj, 'dialect')\n        self.assertIn('\"a\": 5', resp)\n        self.assertIn('\"b\": [\"a\", \"g\", 5]', resp)\n        self.assertEquals(jsonObj.process_result_value(val, 'dialect'), obj)\n\n    def test_validate_json(self):\n        invalid = '{\"a\": 5, \"b\": [1, 5, [\"g\", \"h]]}'\n        with self.assertRaises(SupersetException):\n            validate_json(invalid)\n\n    def test_memoized_on_functions(self):\n        watcher = {'val': 0}\n\n        @memoized\n        def test_function(a, b, c):\n            watcher['val'] += 1\n            return a * b * c\n        result1 = test_function(1, 2, 3)\n        result2 = test_function(1, 2, 3)\n        self.assertEquals(result1, result2)\n        self.assertEquals(watcher['val'], 1)\n\n    def test_memoized_on_methods(self):\n\n        class test_class:\n            def __init__(self, num):\n                self.num = num\n                self.watcher = 0\n\n            @memoized\n            def test_method(self, a, b, c):\n                self.watcher += 1\n                return a * b * c * self.num\n\n        instance = test_class(5)\n        result1 = instance.test_method(1, 2, 3)\n        result2 = instance.test_method(1, 2, 3)\n        self.assertEquals(result1, result2)\n        self.assertEquals(instance.watcher, 1)\n        instance.num = 10\n        self.assertEquals(result2, instance.test_method(1, 2, 3))\n\n    def test_memoized_on_methods_with_watches(self):\n\n        class test_class:\n            def __init__(self, x, y):\n                self.x = x\n                self.y = y\n                self.watcher = 0\n\n            @memoized(watch=('x', 'y'))\n            def test_method(self, a, b, c):\n                self.watcher += 1\n                return a * b * c * self.x * self.y\n\n        instance = test_class(3, 12)\n        result1 = instance.test_method(1, 2, 3)\n        result2 = instance.test_method(1, 2, 3)\n        self.assertEquals(result1, result2)\n        self.assertEquals(instance.watcher, 1)\n        result3 = instance.test_method(2, 3, 4)\n        self.assertEquals(instance.watcher, 2)\n        result4 = instance.test_method(2, 3, 4)\n        self.assertEquals(instance.watcher, 2)\n        self.assertEquals(result3, result4)\n        self.assertNotEqual(result3, result1)\n        instance.x = 1\n        result5 = instance.test_method(2, 3, 4)\n        self.assertEqual(instance.watcher, 3)\n        self.assertNotEqual(result5, result4)\n        result6 = instance.test_method(2, 3, 4)\n        self.assertEqual(instance.watcher, 3)\n        self.assertEqual(result6, result5)\n        instance.x = 10\n        instance.y = 10\n        result7 = instance.test_method(2, 3, 4)\n        self.assertEqual(instance.watcher, 4)\n        self.assertNotEqual(result7, result6)\n        instance.x = 3\n        instance.y = 12\n        result8 = instance.test_method(1, 2, 3)\n        self.assertEqual(instance.watcher, 4)\n        self.assertEqual(result1, result8)\n", "description": "Apache Superset (incubating) is a modern, enterprise-ready business intelligence web application", "file_name": "utils_tests.py", "id": "b1ff531702201b41ce9f38fb86171599", "language": "Python", "project_name": "incubator-superset", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/apache-incubator-superset/apache-incubator-superset-95a9b04/tests/utils_tests.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:41:03Z", "url": "https://github.com/apache/incubator-superset", "wiki": false}