{"author": "rg3", "code": "\n\n\nfrom __future__ import unicode_literals\n\n\n\n\n\n\n\nimport collections\nimport socket\n\nfrom .compat import (\n    compat_ord,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\n\n__author__ = 'Timo Schmid <coding@timoschmid.de>'\n\nSOCKS4_VERSION = 4\nSOCKS4_REPLY_VERSION = 0x00\n\n\n\n\nSOCKS4_DEFAULT_DSTIP = compat_struct_pack('!BBBB', 0, 0, 0, 0xFF)\n\nSOCKS5_VERSION = 5\nSOCKS5_USER_AUTH_VERSION = 0x01\nSOCKS5_USER_AUTH_SUCCESS = 0x00\n\n\nclass Socks4Command(object):\n    CMD_CONNECT = 0x01\n    CMD_BIND = 0x02\n\n\nclass Socks5Command(Socks4Command):\n    CMD_UDP_ASSOCIATE = 0x03\n\n\nclass Socks5Auth(object):\n    AUTH_NONE = 0x00\n    AUTH_GSSAPI = 0x01\n    AUTH_USER_PASS = 0x02\n    AUTH_NO_ACCEPTABLE = 0xFF  \n\n\nclass Socks5AddressType(object):\n    ATYP_IPV4 = 0x01\n    ATYP_DOMAINNAME = 0x03\n    ATYP_IPV6 = 0x04\n\n\nclass ProxyError(socket.error):\n    ERR_SUCCESS = 0x00\n\n    def __init__(self, code=None, msg=None):\n        if code is not None and msg is None:\n            msg = self.CODES.get(code) or 'unknown error'\n        super(ProxyError, self).__init__(code, msg)\n\n\nclass InvalidVersionError(ProxyError):\n    def __init__(self, expected_version, got_version):\n        msg = ('Invalid response version from server. Expected {0:02x} got '\n               '{1:02x}'.format(expected_version, got_version))\n        super(InvalidVersionError, self).__init__(0, msg)\n\n\nclass Socks4Error(ProxyError):\n    ERR_SUCCESS = 90\n\n    CODES = {\n        91: 'request rejected or failed',\n        92: 'request rejected because SOCKS server cannot connect to identd on the client',\n        93: 'request rejected because the client program and identd report different user-ids'\n    }\n\n\nclass Socks5Error(ProxyError):\n    ERR_GENERAL_FAILURE = 0x01\n\n    CODES = {\n        0x01: 'general SOCKS server failure',\n        0x02: 'connection not allowed by ruleset',\n        0x03: 'Network unreachable',\n        0x04: 'Host unreachable',\n        0x05: 'Connection refused',\n        0x06: 'TTL expired',\n        0x07: 'Command not supported',\n        0x08: 'Address type not supported',\n        0xFE: 'unknown username or invalid password',\n        0xFF: 'all offered authentication methods were rejected'\n    }\n\n\nclass ProxyType(object):\n    SOCKS4 = 0\n    SOCKS4A = 1\n    SOCKS5 = 2\n\n\nProxy = collections.namedtuple('Proxy', (\n    'type', 'host', 'port', 'username', 'password', 'remote_dns'))\n\n\nclass sockssocket(socket.socket):\n    def __init__(self, *args, **kwargs):\n        self._proxy = None\n        super(sockssocket, self).__init__(*args, **kwargs)\n\n    def setproxy(self, proxytype, addr, port, rdns=True, username=None, password=None):\n        assert proxytype in (ProxyType.SOCKS4, ProxyType.SOCKS4A, ProxyType.SOCKS5)\n\n        self._proxy = Proxy(proxytype, addr, port, username, password, rdns)\n\n    def recvall(self, cnt):\n        data = b''\n        while len(data) < cnt:\n            cur = self.recv(cnt - len(data))\n            if not cur:\n                raise EOFError('{0} bytes missing'.format(cnt - len(data)))\n            data += cur\n        return data\n\n    def _recv_bytes(self, cnt):\n        data = self.recvall(cnt)\n        return compat_struct_unpack('!{0}B'.format(cnt), data)\n\n    @staticmethod\n    def _len_and_data(data):\n        return compat_struct_pack('!B', len(data)) + data\n\n    def _check_response_version(self, expected_version, got_version):\n        if got_version != expected_version:\n            self.close()\n            raise InvalidVersionError(expected_version, got_version)\n\n    def _resolve_address(self, destaddr, default, use_remote_dns):\n        try:\n            return socket.inet_aton(destaddr)\n        except socket.error:\n            if use_remote_dns and self._proxy.remote_dns:\n                return default\n            else:\n                return socket.inet_aton(socket.gethostbyname(destaddr))\n\n    def _setup_socks4(self, address, is_4a=False):\n        destaddr, port = address\n\n        ipaddr = self._resolve_address(destaddr, SOCKS4_DEFAULT_DSTIP, use_remote_dns=is_4a)\n\n        packet = compat_struct_pack('!BBH', SOCKS4_VERSION, Socks4Command.CMD_CONNECT, port) + ipaddr\n\n        username = (self._proxy.username or '').encode('utf-8')\n        packet += username + b'\\x00'\n\n        if is_4a and self._proxy.remote_dns:\n            packet += destaddr.encode('utf-8') + b'\\x00'\n\n        self.sendall(packet)\n\n        version, resp_code, dstport, dsthost = compat_struct_unpack('!BBHI', self.recvall(8))\n\n        self._check_response_version(SOCKS4_REPLY_VERSION, version)\n\n        if resp_code != Socks4Error.ERR_SUCCESS:\n            self.close()\n            raise Socks4Error(resp_code)\n\n        return (dsthost, dstport)\n\n    def _setup_socks4a(self, address):\n        self._setup_socks4(address, is_4a=True)\n\n    def _socks5_auth(self):\n        packet = compat_struct_pack('!B', SOCKS5_VERSION)\n\n        auth_methods = [Socks5Auth.AUTH_NONE]\n        if self._proxy.username and self._proxy.password:\n            auth_methods.append(Socks5Auth.AUTH_USER_PASS)\n\n        packet += compat_struct_pack('!B', len(auth_methods))\n        packet += compat_struct_pack('!{0}B'.format(len(auth_methods)), *auth_methods)\n\n        self.sendall(packet)\n\n        version, method = self._recv_bytes(2)\n\n        self._check_response_version(SOCKS5_VERSION, version)\n\n        if method == Socks5Auth.AUTH_NO_ACCEPTABLE or (\n                method == Socks5Auth.AUTH_USER_PASS and (not self._proxy.username or not self._proxy.password)):\n            self.close()\n            raise Socks5Error(Socks5Auth.AUTH_NO_ACCEPTABLE)\n\n        if method == Socks5Auth.AUTH_USER_PASS:\n            username = self._proxy.username.encode('utf-8')\n            password = self._proxy.password.encode('utf-8')\n            packet = compat_struct_pack('!B', SOCKS5_USER_AUTH_VERSION)\n            packet += self._len_and_data(username) + self._len_and_data(password)\n            self.sendall(packet)\n\n            version, status = self._recv_bytes(2)\n\n            self._check_response_version(SOCKS5_USER_AUTH_VERSION, version)\n\n            if status != SOCKS5_USER_AUTH_SUCCESS:\n                self.close()\n                raise Socks5Error(Socks5Error.ERR_GENERAL_FAILURE)\n\n    def _setup_socks5(self, address):\n        destaddr, port = address\n\n        ipaddr = self._resolve_address(destaddr, None, use_remote_dns=True)\n\n        self._socks5_auth()\n\n        reserved = 0\n        packet = compat_struct_pack('!BBB', SOCKS5_VERSION, Socks5Command.CMD_CONNECT, reserved)\n        if ipaddr is None:\n            destaddr = destaddr.encode('utf-8')\n            packet += compat_struct_pack('!B', Socks5AddressType.ATYP_DOMAINNAME)\n            packet += self._len_and_data(destaddr)\n        else:\n            packet += compat_struct_pack('!B', Socks5AddressType.ATYP_IPV4) + ipaddr\n        packet += compat_struct_pack('!H', port)\n\n        self.sendall(packet)\n\n        version, status, reserved, atype = self._recv_bytes(4)\n\n        self._check_response_version(SOCKS5_VERSION, version)\n\n        if status != Socks5Error.ERR_SUCCESS:\n            self.close()\n            raise Socks5Error(status)\n\n        if atype == Socks5AddressType.ATYP_IPV4:\n            destaddr = self.recvall(4)\n        elif atype == Socks5AddressType.ATYP_DOMAINNAME:\n            alen = compat_ord(self.recv(1))\n            destaddr = self.recvall(alen)\n        elif atype == Socks5AddressType.ATYP_IPV6:\n            destaddr = self.recvall(16)\n        destport = compat_struct_unpack('!H', self.recvall(2))[0]\n\n        return (destaddr, destport)\n\n    def _make_proxy(self, connect_func, address):\n        if not self._proxy:\n            return connect_func(self, address)\n\n        result = connect_func(self, (self._proxy.host, self._proxy.port))\n        if result != 0 and result is not None:\n            return result\n        setup_funcs = {\n            ProxyType.SOCKS4: self._setup_socks4,\n            ProxyType.SOCKS4A: self._setup_socks4a,\n            ProxyType.SOCKS5: self._setup_socks5,\n        }\n        setup_funcs[self._proxy.type](address)\n        return result\n\n    def connect(self, address):\n        self._make_proxy(socket.socket.connect, address)\n\n    def connect_ex(self, address):\n        return self._make_proxy(socket.socket.connect_ex, address)\n", "comments": "# Public Domain SOCKS proxy protocol implementation\n# Adapted from https://gist.github.com/bluec0re/cafd3764412967417fd3\n# References:\n# SOCKS4 protocol http://www.openssh.com/txt/socks4.protocol\n# SOCKS4A protocol http://www.openssh.com/txt/socks4a.protocol\n# SOCKS5 protocol https://tools.ietf.org/html/rfc1928\n# SOCKS5 username/password authentication https://tools.ietf.org/html/rfc1929\n# Excerpt from SOCKS4A protocol:\n# if the client cannot resolve the destination host's domain name to find its\n# IP address, it should set the first three bytes of DSTIP to NULL and the last\n# byte to a non-zero value.\n# For server response\n", "content": "# Public Domain SOCKS proxy protocol implementation\n# Adapted from https://gist.github.com/bluec0re/cafd3764412967417fd3\n\nfrom __future__ import unicode_literals\n\n# References:\n# SOCKS4 protocol http://www.openssh.com/txt/socks4.protocol\n# SOCKS4A protocol http://www.openssh.com/txt/socks4a.protocol\n# SOCKS5 protocol https://tools.ietf.org/html/rfc1928\n# SOCKS5 username/password authentication https://tools.ietf.org/html/rfc1929\n\nimport collections\nimport socket\n\nfrom .compat import (\n    compat_ord,\n    compat_struct_pack,\n    compat_struct_unpack,\n)\n\n__author__ = 'Timo Schmid <coding@timoschmid.de>'\n\nSOCKS4_VERSION = 4\nSOCKS4_REPLY_VERSION = 0x00\n# Excerpt from SOCKS4A protocol:\n# if the client cannot resolve the destination host's domain name to find its\n# IP address, it should set the first three bytes of DSTIP to NULL and the last\n# byte to a non-zero value.\nSOCKS4_DEFAULT_DSTIP = compat_struct_pack('!BBBB', 0, 0, 0, 0xFF)\n\nSOCKS5_VERSION = 5\nSOCKS5_USER_AUTH_VERSION = 0x01\nSOCKS5_USER_AUTH_SUCCESS = 0x00\n\n\nclass Socks4Command(object):\n    CMD_CONNECT = 0x01\n    CMD_BIND = 0x02\n\n\nclass Socks5Command(Socks4Command):\n    CMD_UDP_ASSOCIATE = 0x03\n\n\nclass Socks5Auth(object):\n    AUTH_NONE = 0x00\n    AUTH_GSSAPI = 0x01\n    AUTH_USER_PASS = 0x02\n    AUTH_NO_ACCEPTABLE = 0xFF  # For server response\n\n\nclass Socks5AddressType(object):\n    ATYP_IPV4 = 0x01\n    ATYP_DOMAINNAME = 0x03\n    ATYP_IPV6 = 0x04\n\n\nclass ProxyError(socket.error):\n    ERR_SUCCESS = 0x00\n\n    def __init__(self, code=None, msg=None):\n        if code is not None and msg is None:\n            msg = self.CODES.get(code) or 'unknown error'\n        super(ProxyError, self).__init__(code, msg)\n\n\nclass InvalidVersionError(ProxyError):\n    def __init__(self, expected_version, got_version):\n        msg = ('Invalid response version from server. Expected {0:02x} got '\n               '{1:02x}'.format(expected_version, got_version))\n        super(InvalidVersionError, self).__init__(0, msg)\n\n\nclass Socks4Error(ProxyError):\n    ERR_SUCCESS = 90\n\n    CODES = {\n        91: 'request rejected or failed',\n        92: 'request rejected because SOCKS server cannot connect to identd on the client',\n        93: 'request rejected because the client program and identd report different user-ids'\n    }\n\n\nclass Socks5Error(ProxyError):\n    ERR_GENERAL_FAILURE = 0x01\n\n    CODES = {\n        0x01: 'general SOCKS server failure',\n        0x02: 'connection not allowed by ruleset',\n        0x03: 'Network unreachable',\n        0x04: 'Host unreachable',\n        0x05: 'Connection refused',\n        0x06: 'TTL expired',\n        0x07: 'Command not supported',\n        0x08: 'Address type not supported',\n        0xFE: 'unknown username or invalid password',\n        0xFF: 'all offered authentication methods were rejected'\n    }\n\n\nclass ProxyType(object):\n    SOCKS4 = 0\n    SOCKS4A = 1\n    SOCKS5 = 2\n\n\nProxy = collections.namedtuple('Proxy', (\n    'type', 'host', 'port', 'username', 'password', 'remote_dns'))\n\n\nclass sockssocket(socket.socket):\n    def __init__(self, *args, **kwargs):\n        self._proxy = None\n        super(sockssocket, self).__init__(*args, **kwargs)\n\n    def setproxy(self, proxytype, addr, port, rdns=True, username=None, password=None):\n        assert proxytype in (ProxyType.SOCKS4, ProxyType.SOCKS4A, ProxyType.SOCKS5)\n\n        self._proxy = Proxy(proxytype, addr, port, username, password, rdns)\n\n    def recvall(self, cnt):\n        data = b''\n        while len(data) < cnt:\n            cur = self.recv(cnt - len(data))\n            if not cur:\n                raise EOFError('{0} bytes missing'.format(cnt - len(data)))\n            data += cur\n        return data\n\n    def _recv_bytes(self, cnt):\n        data = self.recvall(cnt)\n        return compat_struct_unpack('!{0}B'.format(cnt), data)\n\n    @staticmethod\n    def _len_and_data(data):\n        return compat_struct_pack('!B', len(data)) + data\n\n    def _check_response_version(self, expected_version, got_version):\n        if got_version != expected_version:\n            self.close()\n            raise InvalidVersionError(expected_version, got_version)\n\n    def _resolve_address(self, destaddr, default, use_remote_dns):\n        try:\n            return socket.inet_aton(destaddr)\n        except socket.error:\n            if use_remote_dns and self._proxy.remote_dns:\n                return default\n            else:\n                return socket.inet_aton(socket.gethostbyname(destaddr))\n\n    def _setup_socks4(self, address, is_4a=False):\n        destaddr, port = address\n\n        ipaddr = self._resolve_address(destaddr, SOCKS4_DEFAULT_DSTIP, use_remote_dns=is_4a)\n\n        packet = compat_struct_pack('!BBH', SOCKS4_VERSION, Socks4Command.CMD_CONNECT, port) + ipaddr\n\n        username = (self._proxy.username or '').encode('utf-8')\n        packet += username + b'\\x00'\n\n        if is_4a and self._proxy.remote_dns:\n            packet += destaddr.encode('utf-8') + b'\\x00'\n\n        self.sendall(packet)\n\n        version, resp_code, dstport, dsthost = compat_struct_unpack('!BBHI', self.recvall(8))\n\n        self._check_response_version(SOCKS4_REPLY_VERSION, version)\n\n        if resp_code != Socks4Error.ERR_SUCCESS:\n            self.close()\n            raise Socks4Error(resp_code)\n\n        return (dsthost, dstport)\n\n    def _setup_socks4a(self, address):\n        self._setup_socks4(address, is_4a=True)\n\n    def _socks5_auth(self):\n        packet = compat_struct_pack('!B', SOCKS5_VERSION)\n\n        auth_methods = [Socks5Auth.AUTH_NONE]\n        if self._proxy.username and self._proxy.password:\n            auth_methods.append(Socks5Auth.AUTH_USER_PASS)\n\n        packet += compat_struct_pack('!B', len(auth_methods))\n        packet += compat_struct_pack('!{0}B'.format(len(auth_methods)), *auth_methods)\n\n        self.sendall(packet)\n\n        version, method = self._recv_bytes(2)\n\n        self._check_response_version(SOCKS5_VERSION, version)\n\n        if method == Socks5Auth.AUTH_NO_ACCEPTABLE or (\n                method == Socks5Auth.AUTH_USER_PASS and (not self._proxy.username or not self._proxy.password)):\n            self.close()\n            raise Socks5Error(Socks5Auth.AUTH_NO_ACCEPTABLE)\n\n        if method == Socks5Auth.AUTH_USER_PASS:\n            username = self._proxy.username.encode('utf-8')\n            password = self._proxy.password.encode('utf-8')\n            packet = compat_struct_pack('!B', SOCKS5_USER_AUTH_VERSION)\n            packet += self._len_and_data(username) + self._len_and_data(password)\n            self.sendall(packet)\n\n            version, status = self._recv_bytes(2)\n\n            self._check_response_version(SOCKS5_USER_AUTH_VERSION, version)\n\n            if status != SOCKS5_USER_AUTH_SUCCESS:\n                self.close()\n                raise Socks5Error(Socks5Error.ERR_GENERAL_FAILURE)\n\n    def _setup_socks5(self, address):\n        destaddr, port = address\n\n        ipaddr = self._resolve_address(destaddr, None, use_remote_dns=True)\n\n        self._socks5_auth()\n\n        reserved = 0\n        packet = compat_struct_pack('!BBB', SOCKS5_VERSION, Socks5Command.CMD_CONNECT, reserved)\n        if ipaddr is None:\n            destaddr = destaddr.encode('utf-8')\n            packet += compat_struct_pack('!B', Socks5AddressType.ATYP_DOMAINNAME)\n            packet += self._len_and_data(destaddr)\n        else:\n            packet += compat_struct_pack('!B', Socks5AddressType.ATYP_IPV4) + ipaddr\n        packet += compat_struct_pack('!H', port)\n\n        self.sendall(packet)\n\n        version, status, reserved, atype = self._recv_bytes(4)\n\n        self._check_response_version(SOCKS5_VERSION, version)\n\n        if status != Socks5Error.ERR_SUCCESS:\n            self.close()\n            raise Socks5Error(status)\n\n        if atype == Socks5AddressType.ATYP_IPV4:\n            destaddr = self.recvall(4)\n        elif atype == Socks5AddressType.ATYP_DOMAINNAME:\n            alen = compat_ord(self.recv(1))\n            destaddr = self.recvall(alen)\n        elif atype == Socks5AddressType.ATYP_IPV6:\n            destaddr = self.recvall(16)\n        destport = compat_struct_unpack('!H', self.recvall(2))[0]\n\n        return (destaddr, destport)\n\n    def _make_proxy(self, connect_func, address):\n        if not self._proxy:\n            return connect_func(self, address)\n\n        result = connect_func(self, (self._proxy.host, self._proxy.port))\n        if result != 0 and result is not None:\n            return result\n        setup_funcs = {\n            ProxyType.SOCKS4: self._setup_socks4,\n            ProxyType.SOCKS4A: self._setup_socks4a,\n            ProxyType.SOCKS5: self._setup_socks5,\n        }\n        setup_funcs[self._proxy.type](address)\n        return result\n\n    def connect(self, address):\n        self._make_proxy(socket.socket.connect, address)\n\n    def connect_ex(self, address):\n        return self._make_proxy(socket.socket.connect_ex, address)\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "socks.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/socks.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}