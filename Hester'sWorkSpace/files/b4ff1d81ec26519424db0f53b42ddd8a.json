{"author": "openai", "code": "import os\n\nfrom gym import error, spaces\nfrom gym.utils import seeding\nimport numpy as np\nfrom os import path\nimport gym\nimport six\n\ntry:\n    import mujoco_py\nexcept ImportError as e:\n    raise error.DependencyNotInstalled(\"{}. (HINT: you need to install mujoco_py, and also perform the setup instructions here: https://github.com/openai/mujoco-py/.)\".format(e))\n\nclass MujocoEnv(gym.Env):\n    \"\"\"Superclass for all MuJoCo environments.\n    \"\"\"\n\n    def __init__(self, model_path, frame_skip):\n        if model_path.startswith(\"/\"):\n            fullpath = model_path\n        else:\n            fullpath = os.path.join(os.path.dirname(__file__), \"assets\", model_path)\n        if not path.exists(fullpath):\n            raise IOError(\"File %s does not exist\" % fullpath)\n        self.frame_skip = frame_skip\n        self.model = mujoco_py.load_model_from_path(fullpath)\n        self.sim = mujoco_py.MjSim(self.model)\n        self.data = self.sim.data\n        self.viewer = None\n\n        self.metadata = {\n            'render.modes': ['human', 'rgb_array'],\n            'video.frames_per_second': int(np.round(1.0 / self.dt))\n        }\n\n        self.init_qpos = self.sim.data.qpos.ravel().copy()\n        self.init_qvel = self.sim.data.qvel.ravel().copy()\n        observation, _reward, done, _info = self.step(np.zeros(self.model.nu))\n        assert not done\n        self.obs_dim = observation.size\n\n        bounds = self.model.actuator_ctrlrange.copy()\n        low = bounds[:, 0]\n        high = bounds[:, 1]\n        self.action_space = spaces.Box(low=low, high=high)\n\n        high = np.inf*np.ones(self.obs_dim)\n        low = -high\n        self.observation_space = spaces.Box(low, high)\n\n        self.seed()\n\n    def seed(self, seed=None):\n        self.np_random, seed = seeding.np_random(seed)\n        return [seed]\n\n    \n    \n\n    def reset_model(self):\n        \"\"\"\n        Reset the robot degrees of freedom (qpos and qvel).\n        Implement this in each subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    def viewer_setup(self):\n        \"\"\"\n        This method is called when the viewer is initialized and after every reset\n        Optionally implement this method, if you need to tinker with camera position\n        and so forth.\n        \"\"\"\n        pass\n\n    -\n\n    def reset(self):\n        self.sim.reset()\n        ob = self.reset_model()\n        if self.viewer is not None:\n            self.viewer_setup()\n        return ob\n\n    def set_state(self, qpos, qvel):\n        assert qpos.shape == (self.model.nq,) and qvel.shape == (self.model.nv,)\n        old_state = self.sim.get_state()\n        new_state = mujoco_py.MjSimState(old_state.time, qpos, qvel,\n                                         old_state.act, old_state.udd_state)\n        self.sim.set_state(new_state)\n        self.sim.forward()\n\n    @property\n    def dt(self):\n        return self.model.opt.timestep * self.frame_skip\n\n    def do_simulation(self, ctrl, n_frames):\n        self.sim.data.ctrl[:] = ctrl\n        for _ in range(n_frames):\n            self.sim.step()\n\n    def render(self, mode='human'):\n        if mode == 'rgb_array':\n            self._get_viewer().render()\n            \n            width, height = 500, 500\n            data = self._get_viewer().read_pixels(width, height, depth=False)\n            \n            return data[::-1, :, :]\n        elif mode == 'human':\n            self._get_viewer().render()\n\n    def close(self):\n        if self.viewer is not None:\n            self.viewer.finish()\n            self.viewer = None\n\n    def _get_viewer(self):\n        if self.viewer is None:\n            self.viewer = mujoco_py.MjViewer(self.sim)\n            self.viewer_setup()\n        return self.viewer\n\n    def get_body_com(self, body_name):\n        return self.data.get_body_xpos(body_name)\n\n    def state_vector(self):\n        return np.concatenate([\n            self.sim.data.qpos.flat,\n            self.sim.data.qvel.flat\n        ])\n", "comments": "   superclass mujoco environments               def   init  (self  model path  frame skip)          model path startswith(   )              fullpath   model path         else              fullpath   os path join(os path dirname(  file  )   assets   model path)         path exists(fullpath)              raise ioerror( file  exist    fullpath)         self frame skip   frame skip         self model   mujoco py load model path(fullpath)         self sim   mujoco py mjsim(self model)         self data   self sim data         self viewer   none          self metadata                  render modes     human    rgb array                 video frames per second   int(np round(1 0   self dt))                    self init qpos   self sim data qpos ravel() copy()         self init qvel   self sim data qvel ravel() copy()         observation   reward  done   info   self step(np zeros(self model nu))         assert done         self obs dim   observation size          bounds   self model actuator ctrlrange copy()         low   bounds    0          high   bounds    1          self action space   spaces box(low low  high high)          high   np inf np ones(self obs dim)         low    high         self observation space   spaces box(low  high)          self seed()      def seed(self  seed none)          self np random  seed   seeding np random(seed)         return  seed         methods override                                          def reset model(self)                      reset robot degrees freedom (qpos qvel)          implement subclass                      raise notimplementederror      def viewer setup(self)                      this method called viewer initialized every reset         optionally implement method  need tinker camera position         forth                 methods override                                                                      window size used old mujoco py     original image upside  flip ", "content": "import os\n\nfrom gym import error, spaces\nfrom gym.utils import seeding\nimport numpy as np\nfrom os import path\nimport gym\nimport six\n\ntry:\n    import mujoco_py\nexcept ImportError as e:\n    raise error.DependencyNotInstalled(\"{}. (HINT: you need to install mujoco_py, and also perform the setup instructions here: https://github.com/openai/mujoco-py/.)\".format(e))\n\nclass MujocoEnv(gym.Env):\n    \"\"\"Superclass for all MuJoCo environments.\n    \"\"\"\n\n    def __init__(self, model_path, frame_skip):\n        if model_path.startswith(\"/\"):\n            fullpath = model_path\n        else:\n            fullpath = os.path.join(os.path.dirname(__file__), \"assets\", model_path)\n        if not path.exists(fullpath):\n            raise IOError(\"File %s does not exist\" % fullpath)\n        self.frame_skip = frame_skip\n        self.model = mujoco_py.load_model_from_path(fullpath)\n        self.sim = mujoco_py.MjSim(self.model)\n        self.data = self.sim.data\n        self.viewer = None\n\n        self.metadata = {\n            'render.modes': ['human', 'rgb_array'],\n            'video.frames_per_second': int(np.round(1.0 / self.dt))\n        }\n\n        self.init_qpos = self.sim.data.qpos.ravel().copy()\n        self.init_qvel = self.sim.data.qvel.ravel().copy()\n        observation, _reward, done, _info = self.step(np.zeros(self.model.nu))\n        assert not done\n        self.obs_dim = observation.size\n\n        bounds = self.model.actuator_ctrlrange.copy()\n        low = bounds[:, 0]\n        high = bounds[:, 1]\n        self.action_space = spaces.Box(low=low, high=high)\n\n        high = np.inf*np.ones(self.obs_dim)\n        low = -high\n        self.observation_space = spaces.Box(low, high)\n\n        self.seed()\n\n    def seed(self, seed=None):\n        self.np_random, seed = seeding.np_random(seed)\n        return [seed]\n\n    # methods to override:\n    # ----------------------------\n\n    def reset_model(self):\n        \"\"\"\n        Reset the robot degrees of freedom (qpos and qvel).\n        Implement this in each subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    def viewer_setup(self):\n        \"\"\"\n        This method is called when the viewer is initialized and after every reset\n        Optionally implement this method, if you need to tinker with camera position\n        and so forth.\n        \"\"\"\n        pass\n\n    # -----------------------------\n\n    def reset(self):\n        self.sim.reset()\n        ob = self.reset_model()\n        if self.viewer is not None:\n            self.viewer_setup()\n        return ob\n\n    def set_state(self, qpos, qvel):\n        assert qpos.shape == (self.model.nq,) and qvel.shape == (self.model.nv,)\n        old_state = self.sim.get_state()\n        new_state = mujoco_py.MjSimState(old_state.time, qpos, qvel,\n                                         old_state.act, old_state.udd_state)\n        self.sim.set_state(new_state)\n        self.sim.forward()\n\n    @property\n    def dt(self):\n        return self.model.opt.timestep * self.frame_skip\n\n    def do_simulation(self, ctrl, n_frames):\n        self.sim.data.ctrl[:] = ctrl\n        for _ in range(n_frames):\n            self.sim.step()\n\n    def render(self, mode='human'):\n        if mode == 'rgb_array':\n            self._get_viewer().render()\n            # window size used for old mujoco-py:\n            width, height = 500, 500\n            data = self._get_viewer().read_pixels(width, height, depth=False)\n            # original image is upside-down, so flip it\n            return data[::-1, :, :]\n        elif mode == 'human':\n            self._get_viewer().render()\n\n    def close(self):\n        if self.viewer is not None:\n            self.viewer.finish()\n            self.viewer = None\n\n    def _get_viewer(self):\n        if self.viewer is None:\n            self.viewer = mujoco_py.MjViewer(self.sim)\n            self.viewer_setup()\n        return self.viewer\n\n    def get_body_com(self, body_name):\n        return self.data.get_body_xpos(body_name)\n\n    def state_vector(self):\n        return np.concatenate([\n            self.sim.data.qpos.flat,\n            self.sim.data.qvel.flat\n        ])\n", "description": "A toolkit for developing and comparing reinforcement learning algorithms.", "file_name": "mujoco_env.py", "id": "b4ff1d81ec26519424db0f53b42ddd8a", "language": "Python", "project_name": "gym", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/openai-gym/openai-gym-6160181/gym/envs/mujoco/mujoco_env.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:30:35Z", "url": "https://github.com/openai/gym", "wiki": true}