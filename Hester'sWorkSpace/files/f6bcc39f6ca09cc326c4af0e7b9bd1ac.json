{"author": "keon", "code": "# Queue Abstract Data Type (ADT)\n# * Queue() creates a new queue that is empty.\n\n# * enqueue(item) adds a new item to the rear of the queue.\n\n# * dequeue() removes the front item from the queue.\n\n# * isEmpty() tests to see whether the queue is empty.\n\n# * size() returns the number of items in the queue.\n\n\nclass AbstractQueue:\n    def __init__(self):\n        self.top = 0\n\n    def isEmpty(self):\n        return self.top == 0\n\n    def __len__(self):\n        return self.top\n\n\nclass ArrayQueue(AbstractQueue):\n    def __init__(self, size=10):\n        \"\"\"\n        Initialize python List with size of 10 or user given input.\n        Python List type is a dynamic array, so we have to restrict its\n        dynamic nature to make it work like a static array.\n        \"\"\"\n        AbstractQueue.__init__(self)\n        self.array = [None] * size\n        self.front = 0\n        self.rear = 0\n\n    def enqueue(self, value):\n        if self.rear == len(self.array):\n            self.expand()\n        self.array[self.rear] = value\n        self.rear += 1\n        self.top += 1\n\n    def dequeue(self):\n        if self.isEmpty():\n            raise IndexError(\"Queue is empty\")\n        value = self.array[self.front]\n        self.array[self.front] = None\n        self.front -= 1\n        self.top -= 1\n        return value\n\n    def expand(self):\n        \"\"\"\n         expands size of the array.\n         Time Complexity: O(n)\n        \"\"\"\n        new_array = [None] * len(self.array) * 2  \n        for i, element in enumerate(self.array):\n            new_array[i] = element\n        self.array = new_array\n\n    def __iter__(self):\n        probe = self.rear\n        while True:\n            if probe < 0:\n                raise StopIteration\n            yield self.array[probe]\n            probe -= 1\n\n\nclass QueueNode(object):\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\nclass LinkedListQueue(AbstractQueue):\n    def __init__(self):\n        AbstractQueue.__init__(self)\n        self.front = None\n        self.rear = None\n\n    def enqueue(self, value):\n        node = QueueNode(value)\n        if not self.front:\n            self.front = node\n            self.rear = node\n        else:\n            self.rear.next = node\n            self.rear = node\n        self.top += 1\n\n    def dequeue(self):\n        if self.isEmpty():\n            raise IndexError(\"Queue is empty\")\n        value = self.front.value\n        if self.front is self.rear:\n            self.front = None\n            self.rear = None\n        else:\n            self.front = self.front.next\n        self.top -= 1\n        return value\n\n    def __iter__(self):\n        probe = self.rear\n        while True:\n            if probe is None:\n                raise StopIteration\n            yield probe.value\n            probe = probe.next\n\n\nclass HeapPriorityQueue(AbstractQueue):\n    pass\n", "comments": "            initialize python list size 10 user given input          python list type dynamic array  restrict         dynamic nature make work like static array                      abstractqueue   init  (self)         self array    none    size         self front   0         self rear   0      def enqueue(self  value)          self rear    len(self array)              self expand()         self array self rear    value         self rear    1         self top    1      def dequeue(self)          self isempty()              raise indexerror( queue empty )         value   self array self front          self array self front    none         self front    1         self top    1         return value      def expand(self)                       expands size array           time complexity  o(n)                queue abstract data type (adt)      queue() creates new queue empty       it needs parameters returns empty queue       enqueue(item) adds new item rear queue       it needs item returns nothing       dequeue() removes front item queue       it needs parameters returns item  the queue modified       isempty() tests see whether queue empty       it needs parameters returns boolean value       size() returns number items queue       it needs parameters returns integer     double size array ", "content": "# Queue Abstract Data Type (ADT)\n# * Queue() creates a new queue that is empty.\n#   It needs no parameters and returns an empty queue.\n# * enqueue(item) adds a new item to the rear of the queue.\n#   It needs the item and returns nothing.\n# * dequeue() removes the front item from the queue.\n#   It needs no parameters and returns the item. The queue is modified.\n# * isEmpty() tests to see whether the queue is empty.\n#   It needs no parameters and returns a boolean value.\n# * size() returns the number of items in the queue.\n#   It needs no parameters and returns an integer.\n\nclass AbstractQueue:\n    def __init__(self):\n        self.top = 0\n\n    def isEmpty(self):\n        return self.top == 0\n\n    def __len__(self):\n        return self.top\n\n\nclass ArrayQueue(AbstractQueue):\n    def __init__(self, size=10):\n        \"\"\"\n        Initialize python List with size of 10 or user given input.\n        Python List type is a dynamic array, so we have to restrict its\n        dynamic nature to make it work like a static array.\n        \"\"\"\n        AbstractQueue.__init__(self)\n        self.array = [None] * size\n        self.front = 0\n        self.rear = 0\n\n    def enqueue(self, value):\n        if self.rear == len(self.array):\n            self.expand()\n        self.array[self.rear] = value\n        self.rear += 1\n        self.top += 1\n\n    def dequeue(self):\n        if self.isEmpty():\n            raise IndexError(\"Queue is empty\")\n        value = self.array[self.front]\n        self.array[self.front] = None\n        self.front -= 1\n        self.top -= 1\n        return value\n\n    def expand(self):\n        \"\"\"\n         expands size of the array.\n         Time Complexity: O(n)\n        \"\"\"\n        new_array = [None] * len(self.array) * 2  # double the size of the array\n        for i, element in enumerate(self.array):\n            new_array[i] = element\n        self.array = new_array\n\n    def __iter__(self):\n        probe = self.rear\n        while True:\n            if probe < 0:\n                raise StopIteration\n            yield self.array[probe]\n            probe -= 1\n\n\nclass QueueNode(object):\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\nclass LinkedListQueue(AbstractQueue):\n    def __init__(self):\n        AbstractQueue.__init__(self)\n        self.front = None\n        self.rear = None\n\n    def enqueue(self, value):\n        node = QueueNode(value)\n        if not self.front:\n            self.front = node\n            self.rear = node\n        else:\n            self.rear.next = node\n            self.rear = node\n        self.top += 1\n\n    def dequeue(self):\n        if self.isEmpty():\n            raise IndexError(\"Queue is empty\")\n        value = self.front.value\n        if self.front is self.rear:\n            self.front = None\n            self.rear = None\n        else:\n            self.front = self.front.next\n        self.top -= 1\n        return value\n\n    def __iter__(self):\n        probe = self.rear\n        while True:\n            if probe is None:\n                raise StopIteration\n            yield probe.value\n            probe = probe.next\n\n\nclass HeapPriorityQueue(AbstractQueue):\n    pass\n", "description": "Minimal examples of data structures and algorithms in Python", "file_name": "queue.py", "id": "f6bcc39f6ca09cc326c4af0e7b9bd1ac", "language": "Python", "project_name": "algorithms", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/keon-algorithms/keon-algorithms-ea43887/queues/queue.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:53:29Z", "url": "https://github.com/keon/algorithms", "wiki": true}