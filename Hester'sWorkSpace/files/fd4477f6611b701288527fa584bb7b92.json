{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    int_or_none,\n    parse_iso8601,\n    mimetype2ext,\n    determine_ext,\n    ExtractorError,\n)\n\n\nclass AMPIE(InfoExtractor):\n    \n    def _extract_feed_info(self, url):\n        feed = self._download_json(\n            url, None, 'Downloading Akamai AMP feed',\n            'Unable to download Akamai AMP feed')\n        item = feed.get('channel', {}).get('item')\n        if not item:\n            raise ExtractorError('%s said: %s' % (self.IE_NAME, feed['error']))\n\n        video_id = item['guid']\n\n        def get_media_node(name, default=None):\n            media_name = 'media-%s' % name\n            media_group = item.get('media-group') or item\n            return media_group.get(media_name) or item.get(media_name) or item.get(name, default)\n\n        thumbnails = []\n        media_thumbnail = get_media_node('thumbnail')\n        if media_thumbnail:\n            if isinstance(media_thumbnail, dict):\n                media_thumbnail = [media_thumbnail]\n            for thumbnail_data in media_thumbnail:\n                thumbnail = thumbnail_data.get('@attributes', {})\n                thumbnail_url = thumbnail.get('url')\n                if not thumbnail_url:\n                    continue\n                thumbnails.append({\n                    'url': self._proto_relative_url(thumbnail_url, 'http:'),\n                    'width': int_or_none(thumbnail.get('width')),\n                    'height': int_or_none(thumbnail.get('height')),\n                })\n\n        subtitles = {}\n        media_subtitle = get_media_node('subTitle')\n        if media_subtitle:\n            if isinstance(media_subtitle, dict):\n                media_subtitle = [media_subtitle]\n            for subtitle_data in media_subtitle:\n                subtitle = subtitle_data.get('@attributes', {})\n                subtitle_href = subtitle.get('href')\n                if not subtitle_href:\n                    continue\n                subtitles.setdefault(subtitle.get('lang') or 'en', []).append({\n                    'url': subtitle_href,\n                    'ext': mimetype2ext(subtitle.get('type')) or determine_ext(subtitle_href),\n                })\n\n        formats = []\n        media_content = get_media_node('content')\n        if isinstance(media_content, dict):\n            media_content = [media_content]\n        for media_data in media_content:\n            media = media_data.get('@attributes', {})\n            media_url = media.get('url')\n            if not media_url:\n                continue\n            ext = mimetype2ext(media.get('type')) or determine_ext(media_url)\n            if ext == 'f4m':\n                formats.extend(self._extract_f4m_formats(\n                    media_url + '?hdcore=3.4.0&plugin=aasp-3.4.0.132.124',\n                    video_id, f4m_id='hds', fatal=False))\n            elif ext == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    media_url, video_id, 'mp4', m3u8_id='hls', fatal=False))\n            else:\n                formats.append({\n                    'format_id': media_data.get('media-category', {}).get('@attributes', {}).get('label'),\n                    'url': media['url'],\n                    'tbr': int_or_none(media.get('bitrate')),\n                    'filesize': int_or_none(media.get('fileSize')),\n                    'ext': ext,\n                })\n\n        self._sort_formats(formats)\n\n        timestamp = parse_iso8601(item.get('pubDate'), ' ') or parse_iso8601(item.get('dc-date'))\n\n        return {\n            'id': video_id,\n            'title': get_media_node('title'),\n            'description': get_media_node('description'),\n            'thumbnails': thumbnails,\n            'timestamp': timestamp,\n            'duration': int_or_none(media_content[0].get('@attributes', {}).get('duration')),\n            'subtitles': subtitles,\n            'formats': formats,\n        }\n", "comments": "# coding: utf-8\n# parse Akamai Adaptive Media Player feed\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    int_or_none,\n    parse_iso8601,\n    mimetype2ext,\n    determine_ext,\n    ExtractorError,\n)\n\n\nclass AMPIE(InfoExtractor):\n    # parse Akamai Adaptive Media Player feed\n    def _extract_feed_info(self, url):\n        feed = self._download_json(\n            url, None, 'Downloading Akamai AMP feed',\n            'Unable to download Akamai AMP feed')\n        item = feed.get('channel', {}).get('item')\n        if not item:\n            raise ExtractorError('%s said: %s' % (self.IE_NAME, feed['error']))\n\n        video_id = item['guid']\n\n        def get_media_node(name, default=None):\n            media_name = 'media-%s' % name\n            media_group = item.get('media-group') or item\n            return media_group.get(media_name) or item.get(media_name) or item.get(name, default)\n\n        thumbnails = []\n        media_thumbnail = get_media_node('thumbnail')\n        if media_thumbnail:\n            if isinstance(media_thumbnail, dict):\n                media_thumbnail = [media_thumbnail]\n            for thumbnail_data in media_thumbnail:\n                thumbnail = thumbnail_data.get('@attributes', {})\n                thumbnail_url = thumbnail.get('url')\n                if not thumbnail_url:\n                    continue\n                thumbnails.append({\n                    'url': self._proto_relative_url(thumbnail_url, 'http:'),\n                    'width': int_or_none(thumbnail.get('width')),\n                    'height': int_or_none(thumbnail.get('height')),\n                })\n\n        subtitles = {}\n        media_subtitle = get_media_node('subTitle')\n        if media_subtitle:\n            if isinstance(media_subtitle, dict):\n                media_subtitle = [media_subtitle]\n            for subtitle_data in media_subtitle:\n                subtitle = subtitle_data.get('@attributes', {})\n                subtitle_href = subtitle.get('href')\n                if not subtitle_href:\n                    continue\n                subtitles.setdefault(subtitle.get('lang') or 'en', []).append({\n                    'url': subtitle_href,\n                    'ext': mimetype2ext(subtitle.get('type')) or determine_ext(subtitle_href),\n                })\n\n        formats = []\n        media_content = get_media_node('content')\n        if isinstance(media_content, dict):\n            media_content = [media_content]\n        for media_data in media_content:\n            media = media_data.get('@attributes', {})\n            media_url = media.get('url')\n            if not media_url:\n                continue\n            ext = mimetype2ext(media.get('type')) or determine_ext(media_url)\n            if ext == 'f4m':\n                formats.extend(self._extract_f4m_formats(\n                    media_url + '?hdcore=3.4.0&plugin=aasp-3.4.0.132.124',\n                    video_id, f4m_id='hds', fatal=False))\n            elif ext == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    media_url, video_id, 'mp4', m3u8_id='hls', fatal=False))\n            else:\n                formats.append({\n                    'format_id': media_data.get('media-category', {}).get('@attributes', {}).get('label'),\n                    'url': media['url'],\n                    'tbr': int_or_none(media.get('bitrate')),\n                    'filesize': int_or_none(media.get('fileSize')),\n                    'ext': ext,\n                })\n\n        self._sort_formats(formats)\n\n        timestamp = parse_iso8601(item.get('pubDate'), ' ') or parse_iso8601(item.get('dc-date'))\n\n        return {\n            'id': video_id,\n            'title': get_media_node('title'),\n            'description': get_media_node('description'),\n            'thumbnails': thumbnails,\n            'timestamp': timestamp,\n            'duration': int_or_none(media_content[0].get('@attributes', {}).get('duration')),\n            'subtitles': subtitles,\n            'formats': formats,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "amp.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/amp.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}