{"author": "tensorflow", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\"\"\"Utilities for parsing Kaggle baby names files.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport os\n\nimport numpy as np\nimport tensorflow as tf\nimport pandas as pd\n\n the default end of name rep will be zero\n_EON = 0\n\n\ndef read_names(names_path):\n    \"\"\"read data from downloaded file. See SmallNames.txt for example format\n    or go to https://www.kaggle.com/kaggle/us-baby-names for full lists\n\n    Args:\n        names_path: path to the csv file similar to the example type\n    Returns:\n        Dataset: a namedtuple of two elements: deduped names and their associated\n            counts. The names contain only 26 chars and are all lower case\n    \"\"\"\n    names_data = pd.read_csv(names_path)\n    names_data.Name = names_data.Name.str.lower()\n\n    name_data = names_data.groupby(by=[\"Name\"])[\"Count\"].sum()\n    name_counts = np.array(name_data.tolist())\n    names_deduped = np.array(name_data.index.tolist())\n\n    Dataset = collections.namedtuple('Dataset', ['Name', 'Count'])\n    return Dataset(names_deduped, name_counts)\n\n\ndef _letter_to_number(letter):\n    \"\"\"converts letters to numbers between 1 and 27\"\"\"\n     ord of lower case 'a' is 97\n    return ord(letter) - 96\n\n\ndef namignizer_iterator(names, counts, batch_size, num_steps, epoch_size):\n    \"\"\"Takes a list of names and counts like those output from read_names, and\n    makes an iterator yielding a batch_size by num_steps array of random names\n    separated by an end of name token. The names are chosen randomly according\n    to their counts. The batch may end mid-name\n\n    Args:\n        names: a set of lowercase names composed of 26 characters\n        counts: a list of the frequency of those names\n        batch_size: int\n        num_steps: int\n        epoch_size: number of batches to yield\n    Yields:\n        (x, y): a batch_size by num_steps array of ints representing letters, where\n            x will be the input and y will be the target\n    \"\"\"\n    name_distribution = counts / counts.sum()\n\n    for i in range(epoch_size):\n        data = np.zeros(batch_size * num_steps + 1)\n        samples = np.random.choice(names, size=batch_size * num_steps // 2,\n                                   replace=True, p=name_distribution)\n\n        data_index = 0\n        for sample in samples:\n            if data_index >= batch_size * num_steps:\n                break\n            for letter in map(_letter_to_number, sample) + [_EON]:\n                if data_index >= batch_size * num_steps:\n                    break\n                data[data_index] = letter\n                data_index += 1\n\n        x = data[:batch_size * num_steps].reshape((batch_size, num_steps))\n        y = data[1:batch_size * num_steps + 1].reshape((batch_size, num_steps))\n\n        yield (x, y)\n\n\ndef name_to_batch(name, batch_size, num_steps):\n    \"\"\" Takes a single name and fills a batch with it\n\n    Args:\n        name: lowercase composed of 26 characters\n        batch_size: int\n        num_steps: int\n    Returns:\n        x, y: a batch_size by num_steps array of ints representing letters, where\n            x will be the input and y will be the target. The array is filled up\n            to the length of the string, the rest is filled with zeros\n    \"\"\"\n    data = np.zeros(batch_size * num_steps + 1)\n\n    data_index = 0\n    for letter in map(_letter_to_number, name) + [_EON]:\n        data[data_index] = letter\n        data_index += 1\n\n    x = data[:batch_size * num_steps].reshape((batch_size, num_steps))\n    y = data[1:batch_size * num_steps + 1].reshape((batch_size, num_steps))\n\n    return x, y\n", "comments": "   utilities parsing kaggle baby names files        future   import absolute import   future   import division   future   import print function  import collections import os  import numpy np import tensorflow tf import pandas pd    default end name rep zero  eon   0   def read names(names path)         read data downloaded file  see smallnames txt example format     go https   www kaggle com kaggle us baby names full lists      args          names path  path csv file similar example type     returns          dataset  namedtuple two elements  deduped names associated             counts  the names contain 26 chars lower case             names data   pd read csv(names path)     names data name   names data name str lower()      name data   names data groupby(by   name  )  count   sum()     name counts   np array(name data tolist())     names deduped   np array(name data index tolist())      dataset   collections namedtuple( dataset     name    count  )     return dataset(names deduped  name counts)   def  letter number(letter)         converts letters numbers 1 27          ord lower case   97     return ord(letter)   96   def namignizer iterator(names  counts  batch size  num steps  epoch size)         takes list names counts like output read names      makes iterator yielding batch size num steps array random names     separated end name token  the names chosen randomly according     counts  the batch may end mid name      args          names  set lowercase names composed 26 characters         counts  list frequency names         batch size  int         num steps  int         epoch size  number batches yield     yields          (x  y)  batch size num steps array ints representing letters              x input target             name distribution   counts   counts sum()      range(epoch size)          data   np zeros(batch size   num steps   1)         samples   np random choice(names  size batch size   num steps    2                                     replace true  p name distribution)          data index   0         sample samples              data index    batch size   num steps                  break             letter map( letter number  sample)     eon                   data index    batch size   num steps                      break                 data data index    letter                 data index    1          x   data  batch size   num steps  reshape((batch size  num steps))           data 1 batch size   num steps   1  reshape((batch size  num steps))          yield (x  y)   def name batch(name  batch size  num steps)          takes single name fills batch      args          name  lowercase composed 26 characters         batch size  int         num steps  int     returns          x   batch size num steps array ints representing letters              x input target  the array filled             length string  rest filled zeros            copyright 2016 google inc  all rights reserved        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license           http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license     default end name rep zero    ord lower case   97 ", "content": "# Copyright 2016 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Utilities for parsing Kaggle baby names files.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport os\n\nimport numpy as np\nimport tensorflow as tf\nimport pandas as pd\n\n# the default end of name rep will be zero\n_EON = 0\n\n\ndef read_names(names_path):\n    \"\"\"read data from downloaded file. See SmallNames.txt for example format\n    or go to https://www.kaggle.com/kaggle/us-baby-names for full lists\n\n    Args:\n        names_path: path to the csv file similar to the example type\n    Returns:\n        Dataset: a namedtuple of two elements: deduped names and their associated\n            counts. The names contain only 26 chars and are all lower case\n    \"\"\"\n    names_data = pd.read_csv(names_path)\n    names_data.Name = names_data.Name.str.lower()\n\n    name_data = names_data.groupby(by=[\"Name\"])[\"Count\"].sum()\n    name_counts = np.array(name_data.tolist())\n    names_deduped = np.array(name_data.index.tolist())\n\n    Dataset = collections.namedtuple('Dataset', ['Name', 'Count'])\n    return Dataset(names_deduped, name_counts)\n\n\ndef _letter_to_number(letter):\n    \"\"\"converts letters to numbers between 1 and 27\"\"\"\n    # ord of lower case 'a' is 97\n    return ord(letter) - 96\n\n\ndef namignizer_iterator(names, counts, batch_size, num_steps, epoch_size):\n    \"\"\"Takes a list of names and counts like those output from read_names, and\n    makes an iterator yielding a batch_size by num_steps array of random names\n    separated by an end of name token. The names are chosen randomly according\n    to their counts. The batch may end mid-name\n\n    Args:\n        names: a set of lowercase names composed of 26 characters\n        counts: a list of the frequency of those names\n        batch_size: int\n        num_steps: int\n        epoch_size: number of batches to yield\n    Yields:\n        (x, y): a batch_size by num_steps array of ints representing letters, where\n            x will be the input and y will be the target\n    \"\"\"\n    name_distribution = counts / counts.sum()\n\n    for i in range(epoch_size):\n        data = np.zeros(batch_size * num_steps + 1)\n        samples = np.random.choice(names, size=batch_size * num_steps // 2,\n                                   replace=True, p=name_distribution)\n\n        data_index = 0\n        for sample in samples:\n            if data_index >= batch_size * num_steps:\n                break\n            for letter in map(_letter_to_number, sample) + [_EON]:\n                if data_index >= batch_size * num_steps:\n                    break\n                data[data_index] = letter\n                data_index += 1\n\n        x = data[:batch_size * num_steps].reshape((batch_size, num_steps))\n        y = data[1:batch_size * num_steps + 1].reshape((batch_size, num_steps))\n\n        yield (x, y)\n\n\ndef name_to_batch(name, batch_size, num_steps):\n    \"\"\" Takes a single name and fills a batch with it\n\n    Args:\n        name: lowercase composed of 26 characters\n        batch_size: int\n        num_steps: int\n    Returns:\n        x, y: a batch_size by num_steps array of ints representing letters, where\n            x will be the input and y will be the target. The array is filled up\n            to the length of the string, the rest is filled with zeros\n    \"\"\"\n    data = np.zeros(batch_size * num_steps + 1)\n\n    data_index = 0\n    for letter in map(_letter_to_number, name) + [_EON]:\n        data[data_index] = letter\n        data_index += 1\n\n    x = data[:batch_size * num_steps].reshape((batch_size, num_steps))\n    y = data[1:batch_size * num_steps + 1].reshape((batch_size, num_steps))\n\n    return x, y\n", "description": "Models and examples built with TensorFlow", "file_name": "data_utils.py", "id": "8807125eaa2eae4ca2a6660c3245966d", "language": "Python", "project_name": "models", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tensorflow-models/tensorflow-models-7e4c66b/research/namignizer/data_utils.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:59:36Z", "url": "https://github.com/tensorflow/models", "wiki": true}