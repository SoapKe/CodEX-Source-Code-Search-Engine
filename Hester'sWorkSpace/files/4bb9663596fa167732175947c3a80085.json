{"author": "powerline", "code": "\n_log = []\nvars = {}\nvvars = {'version': 703}\n_tabpage = 0\n_mode = 'n'\n_buf_purge_events = set()\noptions = {\n\t'paste': 0,\n\t'ambiwidth': 'single',\n\t'columns': 80,\n\t'encoding': 'utf-8',\n}\n_last_bufnr = 0\n_highlights = {}\nfrom collections import defaultdict as _defaultdict\n_environ = _defaultdict(lambda: '')\ndel _defaultdict\n\n\n_thread_id = None\n\n\ndef _set_thread_id():\n\tglobal _thread_id\n\tfrom threading import current_thread\n\t_thread_id = current_thread().ident\n\n\n\n_set_thread_id()\n\n\ndef _print_log():\n\tfor item in _log:\n\t\tprint (item)\n\t_log[:] = ()\n\n\ndef _vim(func):\n\tfrom functools import wraps\n\tfrom threading import current_thread\n\n\t@wraps(func)\n\tdef f(*args, **kwargs):\n\t\tglobal _thread_id\n\t\tif _thread_id != current_thread().ident:\n\t\t\traise RuntimeError('Accessing vim from separate threads is not allowed')\n\t\t_log.append((func.__name__, args))\n\t\treturn func(*args, **kwargs)\n\n\treturn f\n\n\ndef _unicode(func):\n\tfrom functools import wraps\n\timport sys\n\n\tif sys.version_info < (3,):\n\t\treturn func\n\n\t@wraps(func)\n\tdef f(*args, **kwargs):\n\t\tfrom powerline.lib.unicode import u\n\t\tret = func(*args, **kwargs)\n\t\tif isinstance(ret, bytes):\n\t\t\tret = u(ret)\n\t\treturn ret\n\n\treturn f\n\n\nclass _Buffers(object):\n\t@_vim\n\tdef __init__(self):\n\t\tself.d = {}\n\n\t@_vim\n\tdef __len__(self):\n\t\treturn len(self.d)\n\n\t@_vim\n\tdef __getitem__(self, item):\n\t\treturn self.d[item]\n\n\t@_vim\n\tdef __setitem__(self, item, value):\n\t\tself.d[item] = value\n\n\t@_vim\n\tdef __iter__(self):\n\t\treturn iter(self.d.values())\n\n\t@_vim\n\tdef __contains__(self, item):\n\t\treturn item in self.d\n\n\t@_vim\n\tdef _keys(self):\n\t\treturn self.d.keys()\n\n\t@_vim\n\tdef _pop(self, *args, **kwargs):\n\t\treturn self.d.pop(*args, **kwargs)\n\n\nbuffers = _Buffers()\n\n\nclass _ObjList(object):\n\t@_vim\n\tdef __init__(self, objtype):\n\t\tself.l = []\n\t\tself.objtype = objtype\n\n\t@_vim\n\tdef __getitem__(self, item):\n\t\treturn self.l[item - int(item > 0)]\n\n\t@_vim\n\tdef __len__(self):\n\t\treturn len(self.l)\n\n\t@_vim\n\tdef __iter__(self):\n\t\treturn iter(self.l)\n\n\t@_vim\n\tdef _pop(self, idx):\n\t\tobj = self.l.pop(idx - 1)\n\t\tfor moved_obj in self.l[idx - 1:]:\n\t\t\tmoved_obj.number -= 1\n\t\treturn obj\n\n\t@_vim\n\tdef _append(self, *args, **kwargs):\n\t\treturn self.l.append(*args, **kwargs)\n\n\t@_vim\n\tdef _new(self, *args, **kwargs):\n\t\tnumber = len(self) + 1\n\t\tnew_obj = self.objtype(number, *args, **kwargs)\n\t\tself._append(new_obj)\n\t\treturn new_obj\n\n\ndef _construct_result(r):\n\timport sys\n\tif sys.version_info < (3,):\n\t\treturn r\n\telse:\n\t\tif isinstance(r, str):\n\t\t\treturn r.encode('utf-8')\n\t\telif isinstance(r, list):\n\t\t\treturn [_construct_result(i) for i in r]\n\t\telif isinstance(r, dict):\n\t\t\treturn dict((\n\t\t\t\t(_construct_result(k), _construct_result(v))\n\t\t\t\tfor k, v in r.items()\n\t\t\t))\n\t\treturn r\n\n\ndef _str_func(func):\n\tfrom functools import wraps\n\n\t@wraps(func)\n\tdef f(*args, **kwargs):\n\t\treturn _construct_result(func(*args, **kwargs))\n\treturn f\n\n\ndef _log_print():\n\timport sys\n\tfor entry in _log:\n\t\tsys.stdout.write(repr(entry) + '\\n')\n\n\n_current_group = None\n_on_wipeout = []\n\n\n@_vim\ndef command(cmd):\n\tglobal _current_group\n\tcmd = cmd.lstrip()\n\tif cmd.startswith('let g:'):\n\t\timport re\n\t\tvarname, value = re.compile(r'^let g:(\\w+)\\s*=\\s*(.*)').match(cmd).groups()\n\t\tvars[varname] = value\n\telif cmd.startswith('hi '):\n\t\tsp = cmd.split()\n\t\t_highlights[sp[1]] = sp[2:]\n\telif cmd.startswith('augroup'):\n\t\taugroup = cmd.partition(' ')[2]\n\t\tif augroup.upper() == 'END':\n\t\t\t_current_group = None\n\t\telse:\n\t\t\t_current_group = augroup\n\telif cmd.startswith('autocmd'):\n\t\trest = cmd.partition(' ')[2]\n\t\tauevent, rest = rest.partition(' ')[::2]\n\t\tpattern, aucmd = rest.partition(' ')[::2]\n\t\tif auevent != 'BufWipeout' or pattern != '*':\n\t\t\traise NotImplementedError\n\t\timport sys\n\t\tif sys.version_info < (3,):\n\t\t\tif not aucmd.startswith(':python '):\n\t\t\t\traise NotImplementedError\n\t\telse:\n\t\t\tif not aucmd.startswith(':python3 '):\n\t\t\t\traise NotImplementedError\n\t\t_on_wipeout.append(aucmd.partition(' ')[2])\n\telif cmd.startswith('set '):\n\t\tif cmd.startswith('set statusline='):\n\t\t\toptions['statusline'] = cmd[len('set statusline='):]\n\t\telif cmd.startswith('set tabline='):\n\t\t\toptions['tabline'] = cmd[len('set tabline='):]\n\t\telse:\n\t\t\traise NotImplementedError(cmd)\n\telse:\n\t\traise NotImplementedError(cmd)\n\n\n@_vim\n@_unicode\ndef eval(expr):\n\tif expr.startswith('g:'):\n\t\treturn vars[expr[2:]]\n\telif expr.startswith('v:'):\n\t\treturn vvars[expr[2:]]\n\telif expr.startswith('&'):\n\t\treturn options[expr[1:]]\n\telif expr.startswith('$'):\n\t\treturn _environ[expr[1:]]\n\telif expr.startswith('PowerlineRegisterCachePurgerEvent'):\n\t\t_buf_purge_events.add(expr[expr.find('\"') + 1:expr.rfind('\"') - 1])\n\t\treturn '0'\n\telif expr.startswith('exists('):\n\t\treturn '0'\n\telif expr.startswith('getwinvar('):\n\t\timport re\n\t\tmatch = re.match(r'^getwinvar\\((\\d+), \"(\\w+)\"\\)$', expr)\n\t\tif not match:\n\t\t\traise NotImplementedError(expr)\n\t\twinnr = int(match.group(1))\n\t\tvarname = match.group(2)\n\t\treturn _emul_getwinvar(winnr, varname)\n\telif expr.startswith('has_key('):\n\t\timport re\n\t\tmatch = re.match(r'^has_key\\(getwinvar\\((\\d+), \"\"\\), \"(\\w+)\"\\)$', expr)\n\t\tif match:\n\t\t\twinnr = int(match.group(1))\n\t\t\tvarname = match.group(2)\n\t\t\treturn 0 + (varname in current.tabpage.windows[winnr].vars)\n\t\telse:\n\t\t\tmatch = re.match(r'^has_key\\(gettabwinvar\\((\\d+), (\\d+), \"\"\\), \"(\\w+)\"\\)$', expr)\n\t\t\tif not match:\n\t\t\t\traise NotImplementedError(expr)\n\t\t\ttabnr = int(match.group(1))\n\t\t\twinnr = int(match.group(2))\n\t\t\tvarname = match.group(3)\n\t\t\treturn 0 + (varname in tabpages[tabnr].windows[winnr].vars)\n\telif expr == 'getbufvar(\"%\", \"NERDTreeRoot\").path.str()':\n\t\timport os\n\t\tassert os.path.basename(current.buffer.name).startswith('NERD_tree_')\n\t\treturn '/usr/include'\n\telif expr.startswith('getbufvar('):\n\t\timport re\n\t\tmatch = re.match(r'^getbufvar\\((\\d+), [\"\\'](.+)[\"\\']\\)$', expr)\n\t\tif not match:\n\t\t\traise NotImplementedError(expr)\n\t\tbufnr = int(match.group(1))\n\t\tvarname = match.group(2)\n\t\treturn _emul_getbufvar(bufnr, varname)\n\telif expr == 'tabpagenr()':\n\t\treturn current.tabpage.number\n\telif expr == 'tabpagenr(\"$\")':\n\t\treturn len(tabpages)\n\telif expr.startswith('tabpagewinnr('):\n\t\ttabnr = int(expr[len('tabpagewinnr('):-1])\n\t\treturn tabpages[tabnr].window.number\n\telif expr.startswith('tabpagebuflist('):\n\t\timport re\n\t\tmatch = re.match(r'tabpagebuflist\\((\\d+)\\)\\[(\\d+)\\]', expr)\n\t\ttabnr = int(match.group(1))\n\t\twinnr = int(match.group(2)) + 1\n\t\treturn tabpages[tabnr].windows[winnr].buffer.number\n\telif expr.startswith('gettabwinvar('):\n\t\timport re\n\t\tmatch = re.match(r'gettabwinvar\\((\\d+), (\\d+), \"(\\w+)\"\\)', expr)\n\t\ttabnr = int(match.group(1))\n\t\twinnr = int(match.group(2))\n\t\tvarname = match.group(3)\n\t\treturn tabpages[tabnr].windows[winnr].vars[varname]\n\telif expr.startswith('type(function('):\n\t\timport re\n\t\tmatch = re.match(r'^type\\(function\\(\"([^\"]+)\"\\)\\) == 2$', expr)\n\t\tif not match:\n\t\t\traise NotImplementedError(expr)\n\t\treturn 0\n\traise NotImplementedError(expr)\n\n\n@_vim\ndef bindeval(expr):\n\tif expr == 'g:':\n\t\treturn vars\n\telif expr == '{}':\n\t\treturn {}\n\telif expr == '[]':\n\t\treturn []\n\timport re\n\tmatch = re.compile(r'^function\\(\"([^\"\\\\]+)\"\\)$').match(expr)\n\tif match:\n\t\treturn globals()['_emul_' + match.group(1)]\n\telse:\n\t\traise NotImplementedError\n\n\n@_vim\n@_str_func\ndef _emul_mode(*args):\n\tif args and args[0]:\n\t\treturn _mode\n\telse:\n\t\treturn _mode[0]\n\n\n@_vim\n@_str_func\ndef _emul_getbufvar(bufnr, varname):\n\timport re\n\tif varname[0] == '&':\n\t\tif bufnr == '%':\n\t\t\tbufnr = current.buffer.number\n\t\tif bufnr not in buffers:\n\t\t\treturn ''\n\t\ttry:\n\t\t\treturn buffers[bufnr].options[varname[1:]]\n\t\texcept KeyError:\n\t\t\ttry:\n\t\t\t\treturn options[varname[1:]]\n\t\t\texcept KeyError:\n\t\t\t\treturn ''\n\telif re.match('^[a-zA-Z_]+$', varname):\n\t\tif bufnr == '%':\n\t\t\tbufnr = current.buffer.number\n\t\tif bufnr not in buffers:\n\t\t\treturn ''\n\t\treturn buffers[bufnr].vars[varname]\n\traise NotImplementedError\n\n\n@_vim\n@_str_func\ndef _emul_getwinvar(winnr, varname):\n\treturn current.tabpage.windows[winnr].vars.get(varname, '')\n\n\n@_vim\ndef _emul_setwinvar(winnr, varname, value):\n\tcurrent.tabpage.windows[winnr].vars[varname] = value\n\n\n@_vim\ndef _emul_virtcol(expr):\n\tif expr == '.':\n\t\treturn current.window.cursor[1] + 1\n\tif isinstance(expr, list) and len(expr) == 3:\n\t\treturn expr[-2] + expr[-1]\n\traise NotImplementedError\n\n\n_v_pos = None\n\n\n@_vim\ndef _emul_getpos(expr):\n\tif expr == '.':\n\t\treturn [0, current.window.cursor[0] + 1, current.window.cursor[1] + 1, 0]\n\tif expr == 'v':\n\t\treturn _v_pos or [0, current.window.cursor[0] + 1, current.window.cursor[1] + 1, 0]\n\traise NotImplementedError\n\n\n@_vim\n@_str_func\ndef _emul_fnamemodify(path, modstring):\n\timport os\n\t_modifiers = {\n\t\t'~': lambda path: path.replace(os.environ['HOME'].encode('utf-8'), b'~') if path.startswith(os.environ['HOME'].encode('utf-8')) else path,\n\t\t'.': lambda path: (lambda tpath: path if tpath[:3] == b'..' + os.sep.encode() else tpath)(os.path.relpath(path)),\n\t\t't': lambda path: os.path.basename(path),\n\t\t'h': lambda path: os.path.dirname(path),\n\t}\n\n\tfor mods in modstring.split(':')[1:]:\n\t\tpath = _modifiers[mods](path)\n\treturn path\n\n\n@_vim\n@_str_func\ndef _emul_expand(expr):\n\tglobal _abuf\n\tif expr == '<abuf>':\n\t\treturn _abuf or current.buffer.number\n\traise NotImplementedError\n\n\n@_vim\ndef _emul_bufnr(expr):\n\tif expr == '$':\n\t\treturn _last_bufnr\n\traise NotImplementedError\n\n\n@_vim\ndef _emul_exists(ident):\n\tif ident.startswith('g:'):\n\t\treturn ident[2:] in vars\n\telif ident.startswith(':'):\n\t\treturn 0\n\traise NotImplementedError\n\n\n@_vim\ndef _emul_line2byte(line):\n\tbuflines = current.buffer._buf_lines\n\tif line == len(buflines) + 1:\n\t\treturn sum((len(s) for s in buflines)) + 1\n\traise NotImplementedError\n\n\n@_vim\ndef _emul_line(expr):\n\tcursorline = current.window.cursor[0] + 1\n\tnumlines = len(current.buffer._buf_lines)\n\tif expr == 'w0':\n\t\treturn max(cursorline - 5, 1)\n\tif expr == 'w$':\n\t\treturn min(cursorline + 5, numlines)\n\traise NotImplementedError\n\n\n@_vim\n@_str_func\ndef _emul_strtrans(s):\n\t\n\treturn s.replace(b'\\xFF', b'<ff>')\n\n\n@_vim\n@_str_func\ndef _emul_bufname(bufnr):\n\ttry:\n\t\treturn buffers[bufnr]._name or b''\n\texcept KeyError:\n\t\treturn b''\n\n\n_window_id = 0\n\n\nclass _Window(object):\n\tdef __init__(self, number, buffer=None, cursor=(1, 0), width=80):\n\t\tglobal _window_id\n\t\tself.cursor = cursor\n\t\tself.width = width\n\t\tself.number = number\n\t\tif buffer:\n\t\t\tif type(buffer) is _Buffer:\n\t\t\t\tself.buffer = buffer\n\t\t\telse:\n\t\t\t\tself.buffer = _Buffer(**buffer)\n\t\telse:\n\t\t\tself.buffer = _Buffer()\n\t\t_window_id += 1\n\t\tself._window_id = _window_id\n\t\tself.options = {}\n\t\tself.vars = {\n\t\t\t'powerline_window_id': self._window_id,\n\t\t}\n\n\tdef __repr__(self):\n\t\treturn '<window ' + str(self.number - 1) + '>'\n\n\nclass _Tabpage(object):\n\tdef __init__(self, number):\n\t\tself.windows = _ObjList(_Window)\n\t\tself.number = number\n\n\tdef _new_window(self, **kwargs):\n\t\tself.window = self.windows._new(**kwargs)\n\t\treturn self.window\n\n\tdef _close_window(self, winnr, open_window=True):\n\t\tcurwinnr = self.window.number\n\t\twin = self.windows._pop(winnr)\n\t\tif self.windows and winnr == curwinnr:\n\t\t\tself.window = self.windows[-1]\n\t\telif open_window:\n\t\t\tcurrent.tabpage._new_window()\n\t\treturn win\n\n\tdef _close(self):\n\t\tglobal _tabpage\n\t\twhile self.windows:\n\t\t\tself._close_window(1, False)\n\t\ttabpages._pop(self.number)\n\t\t_tabpage = len(tabpages)\n\n\ntabpages = _ObjList(_Tabpage)\n\n\n_abuf = None\n\n\nclass _Buffer(object):\n\tdef __init__(self, name=None):\n\t\tglobal _last_bufnr\n\t\t_last_bufnr += 1\n\t\tbufnr = _last_bufnr\n\t\tself.number = bufnr\n\t\t# FIXME Use unicode() for python-3\n\t\tself.name = name\n\t\tself.vars = {'changedtick': 1}\n\t\tself.options = {\n\t\t\t'modified': 0,\n\t\t\t'readonly': 0,\n\t\t\t'fileformat': 'unix',\n\t\t\t'filetype': '',\n\t\t\t'buftype': '',\n\t\t\t'fileencoding': 'utf-8',\n\t\t\t'textwidth': 80,\n\t\t}\n\t\tself._buf_lines = ['']\n\t\tself._undostate = [self._buf_lines[:]]\n\t\tself._undo_written = len(self._undostate)\n\t\tbuffers[bufnr] = self\n\n\t@property\n\tdef name(self):\n\t\timport sys\n\t\tif sys.version_info < (3,):\n\t\t\treturn self._name\n\t\telse:\n\t\t\treturn str(self._name, 'utf-8') if self._name else None\n\n\t@name.setter\n\tdef name(self, name):\n\t\tif name is None:\n\t\t\tself._name = None\n\t\telse:\n\t\t\timport os\n\t\t\tif type(name) is not bytes:\n\t\t\t\tname = name.encode('utf-8')\n\t\t\tif b':/' in name:\n\t\t\t\tself._name = name\n\t\t\telse:\n\t\t\t\tself._name = os.path.abspath(name)\n\n\tdef __getitem__(self, line):\n\t\treturn self._buf_lines[line]\n\n\tdef __setitem__(self, line, value):\n\t\tself.options['modified'] = 1\n\t\tself.vars['changedtick'] += 1\n\t\tself._buf_lines[line] = value\n\t\tfrom copy import copy\n\t\tself._undostate.append(copy(self._buf_lines))\n\n\tdef __setslice__(self, *args):\n\t\tself.options['modified'] = 1\n\t\tself.vars['changedtick'] += 1\n\t\tself._buf_lines.__setslice__(*args)\n\t\tfrom copy import copy\n\t\tself._undostate.append(copy(self._buf_lines))\n\n\tdef __getslice__(self, *args):\n\t\treturn self._buf_lines.__getslice__(*args)\n\n\tdef __len__(self):\n\t\treturn len(self._buf_lines)\n\n\tdef __repr__(self):\n\t\treturn '<buffer ' + str(self.name) + '>'\n\n\tdef __del__(self):\n\t\tglobal _abuf\n\t\tbufnr = self.number\n\t\ttry:\n\t\t\timport __main__\n\t\texcept ImportError:\n\t\t\tpass\n\t\texcept RuntimeError:\n\t\t\t\n\t\t\tpass\n\t\telse:\n\t\t\tif _on_wipeout:\n\t\t\t\t_abuf = bufnr\n\t\t\t\ttry:\n\t\t\t\t\tfor event in _on_wipeout:\n\t\t\t\t\t\texec(event, __main__.__dict__)\n\t\t\t\tfinally:\n\t\t\t\t\t_abuf = None\n\n\nclass _Current(object):\n\t@property\n\tdef buffer(self):\n\t\treturn self.window.buffer\n\n\t@property\n\tdef window(self):\n\t\treturn self.tabpage.window\n\n\t@property\n\tdef tabpage(self):\n\t\treturn tabpages[_tabpage - 1]\n\n\ncurrent = _Current()\n\n\n_dict = None\n\n\n@_vim\ndef _init():\n\tglobal _dict\n\n\tif _dict:\n\t\treturn _dict\n\n\t_dict = {}\n\tfor varname, value in globals().items():\n\t\tif varname[0] != '_':\n\t\t\t_dict[varname] = value\n\t_tabnew()\n\treturn _dict\n\n\n@_vim\ndef _get_segment_info():\n\tmode_translations = {\n\t\tchr(ord('V') - 0x40): '^V',\n\t\tchr(ord('S') - 0x40): '^S',\n\t}\n\tmode = _mode\n\tmode = mode_translations.get(mode, mode)\n\twindow = current.window\n\tbuffer = current.buffer\n\ttabpage = current.tabpage\n\treturn {\n\t\t'window': window,\n\t\t'winnr': window.number,\n\t\t'buffer': buffer,\n\t\t'bufnr': buffer.number,\n\t\t'tabpage': tabpage,\n\t\t'tabnr': tabpage.number,\n\t\t'window_id': window._window_id,\n\t\t'mode': mode,\n\t\t'encoding': options['encoding'],\n\t}\n\n\n@_vim\ndef _launch_event(event):\n\tpass\n\n\n@_vim\ndef _start_mode(mode):\n\tglobal _mode\n\tif mode == 'i':\n\t\t_launch_event('InsertEnter')\n\telif _mode == 'i':\n\t\t_launch_event('InsertLeave')\n\t_mode = mode\n\n\n@_vim\ndef _undo():\n\tif len(current.buffer._undostate) == 1:\n\t\treturn\n\tbuffer = current.buffer\n\tbuffer._undostate.pop(-1)\n\tbuffer._buf_lines = buffer._undostate[-1]\n\tif buffer._undo_written == len(buffer._undostate):\n\t\tbuffer.options['modified'] = 0\n\n\n@_vim\ndef _edit(name=None):\n\tif current.buffer.name is None:\n\t\tbuffer = current.buffer\n\t\tbuffer.name = name\n\telse:\n\t\tbuffer = _Buffer(name)\n\t\tcurrent.window.buffer = buffer\n\n\n@_vim\ndef _tabnew(name=None):\n\tglobal windows\n\tglobal _tabpage\n\ttabpage = tabpages._new()\n\twindows = tabpage.windows\n\t_tabpage = len(tabpages)\n\t_new(name)\n\treturn tabpage\n\n\n@_vim\ndef _new(name=None):\n\tcurrent.tabpage._new_window(buffer={'name': name})\n\n\n@_vim\ndef _split():\n\tcurrent.tabpage._new_window(buffer=current.buffer)\n\n\n@_vim\ndef _close(winnr, wipe=True):\n\twin = current.tabpage._close_window(winnr)\n\tif wipe:\n\t\tfor w in current.tabpage.windows:\n\t\t\tif w.buffer.number == win.buffer.number:\n\t\t\t\tbreak\n\t\telse:\n\t\t\t_bw(win.buffer.number)\n\n\n@_vim\ndef _bw(bufnr=None):\n\tbufnr = bufnr or current.buffer.number\n\twinnr = 1\n\tfor win in current.tabpage.windows:\n\t\tif win.buffer.number == bufnr:\n\t\t\t_close(winnr, wipe=False)\n\t\twinnr += 1\n\tbuffers._pop(bufnr)\n\tif not buffers:\n\t\t_Buffer()\n\t_b(max(buffers._keys()))\n\n\n@_vim\ndef _b(bufnr):\n\tcurrent.window.buffer = buffers[bufnr]\n\n\n@_vim\ndef _set_cursor(line, col):\n\tcurrent.window.cursor = (line, col)\n\tif _mode == 'n':\n\t\t_launch_event('CursorMoved')\n\telif _mode == 'i':\n\t\t_launch_event('CursorMovedI')\n\n\n@_vim\ndef _get_buffer():\n\treturn current.buffer\n\n\n@_vim\ndef _set_bufoption(option, value, bufnr=None):\n\tbuffers[bufnr or current.buffer.number].options[option] = value\n\tif option == 'filetype':\n\t\t_launch_event('FileType')\n\n\nclass _WithNewBuffer(object):\n\tdef __init__(self, func, *args, **kwargs):\n\t\tself.call = lambda: func(*args, **kwargs)\n\n\tdef __enter__(self):\n\t\tself.call()\n\t\tself.bufnr = current.buffer.number\n\t\treturn _get_segment_info()\n\n\tdef __exit__(self, *args):\n\t\t_bw(self.bufnr)\n\n\n@_vim\ndef _set_dict(d, new, setfunc=None):\n\tif not setfunc:\n\t\tdef setfunc(k, v):\n\t\t\td[k] = v\n\n\told = {}\n\tna = []\n\tfor k, v in new.items():\n\t\ttry:\n\t\t\told[k] = d[k]\n\t\texcept KeyError:\n\t\t\tna.append(k)\n\t\tsetfunc(k, v)\n\treturn old, na\n\n\nclass _WithBufOption(object):\n\tdef __init__(self, **new):\n\t\tself.new = new\n\n\tdef __enter__(self):\n\t\tself.buffer = current.buffer\n\t\tself.old = _set_dict(self.buffer.options, self.new, _set_bufoption)[0]\n\n\tdef __exit__(self, *args):\n\t\tself.buffer.options.update(self.old)\n\n\nclass _WithMode(object):\n\tdef __init__(self, new):\n\t\tself.new = new\n\n\tdef __enter__(self):\n\t\tself.old = _mode\n\t\t_start_mode(self.new)\n\t\treturn _get_segment_info()\n\n\tdef __exit__(self, *args):\n\t\t_start_mode(self.old)\n\n\nclass _WithDict(object):\n\tdef __init__(self, d, **new):\n\t\tself.new = new\n\t\tself.d = d\n\n\tdef __enter__(self):\n\t\tself.old, self.na = _set_dict(self.d, self.new)\n\n\tdef __exit__(self, *args):\n\t\tself.d.update(self.old)\n\t\tfor k in self.na:\n\t\t\tself.d.pop(k)\n\n\nclass _WithSplit(object):\n\tdef __enter__(self):\n\t\t_split()\n\n\tdef __exit__(self, *args):\n\t\t_close(2, wipe=False)\n\n\nclass _WithBufName(object):\n\tdef __init__(self, new):\n\t\tself.new = new\n\n\tdef __enter__(self):\n\t\timport os\n\t\tbuffer = current.buffer\n\t\tself.buffer = buffer\n\t\tself.old = buffer.name\n\t\tbuffer.name = self.new\n\n\tdef __exit__(self, *args):\n\t\tself.buffer.name = self.old\n\n\nclass _WithNewTabPage(object):\n\tdef __init__(self, *args, **kwargs):\n\t\tself.args = args\n\t\tself.kwargs = kwargs\n\n\tdef __enter__(self):\n\t\tself.tab = _tabnew(*self.args, **self.kwargs)\n\n\tdef __exit__(self, *args):\n\t\tself.tab._close()\n\n\nclass _WithGlobal(object):\n\tdef __init__(self, **kwargs):\n\t\tself.kwargs = kwargs\n\n\tdef __enter__(self):\n\t\tself.empty = object()\n\t\tself.old = dict(((key, globals().get(key, self.empty)) for key in self.kwargs))\n\t\tglobals().update(self.kwargs)\n\n\tdef __exit__(self, *args):\n\t\tfor k, v in self.old.items():\n\t\t\tif v is self.empty:\n\t\t\t\tglobals().pop(k, None)\n\t\t\telse:\n\t\t\t\tglobals()[k] = v\n\n\n@_vim\ndef _with(key, *args, **kwargs):\n\tif key == 'buffer':\n\t\treturn _WithNewBuffer(_edit, *args, **kwargs)\n\telif key == 'bufname':\n\t\treturn _WithBufName(*args, **kwargs)\n\telif key == 'mode':\n\t\treturn _WithMode(*args, **kwargs)\n\telif key == 'bufoptions':\n\t\treturn _WithBufOption(**kwargs)\n\telif key == 'options':\n\t\treturn _WithDict(options, **kwargs)\n\telif key == 'globals':\n\t\treturn _WithDict(vars, **kwargs)\n\telif key == 'wvars':\n\t\treturn _WithDict(current.window.vars, **kwargs)\n\telif key == 'environ':\n\t\treturn _WithDict(_environ, **kwargs)\n\telif key == 'split':\n\t\treturn _WithSplit()\n\telif key == 'tabpage':\n\t\treturn _WithNewTabPage(*args, **kwargs)\n\telif key == 'vpos':\n\t\treturn _WithGlobal(_v_pos=[0, kwargs['line'], kwargs['col'], kwargs['off']])\n\n\nclass error(Exception):\n\tpass\n", "comments": "  vim fileencoding utf 8 noet    assuming import done main thread    fixme do replaces    fixme use unicode() python 3    module may already garbage collected ", "content": "# vim:fileencoding=utf-8:noet\n_log = []\nvars = {}\nvvars = {'version': 703}\n_tabpage = 0\n_mode = 'n'\n_buf_purge_events = set()\noptions = {\n\t'paste': 0,\n\t'ambiwidth': 'single',\n\t'columns': 80,\n\t'encoding': 'utf-8',\n}\n_last_bufnr = 0\n_highlights = {}\nfrom collections import defaultdict as _defaultdict\n_environ = _defaultdict(lambda: '')\ndel _defaultdict\n\n\n_thread_id = None\n\n\ndef _set_thread_id():\n\tglobal _thread_id\n\tfrom threading import current_thread\n\t_thread_id = current_thread().ident\n\n\n# Assuming import is done from the main thread\n_set_thread_id()\n\n\ndef _print_log():\n\tfor item in _log:\n\t\tprint (item)\n\t_log[:] = ()\n\n\ndef _vim(func):\n\tfrom functools import wraps\n\tfrom threading import current_thread\n\n\t@wraps(func)\n\tdef f(*args, **kwargs):\n\t\tglobal _thread_id\n\t\tif _thread_id != current_thread().ident:\n\t\t\traise RuntimeError('Accessing vim from separate threads is not allowed')\n\t\t_log.append((func.__name__, args))\n\t\treturn func(*args, **kwargs)\n\n\treturn f\n\n\ndef _unicode(func):\n\tfrom functools import wraps\n\timport sys\n\n\tif sys.version_info < (3,):\n\t\treturn func\n\n\t@wraps(func)\n\tdef f(*args, **kwargs):\n\t\tfrom powerline.lib.unicode import u\n\t\tret = func(*args, **kwargs)\n\t\tif isinstance(ret, bytes):\n\t\t\tret = u(ret)\n\t\treturn ret\n\n\treturn f\n\n\nclass _Buffers(object):\n\t@_vim\n\tdef __init__(self):\n\t\tself.d = {}\n\n\t@_vim\n\tdef __len__(self):\n\t\treturn len(self.d)\n\n\t@_vim\n\tdef __getitem__(self, item):\n\t\treturn self.d[item]\n\n\t@_vim\n\tdef __setitem__(self, item, value):\n\t\tself.d[item] = value\n\n\t@_vim\n\tdef __iter__(self):\n\t\treturn iter(self.d.values())\n\n\t@_vim\n\tdef __contains__(self, item):\n\t\treturn item in self.d\n\n\t@_vim\n\tdef _keys(self):\n\t\treturn self.d.keys()\n\n\t@_vim\n\tdef _pop(self, *args, **kwargs):\n\t\treturn self.d.pop(*args, **kwargs)\n\n\nbuffers = _Buffers()\n\n\nclass _ObjList(object):\n\t@_vim\n\tdef __init__(self, objtype):\n\t\tself.l = []\n\t\tself.objtype = objtype\n\n\t@_vim\n\tdef __getitem__(self, item):\n\t\treturn self.l[item - int(item > 0)]\n\n\t@_vim\n\tdef __len__(self):\n\t\treturn len(self.l)\n\n\t@_vim\n\tdef __iter__(self):\n\t\treturn iter(self.l)\n\n\t@_vim\n\tdef _pop(self, idx):\n\t\tobj = self.l.pop(idx - 1)\n\t\tfor moved_obj in self.l[idx - 1:]:\n\t\t\tmoved_obj.number -= 1\n\t\treturn obj\n\n\t@_vim\n\tdef _append(self, *args, **kwargs):\n\t\treturn self.l.append(*args, **kwargs)\n\n\t@_vim\n\tdef _new(self, *args, **kwargs):\n\t\tnumber = len(self) + 1\n\t\tnew_obj = self.objtype(number, *args, **kwargs)\n\t\tself._append(new_obj)\n\t\treturn new_obj\n\n\ndef _construct_result(r):\n\timport sys\n\tif sys.version_info < (3,):\n\t\treturn r\n\telse:\n\t\tif isinstance(r, str):\n\t\t\treturn r.encode('utf-8')\n\t\telif isinstance(r, list):\n\t\t\treturn [_construct_result(i) for i in r]\n\t\telif isinstance(r, dict):\n\t\t\treturn dict((\n\t\t\t\t(_construct_result(k), _construct_result(v))\n\t\t\t\tfor k, v in r.items()\n\t\t\t))\n\t\treturn r\n\n\ndef _str_func(func):\n\tfrom functools import wraps\n\n\t@wraps(func)\n\tdef f(*args, **kwargs):\n\t\treturn _construct_result(func(*args, **kwargs))\n\treturn f\n\n\ndef _log_print():\n\timport sys\n\tfor entry in _log:\n\t\tsys.stdout.write(repr(entry) + '\\n')\n\n\n_current_group = None\n_on_wipeout = []\n\n\n@_vim\ndef command(cmd):\n\tglobal _current_group\n\tcmd = cmd.lstrip()\n\tif cmd.startswith('let g:'):\n\t\timport re\n\t\tvarname, value = re.compile(r'^let g:(\\w+)\\s*=\\s*(.*)').match(cmd).groups()\n\t\tvars[varname] = value\n\telif cmd.startswith('hi '):\n\t\tsp = cmd.split()\n\t\t_highlights[sp[1]] = sp[2:]\n\telif cmd.startswith('augroup'):\n\t\taugroup = cmd.partition(' ')[2]\n\t\tif augroup.upper() == 'END':\n\t\t\t_current_group = None\n\t\telse:\n\t\t\t_current_group = augroup\n\telif cmd.startswith('autocmd'):\n\t\trest = cmd.partition(' ')[2]\n\t\tauevent, rest = rest.partition(' ')[::2]\n\t\tpattern, aucmd = rest.partition(' ')[::2]\n\t\tif auevent != 'BufWipeout' or pattern != '*':\n\t\t\traise NotImplementedError\n\t\timport sys\n\t\tif sys.version_info < (3,):\n\t\t\tif not aucmd.startswith(':python '):\n\t\t\t\traise NotImplementedError\n\t\telse:\n\t\t\tif not aucmd.startswith(':python3 '):\n\t\t\t\traise NotImplementedError\n\t\t_on_wipeout.append(aucmd.partition(' ')[2])\n\telif cmd.startswith('set '):\n\t\tif cmd.startswith('set statusline='):\n\t\t\toptions['statusline'] = cmd[len('set statusline='):]\n\t\telif cmd.startswith('set tabline='):\n\t\t\toptions['tabline'] = cmd[len('set tabline='):]\n\t\telse:\n\t\t\traise NotImplementedError(cmd)\n\telse:\n\t\traise NotImplementedError(cmd)\n\n\n@_vim\n@_unicode\ndef eval(expr):\n\tif expr.startswith('g:'):\n\t\treturn vars[expr[2:]]\n\telif expr.startswith('v:'):\n\t\treturn vvars[expr[2:]]\n\telif expr.startswith('&'):\n\t\treturn options[expr[1:]]\n\telif expr.startswith('$'):\n\t\treturn _environ[expr[1:]]\n\telif expr.startswith('PowerlineRegisterCachePurgerEvent'):\n\t\t_buf_purge_events.add(expr[expr.find('\"') + 1:expr.rfind('\"') - 1])\n\t\treturn '0'\n\telif expr.startswith('exists('):\n\t\treturn '0'\n\telif expr.startswith('getwinvar('):\n\t\timport re\n\t\tmatch = re.match(r'^getwinvar\\((\\d+), \"(\\w+)\"\\)$', expr)\n\t\tif not match:\n\t\t\traise NotImplementedError(expr)\n\t\twinnr = int(match.group(1))\n\t\tvarname = match.group(2)\n\t\treturn _emul_getwinvar(winnr, varname)\n\telif expr.startswith('has_key('):\n\t\timport re\n\t\tmatch = re.match(r'^has_key\\(getwinvar\\((\\d+), \"\"\\), \"(\\w+)\"\\)$', expr)\n\t\tif match:\n\t\t\twinnr = int(match.group(1))\n\t\t\tvarname = match.group(2)\n\t\t\treturn 0 + (varname in current.tabpage.windows[winnr].vars)\n\t\telse:\n\t\t\tmatch = re.match(r'^has_key\\(gettabwinvar\\((\\d+), (\\d+), \"\"\\), \"(\\w+)\"\\)$', expr)\n\t\t\tif not match:\n\t\t\t\traise NotImplementedError(expr)\n\t\t\ttabnr = int(match.group(1))\n\t\t\twinnr = int(match.group(2))\n\t\t\tvarname = match.group(3)\n\t\t\treturn 0 + (varname in tabpages[tabnr].windows[winnr].vars)\n\telif expr == 'getbufvar(\"%\", \"NERDTreeRoot\").path.str()':\n\t\timport os\n\t\tassert os.path.basename(current.buffer.name).startswith('NERD_tree_')\n\t\treturn '/usr/include'\n\telif expr.startswith('getbufvar('):\n\t\timport re\n\t\tmatch = re.match(r'^getbufvar\\((\\d+), [\"\\'](.+)[\"\\']\\)$', expr)\n\t\tif not match:\n\t\t\traise NotImplementedError(expr)\n\t\tbufnr = int(match.group(1))\n\t\tvarname = match.group(2)\n\t\treturn _emul_getbufvar(bufnr, varname)\n\telif expr == 'tabpagenr()':\n\t\treturn current.tabpage.number\n\telif expr == 'tabpagenr(\"$\")':\n\t\treturn len(tabpages)\n\telif expr.startswith('tabpagewinnr('):\n\t\ttabnr = int(expr[len('tabpagewinnr('):-1])\n\t\treturn tabpages[tabnr].window.number\n\telif expr.startswith('tabpagebuflist('):\n\t\timport re\n\t\tmatch = re.match(r'tabpagebuflist\\((\\d+)\\)\\[(\\d+)\\]', expr)\n\t\ttabnr = int(match.group(1))\n\t\twinnr = int(match.group(2)) + 1\n\t\treturn tabpages[tabnr].windows[winnr].buffer.number\n\telif expr.startswith('gettabwinvar('):\n\t\timport re\n\t\tmatch = re.match(r'gettabwinvar\\((\\d+), (\\d+), \"(\\w+)\"\\)', expr)\n\t\ttabnr = int(match.group(1))\n\t\twinnr = int(match.group(2))\n\t\tvarname = match.group(3)\n\t\treturn tabpages[tabnr].windows[winnr].vars[varname]\n\telif expr.startswith('type(function('):\n\t\timport re\n\t\tmatch = re.match(r'^type\\(function\\(\"([^\"]+)\"\\)\\) == 2$', expr)\n\t\tif not match:\n\t\t\traise NotImplementedError(expr)\n\t\treturn 0\n\traise NotImplementedError(expr)\n\n\n@_vim\ndef bindeval(expr):\n\tif expr == 'g:':\n\t\treturn vars\n\telif expr == '{}':\n\t\treturn {}\n\telif expr == '[]':\n\t\treturn []\n\timport re\n\tmatch = re.compile(r'^function\\(\"([^\"\\\\]+)\"\\)$').match(expr)\n\tif match:\n\t\treturn globals()['_emul_' + match.group(1)]\n\telse:\n\t\traise NotImplementedError\n\n\n@_vim\n@_str_func\ndef _emul_mode(*args):\n\tif args and args[0]:\n\t\treturn _mode\n\telse:\n\t\treturn _mode[0]\n\n\n@_vim\n@_str_func\ndef _emul_getbufvar(bufnr, varname):\n\timport re\n\tif varname[0] == '&':\n\t\tif bufnr == '%':\n\t\t\tbufnr = current.buffer.number\n\t\tif bufnr not in buffers:\n\t\t\treturn ''\n\t\ttry:\n\t\t\treturn buffers[bufnr].options[varname[1:]]\n\t\texcept KeyError:\n\t\t\ttry:\n\t\t\t\treturn options[varname[1:]]\n\t\t\texcept KeyError:\n\t\t\t\treturn ''\n\telif re.match('^[a-zA-Z_]+$', varname):\n\t\tif bufnr == '%':\n\t\t\tbufnr = current.buffer.number\n\t\tif bufnr not in buffers:\n\t\t\treturn ''\n\t\treturn buffers[bufnr].vars[varname]\n\traise NotImplementedError\n\n\n@_vim\n@_str_func\ndef _emul_getwinvar(winnr, varname):\n\treturn current.tabpage.windows[winnr].vars.get(varname, '')\n\n\n@_vim\ndef _emul_setwinvar(winnr, varname, value):\n\tcurrent.tabpage.windows[winnr].vars[varname] = value\n\n\n@_vim\ndef _emul_virtcol(expr):\n\tif expr == '.':\n\t\treturn current.window.cursor[1] + 1\n\tif isinstance(expr, list) and len(expr) == 3:\n\t\treturn expr[-2] + expr[-1]\n\traise NotImplementedError\n\n\n_v_pos = None\n\n\n@_vim\ndef _emul_getpos(expr):\n\tif expr == '.':\n\t\treturn [0, current.window.cursor[0] + 1, current.window.cursor[1] + 1, 0]\n\tif expr == 'v':\n\t\treturn _v_pos or [0, current.window.cursor[0] + 1, current.window.cursor[1] + 1, 0]\n\traise NotImplementedError\n\n\n@_vim\n@_str_func\ndef _emul_fnamemodify(path, modstring):\n\timport os\n\t_modifiers = {\n\t\t'~': lambda path: path.replace(os.environ['HOME'].encode('utf-8'), b'~') if path.startswith(os.environ['HOME'].encode('utf-8')) else path,\n\t\t'.': lambda path: (lambda tpath: path if tpath[:3] == b'..' + os.sep.encode() else tpath)(os.path.relpath(path)),\n\t\t't': lambda path: os.path.basename(path),\n\t\t'h': lambda path: os.path.dirname(path),\n\t}\n\n\tfor mods in modstring.split(':')[1:]:\n\t\tpath = _modifiers[mods](path)\n\treturn path\n\n\n@_vim\n@_str_func\ndef _emul_expand(expr):\n\tglobal _abuf\n\tif expr == '<abuf>':\n\t\treturn _abuf or current.buffer.number\n\traise NotImplementedError\n\n\n@_vim\ndef _emul_bufnr(expr):\n\tif expr == '$':\n\t\treturn _last_bufnr\n\traise NotImplementedError\n\n\n@_vim\ndef _emul_exists(ident):\n\tif ident.startswith('g:'):\n\t\treturn ident[2:] in vars\n\telif ident.startswith(':'):\n\t\treturn 0\n\traise NotImplementedError\n\n\n@_vim\ndef _emul_line2byte(line):\n\tbuflines = current.buffer._buf_lines\n\tif line == len(buflines) + 1:\n\t\treturn sum((len(s) for s in buflines)) + 1\n\traise NotImplementedError\n\n\n@_vim\ndef _emul_line(expr):\n\tcursorline = current.window.cursor[0] + 1\n\tnumlines = len(current.buffer._buf_lines)\n\tif expr == 'w0':\n\t\treturn max(cursorline - 5, 1)\n\tif expr == 'w$':\n\t\treturn min(cursorline + 5, numlines)\n\traise NotImplementedError\n\n\n@_vim\n@_str_func\ndef _emul_strtrans(s):\n\t# FIXME Do more replaces\n\treturn s.replace(b'\\xFF', b'<ff>')\n\n\n@_vim\n@_str_func\ndef _emul_bufname(bufnr):\n\ttry:\n\t\treturn buffers[bufnr]._name or b''\n\texcept KeyError:\n\t\treturn b''\n\n\n_window_id = 0\n\n\nclass _Window(object):\n\tdef __init__(self, number, buffer=None, cursor=(1, 0), width=80):\n\t\tglobal _window_id\n\t\tself.cursor = cursor\n\t\tself.width = width\n\t\tself.number = number\n\t\tif buffer:\n\t\t\tif type(buffer) is _Buffer:\n\t\t\t\tself.buffer = buffer\n\t\t\telse:\n\t\t\t\tself.buffer = _Buffer(**buffer)\n\t\telse:\n\t\t\tself.buffer = _Buffer()\n\t\t_window_id += 1\n\t\tself._window_id = _window_id\n\t\tself.options = {}\n\t\tself.vars = {\n\t\t\t'powerline_window_id': self._window_id,\n\t\t}\n\n\tdef __repr__(self):\n\t\treturn '<window ' + str(self.number - 1) + '>'\n\n\nclass _Tabpage(object):\n\tdef __init__(self, number):\n\t\tself.windows = _ObjList(_Window)\n\t\tself.number = number\n\n\tdef _new_window(self, **kwargs):\n\t\tself.window = self.windows._new(**kwargs)\n\t\treturn self.window\n\n\tdef _close_window(self, winnr, open_window=True):\n\t\tcurwinnr = self.window.number\n\t\twin = self.windows._pop(winnr)\n\t\tif self.windows and winnr == curwinnr:\n\t\t\tself.window = self.windows[-1]\n\t\telif open_window:\n\t\t\tcurrent.tabpage._new_window()\n\t\treturn win\n\n\tdef _close(self):\n\t\tglobal _tabpage\n\t\twhile self.windows:\n\t\t\tself._close_window(1, False)\n\t\ttabpages._pop(self.number)\n\t\t_tabpage = len(tabpages)\n\n\ntabpages = _ObjList(_Tabpage)\n\n\n_abuf = None\n\n\nclass _Buffer(object):\n\tdef __init__(self, name=None):\n\t\tglobal _last_bufnr\n\t\t_last_bufnr += 1\n\t\tbufnr = _last_bufnr\n\t\tself.number = bufnr\n\t\t# FIXME Use unicode() for python-3\n\t\tself.name = name\n\t\tself.vars = {'changedtick': 1}\n\t\tself.options = {\n\t\t\t'modified': 0,\n\t\t\t'readonly': 0,\n\t\t\t'fileformat': 'unix',\n\t\t\t'filetype': '',\n\t\t\t'buftype': '',\n\t\t\t'fileencoding': 'utf-8',\n\t\t\t'textwidth': 80,\n\t\t}\n\t\tself._buf_lines = ['']\n\t\tself._undostate = [self._buf_lines[:]]\n\t\tself._undo_written = len(self._undostate)\n\t\tbuffers[bufnr] = self\n\n\t@property\n\tdef name(self):\n\t\timport sys\n\t\tif sys.version_info < (3,):\n\t\t\treturn self._name\n\t\telse:\n\t\t\treturn str(self._name, 'utf-8') if self._name else None\n\n\t@name.setter\n\tdef name(self, name):\n\t\tif name is None:\n\t\t\tself._name = None\n\t\telse:\n\t\t\timport os\n\t\t\tif type(name) is not bytes:\n\t\t\t\tname = name.encode('utf-8')\n\t\t\tif b':/' in name:\n\t\t\t\tself._name = name\n\t\t\telse:\n\t\t\t\tself._name = os.path.abspath(name)\n\n\tdef __getitem__(self, line):\n\t\treturn self._buf_lines[line]\n\n\tdef __setitem__(self, line, value):\n\t\tself.options['modified'] = 1\n\t\tself.vars['changedtick'] += 1\n\t\tself._buf_lines[line] = value\n\t\tfrom copy import copy\n\t\tself._undostate.append(copy(self._buf_lines))\n\n\tdef __setslice__(self, *args):\n\t\tself.options['modified'] = 1\n\t\tself.vars['changedtick'] += 1\n\t\tself._buf_lines.__setslice__(*args)\n\t\tfrom copy import copy\n\t\tself._undostate.append(copy(self._buf_lines))\n\n\tdef __getslice__(self, *args):\n\t\treturn self._buf_lines.__getslice__(*args)\n\n\tdef __len__(self):\n\t\treturn len(self._buf_lines)\n\n\tdef __repr__(self):\n\t\treturn '<buffer ' + str(self.name) + '>'\n\n\tdef __del__(self):\n\t\tglobal _abuf\n\t\tbufnr = self.number\n\t\ttry:\n\t\t\timport __main__\n\t\texcept ImportError:\n\t\t\tpass\n\t\texcept RuntimeError:\n\t\t\t# Module may have already been garbage-collected\n\t\t\tpass\n\t\telse:\n\t\t\tif _on_wipeout:\n\t\t\t\t_abuf = bufnr\n\t\t\t\ttry:\n\t\t\t\t\tfor event in _on_wipeout:\n\t\t\t\t\t\texec(event, __main__.__dict__)\n\t\t\t\tfinally:\n\t\t\t\t\t_abuf = None\n\n\nclass _Current(object):\n\t@property\n\tdef buffer(self):\n\t\treturn self.window.buffer\n\n\t@property\n\tdef window(self):\n\t\treturn self.tabpage.window\n\n\t@property\n\tdef tabpage(self):\n\t\treturn tabpages[_tabpage - 1]\n\n\ncurrent = _Current()\n\n\n_dict = None\n\n\n@_vim\ndef _init():\n\tglobal _dict\n\n\tif _dict:\n\t\treturn _dict\n\n\t_dict = {}\n\tfor varname, value in globals().items():\n\t\tif varname[0] != '_':\n\t\t\t_dict[varname] = value\n\t_tabnew()\n\treturn _dict\n\n\n@_vim\ndef _get_segment_info():\n\tmode_translations = {\n\t\tchr(ord('V') - 0x40): '^V',\n\t\tchr(ord('S') - 0x40): '^S',\n\t}\n\tmode = _mode\n\tmode = mode_translations.get(mode, mode)\n\twindow = current.window\n\tbuffer = current.buffer\n\ttabpage = current.tabpage\n\treturn {\n\t\t'window': window,\n\t\t'winnr': window.number,\n\t\t'buffer': buffer,\n\t\t'bufnr': buffer.number,\n\t\t'tabpage': tabpage,\n\t\t'tabnr': tabpage.number,\n\t\t'window_id': window._window_id,\n\t\t'mode': mode,\n\t\t'encoding': options['encoding'],\n\t}\n\n\n@_vim\ndef _launch_event(event):\n\tpass\n\n\n@_vim\ndef _start_mode(mode):\n\tglobal _mode\n\tif mode == 'i':\n\t\t_launch_event('InsertEnter')\n\telif _mode == 'i':\n\t\t_launch_event('InsertLeave')\n\t_mode = mode\n\n\n@_vim\ndef _undo():\n\tif len(current.buffer._undostate) == 1:\n\t\treturn\n\tbuffer = current.buffer\n\tbuffer._undostate.pop(-1)\n\tbuffer._buf_lines = buffer._undostate[-1]\n\tif buffer._undo_written == len(buffer._undostate):\n\t\tbuffer.options['modified'] = 0\n\n\n@_vim\ndef _edit(name=None):\n\tif current.buffer.name is None:\n\t\tbuffer = current.buffer\n\t\tbuffer.name = name\n\telse:\n\t\tbuffer = _Buffer(name)\n\t\tcurrent.window.buffer = buffer\n\n\n@_vim\ndef _tabnew(name=None):\n\tglobal windows\n\tglobal _tabpage\n\ttabpage = tabpages._new()\n\twindows = tabpage.windows\n\t_tabpage = len(tabpages)\n\t_new(name)\n\treturn tabpage\n\n\n@_vim\ndef _new(name=None):\n\tcurrent.tabpage._new_window(buffer={'name': name})\n\n\n@_vim\ndef _split():\n\tcurrent.tabpage._new_window(buffer=current.buffer)\n\n\n@_vim\ndef _close(winnr, wipe=True):\n\twin = current.tabpage._close_window(winnr)\n\tif wipe:\n\t\tfor w in current.tabpage.windows:\n\t\t\tif w.buffer.number == win.buffer.number:\n\t\t\t\tbreak\n\t\telse:\n\t\t\t_bw(win.buffer.number)\n\n\n@_vim\ndef _bw(bufnr=None):\n\tbufnr = bufnr or current.buffer.number\n\twinnr = 1\n\tfor win in current.tabpage.windows:\n\t\tif win.buffer.number == bufnr:\n\t\t\t_close(winnr, wipe=False)\n\t\twinnr += 1\n\tbuffers._pop(bufnr)\n\tif not buffers:\n\t\t_Buffer()\n\t_b(max(buffers._keys()))\n\n\n@_vim\ndef _b(bufnr):\n\tcurrent.window.buffer = buffers[bufnr]\n\n\n@_vim\ndef _set_cursor(line, col):\n\tcurrent.window.cursor = (line, col)\n\tif _mode == 'n':\n\t\t_launch_event('CursorMoved')\n\telif _mode == 'i':\n\t\t_launch_event('CursorMovedI')\n\n\n@_vim\ndef _get_buffer():\n\treturn current.buffer\n\n\n@_vim\ndef _set_bufoption(option, value, bufnr=None):\n\tbuffers[bufnr or current.buffer.number].options[option] = value\n\tif option == 'filetype':\n\t\t_launch_event('FileType')\n\n\nclass _WithNewBuffer(object):\n\tdef __init__(self, func, *args, **kwargs):\n\t\tself.call = lambda: func(*args, **kwargs)\n\n\tdef __enter__(self):\n\t\tself.call()\n\t\tself.bufnr = current.buffer.number\n\t\treturn _get_segment_info()\n\n\tdef __exit__(self, *args):\n\t\t_bw(self.bufnr)\n\n\n@_vim\ndef _set_dict(d, new, setfunc=None):\n\tif not setfunc:\n\t\tdef setfunc(k, v):\n\t\t\td[k] = v\n\n\told = {}\n\tna = []\n\tfor k, v in new.items():\n\t\ttry:\n\t\t\told[k] = d[k]\n\t\texcept KeyError:\n\t\t\tna.append(k)\n\t\tsetfunc(k, v)\n\treturn old, na\n\n\nclass _WithBufOption(object):\n\tdef __init__(self, **new):\n\t\tself.new = new\n\n\tdef __enter__(self):\n\t\tself.buffer = current.buffer\n\t\tself.old = _set_dict(self.buffer.options, self.new, _set_bufoption)[0]\n\n\tdef __exit__(self, *args):\n\t\tself.buffer.options.update(self.old)\n\n\nclass _WithMode(object):\n\tdef __init__(self, new):\n\t\tself.new = new\n\n\tdef __enter__(self):\n\t\tself.old = _mode\n\t\t_start_mode(self.new)\n\t\treturn _get_segment_info()\n\n\tdef __exit__(self, *args):\n\t\t_start_mode(self.old)\n\n\nclass _WithDict(object):\n\tdef __init__(self, d, **new):\n\t\tself.new = new\n\t\tself.d = d\n\n\tdef __enter__(self):\n\t\tself.old, self.na = _set_dict(self.d, self.new)\n\n\tdef __exit__(self, *args):\n\t\tself.d.update(self.old)\n\t\tfor k in self.na:\n\t\t\tself.d.pop(k)\n\n\nclass _WithSplit(object):\n\tdef __enter__(self):\n\t\t_split()\n\n\tdef __exit__(self, *args):\n\t\t_close(2, wipe=False)\n\n\nclass _WithBufName(object):\n\tdef __init__(self, new):\n\t\tself.new = new\n\n\tdef __enter__(self):\n\t\timport os\n\t\tbuffer = current.buffer\n\t\tself.buffer = buffer\n\t\tself.old = buffer.name\n\t\tbuffer.name = self.new\n\n\tdef __exit__(self, *args):\n\t\tself.buffer.name = self.old\n\n\nclass _WithNewTabPage(object):\n\tdef __init__(self, *args, **kwargs):\n\t\tself.args = args\n\t\tself.kwargs = kwargs\n\n\tdef __enter__(self):\n\t\tself.tab = _tabnew(*self.args, **self.kwargs)\n\n\tdef __exit__(self, *args):\n\t\tself.tab._close()\n\n\nclass _WithGlobal(object):\n\tdef __init__(self, **kwargs):\n\t\tself.kwargs = kwargs\n\n\tdef __enter__(self):\n\t\tself.empty = object()\n\t\tself.old = dict(((key, globals().get(key, self.empty)) for key in self.kwargs))\n\t\tglobals().update(self.kwargs)\n\n\tdef __exit__(self, *args):\n\t\tfor k, v in self.old.items():\n\t\t\tif v is self.empty:\n\t\t\t\tglobals().pop(k, None)\n\t\t\telse:\n\t\t\t\tglobals()[k] = v\n\n\n@_vim\ndef _with(key, *args, **kwargs):\n\tif key == 'buffer':\n\t\treturn _WithNewBuffer(_edit, *args, **kwargs)\n\telif key == 'bufname':\n\t\treturn _WithBufName(*args, **kwargs)\n\telif key == 'mode':\n\t\treturn _WithMode(*args, **kwargs)\n\telif key == 'bufoptions':\n\t\treturn _WithBufOption(**kwargs)\n\telif key == 'options':\n\t\treturn _WithDict(options, **kwargs)\n\telif key == 'globals':\n\t\treturn _WithDict(vars, **kwargs)\n\telif key == 'wvars':\n\t\treturn _WithDict(current.window.vars, **kwargs)\n\telif key == 'environ':\n\t\treturn _WithDict(_environ, **kwargs)\n\telif key == 'split':\n\t\treturn _WithSplit()\n\telif key == 'tabpage':\n\t\treturn _WithNewTabPage(*args, **kwargs)\n\telif key == 'vpos':\n\t\treturn _WithGlobal(_v_pos=[0, kwargs['line'], kwargs['col'], kwargs['off']])\n\n\nclass error(Exception):\n\tpass\n", "description": "Powerline is a statusline plugin for vim, and provides statuslines and prompts for several other applications, including zsh, bash, tmux, IPython, Awesome and Qtile.", "file_name": "vim.py", "id": "4bb9663596fa167732175947c3a80085", "language": "Python", "project_name": "powerline", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/powerline-powerline/powerline-powerline-d36850f/tests/modules/vim.py", "save_time": "", "source": "", "update_at": "2018-03-18T09:00:33Z", "url": "https://github.com/powerline/powerline", "wiki": false}