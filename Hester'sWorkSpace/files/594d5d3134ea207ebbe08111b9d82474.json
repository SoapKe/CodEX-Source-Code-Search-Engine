{"author": "encode", "code": "\"\"\"\nThe `compat` module provides support for backwards compatibility with older\nversions of Django/Python, and compatibility wrappers around optional packages.\n\"\"\"\n\nfrom __future__ import unicode_literals\n\nimport django\nfrom django.conf import settings\nfrom django.core import validators\nfrom django.utils import six\nfrom django.views.generic import View\n\ntry:\n    from django.urls import (  \n        URLPattern,\n        URLResolver,\n    )\nexcept ImportError:\n    \n    from django.urls import (  \n        RegexURLPattern as URLPattern,\n        RegexURLResolver as URLResolver,\n    )\n\n\ndef get_original_route(urlpattern):\n    \"\"\"\n    Get the original route/regex that was typed in by the user into the path(), re_path() or url() directive. This\n    is in contrast with get_regex_pattern below, which for RoutePattern returns the raw regex generated from the path().\n    \"\"\"\n    if hasattr(urlpattern, 'pattern'):\n        \n        return str(urlpattern.pattern)\n    else:\n        \n        return urlpattern.regex.pattern\n\n\ndef get_regex_pattern(urlpattern):\n    \"\"\"\n    Get the raw regex out of the urlpattern's RegexPattern or RoutePattern. This is always a regular expression,\n    unlike get_original_route above.\n    \"\"\"\n    if hasattr(urlpattern, 'pattern'):\n        \n        return urlpattern.pattern.regex.pattern\n    else:\n        \n        return urlpattern.regex.pattern\n\n\ndef is_route_pattern(urlpattern):\n    if hasattr(urlpattern, 'pattern'):\n        \n        from django.urls.resolvers import RoutePattern\n        return isinstance(urlpattern.pattern, RoutePattern)\n    else:\n        \n        return False\n\n\ndef make_url_resolver(regex, urlpatterns):\n    try:\n        \n        from django.urls.resolvers import RegexPattern\n        return URLResolver(RegexPattern(regex), urlpatterns)\n\n    except ImportError:\n        \n        return URLResolver(regex, urlpatterns)\n\n\ndef unicode_repr(instance):\n    \n    # on both python 3 (already the case) and 2 (not the case).\n    if six.PY2:\n        return repr(instance).decode('utf-8')\n    return repr(instance)\n\n\ndef unicode_to_repr(value):\n    \n    \n    \n    if six.PY2:\n        return value.encode('utf-8')\n    return value\n\n\ndef unicode_http_header(value):\n    \n    if isinstance(value, six.binary_type):\n        return value.decode('iso-8859-1')\n    return value\n\n\ndef distinct(queryset, base):\n    if settings.DATABASES[queryset.db][\"ENGINE\"] == \"django.db.backends.oracle\":\n        \n        return base.filter(pk__in=set(queryset.values_list('pk', flat=True)))\n    return queryset.distinct()\n\n\n\ntry:\n    from django.contrib.postgres import fields as postgres_fields\nexcept ImportError:\n    postgres_fields = None\n\n\n# coreapi is optional (Note that uritemplate is a dependency of coreapi)\ntry:\n    import coreapi\n    import uritemplate\nexcept ImportError:\n    coreapi = None\n    uritemplate = None\n\n\n\ntry:\n    import coreschema\nexcept ImportError:\n    coreschema = None\n\n\n\ntry:\n    import crispy_forms\nexcept ImportError:\n    crispy_forms = None\n\n\n\ntry:\n    import requests\nexcept ImportError:\n    requests = None\n\n\n\n# Fixes (#1712). We keep the try/except for the test suite.\nguardian = None\ntry:\n    if 'guardian' in settings.INSTALLED_APPS:\n        import guardian  \nexcept ImportError:\n    pass\n\n\n\nif 'patch' not in View.http_method_names:\n    View.http_method_names = View.http_method_names + ['patch']\n\n\n\ntry:\n    import markdown\n\n    if markdown.version <= '2.2':\n        HEADERID_EXT_PATH = 'headerid'\n        LEVEL_PARAM = 'level'\n    elif markdown.version < '2.6':\n        HEADERID_EXT_PATH = 'markdown.extensions.headerid'\n        LEVEL_PARAM = 'level'\n    else:\n        HEADERID_EXT_PATH = 'markdown.extensions.toc'\n        LEVEL_PARAM = 'baselevel'\n\n    def apply_markdown(text):\n        \"\"\"\n        Simple wrapper around :func:`markdown.markdown` to set the base level\n        of '#' style headers to <h2>.\n        \"\"\"\n        extensions = [HEADERID_EXT_PATH]\n        extension_configs = {\n            HEADERID_EXT_PATH: {\n                LEVEL_PARAM: '2'\n            }\n        }\n        md = markdown.Markdown(\n            extensions=extensions, extension_configs=extension_configs\n        )\n        md_filter_add_syntax_highlight(md)\n        return md.convert(text)\nexcept ImportError:\n    apply_markdown = None\n    markdown = None\n\n\ntry:\n    import pygments\n    from pygments.lexers import get_lexer_by_name, TextLexer\n    from pygments.formatters import HtmlFormatter\n\n    def pygments_highlight(text, lang, style):\n        lexer = get_lexer_by_name(lang, stripall=False)\n        formatter = HtmlFormatter(nowrap=True, style=style)\n        return pygments.highlight(text, lexer, formatter)\n\n    def pygments_css(style):\n        formatter = HtmlFormatter(style=style)\n        return formatter.get_style_defs('.highlight')\n\nexcept ImportError:\n    pygments = None\n\n    def pygments_highlight(text, lang, style):\n        return text\n\n    def pygments_css(style):\n        return None\n\nif markdown is not None and pygments is not None:\n    \n    \n\n    from markdown.preprocessors import Preprocessor\n    import re\n\n    class CodeBlockPreprocessor(Preprocessor):\n        pattern = re.compile(\n            r'^\\s*``` *([^\\n]+)\\n(.+?)^\\s*```', re.M | re.S)\n\n        formatter = HtmlFormatter()\n\n        def run(self, lines):\n            def repl(m):\n                try:\n                    lexer = get_lexer_by_name(m.group(1))\n                except (ValueError, NameError):\n                    lexer = TextLexer()\n                code = m.group(2).replace('\\t', '    ')\n                code = pygments.highlight(code, lexer, self.formatter)\n                code = code.replace('\\n\\n', '\\n&nbsp;\\n').replace('\\n', '<br />').replace('\\\\@', '@')\n                return '\\n\\n%s\\n\\n' % code\n            ret = self.pattern.sub(repl, \"\\n\".join(lines))\n            return ret.split(\"\\n\")\n\n    def md_filter_add_syntax_highlight(md):\n        md.preprocessors.add('highlight', CodeBlockPreprocessor(), \"_begin\")\n        return True\nelse:\n    def md_filter_add_syntax_highlight(md):\n        return False\n\n\ntry:\n    import pytz  \n    from pytz.exceptions import InvalidTimeError\nexcept ImportError:\n    InvalidTimeError = Exception\n\n\ntry:\n    from django.urls import include, path, re_path, register_converter  \nexcept ImportError:\n    from django.conf.urls import include, url \n    path = None\n    register_converter = None\n    re_path = url\n\n\n# `separators` argument to `json.dumps()` differs between 2.x and 3.x\n\nif six.PY3:\n    SHORT_SEPARATORS = (',', ':')\n    LONG_SEPARATORS = (', ', ': ')\n    INDENT_SEPARATORS = (',', ': ')\nelse:\n    SHORT_SEPARATORS = (b',', b':')\n    LONG_SEPARATORS = (b', ', b': ')\n    INDENT_SEPARATORS = (b',', b': ')\n\n\nclass CustomValidatorMessage(object):\n    \"\"\"\n    We need to avoid evaluation of `lazy` translated `message` in `django.core.validators.BaseValidator.__init__`.\n    https://github.com/django/django/blob/75ed5900321d170debef4ac452b8b3cf8a1c2384/django/core/validators.py\n\n    Ref: https://github.com/encode/django-rest-framework/pull/5452\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self.message = kwargs.pop('message', self.message)\n        super(CustomValidatorMessage, self).__init__(*args, **kwargs)\n\n\nclass MinValueValidator(CustomValidatorMessage, validators.MinValueValidator):\n    pass\n\n\nclass MaxValueValidator(CustomValidatorMessage, validators.MaxValueValidator):\n    pass\n\n\nclass MinLengthValidator(CustomValidatorMessage, validators.MinLengthValidator):\n    pass\n\n\nclass MaxLengthValidator(CustomValidatorMessage, validators.MaxLengthValidator):\n    pass\n\n\ndef authenticate(request=None, **credentials):\n    from django.contrib.auth import authenticate\n    if django.VERSION < (1, 11):\n        return authenticate(**credentials)\n    else:\n        return authenticate(request=request, **credentials)\n", "comments": "    the  compat  module provides support backwards compatibility older versions django python  compatibility wrappers around optional packages         future   import unicode literals  import django django conf import settings django core import validators django utils import six django views generic import view  try      django urls import (    noqa         urlpattern          urlresolver      ) except importerror        will removed django 2 0     django urls import (    noqa         regexurlpattern urlpattern          regexurlresolver urlresolver      )   def get original route(urlpattern)              get original route regex typed user path()  path() url() directive  this     contrast get regex pattern  routepattern returns raw regex generated path()              hasattr(urlpattern   pattern )            django 2 0         return str(urlpattern pattern)     else            django   2 0         return urlpattern regex pattern   def get regex pattern(urlpattern)              get raw regex urlpattern regexpattern routepattern  this always regular expression      unlike get original route              hasattr(urlpattern   pattern )            django 2 0         return urlpattern pattern regex pattern     else            django   2 0         return urlpattern regex pattern   def route pattern(urlpattern)      hasattr(urlpattern   pattern )            django 2 0         django urls resolvers import routepattern         return isinstance(urlpattern pattern  routepattern)     else            django   2 0         return false   def make url resolver(regex  urlpatterns)      try            django 2 0         django urls resolvers import regexpattern         return urlresolver(regexpattern(regex)  urlpatterns)      except importerror            django   2 0         return urlresolver(regex  urlpatterns)   def unicode repr(instance)        get repr instance  ensure unicode string       python 3 (already case) 2 (not case)      six py2          return repr(instance) decode( utf 8 )     return repr(instance)   def unicode repr(value)        coerce unicode string correct repr return type  depending       python version  we wrap    repr    implementations       use unicode throughout internally      six py2          return value encode( utf 8 )     return value   def unicode http header(value)        coerce http header value unicode      isinstance(value  six binary type)          return value decode( iso 8859 1 )     return value   def distinct(queryset  base)      settings databases queryset db   engine       django db backends oracle             distinct analogue oracle users         return base filter(pk  set(queryset values list( pk   flat true)))     return queryset distinct()     django contrib postgres requires psycopg2 try      django contrib postgres import fields postgres fields except importerror      postgres fields   none     coreapi optional (note uritemplate dependency coreapi) try      import coreapi     import uritemplate except importerror      coreapi   none     uritemplate   none     coreschema optional try      import coreschema except importerror      coreschema   none     django crispy forms optional try      import crispy forms except importerror      crispy forms   none     requests optional try      import requests except importerror      requests   none     django guardian optional  import guardian installed apps   fixes ( 1712)  we keep try except test suite  guardian   none try       guardian  settings installed apps          import guardian    noqa except importerror      pass     patch method implemented django  patch  view http method names      view http method names   view http method names     patch       markdown optional try      import markdown      markdown version     2 2           headerid ext path    headerid          level param    level      elif markdown version    2 6           headerid ext path    markdown extensions headerid          level param    level      else          headerid ext path    markdown extensions toc          level param    baselevel       def apply markdown(text)                      simple wrapper around  func  markdown markdown  set base level             style headers  h2                       extensions    headerid ext path          extension configs                 headerid ext path                    level param   2                                  md   markdown markdown(             extensions extensions  extension configs extension configs         )         md filter add syntax highlight(md)         return md convert(text) except importerror      apply markdown   none     markdown   none   try      import pygments     pygments lexers import get lexer name  textlexer     pygments formatters import htmlformatter      def pygments highlight(text  lang  style)          lexer   get lexer name(lang  stripall false)         formatter   htmlformatter(nowrap true  style style)         return pygments highlight(text  lexer  formatter)      def pygments css(style)          formatter   htmlformatter(style style)         return formatter get style defs(  highlight )  except importerror      pygments   none      def pygments highlight(text  lang  style)          return text      def pygments css(style)          return none  markdown none pygments none        starting blogpost modified support current markdown extensions api       https   zerokspot com weblog 2008 06 18 syntax highlighting markdown pygments       markdown preprocessors import preprocessor     import      class codeblockpreprocessor(preprocessor)          pattern   compile(             r        (   n  ) n(   )        m   s)          formatter   htmlformatter()          def run(self  lines)              def repl(m)                  try                      lexer   get lexer name(m group(1))                 except (valueerror  nameerror)                      lexer   textlexer()                 code   group(2) replace(          )                 code   pygments highlight(code  lexer  self formatter)                 code   code replace(  n n     n nbsp  n ) replace(  n     br    ) replace(          )                 return   n n n n    code             ret   self pattern sub(repl    n  join(lines))             return ret split(  n )      def md filter add syntax highlight(md)          md preprocessors add( highlight   codeblockpreprocessor()    begin )         return true else      def md filter add syntax highlight(md)          return false    pytz required django 1 11  remove dropping django 1 10 support  try      import pytz    noqa     pytz exceptions import invalidtimeerror except importerror      invalidtimeerror   exception    django 1 x url routing syntax  remove dropping django 1 11 support  try      django urls import include  path  path  register converter    noqa except importerror      django conf urls import include  url   noqa     path   none     register converter   none     path   url      separators  argument  json dumps()  differs 2 x 3 x   see  https   bugs python org issue22767 six py3      short separators   (        )     long separators   (          )     indent separators   (         ) else      short separators   (b     b   )     long separators   (b      b    )     indent separators   (b     b    )   class customvalidatormessage(object)              we need avoid evaluation  lazy  translated  message   django core validators basevalidator   init         https   github com django django blob 75ed5900321d170debef4ac452b8b3cf8a1c2384 django core validators py l297      ref  https   github com encode django rest framework pull 5452            noqa    will removed django 2 0    noqa    django 2 0    django   2 0    django 2 0    django   2 0    django 2 0    django   2 0    django 2 0    django   2 0    get repr instance  ensure unicode string    python 3 (already case) 2 (not case)     coerce unicode string correct repr return type  depending    python version  we wrap    repr    implementations    use unicode throughout internally     coerce http header value unicode     distinct analogue oracle users    django contrib postgres requires psycopg2    coreapi optional (note uritemplate dependency coreapi)    coreschema optional    django crispy forms optional    requests optional    django guardian optional  import guardian installed apps    fixes ( 1712)  we keep try except test suite     noqa    patch method implemented django    markdown optional    starting blogpost modified support current markdown extensions api    https   zerokspot com weblog 2008 06 18 syntax highlighting markdown pygments     pytz required django 1 11  remove dropping django 1 10 support     noqa    django 1 x url routing syntax  remove dropping django 1 11 support     noqa    noqa     separators  argument  json dumps()  differs 2 x 3 x    see  https   bugs python org issue22767   l297 ", "content": "\"\"\"\nThe `compat` module provides support for backwards compatibility with older\nversions of Django/Python, and compatibility wrappers around optional packages.\n\"\"\"\n\nfrom __future__ import unicode_literals\n\nimport django\nfrom django.conf import settings\nfrom django.core import validators\nfrom django.utils import six\nfrom django.views.generic import View\n\ntry:\n    from django.urls import (  # noqa\n        URLPattern,\n        URLResolver,\n    )\nexcept ImportError:\n    # Will be removed in Django 2.0\n    from django.urls import (  # noqa\n        RegexURLPattern as URLPattern,\n        RegexURLResolver as URLResolver,\n    )\n\n\ndef get_original_route(urlpattern):\n    \"\"\"\n    Get the original route/regex that was typed in by the user into the path(), re_path() or url() directive. This\n    is in contrast with get_regex_pattern below, which for RoutePattern returns the raw regex generated from the path().\n    \"\"\"\n    if hasattr(urlpattern, 'pattern'):\n        # Django 2.0\n        return str(urlpattern.pattern)\n    else:\n        # Django < 2.0\n        return urlpattern.regex.pattern\n\n\ndef get_regex_pattern(urlpattern):\n    \"\"\"\n    Get the raw regex out of the urlpattern's RegexPattern or RoutePattern. This is always a regular expression,\n    unlike get_original_route above.\n    \"\"\"\n    if hasattr(urlpattern, 'pattern'):\n        # Django 2.0\n        return urlpattern.pattern.regex.pattern\n    else:\n        # Django < 2.0\n        return urlpattern.regex.pattern\n\n\ndef is_route_pattern(urlpattern):\n    if hasattr(urlpattern, 'pattern'):\n        # Django 2.0\n        from django.urls.resolvers import RoutePattern\n        return isinstance(urlpattern.pattern, RoutePattern)\n    else:\n        # Django < 2.0\n        return False\n\n\ndef make_url_resolver(regex, urlpatterns):\n    try:\n        # Django 2.0\n        from django.urls.resolvers import RegexPattern\n        return URLResolver(RegexPattern(regex), urlpatterns)\n\n    except ImportError:\n        # Django < 2.0\n        return URLResolver(regex, urlpatterns)\n\n\ndef unicode_repr(instance):\n    # Get the repr of an instance, but ensure it is a unicode string\n    # on both python 3 (already the case) and 2 (not the case).\n    if six.PY2:\n        return repr(instance).decode('utf-8')\n    return repr(instance)\n\n\ndef unicode_to_repr(value):\n    # Coerce a unicode string to the correct repr return type, depending on\n    # the Python version. We wrap all our `__repr__` implementations with\n    # this and then use unicode throughout internally.\n    if six.PY2:\n        return value.encode('utf-8')\n    return value\n\n\ndef unicode_http_header(value):\n    # Coerce HTTP header value to unicode.\n    if isinstance(value, six.binary_type):\n        return value.decode('iso-8859-1')\n    return value\n\n\ndef distinct(queryset, base):\n    if settings.DATABASES[queryset.db][\"ENGINE\"] == \"django.db.backends.oracle\":\n        # distinct analogue for Oracle users\n        return base.filter(pk__in=set(queryset.values_list('pk', flat=True)))\n    return queryset.distinct()\n\n\n# django.contrib.postgres requires psycopg2\ntry:\n    from django.contrib.postgres import fields as postgres_fields\nexcept ImportError:\n    postgres_fields = None\n\n\n# coreapi is optional (Note that uritemplate is a dependency of coreapi)\ntry:\n    import coreapi\n    import uritemplate\nexcept ImportError:\n    coreapi = None\n    uritemplate = None\n\n\n# coreschema is optional\ntry:\n    import coreschema\nexcept ImportError:\n    coreschema = None\n\n\n# django-crispy-forms is optional\ntry:\n    import crispy_forms\nexcept ImportError:\n    crispy_forms = None\n\n\n# requests is optional\ntry:\n    import requests\nexcept ImportError:\n    requests = None\n\n\n# Django-guardian is optional. Import only if guardian is in INSTALLED_APPS\n# Fixes (#1712). We keep the try/except for the test suite.\nguardian = None\ntry:\n    if 'guardian' in settings.INSTALLED_APPS:\n        import guardian  # noqa\nexcept ImportError:\n    pass\n\n\n# PATCH method is not implemented by Django\nif 'patch' not in View.http_method_names:\n    View.http_method_names = View.http_method_names + ['patch']\n\n\n# Markdown is optional\ntry:\n    import markdown\n\n    if markdown.version <= '2.2':\n        HEADERID_EXT_PATH = 'headerid'\n        LEVEL_PARAM = 'level'\n    elif markdown.version < '2.6':\n        HEADERID_EXT_PATH = 'markdown.extensions.headerid'\n        LEVEL_PARAM = 'level'\n    else:\n        HEADERID_EXT_PATH = 'markdown.extensions.toc'\n        LEVEL_PARAM = 'baselevel'\n\n    def apply_markdown(text):\n        \"\"\"\n        Simple wrapper around :func:`markdown.markdown` to set the base level\n        of '#' style headers to <h2>.\n        \"\"\"\n        extensions = [HEADERID_EXT_PATH]\n        extension_configs = {\n            HEADERID_EXT_PATH: {\n                LEVEL_PARAM: '2'\n            }\n        }\n        md = markdown.Markdown(\n            extensions=extensions, extension_configs=extension_configs\n        )\n        md_filter_add_syntax_highlight(md)\n        return md.convert(text)\nexcept ImportError:\n    apply_markdown = None\n    markdown = None\n\n\ntry:\n    import pygments\n    from pygments.lexers import get_lexer_by_name, TextLexer\n    from pygments.formatters import HtmlFormatter\n\n    def pygments_highlight(text, lang, style):\n        lexer = get_lexer_by_name(lang, stripall=False)\n        formatter = HtmlFormatter(nowrap=True, style=style)\n        return pygments.highlight(text, lexer, formatter)\n\n    def pygments_css(style):\n        formatter = HtmlFormatter(style=style)\n        return formatter.get_style_defs('.highlight')\n\nexcept ImportError:\n    pygments = None\n\n    def pygments_highlight(text, lang, style):\n        return text\n\n    def pygments_css(style):\n        return None\n\nif markdown is not None and pygments is not None:\n    # starting from this blogpost and modified to support current markdown extensions API\n    # https://zerokspot.com/weblog/2008/06/18/syntax-highlighting-in-markdown-with-pygments/\n\n    from markdown.preprocessors import Preprocessor\n    import re\n\n    class CodeBlockPreprocessor(Preprocessor):\n        pattern = re.compile(\n            r'^\\s*``` *([^\\n]+)\\n(.+?)^\\s*```', re.M | re.S)\n\n        formatter = HtmlFormatter()\n\n        def run(self, lines):\n            def repl(m):\n                try:\n                    lexer = get_lexer_by_name(m.group(1))\n                except (ValueError, NameError):\n                    lexer = TextLexer()\n                code = m.group(2).replace('\\t', '    ')\n                code = pygments.highlight(code, lexer, self.formatter)\n                code = code.replace('\\n\\n', '\\n&nbsp;\\n').replace('\\n', '<br />').replace('\\\\@', '@')\n                return '\\n\\n%s\\n\\n' % code\n            ret = self.pattern.sub(repl, \"\\n\".join(lines))\n            return ret.split(\"\\n\")\n\n    def md_filter_add_syntax_highlight(md):\n        md.preprocessors.add('highlight', CodeBlockPreprocessor(), \"_begin\")\n        return True\nelse:\n    def md_filter_add_syntax_highlight(md):\n        return False\n\n# pytz is required from Django 1.11. Remove when dropping Django 1.10 support.\ntry:\n    import pytz  # noqa\n    from pytz.exceptions import InvalidTimeError\nexcept ImportError:\n    InvalidTimeError = Exception\n\n# Django 1.x url routing syntax. Remove when dropping Django 1.11 support.\ntry:\n    from django.urls import include, path, re_path, register_converter  # noqa\nexcept ImportError:\n    from django.conf.urls import include, url # noqa\n    path = None\n    register_converter = None\n    re_path = url\n\n\n# `separators` argument to `json.dumps()` differs between 2.x and 3.x\n# See: https://bugs.python.org/issue22767\nif six.PY3:\n    SHORT_SEPARATORS = (',', ':')\n    LONG_SEPARATORS = (', ', ': ')\n    INDENT_SEPARATORS = (',', ': ')\nelse:\n    SHORT_SEPARATORS = (b',', b':')\n    LONG_SEPARATORS = (b', ', b': ')\n    INDENT_SEPARATORS = (b',', b': ')\n\n\nclass CustomValidatorMessage(object):\n    \"\"\"\n    We need to avoid evaluation of `lazy` translated `message` in `django.core.validators.BaseValidator.__init__`.\n    https://github.com/django/django/blob/75ed5900321d170debef4ac452b8b3cf8a1c2384/django/core/validators.py#L297\n\n    Ref: https://github.com/encode/django-rest-framework/pull/5452\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self.message = kwargs.pop('message', self.message)\n        super(CustomValidatorMessage, self).__init__(*args, **kwargs)\n\n\nclass MinValueValidator(CustomValidatorMessage, validators.MinValueValidator):\n    pass\n\n\nclass MaxValueValidator(CustomValidatorMessage, validators.MaxValueValidator):\n    pass\n\n\nclass MinLengthValidator(CustomValidatorMessage, validators.MinLengthValidator):\n    pass\n\n\nclass MaxLengthValidator(CustomValidatorMessage, validators.MaxLengthValidator):\n    pass\n\n\ndef authenticate(request=None, **credentials):\n    from django.contrib.auth import authenticate\n    if django.VERSION < (1, 11):\n        return authenticate(**credentials)\n    else:\n        return authenticate(request=request, **credentials)\n", "description": "Web APIs for Django.", "file_name": "compat.py", "id": "594d5d3134ea207ebbe08111b9d82474", "language": "Python", "project_name": "django-rest-framework", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/encode-django-rest-framework/encode-django-rest-framework-247cf09/rest_framework/compat.py", "save_time": "", "source": "", "update_at": "2018-03-18T10:13:19Z", "url": "https://github.com/encode/django-rest-framework", "wiki": false}