{"author": "ansible", "code": "\n -*- coding: utf-8 -*-\n\n Copyright (c) 2017 F5 Networks Inc.\n GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = r'''\n---\nmodule: bigip_profile_client_ssl\nshort_description: Manages client SSL profiles on a BIG-IP\ndescription: Manages client SSL profiles on a BIG-IP.\nversion_added: \"2.5\"\noptions:\n  name:\n    description:\n      - Specifies the name of the profile.\n    required: True\n  parent:\n    description:\n      - The parent template of this monitor template. Once this value has\n        been set, it cannot be changed. By default, this value is the C(clientssl)\n        parent on the C(Common) partition.\n    default: \"/Common/clientssl\"\n  ciphers:\n    description:\n      - Specifies the list of ciphers that the system supports. When creating a new\n        profile, the default cipher list is C(DEFAULT).\n  cert_key_chain:\n    description:\n      - One or more certificates and keys to associate with the SSL profile. This\n        option is always a list. The keys in the list dictate the details of the\n        client/key/chain combination. Note that BIG-IPs can only have one of each\n        type of each certificate/key type. This means that you can only have one\n        RSA, one DSA, and one ECDSA per profile. If you attempt to assign two\n        RSA, DSA, or ECDSA certificate/key combo, the device will reject this.\n      - This list is a complex list that specifies a number of keys. There are several supported keys.\n    suboptions:\n      cert:\n        description:\n          - Specifies a cert name for use.\n        required: True\n      key:\n        description:\n          - Contains a key name.\n        required: True\n      chain:\n        description:\n          - Contains a certificate chain that is relevant to the certificate and key\n            mentioned earlier.\n          - This key is optional.\n      passphrase:\n        description:\n          - Contains the passphrase of the key file, should it require one.\n          - Passphrases are encrypted on the remote BIG-IP device. Therefore, there is no way\n            to compare them when updating a client SSL profile. Due to this, if you specify a\n            passphrase, this module will always register a C(changed) event.\n  partition:\n    description:\n      - Device partition to manage resources on.\n    default: Common\n    version_added: 2.5\n  state:\n    description:\n      - When C(present), ensures that the profile exists.\n      - When C(absent), ensures the profile is removed.\n    default: present\n    choices:\n      - present\n      - absent\n    version_added: 2.5\nnotes:\n  - Requires BIG-IP software version >= 12\nextends_documentation_fragment: f5\nauthor:\n  - Tim Rupp (@caphrim007)\n'''\n\nEXAMPLES = r'''\n- name: Create client SSL profile\n  bigip_profile_client_ssl:\n    state: present\n    server: lb.mydomain.com\n    user: admin\n    password: secret\n    name: my_profile\n  delegate_to: localhost\n\n- name: Create client SSL profile with specific ciphers\n  bigip_profile_client_ssl:\n    state: present\n    server: lb.mydomain.com\n    user: admin\n    password: secret\n    name: my_profile\n    ciphers: \"!SSLv3:!SSLv2:ECDHE+AES-GCM+SHA256:ECDHE-RSA-AES128-CBC-SHA\"\n  delegate_to: localhost\n\n- name: Create a client SSL profile with a cert/key/chain setting\n  bigip_profile_client_ssl:\n    state: present\n    server: lb.mydomain.com\n    user: admin\n    password: secret\n    name: my_profile\n    cert_key_chain:\n      - cert: bigip_ssl_cert1\n        key: bigip_ssl_key1\n        chain: bigip_ssl_cert1\n  delegate_to: localhost\n'''\n\nRETURN = r'''\nciphers:\n  description: The ciphers applied to the profile.\n  returned: changed\n  type: string\n  sample: \"!SSLv3:!SSLv2:ECDHE+AES-GCM+SHA256:ECDHE-RSA-AES128-CBC-SHA\"\n'''\n\nimport os\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.basic import env_fallback\nfrom ansible.module_utils.six import iteritems\n\nHAS_DEVEL_IMPORTS = False\n\ntry:\n     Sideband repository used for dev\n    from library.module_utils.network.f5.bigip import HAS_F5SDK\n    from library.module_utils.network.f5.bigip import F5Client\n    from library.module_utils.network.f5.common import F5ModuleError\n    from library.module_utils.network.f5.common import AnsibleF5Parameters\n    from library.module_utils.network.f5.common import cleanup_tokens\n    from library.module_utils.network.f5.common import fqdn_name\n    from library.module_utils.network.f5.common import f5_argument_spec\n    try:\n        from library.module_utils.network.f5.common import iControlUnexpectedHTTPError\n    except ImportError:\n        HAS_F5SDK = False\n    HAS_DEVEL_IMPORTS = True\nexcept ImportError:\n     Upstream Ansible\n    from ansible.module_utils.network.f5.bigip import HAS_F5SDK\n    from ansible.module_utils.network.f5.bigip import F5Client\n    from ansible.module_utils.network.f5.common import F5ModuleError\n    from ansible.module_utils.network.f5.common import AnsibleF5Parameters\n    from ansible.module_utils.network.f5.common import cleanup_tokens\n    from ansible.module_utils.network.f5.common import fqdn_name\n    from ansible.module_utils.network.f5.common import f5_argument_spec\n    try:\n        from ansible.module_utils.network.f5.common import iControlUnexpectedHTTPError\n    except ImportError:\n        HAS_F5SDK = False\n\n\nclass Parameters(AnsibleF5Parameters):\n    api_map = {\n        'certKeyChain': 'cert_key_chain'\n    }\n\n    api_attributes = [\n        'ciphers', 'certKeyChain'\n    ]\n\n    returnables = [\n        'ciphers'\n    ]\n\n    updatables = [\n        'ciphers', 'cert_key_chain'\n    ]\n\n\nclass ModuleParameters(Parameters):\n    def _fqdn_name(self, value):\n        if value is not None and not value.startswith('/'):\n            return '/{0}/{1}'.format(self.partition, value)\n        return value\n\n    def _key_filename(self, name):\n        if name.endswith('.key'):\n            return name\n        else:\n            return name + '.key'\n\n    def _cert_filename(self, name):\n        if name.endswith('.crt'):\n            return name\n        else:\n            return name + '.crt'\n\n    def _get_chain_value(self, item):\n        if 'chain' not in item or item['chain'] == 'none':\n            result = 'none'\n        else:\n            result = self._cert_filename(self._fqdn_name(item['chain']))\n        return result\n\n    @property\n    def parent(self):\n        if self._values['parent'] is None:\n            return None\n        result = self._fqdn_name(self._values['parent'])\n        return result\n\n    @property\n    def cert_key_chain(self):\n        if self._values['cert_key_chain'] is None:\n            return None\n        result = []\n        for item in self._values['cert_key_chain']:\n            if 'key' in item and 'cert' not in item:\n                raise F5ModuleError(\n                    \"When providing a 'key', you must also provide a 'cert'\"\n                )\n            if 'cert' in item and 'key' not in item:\n                raise F5ModuleError(\n                    \"When providing a 'cert', you must also provide a 'key'\"\n                )\n            key = self._key_filename(item['key'])\n            cert = self._cert_filename(item['cert'])\n            chain = self._get_chain_value(item)\n            name = os.path.basename(cert)\n            filename, ex = os.path.splitext(name)\n            tmp = {\n                'name': filename,\n                'cert': self._fqdn_name(cert),\n                'key': self._fqdn_name(key),\n                'chain': chain\n            }\n            if 'passphrase' in item:\n                tmp['passphrase'] = item['passphrase']\n            result.append(tmp)\n        result = sorted(result, key=lambda x: x['name'])\n        return result\n\n\nclass ApiParameters(Parameters):\n    @property\n    def cert_key_chain(self):\n        if self._values['cert_key_chain'] is None:\n            return None\n        result = []\n        for item in self._values['cert_key_chain']:\n            tmp = dict(\n                name=item['name'],\n            )\n            for x in ['cert', 'key', 'chain', 'passphrase']:\n                if x in item:\n                    tmp[x] = item[x]\n                if 'chain' not in item:\n                    tmp['chain'] = 'none'\n            result.append(tmp)\n        result = sorted(result, key=lambda y: y['name'])\n        return result\n\n\nclass Changes(Parameters):\n    def to_return(self):\n        result = {}\n        try:\n            for returnable in self.returnables:\n                result[returnable] = getattr(self, returnable)\n            result = self._filter_params(result)\n        except Exception:\n            pass\n        return result\n\n\nclass UsableChanges(Changes):\n    pass\n\n\nclass ReportableChanges(Changes):\n    pass\n\n\nclass Difference(object):\n    def __init__(self, want, have=None):\n        self.want = want\n        self.have = have\n\n    def compare(self, param):\n        try:\n            result = getattr(self, param)\n            return result\n        except AttributeError:\n            result = self.__default(param)\n            return result\n\n    def __default(self, param):\n        attr1 = getattr(self.want, param)\n        try:\n            attr2 = getattr(self.have, param)\n            if attr1 != attr2:\n                return attr1\n        except AttributeError:\n            return attr1\n\n    def to_tuple(self, items):\n        result = []\n        for x in items:\n            tmp = [(str(k), str(v)) for k, v in iteritems(x)]\n            result += tmp\n        return result\n\n    def _diff_complex_items(self, want, have):\n        if want == [] and have is None:\n            return None\n        if want is None:\n            return None\n        w = self.to_tuple(want)\n        h = self.to_tuple(have)\n        if set(w).issubset(set(h)):\n            return None\n        else:\n            return want\n\n    @property\n    def parent(self):\n        if self.want.parent != self.have.parent:\n            raise F5ModuleError(\n                \"The parent profile cannot be changed\"\n            )\n\n    @property\n    def cert_key_chain(self):\n        result = self._diff_complex_items(self.want.cert_key_chain, self.have.cert_key_chain)\n        return result\n\n\nclass ModuleManager(object):\n    def __init__(self, *args, **kwargs):\n        self.module = kwargs.get('module', None)\n        self.client = kwargs.get('client', None)\n        self.want = ModuleParameters(params=self.module.params)\n        self.have = ApiParameters()\n        self.changes = UsableChanges()\n\n    def _set_changed_options(self):\n        changed = {}\n        for key in Parameters.returnables:\n            if getattr(self.want, key) is not None:\n                changed[key] = getattr(self.want, key)\n        if changed:\n            self.changes = UsableChanges(params=changed)\n\n    def _update_changed_options(self):\n        diff = Difference(self.want, self.have)\n        updatables = Parameters.updatables\n        changed = dict()\n        for k in updatables:\n            change = diff.compare(k)\n            if change is None:\n                continue\n            else:\n                if isinstance(change, dict):\n                    changed.update(change)\n                else:\n                    changed[k] = change\n        if changed:\n            self.changes = UsableChanges(params=changed)\n            return True\n        return False\n\n    def exec_module(self):\n        changed = False\n        result = dict()\n        state = self.want.state\n\n        try:\n            if state == \"present\":\n                changed = self.present()\n            elif state == \"absent\":\n                changed = self.absent()\n        except iControlUnexpectedHTTPError as e:\n            raise F5ModuleError(str(e))\n\n        reportable = ReportableChanges(params=self.changes.to_return())\n        changes = reportable.to_return()\n        result.update(**changes)\n        result.update(dict(changed=changed))\n        self._announce_deprecations(result)\n        return result\n\n    def _announce_deprecations(self, result):\n        warnings = result.pop('__warnings', [])\n        for warning in warnings:\n            self.module.deprecate(\n                msg=warning['msg'],\n                version=warning['version']\n            )\n\n    def present(self):\n        if self.exists():\n            return self.update()\n        else:\n            return self.create()\n\n    def create(self):\n        self._set_changed_options()\n        if self.want.ciphers is None:\n            self.want.update({'ciphers': 'DEFAULT'})\n        if self.module.check_mode:\n            return True\n        self.create_on_device()\n        return True\n\n    def should_update(self):\n        result = self._update_changed_options()\n        if result:\n            return True\n        return False\n\n    def update(self):\n        self.have = self.read_current_from_device()\n        if not self.should_update():\n            return False\n        if self.module.check_mode:\n            return True\n        self.update_on_device()\n        return True\n\n    def absent(self):\n        if self.exists():\n            return self.remove()\n        return False\n\n    def remove(self):\n        if self.module.check_mode:\n            return True\n        self.remove_from_device()\n        if self.exists():\n            raise F5ModuleError(\"Failed to delete the profile.\")\n        return True\n\n    def read_current_from_device(self):\n        resource = self.client.api.tm.ltm.profile.client_ssls.client_ssl.load(\n            name=self.want.name,\n            partition=self.want.partition\n        )\n        result = resource.attrs\n        return ApiParameters(params=result)\n\n    def exists(self):\n        result = self.client.api.tm.ltm.profile.client_ssls.client_ssl.exists(\n            name=self.want.name,\n            partition=self.want.partition\n        )\n        return result\n\n    def update_on_device(self):\n        params = self.changes.api_params()\n        result = self.client.api.tm.ltm.profile.client_ssls.client_ssl.load(\n            name=self.want.name,\n            partition=self.want.partition\n        )\n        result.modify(**params)\n\n    def create_on_device(self):\n        params = self.want.api_params()\n        self.client.api.tm.ltm.profile.client_ssls.client_ssl.create(\n            name=self.want.name,\n            partition=self.want.partition,\n            **params\n        )\n\n    def remove_from_device(self):\n        result = self.client.api.tm.ltm.profile.client_ssls.client_ssl.load(\n            name=self.want.name,\n            partition=self.want.partition\n        )\n        if result:\n            result.delete()\n\n\nclass ArgumentSpec(object):\n    def __init__(self):\n        self.supports_check_mode = True\n        argument_spec = dict(\n            name=dict(required=True),\n            parent=dict(),\n            ciphers=dict(),\n            cert_key_chain=dict(\n                type='list',\n                options=dict(\n                    cert=dict(required=True),\n                    key=dict(required=True),\n                    chain=dict(),\n                    passphrase=dict()\n                )\n            ),\n            state=dict(\n                default='present',\n                choices=['present', 'absent']\n            ),\n            partition=dict(\n                default='Common',\n                fallback=(env_fallback, ['F5_PARTITION'])\n            )\n        )\n        self.argument_spec = {}\n        self.argument_spec.update(f5_argument_spec)\n        self.argument_spec.update(argument_spec)\n\n\ndef main():\n    spec = ArgumentSpec()\n\n    module = AnsibleModule(\n        argument_spec=spec.argument_spec,\n        supports_check_mode=spec.supports_check_mode\n    )\n    if not HAS_F5SDK:\n        module.fail_json(msg=\"The python f5-sdk module is required\")\n\n    try:\n        client = F5Client(**module.params)\n        mm = ModuleManager(module=module, client=client)\n        results = mm.exec_module()\n        cleanup_tokens(client)\n        module.exit_json(**results)\n    except F5ModuleError as ex:\n        cleanup_tokens(client)\n        module.fail_json(msg=str(ex))\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  bigip profile client ssl short description  manages client ssl profiles big ip description  manages client ssl profiles big ip  version added   2 5  options    name      description          specifies name profile      required  true   parent      description          the parent template monitor template  once value         set  cannot changed  by default  value c(clientssl)         parent c(common) partition      default    common clientssl    ciphers      description          specifies list ciphers system supports  when creating new         profile  default cipher list c(default)    cert key chain      description          one certificates keys associate ssl profile  this         option always list  the keys list dictate details         client key chain combination  note big ips one         type certificate key type  this means one         rsa  one dsa  one ecdsa per profile  if attempt assign two         rsa  dsa  ecdsa certificate key combo  device reject          this list complex list specifies number keys  there several supported keys      suboptions        cert          description              specifies cert name use          required  true       key          description              contains key name          required  true       chain          description              contains certificate chain relevant certificate key             mentioned earlier              this key optional        passphrase          description              contains passphrase key file  require one              passphrases encrypted remote big ip device  therefore  way             compare updating client ssl profile  due  specify             passphrase  module always register c(changed) event    partition      description          device partition manage resources      default  common     version added  2 5   state      description          when c(present)  ensures profile exists          when c(absent)  ensures profile removed      default  present     choices          present         absent     version added  2 5 notes      requires big ip software version    12 extends documentation fragment  f5 author      tim rupp ( caphrim007)      examples   r      name  create client ssl profile   bigip profile client ssl      state  present     server  lb mydomain com     user  admin     password  secret     name  profile   delegate  localhost    name  create client ssl profile specific ciphers   bigip profile client ssl      state  present     server  lb mydomain com     user  admin     password  secret     name  profile     ciphers    sslv3  sslv2 ecdhe aes gcm sha256 ecdhe rsa aes128 cbc sha    delegate  localhost    name  create client ssl profile cert key chain setting   bigip profile client ssl      state  present     server  lb mydomain com     user  admin     password  secret     name  profile     cert key chain          cert  bigip ssl cert1         key  bigip ssl key1         chain  bigip ssl cert1   delegate  localhost      return   r    ciphers    description  the ciphers applied profile    returned  changed   type  string   sample    sslv3  sslv2 ecdhe aes gcm sha256 ecdhe rsa aes128 cbc sha          usr bin python        coding  utf 8           copyright (c) 2017 f5 networks inc     gnu general public license v3 0 (see copying https   www gnu org licenses gpl 3 0 txt)    sideband repository used dev    upstream ansible ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n#\n# Copyright (c) 2017 F5 Networks Inc.\n# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = r'''\n---\nmodule: bigip_profile_client_ssl\nshort_description: Manages client SSL profiles on a BIG-IP\ndescription: Manages client SSL profiles on a BIG-IP.\nversion_added: \"2.5\"\noptions:\n  name:\n    description:\n      - Specifies the name of the profile.\n    required: True\n  parent:\n    description:\n      - The parent template of this monitor template. Once this value has\n        been set, it cannot be changed. By default, this value is the C(clientssl)\n        parent on the C(Common) partition.\n    default: \"/Common/clientssl\"\n  ciphers:\n    description:\n      - Specifies the list of ciphers that the system supports. When creating a new\n        profile, the default cipher list is C(DEFAULT).\n  cert_key_chain:\n    description:\n      - One or more certificates and keys to associate with the SSL profile. This\n        option is always a list. The keys in the list dictate the details of the\n        client/key/chain combination. Note that BIG-IPs can only have one of each\n        type of each certificate/key type. This means that you can only have one\n        RSA, one DSA, and one ECDSA per profile. If you attempt to assign two\n        RSA, DSA, or ECDSA certificate/key combo, the device will reject this.\n      - This list is a complex list that specifies a number of keys. There are several supported keys.\n    suboptions:\n      cert:\n        description:\n          - Specifies a cert name for use.\n        required: True\n      key:\n        description:\n          - Contains a key name.\n        required: True\n      chain:\n        description:\n          - Contains a certificate chain that is relevant to the certificate and key\n            mentioned earlier.\n          - This key is optional.\n      passphrase:\n        description:\n          - Contains the passphrase of the key file, should it require one.\n          - Passphrases are encrypted on the remote BIG-IP device. Therefore, there is no way\n            to compare them when updating a client SSL profile. Due to this, if you specify a\n            passphrase, this module will always register a C(changed) event.\n  partition:\n    description:\n      - Device partition to manage resources on.\n    default: Common\n    version_added: 2.5\n  state:\n    description:\n      - When C(present), ensures that the profile exists.\n      - When C(absent), ensures the profile is removed.\n    default: present\n    choices:\n      - present\n      - absent\n    version_added: 2.5\nnotes:\n  - Requires BIG-IP software version >= 12\nextends_documentation_fragment: f5\nauthor:\n  - Tim Rupp (@caphrim007)\n'''\n\nEXAMPLES = r'''\n- name: Create client SSL profile\n  bigip_profile_client_ssl:\n    state: present\n    server: lb.mydomain.com\n    user: admin\n    password: secret\n    name: my_profile\n  delegate_to: localhost\n\n- name: Create client SSL profile with specific ciphers\n  bigip_profile_client_ssl:\n    state: present\n    server: lb.mydomain.com\n    user: admin\n    password: secret\n    name: my_profile\n    ciphers: \"!SSLv3:!SSLv2:ECDHE+AES-GCM+SHA256:ECDHE-RSA-AES128-CBC-SHA\"\n  delegate_to: localhost\n\n- name: Create a client SSL profile with a cert/key/chain setting\n  bigip_profile_client_ssl:\n    state: present\n    server: lb.mydomain.com\n    user: admin\n    password: secret\n    name: my_profile\n    cert_key_chain:\n      - cert: bigip_ssl_cert1\n        key: bigip_ssl_key1\n        chain: bigip_ssl_cert1\n  delegate_to: localhost\n'''\n\nRETURN = r'''\nciphers:\n  description: The ciphers applied to the profile.\n  returned: changed\n  type: string\n  sample: \"!SSLv3:!SSLv2:ECDHE+AES-GCM+SHA256:ECDHE-RSA-AES128-CBC-SHA\"\n'''\n\nimport os\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.basic import env_fallback\nfrom ansible.module_utils.six import iteritems\n\nHAS_DEVEL_IMPORTS = False\n\ntry:\n    # Sideband repository used for dev\n    from library.module_utils.network.f5.bigip import HAS_F5SDK\n    from library.module_utils.network.f5.bigip import F5Client\n    from library.module_utils.network.f5.common import F5ModuleError\n    from library.module_utils.network.f5.common import AnsibleF5Parameters\n    from library.module_utils.network.f5.common import cleanup_tokens\n    from library.module_utils.network.f5.common import fqdn_name\n    from library.module_utils.network.f5.common import f5_argument_spec\n    try:\n        from library.module_utils.network.f5.common import iControlUnexpectedHTTPError\n    except ImportError:\n        HAS_F5SDK = False\n    HAS_DEVEL_IMPORTS = True\nexcept ImportError:\n    # Upstream Ansible\n    from ansible.module_utils.network.f5.bigip import HAS_F5SDK\n    from ansible.module_utils.network.f5.bigip import F5Client\n    from ansible.module_utils.network.f5.common import F5ModuleError\n    from ansible.module_utils.network.f5.common import AnsibleF5Parameters\n    from ansible.module_utils.network.f5.common import cleanup_tokens\n    from ansible.module_utils.network.f5.common import fqdn_name\n    from ansible.module_utils.network.f5.common import f5_argument_spec\n    try:\n        from ansible.module_utils.network.f5.common import iControlUnexpectedHTTPError\n    except ImportError:\n        HAS_F5SDK = False\n\n\nclass Parameters(AnsibleF5Parameters):\n    api_map = {\n        'certKeyChain': 'cert_key_chain'\n    }\n\n    api_attributes = [\n        'ciphers', 'certKeyChain'\n    ]\n\n    returnables = [\n        'ciphers'\n    ]\n\n    updatables = [\n        'ciphers', 'cert_key_chain'\n    ]\n\n\nclass ModuleParameters(Parameters):\n    def _fqdn_name(self, value):\n        if value is not None and not value.startswith('/'):\n            return '/{0}/{1}'.format(self.partition, value)\n        return value\n\n    def _key_filename(self, name):\n        if name.endswith('.key'):\n            return name\n        else:\n            return name + '.key'\n\n    def _cert_filename(self, name):\n        if name.endswith('.crt'):\n            return name\n        else:\n            return name + '.crt'\n\n    def _get_chain_value(self, item):\n        if 'chain' not in item or item['chain'] == 'none':\n            result = 'none'\n        else:\n            result = self._cert_filename(self._fqdn_name(item['chain']))\n        return result\n\n    @property\n    def parent(self):\n        if self._values['parent'] is None:\n            return None\n        result = self._fqdn_name(self._values['parent'])\n        return result\n\n    @property\n    def cert_key_chain(self):\n        if self._values['cert_key_chain'] is None:\n            return None\n        result = []\n        for item in self._values['cert_key_chain']:\n            if 'key' in item and 'cert' not in item:\n                raise F5ModuleError(\n                    \"When providing a 'key', you must also provide a 'cert'\"\n                )\n            if 'cert' in item and 'key' not in item:\n                raise F5ModuleError(\n                    \"When providing a 'cert', you must also provide a 'key'\"\n                )\n            key = self._key_filename(item['key'])\n            cert = self._cert_filename(item['cert'])\n            chain = self._get_chain_value(item)\n            name = os.path.basename(cert)\n            filename, ex = os.path.splitext(name)\n            tmp = {\n                'name': filename,\n                'cert': self._fqdn_name(cert),\n                'key': self._fqdn_name(key),\n                'chain': chain\n            }\n            if 'passphrase' in item:\n                tmp['passphrase'] = item['passphrase']\n            result.append(tmp)\n        result = sorted(result, key=lambda x: x['name'])\n        return result\n\n\nclass ApiParameters(Parameters):\n    @property\n    def cert_key_chain(self):\n        if self._values['cert_key_chain'] is None:\n            return None\n        result = []\n        for item in self._values['cert_key_chain']:\n            tmp = dict(\n                name=item['name'],\n            )\n            for x in ['cert', 'key', 'chain', 'passphrase']:\n                if x in item:\n                    tmp[x] = item[x]\n                if 'chain' not in item:\n                    tmp['chain'] = 'none'\n            result.append(tmp)\n        result = sorted(result, key=lambda y: y['name'])\n        return result\n\n\nclass Changes(Parameters):\n    def to_return(self):\n        result = {}\n        try:\n            for returnable in self.returnables:\n                result[returnable] = getattr(self, returnable)\n            result = self._filter_params(result)\n        except Exception:\n            pass\n        return result\n\n\nclass UsableChanges(Changes):\n    pass\n\n\nclass ReportableChanges(Changes):\n    pass\n\n\nclass Difference(object):\n    def __init__(self, want, have=None):\n        self.want = want\n        self.have = have\n\n    def compare(self, param):\n        try:\n            result = getattr(self, param)\n            return result\n        except AttributeError:\n            result = self.__default(param)\n            return result\n\n    def __default(self, param):\n        attr1 = getattr(self.want, param)\n        try:\n            attr2 = getattr(self.have, param)\n            if attr1 != attr2:\n                return attr1\n        except AttributeError:\n            return attr1\n\n    def to_tuple(self, items):\n        result = []\n        for x in items:\n            tmp = [(str(k), str(v)) for k, v in iteritems(x)]\n            result += tmp\n        return result\n\n    def _diff_complex_items(self, want, have):\n        if want == [] and have is None:\n            return None\n        if want is None:\n            return None\n        w = self.to_tuple(want)\n        h = self.to_tuple(have)\n        if set(w).issubset(set(h)):\n            return None\n        else:\n            return want\n\n    @property\n    def parent(self):\n        if self.want.parent != self.have.parent:\n            raise F5ModuleError(\n                \"The parent profile cannot be changed\"\n            )\n\n    @property\n    def cert_key_chain(self):\n        result = self._diff_complex_items(self.want.cert_key_chain, self.have.cert_key_chain)\n        return result\n\n\nclass ModuleManager(object):\n    def __init__(self, *args, **kwargs):\n        self.module = kwargs.get('module', None)\n        self.client = kwargs.get('client', None)\n        self.want = ModuleParameters(params=self.module.params)\n        self.have = ApiParameters()\n        self.changes = UsableChanges()\n\n    def _set_changed_options(self):\n        changed = {}\n        for key in Parameters.returnables:\n            if getattr(self.want, key) is not None:\n                changed[key] = getattr(self.want, key)\n        if changed:\n            self.changes = UsableChanges(params=changed)\n\n    def _update_changed_options(self):\n        diff = Difference(self.want, self.have)\n        updatables = Parameters.updatables\n        changed = dict()\n        for k in updatables:\n            change = diff.compare(k)\n            if change is None:\n                continue\n            else:\n                if isinstance(change, dict):\n                    changed.update(change)\n                else:\n                    changed[k] = change\n        if changed:\n            self.changes = UsableChanges(params=changed)\n            return True\n        return False\n\n    def exec_module(self):\n        changed = False\n        result = dict()\n        state = self.want.state\n\n        try:\n            if state == \"present\":\n                changed = self.present()\n            elif state == \"absent\":\n                changed = self.absent()\n        except iControlUnexpectedHTTPError as e:\n            raise F5ModuleError(str(e))\n\n        reportable = ReportableChanges(params=self.changes.to_return())\n        changes = reportable.to_return()\n        result.update(**changes)\n        result.update(dict(changed=changed))\n        self._announce_deprecations(result)\n        return result\n\n    def _announce_deprecations(self, result):\n        warnings = result.pop('__warnings', [])\n        for warning in warnings:\n            self.module.deprecate(\n                msg=warning['msg'],\n                version=warning['version']\n            )\n\n    def present(self):\n        if self.exists():\n            return self.update()\n        else:\n            return self.create()\n\n    def create(self):\n        self._set_changed_options()\n        if self.want.ciphers is None:\n            self.want.update({'ciphers': 'DEFAULT'})\n        if self.module.check_mode:\n            return True\n        self.create_on_device()\n        return True\n\n    def should_update(self):\n        result = self._update_changed_options()\n        if result:\n            return True\n        return False\n\n    def update(self):\n        self.have = self.read_current_from_device()\n        if not self.should_update():\n            return False\n        if self.module.check_mode:\n            return True\n        self.update_on_device()\n        return True\n\n    def absent(self):\n        if self.exists():\n            return self.remove()\n        return False\n\n    def remove(self):\n        if self.module.check_mode:\n            return True\n        self.remove_from_device()\n        if self.exists():\n            raise F5ModuleError(\"Failed to delete the profile.\")\n        return True\n\n    def read_current_from_device(self):\n        resource = self.client.api.tm.ltm.profile.client_ssls.client_ssl.load(\n            name=self.want.name,\n            partition=self.want.partition\n        )\n        result = resource.attrs\n        return ApiParameters(params=result)\n\n    def exists(self):\n        result = self.client.api.tm.ltm.profile.client_ssls.client_ssl.exists(\n            name=self.want.name,\n            partition=self.want.partition\n        )\n        return result\n\n    def update_on_device(self):\n        params = self.changes.api_params()\n        result = self.client.api.tm.ltm.profile.client_ssls.client_ssl.load(\n            name=self.want.name,\n            partition=self.want.partition\n        )\n        result.modify(**params)\n\n    def create_on_device(self):\n        params = self.want.api_params()\n        self.client.api.tm.ltm.profile.client_ssls.client_ssl.create(\n            name=self.want.name,\n            partition=self.want.partition,\n            **params\n        )\n\n    def remove_from_device(self):\n        result = self.client.api.tm.ltm.profile.client_ssls.client_ssl.load(\n            name=self.want.name,\n            partition=self.want.partition\n        )\n        if result:\n            result.delete()\n\n\nclass ArgumentSpec(object):\n    def __init__(self):\n        self.supports_check_mode = True\n        argument_spec = dict(\n            name=dict(required=True),\n            parent=dict(),\n            ciphers=dict(),\n            cert_key_chain=dict(\n                type='list',\n                options=dict(\n                    cert=dict(required=True),\n                    key=dict(required=True),\n                    chain=dict(),\n                    passphrase=dict()\n                )\n            ),\n            state=dict(\n                default='present',\n                choices=['present', 'absent']\n            ),\n            partition=dict(\n                default='Common',\n                fallback=(env_fallback, ['F5_PARTITION'])\n            )\n        )\n        self.argument_spec = {}\n        self.argument_spec.update(f5_argument_spec)\n        self.argument_spec.update(argument_spec)\n\n\ndef main():\n    spec = ArgumentSpec()\n\n    module = AnsibleModule(\n        argument_spec=spec.argument_spec,\n        supports_check_mode=spec.supports_check_mode\n    )\n    if not HAS_F5SDK:\n        module.fail_json(msg=\"The python f5-sdk module is required\")\n\n    try:\n        client = F5Client(**module.params)\n        mm = ModuleManager(module=module, client=client)\n        results = mm.exec_module()\n        cleanup_tokens(client)\n        module.exit_json(**results)\n    except F5ModuleError as ex:\n        cleanup_tokens(client)\n        module.fail_json(msg=str(ex))\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "bigip_profile_client_ssl.py", "id": "155b84a124171d83303872cdb6a45109", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/network/f5/bigip_profile_client_ssl.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}