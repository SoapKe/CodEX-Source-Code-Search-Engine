{"author": "nvbn", "code": "import pytest\nimport six\nimport os\nfrom mock import Mock\nfrom thefuck import const\n\n\n@pytest.fixture\ndef load_source(mocker):\n    return mocker.patch('thefuck.conf.load_source')\n\n\ndef test_settings_defaults(load_source, settings):\n    load_source.return_value = object()\n    settings.init()\n    for key, val in const.DEFAULT_SETTINGS.items():\n        assert getattr(settings, key) == val\n\n\nclass TestSettingsFromFile(object):\n    def test_from_file(self, load_source, settings):\n        load_source.return_value = Mock(rules=['test'],\n                                        wait_command=10,\n                                        require_confirmation=True,\n                                        no_colors=True,\n                                        priority={'vim': 100},\n                                        exclude_rules=['git'])\n        settings.init()\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n        assert settings.priority == {'vim': 100}\n        assert settings.exclude_rules == ['git']\n\n    def test_from_file_with_DEFAULT(self, load_source, settings):\n        load_source.return_value = Mock(rules=const.DEFAULT_RULES + ['test'],\n                                        wait_command=10,\n                                        exclude_rules=[],\n                                        require_confirmation=True,\n                                        no_colors=True)\n        settings.init()\n        assert settings.rules == const.DEFAULT_RULES + ['test']\n\n\n@pytest.mark.usefixture('load_source')\nclass TestSettingsFromEnv(object):\n    def test_from_env(self, os_environ, settings):\n        os_environ.update({'THEFUCK_RULES': 'bash:lisp',\n                           'THEFUCK_EXCLUDE_RULES': 'git:vim',\n                           'THEFUCK_WAIT_COMMAND': '55',\n                           'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                           'THEFUCK_NO_COLORS': 'false',\n                           'THEFUCK_PRIORITY': 'bash=10:lisp=wrong:vim=15',\n                           'THEFUCK_WAIT_SLOW_COMMAND': '999',\n                           'THEFUCK_SLOW_COMMANDS': 'lein:react-native:./gradlew'})\n        settings.init()\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.exclude_rules == ['git', 'vim']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n        assert settings.priority == {'bash': 10, 'vim': 15}\n        assert settings.wait_slow_command == 999\n        assert settings.slow_commands == ['lein', 'react-native', './gradlew']\n\n    def test_from_env_with_DEFAULT(self, os_environ, settings):\n        os_environ.update({'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'})\n        settings.init()\n        assert settings.rules == const.DEFAULT_RULES + ['bash', 'lisp']\n\n\ndef test_settings_from_args(settings):\n    settings.init(Mock(yes=True, debug=True, repeat=True))\n    assert not settings.require_confirmation\n    assert settings.debug\n    assert settings.repeat\n\n\nclass TestInitializeSettingsFile(object):\n    def test_ignore_if_exists(self, settings):\n        settings_path_mock = Mock(is_file=Mock(return_value=True), open=Mock())\n        settings.user_dir = Mock(joinpath=Mock(return_value=settings_path_mock))\n        settings._init_settings_file()\n        assert settings_path_mock.is_file.call_count == 1\n        assert not settings_path_mock.open.called\n\n    def test_create_if_doesnt_exists(self, settings):\n        settings_file = six.StringIO()\n        settings_path_mock = Mock(\n            is_file=Mock(return_value=False),\n            open=Mock(return_value=Mock(\n                __exit__=lambda *args: None, __enter__=lambda *args: settings_file)))\n        settings.user_dir = Mock(joinpath=Mock(return_value=settings_path_mock))\n        settings._init_settings_file()\n        settings_file_contents = settings_file.getvalue()\n        assert settings_path_mock.is_file.call_count == 1\n        assert settings_path_mock.open.call_count == 1\n        assert const.SETTINGS_HEADER in settings_file_contents\n        for setting in const.DEFAULT_SETTINGS.items():\n            assert '\n        settings_file.close()\n\n\n@pytest.mark.parametrize('legacy_dir_exists, xdg_config_home, result', [\n    (False, '~/.config', '~/.config/thefuck'),\n    (False, '/user/test/config/', '/user/test/config/thefuck'),\n    (True, '~/.config', '~/.thefuck'),\n    (True, '/user/test/config/', '~/.thefuck')])\ndef test_get_user_dir_path(mocker, os_environ, settings, legacy_dir_exists,\n                           xdg_config_home, result):\n    mocker.patch('thefuck.conf.Path.is_dir',\n                 return_value=legacy_dir_exists)\n\n    if xdg_config_home is not None:\n        os_environ['XDG_CONFIG_HOME'] = xdg_config_home\n    else:\n        os_environ.pop('XDG_CONFIG_HOME', None)\n\n    path = settings._get_user_dir_path().as_posix()\n    assert path == os.path.expanduser(result)\n", "comments": "# {} = {}\\n'.format(*setting) in settings_file_contents\n", "content": "import pytest\nimport six\nimport os\nfrom mock import Mock\nfrom thefuck import const\n\n\n@pytest.fixture\ndef load_source(mocker):\n    return mocker.patch('thefuck.conf.load_source')\n\n\ndef test_settings_defaults(load_source, settings):\n    load_source.return_value = object()\n    settings.init()\n    for key, val in const.DEFAULT_SETTINGS.items():\n        assert getattr(settings, key) == val\n\n\nclass TestSettingsFromFile(object):\n    def test_from_file(self, load_source, settings):\n        load_source.return_value = Mock(rules=['test'],\n                                        wait_command=10,\n                                        require_confirmation=True,\n                                        no_colors=True,\n                                        priority={'vim': 100},\n                                        exclude_rules=['git'])\n        settings.init()\n        assert settings.rules == ['test']\n        assert settings.wait_command == 10\n        assert settings.require_confirmation is True\n        assert settings.no_colors is True\n        assert settings.priority == {'vim': 100}\n        assert settings.exclude_rules == ['git']\n\n    def test_from_file_with_DEFAULT(self, load_source, settings):\n        load_source.return_value = Mock(rules=const.DEFAULT_RULES + ['test'],\n                                        wait_command=10,\n                                        exclude_rules=[],\n                                        require_confirmation=True,\n                                        no_colors=True)\n        settings.init()\n        assert settings.rules == const.DEFAULT_RULES + ['test']\n\n\n@pytest.mark.usefixture('load_source')\nclass TestSettingsFromEnv(object):\n    def test_from_env(self, os_environ, settings):\n        os_environ.update({'THEFUCK_RULES': 'bash:lisp',\n                           'THEFUCK_EXCLUDE_RULES': 'git:vim',\n                           'THEFUCK_WAIT_COMMAND': '55',\n                           'THEFUCK_REQUIRE_CONFIRMATION': 'true',\n                           'THEFUCK_NO_COLORS': 'false',\n                           'THEFUCK_PRIORITY': 'bash=10:lisp=wrong:vim=15',\n                           'THEFUCK_WAIT_SLOW_COMMAND': '999',\n                           'THEFUCK_SLOW_COMMANDS': 'lein:react-native:./gradlew'})\n        settings.init()\n        assert settings.rules == ['bash', 'lisp']\n        assert settings.exclude_rules == ['git', 'vim']\n        assert settings.wait_command == 55\n        assert settings.require_confirmation is True\n        assert settings.no_colors is False\n        assert settings.priority == {'bash': 10, 'vim': 15}\n        assert settings.wait_slow_command == 999\n        assert settings.slow_commands == ['lein', 'react-native', './gradlew']\n\n    def test_from_env_with_DEFAULT(self, os_environ, settings):\n        os_environ.update({'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'})\n        settings.init()\n        assert settings.rules == const.DEFAULT_RULES + ['bash', 'lisp']\n\n\ndef test_settings_from_args(settings):\n    settings.init(Mock(yes=True, debug=True, repeat=True))\n    assert not settings.require_confirmation\n    assert settings.debug\n    assert settings.repeat\n\n\nclass TestInitializeSettingsFile(object):\n    def test_ignore_if_exists(self, settings):\n        settings_path_mock = Mock(is_file=Mock(return_value=True), open=Mock())\n        settings.user_dir = Mock(joinpath=Mock(return_value=settings_path_mock))\n        settings._init_settings_file()\n        assert settings_path_mock.is_file.call_count == 1\n        assert not settings_path_mock.open.called\n\n    def test_create_if_doesnt_exists(self, settings):\n        settings_file = six.StringIO()\n        settings_path_mock = Mock(\n            is_file=Mock(return_value=False),\n            open=Mock(return_value=Mock(\n                __exit__=lambda *args: None, __enter__=lambda *args: settings_file)))\n        settings.user_dir = Mock(joinpath=Mock(return_value=settings_path_mock))\n        settings._init_settings_file()\n        settings_file_contents = settings_file.getvalue()\n        assert settings_path_mock.is_file.call_count == 1\n        assert settings_path_mock.open.call_count == 1\n        assert const.SETTINGS_HEADER in settings_file_contents\n        for setting in const.DEFAULT_SETTINGS.items():\n            assert '# {} = {}\\n'.format(*setting) in settings_file_contents\n        settings_file.close()\n\n\n@pytest.mark.parametrize('legacy_dir_exists, xdg_config_home, result', [\n    (False, '~/.config', '~/.config/thefuck'),\n    (False, '/user/test/config/', '/user/test/config/thefuck'),\n    (True, '~/.config', '~/.thefuck'),\n    (True, '/user/test/config/', '~/.thefuck')])\ndef test_get_user_dir_path(mocker, os_environ, settings, legacy_dir_exists,\n                           xdg_config_home, result):\n    mocker.patch('thefuck.conf.Path.is_dir',\n                 return_value=legacy_dir_exists)\n\n    if xdg_config_home is not None:\n        os_environ['XDG_CONFIG_HOME'] = xdg_config_home\n    else:\n        os_environ.pop('XDG_CONFIG_HOME', None)\n\n    path = settings._get_user_dir_path().as_posix()\n    assert path == os.path.expanduser(result)\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "test_conf.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/tests/test_conf.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}