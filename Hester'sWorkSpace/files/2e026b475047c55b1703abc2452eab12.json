{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_HTTPError,\n    compat_str,\n    compat_urlparse,\n)\nfrom ..utils import (\n    ExtractorError,\n    int_or_none,\n    urlencode_postdata,\n)\n\n\nclass LyndaBaseIE(InfoExtractor):\n    _SIGNIN_URL = 'https://www.lynda.com/signin'\n    _PASSWORD_URL = 'https://www.lynda.com/signin/password'\n    _USER_URL = 'https://www.lynda.com/signin/user'\n    _ACCOUNT_CREDENTIALS_HINT = 'Use --username and --password options to provide lynda.com account credentials.'\n    _NETRC_MACHINE = 'lynda'\n\n    def _real_initialize(self):\n        self._login()\n\n    @staticmethod\n    def _check_error(json_string, key_or_keys):\n        keys = [key_or_keys] if isinstance(key_or_keys, compat_str) else key_or_keys\n        for key in keys:\n            error = json_string.get(key)\n            if error:\n                raise ExtractorError('Unable to login: %s' % error, expected=True)\n\n    def _login_step(self, form_html, fallback_action_url, extra_form_data, note, referrer_url):\n        action_url = self._search_regex(\n            r'<form[^>]+action=([\"\\'])(?P<url>.+?)\\1', form_html,\n            'post url', default=fallback_action_url, group='url')\n\n        if not action_url.startswith('http'):\n            action_url = compat_urlparse.urljoin(self._SIGNIN_URL, action_url)\n\n        form_data = self._hidden_inputs(form_html)\n        form_data.update(extra_form_data)\n\n        try:\n            response = self._download_json(\n                action_url, None, note,\n                data=urlencode_postdata(form_data),\n                headers={\n                    'Referer': referrer_url,\n                    'X-Requested-With': 'XMLHttpRequest',\n                })\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError) and e.cause.code == 500:\n                response = self._parse_json(e.cause.read().decode('utf-8'), None)\n                self._check_error(response, ('email', 'password'))\n            raise\n\n        self._check_error(response, 'ErrorMessage')\n\n        return response, action_url\n\n    def _login(self):\n        username, password = self._get_login_info()\n        if username is None:\n            return\n\n        \n        signin_page = self._download_webpage(\n            self._SIGNIN_URL, None, 'Downloading signin page')\n\n        \n        if any(re.search(p, signin_page) for p in (\n                r'isLoggedIn\\s*:\\s*true', r'logout\\.aspx', r'>Log out<')):\n            return\n\n        \n        signin_form = self._search_regex(\n            r'(?s)(<form[^>]+data-form-name=[\"\\']signin[\"\\'][^>]*>.+?</form>)',\n            signin_page, 'signin form')\n        signin_page, signin_url = self._login_step(\n            signin_form, self._PASSWORD_URL, {'email': username},\n            'Submitting email', self._SIGNIN_URL)\n\n        \n        password_form = signin_page['body']\n        self._login_step(\n            password_form, self._USER_URL, {'email': username, 'password': password},\n            'Submitting password', signin_url)\n\n\nclass LyndaIE(LyndaBaseIE):\n    IE_NAME = 'lynda'\n    IE_DESC = 'lynda.com videos'\n    _VALID_URL = r\n\n    _TIMECODE_REGEX = r'\\[(?P<timecode>\\d+:\\d+:\\d+[\\.,]\\d+)\\]'\n\n    _TESTS = [{\n        'url': 'https://www.lynda.com/Bootstrap-tutorials/Using-exercise-files/110885/114408-4.html',\n        \n        'info_dict': {\n            'id': '114408',\n            'ext': 'mp4',\n            'title': 'Using the exercise files',\n            'duration': 68\n        }\n    }, {\n        'url': 'https://www.lynda.com/player/embed/133770?tr=foo=1;bar=g;fizz=rt&fs=0',\n        'only_matching': True,\n    }, {\n        'url': 'https://educourse.ga/Bootstrap-tutorials/Using-exercise-files/110885/114408-4.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.lynda.com/de/Graphic-Design-tutorials/Willkommen-Grundlagen-guten-Gestaltung/393570/393572-4.html',\n        'only_matching': True,\n    }]\n\n    def _raise_unavailable(self, video_id):\n        self.raise_login_required(\n            'Video %s is only available for members' % video_id)\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        video_id = mobj.group('id')\n        course_id = mobj.group('course_id')\n\n        query = {\n            'videoId': video_id,\n            'type': 'video',\n        }\n\n        video = self._download_json(\n            'https://www.lynda.com/ajax/player', video_id,\n            'Downloading video JSON', fatal=False, query=query)\n\n        \n        if not video:\n            query['courseId'] = course_id\n\n            play = self._download_json(\n                'https://www.lynda.com/ajax/course/%s/%s/play'\n                % (course_id, video_id), video_id, 'Downloading play JSON')\n\n            if not play:\n                self._raise_unavailable(video_id)\n\n            formats = []\n            for formats_dict in play:\n                urls = formats_dict.get('urls')\n                if not isinstance(urls, dict):\n                    continue\n                cdn = formats_dict.get('name')\n                for format_id, format_url in urls.items():\n                    if not format_url:\n                        continue\n                    formats.append({\n                        'url': format_url,\n                        'format_id': '%s-%s' % (cdn, format_id) if cdn else format_id,\n                        'height': int_or_none(format_id),\n                    })\n            self._sort_formats(formats)\n\n            conviva = self._download_json(\n                'https://www.lynda.com/ajax/player/conviva', video_id,\n                'Downloading conviva JSON', query=query)\n\n            return {\n                'id': video_id,\n                'title': conviva['VideoTitle'],\n                'description': conviva.get('VideoDescription'),\n                'release_year': int_or_none(conviva.get('ReleaseYear')),\n                'duration': int_or_none(conviva.get('Duration')),\n                'creator': conviva.get('Author'),\n                'formats': formats,\n            }\n\n        if 'Status' in video:\n            raise ExtractorError(\n                'lynda returned error: %s' % video['Message'], expected=True)\n\n        if video.get('HasAccess') is False:\n            self._raise_unavailable(video_id)\n\n        video_id = compat_str(video.get('ID') or video_id)\n        duration = int_or_none(video.get('DurationInSeconds'))\n        title = video['Title']\n\n        formats = []\n\n        fmts = video.get('Formats')\n        if fmts:\n            formats.extend([{\n                'url': f['Url'],\n                'ext': f.get('Extension'),\n                'width': int_or_none(f.get('Width')),\n                'height': int_or_none(f.get('Height')),\n                'filesize': int_or_none(f.get('FileSize')),\n                'format_id': compat_str(f.get('Resolution')) if f.get('Resolution') else None,\n            } for f in fmts if f.get('Url')])\n\n        prioritized_streams = video.get('PrioritizedStreams')\n        if prioritized_streams:\n            for prioritized_stream_id, prioritized_stream in prioritized_streams.items():\n                formats.extend([{\n                    'url': video_url,\n                    'height': int_or_none(format_id),\n                    'format_id': '%s-%s' % (prioritized_stream_id, format_id),\n                } for format_id, video_url in prioritized_stream.items()])\n\n        self._check_formats(formats, video_id)\n        self._sort_formats(formats)\n\n        subtitles = self.extract_subtitles(video_id)\n\n        return {\n            'id': video_id,\n            'title': title,\n            'duration': duration,\n            'subtitles': subtitles,\n            'formats': formats\n        }\n\n    def _fix_subtitles(self, subs):\n        srt = ''\n        seq_counter = 0\n        for pos in range(0, len(subs) - 1):\n            seq_current = subs[pos]\n            m_current = re.match(self._TIMECODE_REGEX, seq_current['Timecode'])\n            if m_current is None:\n                continue\n            seq_next = subs[pos + 1]\n            m_next = re.match(self._TIMECODE_REGEX, seq_next['Timecode'])\n            if m_next is None:\n                continue\n            appear_time = m_current.group('timecode')\n            disappear_time = m_next.group('timecode')\n            text = seq_current['Caption'].strip()\n            if text:\n                seq_counter += 1\n                srt += '%s\\r\\n%s --> %s\\r\\n%s\\r\\n\\r\\n' % (seq_counter, appear_time, disappear_time, text)\n        if srt:\n            return srt\n\n    def _get_subtitles(self, video_id):\n        url = 'https://www.lynda.com/ajax/player?videoId=%s&type=transcript' % video_id\n        subs = self._download_json(url, None, False)\n        fixed_subs = self._fix_subtitles(subs)\n        if fixed_subs:\n            return {'en': [{'ext': 'srt', 'data': fixed_subs}]}\n        else:\n            return {}\n\n\nclass LyndaCourseIE(LyndaBaseIE):\n    IE_NAME = 'lynda:course'\n    IE_DESC = 'lynda.com online courses'\n\n    \n    \n    _VALID_URL = r'https?://(?:www|m)\\.(?:lynda\\.com|educourse\\.ga)/(?P<coursepath>(?:[^/]+/){2,3}(?P<courseid>\\d+))-2\\.html'\n\n    _TESTS = [{\n        'url': 'https://www.lynda.com/Graphic-Design-tutorials/Grundlagen-guten-Gestaltung/393570-2.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.lynda.com/de/Graphic-Design-tutorials/Grundlagen-guten-Gestaltung/393570-2.html',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        course_path = mobj.group('coursepath')\n        course_id = mobj.group('courseid')\n\n        item_template = 'https://www.lynda.com/%s/%%s-4.html' % course_path\n\n        course = self._download_json(\n            'https://www.lynda.com/ajax/player?courseId=%s&type=course' % course_id,\n            course_id, 'Downloading course JSON', fatal=False)\n\n        if not course:\n            webpage = self._download_webpage(url, course_id)\n            entries = [\n                self.url_result(\n                    item_template % video_id, ie=LyndaIE.ie_key(),\n                    video_id=video_id)\n                for video_id in re.findall(\n                    r'data-video-id=[\"\\'](\\d+)', webpage)]\n            return self.playlist_result(\n                entries, course_id,\n                self._og_search_title(webpage, fatal=False),\n                self._og_search_description(webpage))\n\n        if course.get('Status') == 'NotFound':\n            raise ExtractorError(\n                'Course %s does not exist' % course_id, expected=True)\n\n        unaccessible_videos = 0\n        entries = []\n\n        \n        \n\n        for chapter in course['Chapters']:\n            for video in chapter.get('Videos', []):\n                if video.get('HasAccess') is False:\n                    unaccessible_videos += 1\n                    continue\n                video_id = video.get('ID')\n                if video_id:\n                    entries.append({\n                        '_type': 'url_transparent',\n                        'url': item_template % video_id,\n                        'ie_key': LyndaIE.ie_key(),\n                        'chapter': chapter.get('Title'),\n                        'chapter_number': int_or_none(chapter.get('ChapterIndex')),\n                        'chapter_id': compat_str(chapter.get('ID')),\n                    })\n\n        if unaccessible_videos > 0:\n            self._downloader.report_warning(\n                '%s videos are only available for members (or paid members) and will not be downloaded. '\n                % unaccessible_videos + self._ACCOUNT_CREDENTIALS_HINT)\n\n        course_title = course.get('Title')\n        course_description = course.get('Description')\n\n        return self.playlist_result(entries, course_id, course_title, course_description)\n", "comments": "(?x)\n                    https?://\n                        (?:www\\.)?(?:lynda\\.com|educourse\\.ga)/\n                        (?:\n                            (?:[^/]+/){2,3}(?P<course_id>\\d+)|\n                            player/embed\n                        )/\n                        (?P<id>\\d+)\n                    \n \n# Step 1: download signin page\n# Already logged in\n# Step 2: submit email\n# Step 3: submit password\n# md5 is unstable\n# Fallback scenario\n# Course link equals to welcome/introduction video link of same course\n# We will recognize it as course link\n# Might want to extract videos right here from video['Formats'] as it seems 'Formats' is not provided\n# by single video API anymore\n", "content": "from __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_HTTPError,\n    compat_str,\n    compat_urlparse,\n)\nfrom ..utils import (\n    ExtractorError,\n    int_or_none,\n    urlencode_postdata,\n)\n\n\nclass LyndaBaseIE(InfoExtractor):\n    _SIGNIN_URL = 'https://www.lynda.com/signin'\n    _PASSWORD_URL = 'https://www.lynda.com/signin/password'\n    _USER_URL = 'https://www.lynda.com/signin/user'\n    _ACCOUNT_CREDENTIALS_HINT = 'Use --username and --password options to provide lynda.com account credentials.'\n    _NETRC_MACHINE = 'lynda'\n\n    def _real_initialize(self):\n        self._login()\n\n    @staticmethod\n    def _check_error(json_string, key_or_keys):\n        keys = [key_or_keys] if isinstance(key_or_keys, compat_str) else key_or_keys\n        for key in keys:\n            error = json_string.get(key)\n            if error:\n                raise ExtractorError('Unable to login: %s' % error, expected=True)\n\n    def _login_step(self, form_html, fallback_action_url, extra_form_data, note, referrer_url):\n        action_url = self._search_regex(\n            r'<form[^>]+action=([\"\\'])(?P<url>.+?)\\1', form_html,\n            'post url', default=fallback_action_url, group='url')\n\n        if not action_url.startswith('http'):\n            action_url = compat_urlparse.urljoin(self._SIGNIN_URL, action_url)\n\n        form_data = self._hidden_inputs(form_html)\n        form_data.update(extra_form_data)\n\n        try:\n            response = self._download_json(\n                action_url, None, note,\n                data=urlencode_postdata(form_data),\n                headers={\n                    'Referer': referrer_url,\n                    'X-Requested-With': 'XMLHttpRequest',\n                })\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError) and e.cause.code == 500:\n                response = self._parse_json(e.cause.read().decode('utf-8'), None)\n                self._check_error(response, ('email', 'password'))\n            raise\n\n        self._check_error(response, 'ErrorMessage')\n\n        return response, action_url\n\n    def _login(self):\n        username, password = self._get_login_info()\n        if username is None:\n            return\n\n        # Step 1: download signin page\n        signin_page = self._download_webpage(\n            self._SIGNIN_URL, None, 'Downloading signin page')\n\n        # Already logged in\n        if any(re.search(p, signin_page) for p in (\n                r'isLoggedIn\\s*:\\s*true', r'logout\\.aspx', r'>Log out<')):\n            return\n\n        # Step 2: submit email\n        signin_form = self._search_regex(\n            r'(?s)(<form[^>]+data-form-name=[\"\\']signin[\"\\'][^>]*>.+?</form>)',\n            signin_page, 'signin form')\n        signin_page, signin_url = self._login_step(\n            signin_form, self._PASSWORD_URL, {'email': username},\n            'Submitting email', self._SIGNIN_URL)\n\n        # Step 3: submit password\n        password_form = signin_page['body']\n        self._login_step(\n            password_form, self._USER_URL, {'email': username, 'password': password},\n            'Submitting password', signin_url)\n\n\nclass LyndaIE(LyndaBaseIE):\n    IE_NAME = 'lynda'\n    IE_DESC = 'lynda.com videos'\n    _VALID_URL = r'''(?x)\n                    https?://\n                        (?:www\\.)?(?:lynda\\.com|educourse\\.ga)/\n                        (?:\n                            (?:[^/]+/){2,3}(?P<course_id>\\d+)|\n                            player/embed\n                        )/\n                        (?P<id>\\d+)\n                    '''\n\n    _TIMECODE_REGEX = r'\\[(?P<timecode>\\d+:\\d+:\\d+[\\.,]\\d+)\\]'\n\n    _TESTS = [{\n        'url': 'https://www.lynda.com/Bootstrap-tutorials/Using-exercise-files/110885/114408-4.html',\n        # md5 is unstable\n        'info_dict': {\n            'id': '114408',\n            'ext': 'mp4',\n            'title': 'Using the exercise files',\n            'duration': 68\n        }\n    }, {\n        'url': 'https://www.lynda.com/player/embed/133770?tr=foo=1;bar=g;fizz=rt&fs=0',\n        'only_matching': True,\n    }, {\n        'url': 'https://educourse.ga/Bootstrap-tutorials/Using-exercise-files/110885/114408-4.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.lynda.com/de/Graphic-Design-tutorials/Willkommen-Grundlagen-guten-Gestaltung/393570/393572-4.html',\n        'only_matching': True,\n    }]\n\n    def _raise_unavailable(self, video_id):\n        self.raise_login_required(\n            'Video %s is only available for members' % video_id)\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        video_id = mobj.group('id')\n        course_id = mobj.group('course_id')\n\n        query = {\n            'videoId': video_id,\n            'type': 'video',\n        }\n\n        video = self._download_json(\n            'https://www.lynda.com/ajax/player', video_id,\n            'Downloading video JSON', fatal=False, query=query)\n\n        # Fallback scenario\n        if not video:\n            query['courseId'] = course_id\n\n            play = self._download_json(\n                'https://www.lynda.com/ajax/course/%s/%s/play'\n                % (course_id, video_id), video_id, 'Downloading play JSON')\n\n            if not play:\n                self._raise_unavailable(video_id)\n\n            formats = []\n            for formats_dict in play:\n                urls = formats_dict.get('urls')\n                if not isinstance(urls, dict):\n                    continue\n                cdn = formats_dict.get('name')\n                for format_id, format_url in urls.items():\n                    if not format_url:\n                        continue\n                    formats.append({\n                        'url': format_url,\n                        'format_id': '%s-%s' % (cdn, format_id) if cdn else format_id,\n                        'height': int_or_none(format_id),\n                    })\n            self._sort_formats(formats)\n\n            conviva = self._download_json(\n                'https://www.lynda.com/ajax/player/conviva', video_id,\n                'Downloading conviva JSON', query=query)\n\n            return {\n                'id': video_id,\n                'title': conviva['VideoTitle'],\n                'description': conviva.get('VideoDescription'),\n                'release_year': int_or_none(conviva.get('ReleaseYear')),\n                'duration': int_or_none(conviva.get('Duration')),\n                'creator': conviva.get('Author'),\n                'formats': formats,\n            }\n\n        if 'Status' in video:\n            raise ExtractorError(\n                'lynda returned error: %s' % video['Message'], expected=True)\n\n        if video.get('HasAccess') is False:\n            self._raise_unavailable(video_id)\n\n        video_id = compat_str(video.get('ID') or video_id)\n        duration = int_or_none(video.get('DurationInSeconds'))\n        title = video['Title']\n\n        formats = []\n\n        fmts = video.get('Formats')\n        if fmts:\n            formats.extend([{\n                'url': f['Url'],\n                'ext': f.get('Extension'),\n                'width': int_or_none(f.get('Width')),\n                'height': int_or_none(f.get('Height')),\n                'filesize': int_or_none(f.get('FileSize')),\n                'format_id': compat_str(f.get('Resolution')) if f.get('Resolution') else None,\n            } for f in fmts if f.get('Url')])\n\n        prioritized_streams = video.get('PrioritizedStreams')\n        if prioritized_streams:\n            for prioritized_stream_id, prioritized_stream in prioritized_streams.items():\n                formats.extend([{\n                    'url': video_url,\n                    'height': int_or_none(format_id),\n                    'format_id': '%s-%s' % (prioritized_stream_id, format_id),\n                } for format_id, video_url in prioritized_stream.items()])\n\n        self._check_formats(formats, video_id)\n        self._sort_formats(formats)\n\n        subtitles = self.extract_subtitles(video_id)\n\n        return {\n            'id': video_id,\n            'title': title,\n            'duration': duration,\n            'subtitles': subtitles,\n            'formats': formats\n        }\n\n    def _fix_subtitles(self, subs):\n        srt = ''\n        seq_counter = 0\n        for pos in range(0, len(subs) - 1):\n            seq_current = subs[pos]\n            m_current = re.match(self._TIMECODE_REGEX, seq_current['Timecode'])\n            if m_current is None:\n                continue\n            seq_next = subs[pos + 1]\n            m_next = re.match(self._TIMECODE_REGEX, seq_next['Timecode'])\n            if m_next is None:\n                continue\n            appear_time = m_current.group('timecode')\n            disappear_time = m_next.group('timecode')\n            text = seq_current['Caption'].strip()\n            if text:\n                seq_counter += 1\n                srt += '%s\\r\\n%s --> %s\\r\\n%s\\r\\n\\r\\n' % (seq_counter, appear_time, disappear_time, text)\n        if srt:\n            return srt\n\n    def _get_subtitles(self, video_id):\n        url = 'https://www.lynda.com/ajax/player?videoId=%s&type=transcript' % video_id\n        subs = self._download_json(url, None, False)\n        fixed_subs = self._fix_subtitles(subs)\n        if fixed_subs:\n            return {'en': [{'ext': 'srt', 'data': fixed_subs}]}\n        else:\n            return {}\n\n\nclass LyndaCourseIE(LyndaBaseIE):\n    IE_NAME = 'lynda:course'\n    IE_DESC = 'lynda.com online courses'\n\n    # Course link equals to welcome/introduction video link of same course\n    # We will recognize it as course link\n    _VALID_URL = r'https?://(?:www|m)\\.(?:lynda\\.com|educourse\\.ga)/(?P<coursepath>(?:[^/]+/){2,3}(?P<courseid>\\d+))-2\\.html'\n\n    _TESTS = [{\n        'url': 'https://www.lynda.com/Graphic-Design-tutorials/Grundlagen-guten-Gestaltung/393570-2.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.lynda.com/de/Graphic-Design-tutorials/Grundlagen-guten-Gestaltung/393570-2.html',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        course_path = mobj.group('coursepath')\n        course_id = mobj.group('courseid')\n\n        item_template = 'https://www.lynda.com/%s/%%s-4.html' % course_path\n\n        course = self._download_json(\n            'https://www.lynda.com/ajax/player?courseId=%s&type=course' % course_id,\n            course_id, 'Downloading course JSON', fatal=False)\n\n        if not course:\n            webpage = self._download_webpage(url, course_id)\n            entries = [\n                self.url_result(\n                    item_template % video_id, ie=LyndaIE.ie_key(),\n                    video_id=video_id)\n                for video_id in re.findall(\n                    r'data-video-id=[\"\\'](\\d+)', webpage)]\n            return self.playlist_result(\n                entries, course_id,\n                self._og_search_title(webpage, fatal=False),\n                self._og_search_description(webpage))\n\n        if course.get('Status') == 'NotFound':\n            raise ExtractorError(\n                'Course %s does not exist' % course_id, expected=True)\n\n        unaccessible_videos = 0\n        entries = []\n\n        # Might want to extract videos right here from video['Formats'] as it seems 'Formats' is not provided\n        # by single video API anymore\n\n        for chapter in course['Chapters']:\n            for video in chapter.get('Videos', []):\n                if video.get('HasAccess') is False:\n                    unaccessible_videos += 1\n                    continue\n                video_id = video.get('ID')\n                if video_id:\n                    entries.append({\n                        '_type': 'url_transparent',\n                        'url': item_template % video_id,\n                        'ie_key': LyndaIE.ie_key(),\n                        'chapter': chapter.get('Title'),\n                        'chapter_number': int_or_none(chapter.get('ChapterIndex')),\n                        'chapter_id': compat_str(chapter.get('ID')),\n                    })\n\n        if unaccessible_videos > 0:\n            self._downloader.report_warning(\n                '%s videos are only available for members (or paid members) and will not be downloaded. '\n                % unaccessible_videos + self._ACCOUNT_CREDENTIALS_HINT)\n\n        course_title = course.get('Title')\n        course_description = course.get('Description')\n\n        return self.playlist_result(entries, course_id, course_title, course_description)\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "lynda.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/lynda.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}