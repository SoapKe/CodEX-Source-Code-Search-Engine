{"author": "deepfakes", "code": "\n\n\n\nfrom keras.utils import conv_utils\nfrom keras.engine.topology import Layer\nimport keras.backend as K\n\n\nclass PixelShuffler(Layer):\n    def __init__(self, size=(2, 2), data_format=None, **kwargs):\n        super(PixelShuffler, self).__init__(**kwargs)\n        self.data_format = conv_utils.normalize_data_format(data_format)\n        self.size = conv_utils.normalize_tuple(size, 2, 'size')\n\n    def call(self, inputs):\n\n        input_shape = K.int_shape(inputs)\n        if len(input_shape) != 4:\n            raise ValueError('Inputs should have rank ' +\n                             str(4) +\n                             '; Received input shape:', str(input_shape))\n\n        if self.data_format == 'channels_first':\n            batch_size, c, h, w = input_shape\n            if batch_size is None:\n                batch_size = -1\n            rh, rw = self.size\n            oh, ow = h * rh, w * rw\n            oc = c // (rh * rw)\n\n            out = K.reshape(inputs, (batch_size, rh, rw, oc, h, w))\n            out = K.permute_dimensions(out, (0, 3, 4, 1, 5, 2))\n            out = K.reshape(out, (batch_size, oc, oh, ow))\n            return out\n\n        elif self.data_format == 'channels_last':\n            batch_size, h, w, c = input_shape\n            if batch_size is None:\n                batch_size = -1\n            rh, rw = self.size\n            oh, ow = h * rh, w * rw\n            oc = c // (rh * rw)\n\n            out = K.reshape(inputs, (batch_size, h, w, rh, rw, oc))\n            out = K.permute_dimensions(out, (0, 1, 3, 2, 4, 5))\n            out = K.reshape(out, (batch_size, oh, ow, oc))\n            return out\n\n    def compute_output_shape(self, input_shape):\n\n        if len(input_shape) != 4:\n            raise ValueError('Inputs should have rank ' +\n                             str(4) +\n                             '; Received input shape:', str(input_shape))\n\n        if self.data_format == 'channels_first':\n            height = input_shape[2] * self.size[0] if input_shape[2] is not None else None\n            width = input_shape[3] * self.size[1] if input_shape[3] is not None else None\n            channels = input_shape[1] // self.size[0] // self.size[1]\n\n            if channels * self.size[0] * self.size[1] != input_shape[1]:\n                raise ValueError('channels of input and size are incompatible')\n\n            return (input_shape[0],\n                    channels,\n                    height,\n                    width)\n\n        elif self.data_format == 'channels_last':\n            height = input_shape[1] * self.size[0] if input_shape[1] is not None else None\n            width = input_shape[2] * self.size[1] if input_shape[2] is not None else None\n            channels = input_shape[3] // self.size[0] // self.size[1]\n\n            if channels * self.size[0] * self.size[1] != input_shape[3]:\n                raise ValueError('channels of input and size are incompatible')\n\n            return (input_shape[0],\n                    height,\n                    width,\n                    channels)\n\n    def get_config(self):\n        config = {'size': self.size,\n                  'data_format': self.data_format}\n        base_config = super(PixelShuffler, self).get_config()\n\n        return dict(list(base_config.items()) + list(config.items()))\n", "comments": "  pixelshuffler layer keras    ae    https   gist github com ae 6e1016cc188104d123676ccef3264981 ", "content": "# PixelShuffler layer for Keras\n# by t-ae\n# https://gist.github.com/t-ae/6e1016cc188104d123676ccef3264981\n\nfrom keras.utils import conv_utils\nfrom keras.engine.topology import Layer\nimport keras.backend as K\n\n\nclass PixelShuffler(Layer):\n    def __init__(self, size=(2, 2), data_format=None, **kwargs):\n        super(PixelShuffler, self).__init__(**kwargs)\n        self.data_format = conv_utils.normalize_data_format(data_format)\n        self.size = conv_utils.normalize_tuple(size, 2, 'size')\n\n    def call(self, inputs):\n\n        input_shape = K.int_shape(inputs)\n        if len(input_shape) != 4:\n            raise ValueError('Inputs should have rank ' +\n                             str(4) +\n                             '; Received input shape:', str(input_shape))\n\n        if self.data_format == 'channels_first':\n            batch_size, c, h, w = input_shape\n            if batch_size is None:\n                batch_size = -1\n            rh, rw = self.size\n            oh, ow = h * rh, w * rw\n            oc = c // (rh * rw)\n\n            out = K.reshape(inputs, (batch_size, rh, rw, oc, h, w))\n            out = K.permute_dimensions(out, (0, 3, 4, 1, 5, 2))\n            out = K.reshape(out, (batch_size, oc, oh, ow))\n            return out\n\n        elif self.data_format == 'channels_last':\n            batch_size, h, w, c = input_shape\n            if batch_size is None:\n                batch_size = -1\n            rh, rw = self.size\n            oh, ow = h * rh, w * rw\n            oc = c // (rh * rw)\n\n            out = K.reshape(inputs, (batch_size, h, w, rh, rw, oc))\n            out = K.permute_dimensions(out, (0, 1, 3, 2, 4, 5))\n            out = K.reshape(out, (batch_size, oh, ow, oc))\n            return out\n\n    def compute_output_shape(self, input_shape):\n\n        if len(input_shape) != 4:\n            raise ValueError('Inputs should have rank ' +\n                             str(4) +\n                             '; Received input shape:', str(input_shape))\n\n        if self.data_format == 'channels_first':\n            height = input_shape[2] * self.size[0] if input_shape[2] is not None else None\n            width = input_shape[3] * self.size[1] if input_shape[3] is not None else None\n            channels = input_shape[1] // self.size[0] // self.size[1]\n\n            if channels * self.size[0] * self.size[1] != input_shape[1]:\n                raise ValueError('channels of input and size are incompatible')\n\n            return (input_shape[0],\n                    channels,\n                    height,\n                    width)\n\n        elif self.data_format == 'channels_last':\n            height = input_shape[1] * self.size[0] if input_shape[1] is not None else None\n            width = input_shape[2] * self.size[1] if input_shape[2] is not None else None\n            channels = input_shape[3] // self.size[0] // self.size[1]\n\n            if channels * self.size[0] * self.size[1] != input_shape[3]:\n                raise ValueError('channels of input and size are incompatible')\n\n            return (input_shape[0],\n                    height,\n                    width,\n                    channels)\n\n    def get_config(self):\n        config = {'size': self.size,\n                  'data_format': self.data_format}\n        base_config = super(PixelShuffler, self).get_config()\n\n        return dict(list(base_config.items()) + list(config.items()))\n", "description": "Non official project based on original /r/Deepfakes thread. Many thanks to him!", "file_name": "PixelShuffler.py", "id": "0afe05a0b7c6c9055533419a694bdc2c", "language": "Python", "project_name": "faceswap", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/deepfakes-faceswap/deepfakes-faceswap-6ff64ef/lib/PixelShuffler.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:27:43Z", "url": "https://github.com/deepfakes/faceswap", "wiki": true}