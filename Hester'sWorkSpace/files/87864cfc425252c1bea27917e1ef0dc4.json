{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    extract_attributes,\n    ExtractorError,\n    urlencode_postdata,\n    urljoin,\n)\n\n\nclass AnimeOnDemandIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?anime-on-demand\\.de/anime/(?P<id>\\d+)'\n    _LOGIN_URL = 'https://www.anime-on-demand.de/users/sign_in'\n    _APPLY_HTML5_URL = 'https://www.anime-on-demand.de/html5apply'\n    _NETRC_MACHINE = 'animeondemand'\n    \n    _GEO_COUNTRIES = ['AT', 'CH', 'DE', 'LI', 'LU']\n    _TESTS = [{\n        \n        'url': 'https://www.anime-on-demand.de/anime/161',\n        'info_dict': {\n            'id': '161',\n            'title': 'Grimgar, Ashes and Illusions (OmU)',\n            'description': 'md5:6681ce3c07c7189d255ac6ab23812d31',\n        },\n        'playlist_mincount': 4,\n    }, {\n        \n        'url': 'https://www.anime-on-demand.de/anime/39',\n        'only_matching': True,\n    }, {\n        \n        'url': 'https://www.anime-on-demand.de/anime/162',\n        'only_matching': True,\n    }, {\n        \n        'url': 'https://www.anime-on-demand.de/anime/169',\n        'only_matching': True,\n    }, {\n        \n        'url': 'https://www.anime-on-demand.de/anime/185',\n        'only_matching': True,\n    }, {\n        \n        'url': 'https://www.anime-on-demand.de/anime/12',\n        'only_matching': True,\n    }]\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n\n        login_page = self._download_webpage(\n            self._LOGIN_URL, None, 'Downloading login page')\n\n        if '>Our licensing terms allow the distribution of animes only to German-speaking countries of Europe' in login_page:\n            self.raise_geo_restricted(\n                '%s is only available in German-speaking countries of Europe' % self.IE_NAME)\n\n        login_form = self._form_hidden_inputs('new_user', login_page)\n\n        login_form.update({\n            'user[login]': username,\n            'user[password]': password,\n        })\n\n        post_url = self._search_regex(\n            r'<form[^>]+action=([\"\\'])(?P<url>.+?)\\1', login_page,\n            'post url', default=self._LOGIN_URL, group='url')\n\n        if not post_url.startswith('http'):\n            post_url = urljoin(self._LOGIN_URL, post_url)\n\n        response = self._download_webpage(\n            post_url, None, 'Logging in',\n            data=urlencode_postdata(login_form), headers={\n                'Referer': self._LOGIN_URL,\n            })\n\n        if all(p not in response for p in ('>Logout<', 'href=\"/users/sign_out\"')):\n            error = self._search_regex(\n                r'<p[^>]+\\bclass=([\"\\'])(?:(?!\\1).)*\\balert\\b(?:(?!\\1).)*\\1[^>]*>(?P<error>.+?)</p>',\n                response, 'error', default=None, group='error')\n            if error:\n                raise ExtractorError('Unable to login: %s' % error, expected=True)\n            raise ExtractorError('Unable to log in')\n\n    def _real_initialize(self):\n        self._login()\n\n    def _real_extract(self, url):\n        anime_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, anime_id)\n\n        if 'data-playlist=' not in webpage:\n            self._download_webpage(\n                self._APPLY_HTML5_URL, anime_id,\n                'Activating HTML5 beta', 'Unable to apply HTML5 beta')\n            webpage = self._download_webpage(url, anime_id)\n\n        csrf_token = self._html_search_meta(\n            'csrf-token', webpage, 'csrf token', fatal=True)\n\n        anime_title = self._html_search_regex(\n            r'(?s)<h1[^>]+itemprop=\"name\"[^>]*>(.+?)</h1>',\n            webpage, 'anime name')\n        anime_description = self._html_search_regex(\n            r'(?s)<div[^>]+itemprop=\"description\"[^>]*>(.+?)</div>',\n            webpage, 'anime description', default=None)\n\n        entries = []\n\n        def extract_info(html, video_id, num=None):\n            title, description = [None] * 2\n            formats = []\n\n            for input_ in re.findall(\n                    r'<input[^>]+class=[\"\\'].*?streamstarter[^>]+>', html):\n                attributes = extract_attributes(input_)\n                title = attributes.get('data-dialog-header')\n                playlist_urls = []\n                for playlist_key in ('data-playlist', 'data-otherplaylist', 'data-stream'):\n                    playlist_url = attributes.get(playlist_key)\n                    if isinstance(playlist_url, compat_str) and re.match(\n                            r'/?[\\da-zA-Z]+', playlist_url):\n                        playlist_urls.append(attributes[playlist_key])\n                if not playlist_urls:\n                    continue\n\n                lang = attributes.get('data-lang')\n                lang_note = attributes.get('value')\n\n                for playlist_url in playlist_urls:\n                    kind = self._search_regex(\n                        r'videomaterialurl/\\d+/([^/]+)/',\n                        playlist_url, 'media kind', default=None)\n                    format_id_list = []\n                    if lang:\n                        format_id_list.append(lang)\n                    if kind:\n                        format_id_list.append(kind)\n                    if not format_id_list and num is not None:\n                        format_id_list.append(compat_str(num))\n                    format_id = '-'.join(format_id_list)\n                    format_note = ', '.join(filter(None, (kind, lang_note)))\n                    item_id_list = []\n                    if format_id:\n                        item_id_list.append(format_id)\n                    item_id_list.append('videomaterial')\n                    playlist = self._download_json(\n                        urljoin(url, playlist_url), video_id,\n                        'Downloading %s JSON' % ' '.join(item_id_list),\n                        headers={\n                            'X-Requested-With': 'XMLHttpRequest',\n                            'X-CSRF-Token': csrf_token,\n                            'Referer': url,\n                            'Accept': 'application/json, text/javascript, */*; q=0.01',\n                        }, fatal=False)\n                    if not playlist:\n                        continue\n                    stream_url = playlist.get('streamurl')\n                    if stream_url:\n                        rtmp = re.search(\n                            r'^(?P<url>rtmpe?://(?P<host>[^/]+)/(?P<app>.+/))(?P<playpath>mp[34]:.+)',\n                            stream_url)\n                        if rtmp:\n                            formats.append({\n                                'url': rtmp.group('url'),\n                                'app': rtmp.group('app'),\n                                'play_path': rtmp.group('playpath'),\n                                'page_url': url,\n                                'player_url': 'https://www.anime-on-demand.de/assets/jwplayer.flash-55abfb34080700304d49125ce9ffb4a6.swf',\n                                'rtmp_real_time': True,\n                                'format_id': 'rtmp',\n                                'ext': 'flv',\n                            })\n                            continue\n                    start_video = playlist.get('startvideo', 0)\n                    playlist = playlist.get('playlist')\n                    if not playlist or not isinstance(playlist, list):\n                        continue\n                    playlist = playlist[start_video]\n                    title = playlist.get('title')\n                    if not title:\n                        continue\n                    description = playlist.get('description')\n                    for source in playlist.get('sources', []):\n                        file_ = source.get('file')\n                        if not file_:\n                            continue\n                        ext = determine_ext(file_)\n                        format_id_list = [lang, kind]\n                        if ext == 'm3u8':\n                            format_id_list.append('hls')\n                        elif source.get('type') == 'video/dash' or ext == 'mpd':\n                            format_id_list.append('dash')\n                        format_id = '-'.join(filter(None, format_id_list))\n                        if ext == 'm3u8':\n                            file_formats = self._extract_m3u8_formats(\n                                file_, video_id, 'mp4',\n                                entry_protocol='m3u8_native', m3u8_id=format_id, fatal=False)\n                        elif source.get('type') == 'video/dash' or ext == 'mpd':\n                            continue\n                            file_formats = self._extract_mpd_formats(\n                                file_, video_id, mpd_id=format_id, fatal=False)\n                        else:\n                            continue\n                        for f in file_formats:\n                            f.update({\n                                'language': lang,\n                                'format_note': format_note,\n                            })\n                        formats.extend(file_formats)\n\n            return {\n                'title': title,\n                'description': description,\n                'formats': formats,\n            }\n\n        def extract_entries(html, video_id, common_info, num=None):\n            info = extract_info(html, video_id, num)\n\n            if info['formats']:\n                self._sort_formats(info['formats'])\n                f = common_info.copy()\n                f.update(info)\n                entries.append(f)\n\n            \n            if not info['formats']:\n                m = re.search(\n                    r'data-dialog-header=([\"\\'])(?P<title>.+?)\\1[^>]+href=([\"\\'])(?P<href>.+?)\\3[^>]*>(?P<kind>Teaser|Trailer)<',\n                    html)\n                if m:\n                    f = common_info.copy()\n                    f.update({\n                        'id': '%s-%s' % (f['id'], m.group('kind').lower()),\n                        'title': m.group('title'),\n                        'url': urljoin(url, m.group('href')),\n                    })\n                    entries.append(f)\n\n        def extract_episodes(html):\n            for num, episode_html in enumerate(re.findall(\n                    r'(?s)<h3[^>]+class=\"episodebox-title\".+?>Episodeninhalt<', html), 1):\n                episodebox_title = self._search_regex(\n                    (r'class=\"episodebox-title\"[^>]+title=([\"\\'])(?P<title>.+?)\\1',\n                     r'class=\"episodebox-title\"[^>]+>(?P<title>.+?)<'),\n                    episode_html, 'episodebox title', default=None, group='title')\n                if not episodebox_title:\n                    continue\n\n                episode_number = int(self._search_regex(\n                    r'(?:Episode|Film)\\s*(\\d+)',\n                    episodebox_title, 'episode number', default=num))\n                episode_title = self._search_regex(\n                    r'(?:Episode|Film)\\s*\\d+\\s*-\\s*(.+)',\n                    episodebox_title, 'episode title', default=None)\n\n                video_id = 'episode-%d' % episode_number\n\n                common_info = {\n                    'id': video_id,\n                    'series': anime_title,\n                    'episode': episode_title,\n                    'episode_number': episode_number,\n                }\n\n                extract_entries(episode_html, video_id, common_info)\n\n        def extract_film(html, video_id):\n            common_info = {\n                'id': anime_id,\n                'title': anime_title,\n                'description': anime_description,\n            }\n            extract_entries(html, video_id, common_info)\n\n        extract_episodes(webpage)\n\n        if not entries:\n            extract_film(webpage, anime_id)\n\n        return self.playlist_result(entries, anime_id, anime_title, anime_description)\n", "comments": "# German-speaking countries of Europe\n# jap, OmU\n# Film wording is used instead of Episode, ger/jap, Dub/OmU\n# Episodes without titles, jap, OmU\n# ger/jap, Dub/OmU, account required\n# Full length film, non-series, ger/jap, Dub/OmU, account required\n# Flash videos\n# Extract teaser/trailer only when full episode is not available\n", "content": "from __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    extract_attributes,\n    ExtractorError,\n    urlencode_postdata,\n    urljoin,\n)\n\n\nclass AnimeOnDemandIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?anime-on-demand\\.de/anime/(?P<id>\\d+)'\n    _LOGIN_URL = 'https://www.anime-on-demand.de/users/sign_in'\n    _APPLY_HTML5_URL = 'https://www.anime-on-demand.de/html5apply'\n    _NETRC_MACHINE = 'animeondemand'\n    # German-speaking countries of Europe\n    _GEO_COUNTRIES = ['AT', 'CH', 'DE', 'LI', 'LU']\n    _TESTS = [{\n        # jap, OmU\n        'url': 'https://www.anime-on-demand.de/anime/161',\n        'info_dict': {\n            'id': '161',\n            'title': 'Grimgar, Ashes and Illusions (OmU)',\n            'description': 'md5:6681ce3c07c7189d255ac6ab23812d31',\n        },\n        'playlist_mincount': 4,\n    }, {\n        # Film wording is used instead of Episode, ger/jap, Dub/OmU\n        'url': 'https://www.anime-on-demand.de/anime/39',\n        'only_matching': True,\n    }, {\n        # Episodes without titles, jap, OmU\n        'url': 'https://www.anime-on-demand.de/anime/162',\n        'only_matching': True,\n    }, {\n        # ger/jap, Dub/OmU, account required\n        'url': 'https://www.anime-on-demand.de/anime/169',\n        'only_matching': True,\n    }, {\n        # Full length film, non-series, ger/jap, Dub/OmU, account required\n        'url': 'https://www.anime-on-demand.de/anime/185',\n        'only_matching': True,\n    }, {\n        # Flash videos\n        'url': 'https://www.anime-on-demand.de/anime/12',\n        'only_matching': True,\n    }]\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n\n        login_page = self._download_webpage(\n            self._LOGIN_URL, None, 'Downloading login page')\n\n        if '>Our licensing terms allow the distribution of animes only to German-speaking countries of Europe' in login_page:\n            self.raise_geo_restricted(\n                '%s is only available in German-speaking countries of Europe' % self.IE_NAME)\n\n        login_form = self._form_hidden_inputs('new_user', login_page)\n\n        login_form.update({\n            'user[login]': username,\n            'user[password]': password,\n        })\n\n        post_url = self._search_regex(\n            r'<form[^>]+action=([\"\\'])(?P<url>.+?)\\1', login_page,\n            'post url', default=self._LOGIN_URL, group='url')\n\n        if not post_url.startswith('http'):\n            post_url = urljoin(self._LOGIN_URL, post_url)\n\n        response = self._download_webpage(\n            post_url, None, 'Logging in',\n            data=urlencode_postdata(login_form), headers={\n                'Referer': self._LOGIN_URL,\n            })\n\n        if all(p not in response for p in ('>Logout<', 'href=\"/users/sign_out\"')):\n            error = self._search_regex(\n                r'<p[^>]+\\bclass=([\"\\'])(?:(?!\\1).)*\\balert\\b(?:(?!\\1).)*\\1[^>]*>(?P<error>.+?)</p>',\n                response, 'error', default=None, group='error')\n            if error:\n                raise ExtractorError('Unable to login: %s' % error, expected=True)\n            raise ExtractorError('Unable to log in')\n\n    def _real_initialize(self):\n        self._login()\n\n    def _real_extract(self, url):\n        anime_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, anime_id)\n\n        if 'data-playlist=' not in webpage:\n            self._download_webpage(\n                self._APPLY_HTML5_URL, anime_id,\n                'Activating HTML5 beta', 'Unable to apply HTML5 beta')\n            webpage = self._download_webpage(url, anime_id)\n\n        csrf_token = self._html_search_meta(\n            'csrf-token', webpage, 'csrf token', fatal=True)\n\n        anime_title = self._html_search_regex(\n            r'(?s)<h1[^>]+itemprop=\"name\"[^>]*>(.+?)</h1>',\n            webpage, 'anime name')\n        anime_description = self._html_search_regex(\n            r'(?s)<div[^>]+itemprop=\"description\"[^>]*>(.+?)</div>',\n            webpage, 'anime description', default=None)\n\n        entries = []\n\n        def extract_info(html, video_id, num=None):\n            title, description = [None] * 2\n            formats = []\n\n            for input_ in re.findall(\n                    r'<input[^>]+class=[\"\\'].*?streamstarter[^>]+>', html):\n                attributes = extract_attributes(input_)\n                title = attributes.get('data-dialog-header')\n                playlist_urls = []\n                for playlist_key in ('data-playlist', 'data-otherplaylist', 'data-stream'):\n                    playlist_url = attributes.get(playlist_key)\n                    if isinstance(playlist_url, compat_str) and re.match(\n                            r'/?[\\da-zA-Z]+', playlist_url):\n                        playlist_urls.append(attributes[playlist_key])\n                if not playlist_urls:\n                    continue\n\n                lang = attributes.get('data-lang')\n                lang_note = attributes.get('value')\n\n                for playlist_url in playlist_urls:\n                    kind = self._search_regex(\n                        r'videomaterialurl/\\d+/([^/]+)/',\n                        playlist_url, 'media kind', default=None)\n                    format_id_list = []\n                    if lang:\n                        format_id_list.append(lang)\n                    if kind:\n                        format_id_list.append(kind)\n                    if not format_id_list and num is not None:\n                        format_id_list.append(compat_str(num))\n                    format_id = '-'.join(format_id_list)\n                    format_note = ', '.join(filter(None, (kind, lang_note)))\n                    item_id_list = []\n                    if format_id:\n                        item_id_list.append(format_id)\n                    item_id_list.append('videomaterial')\n                    playlist = self._download_json(\n                        urljoin(url, playlist_url), video_id,\n                        'Downloading %s JSON' % ' '.join(item_id_list),\n                        headers={\n                            'X-Requested-With': 'XMLHttpRequest',\n                            'X-CSRF-Token': csrf_token,\n                            'Referer': url,\n                            'Accept': 'application/json, text/javascript, */*; q=0.01',\n                        }, fatal=False)\n                    if not playlist:\n                        continue\n                    stream_url = playlist.get('streamurl')\n                    if stream_url:\n                        rtmp = re.search(\n                            r'^(?P<url>rtmpe?://(?P<host>[^/]+)/(?P<app>.+/))(?P<playpath>mp[34]:.+)',\n                            stream_url)\n                        if rtmp:\n                            formats.append({\n                                'url': rtmp.group('url'),\n                                'app': rtmp.group('app'),\n                                'play_path': rtmp.group('playpath'),\n                                'page_url': url,\n                                'player_url': 'https://www.anime-on-demand.de/assets/jwplayer.flash-55abfb34080700304d49125ce9ffb4a6.swf',\n                                'rtmp_real_time': True,\n                                'format_id': 'rtmp',\n                                'ext': 'flv',\n                            })\n                            continue\n                    start_video = playlist.get('startvideo', 0)\n                    playlist = playlist.get('playlist')\n                    if not playlist or not isinstance(playlist, list):\n                        continue\n                    playlist = playlist[start_video]\n                    title = playlist.get('title')\n                    if not title:\n                        continue\n                    description = playlist.get('description')\n                    for source in playlist.get('sources', []):\n                        file_ = source.get('file')\n                        if not file_:\n                            continue\n                        ext = determine_ext(file_)\n                        format_id_list = [lang, kind]\n                        if ext == 'm3u8':\n                            format_id_list.append('hls')\n                        elif source.get('type') == 'video/dash' or ext == 'mpd':\n                            format_id_list.append('dash')\n                        format_id = '-'.join(filter(None, format_id_list))\n                        if ext == 'm3u8':\n                            file_formats = self._extract_m3u8_formats(\n                                file_, video_id, 'mp4',\n                                entry_protocol='m3u8_native', m3u8_id=format_id, fatal=False)\n                        elif source.get('type') == 'video/dash' or ext == 'mpd':\n                            continue\n                            file_formats = self._extract_mpd_formats(\n                                file_, video_id, mpd_id=format_id, fatal=False)\n                        else:\n                            continue\n                        for f in file_formats:\n                            f.update({\n                                'language': lang,\n                                'format_note': format_note,\n                            })\n                        formats.extend(file_formats)\n\n            return {\n                'title': title,\n                'description': description,\n                'formats': formats,\n            }\n\n        def extract_entries(html, video_id, common_info, num=None):\n            info = extract_info(html, video_id, num)\n\n            if info['formats']:\n                self._sort_formats(info['formats'])\n                f = common_info.copy()\n                f.update(info)\n                entries.append(f)\n\n            # Extract teaser/trailer only when full episode is not available\n            if not info['formats']:\n                m = re.search(\n                    r'data-dialog-header=([\"\\'])(?P<title>.+?)\\1[^>]+href=([\"\\'])(?P<href>.+?)\\3[^>]*>(?P<kind>Teaser|Trailer)<',\n                    html)\n                if m:\n                    f = common_info.copy()\n                    f.update({\n                        'id': '%s-%s' % (f['id'], m.group('kind').lower()),\n                        'title': m.group('title'),\n                        'url': urljoin(url, m.group('href')),\n                    })\n                    entries.append(f)\n\n        def extract_episodes(html):\n            for num, episode_html in enumerate(re.findall(\n                    r'(?s)<h3[^>]+class=\"episodebox-title\".+?>Episodeninhalt<', html), 1):\n                episodebox_title = self._search_regex(\n                    (r'class=\"episodebox-title\"[^>]+title=([\"\\'])(?P<title>.+?)\\1',\n                     r'class=\"episodebox-title\"[^>]+>(?P<title>.+?)<'),\n                    episode_html, 'episodebox title', default=None, group='title')\n                if not episodebox_title:\n                    continue\n\n                episode_number = int(self._search_regex(\n                    r'(?:Episode|Film)\\s*(\\d+)',\n                    episodebox_title, 'episode number', default=num))\n                episode_title = self._search_regex(\n                    r'(?:Episode|Film)\\s*\\d+\\s*-\\s*(.+)',\n                    episodebox_title, 'episode title', default=None)\n\n                video_id = 'episode-%d' % episode_number\n\n                common_info = {\n                    'id': video_id,\n                    'series': anime_title,\n                    'episode': episode_title,\n                    'episode_number': episode_number,\n                }\n\n                extract_entries(episode_html, video_id, common_info)\n\n        def extract_film(html, video_id):\n            common_info = {\n                'id': anime_id,\n                'title': anime_title,\n                'description': anime_description,\n            }\n            extract_entries(html, video_id, common_info)\n\n        extract_episodes(webpage)\n\n        if not entries:\n            extract_film(webpage, anime_id)\n\n        return self.playlist_result(entries, anime_id, anime_title, anime_description)\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "animeondemand.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/animeondemand.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}