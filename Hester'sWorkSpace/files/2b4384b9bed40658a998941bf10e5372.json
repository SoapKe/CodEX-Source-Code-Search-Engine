{"author": "odoo", "code": "\nfrom werkzeug import urls\n\nfrom .authorize_request import AuthorizeAPI\nfrom datetime import datetime\nimport hashlib\nimport hmac\nimport logging\nimport time\n\nfrom odoo import _, api, fields, models\nfrom odoo.addons.payment.models.payment_acquirer import ValidationError\nfrom odoo.addons.payment_authorize.controllers.main import AuthorizeController\nfrom odoo.tools.float_utils import float_compare\nfrom odoo.tools.safe_eval import safe_eval\n\n_logger = logging.getLogger(__name__)\n\n\nclass PaymentAcquirerAuthorize(models.Model):\n    _inherit = 'payment.acquirer'\n\n    provider = fields.Selection(selection_add=[('authorize', 'Authorize.Net')])\n    authorize_login = fields.Char(string='API Login Id', required_if_provider='authorize', groups='base.group_user')\n    authorize_transaction_key = fields.Char(string='API Transaction Key', required_if_provider='authorize', groups='base.group_user')\n\n    def _get_feature_support(self):\n        \"\"\"Get advanced feature support by provider.\n\n        Each provider should add its technical in the corresponding\n        key for the following features:\n            * fees: support payment fees computations\n            * authorize: support authorizing payment (separates\n                         authorization and capture)\n            * tokenize: support saving payment data in a payment.tokenize\n                        object\n        \"\"\"\n        res = super(PaymentAcquirerAuthorize, self)._get_feature_support()\n        res['authorize'].append('authorize')\n        res['tokenize'].append('authorize')\n        return res\n\n    def _get_authorize_urls(self, environment):\n        \"\"\" Authorize URLs \"\"\"\n        if environment == 'prod':\n            return {'authorize_form_url': 'https://secure2.authorize.net/gateway/transact.dll'}\n        else:\n            return {'authorize_form_url': 'https://test.authorize.net/gateway/transact.dll'}\n\n    def _authorize_generate_hashing(self, values):\n        data = '^'.join([\n            values['x_login'],\n            values['x_fp_sequence'],\n            values['x_fp_timestamp'],\n            values['x_amount'],\n            values['x_currency_code']])\n        return hmac.new(values['x_trans_key'].encode('utf-8'), data.encode('utf-8'), hashlib.md5).hexdigest()\n\n    @api.multi\n    def authorize_form_generate_values(self, values):\n        self.ensure_one()\n        base_url = self.env['ir.config_parameter'].get_param('web.base.url')\n        authorize_tx_values = dict(values)\n        temp_authorize_tx_values = {\n            'x_login': self.authorize_login,\n            'x_trans_key': self.authorize_transaction_key,\n            'x_amount': str(values['amount']),\n            'x_show_form': 'PAYMENT_FORM',\n            'x_type': 'AUTH_CAPTURE' if not self.capture_manually else 'AUTH_ONLY',\n            'x_method': 'CC',\n            'x_fp_sequence': '%s%s' % (self.id, int(time.time())),\n            'x_version': '3.1',\n            'x_relay_response': 'TRUE',\n            'x_fp_timestamp': str(int(time.time())),\n            'x_relay_url': urls.url_join(base_url, AuthorizeController._return_url),\n            'x_cancel_url': urls.url_join(base_url, AuthorizeController._cancel_url),\n            'x_currency_code': values['currency'] and values['currency'].name or '',\n            'address': values.get('partner_address'),\n            'city': values.get('partner_city'),\n            'country': values.get('partner_country') and values.get('partner_country').name or '',\n            'email': values.get('partner_email'),\n            'zip_code': values.get('partner_zip'),\n            'first_name': values.get('partner_first_name'),\n            'last_name': values.get('partner_last_name'),\n            'phone': values.get('partner_phone'),\n            'state': values.get('partner_state') and values['partner_state'].code or '',\n            'billing_address': values.get('billing_partner_address'),\n            'billing_city': values.get('billing_partner_city'),\n            'billing_country': values.get('billing_partner_country') and values.get('billing_partner_country').name or '',\n            'billing_email': values.get('billing_partner_email'),\n            'billing_zip_code': values.get('billing_partner_zip'),\n            'billing_first_name': values.get('billing_partner_first_name'),\n            'billing_last_name': values.get('billing_partner_last_name'),\n            'billing_phone': values.get('billing_partner_phone'),\n            'billing_state': values.get('billing_partner_state') and values['billing_partner_state'].code or '',\n        }\n        temp_authorize_tx_values['returndata'] = authorize_tx_values.pop('return_url', '')\n        temp_authorize_tx_values['x_fp_hash'] = self._authorize_generate_hashing(temp_authorize_tx_values)\n        authorize_tx_values.update(temp_authorize_tx_values)\n        return authorize_tx_values\n\n    @api.multi\n    def authorize_get_form_action_url(self):\n        self.ensure_one()\n        return self._get_authorize_urls(self.environment)['authorize_form_url']\n\n    @api.model\n    def authorize_s2s_form_process(self, data):\n        values = {\n            'cc_number': data.get('cc_number'),\n            'cc_holder_name': data.get('cc_holder_name'),\n            'cc_expiry': data.get('cc_expiry'),\n            'cc_cvc': data.get('cc_cvc'),\n            'cc_brand': data.get('cc_brand'),\n            'acquirer_id': int(data.get('acquirer_id')),\n            'partner_id': int(data.get('partner_id'))\n        }\n        PaymentMethod = self.env['payment.token'].sudo().create(values)\n        return PaymentMethod\n\n    @api.multi\n    def authorize_s2s_form_validate(self, data):\n        error = dict()\n        mandatory_fields = [\"cc_number\", \"cc_cvc\", \"cc_holder_name\", \"cc_expiry\", \"cc_brand\"]\n        \n        for field_name in mandatory_fields:\n            if not data.get(field_name):\n                error[field_name] = 'missing'\n        if data['cc_expiry'] and datetime.now().strftime('%y%m') > datetime.strptime(data['cc_expiry'], '%m / %y').strftime('%y%m'):\n            return False\n        return False if error else True\n\n    @api.multi\n    def authorize_test_credentials(self):\n        self.ensure_one()\n        transaction = AuthorizeAPI(self.acquirer_id)\n        return transaction.test_authenticate()\n\nclass TxAuthorize(models.Model):\n    _inherit = 'payment.transaction'\n\n    _authorize_valid_tx_status = 1\n    _authorize_pending_tx_status = 4\n    _authorize_cancel_tx_status = 2\n\n    \n    \n    \n\n    @api.model\n    def create(self, vals):\n        # The reference is used in the Authorize form to fill a field (invoiceNumber) which is\n        \n        \n        if 'reference' in vals and 'acquirer_id' in vals:\n            acquier = self.env['payment.acquirer'].browse(vals['acquirer_id'])\n            if acquier.provider == 'authorize':\n                vals['reference'] = vals.get('reference', '')[:20]\n        return super(TxAuthorize, self).create(vals)\n\n    @api.model\n    def _authorize_form_get_tx_from_data(self, data):\n        \"\"\" Given a data dict coming from authorize, verify it and find the related\n        transaction record. \"\"\"\n        reference, trans_id, fingerprint = data.get('x_invoice_num'), data.get('x_trans_id'), data.get('x_MD5_Hash')\n        if not reference or not trans_id or not fingerprint:\n            error_msg = _('Authorize: received data with missing reference (%s) or trans_id (%s) or fingerprint (%s)') % (reference, trans_id, fingerprint)\n            _logger.info(error_msg)\n            raise ValidationError(error_msg)\n        tx = self.search([('reference', '=', reference)])\n        if not tx or len(tx) > 1:\n            error_msg = 'Authorize: received data for reference %s' % (reference)\n            if not tx:\n                error_msg += '; no order found'\n            else:\n                error_msg += '; multiple order found'\n            _logger.info(error_msg)\n            raise ValidationError(error_msg)\n        return tx[0]\n\n    @api.multi\n    def _authorize_form_get_invalid_parameters(self, data):\n        invalid_parameters = []\n\n        if self.acquirer_reference and data.get('x_trans_id') != self.acquirer_reference:\n            invalid_parameters.append(('Transaction Id', data.get('x_trans_id'), self.acquirer_reference))\n        \n        if float_compare(float(data.get('x_amount', '0.0')), self.amount, 2) != 0:\n            invalid_parameters.append(('Amount', data.get('x_amount'), '%.2f' % self.amount))\n        return invalid_parameters\n\n    @api.multi\n    def _authorize_form_validate(self, data):\n        if self.state in ['done', 'refunded']:\n            _logger.warning('Authorize: trying to validate an already validated tx (ref %s)' % self.reference)\n            return True\n        status_code = int(data.get('x_response_code', '0'))\n        if status_code == self._authorize_valid_tx_status:\n            if data.get('x_type').lower() in ['auth_capture', 'prior_auth_capture']:\n                self.write({\n                    'state': 'done',\n                    'acquirer_reference': data.get('x_trans_id'),\n                    'date_validate': fields.Datetime.now(),\n                })\n            elif data.get('x_type').lower() in ['auth_only']:\n                self.write({\n                    'state': 'authorized',\n                    'acquirer_reference': data.get('x_trans_id'),\n                })\n            if self.partner_id and not self.payment_token_id and \\\n               (self.type == 'form_save' or self.acquirer_id.save_token == 'always'):\n                transaction = AuthorizeAPI(self.acquirer_id)\n                res = transaction.create_customer_profile_from_tx(self.partner_id, self.acquirer_reference)\n                token_id = self.env['payment.token'].create({\n                    'authorize_profile': res.get('profile_id'),\n                    'name': res.get('name'),\n                    'acquirer_ref': res.get('payment_profile_id'),\n                    'acquirer_id': self.acquirer_id.id,\n                    'partner_id': self.partner_id.id,\n                })\n                self.payment_token_id = token_id\n\n            if self.payment_token_id:\n                self.payment_token_id.verified = True\n            return True\n        elif status_code == self._authorize_pending_tx_status:\n            self.write({\n                'state': 'pending',\n                'acquirer_reference': data.get('x_trans_id'),\n            })\n            return True\n        elif status_code == self._authorize_cancel_tx_status:\n            self.write({\n                'state': 'cancel',\n                'acquirer_reference': data.get('x_trans_id'),\n                'state_message': data.get('x_response_reason_text'),\n            })\n            return True\n        else:\n            error = data.get('x_response_reason_text')\n            _logger.info(error)\n            self.write({\n                'state': 'error',\n                'state_message': error,\n                'acquirer_reference': data.get('x_trans_id'),\n            })\n            return False\n\n    @api.multi\n    def authorize_s2s_do_transaction(self, **data):\n        self.ensure_one()\n        transaction = AuthorizeAPI(self.acquirer_id)\n        if not self.acquirer_id.capture_manually:\n            res = transaction.auth_and_capture(self.payment_token_id, self.amount, self.reference)\n        else:\n            res = transaction.authorize(self.payment_token_id, self.amount, self.reference)\n        return self._authorize_s2s_validate_tree(res)\n\n    @api.multi\n    def authorize_s2s_do_refund(self):\n        self.ensure_one()\n        transaction = AuthorizeAPI(self.acquirer_id)\n        self.state = 'refunding'\n        if self.type == 'validation':\n            res = transaction.void(self.acquirer_reference)\n        else:\n            res = transaction.credit(self.payment_token_id, self.amount, self.acquirer_reference)\n        return self._authorize_s2s_validate_tree(res)\n\n    @api.multi\n    def authorize_s2s_capture_transaction(self):\n        self.ensure_one()\n        transaction = AuthorizeAPI(self.acquirer_id)\n        tree = transaction.capture(self.acquirer_reference or '', self.amount)\n        return self._authorize_s2s_validate_tree(tree)\n\n    @api.multi\n    def authorize_s2s_void_transaction(self):\n        self.ensure_one()\n        transaction = AuthorizeAPI(self.acquirer_id)\n        tree = transaction.void(self.acquirer_reference or '')\n        return self._authorize_s2s_validate_tree(tree)\n\n    @api.multi\n    def _authorize_s2s_validate_tree(self, tree):\n        return self._authorize_s2s_validate(tree)\n\n    @api.multi\n    def _authorize_s2s_validate(self, tree):\n        if self.state in ['done', 'refunded']:\n            _logger.warning('Authorize: trying to validate an already validated tx (ref %s)' % self.reference)\n            return True\n        status_code = int(tree.get('x_response_code', '0'))\n        if status_code == self._authorize_valid_tx_status:\n            if tree.get('x_type').lower() in ['auth_capture', 'prior_auth_capture']:\n                init_state = self.state\n                self.write({\n                    'state': 'done',\n                    'acquirer_reference': tree.get('x_trans_id'),\n                    'date_validate': fields.Datetime.now(),\n                })\n                if init_state != 'authorized':\n                    self.execute_callback()\n\n                if self.payment_token_id:\n                    self.payment_token_id.verified = True\n\n            if tree.get('x_type').lower() == 'auth_only':\n                self.write({\n                    'state': 'authorized',\n                    'acquirer_reference': tree.get('x_trans_id'),\n                })\n                self.execute_callback()\n            if tree.get('x_type').lower() == 'void':\n                if self.type == 'validation' and self.state == 'refunding':\n                    self.write({\n                        'state': 'refunded',\n                    })\n                else:\n                    self.write({\n                        'state': 'cancel',\n                    })\n            return True\n        elif status_code == self._authorize_pending_tx_status:\n            new_state = 'refunding' if self.state == 'refunding' else 'pending'\n            self.write({\n                'state': new_state,\n                'acquirer_reference': tree.get('x_trans_id'),\n            })\n            return True\n        elif status_code == self._authorize_cancel_tx_status:\n            self.write({\n                'state': 'cancel',\n                'acquirer_reference': tree.get('x_trans_id'),\n            })\n            return True\n        else:\n            error = tree.get('x_response_reason_text')\n            _logger.info(error)\n            self.write({\n                'state': 'error',\n                'state_message': error,\n                'acquirer_reference': tree.get('x_trans_id'),\n            })\n            return False\n\n\nclass PaymentToken(models.Model):\n    _inherit = 'payment.token'\n\n    authorize_profile = fields.Char(string='Authorize.net Profile ID', help='This contains the unique reference '\n                                    'for this partner/payment token combination in the Authorize.net backend')\n    provider = fields.Selection(string='Provider', related='acquirer_id.provider')\n    save_token = fields.Selection(string='Save Cards', related='acquirer_id.save_token')\n\n    @api.model\n    def authorize_create(self, values):\n        if values.get('cc_number'):\n            values['cc_number'] = values['cc_number'].replace(' ', '')\n            acquirer = self.env['payment.acquirer'].browse(values['acquirer_id'])\n            expiry = str(values['cc_expiry'][:2]) + str(values['cc_expiry'][-2:])\n            partner = self.env['res.partner'].browse(values['partner_id'])\n            transaction = AuthorizeAPI(acquirer)\n            res = transaction.create_customer_profile(partner, values['cc_number'], expiry, values['cc_cvc'])\n            if res.get('profile_id') and res.get('payment_profile_id'):\n                return {\n                    'authorize_profile': res.get('profile_id'),\n                    'name': 'XXXXXXXXXXXX%s - %s' % (values['cc_number'][-4:], values['cc_holder_name']),\n                    'acquirer_ref': res.get('payment_profile_id'),\n                }\n            else:\n                raise ValidationError(_('The Customer Profile creation in Authorize.NET failed.'))\n        else:\n            return values\n", "comments": "   get advanced feature support provider           each provider add technical corresponding         key following features                fees  support payment fees computations               authorize  support authorizing payment (separates                          authorization capture)               tokenize  support saving payment data payment tokenize                         object                     res   super(paymentacquirerauthorize  self)  get feature support()         res  authorize   append( authorize )         res  tokenize   append( authorize )         return res      def  get authorize urls(self  environment)              authorize urls             environment     prod               return   authorize form url    https   secure2 authorize net gateway transact dll           else              return   authorize form url    https   test authorize net gateway transact dll        def  authorize generate hashing(self  values)          data       join(              values  x login                values  x fp sequence                values  x fp timestamp                values  x amount                values  x currency code   )         return hmac new(values  x trans key   encode( utf 8 )  data encode( utf 8 )  hashlib md5) hexdigest()       api multi     def authorize form generate values(self  values)          self ensure one()         base url   self env  ir config parameter   get param( web base url )         authorize tx values   dict(values)         temp authorize tx values                  x login   self authorize login               x trans key   self authorize transaction key               x amount   str(values  amount  )               x show form    payment form                x type    auth capture  self capture manually else  auth only                x method    cc                x fp sequence        (self id  int(time time()))               x version    3 1                x relay response    true                x fp timestamp   str(int(time time()))               x relay url   urls url join(base url  authorizecontroller  return url)               x cancel url   urls url join(base url  authorizecontroller  cancel url)               x currency code   values  currency   values  currency   name                  address   values get( partner address )               city   values get( partner city )               country   values get( partner country ) values get( partner country ) name                  email   values get( partner email )               zip code   values get( partner zip )               first name   values get( partner first name )               last name   values get( partner last name )               phone   values get( partner phone )               state   values get( partner state ) values  partner state   code                  billing address   values get( billing partner address )               billing city   values get( billing partner city )               billing country   values get( billing partner country ) values get( billing partner country ) name                  billing email   values get( billing partner email )               billing zip code   values get( billing partner zip )               billing first name   values get( billing partner first name )               billing last name   values get( billing partner last name )               billing phone   values get( billing partner phone )               billing state   values get( billing partner state ) values  billing partner state   code                       temp authorize tx values  returndata     authorize tx values pop( return url     )         temp authorize tx values  x fp hash     self  authorize generate hashing(temp authorize tx values)         authorize tx values update(temp authorize tx values)         return authorize tx values       api multi     def authorize get form action url(self)          self ensure one()         return self  get authorize urls(self environment)  authorize form url         api model     def authorize s2s form process(self  data)          values                  cc number   data get( cc number )               cc holder name   data get( cc holder name )               cc expiry   data get( cc expiry )               cc cvc   data get( cc cvc )               cc brand   data get( cc brand )               acquirer id   int(data get( acquirer id ))               partner id   int(data get( partner id ))                   paymentmethod   self env  payment token   sudo() create(values)         return paymentmethod       api multi     def authorize s2s form validate(self  data)          error   dict()         mandatory fields     cc number    cc cvc    cc holder name    cc expiry    cc brand             validation         field name mandatory fields              data get(field name)                  error field name     missing          data  cc expiry   datetime now() strftime(  )   datetime strptime(data  cc expiry         ) strftime(  )              return false         return false error else true       api multi     def authorize test credentials(self)          self ensure one()         transaction   authorizeapi(self acquirer id)         return transaction test authenticate()  class txauthorize(models model)       inherit    payment transaction        authorize valid tx status   1      authorize pending tx status   4      authorize cancel tx status   2                                                                 form related methods                                                                api model     def create(self  vals)            the reference used authorize form fill field (invoicenumber)           limited 20 characters  we truncate reference  since reused           payment validation find back transaction           reference  vals  acquirer id  vals              acquier   self env  payment acquirer   browse(vals  acquirer id  )             acquier provider     authorize                   vals  reference     vals get( reference     )  20          return super(txauthorize  self) create(vals)       api model     def  authorize form get tx data(self  data)              given data dict coming authorize  verify find related         transaction record         coding  utf 8    validation                                                          form related methods                                                          the reference used authorize form fill field (invoicenumber)    limited 20 characters  we truncate reference  since reused    payment validation find back transaction     check buyed ", "content": "# coding: utf-8\nfrom werkzeug import urls\n\nfrom .authorize_request import AuthorizeAPI\nfrom datetime import datetime\nimport hashlib\nimport hmac\nimport logging\nimport time\n\nfrom odoo import _, api, fields, models\nfrom odoo.addons.payment.models.payment_acquirer import ValidationError\nfrom odoo.addons.payment_authorize.controllers.main import AuthorizeController\nfrom odoo.tools.float_utils import float_compare\nfrom odoo.tools.safe_eval import safe_eval\n\n_logger = logging.getLogger(__name__)\n\n\nclass PaymentAcquirerAuthorize(models.Model):\n    _inherit = 'payment.acquirer'\n\n    provider = fields.Selection(selection_add=[('authorize', 'Authorize.Net')])\n    authorize_login = fields.Char(string='API Login Id', required_if_provider='authorize', groups='base.group_user')\n    authorize_transaction_key = fields.Char(string='API Transaction Key', required_if_provider='authorize', groups='base.group_user')\n\n    def _get_feature_support(self):\n        \"\"\"Get advanced feature support by provider.\n\n        Each provider should add its technical in the corresponding\n        key for the following features:\n            * fees: support payment fees computations\n            * authorize: support authorizing payment (separates\n                         authorization and capture)\n            * tokenize: support saving payment data in a payment.tokenize\n                        object\n        \"\"\"\n        res = super(PaymentAcquirerAuthorize, self)._get_feature_support()\n        res['authorize'].append('authorize')\n        res['tokenize'].append('authorize')\n        return res\n\n    def _get_authorize_urls(self, environment):\n        \"\"\" Authorize URLs \"\"\"\n        if environment == 'prod':\n            return {'authorize_form_url': 'https://secure2.authorize.net/gateway/transact.dll'}\n        else:\n            return {'authorize_form_url': 'https://test.authorize.net/gateway/transact.dll'}\n\n    def _authorize_generate_hashing(self, values):\n        data = '^'.join([\n            values['x_login'],\n            values['x_fp_sequence'],\n            values['x_fp_timestamp'],\n            values['x_amount'],\n            values['x_currency_code']])\n        return hmac.new(values['x_trans_key'].encode('utf-8'), data.encode('utf-8'), hashlib.md5).hexdigest()\n\n    @api.multi\n    def authorize_form_generate_values(self, values):\n        self.ensure_one()\n        base_url = self.env['ir.config_parameter'].get_param('web.base.url')\n        authorize_tx_values = dict(values)\n        temp_authorize_tx_values = {\n            'x_login': self.authorize_login,\n            'x_trans_key': self.authorize_transaction_key,\n            'x_amount': str(values['amount']),\n            'x_show_form': 'PAYMENT_FORM',\n            'x_type': 'AUTH_CAPTURE' if not self.capture_manually else 'AUTH_ONLY',\n            'x_method': 'CC',\n            'x_fp_sequence': '%s%s' % (self.id, int(time.time())),\n            'x_version': '3.1',\n            'x_relay_response': 'TRUE',\n            'x_fp_timestamp': str(int(time.time())),\n            'x_relay_url': urls.url_join(base_url, AuthorizeController._return_url),\n            'x_cancel_url': urls.url_join(base_url, AuthorizeController._cancel_url),\n            'x_currency_code': values['currency'] and values['currency'].name or '',\n            'address': values.get('partner_address'),\n            'city': values.get('partner_city'),\n            'country': values.get('partner_country') and values.get('partner_country').name or '',\n            'email': values.get('partner_email'),\n            'zip_code': values.get('partner_zip'),\n            'first_name': values.get('partner_first_name'),\n            'last_name': values.get('partner_last_name'),\n            'phone': values.get('partner_phone'),\n            'state': values.get('partner_state') and values['partner_state'].code or '',\n            'billing_address': values.get('billing_partner_address'),\n            'billing_city': values.get('billing_partner_city'),\n            'billing_country': values.get('billing_partner_country') and values.get('billing_partner_country').name or '',\n            'billing_email': values.get('billing_partner_email'),\n            'billing_zip_code': values.get('billing_partner_zip'),\n            'billing_first_name': values.get('billing_partner_first_name'),\n            'billing_last_name': values.get('billing_partner_last_name'),\n            'billing_phone': values.get('billing_partner_phone'),\n            'billing_state': values.get('billing_partner_state') and values['billing_partner_state'].code or '',\n        }\n        temp_authorize_tx_values['returndata'] = authorize_tx_values.pop('return_url', '')\n        temp_authorize_tx_values['x_fp_hash'] = self._authorize_generate_hashing(temp_authorize_tx_values)\n        authorize_tx_values.update(temp_authorize_tx_values)\n        return authorize_tx_values\n\n    @api.multi\n    def authorize_get_form_action_url(self):\n        self.ensure_one()\n        return self._get_authorize_urls(self.environment)['authorize_form_url']\n\n    @api.model\n    def authorize_s2s_form_process(self, data):\n        values = {\n            'cc_number': data.get('cc_number'),\n            'cc_holder_name': data.get('cc_holder_name'),\n            'cc_expiry': data.get('cc_expiry'),\n            'cc_cvc': data.get('cc_cvc'),\n            'cc_brand': data.get('cc_brand'),\n            'acquirer_id': int(data.get('acquirer_id')),\n            'partner_id': int(data.get('partner_id'))\n        }\n        PaymentMethod = self.env['payment.token'].sudo().create(values)\n        return PaymentMethod\n\n    @api.multi\n    def authorize_s2s_form_validate(self, data):\n        error = dict()\n        mandatory_fields = [\"cc_number\", \"cc_cvc\", \"cc_holder_name\", \"cc_expiry\", \"cc_brand\"]\n        # Validation\n        for field_name in mandatory_fields:\n            if not data.get(field_name):\n                error[field_name] = 'missing'\n        if data['cc_expiry'] and datetime.now().strftime('%y%m') > datetime.strptime(data['cc_expiry'], '%m / %y').strftime('%y%m'):\n            return False\n        return False if error else True\n\n    @api.multi\n    def authorize_test_credentials(self):\n        self.ensure_one()\n        transaction = AuthorizeAPI(self.acquirer_id)\n        return transaction.test_authenticate()\n\nclass TxAuthorize(models.Model):\n    _inherit = 'payment.transaction'\n\n    _authorize_valid_tx_status = 1\n    _authorize_pending_tx_status = 4\n    _authorize_cancel_tx_status = 2\n\n    # --------------------------------------------------\n    # FORM RELATED METHODS\n    # --------------------------------------------------\n\n    @api.model\n    def create(self, vals):\n        # The reference is used in the Authorize form to fill a field (invoiceNumber) which is\n        # limited to 20 characters. We truncate the reference now, since it will be reused at\n        # payment validation to find back the transaction.\n        if 'reference' in vals and 'acquirer_id' in vals:\n            acquier = self.env['payment.acquirer'].browse(vals['acquirer_id'])\n            if acquier.provider == 'authorize':\n                vals['reference'] = vals.get('reference', '')[:20]\n        return super(TxAuthorize, self).create(vals)\n\n    @api.model\n    def _authorize_form_get_tx_from_data(self, data):\n        \"\"\" Given a data dict coming from authorize, verify it and find the related\n        transaction record. \"\"\"\n        reference, trans_id, fingerprint = data.get('x_invoice_num'), data.get('x_trans_id'), data.get('x_MD5_Hash')\n        if not reference or not trans_id or not fingerprint:\n            error_msg = _('Authorize: received data with missing reference (%s) or trans_id (%s) or fingerprint (%s)') % (reference, trans_id, fingerprint)\n            _logger.info(error_msg)\n            raise ValidationError(error_msg)\n        tx = self.search([('reference', '=', reference)])\n        if not tx or len(tx) > 1:\n            error_msg = 'Authorize: received data for reference %s' % (reference)\n            if not tx:\n                error_msg += '; no order found'\n            else:\n                error_msg += '; multiple order found'\n            _logger.info(error_msg)\n            raise ValidationError(error_msg)\n        return tx[0]\n\n    @api.multi\n    def _authorize_form_get_invalid_parameters(self, data):\n        invalid_parameters = []\n\n        if self.acquirer_reference and data.get('x_trans_id') != self.acquirer_reference:\n            invalid_parameters.append(('Transaction Id', data.get('x_trans_id'), self.acquirer_reference))\n        # check what is buyed\n        if float_compare(float(data.get('x_amount', '0.0')), self.amount, 2) != 0:\n            invalid_parameters.append(('Amount', data.get('x_amount'), '%.2f' % self.amount))\n        return invalid_parameters\n\n    @api.multi\n    def _authorize_form_validate(self, data):\n        if self.state in ['done', 'refunded']:\n            _logger.warning('Authorize: trying to validate an already validated tx (ref %s)' % self.reference)\n            return True\n        status_code = int(data.get('x_response_code', '0'))\n        if status_code == self._authorize_valid_tx_status:\n            if data.get('x_type').lower() in ['auth_capture', 'prior_auth_capture']:\n                self.write({\n                    'state': 'done',\n                    'acquirer_reference': data.get('x_trans_id'),\n                    'date_validate': fields.Datetime.now(),\n                })\n            elif data.get('x_type').lower() in ['auth_only']:\n                self.write({\n                    'state': 'authorized',\n                    'acquirer_reference': data.get('x_trans_id'),\n                })\n            if self.partner_id and not self.payment_token_id and \\\n               (self.type == 'form_save' or self.acquirer_id.save_token == 'always'):\n                transaction = AuthorizeAPI(self.acquirer_id)\n                res = transaction.create_customer_profile_from_tx(self.partner_id, self.acquirer_reference)\n                token_id = self.env['payment.token'].create({\n                    'authorize_profile': res.get('profile_id'),\n                    'name': res.get('name'),\n                    'acquirer_ref': res.get('payment_profile_id'),\n                    'acquirer_id': self.acquirer_id.id,\n                    'partner_id': self.partner_id.id,\n                })\n                self.payment_token_id = token_id\n\n            if self.payment_token_id:\n                self.payment_token_id.verified = True\n            return True\n        elif status_code == self._authorize_pending_tx_status:\n            self.write({\n                'state': 'pending',\n                'acquirer_reference': data.get('x_trans_id'),\n            })\n            return True\n        elif status_code == self._authorize_cancel_tx_status:\n            self.write({\n                'state': 'cancel',\n                'acquirer_reference': data.get('x_trans_id'),\n                'state_message': data.get('x_response_reason_text'),\n            })\n            return True\n        else:\n            error = data.get('x_response_reason_text')\n            _logger.info(error)\n            self.write({\n                'state': 'error',\n                'state_message': error,\n                'acquirer_reference': data.get('x_trans_id'),\n            })\n            return False\n\n    @api.multi\n    def authorize_s2s_do_transaction(self, **data):\n        self.ensure_one()\n        transaction = AuthorizeAPI(self.acquirer_id)\n        if not self.acquirer_id.capture_manually:\n            res = transaction.auth_and_capture(self.payment_token_id, self.amount, self.reference)\n        else:\n            res = transaction.authorize(self.payment_token_id, self.amount, self.reference)\n        return self._authorize_s2s_validate_tree(res)\n\n    @api.multi\n    def authorize_s2s_do_refund(self):\n        self.ensure_one()\n        transaction = AuthorizeAPI(self.acquirer_id)\n        self.state = 'refunding'\n        if self.type == 'validation':\n            res = transaction.void(self.acquirer_reference)\n        else:\n            res = transaction.credit(self.payment_token_id, self.amount, self.acquirer_reference)\n        return self._authorize_s2s_validate_tree(res)\n\n    @api.multi\n    def authorize_s2s_capture_transaction(self):\n        self.ensure_one()\n        transaction = AuthorizeAPI(self.acquirer_id)\n        tree = transaction.capture(self.acquirer_reference or '', self.amount)\n        return self._authorize_s2s_validate_tree(tree)\n\n    @api.multi\n    def authorize_s2s_void_transaction(self):\n        self.ensure_one()\n        transaction = AuthorizeAPI(self.acquirer_id)\n        tree = transaction.void(self.acquirer_reference or '')\n        return self._authorize_s2s_validate_tree(tree)\n\n    @api.multi\n    def _authorize_s2s_validate_tree(self, tree):\n        return self._authorize_s2s_validate(tree)\n\n    @api.multi\n    def _authorize_s2s_validate(self, tree):\n        if self.state in ['done', 'refunded']:\n            _logger.warning('Authorize: trying to validate an already validated tx (ref %s)' % self.reference)\n            return True\n        status_code = int(tree.get('x_response_code', '0'))\n        if status_code == self._authorize_valid_tx_status:\n            if tree.get('x_type').lower() in ['auth_capture', 'prior_auth_capture']:\n                init_state = self.state\n                self.write({\n                    'state': 'done',\n                    'acquirer_reference': tree.get('x_trans_id'),\n                    'date_validate': fields.Datetime.now(),\n                })\n                if init_state != 'authorized':\n                    self.execute_callback()\n\n                if self.payment_token_id:\n                    self.payment_token_id.verified = True\n\n            if tree.get('x_type').lower() == 'auth_only':\n                self.write({\n                    'state': 'authorized',\n                    'acquirer_reference': tree.get('x_trans_id'),\n                })\n                self.execute_callback()\n            if tree.get('x_type').lower() == 'void':\n                if self.type == 'validation' and self.state == 'refunding':\n                    self.write({\n                        'state': 'refunded',\n                    })\n                else:\n                    self.write({\n                        'state': 'cancel',\n                    })\n            return True\n        elif status_code == self._authorize_pending_tx_status:\n            new_state = 'refunding' if self.state == 'refunding' else 'pending'\n            self.write({\n                'state': new_state,\n                'acquirer_reference': tree.get('x_trans_id'),\n            })\n            return True\n        elif status_code == self._authorize_cancel_tx_status:\n            self.write({\n                'state': 'cancel',\n                'acquirer_reference': tree.get('x_trans_id'),\n            })\n            return True\n        else:\n            error = tree.get('x_response_reason_text')\n            _logger.info(error)\n            self.write({\n                'state': 'error',\n                'state_message': error,\n                'acquirer_reference': tree.get('x_trans_id'),\n            })\n            return False\n\n\nclass PaymentToken(models.Model):\n    _inherit = 'payment.token'\n\n    authorize_profile = fields.Char(string='Authorize.net Profile ID', help='This contains the unique reference '\n                                    'for this partner/payment token combination in the Authorize.net backend')\n    provider = fields.Selection(string='Provider', related='acquirer_id.provider')\n    save_token = fields.Selection(string='Save Cards', related='acquirer_id.save_token')\n\n    @api.model\n    def authorize_create(self, values):\n        if values.get('cc_number'):\n            values['cc_number'] = values['cc_number'].replace(' ', '')\n            acquirer = self.env['payment.acquirer'].browse(values['acquirer_id'])\n            expiry = str(values['cc_expiry'][:2]) + str(values['cc_expiry'][-2:])\n            partner = self.env['res.partner'].browse(values['partner_id'])\n            transaction = AuthorizeAPI(acquirer)\n            res = transaction.create_customer_profile(partner, values['cc_number'], expiry, values['cc_cvc'])\n            if res.get('profile_id') and res.get('payment_profile_id'):\n                return {\n                    'authorize_profile': res.get('profile_id'),\n                    'name': 'XXXXXXXXXXXX%s - %s' % (values['cc_number'][-4:], values['cc_holder_name']),\n                    'acquirer_ref': res.get('payment_profile_id'),\n                }\n            else:\n                raise ValidationError(_('The Customer Profile creation in Authorize.NET failed.'))\n        else:\n            return values\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "payment.py", "id": "2b4384b9bed40658a998941bf10e5372", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/payment_authorize/models/payment.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}