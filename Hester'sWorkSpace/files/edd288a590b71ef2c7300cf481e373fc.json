{"author": "django", "code": "import datetime\nfrom collections import OrderedDict\n\nfrom django.contrib.auth.models import User\nfrom django.test import TestCase\n\nfrom .models import Order, RevisionableModel, TestObject\n\n\nclass ExtraRegressTests(TestCase):\n\n    def setUp(self):\n        self.u = User.objects.create_user(\n            username=\"fred\",\n            password=\"secret\",\n            email=\"fred@example.com\"\n        )\n\n    def test_regression_7314_7372(self):\n        \"\"\"\n        Regression tests for \n        \"\"\"\n        rm = RevisionableModel.objects.create(\n            title='First Revision',\n            when=datetime.datetime(2008, 9, 28, 10, 30, 0)\n        )\n        self.assertEqual(rm.pk, rm.base.pk)\n\n        rm2 = rm.new_revision()\n        rm2.title = \"Second Revision\"\n        rm.when = datetime.datetime(2008, 9, 28, 14, 25, 0)\n        rm2.save()\n\n        self.assertEqual(rm2.title, 'Second Revision')\n        self.assertEqual(rm2.base.title, 'First Revision')\n\n        self.assertNotEqual(rm2.pk, rm.pk)\n        self.assertEqual(rm2.base.pk, rm.pk)\n\n        \n        qs = RevisionableModel.objects.extra(\n            where=[\"%(table)s.id IN (SELECT MAX(rev.id) FROM %(table)s rev GROUP BY rev.base_id)\" % {\n                'table': RevisionableModel._meta.db_table,\n            }]\n        )\n\n        self.assertQuerysetEqual(\n            qs, [('Second Revision', 'First Revision')],\n            transform=lambda r: (r.title, r.base.title)\n        )\n\n        \n        qs2 = RevisionableModel.objects.filter(title__contains=\"Revision\")\n        self.assertQuerysetEqual(\n            qs2, [\n                ('First Revision', 'First Revision'),\n                ('Second Revision', 'First Revision'),\n            ],\n            transform=lambda r: (r.title, r.base.title),\n            ordered=False\n        )\n\n        \n        self.assertQuerysetEqual(\n            qs & qs2,\n            [('Second Revision', 'First Revision')],\n            transform=lambda r: (r.title, r.base.title),\n            ordered=False\n        )\n\n    def test_extra_stay_tied(self):\n        \n        \n        \n        qs = User.objects.extra(\n            select=OrderedDict(((\"alpha\", \"%s\"), (\"beta\", \"2\"), (\"gamma\", \"%s\"))),\n            select_params=(1, 3)\n        )\n        qs = qs.extra(select={\"beta\": 4})\n        qs = qs.extra(select={\"alpha\": \"%s\"}, select_params=[5])\n        self.assertEqual(\n            list(qs.filter(id=self.u.id).values('alpha', 'beta', 'gamma')),\n            [{'alpha': 5, 'beta': 4, 'gamma': 3}]\n        )\n\n    def test_regression_7957(self):\n        \"\"\"\n        Regression test for #7957: Combining extra() calls should leave the\n        corresponding parameters associated with the right extra() bit. I.e.\n        internal dictionary must remain sorted.\n        \"\"\"\n        self.assertEqual(\n            (User.objects\n                .extra(select={\"alpha\": \"%s\"}, select_params=(1,))\n                .extra(select={\"beta\": \"%s\"}, select_params=(2,))[0].alpha),\n            1\n        )\n\n        self.assertEqual(\n            (User.objects\n                .extra(select={\"beta\": \"%s\"}, select_params=(1,))\n                .extra(select={\"alpha\": \"%s\"}, select_params=(2,))[0].alpha),\n            2\n        )\n\n    def test_regression_7961(self):\n        \"\"\"\n        Regression test for \n        extra(...) in a query, remove any corresponding parameters from the\n        query as well.\n        \"\"\"\n        self.assertEqual(\n            list(User.objects.extra(select={\"alpha\": \"%s\"}, select_params=(-6,))\n                 .filter(id=self.u.id).values_list('id', flat=True)),\n            [self.u.id]\n        )\n\n    def test_regression_8063(self):\n        \"\"\"\n        Regression test for \n        extra() bits.\n        \"\"\"\n        qs = User.objects.all().extra(where=['id=%s'], params=[self.u.id])\n        self.assertQuerysetEqual(qs, ['<User: fred>'])\n        self.assertQuerysetEqual(qs[:1], ['<User: fred>'])\n\n    def test_regression_8039(self):\n        \"\"\"\n        Regression test for \n        from extra(). This test is the critical case: ordering uses a table,\n        but then removes the reference because of an optimization. The table\n        should still be present because of the extra() call.\n        \"\"\"\n        self.assertQuerysetEqual(\n            (Order.objects\n                .extra(where=[\"username=%s\"], params=[\"fred\"], tables=[\"auth_user\"])\n                .order_by('created_by')),\n            []\n        )\n\n    def test_regression_8819(self):\n        \"\"\"\n        Regression test for #8819: Fields in the extra(select=...) list\n        should be available to extra(order_by=...).\n        \"\"\"\n        self.assertQuerysetEqual(\n            User.objects.filter(pk=self.u.id).extra(select={'extra_field': 1}).distinct(),\n            ['<User: fred>']\n        )\n        self.assertQuerysetEqual(\n            User.objects.filter(pk=self.u.id).extra(select={'extra_field': 1}, order_by=['extra_field']),\n            ['<User: fred>']\n        )\n        self.assertQuerysetEqual(\n            User.objects.filter(pk=self.u.id).extra(select={'extra_field': 1}, order_by=['extra_field']).distinct(),\n            ['<User: fred>']\n        )\n\n    def test_dates_query(self):\n        \"\"\"\n        When calling the dates() method on a queryset with extra selection\n        columns, we can (and should) ignore those columns. They don't change\n        the result and cause incorrect SQL to be produced otherwise.\n        \"\"\"\n        RevisionableModel.objects.create(\n            title='First Revision',\n            when=datetime.datetime(2008, 9, 28, 10, 30, 0)\n        )\n\n        self.assertSequenceEqual(\n            RevisionableModel.objects.extra(select={\"the_answer\": 'id'}).datetimes('when', 'month'),\n            [datetime.datetime(2008, 9, 1, 0, 0)],\n        )\n\n    def test_values_with_extra(self):\n        \"\"\"\n        Regression test for #10256... If there is a values() clause, Extra\n        columns are only returned if they are explicitly mentioned.\n        \"\"\"\n        obj = TestObject(first='first', second='second', third='third')\n        obj.save()\n\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values()\n            ),\n            [{\n                'bar': 'second', 'third': 'third', 'second': 'second', 'whiz': 'third', 'foo': 'first',\n                'id': obj.pk, 'first': 'first'\n            }]\n        )\n\n        \n        self.assertEqual(\n            list(\n                TestObject.objects\n                .values()\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n            ),\n            [{\n                'bar': 'second', 'third': 'third', 'second': 'second', 'whiz': 'third', 'foo': 'first',\n                'id': obj.pk, 'first': 'first'\n            }]\n        )\n\n        # Extra columns are ignored if not mentioned in the values() clause\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values('first', 'second')\n            ),\n            [{'second': 'second', 'first': 'first'}]\n        )\n\n        # Extra columns after a non-empty values() clause are ignored\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .values('first', 'second')\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n            ),\n            [{'second': 'second', 'first': 'first'}]\n        )\n\n        \n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values('first', 'second', 'foo')\n            ),\n            [{'second': 'second', 'foo': 'first', 'first': 'first'}]\n        )\n\n        \n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values('foo', 'whiz')\n            ),\n            [{'foo': 'first', 'whiz': 'third'}]\n        )\n\n        \n        ()\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list()\n            ),\n            [('first', 'second', 'third', obj.pk, 'first', 'second', 'third')]\n        )\n\n        # Extra columns after an empty values_list() are still included\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .values_list()\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n            ),\n            [('first', 'second', 'third', obj.pk, 'first', 'second', 'third')]\n        )\n\n        ()\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list('first', 'second')\n            ),\n            [('first', 'second')]\n        )\n\n        # Extra columns after a non-empty values_list() clause are ignored completely\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .values_list('first', 'second')\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n            ),\n            [('first', 'second')]\n        )\n\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list('second', flat=True)\n            ),\n            ['second']\n        )\n\n        # Only the extra columns specified in the values_list() are returned\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list('first', 'second', 'whiz')\n            ),\n            [('first', 'second', 'third')]\n        )\n\n        \n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list('foo', 'whiz')\n            ),\n            [('first', 'third')]\n        )\n\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list('whiz', flat=True)\n            ),\n            ['third']\n        )\n\n        \n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list('whiz', 'foo')\n            ),\n            [('third', 'first')]\n        )\n\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list('first', 'id')\n            ),\n            [('first', obj.pk)]\n        )\n\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list('whiz', 'first', 'bar', 'id')\n            ),\n            [('third', 'first', 'second', obj.pk)]\n        )\n\n    def test_regression_10847(self):\n        \"\"\"\n        Regression for \n        accurately evaluated. Using an inner query ensures that as_sql() is\n        producing correct output without requiring full evaluation and\n        execution of the inner query.\n        \"\"\"\n        obj = TestObject(first='first', second='second', third='third')\n        obj.save()\n\n        self.assertEqual(\n            list(TestObject.objects.extra(select={'extra': 1}).values('pk')),\n            [{'pk': obj.pk}]\n        )\n\n        self.assertQuerysetEqual(\n            TestObject.objects.filter(\n                pk__in=TestObject.objects.extra(select={'extra': 1}).values('pk')\n            ),\n            ['<TestObject: TestObject: first,second,third>']\n        )\n\n        self.assertEqual(\n            list(TestObject.objects.values('pk').extra(select={'extra': 1})),\n            [{'pk': obj.pk}]\n        )\n\n        self.assertQuerysetEqual(\n            TestObject.objects.filter(\n                pk__in=TestObject.objects.values('pk').extra(select={'extra': 1})\n            ),\n            ['<TestObject: TestObject: first,second,third>']\n        )\n\n        self.assertQuerysetEqual(\n            TestObject.objects.filter(pk=obj.pk) | TestObject.objects.extra(where=[\"id > %s\"], params=[obj.pk]),\n            ['<TestObject: TestObject: first,second,third>']\n        )\n\n    def test_regression_17877(self):\n        \"\"\"\n        Extra WHERE clauses get correctly ANDed, even when they\n        contain OR operations.\n        \"\"\"\n        \n        t = TestObject(first='a', second='a', third='a')\n        t.save()\n        \n        t = TestObject(first='b', second='a', third='a')\n        t.save()\n        \n        t = TestObject(first='a', second='a', third='b')\n        t.save()\n        \n        t = TestObject(first='b', second='a', third='b')\n        t.save()\n        \n        t = TestObject(first='b', second='b', third='a')\n        t.save()\n        \n        t = TestObject(first='a', second='b', third='b')\n        t.save()\n\n        self.assertQuerysetEqual(\n            TestObject.objects.extra(\n                where=[\"first = 'a' OR second = 'a'\", \"third = 'a'\"],\n            ),\n            ['<TestObject: TestObject: a,a,a>', '<TestObject: TestObject: b,a,a>'],\n            ordered=False\n        )\n\n    def test_extra_values_distinct_ordering(self):\n        t1 = TestObject.objects.create(first='a', second='a', third='a')\n        t2 = TestObject.objects.create(first='a', second='b', third='b')\n        qs = TestObject.objects.extra(\n            select={'second_extra': 'second'}\n        ).values_list('id', flat=True).distinct()\n        self.assertSequenceEqual(qs.order_by('second_extra'), [t1.pk, t2.pk])\n        self.assertSequenceEqual(qs.order_by('-second_extra'), [t2.pk, t1.pk])\n        \n        # non-distinct results here (this is on purpose, see #7070).\n        \n        self.assertSequenceEqual(qs.order_by('-second_extra').values_list('first'), [('a',), ('a',)])\n", "comments": "            regression tests  7314  7372                     rm   revisionablemodel objects create(             title  first revision               datetime datetime(2008  9  28  10  30  0)         )         self assertequal(rm pk  rm base pk)          rm2   rm new revision()         rm2 title    second revision          rm   datetime datetime(2008  9  28  14  25  0)         rm2 save()          self assertequal(rm2 title   second revision )         self assertequal(rm2 base title   first revision )          self assertnotequal(rm2 pk  rm pk)         self assertequal(rm2 base pk  rm pk)            queryset match recent revision          qs   revisionablemodel objects extra(                (table)s id in (select max(rev id) from  (table)s rev group by rev base id)                       table   revisionablemodel  meta db table                         )          self assertquerysetequal(             qs   ( second revision    first revision )               transform lambda r  (r title  r base title)         )            queryset search string title          qs2   revisionablemodel objects filter(title  contains  revision )         self assertquerysetequal(             qs2                    ( first revision    first revision )                  ( second revision    first revision )                             transform lambda r  (r title  r base title)              ordered false         )            following queryset return recent revision          self assertquerysetequal(             qs   qs2               ( second revision    first revision )               transform lambda r  (r title  r base title)              ordered false         )      def test extra stay tied(self)            extra select parameters stay tied corresponding           select portions  applies portions updated otherwise           moved around          qs   user objects extra(             select ordereddict((( alpha     )  ( beta    2 )  ( gamma     )))              select params (1  3)         )         qs   qs extra(select   beta   4 )         qs   qs extra(select   alpha        select params  5 )         self assertequal(             list(qs filter(id self u id) values( alpha    beta    gamma ))                 alpha   5   beta   4   gamma   3           )      def test regression 7957(self)                      regression test  7957  combining extra() calls leave         corresponding parameters associated right extra() bit  i e          internal dictionary must remain sorted                      self assertequal(             (user objects                  extra(select   alpha        select params (1 ))                  extra(select   beta        select params (2 )) 0  alpha)              1         )          self assertequal(             (user objects                  extra(select   beta        select params (1 ))                  extra(select   alpha        select params (2 )) 0  alpha)              2         )      def test regression 7961(self)                      regression test  7961  when using portion         extra(   ) query  remove corresponding parameters         query well                      self assertequal(             list(user objects extra(select   alpha        select params ( 6 ))                   filter(id self u id) values list( id   flat true))               self u id          )      def test regression 8063(self)                      regression test  8063  limiting query discard         extra() bits                      qs   user objects all() extra(where   id     params  self u id )         self assertquerysetequal(qs     user  fred   )         self assertquerysetequal(qs  1      user  fred   )      def test regression 8039(self)                      regression test  8039  ordering sometimes removed relevant tables         extra()  this test critical case  ordering uses table          removes reference optimization  the table         still present extra() call                      self assertquerysetequal(             (order objects                  extra(where   username     params   fred    tables   auth user  )                  order by( created ))                         )      def test regression 8819(self)                      regression test  8819  fields extra(select    ) list         available extra(order    )                      self assertquerysetequal(             user objects filter(pk self u id) extra(select   extra field   1 ) distinct()                 user  fred            )         self assertquerysetequal(             user objects filter(pk self u id) extra(select   extra field   1   order   extra field  )                 user  fred            )         self assertquerysetequal(             user objects filter(pk self u id) extra(select   extra field   1   order   extra field  ) distinct()                 user  fred            )      def test dates query(self)                      when calling dates() method queryset extra selection         columns  (and should) ignore columns  they change         result cause incorrect sql produced otherwise                      revisionablemodel objects create(             title  first revision               datetime datetime(2008  9  28  10  30  0)         )          self assertsequenceequal(             revisionablemodel objects extra(select   answer    id  ) datetimes(    month )               datetime datetime(2008  9  1  0  0)           )      def test values extra(self)                      regression test  10256    if values() clause  extra         columns returned explicitly mentioned                      obj   testobject(first  first   second  second   third  third )         obj save()          self assertequal(             list(                 testobject objects                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))                  values()             )                                  bar    second    third    third    second    second    whiz    third    foo    first                    id   obj pk   first    first                         )            extra clauses empty values clause still included         self assertequal(             list(                 testobject objects                  values()                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))             )                                  bar    second    third    third    second    second    whiz    third    foo    first                    id   obj pk   first    first                         )            extra columns ignored mentioned values() clause         self assertequal(             list(                 testobject objects                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))                  values( first    second )             )                 second    second    first    first            )            extra columns non empty values() clause ignored         self assertequal(             list(                 testobject objects                  values( first    second )                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))             )                 second    second    first    first            )            extra columns partially returned         self assertequal(             list(                 testobject objects                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))                  values( first    second    foo )             )                 second    second    foo    first    first    first            )            also works extra columns included         self assertequal(             list(                 testobject objects                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))                  values( foo    whiz )             )                 foo    first    whiz    third            )            values list works way           all columns returned empty values list()         self assertequal(             list(                 testobject objects                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))                  values list()             )               ( first    second    third   obj pk   first    second    third )          )            extra columns empty values list() still included         self assertequal(             list(                 testobject objects                  values list()                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))             )               ( first    second    third   obj pk   first    second    third )          )            extra columns ignored completely mentioned values list()         self assertequal(             list(                 testobject objects                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))                  values list( first    second )             )               ( first    second )          )            extra columns non empty values list() clause ignored completely         self assertequal(             list(                 testobject objects                  values list( first    second )                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))             )               ( first    second )          )          self assertequal(             list(                 testobject objects                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))                  values list( second   flat true)             )                second           )            only extra columns specified values list() returned         self assertequal(             list(                 testobject objects                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))                  values list( first    second    whiz )             )               ( first    second    third )          )               also works extra columns included         self assertequal(             list(                 testobject objects                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))                  values list( foo    whiz )             )               ( first    third )          )          self assertequal(             list(                 testobject objects                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))                  values list( whiz   flat true)             )                third           )                values returned order specified         self assertequal(             list(                 testobject objects                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))                  values list( whiz    foo )             )               ( third    first )          )          self assertequal(             list(                 testobject objects                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))                  values list( first    id )             )               ( first   obj pk)          )          self assertequal(             list(                 testobject objects                  extra(select ordereddict((( foo    first )  ( bar    second )  ( whiz    third ))))                  values list( whiz    first    bar    id )             )               ( third    first    second   obj pk)          )      def test regression 10847(self)                      regression  10847  list extra columns always         accurately evaluated  using inner query ensures sql()         producing correct output without requiring full evaluation         execution inner query                      obj   testobject(first  first   second  second   third  third )         obj save()          self assertequal(             list(testobject objects extra(select   extra   1 ) values( pk ))                 pk   obj pk           )          self assertquerysetequal(             testobject objects filter(                 pk  testobject objects extra(select   extra   1 ) values( pk )             )                 testobject  testobject  first second third            )          self assertequal(             list(testobject objects values( pk ) extra(select   extra   1 ))                 pk   obj pk           )          self assertquerysetequal(             testobject objects filter(                 pk  testobject objects values( pk ) extra(select   extra   1 )             )                 testobject  testobject  first second third            )          self assertquerysetequal(             testobject objects filter(pk obj pk)   testobject objects extra(where   id       params  obj pk )                 testobject  testobject  first second third            )      def test regression 17877(self)                      extra where clauses get correctly anded  even         contain or operations                7314  7372    queryset match recent revision     queryset search string title     following queryset return recent revision     extra select parameters stay tied corresponding    select portions  applies portions updated otherwise    moved around    7957  combining extra() calls leave   7961  when using portion   8063  limiting query discard   8039  ordering sometimes removed relevant tables   8819  fields extra(select    ) list   10256    if values() clause  extra    extra clauses empty values clause still included    extra columns ignored mentioned values() clause    extra columns non empty values() clause ignored    extra columns partially returned    also works extra columns included    values list works way    all columns returned empty values list()    extra columns empty values list() still included    extra columns ignored completely mentioned values list()    extra columns non empty values list() clause ignored completely    only extra columns specified values list() returned       also works extra columns included        values returned order specified   10847  list extra columns always    test case 1  appear queryset     test case 2  appear queryset     test case 3  appear queryset  bug case     test case 4  appear queryset     test case 5  appear queryset     test case 6  appear queryset  bug case     note  extra ordering must appear select clause  get two    non distinct results (this purpose  see  7070)     extra select appear result values  ", "content": "import datetime\nfrom collections import OrderedDict\n\nfrom django.contrib.auth.models import User\nfrom django.test import TestCase\n\nfrom .models import Order, RevisionableModel, TestObject\n\n\nclass ExtraRegressTests(TestCase):\n\n    def setUp(self):\n        self.u = User.objects.create_user(\n            username=\"fred\",\n            password=\"secret\",\n            email=\"fred@example.com\"\n        )\n\n    def test_regression_7314_7372(self):\n        \"\"\"\n        Regression tests for #7314 and #7372\n        \"\"\"\n        rm = RevisionableModel.objects.create(\n            title='First Revision',\n            when=datetime.datetime(2008, 9, 28, 10, 30, 0)\n        )\n        self.assertEqual(rm.pk, rm.base.pk)\n\n        rm2 = rm.new_revision()\n        rm2.title = \"Second Revision\"\n        rm.when = datetime.datetime(2008, 9, 28, 14, 25, 0)\n        rm2.save()\n\n        self.assertEqual(rm2.title, 'Second Revision')\n        self.assertEqual(rm2.base.title, 'First Revision')\n\n        self.assertNotEqual(rm2.pk, rm.pk)\n        self.assertEqual(rm2.base.pk, rm.pk)\n\n        # Queryset to match most recent revision:\n        qs = RevisionableModel.objects.extra(\n            where=[\"%(table)s.id IN (SELECT MAX(rev.id) FROM %(table)s rev GROUP BY rev.base_id)\" % {\n                'table': RevisionableModel._meta.db_table,\n            }]\n        )\n\n        self.assertQuerysetEqual(\n            qs, [('Second Revision', 'First Revision')],\n            transform=lambda r: (r.title, r.base.title)\n        )\n\n        # Queryset to search for string in title:\n        qs2 = RevisionableModel.objects.filter(title__contains=\"Revision\")\n        self.assertQuerysetEqual(\n            qs2, [\n                ('First Revision', 'First Revision'),\n                ('Second Revision', 'First Revision'),\n            ],\n            transform=lambda r: (r.title, r.base.title),\n            ordered=False\n        )\n\n        # Following queryset should return the most recent revision:\n        self.assertQuerysetEqual(\n            qs & qs2,\n            [('Second Revision', 'First Revision')],\n            transform=lambda r: (r.title, r.base.title),\n            ordered=False\n        )\n\n    def test_extra_stay_tied(self):\n        # Extra select parameters should stay tied to their corresponding\n        # select portions. Applies when portions are updated or otherwise\n        # moved around.\n        qs = User.objects.extra(\n            select=OrderedDict(((\"alpha\", \"%s\"), (\"beta\", \"2\"), (\"gamma\", \"%s\"))),\n            select_params=(1, 3)\n        )\n        qs = qs.extra(select={\"beta\": 4})\n        qs = qs.extra(select={\"alpha\": \"%s\"}, select_params=[5])\n        self.assertEqual(\n            list(qs.filter(id=self.u.id).values('alpha', 'beta', 'gamma')),\n            [{'alpha': 5, 'beta': 4, 'gamma': 3}]\n        )\n\n    def test_regression_7957(self):\n        \"\"\"\n        Regression test for #7957: Combining extra() calls should leave the\n        corresponding parameters associated with the right extra() bit. I.e.\n        internal dictionary must remain sorted.\n        \"\"\"\n        self.assertEqual(\n            (User.objects\n                .extra(select={\"alpha\": \"%s\"}, select_params=(1,))\n                .extra(select={\"beta\": \"%s\"}, select_params=(2,))[0].alpha),\n            1\n        )\n\n        self.assertEqual(\n            (User.objects\n                .extra(select={\"beta\": \"%s\"}, select_params=(1,))\n                .extra(select={\"alpha\": \"%s\"}, select_params=(2,))[0].alpha),\n            2\n        )\n\n    def test_regression_7961(self):\n        \"\"\"\n        Regression test for #7961: When not using a portion of an\n        extra(...) in a query, remove any corresponding parameters from the\n        query as well.\n        \"\"\"\n        self.assertEqual(\n            list(User.objects.extra(select={\"alpha\": \"%s\"}, select_params=(-6,))\n                 .filter(id=self.u.id).values_list('id', flat=True)),\n            [self.u.id]\n        )\n\n    def test_regression_8063(self):\n        \"\"\"\n        Regression test for #8063: limiting a query shouldn't discard any\n        extra() bits.\n        \"\"\"\n        qs = User.objects.all().extra(where=['id=%s'], params=[self.u.id])\n        self.assertQuerysetEqual(qs, ['<User: fred>'])\n        self.assertQuerysetEqual(qs[:1], ['<User: fred>'])\n\n    def test_regression_8039(self):\n        \"\"\"\n        Regression test for #8039: Ordering sometimes removed relevant tables\n        from extra(). This test is the critical case: ordering uses a table,\n        but then removes the reference because of an optimization. The table\n        should still be present because of the extra() call.\n        \"\"\"\n        self.assertQuerysetEqual(\n            (Order.objects\n                .extra(where=[\"username=%s\"], params=[\"fred\"], tables=[\"auth_user\"])\n                .order_by('created_by')),\n            []\n        )\n\n    def test_regression_8819(self):\n        \"\"\"\n        Regression test for #8819: Fields in the extra(select=...) list\n        should be available to extra(order_by=...).\n        \"\"\"\n        self.assertQuerysetEqual(\n            User.objects.filter(pk=self.u.id).extra(select={'extra_field': 1}).distinct(),\n            ['<User: fred>']\n        )\n        self.assertQuerysetEqual(\n            User.objects.filter(pk=self.u.id).extra(select={'extra_field': 1}, order_by=['extra_field']),\n            ['<User: fred>']\n        )\n        self.assertQuerysetEqual(\n            User.objects.filter(pk=self.u.id).extra(select={'extra_field': 1}, order_by=['extra_field']).distinct(),\n            ['<User: fred>']\n        )\n\n    def test_dates_query(self):\n        \"\"\"\n        When calling the dates() method on a queryset with extra selection\n        columns, we can (and should) ignore those columns. They don't change\n        the result and cause incorrect SQL to be produced otherwise.\n        \"\"\"\n        RevisionableModel.objects.create(\n            title='First Revision',\n            when=datetime.datetime(2008, 9, 28, 10, 30, 0)\n        )\n\n        self.assertSequenceEqual(\n            RevisionableModel.objects.extra(select={\"the_answer\": 'id'}).datetimes('when', 'month'),\n            [datetime.datetime(2008, 9, 1, 0, 0)],\n        )\n\n    def test_values_with_extra(self):\n        \"\"\"\n        Regression test for #10256... If there is a values() clause, Extra\n        columns are only returned if they are explicitly mentioned.\n        \"\"\"\n        obj = TestObject(first='first', second='second', third='third')\n        obj.save()\n\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values()\n            ),\n            [{\n                'bar': 'second', 'third': 'third', 'second': 'second', 'whiz': 'third', 'foo': 'first',\n                'id': obj.pk, 'first': 'first'\n            }]\n        )\n\n        # Extra clauses after an empty values clause are still included\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .values()\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n            ),\n            [{\n                'bar': 'second', 'third': 'third', 'second': 'second', 'whiz': 'third', 'foo': 'first',\n                'id': obj.pk, 'first': 'first'\n            }]\n        )\n\n        # Extra columns are ignored if not mentioned in the values() clause\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values('first', 'second')\n            ),\n            [{'second': 'second', 'first': 'first'}]\n        )\n\n        # Extra columns after a non-empty values() clause are ignored\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .values('first', 'second')\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n            ),\n            [{'second': 'second', 'first': 'first'}]\n        )\n\n        # Extra columns can be partially returned\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values('first', 'second', 'foo')\n            ),\n            [{'second': 'second', 'foo': 'first', 'first': 'first'}]\n        )\n\n        # Also works if only extra columns are included\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values('foo', 'whiz')\n            ),\n            [{'foo': 'first', 'whiz': 'third'}]\n        )\n\n        # Values list works the same way\n        # All columns are returned for an empty values_list()\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list()\n            ),\n            [('first', 'second', 'third', obj.pk, 'first', 'second', 'third')]\n        )\n\n        # Extra columns after an empty values_list() are still included\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .values_list()\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n            ),\n            [('first', 'second', 'third', obj.pk, 'first', 'second', 'third')]\n        )\n\n        # Extra columns ignored completely if not mentioned in values_list()\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list('first', 'second')\n            ),\n            [('first', 'second')]\n        )\n\n        # Extra columns after a non-empty values_list() clause are ignored completely\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .values_list('first', 'second')\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n            ),\n            [('first', 'second')]\n        )\n\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list('second', flat=True)\n            ),\n            ['second']\n        )\n\n        # Only the extra columns specified in the values_list() are returned\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list('first', 'second', 'whiz')\n            ),\n            [('first', 'second', 'third')]\n        )\n\n        # ...also works if only extra columns are included\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list('foo', 'whiz')\n            ),\n            [('first', 'third')]\n        )\n\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list('whiz', flat=True)\n            ),\n            ['third']\n        )\n\n        # ... and values are returned in the order they are specified\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list('whiz', 'foo')\n            ),\n            [('third', 'first')]\n        )\n\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list('first', 'id')\n            ),\n            [('first', obj.pk)]\n        )\n\n        self.assertEqual(\n            list(\n                TestObject.objects\n                .extra(select=OrderedDict((('foo', 'first'), ('bar', 'second'), ('whiz', 'third'))))\n                .values_list('whiz', 'first', 'bar', 'id')\n            ),\n            [('third', 'first', 'second', obj.pk)]\n        )\n\n    def test_regression_10847(self):\n        \"\"\"\n        Regression for #10847: the list of extra columns can always be\n        accurately evaluated. Using an inner query ensures that as_sql() is\n        producing correct output without requiring full evaluation and\n        execution of the inner query.\n        \"\"\"\n        obj = TestObject(first='first', second='second', third='third')\n        obj.save()\n\n        self.assertEqual(\n            list(TestObject.objects.extra(select={'extra': 1}).values('pk')),\n            [{'pk': obj.pk}]\n        )\n\n        self.assertQuerysetEqual(\n            TestObject.objects.filter(\n                pk__in=TestObject.objects.extra(select={'extra': 1}).values('pk')\n            ),\n            ['<TestObject: TestObject: first,second,third>']\n        )\n\n        self.assertEqual(\n            list(TestObject.objects.values('pk').extra(select={'extra': 1})),\n            [{'pk': obj.pk}]\n        )\n\n        self.assertQuerysetEqual(\n            TestObject.objects.filter(\n                pk__in=TestObject.objects.values('pk').extra(select={'extra': 1})\n            ),\n            ['<TestObject: TestObject: first,second,third>']\n        )\n\n        self.assertQuerysetEqual(\n            TestObject.objects.filter(pk=obj.pk) | TestObject.objects.extra(where=[\"id > %s\"], params=[obj.pk]),\n            ['<TestObject: TestObject: first,second,third>']\n        )\n\n    def test_regression_17877(self):\n        \"\"\"\n        Extra WHERE clauses get correctly ANDed, even when they\n        contain OR operations.\n        \"\"\"\n        # Test Case 1: should appear in queryset.\n        t = TestObject(first='a', second='a', third='a')\n        t.save()\n        # Test Case 2: should appear in queryset.\n        t = TestObject(first='b', second='a', third='a')\n        t.save()\n        # Test Case 3: should not appear in queryset, bug case.\n        t = TestObject(first='a', second='a', third='b')\n        t.save()\n        # Test Case 4: should not appear in queryset.\n        t = TestObject(first='b', second='a', third='b')\n        t.save()\n        # Test Case 5: should not appear in queryset.\n        t = TestObject(first='b', second='b', third='a')\n        t.save()\n        # Test Case 6: should not appear in queryset, bug case.\n        t = TestObject(first='a', second='b', third='b')\n        t.save()\n\n        self.assertQuerysetEqual(\n            TestObject.objects.extra(\n                where=[\"first = 'a' OR second = 'a'\", \"third = 'a'\"],\n            ),\n            ['<TestObject: TestObject: a,a,a>', '<TestObject: TestObject: b,a,a>'],\n            ordered=False\n        )\n\n    def test_extra_values_distinct_ordering(self):\n        t1 = TestObject.objects.create(first='a', second='a', third='a')\n        t2 = TestObject.objects.create(first='a', second='b', third='b')\n        qs = TestObject.objects.extra(\n            select={'second_extra': 'second'}\n        ).values_list('id', flat=True).distinct()\n        self.assertSequenceEqual(qs.order_by('second_extra'), [t1.pk, t2.pk])\n        self.assertSequenceEqual(qs.order_by('-second_extra'), [t2.pk, t1.pk])\n        # Note: the extra ordering must appear in select clause, so we get two\n        # non-distinct results here (this is on purpose, see #7070).\n        # Extra select doesn't appear in result values.\n        self.assertSequenceEqual(qs.order_by('-second_extra').values_list('first'), [('a',), ('a',)])\n", "description": "The Web framework for perfectionists with deadlines.", "file_name": "tests.py", "id": "edd288a590b71ef2c7300cf481e373fc", "language": "Python", "project_name": "django", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/django-django/django-django-acfc650/tests/extra_regress/tests.py", "save_time": "", "source": "", "update_at": "2018-03-14T02:00:36Z", "url": "https://github.com/django/django", "wiki": false}