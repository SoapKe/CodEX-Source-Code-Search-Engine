{"author": "tgalal", "code": "from yowsup.structs import ProtocolEntity, ProtocolTreeNode\nfrom yowsup.layers.protocol_receipts.protocolentities  import OutgoingReceiptProtocolEntity\nfrom copy import deepcopy\n\nclass MessageProtocolEntity(ProtocolEntity):\n\n    MESSAGE_TYPE_TEXT = \"text\"\n    MESSAGE_TYPE_MEDIA = \"media\"\n\n    def __init__(self, _type, _id = None,  _from = None, to = None, notify = None, timestamp = None,\n        participant = None, offline = None, retry = None):\n\n        assert (to or _from), \"Must specify either to or _from jids to create the message\"\n        assert not(to and _from), \"Can't set both attributes to message at same time (to, _from)\"\n\n\n        super(MessageProtocolEntity, self).__init__(\"message\")\n        self._type          = _type\n        self._id            = self._generateId() if _id is None else _id\n        self._from          =_from\n        self.to             = to\n        self.timestamp      = int(timestamp) if timestamp else self._getCurrentTimestamp()\n        self.notify         = notify\n        self.offline        = offline == \"1\" if offline is not None else offline\n        self.retry          = int(retry) if retry else None\n        self.participant    = participant\n\n    def getType(self):\n        return self._type\n\n    def getId(self):\n        return self._id\n\n    def getTimestamp(self):\n        return self.timestamp\n\n    def getFrom(self, full = True):\n        return self._from if full else self._from.split('@')[0]\n\n    def isBroadcast(self):\n        return False\n\n    def getTo(self, full = True):\n        return self.to if full else self.to.split('@')[0]\n\n    def getParticipant(self, full = True):\n        return self.participant if full else self.participant.split('@')[0]\n\n    def getAuthor(self, full = True):\n        return self.getParticipant(full) if self.isGroupMessage() else self.getFrom(full)\n\n    def getNotify(self):\n        return self.notify\n\n    def toProtocolTreeNode(self):\n        attribs = {\n            \"type\"      : self._type,\n            \"id\"        : self._id,\n        }\n\n        if self.isOutgoing():\n            attribs[\"to\"] = self.to\n        else:\n            attribs[\"from\"] = self._from\n\n            attribs[\"t\"] = str(self.timestamp)\n\n            if self.offline is not None:\n               attribs[\"offline\"] = \"1\" if self.offline else \"0\"\n            if self.notify:\n                attribs[\"notify\"] = self.notify\n            if self.retry:\n                attribs[\"retry\"] = str(self.retry)\n            if self.participant:\n                attribs[\"participant\"] = self.participant\n\n\n        xNode = None\n        #if self.isOutgoing():\n        #    serverNode = ProtocolTreeNode(\"server\", {})\n        #    xNode = ProtocolTreeNode(\"x\", {\"xmlns\": \"jabber:x:event\"}, [serverNode])\n\n\n        return self._createProtocolTreeNode(attribs, children = [xNode] if xNode else None, data = None)\n\n    def isOutgoing(self):\n        return self._from is None\n\n    def isGroupMessage(self):\n        if self.isOutgoing():\n            return \"-\" in self.to\n        return self.participant != None\n\n    def __str__(self):\n        out  = \"Message:\\n\"\n        out += \"ID: %s\\n\" % self._id\n        out += \"To: %s\\n\" % self.to  if self.isOutgoing() else \"From: %s\\n\" % self._from\n        out += \"Type:  %s\\n\" % self._type\n        out += \"Timestamp: %s\\n\" % self.timestamp\n        if self.participant:\n            out += \"Participant: %s\\n\" % self.participant\n        return out\n\n    def ack(self, read=False):\n        return OutgoingReceiptProtocolEntity(self.getId(), self.getFrom(), read, participant=self.getParticipant())\n\n    def forward(self, to, _id = None):\n        OutgoingMessage = deepcopy(self)\n        OutgoingMessage.to = to\n        OutgoingMessage._from = None\n        OutgoingMessage._id = self._generateId() if _id is None else _id\n        return OutgoingMessage\n\n    @staticmethod\n    def fromProtocolTreeNode(node):\n\n        return MessageProtocolEntity(\n            node.getAttributeValue(\"type\"),\n            node.getAttributeValue(\"id\"),\n            node.getAttributeValue(\"from\"),\n            node.getAttributeValue(\"to\"),\n            node.getAttributeValue(\"notify\"),\n            node.getAttributeValue(\"t\"),\n            node.getAttributeValue(\"participant\"),\n            node.getAttributeValue(\"offline\"),\n            node.getAttributeValue(\"retry\")\n            )\n", "comments": " self isoutgoing()        servernode   protocoltreenode( server     )       xnode   protocoltreenode( x     xmlns    jabber x event     servernode ) ", "content": "from yowsup.structs import ProtocolEntity, ProtocolTreeNode\nfrom yowsup.layers.protocol_receipts.protocolentities  import OutgoingReceiptProtocolEntity\nfrom copy import deepcopy\n\nclass MessageProtocolEntity(ProtocolEntity):\n\n    MESSAGE_TYPE_TEXT = \"text\"\n    MESSAGE_TYPE_MEDIA = \"media\"\n\n    def __init__(self, _type, _id = None,  _from = None, to = None, notify = None, timestamp = None,\n        participant = None, offline = None, retry = None):\n\n        assert (to or _from), \"Must specify either to or _from jids to create the message\"\n        assert not(to and _from), \"Can't set both attributes to message at same time (to, _from)\"\n\n\n        super(MessageProtocolEntity, self).__init__(\"message\")\n        self._type          = _type\n        self._id            = self._generateId() if _id is None else _id\n        self._from          =_from\n        self.to             = to\n        self.timestamp      = int(timestamp) if timestamp else self._getCurrentTimestamp()\n        self.notify         = notify\n        self.offline        = offline == \"1\" if offline is not None else offline\n        self.retry          = int(retry) if retry else None\n        self.participant    = participant\n\n    def getType(self):\n        return self._type\n\n    def getId(self):\n        return self._id\n\n    def getTimestamp(self):\n        return self.timestamp\n\n    def getFrom(self, full = True):\n        return self._from if full else self._from.split('@')[0]\n\n    def isBroadcast(self):\n        return False\n\n    def getTo(self, full = True):\n        return self.to if full else self.to.split('@')[0]\n\n    def getParticipant(self, full = True):\n        return self.participant if full else self.participant.split('@')[0]\n\n    def getAuthor(self, full = True):\n        return self.getParticipant(full) if self.isGroupMessage() else self.getFrom(full)\n\n    def getNotify(self):\n        return self.notify\n\n    def toProtocolTreeNode(self):\n        attribs = {\n            \"type\"      : self._type,\n            \"id\"        : self._id,\n        }\n\n        if self.isOutgoing():\n            attribs[\"to\"] = self.to\n        else:\n            attribs[\"from\"] = self._from\n\n            attribs[\"t\"] = str(self.timestamp)\n\n            if self.offline is not None:\n               attribs[\"offline\"] = \"1\" if self.offline else \"0\"\n            if self.notify:\n                attribs[\"notify\"] = self.notify\n            if self.retry:\n                attribs[\"retry\"] = str(self.retry)\n            if self.participant:\n                attribs[\"participant\"] = self.participant\n\n\n        xNode = None\n        #if self.isOutgoing():\n        #    serverNode = ProtocolTreeNode(\"server\", {})\n        #    xNode = ProtocolTreeNode(\"x\", {\"xmlns\": \"jabber:x:event\"}, [serverNode])\n\n\n        return self._createProtocolTreeNode(attribs, children = [xNode] if xNode else None, data = None)\n\n    def isOutgoing(self):\n        return self._from is None\n\n    def isGroupMessage(self):\n        if self.isOutgoing():\n            return \"-\" in self.to\n        return self.participant != None\n\n    def __str__(self):\n        out  = \"Message:\\n\"\n        out += \"ID: %s\\n\" % self._id\n        out += \"To: %s\\n\" % self.to  if self.isOutgoing() else \"From: %s\\n\" % self._from\n        out += \"Type:  %s\\n\" % self._type\n        out += \"Timestamp: %s\\n\" % self.timestamp\n        if self.participant:\n            out += \"Participant: %s\\n\" % self.participant\n        return out\n\n    def ack(self, read=False):\n        return OutgoingReceiptProtocolEntity(self.getId(), self.getFrom(), read, participant=self.getParticipant())\n\n    def forward(self, to, _id = None):\n        OutgoingMessage = deepcopy(self)\n        OutgoingMessage.to = to\n        OutgoingMessage._from = None\n        OutgoingMessage._id = self._generateId() if _id is None else _id\n        return OutgoingMessage\n\n    @staticmethod\n    def fromProtocolTreeNode(node):\n\n        return MessageProtocolEntity(\n            node.getAttributeValue(\"type\"),\n            node.getAttributeValue(\"id\"),\n            node.getAttributeValue(\"from\"),\n            node.getAttributeValue(\"to\"),\n            node.getAttributeValue(\"notify\"),\n            node.getAttributeValue(\"t\"),\n            node.getAttributeValue(\"participant\"),\n            node.getAttributeValue(\"offline\"),\n            node.getAttributeValue(\"retry\")\n            )\n", "description": "The python WhatsApp library", "file_name": "message.py", "id": "059303fc91557d898a14418689d5291b", "language": "Python", "project_name": "yowsup", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tgalal-yowsup/tgalal-yowsup-03795cc/yowsup/layers/protocol_messages/protocolentities/message.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:01:40Z", "url": "https://github.com/tgalal/yowsup", "wiki": true}