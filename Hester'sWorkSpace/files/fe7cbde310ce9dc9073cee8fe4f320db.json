{"author": "pallets", "code": "\n\n        return self.wsgi_app(environ, start_response)\n\n    def __repr__(self):\n        return '<%s %r>' % (\n            self.__class__.__name__,\n            self.name,\n        )\n", "comments": "\n    flask.app\n    ~~~~~~~~~\n\n    This module implements the central WSGI application object.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport sys\nimport warnings\nfrom datetime import timedelta\nfrom functools import update_wrapper\nfrom itertools import chain\nfrom threading import Lock\n\nfrom werkzeug.datastructures import Headers, ImmutableDict\nfrom werkzeug.exceptions import BadRequest, BadRequestKeyError, HTTPException, \\\n    InternalServerError, MethodNotAllowed, default_exceptions\nfrom werkzeug.routing import BuildError, Map, RequestRedirect, Rule\n\nfrom . import cli, json\nfrom ._compat import integer_types, reraise, string_types, text_type\nfrom .config import Config, ConfigAttribute\nfrom .ctx import AppContext, RequestContext, _AppCtxGlobals\nfrom .globals import _request_ctx_stack, g, request, session\nfrom .helpers import _PackageBoundObject, \\\n    _endpoint_from_view_func, find_package, get_env, get_debug_flag, \\\n    get_flashed_messages, locked_cached_property, url_for\nfrom .logging import create_logger\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down, got_request_exception, \\\n    request_finished, request_started, request_tearing_down\nfrom .templating import DispatchingJinjaLoader, Environment, \\\n    _default_template_ctx_processor\nfrom .wrappers import Request, Response\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\n\n\ndef setupmethod(f):\n    \"\"\"Wraps a method so that it performs a check in debug mode if the\n    first request was already handled.\n    \"\"\"\n    def wrapper_func(self, *args, **kwargs):\n        if self.debug and self._got_first_request:\n            raise AssertionError('A setup function was called after the '\n                'first request was handled.  This usually indicates a bug '\n                'in the application where a module was not imported '\n                'and decorators or other functionality was called too late.\\n'\n                'To fix this make sure to import all your view modules, '\n                'database models and everything related at a central place '\n                'before the application starts serving requests.')\n        return f(self, *args, **kwargs)\n    return update_wrapper(wrapper_func, f)\n\n\nclass Flask(_PackageBoundObject):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a different path for the\n                            static files on the web.  Defaults to the name\n                            of the `static_folder` folder.\n    :param static_folder: the folder with static files that should be served\n                          at `static_url_path`.  Defaults to the ``'static'``\n                          folder in the root path of the application.\n    :param static_host: the host to use when adding the static route.\n        Defaults to None. Required when using ``host_matching=True``\n        with a ``static_folder`` configured.\n    :param host_matching: set ``url_map.host_matching`` attribute.\n        Defaults to False.\n    :param subdomain_matching: consider the subdomain relative to\n        :data:`SERVER_NAME` when matching routes. Defaults to False.\n    :param template_folder: the folder that contains the templates that should\n                            be used by the application.  Defaults to\n                            ``'templates'`` folder in the root path of the\n                            application.\n    :param instance_path: An alternative instance path for the application.\n                          By default the folder ``'instance'`` next to the\n                          package or module is assumed to be the instance\n                          path.\n    :param instance_relative_config: if set to ``True`` relative filenames\n                                     for loading the config are assumed to\n                                     be relative to the instance path instead\n                                     of the application root.\n    :param root_path: Flask by default will automatically calculate the path\n                      to the root of the application.  In certain situations\n                      this cannot be achieved (for instance if the package\n                      is a Python 3 namespace package) and needs to be\n                      manually defined.\n    \"\"\"\n\n    #: The class that is used for request objects.  See :class:`~flask.Request`\n    #: for more information.\n    request_class = Request\n\n    #: The class that is used for response objects.  See\n    #: :class:`~flask.Response` for more information.\n    response_class = Response\n\n    #: The class that is used for the Jinja environment.\n    #:\n    #: .. versionadded:: 0.11\n    jinja_environment = Environment\n\n    #: The class that is used for the :data:`~flask.g` instance.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Store arbitrary attributes on flask.g.\n    #: 2. Add a property for lazy per-request database connectors.\n    #: 3. Return None instead of AttributeError on unexpected attributes.\n    #: 4. Raise exception if an unexpected attr is set, a \"controlled\" flask.g.\n    #:\n    #: In Flask 0.9 this property was called `request_globals_class` but it\n    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the\n    #: flask.g object is now application context scoped.\n    #:\n    #: .. versionadded:: 0.10\n    app_ctx_globals_class = _AppCtxGlobals\n\n    #: The class that is used for the ``config`` attribute of this app.\n    #: Defaults to :class:`~flask.Config`.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Default values for certain config options.\n    #: 2. Access to config values through attributes in addition to keys.\n    #:\n    #: .. versionadded:: 0.11\n    config_class = Config\n\n    #: The testing flag.  Set this to ``True`` to enable the test mode of\n    #: Flask extensions (and in the future probably also Flask itself).\n    #: For example this might activate test helpers that have an\n    #: additional runtime cost which should not be enabled by default.\n    #:\n    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the\n    #: default it's implicitly enabled.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``TESTING`` configuration key.  Defaults to ``False``.\n    testing = ConfigAttribute('TESTING')\n\n    #: If a secret key is set, cryptographic components can use this to\n    #: sign cookies and other things. Set this to a complex random value\n    #: when you want to use the secure cookie for instance.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.\n    secret_key = ConfigAttribute('SECRET_KEY')\n\n    #: The secure cookie uses this for the name of the session cookie.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``SESSION_COOKIE_NAME`` configuration key.  Defaults to ``'session'``\n    session_cookie_name = ConfigAttribute('SESSION_COOKIE_NAME')\n\n    #: A :class:`~datetime.timedelta` which is used to set the expiration\n    #: date of a permanent session.  The default is 31 days which makes a\n    #: permanent session survive for roughly one month.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to\n    #: ``timedelta(days=31)``\n    permanent_session_lifetime = ConfigAttribute('PERMANENT_SESSION_LIFETIME',\n        get_converter=_make_timedelta)\n\n    #: A :class:`~datetime.timedelta` which is used as default cache_timeout\n    #: for the :func:`send_file` functions. The default is 12 hours.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``SEND_FILE_MAX_AGE_DEFAULT`` configuration key. This configuration\n    #: variable can also be set with an integer value used as seconds.\n    #: Defaults to ``timedelta(hours=12)``\n    send_file_max_age_default = ConfigAttribute('SEND_FILE_MAX_AGE_DEFAULT',\n        get_converter=_make_timedelta)\n\n    #: Enable this if you want to use the X-Sendfile feature.  Keep in\n    #: mind that the server has to support this.  This only affects files\n    #: sent with the :func:`send_file` method.\n    #:\n    #: .. versionadded:: 0.2\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``USE_X_SENDFILE`` configuration key.  Defaults to ``False``.\n    use_x_sendfile = ConfigAttribute('USE_X_SENDFILE')\n\n    #: The JSON encoder class to use.  Defaults to :class:`~flask.json.JSONEncoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_encoder = json.JSONEncoder\n\n    #: The JSON decoder class to use.  Defaults to :class:`~flask.json.JSONDecoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_decoder = json.JSONDecoder\n\n    #: Options that are passed directly to the Jinja2 environment.\n    jinja_options = ImmutableDict(\n        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']\n    )\n\n    #: Default configuration parameters.\n    default_config = ImmutableDict({\n        'ENV':                                  None,\n        'DEBUG':                                None,\n        'TESTING':                              False,\n        'PROPAGATE_EXCEPTIONS':                 None,\n        'PRESERVE_CONTEXT_ON_EXCEPTION':        None,\n        'SECRET_KEY':                           None,\n        'PERMANENT_SESSION_LIFETIME':           timedelta(days=31),\n        'USE_X_SENDFILE':                       False,\n        'SERVER_NAME':                          None,\n        'APPLICATION_ROOT':                     '/',\n        'SESSION_COOKIE_NAME':                  'session',\n        'SESSION_COOKIE_DOMAIN':                None,\n        'SESSION_COOKIE_PATH':                  None,\n        'SESSION_COOKIE_HTTPONLY':              True,\n        'SESSION_COOKIE_SECURE':                False,\n        'SESSION_COOKIE_SAMESITE':              None,\n        'SESSION_REFRESH_EACH_REQUEST':         True,\n        'MAX_CONTENT_LENGTH':                   None,\n        'SEND_FILE_MAX_AGE_DEFAULT':            timedelta(hours=12),\n        'TRAP_BAD_REQUEST_ERRORS':              None,\n        'TRAP_HTTP_EXCEPTIONS':                 False,\n        'EXPLAIN_TEMPLATE_LOADING':             False,\n        'PREFERRED_URL_SCHEME':                 'http',\n        'JSON_AS_ASCII':                        True,\n        'JSON_SORT_KEYS':                       True,\n        'JSONIFY_PRETTYPRINT_REGULAR':          False,\n        'JSONIFY_MIMETYPE':                     'application/json',\n        'TEMPLATES_AUTO_RELOAD':                None,\n    })\n\n    #: The rule object to use for URL rules created.  This is used by\n    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.\n    #:\n    #: .. versionadded:: 0.7\n    url_rule_class = Rule\n\n    #: the test client that is used with when `test_client` is used.\n    #:\n    #: .. versionadded:: 0.7\n    test_client_class = None\n\n    #: The :class:`~click.testing.CliRunner` subclass, by default\n    #: :class:`~flask.testing.FlaskCliRunner` that is used by\n    #: :meth:`test_cli_runner`. Its ``__init__`` method should take a\n    #: Flask app object as the first argument.\n    #:\n    #: .. versionadded:: 1.0\n    test_cli_runner_class = None\n\n    #: the session interface to use.  By default an instance of\n    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n    #:\n    #: .. versionadded:: 0.8\n    session_interface = SecureCookieSessionInterface()\n\n    # TODO remove the next three attrs when Sphinx :inherited-members: works\n    # https://github.com/sphinx-doc/sphinx/issues/741\n\n    #: The name of the package or module that this app belongs to. Do not\n    #: change this once it is set by the constructor.\n    import_name = None\n\n    #: Location of the template files to be added to the template lookup.\n    #: ``None`` if templates should not be added.\n    template_folder = None\n\n    #: Absolute path to the package on the filesystem. Used to look up\n    #: resources contained in the package.\n    root_path = None\n\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder='static',\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder='templates',\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None\n    ):\n        _PackageBoundObject.__init__(\n            self,\n            import_name,\n            template_folder=template_folder,\n            root_path=root_path\n        )\n\n        if static_url_path is not None:\n            self.static_url_path = static_url_path\n\n        if static_folder is not None:\n            self.static_folder = static_folder\n\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError(\n                'If an instance path is provided it must be absolute.'\n                ' A relative path was given instead.'\n            )\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        #: A dictionary of all view functions registered.  The keys will\n        #: be function names which are also used to generate URLs and\n        #: the values are the function objects themselves.\n        #: To register a view function, use the :meth:`route` decorator.\n        self.view_functions = {}\n\n        #: A dictionary of all registered error handlers.  The key is ``None``\n        #: for error handlers active on the application, otherwise the key is\n        #: the name of the blueprint.  Each key points to another dictionary\n        #: where the key is the status code of the http exception.  The\n        #: special key ``None`` points to a list of tuples where the first item\n        #: is the class for the instance check and the second the error handler\n        #: function.\n        #:\n        #: To register an error handler, use the :meth:`errorhandler`\n        #: decorator.\n        self.error_handler_spec = {}\n\n        #: A list of functions that are called when :meth:`url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`.  Each function registered here\n        #: is called with `error`, `endpoint` and `values`.  If a function\n        #: returns ``None`` or raises a :exc:`BuildError` the next function is\n        #: tried.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers = []\n\n        #: A dictionary with lists of functions that will be called at the\n        #: beginning of each request. The key of the dictionary is the name of\n        #: the blueprint this function is active for, or ``None`` for all\n        #: requests. To register a function, use the :meth:`before_request`\n        #: decorator.\n        self.before_request_funcs = {}\n\n        #: A list of functions that will be called at the beginning of the\n        #: first request to this instance. To register a function, use the\n        #: :meth:`before_first_request` decorator.\n        #:\n        #: .. versionadded:: 0.8\n        self.before_first_request_funcs = []\n\n        #: A dictionary with lists of functions that should be called after\n        #: each request.  The key of the dictionary is the name of the blueprint\n        #: this function is active for, ``None`` for all requests.  This can for\n        #: example be used to close database connections. To register a function\n        #: here, use the :meth:`after_request` decorator.\n        self.after_request_funcs = {}\n\n        #: A dictionary with lists of functions that are called after\n        #: each request, even if an exception has occurred. The key of the\n        #: dictionary is the name of the blueprint this function is active for,\n        #: ``None`` for all requests. These functions are not allowed to modify\n        #: the request, and their return values are ignored. If an exception\n        #: occurred while processing the request, it gets passed to each\n        #: teardown_request function. To register a function here, use the\n        #: :meth:`teardown_request` decorator.\n        #:\n        #: .. versionadded:: 0.7\n        self.teardown_request_funcs = {}\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs = []\n\n        #: A dictionary with lists of functions that are called before the\n        #: :attr:`before_request_funcs` functions. The key of the dictionary is\n        #: the name of the blueprint this function is active for, or ``None``\n        #: for all requests. To register a function, use\n        #: :meth:`url_value_preprocessor`.\n        #:\n        #: .. versionadded:: 0.7\n        self.url_value_preprocessors = {}\n\n        #: A dictionary with lists of functions that can be used as URL value\n        #: preprocessors.  The key ``None`` here is used for application wide\n        #: callbacks, otherwise the key is the name of the blueprint.\n        #: Each of these functions has the chance to modify the dictionary\n        #: of URL values before they are used as the keyword arguments of the\n        #: view function.  For each function registered this one should also\n        #: provide a :meth:`url_defaults` function that adds the parameters\n        #: automatically again that were removed that way.\n        #:\n        #: .. versionadded:: 0.7\n        self.url_default_functions = {}\n\n        #: A dictionary with list of functions that are called without argument\n        #: to populate the template context.  The key of the dictionary is the\n        #: name of the blueprint this function is active for, ``None`` for all\n        #: requests.  Each returns a dictionary that the template context is\n        #: updated with.  To register a function here, use the\n        #: :meth:`context_processor` decorator.\n        self.template_context_processors = {\n            None: [_default_template_ctx_processor]\n        }\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors = []\n\n        #: all the attached blueprints in a dictionary by name.  Blueprints\n        #: can be attached multiple times so this dictionary does not tell\n        #: you how often they got attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints = {}\n        self._blueprint_order = []\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.  For backwards compatibility extensions should register\n        #: themselves like this::\n        #:\n        #:      if not hasattr(app, 'extensions'):\n        #:          app.extensions = {}\n        #:      app.extensions['extensionname'] = SomeObject()\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = Map()\n\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n\n        # Add a static route using the provided static_url_path, static_host,\n        # and static_folder if there is a configured static_folder.\n        # Note we do this without checking if static_folder exists.\n        # For one, it might be created while the server is running (e.g. during\n        # development). Also, Google App Engine stores static files somewhere\n        if self.has_static_folder:\n            assert bool(static_host) == host_matching, 'Invalid static_host/host_matching combination'\n            self.add_url_rule(\n                self.static_url_path + '/<path:filename>',\n                endpoint='static',\n                host=static_host,\n                view_func=self.send_static_file\n            )\n\n        #: The click command line context for this application.  Commands\n        #: registered here show up in the :command:`flask` command once the\n        #: application has been discovered.  The default commands are\n        #: provided by Flask itself and can be overridden.\n        #:\n        #: This is an instance of a :class:`click.Group` object.\n        self.cli = cli.AppGroup(self.name)\n\n    @locked_cached_property\n    def name(self):\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overridden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.import_name == '__main__':\n            fn = getattr(sys.modules['__main__'], '__file__', None)\n            if fn is None:\n                return '__main__'\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name\n\n    @property\n    def propagate_exceptions(self):\n        \"\"\"Returns the value of the ``PROPAGATE_EXCEPTIONS`` configuration\n        value in case it's set, otherwise a sensible default is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config['PROPAGATE_EXCEPTIONS']\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n\n    @property\n    def preserve_context_on_exception(self):\n        \"\"\"Returns the value of the ``PRESERVE_CONTEXT_ON_EXCEPTION``\n        configuration value in case it's set, otherwise a sensible default\n        is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config['PRESERVE_CONTEXT_ON_EXCEPTION']\n        if rv is not None:\n            return rv\n        return self.debug\n\n    @locked_cached_property\n    def logger(self):\n        \"\"\"The ``'flask.app'`` logger, a standard Python\n        :class:`~logging.Logger`.\n\n        In debug mode, the logger's :attr:`~logging.Logger.level` will be set\n        to :data:`~logging.DEBUG`.\n\n        If there are no handlers configured, a default handler will be added.\n        See :ref:`logging` for more information.\n\n        .. versionchanged:: 1.0\n            Behavior was simplified. The logger is always named\n            ``flask.app``. The level is only set during configuration, it\n            doesn't check ``app.debug`` each time. Only one format is used,\n            not different ones depending on ``app.debug``. No handlers are\n            removed, and a handler is only added if no handlers are already\n            configured.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        return create_logger(self)\n\n    @locked_cached_property\n    def jinja_env(self):\n        \"\"\"The Jinja2 environment used to load templates.\"\"\"\n        return self.create_jinja_environment()\n\n    @property\n    def got_first_request(self):\n        \"\"\"This attribute is set to ``True`` if the application started\n        handling the first request.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        return self._got_first_request\n\n    def make_config(self, instance_relative=False):\n        \"\"\"Used to create the config attribute by the Flask constructor.\n        The `instance_relative` parameter is passed in from the constructor\n        of Flask (there named `instance_relative_config`) and indicates if\n        the config should be relative to the instance path or the root path\n        of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults['ENV'] = get_env()\n        defaults['DEBUG'] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n\n    def auto_find_instance_path(self):\n        \"\"\"Tries to locate the instance path if it was not provided to the\n        constructor of the application class.  It will basically calculate\n        the path to a folder named ``instance`` next to your main file or\n        the package.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            return os.path.join(package_path, 'instance')\n        return os.path.join(prefix, 'var', self.name + '-instance')\n\n    def open_instance_resource(self, resource, mode='rb'):\n        \"\"\"Opens a resource from the application's instance folder\n        (:attr:`instance_path`).  Otherwise works like\n        :meth:`open_resource`.  Instance resources can also be opened for\n        writing.\n\n        :param resource: the name of the resource.  To access resources within\n                         subfolders use forward slashes as separator.\n        :param mode: resource file opening mode, default is 'rb'.\n        \"\"\"\n        return open(os.path.join(self.instance_path, resource), mode)\n\n    def _get_templates_auto_reload(self):\n        \"\"\"Reload templates when they are changed. Used by\n        :meth:`create_jinja_environment`.\n\n        This attribute can be configured with :data:`TEMPLATES_AUTO_RELOAD`. If\n        not set, it will be enabled in debug mode.\n\n        .. versionadded:: 1.0\n            This property was added but the underlying config and behavior\n            already existed.\n        \"\"\"\n        rv = self.config['TEMPLATES_AUTO_RELOAD']\n        return rv if rv is not None else self.debug\n\n    def _set_templates_auto_reload(self, value):\n        self.config['TEMPLATES_AUTO_RELOAD'] = value\n\n    templates_auto_reload = property(\n        _get_templates_auto_reload, _set_templates_auto_reload\n    )\n    del _get_templates_auto_reload, _set_templates_auto_reload\n\n    def create_jinja_environment(self):\n        \"\"\"Creates the Jinja2 environment based on :attr:`jinja_options`\n        and :meth:`select_jinja_autoescape`.  Since 0.7 this also adds\n        the Jinja2 globals and filters after initialization.  Override\n        this function to customize the behavior.\n\n        .. versionadded:: 0.5\n        .. versionchanged:: 0.11\n           ``Environment.auto_reload`` set in accordance with\n           ``TEMPLATES_AUTO_RELOAD`` configuration option.\n        \"\"\"\n        options = dict(self.jinja_options)\n\n        if 'autoescape' not in options:\n            options['autoescape'] = self.select_jinja_autoescape\n\n        if 'auto_reload' not in options:\n            options['auto_reload'] = self.templates_auto_reload\n\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            # request, session and g are normally added with the\n            # context processor for efficiency reasons but for imported\n            # templates we also want the proxies in there.\n            request=request,\n            session=session,\n            g=g\n        )\n        rv.filters['tojson'] = json.tojson_filter\n        return rv\n\n    def create_global_jinja_loader(self):\n        \"\"\"Creates the loader for the Jinja2 environment.  Can be used to\n        override just the loader and keeping the rest unchanged.  It's\n        discouraged to override this function.  Instead one should override\n        the :meth:`jinja_loader` function instead.\n\n        The global loader dispatches between the loaders of the application\n        and the individual blueprints.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return DispatchingJinjaLoader(self)\n\n    def select_jinja_autoescape(self, filename):\n        \"\"\"Returns ``True`` if autoescaping should be active for the given\n        template name. If no template name is given, returns `True`.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if filename is None:\n            return True\n        return filename.endswith(('.html', '.htm', '.xml', '.xhtml'))\n\n    def update_template_context(self, context):\n        \"\"\"Update the template context with some commonly used variables.\n        This injects request, session, config and g into the template\n        context as well as everything template context processors want\n        to inject.  Note that the as of Flask 0.6, the original values\n        in the context will not be overridden if a context processor\n        decides to return a value with the same key.\n\n        :param context: the context as a dictionary that is updated in place\n                        to add extra variables.\n        \"\"\"\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        # make sure the original values win.  This makes it possible to\n        # easier add new variables in context processors without breaking\n        # existing views.\n        context.update(orig_ctx)\n\n    def make_shell_context(self):\n        \"\"\"Returns the shell context for an interactive shell for this\n        application.  This runs all the registered shell context\n        processors.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        rv = {'app': self, 'g': g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n\n    #: What environment the app is running in. Flask and extensions may\n    #: enable behaviors based on the environment, such as enabling debug\n    #: mode. This maps to the :data:`ENV` config key. This is set by the\n    #: :envvar:`FLASK_ENV` environment variable and may not behave as\n    #: expected if set in code.\n    #:\n    #: **Do not enable development when deploying in production.**\n    #:\n    #: Default: ``'production'``\n    env = ConfigAttribute('ENV')\n\n    def _get_debug(self):\n        return self.config['DEBUG']\n\n    def _set_debug(self, value):\n        self.config['DEBUG'] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n\n    #: Whether debug mode is enabled. When using ``flask run`` to start\n    #: the development server, an interactive debugger will be shown for\n    #: unhandled exceptions, and the server will be reloaded when code\n    #: changes. This maps to the :data:`DEBUG` config key. This is\n    #: enabled when :attr:`env` is ``'development'`` and is overridden\n    #: by the ``FLASK_DEBUG`` environment variable. It may not behave as\n    #: expected if set in code.\n    #:\n    #: **Do not enable debug mode when deploying in production.**\n    #:\n    #: Default: ``True`` if :attr:`env` is ``'development'``, or\n    #: ``False`` otherwise.\n    debug = property(_get_debug, _set_debug)\n    del _get_debug, _set_debug\n\n    def run(self, host=None, port=None, debug=None,\n            load_dotenv=True, **options):\n        \"\"\"Runs the application on a local development server.\n\n        Do not use ``run()`` in a production setting. It is not intended to\n        meet security and performance requirements for a production server.\n        Instead, see :ref:`deployment` for WSGI server recommendations.\n\n        If the :attr:`debug` flag is set the server will automatically reload\n        for code changes and show a debugger in case an exception happened.\n\n        If you want to run the application in debug mode, but disable the\n        code execution on the interactive debugger, you can pass\n        ``use_evalex=False`` as parameter.  This will keep the debugger's\n        traceback screen active, but disable code execution.\n\n        It is not recommended to use this function for development with\n        automatic reloading as this is badly supported.  Instead you should\n        be using the :command:`flask` command line script's ``run`` support.\n\n        .. admonition:: Keep in Mind\n\n           Flask will suppress any server error with a generic error page\n           unless it is in debug mode.  As such to enable just the\n           interactive debugger without the code reloading, you have to\n           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n           Setting ``use_debugger`` to ``True`` without being in debug mode\n           won't catch any exceptions because there won't be any to\n           catch.\n\n        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n            have the server available externally as well. Defaults to\n            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable\n            if present.\n        :param port: the port of the webserver. Defaults to ``5000`` or the\n            port defined in the ``SERVER_NAME`` config variable if present.\n        :param debug: if given, enable or disable debug mode. See\n            :attr:`debug`.\n        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n            files to set environment variables. Will also change the working\n            directory to the directory containing the first file found.\n        :param options: the options to be forwarded to the underlying Werkzeug\n            server. See :func:`werkzeug.serving.run_simple` for more\n            information.\n\n        .. versionchanged:: 1.0\n            If installed, python-dotenv will be used to load environment\n            variables from :file:`.env` and :file:`.flaskenv` files.\n\n            If set, the :envvar:`FLASK_ENV` and :envvar:`FLASK_DEBUG`\n            environment variables will override :attr:`env` and\n            :attr:`debug`.\n\n            Threaded mode is enabled by default.\n\n        .. versionchanged:: 0.10\n            The default port is now picked from the ``SERVER_NAME``\n            variable.\n        \"\"\"\n        # Change this into a no-op if the server is invoked from the\n        # command line. Have a look at cli.py for more information.\n        if os.environ.get('FLASK_RUN_FROM_CLI') == 'true':\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n\n        if load_dotenv:\n            cli.load_dotenv()\n\n            # if set, let env vars override previous values\n            if 'FLASK_ENV' in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif 'FLASK_DEBUG' in os.environ:\n                self.debug = get_debug_flag()\n\n        # debug passed to method overrides all other sources\n        if debug is not None:\n            self.debug = bool(debug)\n\n        _host = '127.0.0.1'\n        _port = 5000\n        server_name = self.config.get('SERVER_NAME')\n        sn_host, sn_port = None, None\n\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(':')\n\n        host = host or sn_host or _host\n        port = int(port or sn_port or _port)\n\n        options.setdefault('use_reloader', self.debug)\n        options.setdefault('use_debugger', self.debug)\n        options.setdefault('threaded', True)\n\n        cli.show_server_banner(self.env, self.debug, self.name)\n\n        from werkzeug.serving import run_simple\n\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            # reset the first request information if the development server\n            # reset normally.  This makes it possible to restart the server\n            # without reloader and that stuff from an interactive shell.\n            self._got_first_request = False\n\n    def test_client(self, use_cookies=True, **kwargs):\n        \"\"\"Creates a test client for this application.  For information\n        about unit testing head over to :ref:`testing`.\n\n        Note that if you are testing for assertions or exceptions in your\n        application code, you must set ``app.testing = True`` in order for the\n        exceptions to propagate to the test client.  Otherwise, the exception\n        will be handled by the application (not visible to the test client) and\n        the only indication of an AssertionError or other exception will be a\n        500 status code response to the test client.  See the :attr:`testing`\n        attribute.  For example::\n\n            app.testing = True\n            client = app.test_client()\n\n        The test client can be used in a ``with`` block to defer the closing down\n        of the context until the end of the ``with`` block.  This is useful if\n        you want to access the context locals for testing::\n\n            with app.test_client() as c:\n                rv = c.get('/?vodka=42')\n                assert request.args['vodka'] == '42'\n\n        Additionally, you may pass optional keyword arguments that will then\n        be passed to the application's :attr:`test_client_class` constructor.\n        For example::\n\n            from flask.testing import FlaskClient\n\n            class CustomClient(FlaskClient):\n                def __init__(self, *args, **kwargs):\n                    self._authentication = kwargs.pop(\"authentication\")\n                    super(CustomClient,self).__init__( *args, **kwargs)\n\n            app.test_client_class = CustomClient\n            client = app.test_client(authentication='Basic ....')\n\n        See :class:`~flask.testing.FlaskClient` for more information.\n\n        .. versionchanged:: 0.4\n           added support for ``with`` block usage for the client.\n\n        .. versionadded:: 0.7\n           The `use_cookies` parameter was added as well as the ability\n           to override the client to be used by setting the\n           :attr:`test_client_class` attribute.\n\n        .. versionchanged:: 0.11\n           Added `**kwargs` to support passing additional keyword arguments to\n           the constructor of :attr:`test_client_class`.\n        \"\"\"\n        cls = self.test_client_class\n        if cls is None:\n            from flask.testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n\n    def test_cli_runner(self, **kwargs):\n        \"\"\"Create a CLI runner for testing CLI commands.\n        See :ref:`testing-cli`.\n\n        Returns an instance of :attr:`test_cli_runner_class`, by default\n        :class:`~flask.testing.FlaskCliRunner`. The Flask app object is\n        passed as the first argument.\n\n        .. versionadded:: 1.0\n        \"\"\"\n        cls = self.test_cli_runner_class\n\n        if cls is None:\n            from flask.testing import FlaskCliRunner as cls\n\n        return cls(self, **kwargs)\n\n    def open_session(self, request):\n        \"\"\"Creates or opens a new session.  Default implementation stores all\n        session data in a signed cookie.  This requires that the\n        :attr:`secret_key` is set.  Instead of overriding this method\n        we recommend replacing the :class:`session_interface`.\n\n        .. deprecated: 1.0\n            Will be removed in 1.1. Use ``session_interface.open_session``\n            instead.\n\n        :param request: an instance of :attr:`request_class`.\n        \"\"\"\n\n        warnings.warn(DeprecationWarning(\n            '\"open_session\" is deprecated and will be removed in 1.1. Use'\n            ' \"session_interface.open_session\" instead.'\n        ))\n        return self.session_interface.open_session(self, request)\n\n    def save_session(self, session, response):\n        \"\"\"Saves the session if it needs updates.  For the default\n        implementation, check :meth:`open_session`.  Instead of overriding this\n        method we recommend replacing the :class:`session_interface`.\n\n        .. deprecated: 1.0\n            Will be removed in 1.1. Use ``session_interface.save_session``\n            instead.\n\n        :param session: the session to be saved (a\n                        :class:`~werkzeug.contrib.securecookie.SecureCookie`\n                        object)\n        :param response: an instance of :attr:`response_class`\n        \"\"\"\n\n        warnings.warn(DeprecationWarning(\n            '\"save_session\" is deprecated and will be removed in 1.1. Use'\n            ' \"session_interface.save_session\" instead.'\n        ))\n        return self.session_interface.save_session(self, session, response)\n\n    def make_null_session(self):\n        \"\"\"Creates a new instance of a missing session.  Instead of overriding\n        this method we recommend replacing the :class:`session_interface`.\n\n        .. deprecated: 1.0\n            Will be removed in 1.1. Use ``session_interface.make_null_session``\n            instead.\n\n        .. versionadded:: 0.7\n        \"\"\"\n\n        warnings.warn(DeprecationWarning(\n            '\"make_null_session\" is deprecated and will be removed in 1.1. Use'\n            ' \"session_interface.make_null_session\" instead.'\n        ))\n        return self.session_interface.make_null_session(self)\n\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        \"\"\"Register a :class:`~flask.Blueprint` on the application. Keyword\n        arguments passed to this method will override the defaults set on the\n        blueprint.\n\n        Calls the blueprint's :meth:`~flask.Blueprint.register` method after\n        recording the blueprint in the application's :attr:`blueprints`.\n\n        :param blueprint: The blueprint to register.\n        :param url_prefix: Blueprint routes will be prefixed with this.\n        :param subdomain: Blueprint routes will match on this subdomain.\n        :param url_defaults: Blueprint routes will use these default values for\n            view arguments.\n        :param options: Additional keyword arguments are passed to\n            :class:`~flask.blueprints.BlueprintSetupState`. They can be\n            accessed in :meth:`~flask.Blueprint.record` callbacks.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        first_registration = False\n\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                'A name collision occurred between blueprints %r and %r. Both'\n                ' share the same name \"%s\". Blueprints that are created on the'\n                ' fly need unique names.' % (\n                    blueprint, self.blueprints[blueprint.name], blueprint.name\n                )\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n\n        blueprint.register(self, options, first_registration)\n\n    def iter_blueprints(self):\n        \"\"\"Iterates over all blueprints by the order they were registered.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        return iter(self._blueprint_order)\n\n    @setupmethod\n    def add_url_rule(self, rule, endpoint=None, view_func=None,\n                     provide_automatic_options=None, **options):\n        \"\"\"Connects a URL rule.  Works exactly like the :meth:`route`\n        decorator.  If a view_func is provided it will be registered with the\n        endpoint.\n\n        Basically this example::\n\n            @app.route('/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('/', 'index', index)\n\n        If the view_func is not provided you will need to connect the endpoint\n        to a view function like so::\n\n            app.view_functions['index'] = index\n\n        Internally :meth:`route` invokes :meth:`add_url_rule` so if you want\n        to customize the behavior via subclassing you only need to change\n        this method.\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        .. versionchanged:: 0.2\n           `view_func` parameter added.\n\n        .. versionchanged:: 0.6\n           ``OPTIONS`` is added automatically as method.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param view_func: the function to call when serving a request to the\n                          provided endpoint\n        :param provide_automatic_options: controls whether the ``OPTIONS``\n            method should be added automatically. This can also be controlled\n            by setting the ``view_func.provide_automatic_options = False``\n            before adding the rule.\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (``GET``, ``POST`` etc.).  By default a rule\n                        just listens for ``GET`` (and implicitly ``HEAD``).\n                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options['endpoint'] = endpoint\n        methods = options.pop('methods', None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only ``GET`` as default.\n        if methods is None:\n            methods = getattr(view_func, 'methods', None) or ('GET',)\n        if isinstance(methods, string_types):\n            raise TypeError('Allowed methods have to be iterables of strings, '\n                            'for example: @app.route(..., methods=[\"POST\"])')\n        methods = set(item.upper() for item in methods)\n\n        # Methods that should always be added\n        required_methods = set(getattr(view_func, 'required_methods', ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(view_func,\n                'provide_automatic_options', None)\n\n        if provide_automatic_options is None:\n            if 'OPTIONS' not in methods:\n                provide_automatic_options = True\n                required_methods.add('OPTIONS')\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError('View function mapping is overwriting an '\n                                     'existing endpoint function: %s' % endpoint)\n            self.view_functions[endpoint] = view_func\n\n    def route(self, rule, **options):\n        \"\"\"A decorator that is used to register a view function for a\n        given URL rule.  This does the same thing as :meth:`add_url_rule`\n        but is intended for decorator usage::\n\n            @app.route('/')\n            def index():\n                return 'Hello World'\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (``GET``, ``POST`` etc.).  By default a rule\n                        just listens for ``GET`` (and implicitly ``HEAD``).\n                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        def decorator(f):\n            endpoint = options.pop('endpoint', None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n        return decorator\n\n    @setupmethod\n    def endpoint(self, endpoint):\n        \"\"\"A decorator to register a function as an endpoint.\n        Example::\n\n            @app.endpoint('example.endpoint')\n            def example():\n                return \"example\"\n\n        :param endpoint: the name of the endpoint\n        \"\"\"\n        def decorator(f):\n            self.view_functions[endpoint] = f\n            return f\n        return decorator\n\n    @staticmethod\n    def _get_exc_class_and_code(exc_class_or_code):\n        \"\"\"Ensure that we register only exceptions as handler keys\"\"\"\n        if isinstance(exc_class_or_code, integer_types):\n            exc_class = default_exceptions[exc_class_or_code]\n        else:\n            exc_class = exc_class_or_code\n\n        assert issubclass(exc_class, Exception)\n\n        if issubclass(exc_class, HTTPException):\n            return exc_class, exc_class.code\n        else:\n            return exc_class, None\n\n    @setupmethod\n    def errorhandler(self, code_or_exception):\n        \"\"\"Register a function to handle errors by code or exception class.\n\n        A decorator that is used to register a function given an\n        error code.  Example::\n\n            @app.errorhandler(404)\n            def page_not_found(error):\n                return 'This page does not exist', 404\n\n        You can also register handlers for arbitrary exceptions::\n\n            @app.errorhandler(DatabaseError)\n            def special_exception_handler(error):\n                return 'Database connection failed', 500\n\n        .. versionadded:: 0.7\n            Use :meth:`register_error_handler` instead of modifying\n            :attr:`error_handler_spec` directly, for application wide error\n            handlers.\n\n        .. versionadded:: 0.7\n           One can now additionally also register custom exception types\n           that do not necessarily have to be a subclass of the\n           :class:`~werkzeug.exceptions.HTTPException` class.\n\n        :param code_or_exception: the code as integer for the handler, or\n                                  an arbitrary exception\n        \"\"\"\n        def decorator(f):\n            self._register_error_handler(None, code_or_exception, f)\n            return f\n        return decorator\n\n    @setupmethod\n    def register_error_handler(self, code_or_exception, f):\n        \"\"\"Alternative error attach function to the :meth:`errorhandler`\n        decorator that is more straightforward to use for non decorator\n        usage.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self._register_error_handler(None, code_or_exception, f)\n\n    @setupmethod\n    def _register_error_handler(self, key, code_or_exception, f):\n        \"\"\"\n        :type key: None|str\n        :type code_or_exception: int|T<=Exception\n        :type f: callable\n        \"\"\"\n        if isinstance(code_or_exception, HTTPException):  # old broken behavior\n            raise ValueError(\n                'Tried to register a handler for an exception instance {0!r}.'\n                ' Handlers can only be registered for exception classes or'\n                ' HTTP error codes.'.format(code_or_exception)\n            )\n\n        try:\n            exc_class, code = self._get_exc_class_and_code(code_or_exception)\n        except KeyError:\n            raise KeyError(\n                \"'{0}' is not a recognized HTTP error code. Use a subclass of\"\n                \" HTTPException with that code instead.\".format(code_or_exception)\n            )\n\n        handlers = self.error_handler_spec.setdefault(key, {}).setdefault(code, {})\n        handlers[exc_class] = f\n\n    @setupmethod\n    def template_filter(self, name=None):\n        \"\"\"A decorator that is used to register custom template filter.\n        You can specify a name for the filter, otherwise the function\n        name will be used. Example::\n\n          @app.template_filter()\n          def reverse(s):\n              return s[::-1]\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        \"\"\"Register a custom template filter.  Works exactly like the\n        :meth:`template_filter` decorator.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.filters[name or f.__name__] = f\n\n    @setupmethod\n    def template_test(self, name=None):\n        \"\"\"A decorator that is used to register custom template test.\n        You can specify a name for the test, otherwise the function\n        name will be used. Example::\n\n          @app.template_test()\n          def is_prime(n):\n              if n == 2:\n                  return True\n              for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n                  if n % i == 0:\n                      return False\n              return True\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        \"\"\"Register a custom template test.  Works exactly like the\n        :meth:`template_test` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.tests[name or f.__name__] = f\n\n    @setupmethod\n    def template_global(self, name=None):\n        \"\"\"A decorator that is used to register a custom template global function.\n        You can specify a name for the global function, otherwise the function\n        name will be used. Example::\n\n            @app.template_global()\n            def double(n):\n                return 2 * n\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        \"\"\"Register a custom template global function. Works exactly like the\n        :meth:`template_global` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.globals[name or f.__name__] = f\n\n    @setupmethod\n    def before_request(self, f):\n        \"\"\"Registers a function to run before each request.\n\n        For example, this can be used to open a database connection, or to load\n        the logged in user from the session.\n\n        The function will be called without any arguments. If it returns a\n        non-None value, the value is handled as if it was the return value from\n        the view, and further request handling is stopped.\n        \"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def before_first_request(self, f):\n        \"\"\"Registers a function to be run before the first request to this\n        instance of the application.\n\n        The function will be called without any arguments and its return\n        value is ignored.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.before_first_request_funcs.append(f)\n        return f\n\n    @setupmethod\n    def after_request(self, f):\n        \"\"\"Register a function to be run after each request.\n\n        Your function must take one parameter, an instance of\n        :attr:`response_class` and return a new response object or the\n        same (see :meth:`process_response`).\n\n        As of Flask 0.7 this function might not be executed at the end of the\n        request in case an unhandled exception occurred.\n        \"\"\"\n        self.after_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_request(self, f):\n        \"\"\"Register a function to be run at the end of each request,\n        regardless of whether there was an exception or not.  These functions\n        are executed when the request context is popped, even if not an\n        actual request was performed.\n\n        Example::\n\n            ctx = app.test_request_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the request context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Generally teardown functions must take every necessary step to avoid\n        that they will fail.  If they do execute code that might fail they\n        will have to surround the execution of these code by try/except\n        statements and log occurring errors.\n\n        When a teardown function was called because of an exception it will\n        be passed an error object.\n\n        The return values of teardown functions are ignored.\n\n        .. admonition:: Debug Note\n\n           In debug mode Flask will not tear down a request on an exception\n           immediately.  Instead it will keep it alive so that the interactive\n           debugger can still access it.  This behavior can be controlled\n           by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.\n        \"\"\"\n        self.teardown_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_appcontext(self, f):\n        \"\"\"Registers a function to be called when the application context\n        ends.  These functions are typically also called when the request\n        context is popped.\n\n        Example::\n\n            ctx = app.app_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the app context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Since a request context typically also manages an application\n        context it would also be called when you pop a request context.\n\n        When a teardown function was called because of an unhandled exception\n        it will be passed an error object. If an :meth:`errorhandler` is\n        registered, it will handle the exception and the teardown will not\n        receive it.\n\n        The return values of teardown functions are ignored.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        self.teardown_appcontext_funcs.append(f)\n        return f\n\n    @setupmethod\n    def context_processor(self, f):\n        \"\"\"Registers a template context processor function.\"\"\"\n        self.template_context_processors[None].append(f)\n        return f\n\n    @setupmethod\n    def shell_context_processor(self, f):\n        \"\"\"Registers a shell context processor function.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        self.shell_context_processors.append(f)\n        return f\n\n    @setupmethod\n    def url_value_preprocessor(self, f):\n        \"\"\"Register a URL value preprocessor function for all view\n        functions in the application. These functions will be called before the\n        :meth:`before_request` functions.\n\n        The function can modify the values captured from the matched url before\n        they are passed to the view. For example, this can be used to pop a\n        common language code value and place it in ``g`` rather than pass it to\n        every view.\n\n        The function is passed the endpoint name and values dict. The return\n        value is ignored.\n        \"\"\"\n        self.url_value_preprocessors.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def url_defaults(self, f):\n        \"\"\"Callback function for URL defaults for all view functions of the\n        application.  It's called with the endpoint and values and should\n        update the values passed in place.\n        \"\"\"\n        self.url_default_functions.setdefault(None, []).append(f)\n        return f\n\n    def _find_error_handler(self, e):\n        \"\"\"Return a registered error handler for an exception in this order:\n        blueprint handler for a specific code, app handler for a specific code,\n        blueprint handler for an exception class, app handler for an exception\n        class, or ``None`` if a suitable handler is not found.\n        \"\"\"\n        exc_class, code = self._get_exc_class_and_code(type(e))\n\n        for name, c in (\n            (request.blueprint, code), (None, code),\n            (request.blueprint, None), (None, None)\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n\n            if not handler_map:\n                continue\n\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n\n                if handler is not None:\n                    return handler\n\n    def handle_http_exception(self, e):\n        \"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        # Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n\n    def trap_http_exception(self, e):\n        \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n        this will return ``False`` for all exceptions except for a bad request\n        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It\n        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.\n\n        This is called for all HTTP exceptions raised by a view function.\n        If it returns ``True`` for any exception the error handler for this\n        exception is not called and it shows up as regular exception in the\n        traceback.  This is helpful for debugging implicitly raised HTTP\n        exceptions.\n\n        .. versionchanged:: 1.0\n            Bad request errors are not trapped by default in debug mode.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.config['TRAP_HTTP_EXCEPTIONS']:\n            return True\n\n        trap_bad_request = self.config['TRAP_BAD_REQUEST_ERRORS']\n\n        # if unset, trap based on debug mode\n        if (trap_bad_request is None and self.debug) or trap_bad_request:\n            return isinstance(e, BadRequest)\n\n        return False\n\n    def handle_user_exception(self, e):\n        \"\"\"This method is called whenever an exception occurs that should be\n        handled.  A special case are\n        :class:`~werkzeug.exception.HTTPException`\\s which are forwarded by\n        this function to the :meth:`handle_http_exception` method.  This\n        function will either return a response value or reraise the\n        exception with the same traceback.\n\n        .. versionchanged:: 1.0\n            Key errors raised from request data like ``form`` show the the bad\n            key in debug mode rather than a generic bad request message.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        assert exc_value is e\n        # ensure not to trash sys.exc_info() at that point in case someone\n        # wants the traceback preserved in handle_http_exception.  Of course\n        # we cannot prevent users from trashing it themselves in a custom\n        # trap_http_exception method so that's their fault then.\n\n        # MultiDict passes the key to the exception, but that's ignored\n        # when generating the response message. Set an informative\n        # description for key errors in debug mode or when trapping errors.\n        if (\n            (self.debug or self.config['TRAP_BAD_REQUEST_ERRORS'])\n            and isinstance(e, BadRequestKeyError)\n            # only set it if it's still the default description\n            and e.description is BadRequestKeyError.description\n        ):\n            e.description = \"KeyError: '{0}'\".format(*e.args)\n\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n\n        handler = self._find_error_handler(e)\n\n        if handler is None:\n            reraise(exc_type, exc_value, tb)\n        return handler(e)\n\n    def handle_exception(self, e):\n        \"\"\"Default exception handling that kicks in when an exception\n        occurs that is not caught.  In debug mode the exception will\n        be re-raised immediately, otherwise it is logged and the handler\n        for a 500 internal server error is used.  If no such handler\n        exists, a default 500 internal server error message is displayed.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n\n        got_request_exception.send(self, exception=e)\n        handler = self._find_error_handler(InternalServerError())\n\n        if self.propagate_exceptions:\n            # if we want to repropagate the exception, we can attempt to\n            # raise it with the whole traceback in case we can do that\n            # (the function was actually called from the except part)\n            # otherwise, we just raise the error again\n            if exc_value is e:\n                reraise(exc_type, exc_value, tb)\n            else:\n                raise e\n\n        self.log_exception((exc_type, exc_value, tb))\n        if handler is None:\n            return InternalServerError()\n        return self.finalize_request(handler(e), from_error_handler=True)\n\n    def log_exception(self, exc_info):\n        \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n        if debugging is disabled and right before the handler is called.\n        The default implementation logs the exception as error on the\n        :attr:`logger`.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.logger.error('Exception on %s [%s]' % (\n            request.path,\n            request.method\n        ), exc_info=exc_info)\n\n    def raise_routing_exception(self, request):\n        \"\"\"Exceptions that are recording during routing are reraised with\n        this method.  During debug we are not reraising redirect requests\n        for non ``GET``, ``HEAD``, or ``OPTIONS`` requests and we're raising\n        a different error instead to help debug situations.\n\n        :internal:\n        \"\"\"\n        if not self.debug \\\n           or not isinstance(request.routing_exception, RequestRedirect) \\\n           or request.method in ('GET', 'HEAD', 'OPTIONS'):\n            raise request.routing_exception\n\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n\n    def dispatch_request(self):\n        \"\"\"Does the request dispatching.  Matches the URL and returns the\n        return value of the view or error handler.  This does not have to\n        be a response object.  In order to convert the return value to a\n        proper response object, call :func:`make_response`.\n\n        .. versionchanged:: 0.7\n           This no longer does the exception handling, this code was\n           moved to the new :meth:`full_dispatch_request`.\n        \"\"\"\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if getattr(rule, 'provide_automatic_options', False) \\\n           and req.method == 'OPTIONS':\n            return self.make_default_options_response()\n        # otherwise dispatch to the handler for that endpoint\n        return self.view_functions[rule.endpoint](**req.view_args)\n\n    def full_dispatch_request(self):\n        \"\"\"Dispatches the request and on top of that performs request\n        pre and postprocessing as well as HTTP exception catching and\n        error handling.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            rv = self.preprocess_request()\n            if rv is None:\n                rv = self.dispatch_request()\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n\n    def finalize_request(self, rv, from_error_handler=False):\n        \"\"\"Given the return value from a view function this finalizes\n        the request by converting it into a response and invoking the\n        postprocessing functions.  This is invoked for both normal\n        request dispatching as well as error handlers.\n\n        Because this means that it might be called as a result of a\n        failure a special safe mode is available which can be enabled\n        with the `from_error_handler` flag.  If enabled, failures in\n        response processing will be logged and otherwise ignored.\n\n        :internal:\n        \"\"\"\n        response = self.make_response(rv)\n        try:\n            response = self.process_response(response)\n            request_finished.send(self, response=response)\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception('Request finalizing failed with an '\n                                  'error while handling an error')\n        return response\n\n    def try_trigger_before_first_request_functions(self):\n        \"\"\"Called before each request and will ensure that it triggers\n        the :attr:`before_first_request_funcs` and only exactly once per\n        application instance (which means process usually).\n\n        :internal:\n        \"\"\"\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            for func in self.before_first_request_funcs:\n                func()\n            self._got_first_request = True\n\n    def make_default_options_response(self):\n        \"\"\"This method is called to create the default ``OPTIONS`` response.\n        This can be changed through subclassing to change the default\n        behavior of ``OPTIONS`` responses.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        adapter = _request_ctx_stack.top.url_adapter\n        if hasattr(adapter, 'allowed_methods'):\n            methods = adapter.allowed_methods()\n        else:\n            # fallback for Werkzeug < 0.7\n            methods = []\n            try:\n                adapter.match(method='--')\n            except MethodNotAllowed as e:\n                methods = e.valid_methods\n            except HTTPException as e:\n                pass\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n\n    def should_ignore_error(self, error):\n        \"\"\"This is called to figure out if an error should be ignored\n        or not as far as the teardown system is concerned.  If this\n        function returns ``True`` then the teardown handlers will not be\n        passed the error.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return False\n\n    def make_response(self, rv):\n        \"\"\"Convert the return value from a view function to an instance of\n        :attr:`response_class`.\n\n        :param rv: the return value from the view function. The view function\n            must return a response. Returning ``None``, or the view ending\n            without returning, is not allowed. The following types are allowed\n            for ``view_rv``:\n\n            ``str`` (``unicode`` in Python 2)\n                A response object is created with the string encoded to UTF-8\n                as the body.\n\n            ``bytes`` (``str`` in Python 2)\n                A response object is created with the bytes as the body.\n\n            ``tuple``\n                Either ``(body, status, headers)``, ``(body, status)``, or\n                ``(body, headers)``, where ``body`` is any of the other types\n                allowed here, ``status`` is a string or an integer, and\n                ``headers`` is a dictionary or a list of ``(key, value)``\n                tuples. If ``body`` is a :attr:`response_class` instance,\n                ``status`` overwrites the exiting value and ``headers`` are\n                extended.\n\n            :attr:`response_class`\n                The object is returned unchanged.\n\n            other :class:`~werkzeug.wrappers.Response` class\n                The object is coerced to :attr:`response_class`.\n\n            :func:`callable`\n                The function is called as a WSGI application. The result is\n                used to create a response object.\n\n        .. versionchanged:: 0.9\n           Previously a tuple was interpreted as the arguments for the\n           response object.\n        \"\"\"\n\n        status = headers = None\n\n        # unpack tuple returns\n        if isinstance(rv, (tuple, list)):\n            len_rv = len(rv)\n\n            # a 3-tuple is unpacked directly\n            if len_rv == 3:\n                rv, status, headers = rv\n            # decide if a 2-tuple has status or headers\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv\n                else:\n                    rv, status = rv\n            # other sized tuples are not allowed\n            else:\n                raise TypeError(\n                    'The view function did not return a valid response tuple.'\n                    ' The tuple must have the form (body, status, headers),'\n                    ' (body, status), or (body, headers).'\n                )\n\n        # the body must not be None\n        if rv is None:\n            raise TypeError(\n                'The view function did not return a valid response. The'\n                ' function either returned None or ended without a return'\n                ' statement.'\n            )\n\n        # make sure the body is an instance of the response class\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (text_type, bytes, bytearray)):\n                # let the response class set the status and headers instead of\n                # waiting to do it manually, so that the class can handle any\n                # special logic\n                rv = self.response_class(rv, status=status, headers=headers)\n                status = headers = None\n            else:\n                # evaluate a WSGI callable, or coerce a different response\n                # class to the correct type\n                try:\n                    rv = self.response_class.force_type(rv, request.environ)\n                except TypeError as e:\n                    new_error = TypeError(\n                        '{e}\\nThe view function did not return a valid'\n                        ' response. The return type must be a string, tuple,'\n                        ' Response instance, or WSGI callable, but it was a'\n                        ' {rv.__class__.__name__}.'.format(e=e, rv=rv)\n                    )\n                    reraise(TypeError, new_error, sys.exc_info()[2])\n\n        # prefer the status if it was provided\n        if status is not None:\n            if isinstance(status, (text_type, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n\n        # extend existing headers with provided headers\n        if headers:\n            rv.headers.extend(headers)\n\n        return rv\n\n    def create_url_adapter(self, request):\n        \"\"\"Creates a URL adapter for the given request. The URL adapter\n        is created at a point where the request context is not yet set\n        up so the request is passed explicitly.\n\n        .. versionadded:: 0.6\n\n        .. versionchanged:: 0.9\n           This can now also be called without a request object when the\n           URL adapter is created for the application context.\n\n        .. versionchanged:: 1.0\n            :data:`SERVER_NAME` no longer implicitly enables subdomain\n            matching. Use :attr:`subdomain_matching` instead.\n        \"\"\"\n        if request is not None:\n            # If subdomain matching is disabled (the default), use the\n            # default subdomain in all cases. This should be the default\n            # in Werkzeug but it currently does not have that feature.\n            subdomain = ((self.url_map.default_subdomain or None)\n                         if not self.subdomain_matching else None)\n            return self.url_map.bind_to_environ(\n                request.environ,\n                server_name=self.config['SERVER_NAME'],\n                subdomain=subdomain)\n        # We need at the very least the server name to be set for this\n        # to work.\n        if self.config['SERVER_NAME'] is not None:\n            return self.url_map.bind(\n                self.config['SERVER_NAME'],\n                script_name=self.config['APPLICATION_ROOT'],\n                url_scheme=self.config['PREFERRED_URL_SCHEME'])\n\n    def inject_url_defaults(self, endpoint, values):\n        \"\"\"Injects the URL defaults for the given endpoint directly into\n        the values dictionary passed.  This is used internally and\n        automatically called on URL building.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        funcs = self.url_default_functions.get(None, ())\n        if '.' in endpoint:\n            bp = endpoint.rsplit('.', 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n\n    def handle_url_build_error(self, error, endpoint, values):\n        \"\"\"Handle :class:`~werkzeug.routing.BuildError` on :meth:`url_for`.\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n                if rv is not None:\n                    return rv\n            except BuildError as e:\n                # make error available outside except block (py3)\n                error = e\n\n        # At this point we want to reraise the exception.  If the error is\n        # still the same one we can reraise it with the original traceback,\n        # otherwise we raise it from here.\n        if error is exc_value:\n            reraise(exc_type, exc_value, tb)\n        raise error\n\n    def preprocess_request(self):\n        \"\"\"Called before the request is dispatched. Calls\n        :attr:`url_value_preprocessors` registered with the app and the\n        current blueprint (if any). Then calls :attr:`before_request_funcs`\n        registered with the app and the blueprint.\n\n        If any :meth:`before_request` handler returns a non-None value, the\n        value is handled as if it was the return value from the view, and\n        further request handling is stopped.\n        \"\"\"\n\n        bp = _request_ctx_stack.top.request.blueprint\n\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n\n    def process_response(self, response):\n        \"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n        return response\n\n    def do_teardown_request(self, exc=_sentinel):\n        \"\"\"Called after the actual request dispatching and will\n        call every as :meth:`teardown_request` decorated function.  This is\n        not actually called by the :class:`Flask` object itself but is always\n        triggered when the request context is popped.  That way we have a\n        tighter control over certain resources under testing environments.\n\n        .. versionchanged:: 0.9\n           Added the `exc` argument.  Previously this was always using the\n           current exception information.\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            func(exc)\n        request_tearing_down.send(self, exc=exc)\n\n    def do_teardown_appcontext(self, exc=_sentinel):\n        \"\"\"Called when an application context is popped.  This works pretty\n        much the same as :meth:`do_teardown_request` but for the application\n        context.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n\n    def app_context(self):\n        \"\"\"Binds the application only.  For as long as the application is bound\n        to the current context the :data:`flask.current_app` points to that\n        application.  An application context is automatically created when a\n        request context is pushed if necessary.\n\n        Example usage::\n\n            with app.app_context():\n                ...\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ):\n        \"\"\"Creates a :class:`~flask.ctx.RequestContext` from the given\n        environment and binds it to the current context.  This must be used in\n        combination with the ``with`` statement because the request is only bound\n        to the current context for the duration of the ``with`` block.\n\n        Example usage::\n\n            with app.request_context(environ):\n                do_something_with(request)\n\n        The object returned can also be used without the ``with`` statement\n        which is useful for working in the shell.  The example above is\n        doing exactly the same as this code::\n\n            ctx = app.request_context(environ)\n            ctx.push()\n            try:\n                do_something_with(request)\n            finally:\n                ctx.pop()\n\n        .. versionchanged:: 0.3\n           Added support for non-with statement usage and ``with`` statement\n           is now passed the ctx object.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args, **kwargs):\n        \"\"\"Creates a :class:`~flask.ctx.RequestContext` from the given values\n        (see :class:`werkzeug.test.EnvironBuilder` for more information, this\n        function accepts the same arguments plus two additional).\n\n        Additional arguments (only if ``base_url`` is not specified):\n\n        :param subdomain: subdomain to use for route matching\n        :param url_scheme: scheme for the request, default\n            ``PREFERRED_URL_SCHEME`` or ``http``.\n        \"\"\"\n\n        from flask.testing import make_test_environ_builder\n\n        builder = make_test_environ_builder(self, *args, **kwargs)\n\n        try:\n            return self.request_context(builder.get_environ())\n        finally:\n            builder.close()\n\n    def wsgi_app(self, environ, start_response):\n        \"\"\"The actual WSGI application.  This is not implemented in\n        `__call__` so that middlewares can be applied without losing a\n        reference to the class.  So instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around and\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n           The behavior of the before and after request callbacks was changed\n           under error conditions and a new callback was added that will\n           always execute at the end of the request, independent on if an\n           error occurred or not.  See :ref:`callbacks-and-errors`.\n\n        :param environ: a WSGI environment\n        :param start_response: a callable accepting a status code,\n                               a list of headers and an optional\n                               exception context to start the response\n        \"\"\"\n        ctx = self.request_context(environ)\n        error = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if self.should_ignore_error(error):\n                error = None\n            ctx.auto_pop(error)\n\n    def __call__(self, environ, start_response):\n        \"\"\"Shortcut for :attr:`wsgi_app`.\n.\n# -*- coding: utf-8 -*-\n", "content": "# -*- coding: utf-8 -*-\n\"\"\"\n    flask.app\n    ~~~~~~~~~\n\n    This module implements the central WSGI application object.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport sys\nimport warnings\nfrom datetime import timedelta\nfrom functools import update_wrapper\nfrom itertools import chain\nfrom threading import Lock\n\nfrom werkzeug.datastructures import Headers, ImmutableDict\nfrom werkzeug.exceptions import BadRequest, BadRequestKeyError, HTTPException, \\\n    InternalServerError, MethodNotAllowed, default_exceptions\nfrom werkzeug.routing import BuildError, Map, RequestRedirect, Rule\n\nfrom . import cli, json\nfrom ._compat import integer_types, reraise, string_types, text_type\nfrom .config import Config, ConfigAttribute\nfrom .ctx import AppContext, RequestContext, _AppCtxGlobals\nfrom .globals import _request_ctx_stack, g, request, session\nfrom .helpers import _PackageBoundObject, \\\n    _endpoint_from_view_func, find_package, get_env, get_debug_flag, \\\n    get_flashed_messages, locked_cached_property, url_for\nfrom .logging import create_logger\nfrom .sessions import SecureCookieSessionInterface\nfrom .signals import appcontext_tearing_down, got_request_exception, \\\n    request_finished, request_started, request_tearing_down\nfrom .templating import DispatchingJinjaLoader, Environment, \\\n    _default_template_ctx_processor\nfrom .wrappers import Request, Response\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\ndef _make_timedelta(value):\n    if not isinstance(value, timedelta):\n        return timedelta(seconds=value)\n    return value\n\n\ndef setupmethod(f):\n    \"\"\"Wraps a method so that it performs a check in debug mode if the\n    first request was already handled.\n    \"\"\"\n    def wrapper_func(self, *args, **kwargs):\n        if self.debug and self._got_first_request:\n            raise AssertionError('A setup function was called after the '\n                'first request was handled.  This usually indicates a bug '\n                'in the application where a module was not imported '\n                'and decorators or other functionality was called too late.\\n'\n                'To fix this make sure to import all your view modules, '\n                'database models and everything related at a central place '\n                'before the application starts serving requests.')\n        return f(self, *args, **kwargs)\n    return update_wrapper(wrapper_func, f)\n\n\nclass Flask(_PackageBoundObject):\n    \"\"\"The flask object implements a WSGI application and acts as the central\n    object.  It is passed the name of the module or package of the\n    application.  Once it is created it will act as a central registry for\n    the view functions, the URL rules, template configuration and much more.\n\n    The name of the package is used to resolve resources from inside the\n    package or the folder the module is contained in depending on if the\n    package parameter resolves to an actual python package (a folder with\n    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).\n\n    For more information about resource loading, see :func:`open_resource`.\n\n    Usually you create a :class:`Flask` instance in your main module or\n    in the :file:`__init__.py` file of your package like this::\n\n        from flask import Flask\n        app = Flask(__name__)\n\n    .. admonition:: About the First Parameter\n\n        The idea of the first parameter is to give Flask an idea of what\n        belongs to your application.  This name is used to find resources\n        on the filesystem, can be used by extensions to improve debugging\n        information and a lot more.\n\n        So it's important what you provide there.  If you are using a single\n        module, `__name__` is always the correct value.  If you however are\n        using a package, it's usually recommended to hardcode the name of\n        your package there.\n\n        For example if your application is defined in :file:`yourapplication/app.py`\n        you should create it with one of the two versions below::\n\n            app = Flask('yourapplication')\n            app = Flask(__name__.split('.')[0])\n\n        Why is that?  The application will work even with `__name__`, thanks\n        to how resources are looked up.  However it will make debugging more\n        painful.  Certain extensions can make assumptions based on the\n        import name of your application.  For example the Flask-SQLAlchemy\n        extension will look for the code in your application that triggered\n        an SQL query in debug mode.  If the import name is not properly set\n        up, that debugging information is lost.  (For example it would only\n        pick up SQL queries in `yourapplication.app` and not\n        `yourapplication.views.frontend`)\n\n    .. versionadded:: 0.7\n       The `static_url_path`, `static_folder`, and `template_folder`\n       parameters were added.\n\n    .. versionadded:: 0.8\n       The `instance_path` and `instance_relative_config` parameters were\n       added.\n\n    .. versionadded:: 0.11\n       The `root_path` parameter was added.\n\n    .. versionadded:: 1.0\n       The ``host_matching`` and ``static_host`` parameters were added.\n\n    .. versionadded:: 1.0\n       The ``subdomain_matching`` parameter was added. Subdomain\n       matching needs to be enabled manually now. Setting\n       :data:`SERVER_NAME` does not implicitly enable it.\n\n    :param import_name: the name of the application package\n    :param static_url_path: can be used to specify a different path for the\n                            static files on the web.  Defaults to the name\n                            of the `static_folder` folder.\n    :param static_folder: the folder with static files that should be served\n                          at `static_url_path`.  Defaults to the ``'static'``\n                          folder in the root path of the application.\n    :param static_host: the host to use when adding the static route.\n        Defaults to None. Required when using ``host_matching=True``\n        with a ``static_folder`` configured.\n    :param host_matching: set ``url_map.host_matching`` attribute.\n        Defaults to False.\n    :param subdomain_matching: consider the subdomain relative to\n        :data:`SERVER_NAME` when matching routes. Defaults to False.\n    :param template_folder: the folder that contains the templates that should\n                            be used by the application.  Defaults to\n                            ``'templates'`` folder in the root path of the\n                            application.\n    :param instance_path: An alternative instance path for the application.\n                          By default the folder ``'instance'`` next to the\n                          package or module is assumed to be the instance\n                          path.\n    :param instance_relative_config: if set to ``True`` relative filenames\n                                     for loading the config are assumed to\n                                     be relative to the instance path instead\n                                     of the application root.\n    :param root_path: Flask by default will automatically calculate the path\n                      to the root of the application.  In certain situations\n                      this cannot be achieved (for instance if the package\n                      is a Python 3 namespace package) and needs to be\n                      manually defined.\n    \"\"\"\n\n    #: The class that is used for request objects.  See :class:`~flask.Request`\n    #: for more information.\n    request_class = Request\n\n    #: The class that is used for response objects.  See\n    #: :class:`~flask.Response` for more information.\n    response_class = Response\n\n    #: The class that is used for the Jinja environment.\n    #:\n    #: .. versionadded:: 0.11\n    jinja_environment = Environment\n\n    #: The class that is used for the :data:`~flask.g` instance.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Store arbitrary attributes on flask.g.\n    #: 2. Add a property for lazy per-request database connectors.\n    #: 3. Return None instead of AttributeError on unexpected attributes.\n    #: 4. Raise exception if an unexpected attr is set, a \"controlled\" flask.g.\n    #:\n    #: In Flask 0.9 this property was called `request_globals_class` but it\n    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the\n    #: flask.g object is now application context scoped.\n    #:\n    #: .. versionadded:: 0.10\n    app_ctx_globals_class = _AppCtxGlobals\n\n    #: The class that is used for the ``config`` attribute of this app.\n    #: Defaults to :class:`~flask.Config`.\n    #:\n    #: Example use cases for a custom class:\n    #:\n    #: 1. Default values for certain config options.\n    #: 2. Access to config values through attributes in addition to keys.\n    #:\n    #: .. versionadded:: 0.11\n    config_class = Config\n\n    #: The testing flag.  Set this to ``True`` to enable the test mode of\n    #: Flask extensions (and in the future probably also Flask itself).\n    #: For example this might activate test helpers that have an\n    #: additional runtime cost which should not be enabled by default.\n    #:\n    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the\n    #: default it's implicitly enabled.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``TESTING`` configuration key.  Defaults to ``False``.\n    testing = ConfigAttribute('TESTING')\n\n    #: If a secret key is set, cryptographic components can use this to\n    #: sign cookies and other things. Set this to a complex random value\n    #: when you want to use the secure cookie for instance.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.\n    secret_key = ConfigAttribute('SECRET_KEY')\n\n    #: The secure cookie uses this for the name of the session cookie.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``SESSION_COOKIE_NAME`` configuration key.  Defaults to ``'session'``\n    session_cookie_name = ConfigAttribute('SESSION_COOKIE_NAME')\n\n    #: A :class:`~datetime.timedelta` which is used to set the expiration\n    #: date of a permanent session.  The default is 31 days which makes a\n    #: permanent session survive for roughly one month.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to\n    #: ``timedelta(days=31)``\n    permanent_session_lifetime = ConfigAttribute('PERMANENT_SESSION_LIFETIME',\n        get_converter=_make_timedelta)\n\n    #: A :class:`~datetime.timedelta` which is used as default cache_timeout\n    #: for the :func:`send_file` functions. The default is 12 hours.\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``SEND_FILE_MAX_AGE_DEFAULT`` configuration key. This configuration\n    #: variable can also be set with an integer value used as seconds.\n    #: Defaults to ``timedelta(hours=12)``\n    send_file_max_age_default = ConfigAttribute('SEND_FILE_MAX_AGE_DEFAULT',\n        get_converter=_make_timedelta)\n\n    #: Enable this if you want to use the X-Sendfile feature.  Keep in\n    #: mind that the server has to support this.  This only affects files\n    #: sent with the :func:`send_file` method.\n    #:\n    #: .. versionadded:: 0.2\n    #:\n    #: This attribute can also be configured from the config with the\n    #: ``USE_X_SENDFILE`` configuration key.  Defaults to ``False``.\n    use_x_sendfile = ConfigAttribute('USE_X_SENDFILE')\n\n    #: The JSON encoder class to use.  Defaults to :class:`~flask.json.JSONEncoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_encoder = json.JSONEncoder\n\n    #: The JSON decoder class to use.  Defaults to :class:`~flask.json.JSONDecoder`.\n    #:\n    #: .. versionadded:: 0.10\n    json_decoder = json.JSONDecoder\n\n    #: Options that are passed directly to the Jinja2 environment.\n    jinja_options = ImmutableDict(\n        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']\n    )\n\n    #: Default configuration parameters.\n    default_config = ImmutableDict({\n        'ENV':                                  None,\n        'DEBUG':                                None,\n        'TESTING':                              False,\n        'PROPAGATE_EXCEPTIONS':                 None,\n        'PRESERVE_CONTEXT_ON_EXCEPTION':        None,\n        'SECRET_KEY':                           None,\n        'PERMANENT_SESSION_LIFETIME':           timedelta(days=31),\n        'USE_X_SENDFILE':                       False,\n        'SERVER_NAME':                          None,\n        'APPLICATION_ROOT':                     '/',\n        'SESSION_COOKIE_NAME':                  'session',\n        'SESSION_COOKIE_DOMAIN':                None,\n        'SESSION_COOKIE_PATH':                  None,\n        'SESSION_COOKIE_HTTPONLY':              True,\n        'SESSION_COOKIE_SECURE':                False,\n        'SESSION_COOKIE_SAMESITE':              None,\n        'SESSION_REFRESH_EACH_REQUEST':         True,\n        'MAX_CONTENT_LENGTH':                   None,\n        'SEND_FILE_MAX_AGE_DEFAULT':            timedelta(hours=12),\n        'TRAP_BAD_REQUEST_ERRORS':              None,\n        'TRAP_HTTP_EXCEPTIONS':                 False,\n        'EXPLAIN_TEMPLATE_LOADING':             False,\n        'PREFERRED_URL_SCHEME':                 'http',\n        'JSON_AS_ASCII':                        True,\n        'JSON_SORT_KEYS':                       True,\n        'JSONIFY_PRETTYPRINT_REGULAR':          False,\n        'JSONIFY_MIMETYPE':                     'application/json',\n        'TEMPLATES_AUTO_RELOAD':                None,\n    })\n\n    #: The rule object to use for URL rules created.  This is used by\n    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.\n    #:\n    #: .. versionadded:: 0.7\n    url_rule_class = Rule\n\n    #: the test client that is used with when `test_client` is used.\n    #:\n    #: .. versionadded:: 0.7\n    test_client_class = None\n\n    #: The :class:`~click.testing.CliRunner` subclass, by default\n    #: :class:`~flask.testing.FlaskCliRunner` that is used by\n    #: :meth:`test_cli_runner`. Its ``__init__`` method should take a\n    #: Flask app object as the first argument.\n    #:\n    #: .. versionadded:: 1.0\n    test_cli_runner_class = None\n\n    #: the session interface to use.  By default an instance of\n    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.\n    #:\n    #: .. versionadded:: 0.8\n    session_interface = SecureCookieSessionInterface()\n\n    # TODO remove the next three attrs when Sphinx :inherited-members: works\n    # https://github.com/sphinx-doc/sphinx/issues/741\n\n    #: The name of the package or module that this app belongs to. Do not\n    #: change this once it is set by the constructor.\n    import_name = None\n\n    #: Location of the template files to be added to the template lookup.\n    #: ``None`` if templates should not be added.\n    template_folder = None\n\n    #: Absolute path to the package on the filesystem. Used to look up\n    #: resources contained in the package.\n    root_path = None\n\n    def __init__(\n        self,\n        import_name,\n        static_url_path=None,\n        static_folder='static',\n        static_host=None,\n        host_matching=False,\n        subdomain_matching=False,\n        template_folder='templates',\n        instance_path=None,\n        instance_relative_config=False,\n        root_path=None\n    ):\n        _PackageBoundObject.__init__(\n            self,\n            import_name,\n            template_folder=template_folder,\n            root_path=root_path\n        )\n\n        if static_url_path is not None:\n            self.static_url_path = static_url_path\n\n        if static_folder is not None:\n            self.static_folder = static_folder\n\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError(\n                'If an instance path is provided it must be absolute.'\n                ' A relative path was given instead.'\n            )\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        #: A dictionary of all view functions registered.  The keys will\n        #: be function names which are also used to generate URLs and\n        #: the values are the function objects themselves.\n        #: To register a view function, use the :meth:`route` decorator.\n        self.view_functions = {}\n\n        #: A dictionary of all registered error handlers.  The key is ``None``\n        #: for error handlers active on the application, otherwise the key is\n        #: the name of the blueprint.  Each key points to another dictionary\n        #: where the key is the status code of the http exception.  The\n        #: special key ``None`` points to a list of tuples where the first item\n        #: is the class for the instance check and the second the error handler\n        #: function.\n        #:\n        #: To register an error handler, use the :meth:`errorhandler`\n        #: decorator.\n        self.error_handler_spec = {}\n\n        #: A list of functions that are called when :meth:`url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`.  Each function registered here\n        #: is called with `error`, `endpoint` and `values`.  If a function\n        #: returns ``None`` or raises a :exc:`BuildError` the next function is\n        #: tried.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers = []\n\n        #: A dictionary with lists of functions that will be called at the\n        #: beginning of each request. The key of the dictionary is the name of\n        #: the blueprint this function is active for, or ``None`` for all\n        #: requests. To register a function, use the :meth:`before_request`\n        #: decorator.\n        self.before_request_funcs = {}\n\n        #: A list of functions that will be called at the beginning of the\n        #: first request to this instance. To register a function, use the\n        #: :meth:`before_first_request` decorator.\n        #:\n        #: .. versionadded:: 0.8\n        self.before_first_request_funcs = []\n\n        #: A dictionary with lists of functions that should be called after\n        #: each request.  The key of the dictionary is the name of the blueprint\n        #: this function is active for, ``None`` for all requests.  This can for\n        #: example be used to close database connections. To register a function\n        #: here, use the :meth:`after_request` decorator.\n        self.after_request_funcs = {}\n\n        #: A dictionary with lists of functions that are called after\n        #: each request, even if an exception has occurred. The key of the\n        #: dictionary is the name of the blueprint this function is active for,\n        #: ``None`` for all requests. These functions are not allowed to modify\n        #: the request, and their return values are ignored. If an exception\n        #: occurred while processing the request, it gets passed to each\n        #: teardown_request function. To register a function here, use the\n        #: :meth:`teardown_request` decorator.\n        #:\n        #: .. versionadded:: 0.7\n        self.teardown_request_funcs = {}\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs = []\n\n        #: A dictionary with lists of functions that are called before the\n        #: :attr:`before_request_funcs` functions. The key of the dictionary is\n        #: the name of the blueprint this function is active for, or ``None``\n        #: for all requests. To register a function, use\n        #: :meth:`url_value_preprocessor`.\n        #:\n        #: .. versionadded:: 0.7\n        self.url_value_preprocessors = {}\n\n        #: A dictionary with lists of functions that can be used as URL value\n        #: preprocessors.  The key ``None`` here is used for application wide\n        #: callbacks, otherwise the key is the name of the blueprint.\n        #: Each of these functions has the chance to modify the dictionary\n        #: of URL values before they are used as the keyword arguments of the\n        #: view function.  For each function registered this one should also\n        #: provide a :meth:`url_defaults` function that adds the parameters\n        #: automatically again that were removed that way.\n        #:\n        #: .. versionadded:: 0.7\n        self.url_default_functions = {}\n\n        #: A dictionary with list of functions that are called without argument\n        #: to populate the template context.  The key of the dictionary is the\n        #: name of the blueprint this function is active for, ``None`` for all\n        #: requests.  Each returns a dictionary that the template context is\n        #: updated with.  To register a function here, use the\n        #: :meth:`context_processor` decorator.\n        self.template_context_processors = {\n            None: [_default_template_ctx_processor]\n        }\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors = []\n\n        #: all the attached blueprints in a dictionary by name.  Blueprints\n        #: can be attached multiple times so this dictionary does not tell\n        #: you how often they got attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints = {}\n        self._blueprint_order = []\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.  For backwards compatibility extensions should register\n        #: themselves like this::\n        #:\n        #:      if not hasattr(app, 'extensions'):\n        #:          app.extensions = {}\n        #:      app.extensions['extensionname'] = SomeObject()\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = Map()\n\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n        self._before_request_lock = Lock()\n\n        # Add a static route using the provided static_url_path, static_host,\n        # and static_folder if there is a configured static_folder.\n        # Note we do this without checking if static_folder exists.\n        # For one, it might be created while the server is running (e.g. during\n        # development). Also, Google App Engine stores static files somewhere\n        if self.has_static_folder:\n            assert bool(static_host) == host_matching, 'Invalid static_host/host_matching combination'\n            self.add_url_rule(\n                self.static_url_path + '/<path:filename>',\n                endpoint='static',\n                host=static_host,\n                view_func=self.send_static_file\n            )\n\n        #: The click command line context for this application.  Commands\n        #: registered here show up in the :command:`flask` command once the\n        #: application has been discovered.  The default commands are\n        #: provided by Flask itself and can be overridden.\n        #:\n        #: This is an instance of a :class:`click.Group` object.\n        self.cli = cli.AppGroup(self.name)\n\n    @locked_cached_property\n    def name(self):\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overridden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.import_name == '__main__':\n            fn = getattr(sys.modules['__main__'], '__file__', None)\n            if fn is None:\n                return '__main__'\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name\n\n    @property\n    def propagate_exceptions(self):\n        \"\"\"Returns the value of the ``PROPAGATE_EXCEPTIONS`` configuration\n        value in case it's set, otherwise a sensible default is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config['PROPAGATE_EXCEPTIONS']\n        if rv is not None:\n            return rv\n        return self.testing or self.debug\n\n    @property\n    def preserve_context_on_exception(self):\n        \"\"\"Returns the value of the ``PRESERVE_CONTEXT_ON_EXCEPTION``\n        configuration value in case it's set, otherwise a sensible default\n        is returned.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        rv = self.config['PRESERVE_CONTEXT_ON_EXCEPTION']\n        if rv is not None:\n            return rv\n        return self.debug\n\n    @locked_cached_property\n    def logger(self):\n        \"\"\"The ``'flask.app'`` logger, a standard Python\n        :class:`~logging.Logger`.\n\n        In debug mode, the logger's :attr:`~logging.Logger.level` will be set\n        to :data:`~logging.DEBUG`.\n\n        If there are no handlers configured, a default handler will be added.\n        See :ref:`logging` for more information.\n\n        .. versionchanged:: 1.0\n            Behavior was simplified. The logger is always named\n            ``flask.app``. The level is only set during configuration, it\n            doesn't check ``app.debug`` each time. Only one format is used,\n            not different ones depending on ``app.debug``. No handlers are\n            removed, and a handler is only added if no handlers are already\n            configured.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        return create_logger(self)\n\n    @locked_cached_property\n    def jinja_env(self):\n        \"\"\"The Jinja2 environment used to load templates.\"\"\"\n        return self.create_jinja_environment()\n\n    @property\n    def got_first_request(self):\n        \"\"\"This attribute is set to ``True`` if the application started\n        handling the first request.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        return self._got_first_request\n\n    def make_config(self, instance_relative=False):\n        \"\"\"Used to create the config attribute by the Flask constructor.\n        The `instance_relative` parameter is passed in from the constructor\n        of Flask (there named `instance_relative_config`) and indicates if\n        the config should be relative to the instance path or the root path\n        of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults['ENV'] = get_env()\n        defaults['DEBUG'] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n\n    def auto_find_instance_path(self):\n        \"\"\"Tries to locate the instance path if it was not provided to the\n        constructor of the application class.  It will basically calculate\n        the path to a folder named ``instance`` next to your main file or\n        the package.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            return os.path.join(package_path, 'instance')\n        return os.path.join(prefix, 'var', self.name + '-instance')\n\n    def open_instance_resource(self, resource, mode='rb'):\n        \"\"\"Opens a resource from the application's instance folder\n        (:attr:`instance_path`).  Otherwise works like\n        :meth:`open_resource`.  Instance resources can also be opened for\n        writing.\n\n        :param resource: the name of the resource.  To access resources within\n                         subfolders use forward slashes as separator.\n        :param mode: resource file opening mode, default is 'rb'.\n        \"\"\"\n        return open(os.path.join(self.instance_path, resource), mode)\n\n    def _get_templates_auto_reload(self):\n        \"\"\"Reload templates when they are changed. Used by\n        :meth:`create_jinja_environment`.\n\n        This attribute can be configured with :data:`TEMPLATES_AUTO_RELOAD`. If\n        not set, it will be enabled in debug mode.\n\n        .. versionadded:: 1.0\n            This property was added but the underlying config and behavior\n            already existed.\n        \"\"\"\n        rv = self.config['TEMPLATES_AUTO_RELOAD']\n        return rv if rv is not None else self.debug\n\n    def _set_templates_auto_reload(self, value):\n        self.config['TEMPLATES_AUTO_RELOAD'] = value\n\n    templates_auto_reload = property(\n        _get_templates_auto_reload, _set_templates_auto_reload\n    )\n    del _get_templates_auto_reload, _set_templates_auto_reload\n\n    def create_jinja_environment(self):\n        \"\"\"Creates the Jinja2 environment based on :attr:`jinja_options`\n        and :meth:`select_jinja_autoescape`.  Since 0.7 this also adds\n        the Jinja2 globals and filters after initialization.  Override\n        this function to customize the behavior.\n\n        .. versionadded:: 0.5\n        .. versionchanged:: 0.11\n           ``Environment.auto_reload`` set in accordance with\n           ``TEMPLATES_AUTO_RELOAD`` configuration option.\n        \"\"\"\n        options = dict(self.jinja_options)\n\n        if 'autoescape' not in options:\n            options['autoescape'] = self.select_jinja_autoescape\n\n        if 'auto_reload' not in options:\n            options['auto_reload'] = self.templates_auto_reload\n\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            # request, session and g are normally added with the\n            # context processor for efficiency reasons but for imported\n            # templates we also want the proxies in there.\n            request=request,\n            session=session,\n            g=g\n        )\n        rv.filters['tojson'] = json.tojson_filter\n        return rv\n\n    def create_global_jinja_loader(self):\n        \"\"\"Creates the loader for the Jinja2 environment.  Can be used to\n        override just the loader and keeping the rest unchanged.  It's\n        discouraged to override this function.  Instead one should override\n        the :meth:`jinja_loader` function instead.\n\n        The global loader dispatches between the loaders of the application\n        and the individual blueprints.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return DispatchingJinjaLoader(self)\n\n    def select_jinja_autoescape(self, filename):\n        \"\"\"Returns ``True`` if autoescaping should be active for the given\n        template name. If no template name is given, returns `True`.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if filename is None:\n            return True\n        return filename.endswith(('.html', '.htm', '.xml', '.xhtml'))\n\n    def update_template_context(self, context):\n        \"\"\"Update the template context with some commonly used variables.\n        This injects request, session, config and g into the template\n        context as well as everything template context processors want\n        to inject.  Note that the as of Flask 0.6, the original values\n        in the context will not be overridden if a context processor\n        decides to return a value with the same key.\n\n        :param context: the context as a dictionary that is updated in place\n                        to add extra variables.\n        \"\"\"\n        funcs = self.template_context_processors[None]\n        reqctx = _request_ctx_stack.top\n        if reqctx is not None:\n            bp = reqctx.request.blueprint\n            if bp is not None and bp in self.template_context_processors:\n                funcs = chain(funcs, self.template_context_processors[bp])\n        orig_ctx = context.copy()\n        for func in funcs:\n            context.update(func())\n        # make sure the original values win.  This makes it possible to\n        # easier add new variables in context processors without breaking\n        # existing views.\n        context.update(orig_ctx)\n\n    def make_shell_context(self):\n        \"\"\"Returns the shell context for an interactive shell for this\n        application.  This runs all the registered shell context\n        processors.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        rv = {'app': self, 'g': g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n\n    #: What environment the app is running in. Flask and extensions may\n    #: enable behaviors based on the environment, such as enabling debug\n    #: mode. This maps to the :data:`ENV` config key. This is set by the\n    #: :envvar:`FLASK_ENV` environment variable and may not behave as\n    #: expected if set in code.\n    #:\n    #: **Do not enable development when deploying in production.**\n    #:\n    #: Default: ``'production'``\n    env = ConfigAttribute('ENV')\n\n    def _get_debug(self):\n        return self.config['DEBUG']\n\n    def _set_debug(self, value):\n        self.config['DEBUG'] = value\n        self.jinja_env.auto_reload = self.templates_auto_reload\n\n    #: Whether debug mode is enabled. When using ``flask run`` to start\n    #: the development server, an interactive debugger will be shown for\n    #: unhandled exceptions, and the server will be reloaded when code\n    #: changes. This maps to the :data:`DEBUG` config key. This is\n    #: enabled when :attr:`env` is ``'development'`` and is overridden\n    #: by the ``FLASK_DEBUG`` environment variable. It may not behave as\n    #: expected if set in code.\n    #:\n    #: **Do not enable debug mode when deploying in production.**\n    #:\n    #: Default: ``True`` if :attr:`env` is ``'development'``, or\n    #: ``False`` otherwise.\n    debug = property(_get_debug, _set_debug)\n    del _get_debug, _set_debug\n\n    def run(self, host=None, port=None, debug=None,\n            load_dotenv=True, **options):\n        \"\"\"Runs the application on a local development server.\n\n        Do not use ``run()`` in a production setting. It is not intended to\n        meet security and performance requirements for a production server.\n        Instead, see :ref:`deployment` for WSGI server recommendations.\n\n        If the :attr:`debug` flag is set the server will automatically reload\n        for code changes and show a debugger in case an exception happened.\n\n        If you want to run the application in debug mode, but disable the\n        code execution on the interactive debugger, you can pass\n        ``use_evalex=False`` as parameter.  This will keep the debugger's\n        traceback screen active, but disable code execution.\n\n        It is not recommended to use this function for development with\n        automatic reloading as this is badly supported.  Instead you should\n        be using the :command:`flask` command line script's ``run`` support.\n\n        .. admonition:: Keep in Mind\n\n           Flask will suppress any server error with a generic error page\n           unless it is in debug mode.  As such to enable just the\n           interactive debugger without the code reloading, you have to\n           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n           Setting ``use_debugger`` to ``True`` without being in debug mode\n           won't catch any exceptions because there won't be any to\n           catch.\n\n        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n            have the server available externally as well. Defaults to\n            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable\n            if present.\n        :param port: the port of the webserver. Defaults to ``5000`` or the\n            port defined in the ``SERVER_NAME`` config variable if present.\n        :param debug: if given, enable or disable debug mode. See\n            :attr:`debug`.\n        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n            files to set environment variables. Will also change the working\n            directory to the directory containing the first file found.\n        :param options: the options to be forwarded to the underlying Werkzeug\n            server. See :func:`werkzeug.serving.run_simple` for more\n            information.\n\n        .. versionchanged:: 1.0\n            If installed, python-dotenv will be used to load environment\n            variables from :file:`.env` and :file:`.flaskenv` files.\n\n            If set, the :envvar:`FLASK_ENV` and :envvar:`FLASK_DEBUG`\n            environment variables will override :attr:`env` and\n            :attr:`debug`.\n\n            Threaded mode is enabled by default.\n\n        .. versionchanged:: 0.10\n            The default port is now picked from the ``SERVER_NAME``\n            variable.\n        \"\"\"\n        # Change this into a no-op if the server is invoked from the\n        # command line. Have a look at cli.py for more information.\n        if os.environ.get('FLASK_RUN_FROM_CLI') == 'true':\n            from .debughelpers import explain_ignored_app_run\n            explain_ignored_app_run()\n            return\n\n        if load_dotenv:\n            cli.load_dotenv()\n\n            # if set, let env vars override previous values\n            if 'FLASK_ENV' in os.environ:\n                self.env = get_env()\n                self.debug = get_debug_flag()\n            elif 'FLASK_DEBUG' in os.environ:\n                self.debug = get_debug_flag()\n\n        # debug passed to method overrides all other sources\n        if debug is not None:\n            self.debug = bool(debug)\n\n        _host = '127.0.0.1'\n        _port = 5000\n        server_name = self.config.get('SERVER_NAME')\n        sn_host, sn_port = None, None\n\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(':')\n\n        host = host or sn_host or _host\n        port = int(port or sn_port or _port)\n\n        options.setdefault('use_reloader', self.debug)\n        options.setdefault('use_debugger', self.debug)\n        options.setdefault('threaded', True)\n\n        cli.show_server_banner(self.env, self.debug, self.name)\n\n        from werkzeug.serving import run_simple\n\n        try:\n            run_simple(host, port, self, **options)\n        finally:\n            # reset the first request information if the development server\n            # reset normally.  This makes it possible to restart the server\n            # without reloader and that stuff from an interactive shell.\n            self._got_first_request = False\n\n    def test_client(self, use_cookies=True, **kwargs):\n        \"\"\"Creates a test client for this application.  For information\n        about unit testing head over to :ref:`testing`.\n\n        Note that if you are testing for assertions or exceptions in your\n        application code, you must set ``app.testing = True`` in order for the\n        exceptions to propagate to the test client.  Otherwise, the exception\n        will be handled by the application (not visible to the test client) and\n        the only indication of an AssertionError or other exception will be a\n        500 status code response to the test client.  See the :attr:`testing`\n        attribute.  For example::\n\n            app.testing = True\n            client = app.test_client()\n\n        The test client can be used in a ``with`` block to defer the closing down\n        of the context until the end of the ``with`` block.  This is useful if\n        you want to access the context locals for testing::\n\n            with app.test_client() as c:\n                rv = c.get('/?vodka=42')\n                assert request.args['vodka'] == '42'\n\n        Additionally, you may pass optional keyword arguments that will then\n        be passed to the application's :attr:`test_client_class` constructor.\n        For example::\n\n            from flask.testing import FlaskClient\n\n            class CustomClient(FlaskClient):\n                def __init__(self, *args, **kwargs):\n                    self._authentication = kwargs.pop(\"authentication\")\n                    super(CustomClient,self).__init__( *args, **kwargs)\n\n            app.test_client_class = CustomClient\n            client = app.test_client(authentication='Basic ....')\n\n        See :class:`~flask.testing.FlaskClient` for more information.\n\n        .. versionchanged:: 0.4\n           added support for ``with`` block usage for the client.\n\n        .. versionadded:: 0.7\n           The `use_cookies` parameter was added as well as the ability\n           to override the client to be used by setting the\n           :attr:`test_client_class` attribute.\n\n        .. versionchanged:: 0.11\n           Added `**kwargs` to support passing additional keyword arguments to\n           the constructor of :attr:`test_client_class`.\n        \"\"\"\n        cls = self.test_client_class\n        if cls is None:\n            from flask.testing import FlaskClient as cls\n        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)\n\n    def test_cli_runner(self, **kwargs):\n        \"\"\"Create a CLI runner for testing CLI commands.\n        See :ref:`testing-cli`.\n\n        Returns an instance of :attr:`test_cli_runner_class`, by default\n        :class:`~flask.testing.FlaskCliRunner`. The Flask app object is\n        passed as the first argument.\n\n        .. versionadded:: 1.0\n        \"\"\"\n        cls = self.test_cli_runner_class\n\n        if cls is None:\n            from flask.testing import FlaskCliRunner as cls\n\n        return cls(self, **kwargs)\n\n    def open_session(self, request):\n        \"\"\"Creates or opens a new session.  Default implementation stores all\n        session data in a signed cookie.  This requires that the\n        :attr:`secret_key` is set.  Instead of overriding this method\n        we recommend replacing the :class:`session_interface`.\n\n        .. deprecated: 1.0\n            Will be removed in 1.1. Use ``session_interface.open_session``\n            instead.\n\n        :param request: an instance of :attr:`request_class`.\n        \"\"\"\n\n        warnings.warn(DeprecationWarning(\n            '\"open_session\" is deprecated and will be removed in 1.1. Use'\n            ' \"session_interface.open_session\" instead.'\n        ))\n        return self.session_interface.open_session(self, request)\n\n    def save_session(self, session, response):\n        \"\"\"Saves the session if it needs updates.  For the default\n        implementation, check :meth:`open_session`.  Instead of overriding this\n        method we recommend replacing the :class:`session_interface`.\n\n        .. deprecated: 1.0\n            Will be removed in 1.1. Use ``session_interface.save_session``\n            instead.\n\n        :param session: the session to be saved (a\n                        :class:`~werkzeug.contrib.securecookie.SecureCookie`\n                        object)\n        :param response: an instance of :attr:`response_class`\n        \"\"\"\n\n        warnings.warn(DeprecationWarning(\n            '\"save_session\" is deprecated and will be removed in 1.1. Use'\n            ' \"session_interface.save_session\" instead.'\n        ))\n        return self.session_interface.save_session(self, session, response)\n\n    def make_null_session(self):\n        \"\"\"Creates a new instance of a missing session.  Instead of overriding\n        this method we recommend replacing the :class:`session_interface`.\n\n        .. deprecated: 1.0\n            Will be removed in 1.1. Use ``session_interface.make_null_session``\n            instead.\n\n        .. versionadded:: 0.7\n        \"\"\"\n\n        warnings.warn(DeprecationWarning(\n            '\"make_null_session\" is deprecated and will be removed in 1.1. Use'\n            ' \"session_interface.make_null_session\" instead.'\n        ))\n        return self.session_interface.make_null_session(self)\n\n    @setupmethod\n    def register_blueprint(self, blueprint, **options):\n        \"\"\"Register a :class:`~flask.Blueprint` on the application. Keyword\n        arguments passed to this method will override the defaults set on the\n        blueprint.\n\n        Calls the blueprint's :meth:`~flask.Blueprint.register` method after\n        recording the blueprint in the application's :attr:`blueprints`.\n\n        :param blueprint: The blueprint to register.\n        :param url_prefix: Blueprint routes will be prefixed with this.\n        :param subdomain: Blueprint routes will match on this subdomain.\n        :param url_defaults: Blueprint routes will use these default values for\n            view arguments.\n        :param options: Additional keyword arguments are passed to\n            :class:`~flask.blueprints.BlueprintSetupState`. They can be\n            accessed in :meth:`~flask.Blueprint.record` callbacks.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        first_registration = False\n\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                'A name collision occurred between blueprints %r and %r. Both'\n                ' share the same name \"%s\". Blueprints that are created on the'\n                ' fly need unique names.' % (\n                    blueprint, self.blueprints[blueprint.name], blueprint.name\n                )\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n            first_registration = True\n\n        blueprint.register(self, options, first_registration)\n\n    def iter_blueprints(self):\n        \"\"\"Iterates over all blueprints by the order they were registered.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        return iter(self._blueprint_order)\n\n    @setupmethod\n    def add_url_rule(self, rule, endpoint=None, view_func=None,\n                     provide_automatic_options=None, **options):\n        \"\"\"Connects a URL rule.  Works exactly like the :meth:`route`\n        decorator.  If a view_func is provided it will be registered with the\n        endpoint.\n\n        Basically this example::\n\n            @app.route('/')\n            def index():\n                pass\n\n        Is equivalent to the following::\n\n            def index():\n                pass\n            app.add_url_rule('/', 'index', index)\n\n        If the view_func is not provided you will need to connect the endpoint\n        to a view function like so::\n\n            app.view_functions['index'] = index\n\n        Internally :meth:`route` invokes :meth:`add_url_rule` so if you want\n        to customize the behavior via subclassing you only need to change\n        this method.\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        .. versionchanged:: 0.2\n           `view_func` parameter added.\n\n        .. versionchanged:: 0.6\n           ``OPTIONS`` is added automatically as method.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param view_func: the function to call when serving a request to the\n                          provided endpoint\n        :param provide_automatic_options: controls whether the ``OPTIONS``\n            method should be added automatically. This can also be controlled\n            by setting the ``view_func.provide_automatic_options = False``\n            before adding the rule.\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (``GET``, ``POST`` etc.).  By default a rule\n                        just listens for ``GET`` (and implicitly ``HEAD``).\n                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        options['endpoint'] = endpoint\n        methods = options.pop('methods', None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only ``GET`` as default.\n        if methods is None:\n            methods = getattr(view_func, 'methods', None) or ('GET',)\n        if isinstance(methods, string_types):\n            raise TypeError('Allowed methods have to be iterables of strings, '\n                            'for example: @app.route(..., methods=[\"POST\"])')\n        methods = set(item.upper() for item in methods)\n\n        # Methods that should always be added\n        required_methods = set(getattr(view_func, 'required_methods', ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(view_func,\n                'provide_automatic_options', None)\n\n        if provide_automatic_options is None:\n            if 'OPTIONS' not in methods:\n                provide_automatic_options = True\n                required_methods.add('OPTIONS')\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options\n\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError('View function mapping is overwriting an '\n                                     'existing endpoint function: %s' % endpoint)\n            self.view_functions[endpoint] = view_func\n\n    def route(self, rule, **options):\n        \"\"\"A decorator that is used to register a view function for a\n        given URL rule.  This does the same thing as :meth:`add_url_rule`\n        but is intended for decorator usage::\n\n            @app.route('/')\n            def index():\n                return 'Hello World'\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (``GET``, ``POST`` etc.).  By default a rule\n                        just listens for ``GET`` (and implicitly ``HEAD``).\n                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        def decorator(f):\n            endpoint = options.pop('endpoint', None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n        return decorator\n\n    @setupmethod\n    def endpoint(self, endpoint):\n        \"\"\"A decorator to register a function as an endpoint.\n        Example::\n\n            @app.endpoint('example.endpoint')\n            def example():\n                return \"example\"\n\n        :param endpoint: the name of the endpoint\n        \"\"\"\n        def decorator(f):\n            self.view_functions[endpoint] = f\n            return f\n        return decorator\n\n    @staticmethod\n    def _get_exc_class_and_code(exc_class_or_code):\n        \"\"\"Ensure that we register only exceptions as handler keys\"\"\"\n        if isinstance(exc_class_or_code, integer_types):\n            exc_class = default_exceptions[exc_class_or_code]\n        else:\n            exc_class = exc_class_or_code\n\n        assert issubclass(exc_class, Exception)\n\n        if issubclass(exc_class, HTTPException):\n            return exc_class, exc_class.code\n        else:\n            return exc_class, None\n\n    @setupmethod\n    def errorhandler(self, code_or_exception):\n        \"\"\"Register a function to handle errors by code or exception class.\n\n        A decorator that is used to register a function given an\n        error code.  Example::\n\n            @app.errorhandler(404)\n            def page_not_found(error):\n                return 'This page does not exist', 404\n\n        You can also register handlers for arbitrary exceptions::\n\n            @app.errorhandler(DatabaseError)\n            def special_exception_handler(error):\n                return 'Database connection failed', 500\n\n        .. versionadded:: 0.7\n            Use :meth:`register_error_handler` instead of modifying\n            :attr:`error_handler_spec` directly, for application wide error\n            handlers.\n\n        .. versionadded:: 0.7\n           One can now additionally also register custom exception types\n           that do not necessarily have to be a subclass of the\n           :class:`~werkzeug.exceptions.HTTPException` class.\n\n        :param code_or_exception: the code as integer for the handler, or\n                                  an arbitrary exception\n        \"\"\"\n        def decorator(f):\n            self._register_error_handler(None, code_or_exception, f)\n            return f\n        return decorator\n\n    @setupmethod\n    def register_error_handler(self, code_or_exception, f):\n        \"\"\"Alternative error attach function to the :meth:`errorhandler`\n        decorator that is more straightforward to use for non decorator\n        usage.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self._register_error_handler(None, code_or_exception, f)\n\n    @setupmethod\n    def _register_error_handler(self, key, code_or_exception, f):\n        \"\"\"\n        :type key: None|str\n        :type code_or_exception: int|T<=Exception\n        :type f: callable\n        \"\"\"\n        if isinstance(code_or_exception, HTTPException):  # old broken behavior\n            raise ValueError(\n                'Tried to register a handler for an exception instance {0!r}.'\n                ' Handlers can only be registered for exception classes or'\n                ' HTTP error codes.'.format(code_or_exception)\n            )\n\n        try:\n            exc_class, code = self._get_exc_class_and_code(code_or_exception)\n        except KeyError:\n            raise KeyError(\n                \"'{0}' is not a recognized HTTP error code. Use a subclass of\"\n                \" HTTPException with that code instead.\".format(code_or_exception)\n            )\n\n        handlers = self.error_handler_spec.setdefault(key, {}).setdefault(code, {})\n        handlers[exc_class] = f\n\n    @setupmethod\n    def template_filter(self, name=None):\n        \"\"\"A decorator that is used to register custom template filter.\n        You can specify a name for the filter, otherwise the function\n        name will be used. Example::\n\n          @app.template_filter()\n          def reverse(s):\n              return s[::-1]\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_filter(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_filter(self, f, name=None):\n        \"\"\"Register a custom template filter.  Works exactly like the\n        :meth:`template_filter` decorator.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.filters[name or f.__name__] = f\n\n    @setupmethod\n    def template_test(self, name=None):\n        \"\"\"A decorator that is used to register custom template test.\n        You can specify a name for the test, otherwise the function\n        name will be used. Example::\n\n          @app.template_test()\n          def is_prime(n):\n              if n == 2:\n                  return True\n              for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n                  if n % i == 0:\n                      return False\n              return True\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_test(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_test(self, f, name=None):\n        \"\"\"Register a custom template test.  Works exactly like the\n        :meth:`template_test` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.tests[name or f.__name__] = f\n\n    @setupmethod\n    def template_global(self, name=None):\n        \"\"\"A decorator that is used to register a custom template global function.\n        You can specify a name for the global function, otherwise the function\n        name will be used. Example::\n\n            @app.template_global()\n            def double(n):\n                return 2 * n\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_template_global(f, name=name)\n            return f\n        return decorator\n\n    @setupmethod\n    def add_template_global(self, f, name=None):\n        \"\"\"Register a custom template global function. Works exactly like the\n        :meth:`template_global` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.globals[name or f.__name__] = f\n\n    @setupmethod\n    def before_request(self, f):\n        \"\"\"Registers a function to run before each request.\n\n        For example, this can be used to open a database connection, or to load\n        the logged in user from the session.\n\n        The function will be called without any arguments. If it returns a\n        non-None value, the value is handled as if it was the return value from\n        the view, and further request handling is stopped.\n        \"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def before_first_request(self, f):\n        \"\"\"Registers a function to be run before the first request to this\n        instance of the application.\n\n        The function will be called without any arguments and its return\n        value is ignored.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.before_first_request_funcs.append(f)\n        return f\n\n    @setupmethod\n    def after_request(self, f):\n        \"\"\"Register a function to be run after each request.\n\n        Your function must take one parameter, an instance of\n        :attr:`response_class` and return a new response object or the\n        same (see :meth:`process_response`).\n\n        As of Flask 0.7 this function might not be executed at the end of the\n        request in case an unhandled exception occurred.\n        \"\"\"\n        self.after_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_request(self, f):\n        \"\"\"Register a function to be run at the end of each request,\n        regardless of whether there was an exception or not.  These functions\n        are executed when the request context is popped, even if not an\n        actual request was performed.\n\n        Example::\n\n            ctx = app.test_request_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the request context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Generally teardown functions must take every necessary step to avoid\n        that they will fail.  If they do execute code that might fail they\n        will have to surround the execution of these code by try/except\n        statements and log occurring errors.\n\n        When a teardown function was called because of an exception it will\n        be passed an error object.\n\n        The return values of teardown functions are ignored.\n\n        .. admonition:: Debug Note\n\n           In debug mode Flask will not tear down a request on an exception\n           immediately.  Instead it will keep it alive so that the interactive\n           debugger can still access it.  This behavior can be controlled\n           by the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.\n        \"\"\"\n        self.teardown_request_funcs.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def teardown_appcontext(self, f):\n        \"\"\"Registers a function to be called when the application context\n        ends.  These functions are typically also called when the request\n        context is popped.\n\n        Example::\n\n            ctx = app.app_context()\n            ctx.push()\n            ...\n            ctx.pop()\n\n        When ``ctx.pop()`` is executed in the above example, the teardown\n        functions are called just before the app context moves from the\n        stack of active contexts.  This becomes relevant if you are using\n        such constructs in tests.\n\n        Since a request context typically also manages an application\n        context it would also be called when you pop a request context.\n\n        When a teardown function was called because of an unhandled exception\n        it will be passed an error object. If an :meth:`errorhandler` is\n        registered, it will handle the exception and the teardown will not\n        receive it.\n\n        The return values of teardown functions are ignored.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        self.teardown_appcontext_funcs.append(f)\n        return f\n\n    @setupmethod\n    def context_processor(self, f):\n        \"\"\"Registers a template context processor function.\"\"\"\n        self.template_context_processors[None].append(f)\n        return f\n\n    @setupmethod\n    def shell_context_processor(self, f):\n        \"\"\"Registers a shell context processor function.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        self.shell_context_processors.append(f)\n        return f\n\n    @setupmethod\n    def url_value_preprocessor(self, f):\n        \"\"\"Register a URL value preprocessor function for all view\n        functions in the application. These functions will be called before the\n        :meth:`before_request` functions.\n\n        The function can modify the values captured from the matched url before\n        they are passed to the view. For example, this can be used to pop a\n        common language code value and place it in ``g`` rather than pass it to\n        every view.\n\n        The function is passed the endpoint name and values dict. The return\n        value is ignored.\n        \"\"\"\n        self.url_value_preprocessors.setdefault(None, []).append(f)\n        return f\n\n    @setupmethod\n    def url_defaults(self, f):\n        \"\"\"Callback function for URL defaults for all view functions of the\n        application.  It's called with the endpoint and values and should\n        update the values passed in place.\n        \"\"\"\n        self.url_default_functions.setdefault(None, []).append(f)\n        return f\n\n    def _find_error_handler(self, e):\n        \"\"\"Return a registered error handler for an exception in this order:\n        blueprint handler for a specific code, app handler for a specific code,\n        blueprint handler for an exception class, app handler for an exception\n        class, or ``None`` if a suitable handler is not found.\n        \"\"\"\n        exc_class, code = self._get_exc_class_and_code(type(e))\n\n        for name, c in (\n            (request.blueprint, code), (None, code),\n            (request.blueprint, None), (None, None)\n        ):\n            handler_map = self.error_handler_spec.setdefault(name, {}).get(c)\n\n            if not handler_map:\n                continue\n\n            for cls in exc_class.__mro__:\n                handler = handler_map.get(cls)\n\n                if handler is not None:\n                    return handler\n\n    def handle_http_exception(self, e):\n        \"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        # Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return handler(e)\n\n    def trap_http_exception(self, e):\n        \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n        this will return ``False`` for all exceptions except for a bad request\n        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It\n        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.\n\n        This is called for all HTTP exceptions raised by a view function.\n        If it returns ``True`` for any exception the error handler for this\n        exception is not called and it shows up as regular exception in the\n        traceback.  This is helpful for debugging implicitly raised HTTP\n        exceptions.\n\n        .. versionchanged:: 1.0\n            Bad request errors are not trapped by default in debug mode.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.config['TRAP_HTTP_EXCEPTIONS']:\n            return True\n\n        trap_bad_request = self.config['TRAP_BAD_REQUEST_ERRORS']\n\n        # if unset, trap based on debug mode\n        if (trap_bad_request is None and self.debug) or trap_bad_request:\n            return isinstance(e, BadRequest)\n\n        return False\n\n    def handle_user_exception(self, e):\n        \"\"\"This method is called whenever an exception occurs that should be\n        handled.  A special case are\n        :class:`~werkzeug.exception.HTTPException`\\s which are forwarded by\n        this function to the :meth:`handle_http_exception` method.  This\n        function will either return a response value or reraise the\n        exception with the same traceback.\n\n        .. versionchanged:: 1.0\n            Key errors raised from request data like ``form`` show the the bad\n            key in debug mode rather than a generic bad request message.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        assert exc_value is e\n        # ensure not to trash sys.exc_info() at that point in case someone\n        # wants the traceback preserved in handle_http_exception.  Of course\n        # we cannot prevent users from trashing it themselves in a custom\n        # trap_http_exception method so that's their fault then.\n\n        # MultiDict passes the key to the exception, but that's ignored\n        # when generating the response message. Set an informative\n        # description for key errors in debug mode or when trapping errors.\n        if (\n            (self.debug or self.config['TRAP_BAD_REQUEST_ERRORS'])\n            and isinstance(e, BadRequestKeyError)\n            # only set it if it's still the default description\n            and e.description is BadRequestKeyError.description\n        ):\n            e.description = \"KeyError: '{0}'\".format(*e.args)\n\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n\n        handler = self._find_error_handler(e)\n\n        if handler is None:\n            reraise(exc_type, exc_value, tb)\n        return handler(e)\n\n    def handle_exception(self, e):\n        \"\"\"Default exception handling that kicks in when an exception\n        occurs that is not caught.  In debug mode the exception will\n        be re-raised immediately, otherwise it is logged and the handler\n        for a 500 internal server error is used.  If no such handler\n        exists, a default 500 internal server error message is displayed.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n\n        got_request_exception.send(self, exception=e)\n        handler = self._find_error_handler(InternalServerError())\n\n        if self.propagate_exceptions:\n            # if we want to repropagate the exception, we can attempt to\n            # raise it with the whole traceback in case we can do that\n            # (the function was actually called from the except part)\n            # otherwise, we just raise the error again\n            if exc_value is e:\n                reraise(exc_type, exc_value, tb)\n            else:\n                raise e\n\n        self.log_exception((exc_type, exc_value, tb))\n        if handler is None:\n            return InternalServerError()\n        return self.finalize_request(handler(e), from_error_handler=True)\n\n    def log_exception(self, exc_info):\n        \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n        if debugging is disabled and right before the handler is called.\n        The default implementation logs the exception as error on the\n        :attr:`logger`.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.logger.error('Exception on %s [%s]' % (\n            request.path,\n            request.method\n        ), exc_info=exc_info)\n\n    def raise_routing_exception(self, request):\n        \"\"\"Exceptions that are recording during routing are reraised with\n        this method.  During debug we are not reraising redirect requests\n        for non ``GET``, ``HEAD``, or ``OPTIONS`` requests and we're raising\n        a different error instead to help debug situations.\n\n        :internal:\n        \"\"\"\n        if not self.debug \\\n           or not isinstance(request.routing_exception, RequestRedirect) \\\n           or request.method in ('GET', 'HEAD', 'OPTIONS'):\n            raise request.routing_exception\n\n        from .debughelpers import FormDataRoutingRedirect\n        raise FormDataRoutingRedirect(request)\n\n    def dispatch_request(self):\n        \"\"\"Does the request dispatching.  Matches the URL and returns the\n        return value of the view or error handler.  This does not have to\n        be a response object.  In order to convert the return value to a\n        proper response object, call :func:`make_response`.\n\n        .. versionchanged:: 0.7\n           This no longer does the exception handling, this code was\n           moved to the new :meth:`full_dispatch_request`.\n        \"\"\"\n        req = _request_ctx_stack.top.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule = req.url_rule\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if getattr(rule, 'provide_automatic_options', False) \\\n           and req.method == 'OPTIONS':\n            return self.make_default_options_response()\n        # otherwise dispatch to the handler for that endpoint\n        return self.view_functions[rule.endpoint](**req.view_args)\n\n    def full_dispatch_request(self):\n        \"\"\"Dispatches the request and on top of that performs request\n        pre and postprocessing as well as HTTP exception catching and\n        error handling.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self.try_trigger_before_first_request_functions()\n        try:\n            request_started.send(self)\n            rv = self.preprocess_request()\n            if rv is None:\n                rv = self.dispatch_request()\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n\n    def finalize_request(self, rv, from_error_handler=False):\n        \"\"\"Given the return value from a view function this finalizes\n        the request by converting it into a response and invoking the\n        postprocessing functions.  This is invoked for both normal\n        request dispatching as well as error handlers.\n\n        Because this means that it might be called as a result of a\n        failure a special safe mode is available which can be enabled\n        with the `from_error_handler` flag.  If enabled, failures in\n        response processing will be logged and otherwise ignored.\n\n        :internal:\n        \"\"\"\n        response = self.make_response(rv)\n        try:\n            response = self.process_response(response)\n            request_finished.send(self, response=response)\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception('Request finalizing failed with an '\n                                  'error while handling an error')\n        return response\n\n    def try_trigger_before_first_request_functions(self):\n        \"\"\"Called before each request and will ensure that it triggers\n        the :attr:`before_first_request_funcs` and only exactly once per\n        application instance (which means process usually).\n\n        :internal:\n        \"\"\"\n        if self._got_first_request:\n            return\n        with self._before_request_lock:\n            if self._got_first_request:\n                return\n            for func in self.before_first_request_funcs:\n                func()\n            self._got_first_request = True\n\n    def make_default_options_response(self):\n        \"\"\"This method is called to create the default ``OPTIONS`` response.\n        This can be changed through subclassing to change the default\n        behavior of ``OPTIONS`` responses.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        adapter = _request_ctx_stack.top.url_adapter\n        if hasattr(adapter, 'allowed_methods'):\n            methods = adapter.allowed_methods()\n        else:\n            # fallback for Werkzeug < 0.7\n            methods = []\n            try:\n                adapter.match(method='--')\n            except MethodNotAllowed as e:\n                methods = e.valid_methods\n            except HTTPException as e:\n                pass\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n\n    def should_ignore_error(self, error):\n        \"\"\"This is called to figure out if an error should be ignored\n        or not as far as the teardown system is concerned.  If this\n        function returns ``True`` then the teardown handlers will not be\n        passed the error.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return False\n\n    def make_response(self, rv):\n        \"\"\"Convert the return value from a view function to an instance of\n        :attr:`response_class`.\n\n        :param rv: the return value from the view function. The view function\n            must return a response. Returning ``None``, or the view ending\n            without returning, is not allowed. The following types are allowed\n            for ``view_rv``:\n\n            ``str`` (``unicode`` in Python 2)\n                A response object is created with the string encoded to UTF-8\n                as the body.\n\n            ``bytes`` (``str`` in Python 2)\n                A response object is created with the bytes as the body.\n\n            ``tuple``\n                Either ``(body, status, headers)``, ``(body, status)``, or\n                ``(body, headers)``, where ``body`` is any of the other types\n                allowed here, ``status`` is a string or an integer, and\n                ``headers`` is a dictionary or a list of ``(key, value)``\n                tuples. If ``body`` is a :attr:`response_class` instance,\n                ``status`` overwrites the exiting value and ``headers`` are\n                extended.\n\n            :attr:`response_class`\n                The object is returned unchanged.\n\n            other :class:`~werkzeug.wrappers.Response` class\n                The object is coerced to :attr:`response_class`.\n\n            :func:`callable`\n                The function is called as a WSGI application. The result is\n                used to create a response object.\n\n        .. versionchanged:: 0.9\n           Previously a tuple was interpreted as the arguments for the\n           response object.\n        \"\"\"\n\n        status = headers = None\n\n        # unpack tuple returns\n        if isinstance(rv, (tuple, list)):\n            len_rv = len(rv)\n\n            # a 3-tuple is unpacked directly\n            if len_rv == 3:\n                rv, status, headers = rv\n            # decide if a 2-tuple has status or headers\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv\n                else:\n                    rv, status = rv\n            # other sized tuples are not allowed\n            else:\n                raise TypeError(\n                    'The view function did not return a valid response tuple.'\n                    ' The tuple must have the form (body, status, headers),'\n                    ' (body, status), or (body, headers).'\n                )\n\n        # the body must not be None\n        if rv is None:\n            raise TypeError(\n                'The view function did not return a valid response. The'\n                ' function either returned None or ended without a return'\n                ' statement.'\n            )\n\n        # make sure the body is an instance of the response class\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (text_type, bytes, bytearray)):\n                # let the response class set the status and headers instead of\n                # waiting to do it manually, so that the class can handle any\n                # special logic\n                rv = self.response_class(rv, status=status, headers=headers)\n                status = headers = None\n            else:\n                # evaluate a WSGI callable, or coerce a different response\n                # class to the correct type\n                try:\n                    rv = self.response_class.force_type(rv, request.environ)\n                except TypeError as e:\n                    new_error = TypeError(\n                        '{e}\\nThe view function did not return a valid'\n                        ' response. The return type must be a string, tuple,'\n                        ' Response instance, or WSGI callable, but it was a'\n                        ' {rv.__class__.__name__}.'.format(e=e, rv=rv)\n                    )\n                    reraise(TypeError, new_error, sys.exc_info()[2])\n\n        # prefer the status if it was provided\n        if status is not None:\n            if isinstance(status, (text_type, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n\n        # extend existing headers with provided headers\n        if headers:\n            rv.headers.extend(headers)\n\n        return rv\n\n    def create_url_adapter(self, request):\n        \"\"\"Creates a URL adapter for the given request. The URL adapter\n        is created at a point where the request context is not yet set\n        up so the request is passed explicitly.\n\n        .. versionadded:: 0.6\n\n        .. versionchanged:: 0.9\n           This can now also be called without a request object when the\n           URL adapter is created for the application context.\n\n        .. versionchanged:: 1.0\n            :data:`SERVER_NAME` no longer implicitly enables subdomain\n            matching. Use :attr:`subdomain_matching` instead.\n        \"\"\"\n        if request is not None:\n            # If subdomain matching is disabled (the default), use the\n            # default subdomain in all cases. This should be the default\n            # in Werkzeug but it currently does not have that feature.\n            subdomain = ((self.url_map.default_subdomain or None)\n                         if not self.subdomain_matching else None)\n            return self.url_map.bind_to_environ(\n                request.environ,\n                server_name=self.config['SERVER_NAME'],\n                subdomain=subdomain)\n        # We need at the very least the server name to be set for this\n        # to work.\n        if self.config['SERVER_NAME'] is not None:\n            return self.url_map.bind(\n                self.config['SERVER_NAME'],\n                script_name=self.config['APPLICATION_ROOT'],\n                url_scheme=self.config['PREFERRED_URL_SCHEME'])\n\n    def inject_url_defaults(self, endpoint, values):\n        \"\"\"Injects the URL defaults for the given endpoint directly into\n        the values dictionary passed.  This is used internally and\n        automatically called on URL building.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        funcs = self.url_default_functions.get(None, ())\n        if '.' in endpoint:\n            bp = endpoint.rsplit('.', 1)[0]\n            funcs = chain(funcs, self.url_default_functions.get(bp, ()))\n        for func in funcs:\n            func(endpoint, values)\n\n    def handle_url_build_error(self, error, endpoint, values):\n        \"\"\"Handle :class:`~werkzeug.routing.BuildError` on :meth:`url_for`.\n        \"\"\"\n        exc_type, exc_value, tb = sys.exc_info()\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n                if rv is not None:\n                    return rv\n            except BuildError as e:\n                # make error available outside except block (py3)\n                error = e\n\n        # At this point we want to reraise the exception.  If the error is\n        # still the same one we can reraise it with the original traceback,\n        # otherwise we raise it from here.\n        if error is exc_value:\n            reraise(exc_type, exc_value, tb)\n        raise error\n\n    def preprocess_request(self):\n        \"\"\"Called before the request is dispatched. Calls\n        :attr:`url_value_preprocessors` registered with the app and the\n        current blueprint (if any). Then calls :attr:`before_request_funcs`\n        registered with the app and the blueprint.\n\n        If any :meth:`before_request` handler returns a non-None value, the\n        value is handled as if it was the return value from the view, and\n        further request handling is stopped.\n        \"\"\"\n\n        bp = _request_ctx_stack.top.request.blueprint\n\n        funcs = self.url_value_preprocessors.get(None, ())\n        if bp is not None and bp in self.url_value_preprocessors:\n            funcs = chain(funcs, self.url_value_preprocessors[bp])\n        for func in funcs:\n            func(request.endpoint, request.view_args)\n\n        funcs = self.before_request_funcs.get(None, ())\n        if bp is not None and bp in self.before_request_funcs:\n            funcs = chain(funcs, self.before_request_funcs[bp])\n        for func in funcs:\n            rv = func()\n            if rv is not None:\n                return rv\n\n    def process_response(self, response):\n        \"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"\n        ctx = _request_ctx_stack.top\n        bp = ctx.request.blueprint\n        funcs = ctx._after_request_functions\n        if bp is not None and bp in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n        if None in self.after_request_funcs:\n            funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n        for handler in funcs:\n            response = handler(response)\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n        return response\n\n    def do_teardown_request(self, exc=_sentinel):\n        \"\"\"Called after the actual request dispatching and will\n        call every as :meth:`teardown_request` decorated function.  This is\n        not actually called by the :class:`Flask` object itself but is always\n        triggered when the request context is popped.  That way we have a\n        tighter control over certain resources under testing environments.\n\n        .. versionchanged:: 0.9\n           Added the `exc` argument.  Previously this was always using the\n           current exception information.\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        funcs = reversed(self.teardown_request_funcs.get(None, ()))\n        bp = _request_ctx_stack.top.request.blueprint\n        if bp is not None and bp in self.teardown_request_funcs:\n            funcs = chain(funcs, reversed(self.teardown_request_funcs[bp]))\n        for func in funcs:\n            func(exc)\n        request_tearing_down.send(self, exc=exc)\n\n    def do_teardown_appcontext(self, exc=_sentinel):\n        \"\"\"Called when an application context is popped.  This works pretty\n        much the same as :meth:`do_teardown_request` but for the application\n        context.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n        for func in reversed(self.teardown_appcontext_funcs):\n            func(exc)\n        appcontext_tearing_down.send(self, exc=exc)\n\n    def app_context(self):\n        \"\"\"Binds the application only.  For as long as the application is bound\n        to the current context the :data:`flask.current_app` points to that\n        application.  An application context is automatically created when a\n        request context is pushed if necessary.\n\n        Example usage::\n\n            with app.app_context():\n                ...\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n\n    def request_context(self, environ):\n        \"\"\"Creates a :class:`~flask.ctx.RequestContext` from the given\n        environment and binds it to the current context.  This must be used in\n        combination with the ``with`` statement because the request is only bound\n        to the current context for the duration of the ``with`` block.\n\n        Example usage::\n\n            with app.request_context(environ):\n                do_something_with(request)\n\n        The object returned can also be used without the ``with`` statement\n        which is useful for working in the shell.  The example above is\n        doing exactly the same as this code::\n\n            ctx = app.request_context(environ)\n            ctx.push()\n            try:\n                do_something_with(request)\n            finally:\n                ctx.pop()\n\n        .. versionchanged:: 0.3\n           Added support for non-with statement usage and ``with`` statement\n           is now passed the ctx object.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n\n    def test_request_context(self, *args, **kwargs):\n        \"\"\"Creates a :class:`~flask.ctx.RequestContext` from the given values\n        (see :class:`werkzeug.test.EnvironBuilder` for more information, this\n        function accepts the same arguments plus two additional).\n\n        Additional arguments (only if ``base_url`` is not specified):\n\n        :param subdomain: subdomain to use for route matching\n        :param url_scheme: scheme for the request, default\n            ``PREFERRED_URL_SCHEME`` or ``http``.\n        \"\"\"\n\n        from flask.testing import make_test_environ_builder\n\n        builder = make_test_environ_builder(self, *args, **kwargs)\n\n        try:\n            return self.request_context(builder.get_environ())\n        finally:\n            builder.close()\n\n    def wsgi_app(self, environ, start_response):\n        \"\"\"The actual WSGI application.  This is not implemented in\n        `__call__` so that middlewares can be applied without losing a\n        reference to the class.  So instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around and\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n           The behavior of the before and after request callbacks was changed\n           under error conditions and a new callback was added that will\n           always execute at the end of the request, independent on if an\n           error occurred or not.  See :ref:`callbacks-and-errors`.\n\n        :param environ: a WSGI environment\n        :param start_response: a callable accepting a status code,\n                               a list of headers and an optional\n                               exception context to start the response\n        \"\"\"\n        ctx = self.request_context(environ)\n        error = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if self.should_ignore_error(error):\n                error = None\n            ctx.auto_pop(error)\n\n    def __call__(self, environ, start_response):\n        \"\"\"Shortcut for :attr:`wsgi_app`.\"\"\"\n        return self.wsgi_app(environ, start_response)\n\n    def __repr__(self):\n        return '<%s %r>' % (\n            self.__class__.__name__,\n            self.name,\n        )\n", "description": "The Python micro framework for building web applications.", "file_name": "app.py", "language": "Python", "project_name": "flask", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/pallets_flask/pallets-flask-a2ea186/flask/app.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:52:03Z", "url": "https://github.com/pallets/flask", "wiki": false}