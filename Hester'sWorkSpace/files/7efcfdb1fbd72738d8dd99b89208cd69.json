{"author": "humphd", "code": "\n\nimport numpy as np\nimport os\nimport sys\nimport argparse\n\nclass ImageClassifier:\n    def __init__(self, model_dir):\n        self.model_dir = model_dir\n        deploy_file = os.path.join(model_dir, 'deploy.prototxt')\n        weights_file = os.path.join(model_dir, 'snapshot_iter_90.caffemodel')\n        self.net = caffe.Net(deploy_file, caffe.TEST, weights=weights_file)\n\n    def setup(self):\n        mean_file = os.path.join(self.model_dir, 'mean.binaryproto')\n        labels_file = os.path.join(self.model_dir, 'labels.txt')\n\n        self.transformer = caffe.io.Transformer({'data': self.net.blobs['data'].data.shape})\n        self.transformer.set_transpose('data', (2, 0, 1))\n        self.transformer.set_raw_scale('data', 255)\n        self.transformer.set_channel_swap('data', (2, 1, 0))\n\n        \n        with open(mean_file, 'rb') as infile:\n            blob = caffe_pb2.BlobProto()\n            blob.MergeFromString(infile.read())\n            if blob.HasField('shape'):\n                blob_dims = blob.shape\n                assert len(blob_dims) == 4, 'Shape should have 4 dimensions - shape is %s' % blob.shape\n            elif blob.HasField('num') and blob.HasField('channels') and \\\n                    blob.HasField('height') and blob.HasField('width'):\n                blob_dims = (blob.num, blob.channels, blob.height, blob.width)\n            else:\n                raise ValueError('blob does not provide shape or 4d dimensions')\n            pixel = np.reshape(blob.data, blob_dims[1:]).mean(1).mean(1)\n            self.transformer.set_mean('data', pixel)\n\n        \n        # Later we'd grab the label we want based on position (e.g., 0=dolphin, 1=seahorse)\n        self.labels = np.loadtxt(labels_file, str, delimiter='\\n')\n\n    def classify(self, fullpath):\n        \n        image = caffe.io.load_image(fullpath)\n        \n        self.net.blobs['data'].data[...] = self.transformer.preprocess('data', image)\n        \n        out = self.net.forward()\n        \n        softmax_layer = out['softmax']\n        \n        dolphin_prob = softmax_layer.item(0)\n        seahorse_prob = softmax_layer.item(1)\n\n        \n        label = self.labels[0] if dolphin_prob > seahorse_prob else self.labels[1]\n        filename = os.path.basename(fullpath)\n        print '%s is a %s dolphin=%.3f%% seahorse=%.3f%%' % (filename, label, dolphin_prob*100, seahorse_prob*100)\n\ndef setup_caffe(caffe_root):\n    \n    sys.path.insert(0, os.path.join(caffe_root, 'python'))\n    global caffe\n    global caffe_pb2\n    import caffe\n    from caffe.proto import caffe_pb2\n\n    \n    caffe.set_mode_cpu()\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description='Classify images of dolphins and seahorses using trained Caffe model'\n    )\n    parser.add_argument('-c', '--caffe_root', help='CAFFE_ROOT dir, if not defined in env')\n    parser.add_argument('-m', '--model_dir', help='Trained model dir, downloaded from DIGITS')\n    parser.add_argument('-d', '--images_dir', help='Directory of images to classify')\n\n    args = parser.parse_args()\n\n    # Prefer $CAFFE_ROOT in the env if it exists, otherwise get from args\n    caffe_root = os.getenv('CAFFE_ROOT') or args.caffe_root\n    if not caffe_root:\n        print 'Error: Missing CAFFE_ROOT dir. Set env variable or pass via --caffe_root'\n        parser.print_help()\n        sys.exit(1)\n    setup_caffe(caffe_root)\n    \n    model_dir = args.model_dir\n    if not model_dir or not os.path.isdir(model_dir):\n        print 'Error: Unable to find model files. Pass dir via --model_dir'\n        parser.print_help()\n        sys.exit(1)\n    classifier = ImageClassifier(model_dir)\n    classifier.setup()\n\n    \n    cwd = os.path.dirname(os.path.abspath(__file__))\n    untrained_samples = os.path.join(cwd, '..', 'data', 'untrained-samples')\n    images_dir = args.images_dir or untrained_samples\n    if not os.path.isdir(images_dir):\n        print 'Error: Unable to find images for classification. Pass dir via --images_dir'\n        parser.print_help()        \n        sys.exit(1)\n    \n    \n    for filename in os.listdir(images_dir):\n        if filename.endswith('.jpg'):\n            classifier.classify(os.path.join(images_dir, filename))\n\nif __name__ == '__main__':\n    main()\n", "comments": "  python classify samples py  c   repos caffe      data googlenet dolphins seahorses    set mean pixel    this overkill  since 2 labels  might read     later grab label want based position (e g   0 dolphin  1 seahorse)    load image disk using caffe built i o module    preprocess image proper format feeding model    run image pixel data network    extract probabilities two categories final layer    here converting python types ndarray floats    print results  i using labels    load caffe python interface specified path    set caffe use cpu mode work many machines possible     prefer  caffe root env exists  otherwise get args    allow passing images dir  use    data untrained samples default    classify images images dir using trained network ", "content": "# python classify-samples.py -c ~/repos/caffe/ -m ../data/googlenet-dolphins-and-seahorses\n\nimport numpy as np\nimport os\nimport sys\nimport argparse\n\nclass ImageClassifier:\n    def __init__(self, model_dir):\n        self.model_dir = model_dir\n        deploy_file = os.path.join(model_dir, 'deploy.prototxt')\n        weights_file = os.path.join(model_dir, 'snapshot_iter_90.caffemodel')\n        self.net = caffe.Net(deploy_file, caffe.TEST, weights=weights_file)\n\n    def setup(self):\n        mean_file = os.path.join(self.model_dir, 'mean.binaryproto')\n        labels_file = os.path.join(self.model_dir, 'labels.txt')\n\n        self.transformer = caffe.io.Transformer({'data': self.net.blobs['data'].data.shape})\n        self.transformer.set_transpose('data', (2, 0, 1))\n        self.transformer.set_raw_scale('data', 255)\n        self.transformer.set_channel_swap('data', (2, 1, 0))\n\n        # set mean pixel\n        with open(mean_file, 'rb') as infile:\n            blob = caffe_pb2.BlobProto()\n            blob.MergeFromString(infile.read())\n            if blob.HasField('shape'):\n                blob_dims = blob.shape\n                assert len(blob_dims) == 4, 'Shape should have 4 dimensions - shape is %s' % blob.shape\n            elif blob.HasField('num') and blob.HasField('channels') and \\\n                    blob.HasField('height') and blob.HasField('width'):\n                blob_dims = (blob.num, blob.channels, blob.height, blob.width)\n            else:\n                raise ValueError('blob does not provide shape or 4d dimensions')\n            pixel = np.reshape(blob.data, blob_dims[1:]).mean(1).mean(1)\n            self.transformer.set_mean('data', pixel)\n\n        # This is overkill here, since we only have 2 labels, but here's how we might read them.\n        # Later we'd grab the label we want based on position (e.g., 0=dolphin, 1=seahorse)\n        self.labels = np.loadtxt(labels_file, str, delimiter='\\n')\n\n    def classify(self, fullpath):\n        # Load the image from disk using caffe's built-in I/O module\n        image = caffe.io.load_image(fullpath)\n        # Preprocess the image into the proper format for feeding into the model\n        self.net.blobs['data'].data[...] = self.transformer.preprocess('data', image)\n        # Run the image's pixel data through the network\n        out = self.net.forward()\n        # Extract the probabilities of our two categories from the final layer\n        softmax_layer = out['softmax']\n        # Here we're converting to Python types from ndarray floats\n        dolphin_prob = softmax_layer.item(0)\n        seahorse_prob = softmax_layer.item(1)\n\n        # Print the results. I'm using labels\n        label = self.labels[0] if dolphin_prob > seahorse_prob else self.labels[1]\n        filename = os.path.basename(fullpath)\n        print '%s is a %s dolphin=%.3f%% seahorse=%.3f%%' % (filename, label, dolphin_prob*100, seahorse_prob*100)\n\ndef setup_caffe(caffe_root):\n    # Load Caffe's Python interface from the specified path\n    sys.path.insert(0, os.path.join(caffe_root, 'python'))\n    global caffe\n    global caffe_pb2\n    import caffe\n    from caffe.proto import caffe_pb2\n\n    # Set Caffe to use CPU mode so this will work on as many machines as possible.\n    caffe.set_mode_cpu()\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description='Classify images of dolphins and seahorses using trained Caffe model'\n    )\n    parser.add_argument('-c', '--caffe_root', help='CAFFE_ROOT dir, if not defined in env')\n    parser.add_argument('-m', '--model_dir', help='Trained model dir, downloaded from DIGITS')\n    parser.add_argument('-d', '--images_dir', help='Directory of images to classify')\n\n    args = parser.parse_args()\n\n    # Prefer $CAFFE_ROOT in the env if it exists, otherwise get from args\n    caffe_root = os.getenv('CAFFE_ROOT') or args.caffe_root\n    if not caffe_root:\n        print 'Error: Missing CAFFE_ROOT dir. Set env variable or pass via --caffe_root'\n        parser.print_help()\n        sys.exit(1)\n    setup_caffe(caffe_root)\n    \n    model_dir = args.model_dir\n    if not model_dir or not os.path.isdir(model_dir):\n        print 'Error: Unable to find model files. Pass dir via --model_dir'\n        parser.print_help()\n        sys.exit(1)\n    classifier = ImageClassifier(model_dir)\n    classifier.setup()\n\n    # Allow passing images dir, or use ../data/untrained-samples by default\n    cwd = os.path.dirname(os.path.abspath(__file__))\n    untrained_samples = os.path.join(cwd, '..', 'data', 'untrained-samples')\n    images_dir = args.images_dir or untrained_samples\n    if not os.path.isdir(images_dir):\n        print 'Error: Unable to find images for classification. Pass dir via --images_dir'\n        parser.print_help()        \n        sys.exit(1)\n    \n    # Classify all images in images_dir using our trained network\n    for filename in os.listdir(images_dir):\n        if filename.endswith('.jpg'):\n            classifier.classify(os.path.join(images_dir, filename))\n\nif __name__ == '__main__':\n    main()\n", "description": "An absolute beginner's guide to Machine Learning and Image Classification with Neural Networks", "file_name": "classify-samples.py", "id": "7efcfdb1fbd72738d8dd99b89208cd69", "language": "Python", "project_name": "have-fun-with-machine-learning", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/humphd-have-fun-with-machine-learning/humphd-have-fun-with-machine-learning-d48ba5e/src/classify-samples.py", "save_time": "", "source": "", "update_at": "2018-03-17T17:43:15Z", "url": "https://github.com/humphd/have-fun-with-machine-learning", "wiki": true}