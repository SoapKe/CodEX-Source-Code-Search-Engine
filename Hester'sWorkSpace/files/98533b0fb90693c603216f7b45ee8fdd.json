{"author": "HelloZeroNet", "code": "\n This file is part of pyasn1 software.\n\n Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>\n License: http://pyasn1.sf.net/license.html\n\nfrom pyasn1.type import univ\nfrom pyasn1.type import useful\nfrom pyasn1.codec.ber import encoder\nfrom pyasn1.compat.octets import int2oct, str2octs, null\nfrom pyasn1 import error\n\n__all__ = ['encode']\n\n\nclass BooleanEncoder(encoder.IntegerEncoder):\n    def encodeValue(self, encodeFun, client, defMode, maxChunkSize):\n        if client == 0:\n            substrate = (0,)\n        else:\n            substrate = (255,)\n        return substrate, False, False\n\n\nclass BitStringEncoder(encoder.BitStringEncoder):\n    def encodeValue(self, encodeFun, client, defMode, maxChunkSize):\n        return encoder.BitStringEncoder.encodeValue(\n            self, encodeFun, client, defMode, 1000\n        )\n\n\nclass OctetStringEncoder(encoder.OctetStringEncoder):\n    def encodeValue(self, encodeFun, client, defMode, maxChunkSize):\n        return encoder.OctetStringEncoder.encodeValue(\n            self, encodeFun, client, defMode, 1000\n        )\n\n\nclass RealEncoder(encoder.RealEncoder):\n    def _chooseEncBase(self, value):\n        m, b, e = value\n        return self._dropFloatingPoint(m, b, e)\n\n\n specialized GeneralStringEncoder here\n\nclass GeneralizedTimeEncoder(OctetStringEncoder):\n    zchar = str2octs('Z')\n    pluschar = str2octs('+')\n    minuschar = str2octs('-')\n    zero = str2octs('0')\n\n    def encodeValue(self, encodeFun, client, defMode, maxChunkSize):\n        octets = client.asOctets()\n         This breaks too many existing data items\n                if '.' not in octets:\n                    raise error.PyAsn1Error('Format must include fraction of second: %r' % octets)\n        if len(octets) < 15:\n            raise error.PyAsn1Error('Bad UTC time length: %r' % octets)\n        if self.pluschar in octets or self.minuschar in octets:\n            raise error.PyAsn1Error('Must be UTC time: %r' % octets)\n        if octets[-1] != self.zchar[0]:\n            raise error.PyAsn1Error('Missing timezone specifier: %r' % octets)\n        return encoder.OctetStringEncoder.encodeValue(\n            self, encodeFun, client, defMode, 1000\n        )\n\n\nclass UTCTimeEncoder(encoder.OctetStringEncoder):\n    zchar = str2octs('Z')\n    pluschar = str2octs('+')\n    minuschar = str2octs('-')\n\n    def encodeValue(self, encodeFun, client, defMode, maxChunkSize):\n        octets = client.asOctets()\n        if self.pluschar in octets or self.minuschar in octets:\n            raise error.PyAsn1Error('Must be UTC time: %r' % octets)\n        if octets and octets[-1] != self.zchar[0]:\n            client = client.clone(octets + self.zchar)\n        if len(client) != 13:\n            raise error.PyAsn1Error('Bad UTC time length: %r' % client)\n        return encoder.OctetStringEncoder.encodeValue(\n            self, encodeFun, client, defMode, 1000\n        )\n\n\nclass SetOfEncoder(encoder.SequenceOfEncoder):\n    def encodeValue(self, encodeFun, client, defMode, maxChunkSize):\n        client.verifySizeSpec()\n        substrate = null\n        idx = len(client)\n         This is certainly a hack but how else do I distinguish SetOf\n         from Set if they have the same tags&constraints?\n        if isinstance(client, univ.SequenceAndSetBase):\n             Set\n            namedTypes = client.getComponentType()\n            comps = []\n            while idx > 0:\n                idx -= 1\n                if namedTypes[idx].isOptional and not client[idx].isValue:\n                    continue\n                if namedTypes[idx].isDefaulted and client[idx] == namedTypes[idx].asn1Object:\n                    continue\n                comps.append(client[idx])\n            comps.sort(key=lambda x: isinstance(x, univ.Choice) and x.getMinTagSet() or x.tagSet)\n            for c in comps:\n                substrate += encodeFun(c, defMode, maxChunkSize)\n        else:\n             SetOf\n            compSubs = []\n            while idx > 0:\n                idx -= 1\n                compSubs.append(\n                    encodeFun(client[idx], defMode, maxChunkSize)\n                )\n            compSubs.sort()   perhaps padding's not needed\n            substrate = null\n            for compSub in compSubs:\n                substrate += compSub\n        return substrate, True, True\n\n\ntagMap = encoder.tagMap.copy()\ntagMap.update({\n    univ.Boolean.tagSet: BooleanEncoder(),\n    univ.BitString.tagSet: BitStringEncoder(),\n    univ.OctetString.tagSet: OctetStringEncoder(),\n    univ.Real.tagSet: RealEncoder(),\n    useful.GeneralizedTime.tagSet: GeneralizedTimeEncoder(),\n    useful.UTCTime.tagSet: UTCTimeEncoder(),\n    univ.SetOf().tagSet: SetOfEncoder()   conflcts with Set\n})\n\ntypeMap = encoder.typeMap.copy()\ntypeMap.update({\n    univ.Boolean.typeId: BooleanEncoder(),\n    univ.BitString.typeId: BitStringEncoder(),\n    univ.OctetString.typeId: OctetStringEncoder(),\n    univ.Real.typeId: RealEncoder(),\n    useful.GeneralizedTime.typeId: GeneralizedTimeEncoder(),\n    useful.UTCTime.typeId: UTCTimeEncoder(),\n    univ.Set.typeId: SetOfEncoder(),\n    univ.SetOf.typeId: SetOfEncoder()\n})\n\n\nclass Encoder(encoder.Encoder):\n    def __call__(self, client, defMode=False, maxChunkSize=0):\n        return encoder.Encoder.__call__(self, client, defMode, maxChunkSize)\n\n\n: Turns ASN.1 object into CER octet stream.\n:\n: Takes any ASN.1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n: walks all its components recursively and produces a CER octet stream.\n:\n: Parameters\n: ----------\n  value: any pyasn1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n:     A pyasn1 object to encode\n:\n: defMode: :py:class:`bool`\n:     If `False`, produces indefinite length encoding\n:\n: maxChunkSize: :py:class:`int`\n:     Maximum chunk size in chunked encoding mode (0 denotes unlimited chunk size)\n:\n: Returns\n: -------\n: : :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n:     Given ASN.1 object encoded into BER octetstream\n:\n: Raises\n: ------\n: : :py:class:`pyasn1.error.PyAsn1Error`\n:     On encoding errors\nencode = Encoder(tagMap, typeMap)\n\n EncoderFactory queries class instance and builds a map of tags -> encoders\n", "comments": "     this file part pyasn1 software        copyright (c) 2005 2017  ilya etingof  etingof gmail com     license  http   pyasn1 sf net license html       specialized generalstringencoder    this breaks many existing data items               octets                raise error pyasn1error( format must include fraction second   r    octets)    this certainly hack else i distinguish setof    set tags constraints     set    setof    perhaps padding needed    conflcts set     turns asn 1 object cer octet stream          takes asn 1 object (e g   py class   pyasn1 type base pyasn1item  derivative)     walks components recursively produces cer octet stream          parameters                    value  pyasn1 object (e g   py class   pyasn1 type base pyasn1item  derivative)         a pyasn1 object encode         defmode   py class  bool          if  false   produces indefinite length encoding         maxchunksize   py class  int          maximum chunk size chunked encoding mode (0 denotes unlimited chunk size)         returns                    py class  bytes  (python 3)  py class  str  (python 2)         given asn 1 object encoded ber octetstream         raises                   py class  pyasn1 error pyasn1error          on encoding errors    encoderfactory queries class instance builds map tags    encoders ", "content": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>\n# License: http://pyasn1.sf.net/license.html\n#\nfrom pyasn1.type import univ\nfrom pyasn1.type import useful\nfrom pyasn1.codec.ber import encoder\nfrom pyasn1.compat.octets import int2oct, str2octs, null\nfrom pyasn1 import error\n\n__all__ = ['encode']\n\n\nclass BooleanEncoder(encoder.IntegerEncoder):\n    def encodeValue(self, encodeFun, client, defMode, maxChunkSize):\n        if client == 0:\n            substrate = (0,)\n        else:\n            substrate = (255,)\n        return substrate, False, False\n\n\nclass BitStringEncoder(encoder.BitStringEncoder):\n    def encodeValue(self, encodeFun, client, defMode, maxChunkSize):\n        return encoder.BitStringEncoder.encodeValue(\n            self, encodeFun, client, defMode, 1000\n        )\n\n\nclass OctetStringEncoder(encoder.OctetStringEncoder):\n    def encodeValue(self, encodeFun, client, defMode, maxChunkSize):\n        return encoder.OctetStringEncoder.encodeValue(\n            self, encodeFun, client, defMode, 1000\n        )\n\n\nclass RealEncoder(encoder.RealEncoder):\n    def _chooseEncBase(self, value):\n        m, b, e = value\n        return self._dropFloatingPoint(m, b, e)\n\n\n# specialized GeneralStringEncoder here\n\nclass GeneralizedTimeEncoder(OctetStringEncoder):\n    zchar = str2octs('Z')\n    pluschar = str2octs('+')\n    minuschar = str2octs('-')\n    zero = str2octs('0')\n\n    def encodeValue(self, encodeFun, client, defMode, maxChunkSize):\n        octets = client.asOctets()\n        # This breaks too many existing data items\n        #        if '.' not in octets:\n        #            raise error.PyAsn1Error('Format must include fraction of second: %r' % octets)\n        if len(octets) < 15:\n            raise error.PyAsn1Error('Bad UTC time length: %r' % octets)\n        if self.pluschar in octets or self.minuschar in octets:\n            raise error.PyAsn1Error('Must be UTC time: %r' % octets)\n        if octets[-1] != self.zchar[0]:\n            raise error.PyAsn1Error('Missing timezone specifier: %r' % octets)\n        return encoder.OctetStringEncoder.encodeValue(\n            self, encodeFun, client, defMode, 1000\n        )\n\n\nclass UTCTimeEncoder(encoder.OctetStringEncoder):\n    zchar = str2octs('Z')\n    pluschar = str2octs('+')\n    minuschar = str2octs('-')\n\n    def encodeValue(self, encodeFun, client, defMode, maxChunkSize):\n        octets = client.asOctets()\n        if self.pluschar in octets or self.minuschar in octets:\n            raise error.PyAsn1Error('Must be UTC time: %r' % octets)\n        if octets and octets[-1] != self.zchar[0]:\n            client = client.clone(octets + self.zchar)\n        if len(client) != 13:\n            raise error.PyAsn1Error('Bad UTC time length: %r' % client)\n        return encoder.OctetStringEncoder.encodeValue(\n            self, encodeFun, client, defMode, 1000\n        )\n\n\nclass SetOfEncoder(encoder.SequenceOfEncoder):\n    def encodeValue(self, encodeFun, client, defMode, maxChunkSize):\n        client.verifySizeSpec()\n        substrate = null\n        idx = len(client)\n        # This is certainly a hack but how else do I distinguish SetOf\n        # from Set if they have the same tags&constraints?\n        if isinstance(client, univ.SequenceAndSetBase):\n            # Set\n            namedTypes = client.getComponentType()\n            comps = []\n            while idx > 0:\n                idx -= 1\n                if namedTypes[idx].isOptional and not client[idx].isValue:\n                    continue\n                if namedTypes[idx].isDefaulted and client[idx] == namedTypes[idx].asn1Object:\n                    continue\n                comps.append(client[idx])\n            comps.sort(key=lambda x: isinstance(x, univ.Choice) and x.getMinTagSet() or x.tagSet)\n            for c in comps:\n                substrate += encodeFun(c, defMode, maxChunkSize)\n        else:\n            # SetOf\n            compSubs = []\n            while idx > 0:\n                idx -= 1\n                compSubs.append(\n                    encodeFun(client[idx], defMode, maxChunkSize)\n                )\n            compSubs.sort()  # perhaps padding's not needed\n            substrate = null\n            for compSub in compSubs:\n                substrate += compSub\n        return substrate, True, True\n\n\ntagMap = encoder.tagMap.copy()\ntagMap.update({\n    univ.Boolean.tagSet: BooleanEncoder(),\n    univ.BitString.tagSet: BitStringEncoder(),\n    univ.OctetString.tagSet: OctetStringEncoder(),\n    univ.Real.tagSet: RealEncoder(),\n    useful.GeneralizedTime.tagSet: GeneralizedTimeEncoder(),\n    useful.UTCTime.tagSet: UTCTimeEncoder(),\n    univ.SetOf().tagSet: SetOfEncoder()  # conflcts with Set\n})\n\ntypeMap = encoder.typeMap.copy()\ntypeMap.update({\n    univ.Boolean.typeId: BooleanEncoder(),\n    univ.BitString.typeId: BitStringEncoder(),\n    univ.OctetString.typeId: OctetStringEncoder(),\n    univ.Real.typeId: RealEncoder(),\n    useful.GeneralizedTime.typeId: GeneralizedTimeEncoder(),\n    useful.UTCTime.typeId: UTCTimeEncoder(),\n    univ.Set.typeId: SetOfEncoder(),\n    univ.SetOf.typeId: SetOfEncoder()\n})\n\n\nclass Encoder(encoder.Encoder):\n    def __call__(self, client, defMode=False, maxChunkSize=0):\n        return encoder.Encoder.__call__(self, client, defMode, maxChunkSize)\n\n\n#: Turns ASN.1 object into CER octet stream.\n#:\n#: Takes any ASN.1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#: walks all its components recursively and produces a CER octet stream.\n#:\n#: Parameters\n#: ----------\n#  value: any pyasn1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     A pyasn1 object to encode\n#:\n#: defMode: :py:class:`bool`\n#:     If `False`, produces indefinite length encoding\n#:\n#: maxChunkSize: :py:class:`int`\n#:     Maximum chunk size in chunked encoding mode (0 denotes unlimited chunk size)\n#:\n#: Returns\n#: -------\n#: : :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n#:     Given ASN.1 object encoded into BER octetstream\n#:\n#: Raises\n#: ------\n#: : :py:class:`pyasn1.error.PyAsn1Error`\n#:     On encoding errors\nencode = Encoder(tagMap, typeMap)\n\n# EncoderFactory queries class instance and builds a map of tags -> encoders\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "encoder.py", "id": "98533b0fb90693c603216f7b45ee8fdd", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/lib/pyasn1/codec/cer/encoder.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}