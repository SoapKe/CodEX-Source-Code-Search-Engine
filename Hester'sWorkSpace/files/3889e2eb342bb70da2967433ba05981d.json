{"author": "sympy", "code": "\"\"\" Linear Solver for Holonomic Functions\"\"\"\n\nfrom __future__ import print_function, division\n\nfrom sympy.matrices.dense import MutableDenseMatrix\nfrom sympy.utilities.iterables import flatten, numbered_symbols\nfrom sympy.core.symbol import Symbol, Dummy, symbols\nfrom sympy import S\n\n\nclass NewMatrix(MutableDenseMatrix):\n    \"\"\"\n    Supports elements which can't be Sympified.\n    See docstrings in sympy/matrices/matrices.py\n    \"\"\"\n\n    @staticmethod\n    def _sympify(a):\n        return a\n\n    def row_join(self, rhs):\n        from sympy.matrices import MutableMatrix\n        \n        if not self:\n            return type(self)(rhs)\n\n        if self.rows != rhs.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n        newmat = NewMatrix.zeros(self.rows, self.cols + rhs.cols)\n        newmat[:, :self.cols] = self\n        newmat[:, self.cols:] = rhs\n        return type(self)(newmat)\n\n    def col_join(self, bott):\n        from sympy.matrices import MutableMatrix\n        \n        if not self:\n            return type(self)(bott)\n\n        if self.cols != bott.cols:\n            raise ShapeError(\n                \"`self` and `bott` must have the same number of columns.\")\n        newmat = NewMatrix.zeros(self.rows + bott.rows, self.cols)\n        newmat[:self.rows, :] = self\n        newmat[self.rows:, :] = bott\n        return type(self)(newmat)\n\n    def gauss_jordan_solve(self, b, freevar=False):\n        from sympy.matrices import Matrix, zeros\n\n        aug = self.hstack(self.copy(), b.copy())\n        row, col = aug[:, :-1].shape\n\n        \n        A, pivots = aug.rref()\n        A, v = A[:, :-1], A[:, -1]\n        pivots = list(filter(lambda p: p < col, pivots))\n        rank = len(pivots)\n\n        \n        permutation = Matrix(range(col)).T\n        A = A.vstack(A, permutation)\n\n        for i, c in enumerate(pivots):\n            A.col_swap(i, c)\n\n        A, permutation = A[:-1, :], A[-1, :]\n\n        \n        \n        if not v[rank:, 0].is_zero:\n            raise ValueError(\"Linear system has no solution\")\n\n        # Get index of free symbols (free parameters)\n        free_var_index = permutation[len(pivots):]  \n\n        \n        tau = NewMatrix([S(1) for k in range(col - rank)]).reshape(col - rank, 1)\n\n        \n        V = A[:rank, rank:]\n        vt = v[:rank, 0]\n        free_sol = tau.vstack(vt - V*tau, tau)\n\n        \n        sol = NewMatrix.zeros(col, 1)\n        for k, v in enumerate(free_sol):\n            sol[permutation[k], 0] = v\n\n        if freevar:\n            return sol, tau, free_var_index\n        else:\n            return sol, tau\n", "comments": "    linear solver holonomic functions       future   import print function  division  sympy matrices dense import mutabledensematrix sympy utilities iterables import flatten  numbered symbols sympy core symbol import symbol  dummy  symbols sympy import s   class newmatrix(mutabledensematrix)              supports elements sympified      see docstrings sympy matrices matrices py            allows build matrix even null matrix    allows build matrix even null matrix    solve reduced row echelon form    bring block form    check existence solutions    rank aug matrix equal rank coefficient matrix    get index free symbols (free parameters)    non pivots columns free variables    free parameters    full parametric solution    undo permutation ", "content": "\"\"\" Linear Solver for Holonomic Functions\"\"\"\n\nfrom __future__ import print_function, division\n\nfrom sympy.matrices.dense import MutableDenseMatrix\nfrom sympy.utilities.iterables import flatten, numbered_symbols\nfrom sympy.core.symbol import Symbol, Dummy, symbols\nfrom sympy import S\n\n\nclass NewMatrix(MutableDenseMatrix):\n    \"\"\"\n    Supports elements which can't be Sympified.\n    See docstrings in sympy/matrices/matrices.py\n    \"\"\"\n\n    @staticmethod\n    def _sympify(a):\n        return a\n\n    def row_join(self, rhs):\n        from sympy.matrices import MutableMatrix\n        # Allows you to build a matrix even if it is null matrix\n        if not self:\n            return type(self)(rhs)\n\n        if self.rows != rhs.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n        newmat = NewMatrix.zeros(self.rows, self.cols + rhs.cols)\n        newmat[:, :self.cols] = self\n        newmat[:, self.cols:] = rhs\n        return type(self)(newmat)\n\n    def col_join(self, bott):\n        from sympy.matrices import MutableMatrix\n        # Allows you to build a matrix even if it is null matrix\n        if not self:\n            return type(self)(bott)\n\n        if self.cols != bott.cols:\n            raise ShapeError(\n                \"`self` and `bott` must have the same number of columns.\")\n        newmat = NewMatrix.zeros(self.rows + bott.rows, self.cols)\n        newmat[:self.rows, :] = self\n        newmat[self.rows:, :] = bott\n        return type(self)(newmat)\n\n    def gauss_jordan_solve(self, b, freevar=False):\n        from sympy.matrices import Matrix, zeros\n\n        aug = self.hstack(self.copy(), b.copy())\n        row, col = aug[:, :-1].shape\n\n        # solve by reduced row echelon form\n        A, pivots = aug.rref()\n        A, v = A[:, :-1], A[:, -1]\n        pivots = list(filter(lambda p: p < col, pivots))\n        rank = len(pivots)\n\n        # Bring to block form\n        permutation = Matrix(range(col)).T\n        A = A.vstack(A, permutation)\n\n        for i, c in enumerate(pivots):\n            A.col_swap(i, c)\n\n        A, permutation = A[:-1, :], A[-1, :]\n\n        # check for existence of solutions\n        # rank of aug Matrix should be equal to rank of coefficient matrix\n        if not v[rank:, 0].is_zero:\n            raise ValueError(\"Linear system has no solution\")\n\n        # Get index of free symbols (free parameters)\n        free_var_index = permutation[len(pivots):]  # non-pivots columns are free variables\n\n        # Free parameters\n        tau = NewMatrix([S(1) for k in range(col - rank)]).reshape(col - rank, 1)\n\n        # Full parametric solution\n        V = A[:rank, rank:]\n        vt = v[:rank, 0]\n        free_sol = tau.vstack(vt - V*tau, tau)\n\n        # Undo permutation\n        sol = NewMatrix.zeros(col, 1)\n        for k, v in enumerate(free_sol):\n            sol[permutation[k], 0] = v\n\n        if freevar:\n            return sol, tau, free_var_index\n        else:\n            return sol, tau\n", "description": "A computer algebra system written in pure Python", "file_name": "linearsolver.py", "id": "3889e2eb342bb70da2967433ba05981d", "language": "Python", "project_name": "sympy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/sympy-sympy/sympy-sympy-205da79/sympy/holonomic/linearsolver.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:35:56Z", "url": "https://github.com/sympy/sympy", "wiki": true}