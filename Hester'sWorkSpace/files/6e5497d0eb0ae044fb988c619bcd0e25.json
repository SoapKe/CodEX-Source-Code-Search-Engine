{"author": "openai", "code": "\n\nimport json\nimport psutil\nimport time\n\nclass DiagnosticsLogger(object):\n    def __init__(self, interval=5):\n        self.interval = interval\n        self.last_cpu_times = {}  # pid -> (user, sys)\n\n    def run(self):\n        while True:\n            cpu_times, chrome_reset = self.cpu_times()\n            print(json.dumps({\n                'time': time.time(),\n                'cpu_times': cpu_times,\n                'cpu_percent': psutil.cpu_percent(percpu=True),\n                'chrome_reset': chrome_reset,\n            }), flush=True)\n            self.chrome_reset = False\n            time.sleep(self.interval)\n\n    def get_chrome_procs(self):\n        def is_chrome(proc):\n            try:\n                return proc.name() == 'chrome'\n            except psutil.ZombieProcess:\n                return False\n        return [p for p in psutil.process_iter() if is_chrome(p)]\n\n    def cpu_times(self):\n        \n        chrome_procs = self.get_chrome_procs()\n        new_pids = {p.pid for p in chrome_procs}\n        old_pids = {pid for pid in self.last_cpu_times}\n        try:\n            cpu_times = {p.pid: p.cpu_times() for p in chrome_procs}\n        except psutil.NoSuchProcess:\n            \n            return {}, True\n        if new_pids != old_pids:\n            \n            \n            self.last_cpu_times = cpu_times\n            return {}, True\n        \n        ordered_old_times = (self.last_cpu_times[p.pid] for p in chrome_procs)\n        ordered_new_times = (cpu_times[p.pid] for p in chrome_procs)\n        cpu_times_diff = {p.pid: {'user': (t[0] - l[0]) / self.interval, 'sys': (t[1] - l[1]) / self.interval}\n                for (p, t, l) in zip(chrome_procs, ordered_new_times, ordered_old_times)}\n        self.last_cpu_times = cpu_times\n        return cpu_times_diff, False\n\nif __name__ == '__main__':\n    DiagnosticsLogger().run()\n\n", "comments": "    return  pid    user   0 0   sys   0 0    chrome reset         usr bin env python    pid    (user  sys)    chrome restarted since fetching new pids  better luck next time     we know chrome procs restarted     return elapsed time next run     same chrome pids last run  measure elapsed cpu times ", "content": "#!/usr/bin/env python\n\nimport json\nimport psutil\nimport time\n\nclass DiagnosticsLogger(object):\n    def __init__(self, interval=5):\n        self.interval = interval\n        self.last_cpu_times = {}  # pid -> (user, sys)\n\n    def run(self):\n        while True:\n            cpu_times, chrome_reset = self.cpu_times()\n            print(json.dumps({\n                'time': time.time(),\n                'cpu_times': cpu_times,\n                'cpu_percent': psutil.cpu_percent(percpu=True),\n                'chrome_reset': chrome_reset,\n            }), flush=True)\n            self.chrome_reset = False\n            time.sleep(self.interval)\n\n    def get_chrome_procs(self):\n        def is_chrome(proc):\n            try:\n                return proc.name() == 'chrome'\n            except psutil.ZombieProcess:\n                return False\n        return [p for p in psutil.process_iter() if is_chrome(p)]\n\n    def cpu_times(self):\n        ''' return {pid: {'user': 0.0, 'sys': 0.0}}, chrome_reset '''\n        chrome_procs = self.get_chrome_procs()\n        new_pids = {p.pid for p in chrome_procs}\n        old_pids = {pid for pid in self.last_cpu_times}\n        try:\n            cpu_times = {p.pid: p.cpu_times() for p in chrome_procs}\n        except psutil.NoSuchProcess:\n            # Chrome restarted since fetching the new pids above. Better luck next time.\n            return {}, True\n        if new_pids != old_pids:\n            # We don't know when the Chrome procs were restarted, so don't\n            # return elapsed time until next run.\n            self.last_cpu_times = cpu_times\n            return {}, True\n        # Same chrome pids as last run: measure the elapsed cpu times\n        ordered_old_times = (self.last_cpu_times[p.pid] for p in chrome_procs)\n        ordered_new_times = (cpu_times[p.pid] for p in chrome_procs)\n        cpu_times_diff = {p.pid: {'user': (t[0] - l[0]) / self.interval, 'sys': (t[1] - l[1]) / self.interval}\n                for (p, t, l) in zip(chrome_procs, ordered_new_times, ordered_old_times)}\n        self.last_cpu_times = cpu_times\n        return cpu_times_diff, False\n\nif __name__ == '__main__':\n    DiagnosticsLogger().run()\n\n", "description": "Universe: a software platform for measuring and training an AI's general intelligence across the world's supply of games, websites and other applications.", "file_name": "system_diagnostics_logger.py", "id": "6e5497d0eb0ae044fb988c619bcd0e25", "language": "Python", "project_name": "universe", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/openai-universe/openai-universe-f95a5fe/example/system-diagnostics/system_diagnostics_logger.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:39:09Z", "url": "https://github.com/openai/universe", "wiki": true}