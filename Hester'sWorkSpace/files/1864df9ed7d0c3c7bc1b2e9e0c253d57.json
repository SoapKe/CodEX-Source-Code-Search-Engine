{"author": "tensorflow", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n ==============================================================================\nfrom __future__ import print_function\n\nimport h5py\nimport numpy as np\nimport os\nimport tensorflow as tf          used for flags here\n\nfrom utils import write_datasets\nfrom synthetic_data_utils import add_alignment_projections, generate_data\nfrom synthetic_data_utils import generate_rnn, get_train_n_valid_inds\nfrom synthetic_data_utils import nparray_and_transpose\nfrom synthetic_data_utils import spikify_data, gaussify_data, split_list_by_inds\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport scipy.signal\n\nmatplotlib.rcParams['image.interpolation'] = 'nearest'\nDATA_DIR = \"rnn_synth_data_v1.0\"\n\nflags = tf.app.flags\nflags.DEFINE_string(\"save_dir\", \"/tmp/\" + DATA_DIR + \"/\",\n                    \"Directory for saving data.\")\nflags.DEFINE_string(\"datafile_name\", \"thits_data\",\n                    \"Name of data file for input case.\")\nflags.DEFINE_string(\"noise_type\", \"poisson\", \"Noise type for data.\")\nflags.DEFINE_integer(\"synth_data_seed\", 5, \"Random seed for RNN generation.\")\nflags.DEFINE_float(\"T\", 1.0, \"Time in seconds to generate.\")\nflags.DEFINE_integer(\"C\", 100, \"Number of conditions\")\nflags.DEFINE_integer(\"N\", 50, \"Number of units for the RNN\")\nflags.DEFINE_integer(\"S\", 50, \"Number of sampled units from RNN\")\nflags.DEFINE_integer(\"npcs\", 10, \"Number of PCS for multi-session case.\")\nflags.DEFINE_float(\"train_percentage\", 4.0/5.0,\n                   \"Percentage of train vs validation trials\")\nflags.DEFINE_integer(\"nreplications\", 40,\n                     \"Number of noise replications of the same underlying rates.\")\nflags.DEFINE_float(\"g\", 1.5, \"Complexity of dynamics\")\nflags.DEFINE_float(\"x0_std\", 1.0,\n                   \"Volume from which to pull initial conditions (affects diversity of dynamics.\")\nflags.DEFINE_float(\"tau\", 0.025, \"Time constant of RNN\")\nflags.DEFINE_float(\"dt\", 0.010, \"Time bin\")\nflags.DEFINE_float(\"input_magnitude\", 20.0,\n                   \"For the input case, what is the value of the input?\")\nflags.DEFINE_float(\"max_firing_rate\", 30.0, \"Map 1.0 of RNN to a spikes per second\")\nFLAGS = flags.FLAGS\n\n\n Note that with N small, (as it is 25 above), the finite size effects\n will have pretty dramatic effects on the dynamics of the random RNN.\n If you want more complex dynamics, you'll have to run the script a\n lot, or increase N (or g).\n\n Getting hard vs. easy data can be a little stochastic, so we set the seed.\n\n Pull out some commonly used parameters.\n These are user parameters (configuration)\nrng = np.random.RandomState(seed=FLAGS.synth_data_seed)\nT = FLAGS.T\nC = FLAGS.C\nN = FLAGS.N\nS = FLAGS.S\ninput_magnitude = FLAGS.input_magnitude\nnreplications = FLAGS.nreplications\nE = nreplications * C          total number of trials\n S is the number of measurements in each datasets, w/ each\n dataset having a different set of observations.\nndatasets = N/S                  ok if rounded down\ntrain_percentage = FLAGS.train_percentage\nntime_steps = int(T / FLAGS.dt)\n End of user parameters\n\nrnn = generate_rnn(rng, N, FLAGS.g, FLAGS.tau, FLAGS.dt, FLAGS.max_firing_rate)\n\n Check to make sure the RNN is the one we used in the paper.\nif N == 50:\n  assert abs(rnn['W'][0,0] - 0.06239899) < 1e-8, 'Error in random seed?'\n  rem_check = nreplications * train_percentage\n  assert  abs(rem_check - int(rem_check)) < 1e-8, \\\n    'Train percentage  * nreplications should be integral number.'\n\n\n Initial condition generation, and condition label generation.  This\n happens outside of the dataset loop, so that all datasets have the\n same conditions, which is similar to a neurophys setup.\ncondition_number = 0\nx0s = []\ncondition_labels = []\nfor c in range(C):\n  x0 = FLAGS.x0_std * rng.randn(N, 1)\n  x0s.append(np.tile(x0, nreplications))  replicate x0 nreplications times\n   replicate the condition label nreplications times\n  for ns in range(nreplications):\n    condition_labels.append(condition_number)\n  condition_number += 1\nx0s = np.concatenate(x0s, axis=1)\n\n Containers for storing data across data.\ndatasets = {}\nfor n in range(ndatasets):\n  print(n+1, \" of \", ndatasets)\n\n   First generate all firing rates. in the next loop, generate all\n   replications this allows the random state for rate generation to be\n   independent of n_replications.\n  dataset_name = 'dataset_N' + str(N) + '_S' + str(S)\n  if S < N:\n    dataset_name += '_n' + str(n+1)\n\n   Sample neuron subsets.  The assumption is the PC axes of the RNN\n   are not unit aligned, so sampling units is adequate to sample all\n   the high-variance PCs.\n  P_sxn = np.eye(S,N)\n  for m in range(n):\n    P_sxn = np.roll(P_sxn, S, axis=1)\n\n  if input_magnitude > 0.0:\n     time of \"hits\" randomly chosen between [1/4 and 3/4] of total time\n    input_times = rng.choice(int(ntime_steps/2), size=[E]) + int(ntime_steps/4)\n  else:\n    input_times = None\n\n  rates, x0s, inputs = \\\n      generate_data(rnn, T=T, E=E, x0s=x0s, P_sxn=P_sxn,\n                    input_magnitude=input_magnitude,\n                    input_times=input_times)\n\n  if FLAGS.noise_type == \"poisson\":\n    noisy_data = spikify_data(rates, rng, rnn['dt'], rnn['max_firing_rate'])\n  elif FLAGS.noise_type == \"gaussian\":\n    noisy_data = gaussify_data(rates, rng, rnn['dt'], rnn['max_firing_rate'])\n  else:\n    raise ValueError(\"Only noise types supported are poisson or gaussian\")\n\n     split into train and validation sets\n  train_inds, valid_inds = get_train_n_valid_inds(E, train_percentage,\n                                                  nreplications)\n\n   Split the data, inputs, labels and times into train vs. validation.\n  rates_train, rates_valid = \\\n      split_list_by_inds(rates, train_inds, valid_inds)\n  noisy_data_train, noisy_data_valid = \\\n      split_list_by_inds(noisy_data, train_inds, valid_inds)\n  input_train, inputs_valid = \\\n      split_list_by_inds(inputs, train_inds, valid_inds)\n  condition_labels_train, condition_labels_valid = \\\n      split_list_by_inds(condition_labels, train_inds, valid_inds)\n  input_times_train, input_times_valid = \\\n      split_list_by_inds(input_times, train_inds, valid_inds)\n\n   Turn rates, noisy_data, and input into numpy arrays.\n  rates_train = nparray_and_transpose(rates_train)\n  rates_valid = nparray_and_transpose(rates_valid)\n  noisy_data_train = nparray_and_transpose(noisy_data_train)\n  noisy_data_valid = nparray_and_transpose(noisy_data_valid)\n  input_train = nparray_and_transpose(input_train)\n  inputs_valid = nparray_and_transpose(inputs_valid)\n\n   Note that we put these 'truth' rates and input into this\n   structure, the only data that is used in LFADS are the noisy\n   data e.g. spike trains.  The rest is either for printing or posterity.\n  data = {'train_truth': rates_train,\n          'valid_truth': rates_valid,\n          'input_train_truth' : input_train,\n          'input_valid_truth' : inputs_valid,\n          'train_data' : noisy_data_train,\n          'valid_data' : noisy_data_valid,\n          'train_percentage' : train_percentage,\n          'nreplications' : nreplications,\n          'dt' : rnn['dt'],\n          'input_magnitude' : input_magnitude,\n          'input_times_train' : input_times_train,\n          'input_times_valid' : input_times_valid,\n          'P_sxn' : P_sxn,\n          'condition_labels_train' : condition_labels_train,\n          'condition_labels_valid' : condition_labels_valid,\n          'conversion_factor': 1.0 / rnn['conversion_factor']}\n  datasets[dataset_name] = data\n\nif S < N:\n   Note that this isn't necessary for this synthetic example, but\n   it's useful to see how the input factor matrices were initialized\n   for actual neurophysiology data.\n  datasets = add_alignment_projections(datasets, npcs=FLAGS.npcs)\n\n Write out the datasets.\nwrite_datasets(FLAGS.save_dir, FLAGS.datafile_name, datasets)\n", "comments": "  copyright 2017 google inc  all rights reserved        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license           http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license                                                                                          used flags    note n small  (as 25 above)  finite size effects    pretty dramatic effects dynamics random rnn     if want complex dynamics  run script    lot  increase n (or g)     getting hard vs  easy data little stochastic  set seed     pull commonly used parameters     these user parameters (configuration)    total number trials    s number measurements datasets  w     dataset different set observations     ok rounded    end user parameters    check make sure rnn one used paper     initial condition generation  condition label generation   this    happens outside dataset loop  datasets    conditions  similar neurophys setup     replicate x0 nreplications times    replicate condition label nreplications times    containers storing data across data     first generate firing rates  next loop  generate    replications allows random state rate generation    independent n replications     sample neuron subsets   the assumption pc axes rnn    unit aligned  sampling units adequate sample    high variance pcs     time  hits  randomly chosen  1 4 3 4  total time    split train validation sets    split data  inputs  labels times train vs  validation     turn rates  noisy data  input numpy arrays     note put  truth  rates input    structure  data used lfads noisy    data e g  spike trains   the rest either printing posterity     note necessary synthetic example     useful see input factor matrices initialized    actual neurophysiology data     write datasets  ", "content": "# Copyright 2017 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# ==============================================================================\nfrom __future__ import print_function\n\nimport h5py\nimport numpy as np\nimport os\nimport tensorflow as tf         # used for flags here\n\nfrom utils import write_datasets\nfrom synthetic_data_utils import add_alignment_projections, generate_data\nfrom synthetic_data_utils import generate_rnn, get_train_n_valid_inds\nfrom synthetic_data_utils import nparray_and_transpose\nfrom synthetic_data_utils import spikify_data, gaussify_data, split_list_by_inds\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport scipy.signal\n\nmatplotlib.rcParams['image.interpolation'] = 'nearest'\nDATA_DIR = \"rnn_synth_data_v1.0\"\n\nflags = tf.app.flags\nflags.DEFINE_string(\"save_dir\", \"/tmp/\" + DATA_DIR + \"/\",\n                    \"Directory for saving data.\")\nflags.DEFINE_string(\"datafile_name\", \"thits_data\",\n                    \"Name of data file for input case.\")\nflags.DEFINE_string(\"noise_type\", \"poisson\", \"Noise type for data.\")\nflags.DEFINE_integer(\"synth_data_seed\", 5, \"Random seed for RNN generation.\")\nflags.DEFINE_float(\"T\", 1.0, \"Time in seconds to generate.\")\nflags.DEFINE_integer(\"C\", 100, \"Number of conditions\")\nflags.DEFINE_integer(\"N\", 50, \"Number of units for the RNN\")\nflags.DEFINE_integer(\"S\", 50, \"Number of sampled units from RNN\")\nflags.DEFINE_integer(\"npcs\", 10, \"Number of PCS for multi-session case.\")\nflags.DEFINE_float(\"train_percentage\", 4.0/5.0,\n                   \"Percentage of train vs validation trials\")\nflags.DEFINE_integer(\"nreplications\", 40,\n                     \"Number of noise replications of the same underlying rates.\")\nflags.DEFINE_float(\"g\", 1.5, \"Complexity of dynamics\")\nflags.DEFINE_float(\"x0_std\", 1.0,\n                   \"Volume from which to pull initial conditions (affects diversity of dynamics.\")\nflags.DEFINE_float(\"tau\", 0.025, \"Time constant of RNN\")\nflags.DEFINE_float(\"dt\", 0.010, \"Time bin\")\nflags.DEFINE_float(\"input_magnitude\", 20.0,\n                   \"For the input case, what is the value of the input?\")\nflags.DEFINE_float(\"max_firing_rate\", 30.0, \"Map 1.0 of RNN to a spikes per second\")\nFLAGS = flags.FLAGS\n\n\n# Note that with N small, (as it is 25 above), the finite size effects\n# will have pretty dramatic effects on the dynamics of the random RNN.\n# If you want more complex dynamics, you'll have to run the script a\n# lot, or increase N (or g).\n\n# Getting hard vs. easy data can be a little stochastic, so we set the seed.\n\n# Pull out some commonly used parameters.\n# These are user parameters (configuration)\nrng = np.random.RandomState(seed=FLAGS.synth_data_seed)\nT = FLAGS.T\nC = FLAGS.C\nN = FLAGS.N\nS = FLAGS.S\ninput_magnitude = FLAGS.input_magnitude\nnreplications = FLAGS.nreplications\nE = nreplications * C         # total number of trials\n# S is the number of measurements in each datasets, w/ each\n# dataset having a different set of observations.\nndatasets = N/S                 # ok if rounded down\ntrain_percentage = FLAGS.train_percentage\nntime_steps = int(T / FLAGS.dt)\n# End of user parameters\n\nrnn = generate_rnn(rng, N, FLAGS.g, FLAGS.tau, FLAGS.dt, FLAGS.max_firing_rate)\n\n# Check to make sure the RNN is the one we used in the paper.\nif N == 50:\n  assert abs(rnn['W'][0,0] - 0.06239899) < 1e-8, 'Error in random seed?'\n  rem_check = nreplications * train_percentage\n  assert  abs(rem_check - int(rem_check)) < 1e-8, \\\n    'Train percentage  * nreplications should be integral number.'\n\n\n# Initial condition generation, and condition label generation.  This\n# happens outside of the dataset loop, so that all datasets have the\n# same conditions, which is similar to a neurophys setup.\ncondition_number = 0\nx0s = []\ncondition_labels = []\nfor c in range(C):\n  x0 = FLAGS.x0_std * rng.randn(N, 1)\n  x0s.append(np.tile(x0, nreplications)) # replicate x0 nreplications times\n  # replicate the condition label nreplications times\n  for ns in range(nreplications):\n    condition_labels.append(condition_number)\n  condition_number += 1\nx0s = np.concatenate(x0s, axis=1)\n\n# Containers for storing data across data.\ndatasets = {}\nfor n in range(ndatasets):\n  print(n+1, \" of \", ndatasets)\n\n  # First generate all firing rates. in the next loop, generate all\n  # replications this allows the random state for rate generation to be\n  # independent of n_replications.\n  dataset_name = 'dataset_N' + str(N) + '_S' + str(S)\n  if S < N:\n    dataset_name += '_n' + str(n+1)\n\n  # Sample neuron subsets.  The assumption is the PC axes of the RNN\n  # are not unit aligned, so sampling units is adequate to sample all\n  # the high-variance PCs.\n  P_sxn = np.eye(S,N)\n  for m in range(n):\n    P_sxn = np.roll(P_sxn, S, axis=1)\n\n  if input_magnitude > 0.0:\n    # time of \"hits\" randomly chosen between [1/4 and 3/4] of total time\n    input_times = rng.choice(int(ntime_steps/2), size=[E]) + int(ntime_steps/4)\n  else:\n    input_times = None\n\n  rates, x0s, inputs = \\\n      generate_data(rnn, T=T, E=E, x0s=x0s, P_sxn=P_sxn,\n                    input_magnitude=input_magnitude,\n                    input_times=input_times)\n\n  if FLAGS.noise_type == \"poisson\":\n    noisy_data = spikify_data(rates, rng, rnn['dt'], rnn['max_firing_rate'])\n  elif FLAGS.noise_type == \"gaussian\":\n    noisy_data = gaussify_data(rates, rng, rnn['dt'], rnn['max_firing_rate'])\n  else:\n    raise ValueError(\"Only noise types supported are poisson or gaussian\")\n\n    # split into train and validation sets\n  train_inds, valid_inds = get_train_n_valid_inds(E, train_percentage,\n                                                  nreplications)\n\n  # Split the data, inputs, labels and times into train vs. validation.\n  rates_train, rates_valid = \\\n      split_list_by_inds(rates, train_inds, valid_inds)\n  noisy_data_train, noisy_data_valid = \\\n      split_list_by_inds(noisy_data, train_inds, valid_inds)\n  input_train, inputs_valid = \\\n      split_list_by_inds(inputs, train_inds, valid_inds)\n  condition_labels_train, condition_labels_valid = \\\n      split_list_by_inds(condition_labels, train_inds, valid_inds)\n  input_times_train, input_times_valid = \\\n      split_list_by_inds(input_times, train_inds, valid_inds)\n\n  # Turn rates, noisy_data, and input into numpy arrays.\n  rates_train = nparray_and_transpose(rates_train)\n  rates_valid = nparray_and_transpose(rates_valid)\n  noisy_data_train = nparray_and_transpose(noisy_data_train)\n  noisy_data_valid = nparray_and_transpose(noisy_data_valid)\n  input_train = nparray_and_transpose(input_train)\n  inputs_valid = nparray_and_transpose(inputs_valid)\n\n  # Note that we put these 'truth' rates and input into this\n  # structure, the only data that is used in LFADS are the noisy\n  # data e.g. spike trains.  The rest is either for printing or posterity.\n  data = {'train_truth': rates_train,\n          'valid_truth': rates_valid,\n          'input_train_truth' : input_train,\n          'input_valid_truth' : inputs_valid,\n          'train_data' : noisy_data_train,\n          'valid_data' : noisy_data_valid,\n          'train_percentage' : train_percentage,\n          'nreplications' : nreplications,\n          'dt' : rnn['dt'],\n          'input_magnitude' : input_magnitude,\n          'input_times_train' : input_times_train,\n          'input_times_valid' : input_times_valid,\n          'P_sxn' : P_sxn,\n          'condition_labels_train' : condition_labels_train,\n          'condition_labels_valid' : condition_labels_valid,\n          'conversion_factor': 1.0 / rnn['conversion_factor']}\n  datasets[dataset_name] = data\n\nif S < N:\n  # Note that this isn't necessary for this synthetic example, but\n  # it's useful to see how the input factor matrices were initialized\n  # for actual neurophysiology data.\n  datasets = add_alignment_projections(datasets, npcs=FLAGS.npcs)\n\n# Write out the datasets.\nwrite_datasets(FLAGS.save_dir, FLAGS.datafile_name, datasets)\n", "description": "Models and examples built with TensorFlow", "file_name": "generate_chaotic_rnn_data.py", "id": "1864df9ed7d0c3c7bc1b2e9e0c253d57", "language": "Python", "project_name": "models", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tensorflow-models/tensorflow-models-7e4c66b/research/lfads/synth_data/generate_chaotic_rnn_data.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:59:36Z", "url": "https://github.com/tensorflow/models", "wiki": true}