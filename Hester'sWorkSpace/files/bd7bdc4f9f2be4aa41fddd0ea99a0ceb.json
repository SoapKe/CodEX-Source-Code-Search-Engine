{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\nimport hashlib\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    ExtractorError,\n    int_or_none,\n    float_or_none,\n)\n\n\nclass YandexMusicBaseIE(InfoExtractor):\n    @staticmethod\n    def _handle_error(response):\n        if isinstance(response, dict):\n            error = response.get('error')\n            if error:\n                raise ExtractorError(error, expected=True)\n            if response.get('type') == 'captcha' or 'captcha' in response:\n                YandexMusicBaseIE._raise_captcha()\n\n    @staticmethod\n    def _raise_captcha():\n        raise ExtractorError(\n            'YandexMusic has considered youtube-dl requests automated and '\n            'asks you to solve a CAPTCHA. You can either wait for some '\n            'time until unblocked and optionally use --sleep-interval '\n            'in future or alternatively you can go to https://music.yandex.ru/ '\n            'solve CAPTCHA, then export cookies and pass cookie file to '\n            'youtube-dl with --cookies',\n            expected=True)\n\n    def _download_webpage(self, *args, **kwargs):\n        webpage = super(YandexMusicBaseIE, self)._download_webpage(*args, **kwargs)\n        if '\u041d\u0430\u043c \u043e\u0447\u0435\u043d\u044c \u0436\u0430\u043b\u044c, \u043d\u043e&nbsp;\u0437\u0430\u043f\u0440\u043e\u0441\u044b, \u043f\u043e\u0441\u0442\u0443\u043f\u0438\u0432\u0448\u0438\u0435 \u0441&nbsp;\u0432\u0430\u0448\u0435\u0433\u043e IP-\u0430\u0434\u0440\u0435\u0441\u0430, \u043f\u043e\u0445\u043e\u0436\u0438 \u043d\u0430&nbsp;\u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u0435.' in webpage:\n            self._raise_captcha()\n        return webpage\n\n    def _download_json(self, *args, **kwargs):\n        response = super(YandexMusicBaseIE, self)._download_json(*args, **kwargs)\n        self._handle_error(response)\n        return response\n\n\nclass YandexMusicTrackIE(YandexMusicBaseIE):\n    IE_NAME = 'yandexmusic:track'\n    IE_DESC = '\u042f\u043d\u0434\u0435\u043a\u0441.\u041c\u0443\u0437\u044b\u043a\u0430 - \u0422\u0440\u0435\u043a'\n    _VALID_URL = r'https?://music\\.yandex\\.(?:ru|kz|ua|by)/album/(?P<album_id>\\d+)/track/(?P<id>\\d+)'\n\n    _TEST = {\n        'url': 'http://music.yandex.ru/album/540508/track/4878838',\n        'md5': 'f496818aa2f60b6c0062980d2e00dc20',\n        'info_dict': {\n            'id': '4878838',\n            'ext': 'mp3',\n            'title': 'Carlo Ambrosio & Fabio Di Bari, Carlo Ambrosio - Gypsy Eyes 1',\n            'filesize': 4628061,\n            'duration': 193.04,\n            'track': 'Gypsy Eyes 1',\n            'album': 'Gypsy Soul',\n            'album_artist': 'Carlo Ambrosio',\n            'artist': 'Carlo Ambrosio & Fabio Di Bari, Carlo Ambrosio',\n            'release_year': '2009',\n        },\n        'skip': 'Travis CI servers blocked by YandexMusic',\n    }\n\n    def _get_track_url(self, storage_dir, track_id):\n        data = self._download_json(\n            'http://music.yandex.ru/api/v1.5/handlers/api-jsonp.jsx?action=getTrackSrc&p=download-info/%s'\n            % storage_dir,\n            track_id, 'Downloading track location JSON')\n\n        \n        \n        for k, v in data.items():\n            if v and isinstance(v, list):\n                data[k] = v[0]\n\n        key = hashlib.md5(('XGRlBW9FXlekgbPrRHuSiA' + data['path'][1:] + data['s']).encode('utf-8')).hexdigest()\n        storage = storage_dir.split('.')\n\n        return ('http://%s/get-mp3/%s/%s?track-id=%s&from=service-10-track&similarities-experiment=default'\n                % (data['host'], key, data['ts'] + data['path'], storage[1]))\n\n    def _get_track_info(self, track):\n        thumbnail = None\n        cover_uri = track.get('albums', [{}])[0].get('coverUri')\n        if cover_uri:\n            thumbnail = cover_uri.replace('%%', 'orig')\n            if not thumbnail.startswith('http'):\n                thumbnail = 'http://' + thumbnail\n\n        track_title = track['title']\n        track_info = {\n            'id': track['id'],\n            'ext': 'mp3',\n            'url': self._get_track_url(track['storageDir'], track['id']),\n            'filesize': int_or_none(track.get('fileSize')),\n            'duration': float_or_none(track.get('durationMs'), 1000),\n            'thumbnail': thumbnail,\n            'track': track_title,\n        }\n\n        def extract_artist(artist_list):\n            if artist_list and isinstance(artist_list, list):\n                artists_names = [a['name'] for a in artist_list if a.get('name')]\n                if artists_names:\n                    return ', '.join(artists_names)\n\n        albums = track.get('albums')\n        if albums and isinstance(albums, list):\n            album = albums[0]\n            if isinstance(album, dict):\n                year = album.get('year')\n                track_info.update({\n                    'album': album.get('title'),\n                    'album_artist': extract_artist(album.get('artists')),\n                    'release_year': compat_str(year) if year else None,\n                })\n\n        track_artist = extract_artist(track.get('artists'))\n        if track_artist:\n            track_info.update({\n                'artist': track_artist,\n                'title': '%s - %s' % (track_artist, track_title),\n            })\n        else:\n            track_info['title'] = track_title\n        return track_info\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        album_id, track_id = mobj.group('album_id'), mobj.group('id')\n\n        track = self._download_json(\n            'http://music.yandex.ru/handlers/track.jsx?track=%s:%s' % (track_id, album_id),\n            track_id, 'Downloading track JSON')['track']\n\n        return self._get_track_info(track)\n\n\nclass YandexMusicPlaylistBaseIE(YandexMusicBaseIE):\n    def _build_playlist(self, tracks):\n        return [\n            self.url_result(\n                'http://music.yandex.ru/album/%s/track/%s' % (track['albums'][0]['id'], track['id']))\n            for track in tracks if track.get('albums') and isinstance(track.get('albums'), list)]\n\n\nclass YandexMusicAlbumIE(YandexMusicPlaylistBaseIE):\n    IE_NAME = 'yandexmusic:album'\n    IE_DESC = '\u042f\u043d\u0434\u0435\u043a\u0441.\u041c\u0443\u0437\u044b\u043a\u0430 - \u0410\u043b\u044c\u0431\u043e\u043c'\n    _VALID_URL = r'https?://music\\.yandex\\.(?:ru|kz|ua|by)/album/(?P<id>\\d+)/?(\\?|$)'\n\n    _TEST = {\n        'url': 'http://music.yandex.ru/album/540508',\n        'info_dict': {\n            'id': '540508',\n            'title': 'Carlo Ambrosio - Gypsy Soul (2009)',\n        },\n        'playlist_count': 50,\n        'skip': 'Travis CI servers blocked by YandexMusic',\n    }\n\n    def _real_extract(self, url):\n        album_id = self._match_id(url)\n\n        album = self._download_json(\n            'http://music.yandex.ru/handlers/album.jsx?album=%s' % album_id,\n            album_id, 'Downloading album JSON')\n\n        entries = self._build_playlist(album['volumes'][0])\n\n        title = '%s - %s' % (album['artists'][0]['name'], album['title'])\n        year = album.get('year')\n        if year:\n            title += ' (%s)' % year\n\n        return self.playlist_result(entries, compat_str(album['id']), title)\n\n\nclass YandexMusicPlaylistIE(YandexMusicPlaylistBaseIE):\n    IE_NAME = 'yandexmusic:playlist'\n    IE_DESC = '\u042f\u043d\u0434\u0435\u043a\u0441.\u041c\u0443\u0437\u044b\u043a\u0430 - \u041f\u043b\u0435\u0439\u043b\u0438\u0441\u0442'\n    _VALID_URL = r'https?://music\\.yandex\\.(?P<tld>ru|kz|ua|by)/users/(?P<user>[^/]+)/playlists/(?P<id>\\d+)'\n\n    _TESTS = [{\n        'url': 'http://music.yandex.ru/users/music.partners/playlists/1245',\n        'info_dict': {\n            'id': '1245',\n            'title': '\u0427\u0442\u043e \u0441\u043b\u0443\u0448\u0430\u044e\u0442 Enter Shikari',\n            'description': 'md5:3b9f27b0efbe53f2ee1e844d07155cc9',\n        },\n        'playlist_count': 6,\n        'skip': 'Travis CI servers blocked by YandexMusic',\n    }, {\n        \n        \n        'url': 'https://music.yandex.ru/users/ya.playlist/playlists/1036',\n        'info_dict': {\n            'id': '1036',\n            'title': '\u041c\u0443\u0437\u044b\u043a\u0430 90-\u0445',\n        },\n        'playlist_mincount': 300,\n        'skip': 'Travis CI servers blocked by YandexMusic',\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        tld = mobj.group('tld')\n        user = mobj.group('user')\n        playlist_id = mobj.group('id')\n\n        playlist = self._download_json(\n            'https://music.yandex.%s/handlers/playlist.jsx' % tld,\n            playlist_id, 'Downloading missing tracks JSON',\n            fatal=False,\n            headers={\n                'Referer': url,\n                'X-Requested-With': 'XMLHttpRequest',\n                'X-Retpath-Y': url,\n            },\n            query={\n                'owner': user,\n                'kinds': playlist_id,\n                'light': 'true',\n                'lang': tld,\n                'external-domain': 'music.yandex.%s' % tld,\n                'overembed': 'false',\n            })['playlist']\n\n        tracks = playlist['tracks']\n        track_ids = [compat_str(track_id) for track_id in playlist['trackIds']]\n\n        \n        \n        if len(tracks) < len(track_ids):\n            present_track_ids = set([\n                compat_str(track['id'])\n                for track in tracks if track.get('id')])\n            missing_track_ids = [\n                track_id for track_id in track_ids\n                if track_id not in present_track_ids]\n            missing_tracks = self._download_json(\n                'https://music.yandex.%s/handlers/track-entries.jsx' % tld,\n                playlist_id, 'Downloading missing tracks JSON',\n                fatal=False,\n                headers={\n                    'Referer': url,\n                    'X-Requested-With': 'XMLHttpRequest',\n                },\n                query={\n                    'entries': ','.join(missing_track_ids),\n                    'lang': tld,\n                    'external-domain': 'music.yandex.%s' % tld,\n                    'overembed': 'false',\n                    'strict': 'true',\n                })\n            if missing_tracks:\n                tracks.extend(missing_tracks)\n\n        return self.playlist_result(\n            self._build_playlist(tracks),\n            compat_str(playlist_id),\n            playlist.get('title'), playlist.get('description'))\n", "comments": "# coding: utf-8\n# Each string is now wrapped in a list, this is probably only temporarily thus\n# supporting both scenarios (see https://github.com/rg3/youtube-dl/issues/10193)\n# playlist exceeding the limit of 150 tracks shipped with webpage (see\n# https://github.com/rg3/youtube-dl/issues/6666)\n# tracks dictionary shipped with playlist.jsx API is limited to 150 tracks,\n# missing tracks should be retrieved manually.\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\nimport hashlib\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    ExtractorError,\n    int_or_none,\n    float_or_none,\n)\n\n\nclass YandexMusicBaseIE(InfoExtractor):\n    @staticmethod\n    def _handle_error(response):\n        if isinstance(response, dict):\n            error = response.get('error')\n            if error:\n                raise ExtractorError(error, expected=True)\n            if response.get('type') == 'captcha' or 'captcha' in response:\n                YandexMusicBaseIE._raise_captcha()\n\n    @staticmethod\n    def _raise_captcha():\n        raise ExtractorError(\n            'YandexMusic has considered youtube-dl requests automated and '\n            'asks you to solve a CAPTCHA. You can either wait for some '\n            'time until unblocked and optionally use --sleep-interval '\n            'in future or alternatively you can go to https://music.yandex.ru/ '\n            'solve CAPTCHA, then export cookies and pass cookie file to '\n            'youtube-dl with --cookies',\n            expected=True)\n\n    def _download_webpage(self, *args, **kwargs):\n        webpage = super(YandexMusicBaseIE, self)._download_webpage(*args, **kwargs)\n        if '\u041d\u0430\u043c \u043e\u0447\u0435\u043d\u044c \u0436\u0430\u043b\u044c, \u043d\u043e&nbsp;\u0437\u0430\u043f\u0440\u043e\u0441\u044b, \u043f\u043e\u0441\u0442\u0443\u043f\u0438\u0432\u0448\u0438\u0435 \u0441&nbsp;\u0432\u0430\u0448\u0435\u0433\u043e IP-\u0430\u0434\u0440\u0435\u0441\u0430, \u043f\u043e\u0445\u043e\u0436\u0438 \u043d\u0430&nbsp;\u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u0435.' in webpage:\n            self._raise_captcha()\n        return webpage\n\n    def _download_json(self, *args, **kwargs):\n        response = super(YandexMusicBaseIE, self)._download_json(*args, **kwargs)\n        self._handle_error(response)\n        return response\n\n\nclass YandexMusicTrackIE(YandexMusicBaseIE):\n    IE_NAME = 'yandexmusic:track'\n    IE_DESC = '\u042f\u043d\u0434\u0435\u043a\u0441.\u041c\u0443\u0437\u044b\u043a\u0430 - \u0422\u0440\u0435\u043a'\n    _VALID_URL = r'https?://music\\.yandex\\.(?:ru|kz|ua|by)/album/(?P<album_id>\\d+)/track/(?P<id>\\d+)'\n\n    _TEST = {\n        'url': 'http://music.yandex.ru/album/540508/track/4878838',\n        'md5': 'f496818aa2f60b6c0062980d2e00dc20',\n        'info_dict': {\n            'id': '4878838',\n            'ext': 'mp3',\n            'title': 'Carlo Ambrosio & Fabio Di Bari, Carlo Ambrosio - Gypsy Eyes 1',\n            'filesize': 4628061,\n            'duration': 193.04,\n            'track': 'Gypsy Eyes 1',\n            'album': 'Gypsy Soul',\n            'album_artist': 'Carlo Ambrosio',\n            'artist': 'Carlo Ambrosio & Fabio Di Bari, Carlo Ambrosio',\n            'release_year': '2009',\n        },\n        'skip': 'Travis CI servers blocked by YandexMusic',\n    }\n\n    def _get_track_url(self, storage_dir, track_id):\n        data = self._download_json(\n            'http://music.yandex.ru/api/v1.5/handlers/api-jsonp.jsx?action=getTrackSrc&p=download-info/%s'\n            % storage_dir,\n            track_id, 'Downloading track location JSON')\n\n        # Each string is now wrapped in a list, this is probably only temporarily thus\n        # supporting both scenarios (see https://github.com/rg3/youtube-dl/issues/10193)\n        for k, v in data.items():\n            if v and isinstance(v, list):\n                data[k] = v[0]\n\n        key = hashlib.md5(('XGRlBW9FXlekgbPrRHuSiA' + data['path'][1:] + data['s']).encode('utf-8')).hexdigest()\n        storage = storage_dir.split('.')\n\n        return ('http://%s/get-mp3/%s/%s?track-id=%s&from=service-10-track&similarities-experiment=default'\n                % (data['host'], key, data['ts'] + data['path'], storage[1]))\n\n    def _get_track_info(self, track):\n        thumbnail = None\n        cover_uri = track.get('albums', [{}])[0].get('coverUri')\n        if cover_uri:\n            thumbnail = cover_uri.replace('%%', 'orig')\n            if not thumbnail.startswith('http'):\n                thumbnail = 'http://' + thumbnail\n\n        track_title = track['title']\n        track_info = {\n            'id': track['id'],\n            'ext': 'mp3',\n            'url': self._get_track_url(track['storageDir'], track['id']),\n            'filesize': int_or_none(track.get('fileSize')),\n            'duration': float_or_none(track.get('durationMs'), 1000),\n            'thumbnail': thumbnail,\n            'track': track_title,\n        }\n\n        def extract_artist(artist_list):\n            if artist_list and isinstance(artist_list, list):\n                artists_names = [a['name'] for a in artist_list if a.get('name')]\n                if artists_names:\n                    return ', '.join(artists_names)\n\n        albums = track.get('albums')\n        if albums and isinstance(albums, list):\n            album = albums[0]\n            if isinstance(album, dict):\n                year = album.get('year')\n                track_info.update({\n                    'album': album.get('title'),\n                    'album_artist': extract_artist(album.get('artists')),\n                    'release_year': compat_str(year) if year else None,\n                })\n\n        track_artist = extract_artist(track.get('artists'))\n        if track_artist:\n            track_info.update({\n                'artist': track_artist,\n                'title': '%s - %s' % (track_artist, track_title),\n            })\n        else:\n            track_info['title'] = track_title\n        return track_info\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        album_id, track_id = mobj.group('album_id'), mobj.group('id')\n\n        track = self._download_json(\n            'http://music.yandex.ru/handlers/track.jsx?track=%s:%s' % (track_id, album_id),\n            track_id, 'Downloading track JSON')['track']\n\n        return self._get_track_info(track)\n\n\nclass YandexMusicPlaylistBaseIE(YandexMusicBaseIE):\n    def _build_playlist(self, tracks):\n        return [\n            self.url_result(\n                'http://music.yandex.ru/album/%s/track/%s' % (track['albums'][0]['id'], track['id']))\n            for track in tracks if track.get('albums') and isinstance(track.get('albums'), list)]\n\n\nclass YandexMusicAlbumIE(YandexMusicPlaylistBaseIE):\n    IE_NAME = 'yandexmusic:album'\n    IE_DESC = '\u042f\u043d\u0434\u0435\u043a\u0441.\u041c\u0443\u0437\u044b\u043a\u0430 - \u0410\u043b\u044c\u0431\u043e\u043c'\n    _VALID_URL = r'https?://music\\.yandex\\.(?:ru|kz|ua|by)/album/(?P<id>\\d+)/?(\\?|$)'\n\n    _TEST = {\n        'url': 'http://music.yandex.ru/album/540508',\n        'info_dict': {\n            'id': '540508',\n            'title': 'Carlo Ambrosio - Gypsy Soul (2009)',\n        },\n        'playlist_count': 50,\n        'skip': 'Travis CI servers blocked by YandexMusic',\n    }\n\n    def _real_extract(self, url):\n        album_id = self._match_id(url)\n\n        album = self._download_json(\n            'http://music.yandex.ru/handlers/album.jsx?album=%s' % album_id,\n            album_id, 'Downloading album JSON')\n\n        entries = self._build_playlist(album['volumes'][0])\n\n        title = '%s - %s' % (album['artists'][0]['name'], album['title'])\n        year = album.get('year')\n        if year:\n            title += ' (%s)' % year\n\n        return self.playlist_result(entries, compat_str(album['id']), title)\n\n\nclass YandexMusicPlaylistIE(YandexMusicPlaylistBaseIE):\n    IE_NAME = 'yandexmusic:playlist'\n    IE_DESC = '\u042f\u043d\u0434\u0435\u043a\u0441.\u041c\u0443\u0437\u044b\u043a\u0430 - \u041f\u043b\u0435\u0439\u043b\u0438\u0441\u0442'\n    _VALID_URL = r'https?://music\\.yandex\\.(?P<tld>ru|kz|ua|by)/users/(?P<user>[^/]+)/playlists/(?P<id>\\d+)'\n\n    _TESTS = [{\n        'url': 'http://music.yandex.ru/users/music.partners/playlists/1245',\n        'info_dict': {\n            'id': '1245',\n            'title': '\u0427\u0442\u043e \u0441\u043b\u0443\u0448\u0430\u044e\u0442 Enter Shikari',\n            'description': 'md5:3b9f27b0efbe53f2ee1e844d07155cc9',\n        },\n        'playlist_count': 6,\n        'skip': 'Travis CI servers blocked by YandexMusic',\n    }, {\n        # playlist exceeding the limit of 150 tracks shipped with webpage (see\n        # https://github.com/rg3/youtube-dl/issues/6666)\n        'url': 'https://music.yandex.ru/users/ya.playlist/playlists/1036',\n        'info_dict': {\n            'id': '1036',\n            'title': '\u041c\u0443\u0437\u044b\u043a\u0430 90-\u0445',\n        },\n        'playlist_mincount': 300,\n        'skip': 'Travis CI servers blocked by YandexMusic',\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        tld = mobj.group('tld')\n        user = mobj.group('user')\n        playlist_id = mobj.group('id')\n\n        playlist = self._download_json(\n            'https://music.yandex.%s/handlers/playlist.jsx' % tld,\n            playlist_id, 'Downloading missing tracks JSON',\n            fatal=False,\n            headers={\n                'Referer': url,\n                'X-Requested-With': 'XMLHttpRequest',\n                'X-Retpath-Y': url,\n            },\n            query={\n                'owner': user,\n                'kinds': playlist_id,\n                'light': 'true',\n                'lang': tld,\n                'external-domain': 'music.yandex.%s' % tld,\n                'overembed': 'false',\n            })['playlist']\n\n        tracks = playlist['tracks']\n        track_ids = [compat_str(track_id) for track_id in playlist['trackIds']]\n\n        # tracks dictionary shipped with playlist.jsx API is limited to 150 tracks,\n        # missing tracks should be retrieved manually.\n        if len(tracks) < len(track_ids):\n            present_track_ids = set([\n                compat_str(track['id'])\n                for track in tracks if track.get('id')])\n            missing_track_ids = [\n                track_id for track_id in track_ids\n                if track_id not in present_track_ids]\n            missing_tracks = self._download_json(\n                'https://music.yandex.%s/handlers/track-entries.jsx' % tld,\n                playlist_id, 'Downloading missing tracks JSON',\n                fatal=False,\n                headers={\n                    'Referer': url,\n                    'X-Requested-With': 'XMLHttpRequest',\n                },\n                query={\n                    'entries': ','.join(missing_track_ids),\n                    'lang': tld,\n                    'external-domain': 'music.yandex.%s' % tld,\n                    'overembed': 'false',\n                    'strict': 'true',\n                })\n            if missing_tracks:\n                tracks.extend(missing_tracks)\n\n        return self.playlist_result(\n            self._build_playlist(tracks),\n            compat_str(playlist_id),\n            playlist.get('title'), playlist.get('description'))\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "yandexmusic.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/yandexmusic.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}