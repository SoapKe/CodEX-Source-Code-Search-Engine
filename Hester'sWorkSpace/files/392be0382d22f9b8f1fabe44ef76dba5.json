{"author": "HelloZeroNet", "code": "import hashlib\nimport binascii\n\nclass MerkleTools(object):\n    def __init__(self, hash_type=\"sha256\"):\n        hash_type = hash_type.lower()\n        if hash_type == 'sha256':\n            self.hash_function = hashlib.sha256\n        elif hash_type == 'md5':\n            self.hash_function = hashlib.md5\n        elif hash_type == 'sha224':\n            self.hash_function = hashlib.sha224\n        elif hash_type == 'sha384':\n            self.hash_function = hashlib.sha384\n        elif hash_type == 'sha512':\n            self.hash_function = hashlib.sha512\n        elif hash_type == 'sha3_256':\n            self.hash_function = hashlib.sha3_256\n        elif hash_type == 'sha3_224':\n            self.hash_function = hashlib.sha3_224\n        elif hash_type == 'sha3_384':\n            self.hash_function = hashlib.sha3_384\n        elif hash_type == 'sha3_512':\n            self.hash_function = hashlib.sha3_512\n        else:\n            raise Exception('`hash_type` {} nor supported'.format(hash_type))\n\n        self.reset_tree()\n\n    def _to_hex(self, x):\n        try:  \n            return x.hex()\n        except:  \n            return binascii.hexlify(x)\n\n    def reset_tree(self):\n        self.leaves = list()\n        self.levels = None\n        self.is_ready = False\n\n    def add_leaf(self, values, do_hash=False):\n        self.is_ready = False\n        \n        if isinstance(values, tuple) or isinstance(values, list):\n            for v in values:\n                if do_hash:\n                    v = v.encode('utf-8')\n                    v = self.hash_function(v).hexdigest()\n                    v = bytearray.fromhex(v)\n                else:\n                    v = bytearray.fromhex(v)\n                self.leaves.append(v)\n        else:\n            if do_hash:\n                v = values.encode(\"utf-8\")\n                v = self.hash_function(v).hexdigest()\n                v = bytearray.fromhex(v)\n            else:\n                v = bytearray.fromhex(values)\n            self.leaves.append(v)\n\n    def get_leaf(self, index):\n        return self._to_hex(self.leaves[index])\n\n    def get_leaf_count(self):\n        return len(self.leaves)\n\n    def get_tree_ready_state(self):\n        return self.is_ready\n\n    def _calculate_next_level(self):\n        solo_leave = None\n        N = len(self.levels[0])  \n        if N % 2 == 1:  \n            solo_leave = self.levels[0][-1]\n            N -= 1\n\n        new_level = []\n        for l, r in zip(self.levels[0][0:N:2], self.levels[0][1:N:2]):\n            new_level.append(self.hash_function(l+r).digest())\n        if solo_leave is not None:\n            new_level.append(solo_leave)\n        self.levels = [new_level, ] + self.levels  \n\n    def make_tree(self):\n        self.is_ready = False\n        if self.get_leaf_count() > 0:\n            self.levels = [self.leaves, ]\n            while len(self.levels[0]) > 1:\n                self._calculate_next_level()\n        self.is_ready = True\n\n    def get_merkle_root(self):\n        if self.is_ready:\n            if self.levels is not None:\n                return self._to_hex(self.levels[0][0])\n            else:\n                return None\n        else:\n            return None\n\n    def get_proof(self, index):\n        if self.levels is None:\n            return None\n        elif not self.is_ready or index > len(self.leaves)-1 or index < 0:\n            return None\n        else:\n            proof = []\n            for x in range(len(self.levels) - 1, 0, -1):\n                level_len = len(self.levels[x])\n                if (index == level_len - 1) and (level_len % 2 == 1):  \n                    index = int(index / 2.)\n                    continue\n                is_right_node = index % 2\n                sibling_index = index - 1 if is_right_node else index + 1\n                sibling_pos = \"left\" if is_right_node else \"right\"\n                sibling_value = self._to_hex(self.levels[x][sibling_index])\n                proof.append({sibling_pos: sibling_value})\n                index = int(index / 2.)\n            return proof\n\n    def validate_proof(self, proof, target_hash, merkle_root):\n        merkle_root = bytearray.fromhex(merkle_root)\n        target_hash = bytearray.fromhex(target_hash)\n        if len(proof) == 0:\n            return target_hash == merkle_root\n        else:\n            proof_hash = target_hash\n            for p in proof:\n                try:\n                    \n                    sibling = bytearray.fromhex(p['left'])\n                    proof_hash = self.hash_function(sibling + proof_hash).digest()\n                except:\n                    \n                    sibling = bytearray.fromhex(p['right'])\n                    proof_hash = self.hash_function(proof_hash + sibling).digest()\n            return proof_hash == merkle_root\n", "comments": "  python3    python2    check single leaf    number leaves level    odd number leaves level    prepend new level    skip odd end node    sibling left node    sibling right node ", "content": "import hashlib\nimport binascii\n\nclass MerkleTools(object):\n    def __init__(self, hash_type=\"sha256\"):\n        hash_type = hash_type.lower()\n        if hash_type == 'sha256':\n            self.hash_function = hashlib.sha256\n        elif hash_type == 'md5':\n            self.hash_function = hashlib.md5\n        elif hash_type == 'sha224':\n            self.hash_function = hashlib.sha224\n        elif hash_type == 'sha384':\n            self.hash_function = hashlib.sha384\n        elif hash_type == 'sha512':\n            self.hash_function = hashlib.sha512\n        elif hash_type == 'sha3_256':\n            self.hash_function = hashlib.sha3_256\n        elif hash_type == 'sha3_224':\n            self.hash_function = hashlib.sha3_224\n        elif hash_type == 'sha3_384':\n            self.hash_function = hashlib.sha3_384\n        elif hash_type == 'sha3_512':\n            self.hash_function = hashlib.sha3_512\n        else:\n            raise Exception('`hash_type` {} nor supported'.format(hash_type))\n\n        self.reset_tree()\n\n    def _to_hex(self, x):\n        try:  # python3\n            return x.hex()\n        except:  # python2\n            return binascii.hexlify(x)\n\n    def reset_tree(self):\n        self.leaves = list()\n        self.levels = None\n        self.is_ready = False\n\n    def add_leaf(self, values, do_hash=False):\n        self.is_ready = False\n        # check if single leaf\n        if isinstance(values, tuple) or isinstance(values, list):\n            for v in values:\n                if do_hash:\n                    v = v.encode('utf-8')\n                    v = self.hash_function(v).hexdigest()\n                    v = bytearray.fromhex(v)\n                else:\n                    v = bytearray.fromhex(v)\n                self.leaves.append(v)\n        else:\n            if do_hash:\n                v = values.encode(\"utf-8\")\n                v = self.hash_function(v).hexdigest()\n                v = bytearray.fromhex(v)\n            else:\n                v = bytearray.fromhex(values)\n            self.leaves.append(v)\n\n    def get_leaf(self, index):\n        return self._to_hex(self.leaves[index])\n\n    def get_leaf_count(self):\n        return len(self.leaves)\n\n    def get_tree_ready_state(self):\n        return self.is_ready\n\n    def _calculate_next_level(self):\n        solo_leave = None\n        N = len(self.levels[0])  # number of leaves on the level\n        if N % 2 == 1:  # if odd number of leaves on the level\n            solo_leave = self.levels[0][-1]\n            N -= 1\n\n        new_level = []\n        for l, r in zip(self.levels[0][0:N:2], self.levels[0][1:N:2]):\n            new_level.append(self.hash_function(l+r).digest())\n        if solo_leave is not None:\n            new_level.append(solo_leave)\n        self.levels = [new_level, ] + self.levels  # prepend new level\n\n    def make_tree(self):\n        self.is_ready = False\n        if self.get_leaf_count() > 0:\n            self.levels = [self.leaves, ]\n            while len(self.levels[0]) > 1:\n                self._calculate_next_level()\n        self.is_ready = True\n\n    def get_merkle_root(self):\n        if self.is_ready:\n            if self.levels is not None:\n                return self._to_hex(self.levels[0][0])\n            else:\n                return None\n        else:\n            return None\n\n    def get_proof(self, index):\n        if self.levels is None:\n            return None\n        elif not self.is_ready or index > len(self.leaves)-1 or index < 0:\n            return None\n        else:\n            proof = []\n            for x in range(len(self.levels) - 1, 0, -1):\n                level_len = len(self.levels[x])\n                if (index == level_len - 1) and (level_len % 2 == 1):  # skip if this is an odd end node\n                    index = int(index / 2.)\n                    continue\n                is_right_node = index % 2\n                sibling_index = index - 1 if is_right_node else index + 1\n                sibling_pos = \"left\" if is_right_node else \"right\"\n                sibling_value = self._to_hex(self.levels[x][sibling_index])\n                proof.append({sibling_pos: sibling_value})\n                index = int(index / 2.)\n            return proof\n\n    def validate_proof(self, proof, target_hash, merkle_root):\n        merkle_root = bytearray.fromhex(merkle_root)\n        target_hash = bytearray.fromhex(target_hash)\n        if len(proof) == 0:\n            return target_hash == merkle_root\n        else:\n            proof_hash = target_hash\n            for p in proof:\n                try:\n                    # the sibling is a left node\n                    sibling = bytearray.fromhex(p['left'])\n                    proof_hash = self.hash_function(sibling + proof_hash).digest()\n                except:\n                    # the sibling is a right node\n                    sibling = bytearray.fromhex(p['right'])\n                    proof_hash = self.hash_function(proof_hash + sibling).digest()\n            return proof_hash == merkle_root\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "__init__.py", "id": "392be0382d22f9b8f1fabe44ef76dba5", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/lib/merkletools/__init__.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}