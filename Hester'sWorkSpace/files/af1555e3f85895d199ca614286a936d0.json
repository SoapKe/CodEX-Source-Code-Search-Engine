{"author": "pallets", "code": "\n\n        rv = {}\n        for k, v in iteritems(self):\n            if not k.startswith(namespace):\n                continue\n            if trim_namespace:\n                key = k[len(namespace):]\n            else:\n                key = k\n            if lowercase:\n                key = key.lower()\n            rv[key] = v\n        return rv\n\n    def __repr__(self):\n        return '<%s %s>' % (self.__class__.__name__, dict.__repr__(self))\n", "comments": "\n    flask.config\n    ~~~~~~~~~~~~\n\n    Implements the configuration related objects.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport types\nimport errno\n\nfrom werkzeug.utils import import_string\nfrom ._compat import string_types, iteritems\nfrom . import json\n\n\nclass ConfigAttribute(object):\n    \"\"\"Makes an attribute forward to the config\"\"\"\n\n    def __init__(self, name, get_converter=None):\n        self.__name__ = name\n        self.get_converter = get_converter\n\n    def __get__(self, obj, type=None):\n        if obj is None:\n            return self\n        rv = obj.config[self.__name__]\n        if self.get_converter is not None:\n            rv = self.get_converter(rv)\n        return rv\n\n    def __set__(self, obj, value):\n        obj.config[self.__name__] = value\n\n\nclass Config(dict):\n    \"\"\"Works exactly like a dict but provides ways to fill it from files\n    or special dictionaries.  There are two common patterns to populate the\n    config.\n\n    Either you can fill the config from a config file::\n\n        app.config.from_pyfile('yourconfig.cfg')\n\n    Or alternatively you can define the configuration options in the\n    module that calls :meth:`from_object` or provide an import path to\n    a module that should be loaded.  It is also possible to tell it to\n    use the same module and with that provide the configuration values\n    just before the call::\n\n        DEBUG = True\n        SECRET_KEY = 'development key'\n        app.config.from_object(__name__)\n\n    In both cases (loading from any Python file or loading from modules),\n    only uppercase keys are added to the config.  This makes it possible to use\n    lowercase values in the config file for temporary values that are not added\n    to the config or to define the config keys in the same file that implements\n    the application.\n\n    Probably the most interesting way to load configurations is from an\n    environment variable pointing to a file::\n\n        app.config.from_envvar('YOURAPPLICATION_SETTINGS')\n\n    In this case before launching the application you have to set this\n    environment variable to the file you want to use.  On Linux and OS X\n    use the export statement::\n\n        export YOURAPPLICATION_SETTINGS='/path/to/config/file'\n\n    On windows use `set` instead.\n\n    :param root_path: path to which files are read relative from.  When the\n                      config object is created by the application, this is\n                      the application's :attr:`~flask.Flask.root_path`.\n    :param defaults: an optional dictionary of default values\n    \"\"\"\n\n    def __init__(self, root_path, defaults=None):\n        dict.__init__(self, defaults or {})\n        self.root_path = root_path\n\n    def from_envvar(self, variable_name, silent=False):\n        \"\"\"Loads a configuration from an environment variable pointing to\n        a configuration file.  This is basically just a shortcut with nicer\n        error messages for this line of code::\n\n            app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])\n\n        :param variable_name: name of the environment variable\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n        :return: bool. ``True`` if able to load config, ``False`` otherwise.\n        \"\"\"\n        rv = os.environ.get(variable_name)\n        if not rv:\n            if silent:\n                return False\n            raise RuntimeError('The environment variable %r is not set '\n                               'and as such configuration could not be '\n                               'loaded.  Set this variable and make it '\n                               'point to a configuration file' %\n                               variable_name)\n        return self.from_pyfile(rv, silent=silent)\n\n    def from_pyfile(self, filename, silent=False):\n        \"\"\"Updates the values in the config from a Python file.  This function\n        behaves as if the file was imported as module with the\n        :meth:`from_object` function.\n\n        :param filename: the filename of the config.  This can either be an\n                         absolute filename or a filename relative to the\n                         root path.\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n\n        .. versionadded:: 0.7\n           `silent` parameter.\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n        d = types.ModuleType('config')\n        d.__file__ = filename\n        try:\n            with open(filename, mode='rb') as config_file:\n                exec(compile(config_file.read(), filename, 'exec'), d.__dict__)\n        except IOError as e:\n            if silent and e.errno in (\n                errno.ENOENT, errno.EISDIR, errno.ENOTDIR\n            ):\n                return False\n            e.strerror = 'Unable to load configuration file (%s)' % e.strerror\n            raise\n        self.from_object(d)\n        return True\n\n    def from_object(self, obj):\n        \"\"\"Updates the values from the given object.  An object can be of one\n        of the following two types:\n\n        -   a string: in this case the object with that name will be imported\n        -   an actual object reference: that object is used directly\n\n        Objects are usually either modules or classes. :meth:`from_object`\n        loads only the uppercase attributes of the module/class. A ``dict``\n        object will not work with :meth:`from_object` because the keys of a\n        ``dict`` are not attributes of the ``dict`` class.\n\n        Example of module-based configuration::\n\n            app.config.from_object('yourapplication.default_config')\n            from yourapplication import default_config\n            app.config.from_object(default_config)\n\n        You should not use this function to load the actual configuration but\n        rather configuration defaults.  The actual config should be loaded\n        with :meth:`from_pyfile` and ideally from a location not within the\n        package because the package might be installed system wide.\n\n        See :ref:`config-dev-prod` for an example of class-based configuration\n        using :meth:`from_object`.\n\n        :param obj: an import name or object\n        \"\"\"\n        if isinstance(obj, string_types):\n            obj = import_string(obj)\n        for key in dir(obj):\n            if key.isupper():\n                self[key] = getattr(obj, key)\n\n    def from_json(self, filename, silent=False):\n        \"\"\"Updates the values in the config from a JSON file. This function\n        behaves as if the JSON object was a dictionary and passed to the\n        :meth:`from_mapping` function.\n\n        :param filename: the filename of the JSON file.  This can either be an\n                         absolute filename or a filename relative to the\n                         root path.\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n\n        try:\n            with open(filename) as json_file:\n                obj = json.loads(json_file.read())\n        except IOError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n                return False\n            e.strerror = 'Unable to load configuration file (%s)' % e.strerror\n            raise\n        return self.from_mapping(obj)\n\n    def from_mapping(self, *mapping, **kwargs):\n        \"\"\"Updates the config like :meth:`update` ignoring items with non-upper\n        keys.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        mappings = []\n        if len(mapping) == 1:\n            if hasattr(mapping[0], 'items'):\n                mappings.append(mapping[0].items())\n            else:\n                mappings.append(mapping[0])\n        elif len(mapping) > 1:\n            raise TypeError(\n                'expected at most 1 positional argument, got %d' % len(mapping)\n            )\n        mappings.append(kwargs.items())\n        for mapping in mappings:\n            for (key, value) in mapping:\n                if key.isupper():\n                    self[key] = value\n        return True\n\n    def get_namespace(self, namespace, lowercase=True, trim_namespace=True):\n        \"\"\"Returns a dictionary containing a subset of configuration options\n        that match the specified namespace/prefix. Example usage::\n\n            app.config['IMAGE_STORE_TYPE'] = 'fs'\n            app.config['IMAGE_STORE_PATH'] = '/var/app/images'\n            app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'\n            image_store_config = app.config.get_namespace('IMAGE_STORE_')\n\n        The resulting dictionary `image_store_config` would look like::\n\n            {\n                'type': 'fs',\n                'path': '/var/app/images',\n                'base_url': 'http://img.website.com'\n            }\n\n        This is often useful when configuration options map directly to\n        keyword arguments in functions or class constructors.\n\n        :param namespace: a configuration namespace\n        :param lowercase: a flag indicating if the keys of the resulting\n                          dictionary should be lowercase\n        :param trim_namespace: a flag indicating if the keys of the resulting\n                          dictionary should not include the namespace\n\n        .. versionadded:: 0.11\n        \n \n# -*- coding: utf-8 -*-\n", "content": "# -*- coding: utf-8 -*-\n\"\"\"\n    flask.config\n    ~~~~~~~~~~~~\n\n    Implements the configuration related objects.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nimport types\nimport errno\n\nfrom werkzeug.utils import import_string\nfrom ._compat import string_types, iteritems\nfrom . import json\n\n\nclass ConfigAttribute(object):\n    \"\"\"Makes an attribute forward to the config\"\"\"\n\n    def __init__(self, name, get_converter=None):\n        self.__name__ = name\n        self.get_converter = get_converter\n\n    def __get__(self, obj, type=None):\n        if obj is None:\n            return self\n        rv = obj.config[self.__name__]\n        if self.get_converter is not None:\n            rv = self.get_converter(rv)\n        return rv\n\n    def __set__(self, obj, value):\n        obj.config[self.__name__] = value\n\n\nclass Config(dict):\n    \"\"\"Works exactly like a dict but provides ways to fill it from files\n    or special dictionaries.  There are two common patterns to populate the\n    config.\n\n    Either you can fill the config from a config file::\n\n        app.config.from_pyfile('yourconfig.cfg')\n\n    Or alternatively you can define the configuration options in the\n    module that calls :meth:`from_object` or provide an import path to\n    a module that should be loaded.  It is also possible to tell it to\n    use the same module and with that provide the configuration values\n    just before the call::\n\n        DEBUG = True\n        SECRET_KEY = 'development key'\n        app.config.from_object(__name__)\n\n    In both cases (loading from any Python file or loading from modules),\n    only uppercase keys are added to the config.  This makes it possible to use\n    lowercase values in the config file for temporary values that are not added\n    to the config or to define the config keys in the same file that implements\n    the application.\n\n    Probably the most interesting way to load configurations is from an\n    environment variable pointing to a file::\n\n        app.config.from_envvar('YOURAPPLICATION_SETTINGS')\n\n    In this case before launching the application you have to set this\n    environment variable to the file you want to use.  On Linux and OS X\n    use the export statement::\n\n        export YOURAPPLICATION_SETTINGS='/path/to/config/file'\n\n    On windows use `set` instead.\n\n    :param root_path: path to which files are read relative from.  When the\n                      config object is created by the application, this is\n                      the application's :attr:`~flask.Flask.root_path`.\n    :param defaults: an optional dictionary of default values\n    \"\"\"\n\n    def __init__(self, root_path, defaults=None):\n        dict.__init__(self, defaults or {})\n        self.root_path = root_path\n\n    def from_envvar(self, variable_name, silent=False):\n        \"\"\"Loads a configuration from an environment variable pointing to\n        a configuration file.  This is basically just a shortcut with nicer\n        error messages for this line of code::\n\n            app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])\n\n        :param variable_name: name of the environment variable\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n        :return: bool. ``True`` if able to load config, ``False`` otherwise.\n        \"\"\"\n        rv = os.environ.get(variable_name)\n        if not rv:\n            if silent:\n                return False\n            raise RuntimeError('The environment variable %r is not set '\n                               'and as such configuration could not be '\n                               'loaded.  Set this variable and make it '\n                               'point to a configuration file' %\n                               variable_name)\n        return self.from_pyfile(rv, silent=silent)\n\n    def from_pyfile(self, filename, silent=False):\n        \"\"\"Updates the values in the config from a Python file.  This function\n        behaves as if the file was imported as module with the\n        :meth:`from_object` function.\n\n        :param filename: the filename of the config.  This can either be an\n                         absolute filename or a filename relative to the\n                         root path.\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n\n        .. versionadded:: 0.7\n           `silent` parameter.\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n        d = types.ModuleType('config')\n        d.__file__ = filename\n        try:\n            with open(filename, mode='rb') as config_file:\n                exec(compile(config_file.read(), filename, 'exec'), d.__dict__)\n        except IOError as e:\n            if silent and e.errno in (\n                errno.ENOENT, errno.EISDIR, errno.ENOTDIR\n            ):\n                return False\n            e.strerror = 'Unable to load configuration file (%s)' % e.strerror\n            raise\n        self.from_object(d)\n        return True\n\n    def from_object(self, obj):\n        \"\"\"Updates the values from the given object.  An object can be of one\n        of the following two types:\n\n        -   a string: in this case the object with that name will be imported\n        -   an actual object reference: that object is used directly\n\n        Objects are usually either modules or classes. :meth:`from_object`\n        loads only the uppercase attributes of the module/class. A ``dict``\n        object will not work with :meth:`from_object` because the keys of a\n        ``dict`` are not attributes of the ``dict`` class.\n\n        Example of module-based configuration::\n\n            app.config.from_object('yourapplication.default_config')\n            from yourapplication import default_config\n            app.config.from_object(default_config)\n\n        You should not use this function to load the actual configuration but\n        rather configuration defaults.  The actual config should be loaded\n        with :meth:`from_pyfile` and ideally from a location not within the\n        package because the package might be installed system wide.\n\n        See :ref:`config-dev-prod` for an example of class-based configuration\n        using :meth:`from_object`.\n\n        :param obj: an import name or object\n        \"\"\"\n        if isinstance(obj, string_types):\n            obj = import_string(obj)\n        for key in dir(obj):\n            if key.isupper():\n                self[key] = getattr(obj, key)\n\n    def from_json(self, filename, silent=False):\n        \"\"\"Updates the values in the config from a JSON file. This function\n        behaves as if the JSON object was a dictionary and passed to the\n        :meth:`from_mapping` function.\n\n        :param filename: the filename of the JSON file.  This can either be an\n                         absolute filename or a filename relative to the\n                         root path.\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n\n        try:\n            with open(filename) as json_file:\n                obj = json.loads(json_file.read())\n        except IOError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n                return False\n            e.strerror = 'Unable to load configuration file (%s)' % e.strerror\n            raise\n        return self.from_mapping(obj)\n\n    def from_mapping(self, *mapping, **kwargs):\n        \"\"\"Updates the config like :meth:`update` ignoring items with non-upper\n        keys.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        mappings = []\n        if len(mapping) == 1:\n            if hasattr(mapping[0], 'items'):\n                mappings.append(mapping[0].items())\n            else:\n                mappings.append(mapping[0])\n        elif len(mapping) > 1:\n            raise TypeError(\n                'expected at most 1 positional argument, got %d' % len(mapping)\n            )\n        mappings.append(kwargs.items())\n        for mapping in mappings:\n            for (key, value) in mapping:\n                if key.isupper():\n                    self[key] = value\n        return True\n\n    def get_namespace(self, namespace, lowercase=True, trim_namespace=True):\n        \"\"\"Returns a dictionary containing a subset of configuration options\n        that match the specified namespace/prefix. Example usage::\n\n            app.config['IMAGE_STORE_TYPE'] = 'fs'\n            app.config['IMAGE_STORE_PATH'] = '/var/app/images'\n            app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'\n            image_store_config = app.config.get_namespace('IMAGE_STORE_')\n\n        The resulting dictionary `image_store_config` would look like::\n\n            {\n                'type': 'fs',\n                'path': '/var/app/images',\n                'base_url': 'http://img.website.com'\n            }\n\n        This is often useful when configuration options map directly to\n        keyword arguments in functions or class constructors.\n\n        :param namespace: a configuration namespace\n        :param lowercase: a flag indicating if the keys of the resulting\n                          dictionary should be lowercase\n        :param trim_namespace: a flag indicating if the keys of the resulting\n                          dictionary should not include the namespace\n\n        .. versionadded:: 0.11\n        \"\"\"\n        rv = {}\n        for k, v in iteritems(self):\n            if not k.startswith(namespace):\n                continue\n            if trim_namespace:\n                key = k[len(namespace):]\n            else:\n                key = k\n            if lowercase:\n                key = key.lower()\n            rv[key] = v\n        return rv\n\n    def __repr__(self):\n        return '<%s %s>' % (self.__class__.__name__, dict.__repr__(self))\n", "description": "The Python micro framework for building web applications.", "file_name": "config.py", "language": "Python", "project_name": "flask", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/pallets_flask/pallets-flask-a2ea186/flask/config.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:52:03Z", "url": "https://github.com/pallets/flask", "wiki": false}