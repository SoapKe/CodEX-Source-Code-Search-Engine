{"author": "thumbor", "code": "\n# -*- coding: utf-8 -*-\n\n\n\n\n\n\n# Copyright (c) 2011 globo.com thumbor@googlegroups.com\n\nfrom __future__ import print_function\nimport random\nimport unicodedata\nfrom io import BytesIO\nfrom unittest import TestCase as PythonTestCase\nimport mimetypes\nfrom os.path import exists, realpath, dirname, join\nimport mock\n\nfrom PIL import Image\nfrom ssim import compute_ssim\nfrom preggy import create_assertions\nfrom six import StringIO\nfrom six.moves.urllib.parse import urlencode\n\nfrom thumbor.app import ThumborServiceApp\nfrom thumbor.context import Context, RequestParameters\nfrom thumbor.config import Config\nfrom thumbor.importer import Importer\nfrom thumbor.transformer import Transformer\nfrom thumbor.engines.pil import Engine as PilEngine\n\nfrom tornado.testing import AsyncHTTPTestCase\n\ntry:\n    unicode        \nexcept NameError:\n    unicode = str  \n\n\n@create_assertions\ndef to_exist(topic):\n    return exists(topic)\n\n\ndef normalize_unicode_path(path):\n    normalized_path = path\n    for format in ['NFD', 'NFC', 'NFKD', 'NFKC']:\n        normalized_path = unicodedata.normalize(format, unicode(path))\n        if exists(normalized_path):\n            break\n    return normalized_path\n\n\n@create_assertions\ndef to_be_the_same_as(topic, expected):\n    topic = normalize_unicode_path(topic)\n    expected = normalize_unicode_path(expected)\n\n    if not exists(topic):\n        raise AssertionError(\"File at %s does not exist\" % topic)\n    if not exists(expected):\n        raise AssertionError(\"File at %s does not exist\" % expected)\n\n    topic_image = Image.open(topic)\n    expected_image = Image.open(expected)\n\n    return get_ssim(topic_image, expected_image) > 0.95\n\n\n@create_assertions\ndef to_be_similar_to(topic, expected):\n    topic_image = Image.open(StringIO(topic))\n    expected_image = Image.open(StringIO(expected))\n\n    return get_ssim(topic_image, expected_image) > 0.95\n\n\n@create_assertions\ndef to_be_webp(topic):\n    im = Image.open(StringIO(topic))\n    return im.format.lower() == 'webp'\n\n\n@create_assertions\ndef to_be_png(topic):\n    im = Image.open(StringIO(topic))\n    return im.format.lower() == 'png'\n\n\n@create_assertions\ndef to_be_gif(topic):\n    im = Image.open(StringIO(topic))\n    return im.format.lower() == 'gif'\n\n\n@create_assertions\ndef to_be_jpeg(topic):\n    im = Image.open(StringIO(topic))\n    return im.format.lower() == 'jpeg'\n\n\ndef get_ssim(actual, expected):\n    if actual.size[0] != expected.size[0] or actual.size[1] != expected.size[1]:\n        raise RuntimeError(\n            \"Can't calculate SSIM for images of different sizes (one is %dx%d, the other %dx%d).\" % (\n                actual.size[0], actual.size[1],\n                expected.size[0], expected.size[1],\n            )\n        )\n\n    return compute_ssim(actual, expected)\n\n\n@create_assertions\ndef to_be_resized(image):\n    return image.has_resized_properly()\n\n\n@create_assertions\ndef to_be_cropped(image):\n    return image.has_cropped_properly()\n\n\ndef encode_multipart_formdata(fields, files):\n    BOUNDARY = 'thumborUploadFormBoundary'\n    CRLF = '\\r\\n'\n    L = []\n    for key, value in fields.items():\n        L.append('--' + BOUNDARY)\n        L.append('Content-Disposition: form-data; name=\"%s\"' % key)\n        L.append('')\n        L.append(value)\n    for (key, filename, value) in files:\n        L.append('--' + BOUNDARY)\n        L.append('Content-Disposition: form-data; name=\"%s\"; filename=\"%s\"' % (key, filename))\n        L.append('Content-Type: %s' % mimetypes.guess_type(filename)[0] or 'application/octet-stream')\n        L.append('')\n        L.append(value)\n    L.append('')\n    L.append('')\n    L.append('--' + BOUNDARY + '--')\n    body = CRLF.join([str(item) for item in L])\n    content_type = 'multipart/form-data; boundary=%s' % BOUNDARY\n    return content_type, body\n\n\nclass TestCase(AsyncHTTPTestCase):\n    _multiprocess_can_split_ = True\n\n    def get_app(self):\n        self.context = self.get_context()\n        return ThumborServiceApp(self.context)\n\n    def get_config(self):\n        return Config()\n\n    def get_server(self):\n        return None\n\n    def get_importer(self):\n        return None\n\n    def get_request_handler(self):\n        return None\n\n    def get_context(self):\n        self.config = self.get_config()\n        self.server = self.get_server()\n        self.importer = self.get_importer()\n        self.request_handler = self.get_request_handler()\n        return Context(\n            self.server,\n            self.config,\n            self.importer,\n            self.request_handler\n        )\n\n    def get(self, path, headers):\n        return self.fetch(path,\n                          method='GET',\n                          body=urlencode({}, doseq=True),\n                          headers=headers,\n                          allow_nonstandard_methods=True)\n\n    def post(self, path, headers, body):\n        return self.fetch(path,\n                          method='POST',\n                          body=body,\n                          headers=headers,\n                          allow_nonstandard_methods=True)\n\n    def put(self, path, headers, body):\n        return self.fetch(path,\n                          method='PUT',\n                          body=body,\n                          headers=headers,\n                          allow_nonstandard_methods=True)\n\n    def delete(self, path, headers):\n        return self.fetch(path,\n                          method='DELETE',\n                          body=urlencode({}, doseq=True),\n                          headers=headers,\n                          allow_nonstandard_methods=True)\n\n    def post_files(self, path, data={}, files=[]):\n        multipart_data = encode_multipart_formdata(data, files)\n\n        return self.fetch(path,\n                          method='POST',\n                          body=multipart_data[1],\n                          headers={\n                              'Content-Type': multipart_data[0]\n                          },\n                          allow_nonstandard_methods=True)\n\n\nclass FilterTestCase(PythonTestCase):\n    _multiprocess_can_split_ = True\n\n    def setUp(self):\n        self.context = {}\n\n    def get_filter(self, filter_name, params_string=\"\", config_context=None):\n        config = Config(\n            FILTERS=[filter_name],\n            LOADER='thumbor.loaders.file_loader',\n            FILE_LOADER_ROOT_PATH=join(dirname(realpath(__file__)), 'fixtures', 'filters')\n        )\n        importer = Importer(config)\n        importer.import_modules()\n\n        req = RequestParameters()\n\n        context = Context(config=config, importer=importer)\n        context.request = req\n        context.request.engine = context.modules.engine\n\n        if config_context is not None:\n            config_context(context)\n\n        self.context = context\n\n        fltr = importer.filters[0]\n        fltr.pre_compile()\n\n        context.transformer = Transformer(context)\n\n        return fltr(params_string, context=context)\n\n    def get_fixture_path(self, name):\n        return './tests/fixtures/filters/%s' % name\n\n    def get_fixture(self, name):\n        im = Image.open(self.get_fixture_path(name))\n        return im.convert('RGB')\n\n    def get_filtered(self, source_image, filter_name, params_string, config_context=None):\n        fltr = self.get_filter(filter_name, params_string, config_context)\n        im = Image.open(self.get_fixture_path(source_image))\n        img_buffer = BytesIO()\n\n        \n        \n        \n        if params_string == 'quality(10)':\n            im.save(img_buffer, 'JPEG', quality=10)\n            fltr.engine.load(img_buffer.getvalue(), '.jpg')\n        else:\n            im.save(img_buffer, 'PNG', quality=100)\n            fltr.engine.load(img_buffer.getvalue(), '.png')\n\n        fltr.context.transformer.img_operation_worker()\n\n        def dummy_callback(*args):\n            pass\n\n        fltr.run(dummy_callback)\n\n        fltr.engine.image = fltr.engine.image.convert('RGB')\n\n        return fltr.engine.image\n\n    def get_ssim(self, actual, expected):\n        return get_ssim(actual, expected)\n\n    def debug(self, image):\n        im = Image.fromarray(image)\n        path = '/tmp/debug_image_%s.jpg' % random.randint(1, 10000)\n        im.save(path, 'JPEG')\n        print('The debug image was in %s.' % path)\n\n    def debug_size(self, image):\n        im = Image.fromarray(image)\n        print(\"Image dimensions are %dx%d (shape is %s)\" % (im.size[0], im.size[1], image.shape))\n\n\nclass DetectorTestCase(PythonTestCase):\n    _multiprocess_can_split_ = True\n\n    def setUp(self):\n        self.context = mock.Mock(request=mock.Mock(focal_points=[]))\n        self.engine = PilEngine(self.context)\n        self.context.modules.engine = self.engine\n", "comments": "   usr bin python        coding  utf 8        thumbor imaging service    https   github com thumbor thumbor wiki    licensed mit license     http   www opensource org licenses mit license    copyright (c) 2011 globo com thumbor googlegroups com    python 2    python 3    special case quality test  quality filter really affect    image  sets context value use save  but convert result     save ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# thumbor imaging service\n# https://github.com/thumbor/thumbor/wiki\n\n# Licensed under the MIT license:\n# http://www.opensource.org/licenses/mit-license\n# Copyright (c) 2011 globo.com thumbor@googlegroups.com\n\nfrom __future__ import print_function\nimport random\nimport unicodedata\nfrom io import BytesIO\nfrom unittest import TestCase as PythonTestCase\nimport mimetypes\nfrom os.path import exists, realpath, dirname, join\nimport mock\n\nfrom PIL import Image\nfrom ssim import compute_ssim\nfrom preggy import create_assertions\nfrom six import StringIO\nfrom six.moves.urllib.parse import urlencode\n\nfrom thumbor.app import ThumborServiceApp\nfrom thumbor.context import Context, RequestParameters\nfrom thumbor.config import Config\nfrom thumbor.importer import Importer\nfrom thumbor.transformer import Transformer\nfrom thumbor.engines.pil import Engine as PilEngine\n\nfrom tornado.testing import AsyncHTTPTestCase\n\ntry:\n    unicode        # Python 2\nexcept NameError:\n    unicode = str  # Python 3\n\n\n@create_assertions\ndef to_exist(topic):\n    return exists(topic)\n\n\ndef normalize_unicode_path(path):\n    normalized_path = path\n    for format in ['NFD', 'NFC', 'NFKD', 'NFKC']:\n        normalized_path = unicodedata.normalize(format, unicode(path))\n        if exists(normalized_path):\n            break\n    return normalized_path\n\n\n@create_assertions\ndef to_be_the_same_as(topic, expected):\n    topic = normalize_unicode_path(topic)\n    expected = normalize_unicode_path(expected)\n\n    if not exists(topic):\n        raise AssertionError(\"File at %s does not exist\" % topic)\n    if not exists(expected):\n        raise AssertionError(\"File at %s does not exist\" % expected)\n\n    topic_image = Image.open(topic)\n    expected_image = Image.open(expected)\n\n    return get_ssim(topic_image, expected_image) > 0.95\n\n\n@create_assertions\ndef to_be_similar_to(topic, expected):\n    topic_image = Image.open(StringIO(topic))\n    expected_image = Image.open(StringIO(expected))\n\n    return get_ssim(topic_image, expected_image) > 0.95\n\n\n@create_assertions\ndef to_be_webp(topic):\n    im = Image.open(StringIO(topic))\n    return im.format.lower() == 'webp'\n\n\n@create_assertions\ndef to_be_png(topic):\n    im = Image.open(StringIO(topic))\n    return im.format.lower() == 'png'\n\n\n@create_assertions\ndef to_be_gif(topic):\n    im = Image.open(StringIO(topic))\n    return im.format.lower() == 'gif'\n\n\n@create_assertions\ndef to_be_jpeg(topic):\n    im = Image.open(StringIO(topic))\n    return im.format.lower() == 'jpeg'\n\n\ndef get_ssim(actual, expected):\n    if actual.size[0] != expected.size[0] or actual.size[1] != expected.size[1]:\n        raise RuntimeError(\n            \"Can't calculate SSIM for images of different sizes (one is %dx%d, the other %dx%d).\" % (\n                actual.size[0], actual.size[1],\n                expected.size[0], expected.size[1],\n            )\n        )\n\n    return compute_ssim(actual, expected)\n\n\n@create_assertions\ndef to_be_resized(image):\n    return image.has_resized_properly()\n\n\n@create_assertions\ndef to_be_cropped(image):\n    return image.has_cropped_properly()\n\n\ndef encode_multipart_formdata(fields, files):\n    BOUNDARY = 'thumborUploadFormBoundary'\n    CRLF = '\\r\\n'\n    L = []\n    for key, value in fields.items():\n        L.append('--' + BOUNDARY)\n        L.append('Content-Disposition: form-data; name=\"%s\"' % key)\n        L.append('')\n        L.append(value)\n    for (key, filename, value) in files:\n        L.append('--' + BOUNDARY)\n        L.append('Content-Disposition: form-data; name=\"%s\"; filename=\"%s\"' % (key, filename))\n        L.append('Content-Type: %s' % mimetypes.guess_type(filename)[0] or 'application/octet-stream')\n        L.append('')\n        L.append(value)\n    L.append('')\n    L.append('')\n    L.append('--' + BOUNDARY + '--')\n    body = CRLF.join([str(item) for item in L])\n    content_type = 'multipart/form-data; boundary=%s' % BOUNDARY\n    return content_type, body\n\n\nclass TestCase(AsyncHTTPTestCase):\n    _multiprocess_can_split_ = True\n\n    def get_app(self):\n        self.context = self.get_context()\n        return ThumborServiceApp(self.context)\n\n    def get_config(self):\n        return Config()\n\n    def get_server(self):\n        return None\n\n    def get_importer(self):\n        return None\n\n    def get_request_handler(self):\n        return None\n\n    def get_context(self):\n        self.config = self.get_config()\n        self.server = self.get_server()\n        self.importer = self.get_importer()\n        self.request_handler = self.get_request_handler()\n        return Context(\n            self.server,\n            self.config,\n            self.importer,\n            self.request_handler\n        )\n\n    def get(self, path, headers):\n        return self.fetch(path,\n                          method='GET',\n                          body=urlencode({}, doseq=True),\n                          headers=headers,\n                          allow_nonstandard_methods=True)\n\n    def post(self, path, headers, body):\n        return self.fetch(path,\n                          method='POST',\n                          body=body,\n                          headers=headers,\n                          allow_nonstandard_methods=True)\n\n    def put(self, path, headers, body):\n        return self.fetch(path,\n                          method='PUT',\n                          body=body,\n                          headers=headers,\n                          allow_nonstandard_methods=True)\n\n    def delete(self, path, headers):\n        return self.fetch(path,\n                          method='DELETE',\n                          body=urlencode({}, doseq=True),\n                          headers=headers,\n                          allow_nonstandard_methods=True)\n\n    def post_files(self, path, data={}, files=[]):\n        multipart_data = encode_multipart_formdata(data, files)\n\n        return self.fetch(path,\n                          method='POST',\n                          body=multipart_data[1],\n                          headers={\n                              'Content-Type': multipart_data[0]\n                          },\n                          allow_nonstandard_methods=True)\n\n\nclass FilterTestCase(PythonTestCase):\n    _multiprocess_can_split_ = True\n\n    def setUp(self):\n        self.context = {}\n\n    def get_filter(self, filter_name, params_string=\"\", config_context=None):\n        config = Config(\n            FILTERS=[filter_name],\n            LOADER='thumbor.loaders.file_loader',\n            FILE_LOADER_ROOT_PATH=join(dirname(realpath(__file__)), 'fixtures', 'filters')\n        )\n        importer = Importer(config)\n        importer.import_modules()\n\n        req = RequestParameters()\n\n        context = Context(config=config, importer=importer)\n        context.request = req\n        context.request.engine = context.modules.engine\n\n        if config_context is not None:\n            config_context(context)\n\n        self.context = context\n\n        fltr = importer.filters[0]\n        fltr.pre_compile()\n\n        context.transformer = Transformer(context)\n\n        return fltr(params_string, context=context)\n\n    def get_fixture_path(self, name):\n        return './tests/fixtures/filters/%s' % name\n\n    def get_fixture(self, name):\n        im = Image.open(self.get_fixture_path(name))\n        return im.convert('RGB')\n\n    def get_filtered(self, source_image, filter_name, params_string, config_context=None):\n        fltr = self.get_filter(filter_name, params_string, config_context)\n        im = Image.open(self.get_fixture_path(source_image))\n        img_buffer = BytesIO()\n\n        # Special case for the quality test, because the quality filter doesn't really affect\n        # the image, it only sets a context value for use on save. But here we convert the result,\n        # we do not save it\n        if params_string == 'quality(10)':\n            im.save(img_buffer, 'JPEG', quality=10)\n            fltr.engine.load(img_buffer.getvalue(), '.jpg')\n        else:\n            im.save(img_buffer, 'PNG', quality=100)\n            fltr.engine.load(img_buffer.getvalue(), '.png')\n\n        fltr.context.transformer.img_operation_worker()\n\n        def dummy_callback(*args):\n            pass\n\n        fltr.run(dummy_callback)\n\n        fltr.engine.image = fltr.engine.image.convert('RGB')\n\n        return fltr.engine.image\n\n    def get_ssim(self, actual, expected):\n        return get_ssim(actual, expected)\n\n    def debug(self, image):\n        im = Image.fromarray(image)\n        path = '/tmp/debug_image_%s.jpg' % random.randint(1, 10000)\n        im.save(path, 'JPEG')\n        print('The debug image was in %s.' % path)\n\n    def debug_size(self, image):\n        im = Image.fromarray(image)\n        print(\"Image dimensions are %dx%d (shape is %s)\" % (im.size[0], im.size[1], image.shape))\n\n\nclass DetectorTestCase(PythonTestCase):\n    _multiprocess_can_split_ = True\n\n    def setUp(self):\n        self.context = mock.Mock(request=mock.Mock(focal_points=[]))\n        self.engine = PilEngine(self.context)\n        self.context.modules.engine = self.engine\n", "description": "thumbor is an open-source photo thumbnail service by globo.com", "file_name": "base.py", "id": "2906c6088a6abda51389f3cf2333c37f", "language": "Python", "project_name": "thumbor", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/thumbor-thumbor/thumbor-thumbor-991f13c/tests/base.py", "save_time": "", "source": "", "update_at": "2018-03-18T09:16:11Z", "url": "https://github.com/thumbor/thumbor", "wiki": true}