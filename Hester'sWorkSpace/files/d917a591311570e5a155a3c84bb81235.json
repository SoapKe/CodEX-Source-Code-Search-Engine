{"author": "pallets", "code": "\n\n    info = ['Locating template \"%s\":' % template]\n    total_found = 0\n    blueprint = None\n    reqctx = _request_ctx_stack.top\n    if reqctx is not None and reqctx.request.blueprint is not None:\n        blueprint = reqctx.request.blueprint\n\n    for idx, (loader, srcobj, triple) in enumerate(attempts):\n        if isinstance(srcobj, Flask):\n            src_info = 'application \"%s\"' % srcobj.import_name\n        elif isinstance(srcobj, Blueprint):\n            src_info = 'blueprint \"%s\" (%s)' % (srcobj.name,\n                                                srcobj.import_name)\n        else:\n            src_info = repr(srcobj)\n\n        info.append('% 5d: trying loader of %s' % (\n            idx + 1, src_info))\n\n        for line in _dump_loader_info(loader):\n            info.append('       %s' % line)\n\n        if triple is None:\n            detail = 'no match'\n        else:\n            detail = 'found (%r)' % (triple[1] or '<string>')\n            total_found += 1\n        info.append('       -> %s' % detail)\n\n    seems_fishy = False\n    if total_found == 0:\n        info.append('Error: the template could not be found.')\n        seems_fishy = True\n    elif total_found > 1:\n        info.append('Warning: multiple loaders returned a match for the template.')\n        seems_fishy = True\n\n    if blueprint is not None and seems_fishy:\n        info.append('  The template was looked up from an endpoint that '\n                    'belongs to the blueprint \"%s\".' % blueprint)\n        info.append('  Maybe you did not place a template in the right folder?')\n        info.append('  See http://flask.pocoo.org/docs/blueprints/\n\n    app.logger.info('\\n'.join(info))\n\n\ndef explain_ignored_app_run():\n    if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':\n        warn(Warning('Silently ignoring app.run() because the '\n                     'application is run from the flask command line '\n                     'executable.  Consider putting app.run() behind an '\n                     'if __name__ == \"__main__\" guard to silence this '\n                     'warning.'), stacklevel=3)\n", "comments": "\n    flask.debughelpers\n    ~~~~~~~~~~~~~~~~~~\n\n    Various helpers to make the development experience better.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom warnings import warn\n\nfrom ._compat import implements_to_string, text_type\nfrom .app import Flask\nfrom .blueprints import Blueprint\nfrom .globals import _request_ctx_stack\n\n\nclass UnexpectedUnicodeError(AssertionError, UnicodeError):\n    \"\"\"Raised in places where we want some better error reporting for\n    unexpected unicode or binary data.\n    \"\"\"\n\n\n@implements_to_string\nclass DebugFilesKeyError(KeyError, AssertionError):\n    \"\"\"Raised from request.files during debugging.  The idea is that it can\n    provide a better error message than just a generic KeyError/BadRequest.\n    \"\"\"\n\n    def __init__(self, request, key):\n        form_matches = request.form.getlist(key)\n        buf = ['You tried to access the file \"%s\" in the request.files '\n               'dictionary but it does not exist.  The mimetype for the request '\n               'is \"%s\" instead of \"multipart/form-data\" which means that no '\n               'file contents were transmitted.  To fix this error you should '\n               'provide enctype=\"multipart/form-data\" in your form.' %\n               (key, request.mimetype)]\n        if form_matches:\n            buf.append('\\n\\nThe browser instead transmitted some file names. '\n                       'This was submitted: %s' % ', '.join('\"%s\"' % x\n                            for x in form_matches))\n        self.msg = ''.join(buf)\n\n    def __str__(self):\n        return self.msg\n\n\nclass FormDataRoutingRedirect(AssertionError):\n    \"\"\"This exception is raised by Flask in debug mode if it detects a\n    redirect caused by the routing system when the request method is not\n    GET, HEAD or OPTIONS.  Reasoning: form data will be dropped.\n    \"\"\"\n\n    def __init__(self, request):\n        exc = request.routing_exception\n        buf = ['A request was sent to this URL (%s) but a redirect was '\n               'issued automatically by the routing system to \"%s\".'\n               % (request.url, exc.new_url)]\n\n        # In case just a slash was appended we can be extra helpful\n        if request.base_url + '/' == exc.new_url.split('?')[0]:\n            buf.append('  The URL was defined with a trailing slash so '\n                       'Flask will automatically redirect to the URL '\n                       'with the trailing slash if it was accessed '\n                       'without one.')\n\n        buf.append('  Make sure to directly send your %s-request to this URL '\n                   'since we can\\'t make browsers or HTTP clients redirect '\n                   'with form data reliably or without user interaction.' %\n                   request.method)\n        buf.append('\\n\\nNote: this exception is only raised in debug mode')\n        AssertionError.__init__(self, ''.join(buf).encode('utf-8'))\n\n\ndef attach_enctype_error_multidict(request):\n    \"\"\"Since Flask 0.8 we're monkeypatching the files object in case a\n    request is detected that does not use multipart form data but the files\n    object is accessed.\n    \"\"\"\n    oldcls = request.files.__class__\n    class newcls(oldcls):\n        def __getitem__(self, key):\n            try:\n                return oldcls.__getitem__(self, key)\n            except KeyError:\n                if key not in request.form:\n                    raise\n                raise DebugFilesKeyError(request, key)\n    newcls.__name__ = oldcls.__name__\n    newcls.__module__ = oldcls.__module__\n    request.files.__class__ = newcls\n\n\ndef _dump_loader_info(loader):\n    yield 'class: %s.%s' % (type(loader).__module__, type(loader).__name__)\n    for key, value in sorted(loader.__dict__.items()):\n        if key.startswith('_'):\n            continue\n        if isinstance(value, (tuple, list)):\n            if not all(isinstance(x, (str, text_type)) for x in value):\n                continue\n            yield '%s:' % key\n            for item in value:\n                yield '  - %s' % item\n            continue\n        elif not isinstance(value, (str, text_type, int, float, bool)):\n            continue\n        yield '%s: %r' % (key, value)\n\n\ndef explain_template_loading_attempts(app, template, attempts):\n    \"\"\"This should help developers understand what failed\nd\n# -*- coding: utf-8 -*-\n#templates')\n", "content": "# -*- coding: utf-8 -*-\n\"\"\"\n    flask.debughelpers\n    ~~~~~~~~~~~~~~~~~~\n\n    Various helpers to make the development experience better.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport os\nfrom warnings import warn\n\nfrom ._compat import implements_to_string, text_type\nfrom .app import Flask\nfrom .blueprints import Blueprint\nfrom .globals import _request_ctx_stack\n\n\nclass UnexpectedUnicodeError(AssertionError, UnicodeError):\n    \"\"\"Raised in places where we want some better error reporting for\n    unexpected unicode or binary data.\n    \"\"\"\n\n\n@implements_to_string\nclass DebugFilesKeyError(KeyError, AssertionError):\n    \"\"\"Raised from request.files during debugging.  The idea is that it can\n    provide a better error message than just a generic KeyError/BadRequest.\n    \"\"\"\n\n    def __init__(self, request, key):\n        form_matches = request.form.getlist(key)\n        buf = ['You tried to access the file \"%s\" in the request.files '\n               'dictionary but it does not exist.  The mimetype for the request '\n               'is \"%s\" instead of \"multipart/form-data\" which means that no '\n               'file contents were transmitted.  To fix this error you should '\n               'provide enctype=\"multipart/form-data\" in your form.' %\n               (key, request.mimetype)]\n        if form_matches:\n            buf.append('\\n\\nThe browser instead transmitted some file names. '\n                       'This was submitted: %s' % ', '.join('\"%s\"' % x\n                            for x in form_matches))\n        self.msg = ''.join(buf)\n\n    def __str__(self):\n        return self.msg\n\n\nclass FormDataRoutingRedirect(AssertionError):\n    \"\"\"This exception is raised by Flask in debug mode if it detects a\n    redirect caused by the routing system when the request method is not\n    GET, HEAD or OPTIONS.  Reasoning: form data will be dropped.\n    \"\"\"\n\n    def __init__(self, request):\n        exc = request.routing_exception\n        buf = ['A request was sent to this URL (%s) but a redirect was '\n               'issued automatically by the routing system to \"%s\".'\n               % (request.url, exc.new_url)]\n\n        # In case just a slash was appended we can be extra helpful\n        if request.base_url + '/' == exc.new_url.split('?')[0]:\n            buf.append('  The URL was defined with a trailing slash so '\n                       'Flask will automatically redirect to the URL '\n                       'with the trailing slash if it was accessed '\n                       'without one.')\n\n        buf.append('  Make sure to directly send your %s-request to this URL '\n                   'since we can\\'t make browsers or HTTP clients redirect '\n                   'with form data reliably or without user interaction.' %\n                   request.method)\n        buf.append('\\n\\nNote: this exception is only raised in debug mode')\n        AssertionError.__init__(self, ''.join(buf).encode('utf-8'))\n\n\ndef attach_enctype_error_multidict(request):\n    \"\"\"Since Flask 0.8 we're monkeypatching the files object in case a\n    request is detected that does not use multipart form data but the files\n    object is accessed.\n    \"\"\"\n    oldcls = request.files.__class__\n    class newcls(oldcls):\n        def __getitem__(self, key):\n            try:\n                return oldcls.__getitem__(self, key)\n            except KeyError:\n                if key not in request.form:\n                    raise\n                raise DebugFilesKeyError(request, key)\n    newcls.__name__ = oldcls.__name__\n    newcls.__module__ = oldcls.__module__\n    request.files.__class__ = newcls\n\n\ndef _dump_loader_info(loader):\n    yield 'class: %s.%s' % (type(loader).__module__, type(loader).__name__)\n    for key, value in sorted(loader.__dict__.items()):\n        if key.startswith('_'):\n            continue\n        if isinstance(value, (tuple, list)):\n            if not all(isinstance(x, (str, text_type)) for x in value):\n                continue\n            yield '%s:' % key\n            for item in value:\n                yield '  - %s' % item\n            continue\n        elif not isinstance(value, (str, text_type, int, float, bool)):\n            continue\n        yield '%s: %r' % (key, value)\n\n\ndef explain_template_loading_attempts(app, template, attempts):\n    \"\"\"This should help developers understand what failed\"\"\"\n    info = ['Locating template \"%s\":' % template]\n    total_found = 0\n    blueprint = None\n    reqctx = _request_ctx_stack.top\n    if reqctx is not None and reqctx.request.blueprint is not None:\n        blueprint = reqctx.request.blueprint\n\n    for idx, (loader, srcobj, triple) in enumerate(attempts):\n        if isinstance(srcobj, Flask):\n            src_info = 'application \"%s\"' % srcobj.import_name\n        elif isinstance(srcobj, Blueprint):\n            src_info = 'blueprint \"%s\" (%s)' % (srcobj.name,\n                                                srcobj.import_name)\n        else:\n            src_info = repr(srcobj)\n\n        info.append('% 5d: trying loader of %s' % (\n            idx + 1, src_info))\n\n        for line in _dump_loader_info(loader):\n            info.append('       %s' % line)\n\n        if triple is None:\n            detail = 'no match'\n        else:\n            detail = 'found (%r)' % (triple[1] or '<string>')\n            total_found += 1\n        info.append('       -> %s' % detail)\n\n    seems_fishy = False\n    if total_found == 0:\n        info.append('Error: the template could not be found.')\n        seems_fishy = True\n    elif total_found > 1:\n        info.append('Warning: multiple loaders returned a match for the template.')\n        seems_fishy = True\n\n    if blueprint is not None and seems_fishy:\n        info.append('  The template was looked up from an endpoint that '\n                    'belongs to the blueprint \"%s\".' % blueprint)\n        info.append('  Maybe you did not place a template in the right folder?')\n        info.append('  See http://flask.pocoo.org/docs/blueprints/#templates')\n\n    app.logger.info('\\n'.join(info))\n\n\ndef explain_ignored_app_run():\n    if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':\n        warn(Warning('Silently ignoring app.run() because the '\n                     'application is run from the flask command line '\n                     'executable.  Consider putting app.run() behind an '\n                     'if __name__ == \"__main__\" guard to silence this '\n                     'warning.'), stacklevel=3)\n", "description": "The Python micro framework for building web applications.", "file_name": "debughelpers.py", "language": "Python", "project_name": "flask", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/pallets_flask/pallets-flask-a2ea186/flask/debughelpers.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:52:03Z", "url": "https://github.com/pallets/flask", "wiki": false}