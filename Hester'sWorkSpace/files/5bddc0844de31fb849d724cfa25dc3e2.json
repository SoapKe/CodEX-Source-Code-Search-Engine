{"author": "ansible", "code": "\n# -*- coding: utf-8 -*-\n# Copyright (c) 2018 Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'network'}\n\nDOCUMENTATION = \"\"\"\n---\nmodule: edgeos_config\nversion_added: \"2.5\"\nauthor:\n    - \"Nathaniel Case (@qalthos)\"\n    - \"Sam Doran (@samdoran)\"\nshort_description: Manage EdgeOS configuration on remote device\ndescription:\n  - This module provides configuration file management of EdgeOS\n    devices. It provides arguments for managing both the\n    configuration file and state of the active configuration. All\n    configuration statements are based on `set` and `delete` commands\n    in the device configuration.\nnotes:\n  - Tested against EdgeOS 1.9.7\n  - Setting C(ANSIBLE_PERSISTENT_COMMAND_TIMEOUT) to 30 is recommended since\n    the save command can take longer than the default of 10 seconds on\n    some EdgeOS hardware.\noptions:\n  lines:\n    description:\n      - The ordered set of configuration lines to be managed and\n        compared with the existing configuration on the remote\n        device.\n  src:\n    description:\n      - The C(src) argument specifies the path to the source config\n        file to load. The source config file can either be in\n        bracket format or set format. The source file can include\n        Jinja2 template variables.\n  match:\n    description:\n      - The C(match) argument controls the method used to match\n        against the current active configuration. By default, the\n        desired config is matched against the active config and the\n        deltas are loaded. If the C(match) argument is set to C(none)\n        the active configuration is ignored and the configuration is\n        always loaded.\n    default: line\n    choices: ['line', 'none']\n  backup:\n    description:\n      - The C(backup) argument will backup the current devices active\n        configuration to the Ansible control host prior to making any\n        changes. The backup file will be located in the backup folder\n        in the root of the playbook\n    type: bool\n    default: 'no'\n  comment:\n    description:\n      - Allows a commit description to be specified to be included\n        when the configuration is committed. If the configuration is\n        not changed or committed, this argument is ignored.\n    default: 'configured by edgeos_config'\n  config:\n    description:\n      - The C(config) argument specifies the base configuration to use\n        to compare against the desired configuration. If this value\n        is not specified, the module will automatically retrieve the\n        current active configuration from the remote device.\n  save:\n    description:\n      - The C(save) argument controls whether or not changes made\n        to the active configuration are saved to disk. This is\n        independent of committing the config. When set to C(True), the\n        active configuration is saved.\n    type: bool\n    default: 'no'\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: configure the remote device\n  edgeos_config:\n    lines:\n      - set system host-name {{ inventory_hostname }}\n      - set service lldp\n      - delete service dhcp-server\n\n- name: backup and load from file\n  edgeos_config:\n    src: edgeos.cfg\n    backup: yes\n\"\"\"\n\nRETURN = \"\"\"\ncommands:\n  description: The list of configuration commands sent to the device\n  returned: always\n  type: list\n  sample: ['...', '...']\nfiltered:\n  description: The list of configuration commands removed to avoid a load failure\n  returned: always\n  type: list\n  sample: ['...', '...']\nbackup_path:\n  description: The full path to the backup file\n  returned: when backup is yes\n  type: string\n  sample: /playbooks/ansible/backup/edgeos_config.2016-07-16@22:28:34\n\"\"\"\n\nimport re\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.network.common.config import NetworkConfig\nfrom ansible.module_utils.network.edgeos.edgeos import load_config, get_config, run_commands\n\nDEFAULT_COMMENT = 'configured by edgeos_config'\n\nCONFIG_FILTERS = [\n    re.compile(r'set system login user \\S+ authentication encrypted-password')\n]\n\n\ndef config_to_commands(config):\n    set_format = config.startswith('set') or config.startswith('delete')\n    candidate = NetworkConfig(indent=4, contents=config)\n    if not set_format:\n        candidate = [c.line for c in candidate.items]\n        commands = list()\n        \n        for item in candidate:\n            for index, entry in enumerate(commands):\n                if item.startswith(entry):\n                    del commands[index]\n                    break\n            commands.append(item)\n\n        commands = ['set %s' % cmd.replace(' {', '') for cmd in commands]\n\n    else:\n        commands = str(candidate).split('\\n')\n\n    return commands\n\n\ndef get_candidate(module):\n    contents = module.params['src'] or module.params['lines']\n\n    if module.params['lines']:\n        contents = '\\n'.join(contents)\n\n    return config_to_commands(contents)\n\n\ndef diff_config(commands, config):\n    config = [str(c).replace(\"'\", '') for c in config.splitlines()]\n\n    updates = list()\n    visited = set()\n\n    for line in commands:\n        item = str(line).replace(\"'\", '')\n\n        if not item.startswith('set') and not item.startswith('delete'):\n            raise ValueError('line must start with either `set` or `delete`')\n\n        elif item.startswith('set') and item not in config:\n            updates.append(line)\n\n        elif item.startswith('delete'):\n            if not config:\n                updates.append(line)\n            else:\n                item = re.sub(r'delete', 'set', item)\n                for entry in config:\n                    if entry.startswith(item) and line not in visited:\n                        updates.append(line)\n                        visited.add(line)\n\n    return list(updates)\n\n\ndef sanitize_config(config, result):\n    result['filtered'] = list()\n    for regex in CONFIG_FILTERS:\n        for index, line in enumerate(list(config)):\n            if regex.search(line):\n                result['filtered'].append(line)\n                del config[index]\n\n\ndef run(module, result):\n    \n    \n    config = module.params['config'] or get_config(module)\n\n    \n    candidate = get_candidate(module)\n\n    \n    commands = diff_config(candidate, config)\n    sanitize_config(commands, result)\n\n    result['commands'] = commands\n\n    commit = not module.check_mode\n    comment = module.params['comment']\n\n    if commands:\n        load_config(module, commands, commit=commit, comment=comment)\n\n        if result.get('filtered'):\n            result['warnings'].append('Some configuration commands were '\n                                      'removed, please see the filtered key')\n\n        result['changed'] = True\n\n\ndef main():\n    spec = dict(\n        src=dict(type='path'),\n        lines=dict(type='list'),\n\n        match=dict(default='line', choices=['line', 'none']),\n\n        comment=dict(default=DEFAULT_COMMENT),\n\n        config=dict(),\n\n        backup=dict(type='bool', default=False),\n        save=dict(type='bool', default=False),\n    )\n\n    mutually_exclusive = [('lines', 'src')]\n\n    module = AnsibleModule(\n        argument_spec=spec,\n        mutually_exclusive=mutually_exclusive,\n        supports_check_mode=True\n    )\n\n    warnings = list()\n\n    result = dict(changed=False, warnings=warnings)\n\n    if module.params['backup']:\n        result['__backup__'] = get_config(module=module)\n\n    if any((module.params['src'], module.params['lines'])):\n        run(module, result)\n\n    if module.params['save']:\n        diff = run_commands(module, commands=['configure', 'compare saved'])[1]\n        if diff != '[edit]':\n            run_commands(module, commands=['save'])\n            result['changed'] = True\n        run_commands(module, commands=['exit'])\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  edgeos config version added   2 5  author         nathaniel case ( qalthos)         sam doran ( samdoran)  short description  manage edgeos configuration remote device description      this module provides configuration file management edgeos     devices  it provides arguments managing     configuration file state active configuration  all     configuration statements based  set   delete  commands     device configuration  notes      tested edgeos 1 9 7     setting c(ansible persistent command timeout) 30 recommended since     save command take longer default 10 seconds     edgeos hardware  options    lines      description          the ordered set configuration lines managed         compared existing configuration remote         device    src      description          the c(src) argument specifies path source config         file load  the source config file either         bracket format set format  the source file include         jinja2 template variables    match      description          the c(match) argument controls method used match         current active configuration  by default          desired config matched active config         deltas loaded  if c(match) argument set c(none)         active configuration ignored configuration         always loaded      default  line     choices    line    none     backup      description          the c(backup) argument backup current devices active         configuration ansible control host prior making         changes  the backup file located backup folder         root playbook     type  bool     default      comment      description          allows commit description specified included         configuration committed  if configuration         changed committed  argument ignored      default   configured edgeos config    config      description          the c(config) argument specifies base configuration use         compare desired configuration  if value         specified  module automatically retrieve         current active configuration remote device    save      description          the c(save) argument controls whether changes made         active configuration saved disk  this         independent committing config  when set c(true)          active configuration saved      type  bool     default         examples         name  configure remote device   edgeos config      lines          set system host name    inventory hostname            set service lldp         delete service dhcp server    name  backup load file   edgeos config      src  edgeos cfg     backup  yes      return       commands    description  the list configuration commands sent device   returned  always   type  list   sample                 filtered    description  the list configuration commands removed avoid load failure   returned  always   type  list   sample                 backup path    description  the full path backup file   returned  backup yes   type  string   sample   playbooks ansible backup edgeos config 2016 07 16 22 28 34         usr bin python        coding  utf 8        copyright (c) 2018 ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    filters less specific lines    get current active config node passed via    config param    create candidate config object arguments    create loadable config includes configuration updates ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n# Copyright (c) 2018 Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'network'}\n\nDOCUMENTATION = \"\"\"\n---\nmodule: edgeos_config\nversion_added: \"2.5\"\nauthor:\n    - \"Nathaniel Case (@qalthos)\"\n    - \"Sam Doran (@samdoran)\"\nshort_description: Manage EdgeOS configuration on remote device\ndescription:\n  - This module provides configuration file management of EdgeOS\n    devices. It provides arguments for managing both the\n    configuration file and state of the active configuration. All\n    configuration statements are based on `set` and `delete` commands\n    in the device configuration.\nnotes:\n  - Tested against EdgeOS 1.9.7\n  - Setting C(ANSIBLE_PERSISTENT_COMMAND_TIMEOUT) to 30 is recommended since\n    the save command can take longer than the default of 10 seconds on\n    some EdgeOS hardware.\noptions:\n  lines:\n    description:\n      - The ordered set of configuration lines to be managed and\n        compared with the existing configuration on the remote\n        device.\n  src:\n    description:\n      - The C(src) argument specifies the path to the source config\n        file to load. The source config file can either be in\n        bracket format or set format. The source file can include\n        Jinja2 template variables.\n  match:\n    description:\n      - The C(match) argument controls the method used to match\n        against the current active configuration. By default, the\n        desired config is matched against the active config and the\n        deltas are loaded. If the C(match) argument is set to C(none)\n        the active configuration is ignored and the configuration is\n        always loaded.\n    default: line\n    choices: ['line', 'none']\n  backup:\n    description:\n      - The C(backup) argument will backup the current devices active\n        configuration to the Ansible control host prior to making any\n        changes. The backup file will be located in the backup folder\n        in the root of the playbook\n    type: bool\n    default: 'no'\n  comment:\n    description:\n      - Allows a commit description to be specified to be included\n        when the configuration is committed. If the configuration is\n        not changed or committed, this argument is ignored.\n    default: 'configured by edgeos_config'\n  config:\n    description:\n      - The C(config) argument specifies the base configuration to use\n        to compare against the desired configuration. If this value\n        is not specified, the module will automatically retrieve the\n        current active configuration from the remote device.\n  save:\n    description:\n      - The C(save) argument controls whether or not changes made\n        to the active configuration are saved to disk. This is\n        independent of committing the config. When set to C(True), the\n        active configuration is saved.\n    type: bool\n    default: 'no'\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: configure the remote device\n  edgeos_config:\n    lines:\n      - set system host-name {{ inventory_hostname }}\n      - set service lldp\n      - delete service dhcp-server\n\n- name: backup and load from file\n  edgeos_config:\n    src: edgeos.cfg\n    backup: yes\n\"\"\"\n\nRETURN = \"\"\"\ncommands:\n  description: The list of configuration commands sent to the device\n  returned: always\n  type: list\n  sample: ['...', '...']\nfiltered:\n  description: The list of configuration commands removed to avoid a load failure\n  returned: always\n  type: list\n  sample: ['...', '...']\nbackup_path:\n  description: The full path to the backup file\n  returned: when backup is yes\n  type: string\n  sample: /playbooks/ansible/backup/edgeos_config.2016-07-16@22:28:34\n\"\"\"\n\nimport re\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.network.common.config import NetworkConfig\nfrom ansible.module_utils.network.edgeos.edgeos import load_config, get_config, run_commands\n\nDEFAULT_COMMENT = 'configured by edgeos_config'\n\nCONFIG_FILTERS = [\n    re.compile(r'set system login user \\S+ authentication encrypted-password')\n]\n\n\ndef config_to_commands(config):\n    set_format = config.startswith('set') or config.startswith('delete')\n    candidate = NetworkConfig(indent=4, contents=config)\n    if not set_format:\n        candidate = [c.line for c in candidate.items]\n        commands = list()\n        # this filters out less specific lines\n        for item in candidate:\n            for index, entry in enumerate(commands):\n                if item.startswith(entry):\n                    del commands[index]\n                    break\n            commands.append(item)\n\n        commands = ['set %s' % cmd.replace(' {', '') for cmd in commands]\n\n    else:\n        commands = str(candidate).split('\\n')\n\n    return commands\n\n\ndef get_candidate(module):\n    contents = module.params['src'] or module.params['lines']\n\n    if module.params['lines']:\n        contents = '\\n'.join(contents)\n\n    return config_to_commands(contents)\n\n\ndef diff_config(commands, config):\n    config = [str(c).replace(\"'\", '') for c in config.splitlines()]\n\n    updates = list()\n    visited = set()\n\n    for line in commands:\n        item = str(line).replace(\"'\", '')\n\n        if not item.startswith('set') and not item.startswith('delete'):\n            raise ValueError('line must start with either `set` or `delete`')\n\n        elif item.startswith('set') and item not in config:\n            updates.append(line)\n\n        elif item.startswith('delete'):\n            if not config:\n                updates.append(line)\n            else:\n                item = re.sub(r'delete', 'set', item)\n                for entry in config:\n                    if entry.startswith(item) and line not in visited:\n                        updates.append(line)\n                        visited.add(line)\n\n    return list(updates)\n\n\ndef sanitize_config(config, result):\n    result['filtered'] = list()\n    for regex in CONFIG_FILTERS:\n        for index, line in enumerate(list(config)):\n            if regex.search(line):\n                result['filtered'].append(line)\n                del config[index]\n\n\ndef run(module, result):\n    # get the current active config from the node or passed in via\n    # the config param\n    config = module.params['config'] or get_config(module)\n\n    # create the candidate config object from the arguments\n    candidate = get_candidate(module)\n\n    # create loadable config that includes only the configuration updates\n    commands = diff_config(candidate, config)\n    sanitize_config(commands, result)\n\n    result['commands'] = commands\n\n    commit = not module.check_mode\n    comment = module.params['comment']\n\n    if commands:\n        load_config(module, commands, commit=commit, comment=comment)\n\n        if result.get('filtered'):\n            result['warnings'].append('Some configuration commands were '\n                                      'removed, please see the filtered key')\n\n        result['changed'] = True\n\n\ndef main():\n    spec = dict(\n        src=dict(type='path'),\n        lines=dict(type='list'),\n\n        match=dict(default='line', choices=['line', 'none']),\n\n        comment=dict(default=DEFAULT_COMMENT),\n\n        config=dict(),\n\n        backup=dict(type='bool', default=False),\n        save=dict(type='bool', default=False),\n    )\n\n    mutually_exclusive = [('lines', 'src')]\n\n    module = AnsibleModule(\n        argument_spec=spec,\n        mutually_exclusive=mutually_exclusive,\n        supports_check_mode=True\n    )\n\n    warnings = list()\n\n    result = dict(changed=False, warnings=warnings)\n\n    if module.params['backup']:\n        result['__backup__'] = get_config(module=module)\n\n    if any((module.params['src'], module.params['lines'])):\n        run(module, result)\n\n    if module.params['save']:\n        diff = run_commands(module, commands=['configure', 'compare saved'])[1]\n        if diff != '[edit]':\n            run_commands(module, commands=['save'])\n            result['changed'] = True\n        run_commands(module, commands=['exit'])\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "edgeos_config.py", "id": "5bddc0844de31fb849d724cfa25dc3e2", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/network/edgeos/edgeos_config.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}