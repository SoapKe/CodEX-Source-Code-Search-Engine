{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport json\nimport math\nimport re\n\nfrom .aws import AWSIE\nfrom ..compat import compat_HTTPError\nfrom ..utils import (\n    clean_html,\n    ExtractorError,\n    InAdvancePagedList,\n    int_or_none,\n    parse_iso8601,\n    str_or_none,\n    urlencode_postdata,\n)\n\n\nclass ShahidBaseIE(AWSIE):\n    _AWS_PROXY_HOST = 'api2.shahid.net'\n    _AWS_API_KEY = '2RRtuMHx95aNI1Kvtn2rChEuwsCogUd4samGPjLh'\n\n    def _handle_error(self, e):\n        fail_data = self._parse_json(\n            e.cause.read().decode('utf-8'), None, fatal=False)\n        if fail_data:\n            faults = fail_data.get('faults', [])\n            faults_message = ', '.join([clean_html(fault['userMessage']) for fault in faults if fault.get('userMessage')])\n            if faults_message:\n                raise ExtractorError(faults_message, expected=True)\n\n    def _call_api(self, path, video_id, request=None):\n        query = {}\n        if request:\n            query['request'] = json.dumps(request)\n        try:\n            return self._aws_execute_api({\n                'uri': '/proxy/v2/' + path,\n                'access_key': 'AKIAI6X4TYCIXM2B7MUQ',\n                'secret_key': '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',\n            }, video_id, query)\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError):\n                self._handle_error(e)\n            raise\n\n\nclass ShahidIE(ShahidBaseIE):\n    _NETRC_MACHINE = 'shahid'\n    _VALID_URL = r'https?://shahid\\.mbc\\.net/ar/(?:serie|show|movie)s/[^/]+/(?P<type>episode|clip|movie)-(?P<id>\\d+)'\n    _TESTS = [{\n        'url': 'https://shahid.mbc.net/ar/shows/%D9%85%D8%AC%D9%84%D8%B3-%D8%A7%D9%84%D8%B4%D8%A8%D8%A7%D8%A8-%D8%A7%D9%84%D9%85%D9%88%D8%B3%D9%85-1-%D9%83%D9%84%D9%8A%D8%A8-1/clip-275286',\n        'info_dict': {\n            'id': '275286',\n            'ext': 'mp4',\n            'title': '\u0645\u062c\u0644\u0633 \u0627\u0644\u0634\u0628\u0627\u0628 \u0627\u0644\u0645\u0648\u0633\u0645 1 \u0643\u0644\u064a\u0628 1',\n            'timestamp': 1506988800,\n            'upload_date': '20171003',\n        },\n        'params': {\n            \n            'skip_download': True,\n        }\n    }, {\n        'url': 'https://shahid.mbc.net/ar/movies/%D8%A7%D9%84%D9%82%D9%86%D8%A7%D8%B5%D8%A9/movie-151746',\n        'only_matching': True\n    }, {\n        \n        'url': 'https://shahid.mbc.net/ar/series/%D9%85%D8%B1%D8%A7%D9%8A%D8%A7-2011-%D8%A7%D9%84%D9%85%D9%88%D8%B3%D9%85-1-%D8%A7%D9%84%D8%AD%D9%84%D9%82%D8%A9-1/episode-90511',\n        'only_matching': True\n    }]\n\n    def _real_initialize(self):\n        email, password = self._get_login_info()\n        if email is None:\n            return\n\n        try:\n            user_data = self._download_json(\n                'https://shahid.mbc.net/wd/service/users/login',\n                None, 'Logging in', data=json.dumps({\n                    'email': email,\n                    'password': password,\n                    'basic': 'false',\n                }).encode('utf-8'), headers={\n                    'Content-Type': 'application/json; charset=UTF-8',\n                })['user']\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError):\n                self._handle_error(e)\n            raise\n\n        self._download_webpage(\n            'https://shahid.mbc.net/populateContext',\n            None, 'Populate Context', data=urlencode_postdata({\n                'firstName': user_data['firstName'],\n                'lastName': user_data['lastName'],\n                'userName': user_data['email'],\n                'csg_user_name': user_data['email'],\n                'subscriberId': user_data['id'],\n                'sessionId': user_data['sessionId'],\n            }))\n\n    def _real_extract(self, url):\n        page_type, video_id = re.match(self._VALID_URL, url).groups()\n        if page_type == 'clip':\n            page_type = 'episode'\n\n        playout = self._call_api(\n            'playout/url/' + video_id, video_id)['playout']\n\n        if playout.get('drm'):\n            raise ExtractorError('This video is DRM protected.', expected=True)\n\n        formats = self._extract_m3u8_formats(playout['url'], video_id, 'mp4')\n        self._sort_formats(formats)\n\n        \n        \n        \n        \n        \n        \n\n        response = self._download_json(\n            'http://api.shahid.net/api/v1_1/%s/%s' % (page_type, video_id),\n            video_id, 'Downloading video JSON', query={\n                'apiKey': 'sh@hid0nlin3',\n                'hash': 'b2wMCTHpSmyxGqQjJFOycRmLSex+BpTK/ooxy6vHaqs=',\n            })\n        data = response.get('data', {})\n        error = data.get('error')\n        if error:\n            raise ExtractorError(\n                '%s returned error: %s' % (self.IE_NAME, '\\n'.join(error.values())),\n                expected=True)\n\n        video = data[page_type]\n        title = video['title']\n        categories = [\n            category['name']\n            for category in video.get('genres', []) if 'name' in category]\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': video.get('description'),\n            'thumbnail': video.get('thumbnailUrl'),\n            'duration': int_or_none(video.get('duration')),\n            'timestamp': parse_iso8601(video.get('referenceDate')),\n            'categories': categories,\n            'series': video.get('showTitle') or video.get('showName'),\n            'season': video.get('seasonTitle'),\n            'season_number': int_or_none(video.get('seasonNumber')),\n            'season_id': str_or_none(video.get('seasonId')),\n            'episode_number': int_or_none(video.get('number')),\n            'episode_id': video_id,\n            'formats': formats,\n        }\n\n\nclass ShahidShowIE(ShahidBaseIE):\n    _VALID_URL = r'https?://shahid\\.mbc\\.net/ar/(?:show|serie)s/[^/]+/(?:show|series)-(?P<id>\\d+)'\n    _TESTS = [{\n        'url': 'https://shahid.mbc.net/ar/shows/%D8%B1%D8%A7%D9%85%D8%B2-%D9%82%D8%B1%D8%B4-%D8%A7%D9%84%D8%A8%D8%AD%D8%B1/show-79187',\n        'info_dict': {\n            'id': '79187',\n            'title': '\u0631\u0627\u0645\u0632 \u0642\u0631\u0634 \u0627\u0644\u0628\u062d\u0631',\n            'description': 'md5:c88fa7e0f02b0abd39d417aee0d046ff',\n        },\n        'playlist_mincount': 32,\n    }, {\n        'url': 'https://shahid.mbc.net/ar/series/How-to-live-Longer-(The-Big-Think)/series-291861',\n        'only_matching': True\n    }]\n    _PAGE_SIZE = 30\n\n    def _real_extract(self, url):\n        show_id = self._match_id(url)\n\n        product = self._call_api(\n            'playableAsset', show_id, {'showId': show_id})['productModel']\n        playlist = product['playlist']\n        playlist_id = playlist['id']\n        show = product.get('show', {})\n\n        def page_func(page_num):\n            playlist = self._call_api(\n                'product/playlist', show_id, {\n                    'playListId': playlist_id,\n                    'pageNumber': page_num,\n                    'pageSize': 30,\n                    'sorts': [{\n                        'order': 'DESC',\n                        'type': 'SORTDATE'\n                    }],\n                })\n            for product in playlist.get('productList', {}).get('products', []):\n                product_url = product.get('productUrl', []).get('url')\n                if not product_url:\n                    continue\n                yield self.url_result(\n                    product_url, 'Shahid',\n                    str_or_none(product.get('id')),\n                    product.get('title'))\n\n        entries = InAdvancePagedList(\n            page_func,\n            math.ceil(playlist['count'] / self._PAGE_SIZE),\n            self._PAGE_SIZE)\n\n        return self.playlist_result(\n            entries, show_id, show.get('title'), show.get('description'))\n", "comments": "# coding: utf-8\n# m3u8 download\n# shahid plus subscriber only\n# video = self._call_api(\n#     'product/id', video_id, {\n#         'id': video_id,\n#         'productType': 'ASSET',\n#         'productSubType': page_type.upper()\n#     })['productModel']\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport json\nimport math\nimport re\n\nfrom .aws import AWSIE\nfrom ..compat import compat_HTTPError\nfrom ..utils import (\n    clean_html,\n    ExtractorError,\n    InAdvancePagedList,\n    int_or_none,\n    parse_iso8601,\n    str_or_none,\n    urlencode_postdata,\n)\n\n\nclass ShahidBaseIE(AWSIE):\n    _AWS_PROXY_HOST = 'api2.shahid.net'\n    _AWS_API_KEY = '2RRtuMHx95aNI1Kvtn2rChEuwsCogUd4samGPjLh'\n\n    def _handle_error(self, e):\n        fail_data = self._parse_json(\n            e.cause.read().decode('utf-8'), None, fatal=False)\n        if fail_data:\n            faults = fail_data.get('faults', [])\n            faults_message = ', '.join([clean_html(fault['userMessage']) for fault in faults if fault.get('userMessage')])\n            if faults_message:\n                raise ExtractorError(faults_message, expected=True)\n\n    def _call_api(self, path, video_id, request=None):\n        query = {}\n        if request:\n            query['request'] = json.dumps(request)\n        try:\n            return self._aws_execute_api({\n                'uri': '/proxy/v2/' + path,\n                'access_key': 'AKIAI6X4TYCIXM2B7MUQ',\n                'secret_key': '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',\n            }, video_id, query)\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError):\n                self._handle_error(e)\n            raise\n\n\nclass ShahidIE(ShahidBaseIE):\n    _NETRC_MACHINE = 'shahid'\n    _VALID_URL = r'https?://shahid\\.mbc\\.net/ar/(?:serie|show|movie)s/[^/]+/(?P<type>episode|clip|movie)-(?P<id>\\d+)'\n    _TESTS = [{\n        'url': 'https://shahid.mbc.net/ar/shows/%D9%85%D8%AC%D9%84%D8%B3-%D8%A7%D9%84%D8%B4%D8%A8%D8%A7%D8%A8-%D8%A7%D9%84%D9%85%D9%88%D8%B3%D9%85-1-%D9%83%D9%84%D9%8A%D8%A8-1/clip-275286',\n        'info_dict': {\n            'id': '275286',\n            'ext': 'mp4',\n            'title': '\u0645\u062c\u0644\u0633 \u0627\u0644\u0634\u0628\u0627\u0628 \u0627\u0644\u0645\u0648\u0633\u0645 1 \u0643\u0644\u064a\u0628 1',\n            'timestamp': 1506988800,\n            'upload_date': '20171003',\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        }\n    }, {\n        'url': 'https://shahid.mbc.net/ar/movies/%D8%A7%D9%84%D9%82%D9%86%D8%A7%D8%B5%D8%A9/movie-151746',\n        'only_matching': True\n    }, {\n        # shahid plus subscriber only\n        'url': 'https://shahid.mbc.net/ar/series/%D9%85%D8%B1%D8%A7%D9%8A%D8%A7-2011-%D8%A7%D9%84%D9%85%D9%88%D8%B3%D9%85-1-%D8%A7%D9%84%D8%AD%D9%84%D9%82%D8%A9-1/episode-90511',\n        'only_matching': True\n    }]\n\n    def _real_initialize(self):\n        email, password = self._get_login_info()\n        if email is None:\n            return\n\n        try:\n            user_data = self._download_json(\n                'https://shahid.mbc.net/wd/service/users/login',\n                None, 'Logging in', data=json.dumps({\n                    'email': email,\n                    'password': password,\n                    'basic': 'false',\n                }).encode('utf-8'), headers={\n                    'Content-Type': 'application/json; charset=UTF-8',\n                })['user']\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError):\n                self._handle_error(e)\n            raise\n\n        self._download_webpage(\n            'https://shahid.mbc.net/populateContext',\n            None, 'Populate Context', data=urlencode_postdata({\n                'firstName': user_data['firstName'],\n                'lastName': user_data['lastName'],\n                'userName': user_data['email'],\n                'csg_user_name': user_data['email'],\n                'subscriberId': user_data['id'],\n                'sessionId': user_data['sessionId'],\n            }))\n\n    def _real_extract(self, url):\n        page_type, video_id = re.match(self._VALID_URL, url).groups()\n        if page_type == 'clip':\n            page_type = 'episode'\n\n        playout = self._call_api(\n            'playout/url/' + video_id, video_id)['playout']\n\n        if playout.get('drm'):\n            raise ExtractorError('This video is DRM protected.', expected=True)\n\n        formats = self._extract_m3u8_formats(playout['url'], video_id, 'mp4')\n        self._sort_formats(formats)\n\n        # video = self._call_api(\n        #     'product/id', video_id, {\n        #         'id': video_id,\n        #         'productType': 'ASSET',\n        #         'productSubType': page_type.upper()\n        #     })['productModel']\n\n        response = self._download_json(\n            'http://api.shahid.net/api/v1_1/%s/%s' % (page_type, video_id),\n            video_id, 'Downloading video JSON', query={\n                'apiKey': 'sh@hid0nlin3',\n                'hash': 'b2wMCTHpSmyxGqQjJFOycRmLSex+BpTK/ooxy6vHaqs=',\n            })\n        data = response.get('data', {})\n        error = data.get('error')\n        if error:\n            raise ExtractorError(\n                '%s returned error: %s' % (self.IE_NAME, '\\n'.join(error.values())),\n                expected=True)\n\n        video = data[page_type]\n        title = video['title']\n        categories = [\n            category['name']\n            for category in video.get('genres', []) if 'name' in category]\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': video.get('description'),\n            'thumbnail': video.get('thumbnailUrl'),\n            'duration': int_or_none(video.get('duration')),\n            'timestamp': parse_iso8601(video.get('referenceDate')),\n            'categories': categories,\n            'series': video.get('showTitle') or video.get('showName'),\n            'season': video.get('seasonTitle'),\n            'season_number': int_or_none(video.get('seasonNumber')),\n            'season_id': str_or_none(video.get('seasonId')),\n            'episode_number': int_or_none(video.get('number')),\n            'episode_id': video_id,\n            'formats': formats,\n        }\n\n\nclass ShahidShowIE(ShahidBaseIE):\n    _VALID_URL = r'https?://shahid\\.mbc\\.net/ar/(?:show|serie)s/[^/]+/(?:show|series)-(?P<id>\\d+)'\n    _TESTS = [{\n        'url': 'https://shahid.mbc.net/ar/shows/%D8%B1%D8%A7%D9%85%D8%B2-%D9%82%D8%B1%D8%B4-%D8%A7%D9%84%D8%A8%D8%AD%D8%B1/show-79187',\n        'info_dict': {\n            'id': '79187',\n            'title': '\u0631\u0627\u0645\u0632 \u0642\u0631\u0634 \u0627\u0644\u0628\u062d\u0631',\n            'description': 'md5:c88fa7e0f02b0abd39d417aee0d046ff',\n        },\n        'playlist_mincount': 32,\n    }, {\n        'url': 'https://shahid.mbc.net/ar/series/How-to-live-Longer-(The-Big-Think)/series-291861',\n        'only_matching': True\n    }]\n    _PAGE_SIZE = 30\n\n    def _real_extract(self, url):\n        show_id = self._match_id(url)\n\n        product = self._call_api(\n            'playableAsset', show_id, {'showId': show_id})['productModel']\n        playlist = product['playlist']\n        playlist_id = playlist['id']\n        show = product.get('show', {})\n\n        def page_func(page_num):\n            playlist = self._call_api(\n                'product/playlist', show_id, {\n                    'playListId': playlist_id,\n                    'pageNumber': page_num,\n                    'pageSize': 30,\n                    'sorts': [{\n                        'order': 'DESC',\n                        'type': 'SORTDATE'\n                    }],\n                })\n            for product in playlist.get('productList', {}).get('products', []):\n                product_url = product.get('productUrl', []).get('url')\n                if not product_url:\n                    continue\n                yield self.url_result(\n                    product_url, 'Shahid',\n                    str_or_none(product.get('id')),\n                    product.get('title'))\n\n        entries = InAdvancePagedList(\n            page_func,\n            math.ceil(playlist['count'] / self._PAGE_SIZE),\n            self._PAGE_SIZE)\n\n        return self.playlist_result(\n            entries, show_id, show.get('title'), show.get('description'))\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "shahid.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/shahid.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}