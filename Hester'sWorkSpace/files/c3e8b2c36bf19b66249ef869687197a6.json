{"author": "mitmproxy", "code": "import os\nfrom mitmproxy import certs\nfrom mitmproxy.test import tutils\n\n\n     def test_simple(self):\n()\n         d.add(\"foo.com\", \"foo\")\n         d.add(\"bar.com\", \"bar\")\n         assert d.get(\"foo.com\") == \"foo\"\n         assert d.get(\"bar.com\") == \"bar\"\n         assert not d.get(\"oink.com\")\n         assert not d.get(\"oink\")\n         assert not d.get(\"\")\n         assert not d.get(\"oink.oink\")\n\n         d.add(\"*.match.org\", \"match\")\n         assert not d.get(\"match.org\")\n         assert d.get(\"foo.match.org\") == \"match\"\n         assert d.get(\"foo.foo.match.org\") == \"match\"\n\n     def test_wildcard(self):\n()\n         d.add(\"foo.com\", \"foo\")\n         assert not d.get(\"*.foo.com\")\n         d.add(\"*.foo.com\", \"wild\")\n\n()\n         d.add(\"*\", \"foo\")\n         assert d.get(\"foo.com\") == \"foo\"\n         assert d.get(\"*.foo.com\") == \"foo\"\n         assert d.get(\"com\") == \"foo\"\n\n\nclass TestCertStore:\n\n    def test_create_explicit(self, tmpdir):\n        ca = certs.CertStore.from_store(str(tmpdir), \"test\")\n        assert ca.get_cert(b\"foo\", [])\n\n        ca2 = certs.CertStore.from_store(str(tmpdir), \"test\")\n        assert ca2.get_cert(b\"foo\", [])\n\n        assert ca.default_ca.get_serial_number() == ca2.default_ca.get_serial_number()\n\n    def test_create_no_common_name(self, tmpdir):\n        ca = certs.CertStore.from_store(str(tmpdir), \"test\")\n        assert ca.get_cert(None, [])[0].cn is None\n\n    def test_create_tmp(self, tmpdir):\n        ca = certs.CertStore.from_store(str(tmpdir), \"test\")\n        assert ca.get_cert(b\"foo.com\", [])\n        assert ca.get_cert(b\"foo.com\", [])\n        assert ca.get_cert(b\"*.foo.com\", [])\n\n        r = ca.get_cert(b\"*.foo.com\", [])\n        assert r[1] == ca.default_privatekey\n\n    def test_sans(self, tmpdir):\n        ca = certs.CertStore.from_store(str(tmpdir), \"test\")\n        c1 = ca.get_cert(b\"foo.com\", [b\"*.bar.com\"])\n        ca.get_cert(b\"foo.bar.com\", [])\n         assert c1 == c2\n        c3 = ca.get_cert(b\"bar.com\", [])\n        assert not c1 == c3\n\n    def test_sans_change(self, tmpdir):\n        ca = certs.CertStore.from_store(str(tmpdir), \"test\")\n        ca.get_cert(b\"foo.com\", [b\"*.bar.com\"])\n        cert, key, chain_file = ca.get_cert(b\"foo.bar.com\", [b\"*.baz.com\"])\n        assert b\"*.baz.com\" in cert.altnames\n\n    def test_expire(self, tmpdir):\n        ca = certs.CertStore.from_store(str(tmpdir), \"test\")\n        ca.STORE_CAP = 3\n        ca.get_cert(b\"one.com\", [])\n        ca.get_cert(b\"two.com\", [])\n        ca.get_cert(b\"three.com\", [])\n\n        assert (b\"one.com\", ()) in ca.certs\n        assert (b\"two.com\", ()) in ca.certs\n        assert (b\"three.com\", ()) in ca.certs\n\n        ca.get_cert(b\"one.com\", [])\n\n        assert (b\"one.com\", ()) in ca.certs\n        assert (b\"two.com\", ()) in ca.certs\n        assert (b\"three.com\", ()) in ca.certs\n\n        ca.get_cert(b\"four.com\", [])\n\n        assert (b\"one.com\", ()) not in ca.certs\n        assert (b\"two.com\", ()) in ca.certs\n        assert (b\"three.com\", ()) in ca.certs\n        assert (b\"four.com\", ()) in ca.certs\n\n    def test_overrides(self, tmpdir):\n        ca1 = certs.CertStore.from_store(str(tmpdir.join(\"ca1\")), \"test\")\n        ca2 = certs.CertStore.from_store(str(tmpdir.join(\"ca2\")), \"test\")\n        assert not ca1.default_ca.get_serial_number() == ca2.default_ca.get_serial_number()\n\n        dc = ca2.get_cert(b\"foo.com\", [b\"sans.example.com\"])\n        dcp = tmpdir.join(\"dc\")\n        dcp.write(dc[0].to_pem())\n        ca1.add_cert_file(\"foo.com\", str(dcp))\n\n        ret = ca1.get_cert(b\"foo.com\", [])\n        assert ret[0].serial == dc[0].serial\n\n    def test_create_dhparams(self, tmpdir):\n        filename = str(tmpdir.join(\"dhparam.pem\"))\n        certs.CertStore.load_dhparam(filename)\n        assert os.path.exists(filename)\n\n\nclass TestDummyCert:\n\n    def test_with_ca(self, tmpdir):\n        ca = certs.CertStore.from_store(str(tmpdir), \"test\")\n        r = certs.dummy_cert(\n            ca.default_privatekey,\n            ca.default_ca,\n            b\"foo.com\",\n            [b\"one.com\", b\"two.com\", b\"*.three.com\", b\"127.0.0.1\"]\n        )\n        assert r.cn == b\"foo.com\"\n        assert r.altnames == [b'one.com', b'two.com', b'*.three.com']\n\n        r = certs.dummy_cert(\n            ca.default_privatekey,\n            ca.default_ca,\n            None,\n            []\n        )\n        assert r.cn is None\n        assert r.altnames == []\n\n\nclass TestCert:\n\n    def test_simple(self):\n        with open(tutils.test_data.path(\"mitmproxy/net/data/text_cert\"), \"rb\") as f:\n            d = f.read()\n        c1 = certs.Cert.from_pem(d)\n        assert c1.cn == b\"google.com\"\n        assert len(c1.altnames) == 436\n\n        with open(tutils.test_data.path(\"mitmproxy/net/data/text_cert_2\"), \"rb\") as f:\n            d = f.read()\n        c2 = certs.Cert.from_pem(d)\n        assert c2.cn == b\"www.inode.co.nz\"\n        assert len(c2.altnames) == 2\n        assert c2.digest(\"sha1\")\n        assert c2.notbefore\n        assert c2.notafter\n        assert c2.subject\n        assert c2.keyinfo == (\"RSA\", 2048)\n        assert c2.serial\n        assert c2.issuer\n        assert c2.to_pem()\n        assert c2.has_expired is not None\n\n        assert c1 != c2\n\n    def test_err_broken_sans(self):\n        with open(tutils.test_data.path(\"mitmproxy/net/data/text_cert_weird1\"), \"rb\") as f:\n            d = f.read()\n        c = certs.Cert.from_pem(d)\n         This breaks unless we ignore a decoding error.\n        assert c.altnames is not None\n\n    def test_der(self):\n        with open(tutils.test_data.path(\"mitmproxy/net/data/dercert\"), \"rb\") as f:\n            d = f.read()\n        s = certs.Cert.from_der(d)\n        assert s.cn\n\n    def test_state(self):\n        with open(tutils.test_data.path(\"mitmproxy/net/data/text_cert\"), \"rb\") as f:\n            d = f.read()\n        c = certs.Cert.from_pem(d)\n\n        c.get_state()\n        c2 = c.copy()\n        a = c.get_state()\n        b = c2.get_state()\n        assert a == b\n        assert c == c2\n        assert c is not c2\n\n        x = certs.Cert('')\n        x.set_state(a)\n        assert x == c\n", "comments": "  class testdntree         def test simple(self)               certs dntree()            add( foo com    foo )            add( bar com    bar )            assert get( foo com )     foo             assert get( bar com )     bar             assert get( oink com )            assert get( oink )            assert get(  )            assert get( oink oink )               add(   match org    match )            assert get( match org )            assert get( foo match org )     match             assert get( foo foo match org )     match            def test wildcard(self)               certs dntree()            add( foo com    foo )            assert get(   foo com )            add(   foo com    wild )                 certs dntree()            add(      foo )            assert get( foo com )     foo             assert get(   foo com )     foo             assert get( com )     foo     assert c1    c2    this breaks unless ignore decoding error  ", "content": "import os\nfrom mitmproxy import certs\nfrom mitmproxy.test import tutils\n\n# class TestDNTree:\n#     def test_simple(self):\n#         d = certs.DNTree()\n#         d.add(\"foo.com\", \"foo\")\n#         d.add(\"bar.com\", \"bar\")\n#         assert d.get(\"foo.com\") == \"foo\"\n#         assert d.get(\"bar.com\") == \"bar\"\n#         assert not d.get(\"oink.com\")\n#         assert not d.get(\"oink\")\n#         assert not d.get(\"\")\n#         assert not d.get(\"oink.oink\")\n#\n#         d.add(\"*.match.org\", \"match\")\n#         assert not d.get(\"match.org\")\n#         assert d.get(\"foo.match.org\") == \"match\"\n#         assert d.get(\"foo.foo.match.org\") == \"match\"\n#\n#     def test_wildcard(self):\n#         d = certs.DNTree()\n#         d.add(\"foo.com\", \"foo\")\n#         assert not d.get(\"*.foo.com\")\n#         d.add(\"*.foo.com\", \"wild\")\n#\n#         d = certs.DNTree()\n#         d.add(\"*\", \"foo\")\n#         assert d.get(\"foo.com\") == \"foo\"\n#         assert d.get(\"*.foo.com\") == \"foo\"\n#         assert d.get(\"com\") == \"foo\"\n\n\nclass TestCertStore:\n\n    def test_create_explicit(self, tmpdir):\n        ca = certs.CertStore.from_store(str(tmpdir), \"test\")\n        assert ca.get_cert(b\"foo\", [])\n\n        ca2 = certs.CertStore.from_store(str(tmpdir), \"test\")\n        assert ca2.get_cert(b\"foo\", [])\n\n        assert ca.default_ca.get_serial_number() == ca2.default_ca.get_serial_number()\n\n    def test_create_no_common_name(self, tmpdir):\n        ca = certs.CertStore.from_store(str(tmpdir), \"test\")\n        assert ca.get_cert(None, [])[0].cn is None\n\n    def test_create_tmp(self, tmpdir):\n        ca = certs.CertStore.from_store(str(tmpdir), \"test\")\n        assert ca.get_cert(b\"foo.com\", [])\n        assert ca.get_cert(b\"foo.com\", [])\n        assert ca.get_cert(b\"*.foo.com\", [])\n\n        r = ca.get_cert(b\"*.foo.com\", [])\n        assert r[1] == ca.default_privatekey\n\n    def test_sans(self, tmpdir):\n        ca = certs.CertStore.from_store(str(tmpdir), \"test\")\n        c1 = ca.get_cert(b\"foo.com\", [b\"*.bar.com\"])\n        ca.get_cert(b\"foo.bar.com\", [])\n        # assert c1 == c2\n        c3 = ca.get_cert(b\"bar.com\", [])\n        assert not c1 == c3\n\n    def test_sans_change(self, tmpdir):\n        ca = certs.CertStore.from_store(str(tmpdir), \"test\")\n        ca.get_cert(b\"foo.com\", [b\"*.bar.com\"])\n        cert, key, chain_file = ca.get_cert(b\"foo.bar.com\", [b\"*.baz.com\"])\n        assert b\"*.baz.com\" in cert.altnames\n\n    def test_expire(self, tmpdir):\n        ca = certs.CertStore.from_store(str(tmpdir), \"test\")\n        ca.STORE_CAP = 3\n        ca.get_cert(b\"one.com\", [])\n        ca.get_cert(b\"two.com\", [])\n        ca.get_cert(b\"three.com\", [])\n\n        assert (b\"one.com\", ()) in ca.certs\n        assert (b\"two.com\", ()) in ca.certs\n        assert (b\"three.com\", ()) in ca.certs\n\n        ca.get_cert(b\"one.com\", [])\n\n        assert (b\"one.com\", ()) in ca.certs\n        assert (b\"two.com\", ()) in ca.certs\n        assert (b\"three.com\", ()) in ca.certs\n\n        ca.get_cert(b\"four.com\", [])\n\n        assert (b\"one.com\", ()) not in ca.certs\n        assert (b\"two.com\", ()) in ca.certs\n        assert (b\"three.com\", ()) in ca.certs\n        assert (b\"four.com\", ()) in ca.certs\n\n    def test_overrides(self, tmpdir):\n        ca1 = certs.CertStore.from_store(str(tmpdir.join(\"ca1\")), \"test\")\n        ca2 = certs.CertStore.from_store(str(tmpdir.join(\"ca2\")), \"test\")\n        assert not ca1.default_ca.get_serial_number() == ca2.default_ca.get_serial_number()\n\n        dc = ca2.get_cert(b\"foo.com\", [b\"sans.example.com\"])\n        dcp = tmpdir.join(\"dc\")\n        dcp.write(dc[0].to_pem())\n        ca1.add_cert_file(\"foo.com\", str(dcp))\n\n        ret = ca1.get_cert(b\"foo.com\", [])\n        assert ret[0].serial == dc[0].serial\n\n    def test_create_dhparams(self, tmpdir):\n        filename = str(tmpdir.join(\"dhparam.pem\"))\n        certs.CertStore.load_dhparam(filename)\n        assert os.path.exists(filename)\n\n\nclass TestDummyCert:\n\n    def test_with_ca(self, tmpdir):\n        ca = certs.CertStore.from_store(str(tmpdir), \"test\")\n        r = certs.dummy_cert(\n            ca.default_privatekey,\n            ca.default_ca,\n            b\"foo.com\",\n            [b\"one.com\", b\"two.com\", b\"*.three.com\", b\"127.0.0.1\"]\n        )\n        assert r.cn == b\"foo.com\"\n        assert r.altnames == [b'one.com', b'two.com', b'*.three.com']\n\n        r = certs.dummy_cert(\n            ca.default_privatekey,\n            ca.default_ca,\n            None,\n            []\n        )\n        assert r.cn is None\n        assert r.altnames == []\n\n\nclass TestCert:\n\n    def test_simple(self):\n        with open(tutils.test_data.path(\"mitmproxy/net/data/text_cert\"), \"rb\") as f:\n            d = f.read()\n        c1 = certs.Cert.from_pem(d)\n        assert c1.cn == b\"google.com\"\n        assert len(c1.altnames) == 436\n\n        with open(tutils.test_data.path(\"mitmproxy/net/data/text_cert_2\"), \"rb\") as f:\n            d = f.read()\n        c2 = certs.Cert.from_pem(d)\n        assert c2.cn == b\"www.inode.co.nz\"\n        assert len(c2.altnames) == 2\n        assert c2.digest(\"sha1\")\n        assert c2.notbefore\n        assert c2.notafter\n        assert c2.subject\n        assert c2.keyinfo == (\"RSA\", 2048)\n        assert c2.serial\n        assert c2.issuer\n        assert c2.to_pem()\n        assert c2.has_expired is not None\n\n        assert c1 != c2\n\n    def test_err_broken_sans(self):\n        with open(tutils.test_data.path(\"mitmproxy/net/data/text_cert_weird1\"), \"rb\") as f:\n            d = f.read()\n        c = certs.Cert.from_pem(d)\n        # This breaks unless we ignore a decoding error.\n        assert c.altnames is not None\n\n    def test_der(self):\n        with open(tutils.test_data.path(\"mitmproxy/net/data/dercert\"), \"rb\") as f:\n            d = f.read()\n        s = certs.Cert.from_der(d)\n        assert s.cn\n\n    def test_state(self):\n        with open(tutils.test_data.path(\"mitmproxy/net/data/text_cert\"), \"rb\") as f:\n            d = f.read()\n        c = certs.Cert.from_pem(d)\n\n        c.get_state()\n        c2 = c.copy()\n        a = c.get_state()\n        b = c2.get_state()\n        assert a == b\n        assert c == c2\n        assert c is not c2\n\n        x = certs.Cert('')\n        x.set_state(a)\n        assert x == c\n", "description": "An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers.", "file_name": "test_certs.py", "id": "c3e8b2c36bf19b66249ef869687197a6", "language": "Python", "project_name": "mitmproxy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mitmproxy-mitmproxy/mitmproxy-mitmproxy-3c7725a/test/mitmproxy/test_certs.py", "save_time": "", "source": "", "update_at": "2018-03-18T11:30:56Z", "url": "https://github.com/mitmproxy/mitmproxy", "wiki": false}