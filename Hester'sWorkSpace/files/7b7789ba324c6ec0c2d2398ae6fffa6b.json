{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\nfrom odoo import api, fields, models, _\nfrom odoo.addons.http_routing.models.ir_http import slug\n\n\nclass EventType(models.Model):\n    _name = 'event.type'\n    _inherit = ['event.type']\n\n    website_menu = fields.Boolean(\n        'Display a dedicated menu on Website')\n\n\nclass Event(models.Model):\n    _name = 'event.event'\n    _inherit = ['event.event', 'website.seo.metadata', 'website.published.mixin']\n\n    website_published = fields.Boolean(track_visibility='onchange')\n\n    is_participating = fields.Boolean(\"Is Participating\", compute=\"_compute_is_participating\")\n\n    website_menu = fields.Boolean(\n        'Dedicated Menu', compute='_compute_website_menu', inverse='_set_website_menu',\n        help=\"Creates menus Introduction, Location and Register on the page \"\n             \" of the event on the website.\", store=True)\n    menu_id = fields.Many2one('website.menu', 'Event Menu', copy=False)\n\n    def _compute_is_participating(self):\n        \n        if self.env.user != self.env.ref('base.public_user'):\n            email = self.env.user.partner_id.email\n            for event in self:\n                domain = ['&', '|', ('email', '=', email), ('partner_id', '=', self.env.user.partner_id.id), ('event_id', '=', event.id)]\n                event.is_participating = self.env['event.registration'].search_count(domain)\n\n    @api.multi\n    @api.depends('name')\n    def _compute_website_url(self):\n        super(Event, self)._compute_website_url()\n        for event in self:\n            if event.id:  \n                event.website_url = '/event/%s' % slug(event)\n\n    @api.onchange('event_type_id')\n    def _onchange_type(self):\n        super(Event, self)._onchange_type()\n        if self.event_type_id:\n            self.website_menu = self.event_type_id.website_menu\n\n    def _get_standard_menu_entries_names(self):\n        \"\"\" Method returning menu entries possibly generated by event modules.\n        It is used to distinguish module-generated pages from custom pages. \"\"\"\n        return [_('Introduction'), _('Location'), _('Register')]\n\n    def _get_menu_entries(self):\n        \"\"\" Method returning menu entries to display on the website view of the\n        event, possibly depending on some options in inheriting modules. \"\"\"\n        self.ensure_one()\n        return [\n            (_('Introduction'), False, 'website_event.template_intro'),\n            (_('Location'), False, 'website_event.template_location'),\n            (_('Register'), '/event/%s/register' % slug(self), False),\n        ]\n\n    @api.multi\n    def _set_website_menu(self):\n        for event in self:\n            if event.menu_id and not event.website_menu:\n                event.menu_id.unlink()\n            elif event.website_menu:\n                if not event.menu_id:\n                    root_menu = self.env['website.menu'].create({'name': event.name})\n                    event.menu_id = root_menu\n\n                existing_page_names = event.menu_id.child_id.mapped('name')\n                required_page_names = [entry[0] for entry in self._get_menu_entries()]\n                standard_page_names = self._get_standard_menu_entries_names()\n\n                \n                submenu_to_delete = event.menu_id.child_id.filtered(lambda menu: menu.name not in required_page_names and menu.name in standard_page_names)\n                submenu_to_delete.unlink()\n\n                \n                for sequence, (name, url, xml_id) in enumerate(self._get_menu_entries()):\n                    if name not in existing_page_names:\n                        if not url:\n                            newpath = self.env['website'].new_page(name + ' ' + self.name, template=xml_id, ispage=False)['url']\n                            url = \"/event/\" + slug(self) + \"/page/\" + newpath[1:]\n                        self.env['website.menu'].create({\n                            'name': name,\n                            'url': url,\n                            'parent_id': event.menu_id.id,\n                            'sequence': sequence,\n                        })\n\n    @api.multi\n    def _compute_website_menu(self):\n        for event in self:\n            event.website_menu = bool(event.menu_id)\n\n    @api.multi\n    def google_map_img(self, zoom=8, width=298, height=298):\n        self.ensure_one()\n        if self.address_id:\n            return self.sudo().address_id.google_map_img(zoom=zoom, width=width, height=height)\n        return None\n\n    @api.multi\n    def google_map_link(self, zoom=8):\n        self.ensure_one()\n        if self.address_id:\n            return self.sudo().address_id.google_map_link(zoom=zoom)\n        return None\n\n    @api.multi\n    def _track_subtype(self, init_values):\n        self.ensure_one()\n        if 'website_published' in init_values and self.website_published:\n            return 'website_event.mt_event_published'\n        elif 'website_published' in init_values and not self.website_published:\n            return 'website_event.mt_event_unpublished'\n        return super(Event, self)._track_subtype(init_values)\n\n    @api.multi\n    def action_open_badge_editor(self):\n        \"\"\" open the event badge editor : redirect to the report page of event badge report \"\"\"\n        self.ensure_one()\n        return {\n            'type': 'ir.actions.act_url',\n            'target': 'new',\n            'url': '/report/html/%s/%s?enable_editor' % ('event.event_event_report_template_badge', self.id),\n        }\n", "comments": "    method returning menu entries possibly generated event modules          it used distinguish module generated pages custom pages              return   ( introduction )   ( location )   ( register )       def  get menu entries(self)              method returning menu entries display website view         event  possibly depending options inheriting modules              self ensure one()         return               ( ( introduction )  false   website event template intro )              ( ( location )  false   website event template location )              ( ( register )    event  register    slug(self)  false)                  api multi     def  set website menu(self)          event self              event menu id event website menu                  event menu id unlink()             elif event website menu                  event menu id                      root menu   self env  website menu   create(  name   event name )                     event menu id   root menu                  existing page names   event menu id child id mapped( name )                 required page names    entry 0  entry self  get menu entries()                  standard page names   self  get standard menu entries names()                    remove entries exist anymore                 submenu delete   event menu id child id filtered(lambda menu  menu name required page names menu name standard page names)                 submenu delete unlink()                    create missing entries                 sequence  (name  url  xml id) enumerate(self  get menu entries())                      name existing page names                          url                              newpath   self env  website   new page(name         self name  template xml id  ispage false)  url                               url     event     slug(self)     page     newpath 1                           self env  website menu   create(                               name   name                               url   url                               parent id   event menu id id                               sequence   sequence                           )       api multi     def  compute website menu(self)          event self              event website menu   bool(event menu id)       api multi     def google map img(self  zoom 8  width 298  height 298)          self ensure one()         self address id              return self sudo() address id google map img(zoom zoom  width width  height height)         return none       api multi     def google map link(self  zoom 8)          self ensure one()         self address id              return self sudo() address id google map link(zoom zoom)         return none       api multi     def  track subtype(self  init values)          self ensure one()          website published  init values self website published              return  website event mt event published          elif  website published  init values self website published              return  website event mt event unpublished          return super(event  self)  track subtype(init values)       api multi     def action open badge editor(self)              open event badge editor   redirect report page event badge report            coding  utf 8        allow public user see participating label    avoid perform slug yet saved record case onchange     remove entries exist anymore    create missing entries ", "content": "# -*- coding: utf-8 -*-\n\nfrom odoo import api, fields, models, _\nfrom odoo.addons.http_routing.models.ir_http import slug\n\n\nclass EventType(models.Model):\n    _name = 'event.type'\n    _inherit = ['event.type']\n\n    website_menu = fields.Boolean(\n        'Display a dedicated menu on Website')\n\n\nclass Event(models.Model):\n    _name = 'event.event'\n    _inherit = ['event.event', 'website.seo.metadata', 'website.published.mixin']\n\n    website_published = fields.Boolean(track_visibility='onchange')\n\n    is_participating = fields.Boolean(\"Is Participating\", compute=\"_compute_is_participating\")\n\n    website_menu = fields.Boolean(\n        'Dedicated Menu', compute='_compute_website_menu', inverse='_set_website_menu',\n        help=\"Creates menus Introduction, Location and Register on the page \"\n             \" of the event on the website.\", store=True)\n    menu_id = fields.Many2one('website.menu', 'Event Menu', copy=False)\n\n    def _compute_is_participating(self):\n        # we don't allow public user to see participating label\n        if self.env.user != self.env.ref('base.public_user'):\n            email = self.env.user.partner_id.email\n            for event in self:\n                domain = ['&', '|', ('email', '=', email), ('partner_id', '=', self.env.user.partner_id.id), ('event_id', '=', event.id)]\n                event.is_participating = self.env['event.registration'].search_count(domain)\n\n    @api.multi\n    @api.depends('name')\n    def _compute_website_url(self):\n        super(Event, self)._compute_website_url()\n        for event in self:\n            if event.id:  # avoid to perform a slug on a not yet saved record in case of an onchange.\n                event.website_url = '/event/%s' % slug(event)\n\n    @api.onchange('event_type_id')\n    def _onchange_type(self):\n        super(Event, self)._onchange_type()\n        if self.event_type_id:\n            self.website_menu = self.event_type_id.website_menu\n\n    def _get_standard_menu_entries_names(self):\n        \"\"\" Method returning menu entries possibly generated by event modules.\n        It is used to distinguish module-generated pages from custom pages. \"\"\"\n        return [_('Introduction'), _('Location'), _('Register')]\n\n    def _get_menu_entries(self):\n        \"\"\" Method returning menu entries to display on the website view of the\n        event, possibly depending on some options in inheriting modules. \"\"\"\n        self.ensure_one()\n        return [\n            (_('Introduction'), False, 'website_event.template_intro'),\n            (_('Location'), False, 'website_event.template_location'),\n            (_('Register'), '/event/%s/register' % slug(self), False),\n        ]\n\n    @api.multi\n    def _set_website_menu(self):\n        for event in self:\n            if event.menu_id and not event.website_menu:\n                event.menu_id.unlink()\n            elif event.website_menu:\n                if not event.menu_id:\n                    root_menu = self.env['website.menu'].create({'name': event.name})\n                    event.menu_id = root_menu\n\n                existing_page_names = event.menu_id.child_id.mapped('name')\n                required_page_names = [entry[0] for entry in self._get_menu_entries()]\n                standard_page_names = self._get_standard_menu_entries_names()\n\n                # remove entries that should not exist anymore\n                submenu_to_delete = event.menu_id.child_id.filtered(lambda menu: menu.name not in required_page_names and menu.name in standard_page_names)\n                submenu_to_delete.unlink()\n\n                # create missing entries\n                for sequence, (name, url, xml_id) in enumerate(self._get_menu_entries()):\n                    if name not in existing_page_names:\n                        if not url:\n                            newpath = self.env['website'].new_page(name + ' ' + self.name, template=xml_id, ispage=False)['url']\n                            url = \"/event/\" + slug(self) + \"/page/\" + newpath[1:]\n                        self.env['website.menu'].create({\n                            'name': name,\n                            'url': url,\n                            'parent_id': event.menu_id.id,\n                            'sequence': sequence,\n                        })\n\n    @api.multi\n    def _compute_website_menu(self):\n        for event in self:\n            event.website_menu = bool(event.menu_id)\n\n    @api.multi\n    def google_map_img(self, zoom=8, width=298, height=298):\n        self.ensure_one()\n        if self.address_id:\n            return self.sudo().address_id.google_map_img(zoom=zoom, width=width, height=height)\n        return None\n\n    @api.multi\n    def google_map_link(self, zoom=8):\n        self.ensure_one()\n        if self.address_id:\n            return self.sudo().address_id.google_map_link(zoom=zoom)\n        return None\n\n    @api.multi\n    def _track_subtype(self, init_values):\n        self.ensure_one()\n        if 'website_published' in init_values and self.website_published:\n            return 'website_event.mt_event_published'\n        elif 'website_published' in init_values and not self.website_published:\n            return 'website_event.mt_event_unpublished'\n        return super(Event, self)._track_subtype(init_values)\n\n    @api.multi\n    def action_open_badge_editor(self):\n        \"\"\" open the event badge editor : redirect to the report page of event badge report \"\"\"\n        self.ensure_one()\n        return {\n            'type': 'ir.actions.act_url',\n            'target': 'new',\n            'url': '/report/html/%s/%s?enable_editor' % ('event.event_event_report_template_badge', self.id),\n        }\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "event.py", "id": "7b7789ba324c6ec0c2d2398ae6fffa6b", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/website_event/models/event.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}