{"author": "pallets", "code": "\n\n\n    indent = None\n    separators = (',', ':')\n\n    if current_app.config['JSONIFY_PRETTYPRINT_REGULAR'] or current_app.debug:\n        indent = 2\n        separators = (', ', ': ')\n\n    if args and kwargs:\n        raise TypeError('jsonify() behavior undefined when passed both args and kwargs')\n    elif len(args) == 1:  \n        data = args[0]\n    else:\n        data = args or kwargs\n\n    return current_app.response_class(\n        dumps(data, indent=indent, separators=separators) + '\\n',\n        mimetype=current_app.config['JSONIFY_MIMETYPE']\n    )\n\n\ndef tojson_filter(obj, **kwargs):\n    return Markup(htmlsafe_dumps(obj, **kwargs))\n", "comments": "\nflask.json\n~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport io\nimport uuid\nfrom datetime import date, datetime\nfrom flask.globals import current_app, request\nfrom flask._compat import text_type, PY2\n\nfrom werkzeug.http import http_date\nfrom jinja2 import Markup\n\n# Use the same json implementation as itsdangerous on which we\n# depend anyways.\nfrom itsdangerous import json as _json\n\n\n# Figure out if simplejson escapes slashes.  This behavior was changed\n# from one version to another without reason.\n_slash_escape = '\\\\/' not in _json.dumps('/')\n\n\n__all__ = ['dump', 'dumps', 'load', 'loads', 'htmlsafe_dump',\n           'htmlsafe_dumps', 'JSONDecoder', 'JSONEncoder',\n           'jsonify']\n\n\ndef _wrap_reader_for_text(fp, encoding):\n    if isinstance(fp.read(0), bytes):\n        fp = io.TextIOWrapper(io.BufferedReader(fp), encoding)\n    return fp\n\n\ndef _wrap_writer_for_text(fp, encoding):\n    try:\n        fp.write('')\n    except TypeError:\n        fp = io.TextIOWrapper(fp, encoding)\n    return fp\n\n\nclass JSONEncoder(_json.JSONEncoder):\n    \"\"\"The default Flask JSON encoder.  This one extends the default simplejson\n    encoder by also supporting ``datetime`` objects, ``UUID`` as well as\n    ``Markup`` objects which are serialized as RFC 822 datetime strings (same\n    as the HTTP date format).  In order to support more data types override the\n    :meth:`default` method.\n    \"\"\"\n\n    def default(self, o):\n        \"\"\"Implement this method in a subclass such that it returns a\n        serializable object for ``o``, or calls the base implementation (to\n        raise a :exc:`TypeError`).\n\n        For example, to support arbitrary iterators, you could implement\n        default like this::\n\n            def default(self, o):\n                try:\n                    iterable = iter(o)\n                except TypeError:\n                    pass\n                else:\n                    return list(iterable)\n                return JSONEncoder.default(self, o)\n        \"\"\"\n        if isinstance(o, datetime):\n            return http_date(o.utctimetuple())\n        if isinstance(o, date):\n            return http_date(o.timetuple())\n        if isinstance(o, uuid.UUID):\n            return str(o)\n        if hasattr(o, '__html__'):\n            return text_type(o.__html__())\n        return _json.JSONEncoder.default(self, o)\n\n\nclass JSONDecoder(_json.JSONDecoder):\n    \"\"\"The default JSON decoder.  This one does not change the behavior from\n    the default simplejson decoder.  Consult the :mod:`json` documentation\n    for more information.  This decoder is not only used for the load\n    functions of this module but also :attr:`~flask.Request`.\n    \"\"\"\n\n\ndef _dump_arg_defaults(kwargs):\n    \"\"\"Inject default arguments for dump functions.\"\"\"\n    if current_app:\n        bp = current_app.blueprints.get(request.blueprint) if request else None\n        kwargs.setdefault(\n            'cls',\n            bp.json_encoder if bp and bp.json_encoder\n                else current_app.json_encoder\n        )\n\n        if not current_app.config['JSON_AS_ASCII']:\n            kwargs.setdefault('ensure_ascii', False)\n\n        kwargs.setdefault('sort_keys', current_app.config['JSON_SORT_KEYS'])\n    else:\n        kwargs.setdefault('sort_keys', True)\n        kwargs.setdefault('cls', JSONEncoder)\n\n\ndef _load_arg_defaults(kwargs):\n    \"\"\"Inject default arguments for load functions.\"\"\"\n    if current_app:\n        bp = current_app.blueprints.get(request.blueprint) if request else None\n        kwargs.setdefault(\n            'cls',\n            bp.json_decoder if bp and bp.json_decoder\n                else current_app.json_decoder\n        )\n    else:\n        kwargs.setdefault('cls', JSONDecoder)\n\n\ndef dumps(obj, **kwargs):\n    \"\"\"Serialize ``obj`` to a JSON formatted ``str`` by using the application's\n    configured encoder (:attr:`~flask.Flask.json_encoder`) if there is an\n    application on the stack.\n\n    This function can return ``unicode`` strings or ascii-only bytestrings by\n    default which coerce into unicode strings automatically.  That behavior by\n    default is controlled by the ``JSON_AS_ASCII`` configuration variable\n    and can be overridden by the simplejson ``ensure_ascii`` parameter.\n    \"\"\"\n    _dump_arg_defaults(kwargs)\n    encoding = kwargs.pop('encoding', None)\n    rv = _json.dumps(obj, **kwargs)\n    if encoding is not None and isinstance(rv, text_type):\n        rv = rv.encode(encoding)\n    return rv\n\n\ndef dump(obj, fp, **kwargs):\n    \"\"\"Like :func:`dumps` but writes into a file object.\"\"\"\n    _dump_arg_defaults(kwargs)\n    encoding = kwargs.pop('encoding', None)\n    if encoding is not None:\n        fp = _wrap_writer_for_text(fp, encoding)\n    _json.dump(obj, fp, **kwargs)\n\n\ndef loads(s, **kwargs):\n    \"\"\"Unserialize a JSON object from a string ``s`` by using the application's\n    configured decoder (:attr:`~flask.Flask.json_decoder`) if there is an\n    application on the stack.\n    \"\"\"\n    _load_arg_defaults(kwargs)\n    if isinstance(s, bytes):\n        s = s.decode(kwargs.pop('encoding', None) or 'utf-8')\n    return _json.loads(s, **kwargs)\n\n\ndef load(fp, **kwargs):\n    \"\"\"Like :func:`loads` but reads from a file object.\n    \"\"\"\n    _load_arg_defaults(kwargs)\n    if not PY2:\n        fp = _wrap_reader_for_text(fp, kwargs.pop('encoding', None) or 'utf-8')\n    return _json.load(fp, **kwargs)\n\n\ndef htmlsafe_dumps(obj, **kwargs):\n    \"\"\"Works exactly like :func:`dumps` but is safe for use in ``<script>``\n    tags.  It accepts the same arguments and returns a JSON string.  Note that\n    this is available in templates through the ``|tojson`` filter which will\n    also mark the result as safe.  Due to how this function escapes certain\n    characters this is safe even if used outside of ``<script>`` tags.\n\n    The following characters are escaped in strings:\n\n    -   ``<``\n    -   ``>``\n    -   ``&``\n    -   ``'``\n\n    This makes it safe to embed such strings in any place in HTML with the\n    notable exception of double quoted attributes.  In that case single\n    quote your attributes or HTML escape it in addition.\n\n    .. versionchanged:: 0.10\n       This function's return value is now always safe for HTML usage, even\n       if outside of script tags or if used in XHTML.  This rule does not\n       hold true when using this function in HTML attributes that are double\n       quoted.  Always single quote attributes if you use the ``|tojson``\n       filter.  Alternatively use ``|tojson|forceescape``.\n    \"\"\"\n    rv = dumps(obj, **kwargs) \\\n        .replace(u'<', u'\\\\u003c') \\\n        .replace(u'>', u'\\\\u003e') \\\n        .replace(u'&', u'\\\\u0026') \\\n        .replace(u\"'\", u'\\\\u0027')\n    if not _slash_escape:\n        rv = rv.replace('\\\\/', '/')\n    return rv\n\n\ndef htmlsafe_dump(obj, fp, **kwargs):\n    \"\"\"Like :func:`htmlsafe_dumps` but writes into a file object.\"\"\"\n    fp.write(text_type(htmlsafe_dumps(obj, **kwargs)))\n\n\ndef jsonify(*args, **kwargs):\n    \"\"\"This function wraps :func:`dumps` to add a few enhancements that make\n    life easier.  It turns the JSON output into a :class:`~flask.Response`\n    object with the :mimetype:`application/json` mimetype.  For convenience, it\n    also converts multiple arguments into an array or multiple keyword arguments\n    into a dict.  This means that both ``jsonify(1,2,3)`` and\n    ``jsonify([1,2,3])`` serialize to ``[1,2,3]``.\n\n    For clarity, the JSON serialization behavior has the following differences\n    from :func:`dumps`:\n\n    1. Single argument: Passed straight through to :func:`dumps`.\n    2. Multiple arguments: Converted to an array before being passed to\n       :func:`dumps`.\n    3. Multiple keyword arguments: Converted to a dict before being passed to\n       :func:`dumps`.\n    4. Both args and kwargs: Behavior undefined and will throw an exception.\n\n    Example usage::\n\n        from flask import jsonify\n\n        @app.route('/_get_current_user')\n        def get_current_user():\n            return jsonify(username=g.user.username,\n                           email=g.user.email,\n                           id=g.user.id)\n\n    This will send a JSON response like this to the browser::\n\n        {\n            \"username\": \"admin\",\n            \"email\": \"admin@localhost\",\n            \"id\": 42\n        }\n\n\n    .. versionchanged:: 0.11\n       Added support for serializing top-level arrays. This introduces a\n       security risk in ancient browsers. See :ref:`json-security` for details.\n\n    This function's response will be pretty printed if the\n    ``JSONIFY_PRETTYPRINT_REGULAR`` config parameter is set to True or the\n    Flask app is running in debug mode. Compressed (not pretty) formatting\n    currently means no indents and no spaces after separators.\n\n    .. versionadded:: 0.2\n    \n \n# -*- coding: utf-8 -*-\n# single args are passed directly to dumps()\n", "content": "# -*- coding: utf-8 -*-\n\"\"\"\nflask.json\n~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport io\nimport uuid\nfrom datetime import date, datetime\nfrom flask.globals import current_app, request\nfrom flask._compat import text_type, PY2\n\nfrom werkzeug.http import http_date\nfrom jinja2 import Markup\n\n# Use the same json implementation as itsdangerous on which we\n# depend anyways.\nfrom itsdangerous import json as _json\n\n\n# Figure out if simplejson escapes slashes.  This behavior was changed\n# from one version to another without reason.\n_slash_escape = '\\\\/' not in _json.dumps('/')\n\n\n__all__ = ['dump', 'dumps', 'load', 'loads', 'htmlsafe_dump',\n           'htmlsafe_dumps', 'JSONDecoder', 'JSONEncoder',\n           'jsonify']\n\n\ndef _wrap_reader_for_text(fp, encoding):\n    if isinstance(fp.read(0), bytes):\n        fp = io.TextIOWrapper(io.BufferedReader(fp), encoding)\n    return fp\n\n\ndef _wrap_writer_for_text(fp, encoding):\n    try:\n        fp.write('')\n    except TypeError:\n        fp = io.TextIOWrapper(fp, encoding)\n    return fp\n\n\nclass JSONEncoder(_json.JSONEncoder):\n    \"\"\"The default Flask JSON encoder.  This one extends the default simplejson\n    encoder by also supporting ``datetime`` objects, ``UUID`` as well as\n    ``Markup`` objects which are serialized as RFC 822 datetime strings (same\n    as the HTTP date format).  In order to support more data types override the\n    :meth:`default` method.\n    \"\"\"\n\n    def default(self, o):\n        \"\"\"Implement this method in a subclass such that it returns a\n        serializable object for ``o``, or calls the base implementation (to\n        raise a :exc:`TypeError`).\n\n        For example, to support arbitrary iterators, you could implement\n        default like this::\n\n            def default(self, o):\n                try:\n                    iterable = iter(o)\n                except TypeError:\n                    pass\n                else:\n                    return list(iterable)\n                return JSONEncoder.default(self, o)\n        \"\"\"\n        if isinstance(o, datetime):\n            return http_date(o.utctimetuple())\n        if isinstance(o, date):\n            return http_date(o.timetuple())\n        if isinstance(o, uuid.UUID):\n            return str(o)\n        if hasattr(o, '__html__'):\n            return text_type(o.__html__())\n        return _json.JSONEncoder.default(self, o)\n\n\nclass JSONDecoder(_json.JSONDecoder):\n    \"\"\"The default JSON decoder.  This one does not change the behavior from\n    the default simplejson decoder.  Consult the :mod:`json` documentation\n    for more information.  This decoder is not only used for the load\n    functions of this module but also :attr:`~flask.Request`.\n    \"\"\"\n\n\ndef _dump_arg_defaults(kwargs):\n    \"\"\"Inject default arguments for dump functions.\"\"\"\n    if current_app:\n        bp = current_app.blueprints.get(request.blueprint) if request else None\n        kwargs.setdefault(\n            'cls',\n            bp.json_encoder if bp and bp.json_encoder\n                else current_app.json_encoder\n        )\n\n        if not current_app.config['JSON_AS_ASCII']:\n            kwargs.setdefault('ensure_ascii', False)\n\n        kwargs.setdefault('sort_keys', current_app.config['JSON_SORT_KEYS'])\n    else:\n        kwargs.setdefault('sort_keys', True)\n        kwargs.setdefault('cls', JSONEncoder)\n\n\ndef _load_arg_defaults(kwargs):\n    \"\"\"Inject default arguments for load functions.\"\"\"\n    if current_app:\n        bp = current_app.blueprints.get(request.blueprint) if request else None\n        kwargs.setdefault(\n            'cls',\n            bp.json_decoder if bp and bp.json_decoder\n                else current_app.json_decoder\n        )\n    else:\n        kwargs.setdefault('cls', JSONDecoder)\n\n\ndef dumps(obj, **kwargs):\n    \"\"\"Serialize ``obj`` to a JSON formatted ``str`` by using the application's\n    configured encoder (:attr:`~flask.Flask.json_encoder`) if there is an\n    application on the stack.\n\n    This function can return ``unicode`` strings or ascii-only bytestrings by\n    default which coerce into unicode strings automatically.  That behavior by\n    default is controlled by the ``JSON_AS_ASCII`` configuration variable\n    and can be overridden by the simplejson ``ensure_ascii`` parameter.\n    \"\"\"\n    _dump_arg_defaults(kwargs)\n    encoding = kwargs.pop('encoding', None)\n    rv = _json.dumps(obj, **kwargs)\n    if encoding is not None and isinstance(rv, text_type):\n        rv = rv.encode(encoding)\n    return rv\n\n\ndef dump(obj, fp, **kwargs):\n    \"\"\"Like :func:`dumps` but writes into a file object.\"\"\"\n    _dump_arg_defaults(kwargs)\n    encoding = kwargs.pop('encoding', None)\n    if encoding is not None:\n        fp = _wrap_writer_for_text(fp, encoding)\n    _json.dump(obj, fp, **kwargs)\n\n\ndef loads(s, **kwargs):\n    \"\"\"Unserialize a JSON object from a string ``s`` by using the application's\n    configured decoder (:attr:`~flask.Flask.json_decoder`) if there is an\n    application on the stack.\n    \"\"\"\n    _load_arg_defaults(kwargs)\n    if isinstance(s, bytes):\n        s = s.decode(kwargs.pop('encoding', None) or 'utf-8')\n    return _json.loads(s, **kwargs)\n\n\ndef load(fp, **kwargs):\n    \"\"\"Like :func:`loads` but reads from a file object.\n    \"\"\"\n    _load_arg_defaults(kwargs)\n    if not PY2:\n        fp = _wrap_reader_for_text(fp, kwargs.pop('encoding', None) or 'utf-8')\n    return _json.load(fp, **kwargs)\n\n\ndef htmlsafe_dumps(obj, **kwargs):\n    \"\"\"Works exactly like :func:`dumps` but is safe for use in ``<script>``\n    tags.  It accepts the same arguments and returns a JSON string.  Note that\n    this is available in templates through the ``|tojson`` filter which will\n    also mark the result as safe.  Due to how this function escapes certain\n    characters this is safe even if used outside of ``<script>`` tags.\n\n    The following characters are escaped in strings:\n\n    -   ``<``\n    -   ``>``\n    -   ``&``\n    -   ``'``\n\n    This makes it safe to embed such strings in any place in HTML with the\n    notable exception of double quoted attributes.  In that case single\n    quote your attributes or HTML escape it in addition.\n\n    .. versionchanged:: 0.10\n       This function's return value is now always safe for HTML usage, even\n       if outside of script tags or if used in XHTML.  This rule does not\n       hold true when using this function in HTML attributes that are double\n       quoted.  Always single quote attributes if you use the ``|tojson``\n       filter.  Alternatively use ``|tojson|forceescape``.\n    \"\"\"\n    rv = dumps(obj, **kwargs) \\\n        .replace(u'<', u'\\\\u003c') \\\n        .replace(u'>', u'\\\\u003e') \\\n        .replace(u'&', u'\\\\u0026') \\\n        .replace(u\"'\", u'\\\\u0027')\n    if not _slash_escape:\n        rv = rv.replace('\\\\/', '/')\n    return rv\n\n\ndef htmlsafe_dump(obj, fp, **kwargs):\n    \"\"\"Like :func:`htmlsafe_dumps` but writes into a file object.\"\"\"\n    fp.write(text_type(htmlsafe_dumps(obj, **kwargs)))\n\n\ndef jsonify(*args, **kwargs):\n    \"\"\"This function wraps :func:`dumps` to add a few enhancements that make\n    life easier.  It turns the JSON output into a :class:`~flask.Response`\n    object with the :mimetype:`application/json` mimetype.  For convenience, it\n    also converts multiple arguments into an array or multiple keyword arguments\n    into a dict.  This means that both ``jsonify(1,2,3)`` and\n    ``jsonify([1,2,3])`` serialize to ``[1,2,3]``.\n\n    For clarity, the JSON serialization behavior has the following differences\n    from :func:`dumps`:\n\n    1. Single argument: Passed straight through to :func:`dumps`.\n    2. Multiple arguments: Converted to an array before being passed to\n       :func:`dumps`.\n    3. Multiple keyword arguments: Converted to a dict before being passed to\n       :func:`dumps`.\n    4. Both args and kwargs: Behavior undefined and will throw an exception.\n\n    Example usage::\n\n        from flask import jsonify\n\n        @app.route('/_get_current_user')\n        def get_current_user():\n            return jsonify(username=g.user.username,\n                           email=g.user.email,\n                           id=g.user.id)\n\n    This will send a JSON response like this to the browser::\n\n        {\n            \"username\": \"admin\",\n            \"email\": \"admin@localhost\",\n            \"id\": 42\n        }\n\n\n    .. versionchanged:: 0.11\n       Added support for serializing top-level arrays. This introduces a\n       security risk in ancient browsers. See :ref:`json-security` for details.\n\n    This function's response will be pretty printed if the\n    ``JSONIFY_PRETTYPRINT_REGULAR`` config parameter is set to True or the\n    Flask app is running in debug mode. Compressed (not pretty) formatting\n    currently means no indents and no spaces after separators.\n\n    .. versionadded:: 0.2\n    \"\"\"\n\n    indent = None\n    separators = (',', ':')\n\n    if current_app.config['JSONIFY_PRETTYPRINT_REGULAR'] or current_app.debug:\n        indent = 2\n        separators = (', ', ': ')\n\n    if args and kwargs:\n        raise TypeError('jsonify() behavior undefined when passed both args and kwargs')\n    elif len(args) == 1:  # single args are passed directly to dumps()\n        data = args[0]\n    else:\n        data = args or kwargs\n\n    return current_app.response_class(\n        dumps(data, indent=indent, separators=separators) + '\\n',\n        mimetype=current_app.config['JSONIFY_MIMETYPE']\n    )\n\n\ndef tojson_filter(obj, **kwargs):\n    return Markup(htmlsafe_dumps(obj, **kwargs))\n", "description": "The Python micro framework for building web applications.", "file_name": "__init__.py", "language": "Python", "project_name": "flask", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/pallets_flask/pallets-flask-a2ea186/flask/json/__init__.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:52:03Z", "url": "https://github.com/pallets/flask", "wiki": false}