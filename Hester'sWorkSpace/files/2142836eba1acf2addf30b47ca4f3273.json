{"author": "HelloZeroNet", "code": "import logging\nimport time\nimport sys\nfrom collections import defaultdict\n\nimport gevent\nimport msgpack\nfrom gevent.server import StreamServer\nfrom gevent.pool import Pool\n\nimport util\nfrom Debug import Debug\nfrom Connection import Connection\nfrom Config import config\nfrom Crypt import CryptConnection\nfrom Crypt import CryptHash\nfrom Tor import TorManager\nfrom Site import SiteManager\n\n\nclass ConnectionServer(object):\n    def __init__(self, ip=None, port=None, request_handler=None):\n        self.ip = ip\n        self.port = port\n        self.last_connection_id = 1  \n        self.log = logging.getLogger(\"ConnServer\")\n        self.port_opened = None\n        self.peer_blacklist = SiteManager.peer_blacklist\n\n        if config.tor != \"disabled\":\n            self.tor_manager = TorManager(self.ip, self.port)\n        else:\n            self.tor_manager = None\n\n        self.connections = []  \n        self.whitelist = config.ip_local  \n        self.ip_incoming = {}  \n        self.broken_ssl_peer_ids = {}  \n        self.ips = {}  \n        self.has_internet = True  \n\n        self.stream_server = None\n        self.running = True\n        self.thread_checker = gevent.spawn(self.checkConnections)\n\n        self.stat_recv = defaultdict(lambda: defaultdict(int))\n        self.stat_sent = defaultdict(lambda: defaultdict(int))\n        self.bytes_recv = 0\n        self.bytes_sent = 0\n        self.num_recv = 0\n        self.num_sent = 0\n\n        \n        self.peer_id = \"-ZN0%s-%s\" % (config.version.replace(\".\", \"\"), CryptHash.random(12, \"base64\"))\n\n        \n        if msgpack.version[0] == 0 and msgpack.version[1] < 4:\n            self.log.error(\n                \"Error: Unsupported msgpack version: %s (<0.4.0), please run `sudo apt-get install python-pip; sudo pip install msgpack --upgrade`\" %\n                str(msgpack.version)\n            )\n            sys.exit(0)\n\n        if port:  \n            self.pool = Pool(500)  \n            self.stream_server = StreamServer(\n                (ip.replace(\"*\", \"0.0.0.0\"), port), self.handleIncomingConnection, spawn=self.pool, backlog=100\n            )\n            if request_handler:\n                self.handleRequest = request_handler\n\n    def start(self):\n        self.running = True\n        CryptConnection.manager.loadCerts()\n        self.log.debug(\"Binding to: %s:%s, (msgpack: %s), supported crypt: %s\" % (\n            self.ip, self.port,\n            \".\".join(map(str, msgpack.version)), CryptConnection.manager.crypt_supported)\n        )\n        try:\n            self.stream_server.serve_forever()  \n        except Exception, err:\n            self.log.info(\"StreamServer bind error, must be running already: %s\" % err)\n\n    def stop(self):\n        self.running = False\n        if self.stream_server:\n            self.stream_server.stop()\n\n    def handleIncomingConnection(self, sock, addr):\n        ip, port = addr\n\n        \n        if ip in self.ip_incoming and ip not in self.whitelist:\n            self.ip_incoming[ip] += 1\n            if self.ip_incoming[ip] > 6:  \n                self.log.debug(\"Connection flood detected from %s\" % ip)\n                time.sleep(30)\n                sock.close()\n                return False\n        else:\n            self.ip_incoming[ip] = 1\n\n        connection = Connection(self, ip, port, sock)\n        self.connections.append(connection)\n        if ip not in config.ip_local:\n            self.ips[ip] = connection\n        connection.handleIncomingConnection(sock)\n\n    def handleMessage(self, *args, **kwargs):\n        pass\n\n    def getConnection(self, ip=None, port=None, peer_id=None, create=True, site=None):\n        if ip.endswith(\".onion\") and self.tor_manager.start_onions and site:  \n            site_onion = self.tor_manager.getOnion(site.address)\n            key = ip + site_onion\n        else:\n            key = ip\n\n        \n        if key in self.ips:\n            connection = self.ips[key]\n            if not peer_id or connection.handshake.get(\"peer_id\") == peer_id:  \n                if not connection.connected and create:\n                    succ = connection.event_connected.get()  \n                    if not succ:\n                        raise Exception(\"Connection event return error\")\n                return connection\n\n            \n            for connection in self.connections:\n                if connection.ip == ip:\n                    if peer_id and connection.handshake.get(\"peer_id\") != peer_id:  \n                        continue\n                    if ip.endswith(\".onion\") and self.tor_manager.start_onions and ip.replace(\".onion\", \"\") != connection.target_onion:\n                        \n                        continue\n                    if not connection.connected and create:\n                        succ = connection.event_connected.get()  \n                        if not succ:\n                            raise Exception(\"Connection event return error\")\n                    return connection\n\n        \n        if create:  \n            if port == 0:\n                raise Exception(\"This peer is not connectable\")\n\n            if (ip, port) in self.peer_blacklist:\n                raise Exception(\"This peer is blacklisted\")\n\n            try:\n                if ip.endswith(\".onion\") and self.tor_manager.start_onions and site:  \n                    connection = Connection(self, ip, port, target_onion=site_onion)\n                else:\n                    connection = Connection(self, ip, port)\n                self.ips[key] = connection\n                self.connections.append(connection)\n                succ = connection.connect()\n                if not succ:\n                    connection.close(\"Connection event return error\")\n                    raise Exception(\"Connection event return error\")\n\n            except Exception, err:\n                connection.close(\"%s Connect error: %s\" % (ip, Debug.formatException(err)))\n                raise err\n\n            if len(self.connections) > config.global_connected_limit:\n                gevent.spawn(self.checkMaxConnections)\n\n            return connection\n        else:\n            return None\n\n    def removeConnection(self, connection):\n        \n        if self.ips.get(connection.ip) == connection:\n            del self.ips[connection.ip]\n        \n        if connection.target_onion:\n            if self.ips.get(connection.ip + connection.target_onion) == connection:\n                del self.ips[connection.ip + connection.target_onion]\n        \n        if connection.cert_pin and self.ips.get(connection.ip + \"\n            del self.ips[connection.ip + \"\n\n        if connection in self.connections:\n            self.connections.remove(connection)\n\n    def checkConnections(self):\n        run_i = 0\n        while self.running:\n            run_i += 1\n            time.sleep(15)  \n            self.ip_incoming = {}  \n            self.broken_ssl_peer_ids = {}  \n            last_message_time = 0\n            s = time.time()\n            for connection in self.connections[:]:  \n                if connection.ip.endswith(\".onion\"):\n                    timeout_multipler = 2\n                else:\n                    timeout_multipler = 1\n\n                idle = time.time() - max(connection.last_recv_time, connection.start_time, connection.last_message_time)\n                if connection.last_message_time > last_message_time and not connection.is_private_ip:\n                    \n                    last_message_time = connection.last_message_time\n\n                if connection.unpacker and idle > 30:\n                    \n                    del connection.unpacker\n                    connection.unpacker = None\n\n                elif connection.last_cmd_sent == \"announce\" and idle > 20:  \n                    connection.close(\"[Cleanup] Tracker connection: %s\" % idle)\n\n                if idle > 60 * 60:\n                    \n                    connection.close(\"[Cleanup] After wakeup, idle: %s\" % idle)\n\n                elif idle > 20 * 60 and connection.last_send_time < time.time() - 10:\n                    \n                    if not connection.ping():\n                        connection.close(\"[Cleanup] Ping timeout\")\n\n                elif idle > 10 * timeout_multipler and connection.incomplete_buff_recv > 0:\n                    \n                    connection.close(\"[Cleanup] Connection buff stalled\")\n\n                elif idle > 10 * timeout_multipler and connection.protocol == \"?\":  \n                    connection.close(\n                        \"[Cleanup] Connect timeout: %.3fs\" % idle\n                    )\n\n                elif idle > 10 * timeout_multipler and connection.waiting_requests and time.time() - connection.last_send_time > 10 * timeout_multipler:\n                    \n                    connection.close(\n                        \"[Cleanup] Command %s timeout: %.3fs\" % (connection.last_cmd_sent, time.time() - connection.last_send_time)\n                    )\n\n                elif idle < 60 and connection.bad_actions > 40:\n                    connection.close(\n                        \"[Cleanup] Too many bad actions: %s\" % connection.bad_actions\n                    )\n\n                elif idle > 5 * 60 and connection.sites == 0:\n                    connection.close(\n                        \"[Cleanup] No site for connection\"\n                    )\n\n                elif run_i % 90 == 0:\n                    \n                    connection.bad_actions = 0\n\n            \n            if time.time() - last_message_time > max(60, 60 * 10 / max(1, float(len(self.connections)) / 50)):\n                \n                if self.has_internet:\n                    self.has_internet = False\n                    self.onInternetOffline()\n            else:\n                \n                if not self.has_internet:\n                    self.has_internet = True\n                    self.onInternetOnline()\n\n            if time.time() - s > 0.01:\n                self.log.debug(\"Connection cleanup in %.3fs\" % (time.time() - s))\n\n    @util.Noparallel(blocking=False)\n    def checkMaxConnections(self):\n        if len(self.connections) < config.global_connected_limit:\n            return 0\n\n        s = time.time()\n        num_connected_before = len(self.connections)\n        self.connections.sort(key=lambda connection: connection.sites)\n        num_closed = 0\n        for connection in self.connections:\n            idle = time.time() - max(connection.last_recv_time, connection.start_time, connection.last_message_time)\n            if idle > 60:\n                connection.close(\"Connection limit reached\")\n                num_closed += 1\n            if num_closed > config.global_connected_limit * 0.1:\n                break\n\n        self.log.debug(\"Closed %s connections of %s after reached limit %s in %.3fs\" % (\n            num_closed, num_connected_before, config.global_connected_limit, time.time() - s\n        ))\n        return num_closed\n\n    def onInternetOnline(self):\n        self.log.info(\"Internet online\")\n\n    def onInternetOffline(self):\n        self.log.info(\"Internet offline\")\n", "comments": "connection id incrementer connections no flood protection ips incoming connections ip last minute avoid connection flood peerids broken ssl connections connection ip internet outage detection bittorrent style peerid check msgpack version listen server port accept 500 connections start normal connection server connection flood protection allow 6 1 minute ip site-unique connection tor find connection ip filter peer_id wait connection recover connection pool does match for different site wait connection no connection found allow create new connection found lock connection site delete registry site locked connection cert pinned connection \" + connection.cert_pin) == connection: \" + connection.cert_pin] check every minute reset connected ips counter reset broken ssl peerids count make copy message local ips means internet connection delete unpacker needed bootstrapper connection close 20 sec wake 1h idle 20 min sent request last 10 sec incomplete data 10 sec idle no connection 10 sec sent command response 10 sec reset bad action counter every 30 min internet outage detection offline: last message 60-600sec depending connection number online", "content": "import logging\nimport time\nimport sys\nfrom collections import defaultdict\n\nimport gevent\nimport msgpack\nfrom gevent.server import StreamServer\nfrom gevent.pool import Pool\n\nimport util\nfrom Debug import Debug\nfrom Connection import Connection\nfrom Config import config\nfrom Crypt import CryptConnection\nfrom Crypt import CryptHash\nfrom Tor import TorManager\nfrom Site import SiteManager\n\n\nclass ConnectionServer(object):\n    def __init__(self, ip=None, port=None, request_handler=None):\n        self.ip = ip\n        self.port = port\n        self.last_connection_id = 1  # Connection id incrementer\n        self.log = logging.getLogger(\"ConnServer\")\n        self.port_opened = None\n        self.peer_blacklist = SiteManager.peer_blacklist\n\n        if config.tor != \"disabled\":\n            self.tor_manager = TorManager(self.ip, self.port)\n        else:\n            self.tor_manager = None\n\n        self.connections = []  # Connections\n        self.whitelist = config.ip_local  # No flood protection on this ips\n        self.ip_incoming = {}  # Incoming connections from ip in the last minute to avoid connection flood\n        self.broken_ssl_peer_ids = {}  # Peerids of broken ssl connections\n        self.ips = {}  # Connection by ip\n        self.has_internet = True  # Internet outage detection\n\n        self.stream_server = None\n        self.running = True\n        self.thread_checker = gevent.spawn(self.checkConnections)\n\n        self.stat_recv = defaultdict(lambda: defaultdict(int))\n        self.stat_sent = defaultdict(lambda: defaultdict(int))\n        self.bytes_recv = 0\n        self.bytes_sent = 0\n        self.num_recv = 0\n        self.num_sent = 0\n\n        # Bittorrent style peerid\n        self.peer_id = \"-ZN0%s-%s\" % (config.version.replace(\".\", \"\"), CryptHash.random(12, \"base64\"))\n\n        # Check msgpack version\n        if msgpack.version[0] == 0 and msgpack.version[1] < 4:\n            self.log.error(\n                \"Error: Unsupported msgpack version: %s (<0.4.0), please run `sudo apt-get install python-pip; sudo pip install msgpack --upgrade`\" %\n                str(msgpack.version)\n            )\n            sys.exit(0)\n\n        if port:  # Listen server on a port\n            self.pool = Pool(500)  # do not accept more than 500 connections\n            self.stream_server = StreamServer(\n                (ip.replace(\"*\", \"0.0.0.0\"), port), self.handleIncomingConnection, spawn=self.pool, backlog=100\n            )\n            if request_handler:\n                self.handleRequest = request_handler\n\n    def start(self):\n        self.running = True\n        CryptConnection.manager.loadCerts()\n        self.log.debug(\"Binding to: %s:%s, (msgpack: %s), supported crypt: %s\" % (\n            self.ip, self.port,\n            \".\".join(map(str, msgpack.version)), CryptConnection.manager.crypt_supported)\n        )\n        try:\n            self.stream_server.serve_forever()  # Start normal connection server\n        except Exception, err:\n            self.log.info(\"StreamServer bind error, must be running already: %s\" % err)\n\n    def stop(self):\n        self.running = False\n        if self.stream_server:\n            self.stream_server.stop()\n\n    def handleIncomingConnection(self, sock, addr):\n        ip, port = addr\n\n        # Connection flood protection\n        if ip in self.ip_incoming and ip not in self.whitelist:\n            self.ip_incoming[ip] += 1\n            if self.ip_incoming[ip] > 6:  # Allow 6 in 1 minute from same ip\n                self.log.debug(\"Connection flood detected from %s\" % ip)\n                time.sleep(30)\n                sock.close()\n                return False\n        else:\n            self.ip_incoming[ip] = 1\n\n        connection = Connection(self, ip, port, sock)\n        self.connections.append(connection)\n        if ip not in config.ip_local:\n            self.ips[ip] = connection\n        connection.handleIncomingConnection(sock)\n\n    def handleMessage(self, *args, **kwargs):\n        pass\n\n    def getConnection(self, ip=None, port=None, peer_id=None, create=True, site=None):\n        if ip.endswith(\".onion\") and self.tor_manager.start_onions and site:  # Site-unique connection for Tor\n            site_onion = self.tor_manager.getOnion(site.address)\n            key = ip + site_onion\n        else:\n            key = ip\n\n        # Find connection by ip\n        if key in self.ips:\n            connection = self.ips[key]\n            if not peer_id or connection.handshake.get(\"peer_id\") == peer_id:  # Filter by peer_id\n                if not connection.connected and create:\n                    succ = connection.event_connected.get()  # Wait for connection\n                    if not succ:\n                        raise Exception(\"Connection event return error\")\n                return connection\n\n            # Recover from connection pool\n            for connection in self.connections:\n                if connection.ip == ip:\n                    if peer_id and connection.handshake.get(\"peer_id\") != peer_id:  # Does not match\n                        continue\n                    if ip.endswith(\".onion\") and self.tor_manager.start_onions and ip.replace(\".onion\", \"\") != connection.target_onion:\n                        # For different site\n                        continue\n                    if not connection.connected and create:\n                        succ = connection.event_connected.get()  # Wait for connection\n                        if not succ:\n                            raise Exception(\"Connection event return error\")\n                    return connection\n\n        # No connection found\n        if create:  # Allow to create new connection if not found\n            if port == 0:\n                raise Exception(\"This peer is not connectable\")\n\n            if (ip, port) in self.peer_blacklist:\n                raise Exception(\"This peer is blacklisted\")\n\n            try:\n                if ip.endswith(\".onion\") and self.tor_manager.start_onions and site:  # Lock connection to site\n                    connection = Connection(self, ip, port, target_onion=site_onion)\n                else:\n                    connection = Connection(self, ip, port)\n                self.ips[key] = connection\n                self.connections.append(connection)\n                succ = connection.connect()\n                if not succ:\n                    connection.close(\"Connection event return error\")\n                    raise Exception(\"Connection event return error\")\n\n            except Exception, err:\n                connection.close(\"%s Connect error: %s\" % (ip, Debug.formatException(err)))\n                raise err\n\n            if len(self.connections) > config.global_connected_limit:\n                gevent.spawn(self.checkMaxConnections)\n\n            return connection\n        else:\n            return None\n\n    def removeConnection(self, connection):\n        # Delete if same as in registry\n        if self.ips.get(connection.ip) == connection:\n            del self.ips[connection.ip]\n        # Site locked connection\n        if connection.target_onion:\n            if self.ips.get(connection.ip + connection.target_onion) == connection:\n                del self.ips[connection.ip + connection.target_onion]\n        # Cert pinned connection\n        if connection.cert_pin and self.ips.get(connection.ip + \"#\" + connection.cert_pin) == connection:\n            del self.ips[connection.ip + \"#\" + connection.cert_pin]\n\n        if connection in self.connections:\n            self.connections.remove(connection)\n\n    def checkConnections(self):\n        run_i = 0\n        while self.running:\n            run_i += 1\n            time.sleep(15)  # Check every minute\n            self.ip_incoming = {}  # Reset connected ips counter\n            self.broken_ssl_peer_ids = {}  # Reset broken ssl peerids count\n            last_message_time = 0\n            s = time.time()\n            for connection in self.connections[:]:  # Make a copy\n                if connection.ip.endswith(\".onion\"):\n                    timeout_multipler = 2\n                else:\n                    timeout_multipler = 1\n\n                idle = time.time() - max(connection.last_recv_time, connection.start_time, connection.last_message_time)\n                if connection.last_message_time > last_message_time and not connection.is_private_ip:\n                    # Message from local IPs does not means internet connection\n                    last_message_time = connection.last_message_time\n\n                if connection.unpacker and idle > 30:\n                    # Delete the unpacker if not needed\n                    del connection.unpacker\n                    connection.unpacker = None\n\n                elif connection.last_cmd_sent == \"announce\" and idle > 20:  # Bootstrapper connection close after 20 sec\n                    connection.close(\"[Cleanup] Tracker connection: %s\" % idle)\n\n                if idle > 60 * 60:\n                    # Wake up after 1h\n                    connection.close(\"[Cleanup] After wakeup, idle: %s\" % idle)\n\n                elif idle > 20 * 60 and connection.last_send_time < time.time() - 10:\n                    # Idle more than 20 min and we have not sent request in last 10 sec\n                    if not connection.ping():\n                        connection.close(\"[Cleanup] Ping timeout\")\n\n                elif idle > 10 * timeout_multipler and connection.incomplete_buff_recv > 0:\n                    # Incomplete data with more than 10 sec idle\n                    connection.close(\"[Cleanup] Connection buff stalled\")\n\n                elif idle > 10 * timeout_multipler and connection.protocol == \"?\":  # No connection after 10 sec\n                    connection.close(\n                        \"[Cleanup] Connect timeout: %.3fs\" % idle\n                    )\n\n                elif idle > 10 * timeout_multipler and connection.waiting_requests and time.time() - connection.last_send_time > 10 * timeout_multipler:\n                    # Sent command and no response in 10 sec\n                    connection.close(\n                        \"[Cleanup] Command %s timeout: %.3fs\" % (connection.last_cmd_sent, time.time() - connection.last_send_time)\n                    )\n\n                elif idle < 60 and connection.bad_actions > 40:\n                    connection.close(\n                        \"[Cleanup] Too many bad actions: %s\" % connection.bad_actions\n                    )\n\n                elif idle > 5 * 60 and connection.sites == 0:\n                    connection.close(\n                        \"[Cleanup] No site for connection\"\n                    )\n\n                elif run_i % 90 == 0:\n                    # Reset bad action counter every 30 min\n                    connection.bad_actions = 0\n\n            # Internet outage detection\n            if time.time() - last_message_time > max(60, 60 * 10 / max(1, float(len(self.connections)) / 50)):\n                # Offline: Last message more than 60-600sec depending on connection number\n                if self.has_internet:\n                    self.has_internet = False\n                    self.onInternetOffline()\n            else:\n                # Online\n                if not self.has_internet:\n                    self.has_internet = True\n                    self.onInternetOnline()\n\n            if time.time() - s > 0.01:\n                self.log.debug(\"Connection cleanup in %.3fs\" % (time.time() - s))\n\n    @util.Noparallel(blocking=False)\n    def checkMaxConnections(self):\n        if len(self.connections) < config.global_connected_limit:\n            return 0\n\n        s = time.time()\n        num_connected_before = len(self.connections)\n        self.connections.sort(key=lambda connection: connection.sites)\n        num_closed = 0\n        for connection in self.connections:\n            idle = time.time() - max(connection.last_recv_time, connection.start_time, connection.last_message_time)\n            if idle > 60:\n                connection.close(\"Connection limit reached\")\n                num_closed += 1\n            if num_closed > config.global_connected_limit * 0.1:\n                break\n\n        self.log.debug(\"Closed %s connections of %s after reached limit %s in %.3fs\" % (\n            num_closed, num_connected_before, config.global_connected_limit, time.time() - s\n        ))\n        return num_closed\n\n    def onInternetOnline(self):\n        self.log.info(\"Internet online\")\n\n    def onInternetOffline(self):\n        self.log.info(\"Internet offline\")\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "ConnectionServer.py", "id": "2142836eba1acf2addf30b47ca4f3273", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-3bdb6a2/src/Connection/ConnectionServer.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:21:08Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}