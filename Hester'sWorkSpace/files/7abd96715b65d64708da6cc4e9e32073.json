{"author": "nvbn", "code": "import tarfile\nimport os\nfrom thefuck.utils import for_app\nfrom thefuck.shells import shell\n\n\ntar_extensions = ('.tar', '.tar.Z', '.tar.bz2', '.tar.gz', '.tar.lz',\n                  '.tar.lzma', '.tar.xz', '.taz', '.tb2', '.tbz', '.tbz2',\n                  '.tgz', '.tlz', '.txz', '.tz')\n\n\ndef _is_tar_extract(cmd):\n    if '--extract' in cmd:\n        return True\n\n    cmd = cmd.split()\n\n    return len(cmd) > 1 and 'x' in cmd[1]\n\n\ndef _tar_file(cmd):\n    for c in cmd:\n        for ext in tar_extensions:\n            if c.endswith(ext):\n                return (c, c[0:len(c) - len(ext)])\n\n\n@for_app('tar')\ndef match(command):\n    return ('-C' not in command.script\n            and _is_tar_extract(command.script)\n            and _tar_file(command.script_parts) is not None)\n\n\ndef get_new_command(command):\n    dir = shell.quote(_tar_file(command.script_parts)[1])\n    return shell.and_('mkdir -p {dir}', '{cmd} -C {dir}') \\\n        .format(dir=dir, cmd=command.script)\n\n\ndef side_effect(old_cmd, command):\n    with tarfile.TarFile(_tar_file(old_cmd.script_parts)[0]) as archive:\n        for file in archive.getnames():\n            try:\n                os.remove(file)\n            except OSError:\n                \n                \n                pass\n", "comments": "# does not try to remove directories as we cannot know if they\n# already existed before\n", "content": "import tarfile\nimport os\nfrom thefuck.utils import for_app\nfrom thefuck.shells import shell\n\n\ntar_extensions = ('.tar', '.tar.Z', '.tar.bz2', '.tar.gz', '.tar.lz',\n                  '.tar.lzma', '.tar.xz', '.taz', '.tb2', '.tbz', '.tbz2',\n                  '.tgz', '.tlz', '.txz', '.tz')\n\n\ndef _is_tar_extract(cmd):\n    if '--extract' in cmd:\n        return True\n\n    cmd = cmd.split()\n\n    return len(cmd) > 1 and 'x' in cmd[1]\n\n\ndef _tar_file(cmd):\n    for c in cmd:\n        for ext in tar_extensions:\n            if c.endswith(ext):\n                return (c, c[0:len(c) - len(ext)])\n\n\n@for_app('tar')\ndef match(command):\n    return ('-C' not in command.script\n            and _is_tar_extract(command.script)\n            and _tar_file(command.script_parts) is not None)\n\n\ndef get_new_command(command):\n    dir = shell.quote(_tar_file(command.script_parts)[1])\n    return shell.and_('mkdir -p {dir}', '{cmd} -C {dir}') \\\n        .format(dir=dir, cmd=command.script)\n\n\ndef side_effect(old_cmd, command):\n    with tarfile.TarFile(_tar_file(old_cmd.script_parts)[0]) as archive:\n        for file in archive.getnames():\n            try:\n                os.remove(file)\n            except OSError:\n                # does not try to remove directories as we cannot know if they\n                # already existed before\n                pass\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "dirty_untar.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/thefuck/rules/dirty_untar.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}