{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport functools\nimport itertools\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_b64decode,\n    compat_chr,\n    compat_ord,\n    compat_str,\n    compat_urllib_parse_unquote,\n    compat_urlparse,\n    compat_zip\n)\nfrom ..utils import (\n    clean_html,\n    ExtractorError,\n    int_or_none,\n    OnDemandPagedList,\n    str_to_int,\n    try_get,\n    urljoin,\n)\n\n\nclass MixcloudIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:(?:www|beta|m)\\.)?mixcloud\\.com/([^/]+)/(?!stream|uploads|favorites|listens|playlists)([^/]+)'\n    IE_NAME = 'mixcloud'\n\n    _TESTS = [{\n        'url': 'http://www.mixcloud.com/dholbach/cryptkeeper/',\n        'info_dict': {\n            'id': 'dholbach-cryptkeeper',\n            'ext': 'm4a',\n            'title': 'Cryptkeeper',\n            'description': 'After quite a long silence from myself, finally another Drum\\'n\\'Bass mix with my favourite current dance floor bangers.',\n            'uploader': 'Daniel Holbach',\n            'uploader_id': 'dholbach',\n            'thumbnail': r're:https?://.*\\.jpg',\n            'view_count': int,\n        },\n    }, {\n        'url': 'http://www.mixcloud.com/gillespeterson/caribou-7-inch-vinyl-mix-chat/',\n        'info_dict': {\n            'id': 'gillespeterson-caribou-7-inch-vinyl-mix-chat',\n            'ext': 'mp3',\n            'title': 'Caribou 7 inch Vinyl Mix & Chat',\n            'description': 'md5:2b8aec6adce69f9d41724647c65875e8',\n            'uploader': 'Gilles Peterson Worldwide',\n            'uploader_id': 'gillespeterson',\n            'thumbnail': 're:https?://.*',\n            'view_count': int,\n        },\n    }, {\n        'url': 'https://beta.mixcloud.com/RedLightRadio/nosedrip-15-red-light-radio-01-18-2016/',\n        'only_matching': True,\n    }]\n\n    @staticmethod\n    def _decrypt_xor_cipher(key, ciphertext):\n        \n        return ''.join([\n            compat_chr(compat_ord(ch) ^ compat_ord(k))\n            for ch, k in compat_zip(ciphertext, itertools.cycle(key))])\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        uploader = mobj.group(1)\n        cloudcast_name = mobj.group(2)\n        track_id = compat_urllib_parse_unquote('-'.join((uploader, cloudcast_name)))\n\n        webpage = self._download_webpage(url, track_id)\n\n        \n        encrypted_play_info = self._search_regex(\n            r'm-play-info=\"([^\"]+)\"', webpage, 'play info', default=None)\n\n        if encrypted_play_info is not None:\n            \n            encrypted_play_info = compat_b64decode(encrypted_play_info)\n        else:\n            \n            full_info_json = self._parse_json(self._html_search_regex(\n                r'<script id=\"relay-data\" type=\"text/x-mixcloud\">([^<]+)</script>',\n                webpage, 'play info'), 'play info')\n            for item in full_info_json:\n                item_data = try_get(\n                    item, lambda x: x['cloudcast']['data']['cloudcastLookup'],\n                    dict)\n                if try_get(item_data, lambda x: x['streamInfo']['url']):\n                    info_json = item_data\n                    break\n            else:\n                raise ExtractorError('Failed to extract matching stream info')\n\n        message = self._html_search_regex(\n            r'(?s)<div[^>]+class=\"global-message cloudcast-disabled-notice-light\"[^>]*>(.+?)<(?:a|/div)',\n            webpage, 'error message', default=None)\n\n        js_url = self._search_regex(\n            r'<script[^>]+\\bsrc=[\"\\\"](https://(?:www\\.)?mixcloud\\.com/media/(?:js2/www_js_4|js/www)\\.[^>]+\\.js)',\n            webpage, 'js url')\n        js = self._download_webpage(js_url, track_id, 'Downloading JS')\n        \n        if encrypted_play_info:\n            kps = ['{\"stream_url\":']\n            kpa_target = encrypted_play_info\n        else:\n            kps = ['https://', 'http://']\n            kpa_target = compat_b64decode(info_json['streamInfo']['url'])\n        for kp in kps:\n            partial_key = self._decrypt_xor_cipher(kpa_target, kp)\n            for quote in [\"'\", '\"']:\n                key = self._search_regex(\n                    r'{0}({1}[^{0}]*){0}'.format(quote, re.escape(partial_key)),\n                    js, 'encryption key', default=None)\n                if key is not None:\n                    break\n            else:\n                continue\n            break\n        else:\n            raise ExtractorError('Failed to extract encryption key')\n\n        if encrypted_play_info is not None:\n            play_info = self._parse_json(self._decrypt_xor_cipher(key, encrypted_play_info), 'play info')\n            if message and 'stream_url' not in play_info:\n                raise ExtractorError('%s said: %s' % (self.IE_NAME, message), expected=True)\n            song_url = play_info['stream_url']\n            formats = [{\n                'format_id': 'normal',\n                'url': song_url\n            }]\n\n            title = self._html_search_regex(r'm-title=\"([^\"]+)\"', webpage, 'title')\n            thumbnail = self._proto_relative_url(self._html_search_regex(\n                r'm-thumbnail-url=\"([^\"]+)\"', webpage, 'thumbnail', fatal=False))\n            uploader = self._html_search_regex(\n                r'm-owner-name=\"([^\"]+)\"', webpage, 'uploader', fatal=False)\n            uploader_id = self._search_regex(\n                r'\\s+\"profile\": \"([^\"]+)\",', webpage, 'uploader id', fatal=False)\n            description = self._og_search_description(webpage)\n            view_count = str_to_int(self._search_regex(\n                [r'<meta itemprop=\"interactionCount\" content=\"UserPlays:([0-9]+)\"',\n                 r'/listeners/?\">([0-9,.]+)</a>',\n                 r'(?:m|data)-tooltip=[\"\\']([\\d,.]+) plays'],\n                webpage, 'play count', default=None))\n\n        else:\n            title = info_json['name']\n            thumbnail = urljoin(\n                'https://thumbnailer.mixcloud.com/unsafe/600x600/',\n                try_get(info_json, lambda x: x['picture']['urlRoot'], compat_str))\n            uploader = try_get(info_json, lambda x: x['owner']['displayName'])\n            uploader_id = try_get(info_json, lambda x: x['owner']['username'])\n            description = try_get(info_json, lambda x: x['description'])\n            view_count = int_or_none(try_get(info_json, lambda x: x['plays']))\n\n            stream_info = info_json['streamInfo']\n            formats = []\n\n            for url_key in ('url', 'hlsUrl', 'dashUrl'):\n                format_url = stream_info.get(url_key)\n                if not format_url:\n                    continue\n                decrypted = self._decrypt_xor_cipher(key, compat_b64decode(format_url))\n                if not decrypted:\n                    continue\n                if url_key == 'hlsUrl':\n                    formats.extend(self._extract_m3u8_formats(\n                        decrypted, track_id, 'mp4', entry_protocol='m3u8_native',\n                        m3u8_id='hls', fatal=False))\n                elif url_key == 'dashUrl':\n                    formats.extend(self._extract_mpd_formats(\n                        decrypted, track_id, mpd_id='dash', fatal=False))\n                else:\n                    formats.append({\n                        'format_id': 'http',\n                        'url': decrypted,\n                    })\n            self._sort_formats(formats)\n\n        return {\n            'id': track_id,\n            'title': title,\n            'formats': formats,\n            'description': description,\n            'thumbnail': thumbnail,\n            'uploader': uploader,\n            'uploader_id': uploader_id,\n            'view_count': view_count,\n        }\n\n\nclass MixcloudPlaylistBaseIE(InfoExtractor):\n    _PAGE_SIZE = 24\n\n    def _find_urls_in_page(self, page):\n        for url in re.findall(r'm-play-button m-url=\"(?P<url>[^\"]+)\"', page):\n            yield self.url_result(\n                compat_urlparse.urljoin('https://www.mixcloud.com', clean_html(url)),\n                MixcloudIE.ie_key())\n\n    def _fetch_tracks_page(self, path, video_id, page_name, current_page, real_page_number=None):\n        real_page_number = real_page_number or current_page + 1\n        return self._download_webpage(\n            'https://www.mixcloud.com/%s/' % path, video_id,\n            note='Download %s (page %d)' % (page_name, current_page + 1),\n            errnote='Unable to download %s' % page_name,\n            query={'page': real_page_number, 'list': 'main', '_ajax': '1'},\n            headers={'X-Requested-With': 'XMLHttpRequest'})\n\n    def _tracks_page_func(self, page, video_id, page_name, current_page):\n        resp = self._fetch_tracks_page(page, video_id, page_name, current_page)\n\n        for item in self._find_urls_in_page(resp):\n            yield item\n\n    def _get_user_description(self, page_content):\n        return self._html_search_regex(\n            r'<div[^>]+class=\"profile-bio\"[^>]*>(.+?)</div>',\n            page_content, 'user description', fatal=False)\n\n\nclass MixcloudUserIE(MixcloudPlaylistBaseIE):\n    _VALID_URL = r'https?://(?:www\\.)?mixcloud\\.com/(?P<user>[^/]+)/(?P<type>uploads|favorites|listens)?/?$'\n    IE_NAME = 'mixcloud:user'\n\n    _TESTS = [{\n        'url': 'http://www.mixcloud.com/dholbach/',\n        'info_dict': {\n            'id': 'dholbach_uploads',\n            'title': 'Daniel Holbach (uploads)',\n            'description': 'md5:def36060ac8747b3aabca54924897e47',\n        },\n        'playlist_mincount': 11,\n    }, {\n        'url': 'http://www.mixcloud.com/dholbach/uploads/',\n        'info_dict': {\n            'id': 'dholbach_uploads',\n            'title': 'Daniel Holbach (uploads)',\n            'description': 'md5:def36060ac8747b3aabca54924897e47',\n        },\n        'playlist_mincount': 11,\n    }, {\n        'url': 'http://www.mixcloud.com/dholbach/favorites/',\n        'info_dict': {\n            'id': 'dholbach_favorites',\n            'title': 'Daniel Holbach (favorites)',\n            'description': 'md5:def36060ac8747b3aabca54924897e47',\n        },\n        'params': {\n            'playlist_items': '1-100',\n        },\n        'playlist_mincount': 100,\n    }, {\n        'url': 'http://www.mixcloud.com/dholbach/listens/',\n        'info_dict': {\n            'id': 'dholbach_listens',\n            'title': 'Daniel Holbach (listens)',\n            'description': 'md5:def36060ac8747b3aabca54924897e47',\n        },\n        'params': {\n            'playlist_items': '1-100',\n        },\n        'playlist_mincount': 100,\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        user_id = mobj.group('user')\n        list_type = mobj.group('type')\n\n        \n        if list_type is None:\n            list_type = 'uploads'\n\n        video_id = '%s_%s' % (user_id, list_type)\n\n        profile = self._download_webpage(\n            'https://www.mixcloud.com/%s/' % user_id, video_id,\n            note='Downloading user profile',\n            errnote='Unable to download user profile')\n\n        username = self._og_search_title(profile)\n        description = self._get_user_description(profile)\n\n        entries = OnDemandPagedList(\n            functools.partial(\n                self._tracks_page_func,\n                '%s/%s' % (user_id, list_type), video_id, 'list of %s' % list_type),\n            self._PAGE_SIZE)\n\n        return self.playlist_result(\n            entries, video_id, '%s (%s)' % (username, list_type), description)\n\n\nclass MixcloudPlaylistIE(MixcloudPlaylistBaseIE):\n    _VALID_URL = r'https?://(?:www\\.)?mixcloud\\.com/(?P<user>[^/]+)/playlists/(?P<playlist>[^/]+)/?$'\n    IE_NAME = 'mixcloud:playlist'\n\n    _TESTS = [{\n        'url': 'https://www.mixcloud.com/RedBullThre3style/playlists/tokyo-finalists-2015/',\n        'info_dict': {\n            'id': 'RedBullThre3style_tokyo-finalists-2015',\n            'title': 'National Champions 2015',\n            'description': 'md5:6ff5fb01ac76a31abc9b3939c16243a3',\n        },\n        'playlist_mincount': 16,\n    }, {\n        'url': 'https://www.mixcloud.com/maxvibes/playlists/jazzcat-on-ness-radio/',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        user_id = mobj.group('user')\n        playlist_id = mobj.group('playlist')\n        video_id = '%s_%s' % (user_id, playlist_id)\n\n        webpage = self._download_webpage(\n            url, user_id,\n            note='Downloading playlist page',\n            errnote='Unable to download playlist page')\n\n        title = self._html_search_regex(\n            r'<a[^>]+class=\"parent active\"[^>]*><b>\\d+</b><span[^>]*>([^<]+)',\n            webpage, 'playlist title',\n            default=None) or self._og_search_title(webpage, fatal=False)\n        description = self._get_user_description(webpage)\n\n        entries = OnDemandPagedList(\n            functools.partial(\n                self._tracks_page_func,\n                '%s/playlists/%s' % (user_id, playlist_id), video_id, 'tracklist'),\n            self._PAGE_SIZE)\n\n        return self.playlist_result(entries, video_id, title, description)\n\n\nclass MixcloudStreamIE(MixcloudPlaylistBaseIE):\n    _VALID_URL = r'https?://(?:www\\.)?mixcloud\\.com/(?P<id>[^/]+)/stream/?$'\n    IE_NAME = 'mixcloud:stream'\n\n    _TEST = {\n        'url': 'https://www.mixcloud.com/FirstEar/stream/',\n        'info_dict': {\n            'id': 'FirstEar',\n            'title': 'First Ear',\n            'description': 'Curators of good music\\nfirstearmusic.com',\n        },\n        'playlist_mincount': 192,\n    }\n\n    def _real_extract(self, url):\n        user_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, user_id)\n\n        entries = []\n        prev_page_url = None\n\n        def _handle_page(page):\n            entries.extend(self._find_urls_in_page(page))\n            return self._search_regex(\n                r'm-next-page-url=\"([^\"]+)\"', page,\n                'next page URL', default=None)\n\n        next_page_url = _handle_page(webpage)\n\n        for idx in itertools.count(0):\n            if not next_page_url or prev_page_url == next_page_url:\n                break\n\n            prev_page_url = next_page_url\n            current_page = int(self._search_regex(\n                r'\\?page=(\\d+)', next_page_url, 'next page number'))\n\n            next_page_url = _handle_page(self._fetch_tracks_page(\n                '%s/stream' % user_id, user_id, 'stream', idx,\n                real_page_number=current_page))\n\n        username = self._og_search_title(webpage)\n        description = self._get_user_description(webpage)\n\n        return self.playlist_result(entries, user_id, username, description)\n", "comments": "Encrypt/Decrypt XOR cipher. Both ways are possible because it's XOR.\n.\n# Legacy path\n# Decode\n# New path\n# Known plaintext attack\n# if only a profile URL was supplied, default to download all uploads\n", "content": "from __future__ import unicode_literals\n\nimport functools\nimport itertools\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_b64decode,\n    compat_chr,\n    compat_ord,\n    compat_str,\n    compat_urllib_parse_unquote,\n    compat_urlparse,\n    compat_zip\n)\nfrom ..utils import (\n    clean_html,\n    ExtractorError,\n    int_or_none,\n    OnDemandPagedList,\n    str_to_int,\n    try_get,\n    urljoin,\n)\n\n\nclass MixcloudIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:(?:www|beta|m)\\.)?mixcloud\\.com/([^/]+)/(?!stream|uploads|favorites|listens|playlists)([^/]+)'\n    IE_NAME = 'mixcloud'\n\n    _TESTS = [{\n        'url': 'http://www.mixcloud.com/dholbach/cryptkeeper/',\n        'info_dict': {\n            'id': 'dholbach-cryptkeeper',\n            'ext': 'm4a',\n            'title': 'Cryptkeeper',\n            'description': 'After quite a long silence from myself, finally another Drum\\'n\\'Bass mix with my favourite current dance floor bangers.',\n            'uploader': 'Daniel Holbach',\n            'uploader_id': 'dholbach',\n            'thumbnail': r're:https?://.*\\.jpg',\n            'view_count': int,\n        },\n    }, {\n        'url': 'http://www.mixcloud.com/gillespeterson/caribou-7-inch-vinyl-mix-chat/',\n        'info_dict': {\n            'id': 'gillespeterson-caribou-7-inch-vinyl-mix-chat',\n            'ext': 'mp3',\n            'title': 'Caribou 7 inch Vinyl Mix & Chat',\n            'description': 'md5:2b8aec6adce69f9d41724647c65875e8',\n            'uploader': 'Gilles Peterson Worldwide',\n            'uploader_id': 'gillespeterson',\n            'thumbnail': 're:https?://.*',\n            'view_count': int,\n        },\n    }, {\n        'url': 'https://beta.mixcloud.com/RedLightRadio/nosedrip-15-red-light-radio-01-18-2016/',\n        'only_matching': True,\n    }]\n\n    @staticmethod\n    def _decrypt_xor_cipher(key, ciphertext):\n        \"\"\"Encrypt/Decrypt XOR cipher. Both ways are possible because it's XOR.\"\"\"\n        return ''.join([\n            compat_chr(compat_ord(ch) ^ compat_ord(k))\n            for ch, k in compat_zip(ciphertext, itertools.cycle(key))])\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        uploader = mobj.group(1)\n        cloudcast_name = mobj.group(2)\n        track_id = compat_urllib_parse_unquote('-'.join((uploader, cloudcast_name)))\n\n        webpage = self._download_webpage(url, track_id)\n\n        # Legacy path\n        encrypted_play_info = self._search_regex(\n            r'm-play-info=\"([^\"]+)\"', webpage, 'play info', default=None)\n\n        if encrypted_play_info is not None:\n            # Decode\n            encrypted_play_info = compat_b64decode(encrypted_play_info)\n        else:\n            # New path\n            full_info_json = self._parse_json(self._html_search_regex(\n                r'<script id=\"relay-data\" type=\"text/x-mixcloud\">([^<]+)</script>',\n                webpage, 'play info'), 'play info')\n            for item in full_info_json:\n                item_data = try_get(\n                    item, lambda x: x['cloudcast']['data']['cloudcastLookup'],\n                    dict)\n                if try_get(item_data, lambda x: x['streamInfo']['url']):\n                    info_json = item_data\n                    break\n            else:\n                raise ExtractorError('Failed to extract matching stream info')\n\n        message = self._html_search_regex(\n            r'(?s)<div[^>]+class=\"global-message cloudcast-disabled-notice-light\"[^>]*>(.+?)<(?:a|/div)',\n            webpage, 'error message', default=None)\n\n        js_url = self._search_regex(\n            r'<script[^>]+\\bsrc=[\"\\\"](https://(?:www\\.)?mixcloud\\.com/media/(?:js2/www_js_4|js/www)\\.[^>]+\\.js)',\n            webpage, 'js url')\n        js = self._download_webpage(js_url, track_id, 'Downloading JS')\n        # Known plaintext attack\n        if encrypted_play_info:\n            kps = ['{\"stream_url\":']\n            kpa_target = encrypted_play_info\n        else:\n            kps = ['https://', 'http://']\n            kpa_target = compat_b64decode(info_json['streamInfo']['url'])\n        for kp in kps:\n            partial_key = self._decrypt_xor_cipher(kpa_target, kp)\n            for quote in [\"'\", '\"']:\n                key = self._search_regex(\n                    r'{0}({1}[^{0}]*){0}'.format(quote, re.escape(partial_key)),\n                    js, 'encryption key', default=None)\n                if key is not None:\n                    break\n            else:\n                continue\n            break\n        else:\n            raise ExtractorError('Failed to extract encryption key')\n\n        if encrypted_play_info is not None:\n            play_info = self._parse_json(self._decrypt_xor_cipher(key, encrypted_play_info), 'play info')\n            if message and 'stream_url' not in play_info:\n                raise ExtractorError('%s said: %s' % (self.IE_NAME, message), expected=True)\n            song_url = play_info['stream_url']\n            formats = [{\n                'format_id': 'normal',\n                'url': song_url\n            }]\n\n            title = self._html_search_regex(r'm-title=\"([^\"]+)\"', webpage, 'title')\n            thumbnail = self._proto_relative_url(self._html_search_regex(\n                r'm-thumbnail-url=\"([^\"]+)\"', webpage, 'thumbnail', fatal=False))\n            uploader = self._html_search_regex(\n                r'm-owner-name=\"([^\"]+)\"', webpage, 'uploader', fatal=False)\n            uploader_id = self._search_regex(\n                r'\\s+\"profile\": \"([^\"]+)\",', webpage, 'uploader id', fatal=False)\n            description = self._og_search_description(webpage)\n            view_count = str_to_int(self._search_regex(\n                [r'<meta itemprop=\"interactionCount\" content=\"UserPlays:([0-9]+)\"',\n                 r'/listeners/?\">([0-9,.]+)</a>',\n                 r'(?:m|data)-tooltip=[\"\\']([\\d,.]+) plays'],\n                webpage, 'play count', default=None))\n\n        else:\n            title = info_json['name']\n            thumbnail = urljoin(\n                'https://thumbnailer.mixcloud.com/unsafe/600x600/',\n                try_get(info_json, lambda x: x['picture']['urlRoot'], compat_str))\n            uploader = try_get(info_json, lambda x: x['owner']['displayName'])\n            uploader_id = try_get(info_json, lambda x: x['owner']['username'])\n            description = try_get(info_json, lambda x: x['description'])\n            view_count = int_or_none(try_get(info_json, lambda x: x['plays']))\n\n            stream_info = info_json['streamInfo']\n            formats = []\n\n            for url_key in ('url', 'hlsUrl', 'dashUrl'):\n                format_url = stream_info.get(url_key)\n                if not format_url:\n                    continue\n                decrypted = self._decrypt_xor_cipher(key, compat_b64decode(format_url))\n                if not decrypted:\n                    continue\n                if url_key == 'hlsUrl':\n                    formats.extend(self._extract_m3u8_formats(\n                        decrypted, track_id, 'mp4', entry_protocol='m3u8_native',\n                        m3u8_id='hls', fatal=False))\n                elif url_key == 'dashUrl':\n                    formats.extend(self._extract_mpd_formats(\n                        decrypted, track_id, mpd_id='dash', fatal=False))\n                else:\n                    formats.append({\n                        'format_id': 'http',\n                        'url': decrypted,\n                    })\n            self._sort_formats(formats)\n\n        return {\n            'id': track_id,\n            'title': title,\n            'formats': formats,\n            'description': description,\n            'thumbnail': thumbnail,\n            'uploader': uploader,\n            'uploader_id': uploader_id,\n            'view_count': view_count,\n        }\n\n\nclass MixcloudPlaylistBaseIE(InfoExtractor):\n    _PAGE_SIZE = 24\n\n    def _find_urls_in_page(self, page):\n        for url in re.findall(r'm-play-button m-url=\"(?P<url>[^\"]+)\"', page):\n            yield self.url_result(\n                compat_urlparse.urljoin('https://www.mixcloud.com', clean_html(url)),\n                MixcloudIE.ie_key())\n\n    def _fetch_tracks_page(self, path, video_id, page_name, current_page, real_page_number=None):\n        real_page_number = real_page_number or current_page + 1\n        return self._download_webpage(\n            'https://www.mixcloud.com/%s/' % path, video_id,\n            note='Download %s (page %d)' % (page_name, current_page + 1),\n            errnote='Unable to download %s' % page_name,\n            query={'page': real_page_number, 'list': 'main', '_ajax': '1'},\n            headers={'X-Requested-With': 'XMLHttpRequest'})\n\n    def _tracks_page_func(self, page, video_id, page_name, current_page):\n        resp = self._fetch_tracks_page(page, video_id, page_name, current_page)\n\n        for item in self._find_urls_in_page(resp):\n            yield item\n\n    def _get_user_description(self, page_content):\n        return self._html_search_regex(\n            r'<div[^>]+class=\"profile-bio\"[^>]*>(.+?)</div>',\n            page_content, 'user description', fatal=False)\n\n\nclass MixcloudUserIE(MixcloudPlaylistBaseIE):\n    _VALID_URL = r'https?://(?:www\\.)?mixcloud\\.com/(?P<user>[^/]+)/(?P<type>uploads|favorites|listens)?/?$'\n    IE_NAME = 'mixcloud:user'\n\n    _TESTS = [{\n        'url': 'http://www.mixcloud.com/dholbach/',\n        'info_dict': {\n            'id': 'dholbach_uploads',\n            'title': 'Daniel Holbach (uploads)',\n            'description': 'md5:def36060ac8747b3aabca54924897e47',\n        },\n        'playlist_mincount': 11,\n    }, {\n        'url': 'http://www.mixcloud.com/dholbach/uploads/',\n        'info_dict': {\n            'id': 'dholbach_uploads',\n            'title': 'Daniel Holbach (uploads)',\n            'description': 'md5:def36060ac8747b3aabca54924897e47',\n        },\n        'playlist_mincount': 11,\n    }, {\n        'url': 'http://www.mixcloud.com/dholbach/favorites/',\n        'info_dict': {\n            'id': 'dholbach_favorites',\n            'title': 'Daniel Holbach (favorites)',\n            'description': 'md5:def36060ac8747b3aabca54924897e47',\n        },\n        'params': {\n            'playlist_items': '1-100',\n        },\n        'playlist_mincount': 100,\n    }, {\n        'url': 'http://www.mixcloud.com/dholbach/listens/',\n        'info_dict': {\n            'id': 'dholbach_listens',\n            'title': 'Daniel Holbach (listens)',\n            'description': 'md5:def36060ac8747b3aabca54924897e47',\n        },\n        'params': {\n            'playlist_items': '1-100',\n        },\n        'playlist_mincount': 100,\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        user_id = mobj.group('user')\n        list_type = mobj.group('type')\n\n        # if only a profile URL was supplied, default to download all uploads\n        if list_type is None:\n            list_type = 'uploads'\n\n        video_id = '%s_%s' % (user_id, list_type)\n\n        profile = self._download_webpage(\n            'https://www.mixcloud.com/%s/' % user_id, video_id,\n            note='Downloading user profile',\n            errnote='Unable to download user profile')\n\n        username = self._og_search_title(profile)\n        description = self._get_user_description(profile)\n\n        entries = OnDemandPagedList(\n            functools.partial(\n                self._tracks_page_func,\n                '%s/%s' % (user_id, list_type), video_id, 'list of %s' % list_type),\n            self._PAGE_SIZE)\n\n        return self.playlist_result(\n            entries, video_id, '%s (%s)' % (username, list_type), description)\n\n\nclass MixcloudPlaylistIE(MixcloudPlaylistBaseIE):\n    _VALID_URL = r'https?://(?:www\\.)?mixcloud\\.com/(?P<user>[^/]+)/playlists/(?P<playlist>[^/]+)/?$'\n    IE_NAME = 'mixcloud:playlist'\n\n    _TESTS = [{\n        'url': 'https://www.mixcloud.com/RedBullThre3style/playlists/tokyo-finalists-2015/',\n        'info_dict': {\n            'id': 'RedBullThre3style_tokyo-finalists-2015',\n            'title': 'National Champions 2015',\n            'description': 'md5:6ff5fb01ac76a31abc9b3939c16243a3',\n        },\n        'playlist_mincount': 16,\n    }, {\n        'url': 'https://www.mixcloud.com/maxvibes/playlists/jazzcat-on-ness-radio/',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        user_id = mobj.group('user')\n        playlist_id = mobj.group('playlist')\n        video_id = '%s_%s' % (user_id, playlist_id)\n\n        webpage = self._download_webpage(\n            url, user_id,\n            note='Downloading playlist page',\n            errnote='Unable to download playlist page')\n\n        title = self._html_search_regex(\n            r'<a[^>]+class=\"parent active\"[^>]*><b>\\d+</b><span[^>]*>([^<]+)',\n            webpage, 'playlist title',\n            default=None) or self._og_search_title(webpage, fatal=False)\n        description = self._get_user_description(webpage)\n\n        entries = OnDemandPagedList(\n            functools.partial(\n                self._tracks_page_func,\n                '%s/playlists/%s' % (user_id, playlist_id), video_id, 'tracklist'),\n            self._PAGE_SIZE)\n\n        return self.playlist_result(entries, video_id, title, description)\n\n\nclass MixcloudStreamIE(MixcloudPlaylistBaseIE):\n    _VALID_URL = r'https?://(?:www\\.)?mixcloud\\.com/(?P<id>[^/]+)/stream/?$'\n    IE_NAME = 'mixcloud:stream'\n\n    _TEST = {\n        'url': 'https://www.mixcloud.com/FirstEar/stream/',\n        'info_dict': {\n            'id': 'FirstEar',\n            'title': 'First Ear',\n            'description': 'Curators of good music\\nfirstearmusic.com',\n        },\n        'playlist_mincount': 192,\n    }\n\n    def _real_extract(self, url):\n        user_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, user_id)\n\n        entries = []\n        prev_page_url = None\n\n        def _handle_page(page):\n            entries.extend(self._find_urls_in_page(page))\n            return self._search_regex(\n                r'm-next-page-url=\"([^\"]+)\"', page,\n                'next page URL', default=None)\n\n        next_page_url = _handle_page(webpage)\n\n        for idx in itertools.count(0):\n            if not next_page_url or prev_page_url == next_page_url:\n                break\n\n            prev_page_url = next_page_url\n            current_page = int(self._search_regex(\n                r'\\?page=(\\d+)', next_page_url, 'next page number'))\n\n            next_page_url = _handle_page(self._fetch_tracks_page(\n                '%s/stream' % user_id, user_id, 'stream', idx,\n                real_page_number=current_page))\n\n        username = self._og_search_title(webpage)\n        description = self._get_user_description(webpage)\n\n        return self.playlist_result(entries, user_id, username, description)\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "mixcloud.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/mixcloud.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}