{"author": "keon", "code": "from itertools import chain, combinations\n\n\"\"\"\nUniverse *U* of n elements\nCollection of subsets of U:\n    S = S1,S2...,Sm\n    Where every substet Si has an associated cost.\n\nFind a minimum cost subcollection of S that covers all elements of U\n\nExample:\n    U = {1,2,3,4,5}\n    S = {S1,S2,S3}\n\n    S1 = {4,1,3},    Cost(S1) = 5\n    S2 = {2,5},      Cost(S2) = 10\n    S3 = {1,4,3,2},  Cost(S3) = 3\n\n    Output:\n        Set cover = {S2, S3}\n        Min Cost = 13\n\"\"\"\n\n\ndef powerset(iterable):\n    \"\"\"Calculate the powerset of any iterable.\n\n    For a range of integers up to the length of the given list,\n    make all possible combinations and chain them together as one object.\n    From https://docs.python.org/3/library/itertools.html\n    \"\"\"\n    \"list(powerset([1,2,3])) --> [(), (1,), (2,), (3,), (1,2), (1,3), (2,3), (1,2,3)]\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))\n\n\ndef optimal_set_cover(universe, subsets, costs):\n    \"\"\" Optimal algorithm - DONT USE ON BIG INPUTS - O(2^n) complexity!\n    Finds the minimum cost subcollection os S that covers all elements of U\n\n    Args:\n        universe (list): Universe of elements\n        subsets (dict): Subsets of U {S1:elements,S2:elements}\n        costs (dict): Costs of each subset in S - {S1:cost, S2:cost...}\n    \"\"\"\n    pset = powerset(subsets.keys())\n    best_set = None\n    best_cost = float(\"inf\")\n    for subset in pset:\n        covered = set()\n        cost = 0\n        for s in subset:\n            covered.update(subsets[s])\n            cost += costs[s]\n        if len(covered) == len(universe) and cost < best_cost:\n            best_set = subset\n            best_cost = cost\n    return best_set\n\n\ndef greedy_set_cover(universe, subsets, costs):\n    \"\"\"Approximate greedy algorithm for set-covering. Can be used on large\n    inputs - though not an optimal solution.\n\n    Args:\n        universe (list): Universe of elements\n        subsets (dict): Subsets of U {S1:elements,S2:elements}\n        costs (dict): Costs of each subset in S - {S1:cost, S2:cost...}\n    \"\"\"\n    elements = set(e for s in subsets.keys() for e in subsets[s])\n    \n    if elements != universe:\n        return None\n\n    \n    covered = set()\n    cover_sets = []\n\n    while covered != universe:\n        min_cost_elem_ratio = float(\"inf\")\n        min_set = None\n        \n        for s, elements in subsets.items():\n            new_elements = len(elements - covered)\n            \n            \n            if new_elements != 0:\n                cost_elem_ratio = costs[s] / new_elements\n                if cost_elem_ratio < min_cost_elem_ratio:\n                    min_cost_elem_ratio = cost_elem_ratio\n                    min_set = s\n        cover_sets.append(min_set)\n        \n        covered |= subsets[min_set]\n    return cover_sets\n\n\nif __name__ == '__main__':\n    universe = {1, 2, 3, 4, 5}\n    subsets = {'S1': {4, 1, 3}, 'S2': {2, 5}, 'S3': {1, 4, 3, 2}}\n    costs = {'S1': 5, 'S2': 10, 'S3': 3}\n\n    optimal_cover = optimal_set_cover(universe, subsets, costs)\n    optimal_cost = sum(costs[s] for s in optimal_cover)\n\n    greedy_cover = greedy_set_cover(universe, subsets, costs)\n    greedy_cost = sum(costs[s] for s in greedy_cover)\n\n    print('Optimal Set Cover:')\n    print(optimal_cover)\n    print('Cost = %s' % optimal_cost)\n\n    print('Greedy Set Cover:')\n    print(greedy_cover)\n    print('Cost = %s' % greedy_cost)\n", "comments": "    universe  u  n elements collection subsets u      s   s1 s2    sm     where every substet si associated cost   find minimum cost subcollection s covers elements u  example      u    1 2 3 4 5      s    s1 s2 s3       s1    4 1 3      cost(s1)   5     s2    2 5        cost(s2)   10     s3    1 4 3 2    cost(s3)   3      output          set cover    s2  s3          min cost   13       def powerset(iterable)         calculate powerset iterable       for range integers length given list      make possible combinations chain together one object      from https   docs python org 3 library itertools html itertools recipes              list(powerset( 1 2 3 ))      ()  (1 )  (2 )  (3 )  (1 2)  (1 3)  (2 3)  (1 2 3)         list(iterable)     return chain iterable(combinations(s  r) r range(len(s)   1))   def optimal set cover(universe  subsets  costs)          optimal algorithm   dont use on big inputs   o(2 n) complexity      finds minimum cost subcollection os s covers elements u      args          universe (list)  universe elements         subsets (dict)  subsets u  s1 elements s2 elements          costs (dict)  costs subset s    s1 cost  s2 cost                 pset   powerset(subsets keys())     best set   none     best cost   float( inf )     subset pset          covered   set()         cost   0         subset              covered update(subsets )             cost    costs          len(covered)    len(universe) cost   best cost              best set   subset             best cost   cost     return best set   def greedy set cover(universe  subsets  costs)         approximate greedy algorithm set covering  can used large     inputs   though optimal solution       args          universe (list)  universe elements         subsets (dict)  subsets u  s1 elements s2 elements          costs (dict)  costs subset s    s1 cost  s2 cost               itertools recipes    elements cover universe    invalid input set cover    track elements universe covered    find set minimum cost elements added ratio    set may elements already covered    new elements   0    check avoid division 0 error    union ", "content": "from itertools import chain, combinations\n\n\"\"\"\nUniverse *U* of n elements\nCollection of subsets of U:\n    S = S1,S2...,Sm\n    Where every substet Si has an associated cost.\n\nFind a minimum cost subcollection of S that covers all elements of U\n\nExample:\n    U = {1,2,3,4,5}\n    S = {S1,S2,S3}\n\n    S1 = {4,1,3},    Cost(S1) = 5\n    S2 = {2,5},      Cost(S2) = 10\n    S3 = {1,4,3,2},  Cost(S3) = 3\n\n    Output:\n        Set cover = {S2, S3}\n        Min Cost = 13\n\"\"\"\n\n\ndef powerset(iterable):\n    \"\"\"Calculate the powerset of any iterable.\n\n    For a range of integers up to the length of the given list,\n    make all possible combinations and chain them together as one object.\n    From https://docs.python.org/3/library/itertools.html#itertools-recipes\n    \"\"\"\n    \"list(powerset([1,2,3])) --> [(), (1,), (2,), (3,), (1,2), (1,3), (2,3), (1,2,3)]\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))\n\n\ndef optimal_set_cover(universe, subsets, costs):\n    \"\"\" Optimal algorithm - DONT USE ON BIG INPUTS - O(2^n) complexity!\n    Finds the minimum cost subcollection os S that covers all elements of U\n\n    Args:\n        universe (list): Universe of elements\n        subsets (dict): Subsets of U {S1:elements,S2:elements}\n        costs (dict): Costs of each subset in S - {S1:cost, S2:cost...}\n    \"\"\"\n    pset = powerset(subsets.keys())\n    best_set = None\n    best_cost = float(\"inf\")\n    for subset in pset:\n        covered = set()\n        cost = 0\n        for s in subset:\n            covered.update(subsets[s])\n            cost += costs[s]\n        if len(covered) == len(universe) and cost < best_cost:\n            best_set = subset\n            best_cost = cost\n    return best_set\n\n\ndef greedy_set_cover(universe, subsets, costs):\n    \"\"\"Approximate greedy algorithm for set-covering. Can be used on large\n    inputs - though not an optimal solution.\n\n    Args:\n        universe (list): Universe of elements\n        subsets (dict): Subsets of U {S1:elements,S2:elements}\n        costs (dict): Costs of each subset in S - {S1:cost, S2:cost...}\n    \"\"\"\n    elements = set(e for s in subsets.keys() for e in subsets[s])\n    # elements don't cover universe -> invalid input for set cover\n    if elements != universe:\n        return None\n\n    # track elements of universe covered\n    covered = set()\n    cover_sets = []\n\n    while covered != universe:\n        min_cost_elem_ratio = float(\"inf\")\n        min_set = None\n        # find set with minimum cost:elements_added ratio\n        for s, elements in subsets.items():\n            new_elements = len(elements - covered)\n            # set may have same elements as already covered -> new_elements = 0\n            # check to avoid division by 0 error\n            if new_elements != 0:\n                cost_elem_ratio = costs[s] / new_elements\n                if cost_elem_ratio < min_cost_elem_ratio:\n                    min_cost_elem_ratio = cost_elem_ratio\n                    min_set = s\n        cover_sets.append(min_set)\n        # union\n        covered |= subsets[min_set]\n    return cover_sets\n\n\nif __name__ == '__main__':\n    universe = {1, 2, 3, 4, 5}\n    subsets = {'S1': {4, 1, 3}, 'S2': {2, 5}, 'S3': {1, 4, 3, 2}}\n    costs = {'S1': 5, 'S2': 10, 'S3': 3}\n\n    optimal_cover = optimal_set_cover(universe, subsets, costs)\n    optimal_cost = sum(costs[s] for s in optimal_cover)\n\n    greedy_cover = greedy_set_cover(universe, subsets, costs)\n    greedy_cost = sum(costs[s] for s in greedy_cover)\n\n    print('Optimal Set Cover:')\n    print(optimal_cover)\n    print('Cost = %s' % optimal_cost)\n\n    print('Greedy Set Cover:')\n    print(greedy_cover)\n    print('Cost = %s' % greedy_cost)\n", "description": "Minimal examples of data structures and algorithms in Python", "file_name": "set_covering.py", "id": "04a34bcbc88fcebe1777d44ac73421e4", "language": "Python", "project_name": "algorithms", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/keon-algorithms/keon-algorithms-ea43887/set/set_covering.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:53:29Z", "url": "https://github.com/keon/algorithms", "wiki": true}