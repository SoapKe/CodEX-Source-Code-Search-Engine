{"author": "HelloZeroNet", "code": "import logging\nimport os\nimport sys\nfrom collections import defaultdict\n\nfrom Debug import Debug\nfrom Config import config\n\n\nclass PluginManager:\n    def __init__(self):\n        self.log = logging.getLogger(\"PluginManager\")\n        self.plugin_path = \"plugins\"  \n        self.plugins = defaultdict(list)  \n        self.subclass_order = {}  \n        self.pluggable = {}\n        self.plugin_names = []  \n        self.after_load = []  \n\n        sys.path.append(self.plugin_path)\n\n        if config.debug:  \n            from Debug import DebugReloader\n            DebugReloader(self.reloadPlugins)\n\n    \n\n    \n    def loadPlugins(self):\n        for dir_name in sorted(os.listdir(self.plugin_path)):\n            dir_path = os.path.join(self.plugin_path, dir_name)\n            if dir_name.startswith(\"disabled\"):\n                continue  \n            if not os.path.isdir(dir_path):\n                continue  \n            if dir_name.startswith(\"Debug\") and not config.debug:\n                continue  \n            self.log.debug(\"Loading plugin: %s\" % dir_name)\n            try:\n                __import__(dir_name)\n            except Exception, err:\n                self.log.error(\"Plugin %s load error: %s\" % (dir_name, Debug.formatException(err)))\n            if dir_name not in self.plugin_names:\n                self.plugin_names.append(dir_name)\n\n        for func in self.after_load:\n            func()\n\n    \n    def reloadPlugins(self):\n        self.plugins_before = self.plugins\n        self.plugins = defaultdict(list)  \n        for module_name, module in sys.modules.items():\n            if module and \"__file__\" in dir(module) and self.plugin_path in module.__file__:  \n                if \"allow_reload\" in dir(module) and not module.allow_reload:  \n                    \n                    for class_name, classes in self.plugins_before.iteritems():\n                        for c in classes:\n                            if c.__module__ != module.__name__:\n                                continue\n                            self.plugins[class_name].append(c)\n                else:\n                    try:\n                        reload(module)\n                    except Exception, err:\n                        self.log.error(\"Plugin %s reload error: %s\" % (module_name, Debug.formatException(err)))\n\n        self.loadPlugins()  \n\n        \n        import gc\n        patched = {}\n        for class_name, classes in self.plugins.iteritems():\n            classes = classes[:]  \n            classes.reverse()\n            base_class = self.pluggable[class_name]  \n            classes.append(base_class)  \n            plugined_class = type(class_name, tuple(classes), dict())  \n            for obj in gc.get_objects():\n                if type(obj).__name__ == class_name:\n                    obj.__class__ = plugined_class\n                    patched[class_name] = patched.get(class_name, 0) + 1\n        self.log.debug(\"Patched objects: %s\" % patched)\n\n        \n        patched = {}\n        for class_name, classes in self.plugins.iteritems():\n            for module_name, module in sys.modules.iteritems():\n                if class_name in dir(module):\n                    if \"__class__\" not in dir(getattr(module, class_name)):  \n                        continue\n                    base_class = self.pluggable[class_name]\n                    classes = self.plugins[class_name][:]\n                    classes.reverse()\n                    classes.append(base_class)\n                    plugined_class = type(class_name, tuple(classes), dict())\n                    setattr(module, class_name, plugined_class)\n                    patched[class_name] = patched.get(class_name, 0) + 1\n\n        self.log.debug(\"Patched modules: %s\" % patched)\n\n\nplugin_manager = PluginManager()  \n\n\n\n\n\n\ndef acceptPlugins(base_class):\n    class_name = base_class.__name__\n    plugin_manager.pluggable[class_name] = base_class\n    if class_name in plugin_manager.plugins:  \n        classes = plugin_manager.plugins[class_name][:]  \n\n        \n        if class_name in plugin_manager.subclass_order:\n            classes = sorted(\n                classes,\n                key=lambda key:\n                    plugin_manager.subclass_order[class_name].index(str(key))\n                    if str(key) in plugin_manager.subclass_order[class_name]\n                    else 9999\n            )\n        plugin_manager.subclass_order[class_name] = map(str, classes)\n\n        classes.reverse()\n        classes.append(base_class)  \n        plugined_class = type(class_name, tuple(classes), dict())  \n        plugin_manager.log.debug(\"New class accepts plugins: %s (Loaded plugins: %s)\" % (class_name, classes))\n    else:  \n        plugined_class = base_class\n    return plugined_class\n\n\n\ndef registerTo(class_name):\n    plugin_manager.log.debug(\"New plugin registered to: %s\" % class_name)\n    if class_name not in plugin_manager.plugins:\n        plugin_manager.plugins[class_name] = []\n\n    def classDecorator(self):\n        plugin_manager.plugins[class_name].append(self)\n        return self\n    return classDecorator\n\n\ndef afterLoad(func):\n    plugin_manager.after_load.append(func)\n    return func\n\n\n\n\nif __name__ == \"__main__\":\n    @registerTo(\"Request\")\n    class RequestPlugin(object):\n\n        def actionMainPage(self, path):\n            return \"Hello MainPage!\"\n\n    @acceptPlugins\n    class Request(object):\n\n        def route(self, path):\n            func = getattr(self, \"action\" + path, None)\n            if func:\n                return func(path)\n            else:\n                return \"Can't route to\", path\n\n    print Request().route(\"MainPage\")\n", "comments": "plugin directory registered plugins (key: class name value: list plugins class) record load order plugins keep reload loaded plugin names execute functions loaded plugins auto reload plugins file change -- load / unload -- load plugin dont load disabled dont load dir only load debug mode module name starts debug reload plugins reset registered plugins module file within plugin_path reload disabled re-add non-reloadable plugins load new plugins change current classes memory copy current plugins original class add class end inherience line create plugined class change classes modules not class singletone -- decorators -- accept plugin class decorator has plugins copy current plugins restore subclass order reload add class end inherience line create plugined class no plugins use original register plugin class name decorator - example usage -", "content": "import logging\nimport os\nimport sys\nfrom collections import defaultdict\n\nfrom Debug import Debug\nfrom Config import config\n\n\nclass PluginManager:\n    def __init__(self):\n        self.log = logging.getLogger(\"PluginManager\")\n        self.plugin_path = \"plugins\"  # Plugin directory\n        self.plugins = defaultdict(list)  # Registered plugins (key: class name, value: list of plugins for class)\n        self.subclass_order = {}  # Record the load order of the plugins, to keep it after reload\n        self.pluggable = {}\n        self.plugin_names = []  # Loaded plugin names\n        self.after_load = []  # Execute functions after loaded plugins\n\n        sys.path.append(self.plugin_path)\n\n        if config.debug:  # Auto reload Plugins on file change\n            from Debug import DebugReloader\n            DebugReloader(self.reloadPlugins)\n\n    # -- Load / Unload --\n\n    # Load all plugin\n    def loadPlugins(self):\n        for dir_name in sorted(os.listdir(self.plugin_path)):\n            dir_path = os.path.join(self.plugin_path, dir_name)\n            if dir_name.startswith(\"disabled\"):\n                continue  # Dont load if disabled\n            if not os.path.isdir(dir_path):\n                continue  # Dont load if not dir\n            if dir_name.startswith(\"Debug\") and not config.debug:\n                continue  # Only load in debug mode if module name starts with Debug\n            self.log.debug(\"Loading plugin: %s\" % dir_name)\n            try:\n                __import__(dir_name)\n            except Exception, err:\n                self.log.error(\"Plugin %s load error: %s\" % (dir_name, Debug.formatException(err)))\n            if dir_name not in self.plugin_names:\n                self.plugin_names.append(dir_name)\n\n        for func in self.after_load:\n            func()\n\n    # Reload all plugins\n    def reloadPlugins(self):\n        self.plugins_before = self.plugins\n        self.plugins = defaultdict(list)  # Reset registered plugins\n        for module_name, module in sys.modules.items():\n            if module and \"__file__\" in dir(module) and self.plugin_path in module.__file__:  # Module file within plugin_path\n                if \"allow_reload\" in dir(module) and not module.allow_reload:  # Reload disabled\n                    # Re-add non-reloadable plugins\n                    for class_name, classes in self.plugins_before.iteritems():\n                        for c in classes:\n                            if c.__module__ != module.__name__:\n                                continue\n                            self.plugins[class_name].append(c)\n                else:\n                    try:\n                        reload(module)\n                    except Exception, err:\n                        self.log.error(\"Plugin %s reload error: %s\" % (module_name, Debug.formatException(err)))\n\n        self.loadPlugins()  # Load new plugins\n\n        # Change current classes in memory\n        import gc\n        patched = {}\n        for class_name, classes in self.plugins.iteritems():\n            classes = classes[:]  # Copy the current plugins\n            classes.reverse()\n            base_class = self.pluggable[class_name]  # Original class\n            classes.append(base_class)  # Add the class itself to end of inherience line\n            plugined_class = type(class_name, tuple(classes), dict())  # Create the plugined class\n            for obj in gc.get_objects():\n                if type(obj).__name__ == class_name:\n                    obj.__class__ = plugined_class\n                    patched[class_name] = patched.get(class_name, 0) + 1\n        self.log.debug(\"Patched objects: %s\" % patched)\n\n        # Change classes in modules\n        patched = {}\n        for class_name, classes in self.plugins.iteritems():\n            for module_name, module in sys.modules.iteritems():\n                if class_name in dir(module):\n                    if \"__class__\" not in dir(getattr(module, class_name)):  # Not a class\n                        continue\n                    base_class = self.pluggable[class_name]\n                    classes = self.plugins[class_name][:]\n                    classes.reverse()\n                    classes.append(base_class)\n                    plugined_class = type(class_name, tuple(classes), dict())\n                    setattr(module, class_name, plugined_class)\n                    patched[class_name] = patched.get(class_name, 0) + 1\n\n        self.log.debug(\"Patched modules: %s\" % patched)\n\n\nplugin_manager = PluginManager()  # Singletone\n\n# -- Decorators --\n\n# Accept plugin to class decorator\n\n\ndef acceptPlugins(base_class):\n    class_name = base_class.__name__\n    plugin_manager.pluggable[class_name] = base_class\n    if class_name in plugin_manager.plugins:  # Has plugins\n        classes = plugin_manager.plugins[class_name][:]  # Copy the current plugins\n\n        # Restore the subclass order after reload\n        if class_name in plugin_manager.subclass_order:\n            classes = sorted(\n                classes,\n                key=lambda key:\n                    plugin_manager.subclass_order[class_name].index(str(key))\n                    if str(key) in plugin_manager.subclass_order[class_name]\n                    else 9999\n            )\n        plugin_manager.subclass_order[class_name] = map(str, classes)\n\n        classes.reverse()\n        classes.append(base_class)  # Add the class itself to end of inherience line\n        plugined_class = type(class_name, tuple(classes), dict())  # Create the plugined class\n        plugin_manager.log.debug(\"New class accepts plugins: %s (Loaded plugins: %s)\" % (class_name, classes))\n    else:  # No plugins just use the original\n        plugined_class = base_class\n    return plugined_class\n\n\n# Register plugin to class name decorator\ndef registerTo(class_name):\n    plugin_manager.log.debug(\"New plugin registered to: %s\" % class_name)\n    if class_name not in plugin_manager.plugins:\n        plugin_manager.plugins[class_name] = []\n\n    def classDecorator(self):\n        plugin_manager.plugins[class_name].append(self)\n        return self\n    return classDecorator\n\n\ndef afterLoad(func):\n    plugin_manager.after_load.append(func)\n    return func\n\n\n# - Example usage -\n\nif __name__ == \"__main__\":\n    @registerTo(\"Request\")\n    class RequestPlugin(object):\n\n        def actionMainPage(self, path):\n            return \"Hello MainPage!\"\n\n    @acceptPlugins\n    class Request(object):\n\n        def route(self, path):\n            func = getattr(self, \"action\" + path, None)\n            if func:\n                return func(path)\n            else:\n                return \"Can't route to\", path\n\n    print Request().route(\"MainPage\")\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "PluginManager.py", "id": "176076083e702792aa5e21a3a7edca06", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-3bdb6a2/src/Plugin/PluginManager.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:21:08Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}