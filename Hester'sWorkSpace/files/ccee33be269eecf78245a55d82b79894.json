{"author": "HelloZeroNet", "code": "import time\nimport logging\nimport collections\n\nimport gevent\n\nfrom Worker import Worker\nfrom Config import config\nfrom util import helper\nfrom Plugin import PluginManager\nimport util\n\n\n@PluginManager.acceptPlugins\nclass WorkerManager(object):\n\n    def __init__(self, site):\n        self.site = site\n        self.workers = {}  \n        self.tasks = []\n        \n        # \"time_started\": None, \"time_added\": time.time(), \"peers\": peers, \"priority\": 0, \"failed\": peer_ids}\n        self.started_task_num = 0  \n        self.asked_peers = []\n        self.running = True\n        self.time_task_added = 0\n        self.log = logging.getLogger(\"WorkerManager:%s\" % self.site.address_short)\n        self.process_taskchecker = gevent.spawn(self.checkTasks)\n\n    def __str__(self):\n        return \"WorkerManager %s\" % self.site.address_short\n\n    def __repr__(self):\n        return \"<%s>\" % self.__str__()\n\n    \n    def checkTasks(self):\n        while self.running:\n            tasks = task = worker = workers = None  \n            announced = False\n            time.sleep(15)  \n\n            \n            for worker in self.workers.values():\n                if worker.task and worker.task[\"done\"]:\n                    worker.skip()  \n\n            if not self.tasks:\n                continue\n\n            tasks = self.tasks[:]  \n            for task in tasks:\n                if task[\"time_started\"] and time.time() >= task[\"time_started\"] + 60:\n                    self.log.debug(\"Timeout, Skipping: %s\" % task)  \n                    \n                    workers = self.findWorkers(task)\n                    if workers:\n                        for worker in workers:\n                            worker.skip()\n                    else:\n                        self.failTask(task)\n                elif time.time() >= task[\"time_added\"] + 60 and not self.workers:  \n                    self.log.debug(\"Timeout, Cleanup task: %s\" % task)\n                    \n                    self.failTask(task)\n\n                elif (task[\"time_started\"] and time.time() >= task[\"time_started\"] + 15) or not self.workers:\n                    \n                    workers = self.findWorkers(task)\n                    self.log.debug(\n                        \"Slow task: %s, (workers: %s, optional_hash_id: %s, peers: %s, failed: %s, asked: %s)\" %\n                        (\n                            task[\"inner_path\"], len(workers), task[\"optional_hash_id\"],\n                            len(task[\"peers\"] or []), len(task[\"failed\"]), len(self.asked_peers)\n                        )\n                    )\n                    if not announced:\n                        task[\"site\"].announce(mode=\"more\")  \n                        announced = True\n                    if task[\"optional_hash_id\"]:\n                        if self.workers:\n                            if not task[\"time_started\"]:\n                                ask_limit = 20\n                            else:\n                                ask_limit = max(10, time.time() - task[\"time_started\"])\n                            if len(self.asked_peers) < ask_limit and len(task[\"peers\"] or []) <= len(task[\"failed\"]) * 2:\n                                \n                                self.startFindOptional(find_more=True)\n                        if task[\"peers\"]:\n                            peers_try = [peer for peer in task[\"peers\"] if peer not in task[\"failed\"] and peer not in workers]\n                            if peers_try:\n                                self.startWorkers(peers_try, force_num=5)\n                            else:\n                                self.startFindOptional(find_more=True)\n                        else:\n                            self.startFindOptional(find_more=True)\n                    else:\n                        if task[\"peers\"]:  \n                            self.log.debug(\"Task peer lock release: %s\" % task[\"inner_path\"])\n                            task[\"peers\"] = []\n                        self.startWorkers()\n\n            if len(self.tasks) > len(self.workers) * 2 and len(self.workers) < self.getMaxWorkers():\n                self.startWorkers()\n\n        self.log.debug(\"checkTasks stopped running\")\n\n    \n    def getTask(self, peer):\n        \n        self.tasks.sort(key=lambda task: task[\"priority\"] - task[\"workers_num\"] * 10, reverse=True)\n\n        for task in self.tasks:  \n            if task[\"peers\"] and peer not in task[\"peers\"]:\n                continue  \n            if peer in task[\"failed\"]:\n                continue  \n            if task[\"optional_hash_id\"] and task[\"peers\"] is None:\n                continue  \n            return task\n\n    def removeGoodFileTasks(self):\n        for task in self.tasks[:]:\n            if task[\"inner_path\"] not in self.site.bad_files:\n                self.log.debug(\"No longer in bad_files, marking as good: %s\" % task[\"inner_path\"])\n                task[\"done\"] = True\n                task[\"evt\"].set(True)\n                self.tasks.remove(task)\n        if not self.tasks:\n            self.started_task_num = 0\n        self.site.updateWebsocket()\n\n    \n    def onPeers(self):\n        self.startWorkers()\n\n    def getMaxWorkers(self):\n        if len(self.tasks) > 50:\n            return config.workers * 3\n        else:\n            return config.workers\n\n    \n    def addWorker(self, peer, multiplexing=False, force=False):\n        key = peer.key\n        if len(self.workers) > self.getMaxWorkers() and not force:\n            return False\n        if multiplexing:  \n            key = \"%s/%s\" % (key, len(self.workers))\n        if key not in self.workers:\n            \n            worker = Worker(self, peer)\n            self.workers[key] = worker\n            worker.key = key\n            worker.start()\n            return worker\n        else:  \n            return False\n\n    def taskAddPeer(self, task, peer):\n        if task[\"peers\"] is None:\n            task[\"peers\"] = []\n        if peer in task[\"failed\"]:\n            return False\n\n        if peer not in task[\"peers\"]:\n            task[\"peers\"].append(peer)\n        return True\n\n    \n    def startWorkers(self, peers=None, force_num=0):\n        if not self.tasks:\n            return False  \n        if len(self.workers) >= self.getMaxWorkers() and not peers:\n            return False  \n        self.log.debug(\n            \"Starting workers, tasks: %s, peers: %s, workers: %s\" %\n            (len(self.tasks), len(peers or []), len(self.workers))\n        )\n        if not peers:\n            peers = self.site.getConnectedPeers()\n            if len(peers) < self.getMaxWorkers():\n                peers += self.site.getRecentPeers(self.getMaxWorkers())\n        if type(peers) is set:\n            peers = list(peers)\n\n        \n        peers.sort(key=lambda peer: peer.connection.last_ping_delay if peer.connection and len(peer.connection.waiting_requests) == 0 and peer.connection.connected else 9999)\n\n        for peer in peers:  \n            if peers and peer not in peers:\n                continue  \n\n            if force_num:\n                worker = self.addWorker(peer, force=True)\n                force_num -= 1\n            else:\n                worker = self.addWorker(peer)\n\n            if worker:\n                self.log.debug(\"Added worker: %s, workers: %s/%s\" % (peer.key, len(self.workers), self.getMaxWorkers()))\n\n    \n    def findOptionalTasks(self, optional_tasks, reset_task=False):\n        found = collections.defaultdict(list)  # { found_hash: [peer1, peer2...], ...}\n\n        for peer in self.site.peers.values():\n            if not peer.has_hashfield:\n                continue\n\n            hashfield_set = set(peer.hashfield)  \n            for task in optional_tasks:\n                optional_hash_id = task[\"optional_hash_id\"]\n                if optional_hash_id in hashfield_set:\n                    if reset_task and len(task[\"failed\"]) > 0:\n                        task[\"failed\"] = []\n                    if peer in task[\"failed\"]:\n                        continue\n                    if self.taskAddPeer(task, peer):\n                        found[optional_hash_id].append(peer)\n\n        return found\n\n    \n    def findOptionalHashIds(self, optional_hash_ids, limit=0):\n        found = collections.defaultdict(list)  # { found_hash_id: [peer1, peer2...], ...}\n\n        for peer in self.site.peers.values():\n            if not peer.has_hashfield:\n                continue\n\n            hashfield_set = set(peer.hashfield)  \n            for optional_hash_id in optional_hash_ids:\n                if optional_hash_id in hashfield_set:\n                    found[optional_hash_id].append(peer)\n                    if limit and len(found[optional_hash_id]) >= limit:\n                        optional_hash_ids.remove(optional_hash_id)\n\n        return found\n\n    \n    def addOptionalPeers(self, found_ips):\n        found = collections.defaultdict(list)\n        for hash_id, peer_ips in found_ips.iteritems():\n            task = [task for task in self.tasks if task[\"optional_hash_id\"] == hash_id]\n            if task:  \n                task = task[0]\n            else:\n                continue\n            for peer_ip in peer_ips:\n                peer = self.site.addPeer(peer_ip[0], peer_ip[1], return_peer=True, source=\"optional\")\n                if not peer:\n                    continue\n                if self.taskAddPeer(task, peer):\n                    found[hash_id].append(peer)\n                if peer.hashfield.appendHashId(hash_id):  \n                    peer.time_hashfield = None  \n\n        return found\n\n    \n    @util.Noparallel(blocking=False, ignore_args=True)\n    def startFindOptional(self, reset_task=False, find_more=False, high_priority=False):\n        \n        if len(self.tasks) < 20 or high_priority:\n            time.sleep(0.01)\n        elif len(self.tasks) > 90:\n            time.sleep(5)\n        else:\n            time.sleep(0.5)\n\n        optional_tasks = [task for task in self.tasks if task[\"optional_hash_id\"]]\n        if not optional_tasks:\n            return False\n        optional_hash_ids = set([task[\"optional_hash_id\"] for task in optional_tasks])\n        time_tasks = self.time_task_added\n\n        self.log.debug(\n            \"Finding peers for optional files: %s (reset_task: %s, find_more: %s)\" %\n            (optional_hash_ids, reset_task, find_more)\n        )\n        found = self.findOptionalTasks(optional_tasks, reset_task=reset_task)\n\n        if found:\n            found_peers = set([peer for peers in found.values() for peer in peers])\n            self.startWorkers(found_peers, force_num=3)\n\n        if len(found) < len(optional_hash_ids) or find_more or (high_priority and any(len(peers) < 10 for peers in found.itervalues())):\n            self.log.debug(\"No local result for optional files: %s\" % (optional_hash_ids - set(found)))\n\n            \n            threads = []\n            peers = self.site.getConnectedPeers()\n            if not peers:\n                peers = self.site.getConnectablePeers()\n            for peer in peers:\n                threads.append(gevent.spawn(peer.updateHashfield, force=find_more))\n            gevent.joinall(threads, timeout=5)\n\n            if time_tasks != self.time_task_added:  \n                optional_tasks = [task for task in self.tasks if task[\"optional_hash_id\"]]\n                optional_hash_ids = set([task[\"optional_hash_id\"] for task in optional_tasks])\n\n            found = self.findOptionalTasks(optional_tasks)\n            self.log.debug(\"Found optional files after query hashtable connected peers: %s/%s\" % (\n                len(found), len(optional_hash_ids)\n            ))\n\n            if found:\n                found_peers = set([peer for hash_id_peers in found.values() for peer in hash_id_peers])\n                self.startWorkers(found_peers, force_num=3)\n\n        if len(found) < len(optional_hash_ids) or find_more:\n            self.log.debug(\n                \"No connected hashtable result for optional files: %s (asked: %s)\" %\n                (optional_hash_ids - set(found), len(self.asked_peers))\n            )\n            if not self.tasks:\n                self.log.debug(\"No tasks, stopping finding optional peers\")\n                return\n\n            \n            threads = []\n            peers = [peer for peer in self.site.getConnectedPeers() if peer.key not in self.asked_peers][0:10]\n            if not peers:\n                peers = self.site.getConnectablePeers(ignore=self.asked_peers)\n\n            for peer in peers:\n                threads.append(gevent.spawn(peer.findHashIds, list(optional_hash_ids)))\n                self.asked_peers.append(peer.key)\n\n            for i in range(5):\n                time.sleep(1)\n\n                thread_values = [thread.value for thread in threads if thread.value]\n                if not thread_values:\n                    continue\n\n                found_ips = helper.mergeDicts(thread_values)\n                found = self.addOptionalPeers(found_ips)\n                self.log.debug(\"Found optional files after findhash connected peers: %s/%s (asked: %s)\" % (\n                    len(found), len(optional_hash_ids), len(threads)\n                ))\n\n                if found:\n                    found_peers = set([peer for hash_id_peers in found.values() for peer in hash_id_peers])\n                    self.startWorkers(found_peers, force_num=3)\n\n                if len(thread_values) == len(threads):\n                    \n                    break\n\n        if len(found) < len(optional_hash_ids):\n            self.log.debug(\n                \"No findHash result, try random peers: %s (asked: %s)\" %\n                (optional_hash_ids - set(found), len(self.asked_peers))\n            )\n            \n\n            if time_tasks != self.time_task_added:  \n                optional_tasks = [task for task in self.tasks if task[\"optional_hash_id\"]]\n                optional_hash_ids = set([task[\"optional_hash_id\"] for task in optional_tasks])\n\n            threads = []\n            peers = self.site.getConnectablePeers(ignore=self.asked_peers)\n\n            for peer in peers:\n                threads.append(gevent.spawn(peer.findHashIds, list(optional_hash_ids)))\n                self.asked_peers.append(peer.key)\n\n            gevent.joinall(threads, timeout=15)\n\n            found_ips = helper.mergeDicts([thread.value for thread in threads if thread.value])\n            found = self.addOptionalPeers(found_ips)\n            self.log.debug(\"Found optional files after findhash random peers: %s/%s\" % (len(found), len(optional_hash_ids)))\n\n            if found:\n                found_peers = set([peer for hash_id_peers in found.values() for peer in hash_id_peers])\n                self.startWorkers(found_peers, force_num=3)\n\n        if len(found) < len(optional_hash_ids):\n            self.log.debug(\"No findhash result for optional files: %s\" % (optional_hash_ids - set(found)))\n\n        if time_tasks != self.time_task_added:  \n            self.log.debug(\"New task since start, restarting...\")\n            gevent.spawn_later(0.1, self.startFindOptional)\n        else:\n            self.log.debug(\"startFindOptional ended\")\n\n    \n    def stopWorkers(self):\n        for worker in self.workers.values():\n            worker.stop()\n        tasks = self.tasks[:]  \n        for task in tasks:  \n            self.failTask(task)\n\n    \n    def findWorkers(self, task):\n        workers = []\n        for worker in self.workers.values():\n            if worker.task == task:\n                workers.append(worker)\n        return workers\n\n    \n    def removeWorker(self, worker):\n        worker.running = False\n        if worker.key in self.workers:\n            del(self.workers[worker.key])\n            self.log.debug(\"Removed worker, workers: %s/%s\" % (len(self.workers), self.getMaxWorkers()))\n        if len(self.workers) <= self.getMaxWorkers() / 3 and len(self.asked_peers) < 10:\n            optional_task = next((task for task in self.tasks if task[\"optional_hash_id\"]), None)\n            if optional_task:\n                if len(self.workers) == 0:\n                    self.startFindOptional(find_more=True)\n                else:\n                    self.startFindOptional()\n            elif self.tasks and not self.workers and worker.task:\n                self.log.debug(\"Starting new workers... (tasks: %s)\" % len(self.tasks))\n                self.startWorkers()\n\n\n    \n    def getPriorityBoost(self, inner_path):\n        if inner_path == \"content.json\":\n            return 9999  \n        if inner_path == \"index.html\":\n            return 9998  \n        if \"-default\" in inner_path:\n            return -4  \n        elif inner_path.endswith(\"all.css\"):\n            return 14  \n        elif inner_path.endswith(\"all.js\"):\n            return 13  \n        elif inner_path.endswith(\"dbschema.json\"):\n            return 12  \n        elif inner_path.endswith(\"content.json\"):\n            return 1  \n        elif inner_path.endswith(\".json\"):\n            if len(inner_path) < 50:  \n                return 11\n            else:\n                return 2\n        return 0\n\n    \n    def addTask(self, inner_path, peer=None, priority=0, file_info=None):\n        self.site.onFileStart(inner_path)  \n        task = self.findTask(inner_path)\n        if task:  \n            task[\"priority\"] = max(priority, task[\"priority\"])\n            if peer and task[\"peers\"]:  \n                task[\"peers\"].append(peer)\n                self.log.debug(\"Added peer %s to %s\" % (peer.key, task[\"inner_path\"]))\n                self.startWorkers([peer])\n            elif peer and peer in task[\"failed\"]:\n                task[\"failed\"].remove(peer)  \n                self.log.debug(\"Removed peer %s from failed %s\" % (peer.key, task[\"inner_path\"]))\n                self.startWorkers([peer])\n            return task\n        else:  \n            evt = gevent.event.AsyncResult()\n            if peer:\n                peers = [peer]  \n            else:\n                peers = None\n            if not file_info:\n                file_info = self.site.content_manager.getFileInfo(inner_path)\n            if file_info and file_info[\"optional\"]:\n                optional_hash_id = helper.toHashId(file_info[\"sha512\"])\n            else:\n                optional_hash_id = None\n            if file_info:\n                size = file_info.get(\"size\", 0)\n            else:\n                size = 0\n            priority += self.getPriorityBoost(inner_path)\n\n            if self.started_task_num == 0:  \n                priority += 1\n\n            task = {\n                \"evt\": evt, \"workers_num\": 0, \"site\": self.site, \"inner_path\": inner_path, \"done\": False,\n                \"optional_hash_id\": optional_hash_id, \"time_added\": time.time(), \"time_started\": None,\n                \"time_action\": None, \"peers\": peers, \"priority\": priority, \"failed\": [], \"size\": size\n            }\n\n            self.tasks.append(task)\n\n            self.started_task_num += 1\n            self.log.debug(\n                \"New task: %s, peer lock: %s, priority: %s, optional_hash_id: %s, tasks started: %s\" %\n                (task[\"inner_path\"], peers, priority, optional_hash_id, self.started_task_num)\n            )\n            self.time_task_added = time.time()\n\n            if optional_hash_id:\n                if self.asked_peers:\n                    del self.asked_peers[:]  \n                self.startFindOptional(high_priority=priority > 0)\n\n                if peers:\n                    self.startWorkers(peers)\n\n            else:\n                self.startWorkers(peers)\n            return task\n\n     using inner_path\n    def findTask(self, inner_path):\n        for task in self.tasks:\n            if task[\"inner_path\"] == inner_path:\n                return task\n        return None  \n\n    \n    def checkComplete(self):\n        time.sleep(0.1)\n        if not self.tasks:\n            self.log.debug(\"Check compelte: No tasks\")\n            self.onComplete()\n\n    def onComplete(self):\n        self.started_task_num = 0\n        del self.asked_peers[:]\n        self.site.onComplete()  \n\n    \n    def doneTask(self, task):\n        task[\"done\"] = True\n        self.tasks.remove(task)  \n        if task[\"optional_hash_id\"]:\n            self.log.debug(\n                \"Downloaded optional file in %.3fs, adding to hashfield: %s\" %\n                (time.time() - task[\"time_started\"], task[\"inner_path\"])\n            )\n            self.site.content_manager.optionalDownloaded(task[\"inner_path\"], task[\"optional_hash_id\"], task[\"size\"])\n        self.site.onFileDone(task[\"inner_path\"])\n        task[\"evt\"].set(True)\n        if not self.tasks:\n            gevent.spawn(self.checkComplete)\n\n    \n    def failTask(self, task):\n        if task in self.tasks:\n            task[\"done\"] = True\n            self.tasks.remove(task)  \n            self.site.onFileFail(task[\"inner_path\"])\n            task[\"evt\"].set(False)\n            if not self.tasks:\n                self.started_task_num = 0\n", "comments": "  key  ip port  value  worker worker      evt   evt   workers num   0   site   self site   inner path   inner path   done   false   optional hash id   none      time started   none   time added   time time()   peers   peers   priority   0   failed   peer ids     last added task num    check expired tasks    cleanup local variables    check every 15 sec    clean workers    stop workers task done    copy removing elements wont cause problem    task taking long time  skip    skip next file workers    no workers left    remove task    find workers  task started 15 sec ago workers    find peers    re search high priority    release peer lock    returns next free less worked task    sort tasks priority worker numbers    find task    this peer allowed pick task    peer already tried solve  failed    no peers found yet optional task    new peers added site    add new worker    add even already worker peer    we dont worker peer workers num less max    we woker peer limit    start workers process tasks    no task workers    workers number already maxed starting peers defined    sort ping    one worker every peer    if peers defined peer valid    find peers optional hash local hash tables add task peers      found hash   peer1  peer2              finding set much faster    find peers optional hash ids local hash tables      found hash id   peer1  peer2              finding set much faster    add peers tasks found result    found task  lets take first    peer file    peer hashfield probably outdated    start find peers optional files    wait file requests    query hashfield connected peers    new task added since start    try query connected peers    got result started thread    try query random peers    new task added since start    new task added since start    stop worker    copy    mark current task failed    find workers task    ends remove worker    tasks sorted    content json always priority    index html also important    default files cloning important    boost css files priority    boost js files priority    boost database specification    boost included content json files priority bit    boost non user json files    create new task return asyncresult    first task  trigger site download started    already task file    this peer also new version  add task possible peers    new update arrived  remove peer failed peers    no task file yet    only download peer    boost priority first requested file    reset asked peers    find task using inner path    not found    wait tasks    no task trigger site complete    mark task done    remove queue    mark task failed    remove queue ", "content": "import time\nimport logging\nimport collections\n\nimport gevent\n\nfrom Worker import Worker\nfrom Config import config\nfrom util import helper\nfrom Plugin import PluginManager\nimport util\n\n\n@PluginManager.acceptPlugins\nclass WorkerManager(object):\n\n    def __init__(self, site):\n        self.site = site\n        self.workers = {}  # Key: ip:port, Value: Worker.Worker\n        self.tasks = []\n        # {\"evt\": evt, \"workers_num\": 0, \"site\": self.site, \"inner_path\": inner_path, \"done\": False, \"optional_hash_id\": None,\n        # \"time_started\": None, \"time_added\": time.time(), \"peers\": peers, \"priority\": 0, \"failed\": peer_ids}\n        self.started_task_num = 0  # Last added task num\n        self.asked_peers = []\n        self.running = True\n        self.time_task_added = 0\n        self.log = logging.getLogger(\"WorkerManager:%s\" % self.site.address_short)\n        self.process_taskchecker = gevent.spawn(self.checkTasks)\n\n    def __str__(self):\n        return \"WorkerManager %s\" % self.site.address_short\n\n    def __repr__(self):\n        return \"<%s>\" % self.__str__()\n\n    # Check expired tasks\n    def checkTasks(self):\n        while self.running:\n            tasks = task = worker = workers = None  # Cleanup local variables\n            announced = False\n            time.sleep(15)  # Check every 15 sec\n\n            # Clean up workers\n            for worker in self.workers.values():\n                if worker.task and worker.task[\"done\"]:\n                    worker.skip()  # Stop workers with task done\n\n            if not self.tasks:\n                continue\n\n            tasks = self.tasks[:]  # Copy it so removing elements wont cause any problem\n            for task in tasks:\n                if task[\"time_started\"] and time.time() >= task[\"time_started\"] + 60:\n                    self.log.debug(\"Timeout, Skipping: %s\" % task)  # Task taking too long time, skip it\n                    # Skip to next file workers\n                    workers = self.findWorkers(task)\n                    if workers:\n                        for worker in workers:\n                            worker.skip()\n                    else:\n                        self.failTask(task)\n                elif time.time() >= task[\"time_added\"] + 60 and not self.workers:  # No workers left\n                    self.log.debug(\"Timeout, Cleanup task: %s\" % task)\n                    # Remove task\n                    self.failTask(task)\n\n                elif (task[\"time_started\"] and time.time() >= task[\"time_started\"] + 15) or not self.workers:\n                    # Find more workers: Task started more than 15 sec ago or no workers\n                    workers = self.findWorkers(task)\n                    self.log.debug(\n                        \"Slow task: %s, (workers: %s, optional_hash_id: %s, peers: %s, failed: %s, asked: %s)\" %\n                        (\n                            task[\"inner_path\"], len(workers), task[\"optional_hash_id\"],\n                            len(task[\"peers\"] or []), len(task[\"failed\"]), len(self.asked_peers)\n                        )\n                    )\n                    if not announced:\n                        task[\"site\"].announce(mode=\"more\")  # Find more peers\n                        announced = True\n                    if task[\"optional_hash_id\"]:\n                        if self.workers:\n                            if not task[\"time_started\"]:\n                                ask_limit = 20\n                            else:\n                                ask_limit = max(10, time.time() - task[\"time_started\"])\n                            if len(self.asked_peers) < ask_limit and len(task[\"peers\"] or []) <= len(task[\"failed\"]) * 2:\n                                # Re-search for high priority\n                                self.startFindOptional(find_more=True)\n                        if task[\"peers\"]:\n                            peers_try = [peer for peer in task[\"peers\"] if peer not in task[\"failed\"] and peer not in workers]\n                            if peers_try:\n                                self.startWorkers(peers_try, force_num=5)\n                            else:\n                                self.startFindOptional(find_more=True)\n                        else:\n                            self.startFindOptional(find_more=True)\n                    else:\n                        if task[\"peers\"]:  # Release the peer lock\n                            self.log.debug(\"Task peer lock release: %s\" % task[\"inner_path\"])\n                            task[\"peers\"] = []\n                        self.startWorkers()\n\n            if len(self.tasks) > len(self.workers) * 2 and len(self.workers) < self.getMaxWorkers():\n                self.startWorkers()\n\n        self.log.debug(\"checkTasks stopped running\")\n\n    # Returns the next free or less worked task\n    def getTask(self, peer):\n        # Sort tasks by priority and worker numbers\n        self.tasks.sort(key=lambda task: task[\"priority\"] - task[\"workers_num\"] * 10, reverse=True)\n\n        for task in self.tasks:  # Find a task\n            if task[\"peers\"] and peer not in task[\"peers\"]:\n                continue  # This peer not allowed to pick this task\n            if peer in task[\"failed\"]:\n                continue  # Peer already tried to solve this, but failed\n            if task[\"optional_hash_id\"] and task[\"peers\"] is None:\n                continue  # No peers found yet for the optional task\n            return task\n\n    def removeGoodFileTasks(self):\n        for task in self.tasks[:]:\n            if task[\"inner_path\"] not in self.site.bad_files:\n                self.log.debug(\"No longer in bad_files, marking as good: %s\" % task[\"inner_path\"])\n                task[\"done\"] = True\n                task[\"evt\"].set(True)\n                self.tasks.remove(task)\n        if not self.tasks:\n            self.started_task_num = 0\n        self.site.updateWebsocket()\n\n    # New peers added to site\n    def onPeers(self):\n        self.startWorkers()\n\n    def getMaxWorkers(self):\n        if len(self.tasks) > 50:\n            return config.workers * 3\n        else:\n            return config.workers\n\n    # Add new worker\n    def addWorker(self, peer, multiplexing=False, force=False):\n        key = peer.key\n        if len(self.workers) > self.getMaxWorkers() and not force:\n            return False\n        if multiplexing:  # Add even if we already have worker for this peer\n            key = \"%s/%s\" % (key, len(self.workers))\n        if key not in self.workers:\n            # We dont have worker for that peer and workers num less than max\n            worker = Worker(self, peer)\n            self.workers[key] = worker\n            worker.key = key\n            worker.start()\n            return worker\n        else:  # We have woker for this peer or its over the limit\n            return False\n\n    def taskAddPeer(self, task, peer):\n        if task[\"peers\"] is None:\n            task[\"peers\"] = []\n        if peer in task[\"failed\"]:\n            return False\n\n        if peer not in task[\"peers\"]:\n            task[\"peers\"].append(peer)\n        return True\n\n    # Start workers to process tasks\n    def startWorkers(self, peers=None, force_num=0):\n        if not self.tasks:\n            return False  # No task for workers\n        if len(self.workers) >= self.getMaxWorkers() and not peers:\n            return False  # Workers number already maxed and no starting peers defined\n        self.log.debug(\n            \"Starting workers, tasks: %s, peers: %s, workers: %s\" %\n            (len(self.tasks), len(peers or []), len(self.workers))\n        )\n        if not peers:\n            peers = self.site.getConnectedPeers()\n            if len(peers) < self.getMaxWorkers():\n                peers += self.site.getRecentPeers(self.getMaxWorkers())\n        if type(peers) is set:\n            peers = list(peers)\n\n        # Sort by ping\n        peers.sort(key=lambda peer: peer.connection.last_ping_delay if peer.connection and len(peer.connection.waiting_requests) == 0 and peer.connection.connected else 9999)\n\n        for peer in peers:  # One worker for every peer\n            if peers and peer not in peers:\n                continue  # If peers defined and peer not valid\n\n            if force_num:\n                worker = self.addWorker(peer, force=True)\n                force_num -= 1\n            else:\n                worker = self.addWorker(peer)\n\n            if worker:\n                self.log.debug(\"Added worker: %s, workers: %s/%s\" % (peer.key, len(self.workers), self.getMaxWorkers()))\n\n    # Find peers for optional hash in local hash tables and add to task peers\n    def findOptionalTasks(self, optional_tasks, reset_task=False):\n        found = collections.defaultdict(list)  # { found_hash: [peer1, peer2...], ...}\n\n        for peer in self.site.peers.values():\n            if not peer.has_hashfield:\n                continue\n\n            hashfield_set = set(peer.hashfield)  # Finding in set is much faster\n            for task in optional_tasks:\n                optional_hash_id = task[\"optional_hash_id\"]\n                if optional_hash_id in hashfield_set:\n                    if reset_task and len(task[\"failed\"]) > 0:\n                        task[\"failed\"] = []\n                    if peer in task[\"failed\"]:\n                        continue\n                    if self.taskAddPeer(task, peer):\n                        found[optional_hash_id].append(peer)\n\n        return found\n\n    # Find peers for optional hash ids in local hash tables\n    def findOptionalHashIds(self, optional_hash_ids, limit=0):\n        found = collections.defaultdict(list)  # { found_hash_id: [peer1, peer2...], ...}\n\n        for peer in self.site.peers.values():\n            if not peer.has_hashfield:\n                continue\n\n            hashfield_set = set(peer.hashfield)  # Finding in set is much faster\n            for optional_hash_id in optional_hash_ids:\n                if optional_hash_id in hashfield_set:\n                    found[optional_hash_id].append(peer)\n                    if limit and len(found[optional_hash_id]) >= limit:\n                        optional_hash_ids.remove(optional_hash_id)\n\n        return found\n\n    # Add peers to tasks from found result\n    def addOptionalPeers(self, found_ips):\n        found = collections.defaultdict(list)\n        for hash_id, peer_ips in found_ips.iteritems():\n            task = [task for task in self.tasks if task[\"optional_hash_id\"] == hash_id]\n            if task:  # Found task, lets take the first\n                task = task[0]\n            else:\n                continue\n            for peer_ip in peer_ips:\n                peer = self.site.addPeer(peer_ip[0], peer_ip[1], return_peer=True, source=\"optional\")\n                if not peer:\n                    continue\n                if self.taskAddPeer(task, peer):\n                    found[hash_id].append(peer)\n                if peer.hashfield.appendHashId(hash_id):  # Peer has this file\n                    peer.time_hashfield = None  # Peer hashfield probably outdated\n\n        return found\n\n    # Start find peers for optional files\n    @util.Noparallel(blocking=False, ignore_args=True)\n    def startFindOptional(self, reset_task=False, find_more=False, high_priority=False):\n        # Wait for more file requests\n        if len(self.tasks) < 20 or high_priority:\n            time.sleep(0.01)\n        elif len(self.tasks) > 90:\n            time.sleep(5)\n        else:\n            time.sleep(0.5)\n\n        optional_tasks = [task for task in self.tasks if task[\"optional_hash_id\"]]\n        if not optional_tasks:\n            return False\n        optional_hash_ids = set([task[\"optional_hash_id\"] for task in optional_tasks])\n        time_tasks = self.time_task_added\n\n        self.log.debug(\n            \"Finding peers for optional files: %s (reset_task: %s, find_more: %s)\" %\n            (optional_hash_ids, reset_task, find_more)\n        )\n        found = self.findOptionalTasks(optional_tasks, reset_task=reset_task)\n\n        if found:\n            found_peers = set([peer for peers in found.values() for peer in peers])\n            self.startWorkers(found_peers, force_num=3)\n\n        if len(found) < len(optional_hash_ids) or find_more or (high_priority and any(len(peers) < 10 for peers in found.itervalues())):\n            self.log.debug(\"No local result for optional files: %s\" % (optional_hash_ids - set(found)))\n\n            # Query hashfield from connected peers\n            threads = []\n            peers = self.site.getConnectedPeers()\n            if not peers:\n                peers = self.site.getConnectablePeers()\n            for peer in peers:\n                threads.append(gevent.spawn(peer.updateHashfield, force=find_more))\n            gevent.joinall(threads, timeout=5)\n\n            if time_tasks != self.time_task_added:  # New task added since start\n                optional_tasks = [task for task in self.tasks if task[\"optional_hash_id\"]]\n                optional_hash_ids = set([task[\"optional_hash_id\"] for task in optional_tasks])\n\n            found = self.findOptionalTasks(optional_tasks)\n            self.log.debug(\"Found optional files after query hashtable connected peers: %s/%s\" % (\n                len(found), len(optional_hash_ids)\n            ))\n\n            if found:\n                found_peers = set([peer for hash_id_peers in found.values() for peer in hash_id_peers])\n                self.startWorkers(found_peers, force_num=3)\n\n        if len(found) < len(optional_hash_ids) or find_more:\n            self.log.debug(\n                \"No connected hashtable result for optional files: %s (asked: %s)\" %\n                (optional_hash_ids - set(found), len(self.asked_peers))\n            )\n            if not self.tasks:\n                self.log.debug(\"No tasks, stopping finding optional peers\")\n                return\n\n            # Try to query connected peers\n            threads = []\n            peers = [peer for peer in self.site.getConnectedPeers() if peer.key not in self.asked_peers][0:10]\n            if not peers:\n                peers = self.site.getConnectablePeers(ignore=self.asked_peers)\n\n            for peer in peers:\n                threads.append(gevent.spawn(peer.findHashIds, list(optional_hash_ids)))\n                self.asked_peers.append(peer.key)\n\n            for i in range(5):\n                time.sleep(1)\n\n                thread_values = [thread.value for thread in threads if thread.value]\n                if not thread_values:\n                    continue\n\n                found_ips = helper.mergeDicts(thread_values)\n                found = self.addOptionalPeers(found_ips)\n                self.log.debug(\"Found optional files after findhash connected peers: %s/%s (asked: %s)\" % (\n                    len(found), len(optional_hash_ids), len(threads)\n                ))\n\n                if found:\n                    found_peers = set([peer for hash_id_peers in found.values() for peer in hash_id_peers])\n                    self.startWorkers(found_peers, force_num=3)\n\n                if len(thread_values) == len(threads):\n                    # Got result from all started thread\n                    break\n\n        if len(found) < len(optional_hash_ids):\n            self.log.debug(\n                \"No findHash result, try random peers: %s (asked: %s)\" %\n                (optional_hash_ids - set(found), len(self.asked_peers))\n            )\n            # Try to query random peers\n\n            if time_tasks != self.time_task_added:  # New task added since start\n                optional_tasks = [task for task in self.tasks if task[\"optional_hash_id\"]]\n                optional_hash_ids = set([task[\"optional_hash_id\"] for task in optional_tasks])\n\n            threads = []\n            peers = self.site.getConnectablePeers(ignore=self.asked_peers)\n\n            for peer in peers:\n                threads.append(gevent.spawn(peer.findHashIds, list(optional_hash_ids)))\n                self.asked_peers.append(peer.key)\n\n            gevent.joinall(threads, timeout=15)\n\n            found_ips = helper.mergeDicts([thread.value for thread in threads if thread.value])\n            found = self.addOptionalPeers(found_ips)\n            self.log.debug(\"Found optional files after findhash random peers: %s/%s\" % (len(found), len(optional_hash_ids)))\n\n            if found:\n                found_peers = set([peer for hash_id_peers in found.values() for peer in hash_id_peers])\n                self.startWorkers(found_peers, force_num=3)\n\n        if len(found) < len(optional_hash_ids):\n            self.log.debug(\"No findhash result for optional files: %s\" % (optional_hash_ids - set(found)))\n\n        if time_tasks != self.time_task_added:  # New task added since start\n            self.log.debug(\"New task since start, restarting...\")\n            gevent.spawn_later(0.1, self.startFindOptional)\n        else:\n            self.log.debug(\"startFindOptional ended\")\n\n    # Stop all worker\n    def stopWorkers(self):\n        for worker in self.workers.values():\n            worker.stop()\n        tasks = self.tasks[:]  # Copy\n        for task in tasks:  # Mark all current task as failed\n            self.failTask(task)\n\n    # Find workers by task\n    def findWorkers(self, task):\n        workers = []\n        for worker in self.workers.values():\n            if worker.task == task:\n                workers.append(worker)\n        return workers\n\n    # Ends and remove a worker\n    def removeWorker(self, worker):\n        worker.running = False\n        if worker.key in self.workers:\n            del(self.workers[worker.key])\n            self.log.debug(\"Removed worker, workers: %s/%s\" % (len(self.workers), self.getMaxWorkers()))\n        if len(self.workers) <= self.getMaxWorkers() / 3 and len(self.asked_peers) < 10:\n            optional_task = next((task for task in self.tasks if task[\"optional_hash_id\"]), None)\n            if optional_task:\n                if len(self.workers) == 0:\n                    self.startFindOptional(find_more=True)\n                else:\n                    self.startFindOptional()\n            elif self.tasks and not self.workers and worker.task:\n                self.log.debug(\"Starting new workers... (tasks: %s)\" % len(self.tasks))\n                self.startWorkers()\n\n\n    # Tasks sorted by this\n    def getPriorityBoost(self, inner_path):\n        if inner_path == \"content.json\":\n            return 9999  # Content.json always priority\n        if inner_path == \"index.html\":\n            return 9998  # index.html also important\n        if \"-default\" in inner_path:\n            return -4  # Default files are cloning not important\n        elif inner_path.endswith(\"all.css\"):\n            return 14  # boost css files priority\n        elif inner_path.endswith(\"all.js\"):\n            return 13  # boost js files priority\n        elif inner_path.endswith(\"dbschema.json\"):\n            return 12  # boost database specification\n        elif inner_path.endswith(\"content.json\"):\n            return 1  # boost included content.json files priority a bit\n        elif inner_path.endswith(\".json\"):\n            if len(inner_path) < 50:  # Boost non-user json files\n                return 11\n            else:\n                return 2\n        return 0\n\n    # Create new task and return asyncresult\n    def addTask(self, inner_path, peer=None, priority=0, file_info=None):\n        self.site.onFileStart(inner_path)  # First task, trigger site download started\n        task = self.findTask(inner_path)\n        if task:  # Already has task for that file\n            task[\"priority\"] = max(priority, task[\"priority\"])\n            if peer and task[\"peers\"]:  # This peer also has new version, add it to task possible peers\n                task[\"peers\"].append(peer)\n                self.log.debug(\"Added peer %s to %s\" % (peer.key, task[\"inner_path\"]))\n                self.startWorkers([peer])\n            elif peer and peer in task[\"failed\"]:\n                task[\"failed\"].remove(peer)  # New update arrived, remove the peer from failed peers\n                self.log.debug(\"Removed peer %s from failed %s\" % (peer.key, task[\"inner_path\"]))\n                self.startWorkers([peer])\n            return task\n        else:  # No task for that file yet\n            evt = gevent.event.AsyncResult()\n            if peer:\n                peers = [peer]  # Only download from this peer\n            else:\n                peers = None\n            if not file_info:\n                file_info = self.site.content_manager.getFileInfo(inner_path)\n            if file_info and file_info[\"optional\"]:\n                optional_hash_id = helper.toHashId(file_info[\"sha512\"])\n            else:\n                optional_hash_id = None\n            if file_info:\n                size = file_info.get(\"size\", 0)\n            else:\n                size = 0\n            priority += self.getPriorityBoost(inner_path)\n\n            if self.started_task_num == 0:  # Boost priority for first requested file\n                priority += 1\n\n            task = {\n                \"evt\": evt, \"workers_num\": 0, \"site\": self.site, \"inner_path\": inner_path, \"done\": False,\n                \"optional_hash_id\": optional_hash_id, \"time_added\": time.time(), \"time_started\": None,\n                \"time_action\": None, \"peers\": peers, \"priority\": priority, \"failed\": [], \"size\": size\n            }\n\n            self.tasks.append(task)\n\n            self.started_task_num += 1\n            self.log.debug(\n                \"New task: %s, peer lock: %s, priority: %s, optional_hash_id: %s, tasks started: %s\" %\n                (task[\"inner_path\"], peers, priority, optional_hash_id, self.started_task_num)\n            )\n            self.time_task_added = time.time()\n\n            if optional_hash_id:\n                if self.asked_peers:\n                    del self.asked_peers[:]  # Reset asked peers\n                self.startFindOptional(high_priority=priority > 0)\n\n                if peers:\n                    self.startWorkers(peers)\n\n            else:\n                self.startWorkers(peers)\n            return task\n\n    # Find a task using inner_path\n    def findTask(self, inner_path):\n        for task in self.tasks:\n            if task[\"inner_path\"] == inner_path:\n                return task\n        return None  # Not found\n\n    # Wait for other tasks\n    def checkComplete(self):\n        time.sleep(0.1)\n        if not self.tasks:\n            self.log.debug(\"Check compelte: No tasks\")\n            self.onComplete()\n\n    def onComplete(self):\n        self.started_task_num = 0\n        del self.asked_peers[:]\n        self.site.onComplete()  # No more task trigger site complete\n\n    # Mark a task done\n    def doneTask(self, task):\n        task[\"done\"] = True\n        self.tasks.remove(task)  # Remove from queue\n        if task[\"optional_hash_id\"]:\n            self.log.debug(\n                \"Downloaded optional file in %.3fs, adding to hashfield: %s\" %\n                (time.time() - task[\"time_started\"], task[\"inner_path\"])\n            )\n            self.site.content_manager.optionalDownloaded(task[\"inner_path\"], task[\"optional_hash_id\"], task[\"size\"])\n        self.site.onFileDone(task[\"inner_path\"])\n        task[\"evt\"].set(True)\n        if not self.tasks:\n            gevent.spawn(self.checkComplete)\n\n    # Mark a task failed\n    def failTask(self, task):\n        if task in self.tasks:\n            task[\"done\"] = True\n            self.tasks.remove(task)  # Remove from queue\n            self.site.onFileFail(task[\"inner_path\"])\n            task[\"evt\"].set(False)\n            if not self.tasks:\n                self.started_task_num = 0\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "WorkerManager.py", "id": "ccee33be269eecf78245a55d82b79894", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/Worker/WorkerManager.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}