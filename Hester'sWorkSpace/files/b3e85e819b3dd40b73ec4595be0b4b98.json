{"author": "scikit-learn", "code": "\n\n\"\"\"\nBased on: http://wxpsvg.googlecode.com/svn/trunk/svg/pathdata.py\nAccording to that project, this file is licensed under the LGPL\n\"\"\"\nfrom __future__ import print_function\n\ntry:\n    from pyparsing import (ParserElement, Literal, Word, CaselessLiteral, \n        Optional, Combine, Forward, ZeroOrMore, nums, oneOf, Group, ParseException, OneOrMore)\nexcept ImportError:\n    import sys\n    sys.exit(\"pyparsing is required\")\n    \n    \n()\n\ndef Command(char):\n    \"\"\" Case insensitive but case preserving\"\"\"\n    return CaselessPreservingLiteral(char)\n    \ndef Arguments(token):\n    return Group(token)\n    \n    \nclass CaselessPreservingLiteral(CaselessLiteral):\n    \"\"\" Like CaselessLiteral, but returns the match as found\n        instead of as defined.\n    \"\"\"\n    def __init__( self, matchString ):\n        super(CaselessPreservingLiteral,self).__init__( matchString.upper() )\n        self.name = \"'%s'\" % matchString\n        self.errmsg = \"Expected \" + self.name\n        self.myException.msg = self.errmsg\n\n    def parseImpl( self, instring, loc, doActions=True ):\n        test = instring[ loc:loc+self.matchLen ]\n        if test.upper() == self.match:\n            return loc+self.matchLen, test\n        #~ raise ParseException( instring, loc, self.errmsg )\n        exc = self.myException\n        exc.loc = loc\n        exc.pstr = instring\n        raise exc   \n    \ndef Sequence(token):\n    \"\"\" A sequence of the token\"\"\"\n    return OneOrMore(token+maybeComma)\n\ndigit_sequence = Word(nums)\n\nsign = oneOf(\"+ -\")\n\ndef convertToFloat(s, loc, toks):\n    try:\n        return float(toks[0])\n    except:\n        raise ParseException(loc, \"invalid float format %s\"%toks[0])\n\nexponent = CaselessLiteral(\"e\")+Optional(sign)+Word(nums)\n\n\n\n#float() function to clear out invalid values - loosely matching like this\n\nfloatingPointConstant = Combine(\n    Optional(sign) + \n    Optional(Word(nums)) + \n    Optional(Literal(\".\") + Optional(Word(nums)))+\n    Optional(exponent)\n)\n\nfloatingPointConstant.setParseAction(convertToFloat)\n\nnumber = floatingPointConstant\n\n\nnonnegativeNumber = Combine(\n    Optional(Word(nums)) + \n    Optional(Literal(\".\") + Optional(Word(nums)))+\n    Optional(exponent)\n)\nnonnegativeNumber.setParseAction(convertToFloat)\n\ncoordinate = number\n\n\nmaybeComma = Optional(Literal(',')).suppress()\n\ncoordinateSequence = Sequence(coordinate)\n\ncoordinatePair = (coordinate + maybeComma + coordinate).setParseAction(lambda t: tuple(t))\ncoordinatePairSequence = Sequence(coordinatePair)\n\ncoordinatePairPair = coordinatePair + maybeComma + coordinatePair\ncoordinatePairPairSequence = Sequence(Group(coordinatePairPair))\n\ncoordinatePairTriple = coordinatePair + maybeComma + coordinatePair + maybeComma + coordinatePair\ncoordinatePairTripleSequence = Sequence(Group(coordinatePairTriple))\n\n\nlineTo = Group(Command(\"L\") + Arguments(coordinatePairSequence))\ncurve = Group(Command(\"C\") + Arguments(coordinatePairSequence))\n\nmoveTo = Group(Command(\"M\") + Arguments(coordinatePairSequence))\n\nclosePath = Group(Command(\"Z\")).setParseAction(lambda t: ('Z', (None,)))\n\nflag = oneOf(\"1 0\").setParseAction(lambda t: bool(int((t[0]))))\n\narcRadius = (\n    nonnegativeNumber + maybeComma + \n    nonnegativeNumber \n).setParseAction(lambda t: tuple(t))\n\narcFlags = (flag + maybeComma + flag).setParseAction(lambda t: tuple(t))\n\nellipticalArcArgument = Group(\n    arcRadius + maybeComma + , ry\n    number + maybeComma +\n    arcFlags + \n    coordinatePair #(x,y)\n)\n\nellipticalArc = Group(Command(\"A\") + Arguments(Sequence(ellipticalArcArgument)))\n\nsmoothQuadraticBezierCurveto = Group(Command(\"T\") + Arguments(coordinatePairSequence))\n\nquadraticBezierCurveto = Group(Command(\"Q\") + Arguments(coordinatePairPairSequence))\n\nsmoothCurve = Group(Command(\"S\") + Arguments(coordinatePairPairSequence))\n\n#curve = Group(Command(\"C\") + Arguments(coordinatePairTripleSequence))\n\nhorizontalLine = Group(Command(\"H\") + Arguments(coordinateSequence))\nverticalLine = Group(Command(\"V\") + Arguments(coordinateSequence))\n\ndrawToCommand = (\n    lineTo | moveTo | closePath | ellipticalArc | smoothQuadraticBezierCurveto |\n    quadraticBezierCurveto | smoothCurve | curve | horizontalLine | verticalLine\n    )\n\n\nmoveToDrawToCommands = moveTo + ZeroOrMore(drawToCommand)\n\npath = ZeroOrMore(moveToDrawToCommands)\npath.keepTabs = True\n\ndef get_points(d):\n    commands = path.parseString(d)\n    points = []\n    currentset = None\n    for command in commands:\n        if command[0] == 'M' or command[0] == 'm':\n            currentset = []\n            points.append(currentset)\n            currentset.append(command[1][-1])\n        elif command[0] == 'L' or command[0] == 'l':\n            currentset.extend(command[1])\n        elif command[0] == 'C' or command[0] == 'c':\n            currentset.extend(command[1])\n    return points\n\nif __name__ == \"__main__\":\n    s = (\"M 242.96145,653.59282 L 244.83646,650.1553 L 247.02397,649.8428 \"\n         \"L 247.33647,650.62405 L 245.30521,653.59282 L 242.96145,653.59282 z \"\n         \"M 252.80525,649.99905 L 258.74278,652.49906 L 260.77404,652.18656 \"\n         \"L 262.33654,648.43654 L 261.71154,645.15528 L 257.64902,644.68653 \"\n         \"L 253.74275,646.40528 L 252.80525,649.99905 z M 282.49289,659.6866 \"\n         \"L 286.08665,664.99912 L 288.43041,664.68662 L 289.52417,664.21787 \"\n         \"L 290.93042,665.46787 L 294.52419,665.31162 L 295.4617,663.90537 \"\n         \"L 292.64918,662.18661 L 290.77417,658.59284 L 288.74291,655.15533 \"\n         \"L 283.11789,657.96784 L 282.49289,659.6866 z M 302.02423,668.28039 \"\n         \"L 303.27423,666.40538 L 307.8055,667.34288 L 308.43051,666.87413 \"\n         \"L 314.36803,667.49913 L 314.05553,668.74914 L 311.55552,670.15539 \"\n         \"L 307.33675,669.84289 L 302.02423,668.28039 z M 307.1805,673.28041 \"\n         \"L 309.05551,677.03043 L 312.02427,675.93667 L 312.33677,674.37416 \"\n         \"L 310.77427,672.3429 L 307.1805,672.0304 L 307.1805,673.28041 z \"\n         \"M 313.89928,672.18665 L 316.08679,669.37414 L 320.61806,671.7179 \"\n         \"L 324.83683,672.81166 L 329.0556,675.46792 L 329.0556,677.34293 \"\n         \"L 325.61809,679.06169 L 320.93056,679.99919 L 318.5868,678.59293 \"\n         \"L 313.89928,672.18665 z M 329.99311,687.18672 L 331.55561,685.93672 \"\n         \"L 334.83688,687.49923 L 342.18066,690.93674 L 345.46193,692.968 \"\n         \"L 347.02443,695.31176 L 348.89944,699.53053 L 352.80571,702.03054 \"\n         \"L 352.49321,703.28055 L 348.74319,706.40556 L 344.68067,707.81182 \"\n         \"L 343.27442,707.18682 L 340.30565,708.90557 L 337.96189,712.03059 \"\n         \"L 335.77438,714.8431 L 334.05562,714.68685 L 330.61811,712.18684 \"\n         \"L 330.30561,707.81182 L 330.93061,705.46806 L 329.3681,699.99928 \"\n         \"L 327.33684,698.28052 L 327.18059,695.78051 L 329.3681,694.84301 \"\n         \"L 331.39936,691.87425 L 331.86811,690.93674 L 330.30561,689.21798 \"\n         \"L 329.99311,687.18672 z \")\n    print(path.parseString(s))\n", "comments": "    based  http   wxpsvg googlecode com svn trunk svg pathdata py according project  file licensed lgpl       future   import print function  try      pyparsing import (parserelement  literal  word  caselessliteral           optional  combine  forward  zeroormore  nums  oneof  group  parseexception  oneormore) except importerror      import sys     sys exit( pyparsing required )            parserelement enablepackrat()  def command(char)          case insensitive case preserving        return caselesspreservingliteral(char)      def arguments(token)      return group(token)           class caselesspreservingliteral(caselessliteral)          like caselessliteral  returns match found         instead defined              def   init  ( self  matchstring )          super(caselesspreservingliteral self)   init  ( matchstring upper() )         self name          matchstring         self errmsg    expected     self name         self myexception msg   self errmsg      def parseimpl( self  instring  loc  doactions true )          test   instring  loc loc self matchlen           test upper()    self match              return loc self matchlen  test            raise parseexception( instring  loc  self errmsg )         exc   self myexception         exc loc   loc         exc pstr   instring         raise exc         def sequence(token)          a sequence token        usr local bin python   parserelement enablepackrat()     raise parseexception( instring  loc  self errmsg )   note almost fields optional     match almost anything  we rely pythons built   float() function clear invalid values   loosely matching like   speeds parsing quite lot   fp constant allow   sign   comma whitespace separate values place svg   commands   rx   ry   rx  ry   rotation   large arc flag  sweep flag   (x y)   curve   group(command( c )   arguments(coordinatepairtriplesequence))     number debug   true ", "content": "#!/usr/local/bin/python\n\n\"\"\"\nBased on: http://wxpsvg.googlecode.com/svn/trunk/svg/pathdata.py\nAccording to that project, this file is licensed under the LGPL\n\"\"\"\nfrom __future__ import print_function\n\ntry:\n    from pyparsing import (ParserElement, Literal, Word, CaselessLiteral, \n        Optional, Combine, Forward, ZeroOrMore, nums, oneOf, Group, ParseException, OneOrMore)\nexcept ImportError:\n    import sys\n    sys.exit(\"pyparsing is required\")\n    \n    \n#ParserElement.enablePackrat()\n\ndef Command(char):\n    \"\"\" Case insensitive but case preserving\"\"\"\n    return CaselessPreservingLiteral(char)\n    \ndef Arguments(token):\n    return Group(token)\n    \n    \nclass CaselessPreservingLiteral(CaselessLiteral):\n    \"\"\" Like CaselessLiteral, but returns the match as found\n        instead of as defined.\n    \"\"\"\n    def __init__( self, matchString ):\n        super(CaselessPreservingLiteral,self).__init__( matchString.upper() )\n        self.name = \"'%s'\" % matchString\n        self.errmsg = \"Expected \" + self.name\n        self.myException.msg = self.errmsg\n\n    def parseImpl( self, instring, loc, doActions=True ):\n        test = instring[ loc:loc+self.matchLen ]\n        if test.upper() == self.match:\n            return loc+self.matchLen, test\n        #~ raise ParseException( instring, loc, self.errmsg )\n        exc = self.myException\n        exc.loc = loc\n        exc.pstr = instring\n        raise exc   \n    \ndef Sequence(token):\n    \"\"\" A sequence of the token\"\"\"\n    return OneOrMore(token+maybeComma)\n\ndigit_sequence = Word(nums)\n\nsign = oneOf(\"+ -\")\n\ndef convertToFloat(s, loc, toks):\n    try:\n        return float(toks[0])\n    except:\n        raise ParseException(loc, \"invalid float format %s\"%toks[0])\n\nexponent = CaselessLiteral(\"e\")+Optional(sign)+Word(nums)\n\n#note that almost all these fields are optional, \n#and this can match almost anything. We rely on Pythons built-in\n#float() function to clear out invalid values - loosely matching like this\n#speeds up parsing quite a lot\nfloatingPointConstant = Combine(\n    Optional(sign) + \n    Optional(Word(nums)) + \n    Optional(Literal(\".\") + Optional(Word(nums)))+\n    Optional(exponent)\n)\n\nfloatingPointConstant.setParseAction(convertToFloat)\n\nnumber = floatingPointConstant\n\n#same as FP constant but don't allow a - sign\nnonnegativeNumber = Combine(\n    Optional(Word(nums)) + \n    Optional(Literal(\".\") + Optional(Word(nums)))+\n    Optional(exponent)\n)\nnonnegativeNumber.setParseAction(convertToFloat)\n\ncoordinate = number\n\n#comma or whitespace can separate values all over the place in SVG\nmaybeComma = Optional(Literal(',')).suppress()\n\ncoordinateSequence = Sequence(coordinate)\n\ncoordinatePair = (coordinate + maybeComma + coordinate).setParseAction(lambda t: tuple(t))\ncoordinatePairSequence = Sequence(coordinatePair)\n\ncoordinatePairPair = coordinatePair + maybeComma + coordinatePair\ncoordinatePairPairSequence = Sequence(Group(coordinatePairPair))\n\ncoordinatePairTriple = coordinatePair + maybeComma + coordinatePair + maybeComma + coordinatePair\ncoordinatePairTripleSequence = Sequence(Group(coordinatePairTriple))\n\n#commands\nlineTo = Group(Command(\"L\") + Arguments(coordinatePairSequence))\ncurve = Group(Command(\"C\") + Arguments(coordinatePairSequence))\n\nmoveTo = Group(Command(\"M\") + Arguments(coordinatePairSequence))\n\nclosePath = Group(Command(\"Z\")).setParseAction(lambda t: ('Z', (None,)))\n\nflag = oneOf(\"1 0\").setParseAction(lambda t: bool(int((t[0]))))\n\narcRadius = (\n    nonnegativeNumber + maybeComma + #rx\n    nonnegativeNumber #ry\n).setParseAction(lambda t: tuple(t))\n\narcFlags = (flag + maybeComma + flag).setParseAction(lambda t: tuple(t))\n\nellipticalArcArgument = Group(\n    arcRadius + maybeComma + #rx, ry\n    number + maybeComma +#rotation\n    arcFlags + #large-arc-flag, sweep-flag\n    coordinatePair #(x,y)\n)\n\nellipticalArc = Group(Command(\"A\") + Arguments(Sequence(ellipticalArcArgument)))\n\nsmoothQuadraticBezierCurveto = Group(Command(\"T\") + Arguments(coordinatePairSequence))\n\nquadraticBezierCurveto = Group(Command(\"Q\") + Arguments(coordinatePairPairSequence))\n\nsmoothCurve = Group(Command(\"S\") + Arguments(coordinatePairPairSequence))\n\n#curve = Group(Command(\"C\") + Arguments(coordinatePairTripleSequence))\n\nhorizontalLine = Group(Command(\"H\") + Arguments(coordinateSequence))\nverticalLine = Group(Command(\"V\") + Arguments(coordinateSequence))\n\ndrawToCommand = (\n    lineTo | moveTo | closePath | ellipticalArc | smoothQuadraticBezierCurveto |\n    quadraticBezierCurveto | smoothCurve | curve | horizontalLine | verticalLine\n    )\n\n#~ number.debug = True\nmoveToDrawToCommands = moveTo + ZeroOrMore(drawToCommand)\n\npath = ZeroOrMore(moveToDrawToCommands)\npath.keepTabs = True\n\ndef get_points(d):\n    commands = path.parseString(d)\n    points = []\n    currentset = None\n    for command in commands:\n        if command[0] == 'M' or command[0] == 'm':\n            currentset = []\n            points.append(currentset)\n            currentset.append(command[1][-1])\n        elif command[0] == 'L' or command[0] == 'l':\n            currentset.extend(command[1])\n        elif command[0] == 'C' or command[0] == 'c':\n            currentset.extend(command[1])\n    return points\n\nif __name__ == \"__main__\":\n    s = (\"M 242.96145,653.59282 L 244.83646,650.1553 L 247.02397,649.8428 \"\n         \"L 247.33647,650.62405 L 245.30521,653.59282 L 242.96145,653.59282 z \"\n         \"M 252.80525,649.99905 L 258.74278,652.49906 L 260.77404,652.18656 \"\n         \"L 262.33654,648.43654 L 261.71154,645.15528 L 257.64902,644.68653 \"\n         \"L 253.74275,646.40528 L 252.80525,649.99905 z M 282.49289,659.6866 \"\n         \"L 286.08665,664.99912 L 288.43041,664.68662 L 289.52417,664.21787 \"\n         \"L 290.93042,665.46787 L 294.52419,665.31162 L 295.4617,663.90537 \"\n         \"L 292.64918,662.18661 L 290.77417,658.59284 L 288.74291,655.15533 \"\n         \"L 283.11789,657.96784 L 282.49289,659.6866 z M 302.02423,668.28039 \"\n         \"L 303.27423,666.40538 L 307.8055,667.34288 L 308.43051,666.87413 \"\n         \"L 314.36803,667.49913 L 314.05553,668.74914 L 311.55552,670.15539 \"\n         \"L 307.33675,669.84289 L 302.02423,668.28039 z M 307.1805,673.28041 \"\n         \"L 309.05551,677.03043 L 312.02427,675.93667 L 312.33677,674.37416 \"\n         \"L 310.77427,672.3429 L 307.1805,672.0304 L 307.1805,673.28041 z \"\n         \"M 313.89928,672.18665 L 316.08679,669.37414 L 320.61806,671.7179 \"\n         \"L 324.83683,672.81166 L 329.0556,675.46792 L 329.0556,677.34293 \"\n         \"L 325.61809,679.06169 L 320.93056,679.99919 L 318.5868,678.59293 \"\n         \"L 313.89928,672.18665 z M 329.99311,687.18672 L 331.55561,685.93672 \"\n         \"L 334.83688,687.49923 L 342.18066,690.93674 L 345.46193,692.968 \"\n         \"L 347.02443,695.31176 L 348.89944,699.53053 L 352.80571,702.03054 \"\n         \"L 352.49321,703.28055 L 348.74319,706.40556 L 344.68067,707.81182 \"\n         \"L 343.27442,707.18682 L 340.30565,708.90557 L 337.96189,712.03059 \"\n         \"L 335.77438,714.8431 L 334.05562,714.68685 L 330.61811,712.18684 \"\n         \"L 330.30561,707.81182 L 330.93061,705.46806 L 329.3681,699.99928 \"\n         \"L 327.33684,698.28052 L 327.18059,695.78051 L 329.3681,694.84301 \"\n         \"L 331.39936,691.87425 L 331.86811,690.93674 L 330.30561,689.21798 \"\n         \"L 329.99311,687.18672 z \")\n    print(path.parseString(s))\n", "description": "scikit-learn: machine learning in Python", "file_name": "parse_path.py", "id": "b3e85e819b3dd40b73ec4595be0b4b98", "language": "Python", "project_name": "scikit-learn", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/scikit-learn-scikit-learn/scikit-learn-scikit-learn-94ed5a8/doc/tutorial/machine_learning_map/parse_path.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:58:59Z", "url": "https://github.com/scikit-learn/scikit-learn", "wiki": true}