{"author": "getredash", "code": "\nimport datetime\nimport json\nfrom unittest import TestCase\n\nimport mock\nfrom dateutil.parser import parse as date_parse\nfrom tests import BaseTestCase\n\nfrom redash import models\nfrom redash.models import db\nfrom redash.utils import gen_query_hash, utcnow\n\n\nclass DashboardTest(BaseTestCase):\n    def test_appends_suffix_to_slug_when_duplicate(self):\n        d1 = self.factory.create_dashboard()\n        db.session.flush()\n        self.assertEquals(d1.slug, 'test')\n\n        d2 = self.factory.create_dashboard(user=d1.user)\n        db.session.flush()\n        self.assertNotEquals(d1.slug, d2.slug)\n\n        d3 = self.factory.create_dashboard(user=d1.user)\n        db.session.flush()\n        self.assertNotEquals(d1.slug, d3.slug)\n        self.assertNotEquals(d2.slug, d3.slug)\n\n\nclass ShouldScheduleNextTest(TestCase):\n    def test_interval_schedule_that_needs_reschedule(self):\n        now = utcnow()\n        two_hours_ago = now - datetime.timedelta(hours=2)\n        self.assertTrue(models.should_schedule_next(two_hours_ago, now, \"3600\",\n                                                    0))\n\n    def test_interval_schedule_that_doesnt_need_reschedule(self):\n        now = utcnow()\n        half_an_hour_ago = now - datetime.timedelta(minutes=30)\n        self.assertFalse(models.should_schedule_next(half_an_hour_ago, now,\n                                                     \"3600\", 0))\n\n    def test_exact_time_that_needs_reschedule(self):\n        now = utcnow()\n        yesterday = now - datetime.timedelta(days=1)\n        scheduled_datetime = now - datetime.timedelta(hours=3)\n        scheduled_time = \"{:02d}:00\".format(scheduled_datetime.hour)\n        self.assertTrue(models.should_schedule_next(yesterday, now,\n                                                    scheduled_time, 0))\n\n    def test_exact_time_that_doesnt_need_reschedule(self):\n        now = date_parse(\"2015-10-16 20:10\")\n        yesterday = date_parse(\"2015-10-15 23:07\")\n        schedule = \"23:00\"\n        self.assertFalse(models.should_schedule_next(yesterday, now, schedule,\n                                                     0))\n\n    def test_exact_time_with_day_change(self):\n        now = utcnow().replace(hour=0, minute=1)\n        previous = (now - datetime.timedelta(days=2)).replace(hour=23,\n                                                              minute=59)\n        schedule = \"23:59\".format(now.hour + 3)\n        self.assertTrue(models.should_schedule_next(previous, now, schedule,\n                                                    0))\n\n    def test_backoff(self):\n        now = utcnow()\n        two_hours_ago = now - datetime.timedelta(hours=2)\n        self.assertTrue(models.should_schedule_next(two_hours_ago, now, \"3600\",\n                                                    5))\n        self.assertFalse(models.should_schedule_next(two_hours_ago, now,\n                                                     \"3600\", 10))\n\n\nclass QueryOutdatedQueriesTest(BaseTestCase):\n    \n    def test_outdated_queries_skips_unscheduled_queries(self):\n        query = self.factory.create_query(schedule=None)\n        queries = models.Query.outdated_queries()\n\n        self.assertNotIn(query, queries)\n\n    def test_outdated_queries_works_with_ttl_based_schedule(self):\n        two_hours_ago = utcnow() - datetime.timedelta(hours=2)\n        query = self.factory.create_query(schedule=\"3600\")\n        query_result = self.factory.create_query_result(query=query.query_text, retrieved_at=two_hours_ago)\n        query.latest_query_data = query_result\n\n        queries = models.Query.outdated_queries()\n        self.assertIn(query, queries)\n\n    def test_outdated_queries_works_scheduled_queries_tracker(self):\n        two_hours_ago = datetime.datetime.now() - datetime.timedelta(hours=2)\n        query = self.factory.create_query(schedule=\"3600\")\n        query_result = self.factory.create_query_result(query=query, retrieved_at=two_hours_ago)\n        query.latest_query_data = query_result\n\n        models.scheduled_queries_executions.update(query.id)\n\n        queries = models.Query.outdated_queries()\n        self.assertNotIn(query, queries)\n\n    def test_skips_fresh_queries(self):\n        half_an_hour_ago = utcnow() - datetime.timedelta(minutes=30)\n        query = self.factory.create_query(schedule=\"3600\")\n        query_result = self.factory.create_query_result(query=query.query_text, retrieved_at=half_an_hour_ago)\n        query.latest_query_data = query_result\n\n        queries = models.Query.outdated_queries()\n        self.assertNotIn(query, queries)\n\n    def test_outdated_queries_works_with_specific_time_schedule(self):\n        half_an_hour_ago = utcnow() - datetime.timedelta(minutes=30)\n        query = self.factory.create_query(schedule=half_an_hour_ago.strftime('%H:%M'))\n        query_result = self.factory.create_query_result(query=query.query_text, retrieved_at=half_an_hour_ago - datetime.timedelta(days=1))\n        query.latest_query_data = query_result\n\n        queries = models.Query.outdated_queries()\n        self.assertIn(query, queries)\n\n    def test_enqueues_query_only_once(self):\n        \"\"\"\n        Only one query per data source with the same text will be reported by\n        Query.outdated_queries().\n        \"\"\"\n        query = self.factory.create_query(schedule=\"60\")\n        query2 = self.factory.create_query(\n            schedule=\"60\", query_text=query.query_text,\n            query_hash=query.query_hash)\n        retrieved_at = utcnow() - datetime.timedelta(minutes=10)\n        query_result = self.factory.create_query_result(\n            retrieved_at=retrieved_at, query_text=query.query_text,\n            query_hash=query.query_hash)\n        query.latest_query_data = query_result\n        query2.latest_query_data = query_result\n\n        self.assertEqual(list(models.Query.outdated_queries()), [query2])\n\n    def test_enqueues_query_with_correct_data_source(self):\n        \"\"\"\n        Queries from different data sources will be reported by\n        Query.outdated_queries() even if they have the same query text.\n        \"\"\"\n        query = self.factory.create_query(\n            schedule=\"60\", data_source=self.factory.create_data_source())\n        query2 = self.factory.create_query(\n            schedule=\"60\", query_text=query.query_text,\n            query_hash=query.query_hash)\n        retrieved_at = utcnow() - datetime.timedelta(minutes=10)\n        query_result = self.factory.create_query_result(\n            retrieved_at=retrieved_at, query_text=query.query_text,\n            query_hash=query.query_hash)\n        query.latest_query_data = query_result\n        query2.latest_query_data = query_result\n\n        self.assertEqual(list(models.Query.outdated_queries()),\n                         [query2, query])\n\n    def test_enqueues_only_for_relevant_data_source(self):\n        \"\"\"\n        If multiple queries with the same text exist, only ones that are\n        scheduled to be refreshed are reported by Query.outdated_queries().\n        \"\"\"\n        query = self.factory.create_query(schedule=\"60\")\n        query2 = self.factory.create_query(\n            schedule=\"3600\", query_text=query.query_text,\n            query_hash=query.query_hash)\n        retrieved_at = utcnow() - datetime.timedelta(minutes=10)\n        query_result = self.factory.create_query_result(\n            retrieved_at=retrieved_at, query_text=query.query_text,\n            query_hash=query.query_hash)\n        query.latest_query_data = query_result\n        query2.latest_query_data = query_result\n\n        self.assertEqual(list(models.Query.outdated_queries()), [query])\n\n    def test_failure_extends_schedule(self):\n        \"\"\"\n        Execution failures recorded for a query result in exponential backoff\n        for scheduling future execution.\n        \"\"\"\n        query = self.factory.create_query(schedule=\"60\", schedule_failures=4)\n        retrieved_at = utcnow() - datetime.timedelta(minutes=16)\n        query_result = self.factory.create_query_result(\n            retrieved_at=retrieved_at, query_text=query.query_text,\n            query_hash=query.query_hash)\n        query.latest_query_data = query_result\n\n        self.assertEqual(list(models.Query.outdated_queries()), [])\n\n        query_result.retrieved_at = utcnow() - datetime.timedelta(minutes=17)\n        self.assertEqual(list(models.Query.outdated_queries()), [query])\n\n\nclass QueryArchiveTest(BaseTestCase):\n    def setUp(self):\n        super(QueryArchiveTest, self).setUp()\n\n    def test_archive_query_sets_flag(self):\n        query = self.factory.create_query()\n        db.session.flush()\n        query.archive()\n\n        self.assertEquals(query.is_archived, True)\n\n    def test_archived_query_doesnt_return_in_all(self):\n        query = self.factory.create_query(schedule=\"1\")\n        yesterday = utcnow() - datetime.timedelta(days=1)\n        query_result, _ = models.QueryResult.store_result(\n            query.org_id, query.data_source, query.query_hash, query.query_text,\n            \"1\", 123, yesterday)\n\n        query.latest_query_data = query_result\n        groups = list(models.Group.query.filter(models.Group.id.in_(query.groups)))\n        self.assertIn(query, list(models.Query.all_queries([g.id for g in groups])))\n        self.assertIn(query, models.Query.outdated_queries())\n        db.session.flush()\n        query.archive()\n\n        self.assertNotIn(query, list(models.Query.all_queries([g.id for g in groups])))\n        self.assertNotIn(query, models.Query.outdated_queries())\n\n    def test_removes_associated_widgets_from_dashboards(self):\n        widget = self.factory.create_widget()\n        query = widget.visualization.query_rel\n        db.session.commit()\n        query.archive()\n        db.session.flush()\n        self.assertEqual(db.session.query(models.Widget).get(widget.id), None)\n\n    def test_removes_scheduling(self):\n        query = self.factory.create_query(schedule=\"1\")\n\n        query.archive()\n\n        self.assertEqual(None, query.schedule)\n\n    def test_deletes_alerts(self):\n        subscription = self.factory.create_alert_subscription()\n        query = subscription.alert.query_rel\n        db.session.commit()\n        query.archive()\n        db.session.flush()\n        self.assertEqual(db.session.query(models.Alert).get(subscription.alert.id), None)\n        self.assertEqual(db.session.query(models.AlertSubscription).get(subscription.id), None)\n\n\nclass QueryResultTest(BaseTestCase):\n    def setUp(self):\n        super(QueryResultTest, self).setUp()\n\n    def test_get_latest_returns_none_if_not_found(self):\n        found_query_result = models.QueryResult.get_latest(self.factory.data_source, \"SELECT 1\", 60)\n        self.assertIsNone(found_query_result)\n\n    def test_get_latest_returns_when_found(self):\n        qr = self.factory.create_query_result()\n        found_query_result = models.QueryResult.get_latest(qr.data_source, qr.query_text, 60)\n\n        self.assertEqual(qr, found_query_result)\n\n    def test_get_latest_doesnt_return_query_from_different_data_source(self):\n        qr = self.factory.create_query_result()\n        data_source = self.factory.create_data_source()\n        found_query_result = models.QueryResult.get_latest(data_source, qr.query_text, 60)\n\n        self.assertIsNone(found_query_result)\n\n    def test_get_latest_doesnt_return_if_ttl_expired(self):\n        yesterday = utcnow() - datetime.timedelta(days=1)\n        qr = self.factory.create_query_result(retrieved_at=yesterday)\n\n        found_query_result = models.QueryResult.get_latest(qr.data_source, qr.query_text, max_age=60)\n\n        self.assertIsNone(found_query_result)\n\n    def test_get_latest_returns_if_ttl_not_expired(self):\n        yesterday = utcnow() - datetime.timedelta(seconds=30)\n        qr = self.factory.create_query_result(retrieved_at=yesterday)\n\n        found_query_result = models.QueryResult.get_latest(qr.data_source, qr.query_text, max_age=120)\n\n        self.assertEqual(found_query_result, qr)\n\n    def test_get_latest_returns_the_most_recent_result(self):\n        yesterday = utcnow() - datetime.timedelta(seconds=30)\n        old_qr = self.factory.create_query_result(retrieved_at=yesterday)\n        qr = self.factory.create_query_result()\n\n        found_query_result = models.QueryResult.get_latest(qr.data_source, qr.query_text, 60)\n\n        self.assertEqual(found_query_result.id, qr.id)\n\n    def test_get_latest_returns_the_last_cached_result_for_negative_ttl(self):\n        yesterday = utcnow() + datetime.timedelta(days=-100)\n        very_old = self.factory.create_query_result(retrieved_at=yesterday)\n\n        yesterday = utcnow() + datetime.timedelta(days=-1)\n        qr = self.factory.create_query_result(retrieved_at=yesterday)\n        found_query_result = models.QueryResult.get_latest(qr.data_source, qr.query_text, -1)\n\n        self.assertEqual(found_query_result.id, qr.id)\n\n\nclass TestUnusedQueryResults(BaseTestCase):\n    def test_returns_only_unused_query_results(self):\n        two_weeks_ago = utcnow() - datetime.timedelta(days=14)\n        qr = self.factory.create_query_result()\n        query = self.factory.create_query(latest_query_data=qr)\n        db.session.flush()\n        unused_qr = self.factory.create_query_result(retrieved_at=two_weeks_ago)\n        self.assertIn((unused_qr.id,), models.QueryResult.unused())\n        self.assertNotIn((qr.id,), list(models.QueryResult.unused()))\n\n    def test_returns_only_over_a_week_old_results(self):\n        two_weeks_ago = utcnow() - datetime.timedelta(days=14)\n        unused_qr = self.factory.create_query_result(retrieved_at=two_weeks_ago)\n        db.session.flush()\n        new_unused_qr = self.factory.create_query_result()\n\n        self.assertIn((unused_qr.id,), models.QueryResult.unused())\n        self.assertNotIn((new_unused_qr.id,), models.QueryResult.unused())\n\n\nclass TestQueryAll(BaseTestCase):\n    def test_returns_only_queries_in_given_groups(self):\n        ds1 = self.factory.create_data_source()\n        ds2 = self.factory.create_data_source()\n\n        group1 = models.Group(name=\"g1\", org=ds1.org, permissions=['create', 'view'])\n        group2 = models.Group(name=\"g2\", org=ds1.org, permissions=['create', 'view'])\n\n        q1 = self.factory.create_query(data_source=ds1)\n        q2 = self.factory.create_query(data_source=ds2)\n\n        db.session.add_all([\n            ds1, ds2,\n            group1, group2,\n            q1, q2,\n            models.DataSourceGroup(\n                group=group1, data_source=ds1),\n            models.DataSourceGroup(group=group2, data_source=ds2)\n            ])\n        db.session.flush()\n        self.assertIn(q1, list(models.Query.all_queries([group1.id])))\n        self.assertNotIn(q2, list(models.Query.all_queries([group1.id])))\n        self.assertIn(q1, list(models.Query.all_queries([group1.id, group2.id])))\n        self.assertIn(q2, list(models.Query.all_queries([group1.id, group2.id])))\n\n    def test_skips_drafts(self):\n        q = self.factory.create_query(is_draft=True)\n        self.assertNotIn(q, models.Query.all_queries([self.factory.default_group.id]))\n\n    def test_includes_drafts_of_given_user(self):\n        q = self.factory.create_query(is_draft=True)\n        self.assertIn(q, models.Query.all_queries([self.factory.default_group.id], user_id=q.user_id))\n\n\nclass TestGroup(BaseTestCase):\n    def test_returns_groups_with_specified_names(self):\n        org1 = self.factory.create_org()\n        org2 = self.factory.create_org()\n\n        matching_group1 = models.Group(id=999, name=\"g1\", org=org1)\n        matching_group2 = models.Group(id=888, name=\"g2\", org=org1)\n        non_matching_group = models.Group(id=777, name=\"g1\", org=org2)\n\n        groups = models.Group.find_by_name(org1, [\"g1\", \"g2\"])\n        self.assertIn(matching_group1, groups)\n        self.assertIn(matching_group2, groups)\n        self.assertNotIn(non_matching_group, groups)\n\n    def test_returns_no_groups(self):\n        org1 = self.factory.create_org()\n\n        models.Group(id=999, name=\"g1\", org=org1)\n        self.assertEqual([], models.Group.find_by_name(org1, [\"non-existing\"]))\n\n\nclass TestQueryResultStoreResult(BaseTestCase):\n    def setUp(self):\n        super(TestQueryResultStoreResult, self).setUp()\n        self.data_source = self.factory.data_source\n        self.query = \"SELECT 1\"\n        self.query_hash = gen_query_hash(self.query)\n        self.runtime = 123\n        self.utcnow = utcnow()\n        self.data = \"data\"\n\n    def test_stores_the_result(self):\n        query_result, _ = models.QueryResult.store_result(\n            self.data_source.org_id, self.data_source, self.query_hash,\n            self.query, self.data, self.runtime, self.utcnow)\n\n        self.assertEqual(query_result.data, self.data)\n        self.assertEqual(query_result.runtime, self.runtime)\n        self.assertEqual(query_result.retrieved_at, self.utcnow)\n        self.assertEqual(query_result.query_text, self.query)\n        self.assertEqual(query_result.query_hash, self.query_hash)\n        self.assertEqual(query_result.data_source, self.data_source)\n\n    def test_updates_existing_queries(self):\n        query1 = self.factory.create_query(query_text=self.query)\n        query2 = self.factory.create_query(query_text=self.query)\n        query3 = self.factory.create_query(query_text=self.query)\n\n        query_result, _ = models.QueryResult.store_result(\n            self.data_source.org_id, self.data_source, self.query_hash,\n            self.query, self.data, self.runtime, self.utcnow)\n\n        self.assertEqual(query1.latest_query_data, query_result)\n        self.assertEqual(query2.latest_query_data, query_result)\n        self.assertEqual(query3.latest_query_data, query_result)\n\n    def test_doesnt_update_queries_with_different_hash(self):\n        query1 = self.factory.create_query(query_text=self.query)\n        query2 = self.factory.create_query(query_text=self.query)\n        query3 = self.factory.create_query(query_text=self.query + \"123\")\n\n        query_result, _ = models.QueryResult.store_result(\n            self.data_source.org_id, self.data_source, self.query_hash,\n            self.query, self.data, self.runtime, self.utcnow)\n\n        self.assertEqual(query1.latest_query_data, query_result)\n        self.assertEqual(query2.latest_query_data, query_result)\n        self.assertNotEqual(query3.latest_query_data, query_result)\n\n    def test_doesnt_update_queries_with_different_data_source(self):\n        query1 = self.factory.create_query(query_text=self.query)\n        query2 = self.factory.create_query(query_text=self.query)\n        query3 = self.factory.create_query(query_text=self.query, data_source=self.factory.create_data_source())\n\n        query_result, _ = models.QueryResult.store_result(\n            self.data_source.org_id, self.data_source, self.query_hash,\n            self.query, self.data, self.runtime, self.utcnow)\n\n        self.assertEqual(query1.latest_query_data, query_result)\n        self.assertEqual(query2.latest_query_data, query_result)\n        self.assertNotEqual(query3.latest_query_data, query_result)\n\n\nclass TestEvents(BaseTestCase):\n    def raw_event(self):\n        timestamp = 1411778709.791\n        user = self.factory.user\n        created_at = datetime.datetime.utcfromtimestamp(timestamp)\n        db.session.flush()\n        raw_event = {\"action\": \"view\",\n                      \"timestamp\": timestamp,\n                      \"object_type\": \"dashboard\",\n                      \"user_id\": user.id,\n                      \"object_id\": 1,\n                      \"org_id\": 1}\n\n        return raw_event, user, created_at\n\n    def test_records_event(self):\n        raw_event, user, created_at = self.raw_event()\n\n        event = models.Event.record(raw_event)\n        db.session.flush()\n        self.assertEqual(event.user, user)\n        self.assertEqual(event.action, \"view\")\n        self.assertEqual(event.object_type, \"dashboard\")\n        self.assertEqual(event.object_id, 1)\n        self.assertEqual(event.created_at, created_at)\n\n    def test_records_additional_properties(self):\n        raw_event, _, _ = self.raw_event()\n        additional_properties = {'test': 1, 'test2': 2, 'whatever': \"abc\"}\n        raw_event.update(additional_properties)\n\n        event = models.Event.record(raw_event)\n\n        self.assertDictEqual(event.additional_properties, additional_properties)\n\n\ndef _set_up_dashboard_test(d):\n    d.g1 = d.factory.create_group(name='First', permissions=['create', 'view'])\n    d.g2 = d.factory.create_group(name='Second',  permissions=['create', 'view'])\n    d.ds1 = d.factory.create_data_source()\n    d.ds2 = d.factory.create_data_source()\n    db.session.flush()\n    d.u1 = d.factory.create_user(group_ids=[d.g1.id])\n    d.u2 = d.factory.create_user(group_ids=[d.g2.id])\n    db.session.add_all([\n        models.DataSourceGroup(group=d.g1, data_source=d.ds1),\n        models.DataSourceGroup(group=d.g2, data_source=d.ds2)\n    ])\n    d.q1 = d.factory.create_query(data_source=d.ds1)\n    d.q2 = d.factory.create_query(data_source=d.ds2)\n    d.v1 = d.factory.create_visualization(query_rel=d.q1)\n    d.v2 = d.factory.create_visualization(query_rel=d.q2)\n    d.w1 = d.factory.create_widget(visualization=d.v1)\n    d.w2 = d.factory.create_widget(visualization=d.v2)\n    d.w3 = d.factory.create_widget(visualization=d.v2, dashboard=d.w2.dashboard)\n    d.w4 = d.factory.create_widget(visualization=d.v2)\n    d.w5 = d.factory.create_widget(visualization=d.v1, dashboard=d.w4.dashboard)\n    d.w1.dashboard.is_draft = False\n    d.w2.dashboard.is_draft = False\n    d.w4.dashboard.is_draft = False\n\nclass TestDashboardAll(BaseTestCase):\n    def setUp(self):\n        super(TestDashboardAll, self).setUp()\n        _set_up_dashboard_test(self)\n\n    def test_requires_group_or_user_id(self):\n        d1 = self.factory.create_dashboard()\n        self.assertNotIn(d1, list(models.Dashboard.all(\n           d1.user.org, d1.user.group_ids, None)))\n        l2 = list(models.Dashboard.all(\n            d1.user.org, [0], d1.user.id))\n        self.assertIn(d1, l2)\n\n    def test_returns_dashboards_based_on_groups(self):\n        self.assertIn(self.w1.dashboard, list(models.Dashboard.all(\n            self.u1.org, self.u1.group_ids, None)))\n        self.assertIn(self.w2.dashboard, list(models.Dashboard.all(\n            self.u2.org, self.u2.group_ids, None)))\n        self.assertNotIn(self.w1.dashboard, list(models.Dashboard.all(\n            self.u2.org, self.u2.group_ids, None)))\n        self.assertNotIn(self.w2.dashboard, list(models.Dashboard.all(\n            self.u1.org, self.u1.group_ids, None)))\n\n    def test_returns_each_dashboard_once(self):\n        dashboards = list(models.Dashboard.all(self.u2.org, self.u2.group_ids, None))\n        self.assertEqual(len(dashboards), 2)\n\n    def test_returns_dashboard_you_have_partial_access_to(self):\n        self.assertIn(self.w5.dashboard, models.Dashboard.all(self.u1.org, self.u1.group_ids, None))\n\n    def test_returns_dashboards_created_by_user(self):\n        d1 = self.factory.create_dashboard(user=self.u1)\n        db.session.flush()\n        self.assertIn(d1, list(models.Dashboard.all(self.u1.org, self.u1.group_ids, self.u1.id)))\n        self.assertIn(d1, list(models.Dashboard.all(self.u1.org, [0], self.u1.id)))\n        self.assertNotIn(d1, list(models.Dashboard.all(self.u2.org, self.u2.group_ids, self.u2.id)))\n\n    def test_returns_dashboards_with_text_widgets(self):\n        w1 = self.factory.create_widget(visualization=None)\n\n        self.assertIn(w1.dashboard, models.Dashboard.all(self.u1.org, self.u1.group_ids, None))\n        self.assertIn(w1.dashboard, models.Dashboard.all(self.u2.org, self.u2.group_ids, None))\n\n    def test_returns_dashboards_from_current_org_only(self):\n        w1 = self.factory.create_widget(visualization=None)\n\n        user = self.factory.create_user(org=self.factory.create_org())\n\n        self.assertIn(w1.dashboard, models.Dashboard.all(self.u1.org, self.u1.group_ids, None))\n        self.assertNotIn(w1.dashboard, models.Dashboard.all(user.org, user.group_ids, None))\n\n\nclass TestDashboardRecent(BaseTestCase):\n    def setUp(self):\n        super(TestDashboardRecent, self).setUp()\n        _set_up_dashboard_test(self)\n\n    def test_returns_recent_dashboards_basic(self):\n        db.session.add(models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                                    object_type=\"dashboard\", object_id=self.w1.dashboard.id))\n        db.session.flush()\n        self.assertIn(self.w1.dashboard, models.Dashboard.recent(self.u1.org, self.u1.group_ids, None))\n        self.assertNotIn(self.w2.dashboard, models.Dashboard.recent(self.u1.org, self.u1.group_ids, None))\n        self.assertNotIn(self.w1.dashboard, models.Dashboard.recent(self.u1.org, self.u2.group_ids, None))\n\n    def test_recent_excludes_drafts(self):\n        models.db.session.add_all([\n        models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                     object_type=\"dashboard\", object_id=self.w1.dashboard.id),\n        models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                     object_type=\"dashboard\", object_id=self.w2.dashboard.id)])\n\n        self.w2.dashboard.is_draft = True\n        self.assertIn(self.w1.dashboard, models.Dashboard.recent(\n            self.u1.org, self.u1.group_ids, None))\n        self.assertNotIn(self.w2.dashboard, models.Dashboard.recent(\n            self.u1.org, self.u1.group_ids, None))\n\n    def test_returns_recent_dashboards_created_by_user(self):\n        d1 = self.factory.create_dashboard(user=self.u1, is_draft=False)\n        db.session.flush()\n        db.session.add(models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                                    object_type=\"dashboard\", object_id=d1.id))\n        self.assertIn(d1, models.Dashboard.recent(self.u1.org, [0], self.u1.id))\n        self.assertNotIn(self.w2.dashboard, models.Dashboard.recent(self.u1.org, [0], self.u1.id))\n        self.assertNotIn(d1, models.Dashboard.recent(self.u2.org, [0], self.u2.id))\n\n    def test_returns_recent_dashboards_with_no_visualizations(self):\n        w1 = self.factory.create_widget(visualization=None)\n        w1.dashboard.is_draft = False\n        db.session.flush()\n        db.session.add(models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                                    object_type=\"dashboard\", object_id=w1.dashboard.id))\n        db.session.flush()\n        self.assertIn(w1.dashboard, models.Dashboard.recent(self.u1.org, [0], self.u1.id))\n        self.assertNotIn(self.w2.dashboard, models.Dashboard.recent(self.u1.org, [0], self.u1.id))\n\n    def test_restricts_dashboards_for_user(self):\n        db.session.flush()\n        db.session.add_all([\n            models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                         object_type=\"dashboard\", object_id=self.w1.dashboard.id),\n            models.Event(org=self.factory.org, user=self.u2, action=\"view\",\n                         object_type=\"dashboard\", object_id=self.w2.dashboard.id),\n            models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                         object_type=\"dashboard\", object_id=self.w5.dashboard.id),\n            models.Event(org=self.factory.org, user=self.u2, action=\"view\",\n                         object_type=\"dashboard\", object_id=self.w5.dashboard.id)\n        ])\n        db.session.flush()\n        self.assertIn(self.w1.dashboard, models.Dashboard.recent(self.u1.org, self.u1.group_ids, self.u1.id, for_user=True))\n        self.assertIn(self.w2.dashboard, models.Dashboard.recent(self.u2.org, self.u2.group_ids, self.u2.id, for_user=True))\n        self.assertNotIn(self.w1.dashboard, models.Dashboard.recent(self.u2.org, self.u2.group_ids, self.u2.id, for_user=True))\n        self.assertNotIn(self.w2.dashboard, models.Dashboard.recent(self.u1.org, self.u1.group_ids, self.u1.id, for_user=True))\n        self.assertIn(self.w5.dashboard, models.Dashboard.recent(self.u1.org, self.u1.group_ids, self.u1.id, for_user=True))\n        self.assertIn(self.w5.dashboard, models.Dashboard.recent(self.u2.org, self.u2.group_ids, self.u2.id, for_user=True))\n\n    def test_returns_each_dashboard_once(self):\n        db.session.flush()\n        db.session.add_all([\n            models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                         object_type=\"dashboard\", object_id=self.w1.dashboard.id),\n            models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                         object_type=\"dashboard\", object_id=self.w1.dashboard.id)\n            ])\n        db.session.flush()\n        dashboards = list(models.Dashboard.recent(self.u1.org, self.u1.group_ids, None))\n        self.assertEqual(len(dashboards), 1)\n\n    def test_returns_dashboards_from_current_org_only(self):\n        w1 = self.factory.create_widget(visualization=None)\n        w1.dashboard.is_draft = False\n        db.session.flush()\n        db.session.add(models.Event(\n            org=self.factory.org, user=self.u1, action=\"view\",\n            object_type=\"dashboard\", object_id=w1.dashboard.id))\n        db.session.flush()\n        user = self.factory.create_user(org=self.factory.create_org())\n\n        self.assertIn(w1.dashboard, models.Dashboard.recent(self.u1.org, self.u1.group_ids, None))\n        self.assertNotIn(w1.dashboard, models.Dashboard.recent(user.org, user.group_ids, None))\n", "comments": "            only one query per data source text reported         query outdated queries()                      query   self factory create query(schedule  60 )         query2   self factory create query(             schedule  60   query text query query text              query hash query query hash)         retrieved   utcnow()   datetime timedelta(minutes 10)         query result   self factory create query result(             retrieved retrieved  query text query query text              query hash query query hash)         query latest query data   query result         query2 latest query data   query result          self assertequal(list(models query outdated queries())   query2 )      def test enqueues query correct data source(self)                      queries different data sources reported         query outdated queries() even query text                      query   self factory create query(             schedule  60   data source self factory create data source())         query2   self factory create query(             schedule  60   query text query query text              query hash query query hash)         retrieved   utcnow()   datetime timedelta(minutes 10)         query result   self factory create query result(             retrieved retrieved  query text query query text              query hash query query hash)         query latest query data   query result         query2 latest query data   query result          self assertequal(list(models query outdated queries())                            query2  query )      def test enqueues relevant data source(self)                      if multiple queries text exist  ones         scheduled refreshed reported query outdated queries()                      query   self factory create query(schedule  60 )         query2   self factory create query(             schedule  3600   query text query query text              query hash query query hash)         retrieved   utcnow()   datetime timedelta(minutes 10)         query result   self factory create query result(             retrieved retrieved  query text query query text              query hash query query hash)         query latest query data   query result         query2 latest query data   query result          self assertequal(list(models query outdated queries())   query )      def test failure extends schedule(self)                      execution failures recorded query result exponential backoff         scheduling future execution                encoding  utf8    todo  test refactored use mock version schedule next simplify  ", "content": "#encoding: utf8\nimport datetime\nimport json\nfrom unittest import TestCase\n\nimport mock\nfrom dateutil.parser import parse as date_parse\nfrom tests import BaseTestCase\n\nfrom redash import models\nfrom redash.models import db\nfrom redash.utils import gen_query_hash, utcnow\n\n\nclass DashboardTest(BaseTestCase):\n    def test_appends_suffix_to_slug_when_duplicate(self):\n        d1 = self.factory.create_dashboard()\n        db.session.flush()\n        self.assertEquals(d1.slug, 'test')\n\n        d2 = self.factory.create_dashboard(user=d1.user)\n        db.session.flush()\n        self.assertNotEquals(d1.slug, d2.slug)\n\n        d3 = self.factory.create_dashboard(user=d1.user)\n        db.session.flush()\n        self.assertNotEquals(d1.slug, d3.slug)\n        self.assertNotEquals(d2.slug, d3.slug)\n\n\nclass ShouldScheduleNextTest(TestCase):\n    def test_interval_schedule_that_needs_reschedule(self):\n        now = utcnow()\n        two_hours_ago = now - datetime.timedelta(hours=2)\n        self.assertTrue(models.should_schedule_next(two_hours_ago, now, \"3600\",\n                                                    0))\n\n    def test_interval_schedule_that_doesnt_need_reschedule(self):\n        now = utcnow()\n        half_an_hour_ago = now - datetime.timedelta(minutes=30)\n        self.assertFalse(models.should_schedule_next(half_an_hour_ago, now,\n                                                     \"3600\", 0))\n\n    def test_exact_time_that_needs_reschedule(self):\n        now = utcnow()\n        yesterday = now - datetime.timedelta(days=1)\n        scheduled_datetime = now - datetime.timedelta(hours=3)\n        scheduled_time = \"{:02d}:00\".format(scheduled_datetime.hour)\n        self.assertTrue(models.should_schedule_next(yesterday, now,\n                                                    scheduled_time, 0))\n\n    def test_exact_time_that_doesnt_need_reschedule(self):\n        now = date_parse(\"2015-10-16 20:10\")\n        yesterday = date_parse(\"2015-10-15 23:07\")\n        schedule = \"23:00\"\n        self.assertFalse(models.should_schedule_next(yesterday, now, schedule,\n                                                     0))\n\n    def test_exact_time_with_day_change(self):\n        now = utcnow().replace(hour=0, minute=1)\n        previous = (now - datetime.timedelta(days=2)).replace(hour=23,\n                                                              minute=59)\n        schedule = \"23:59\".format(now.hour + 3)\n        self.assertTrue(models.should_schedule_next(previous, now, schedule,\n                                                    0))\n\n    def test_backoff(self):\n        now = utcnow()\n        two_hours_ago = now - datetime.timedelta(hours=2)\n        self.assertTrue(models.should_schedule_next(two_hours_ago, now, \"3600\",\n                                                    5))\n        self.assertFalse(models.should_schedule_next(two_hours_ago, now,\n                                                     \"3600\", 10))\n\n\nclass QueryOutdatedQueriesTest(BaseTestCase):\n    # TODO: this test can be refactored to use mock version of should_schedule_next to simplify it.\n    def test_outdated_queries_skips_unscheduled_queries(self):\n        query = self.factory.create_query(schedule=None)\n        queries = models.Query.outdated_queries()\n\n        self.assertNotIn(query, queries)\n\n    def test_outdated_queries_works_with_ttl_based_schedule(self):\n        two_hours_ago = utcnow() - datetime.timedelta(hours=2)\n        query = self.factory.create_query(schedule=\"3600\")\n        query_result = self.factory.create_query_result(query=query.query_text, retrieved_at=two_hours_ago)\n        query.latest_query_data = query_result\n\n        queries = models.Query.outdated_queries()\n        self.assertIn(query, queries)\n\n    def test_outdated_queries_works_scheduled_queries_tracker(self):\n        two_hours_ago = datetime.datetime.now() - datetime.timedelta(hours=2)\n        query = self.factory.create_query(schedule=\"3600\")\n        query_result = self.factory.create_query_result(query=query, retrieved_at=two_hours_ago)\n        query.latest_query_data = query_result\n\n        models.scheduled_queries_executions.update(query.id)\n\n        queries = models.Query.outdated_queries()\n        self.assertNotIn(query, queries)\n\n    def test_skips_fresh_queries(self):\n        half_an_hour_ago = utcnow() - datetime.timedelta(minutes=30)\n        query = self.factory.create_query(schedule=\"3600\")\n        query_result = self.factory.create_query_result(query=query.query_text, retrieved_at=half_an_hour_ago)\n        query.latest_query_data = query_result\n\n        queries = models.Query.outdated_queries()\n        self.assertNotIn(query, queries)\n\n    def test_outdated_queries_works_with_specific_time_schedule(self):\n        half_an_hour_ago = utcnow() - datetime.timedelta(minutes=30)\n        query = self.factory.create_query(schedule=half_an_hour_ago.strftime('%H:%M'))\n        query_result = self.factory.create_query_result(query=query.query_text, retrieved_at=half_an_hour_ago - datetime.timedelta(days=1))\n        query.latest_query_data = query_result\n\n        queries = models.Query.outdated_queries()\n        self.assertIn(query, queries)\n\n    def test_enqueues_query_only_once(self):\n        \"\"\"\n        Only one query per data source with the same text will be reported by\n        Query.outdated_queries().\n        \"\"\"\n        query = self.factory.create_query(schedule=\"60\")\n        query2 = self.factory.create_query(\n            schedule=\"60\", query_text=query.query_text,\n            query_hash=query.query_hash)\n        retrieved_at = utcnow() - datetime.timedelta(minutes=10)\n        query_result = self.factory.create_query_result(\n            retrieved_at=retrieved_at, query_text=query.query_text,\n            query_hash=query.query_hash)\n        query.latest_query_data = query_result\n        query2.latest_query_data = query_result\n\n        self.assertEqual(list(models.Query.outdated_queries()), [query2])\n\n    def test_enqueues_query_with_correct_data_source(self):\n        \"\"\"\n        Queries from different data sources will be reported by\n        Query.outdated_queries() even if they have the same query text.\n        \"\"\"\n        query = self.factory.create_query(\n            schedule=\"60\", data_source=self.factory.create_data_source())\n        query2 = self.factory.create_query(\n            schedule=\"60\", query_text=query.query_text,\n            query_hash=query.query_hash)\n        retrieved_at = utcnow() - datetime.timedelta(minutes=10)\n        query_result = self.factory.create_query_result(\n            retrieved_at=retrieved_at, query_text=query.query_text,\n            query_hash=query.query_hash)\n        query.latest_query_data = query_result\n        query2.latest_query_data = query_result\n\n        self.assertEqual(list(models.Query.outdated_queries()),\n                         [query2, query])\n\n    def test_enqueues_only_for_relevant_data_source(self):\n        \"\"\"\n        If multiple queries with the same text exist, only ones that are\n        scheduled to be refreshed are reported by Query.outdated_queries().\n        \"\"\"\n        query = self.factory.create_query(schedule=\"60\")\n        query2 = self.factory.create_query(\n            schedule=\"3600\", query_text=query.query_text,\n            query_hash=query.query_hash)\n        retrieved_at = utcnow() - datetime.timedelta(minutes=10)\n        query_result = self.factory.create_query_result(\n            retrieved_at=retrieved_at, query_text=query.query_text,\n            query_hash=query.query_hash)\n        query.latest_query_data = query_result\n        query2.latest_query_data = query_result\n\n        self.assertEqual(list(models.Query.outdated_queries()), [query])\n\n    def test_failure_extends_schedule(self):\n        \"\"\"\n        Execution failures recorded for a query result in exponential backoff\n        for scheduling future execution.\n        \"\"\"\n        query = self.factory.create_query(schedule=\"60\", schedule_failures=4)\n        retrieved_at = utcnow() - datetime.timedelta(minutes=16)\n        query_result = self.factory.create_query_result(\n            retrieved_at=retrieved_at, query_text=query.query_text,\n            query_hash=query.query_hash)\n        query.latest_query_data = query_result\n\n        self.assertEqual(list(models.Query.outdated_queries()), [])\n\n        query_result.retrieved_at = utcnow() - datetime.timedelta(minutes=17)\n        self.assertEqual(list(models.Query.outdated_queries()), [query])\n\n\nclass QueryArchiveTest(BaseTestCase):\n    def setUp(self):\n        super(QueryArchiveTest, self).setUp()\n\n    def test_archive_query_sets_flag(self):\n        query = self.factory.create_query()\n        db.session.flush()\n        query.archive()\n\n        self.assertEquals(query.is_archived, True)\n\n    def test_archived_query_doesnt_return_in_all(self):\n        query = self.factory.create_query(schedule=\"1\")\n        yesterday = utcnow() - datetime.timedelta(days=1)\n        query_result, _ = models.QueryResult.store_result(\n            query.org_id, query.data_source, query.query_hash, query.query_text,\n            \"1\", 123, yesterday)\n\n        query.latest_query_data = query_result\n        groups = list(models.Group.query.filter(models.Group.id.in_(query.groups)))\n        self.assertIn(query, list(models.Query.all_queries([g.id for g in groups])))\n        self.assertIn(query, models.Query.outdated_queries())\n        db.session.flush()\n        query.archive()\n\n        self.assertNotIn(query, list(models.Query.all_queries([g.id for g in groups])))\n        self.assertNotIn(query, models.Query.outdated_queries())\n\n    def test_removes_associated_widgets_from_dashboards(self):\n        widget = self.factory.create_widget()\n        query = widget.visualization.query_rel\n        db.session.commit()\n        query.archive()\n        db.session.flush()\n        self.assertEqual(db.session.query(models.Widget).get(widget.id), None)\n\n    def test_removes_scheduling(self):\n        query = self.factory.create_query(schedule=\"1\")\n\n        query.archive()\n\n        self.assertEqual(None, query.schedule)\n\n    def test_deletes_alerts(self):\n        subscription = self.factory.create_alert_subscription()\n        query = subscription.alert.query_rel\n        db.session.commit()\n        query.archive()\n        db.session.flush()\n        self.assertEqual(db.session.query(models.Alert).get(subscription.alert.id), None)\n        self.assertEqual(db.session.query(models.AlertSubscription).get(subscription.id), None)\n\n\nclass QueryResultTest(BaseTestCase):\n    def setUp(self):\n        super(QueryResultTest, self).setUp()\n\n    def test_get_latest_returns_none_if_not_found(self):\n        found_query_result = models.QueryResult.get_latest(self.factory.data_source, \"SELECT 1\", 60)\n        self.assertIsNone(found_query_result)\n\n    def test_get_latest_returns_when_found(self):\n        qr = self.factory.create_query_result()\n        found_query_result = models.QueryResult.get_latest(qr.data_source, qr.query_text, 60)\n\n        self.assertEqual(qr, found_query_result)\n\n    def test_get_latest_doesnt_return_query_from_different_data_source(self):\n        qr = self.factory.create_query_result()\n        data_source = self.factory.create_data_source()\n        found_query_result = models.QueryResult.get_latest(data_source, qr.query_text, 60)\n\n        self.assertIsNone(found_query_result)\n\n    def test_get_latest_doesnt_return_if_ttl_expired(self):\n        yesterday = utcnow() - datetime.timedelta(days=1)\n        qr = self.factory.create_query_result(retrieved_at=yesterday)\n\n        found_query_result = models.QueryResult.get_latest(qr.data_source, qr.query_text, max_age=60)\n\n        self.assertIsNone(found_query_result)\n\n    def test_get_latest_returns_if_ttl_not_expired(self):\n        yesterday = utcnow() - datetime.timedelta(seconds=30)\n        qr = self.factory.create_query_result(retrieved_at=yesterday)\n\n        found_query_result = models.QueryResult.get_latest(qr.data_source, qr.query_text, max_age=120)\n\n        self.assertEqual(found_query_result, qr)\n\n    def test_get_latest_returns_the_most_recent_result(self):\n        yesterday = utcnow() - datetime.timedelta(seconds=30)\n        old_qr = self.factory.create_query_result(retrieved_at=yesterday)\n        qr = self.factory.create_query_result()\n\n        found_query_result = models.QueryResult.get_latest(qr.data_source, qr.query_text, 60)\n\n        self.assertEqual(found_query_result.id, qr.id)\n\n    def test_get_latest_returns_the_last_cached_result_for_negative_ttl(self):\n        yesterday = utcnow() + datetime.timedelta(days=-100)\n        very_old = self.factory.create_query_result(retrieved_at=yesterday)\n\n        yesterday = utcnow() + datetime.timedelta(days=-1)\n        qr = self.factory.create_query_result(retrieved_at=yesterday)\n        found_query_result = models.QueryResult.get_latest(qr.data_source, qr.query_text, -1)\n\n        self.assertEqual(found_query_result.id, qr.id)\n\n\nclass TestUnusedQueryResults(BaseTestCase):\n    def test_returns_only_unused_query_results(self):\n        two_weeks_ago = utcnow() - datetime.timedelta(days=14)\n        qr = self.factory.create_query_result()\n        query = self.factory.create_query(latest_query_data=qr)\n        db.session.flush()\n        unused_qr = self.factory.create_query_result(retrieved_at=two_weeks_ago)\n        self.assertIn((unused_qr.id,), models.QueryResult.unused())\n        self.assertNotIn((qr.id,), list(models.QueryResult.unused()))\n\n    def test_returns_only_over_a_week_old_results(self):\n        two_weeks_ago = utcnow() - datetime.timedelta(days=14)\n        unused_qr = self.factory.create_query_result(retrieved_at=two_weeks_ago)\n        db.session.flush()\n        new_unused_qr = self.factory.create_query_result()\n\n        self.assertIn((unused_qr.id,), models.QueryResult.unused())\n        self.assertNotIn((new_unused_qr.id,), models.QueryResult.unused())\n\n\nclass TestQueryAll(BaseTestCase):\n    def test_returns_only_queries_in_given_groups(self):\n        ds1 = self.factory.create_data_source()\n        ds2 = self.factory.create_data_source()\n\n        group1 = models.Group(name=\"g1\", org=ds1.org, permissions=['create', 'view'])\n        group2 = models.Group(name=\"g2\", org=ds1.org, permissions=['create', 'view'])\n\n        q1 = self.factory.create_query(data_source=ds1)\n        q2 = self.factory.create_query(data_source=ds2)\n\n        db.session.add_all([\n            ds1, ds2,\n            group1, group2,\n            q1, q2,\n            models.DataSourceGroup(\n                group=group1, data_source=ds1),\n            models.DataSourceGroup(group=group2, data_source=ds2)\n            ])\n        db.session.flush()\n        self.assertIn(q1, list(models.Query.all_queries([group1.id])))\n        self.assertNotIn(q2, list(models.Query.all_queries([group1.id])))\n        self.assertIn(q1, list(models.Query.all_queries([group1.id, group2.id])))\n        self.assertIn(q2, list(models.Query.all_queries([group1.id, group2.id])))\n\n    def test_skips_drafts(self):\n        q = self.factory.create_query(is_draft=True)\n        self.assertNotIn(q, models.Query.all_queries([self.factory.default_group.id]))\n\n    def test_includes_drafts_of_given_user(self):\n        q = self.factory.create_query(is_draft=True)\n        self.assertIn(q, models.Query.all_queries([self.factory.default_group.id], user_id=q.user_id))\n\n\nclass TestGroup(BaseTestCase):\n    def test_returns_groups_with_specified_names(self):\n        org1 = self.factory.create_org()\n        org2 = self.factory.create_org()\n\n        matching_group1 = models.Group(id=999, name=\"g1\", org=org1)\n        matching_group2 = models.Group(id=888, name=\"g2\", org=org1)\n        non_matching_group = models.Group(id=777, name=\"g1\", org=org2)\n\n        groups = models.Group.find_by_name(org1, [\"g1\", \"g2\"])\n        self.assertIn(matching_group1, groups)\n        self.assertIn(matching_group2, groups)\n        self.assertNotIn(non_matching_group, groups)\n\n    def test_returns_no_groups(self):\n        org1 = self.factory.create_org()\n\n        models.Group(id=999, name=\"g1\", org=org1)\n        self.assertEqual([], models.Group.find_by_name(org1, [\"non-existing\"]))\n\n\nclass TestQueryResultStoreResult(BaseTestCase):\n    def setUp(self):\n        super(TestQueryResultStoreResult, self).setUp()\n        self.data_source = self.factory.data_source\n        self.query = \"SELECT 1\"\n        self.query_hash = gen_query_hash(self.query)\n        self.runtime = 123\n        self.utcnow = utcnow()\n        self.data = \"data\"\n\n    def test_stores_the_result(self):\n        query_result, _ = models.QueryResult.store_result(\n            self.data_source.org_id, self.data_source, self.query_hash,\n            self.query, self.data, self.runtime, self.utcnow)\n\n        self.assertEqual(query_result.data, self.data)\n        self.assertEqual(query_result.runtime, self.runtime)\n        self.assertEqual(query_result.retrieved_at, self.utcnow)\n        self.assertEqual(query_result.query_text, self.query)\n        self.assertEqual(query_result.query_hash, self.query_hash)\n        self.assertEqual(query_result.data_source, self.data_source)\n\n    def test_updates_existing_queries(self):\n        query1 = self.factory.create_query(query_text=self.query)\n        query2 = self.factory.create_query(query_text=self.query)\n        query3 = self.factory.create_query(query_text=self.query)\n\n        query_result, _ = models.QueryResult.store_result(\n            self.data_source.org_id, self.data_source, self.query_hash,\n            self.query, self.data, self.runtime, self.utcnow)\n\n        self.assertEqual(query1.latest_query_data, query_result)\n        self.assertEqual(query2.latest_query_data, query_result)\n        self.assertEqual(query3.latest_query_data, query_result)\n\n    def test_doesnt_update_queries_with_different_hash(self):\n        query1 = self.factory.create_query(query_text=self.query)\n        query2 = self.factory.create_query(query_text=self.query)\n        query3 = self.factory.create_query(query_text=self.query + \"123\")\n\n        query_result, _ = models.QueryResult.store_result(\n            self.data_source.org_id, self.data_source, self.query_hash,\n            self.query, self.data, self.runtime, self.utcnow)\n\n        self.assertEqual(query1.latest_query_data, query_result)\n        self.assertEqual(query2.latest_query_data, query_result)\n        self.assertNotEqual(query3.latest_query_data, query_result)\n\n    def test_doesnt_update_queries_with_different_data_source(self):\n        query1 = self.factory.create_query(query_text=self.query)\n        query2 = self.factory.create_query(query_text=self.query)\n        query3 = self.factory.create_query(query_text=self.query, data_source=self.factory.create_data_source())\n\n        query_result, _ = models.QueryResult.store_result(\n            self.data_source.org_id, self.data_source, self.query_hash,\n            self.query, self.data, self.runtime, self.utcnow)\n\n        self.assertEqual(query1.latest_query_data, query_result)\n        self.assertEqual(query2.latest_query_data, query_result)\n        self.assertNotEqual(query3.latest_query_data, query_result)\n\n\nclass TestEvents(BaseTestCase):\n    def raw_event(self):\n        timestamp = 1411778709.791\n        user = self.factory.user\n        created_at = datetime.datetime.utcfromtimestamp(timestamp)\n        db.session.flush()\n        raw_event = {\"action\": \"view\",\n                      \"timestamp\": timestamp,\n                      \"object_type\": \"dashboard\",\n                      \"user_id\": user.id,\n                      \"object_id\": 1,\n                      \"org_id\": 1}\n\n        return raw_event, user, created_at\n\n    def test_records_event(self):\n        raw_event, user, created_at = self.raw_event()\n\n        event = models.Event.record(raw_event)\n        db.session.flush()\n        self.assertEqual(event.user, user)\n        self.assertEqual(event.action, \"view\")\n        self.assertEqual(event.object_type, \"dashboard\")\n        self.assertEqual(event.object_id, 1)\n        self.assertEqual(event.created_at, created_at)\n\n    def test_records_additional_properties(self):\n        raw_event, _, _ = self.raw_event()\n        additional_properties = {'test': 1, 'test2': 2, 'whatever': \"abc\"}\n        raw_event.update(additional_properties)\n\n        event = models.Event.record(raw_event)\n\n        self.assertDictEqual(event.additional_properties, additional_properties)\n\n\ndef _set_up_dashboard_test(d):\n    d.g1 = d.factory.create_group(name='First', permissions=['create', 'view'])\n    d.g2 = d.factory.create_group(name='Second',  permissions=['create', 'view'])\n    d.ds1 = d.factory.create_data_source()\n    d.ds2 = d.factory.create_data_source()\n    db.session.flush()\n    d.u1 = d.factory.create_user(group_ids=[d.g1.id])\n    d.u2 = d.factory.create_user(group_ids=[d.g2.id])\n    db.session.add_all([\n        models.DataSourceGroup(group=d.g1, data_source=d.ds1),\n        models.DataSourceGroup(group=d.g2, data_source=d.ds2)\n    ])\n    d.q1 = d.factory.create_query(data_source=d.ds1)\n    d.q2 = d.factory.create_query(data_source=d.ds2)\n    d.v1 = d.factory.create_visualization(query_rel=d.q1)\n    d.v2 = d.factory.create_visualization(query_rel=d.q2)\n    d.w1 = d.factory.create_widget(visualization=d.v1)\n    d.w2 = d.factory.create_widget(visualization=d.v2)\n    d.w3 = d.factory.create_widget(visualization=d.v2, dashboard=d.w2.dashboard)\n    d.w4 = d.factory.create_widget(visualization=d.v2)\n    d.w5 = d.factory.create_widget(visualization=d.v1, dashboard=d.w4.dashboard)\n    d.w1.dashboard.is_draft = False\n    d.w2.dashboard.is_draft = False\n    d.w4.dashboard.is_draft = False\n\nclass TestDashboardAll(BaseTestCase):\n    def setUp(self):\n        super(TestDashboardAll, self).setUp()\n        _set_up_dashboard_test(self)\n\n    def test_requires_group_or_user_id(self):\n        d1 = self.factory.create_dashboard()\n        self.assertNotIn(d1, list(models.Dashboard.all(\n           d1.user.org, d1.user.group_ids, None)))\n        l2 = list(models.Dashboard.all(\n            d1.user.org, [0], d1.user.id))\n        self.assertIn(d1, l2)\n\n    def test_returns_dashboards_based_on_groups(self):\n        self.assertIn(self.w1.dashboard, list(models.Dashboard.all(\n            self.u1.org, self.u1.group_ids, None)))\n        self.assertIn(self.w2.dashboard, list(models.Dashboard.all(\n            self.u2.org, self.u2.group_ids, None)))\n        self.assertNotIn(self.w1.dashboard, list(models.Dashboard.all(\n            self.u2.org, self.u2.group_ids, None)))\n        self.assertNotIn(self.w2.dashboard, list(models.Dashboard.all(\n            self.u1.org, self.u1.group_ids, None)))\n\n    def test_returns_each_dashboard_once(self):\n        dashboards = list(models.Dashboard.all(self.u2.org, self.u2.group_ids, None))\n        self.assertEqual(len(dashboards), 2)\n\n    def test_returns_dashboard_you_have_partial_access_to(self):\n        self.assertIn(self.w5.dashboard, models.Dashboard.all(self.u1.org, self.u1.group_ids, None))\n\n    def test_returns_dashboards_created_by_user(self):\n        d1 = self.factory.create_dashboard(user=self.u1)\n        db.session.flush()\n        self.assertIn(d1, list(models.Dashboard.all(self.u1.org, self.u1.group_ids, self.u1.id)))\n        self.assertIn(d1, list(models.Dashboard.all(self.u1.org, [0], self.u1.id)))\n        self.assertNotIn(d1, list(models.Dashboard.all(self.u2.org, self.u2.group_ids, self.u2.id)))\n\n    def test_returns_dashboards_with_text_widgets(self):\n        w1 = self.factory.create_widget(visualization=None)\n\n        self.assertIn(w1.dashboard, models.Dashboard.all(self.u1.org, self.u1.group_ids, None))\n        self.assertIn(w1.dashboard, models.Dashboard.all(self.u2.org, self.u2.group_ids, None))\n\n    def test_returns_dashboards_from_current_org_only(self):\n        w1 = self.factory.create_widget(visualization=None)\n\n        user = self.factory.create_user(org=self.factory.create_org())\n\n        self.assertIn(w1.dashboard, models.Dashboard.all(self.u1.org, self.u1.group_ids, None))\n        self.assertNotIn(w1.dashboard, models.Dashboard.all(user.org, user.group_ids, None))\n\n\nclass TestDashboardRecent(BaseTestCase):\n    def setUp(self):\n        super(TestDashboardRecent, self).setUp()\n        _set_up_dashboard_test(self)\n\n    def test_returns_recent_dashboards_basic(self):\n        db.session.add(models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                                    object_type=\"dashboard\", object_id=self.w1.dashboard.id))\n        db.session.flush()\n        self.assertIn(self.w1.dashboard, models.Dashboard.recent(self.u1.org, self.u1.group_ids, None))\n        self.assertNotIn(self.w2.dashboard, models.Dashboard.recent(self.u1.org, self.u1.group_ids, None))\n        self.assertNotIn(self.w1.dashboard, models.Dashboard.recent(self.u1.org, self.u2.group_ids, None))\n\n    def test_recent_excludes_drafts(self):\n        models.db.session.add_all([\n        models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                     object_type=\"dashboard\", object_id=self.w1.dashboard.id),\n        models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                     object_type=\"dashboard\", object_id=self.w2.dashboard.id)])\n\n        self.w2.dashboard.is_draft = True\n        self.assertIn(self.w1.dashboard, models.Dashboard.recent(\n            self.u1.org, self.u1.group_ids, None))\n        self.assertNotIn(self.w2.dashboard, models.Dashboard.recent(\n            self.u1.org, self.u1.group_ids, None))\n\n    def test_returns_recent_dashboards_created_by_user(self):\n        d1 = self.factory.create_dashboard(user=self.u1, is_draft=False)\n        db.session.flush()\n        db.session.add(models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                                    object_type=\"dashboard\", object_id=d1.id))\n        self.assertIn(d1, models.Dashboard.recent(self.u1.org, [0], self.u1.id))\n        self.assertNotIn(self.w2.dashboard, models.Dashboard.recent(self.u1.org, [0], self.u1.id))\n        self.assertNotIn(d1, models.Dashboard.recent(self.u2.org, [0], self.u2.id))\n\n    def test_returns_recent_dashboards_with_no_visualizations(self):\n        w1 = self.factory.create_widget(visualization=None)\n        w1.dashboard.is_draft = False\n        db.session.flush()\n        db.session.add(models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                                    object_type=\"dashboard\", object_id=w1.dashboard.id))\n        db.session.flush()\n        self.assertIn(w1.dashboard, models.Dashboard.recent(self.u1.org, [0], self.u1.id))\n        self.assertNotIn(self.w2.dashboard, models.Dashboard.recent(self.u1.org, [0], self.u1.id))\n\n    def test_restricts_dashboards_for_user(self):\n        db.session.flush()\n        db.session.add_all([\n            models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                         object_type=\"dashboard\", object_id=self.w1.dashboard.id),\n            models.Event(org=self.factory.org, user=self.u2, action=\"view\",\n                         object_type=\"dashboard\", object_id=self.w2.dashboard.id),\n            models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                         object_type=\"dashboard\", object_id=self.w5.dashboard.id),\n            models.Event(org=self.factory.org, user=self.u2, action=\"view\",\n                         object_type=\"dashboard\", object_id=self.w5.dashboard.id)\n        ])\n        db.session.flush()\n        self.assertIn(self.w1.dashboard, models.Dashboard.recent(self.u1.org, self.u1.group_ids, self.u1.id, for_user=True))\n        self.assertIn(self.w2.dashboard, models.Dashboard.recent(self.u2.org, self.u2.group_ids, self.u2.id, for_user=True))\n        self.assertNotIn(self.w1.dashboard, models.Dashboard.recent(self.u2.org, self.u2.group_ids, self.u2.id, for_user=True))\n        self.assertNotIn(self.w2.dashboard, models.Dashboard.recent(self.u1.org, self.u1.group_ids, self.u1.id, for_user=True))\n        self.assertIn(self.w5.dashboard, models.Dashboard.recent(self.u1.org, self.u1.group_ids, self.u1.id, for_user=True))\n        self.assertIn(self.w5.dashboard, models.Dashboard.recent(self.u2.org, self.u2.group_ids, self.u2.id, for_user=True))\n\n    def test_returns_each_dashboard_once(self):\n        db.session.flush()\n        db.session.add_all([\n            models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                         object_type=\"dashboard\", object_id=self.w1.dashboard.id),\n            models.Event(org=self.factory.org, user=self.u1, action=\"view\",\n                         object_type=\"dashboard\", object_id=self.w1.dashboard.id)\n            ])\n        db.session.flush()\n        dashboards = list(models.Dashboard.recent(self.u1.org, self.u1.group_ids, None))\n        self.assertEqual(len(dashboards), 1)\n\n    def test_returns_dashboards_from_current_org_only(self):\n        w1 = self.factory.create_widget(visualization=None)\n        w1.dashboard.is_draft = False\n        db.session.flush()\n        db.session.add(models.Event(\n            org=self.factory.org, user=self.u1, action=\"view\",\n            object_type=\"dashboard\", object_id=w1.dashboard.id))\n        db.session.flush()\n        user = self.factory.create_user(org=self.factory.create_org())\n\n        self.assertIn(w1.dashboard, models.Dashboard.recent(self.u1.org, self.u1.group_ids, None))\n        self.assertNotIn(w1.dashboard, models.Dashboard.recent(user.org, user.group_ids, None))\n", "description": "Make Your Company Data Driven. Connect to any data source, easily visualize and share your data.", "file_name": "test_models.py", "id": "dcf54bf2672a85b98f6ccccd310f98a4", "language": "Python", "project_name": "redash", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/getredash-redash/getredash-redash-0410d83/tests/test_models.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:54:55Z", "url": "https://github.com/getredash/redash", "wiki": false}