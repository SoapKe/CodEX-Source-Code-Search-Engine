{"author": "HelloZeroNet", "code": "import logging\n\nfrom lib.BitcoinECC import BitcoinECC\nfrom lib.pybitcointools import bitcoin as btctools\nfrom Config import config\n\n\ntry:\n    if not config.use_openssl:\n        raise Exception(\"Disabled by config\")\n    from lib.opensslVerify import opensslVerify\n    logging.info(\"OpenSSL loaded, version: %s\" % opensslVerify.openssl_version)\nexcept Exception, err:\n    logging.info(\"OpenSSL load failed: %s, falling back to slow bitcoin verify\" % err)\n    opensslVerify = None\n\n\ndef newPrivatekey(uncompressed=True):  \n    privatekey = btctools.encode_privkey(btctools.random_key(), \"wif\")\n    return privatekey\n\n\ndef newSeed():\n    return btctools.random_key()\n\n\ndef hdPrivatekey(seed, child):\n    masterkey = btctools.bip32_master_key(seed)\n    childkey = btctools.bip32_ckd(masterkey, child % 100000000)  \n    key = btctools.bip32_extract_key(childkey)\n    return btctools.encode_privkey(key, \"wif\")\n\n\ndef privatekeyToAddress(privatekey):  \n    if privatekey.startswith(\"23\") and len(privatekey) > 52:  \n        bitcoin = BitcoinECC.Bitcoin()\n        bitcoin.BitcoinAddressFromPrivate(privatekey)\n        return bitcoin.BitcoinAddresFromPublicKey()\n    else:\n        try:\n            return btctools.privkey_to_address(privatekey)\n        except Exception:  \n            return False\n\n\ndef sign(data, privatekey):  \n    if privatekey.startswith(\"23\") and len(privatekey) > 52:\n        return None  \n    sign = btctools.ecdsa_sign(data, privatekey)\n    return sign\n\n\ndef signOld(data, privatekey):   (backward compatible old style)\n    bitcoin = BitcoinECC.Bitcoin()\n    bitcoin.BitcoinAddressFromPrivate(privatekey)\n    sign = bitcoin.SignECDSA(data)\n    return sign\n\n\ndef verify(data, address, sign):  \n    if hasattr(sign, \"endswith\"):\n        if opensslVerify:  \n            pub = opensslVerify.getMessagePubkey(data, sign)\n            sign_address = btctools.pubtoaddr(pub)\n        else:  \n            pub = btctools.ecdsa_recover(data, sign)\n            sign_address = btctools.pubtoaddr(pub)\n\n        if type(address) is list:  \n            return sign_address in address\n        else:  \n            return sign_address == address\n    else:  \n        bitcoin = BitcoinECC.Bitcoin()\n        return bitcoin.VerifyMessageFromBitcoinAddress(address, data, sign)\n", "comments": "  try load openssl    return new private key    too large child id could cause problems    return address private key    backward compatibility broken lib    invalid privatekey    return sign data using private key    old style private key supported    return sign data using private key (backward compatible old style)    verify data using address sign    use faster method avalible    use pure python    any address list    one possible address    backward compatible old style ", "content": "import logging\n\nfrom lib.BitcoinECC import BitcoinECC\nfrom lib.pybitcointools import bitcoin as btctools\nfrom Config import config\n\n# Try to load openssl\ntry:\n    if not config.use_openssl:\n        raise Exception(\"Disabled by config\")\n    from lib.opensslVerify import opensslVerify\n    logging.info(\"OpenSSL loaded, version: %s\" % opensslVerify.openssl_version)\nexcept Exception, err:\n    logging.info(\"OpenSSL load failed: %s, falling back to slow bitcoin verify\" % err)\n    opensslVerify = None\n\n\ndef newPrivatekey(uncompressed=True):  # Return new private key\n    privatekey = btctools.encode_privkey(btctools.random_key(), \"wif\")\n    return privatekey\n\n\ndef newSeed():\n    return btctools.random_key()\n\n\ndef hdPrivatekey(seed, child):\n    masterkey = btctools.bip32_master_key(seed)\n    childkey = btctools.bip32_ckd(masterkey, child % 100000000)  # Too large child id could cause problems\n    key = btctools.bip32_extract_key(childkey)\n    return btctools.encode_privkey(key, \"wif\")\n\n\ndef privatekeyToAddress(privatekey):  # Return address from private key\n    if privatekey.startswith(\"23\") and len(privatekey) > 52:  # Backward compatibility to broken lib\n        bitcoin = BitcoinECC.Bitcoin()\n        bitcoin.BitcoinAddressFromPrivate(privatekey)\n        return bitcoin.BitcoinAddresFromPublicKey()\n    else:\n        try:\n            return btctools.privkey_to_address(privatekey)\n        except Exception:  # Invalid privatekey\n            return False\n\n\ndef sign(data, privatekey):  # Return sign to data using private key\n    if privatekey.startswith(\"23\") and len(privatekey) > 52:\n        return None  # Old style private key not supported\n    sign = btctools.ecdsa_sign(data, privatekey)\n    return sign\n\n\ndef signOld(data, privatekey):  # Return sign to data using private key (backward compatible old style)\n    bitcoin = BitcoinECC.Bitcoin()\n    bitcoin.BitcoinAddressFromPrivate(privatekey)\n    sign = bitcoin.SignECDSA(data)\n    return sign\n\n\ndef verify(data, address, sign):  # Verify data using address and sign\n    if hasattr(sign, \"endswith\"):\n        if opensslVerify:  # Use the faster method if avalible\n            pub = opensslVerify.getMessagePubkey(data, sign)\n            sign_address = btctools.pubtoaddr(pub)\n        else:  # Use pure-python\n            pub = btctools.ecdsa_recover(data, sign)\n            sign_address = btctools.pubtoaddr(pub)\n\n        if type(address) is list:  # Any address in the list\n            return sign_address in address\n        else:  # One possible address\n            return sign_address == address\n    else:  # Backward compatible old style\n        bitcoin = BitcoinECC.Bitcoin()\n        return bitcoin.VerifyMessageFromBitcoinAddress(address, data, sign)\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "CryptBitcoin.py", "id": "45f98e0842451c067add62062dde0950", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/Crypt/CryptBitcoin.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}