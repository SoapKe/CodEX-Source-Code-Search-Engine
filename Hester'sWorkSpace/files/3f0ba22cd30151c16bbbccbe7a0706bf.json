{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_HTTPError,\n)\nfrom ..utils import (\n    qualities,\n    strip_or_none,\n    int_or_none,\n    ExtractorError,\n)\n\n\nclass FilmOnIE(InfoExtractor):\n    IE_NAME = 'filmon'\n    _VALID_URL = r'(?:https?://(?:www\\.)?filmon\\.com/vod/view/|filmon:)(?P<id>\\d+)'\n    _TESTS = [{\n        'url': 'https://www.filmon.com/vod/view/24869-0-plan-9-from-outer-space',\n        'info_dict': {\n            'id': '24869',\n            'ext': 'mp4',\n            'title': 'Plan 9 From Outer Space',\n            'description': 'Dead human, zombies and vampires',\n        },\n    }, {\n        'url': 'https://www.filmon.com/vod/view/2825-1-popeye-series-1',\n        'info_dict': {\n            'id': '2825',\n            'title': 'Popeye Series 1',\n            'description': 'The original series of Popeye.',\n        },\n        'playlist_mincount': 8,\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        try:\n            response = self._download_json(\n                'https://www.filmon.com/api/vod/movie?id=%s' % video_id,\n                video_id)['response']\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError):\n                errmsg = self._parse_json(e.cause.read().decode(), video_id)['reason']\n                raise ExtractorError('%s said: %s' % (self.IE_NAME, errmsg), expected=True)\n            raise\n\n        title = response['title']\n        description = strip_or_none(response.get('description'))\n\n        if response.get('type_id') == 1:\n            entries = [self.url_result('filmon:' + episode_id) for episode_id in response.get('episodes', [])]\n            return self.playlist_result(entries, video_id, title, description)\n\n        QUALITY = qualities(('low', 'high'))\n        formats = []\n        for format_id, stream in response.get('streams', {}).items():\n            stream_url = stream.get('url')\n            if not stream_url:\n                continue\n            formats.append({\n                'format_id': format_id,\n                'url': stream_url,\n                'ext': 'mp4',\n                'quality': QUALITY(stream.get('quality')),\n                'protocol': 'm3u8_native',\n            })\n        self._sort_formats(formats)\n\n        thumbnails = []\n        poster = response.get('poster', {})\n        thumbs = poster.get('thumbs', {})\n        thumbs['poster'] = poster\n        for thumb_id, thumb in thumbs.items():\n            thumb_url = thumb.get('url')\n            if not thumb_url:\n                continue\n            thumbnails.append({\n                'id': thumb_id,\n                'url': thumb_url,\n                'width': int_or_none(thumb.get('width')),\n                'height': int_or_none(thumb.get('height')),\n            })\n\n        return {\n            'id': video_id,\n            'title': title,\n            'formats': formats,\n            'description': description,\n            'thumbnails': thumbnails,\n        }\n\n\nclass FilmOnChannelIE(InfoExtractor):\n    IE_NAME = 'filmon:channel'\n    _VALID_URL = r'https?://(?:www\\.)?filmon\\.com/(?:tv|channel)/(?P<id>[a-z0-9-]+)'\n    _TESTS = [{\n        \n        'url': 'http://www.filmon.com/tv/sports-haters',\n        'info_dict': {\n            'id': '4190',\n            'ext': 'mp4',\n            'title': 'Sports Haters',\n            'description': 'md5:dabcb4c1d9cfc77085612f1a85f8275d',\n        },\n    }, {\n        \n        'url': 'https://www.filmon.com/channel/filmon-sports',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.filmon.com/tv/2894',\n        'only_matching': True,\n    }]\n\n    _THUMBNAIL_RES = [\n        ('logo', 56, 28),\n        ('big_logo', 106, 106),\n        ('extra_big_logo', 300, 300),\n    ]\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        try:\n            channel_data = self._download_json(\n                'http://www.filmon.com/api-v2/channel/' + channel_id, channel_id)['data']\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError):\n                errmsg = self._parse_json(e.cause.read().decode(), channel_id)['message']\n                raise ExtractorError('%s said: %s' % (self.IE_NAME, errmsg), expected=True)\n            raise\n\n        channel_id = compat_str(channel_data['id'])\n        is_live = not channel_data.get('is_vod') and not channel_data.get('is_vox')\n        title = channel_data['title']\n\n        QUALITY = qualities(('low', 'high'))\n        formats = []\n        for stream in channel_data.get('streams', []):\n            stream_url = stream.get('url')\n            if not stream_url:\n                continue\n            if not is_live:\n                formats.extend(self._extract_wowza_formats(\n                    stream_url, channel_id, skip_protocols=['dash', 'rtmp', 'rtsp']))\n                continue\n            quality = stream.get('quality')\n            formats.append({\n                'format_id': quality,\n                \n                \n                'url': stream_url,\n                'ext': 'mp4',\n                'quality': QUALITY(quality),\n            })\n        self._sort_formats(formats)\n\n        thumbnails = []\n        for name, width, height in self._THUMBNAIL_RES:\n            thumbnails.append({\n                'id': name,\n                'url': 'http://static.filmon.com/assets/channels/%s/%s.png' % (channel_id, name),\n                'width': width,\n                'height': height,\n            })\n\n        return {\n            'id': channel_id,\n            'display_id': channel_data.get('alias'),\n            'title': self._live_title(title) if is_live else title,\n            'description': channel_data.get('description'),\n            'thumbnails': thumbnails,\n            'formats': formats,\n            'is_live': is_live,\n        }\n", "comments": "# coding: utf-8\n# VOD\n# LIVE\n# this is an m3u8 stream, but we are deliberately not using _extract_m3u8_formats\n# because it doesn't have bitrate variants anyway\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_HTTPError,\n)\nfrom ..utils import (\n    qualities,\n    strip_or_none,\n    int_or_none,\n    ExtractorError,\n)\n\n\nclass FilmOnIE(InfoExtractor):\n    IE_NAME = 'filmon'\n    _VALID_URL = r'(?:https?://(?:www\\.)?filmon\\.com/vod/view/|filmon:)(?P<id>\\d+)'\n    _TESTS = [{\n        'url': 'https://www.filmon.com/vod/view/24869-0-plan-9-from-outer-space',\n        'info_dict': {\n            'id': '24869',\n            'ext': 'mp4',\n            'title': 'Plan 9 From Outer Space',\n            'description': 'Dead human, zombies and vampires',\n        },\n    }, {\n        'url': 'https://www.filmon.com/vod/view/2825-1-popeye-series-1',\n        'info_dict': {\n            'id': '2825',\n            'title': 'Popeye Series 1',\n            'description': 'The original series of Popeye.',\n        },\n        'playlist_mincount': 8,\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        try:\n            response = self._download_json(\n                'https://www.filmon.com/api/vod/movie?id=%s' % video_id,\n                video_id)['response']\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError):\n                errmsg = self._parse_json(e.cause.read().decode(), video_id)['reason']\n                raise ExtractorError('%s said: %s' % (self.IE_NAME, errmsg), expected=True)\n            raise\n\n        title = response['title']\n        description = strip_or_none(response.get('description'))\n\n        if response.get('type_id') == 1:\n            entries = [self.url_result('filmon:' + episode_id) for episode_id in response.get('episodes', [])]\n            return self.playlist_result(entries, video_id, title, description)\n\n        QUALITY = qualities(('low', 'high'))\n        formats = []\n        for format_id, stream in response.get('streams', {}).items():\n            stream_url = stream.get('url')\n            if not stream_url:\n                continue\n            formats.append({\n                'format_id': format_id,\n                'url': stream_url,\n                'ext': 'mp4',\n                'quality': QUALITY(stream.get('quality')),\n                'protocol': 'm3u8_native',\n            })\n        self._sort_formats(formats)\n\n        thumbnails = []\n        poster = response.get('poster', {})\n        thumbs = poster.get('thumbs', {})\n        thumbs['poster'] = poster\n        for thumb_id, thumb in thumbs.items():\n            thumb_url = thumb.get('url')\n            if not thumb_url:\n                continue\n            thumbnails.append({\n                'id': thumb_id,\n                'url': thumb_url,\n                'width': int_or_none(thumb.get('width')),\n                'height': int_or_none(thumb.get('height')),\n            })\n\n        return {\n            'id': video_id,\n            'title': title,\n            'formats': formats,\n            'description': description,\n            'thumbnails': thumbnails,\n        }\n\n\nclass FilmOnChannelIE(InfoExtractor):\n    IE_NAME = 'filmon:channel'\n    _VALID_URL = r'https?://(?:www\\.)?filmon\\.com/(?:tv|channel)/(?P<id>[a-z0-9-]+)'\n    _TESTS = [{\n        # VOD\n        'url': 'http://www.filmon.com/tv/sports-haters',\n        'info_dict': {\n            'id': '4190',\n            'ext': 'mp4',\n            'title': 'Sports Haters',\n            'description': 'md5:dabcb4c1d9cfc77085612f1a85f8275d',\n        },\n    }, {\n        # LIVE\n        'url': 'https://www.filmon.com/channel/filmon-sports',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.filmon.com/tv/2894',\n        'only_matching': True,\n    }]\n\n    _THUMBNAIL_RES = [\n        ('logo', 56, 28),\n        ('big_logo', 106, 106),\n        ('extra_big_logo', 300, 300),\n    ]\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        try:\n            channel_data = self._download_json(\n                'http://www.filmon.com/api-v2/channel/' + channel_id, channel_id)['data']\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError):\n                errmsg = self._parse_json(e.cause.read().decode(), channel_id)['message']\n                raise ExtractorError('%s said: %s' % (self.IE_NAME, errmsg), expected=True)\n            raise\n\n        channel_id = compat_str(channel_data['id'])\n        is_live = not channel_data.get('is_vod') and not channel_data.get('is_vox')\n        title = channel_data['title']\n\n        QUALITY = qualities(('low', 'high'))\n        formats = []\n        for stream in channel_data.get('streams', []):\n            stream_url = stream.get('url')\n            if not stream_url:\n                continue\n            if not is_live:\n                formats.extend(self._extract_wowza_formats(\n                    stream_url, channel_id, skip_protocols=['dash', 'rtmp', 'rtsp']))\n                continue\n            quality = stream.get('quality')\n            formats.append({\n                'format_id': quality,\n                # this is an m3u8 stream, but we are deliberately not using _extract_m3u8_formats\n                # because it doesn't have bitrate variants anyway\n                'url': stream_url,\n                'ext': 'mp4',\n                'quality': QUALITY(quality),\n            })\n        self._sort_formats(formats)\n\n        thumbnails = []\n        for name, width, height in self._THUMBNAIL_RES:\n            thumbnails.append({\n                'id': name,\n                'url': 'http://static.filmon.com/assets/channels/%s/%s.png' % (channel_id, name),\n                'width': width,\n                'height': height,\n            })\n\n        return {\n            'id': channel_id,\n            'display_id': channel_data.get('alias'),\n            'title': self._live_title(title) if is_live else title,\n            'description': channel_data.get('description'),\n            'thumbnails': thumbnails,\n            'formats': formats,\n            'is_live': is_live,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "filmon.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/filmon.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}