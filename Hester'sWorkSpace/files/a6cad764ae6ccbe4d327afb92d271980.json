{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport re\nimport itertools\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_urlparse,\n)\nfrom ..utils import (\n    find_xpath_attr,\n    xpath_attr,\n    xpath_with_ns,\n    xpath_text,\n    orderedSet,\n    update_url_query,\n    int_or_none,\n    float_or_none,\n    parse_iso8601,\n    determine_ext,\n)\n\n\nclass LivestreamIE(InfoExtractor):\n    IE_NAME = 'livestream'\n    _VALID_URL = r'https?://(?:new\\.)?livestream\\.com/(?:accounts/(?P<account_id>\\d+)|(?P<account_name>[^/]+))/(?:events/(?P<event_id>\\d+)|(?P<event_name>[^/]+))(?:/videos/(?P<id>\\d+))?'\n    _TESTS = [{\n        'url': 'http://new.livestream.com/CoheedandCambria/WebsterHall/videos/4719370',\n        'md5': '53274c76ba7754fb0e8d072716f2292b',\n        'info_dict': {\n            'id': '4719370',\n            'ext': 'mp4',\n            'title': 'Live from Webster Hall NYC',\n            'timestamp': 1350008072,\n            'upload_date': '20121012',\n            'duration': 5968.0,\n            'like_count': int,\n            'view_count': int,\n            'thumbnail': r're:^http://.*\\.jpg$'\n        }\n    }, {\n        'url': 'http://new.livestream.com/tedx/cityenglish',\n        'info_dict': {\n            'title': 'TEDCity2.0 (English)',\n            'id': '2245590',\n        },\n        'playlist_mincount': 4,\n    }, {\n        'url': 'http://new.livestream.com/chess24/tatasteelchess',\n        'info_dict': {\n            'title': 'Tata Steel Chess',\n            'id': '3705884',\n        },\n        'playlist_mincount': 60,\n    }, {\n        'url': 'https://new.livestream.com/accounts/362/events/3557232/videos/67864563/player?autoPlay=false&height=360&mute=false&width=640',\n        'only_matching': True,\n    }, {\n        'url': 'http://livestream.com/bsww/concacafbeachsoccercampeonato2015',\n        'only_matching': True,\n    }]\n    _API_URL_TEMPLATE = 'http://livestream.com/api/accounts/%s/events/%s'\n\n    def _parse_smil_formats(self, smil, smil_url, video_id, namespace=None, f4m_params=None, transform_rtmp_url=None):\n        base_ele = find_xpath_attr(\n            smil, self._xpath_ns('.//meta', namespace), 'name', 'httpBase')\n        base = base_ele.get('content') if base_ele is not None else 'http://livestreamvod-f.akamaihd.net/'\n\n        formats = []\n        video_nodes = smil.findall(self._xpath_ns('.//video', namespace))\n\n        for vn in video_nodes:\n            tbr = int_or_none(vn.attrib.get('system-bitrate'), 1000)\n            furl = (\n                update_url_query(compat_urlparse.urljoin(base, vn.attrib['src']), {\n                    'v': '3.0.3',\n                    'fp': 'WIN% 14,0,0,145',\n                }))\n            if 'clipBegin' in vn.attrib:\n                furl += '&ssek=' + vn.attrib['clipBegin']\n            formats.append({\n                'url': furl,\n                'format_id': 'smil_%d' % tbr,\n                'ext': 'flv',\n                'tbr': tbr,\n                'preference': -1000,\n            })\n        return formats\n\n    def _extract_video_info(self, video_data):\n        video_id = compat_str(video_data['id'])\n\n        FORMAT_KEYS = (\n            ('sd', 'progressive_url'),\n            ('hd', 'progressive_url_hd'),\n        )\n\n        formats = []\n        for format_id, key in FORMAT_KEYS:\n            video_url = video_data.get(key)\n            if video_url:\n                ext = determine_ext(video_url)\n                if ext == 'm3u8':\n                    continue\n                bitrate = int_or_none(self._search_regex(\n                    r'(\\d+)\\.%s' % ext, video_url, 'bitrate', default=None))\n                formats.append({\n                    'url': video_url,\n                    'format_id': format_id,\n                    'tbr': bitrate,\n                    'ext': ext,\n                })\n\n        smil_url = video_data.get('smil_url')\n        if smil_url:\n            formats.extend(self._extract_smil_formats(smil_url, video_id, fatal=False))\n\n        m3u8_url = video_data.get('m3u8_url')\n        if m3u8_url:\n            formats.extend(self._extract_m3u8_formats(\n                m3u8_url, video_id, 'mp4', 'm3u8_native',\n                m3u8_id='hls', fatal=False))\n\n        f4m_url = video_data.get('f4m_url')\n        if f4m_url:\n            formats.extend(self._extract_f4m_formats(\n                f4m_url, video_id, f4m_id='hds', fatal=False))\n        self._sort_formats(formats)\n\n        comments = [{\n            'author_id': comment.get('author_id'),\n            'author': comment.get('author', {}).get('full_name'),\n            'id': comment.get('id'),\n            'text': comment['text'],\n            'timestamp': parse_iso8601(comment.get('created_at')),\n        } for comment in video_data.get('comments', {}).get('data', [])]\n\n        return {\n            'id': video_id,\n            'formats': formats,\n            'title': video_data['caption'],\n            'description': video_data.get('description'),\n            'thumbnail': video_data.get('thumbnail_url'),\n            'duration': float_or_none(video_data.get('duration'), 1000),\n            'timestamp': parse_iso8601(video_data.get('publish_at')),\n            'like_count': video_data.get('likes', {}).get('total'),\n            'comment_count': video_data.get('comments', {}).get('total'),\n            'view_count': video_data.get('views'),\n            'comments': comments,\n        }\n\n    def _extract_stream_info(self, stream_info):\n        broadcast_id = compat_str(stream_info['broadcast_id'])\n        is_live = stream_info.get('is_live')\n\n        formats = []\n        smil_url = stream_info.get('play_url')\n        if smil_url:\n            formats.extend(self._extract_smil_formats(smil_url, broadcast_id))\n\n        m3u8_url = stream_info.get('m3u8_url')\n        if m3u8_url:\n            formats.extend(self._extract_m3u8_formats(\n                m3u8_url, broadcast_id, 'mp4', 'm3u8_native',\n                m3u8_id='hls', fatal=False))\n\n        rtsp_url = stream_info.get('rtsp_url')\n        if rtsp_url:\n            formats.append({\n                'url': rtsp_url,\n                'format_id': 'rtsp',\n            })\n        self._sort_formats(formats)\n\n        return {\n            'id': broadcast_id,\n            'formats': formats,\n            'title': self._live_title(stream_info['stream_title']) if is_live else stream_info['stream_title'],\n            'thumbnail': stream_info.get('thumbnail_url'),\n            'is_live': is_live,\n        }\n\n    def _extract_event(self, event_data):\n        event_id = compat_str(event_data['id'])\n        account_id = compat_str(event_data['owner_account_id'])\n        feed_root_url = self._API_URL_TEMPLATE % (account_id, event_id) + '/feed.json'\n\n        stream_info = event_data.get('stream_info')\n        if stream_info:\n            return self._extract_stream_info(stream_info)\n\n        last_video = None\n        entries = []\n        for i in itertools.count(1):\n            if last_video is None:\n                info_url = feed_root_url\n            else:\n                info_url = '{root}?&id={id}&newer=-1&type=video'.format(\n                    root=feed_root_url, id=last_video)\n            videos_info = self._download_json(\n                info_url, event_id, 'Downloading page {0}'.format(i))['data']\n            videos_info = [v['data'] for v in videos_info if v['type'] == 'video']\n            if not videos_info:\n                break\n            for v in videos_info:\n                v_id = compat_str(v['id'])\n                entries.append(self.url_result(\n                    'http://livestream.com/accounts/%s/events/%s/videos/%s' % (account_id, event_id, v_id),\n                    'Livestream', v_id, v.get('caption')))\n            last_video = videos_info[-1]['id']\n        return self.playlist_result(entries, event_id, event_data['full_name'])\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        video_id = mobj.group('id')\n        event = mobj.group('event_id') or mobj.group('event_name')\n        account = mobj.group('account_id') or mobj.group('account_name')\n        api_url = self._API_URL_TEMPLATE % (account, event)\n        if video_id:\n            video_data = self._download_json(\n                api_url + '/videos/%s' % video_id, video_id)\n            return self._extract_video_info(video_data)\n        else:\n            event_data = self._download_json(api_url, video_id)\n            return self._extract_event(event_data)\n\n\n\nclass LivestreamOriginalIE(InfoExtractor):\n    IE_NAME = 'livestream:original'\n    _VALID_URL = r, webpage))\n\n        entries = [{\n            '_type': 'url',\n            'url': compat_urlparse.urljoin(url, p),\n        } for p in paths]\n\n        return self.playlist_result(entries, folder_id)\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        user = mobj.group('user')\n        url_type = mobj.group('type')\n        content_id = mobj.group('id')\n        if url_type == 'folder':\n            return self._extract_folder(url, content_id)\n        else:\n            \n            stream_url = 'http://x%sx.api.channel.livestream.com/3.0/getstream.json' % user\n            info = {}\n            if content_id:\n                stream_url += '?id=%s' % content_id\n                info = self._extract_video_info(user, content_id)\n            else:\n                content_id = user\n                webpage = self._download_webpage(url, content_id)\n                info = {\n                    'title': self._og_search_title(webpage),\n                    'description': self._og_search_description(webpage),\n                    'thumbnail': self._search_regex(r'channelLogo\\.src\\s*=\\s*\"([^\"]+)\"', webpage, 'thumbnail', None),\n                }\n            video_data = self._download_json(stream_url, content_id)\n            is_live = video_data.get('isLive')\n            info.update({\n                'id': content_id,\n                'title': self._live_title(info['title']) if is_live else info['title'],\n                'formats': self._extract_video_formats(video_data, content_id),\n                'is_live': is_live,\n            })\n            return info\n\n\n\n\nclass LivestreamShortenerIE(InfoExtractor):\n    IE_NAME = 'livestream:shortener'\n    IE_DESC = False  \n    _VALID_URL = r'https?://livestre\\.am/(?P<id>.+)'\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        id = mobj.group('id')\n        webpage = self._download_webpage(url, id)\n\n        return {\n            '_type': 'url',\n            'url': self._og_search_url(webpage),\n        }\n", "comments": "(?x)https?://original\\.livestream\\.com/\n        (?P<user>[^/\\?#]+)(?:/(?P<type>video|folder)\n        (?:(?:\\?.*?Id=|/)(?P<id>.*?)(&|$))?)?\n        '''\n    _TESTS = [{\n        'url': 'http://original.livestream.com/dealbook/video?clipId=pla_8aa4a3f1-ba15-46a4-893b-902210e138fb',\n        'info_dict': {\n            'id': 'pla_8aa4a3f1-ba15-46a4-893b-902210e138fb',\n            'ext': 'mp4',\n            'title': 'Spark 1 (BitCoin) with Cameron Winklevoss & Tyler Winklevoss of Winklevoss Capital',\n            'duration': 771.301,\n            'view_count': int,\n        },\n    }, {\n        'url': 'https://original.livestream.com/newplay/folder?dirId=a07bf706-d0e4-4e75-a747-b021d84f2fd3',\n        'info_dict': {\n            'id': 'a07bf706-d0e4-4e75-a747-b021d84f2fd3',\n        },\n        'playlist_mincount': 4,\n    }, {\n        # live stream\n        'url': 'http://original.livestream.com/znsbahamas',\n        'only_matching': True,\n    }]\n\n    def _extract_video_info(self, user, video_id):\n        api_url = 'http://x%sx.api.channel.livestream.com/2.0/clipdetails?extendedInfo=true&id=%s' % (user, video_id)\n        info = self._download_xml(api_url, video_id)\n\n        item = info.find('channel').find('item')\n        title = xpath_text(item, 'title')\n        media_ns = {'media': 'http://search.yahoo.com/mrss'}\n        thumbnail_url = xpath_attr(\n            item, xpath_with_ns('media:thumbnail', media_ns), 'url')\n        duration = float_or_none(xpath_attr(\n            item, xpath_with_ns('media:content', media_ns), 'duration'))\n        ls_ns = {'ls': 'http://api.channel.livestream.com/2.0'}\n        view_count = int_or_none(xpath_text(\n            item, xpath_with_ns('ls:viewsCount', ls_ns)))\n\n        return {\n            'id': video_id,\n            'title': title,\n            'thumbnail': thumbnail_url,\n            'duration': duration,\n            'view_count': view_count,\n        }\n\n    def _extract_video_formats(self, video_data, video_id):\n        formats = []\n\n        progressive_url = video_data.get('progressiveUrl')\n        if progressive_url:\n            formats.append({\n                'url': progressive_url,\n                'format_id': 'http',\n            })\n\n        m3u8_url = video_data.get('httpUrl')\n        if m3u8_url:\n            formats.extend(self._extract_m3u8_formats(\n                m3u8_url, video_id, 'mp4', 'm3u8_native',\n                m3u8_id='hls', fatal=False))\n\n        rtsp_url = video_data.get('rtspUrl')\n        if rtsp_url:\n            formats.append({\n                'url': rtsp_url,\n                'format_id': 'rtsp',\n            })\n\n        self._sort_formats(formats)\n        return formats\n\n    def _extract_folder(self, url, folder_id):\n        webpage = self._download_webpage(url, folder_id)\n        paths = orderedSet(re.findall(\n            r'''(?x)(?:\n                <li\\s+class=\"folder\">\\s*<a\\s+href=\"|\n                <a\\s+href=\"(?=https?://livestre\\.am/)\n            )([^\"]+)\"\n\"\n# The original version of Livestream uses a different system\n# this url is used on mobile devices\n# The server doesn't support HEAD request, the generic extractor can't detect\n# the redirection\n# Do not list\n", "content": "from __future__ import unicode_literals\n\nimport re\nimport itertools\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_urlparse,\n)\nfrom ..utils import (\n    find_xpath_attr,\n    xpath_attr,\n    xpath_with_ns,\n    xpath_text,\n    orderedSet,\n    update_url_query,\n    int_or_none,\n    float_or_none,\n    parse_iso8601,\n    determine_ext,\n)\n\n\nclass LivestreamIE(InfoExtractor):\n    IE_NAME = 'livestream'\n    _VALID_URL = r'https?://(?:new\\.)?livestream\\.com/(?:accounts/(?P<account_id>\\d+)|(?P<account_name>[^/]+))/(?:events/(?P<event_id>\\d+)|(?P<event_name>[^/]+))(?:/videos/(?P<id>\\d+))?'\n    _TESTS = [{\n        'url': 'http://new.livestream.com/CoheedandCambria/WebsterHall/videos/4719370',\n        'md5': '53274c76ba7754fb0e8d072716f2292b',\n        'info_dict': {\n            'id': '4719370',\n            'ext': 'mp4',\n            'title': 'Live from Webster Hall NYC',\n            'timestamp': 1350008072,\n            'upload_date': '20121012',\n            'duration': 5968.0,\n            'like_count': int,\n            'view_count': int,\n            'thumbnail': r're:^http://.*\\.jpg$'\n        }\n    }, {\n        'url': 'http://new.livestream.com/tedx/cityenglish',\n        'info_dict': {\n            'title': 'TEDCity2.0 (English)',\n            'id': '2245590',\n        },\n        'playlist_mincount': 4,\n    }, {\n        'url': 'http://new.livestream.com/chess24/tatasteelchess',\n        'info_dict': {\n            'title': 'Tata Steel Chess',\n            'id': '3705884',\n        },\n        'playlist_mincount': 60,\n    }, {\n        'url': 'https://new.livestream.com/accounts/362/events/3557232/videos/67864563/player?autoPlay=false&height=360&mute=false&width=640',\n        'only_matching': True,\n    }, {\n        'url': 'http://livestream.com/bsww/concacafbeachsoccercampeonato2015',\n        'only_matching': True,\n    }]\n    _API_URL_TEMPLATE = 'http://livestream.com/api/accounts/%s/events/%s'\n\n    def _parse_smil_formats(self, smil, smil_url, video_id, namespace=None, f4m_params=None, transform_rtmp_url=None):\n        base_ele = find_xpath_attr(\n            smil, self._xpath_ns('.//meta', namespace), 'name', 'httpBase')\n        base = base_ele.get('content') if base_ele is not None else 'http://livestreamvod-f.akamaihd.net/'\n\n        formats = []\n        video_nodes = smil.findall(self._xpath_ns('.//video', namespace))\n\n        for vn in video_nodes:\n            tbr = int_or_none(vn.attrib.get('system-bitrate'), 1000)\n            furl = (\n                update_url_query(compat_urlparse.urljoin(base, vn.attrib['src']), {\n                    'v': '3.0.3',\n                    'fp': 'WIN% 14,0,0,145',\n                }))\n            if 'clipBegin' in vn.attrib:\n                furl += '&ssek=' + vn.attrib['clipBegin']\n            formats.append({\n                'url': furl,\n                'format_id': 'smil_%d' % tbr,\n                'ext': 'flv',\n                'tbr': tbr,\n                'preference': -1000,\n            })\n        return formats\n\n    def _extract_video_info(self, video_data):\n        video_id = compat_str(video_data['id'])\n\n        FORMAT_KEYS = (\n            ('sd', 'progressive_url'),\n            ('hd', 'progressive_url_hd'),\n        )\n\n        formats = []\n        for format_id, key in FORMAT_KEYS:\n            video_url = video_data.get(key)\n            if video_url:\n                ext = determine_ext(video_url)\n                if ext == 'm3u8':\n                    continue\n                bitrate = int_or_none(self._search_regex(\n                    r'(\\d+)\\.%s' % ext, video_url, 'bitrate', default=None))\n                formats.append({\n                    'url': video_url,\n                    'format_id': format_id,\n                    'tbr': bitrate,\n                    'ext': ext,\n                })\n\n        smil_url = video_data.get('smil_url')\n        if smil_url:\n            formats.extend(self._extract_smil_formats(smil_url, video_id, fatal=False))\n\n        m3u8_url = video_data.get('m3u8_url')\n        if m3u8_url:\n            formats.extend(self._extract_m3u8_formats(\n                m3u8_url, video_id, 'mp4', 'm3u8_native',\n                m3u8_id='hls', fatal=False))\n\n        f4m_url = video_data.get('f4m_url')\n        if f4m_url:\n            formats.extend(self._extract_f4m_formats(\n                f4m_url, video_id, f4m_id='hds', fatal=False))\n        self._sort_formats(formats)\n\n        comments = [{\n            'author_id': comment.get('author_id'),\n            'author': comment.get('author', {}).get('full_name'),\n            'id': comment.get('id'),\n            'text': comment['text'],\n            'timestamp': parse_iso8601(comment.get('created_at')),\n        } for comment in video_data.get('comments', {}).get('data', [])]\n\n        return {\n            'id': video_id,\n            'formats': formats,\n            'title': video_data['caption'],\n            'description': video_data.get('description'),\n            'thumbnail': video_data.get('thumbnail_url'),\n            'duration': float_or_none(video_data.get('duration'), 1000),\n            'timestamp': parse_iso8601(video_data.get('publish_at')),\n            'like_count': video_data.get('likes', {}).get('total'),\n            'comment_count': video_data.get('comments', {}).get('total'),\n            'view_count': video_data.get('views'),\n            'comments': comments,\n        }\n\n    def _extract_stream_info(self, stream_info):\n        broadcast_id = compat_str(stream_info['broadcast_id'])\n        is_live = stream_info.get('is_live')\n\n        formats = []\n        smil_url = stream_info.get('play_url')\n        if smil_url:\n            formats.extend(self._extract_smil_formats(smil_url, broadcast_id))\n\n        m3u8_url = stream_info.get('m3u8_url')\n        if m3u8_url:\n            formats.extend(self._extract_m3u8_formats(\n                m3u8_url, broadcast_id, 'mp4', 'm3u8_native',\n                m3u8_id='hls', fatal=False))\n\n        rtsp_url = stream_info.get('rtsp_url')\n        if rtsp_url:\n            formats.append({\n                'url': rtsp_url,\n                'format_id': 'rtsp',\n            })\n        self._sort_formats(formats)\n\n        return {\n            'id': broadcast_id,\n            'formats': formats,\n            'title': self._live_title(stream_info['stream_title']) if is_live else stream_info['stream_title'],\n            'thumbnail': stream_info.get('thumbnail_url'),\n            'is_live': is_live,\n        }\n\n    def _extract_event(self, event_data):\n        event_id = compat_str(event_data['id'])\n        account_id = compat_str(event_data['owner_account_id'])\n        feed_root_url = self._API_URL_TEMPLATE % (account_id, event_id) + '/feed.json'\n\n        stream_info = event_data.get('stream_info')\n        if stream_info:\n            return self._extract_stream_info(stream_info)\n\n        last_video = None\n        entries = []\n        for i in itertools.count(1):\n            if last_video is None:\n                info_url = feed_root_url\n            else:\n                info_url = '{root}?&id={id}&newer=-1&type=video'.format(\n                    root=feed_root_url, id=last_video)\n            videos_info = self._download_json(\n                info_url, event_id, 'Downloading page {0}'.format(i))['data']\n            videos_info = [v['data'] for v in videos_info if v['type'] == 'video']\n            if not videos_info:\n                break\n            for v in videos_info:\n                v_id = compat_str(v['id'])\n                entries.append(self.url_result(\n                    'http://livestream.com/accounts/%s/events/%s/videos/%s' % (account_id, event_id, v_id),\n                    'Livestream', v_id, v.get('caption')))\n            last_video = videos_info[-1]['id']\n        return self.playlist_result(entries, event_id, event_data['full_name'])\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        video_id = mobj.group('id')\n        event = mobj.group('event_id') or mobj.group('event_name')\n        account = mobj.group('account_id') or mobj.group('account_name')\n        api_url = self._API_URL_TEMPLATE % (account, event)\n        if video_id:\n            video_data = self._download_json(\n                api_url + '/videos/%s' % video_id, video_id)\n            return self._extract_video_info(video_data)\n        else:\n            event_data = self._download_json(api_url, video_id)\n            return self._extract_event(event_data)\n\n\n# The original version of Livestream uses a different system\nclass LivestreamOriginalIE(InfoExtractor):\n    IE_NAME = 'livestream:original'\n    _VALID_URL = r'''(?x)https?://original\\.livestream\\.com/\n        (?P<user>[^/\\?#]+)(?:/(?P<type>video|folder)\n        (?:(?:\\?.*?Id=|/)(?P<id>.*?)(&|$))?)?\n        '''\n    _TESTS = [{\n        'url': 'http://original.livestream.com/dealbook/video?clipId=pla_8aa4a3f1-ba15-46a4-893b-902210e138fb',\n        'info_dict': {\n            'id': 'pla_8aa4a3f1-ba15-46a4-893b-902210e138fb',\n            'ext': 'mp4',\n            'title': 'Spark 1 (BitCoin) with Cameron Winklevoss & Tyler Winklevoss of Winklevoss Capital',\n            'duration': 771.301,\n            'view_count': int,\n        },\n    }, {\n        'url': 'https://original.livestream.com/newplay/folder?dirId=a07bf706-d0e4-4e75-a747-b021d84f2fd3',\n        'info_dict': {\n            'id': 'a07bf706-d0e4-4e75-a747-b021d84f2fd3',\n        },\n        'playlist_mincount': 4,\n    }, {\n        # live stream\n        'url': 'http://original.livestream.com/znsbahamas',\n        'only_matching': True,\n    }]\n\n    def _extract_video_info(self, user, video_id):\n        api_url = 'http://x%sx.api.channel.livestream.com/2.0/clipdetails?extendedInfo=true&id=%s' % (user, video_id)\n        info = self._download_xml(api_url, video_id)\n\n        item = info.find('channel').find('item')\n        title = xpath_text(item, 'title')\n        media_ns = {'media': 'http://search.yahoo.com/mrss'}\n        thumbnail_url = xpath_attr(\n            item, xpath_with_ns('media:thumbnail', media_ns), 'url')\n        duration = float_or_none(xpath_attr(\n            item, xpath_with_ns('media:content', media_ns), 'duration'))\n        ls_ns = {'ls': 'http://api.channel.livestream.com/2.0'}\n        view_count = int_or_none(xpath_text(\n            item, xpath_with_ns('ls:viewsCount', ls_ns)))\n\n        return {\n            'id': video_id,\n            'title': title,\n            'thumbnail': thumbnail_url,\n            'duration': duration,\n            'view_count': view_count,\n        }\n\n    def _extract_video_formats(self, video_data, video_id):\n        formats = []\n\n        progressive_url = video_data.get('progressiveUrl')\n        if progressive_url:\n            formats.append({\n                'url': progressive_url,\n                'format_id': 'http',\n            })\n\n        m3u8_url = video_data.get('httpUrl')\n        if m3u8_url:\n            formats.extend(self._extract_m3u8_formats(\n                m3u8_url, video_id, 'mp4', 'm3u8_native',\n                m3u8_id='hls', fatal=False))\n\n        rtsp_url = video_data.get('rtspUrl')\n        if rtsp_url:\n            formats.append({\n                'url': rtsp_url,\n                'format_id': 'rtsp',\n            })\n\n        self._sort_formats(formats)\n        return formats\n\n    def _extract_folder(self, url, folder_id):\n        webpage = self._download_webpage(url, folder_id)\n        paths = orderedSet(re.findall(\n            r'''(?x)(?:\n                <li\\s+class=\"folder\">\\s*<a\\s+href=\"|\n                <a\\s+href=\"(?=https?://livestre\\.am/)\n            )([^\"]+)\"''', webpage))\n\n        entries = [{\n            '_type': 'url',\n            'url': compat_urlparse.urljoin(url, p),\n        } for p in paths]\n\n        return self.playlist_result(entries, folder_id)\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        user = mobj.group('user')\n        url_type = mobj.group('type')\n        content_id = mobj.group('id')\n        if url_type == 'folder':\n            return self._extract_folder(url, content_id)\n        else:\n            # this url is used on mobile devices\n            stream_url = 'http://x%sx.api.channel.livestream.com/3.0/getstream.json' % user\n            info = {}\n            if content_id:\n                stream_url += '?id=%s' % content_id\n                info = self._extract_video_info(user, content_id)\n            else:\n                content_id = user\n                webpage = self._download_webpage(url, content_id)\n                info = {\n                    'title': self._og_search_title(webpage),\n                    'description': self._og_search_description(webpage),\n                    'thumbnail': self._search_regex(r'channelLogo\\.src\\s*=\\s*\"([^\"]+)\"', webpage, 'thumbnail', None),\n                }\n            video_data = self._download_json(stream_url, content_id)\n            is_live = video_data.get('isLive')\n            info.update({\n                'id': content_id,\n                'title': self._live_title(info['title']) if is_live else info['title'],\n                'formats': self._extract_video_formats(video_data, content_id),\n                'is_live': is_live,\n            })\n            return info\n\n\n# The server doesn't support HEAD request, the generic extractor can't detect\n# the redirection\nclass LivestreamShortenerIE(InfoExtractor):\n    IE_NAME = 'livestream:shortener'\n    IE_DESC = False  # Do not list\n    _VALID_URL = r'https?://livestre\\.am/(?P<id>.+)'\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        id = mobj.group('id')\n        webpage = self._download_webpage(url, id)\n\n        return {\n            '_type': 'url',\n            'url': self._og_search_url(webpage),\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "livestream.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/livestream.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}