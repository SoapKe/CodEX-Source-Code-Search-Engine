{"author": "ansible", "code": "\n# -*- coding: utf-8 -*-\n\n# (c) 2015, Matt Martz <matt@sivel.net>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = r'''\n---\nmodule: expect\nversion_added: '2.0'\nshort_description: Executes a command and responds to prompts.\ndescription:\n     - The C(expect) module executes a command and responds to prompts.\n     - The given command will be executed on all selected nodes. It will not be\n       processed through the shell, so variables like C($HOME) and operations\n       like C(\"<\"), C(\">\"), C(\"|\"), and C(\"&\") will not work.\noptions:\n  command:\n    description:\n      - The command module takes command to run.\n    required: true\n  creates:\n    description:\n      - A filename, when it already exists, this step will B(not) be run.\n  removes:\n    description:\n      - A filename, when it does not exist, this step will B(not) be run.\n  chdir:\n    description:\n      - Change into this directory before running the command.\n  responses:\n    description:\n      - Mapping of expected string/regex and string to respond with. If the\n        response is a list, successive matches return successive\n        responses. List functionality is new in 2.1.\n    required: true\n  timeout:\n    description:\n      - Amount of time in seconds to wait for the expected strings.\n    default: 30\n  echo:\n    description:\n      - Whether or not to echo out your response strings.\n    default: false\nrequirements:\n  - python >= 2.6\n  - pexpect >= 3.3\nnotes:\n  - If you want to run a command through the shell (say you are using C(<),\n    C(>), C(|), etc), you must specify a shell in the command such as\n    C(/bin/bash -c \"/path/to/something | grep else\").\n  - The question, or key, under I(responses) is a python regex match. Case\n    insensitive searches are indicated with a prefix of C(?i).\n  - By default, if a question is encountered multiple times, its string\n    response will be repeated. If you need different responses for successive\n    question matches, instead of a string response, use a list of strings as\n    the response. The list functionality is new in 2.1.\n  - The M(expect) module is designed for simple scenarios. For more complex\n    needs, consider the use of expect code with the M(shell) or M(script)\n    modules. (An example is part of the M(shell) module documentation)\nauthor: \"Matt Martz (@sivel)\"\n'''\n\nEXAMPLES = r'''\n- name: Case insensitve password string match\n  expect:\n    command: passwd username\n    responses:\n      (?i)password: \"MySekretPa$$word\"\n\n- name: Generic question with multiple different responses\n  expect:\n    command: /path/to/custom/command\n    responses:\n      Question:\n        - response1\n        - response2\n        - response3\n'''\n\nimport datetime\nimport os\nimport traceback\n\ntry:\n    import pexpect\n    HAS_PEXPECT = True\nexcept ImportError:\n    HAS_PEXPECT = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils._text import to_native, to_text\n\n\ndef response_closure(module, question, responses):\n    resp_gen = (u'%s\\n' % to_text(r).rstrip(u'\\n') for r in responses)\n\n    def wrapped(info):\n        try:\n            return next(resp_gen)\n        except StopIteration:\n            module.fail_json(msg=\"No remaining responses for '%s', \"\n                                 \"output was '%s'\" %\n                                 (question,\n                                  info['child_result_list'][-1]))\n\n    return wrapped\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            command=dict(required=True),\n            chdir=dict(type='path'),\n            creates=dict(type='path'),\n            removes=dict(type='path'),\n            responses=dict(type='dict', required=True),\n            timeout=dict(type='int', default=30),\n            echo=dict(type='bool', default=False),\n        )\n    )\n\n    if not HAS_PEXPECT:\n        module.fail_json(msg='The pexpect python module is required')\n\n    chdir = module.params['chdir']\n    args = module.params['command']\n    creates = module.params['creates']\n    removes = module.params['removes']\n    responses = module.params['responses']\n    timeout = module.params['timeout']\n    echo = module.params['echo']\n\n    events = dict()\n    for key, value in responses.items():\n        if isinstance(value, list):\n            response = response_closure(module, key, value)\n        else:\n            response = u'%s\\n' % to_text(value).rstrip(u'\\n')\n\n        events[to_text(key)] = response\n\n    if args.strip() == '':\n        module.fail_json(rc=256, msg=\"no command given\")\n\n    if chdir:\n        chdir = os.path.abspath(chdir)\n        os.chdir(chdir)\n\n    if creates:\n        \n        \n        \n        if os.path.exists(creates):\n            module.exit_json(\n                cmd=args,\n                stdout=\"skipped, since %s exists\" % creates,\n                changed=False,\n                rc=0\n            )\n\n    if removes:\n        \n        \n        \n        if not os.path.exists(removes):\n            module.exit_json(\n                cmd=args,\n                stdout=\"skipped, since %s does not exist\" % removes,\n                changed=False,\n                rc=0\n            )\n\n    startd = datetime.datetime.now()\n\n    try:\n        try:\n            \n            out, rc = pexpect.run(args, timeout=timeout, withexitstatus=True,\n                                  events=events, cwd=chdir, echo=echo,\n                                  encoding='utf-8')\n        except TypeError:\n            \n            out, rc = pexpect.runu(args, timeout=timeout, withexitstatus=True,\n                                   events=events, cwd=chdir, echo=echo)\n    except (TypeError, AttributeError) as e:\n        \n        \n        \n        \n        module.fail_json(msg='Insufficient version of pexpect installed '\n                             '(%s), this module requires pexpect>=3.3. '\n                             'Error was %s' % (pexpect.__version__, to_native(e)))\n    except pexpect.ExceptionPexpect as e:\n        module.fail_json(msg='%s' % to_native(e), exception=traceback.format_exc())\n\n    endd = datetime.datetime.now()\n    delta = endd - startd\n\n    if out is None:\n        out = ''\n\n    result = dict(\n        cmd=args,\n        stdout=out.rstrip('\\r\\n'),\n        rc=rc,\n        start=str(startd),\n        end=str(endd),\n        delta=str(delta),\n        changed=True,\n    )\n\n    if rc is None:\n        module.fail_json(msg='command exceeded timeout', **result)\n    elif rc != 0:\n        module.fail_json(msg='non-zero return code', **result)\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  expect version added   2 0  short description  executes command responds prompts  description         the c(expect) module executes command responds prompts         the given command executed selected nodes  it        processed shell  variables like c( home) operations        like c(   )  c(   )  c(   )  c(   ) work  options    command      description          the command module takes command run      required  true   creates      description          a filename  already exists  step b(not) run    removes      description          a filename  exist  step b(not) run    chdir      description          change directory running command    responses      description          mapping expected string regex string respond  if         response list  successive matches return successive         responses  list functionality new 2 1      required  true   timeout      description          amount time seconds wait expected strings      default  30   echo      description          whether echo response strings      default  false requirements      python    2 6     pexpect    3 3 notes      if want run command shell (say using c( )      c( )  c( )  etc)  must specify shell command     c( bin bash  c   path something   grep else )      the question  key  i(responses) python regex match  case     insensitive searches indicated prefix c( i)      by default  question encountered multiple times  string     response repeated  if need different responses successive     question matches  instead string response  use list strings     response  the list functionality new 2 1      the m(expect) module designed simple scenarios  for complex     needs  consider use expect code m(shell) m(script)     modules  (an example part m(shell) module documentation) author   matt martz ( sivel)       examples   r      name  case insensitve password string match   expect      command  passwd username     responses        ( i)password   mysekretpa  word     name  generic question multiple different responses   expect      command   path custom command     responses        question            response1           response2           response3         usr bin python        coding  utf 8        (c) 2015  matt martz  matt sivel net     gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    run command line contains creates filename    filename already exists   this allows idempotence    command executions     run command line contains removes filename    filename exist   this allows idempotence    command executions     prefer pexpect run pexpect  4    use pexpect runu pexpect  3 3  4    this catch insufficient versions pexpect    we deem insufficient lack ability specify    echo responses via run runu functions  would    potentially leak sensentive information ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# (c) 2015, Matt Martz <matt@sivel.net>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = r'''\n---\nmodule: expect\nversion_added: '2.0'\nshort_description: Executes a command and responds to prompts.\ndescription:\n     - The C(expect) module executes a command and responds to prompts.\n     - The given command will be executed on all selected nodes. It will not be\n       processed through the shell, so variables like C($HOME) and operations\n       like C(\"<\"), C(\">\"), C(\"|\"), and C(\"&\") will not work.\noptions:\n  command:\n    description:\n      - The command module takes command to run.\n    required: true\n  creates:\n    description:\n      - A filename, when it already exists, this step will B(not) be run.\n  removes:\n    description:\n      - A filename, when it does not exist, this step will B(not) be run.\n  chdir:\n    description:\n      - Change into this directory before running the command.\n  responses:\n    description:\n      - Mapping of expected string/regex and string to respond with. If the\n        response is a list, successive matches return successive\n        responses. List functionality is new in 2.1.\n    required: true\n  timeout:\n    description:\n      - Amount of time in seconds to wait for the expected strings.\n    default: 30\n  echo:\n    description:\n      - Whether or not to echo out your response strings.\n    default: false\nrequirements:\n  - python >= 2.6\n  - pexpect >= 3.3\nnotes:\n  - If you want to run a command through the shell (say you are using C(<),\n    C(>), C(|), etc), you must specify a shell in the command such as\n    C(/bin/bash -c \"/path/to/something | grep else\").\n  - The question, or key, under I(responses) is a python regex match. Case\n    insensitive searches are indicated with a prefix of C(?i).\n  - By default, if a question is encountered multiple times, its string\n    response will be repeated. If you need different responses for successive\n    question matches, instead of a string response, use a list of strings as\n    the response. The list functionality is new in 2.1.\n  - The M(expect) module is designed for simple scenarios. For more complex\n    needs, consider the use of expect code with the M(shell) or M(script)\n    modules. (An example is part of the M(shell) module documentation)\nauthor: \"Matt Martz (@sivel)\"\n'''\n\nEXAMPLES = r'''\n- name: Case insensitve password string match\n  expect:\n    command: passwd username\n    responses:\n      (?i)password: \"MySekretPa$$word\"\n\n- name: Generic question with multiple different responses\n  expect:\n    command: /path/to/custom/command\n    responses:\n      Question:\n        - response1\n        - response2\n        - response3\n'''\n\nimport datetime\nimport os\nimport traceback\n\ntry:\n    import pexpect\n    HAS_PEXPECT = True\nexcept ImportError:\n    HAS_PEXPECT = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils._text import to_native, to_text\n\n\ndef response_closure(module, question, responses):\n    resp_gen = (u'%s\\n' % to_text(r).rstrip(u'\\n') for r in responses)\n\n    def wrapped(info):\n        try:\n            return next(resp_gen)\n        except StopIteration:\n            module.fail_json(msg=\"No remaining responses for '%s', \"\n                                 \"output was '%s'\" %\n                                 (question,\n                                  info['child_result_list'][-1]))\n\n    return wrapped\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            command=dict(required=True),\n            chdir=dict(type='path'),\n            creates=dict(type='path'),\n            removes=dict(type='path'),\n            responses=dict(type='dict', required=True),\n            timeout=dict(type='int', default=30),\n            echo=dict(type='bool', default=False),\n        )\n    )\n\n    if not HAS_PEXPECT:\n        module.fail_json(msg='The pexpect python module is required')\n\n    chdir = module.params['chdir']\n    args = module.params['command']\n    creates = module.params['creates']\n    removes = module.params['removes']\n    responses = module.params['responses']\n    timeout = module.params['timeout']\n    echo = module.params['echo']\n\n    events = dict()\n    for key, value in responses.items():\n        if isinstance(value, list):\n            response = response_closure(module, key, value)\n        else:\n            response = u'%s\\n' % to_text(value).rstrip(u'\\n')\n\n        events[to_text(key)] = response\n\n    if args.strip() == '':\n        module.fail_json(rc=256, msg=\"no command given\")\n\n    if chdir:\n        chdir = os.path.abspath(chdir)\n        os.chdir(chdir)\n\n    if creates:\n        # do not run the command if the line contains creates=filename\n        # and the filename already exists.  This allows idempotence\n        # of command executions.\n        if os.path.exists(creates):\n            module.exit_json(\n                cmd=args,\n                stdout=\"skipped, since %s exists\" % creates,\n                changed=False,\n                rc=0\n            )\n\n    if removes:\n        # do not run the command if the line contains removes=filename\n        # and the filename does not exist.  This allows idempotence\n        # of command executions.\n        if not os.path.exists(removes):\n            module.exit_json(\n                cmd=args,\n                stdout=\"skipped, since %s does not exist\" % removes,\n                changed=False,\n                rc=0\n            )\n\n    startd = datetime.datetime.now()\n\n    try:\n        try:\n            # Prefer pexpect.run from pexpect>=4\n            out, rc = pexpect.run(args, timeout=timeout, withexitstatus=True,\n                                  events=events, cwd=chdir, echo=echo,\n                                  encoding='utf-8')\n        except TypeError:\n            # Use pexpect.runu in pexpect>=3.3,<4\n            out, rc = pexpect.runu(args, timeout=timeout, withexitstatus=True,\n                                   events=events, cwd=chdir, echo=echo)\n    except (TypeError, AttributeError) as e:\n        # This should catch all insufficient versions of pexpect\n        # We deem them insufficient for their lack of ability to specify\n        # to not echo responses via the run/runu functions, which would\n        # potentially leak sensentive information\n        module.fail_json(msg='Insufficient version of pexpect installed '\n                             '(%s), this module requires pexpect>=3.3. '\n                             'Error was %s' % (pexpect.__version__, to_native(e)))\n    except pexpect.ExceptionPexpect as e:\n        module.fail_json(msg='%s' % to_native(e), exception=traceback.format_exc())\n\n    endd = datetime.datetime.now()\n    delta = endd - startd\n\n    if out is None:\n        out = ''\n\n    result = dict(\n        cmd=args,\n        stdout=out.rstrip('\\r\\n'),\n        rc=rc,\n        start=str(startd),\n        end=str(endd),\n        delta=str(delta),\n        changed=True,\n    )\n\n    if rc is None:\n        module.fail_json(msg='command exceeded timeout', **result)\n    elif rc != 0:\n        module.fail_json(msg='non-zero return code', **result)\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "expect.py", "id": "2f91d08f6c4f294ace5528324863837e", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/commands/expect.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}