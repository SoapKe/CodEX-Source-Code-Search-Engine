{"author": "mitmproxy", "code": "\nclass LogEntry:\n    def __init__(self, msg, level):\n        self.msg = msg\n        self.level = level\n\n    def __eq__(self, other):\n        if isinstance(other, LogEntry):\n            return self.__dict__ == other.__dict__\n        return False\n\n    def __repr__(self):\n        return \"LogEntry({}, {})\".format(self.msg, self.level)\n\n\nclass Log:\n    \"\"\"\n        The central logger, exposed to scripts as mitmproxy.ctx.log.\n    \"\"\"\n    def __init__(self, master):\n        self.master = master\n\n    def debug(self, txt):\n        \"\"\"\n            Log with level debug.\n        \"\"\"\n        self(txt, \"debug\")\n\n    def info(self, txt):\n        \"\"\"\n            Log with level info.\n        \"\"\"\n        self(txt, \"info\")\n\n    def alert(self, txt):\n        \"\"\"\n            Log with level alert. Alerts have the same urgency as info, but\n            signals to interctive tools that the user's attention should be\n            drawn to the output even if they're not currently looking at the\n            event log.\n        \"\"\"\n        self(txt, \"alert\")\n\n    def warn(self, txt):\n        \"\"\"\n            Log with level warn.\n        \"\"\"\n        self(txt, \"warn\")\n\n    def error(self, txt):\n        \"\"\"\n            Log with level error.\n        \"\"\"\n        self(txt, \"error\")\n\n    def __call__(self, text, level=\"info\"):\n        self.master.add_log(text, level)\n\n\nLogTierOrder = [\n    \"error\",\n    \"warn\",\n    \"info\",\n    \"alert\",\n    \"debug\",\n]\n\n\ndef log_tier(level):\n    return dict(error=0, warn=1, info=2, alert=2, debug=3).get(level)\n", "comments": "            the central logger  exposed scripts mitmproxy ctx log              def   init  (self  master)          self master   master      def debug(self  txt)                          log level debug                      self(txt   debug )      def info(self  txt)                          log level info                      self(txt   info )      def alert(self  txt)                          log level alert  alerts urgency info              signals interctive tools user attention             drawn output even currently looking             event log                      self(txt   alert )      def warn(self  txt)                          log level warn                      self(txt   warn )      def error(self  txt)                          log level error              ", "content": "\nclass LogEntry:\n    def __init__(self, msg, level):\n        self.msg = msg\n        self.level = level\n\n    def __eq__(self, other):\n        if isinstance(other, LogEntry):\n            return self.__dict__ == other.__dict__\n        return False\n\n    def __repr__(self):\n        return \"LogEntry({}, {})\".format(self.msg, self.level)\n\n\nclass Log:\n    \"\"\"\n        The central logger, exposed to scripts as mitmproxy.ctx.log.\n    \"\"\"\n    def __init__(self, master):\n        self.master = master\n\n    def debug(self, txt):\n        \"\"\"\n            Log with level debug.\n        \"\"\"\n        self(txt, \"debug\")\n\n    def info(self, txt):\n        \"\"\"\n            Log with level info.\n        \"\"\"\n        self(txt, \"info\")\n\n    def alert(self, txt):\n        \"\"\"\n            Log with level alert. Alerts have the same urgency as info, but\n            signals to interctive tools that the user's attention should be\n            drawn to the output even if they're not currently looking at the\n            event log.\n        \"\"\"\n        self(txt, \"alert\")\n\n    def warn(self, txt):\n        \"\"\"\n            Log with level warn.\n        \"\"\"\n        self(txt, \"warn\")\n\n    def error(self, txt):\n        \"\"\"\n            Log with level error.\n        \"\"\"\n        self(txt, \"error\")\n\n    def __call__(self, text, level=\"info\"):\n        self.master.add_log(text, level)\n\n\nLogTierOrder = [\n    \"error\",\n    \"warn\",\n    \"info\",\n    \"alert\",\n    \"debug\",\n]\n\n\ndef log_tier(level):\n    return dict(error=0, warn=1, info=2, alert=2, debug=3).get(level)\n", "description": "An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers.", "file_name": "log.py", "id": "c6e306a84b2f25dcede12dc212360607", "language": "Python", "project_name": "mitmproxy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mitmproxy-mitmproxy/mitmproxy-mitmproxy-3c7725a/mitmproxy/log.py", "save_time": "", "source": "", "update_at": "2018-03-18T11:30:56Z", "url": "https://github.com/mitmproxy/mitmproxy", "wiki": false}