{"author": "openai", "code": "import logging\nimport os\nimport pytest\nimport re\n\nimport gym\nfrom universe import wrappers\nfrom universe.runtimes import registration\n\nlogger = logging.getLogger(__name__)\n\n\n\ntest_envs = [\n    \n    \n    'flashgames.DuskDrive-v0',\n    'internet.SlitherIO-v0',\n    \n]\n\n@pytest.mark.parametrize('env_id', test_envs)\ndef test_smoke(env_id):\n    \"\"\"Check that environments start up without errors and that we can extract rewards and observations\"\"\"\n    gym.undo_logger_setup()\n    logging.getLogger().setLevel(logging.INFO)\n\n    env = gym.make(env_id)\n    if env.metadata.get('configure.required', False):\n        if os.environ.get('FORCE_LATEST_UNIVERSE_DOCKER_RUNTIMES'):  \n            configure_with_latest_docker_runtime_tag(env)\n        else:\n            env.configure(remotes=1)\n\n    env = wrappers.Unvectorize(env)\n\n    env.reset()\n    _rollout(env, timestep_limit=60*30) \n\ndef _rollout(env, timestep_limit=None):\n    \"\"\"\n    Test that a rollout follows our desired format. Includes the following checks:\n\n    1. The environment resets and provides an observation within our timestep_limit\n    2. Done signals map to the following:\n\n        done=True => Episode over (sent once at end of episode)\n        done=None => Resetting, agent takes no actions until done=False again\n        done=False => Episode is running, agent should take actions\n    \"\"\"\n    count = 0\n    episode_state = \"resetting\"\n\n    while True:\n        obs, reward, done, info = env.step([])  \n        count += 1\n\n        if episode_state == 'resetting':\n            if done is None:  \n                assert obs is None\n                continue\n            elif done is False:\n                episode_state = 'running'\n\n        if episode_state == 'running':\n            assert done is False\n            assert isinstance(reward, float)\n            assert isinstance(done, bool), \"Received done=None before done=True\"\n            \n            if obs is not None:\n                assert obs['vision'].shape == (768, 1024, 3)\n            break\n\n        if timestep_limit is not None and count >= timestep_limit:\n            assert episode_state == 'running', \"Failed to finish resetting in timestep limit\"\n            break\n\n        \n        #     self.assertTrue(completed_full_episode, \"Failed to complete a full episode in timestep limit\")\n        \n\ndef configure_with_latest_docker_runtime_tag(env):\n    original_image = registration.runtime_spec(env.spec.tags['runtime']).image\n    latest_image = re.sub(r':.*', ':latest', original_image)\n    logger.info(\"Using latest image: {}\".format(latest_image))\n    env.configure(remotes=1, docker_image=latest_image)\n", "comments": "   check environments start without errors extract rewards observations        gym undo logger setup()     logging getlogger() setlevel(logging info)      env   gym make(env id)     env metadata get( configure required   false)          os environ get( force latest universe docker runtimes )     used test universe envs ci             configure latest docker runtime tag(env)         else              env configure(remotes 1)      env   wrappers unvectorize(env)      env reset()      rollout(env  timestep limit 60 30)   check rollout  def  rollout(env  timestep limit none)              test rollout follows desired format  includes following checks       1  the environment resets provides observation within timestep limit     2  done signals map following           done true    episode (sent end episode)         done none    resetting  agent takes actions done false         done false    episode running  agent take actions            choose sample category    todo  add comprehensive test runs envs     gym core pongshortsync v3       gym core cartpolelowdsync v0       wob dragbox v0      used test universe envs ci    check rollout    step noop action    still resetting    todo  remove none check fix done none semantics    timestep limit none count    timestep limit         self asserttrue(completed full episode   failed complete full episode timestep limit )        break ", "content": "import logging\nimport os\nimport pytest\nimport re\n\nimport gym\nfrom universe import wrappers\nfrom universe.runtimes import registration\n\nlogger = logging.getLogger(__name__)\n\n# Choose a sample from each category\n# TODO: Add more comprehensive test that runs all envs\ntest_envs = [\n    # 'gym-core.PongShortSync-v3',\n    # 'gym-core.CartPoleLowDSync-v0',\n    'flashgames.DuskDrive-v0',\n    'internet.SlitherIO-v0',\n    # 'wob.DragBox-v0',\n]\n\n@pytest.mark.parametrize('env_id', test_envs)\ndef test_smoke(env_id):\n    \"\"\"Check that environments start up without errors and that we can extract rewards and observations\"\"\"\n    gym.undo_logger_setup()\n    logging.getLogger().setLevel(logging.INFO)\n\n    env = gym.make(env_id)\n    if env.metadata.get('configure.required', False):\n        if os.environ.get('FORCE_LATEST_UNIVERSE_DOCKER_RUNTIMES'):  # Used to test universe-envs in CI\n            configure_with_latest_docker_runtime_tag(env)\n        else:\n            env.configure(remotes=1)\n\n    env = wrappers.Unvectorize(env)\n\n    env.reset()\n    _rollout(env, timestep_limit=60*30) # Check a rollout\n\ndef _rollout(env, timestep_limit=None):\n    \"\"\"\n    Test that a rollout follows our desired format. Includes the following checks:\n\n    1. The environment resets and provides an observation within our timestep_limit\n    2. Done signals map to the following:\n\n        done=True => Episode over (sent once at end of episode)\n        done=None => Resetting, agent takes no actions until done=False again\n        done=False => Episode is running, agent should take actions\n    \"\"\"\n    count = 0\n    episode_state = \"resetting\"\n\n    while True:\n        obs, reward, done, info = env.step([])  # Step with noop action\n        count += 1\n\n        if episode_state == 'resetting':\n            if done is None:  # Still resetting\n                assert obs is None\n                continue\n            elif done is False:\n                episode_state = 'running'\n\n        if episode_state == 'running':\n            assert done is False\n            assert isinstance(reward, float)\n            assert isinstance(done, bool), \"Received done=None before done=True\"\n            # TODO: Remove this None check after we fix done=None semantics\n            if obs is not None:\n                assert obs['vision'].shape == (768, 1024, 3)\n            break\n\n        if timestep_limit is not None and count >= timestep_limit:\n            assert episode_state == 'running', \"Failed to finish resetting in timestep limit\"\n            break\n\n        # if timestep_limit is not None and count >= timestep_limit:\n        #     self.assertTrue(completed_full_episode, \"Failed to complete a full episode in timestep limit\")\n        #     break\n\ndef configure_with_latest_docker_runtime_tag(env):\n    original_image = registration.runtime_spec(env.spec.tags['runtime']).image\n    latest_image = re.sub(r':.*', ':latest', original_image)\n    logger.info(\"Using latest image: {}\".format(latest_image))\n    env.configure(remotes=1, docker_image=latest_image)\n", "description": "Universe: a software platform for measuring and training an AI's general intelligence across the world's supply of games, websites and other applications.", "file_name": "test_envs.py", "id": "34ead314e9be685aeaca8daf0e9ea9f4", "language": "Python", "project_name": "universe", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/openai-universe/openai-universe-f95a5fe/tests/functional/test_envs.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:39:09Z", "url": "https://github.com/openai/universe", "wiki": true}