{"author": "NVIDIA", "code": "\"\"\"\nCopyright (C) 2018 NVIDIA Corporation.  All rights reserved.\nLicensed under the CC BY-NC-SA 4.0 license (https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode).\n\"\"\"\nfrom __future__ import division\nimport torch.nn as nn\nimport scipy.misc\nimport numpy as np\nimport scipy.sparse\nimport scipy.sparse.linalg\nfrom numpy.lib.stride_tricks import as_strided\n\nfrom PIL import Image\n\nclass Propagator(nn.Module):\n  def __init__(self, beta=0.9999):\n    super(Propagator, self).__init__()\n    self.beta = beta\n\n  def process(self, initImg, contentImg):\n    content = scipy.misc.imread(contentImg, mode='RGB')\n    B = scipy.misc.imread(initImg, mode='RGB').astype(np.float64)/255\n    h1,w1,k = B.shape\n    h = h1 - 4\n    w = w1 - 4\n    B = B[int((h1-h)/2):int((h1-h)/2+h),int((w1-w)/2):int((w1-w)/2+w),:]\n    content = scipy.misc.imresize(content,(h,w))\n    B = self.__replication_padding(B,2)\n    content = self.__replication_padding(content,2)\n    content = content.astype(np.float64)/255\n    B = np.reshape(B,(h1*w1,k))\n    W = self.__compute_laplacian(content)\n    W = W.tocsc()\n    dd = W.sum(0)\n    dd = np.sqrt(np.power(dd,-1))\n    dd = dd.A.squeeze()\n    D = scipy.sparse.csc_matrix((dd, (np.arange(0,w1*h1), np.arange(0,w1*h1)))) \n    S = D.dot(W).dot(D)\n    A = scipy.sparse.identity(w1*h1) - self.beta*S\n    A = A.tocsc()\n    solver = scipy.sparse.linalg.factorized(A)\n    V = np.zeros((h1*w1,k))\n    V[:,0] = solver(B[:,0])\n    V[:,1] = solver(B[:,1])\n    V[:,2] = solver(B[:,2])\n    V = V*(1-self.beta)\n    V = V.reshape(h1,w1,k)\n    V = V[2:2+h,2:2+w,:]\n    \n    img = Image.fromarray(np.uint8(np.clip(V * 255., 0, 255.)))\n    return img\n\n  \n  def __compute_laplacian(self, img, eps=10**(-7), win_rad=1):\n      win_size = (win_rad*2+1)**2\n      h, w, d = img.shape\n      c_h, c_w = h - 2*win_rad, w - 2*win_rad\n      win_diam = win_rad*2+1\n      indsM = np.arange(h*w).reshape((h, w))\n      ravelImg = img.reshape(h*w, d)\n      win_inds = self.__rolling_block(indsM, block=(win_diam, win_diam))\n      win_inds = win_inds.reshape(c_h, c_w, win_size)\n      winI = ravelImg[win_inds]\n      win_mu = np.mean(winI, axis=2, keepdims=True)\n      win_var = np.einsum('...ji,...jk ->...ik', winI, winI)/win_size - np.einsum('...ji,...jk ->...ik', win_mu, win_mu)\n      inv = np.linalg.inv(win_var + (eps/win_size)*np.eye(3))\n      X = np.einsum('...ij,...jk->...ik', winI - win_mu, inv)\n      vals = (1/win_size)*(1 + np.einsum('...ij,...kj->...ik', X, winI - win_mu))\n      nz_indsCol = np.tile(win_inds, win_size).ravel()\n      nz_indsRow = np.repeat(win_inds, win_size).ravel()\n      nz_indsVal = vals.ravel()\n      L = scipy.sparse.coo_matrix((nz_indsVal, (nz_indsRow, nz_indsCol)), shape=(h*w, h*w))\n      return L\n\n  def __replication_padding(self, arr,pad):\n      h,w,c = arr.shape\n      ans = np.zeros((h+pad*2,w+pad*2,c))\n      for i in range(c):\n          ans[:,:,i] = np.pad(arr[:,:,i],pad_width=(pad,pad),mode='edge')\n      return ans\n\n  def __rolling_block(self, A, block=(3, 3)):\n    shape = (A.shape[0] - block[0] + 1, A.shape[1] - block[1] + 1) + block\n    strides = (A.strides[0], A.strides[1]) + A.strides\n    return as_strided(A, shape=shape, strides=strides)", "comments": "    copyright (c) 2018 nvidia corporation   all rights reserved  licensed cc by nc sa 4 0 license (https   creativecommons org licenses nc sa 4 0 legalcode)         0 026    returns sparse matting laplacian ", "content": "\"\"\"\nCopyright (C) 2018 NVIDIA Corporation.  All rights reserved.\nLicensed under the CC BY-NC-SA 4.0 license (https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode).\n\"\"\"\nfrom __future__ import division\nimport torch.nn as nn\nimport scipy.misc\nimport numpy as np\nimport scipy.sparse\nimport scipy.sparse.linalg\nfrom numpy.lib.stride_tricks import as_strided\n\nfrom PIL import Image\n\nclass Propagator(nn.Module):\n  def __init__(self, beta=0.9999):\n    super(Propagator, self).__init__()\n    self.beta = beta\n\n  def process(self, initImg, contentImg):\n    content = scipy.misc.imread(contentImg, mode='RGB')\n    B = scipy.misc.imread(initImg, mode='RGB').astype(np.float64)/255\n    h1,w1,k = B.shape\n    h = h1 - 4\n    w = w1 - 4\n    B = B[int((h1-h)/2):int((h1-h)/2+h),int((w1-w)/2):int((w1-w)/2+w),:]\n    content = scipy.misc.imresize(content,(h,w))\n    B = self.__replication_padding(B,2)\n    content = self.__replication_padding(content,2)\n    content = content.astype(np.float64)/255\n    B = np.reshape(B,(h1*w1,k))\n    W = self.__compute_laplacian(content)\n    W = W.tocsc()\n    dd = W.sum(0)\n    dd = np.sqrt(np.power(dd,-1))\n    dd = dd.A.squeeze()\n    D = scipy.sparse.csc_matrix((dd, (np.arange(0,w1*h1), np.arange(0,w1*h1)))) # 0.026\n    S = D.dot(W).dot(D)\n    A = scipy.sparse.identity(w1*h1) - self.beta*S\n    A = A.tocsc()\n    solver = scipy.sparse.linalg.factorized(A)\n    V = np.zeros((h1*w1,k))\n    V[:,0] = solver(B[:,0])\n    V[:,1] = solver(B[:,1])\n    V[:,2] = solver(B[:,2])\n    V = V*(1-self.beta)\n    V = V.reshape(h1,w1,k)\n    V = V[2:2+h,2:2+w,:]\n    \n    img = Image.fromarray(np.uint8(np.clip(V * 255., 0, 255.)))\n    return img\n\n  # Returns sparse matting laplacian\n  def __compute_laplacian(self, img, eps=10**(-7), win_rad=1):\n      win_size = (win_rad*2+1)**2\n      h, w, d = img.shape\n      c_h, c_w = h - 2*win_rad, w - 2*win_rad\n      win_diam = win_rad*2+1\n      indsM = np.arange(h*w).reshape((h, w))\n      ravelImg = img.reshape(h*w, d)\n      win_inds = self.__rolling_block(indsM, block=(win_diam, win_diam))\n      win_inds = win_inds.reshape(c_h, c_w, win_size)\n      winI = ravelImg[win_inds]\n      win_mu = np.mean(winI, axis=2, keepdims=True)\n      win_var = np.einsum('...ji,...jk ->...ik', winI, winI)/win_size - np.einsum('...ji,...jk ->...ik', win_mu, win_mu)\n      inv = np.linalg.inv(win_var + (eps/win_size)*np.eye(3))\n      X = np.einsum('...ij,...jk->...ik', winI - win_mu, inv)\n      vals = (1/win_size)*(1 + np.einsum('...ij,...kj->...ik', X, winI - win_mu))\n      nz_indsCol = np.tile(win_inds, win_size).ravel()\n      nz_indsRow = np.repeat(win_inds, win_size).ravel()\n      nz_indsVal = vals.ravel()\n      L = scipy.sparse.coo_matrix((nz_indsVal, (nz_indsRow, nz_indsCol)), shape=(h*w, h*w))\n      return L\n\n  def __replication_padding(self, arr,pad):\n      h,w,c = arr.shape\n      ans = np.zeros((h+pad*2,w+pad*2,c))\n      for i in range(c):\n          ans[:,:,i] = np.pad(arr[:,:,i],pad_width=(pad,pad),mode='edge')\n      return ans\n\n  def __rolling_block(self, A, block=(3, 3)):\n    shape = (A.shape[0] - block[0] + 1, A.shape[1] - block[1] + 1) + block\n    strides = (A.strides[0], A.strides[1]) + A.strides\n    return as_strided(A, shape=shape, strides=strides)", "description": "Style transfer, deep learning, feature transform", "file_name": "photo_smooth.py", "id": "7edfbf5220181669fc46146f8354aa12", "language": "Python", "project_name": "FastPhotoStyle", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/NVIDIA-FastPhotoStyle/NVIDIA-FastPhotoStyle-208d4f6/photo_smooth.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:35:44Z", "url": "https://github.com/NVIDIA/FastPhotoStyle", "wiki": true}