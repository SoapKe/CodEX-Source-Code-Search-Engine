{"author": "USArmyResearchLab", "code": "\n\n\nimport sys\nimport dpkt\nimport struct\nimport pcap\nimport socket\nimport time\nfrom Crypto.Random import random\nfrom Crypto.Hash import SHA\nfrom output import PCAPWriter\nfrom util import getopts\n\n\ndef hashaddr(addr, *extra):\n    # hash key+address plus any extra data (ports if flow)\n    global key, , ip_mask\n    sha = SHA.new(key + addr)\n    for e in extra:\n        sha.update(str(extra))\n    # take len(addr) octets of digest as address, to int, mask, or with range,\n    \n    return inttoip((iptoint(sha.digest()[0:len(addr)]) & ip_mask) | )\n\n\ndef mangleMAC(addr):\n    global zero_mac\n    if zero_mac:\n        return \"\\x00\\x00\\x00\\x00\\x00\\x00\"\n    if addr in emap:\n        return emap[addr]\n    haddr = None\n    if addr == \"\\x00\\x00\\x00\\x00\\x00\\x00\":\n        haddr = addr  \n    if ord(addr[0]) & 0x01:\n        haddr = addr  \n    if not haddr:\n        haddr = hashaddr(addr)\n        # return hash bytes with first byte set to xxxxxx10 (LAA unicast)\n        haddr = chr(ord(haddr[0]) & 0xfc | 0x2) + haddr[1:6]\n    emap[addr] = haddr\n    return haddr\n\n\ndef mangleIP(addr, *ports):  \n    global exclude, exclude_port, anon_all, by_flow\n    haddr = None\n    intip = iptoint(addr)\n    if len(addr) == 4 and intip >= 0xE0000000:\n        haddr = addr  \n    ip = iptoa(addr)\n    \n    if not anon_all and (ip.startswith('127.')\n                         or ip.startswith('10.')\n                         or ip.startswith('172.16.')\n                         or ip.startswith('192.168.')\n                         or ip.startswith('169.254.')):\n                    haddr = addr\n    \n    for x in exclude:\n        if ip.startswith(x):\n            haddr = addr\n    if ports and ports[0] in exclude_port:\n        haddr = addr  \n    if not haddr:\n        if by_flow:\n            \n            haddr = hashaddr(addr, *ports)\n        else:\n            haddr = hashaddr(addr)\n    return haddr\n\n\ndef mangleIPs(src, dst, sport, dport):\n    if by_flow:  \n        if (src, sport, dst, dport) in ipmap:\n            src, dst = ipmap[(src, sport, dst, dport)]\n        elif (dst, dport, src, sport) in ipmap:\n            \n            dst, src = ipmap[(dst, dport, src, sport)]\n        else:\n            src, dst = ipmap.setdefault(\n                (src, sport, dst, dport), (mangleIP(src, sport, dport), mangleIP(dst, dport, sport)))\n    else:\n        if src in ipmap:\n            src = ipmap[src]\n        else:\n            src = ipmap.setdefault(src, mangleIP(src, sport))\n        if dst in ipmap:\n            dst = ipmap[dst]\n        else:\n            dst = ipmap.setdefault(dst, mangleIP(dst, dport))\n    return src, dst\n\n\ndef mactoa(addr):\n    return ':'.join(['%02x' % b for b in struct.unpack('6B', addr)])\n\n\ndef iptoa(addr):\n    if len(addr) is 16:\n        return socket.inet_ntop(socket.AF_INET6, addr)\n    else:\n        return socket.inet_ntop(socket.AF_INET, addr)\n\n\ndef iptoint(addr):\n    if len(addr) is 16:  \n        ip = struct.unpack('!IIII', addr)\n        return ip[0] << 96 | ip[1] << 64 | ip[2] << 32 | ip[3]\n    else:\n        return struct.unpack('!I', addr)[0]  \n\n\ndef inttoip(l):\n    if l > 0xffffffff:  \n        return struct.pack('!IIII', l >> 96, l >> 64 & 0xffffffff, l >> 32 & 0xffffffff, l & 0xffffffff)\n    else:\n        return struct.pack('!I', l)\n\n\ndef pcap_handler(ts, pktdata):\n    global init_ts, start_ts, replace_ts, by_flow, anon_mac, zero_mac\n    if not init_ts:\n        init_ts = ts\n    if replace_ts:\n        ts = start_ts + (ts - init_ts)  \n    try:\n        pkt = dpkt.ethernet.Ethernet(pktdata)\n        if anon_mac or zero_mac:\n            pkt.src = mangleMAC(pkt.src)\n            pkt.dst = mangleMAC(pkt.dst)\n        if pkt.type == dpkt.ethernet.ETH_TYPE_IP:\n            try:\n                ?\n                sport, dport = pkt.data.data.sport, pkt.data.data.dport\n            except:\n                sport = dport = None  \n            pkt.data.src, pkt.data.dst = mangleIPs(\n                pkt.data.src, pkt.data.dst, sport, dport)\n        pktdata = str(pkt)\n    except Exception, e:\n        print e\n    out.write(len(pktdata), pktdata, ts)\n\nif __name__ == '__main__':\n\n    global key, init_ts, start_ts, replace_ts, by_flow, anon_mac, zero_mac, exclude, exclude_port, anon_all, , ip_mask\n    opts, args = getopts(sys.argv[1:], 'i:aezftx:p:rk:', [\n                         'ip=', 'all', 'ether', 'zero', 'flow', 'ts', 'exclude=', 'random', 'key=', 'port='], ['-x', '--exclude', '-p', '--port'])\n\n    if '-r' in opts or '--random' in opts:\n        key = random.long_to_bytes(random.getrandbits(64), 8)\n    else:\n        key = ''\n    key = opts.get('-k', opts.get('--key', key))\n\n     = opts.get('-i', opts.get('--ip', '0.0.0.0'))\n    ip_mask = 0  \n    ipr = ''\n    for o in map(int, .split('.')):\n        ipr += chr(o)\n        ip_mask <<= 8  \n        if not o:\n            ip_mask |= 0xff  \n     = iptoint(ipr)  |\n\n    replace_ts = '-t' in opts or '--ts' in opts\n    by_flow = '-f' in opts or '--flow' in opts\n    anon_mac = '-e' in opts or '--ether' in opts\n    zero_mac = '-z' in opts or '--zero' in opts\n    anon_all = '-a' in opts or '--all' in opts\n\n    start_ts = time.time()\n    init_ts = None\n\n    exclude = opts.get('-x', [])\n    exclude.extend(opts.get('--exclude', []))\n\n    exclude_port = map(int, opts.get('-p', []))\n    exclude_port.extend(map(int, opts.get('--port', [])))\n\n    emap = {}\n    ipmap = {}\n\n    if len(args) < 2:\n        print \"usage: pcapanon.py [options] <in-pcap [in-pcap]...> <out-pcap> > mapping.csv\\nOptions:\\n\\t[-i/--ip range]\\n\\t[-r/--random | -k/--key 'salt' ]\\n\\t[-a/--all] [-t/--ts] [-f/--flow]\\n\\t[-e/--ether | -z/--zero]\\n\\t[-x/--exclude pattern...]\\n\\t[-p/--port list...]\"\n        print \"Will anonymize all non-reserved IPs to be in range specified by -i/--ip option,\"\n        print \"\\tnonzero range octets are copied to anonymized address,\\n\\t(default range is 0.0.0.0 for fully random IPs)\"\n        print \"CSV output maps original to anonymized addresses\"\n        print \"By default anonymization will use a straight SHA1 hash of the address\"\n        print \"\\t***this is crackable as mapping is always the same***\".upper()\n        print \"Use -r/--random to generate a random salt (cannot easily reverse without knowing map)\"\n        print \"\\tor use -k/--key 'salt' (will generate same mapping given same salt),\"\n        print \"-f/--flows will anonymize by flow (per source:port<->dest:port tuples)\"\n        print \"-a/--all will also anonymize reserved IPs\"\n        print \"-x/--exclude will leave IPs starting with pattern unchanged\"\n        print \"-p/--port port will leave IP unchanged if port is in list\"\n        print \"-t/--ts will replace timestamp of first packet with time pcapanon was run,\\n\\tsubsequent packets will preserve delta from initial ts\"\n        print \"-e/--ether will also anonymize non-broadcast MAC addresses\"\n        print \"-z/--zero will zero all MAC addresses\"\n        sys.exit(0)\n\n    out = PCAPWriter(args[-1])\n    print '#file, packets'\n    for f in args[0:-1]:\n        p = 0\n        cap = pcap.pcap(f)\n        while cap.dispatch(1, pcap_handler):\n            p += 1  \n        del cap\n        print '%s,%s' % (f, p)\n    out.close()\n\n    print \"#type,is-anonymized, original, anonymized\"\n    for ia, oa in sorted(emap.items()):\n        print 'ether,%d, %s, %s' % (int(not ia == oa), mactoa(ia), mactoa(oa))\n    for ia, oa in sorted(ipmap.items()):\n        if by_flow:\n            sip, sp, dip, dp = ia\n            osip, odip = oa\n            print \"flow,%d, %s:%s,%s:%s, %s:%s,%s:%s\" % (int(sip != osip or dip != odip), iptoa(sip), sp, iptoa(dip), dp, iptoa(osip), sp, iptoa(odip), dp)\n        else:\n            print 'ip,%d, %s, %s' % (int(ia != oa), iptoa(ia), iptoa(oa))\n", "comments": "    created feb 6  2012   author  tparker         usr bin env python    hash key address plus extra data (ports flow)    take len(addr) octets digest address  int  mask  range     back octets    return null mac    mac 0x800000000000    broadcast addr  touch    return hash bytes first byte set xxxxxx10 (laa unicast)    addr extra port port    pass multicast 224 x x x higher    pass 127 x x x  iana reserved  autoconfig ranges    pass ips matching exclude    port exclude    use ports flow  else use ip    flow  hash addresses ports    make sure reverse flow maps    ipv6 long    ip int    ipv6    replace timestamps    tcp udp     nope    bitmask hashed address    shift 8 bits    set octet mask 0xff ip range octet zero    convert int value hash mask ip range    process whole file ", "content": "#!/usr/bin/env python\n'''\nCreated on Feb 6, 2012\n\n@author: tparker\n'''\n\nimport sys\nimport dpkt\nimport struct\nimport pcap\nimport socket\nimport time\nfrom Crypto.Random import random\nfrom Crypto.Hash import SHA\nfrom output import PCAPWriter\nfrom util import getopts\n\n\ndef hashaddr(addr, *extra):\n    # hash key+address plus any extra data (ports if flow)\n    global key, ip_range, ip_mask\n    sha = SHA.new(key + addr)\n    for e in extra:\n        sha.update(str(extra))\n    # take len(addr) octets of digest as address, to int, mask, or with range,\n    # back to octets\n    return inttoip((iptoint(sha.digest()[0:len(addr)]) & ip_mask) | ip_range)\n\n\ndef mangleMAC(addr):\n    global zero_mac\n    if zero_mac:\n        return \"\\x00\\x00\\x00\\x00\\x00\\x00\"\n    if addr in emap:\n        return emap[addr]\n    haddr = None\n    if addr == \"\\x00\\x00\\x00\\x00\\x00\\x00\":\n        haddr = addr  # return null MAC\n    if ord(addr[0]) & 0x01:\n        haddr = addr  # mac&0x800000000000 == broadcast addr, do not touch\n    if not haddr:\n        haddr = hashaddr(addr)\n        # return hash bytes with first byte set to xxxxxx10 (LAA unicast)\n        haddr = chr(ord(haddr[0]) & 0xfc | 0x2) + haddr[1:6]\n    emap[addr] = haddr\n    return haddr\n\n\ndef mangleIP(addr, *ports):  # addr,extra=our_port,other_port\n    global exclude, exclude_port, anon_all, by_flow\n    haddr = None\n    intip = iptoint(addr)\n    if len(addr) == 4 and intip >= 0xE0000000:\n        haddr = addr  # pass multicast 224.x.x.x and higher\n    ip = iptoa(addr)\n    # pass 127.x.x.x, IANA reserved, and autoconfig ranges\n    if not anon_all and (ip.startswith('127.')\n                         or ip.startswith('10.')\n                         or ip.startswith('172.16.')\n                         or ip.startswith('192.168.')\n                         or ip.startswith('169.254.')):\n                    haddr = addr\n    # pass ips matching exclude\n    for x in exclude:\n        if ip.startswith(x):\n            haddr = addr\n    if ports and ports[0] in exclude_port:\n        haddr = addr  # if our port is exclude\n    if not haddr:\n        if by_flow:\n            # use ports if by flow, else just use ip\n            haddr = hashaddr(addr, *ports)\n        else:\n            haddr = hashaddr(addr)\n    return haddr\n\n\ndef mangleIPs(src, dst, sport, dport):\n    if by_flow:  # if by flow, hash addresses with s/d ports\n        if (src, sport, dst, dport) in ipmap:\n            src, dst = ipmap[(src, sport, dst, dport)]\n        elif (dst, dport, src, sport) in ipmap:\n            # make sure reverse flow maps same\n            dst, src = ipmap[(dst, dport, src, sport)]\n        else:\n            src, dst = ipmap.setdefault(\n                (src, sport, dst, dport), (mangleIP(src, sport, dport), mangleIP(dst, dport, sport)))\n    else:\n        if src in ipmap:\n            src = ipmap[src]\n        else:\n            src = ipmap.setdefault(src, mangleIP(src, sport))\n        if dst in ipmap:\n            dst = ipmap[dst]\n        else:\n            dst = ipmap.setdefault(dst, mangleIP(dst, dport))\n    return src, dst\n\n\ndef mactoa(addr):\n    return ':'.join(['%02x' % b for b in struct.unpack('6B', addr)])\n\n\ndef iptoa(addr):\n    if len(addr) is 16:\n        return socket.inet_ntop(socket.AF_INET6, addr)\n    else:\n        return socket.inet_ntop(socket.AF_INET, addr)\n\n\ndef iptoint(addr):\n    if len(addr) is 16:  # ipv6 to long\n        ip = struct.unpack('!IIII', addr)\n        return ip[0] << 96 | ip[1] << 64 | ip[2] << 32 | ip[3]\n    else:\n        return struct.unpack('!I', addr)[0]  # ip to int\n\n\ndef inttoip(l):\n    if l > 0xffffffff:  # ipv6\n        return struct.pack('!IIII', l >> 96, l >> 64 & 0xffffffff, l >> 32 & 0xffffffff, l & 0xffffffff)\n    else:\n        return struct.pack('!I', l)\n\n\ndef pcap_handler(ts, pktdata):\n    global init_ts, start_ts, replace_ts, by_flow, anon_mac, zero_mac\n    if not init_ts:\n        init_ts = ts\n    if replace_ts:\n        ts = start_ts + (ts - init_ts)  # replace timestamps\n    try:\n        pkt = dpkt.ethernet.Ethernet(pktdata)\n        if anon_mac or zero_mac:\n            pkt.src = mangleMAC(pkt.src)\n            pkt.dst = mangleMAC(pkt.dst)\n        if pkt.type == dpkt.ethernet.ETH_TYPE_IP:\n            try:\n                # TCP or UDP?\n                sport, dport = pkt.data.data.sport, pkt.data.data.dport\n            except:\n                sport = dport = None  # nope\n            pkt.data.src, pkt.data.dst = mangleIPs(\n                pkt.data.src, pkt.data.dst, sport, dport)\n        pktdata = str(pkt)\n    except Exception, e:\n        print e\n    out.write(len(pktdata), pktdata, ts)\n\nif __name__ == '__main__':\n\n    global key, init_ts, start_ts, replace_ts, by_flow, anon_mac, zero_mac, exclude, exclude_port, anon_all, ip_range, ip_mask\n    opts, args = getopts(sys.argv[1:], 'i:aezftx:p:rk:', [\n                         'ip=', 'all', 'ether', 'zero', 'flow', 'ts', 'exclude=', 'random', 'key=', 'port='], ['-x', '--exclude', '-p', '--port'])\n\n    if '-r' in opts or '--random' in opts:\n        key = random.long_to_bytes(random.getrandbits(64), 8)\n    else:\n        key = ''\n    key = opts.get('-k', opts.get('--key', key))\n\n    ip_range = opts.get('-i', opts.get('--ip', '0.0.0.0'))\n    ip_mask = 0  # bitmask for hashed address\n    ipr = ''\n    for o in map(int, ip_range.split('.')):\n        ipr += chr(o)\n        ip_mask <<= 8  # shift by 8 bits\n        if not o:\n            ip_mask |= 0xff  # set octet mask to 0xff if ip_range octet is zero\n    ip_range = iptoint(ipr)  # convert to int value for hash&mask|ip_range\n\n    replace_ts = '-t' in opts or '--ts' in opts\n    by_flow = '-f' in opts or '--flow' in opts\n    anon_mac = '-e' in opts or '--ether' in opts\n    zero_mac = '-z' in opts or '--zero' in opts\n    anon_all = '-a' in opts or '--all' in opts\n\n    start_ts = time.time()\n    init_ts = None\n\n    exclude = opts.get('-x', [])\n    exclude.extend(opts.get('--exclude', []))\n\n    exclude_port = map(int, opts.get('-p', []))\n    exclude_port.extend(map(int, opts.get('--port', [])))\n\n    emap = {}\n    ipmap = {}\n\n    if len(args) < 2:\n        print \"usage: pcapanon.py [options] <in-pcap [in-pcap]...> <out-pcap> > mapping.csv\\nOptions:\\n\\t[-i/--ip range]\\n\\t[-r/--random | -k/--key 'salt' ]\\n\\t[-a/--all] [-t/--ts] [-f/--flow]\\n\\t[-e/--ether | -z/--zero]\\n\\t[-x/--exclude pattern...]\\n\\t[-p/--port list...]\"\n        print \"Will anonymize all non-reserved IPs to be in range specified by -i/--ip option,\"\n        print \"\\tnonzero range octets are copied to anonymized address,\\n\\t(default range is 0.0.0.0 for fully random IPs)\"\n        print \"CSV output maps original to anonymized addresses\"\n        print \"By default anonymization will use a straight SHA1 hash of the address\"\n        print \"\\t***this is crackable as mapping is always the same***\".upper()\n        print \"Use -r/--random to generate a random salt (cannot easily reverse without knowing map)\"\n        print \"\\tor use -k/--key 'salt' (will generate same mapping given same salt),\"\n        print \"-f/--flows will anonymize by flow (per source:port<->dest:port tuples)\"\n        print \"-a/--all will also anonymize reserved IPs\"\n        print \"-x/--exclude will leave IPs starting with pattern unchanged\"\n        print \"-p/--port port will leave IP unchanged if port is in list\"\n        print \"-t/--ts will replace timestamp of first packet with time pcapanon was run,\\n\\tsubsequent packets will preserve delta from initial ts\"\n        print \"-e/--ether will also anonymize non-broadcast MAC addresses\"\n        print \"-z/--zero will zero all MAC addresses\"\n        sys.exit(0)\n\n    out = PCAPWriter(args[-1])\n    print '#file, packets'\n    for f in args[0:-1]:\n        p = 0\n        cap = pcap.pcap(f)\n        while cap.dispatch(1, pcap_handler):\n            p += 1  # process whole file\n        del cap\n        print '%s,%s' % (f, p)\n    out.close()\n\n    print \"#type,is-anonymized, original, anonymized\"\n    for ia, oa in sorted(emap.items()):\n        print 'ether,%d, %s, %s' % (int(not ia == oa), mactoa(ia), mactoa(oa))\n    for ia, oa in sorted(ipmap.items()):\n        if by_flow:\n            sip, sp, dip, dp = ia\n            osip, odip = oa\n            print \"flow,%d, %s:%s,%s:%s, %s:%s,%s:%s\" % (int(sip != osip or dip != odip), iptoa(sip), sp, iptoa(dip), dp, iptoa(osip), sp, iptoa(odip), dp)\n        else:\n            print 'ip,%d, %s, %s' % (int(ia != oa), iptoa(ia), iptoa(oa))\n", "description": "Dshell is a network forensic analysis framework.", "file_name": "pcapanon.py", "id": "99e2a056fbd0d27e0da22e4672fc51d5", "language": "Python", "project_name": "Dshell", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/USArmyResearchLab-Dshell/USArmyResearchLab-Dshell-5850adf/bin/pcapanon.py", "save_time": "", "source": "", "update_at": "2018-03-18T10:01:29Z", "url": "https://github.com/USArmyResearchLab/Dshell", "wiki": true}