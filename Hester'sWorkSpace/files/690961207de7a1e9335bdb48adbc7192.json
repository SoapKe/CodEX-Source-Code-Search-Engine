{"author": "apache", "code": "# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nfrom email.mime.application import MIMEApplication\nfrom email.mime.multipart import MIMEMultipart\nimport logging\nimport tempfile\nimport unittest\n\nimport mock\n\nfrom superset import app, utils\n\nsend_email_test = mock.Mock()\n\n\nclass EmailSmtpTest(unittest.TestCase):\n    def setUp(self):\n        app.config['smtp_ssl'] = False\n\n    @mock.patch('superset.utils.send_MIME_email')\n    def test_send_smtp(self, mock_send_mime):\n        attachment = tempfile.NamedTemporaryFile()\n        attachment.write(b'attachment')\n        attachment.seek(0)\n        utils.send_email_smtp(\n            'to', 'subject', 'content', app.config, files=[attachment.name])\n        assert mock_send_mime.called\n        call_args = mock_send_mime.call_args[0]\n        logging.debug(call_args)\n        assert call_args[0] == app.config.get('SMTP_MAIL_FROM')\n        assert call_args[1] == ['to']\n        msg = call_args[2]\n        assert msg['Subject'] == 'subject'\n        assert msg['From'] == app.config.get('SMTP_MAIL_FROM')\n        assert len(msg.get_payload()) == 2\n        mimeapp = MIMEApplication('attachment')\n        assert msg.get_payload()[-1].get_payload() == mimeapp.get_payload()\n\n    @mock.patch('superset.utils.send_MIME_email')\n    def test_send_bcc_smtp(self, mock_send_mime):\n        attachment = tempfile.NamedTemporaryFile()\n        attachment.write(b'attachment')\n        attachment.seek(0)\n        utils.send_email_smtp(\n            'to', 'subject', 'content', app.config, files=[attachment.name],\n            cc='cc', bcc='bcc')\n        assert mock_send_mime.called\n        call_args = mock_send_mime.call_args[0]\n        assert call_args[0] == app.config.get('SMTP_MAIL_FROM')\n        assert call_args[1] == ['to', 'cc', 'bcc']\n        msg = call_args[2]\n        assert msg['Subject'] == 'subject'\n        assert msg['From'] == app.config.get('SMTP_MAIL_FROM')\n        assert len(msg.get_payload()) == 2\n        mimeapp = MIMEApplication('attachment')\n        assert msg.get_payload()[-1].get_payload() == mimeapp.get_payload()\n\n    @mock.patch('smtplib.SMTP_SSL')\n    @mock.patch('smtplib.SMTP')\n    def test_send_mime(self, mock_smtp, mock_smtp_ssl):\n        mock_smtp.return_value = mock.Mock()\n        mock_smtp_ssl.return_value = mock.Mock()\n        msg = MIMEMultipart()\n        utils.send_MIME_email('from', 'to', msg, app.config, dryrun=False)\n        mock_smtp.assert_called_with(\n            app.config.get('SMTP_HOST'),\n            app.config.get('SMTP_PORT'),\n        )\n        assert mock_smtp.return_value.starttls.called\n        mock_smtp.return_value.login.assert_called_with(\n            app.config.get('SMTP_USER'),\n            app.config.get('SMTP_PASSWORD'),\n        )\n        mock_smtp.return_value.sendmail.assert_called_with(\n            'from', 'to', msg.as_string())\n        assert mock_smtp.return_value.quit.called\n\n    @mock.patch('smtplib.SMTP_SSL')\n    @mock.patch('smtplib.SMTP')\n    def test_send_mime_ssl(self, mock_smtp, mock_smtp_ssl):\n        app.config['SMTP_SSL'] = True\n        mock_smtp.return_value = mock.Mock()\n        mock_smtp_ssl.return_value = mock.Mock()\n        utils.send_MIME_email(\n            'from', 'to', MIMEMultipart(), app.config, dryrun=False)\n        assert not mock_smtp.called\n        mock_smtp_ssl.assert_called_with(\n            app.config.get('SMTP_HOST'),\n            app.config.get('SMTP_PORT'),\n        )\n\n    @mock.patch('smtplib.SMTP_SSL')\n    @mock.patch('smtplib.SMTP')\n    def test_send_mime_noauth(self, mock_smtp, mock_smtp_ssl):\n        app.config['SMTP_USER'] = None\n        app.config['SMTP_PASSWORD'] = None\n        mock_smtp.return_value = mock.Mock()\n        mock_smtp_ssl.return_value = mock.Mock()\n        utils.send_MIME_email(\n            'from', 'to', MIMEMultipart(), app.config, dryrun=False)\n        assert not mock_smtp_ssl.called\n        mock_smtp.assert_called_with(\n            app.config.get('SMTP_HOST'),\n            app.config.get('SMTP_PORT'),\n        )\n        assert not mock_smtp.login.called\n\n    @mock.patch('smtplib.SMTP_SSL')\n    @mock.patch('smtplib.SMTP')\n    def test_send_mime_dryrun(self, mock_smtp, mock_smtp_ssl):\n        utils.send_MIME_email(\n            'from', 'to', MIMEMultipart(), app.config, dryrun=True)\n        assert not mock_smtp.called\n        assert not mock_smtp_ssl.called\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "comments": "   unit tests email service superset           coding  utf 8     ", "content": "# -*- coding: utf-8 -*-\n\"\"\"Unit tests for email service in Superset\"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nfrom email.mime.application import MIMEApplication\nfrom email.mime.multipart import MIMEMultipart\nimport logging\nimport tempfile\nimport unittest\n\nimport mock\n\nfrom superset import app, utils\n\nsend_email_test = mock.Mock()\n\n\nclass EmailSmtpTest(unittest.TestCase):\n    def setUp(self):\n        app.config['smtp_ssl'] = False\n\n    @mock.patch('superset.utils.send_MIME_email')\n    def test_send_smtp(self, mock_send_mime):\n        attachment = tempfile.NamedTemporaryFile()\n        attachment.write(b'attachment')\n        attachment.seek(0)\n        utils.send_email_smtp(\n            'to', 'subject', 'content', app.config, files=[attachment.name])\n        assert mock_send_mime.called\n        call_args = mock_send_mime.call_args[0]\n        logging.debug(call_args)\n        assert call_args[0] == app.config.get('SMTP_MAIL_FROM')\n        assert call_args[1] == ['to']\n        msg = call_args[2]\n        assert msg['Subject'] == 'subject'\n        assert msg['From'] == app.config.get('SMTP_MAIL_FROM')\n        assert len(msg.get_payload()) == 2\n        mimeapp = MIMEApplication('attachment')\n        assert msg.get_payload()[-1].get_payload() == mimeapp.get_payload()\n\n    @mock.patch('superset.utils.send_MIME_email')\n    def test_send_bcc_smtp(self, mock_send_mime):\n        attachment = tempfile.NamedTemporaryFile()\n        attachment.write(b'attachment')\n        attachment.seek(0)\n        utils.send_email_smtp(\n            'to', 'subject', 'content', app.config, files=[attachment.name],\n            cc='cc', bcc='bcc')\n        assert mock_send_mime.called\n        call_args = mock_send_mime.call_args[0]\n        assert call_args[0] == app.config.get('SMTP_MAIL_FROM')\n        assert call_args[1] == ['to', 'cc', 'bcc']\n        msg = call_args[2]\n        assert msg['Subject'] == 'subject'\n        assert msg['From'] == app.config.get('SMTP_MAIL_FROM')\n        assert len(msg.get_payload()) == 2\n        mimeapp = MIMEApplication('attachment')\n        assert msg.get_payload()[-1].get_payload() == mimeapp.get_payload()\n\n    @mock.patch('smtplib.SMTP_SSL')\n    @mock.patch('smtplib.SMTP')\n    def test_send_mime(self, mock_smtp, mock_smtp_ssl):\n        mock_smtp.return_value = mock.Mock()\n        mock_smtp_ssl.return_value = mock.Mock()\n        msg = MIMEMultipart()\n        utils.send_MIME_email('from', 'to', msg, app.config, dryrun=False)\n        mock_smtp.assert_called_with(\n            app.config.get('SMTP_HOST'),\n            app.config.get('SMTP_PORT'),\n        )\n        assert mock_smtp.return_value.starttls.called\n        mock_smtp.return_value.login.assert_called_with(\n            app.config.get('SMTP_USER'),\n            app.config.get('SMTP_PASSWORD'),\n        )\n        mock_smtp.return_value.sendmail.assert_called_with(\n            'from', 'to', msg.as_string())\n        assert mock_smtp.return_value.quit.called\n\n    @mock.patch('smtplib.SMTP_SSL')\n    @mock.patch('smtplib.SMTP')\n    def test_send_mime_ssl(self, mock_smtp, mock_smtp_ssl):\n        app.config['SMTP_SSL'] = True\n        mock_smtp.return_value = mock.Mock()\n        mock_smtp_ssl.return_value = mock.Mock()\n        utils.send_MIME_email(\n            'from', 'to', MIMEMultipart(), app.config, dryrun=False)\n        assert not mock_smtp.called\n        mock_smtp_ssl.assert_called_with(\n            app.config.get('SMTP_HOST'),\n            app.config.get('SMTP_PORT'),\n        )\n\n    @mock.patch('smtplib.SMTP_SSL')\n    @mock.patch('smtplib.SMTP')\n    def test_send_mime_noauth(self, mock_smtp, mock_smtp_ssl):\n        app.config['SMTP_USER'] = None\n        app.config['SMTP_PASSWORD'] = None\n        mock_smtp.return_value = mock.Mock()\n        mock_smtp_ssl.return_value = mock.Mock()\n        utils.send_MIME_email(\n            'from', 'to', MIMEMultipart(), app.config, dryrun=False)\n        assert not mock_smtp_ssl.called\n        mock_smtp.assert_called_with(\n            app.config.get('SMTP_HOST'),\n            app.config.get('SMTP_PORT'),\n        )\n        assert not mock_smtp.login.called\n\n    @mock.patch('smtplib.SMTP_SSL')\n    @mock.patch('smtplib.SMTP')\n    def test_send_mime_dryrun(self, mock_smtp, mock_smtp_ssl):\n        utils.send_MIME_email(\n            'from', 'to', MIMEMultipart(), app.config, dryrun=True)\n        assert not mock_smtp.called\n        assert not mock_smtp_ssl.called\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "description": "Apache Superset (incubating) is a modern, enterprise-ready business intelligence web application", "file_name": "email_tests.py", "id": "690961207de7a1e9335bdb48adbc7192", "language": "Python", "project_name": "incubator-superset", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/apache-incubator-superset/apache-incubator-superset-95a9b04/tests/email_tests.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:41:03Z", "url": "https://github.com/apache/incubator-superset", "wiki": false}