{"author": "deepfakes", "code": "import cv2\nimport numpy\nfrom random import shuffle\n\nfrom .utils import BackgroundGenerator\nfrom .umeyama import umeyama\n\nclass TrainingDataGenerator():\n    def __init__(self, random_transform_args, coverage, scale=5, zoom=1): \n        self.random_transform_args = random_transform_args\n        self.coverage = coverage\n        self.scale = scale\n        self.zoom = zoom\n\n    def minibatchAB(self, images, batchsize):\n        batch = BackgroundGenerator(self.minibatch(images, batchsize), 1)\n        for ep1, warped_img, target_img in batch.iterator():\n            yield ep1, warped_img, target_img\n\n    \n    def minibatch(self, data, batchsize):\n        length = len(data)\n        assert length >= batchsize, \"Number of images is lower than batch-size (Note that too few images may lead to bad training). # images: {}, batch-size: {}\".format(length, batchsize)\n        epoch = i = 0\n        shuffle(data)\n        while True:\n            size = batchsize\n            if i+size > length:\n                shuffle(data)\n                i = 0\n                epoch+=1\n            rtn = numpy.float32([self.read_image(img) for img in data[i:i+size]])\n            i+=size\n            yield epoch, rtn[:,0,:,:,:], rtn[:,1,:,:,:]       \n\n    def color_adjust(self, img):\n        return img / 255.0\n    \n    def read_image(self, fn):\n        try:\n            image = self.color_adjust(cv2.imread(fn))\n        except TypeError:\n            raise Exception(\"Error while reading image\", fn)\n        \n        image = cv2.resize(image, (256,256))\n        image = self.random_transform( image, **self.random_transform_args )\n        warped_img, target_img = self.random_warp( image, self.coverage, self.scale, self.zoom )\n        \n        return warped_img, target_img\n\n    def random_transform(self, image, rotation_range, zoom_range, shift_range, random_flip):\n        h, w = image.shape[0:2]\n        rotation = numpy.random.uniform(-rotation_range, rotation_range)\n        scale = numpy.random.uniform(1 - zoom_range, 1 + zoom_range)\n        tx = numpy.random.uniform(-shift_range, shift_range) * w\n        ty = numpy.random.uniform(-shift_range, shift_range) * h\n        mat = cv2.getRotationMatrix2D((w // 2, h // 2), rotation, scale)\n        mat[:, 2] += (tx, ty)\n        result = cv2.warpAffine(\n            image, mat, (w, h), borderMode=cv2.BORDER_REPLICATE)\n        if numpy.random.random() < random_flip:\n            result = result[:, ::-1]\n        return result\n\n    \n    def random_warp(self, image, coverage, scale = 5, zoom = 1):\n        assert image.shape == (256, 256, 3)\n        range_ = numpy.linspace(128 - coverage//2, 128 + coverage//2, 5)\n        mapx = numpy.broadcast_to(range_, (5, 5))\n        mapy = mapx.T\n\n        mapx = mapx + numpy.random.normal(size=(5,5), scale=scale)\n        mapy = mapy + numpy.random.normal(size=(5,5), scale=scale)\n\n        interp_mapx = cv2.resize(mapx, (80*zoom,80*zoom))[8*zoom:72*zoom,8*zoom:72*zoom].astype('float32')\n        interp_mapy = cv2.resize(mapy, (80*zoom,80*zoom))[8*zoom:72*zoom,8*zoom:72*zoom].astype('float32')\n\n        warped_image = cv2.remap(image, interp_mapx, interp_mapy, cv2.INTER_LINEAR)\n\n        src_points = numpy.stack([mapx.ravel(), mapy.ravel() ], axis=-1)\n        dst_points = numpy.mgrid[0:65*zoom:16*zoom,0:65*zoom:16*zoom].T.reshape(-1,2)\n        mat = umeyama(src_points, dst_points, True)[0:2]\n\n        target_image = cv2.warpAffine(image, mat, (64*zoom,64*zoom))\n\n        return warped_image, target_image\n\ndef stack_images(images):\n    def get_transpose_axes(n):\n        if n % 2 == 0:\n            y_axes = list(range(1, n - 1, 2))\n            x_axes = list(range(0, n - 1, 2))\n        else:\n            y_axes = list(range(0, n - 1, 2))\n            x_axes = list(range(1, n - 1, 2))\n        return y_axes, x_axes, [n - 1]\n    \n    images_shape = numpy.array(images.shape)\n    new_axes = get_transpose_axes(len(images_shape))\n    new_shape = [numpy.prod(images_shape[x]) for x in new_axes]\n    return numpy.transpose(\n        images,\n        axes=numpy.concatenate(new_axes)\n        ).reshape(new_shape)\n", "comments": " todo thos default stay warp function    a generator function yields epoch  batchsize warped img batchsize target img    images      batch size      format(length  batchsize)    get pair random warped images aligned face image ", "content": "import cv2\nimport numpy\nfrom random import shuffle\n\nfrom .utils import BackgroundGenerator\nfrom .umeyama import umeyama\n\nclass TrainingDataGenerator():\n    def __init__(self, random_transform_args, coverage, scale=5, zoom=1): #TODO thos default should stay in the warp function\n        self.random_transform_args = random_transform_args\n        self.coverage = coverage\n        self.scale = scale\n        self.zoom = zoom\n\n    def minibatchAB(self, images, batchsize):\n        batch = BackgroundGenerator(self.minibatch(images, batchsize), 1)\n        for ep1, warped_img, target_img in batch.iterator():\n            yield ep1, warped_img, target_img\n\n    # A generator function that yields epoch, batchsize of warped_img and batchsize of target_img\n    def minibatch(self, data, batchsize):\n        length = len(data)\n        assert length >= batchsize, \"Number of images is lower than batch-size (Note that too few images may lead to bad training). # images: {}, batch-size: {}\".format(length, batchsize)\n        epoch = i = 0\n        shuffle(data)\n        while True:\n            size = batchsize\n            if i+size > length:\n                shuffle(data)\n                i = 0\n                epoch+=1\n            rtn = numpy.float32([self.read_image(img) for img in data[i:i+size]])\n            i+=size\n            yield epoch, rtn[:,0,:,:,:], rtn[:,1,:,:,:]       \n\n    def color_adjust(self, img):\n        return img / 255.0\n    \n    def read_image(self, fn):\n        try:\n            image = self.color_adjust(cv2.imread(fn))\n        except TypeError:\n            raise Exception(\"Error while reading image\", fn)\n        \n        image = cv2.resize(image, (256,256))\n        image = self.random_transform( image, **self.random_transform_args )\n        warped_img, target_img = self.random_warp( image, self.coverage, self.scale, self.zoom )\n        \n        return warped_img, target_img\n\n    def random_transform(self, image, rotation_range, zoom_range, shift_range, random_flip):\n        h, w = image.shape[0:2]\n        rotation = numpy.random.uniform(-rotation_range, rotation_range)\n        scale = numpy.random.uniform(1 - zoom_range, 1 + zoom_range)\n        tx = numpy.random.uniform(-shift_range, shift_range) * w\n        ty = numpy.random.uniform(-shift_range, shift_range) * h\n        mat = cv2.getRotationMatrix2D((w // 2, h // 2), rotation, scale)\n        mat[:, 2] += (tx, ty)\n        result = cv2.warpAffine(\n            image, mat, (w, h), borderMode=cv2.BORDER_REPLICATE)\n        if numpy.random.random() < random_flip:\n            result = result[:, ::-1]\n        return result\n\n    # get pair of random warped images from aligned face image\n    def random_warp(self, image, coverage, scale = 5, zoom = 1):\n        assert image.shape == (256, 256, 3)\n        range_ = numpy.linspace(128 - coverage//2, 128 + coverage//2, 5)\n        mapx = numpy.broadcast_to(range_, (5, 5))\n        mapy = mapx.T\n\n        mapx = mapx + numpy.random.normal(size=(5,5), scale=scale)\n        mapy = mapy + numpy.random.normal(size=(5,5), scale=scale)\n\n        interp_mapx = cv2.resize(mapx, (80*zoom,80*zoom))[8*zoom:72*zoom,8*zoom:72*zoom].astype('float32')\n        interp_mapy = cv2.resize(mapy, (80*zoom,80*zoom))[8*zoom:72*zoom,8*zoom:72*zoom].astype('float32')\n\n        warped_image = cv2.remap(image, interp_mapx, interp_mapy, cv2.INTER_LINEAR)\n\n        src_points = numpy.stack([mapx.ravel(), mapy.ravel() ], axis=-1)\n        dst_points = numpy.mgrid[0:65*zoom:16*zoom,0:65*zoom:16*zoom].T.reshape(-1,2)\n        mat = umeyama(src_points, dst_points, True)[0:2]\n\n        target_image = cv2.warpAffine(image, mat, (64*zoom,64*zoom))\n\n        return warped_image, target_image\n\ndef stack_images(images):\n    def get_transpose_axes(n):\n        if n % 2 == 0:\n            y_axes = list(range(1, n - 1, 2))\n            x_axes = list(range(0, n - 1, 2))\n        else:\n            y_axes = list(range(0, n - 1, 2))\n            x_axes = list(range(1, n - 1, 2))\n        return y_axes, x_axes, [n - 1]\n    \n    images_shape = numpy.array(images.shape)\n    new_axes = get_transpose_axes(len(images_shape))\n    new_shape = [numpy.prod(images_shape[x]) for x in new_axes]\n    return numpy.transpose(\n        images,\n        axes=numpy.concatenate(new_axes)\n        ).reshape(new_shape)\n", "description": "Non official project based on original /r/Deepfakes thread. Many thanks to him!", "file_name": "training_data.py", "id": "4d3dd9d954774f9ed170b35ddd5c15ca", "language": "Python", "project_name": "faceswap", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/deepfakes-faceswap/deepfakes-faceswap-6ff64ef/lib/training_data.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:27:43Z", "url": "https://github.com/deepfakes/faceswap", "wiki": true}