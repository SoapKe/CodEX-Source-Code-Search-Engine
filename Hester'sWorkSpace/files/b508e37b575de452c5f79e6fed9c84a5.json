{"author": "getredash", "code": "from unittest import TestCase\nfrom collections import namedtuple\nimport uuid\n\nimport mock\n\nfrom tests import BaseTestCase\nfrom redash import redis_connection, models\nfrom redash.query_runner.pg import PostgreSQL\nfrom redash.tasks.queries import QueryTaskTracker, enqueue_query, execute_query\n\n\nclass TestPrune(TestCase):\n    def setUp(self):\n        self.list = \"test_list\"\n        redis_connection.delete(self.list)\n        self.keys = []\n        for score in range(0, 100):\n            key = 'k:{}'.format(score)\n            self.keys.append(key)\n            redis_connection.zadd(self.list, score, key)\n            redis_connection.set(key, 1)\n\n    def test_does_nothing_when_below_threshold(self):\n        remove_count = QueryTaskTracker.prune(self.list, 100)\n        self.assertEqual(remove_count, 0)\n        self.assertEqual(redis_connection.zcard(self.list), 100)\n\n    def test_removes_oldest_items_first(self):\n        remove_count = QueryTaskTracker.prune(self.list, 50)\n        self.assertEqual(remove_count, 50)\n        self.assertEqual(redis_connection.zcard(self.list), 50)\n\n        self.assertEqual(redis_connection.zscore(self.list, 'k:99'), 99.0)\n        self.assertIsNone(redis_connection.zscore(self.list, 'k:1'))\n\n        for k in self.keys[0:50]:\n            self.assertFalse(redis_connection.exists(k))\n\n\nFakeResult = namedtuple('FakeResult', 'id')\n\n\ndef gen_hash(*args, **kwargs):\n    return FakeResult(uuid.uuid4().hex)\n\n\nclass TestEnqueueTask(BaseTestCase):\n    def test_multiple_enqueue_of_same_query(self):\n        query = self.factory.create_query()\n        execute_query.apply_async = mock.MagicMock(side_effect=gen_hash)\n\n        enqueue_query(query.query_text, query.data_source, query.user_id, query, {'Username': 'Arik', 'Query ID': query.id})\n        enqueue_query(query.query_text, query.data_source, query.user_id, query, {'Username': 'Arik', 'Query ID': query.id})\n        enqueue_query(query.query_text, query.data_source, query.user_id, query, {'Username': 'Arik', 'Query ID': query.id})\n\n        self.assertEqual(1, execute_query.apply_async.call_count)\n        self.assertEqual(1, redis_connection.zcard(QueryTaskTracker.WAITING_LIST))\n        self.assertEqual(0, redis_connection.zcard(QueryTaskTracker.IN_PROGRESS_LIST))\n        self.assertEqual(0, redis_connection.zcard(QueryTaskTracker.DONE_LIST))\n\n    def test_multiple_enqueue_of_different_query(self):\n        query = self.factory.create_query()\n        execute_query.apply_async = mock.MagicMock(side_effect=gen_hash)\n\n        enqueue_query(query.query_text, query.data_source, query.user_id, None, {'Username': 'Arik', 'Query ID': query.id})\n        enqueue_query(query.query_text + '2', query.data_source, query.user_id, None, {'Username': 'Arik', 'Query ID': query.id})\n        enqueue_query(query.query_text + '3', query.data_source, query.user_id, None, {'Username': 'Arik', 'Query ID': query.id})\n\n        self.assertEqual(3, execute_query.apply_async.call_count)\n        self.assertEqual(3, redis_connection.zcard(QueryTaskTracker.WAITING_LIST))\n        self.assertEqual(0, redis_connection.zcard(QueryTaskTracker.IN_PROGRESS_LIST))\n        self.assertEqual(0, redis_connection.zcard(QueryTaskTracker.DONE_LIST))\n\n\nclass QueryExecutorTests(BaseTestCase):\n\n    def test_success(self):\n        \"\"\"\n        ``execute_query`` invokes the query runner and stores a query result.\n        \"\"\"\n        cm = mock.patch(\"celery.app.task.Context.delivery_info\", {'routing_key': 'test'})\n        with cm, mock.patch.object(PostgreSQL, \"run_query\") as qr:\n            qr.return_value = ([1, 2], None)\n            result_id = execute_query(\"SELECT 1, 2\", self.factory.data_source.id, {})\n            self.assertEqual(1, qr.call_count)\n            result = models.QueryResult.query.get(result_id)\n            self.assertEqual(result.data, '{1,2}')\n\n    def test_success_scheduled(self):\n        \"\"\"\n        Scheduled queries remember their latest results.\n        \"\"\"\n        cm = mock.patch(\"celery.app.task.Context.delivery_info\",\n                        {'routing_key': 'test'})\n        q = self.factory.create_query(query_text=\"SELECT 1, 2\", schedule=300)\n        with cm, mock.patch.object(PostgreSQL, \"run_query\") as qr:\n            qr.return_value = ([1, 2], None)\n            result_id = execute_query(\n                \"SELECT 1, 2\",\n                self.factory.data_source.id, {},\n                scheduled_query_id=q.id)\n            q = models.Query.get_by_id(q.id)\n            self.assertEqual(q.schedule_failures, 0)\n            result = models.QueryResult.query.get(result_id)\n            self.assertEqual(q.latest_query_data, result)\n\n    def test_failure_scheduled(self):\n        \"\"\"\n        Scheduled queries that fail have their failure recorded.\n        \"\"\"\n        cm = mock.patch(\"celery.app.task.Context.delivery_info\",\n                        {'routing_key': 'test'})\n        q = self.factory.create_query(query_text=\"SELECT 1, 2\", schedule=300)\n        with cm, mock.patch.object(PostgreSQL, \"run_query\") as qr:\n            qr.exception = ValueError(\"broken\")\n            execute_query(\"SELECT 1, 2\", self.factory.data_source.id, {}, scheduled_query_id=q.id)\n            q = models.Query.get_by_id(q.id)\n            self.assertEqual(q.schedule_failures, 1)\n            execute_query(\"SELECT 1, 2\", self.factory.data_source.id, {}, scheduled_query_id=q.id)\n            q = models.Query.get_by_id(q.id)\n            self.assertEqual(q.schedule_failures, 2)\n\n    def test_success_after_failure(self):\n        \"\"\"\n        Query execution success resets the failure counter.\n        \"\"\"\n        cm = mock.patch(\"celery.app.task.Context.delivery_info\",\n                        {'routing_key': 'test'})\n        q = self.factory.create_query(query_text=\"SELECT 1, 2\", schedule=300)\n        with cm, mock.patch.object(PostgreSQL, \"run_query\") as qr:\n            qr.exception = ValueError(\"broken\")\n            execute_query(\"SELECT 1, 2\",\n                          self.factory.data_source.id, {},\n                          scheduled_query_id=q.id)\n            q = models.Query.get_by_id(q.id)\n            self.assertEqual(q.schedule_failures, 1)\n\n        with cm, mock.patch.object(PostgreSQL, \"run_query\") as qr:\n            qr.return_value = ([1, 2], None)\n            execute_query(\"SELECT 1, 2\",\n                          self.factory.data_source.id, {},\n                          scheduled_query_id=q.id)\n            q = models.Query.get_by_id(q.id)\n            self.assertEqual(q.schedule_failures, 0)\n", "comments": "              execute query   invokes query runner stores query result                      cm   mock patch( celery app task context delivery info     routing key    test  )         cm  mock patch object(postgresql   run query ) qr              qr return value   ( 1  2   none)             result id   execute query( select 1  2   self factory data source id    )             self assertequal(1  qr call count)             result   models queryresult query get(result id)             self assertequal(result data    1 2  )      def test success scheduled(self)                      scheduled queries remember latest results                      cm   mock patch( celery app task context delivery info                             routing key    test  )         q   self factory create query(query text  select 1  2   schedule 300)         cm  mock patch object(postgresql   run query ) qr              qr return value   ( 1  2   none)             result id   execute query(                  select 1  2                   self factory data source id                      scheduled query id q id)             q   models query get id(q id)             self assertequal(q schedule failures  0)             result   models queryresult query get(result id)             self assertequal(q latest query data  result)      def test failure scheduled(self)                      scheduled queries fail failure recorded                      cm   mock patch( celery app task context delivery info                             routing key    test  )         q   self factory create query(query text  select 1  2   schedule 300)         cm  mock patch object(postgresql   run query ) qr              qr exception   valueerror( broken )             execute query( select 1  2   self factory data source id      scheduled query id q id)             q   models query get id(q id)             self assertequal(q schedule failures  1)             execute query( select 1  2   self factory data source id      scheduled query id q id)             q   models query get id(q id)             self assertequal(q schedule failures  2)      def test success failure(self)                      query execution success resets failure counter              ", "content": "from unittest import TestCase\nfrom collections import namedtuple\nimport uuid\n\nimport mock\n\nfrom tests import BaseTestCase\nfrom redash import redis_connection, models\nfrom redash.query_runner.pg import PostgreSQL\nfrom redash.tasks.queries import QueryTaskTracker, enqueue_query, execute_query\n\n\nclass TestPrune(TestCase):\n    def setUp(self):\n        self.list = \"test_list\"\n        redis_connection.delete(self.list)\n        self.keys = []\n        for score in range(0, 100):\n            key = 'k:{}'.format(score)\n            self.keys.append(key)\n            redis_connection.zadd(self.list, score, key)\n            redis_connection.set(key, 1)\n\n    def test_does_nothing_when_below_threshold(self):\n        remove_count = QueryTaskTracker.prune(self.list, 100)\n        self.assertEqual(remove_count, 0)\n        self.assertEqual(redis_connection.zcard(self.list), 100)\n\n    def test_removes_oldest_items_first(self):\n        remove_count = QueryTaskTracker.prune(self.list, 50)\n        self.assertEqual(remove_count, 50)\n        self.assertEqual(redis_connection.zcard(self.list), 50)\n\n        self.assertEqual(redis_connection.zscore(self.list, 'k:99'), 99.0)\n        self.assertIsNone(redis_connection.zscore(self.list, 'k:1'))\n\n        for k in self.keys[0:50]:\n            self.assertFalse(redis_connection.exists(k))\n\n\nFakeResult = namedtuple('FakeResult', 'id')\n\n\ndef gen_hash(*args, **kwargs):\n    return FakeResult(uuid.uuid4().hex)\n\n\nclass TestEnqueueTask(BaseTestCase):\n    def test_multiple_enqueue_of_same_query(self):\n        query = self.factory.create_query()\n        execute_query.apply_async = mock.MagicMock(side_effect=gen_hash)\n\n        enqueue_query(query.query_text, query.data_source, query.user_id, query, {'Username': 'Arik', 'Query ID': query.id})\n        enqueue_query(query.query_text, query.data_source, query.user_id, query, {'Username': 'Arik', 'Query ID': query.id})\n        enqueue_query(query.query_text, query.data_source, query.user_id, query, {'Username': 'Arik', 'Query ID': query.id})\n\n        self.assertEqual(1, execute_query.apply_async.call_count)\n        self.assertEqual(1, redis_connection.zcard(QueryTaskTracker.WAITING_LIST))\n        self.assertEqual(0, redis_connection.zcard(QueryTaskTracker.IN_PROGRESS_LIST))\n        self.assertEqual(0, redis_connection.zcard(QueryTaskTracker.DONE_LIST))\n\n    def test_multiple_enqueue_of_different_query(self):\n        query = self.factory.create_query()\n        execute_query.apply_async = mock.MagicMock(side_effect=gen_hash)\n\n        enqueue_query(query.query_text, query.data_source, query.user_id, None, {'Username': 'Arik', 'Query ID': query.id})\n        enqueue_query(query.query_text + '2', query.data_source, query.user_id, None, {'Username': 'Arik', 'Query ID': query.id})\n        enqueue_query(query.query_text + '3', query.data_source, query.user_id, None, {'Username': 'Arik', 'Query ID': query.id})\n\n        self.assertEqual(3, execute_query.apply_async.call_count)\n        self.assertEqual(3, redis_connection.zcard(QueryTaskTracker.WAITING_LIST))\n        self.assertEqual(0, redis_connection.zcard(QueryTaskTracker.IN_PROGRESS_LIST))\n        self.assertEqual(0, redis_connection.zcard(QueryTaskTracker.DONE_LIST))\n\n\nclass QueryExecutorTests(BaseTestCase):\n\n    def test_success(self):\n        \"\"\"\n        ``execute_query`` invokes the query runner and stores a query result.\n        \"\"\"\n        cm = mock.patch(\"celery.app.task.Context.delivery_info\", {'routing_key': 'test'})\n        with cm, mock.patch.object(PostgreSQL, \"run_query\") as qr:\n            qr.return_value = ([1, 2], None)\n            result_id = execute_query(\"SELECT 1, 2\", self.factory.data_source.id, {})\n            self.assertEqual(1, qr.call_count)\n            result = models.QueryResult.query.get(result_id)\n            self.assertEqual(result.data, '{1,2}')\n\n    def test_success_scheduled(self):\n        \"\"\"\n        Scheduled queries remember their latest results.\n        \"\"\"\n        cm = mock.patch(\"celery.app.task.Context.delivery_info\",\n                        {'routing_key': 'test'})\n        q = self.factory.create_query(query_text=\"SELECT 1, 2\", schedule=300)\n        with cm, mock.patch.object(PostgreSQL, \"run_query\") as qr:\n            qr.return_value = ([1, 2], None)\n            result_id = execute_query(\n                \"SELECT 1, 2\",\n                self.factory.data_source.id, {},\n                scheduled_query_id=q.id)\n            q = models.Query.get_by_id(q.id)\n            self.assertEqual(q.schedule_failures, 0)\n            result = models.QueryResult.query.get(result_id)\n            self.assertEqual(q.latest_query_data, result)\n\n    def test_failure_scheduled(self):\n        \"\"\"\n        Scheduled queries that fail have their failure recorded.\n        \"\"\"\n        cm = mock.patch(\"celery.app.task.Context.delivery_info\",\n                        {'routing_key': 'test'})\n        q = self.factory.create_query(query_text=\"SELECT 1, 2\", schedule=300)\n        with cm, mock.patch.object(PostgreSQL, \"run_query\") as qr:\n            qr.exception = ValueError(\"broken\")\n            execute_query(\"SELECT 1, 2\", self.factory.data_source.id, {}, scheduled_query_id=q.id)\n            q = models.Query.get_by_id(q.id)\n            self.assertEqual(q.schedule_failures, 1)\n            execute_query(\"SELECT 1, 2\", self.factory.data_source.id, {}, scheduled_query_id=q.id)\n            q = models.Query.get_by_id(q.id)\n            self.assertEqual(q.schedule_failures, 2)\n\n    def test_success_after_failure(self):\n        \"\"\"\n        Query execution success resets the failure counter.\n        \"\"\"\n        cm = mock.patch(\"celery.app.task.Context.delivery_info\",\n                        {'routing_key': 'test'})\n        q = self.factory.create_query(query_text=\"SELECT 1, 2\", schedule=300)\n        with cm, mock.patch.object(PostgreSQL, \"run_query\") as qr:\n            qr.exception = ValueError(\"broken\")\n            execute_query(\"SELECT 1, 2\",\n                          self.factory.data_source.id, {},\n                          scheduled_query_id=q.id)\n            q = models.Query.get_by_id(q.id)\n            self.assertEqual(q.schedule_failures, 1)\n\n        with cm, mock.patch.object(PostgreSQL, \"run_query\") as qr:\n            qr.return_value = ([1, 2], None)\n            execute_query(\"SELECT 1, 2\",\n                          self.factory.data_source.id, {},\n                          scheduled_query_id=q.id)\n            q = models.Query.get_by_id(q.id)\n            self.assertEqual(q.schedule_failures, 0)\n", "description": "Make Your Company Data Driven. Connect to any data source, easily visualize and share your data.", "file_name": "test_queries.py", "id": "b508e37b575de452c5f79e6fed9c84a5", "language": "Python", "project_name": "redash", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/getredash-redash/getredash-redash-0410d83/tests/tasks/test_queries.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:54:55Z", "url": "https://github.com/getredash/redash", "wiki": false}