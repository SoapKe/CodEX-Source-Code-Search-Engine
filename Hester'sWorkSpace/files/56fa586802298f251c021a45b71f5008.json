{"author": "nvbn", "code": "\n\nimport sys\nfrom .conf import settings\nfrom .exceptions import NoRuleMatched\nfrom .system import get_key\nfrom .utils import get_alias\nfrom . import logs, const\n\n\ndef read_actions():\n    \n    try:\n        selector = CommandSelector(corrected_commands)\n    except NoRuleMatched:\n        logs.failed('No fucks given' if get_alias() == 'fuck'\n                    else 'Nothing found')\n        return\n\n    if not settings.require_confirmation:\n        logs.show_corrected_command(selector.value)\n        return selector.value\n\n    logs.confirm_text(selector.value)\n\n    for action in read_actions():\n        if action == const.ACTION_SELECT:\n            sys.stderr.write('\\n')\n            return selector.value\n        elif action == const.ACTION_ABORT:\n            logs.failed('\\nAborted')\n            return\n        elif action == const.ACTION_PREVIOUS:\n            selector.previous()\n            logs.confirm_text(selector.value)\n        elif action == const.ACTION_NEXT:\n            selector.next()\n            logs.confirm_text(selector.value)\n", "comments": "Yields actions for pressed keys.\"\"\"\n    while True:\n        key = get_key()\n\n        # Handle arrows, j/k (qwerty), and n/e (colemak)\n        if key in (const.KEY_UP, const.KEY_CTRL_N, 'k', 'e'):\n            yield const.ACTION_PREVIOUS\n        elif key in (const.KEY_DOWN, const.KEY_CTRL_P, 'j', 'n'):\n            yield const.ACTION_NEXT\n        elif key in (const.KEY_CTRL_C, 'q'):\n            yield const.ACTION_ABORT\n        elif key in ('\\n', '\\r'):\n            yield const.ACTION_SELECT\n\n\nclass CommandSelector(object):\n    \"\"\"Helper for selecting rule from rules list.\"\"\"\n\n    def __init__(self, commands):\n        \"\"\":type commands: Iterable[thefuck.types.CorrectedCommand]\"\"\"\n        self._commands_gen = commands\n        try:\n            self._commands = [next(self._commands_gen)]\n        except StopIteration:\n            raise NoRuleMatched\n        self._realised = False\n        self._index = 0\n\n    def _realise(self):\n        if not self._realised:\n            self._commands += list(self._commands_gen)\n            self._realised = True\n\n    def next(self):\n        self._realise()\n        self._index = (self._index + 1) % len(self._commands)\n\n    def previous(self):\n        self._realise()\n        self._index = (self._index - 1) % len(self._commands)\n\n    @property\n    def value(self):\n        \"\"\":rtype hefuck.types.CorrectedCommand\"\"\"\n        return self._commands[self._index]\n\n\ndef select_command(corrected_commands):\n    \"\"\"Returns:\n\n     - the first command when confirmation disabled;\n     - None when ctrl+c pressed;\n     - selected command.\n\n    :type corrected_commands: Iterable[thefuck.types.CorrectedCommand]\n    :rtype: thefuck.types.CorrectedCommand | None\n\n    \n \n# -*- encoding: utf-8 -*-\n", "content": "# -*- encoding: utf-8 -*-\n\nimport sys\nfrom .conf import settings\nfrom .exceptions import NoRuleMatched\nfrom .system import get_key\nfrom .utils import get_alias\nfrom . import logs, const\n\n\ndef read_actions():\n    \"\"\"Yields actions for pressed keys.\"\"\"\n    while True:\n        key = get_key()\n\n        # Handle arrows, j/k (qwerty), and n/e (colemak)\n        if key in (const.KEY_UP, const.KEY_CTRL_N, 'k', 'e'):\n            yield const.ACTION_PREVIOUS\n        elif key in (const.KEY_DOWN, const.KEY_CTRL_P, 'j', 'n'):\n            yield const.ACTION_NEXT\n        elif key in (const.KEY_CTRL_C, 'q'):\n            yield const.ACTION_ABORT\n        elif key in ('\\n', '\\r'):\n            yield const.ACTION_SELECT\n\n\nclass CommandSelector(object):\n    \"\"\"Helper for selecting rule from rules list.\"\"\"\n\n    def __init__(self, commands):\n        \"\"\":type commands: Iterable[thefuck.types.CorrectedCommand]\"\"\"\n        self._commands_gen = commands\n        try:\n            self._commands = [next(self._commands_gen)]\n        except StopIteration:\n            raise NoRuleMatched\n        self._realised = False\n        self._index = 0\n\n    def _realise(self):\n        if not self._realised:\n            self._commands += list(self._commands_gen)\n            self._realised = True\n\n    def next(self):\n        self._realise()\n        self._index = (self._index + 1) % len(self._commands)\n\n    def previous(self):\n        self._realise()\n        self._index = (self._index - 1) % len(self._commands)\n\n    @property\n    def value(self):\n        \"\"\":rtype hefuck.types.CorrectedCommand\"\"\"\n        return self._commands[self._index]\n\n\ndef select_command(corrected_commands):\n    \"\"\"Returns:\n\n     - the first command when confirmation disabled;\n     - None when ctrl+c pressed;\n     - selected command.\n\n    :type corrected_commands: Iterable[thefuck.types.CorrectedCommand]\n    :rtype: thefuck.types.CorrectedCommand | None\n\n    \"\"\"\n    try:\n        selector = CommandSelector(corrected_commands)\n    except NoRuleMatched:\n        logs.failed('No fucks given' if get_alias() == 'fuck'\n                    else 'Nothing found')\n        return\n\n    if not settings.require_confirmation:\n        logs.show_corrected_command(selector.value)\n        return selector.value\n\n    logs.confirm_text(selector.value)\n\n    for action in read_actions():\n        if action == const.ACTION_SELECT:\n            sys.stderr.write('\\n')\n            return selector.value\n        elif action == const.ACTION_ABORT:\n            logs.failed('\\nAborted')\n            return\n        elif action == const.ACTION_PREVIOUS:\n            selector.previous()\n            logs.confirm_text(selector.value)\n        elif action == const.ACTION_NEXT:\n            selector.next()\n            logs.confirm_text(selector.value)\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "ui.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/thefuck/ui.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}