{"author": "HelloZeroNet", "code": "import logging\nimport re\nimport socket\nimport binascii\nimport sys\nimport os\nimport time\nimport random\nimport subprocess\nimport atexit\n\nimport gevent\n\nfrom Config import config\nfrom Crypt import CryptRsa\nfrom Site import SiteManager\nfrom lib.PySocks import socks\ntry:\n    from gevent.coros import RLock\nexcept:\n    from gevent.lock import RLock\nfrom util import helper\nfrom Debug import Debug\nfrom Plugin import PluginManager\n\n\n@PluginManager.acceptPlugins\nclass TorManager(object):\n    def __init__(self, fileserver_ip=None, fileserver_port=None):\n        self.privatekeys = {}  \n        self.site_onions = {}  \n        self.tor_exe = \"tools/tor/tor.exe\"\n        self.tor_process = None\n        self.log = logging.getLogger(\"TorManager\")\n        self.start_onions = None\n        self.conn = None\n        self.lock = RLock()\n\n        if config.tor == \"disable\":\n            self.enabled = False\n            self.start_onions = False\n            self.setStatus(\"Disabled\")\n        else:\n            self.enabled = True\n            self.setStatus(\"Waiting\")\n\n        if fileserver_port:\n            self.fileserver_port = fileserver_port\n        else:\n            self.fileserver_port = config.fileserver_port\n\n        self.ip, self.port = config.tor_controller.split(\":\")\n        self.port = int(self.port)\n\n        self.proxy_ip, self.proxy_port = config.tor_proxy.split(\":\")\n        self.proxy_port = int(self.proxy_port)\n\n        \n        if config.tor != \"disable\":\n            try:\n                assert self.connect(), \"No connection\"\n                self.log.debug(\"Tor proxy port %s check ok\" % config.tor_proxy)\n            except Exception, err:\n                self.log.info(\"Starting self-bundled Tor, due to Tor proxy port %s check error: %s\" % (config.tor_proxy, err))\n                self.enabled = False\n                \n                from lib.PySocks import socks\n                self.port = 49051\n                self.proxy_port = 49050\n                socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, \"127.0.0.1\", self.proxy_port)\n                if os.path.isfile(self.tor_exe):  \n                    self.startTor()\n                else:  \n                    gevent.spawn(self.startTor)\n\n    def setStatus(self, status):\n        self.status = status\n        if \"ui_server\" in dir(sys.modules[\"main\"]):\n            sys.modules[\"main\"].ui_server.updateWebsocket()\n\n    def startTor(self):\n        if sys.platform.startswith(\"win\"):\n            try:\n                if not os.path.isfile(self.tor_exe):\n                    self.downloadTor()\n\n                self.log.info(\"Starting Tor client %s...\" % self.tor_exe)\n                tor_dir = os.path.dirname(self.tor_exe)\n                startupinfo = subprocess.STARTUPINFO()\n                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n                self.tor_process = subprocess.Popen(r\"%s -f torrc\" % self.tor_exe, cwd=tor_dir, close_fds=True, startupinfo=startupinfo)\n                for wait in range(1, 10):  \n                    time.sleep(wait * 0.5)\n                    self.enabled = True\n                    if self.connect():\n                        break\n                \n                atexit.register(self.stopTor)\n            except Exception, err:\n                self.log.error(\"Error starting Tor client: %s\" % Debug.formatException(err))\n                self.enabled = False\n        return False\n\n    def stopTor(self):\n        self.log.debug(\"Stopping...\")\n        try:\n            self.tor_process.terminate()\n        except Exception, err:\n            self.log.error(\"Error stopping Tor: %s\" % err)\n\n    def downloadTor(self):\n        self.log.info(\"Downloading Tor...\")\n        \n        download_page = helper.httpRequest(\"https://www.torproject.org/download/download.html\").read()\n        download_url = re.search('href=\"(.*?tor.*?win32.*?zip)\"', download_page).group(1)\n        if not download_url.startswith(\"http\"):\n            download_url = \"https://www.torproject.org/download/\" + download_url\n\n        \n        self.log.info(\"Downloading %s\" % download_url)\n        data = helper.httpRequest(download_url, as_file=True)\n        data_size = data.tell()\n\n        \n        if data_size < 1024 and \"The document has moved\" in data.getvalue():\n            download_url = re.search('href=\"(.*?tor.*?win32.*?zip)\"', data.getvalue()).group(1)\n            data = helper.httpRequest(download_url, as_file=True)\n            data_size = data.tell()\n\n        if data_size > 1024:\n            import zipfile\n            zip = zipfile.ZipFile(data)\n            self.log.info(\"Unpacking Tor\")\n            for inner_path in zip.namelist():\n                if \"..\" in inner_path:\n                    continue\n                dest_path = inner_path\n                dest_path = re.sub(\"^Data/Tor/\", \"tools/tor/data/\", dest_path)\n                dest_path = re.sub(\"^Data/\", \"tools/tor/data/\", dest_path)\n                dest_path = re.sub(\"^Tor/\", \"tools/tor/\", dest_path)\n                dest_dir = os.path.dirname(dest_path)\n                if dest_dir and not os.path.isdir(dest_dir):\n                    os.makedirs(dest_dir)\n\n                if dest_dir != dest_path.strip(\"/\"):\n                    data = zip.read(inner_path)\n                    if not os.path.isfile(dest_path):\n                        open(dest_path, 'wb').write(data)\n        else:\n            self.log.error(\"Bad response from server: %s\" % data.getvalue())\n            return False\n\n    def connect(self):\n        if not self.enabled:\n            return False\n        self.site_onions = {}\n        self.privatekeys = {}\n\n        return self.connectController()\n\n    def connectController(self):\n        if \"socket_noproxy\" in dir(socket):  \n            conn = socket.socket_noproxy(socket.AF_INET, socket.SOCK_STREAM)\n        else:\n            conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n        self.log.info(\"Connecting to Tor Controller %s:%s\" % (self.ip, self.port))\n        try:\n            with self.lock:\n                conn.connect((self.ip, self.port))\n\n                \n                res_protocol = self.send(\"PROTOCOLINFO\", conn)\n                cookie_match = re.search('COOKIEFILE=\"(.*?)\"', res_protocol)\n                if cookie_match:\n                    cookie_file = cookie_match.group(1).decode(\"string-escape\")\n                    auth_hex = binascii.b2a_hex(open(cookie_file, \"rb\").read())\n                    res_auth = self.send(\"AUTHENTICATE %s\" % auth_hex, conn)\n                elif config.tor_password:\n                    res_auth = self.send('AUTHENTICATE \"%s\"' % config.tor_password, conn)\n                else:\n                    res_auth = self.send(\"AUTHENTICATE\", conn)\n\n                assert \"250 OK\" in res_auth, \"Authenticate error %s\" % res_auth\n\n                \n                res_version = self.send(\"GETINFO version\", conn)\n                version = re.search('version=([0-9\\.]+)', res_version).group(1)\n                assert float(version.replace(\".\", \"0\", 2)) >= 207.5, \"Tor version >=0.2.7.5 required, found: %s\" % version\n\n                self.setStatus(u\"Connected (%s)\" % res_auth)\n                self.conn = conn\n        except Exception, err:\n            self.conn = None\n            self.setStatus(u\"Error (%s)\" % err)\n            self.log.warning(\"Tor controller connect error: %s\" % Debug.formatException(err))\n            self.enabled = False\n        return self.conn\n\n    def disconnect(self):\n        self.conn.close()\n        self.conn = None\n\n    def startOnions(self):\n        if self.enabled:\n            self.log.debug(\"Start onions\")\n            self.start_onions = True\n            self.getOnion(\"global\")\n\n    \n    def resetCircuits(self):\n        res = self.request(\"SIGNAL NEWNYM\")\n        if \"250 OK\" not in res:\n            self.setStatus(u\"Reset circuits error (%s)\" % res)\n            self.log.error(\"Tor reset circuits error: %s\" % res)\n\n    def addOnion(self):\n        if len(self.privatekeys) >= config.tor_hs_limit:\n            return random.choice([key for key in self.privatekeys.keys() if key != self.site_onions.get(\"global\")])\n\n        result = self.makeOnionAndKey()\n        if result:\n            onion_address, onion_privatekey = result\n            self.privatekeys[onion_address] = onion_privatekey\n            self.setStatus(u\"OK (%s onions running)\" % len(self.privatekeys))\n            SiteManager.peer_blacklist.append((onion_address + \".onion\", self.fileserver_port))\n            return onion_address\n        else:\n            return False\n\n    def makeOnionAndKey(self):\n        res = self.request(\"ADD_ONION NEW:RSA1024 port=%s\" % self.fileserver_port)\n        match = re.search(\"ServiceID=([A-Za-z0-9]+).*PrivateKey=RSA1024:(.*?)[\\r\\n]\", res, re.DOTALL)\n        if match:\n            onion_address, onion_privatekey = match.groups()\n            return (onion_address, onion_privatekey)\n        else:\n            self.setStatus(u\"AddOnion error (%s)\" % res)\n            self.log.error(\"Tor addOnion error: %s\" % res)\n            return False\n\n    def delOnion(self, address):\n        res = self.request(\"DEL_ONION %s\" % address)\n        if \"250 OK\" in res:\n            del self.privatekeys[address]\n            self.setStatus(\"OK (%s onion running)\" % len(self.privatekeys))\n            return True\n        else:\n            self.setStatus(u\"DelOnion error (%s)\" % res)\n            self.log.error(\"Tor delOnion error: %s\" % res)\n            self.disconnect()\n            return False\n\n    def request(self, cmd):\n        with self.lock:\n            if not self.enabled:\n                return False\n            if not self.conn:\n                if not self.connect():\n                    return \"\"\n            return self.send(cmd)\n\n    def send(self, cmd, conn=None):\n        if not conn:\n            conn = self.conn\n        self.log.debug(\"> %s\" % cmd)\n        back = \"\"\n        for retry in range(2):\n            try:\n                conn.sendall(\"%s\\r\\n\" % cmd)\n                while not back.endswith(\"250 OK\\r\\n\"):\n                    back += conn.recv(1024 * 64).decode(\"utf8\", \"ignore\")\n                break\n            except Exception, err:\n                self.log.error(\"Tor send error: %s, reconnecting...\" % err)\n                self.disconnect()\n                time.sleep(1)\n                self.connect()\n                back = None\n        self.log.debug(\"< %s\" % back.strip())\n        return back\n\n    def getPrivatekey(self, address):\n        return self.privatekeys[address]\n\n    def getPublickey(self, address):\n        return CryptRsa.privatekeyToPublickey(self.privatekeys[address])\n\n    def getOnion(self, site_address):\n        with self.lock:\n            if not self.enabled:\n                return None\n            if config.tor == \"always\":  \n                onion = self.site_onions.get(site_address)\n            else:  \n                onion = self.site_onions.get(\"global\")\n                site_address = \"global\"\n            if not onion:\n                self.site_onions[site_address] = self.addOnion()\n                onion = self.site_onions[site_address]\n                self.log.debug(\"Created new hidden service for %s: %s\" % (site_address, onion))\n            return onion\n\n    \n    \n    def createSocket(self, onion, port):\n        if not self.enabled:\n            return False\n        self.log.debug(\"Creating new Tor socket to %s:%s\" % (onion, port))\n        if config.tor == \"always\":  \n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        else:\n            sock = socks.socksocket()\n            sock.set_proxy(socks.SOCKS5, self.proxy_ip, self.proxy_port)\n        return sock\n", "comments": "  onion  privatekey    site address  onion    test proxy port    change self bundled tor ports    already  downloaded  sync mode    not downloaded yet  async mode    wait startup    terminate exit    check tor webpage link    download tor client    handle redirect    socket proxy patched  use non proxy one    auth cookie file    version 0 2 7 5 required add onion support    get new exit node ip    different onion every site    same onion every site    creates returns    socket connected tor network    every socket proxied default  mode ", "content": "import logging\nimport re\nimport socket\nimport binascii\nimport sys\nimport os\nimport time\nimport random\nimport subprocess\nimport atexit\n\nimport gevent\n\nfrom Config import config\nfrom Crypt import CryptRsa\nfrom Site import SiteManager\nfrom lib.PySocks import socks\ntry:\n    from gevent.coros import RLock\nexcept:\n    from gevent.lock import RLock\nfrom util import helper\nfrom Debug import Debug\nfrom Plugin import PluginManager\n\n\n@PluginManager.acceptPlugins\nclass TorManager(object):\n    def __init__(self, fileserver_ip=None, fileserver_port=None):\n        self.privatekeys = {}  # Onion: Privatekey\n        self.site_onions = {}  # Site address: Onion\n        self.tor_exe = \"tools/tor/tor.exe\"\n        self.tor_process = None\n        self.log = logging.getLogger(\"TorManager\")\n        self.start_onions = None\n        self.conn = None\n        self.lock = RLock()\n\n        if config.tor == \"disable\":\n            self.enabled = False\n            self.start_onions = False\n            self.setStatus(\"Disabled\")\n        else:\n            self.enabled = True\n            self.setStatus(\"Waiting\")\n\n        if fileserver_port:\n            self.fileserver_port = fileserver_port\n        else:\n            self.fileserver_port = config.fileserver_port\n\n        self.ip, self.port = config.tor_controller.split(\":\")\n        self.port = int(self.port)\n\n        self.proxy_ip, self.proxy_port = config.tor_proxy.split(\":\")\n        self.proxy_port = int(self.proxy_port)\n\n        # Test proxy port\n        if config.tor != \"disable\":\n            try:\n                assert self.connect(), \"No connection\"\n                self.log.debug(\"Tor proxy port %s check ok\" % config.tor_proxy)\n            except Exception, err:\n                self.log.info(\"Starting self-bundled Tor, due to Tor proxy port %s check error: %s\" % (config.tor_proxy, err))\n                self.enabled = False\n                # Change to self-bundled Tor ports\n                from lib.PySocks import socks\n                self.port = 49051\n                self.proxy_port = 49050\n                socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, \"127.0.0.1\", self.proxy_port)\n                if os.path.isfile(self.tor_exe):  # Already, downloaded: sync mode\n                    self.startTor()\n                else:  # Not downloaded yet: Async mode\n                    gevent.spawn(self.startTor)\n\n    def setStatus(self, status):\n        self.status = status\n        if \"ui_server\" in dir(sys.modules[\"main\"]):\n            sys.modules[\"main\"].ui_server.updateWebsocket()\n\n    def startTor(self):\n        if sys.platform.startswith(\"win\"):\n            try:\n                if not os.path.isfile(self.tor_exe):\n                    self.downloadTor()\n\n                self.log.info(\"Starting Tor client %s...\" % self.tor_exe)\n                tor_dir = os.path.dirname(self.tor_exe)\n                startupinfo = subprocess.STARTUPINFO()\n                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n                self.tor_process = subprocess.Popen(r\"%s -f torrc\" % self.tor_exe, cwd=tor_dir, close_fds=True, startupinfo=startupinfo)\n                for wait in range(1, 10):  # Wait for startup\n                    time.sleep(wait * 0.5)\n                    self.enabled = True\n                    if self.connect():\n                        break\n                # Terminate on exit\n                atexit.register(self.stopTor)\n            except Exception, err:\n                self.log.error(\"Error starting Tor client: %s\" % Debug.formatException(err))\n                self.enabled = False\n        return False\n\n    def stopTor(self):\n        self.log.debug(\"Stopping...\")\n        try:\n            self.tor_process.terminate()\n        except Exception, err:\n            self.log.error(\"Error stopping Tor: %s\" % err)\n\n    def downloadTor(self):\n        self.log.info(\"Downloading Tor...\")\n        # Check Tor webpage for link\n        download_page = helper.httpRequest(\"https://www.torproject.org/download/download.html\").read()\n        download_url = re.search('href=\"(.*?tor.*?win32.*?zip)\"', download_page).group(1)\n        if not download_url.startswith(\"http\"):\n            download_url = \"https://www.torproject.org/download/\" + download_url\n\n        # Download Tor client\n        self.log.info(\"Downloading %s\" % download_url)\n        data = helper.httpRequest(download_url, as_file=True)\n        data_size = data.tell()\n\n        # Handle redirect\n        if data_size < 1024 and \"The document has moved\" in data.getvalue():\n            download_url = re.search('href=\"(.*?tor.*?win32.*?zip)\"', data.getvalue()).group(1)\n            data = helper.httpRequest(download_url, as_file=True)\n            data_size = data.tell()\n\n        if data_size > 1024:\n            import zipfile\n            zip = zipfile.ZipFile(data)\n            self.log.info(\"Unpacking Tor\")\n            for inner_path in zip.namelist():\n                if \"..\" in inner_path:\n                    continue\n                dest_path = inner_path\n                dest_path = re.sub(\"^Data/Tor/\", \"tools/tor/data/\", dest_path)\n                dest_path = re.sub(\"^Data/\", \"tools/tor/data/\", dest_path)\n                dest_path = re.sub(\"^Tor/\", \"tools/tor/\", dest_path)\n                dest_dir = os.path.dirname(dest_path)\n                if dest_dir and not os.path.isdir(dest_dir):\n                    os.makedirs(dest_dir)\n\n                if dest_dir != dest_path.strip(\"/\"):\n                    data = zip.read(inner_path)\n                    if not os.path.isfile(dest_path):\n                        open(dest_path, 'wb').write(data)\n        else:\n            self.log.error(\"Bad response from server: %s\" % data.getvalue())\n            return False\n\n    def connect(self):\n        if not self.enabled:\n            return False\n        self.site_onions = {}\n        self.privatekeys = {}\n\n        return self.connectController()\n\n    def connectController(self):\n        if \"socket_noproxy\" in dir(socket):  # Socket proxy-patched, use non-proxy one\n            conn = socket.socket_noproxy(socket.AF_INET, socket.SOCK_STREAM)\n        else:\n            conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n        self.log.info(\"Connecting to Tor Controller %s:%s\" % (self.ip, self.port))\n        try:\n            with self.lock:\n                conn.connect((self.ip, self.port))\n\n                # Auth cookie file\n                res_protocol = self.send(\"PROTOCOLINFO\", conn)\n                cookie_match = re.search('COOKIEFILE=\"(.*?)\"', res_protocol)\n                if cookie_match:\n                    cookie_file = cookie_match.group(1).decode(\"string-escape\")\n                    auth_hex = binascii.b2a_hex(open(cookie_file, \"rb\").read())\n                    res_auth = self.send(\"AUTHENTICATE %s\" % auth_hex, conn)\n                elif config.tor_password:\n                    res_auth = self.send('AUTHENTICATE \"%s\"' % config.tor_password, conn)\n                else:\n                    res_auth = self.send(\"AUTHENTICATE\", conn)\n\n                assert \"250 OK\" in res_auth, \"Authenticate error %s\" % res_auth\n\n                # Version 0.2.7.5 required because ADD_ONION support\n                res_version = self.send(\"GETINFO version\", conn)\n                version = re.search('version=([0-9\\.]+)', res_version).group(1)\n                assert float(version.replace(\".\", \"0\", 2)) >= 207.5, \"Tor version >=0.2.7.5 required, found: %s\" % version\n\n                self.setStatus(u\"Connected (%s)\" % res_auth)\n                self.conn = conn\n        except Exception, err:\n            self.conn = None\n            self.setStatus(u\"Error (%s)\" % err)\n            self.log.warning(\"Tor controller connect error: %s\" % Debug.formatException(err))\n            self.enabled = False\n        return self.conn\n\n    def disconnect(self):\n        self.conn.close()\n        self.conn = None\n\n    def startOnions(self):\n        if self.enabled:\n            self.log.debug(\"Start onions\")\n            self.start_onions = True\n            self.getOnion(\"global\")\n\n    # Get new exit node ip\n    def resetCircuits(self):\n        res = self.request(\"SIGNAL NEWNYM\")\n        if \"250 OK\" not in res:\n            self.setStatus(u\"Reset circuits error (%s)\" % res)\n            self.log.error(\"Tor reset circuits error: %s\" % res)\n\n    def addOnion(self):\n        if len(self.privatekeys) >= config.tor_hs_limit:\n            return random.choice([key for key in self.privatekeys.keys() if key != self.site_onions.get(\"global\")])\n\n        result = self.makeOnionAndKey()\n        if result:\n            onion_address, onion_privatekey = result\n            self.privatekeys[onion_address] = onion_privatekey\n            self.setStatus(u\"OK (%s onions running)\" % len(self.privatekeys))\n            SiteManager.peer_blacklist.append((onion_address + \".onion\", self.fileserver_port))\n            return onion_address\n        else:\n            return False\n\n    def makeOnionAndKey(self):\n        res = self.request(\"ADD_ONION NEW:RSA1024 port=%s\" % self.fileserver_port)\n        match = re.search(\"ServiceID=([A-Za-z0-9]+).*PrivateKey=RSA1024:(.*?)[\\r\\n]\", res, re.DOTALL)\n        if match:\n            onion_address, onion_privatekey = match.groups()\n            return (onion_address, onion_privatekey)\n        else:\n            self.setStatus(u\"AddOnion error (%s)\" % res)\n            self.log.error(\"Tor addOnion error: %s\" % res)\n            return False\n\n    def delOnion(self, address):\n        res = self.request(\"DEL_ONION %s\" % address)\n        if \"250 OK\" in res:\n            del self.privatekeys[address]\n            self.setStatus(\"OK (%s onion running)\" % len(self.privatekeys))\n            return True\n        else:\n            self.setStatus(u\"DelOnion error (%s)\" % res)\n            self.log.error(\"Tor delOnion error: %s\" % res)\n            self.disconnect()\n            return False\n\n    def request(self, cmd):\n        with self.lock:\n            if not self.enabled:\n                return False\n            if not self.conn:\n                if not self.connect():\n                    return \"\"\n            return self.send(cmd)\n\n    def send(self, cmd, conn=None):\n        if not conn:\n            conn = self.conn\n        self.log.debug(\"> %s\" % cmd)\n        back = \"\"\n        for retry in range(2):\n            try:\n                conn.sendall(\"%s\\r\\n\" % cmd)\n                while not back.endswith(\"250 OK\\r\\n\"):\n                    back += conn.recv(1024 * 64).decode(\"utf8\", \"ignore\")\n                break\n            except Exception, err:\n                self.log.error(\"Tor send error: %s, reconnecting...\" % err)\n                self.disconnect()\n                time.sleep(1)\n                self.connect()\n                back = None\n        self.log.debug(\"< %s\" % back.strip())\n        return back\n\n    def getPrivatekey(self, address):\n        return self.privatekeys[address]\n\n    def getPublickey(self, address):\n        return CryptRsa.privatekeyToPublickey(self.privatekeys[address])\n\n    def getOnion(self, site_address):\n        with self.lock:\n            if not self.enabled:\n                return None\n            if config.tor == \"always\":  # Different onion for every site\n                onion = self.site_onions.get(site_address)\n            else:  # Same onion for every site\n                onion = self.site_onions.get(\"global\")\n                site_address = \"global\"\n            if not onion:\n                self.site_onions[site_address] = self.addOnion()\n                onion = self.site_onions[site_address]\n                self.log.debug(\"Created new hidden service for %s: %s\" % (site_address, onion))\n            return onion\n\n    # Creates and returns a\n    # socket that has connected to the Tor Network\n    def createSocket(self, onion, port):\n        if not self.enabled:\n            return False\n        self.log.debug(\"Creating new Tor socket to %s:%s\" % (onion, port))\n        if config.tor == \"always\":  # Every socket is proxied by default, in this mode\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        else:\n            sock = socks.socksocket()\n            sock.set_proxy(socks.SOCKS5, self.proxy_ip, self.proxy_port)\n        return sock\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "TorManager.py", "id": "9f6e8dadfbbb6b99efdd6da378c39e3e", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/Tor/TorManager.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}