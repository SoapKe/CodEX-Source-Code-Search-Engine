{"author": "apache", "code": "# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nimport logging\n\nimport sqlparse\nfrom sqlparse.sql import Identifier, IdentifierList\nfrom sqlparse.tokens import Keyword, Name\n\nRESULT_OPERATIONS = {'UNION', 'INTERSECT', 'EXCEPT'}\nPRECEDES_TABLE_NAME = {'FROM', 'JOIN', 'DESC', 'DESCRIBE', 'WITH'}\n\n\n\nclass SupersetQuery(object):\n    def __init__(self, sql_statement):\n        self.sql = sql_statement\n        self._table_names = set()\n        self._alias_names = set()\n        \n        logging.info('Parsing with sqlparse statement {}'.format(self.sql))\n        self._parsed = sqlparse.parse(self.sql)\n        for statement in self._parsed:\n            self.__extract_from_token(statement)\n        self._table_names = self._table_names - self._alias_names\n\n    @property\n    def tables(self):\n        return self._table_names\n\n    def is_select(self):\n        return self._parsed[0].get_type() == 'SELECT'\n\n    def stripped(self):\n        sql = self.sql\n        if sql:\n            while sql[-1] in (' ', ';', '\\n', '\\t'):\n                sql = sql[:-1]\n            return sql\n\n    @staticmethod\n    def __precedes_table_name(token_value):\n        for keyword in PRECEDES_TABLE_NAME:\n            if keyword in token_value:\n                return True\n        return False\n\n    @staticmethod\n    def __get_full_name(identifier):\n        if len(identifier.tokens) > 1 and identifier.tokens[1].value == '.':\n            return '{}.{}'.format(identifier.tokens[0].value,\n                                  identifier.tokens[2].value)\n        return identifier.get_real_name()\n\n    @staticmethod\n    def __is_result_operation(keyword):\n        for operation in RESULT_OPERATIONS:\n            if operation in keyword.upper():\n                return True\n        return False\n\n    @staticmethod\n    def __is_identifier(token):\n        return (\n            isinstance(token, IdentifierList) or isinstance(token, Identifier))\n\n    def __process_identifier(self, identifier):\n        \n        if '(' not in '{}'.format(identifier):\n            self._table_names.add(SupersetQuery.__get_full_name(identifier))\n            return\n\n        \n        if hasattr(identifier, 'get_alias'):\n            self._alias_names.add(identifier.get_alias())\n        if hasattr(identifier, 'tokens'):\n            \n            if identifier.tokens[0].ttype == Name:\n                self._alias_names.add(identifier.tokens[0].value)\n        self.__extract_from_token(identifier)\n\n    def as_create_table(self, table_name, overwrite=False):\n        \n        # TODO(bkyryliuk): enforce that all the columns have names.\n        \n        # TODO(bkyryliuk): drop table if allowed, check the namespace and\n        \n        \n        exec_sql = ''\n        sql = self.stripped()\n        if overwrite:\n            exec_sql = 'DROP TABLE IF EXISTS {table_name};\\n'\n        exec_sql += 'CREATE TABLE {table_name} AS \\n{sql}'\n        return exec_sql.format(**locals())\n\n    def __extract_from_token(self, token):\n        if not hasattr(token, 'tokens'):\n            return\n\n        table_name_preceding_token = False\n\n        for item in token.tokens:\n            if item.is_group and not self.__is_identifier(item):\n                self.__extract_from_token(item)\n\n            if item.ttype in Keyword:\n                if SupersetQuery.__precedes_table_name(item.value.upper()):\n                    table_name_preceding_token = True\n                    continue\n\n            if not table_name_preceding_token:\n                continue\n\n            if item.ttype in Keyword:\n                if SupersetQuery.__is_result_operation(item.value):\n                    table_name_preceding_token = False\n                    continue\n                \n                break\n\n            if isinstance(item, Identifier):\n                self.__process_identifier(item)\n\n            if isinstance(item, IdentifierList):\n                for token in item.tokens:\n                    if SupersetQuery.__is_identifier(token):\n                        self.__process_identifier(token)\n", "comments": "   reformats query create table query           works single select sql statements  cases         sql query modified           param superset query  string  sql query executed          param table name  string  contain results             query execution          param overwrite  boolean  table table name dropped true          return  string  create table query                    coding  utf 8        todo  sql lab logic     todo  multistatement support    exclude subselects    store aliases    aliases parsed properly    todo(bkyryliuk)  enforce columns names     presto requires cta operation     todo(bkyryliuk)  drop table allowed  check namespace                     permissions     todo raise multi statement    from clause ", "content": "# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nimport logging\n\nimport sqlparse\nfrom sqlparse.sql import Identifier, IdentifierList\nfrom sqlparse.tokens import Keyword, Name\n\nRESULT_OPERATIONS = {'UNION', 'INTERSECT', 'EXCEPT'}\nPRECEDES_TABLE_NAME = {'FROM', 'JOIN', 'DESC', 'DESCRIBE', 'WITH'}\n\n\n# TODO: some sql_lab logic here.\nclass SupersetQuery(object):\n    def __init__(self, sql_statement):\n        self.sql = sql_statement\n        self._table_names = set()\n        self._alias_names = set()\n        # TODO: multistatement support\n        logging.info('Parsing with sqlparse statement {}'.format(self.sql))\n        self._parsed = sqlparse.parse(self.sql)\n        for statement in self._parsed:\n            self.__extract_from_token(statement)\n        self._table_names = self._table_names - self._alias_names\n\n    @property\n    def tables(self):\n        return self._table_names\n\n    def is_select(self):\n        return self._parsed[0].get_type() == 'SELECT'\n\n    def stripped(self):\n        sql = self.sql\n        if sql:\n            while sql[-1] in (' ', ';', '\\n', '\\t'):\n                sql = sql[:-1]\n            return sql\n\n    @staticmethod\n    def __precedes_table_name(token_value):\n        for keyword in PRECEDES_TABLE_NAME:\n            if keyword in token_value:\n                return True\n        return False\n\n    @staticmethod\n    def __get_full_name(identifier):\n        if len(identifier.tokens) > 1 and identifier.tokens[1].value == '.':\n            return '{}.{}'.format(identifier.tokens[0].value,\n                                  identifier.tokens[2].value)\n        return identifier.get_real_name()\n\n    @staticmethod\n    def __is_result_operation(keyword):\n        for operation in RESULT_OPERATIONS:\n            if operation in keyword.upper():\n                return True\n        return False\n\n    @staticmethod\n    def __is_identifier(token):\n        return (\n            isinstance(token, IdentifierList) or isinstance(token, Identifier))\n\n    def __process_identifier(self, identifier):\n        # exclude subselects\n        if '(' not in '{}'.format(identifier):\n            self._table_names.add(SupersetQuery.__get_full_name(identifier))\n            return\n\n        # store aliases\n        if hasattr(identifier, 'get_alias'):\n            self._alias_names.add(identifier.get_alias())\n        if hasattr(identifier, 'tokens'):\n            # some aliases are not parsed properly\n            if identifier.tokens[0].ttype == Name:\n                self._alias_names.add(identifier.tokens[0].value)\n        self.__extract_from_token(identifier)\n\n    def as_create_table(self, table_name, overwrite=False):\n        \"\"\"Reformats the query into the create table as query.\n\n        Works only for the single select SQL statements, in all other cases\n        the sql query is not modified.\n        :param superset_query: string, sql query that will be executed\n        :param table_name: string, will contain the results of the\n            query execution\n        :param overwrite, boolean, table table_name will be dropped if true\n        :return: string, create table as query\n        \"\"\"\n        # TODO(bkyryliuk): enforce that all the columns have names.\n        # Presto requires it for the CTA operation.\n        # TODO(bkyryliuk): drop table if allowed, check the namespace and\n        #                  the permissions.\n        # TODO raise if multi-statement\n        exec_sql = ''\n        sql = self.stripped()\n        if overwrite:\n            exec_sql = 'DROP TABLE IF EXISTS {table_name};\\n'\n        exec_sql += 'CREATE TABLE {table_name} AS \\n{sql}'\n        return exec_sql.format(**locals())\n\n    def __extract_from_token(self, token):\n        if not hasattr(token, 'tokens'):\n            return\n\n        table_name_preceding_token = False\n\n        for item in token.tokens:\n            if item.is_group and not self.__is_identifier(item):\n                self.__extract_from_token(item)\n\n            if item.ttype in Keyword:\n                if SupersetQuery.__precedes_table_name(item.value.upper()):\n                    table_name_preceding_token = True\n                    continue\n\n            if not table_name_preceding_token:\n                continue\n\n            if item.ttype in Keyword:\n                if SupersetQuery.__is_result_operation(item.value):\n                    table_name_preceding_token = False\n                    continue\n                # FROM clause is over\n                break\n\n            if isinstance(item, Identifier):\n                self.__process_identifier(item)\n\n            if isinstance(item, IdentifierList):\n                for token in item.tokens:\n                    if SupersetQuery.__is_identifier(token):\n                        self.__process_identifier(token)\n", "description": "Apache Superset (incubating) is a modern, enterprise-ready business intelligence web application", "file_name": "sql_parse.py", "id": "80849412365618e869b929066f4c2a5d", "language": "Python", "project_name": "incubator-superset", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/apache-incubator-superset/apache-incubator-superset-95a9b04/superset/sql_parse.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:41:03Z", "url": "https://github.com/apache/incubator-superset", "wiki": false}