{"author": "getsentry", "code": "# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport mock\nimport six\nimport time\n\nfrom exam import fixture, patcher\n\nfrom sentry.quotas.redis import (\n    is_rate_limited,\n    BasicRedisQuota,\n    RedisQuota,\n)\nfrom sentry.testutils import TestCase\nfrom sentry.utils.redis import clusters\nfrom six.moves import xrange\n\n\ndef test_is_rate_limited_script():\n    now = int(time.time())\n\n    cluster = clusters.get('default')\n    client = cluster.get_local_client(six.next(iter(cluster.hosts)))\n\n    \n    assert list(map(bool, is_rate_limited(\n                client, ('foo', 'r:foo', 'bar', 'r:bar'), (1, now + 60, 2, now + 120)))\n                ) == [False, False]\n\n    # The item should be rate limited by the first key (1).\n    assert list(map(bool, is_rate_limited(\n                client, ('foo', 'r:foo', 'bar', 'r:bar'), (1, now + 60, 2, now + 120)))\n                ) == [True, False]\n\n    # The item should still be rate limited by the first key (1), but *not*\n    # rate limited by the second key (2) even though this is the third time\n    \n    \n    assert list(map(bool, is_rate_limited(\n                client, ('foo', 'r:foo', 'bar', 'r:bar'), (1, now + 60, 2, now + 120)))\n                ) == [True, False]\n\n    assert client.get('foo') == '1'\n    assert 59 <= client.ttl('foo') <= 60\n\n    assert client.get('bar') == '1'\n    assert 119 <= client.ttl('bar') <= 120\n\n    \n    assert client.get('r:foo') is None\n    assert client.get('r:bar') is None\n\n    \n    client.set('apple', 5)\n    \n    is_rate_limited(\n        client, ('orange', 'baz'), (1, now + 60)\n    )\n    \n    assert list(map(bool, is_rate_limited(\n        client, ('orange', 'baz'), (1, now + 60)\n    ))) == [True, ]\n    \n    assert list(map(bool, is_rate_limited(\n        client, ('orange', 'apple'), (1, now + 60)\n    ))) == [False, ]\n\n\nclass RedisQuotaTest(TestCase):\n    quota = fixture(RedisQuota)\n\n    @patcher.object(RedisQuota, 'get_project_quota')\n    def get_project_quota(self):\n        inst = mock.MagicMock()\n        inst.return_value = (0, 60)\n        return inst\n\n    @patcher.object(RedisQuota, 'get_organization_quota')\n    def get_organization_quota(self):\n        inst = mock.MagicMock()\n        inst.return_value = (0, 60)\n        return inst\n\n    def test_uses_defined_quotas(self):\n        self.get_project_quota.return_value = (200, 60)\n        self.get_organization_quota.return_value = (300, 60)\n        quotas = self.quota.get_quotas(self.project)\n        assert quotas[0].key == 'p:{}'.format(self.project.id)\n        assert quotas[0].limit == 200\n        assert quotas[0].window == 60\n        assert quotas[1].key == 'o:{}'.format(self.project.organization.id)\n        assert quotas[1].limit == 300\n        assert quotas[1].window == 60\n\n    @mock.patch('sentry.quotas.redis.is_rate_limited')\n    @mock.patch.object(RedisQuota, 'get_quotas', return_value=[])\n    def test_bails_immediately_without_any_quota(self, get_quotas, is_rate_limited):\n        result = self.quota.is_rate_limited(self.project)\n        assert not is_rate_limited.called\n        assert not result.is_limited\n\n    @mock.patch('sentry.quotas.redis.is_rate_limited', return_value=(False, False))\n    def test_is_not_limited_without_rejections(self, is_rate_limited):\n        self.get_organization_quota.return_value = (100, 60)\n        self.get_project_quota.return_value = (200, 60)\n        assert not self.quota.is_rate_limited(self.project).is_limited\n\n    @mock.patch('sentry.quotas.redis.is_rate_limited', return_value=(True, False))\n    def test_is_limited_on_rejections(self, is_rate_limited):\n        self.get_organization_quota.return_value = (100, 60)\n        self.get_project_quota.return_value = (200, 60)\n        assert self.quota.is_rate_limited(self.project).is_limited\n\n    @mock.patch.object(RedisQuota, 'get_quotas')\n    @mock.patch('sentry.quotas.redis.is_rate_limited', return_value=(True, False))\n    def test_not_limited_without_enforce(self, mock_is_rate_limited, mock_get_quotas):\n        mock_get_quotas.return_value = (\n            BasicRedisQuota(\n                key='p:1',\n                limit=1,\n                window=1,\n                reason_code='project_quota',\n                enforce=False,\n            ), BasicRedisQuota(\n                key='p:2',\n                limit=1,\n                window=1,\n                reason_code='project_quota',\n                enforce=True,\n            ),\n        )\n\n        assert not self.quota.is_rate_limited(self.project).is_limited\n\n    @mock.patch.object(RedisQuota, 'get_quotas')\n    @mock.patch('sentry.quotas.redis.is_rate_limited', return_value=(True, True))\n    def test_limited_without_enforce(self, mock_is_rate_limited, mock_get_quotas):\n        mock_get_quotas.return_value = (\n            BasicRedisQuota(\n                key='p:1',\n                limit=1,\n                window=1,\n                reason_code='project_quota',\n                enforce=False,\n            ), BasicRedisQuota(\n                key='p:2',\n                limit=1,\n                window=1,\n                reason_code='project_quota',\n                enforce=True,\n            ),\n        )\n\n        assert self.quota.is_rate_limited(self.project).is_limited\n\n    def test_get_usage(self):\n        timestamp = time.time()\n\n        self.get_project_quota.return_value = (200, 60)\n        self.get_organization_quota.return_value = (300, 60)\n\n        n = 10\n        for _ in xrange(n):\n            self.quota.is_rate_limited(self.project, timestamp=timestamp)\n\n        quotas = self.quota.get_quotas(self.project)\n\n        assert self.quota.get_usage(\n            self.project.organization_id,\n            quotas + [\n                BasicRedisQuota(\n                    key='unlimited',\n                    limit=0,\n                    window=60,\n                    reason_code='unlimited',\n                ),\n                BasicRedisQuota(\n                    key='dummy',\n                    limit=10,\n                    window=60,\n                    reason_code='dummy',\n                ),\n            ],\n            timestamp=timestamp,\n        ) == [n for _ in quotas] + [None, 0]\n\n    @mock.patch.object(RedisQuota, 'get_quotas')\n    def test_refund(self, mock_get_quotas):\n        timestamp = time.time()\n\n        mock_get_quotas.return_value = (\n            BasicRedisQuota(\n                key='p:1',\n                limit=1,\n                window=1,\n                reason_code='project_quota',\n                enforce=False,\n            ), BasicRedisQuota(\n                key='p:2',\n                limit=1,\n                window=1,\n                reason_code='project_quota',\n                enforce=True,\n            ),\n        )\n\n        self.quota.refund(self.project, timestamp=timestamp)\n        client = self.quota.cluster.get_local_client_for_key(\n            six.text_type(self.project.organization.pk)\n        )\n\n        keys = client.keys('r:quota:p:?:*')\n\n        assert len(keys) == 2\n\n        for key in keys:\n            assert client.get(key) == '1'\n\n    def test_get_usage_uses_refund(self):\n        timestamp = time.time()\n\n        self.get_project_quota.return_value = (200, 60)\n        self.get_organization_quota.return_value = (300, 60)\n\n        n = 10\n        for _ in xrange(n):\n            self.quota.is_rate_limited(self.project, timestamp=timestamp)\n\n        self.quota.refund(self.project, timestamp=timestamp)\n\n        quotas = self.quota.get_quotas(self.project)\n\n        assert self.quota.get_usage(\n            self.project.organization_id,\n            quotas + [\n                BasicRedisQuota(\n                    key='unlimited',\n                    limit=0,\n                    window=60,\n                    reason_code='unlimited',\n                ),\n                BasicRedisQuota(\n                    key='dummy',\n                    limit=10,\n                    window=60,\n                    reason_code='dummy',\n                ),\n            ],\n            timestamp=timestamp,\n            \n        ) == [n - 1 for _ in quotas] + [None, 0]\n", "comments": "      coding  utf 8        the item rate limited either key     the item rate limited first key (1)     the item still rate limited first key (1)       rate limited second key (2) even though third time    checked quotas  this ensures items rejected lower    quota affect unrelated items share parent quota     make sure  refund negative  keys incremented    test refunded quotas work    increment    test rate limited without refund    test refund key used      1 refunded ", "content": "# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport mock\nimport six\nimport time\n\nfrom exam import fixture, patcher\n\nfrom sentry.quotas.redis import (\n    is_rate_limited,\n    BasicRedisQuota,\n    RedisQuota,\n)\nfrom sentry.testutils import TestCase\nfrom sentry.utils.redis import clusters\nfrom six.moves import xrange\n\n\ndef test_is_rate_limited_script():\n    now = int(time.time())\n\n    cluster = clusters.get('default')\n    client = cluster.get_local_client(six.next(iter(cluster.hosts)))\n\n    # The item should not be rate limited by either key.\n    assert list(map(bool, is_rate_limited(\n                client, ('foo', 'r:foo', 'bar', 'r:bar'), (1, now + 60, 2, now + 120)))\n                ) == [False, False]\n\n    # The item should be rate limited by the first key (1).\n    assert list(map(bool, is_rate_limited(\n                client, ('foo', 'r:foo', 'bar', 'r:bar'), (1, now + 60, 2, now + 120)))\n                ) == [True, False]\n\n    # The item should still be rate limited by the first key (1), but *not*\n    # rate limited by the second key (2) even though this is the third time\n    # we've checked the quotas. This ensures items that are rejected by a lower\n    # quota don't affect unrelated items that share a parent quota.\n    assert list(map(bool, is_rate_limited(\n                client, ('foo', 'r:foo', 'bar', 'r:bar'), (1, now + 60, 2, now + 120)))\n                ) == [True, False]\n\n    assert client.get('foo') == '1'\n    assert 59 <= client.ttl('foo') <= 60\n\n    assert client.get('bar') == '1'\n    assert 119 <= client.ttl('bar') <= 120\n\n    # make sure \"refund/negative\" keys haven't been incremented\n    assert client.get('r:foo') is None\n    assert client.get('r:bar') is None\n\n    # Test that refunded quotas work\n    client.set('apple', 5)\n    # increment\n    is_rate_limited(\n        client, ('orange', 'baz'), (1, now + 60)\n    )\n    # test that it's rate limited without refund\n    assert list(map(bool, is_rate_limited(\n        client, ('orange', 'baz'), (1, now + 60)\n    ))) == [True, ]\n    # test that refund key is used\n    assert list(map(bool, is_rate_limited(\n        client, ('orange', 'apple'), (1, now + 60)\n    ))) == [False, ]\n\n\nclass RedisQuotaTest(TestCase):\n    quota = fixture(RedisQuota)\n\n    @patcher.object(RedisQuota, 'get_project_quota')\n    def get_project_quota(self):\n        inst = mock.MagicMock()\n        inst.return_value = (0, 60)\n        return inst\n\n    @patcher.object(RedisQuota, 'get_organization_quota')\n    def get_organization_quota(self):\n        inst = mock.MagicMock()\n        inst.return_value = (0, 60)\n        return inst\n\n    def test_uses_defined_quotas(self):\n        self.get_project_quota.return_value = (200, 60)\n        self.get_organization_quota.return_value = (300, 60)\n        quotas = self.quota.get_quotas(self.project)\n        assert quotas[0].key == 'p:{}'.format(self.project.id)\n        assert quotas[0].limit == 200\n        assert quotas[0].window == 60\n        assert quotas[1].key == 'o:{}'.format(self.project.organization.id)\n        assert quotas[1].limit == 300\n        assert quotas[1].window == 60\n\n    @mock.patch('sentry.quotas.redis.is_rate_limited')\n    @mock.patch.object(RedisQuota, 'get_quotas', return_value=[])\n    def test_bails_immediately_without_any_quota(self, get_quotas, is_rate_limited):\n        result = self.quota.is_rate_limited(self.project)\n        assert not is_rate_limited.called\n        assert not result.is_limited\n\n    @mock.patch('sentry.quotas.redis.is_rate_limited', return_value=(False, False))\n    def test_is_not_limited_without_rejections(self, is_rate_limited):\n        self.get_organization_quota.return_value = (100, 60)\n        self.get_project_quota.return_value = (200, 60)\n        assert not self.quota.is_rate_limited(self.project).is_limited\n\n    @mock.patch('sentry.quotas.redis.is_rate_limited', return_value=(True, False))\n    def test_is_limited_on_rejections(self, is_rate_limited):\n        self.get_organization_quota.return_value = (100, 60)\n        self.get_project_quota.return_value = (200, 60)\n        assert self.quota.is_rate_limited(self.project).is_limited\n\n    @mock.patch.object(RedisQuota, 'get_quotas')\n    @mock.patch('sentry.quotas.redis.is_rate_limited', return_value=(True, False))\n    def test_not_limited_without_enforce(self, mock_is_rate_limited, mock_get_quotas):\n        mock_get_quotas.return_value = (\n            BasicRedisQuota(\n                key='p:1',\n                limit=1,\n                window=1,\n                reason_code='project_quota',\n                enforce=False,\n            ), BasicRedisQuota(\n                key='p:2',\n                limit=1,\n                window=1,\n                reason_code='project_quota',\n                enforce=True,\n            ),\n        )\n\n        assert not self.quota.is_rate_limited(self.project).is_limited\n\n    @mock.patch.object(RedisQuota, 'get_quotas')\n    @mock.patch('sentry.quotas.redis.is_rate_limited', return_value=(True, True))\n    def test_limited_without_enforce(self, mock_is_rate_limited, mock_get_quotas):\n        mock_get_quotas.return_value = (\n            BasicRedisQuota(\n                key='p:1',\n                limit=1,\n                window=1,\n                reason_code='project_quota',\n                enforce=False,\n            ), BasicRedisQuota(\n                key='p:2',\n                limit=1,\n                window=1,\n                reason_code='project_quota',\n                enforce=True,\n            ),\n        )\n\n        assert self.quota.is_rate_limited(self.project).is_limited\n\n    def test_get_usage(self):\n        timestamp = time.time()\n\n        self.get_project_quota.return_value = (200, 60)\n        self.get_organization_quota.return_value = (300, 60)\n\n        n = 10\n        for _ in xrange(n):\n            self.quota.is_rate_limited(self.project, timestamp=timestamp)\n\n        quotas = self.quota.get_quotas(self.project)\n\n        assert self.quota.get_usage(\n            self.project.organization_id,\n            quotas + [\n                BasicRedisQuota(\n                    key='unlimited',\n                    limit=0,\n                    window=60,\n                    reason_code='unlimited',\n                ),\n                BasicRedisQuota(\n                    key='dummy',\n                    limit=10,\n                    window=60,\n                    reason_code='dummy',\n                ),\n            ],\n            timestamp=timestamp,\n        ) == [n for _ in quotas] + [None, 0]\n\n    @mock.patch.object(RedisQuota, 'get_quotas')\n    def test_refund(self, mock_get_quotas):\n        timestamp = time.time()\n\n        mock_get_quotas.return_value = (\n            BasicRedisQuota(\n                key='p:1',\n                limit=1,\n                window=1,\n                reason_code='project_quota',\n                enforce=False,\n            ), BasicRedisQuota(\n                key='p:2',\n                limit=1,\n                window=1,\n                reason_code='project_quota',\n                enforce=True,\n            ),\n        )\n\n        self.quota.refund(self.project, timestamp=timestamp)\n        client = self.quota.cluster.get_local_client_for_key(\n            six.text_type(self.project.organization.pk)\n        )\n\n        keys = client.keys('r:quota:p:?:*')\n\n        assert len(keys) == 2\n\n        for key in keys:\n            assert client.get(key) == '1'\n\n    def test_get_usage_uses_refund(self):\n        timestamp = time.time()\n\n        self.get_project_quota.return_value = (200, 60)\n        self.get_organization_quota.return_value = (300, 60)\n\n        n = 10\n        for _ in xrange(n):\n            self.quota.is_rate_limited(self.project, timestamp=timestamp)\n\n        self.quota.refund(self.project, timestamp=timestamp)\n\n        quotas = self.quota.get_quotas(self.project)\n\n        assert self.quota.get_usage(\n            self.project.organization_id,\n            quotas + [\n                BasicRedisQuota(\n                    key='unlimited',\n                    limit=0,\n                    window=60,\n                    reason_code='unlimited',\n                ),\n                BasicRedisQuota(\n                    key='dummy',\n                    limit=10,\n                    window=60,\n                    reason_code='dummy',\n                ),\n            ],\n            timestamp=timestamp,\n            # the - 1 is because we refunded once\n        ) == [n - 1 for _ in quotas] + [None, 0]\n", "description": "Sentry is a cross-platform crash reporting and aggregation platform.", "file_name": "tests.py", "id": "a13cd2706d40de39b317311c424b28a0", "language": "Python", "project_name": "sentry", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/getsentry-sentry/getsentry-sentry-6a9c7e2/tests/sentry/quotas/redis/tests.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:23:24Z", "url": "https://github.com/getsentry/sentry", "wiki": false}