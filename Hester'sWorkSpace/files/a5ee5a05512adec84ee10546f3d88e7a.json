{"author": "HelloZeroNet", "code": "import random\nimport hashlib\nimport base64\nimport math\n\nclass GaussInt:\n    def __init__(self,x,y,n,p=0):\n        if p:\n            self.x=x%p\n            self.y=y%p\n            self.n=n%p\n        else:\n            self.x=x\n            self.y=y\n            self.n=n\n\n        self.p=p\n        \n    def __add__(self,b):\n        return GaussInt(self.x+b.x,self.y+b.y,self.n,self.p)\n        \n    def __sub__(self,b):\n        return GaussInt(self.x-b.x,self.y-b.y,self.n,self.p)\n    \n    def __mul__(self,b):\n        return GaussInt(self.x*b.x+self.n*self.y*b.y,self.x*b.y+self.y*b.x,self.n,self.p)\n    \n    def __div__(self,b):\n        return GaussInt((self.x*b.x-self.n*self.y*b.y)/(b.x*b.x-self.n*b.y*b.y),(-self.x*b.y+self.y*b.x)/(b.x*b.x-self.n*b.y*b.y),self.n,self.p)\n    \n    def __eq__(self,b):\n        return self.x==b.x and self.y==b.y\n    \n    def __repr__(self):\n        if self.p:\n            return \"%s+%s (%d,%d)\"%(self.x,self.y,self.n,self.p)\n        else:\n            return \"%s+%s (%d)\"%(self.x,self.y,self.n)\n        \n    def __pow__(self,n):\n        b=Base(n,2)\n        t=GaussInt(1,0,self.n)\n        while b:\n            t=t*t\n            if b.pop():\n                t=self*t\n            \n        return t\n\n    def Inv(self):\n        return GaussInt(self.x/(self.x*self.x-self.n*self.y*self.y),-self.y/(self.x*self.x-self.n*self.y*self.y),self.n,self.p)\n        \n    def Eval(self):\n        return self.x.Eval()+self.y.Eval()*math.sqrt(self.n)   \n\ndef Cipolla(a,p):\n    b=0\n    while pow((b*b-a)%p,(p-1)/2,p)==1:\n        b+=1\n\n    return (GaussInt(b,1,b**2-a,p)**((p+1)/2)).x\n\ndef InvMod(a,n):\n    m=[]\n\n    s=n\n    while n:\n        m.append(a/n)\n        (a,n)=(n,a%n)\n\n    u=1\n    v=0\n    while m:\n        (u,v)=(v,u-m.pop()*v)\n\n    return u%s\n\ndef Base(n,b):\n    l=[]\n    while n:\n        l.append(n%b)\n        n/=b\n\n    return l\n\ndef MsgMagic(message):\n    return \"\\x18Bitcoin Signed Message:\\n\"+chr(len(message))+message\n\ndef Hash(m,method):\n    h=hashlib.new(method)\n    h.update(m)\n\n    return h.digest()\n\ndef b58encode(v):\n    \n    digit=\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n    base=len(digit)\n    val=0\n    for c in v:\n        val*=256\n        val+=ord(c)\n\n    result=\"\"\n    while val:\n        (val,mod)=divmod(val,base)\n        result=digit[mod]+result\n\n    pad=0\n    for c in v:\n        if c==\"\\x00\":\n            pad+=1\n        else:\n            break\n    \n    return (digit[0]*pad)+result\n\ndef b58decode(v):\n    \n    digit=\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n    base=len(digit)\n    val=0    \n    for c in v:\n        val*=base\n        val+=digit.find(c)\n\n    result=\"\"\n    while val:\n        (val,mod)=divmod(val,256)\n        result=chr(mod)+result\n\n    pad=0\n    for c in v:\n        if c==digit[0]:\n            pad+=1\n        else:\n            break\n\n    return \"\\x00\"*pad+result\n\ndef Byte2Int(b):\n    n=0\n    for x in b:\n        n*=256\n        n+=ord(x)\n    \n    return n\n\ndef Byte2Hex(b):\n    \n    out=\"\"\n    for x in b:\n        y=hex(ord(x))[2:]\n        if len(y)==1:\n            y=\"0\"+y\n        out+=\"%2s\"%y\n    \n    return out\n\ndef Int2Byte(n,b):\n    \n    out=\"\"\n    \n    for _ in range(b):\n        (n,m)=divmod(n,256)\n        out=chr(m)+out\n    \n    return out\n\nclass EllipticCurvePoint:\n    \n    \n\n    def __init__(self,x,a,b,p,n=0):\n        \n        \n        self.x=x[:]\n        self.a=a\n        self.b=b\n        self.p=p\n        self.n=n\n    \n    def __add__(self,y):\n        \n        \n        #Projectives coordinates are more efficient than the usual (x,y) coordinates\n        \n        z=EllipticCurvePoint([0,0,0],self.a,self.b,self.p)\n\n        if self==y:\n            d=(2*self.x[1]*self.x[2])%self.p\n            d3=pow(d,3,self.p)\n            n=(3*pow(self.x[0],2,self.p)+self.a*pow(self.x[2],2,self.p))%self.p\n            \n            z.x[0]=(pow(n,2,self.p)*d*self.x[2]-2*d3*self.x[0])%self.p\n            z.x[1]=(3*self.x[0]*n*pow(d,2,self.p)-pow(n,3,self.p)*self.x[2]-self.x[1]*d3)%self.p\n            z.x[2]=(self.x[2]*d3)%self.p\n        else:\n            d=(y.x[0]*self.x[2]-y.x[2]*self.x[0])%self.p\n            d3=pow(d,3,self.p)\n            n=(y.x[1]*self.x[2]-self.x[1]*y.x[2])%self.p\n\n            z.x[0]=(y.x[2]*self.x[2]*pow(n,2,self.p)*d-d3*(y.x[2]*self.x[0]+y.x[0]*self.x[2]))%self.p\n            z.x[1]=(pow(d,2,self.p)*n*(2*self.x[0]*y.x[2]+y.x[0]*self.x[2])-pow(n,3,self.p)*self.x[2]*y.x[2]-self.x[1]*d3*y.x[2])%self.p\n            z.x[2]=(self.x[2]*d3*y.x[2])%self.p\n        \n        return z\n    \n    def __mul__(self,n):\n        \n        b=Base(n,2)\n        t=EllipticCurvePoint(self.x,self.a,self.b,self.p)\n        b.pop()\n        while b:\n            t+=t\n            if b.pop():\n                t+=self\n\n        return t\n    \n    def __repr__(self):\n        #print a point in (x,y) coordinate.\n        return \"x=%d\\ny=%d\\n\"%((self.x[0]*InvMod(self.x[2],self.p))%self.p,(self.x[1]*InvMod(self.x[2],self.p))%self.p)\n    \n    def __eq__(self,y):\n        ?\n        \n        return self.x[0]*y.x[1]==self.x[1]*y.x[0] and self.x[1]*y.x[2]==self.x[2]*y.x[1] and self.x[2]*y.x[0]==self.x[0]*y.x[2] and self.a==y.a and self.b==y.b and self.p==y.p\n    \n    def __ne__(self,y):\n        ?\n        return not (self == y)\n    \n    def Normalize(self):\n        #Transform projective coordinates of self to the usual (x,y) coordinates.\n        if self.x[2]:\n            self.x[0]=(self.x[0]*InvMod(self.x[2],self.p))%self.p\n            self.x[1]=(self.x[1]*InvMod(self.x[2],self.p))%self.p\n            self.x[2]=1\n        elif self.x[1]:\n            self.x[0]=(self.x[0]*InvMod(self.x[1],self.p))%self.p\n            self.x[1]=1\n        elif self.x[0]:\n            self.x[0]=1\n        else:\n            raise Exception\n\n    def Check(self):\n        ?\n        return (self.x[0]**3+self.a*self.x[0]*self.x[2]**2+self.b*self.x[2]**3-self.x[1]**2*self.x[2])%self.p==0\n\n    \n    def CryptAddr(self,filename,password,Address):\n        txt=\"\"\n        for tag in Address:\n            (addr,priv)=Address[tag]\n            if priv:\n                txt+=\"%s\\t%s\\t%s\\n\"%(tag,addr,priv)\n            else:\n                txt+=\"%s\\t%s\\t\\n\"%(tag,addr)\n\n        txt+=\"\\x00\"*(15-(len(txt)-1)%16)\n\n        password+=\"\\x00\"*(15-(len(password)-1)%16)\n        crypt=twofish.Twofish(password).encrypt(txt)\n\n        f=open(filename,\"wb\")\n        f.write(crypt)\n        f.close()\n\n    def GenerateD(self):\n        \n        \n        \n        #return random.randint(1,self.n-1)\n        return random.SystemRandom().randint(1,self.n-1) \n\n    def CheckECDSA(self,sig,message,Q):\n        #Check a signature (r,s) of the message m using the public key self.Q\n        \n        \n        \n        (r,s)=sig\n        \n        if Q.x[2]==0:\n            return False\n        if not Q.Check():\n            return False\n        if (Q*self.n).x[2]!=0:\n            return False\n        if r<1 or r>self.n-1 or s<1 or s>self.n-1:\n            return False\n\n        z=Byte2Int(Hash(Hash(MsgMagic(message),\"SHA256\"),\"SHA256\"))\n        \n        w=InvMod(s,self.n)\n        u1=(z*w)%self.n\n        u2=(r*w)%self.n\n        R=self*u1+Q*u2\n        R.Normalize()\n\n        return (R.x[0]-r)%self.n==0\n\n    def SignMessage(self,message,priv):\n        \n        (d,uncompressed)=self.DFromPriv(priv)\n\n        z=Byte2Int(Hash(Hash(MsgMagic(message),\"SHA256\"),\"SHA256\"))\n        \n        r=0\n        s=0\n        while not r or not s:\n            #k=random.randint(1,self.n-1)\n            k=random.SystemRandom().randint(1,self.n-1) \n            R=self*k\n            R.Normalize()\n            r=R.x[0]%self.n\n            s=(InvMod(k,self.n)*(z+r*d))%self.n\n\n        val=27\n        if not uncompressed:\n            val+=4\n\n        return base64.standard_b64encode(chr(val)+Int2Byte(r,32)+Int2Byte(s,32))\n\n    def VerifyMessageFromAddress(self,addr,message,sig):\n        #Check a signature (r,s) for the message m signed by the Bitcoin \n        \n\n        sign=base64.standard_b64decode(sig)\n        (r,s)=(Byte2Int(sign[1:33]),Byte2Int(sign[33:65]))\n\n        z=Byte2Int(Hash(Hash(MsgMagic(message),\"SHA256\"),\"SHA256\"))        \n\n        val=ord(sign[0])\n        if val<27 or val>=35:\n            return False\n\n        if val>=31:\n            uncompressed=False\n            val-=4\n        else:\n            uncompressed=True\n        \n        x=r\n        y2=(pow(x,3,self.p) + self.a*x + self.b) % self.p\n        y=Cipolla(y2,self.p)\n\n        for _ in range(2):\n            kG=EllipticCurvePoint([x,y,1],self.a,self.b,self.p,self.n)  \n            mzG=self*((-z)%self.n)\n            Q=(kG*s+mzG)*InvMod(r,self.n)\n            \n            if self.AddressFromPublicKey(Q,uncompressed)==addr:\n                return True\n\n            y=self.p-y\n\n        return False\n\n    def AddressFromPrivate(self,priv):\n        \n        (d,uncompressed)=self.DFromPriv(priv)\n        \n        return self.AddressFromD(d,uncompressed)\n\n    def PrivFromD(self,d,uncompressed):\n        \n        p=Int2Byte(d,32)\n        p=\"\\x80\"+p\n        \n        if not uncompressed:\n            p+=chr(1)\n\n        cs=Hash(Hash(p,\"SHA256\"),\"SHA256\")[:4]\n\n        return b58encode(p+cs)\n    \n    def DFromPriv(self,priv):\n        uncompressed=(len(priv)==51)\n        priv=b58decode(priv)\n        \n        if uncompressed:\n            priv=priv[:-4]\n        else:\n            priv=priv[:-5]\n        \n        return (Byte2Int(priv[1:]),uncompressed)\n\n    def AddressFromPublicKey(self,Q,uncompressed):\n        \n        \n        # (x,y) coordinates.\n        Q.Normalize()\n        if uncompressed:\n            pk=chr(4)+Int2Byte(Q.x[0],32)+Int2Byte(Q.x[1],32)\n        else:\n            pk=chr(2+Q.x[1]%2)+Int2Byte(Q.x[0],32)\n\n        kh=chr(0)+Hash(Hash(pk,\"SHA256\"),\"RIPEMD160\")\n        cs=Hash(Hash(kh,\"SHA256\"),\"SHA256\")[:4]\n\n        return b58encode(kh+cs)\n\n    def AddressFromD(self,d,uncompressed):\n        \n        return self.AddressFromPublicKey(self*d,uncompressed)\n\n    def IsValid(self,addr):\n        adr=b58decode(addr)\n        kh=adr[:-4]\n        cs=adr[-4:]\n\n        verif=Hash(Hash(kh,\"SHA256\"),\"SHA256\")[:4]\n\n        return cs==verif\n\n    def AddressGenerator(self,k,uncompressed=True):\n        \n        \n        liste={}\n        for i in range(k):\n            d=self.GenerateD()\n            addr=self.AddressFromD(d,uncompressed)\n            priv=self.PrivFromD(d,uncompressed)\n            liste[i]=[addr,priv]\n            print \"%s %s\"%(addr, priv)\n\n        return liste\n\ndef Bitcoin():\n    a=0\n    b=7\n    p=2**256-2**32-2**9-2**8-2**7-2**6-2**4-1\n    Gx=int(\"79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\",16)\n    Gy=int(\"483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\",16)\n    n=int(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\",16)\n    \n    return EllipticCurvePoint([Gx,Gy,1],a,b,p,n)\n\ndef main():\n    bitcoin=Bitcoin()\n\n    \n    privkey = \"PrivatekeyinBase58\"\n    adr = bitcoin.AddressFromPrivate(privkey)\n    print \"Address : \", adr\n    \n    \n    m=\"Hello World\"\n    sig=bitcoin.SignMessage(\"Hello World\", privkey)\n    \n    \n    if bitcoin.VerifyMessageFromAddress(adr,m,sig):\n        print \"Message verified\"\n    \n    \n    print \"Here are some adresses and associated private keys\"\n    bitcoin.AddressGenerator(10)\n    \nif __name__ == \"__main__\": main()\n", "comments": " encode byte string base58   decode base58 string byte string   convert byte string hex number   convert integer byte string length b   main class   it point elliptic curve   we store coordinate x elliptic curve parameter    x length 3  this 3 projective coordinates point    the main function add self   it uses formulas i derived projective coordinates    projectives coordinates efficient usual (x y) coordinates   need compute inverse mod p  faster    the fast multiplication point n times    print point (x y) coordinate    does self      it computes self cross product x check result 0    does self  x     transform projective coordinates self usual (x y) coordinates    is self curve     generate private key  it random number 1 n 1    of course  function cryptographically secure    don use generate key  use cryptographically secure source randomness instead    return random randint(1 self n 1)    better random fix    check signature (r s) message using public key self q    generator self    this one used bitcoin public key known     hash public key known  see function verifymessagefromaddress    sign message  the private key self    k random randint(1 self n 1)    better random fix   check signature (r s) message signed bitcoin     address  addr     transform private key bitcoin address    encode private key self base58 encoding    find bitcoin address public key self q   we normalization go projective coordinates usual    (x y) coordinates    computes bitcoin address given private key self    generate bitcoin address write multibit format    change date like    generate adress private key   sign message current address   verify message using bitcoin adress  signature message    not using public key needed    generate addresses ", "content": "import random\nimport hashlib\nimport base64\nimport math\n\nclass GaussInt:\n    def __init__(self,x,y,n,p=0):\n        if p:\n            self.x=x%p\n            self.y=y%p\n            self.n=n%p\n        else:\n            self.x=x\n            self.y=y\n            self.n=n\n\n        self.p=p\n        \n    def __add__(self,b):\n        return GaussInt(self.x+b.x,self.y+b.y,self.n,self.p)\n        \n    def __sub__(self,b):\n        return GaussInt(self.x-b.x,self.y-b.y,self.n,self.p)\n    \n    def __mul__(self,b):\n        return GaussInt(self.x*b.x+self.n*self.y*b.y,self.x*b.y+self.y*b.x,self.n,self.p)\n    \n    def __div__(self,b):\n        return GaussInt((self.x*b.x-self.n*self.y*b.y)/(b.x*b.x-self.n*b.y*b.y),(-self.x*b.y+self.y*b.x)/(b.x*b.x-self.n*b.y*b.y),self.n,self.p)\n    \n    def __eq__(self,b):\n        return self.x==b.x and self.y==b.y\n    \n    def __repr__(self):\n        if self.p:\n            return \"%s+%s (%d,%d)\"%(self.x,self.y,self.n,self.p)\n        else:\n            return \"%s+%s (%d)\"%(self.x,self.y,self.n)\n        \n    def __pow__(self,n):\n        b=Base(n,2)\n        t=GaussInt(1,0,self.n)\n        while b:\n            t=t*t\n            if b.pop():\n                t=self*t\n            \n        return t\n\n    def Inv(self):\n        return GaussInt(self.x/(self.x*self.x-self.n*self.y*self.y),-self.y/(self.x*self.x-self.n*self.y*self.y),self.n,self.p)\n        \n    def Eval(self):\n        return self.x.Eval()+self.y.Eval()*math.sqrt(self.n)   \n\ndef Cipolla(a,p):\n    b=0\n    while pow((b*b-a)%p,(p-1)/2,p)==1:\n        b+=1\n\n    return (GaussInt(b,1,b**2-a,p)**((p+1)/2)).x\n\ndef InvMod(a,n):\n    m=[]\n\n    s=n\n    while n:\n        m.append(a/n)\n        (a,n)=(n,a%n)\n\n    u=1\n    v=0\n    while m:\n        (u,v)=(v,u-m.pop()*v)\n\n    return u%s\n\ndef Base(n,b):\n    l=[]\n    while n:\n        l.append(n%b)\n        n/=b\n\n    return l\n\ndef MsgMagic(message):\n    return \"\\x18Bitcoin Signed Message:\\n\"+chr(len(message))+message\n\ndef Hash(m,method):\n    h=hashlib.new(method)\n    h.update(m)\n\n    return h.digest()\n\ndef b58encode(v):\n    #Encode a byte string to the Base58\n    digit=\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n    base=len(digit)\n    val=0\n    for c in v:\n        val*=256\n        val+=ord(c)\n\n    result=\"\"\n    while val:\n        (val,mod)=divmod(val,base)\n        result=digit[mod]+result\n\n    pad=0\n    for c in v:\n        if c==\"\\x00\":\n            pad+=1\n        else:\n            break\n    \n    return (digit[0]*pad)+result\n\ndef b58decode(v):\n    #Decode a Base58 string to byte string\n    digit=\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n    base=len(digit)\n    val=0    \n    for c in v:\n        val*=base\n        val+=digit.find(c)\n\n    result=\"\"\n    while val:\n        (val,mod)=divmod(val,256)\n        result=chr(mod)+result\n\n    pad=0\n    for c in v:\n        if c==digit[0]:\n            pad+=1\n        else:\n            break\n\n    return \"\\x00\"*pad+result\n\ndef Byte2Int(b):\n    n=0\n    for x in b:\n        n*=256\n        n+=ord(x)\n    \n    return n\n\ndef Byte2Hex(b):\n    #Convert a byte string to hex number\n    out=\"\"\n    for x in b:\n        y=hex(ord(x))[2:]\n        if len(y)==1:\n            y=\"0\"+y\n        out+=\"%2s\"%y\n    \n    return out\n\ndef Int2Byte(n,b):\n    #Convert a integer to a byte string of length b\n    out=\"\"\n    \n    for _ in range(b):\n        (n,m)=divmod(n,256)\n        out=chr(m)+out\n    \n    return out\n\nclass EllipticCurvePoint:\n    #Main class\n    #It's a point on an Elliptic Curve\n\n    def __init__(self,x,a,b,p,n=0):\n        #We store the coordinate in x and the elliptic curve parameter.\n        #x is of length 3. This is the 3 projective coordinates of the point.\n        self.x=x[:]\n        self.a=a\n        self.b=b\n        self.p=p\n        self.n=n\n    \n    def __add__(self,y):\n        #The main function to add self and y\n        #It uses the formulas I derived in projective coordinates.\n        #Projectives coordinates are more efficient than the usual (x,y) coordinates\n        #because we don't need to compute inverse mod p, which is faster.\n        z=EllipticCurvePoint([0,0,0],self.a,self.b,self.p)\n\n        if self==y:\n            d=(2*self.x[1]*self.x[2])%self.p\n            d3=pow(d,3,self.p)\n            n=(3*pow(self.x[0],2,self.p)+self.a*pow(self.x[2],2,self.p))%self.p\n            \n            z.x[0]=(pow(n,2,self.p)*d*self.x[2]-2*d3*self.x[0])%self.p\n            z.x[1]=(3*self.x[0]*n*pow(d,2,self.p)-pow(n,3,self.p)*self.x[2]-self.x[1]*d3)%self.p\n            z.x[2]=(self.x[2]*d3)%self.p\n        else:\n            d=(y.x[0]*self.x[2]-y.x[2]*self.x[0])%self.p\n            d3=pow(d,3,self.p)\n            n=(y.x[1]*self.x[2]-self.x[1]*y.x[2])%self.p\n\n            z.x[0]=(y.x[2]*self.x[2]*pow(n,2,self.p)*d-d3*(y.x[2]*self.x[0]+y.x[0]*self.x[2]))%self.p\n            z.x[1]=(pow(d,2,self.p)*n*(2*self.x[0]*y.x[2]+y.x[0]*self.x[2])-pow(n,3,self.p)*self.x[2]*y.x[2]-self.x[1]*d3*y.x[2])%self.p\n            z.x[2]=(self.x[2]*d3*y.x[2])%self.p\n        \n        return z\n    \n    def __mul__(self,n):\n        #The fast multiplication of point n times by itself.\n        b=Base(n,2)\n        t=EllipticCurvePoint(self.x,self.a,self.b,self.p)\n        b.pop()\n        while b:\n            t+=t\n            if b.pop():\n                t+=self\n\n        return t\n    \n    def __repr__(self):\n        #print a point in (x,y) coordinate.\n        return \"x=%d\\ny=%d\\n\"%((self.x[0]*InvMod(self.x[2],self.p))%self.p,(self.x[1]*InvMod(self.x[2],self.p))%self.p)\n    \n    def __eq__(self,y):\n        #Does self==y ?\n        #It computes self cross product with x and check if the result is 0.\n        return self.x[0]*y.x[1]==self.x[1]*y.x[0] and self.x[1]*y.x[2]==self.x[2]*y.x[1] and self.x[2]*y.x[0]==self.x[0]*y.x[2] and self.a==y.a and self.b==y.b and self.p==y.p\n    \n    def __ne__(self,y):\n        #Does self!=x ?\n        return not (self == y)\n    \n    def Normalize(self):\n        #Transform projective coordinates of self to the usual (x,y) coordinates.\n        if self.x[2]:\n            self.x[0]=(self.x[0]*InvMod(self.x[2],self.p))%self.p\n            self.x[1]=(self.x[1]*InvMod(self.x[2],self.p))%self.p\n            self.x[2]=1\n        elif self.x[1]:\n            self.x[0]=(self.x[0]*InvMod(self.x[1],self.p))%self.p\n            self.x[1]=1\n        elif self.x[0]:\n            self.x[0]=1\n        else:\n            raise Exception\n\n    def Check(self):\n        #Is self on the curve ?\n        return (self.x[0]**3+self.a*self.x[0]*self.x[2]**2+self.b*self.x[2]**3-self.x[1]**2*self.x[2])%self.p==0\n\n    \n    def CryptAddr(self,filename,password,Address):\n        txt=\"\"\n        for tag in Address:\n            (addr,priv)=Address[tag]\n            if priv:\n                txt+=\"%s\\t%s\\t%s\\n\"%(tag,addr,priv)\n            else:\n                txt+=\"%s\\t%s\\t\\n\"%(tag,addr)\n\n        txt+=\"\\x00\"*(15-(len(txt)-1)%16)\n\n        password+=\"\\x00\"*(15-(len(password)-1)%16)\n        crypt=twofish.Twofish(password).encrypt(txt)\n\n        f=open(filename,\"wb\")\n        f.write(crypt)\n        f.close()\n\n    def GenerateD(self):\n        #Generate a private key. It's just a random number between 1 and n-1.\n        #Of course, this function isn't cryptographically secure.\n        #Don't use it to generate your key. Use a cryptographically secure source of randomness instead.\n        #return random.randint(1,self.n-1)\n        return random.SystemRandom().randint(1,self.n-1) # Better random fix \n\n    def CheckECDSA(self,sig,message,Q):\n        #Check a signature (r,s) of the message m using the public key self.Q\n        # and the generator which is self.\n        #This is not the one used by Bitcoin because the public key isn't known;\n        # only a hash of the public key is known. See the function VerifyMessageFromAddress.\n        (r,s)=sig\n        \n        if Q.x[2]==0:\n            return False\n        if not Q.Check():\n            return False\n        if (Q*self.n).x[2]!=0:\n            return False\n        if r<1 or r>self.n-1 or s<1 or s>self.n-1:\n            return False\n\n        z=Byte2Int(Hash(Hash(MsgMagic(message),\"SHA256\"),\"SHA256\"))\n        \n        w=InvMod(s,self.n)\n        u1=(z*w)%self.n\n        u2=(r*w)%self.n\n        R=self*u1+Q*u2\n        R.Normalize()\n\n        return (R.x[0]-r)%self.n==0\n\n    def SignMessage(self,message,priv):\n        #Sign a message. The private key is self.d.\n        (d,uncompressed)=self.DFromPriv(priv)\n\n        z=Byte2Int(Hash(Hash(MsgMagic(message),\"SHA256\"),\"SHA256\"))\n        \n        r=0\n        s=0\n        while not r or not s:\n            #k=random.randint(1,self.n-1)\n            k=random.SystemRandom().randint(1,self.n-1) # Better random fix\n            R=self*k\n            R.Normalize()\n            r=R.x[0]%self.n\n            s=(InvMod(k,self.n)*(z+r*d))%self.n\n\n        val=27\n        if not uncompressed:\n            val+=4\n\n        return base64.standard_b64encode(chr(val)+Int2Byte(r,32)+Int2Byte(s,32))\n\n    def VerifyMessageFromAddress(self,addr,message,sig):\n        #Check a signature (r,s) for the message m signed by the Bitcoin \n        # address \"addr\".\n\n        sign=base64.standard_b64decode(sig)\n        (r,s)=(Byte2Int(sign[1:33]),Byte2Int(sign[33:65]))\n\n        z=Byte2Int(Hash(Hash(MsgMagic(message),\"SHA256\"),\"SHA256\"))        \n\n        val=ord(sign[0])\n        if val<27 or val>=35:\n            return False\n\n        if val>=31:\n            uncompressed=False\n            val-=4\n        else:\n            uncompressed=True\n        \n        x=r\n        y2=(pow(x,3,self.p) + self.a*x + self.b) % self.p\n        y=Cipolla(y2,self.p)\n\n        for _ in range(2):\n            kG=EllipticCurvePoint([x,y,1],self.a,self.b,self.p,self.n)  \n            mzG=self*((-z)%self.n)\n            Q=(kG*s+mzG)*InvMod(r,self.n)\n            \n            if self.AddressFromPublicKey(Q,uncompressed)==addr:\n                return True\n\n            y=self.p-y\n\n        return False\n\n    def AddressFromPrivate(self,priv):\n        #Transform a private key to a bitcoin address.\n        (d,uncompressed)=self.DFromPriv(priv)\n        \n        return self.AddressFromD(d,uncompressed)\n\n    def PrivFromD(self,d,uncompressed):\n        #Encode a private key self.d to base58 encoding.\n        p=Int2Byte(d,32)\n        p=\"\\x80\"+p\n        \n        if not uncompressed:\n            p+=chr(1)\n\n        cs=Hash(Hash(p,\"SHA256\"),\"SHA256\")[:4]\n\n        return b58encode(p+cs)\n    \n    def DFromPriv(self,priv):\n        uncompressed=(len(priv)==51)\n        priv=b58decode(priv)\n        \n        if uncompressed:\n            priv=priv[:-4]\n        else:\n            priv=priv[:-5]\n        \n        return (Byte2Int(priv[1:]),uncompressed)\n\n    def AddressFromPublicKey(self,Q,uncompressed):\n        #Find the bitcoin address from the public key self.Q\n        #We do normalization to go from the projective coordinates to the usual\n        # (x,y) coordinates.\n        Q.Normalize()\n        if uncompressed:\n            pk=chr(4)+Int2Byte(Q.x[0],32)+Int2Byte(Q.x[1],32)\n        else:\n            pk=chr(2+Q.x[1]%2)+Int2Byte(Q.x[0],32)\n\n        kh=chr(0)+Hash(Hash(pk,\"SHA256\"),\"RIPEMD160\")\n        cs=Hash(Hash(kh,\"SHA256\"),\"SHA256\")[:4]\n\n        return b58encode(kh+cs)\n\n    def AddressFromD(self,d,uncompressed):\n        #Computes a bitcoin address given the private key self.d.\n        return self.AddressFromPublicKey(self*d,uncompressed)\n\n    def IsValid(self,addr):\n        adr=b58decode(addr)\n        kh=adr[:-4]\n        cs=adr[-4:]\n\n        verif=Hash(Hash(kh,\"SHA256\"),\"SHA256\")[:4]\n\n        return cs==verif\n\n    def AddressGenerator(self,k,uncompressed=True):\n        #Generate Bitcoin address and write them in the multibit format.\n        #Change the date as you like.\n        liste={}\n        for i in range(k):\n            d=self.GenerateD()\n            addr=self.AddressFromD(d,uncompressed)\n            priv=self.PrivFromD(d,uncompressed)\n            liste[i]=[addr,priv]\n            print \"%s %s\"%(addr, priv)\n\n        return liste\n\ndef Bitcoin():\n    a=0\n    b=7\n    p=2**256-2**32-2**9-2**8-2**7-2**6-2**4-1\n    Gx=int(\"79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\",16)\n    Gy=int(\"483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\",16)\n    n=int(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\",16)\n    \n    return EllipticCurvePoint([Gx,Gy,1],a,b,p,n)\n\ndef main():\n    bitcoin=Bitcoin()\n\n    #Generate an adress from the private key\n    privkey = \"PrivatekeyinBase58\"\n    adr = bitcoin.AddressFromPrivate(privkey)\n    print \"Address : \", adr\n    \n    #Sign a message with the current address\n    m=\"Hello World\"\n    sig=bitcoin.SignMessage(\"Hello World\", privkey)\n    #Verify the message using only the bitcoin adress, the signature and the message.\n    #Not using the public key as it is not needed.\n    if bitcoin.VerifyMessageFromAddress(adr,m,sig):\n        print \"Message verified\"\n    \n    #Generate some addresses\n    print \"Here are some adresses and associated private keys\"\n    bitcoin.AddressGenerator(10)\n    \nif __name__ == \"__main__\": main()\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "newBitcoinECC.py", "id": "a5ee5a05512adec84ee10546f3d88e7a", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/lib/BitcoinECC/newBitcoinECC.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}