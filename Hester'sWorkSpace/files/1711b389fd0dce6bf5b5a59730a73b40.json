{"author": "jakubroztocil", "code": "\nimport json\n\nimport argparse\n\nimport pytest\nfrom requests.exceptions import InvalidSchema\n\nfrom httpie import input\nfrom httpie.input import KeyValue, KeyValueArgType, DataDict\nfrom httpie import ExitStatus\nfrom httpie.cli import parser\nfrom utils import MockEnvironment, http, HTTP_OK\nfrom fixtures import (\n    FILE_PATH_ARG, JSON_FILE_PATH_ARG,\n    JSON_FILE_CONTENT, FILE_CONTENT, FILE_PATH\n)\n\n\nclass TestItemParsing:\n\n    key_value = KeyValueArgType(*input.SEP_GROUP_ALL_ITEMS)\n\n    def test_invalid_items(self):\n        items = ['no-separator']\n        for item in items:\n            pytest.raises(argparse.ArgumentTypeError, self.key_value, item)\n\n    def test_escape_separator(self):\n        items = input.parse_items([\n            \n            self.key_value(r'foo\\:bar:baz'),\n            self.key_value(r'jack\\@jill:hill'),\n\n            \n            self.key_value(r'baz\\=bar=foo'),\n\n            \n            self.key_value(r'bar\\@baz@%s' % FILE_PATH_ARG),\n        ])\n        \n        headers = dict(items.headers._store.values())\n\n        assert headers == {\n            'foo:bar': 'baz',\n            'jack@jill': 'hill',\n        }\n        assert items.data == {'baz=bar': 'foo'}\n        assert 'bar@baz' in items.files\n\n    @pytest.mark.parametrize(('string', 'key', 'sep', 'value'), [\n        ('path=c:\\windows', 'path', '=', 'c:\\windows'),\n        ('path=c:\\windows\\\\', 'path', '=', 'c:\\windows\\\\'),\n        ('path\\==c:\\windows', 'path=', '=', 'c:\\windows'),\n    ])\n    def test_backslash_before_non_special_character_does_not_escape(\n            self, string, key, sep, value):\n        expected = KeyValue(orig=string, key=key, sep=sep, value=value)\n        actual = self.key_value(string)\n        assert actual == expected\n\n    def test_escape_longsep(self):\n        items = input.parse_items([\n            self.key_value(r'bob\\:==foo'),\n        ])\n        assert items.params == {'bob:': 'foo'}\n\n    def test_valid_items(self):\n        items = input.parse_items([\n            self.key_value('string=value'),\n            self.key_value('Header:value'),\n            self.key_value('Unset-Header:'),\n            self.key_value('Empty-Header;'),\n            self.key_value('list:=[\"a\", 1, {}, false]'),\n            self.key_value('obj:={\"a\": \"b\"}'),\n            self.key_value('ed='),\n            self.key_value('bool:=true'),\n            self.key_value('file@' + FILE_PATH_ARG),\n            self.key_value('query==value'),\n            self.key_value('string-embed=@' + FILE_PATH_ARG),\n            self.key_value('raw-json-embed:=@' + JSON_FILE_PATH_ARG),\n        ])\n\n        \n        \n        headers = dict(items.headers._store.values())\n        assert headers == {\n            'Header': 'value',\n            'Unset-Header': None,\n            'Empty-Header': ''\n        }\n\n        \n        raw_json_embed = items.data.pop('raw-json-embed')\n        assert raw_json_embed == json.loads(JSON_FILE_CONTENT)\n        items.data['string-embed'] = items.data['string-embed'].strip()\n        assert dict(items.data) == {\n            \"ed\": \"\",\n            \"string\": \"value\",\n            \"bool\": True,\n            \"list\": [\"a\", 1, {}, False],\n            \"obj\": {\"a\": \"b\"},\n            \"string-embed\": FILE_CONTENT,\n        }\n\n        \n        assert items.params == {'query': 'value'}\n\n        \n        assert 'file' in items.files\n        assert (items.files['file'][1].read().strip().\n                decode('utf8') == FILE_CONTENT)\n\n    def test_multiple_file_fields_with_same_field_name(self):\n        items = input.parse_items([\n            self.key_value('file_field@' + FILE_PATH_ARG),\n            self.key_value('file_field@' + FILE_PATH_ARG),\n        ])\n        assert len(items.files['file_field']) == 2\n\n    def test_multiple_text_fields_with_same_field_name(self):\n        items = input.parse_items(\n            [self.key_value('text_field=a'),\n             self.key_value('text_field=b')],\n            data_class=DataDict\n        )\n        assert items.data['text_field'] == ['a', 'b']\n        assert list(items.data.items()) == [\n            ('text_field', 'a'),\n            ('text_field', 'b'),\n        ]\n\n\nclass TestQuerystring:\n    def test_query_string_params_in_url(self, httpbin):\n        r = http('--print=Hhb', 'GET', httpbin.url + '/get?a=1&b=2')\n        path = '/get?a=1&b=2'\n        url = httpbin.url + path\n        assert HTTP_OK in r\n        assert 'GET %s HTTP/1.1' % path in r\n        assert '\"url\": \"%s\"' % url in r\n\n    def test_query_string_params_items(self, httpbin):\n        r = http('--print=Hhb', 'GET', httpbin.url + '/get', 'a==1')\n        path = '/get?a=1'\n        url = httpbin.url + path\n        assert HTTP_OK in r\n        assert 'GET %s HTTP/1.1' % path in r\n        assert '\"url\": \"%s\"' % url in r\n\n    def test_query_string_params_in_url_and_items_with_duplicates(self,\n                                                                  httpbin):\n        r = http('--print=Hhb', 'GET',\n                 httpbin.url + '/get?a=1&a=1', 'a==1', 'a==1')\n        path = '/get?a=1&a=1&a=1&a=1'\n        url = httpbin.url + path\n        assert HTTP_OK in r\n        assert 'GET %s HTTP/1.1' % path in r\n        assert '\"url\": \"%s\"' % url in r\n\n\nclass TestLocalhostShorthand:\n    def test_expand_localhost_shorthand(self):\n        args = parser.parse_args(args=[':'], env=MockEnvironment())\n        assert args.url == 'http://localhost'\n\n    def test_expand_localhost_shorthand_with_slash(self):\n        args = parser.parse_args(args=[':/'], env=MockEnvironment())\n        assert args.url == 'http://localhost/'\n\n    def test_expand_localhost_shorthand_with_port(self):\n        args = parser.parse_args(args=[':3000'], env=MockEnvironment())\n        assert args.url == 'http://localhost:3000'\n\n    def test_expand_localhost_shorthand_with_path(self):\n        args = parser.parse_args(args=[':/path'], env=MockEnvironment())\n        assert args.url == 'http://localhost/path'\n\n    def test_expand_localhost_shorthand_with_port_and_slash(self):\n        args = parser.parse_args(args=[':3000/'], env=MockEnvironment())\n        assert args.url == 'http://localhost:3000/'\n\n    def test_expand_localhost_shorthand_with_port_and_path(self):\n        args = parser.parse_args(args=[':3000/path'], env=MockEnvironment())\n        assert args.url == 'http://localhost:3000/path'\n\n    def test_dont_expand_shorthand_ipv6_as_shorthand(self):\n        args = parser.parse_args(args=['::1'], env=MockEnvironment())\n        assert args.url == 'http://::1'\n\n    def test_dont_expand_longer_ipv6_as_shorthand(self):\n        args = parser.parse_args(\n            args=['::ffff:c000:0280'],\n            env=MockEnvironment()\n        )\n        assert args.url == 'http://::ffff:c000:0280'\n\n    def test_dont_expand_full_ipv6_as_shorthand(self):\n        args = parser.parse_args(\n            args=['0000:0000:0000:0000:0000:0000:0000:0001'],\n            env=MockEnvironment()\n        )\n        assert args.url == 'http://0000:0000:0000:0000:0000:0000:0000:0001'\n\n\nclass TestArgumentParser:\n\n    def setup_method(self, method):\n        self.parser = input.HTTPieArgumentParser()\n\n    def test_guess_when_method_set_and_valid(self):\n        self.parser.args = argparse.Namespace()\n        self.parser.args.method = 'GET'\n        self.parser.args.url = 'http://example.com/'\n        self.parser.args.items = []\n        self.parser.args.ignore_stdin = False\n\n        self.parser.env = MockEnvironment()\n\n        self.parser._guess_method()\n\n        assert self.parser.args.method == 'GET'\n        assert self.parser.args.url == 'http://example.com/'\n        assert self.parser.args.items == []\n\n    def test_guess_when_method_not_set(self):\n        self.parser.args = argparse.Namespace()\n        self.parser.args.method = None\n        self.parser.args.url = 'http://example.com/'\n        self.parser.args.items = []\n        self.parser.args.ignore_stdin = False\n        self.parser.env = MockEnvironment()\n\n        self.parser._guess_method()\n\n        assert self.parser.args.method == 'GET'\n        assert self.parser.args.url == 'http://example.com/'\n        assert self.parser.args.items == []\n\n    def test_guess_when_method_set_but_invalid_and_data_field(self):\n        self.parser.args = argparse.Namespace()\n        self.parser.args.method = 'http://example.com/'\n        self.parser.args.url = 'data=field'\n        self.parser.args.items = []\n        self.parser.args.ignore_stdin = False\n        self.parser.env = MockEnvironment()\n        self.parser._guess_method()\n\n        assert self.parser.args.method == 'POST'\n        assert self.parser.args.url == 'http://example.com/'\n        assert self.parser.args.items == [\n            KeyValue(key='data',\n                     value='field',\n                     sep='=',\n                     orig='data=field')\n        ]\n\n    def test_guess_when_method_set_but_invalid_and_header_field(self):\n        self.parser.args = argparse.Namespace()\n        self.parser.args.method = 'http://example.com/'\n        self.parser.args.url = 'test:header'\n        self.parser.args.items = []\n        self.parser.args.ignore_stdin = False\n\n        self.parser.env = MockEnvironment()\n\n        self.parser._guess_method()\n\n        assert self.parser.args.method == 'GET'\n        assert self.parser.args.url == 'http://example.com/'\n        assert self.parser.args.items, [\n            KeyValue(key='test',\n                     value='header',\n                     sep=':',\n                     orig='test:header')\n        ]\n\n    def test_guess_when_method_set_but_invalid_and_item_exists(self):\n        self.parser.args = argparse.Namespace()\n        self.parser.args.method = 'http://example.com/'\n        self.parser.args.url = 'new_item=a'\n        self.parser.args.items = [\n            KeyValue(\n                key='old_item', value='b', sep='=', orig='old_item=b')\n        ]\n        self.parser.args.ignore_stdin = False\n\n        self.parser.env = MockEnvironment()\n\n        self.parser._guess_method()\n\n        assert self.parser.args.items, [\n            KeyValue(key='new_item', value='a', sep='=', orig='new_item=a'),\n            KeyValue(\n                key='old_item', value='b', sep='=', orig='old_item=b'),\n        ]\n\n\nclass TestNoOptions:\n\n    def test_valid_no_options(self, httpbin):\n        r = http('--verbose', '--no-verbose', 'GET', httpbin.url + '/get')\n        assert 'GET /get HTTP/1.1' not in r\n\n    def test_invalid_no_options(self, httpbin):\n        r = http('--no-war', 'GET', httpbin.url + '/get',\n                 error_exit_ok=True)\n        assert r.exit_status == 1\n        assert 'unrecognized arguments: --no-war' in r.stderr\n        assert 'GET /get HTTP/1.1' not in r\n\n\nclass TestIgnoreStdin:\n\n    def test_ignore_stdin(self, httpbin):\n        with open(FILE_PATH) as f:\n            env = MockEnvironment(stdin=f, stdin_isatty=False)\n            r = http('--ignore-stdin', '--verbose', httpbin.url + '/get',\n                     env=env)\n        assert HTTP_OK in r\n        assert 'GET /get HTTP' in r, \"Don't default to POST.\"\n        assert FILE_CONTENT not in r, \"Don't send stdin data.\"\n\n    def test_ignore_stdin_cannot_prompt_password(self, httpbin):\n        r = http('--ignore-stdin', '--auth=no-password', httpbin.url + '/get',\n                 error_exit_ok=True)\n        assert r.exit_status == ExitStatus.ERROR\n        assert 'because --ignore-stdin' in r.stderr\n\n\nclass TestSchemes:\n\n    def test_invalid_custom_scheme(self):\n        \n        \n        with pytest.raises(InvalidSchema):\n            http('foo+bar-BAZ.123://bah')\n\n    def test_invalid_scheme_via_via_default_scheme(self):\n        \n        \n        with pytest.raises(InvalidSchema):\n            http('bah', '--default=scheme=foo+bar-BAZ.123')\n\n    def test_default_scheme(self, httpbin_secure):\n        url = '{0}:{1}'.format(httpbin_secure.host, httpbin_secure.port)\n        assert HTTP_OK in http(url, '--default-scheme=https')\n", "comments": "   cli argument parsing related tests        noinspection pycompatibility    headers    data    files     requests structures caseinsensitivedict      dict     parsed headers     requests structures caseinsensitivedict      dict     parsed data    parsed query string parameters    parsed file fields    invalidschema expected httpie    touch formally valid scheme     invalidschema expected httpie    touch formally valid scheme  ", "content": "\"\"\"CLI argument parsing related tests.\"\"\"\nimport json\n# noinspection PyCompatibility\nimport argparse\n\nimport pytest\nfrom requests.exceptions import InvalidSchema\n\nfrom httpie import input\nfrom httpie.input import KeyValue, KeyValueArgType, DataDict\nfrom httpie import ExitStatus\nfrom httpie.cli import parser\nfrom utils import MockEnvironment, http, HTTP_OK\nfrom fixtures import (\n    FILE_PATH_ARG, JSON_FILE_PATH_ARG,\n    JSON_FILE_CONTENT, FILE_CONTENT, FILE_PATH\n)\n\n\nclass TestItemParsing:\n\n    key_value = KeyValueArgType(*input.SEP_GROUP_ALL_ITEMS)\n\n    def test_invalid_items(self):\n        items = ['no-separator']\n        for item in items:\n            pytest.raises(argparse.ArgumentTypeError, self.key_value, item)\n\n    def test_escape_separator(self):\n        items = input.parse_items([\n            # headers\n            self.key_value(r'foo\\:bar:baz'),\n            self.key_value(r'jack\\@jill:hill'),\n\n            # data\n            self.key_value(r'baz\\=bar=foo'),\n\n            # files\n            self.key_value(r'bar\\@baz@%s' % FILE_PATH_ARG),\n        ])\n        # `requests.structures.CaseInsensitiveDict` => `dict`\n        headers = dict(items.headers._store.values())\n\n        assert headers == {\n            'foo:bar': 'baz',\n            'jack@jill': 'hill',\n        }\n        assert items.data == {'baz=bar': 'foo'}\n        assert 'bar@baz' in items.files\n\n    @pytest.mark.parametrize(('string', 'key', 'sep', 'value'), [\n        ('path=c:\\windows', 'path', '=', 'c:\\windows'),\n        ('path=c:\\windows\\\\', 'path', '=', 'c:\\windows\\\\'),\n        ('path\\==c:\\windows', 'path=', '=', 'c:\\windows'),\n    ])\n    def test_backslash_before_non_special_character_does_not_escape(\n            self, string, key, sep, value):\n        expected = KeyValue(orig=string, key=key, sep=sep, value=value)\n        actual = self.key_value(string)\n        assert actual == expected\n\n    def test_escape_longsep(self):\n        items = input.parse_items([\n            self.key_value(r'bob\\:==foo'),\n        ])\n        assert items.params == {'bob:': 'foo'}\n\n    def test_valid_items(self):\n        items = input.parse_items([\n            self.key_value('string=value'),\n            self.key_value('Header:value'),\n            self.key_value('Unset-Header:'),\n            self.key_value('Empty-Header;'),\n            self.key_value('list:=[\"a\", 1, {}, false]'),\n            self.key_value('obj:={\"a\": \"b\"}'),\n            self.key_value('ed='),\n            self.key_value('bool:=true'),\n            self.key_value('file@' + FILE_PATH_ARG),\n            self.key_value('query==value'),\n            self.key_value('string-embed=@' + FILE_PATH_ARG),\n            self.key_value('raw-json-embed:=@' + JSON_FILE_PATH_ARG),\n        ])\n\n        # Parsed headers\n        # `requests.structures.CaseInsensitiveDict` => `dict`\n        headers = dict(items.headers._store.values())\n        assert headers == {\n            'Header': 'value',\n            'Unset-Header': None,\n            'Empty-Header': ''\n        }\n\n        # Parsed data\n        raw_json_embed = items.data.pop('raw-json-embed')\n        assert raw_json_embed == json.loads(JSON_FILE_CONTENT)\n        items.data['string-embed'] = items.data['string-embed'].strip()\n        assert dict(items.data) == {\n            \"ed\": \"\",\n            \"string\": \"value\",\n            \"bool\": True,\n            \"list\": [\"a\", 1, {}, False],\n            \"obj\": {\"a\": \"b\"},\n            \"string-embed\": FILE_CONTENT,\n        }\n\n        # Parsed query string parameters\n        assert items.params == {'query': 'value'}\n\n        # Parsed file fields\n        assert 'file' in items.files\n        assert (items.files['file'][1].read().strip().\n                decode('utf8') == FILE_CONTENT)\n\n    def test_multiple_file_fields_with_same_field_name(self):\n        items = input.parse_items([\n            self.key_value('file_field@' + FILE_PATH_ARG),\n            self.key_value('file_field@' + FILE_PATH_ARG),\n        ])\n        assert len(items.files['file_field']) == 2\n\n    def test_multiple_text_fields_with_same_field_name(self):\n        items = input.parse_items(\n            [self.key_value('text_field=a'),\n             self.key_value('text_field=b')],\n            data_class=DataDict\n        )\n        assert items.data['text_field'] == ['a', 'b']\n        assert list(items.data.items()) == [\n            ('text_field', 'a'),\n            ('text_field', 'b'),\n        ]\n\n\nclass TestQuerystring:\n    def test_query_string_params_in_url(self, httpbin):\n        r = http('--print=Hhb', 'GET', httpbin.url + '/get?a=1&b=2')\n        path = '/get?a=1&b=2'\n        url = httpbin.url + path\n        assert HTTP_OK in r\n        assert 'GET %s HTTP/1.1' % path in r\n        assert '\"url\": \"%s\"' % url in r\n\n    def test_query_string_params_items(self, httpbin):\n        r = http('--print=Hhb', 'GET', httpbin.url + '/get', 'a==1')\n        path = '/get?a=1'\n        url = httpbin.url + path\n        assert HTTP_OK in r\n        assert 'GET %s HTTP/1.1' % path in r\n        assert '\"url\": \"%s\"' % url in r\n\n    def test_query_string_params_in_url_and_items_with_duplicates(self,\n                                                                  httpbin):\n        r = http('--print=Hhb', 'GET',\n                 httpbin.url + '/get?a=1&a=1', 'a==1', 'a==1')\n        path = '/get?a=1&a=1&a=1&a=1'\n        url = httpbin.url + path\n        assert HTTP_OK in r\n        assert 'GET %s HTTP/1.1' % path in r\n        assert '\"url\": \"%s\"' % url in r\n\n\nclass TestLocalhostShorthand:\n    def test_expand_localhost_shorthand(self):\n        args = parser.parse_args(args=[':'], env=MockEnvironment())\n        assert args.url == 'http://localhost'\n\n    def test_expand_localhost_shorthand_with_slash(self):\n        args = parser.parse_args(args=[':/'], env=MockEnvironment())\n        assert args.url == 'http://localhost/'\n\n    def test_expand_localhost_shorthand_with_port(self):\n        args = parser.parse_args(args=[':3000'], env=MockEnvironment())\n        assert args.url == 'http://localhost:3000'\n\n    def test_expand_localhost_shorthand_with_path(self):\n        args = parser.parse_args(args=[':/path'], env=MockEnvironment())\n        assert args.url == 'http://localhost/path'\n\n    def test_expand_localhost_shorthand_with_port_and_slash(self):\n        args = parser.parse_args(args=[':3000/'], env=MockEnvironment())\n        assert args.url == 'http://localhost:3000/'\n\n    def test_expand_localhost_shorthand_with_port_and_path(self):\n        args = parser.parse_args(args=[':3000/path'], env=MockEnvironment())\n        assert args.url == 'http://localhost:3000/path'\n\n    def test_dont_expand_shorthand_ipv6_as_shorthand(self):\n        args = parser.parse_args(args=['::1'], env=MockEnvironment())\n        assert args.url == 'http://::1'\n\n    def test_dont_expand_longer_ipv6_as_shorthand(self):\n        args = parser.parse_args(\n            args=['::ffff:c000:0280'],\n            env=MockEnvironment()\n        )\n        assert args.url == 'http://::ffff:c000:0280'\n\n    def test_dont_expand_full_ipv6_as_shorthand(self):\n        args = parser.parse_args(\n            args=['0000:0000:0000:0000:0000:0000:0000:0001'],\n            env=MockEnvironment()\n        )\n        assert args.url == 'http://0000:0000:0000:0000:0000:0000:0000:0001'\n\n\nclass TestArgumentParser:\n\n    def setup_method(self, method):\n        self.parser = input.HTTPieArgumentParser()\n\n    def test_guess_when_method_set_and_valid(self):\n        self.parser.args = argparse.Namespace()\n        self.parser.args.method = 'GET'\n        self.parser.args.url = 'http://example.com/'\n        self.parser.args.items = []\n        self.parser.args.ignore_stdin = False\n\n        self.parser.env = MockEnvironment()\n\n        self.parser._guess_method()\n\n        assert self.parser.args.method == 'GET'\n        assert self.parser.args.url == 'http://example.com/'\n        assert self.parser.args.items == []\n\n    def test_guess_when_method_not_set(self):\n        self.parser.args = argparse.Namespace()\n        self.parser.args.method = None\n        self.parser.args.url = 'http://example.com/'\n        self.parser.args.items = []\n        self.parser.args.ignore_stdin = False\n        self.parser.env = MockEnvironment()\n\n        self.parser._guess_method()\n\n        assert self.parser.args.method == 'GET'\n        assert self.parser.args.url == 'http://example.com/'\n        assert self.parser.args.items == []\n\n    def test_guess_when_method_set_but_invalid_and_data_field(self):\n        self.parser.args = argparse.Namespace()\n        self.parser.args.method = 'http://example.com/'\n        self.parser.args.url = 'data=field'\n        self.parser.args.items = []\n        self.parser.args.ignore_stdin = False\n        self.parser.env = MockEnvironment()\n        self.parser._guess_method()\n\n        assert self.parser.args.method == 'POST'\n        assert self.parser.args.url == 'http://example.com/'\n        assert self.parser.args.items == [\n            KeyValue(key='data',\n                     value='field',\n                     sep='=',\n                     orig='data=field')\n        ]\n\n    def test_guess_when_method_set_but_invalid_and_header_field(self):\n        self.parser.args = argparse.Namespace()\n        self.parser.args.method = 'http://example.com/'\n        self.parser.args.url = 'test:header'\n        self.parser.args.items = []\n        self.parser.args.ignore_stdin = False\n\n        self.parser.env = MockEnvironment()\n\n        self.parser._guess_method()\n\n        assert self.parser.args.method == 'GET'\n        assert self.parser.args.url == 'http://example.com/'\n        assert self.parser.args.items, [\n            KeyValue(key='test',\n                     value='header',\n                     sep=':',\n                     orig='test:header')\n        ]\n\n    def test_guess_when_method_set_but_invalid_and_item_exists(self):\n        self.parser.args = argparse.Namespace()\n        self.parser.args.method = 'http://example.com/'\n        self.parser.args.url = 'new_item=a'\n        self.parser.args.items = [\n            KeyValue(\n                key='old_item', value='b', sep='=', orig='old_item=b')\n        ]\n        self.parser.args.ignore_stdin = False\n\n        self.parser.env = MockEnvironment()\n\n        self.parser._guess_method()\n\n        assert self.parser.args.items, [\n            KeyValue(key='new_item', value='a', sep='=', orig='new_item=a'),\n            KeyValue(\n                key='old_item', value='b', sep='=', orig='old_item=b'),\n        ]\n\n\nclass TestNoOptions:\n\n    def test_valid_no_options(self, httpbin):\n        r = http('--verbose', '--no-verbose', 'GET', httpbin.url + '/get')\n        assert 'GET /get HTTP/1.1' not in r\n\n    def test_invalid_no_options(self, httpbin):\n        r = http('--no-war', 'GET', httpbin.url + '/get',\n                 error_exit_ok=True)\n        assert r.exit_status == 1\n        assert 'unrecognized arguments: --no-war' in r.stderr\n        assert 'GET /get HTTP/1.1' not in r\n\n\nclass TestIgnoreStdin:\n\n    def test_ignore_stdin(self, httpbin):\n        with open(FILE_PATH) as f:\n            env = MockEnvironment(stdin=f, stdin_isatty=False)\n            r = http('--ignore-stdin', '--verbose', httpbin.url + '/get',\n                     env=env)\n        assert HTTP_OK in r\n        assert 'GET /get HTTP' in r, \"Don't default to POST.\"\n        assert FILE_CONTENT not in r, \"Don't send stdin data.\"\n\n    def test_ignore_stdin_cannot_prompt_password(self, httpbin):\n        r = http('--ignore-stdin', '--auth=no-password', httpbin.url + '/get',\n                 error_exit_ok=True)\n        assert r.exit_status == ExitStatus.ERROR\n        assert 'because --ignore-stdin' in r.stderr\n\n\nclass TestSchemes:\n\n    def test_invalid_custom_scheme(self):\n        # InvalidSchema is expected because HTTPie\n        # shouldn't touch a formally valid scheme.\n        with pytest.raises(InvalidSchema):\n            http('foo+bar-BAZ.123://bah')\n\n    def test_invalid_scheme_via_via_default_scheme(self):\n        # InvalidSchema is expected because HTTPie\n        # shouldn't touch a formally valid scheme.\n        with pytest.raises(InvalidSchema):\n            http('bah', '--default=scheme=foo+bar-BAZ.123')\n\n    def test_default_scheme(self, httpbin_secure):\n        url = '{0}:{1}'.format(httpbin_secure.host, httpbin_secure.port)\n        assert HTTP_OK in http(url, '--default-scheme=https')\n", "description": "Modern command line HTTP client \u2013 user-friendly curl alternative with intuitive UI, JSON support, syntax highlighting, wget-like downloads, extensions, etc.  https://httpie.org", "file_name": "test_cli.py", "id": "1711b389fd0dce6bf5b5a59730a73b40", "language": "Python", "project_name": "httpie", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/jakubroztocil-httpie/jakubroztocil-httpie-0f4dce9/tests/test_cli.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:39:35Z", "url": "https://github.com/jakubroztocil/httpie", "wiki": false}