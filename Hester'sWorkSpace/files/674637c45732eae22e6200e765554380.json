{"author": "getsentry", "code": "# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport mock\nimport pytest\nimport responses\nimport six\n\nfrom django.core.urlresolvers import reverse\nfrom exam import fixture\nfrom social_auth.models import UserSocialAuth\n\nfrom sentry.models import (\n    UserEmail, LostPasswordHash, User, UserOption\n)\nfrom sentry.testutils import TestCase\n\n\nclass AppearanceSettingsTest(TestCase):\n    @fixture\n    def path(self):\n        return reverse('sentry-account-settings-appearance')\n\n    def test_requires_authentication(self):\n        self.assertRequiresAuthentication(self.path)\n\n    def test_does_use_template(self):\n        self.login_as(self.user)\n\n        resp = self.client.get(self.path)\n\n        assert resp.status_code == 200\n        self.assertTemplateUsed(resp, 'sentry/account/appearance.html')\n\n    def test_does_save_settings(self):\n        self.login_as(self.user)\n\n        resp = self.client.post(self.path, {\n            'language': 'en',\n            'stacktrace_order': '2',\n            'clock_24_hours': True\n        })\n        assert resp.status_code == 302\n\n        options = UserOption.objects.get_all_values(user=self.user)\n\n        assert options.get('language') == 'en'\n        assert options.get('stacktrace_order') == '2'\n        assert options.get('clock_24_hours') is True\n\n\nclass SettingsTest(TestCase):\n    @fixture\n    def path(self):\n        return reverse('sentry-account-settings')\n\n    def params(self, without=()):\n        params = {\n            'email': 'admin@localhost',\n            'name': 'Foo bar',\n        }\n        return dict((k, v) for k, v in six.iteritems(params) if k not in without)\n\n    def test_requires_authentication(self):\n        self.assertRequiresAuthentication(self.path)\n\n    def test_renders_with_required_context(self):\n        self.login_as(self.user)\n\n        resp = self.client.get(self.path)\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        assert 'form' in resp.context\n\n    def test_requires_email(self):\n        self.login_as(self.user)\n\n        resp = self.client.post(self.path, self.params(without=['email']))\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        assert 'form' in resp.context\n        assert 'email' in resp.context['form'].errors\n\n    def test_requires_name(self):\n        self.login_as(self.user)\n\n        resp = self.client.post(self.path, self.params(without=['name']))\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        assert 'form' in resp.context\n        assert 'name' in resp.context['form'].errors\n\n    def test_minimum_valid_params(self):\n        self.login_as(self.user)\n\n        params = self.params()\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 302\n        user = User.objects.get(id=self.user.id)\n        assert user.name == params['name']\n\n    def test_can_change_password_with_password(self):\n        old_nonce = self.user.session_nonce\n        self.login_as(self.user)\n\n        params = self.params()\n        params['password'] = 'admin'\n        params['new_password'] = 'foobar'\n        params['verify_new_password'] = 'foobar'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 302\n        user = User.objects.get(id=self.user.id)\n        assert user.check_password('foobar')\n        assert user.session_nonce != old_nonce\n\n    def test_cannot_change_password_with_invalid_password(self):\n        self.login_as(self.user)\n\n        params = self.params()\n        params['new_password'] = 'foobar'\n        params['verify_new_password'] = 'foobar'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        assert resp.context['form'].errors\n        user = User.objects.get(id=self.user.id)\n        assert not user.check_password('foobar')\n\n    def test_cannot_change_password_with_managed_user(self):\n        user = self.create_user('foo@example.com', is_managed=True)\n\n        self.login_as(user)\n\n        params = self.params()\n        params['email'] = user.email\n        params['password'] = 'admin'\n        params['new_password'] = 'foobar'\n        params['verify_new_password'] = 'foobar'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 302\n        user = User.objects.get(id=self.user.id)\n        assert not user.check_password('foobar')\n\n    def test_can_change_email_with_password(self):\n        self.login_as(self.user)\n\n        params = self.params()\n        params['password'] = 'admin'\n        params['email'] = 'bizbaz@example.com'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 302\n        user = User.objects.get(id=self.user.id)\n        assert user.email == 'bizbaz@example.com'\n\n    def test_can_change_email_without_set_password(self):\n        self.login_as(self.user)\n\n        self.user.update(password='')\n\n        params = self.params()\n        params['email'] = 'bizbaz@example.com'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 302\n        user = User.objects.get(id=self.user.id)\n        assert user.email == 'bizbaz@example.com'\n\n    def test_cannot_change_email_with_invalid_password(self):\n        self.login_as(self.user)\n\n        params = self.params()\n        params['email'] = 'bizbaz@example.com'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        assert resp.context['form'].errors\n        user = User.objects.get(id=self.user.id)\n        assert user.email == 'admin@localhost'\n\n    def test_settings_renders_with_verify_new_password(self):\n        user = self.create_user('foo@example.com')\n        self.login_as(user)\n        path = reverse('sentry-account-settings')\n        resp = self.client.get(path)\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        form = resp.context['form']\n        assert form.errors == {}\n        for field in ('name', 'email', 'new_password', 'verify_new_password', 'password'):\n            assert field in form.fields\n\n        self.assertContains(resp, 'New password')\n        self.assertContains(resp, 'Verify new password')\n\n    def test_settings_renders_without_new_password(self):\n        user = self.create_user('foo@example.com')\n        user.update(is_managed=True)\n        self.login_as(user)\n        path = reverse('sentry-account-settings')\n        resp = self.client.get(path)\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        form = resp.context['form']\n        assert form.errors == {}\n        for field in ('new_password', 'verify_new_password'):\n            assert field not in form.fields\n\n    def test_cannot_change_password_without_verify_password(self):\n        self.login_as(self.user)\n\n        params = self.params()\n        params['new_password'] = 'foobar'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        assert resp.context['form'].errors\n        user = User.objects.get(id=self.user.id)\n        assert not user.check_password('foobar')\n\n    def test_cannot_change_password_with_unequal_verify_password(self):\n        self.login_as(self.user)\n\n        params = self.params()\n        params['new_password'] = 'foobar'\n        params['verify_new_password'] = 'foobars'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        assert resp.context['form'].errors\n        user = User.objects.get(id=self.user.id)\n        assert not user.check_password('foobar')\n        assert not user.check_password('foobars')\n\n    def test_password_hash_invalidated_when_email_changes(self):\n        self.login_as(self.user)\n\n        LostPasswordHash.objects.create(user=self.user)\n\n        params = self.params()\n        params['password'] = 'admin'\n        params['email'] = 'bizbaz@example.com'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 302\n        user = User.objects.get(id=self.user.id)\n        assert user.email == 'bizbaz@example.com'\n        assert not LostPasswordHash.objects.filter(user=self.user).exists()\n\n    def test_password_hash_invalidated_when_password_changes(self):\n        old_nonce = self.user.session_nonce\n        self.login_as(self.user)\n\n        LostPasswordHash.objects.create(user=self.user)\n\n        params = self.params()\n        params['password'] = 'admin'\n        params['new_password'] = 'foobar'\n        params['verify_new_password'] = 'foobar'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 302\n        user = User.objects.get(id=self.user.id)\n        assert user.check_password('foobar')\n        assert user.session_nonce != old_nonce\n        assert not LostPasswordHash.objects.filter(user=self.user).exists()\n\n\nclass ListIdentitiesTest(TestCase):\n    @fixture\n    def path(self):\n        return reverse('sentry-account-settings-identities')\n\n    def test_requires_authentication(self):\n        self.assertRequiresAuthentication(self.path)\n\n    def test_renders_with_required_context(self):\n        self.login_as(self.user)\n        UserSocialAuth.objects.create(user=self.user, provider='github')\n\n        resp = self.client.get(self.path)\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/identities.html')\n        assert 'identity_list' in resp.context\n        assert 'AUTH_PROVIDERS' in resp.context\n\n\nclass RecoverPasswordTest(TestCase):\n    @fixture\n    def path(self):\n        return reverse('sentry-account-recover')\n\n    def test_renders_with_required_context(self):\n        resp = self.client.get(self.path)\n        assert resp.status_code == 200\n        self.assertTemplateUsed(resp, 'sentry/account/recover/index.html')\n        assert 'form' in resp.context\n\n    def test_invalid_username(self):\n        resp = self.client.post(self.path, {\n            'user': 'nonexistent'\n        })\n        assert resp.status_code == 200\n        self.assertTemplateUsed(resp, 'sentry/account/recover/index.html')\n        assert 'form' in resp.context\n        assert 'user' in resp.context['form'].errors\n\n    def test_managed_account_is_invalid(self):\n        user = self.create_user('foo@example.com', is_managed=True)\n\n        resp = self.client.post(self.path, {\n            'user': user.email,\n        })\n        assert resp.status_code == 200\n        self.assertTemplateUsed(resp, 'sentry/account/recover/index.html')\n        assert 'form' in resp.context\n        assert 'user' in resp.context['form'].errors\n\n    @mock.patch('sentry.models.LostPasswordHash.send_email')\n    def test_valid_username(self, send_recover_mail):\n        resp = self.client.post(self.path, {\n            'user': self.user.username\n        })\n        assert resp.status_code == 200\n        self.assertTemplateUsed(resp, 'sentry/account/recover/sent.html')\n        assert 'email' in resp.context\n        send_recover_mail.call_count == 1\n\n    @mock.patch('sentry.models.LostPasswordHash.send_email')\n    def test_lost_password_hash_invalid_after_successful_login(self, send_recover_mail):\n        resp = self.client.post(self.path, {\n            'user': self.user.username\n        })\n        assert resp.status_code == 200\n        send_recover_mail.call_count == 1\n\n        assert LostPasswordHash.objects.get(user=self.user).is_valid()\n        self.login_as(self.user)\n        assert not LostPasswordHash.objects.filter(user=self.user).exists()\n\n\nclass RecoverPasswordConfirmTest(TestCase):\n    def setUp(self):\n        super(RecoverPasswordConfirmTest, self).setUp()\n        self.password_hash = LostPasswordHash.objects.create(user=self.user)\n\n    @fixture\n    def path(self):\n        return reverse(\n            'sentry-account-recover-confirm',\n            args=[\n                self.user.id,\n                self.password_hash.hash])\n\n    def test_valid_token(self):\n        resp = self.client.get(self.path)\n        assert resp.status_code == 200\n        self.assertTemplateUsed(resp, 'sentry/account/recover/confirm.html')\n\n    def test_invalid_token(self):\n        resp = self.client.get(reverse('sentry-account-recover-confirm', args=[1, 'adfadsf']))\n        assert resp.status_code == 200\n        self.assertTemplateUsed(resp, 'sentry/account/recover/failure.html')\n\n    def test_change_password(self):\n        old_nonce = self.user.session_nonce\n        resp = self.client.post(self.path, {\n            'password': 'bar',\n            'confirm_password': 'bar'\n        })\n        assert resp.status_code == 302\n        user = User.objects.get(id=self.user.id)\n        assert user.check_password('bar')\n        assert user.session_nonce != old_nonce\n        assert not LostPasswordHash.objects.filter(user=user).exists()\n\n\nclass ConfirmEmailSendTest(TestCase):\n    @mock.patch('sentry.models.User.send_confirm_emails')\n    def test_valid(self, send_confirm_email):\n        self.login_as(self.user)\n        UserEmail.objects.filter(user=self.user).update(is_verified=False)\n        resp = self.client.post(reverse('sentry-account-confirm-email-send'))\n        self.assertRedirects(resp, reverse('sentry-account-settings-emails'), status_code=302)\n        send_confirm_email.assert_called_once_with()\n\n    def test_get_request_not_valid(self):\n        self.login_as(self.user)\n        resp = self.client.get(reverse('sentry-account-confirm-email-send'))\n        assert resp.status_code == 405\n\n    @mock.patch('sentry.models.User.send_confirm_email_singular')\n    def test_send_single_email(self, send_confirm_email):\n        user = self.create_user('foo@example.com')\n        email = UserEmail.objects.create(user=user, email='bar@example.com')\n        email.save()\n        self.login_as(user)\n        self.client.post(reverse('sentry-account-confirm-email-send'),\n                         data={'primary-email': '', 'email': 'foo@example.com'},\n                         follow=True)\n        send_confirm_email.assert_called_once_with(UserEmail.get_primary_email(user))\n\n\nclass ConfirmEmailTest(TestCase):\n\n    def test_invalid(self):\n        self.user.save()\n        UserEmail.objects.get(email=self.user.email).update(is_verified=False)\n        resp = self.client.get(reverse('sentry-account-confirm-email',\n                                       args=[self.user.id, '5b1f2f266efa03b721cc9ea0d4742c5e']))\n        assert resp.status_code == 302\n        email = UserEmail.objects.get(email=self.user.email)\n        assert not email.is_verified\n\n    def test_valid(self):\n        self.user.save()\n        UserEmail.objects.get(email=self.user.email).update(is_verified=False)\n        self.login_as(self.user)\n        self.client.post(reverse('sentry-account-confirm-email-send'))\n        email = self.user.emails.first()\n        resp = self.client.get(reverse('sentry-account-confirm-email',\n                                       args=[self.user.id, email.validation_hash]))\n        self.assertRedirects(resp, reverse('sentry-account-settings-emails'), status_code=302)\n        email = self.user.emails.first()\n        assert email.is_verified\n        assert not email.hash_is_valid()\n\n\nclass DisconnectIdentityTest(TestCase):\n    @responses.activate\n    def test_simple(self):\n        self.login_as(self.user)\n\n        auth = UserSocialAuth.objects.create(\n            user=self.user,\n            provider='github',\n            extra_data={'access_token': 'abcdef'},\n        )\n\n        with self.settings(GITHUB_APP_ID='app_id', GITHUB_API_SECRET='secret'):\n            resp = self.client.post(reverse('sentry-account-disconnect-identity', args=[\n                auth.id,\n            ]))\n\n        assert resp['Location'] == 'http://testserver{}'.format(\n            reverse('sentry-account-settings-identities'),\n        )\n\n        assert not UserSocialAuth.objects.filter(id=auth.id).exists()\n\n    @responses.activate\n    def test_invalid_backend(self):\n        self.login_as(self.user)\n\n        auth = UserSocialAuth.objects.create(\n            user=self.user,\n            provider='invalid',\n            extra_data={'access_token': 'abcdef'},\n        )\n\n        with pytest.raises(Exception):\n            \n            self.client.post(reverse('sentry-account-disconnect-identity', args=[\n                auth.id,\n            ]))\n", "comments": "      coding  utf 8        error hard ", "content": "# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\n\nimport mock\nimport pytest\nimport responses\nimport six\n\nfrom django.core.urlresolvers import reverse\nfrom exam import fixture\nfrom social_auth.models import UserSocialAuth\n\nfrom sentry.models import (\n    UserEmail, LostPasswordHash, User, UserOption\n)\nfrom sentry.testutils import TestCase\n\n\nclass AppearanceSettingsTest(TestCase):\n    @fixture\n    def path(self):\n        return reverse('sentry-account-settings-appearance')\n\n    def test_requires_authentication(self):\n        self.assertRequiresAuthentication(self.path)\n\n    def test_does_use_template(self):\n        self.login_as(self.user)\n\n        resp = self.client.get(self.path)\n\n        assert resp.status_code == 200\n        self.assertTemplateUsed(resp, 'sentry/account/appearance.html')\n\n    def test_does_save_settings(self):\n        self.login_as(self.user)\n\n        resp = self.client.post(self.path, {\n            'language': 'en',\n            'stacktrace_order': '2',\n            'clock_24_hours': True\n        })\n        assert resp.status_code == 302\n\n        options = UserOption.objects.get_all_values(user=self.user)\n\n        assert options.get('language') == 'en'\n        assert options.get('stacktrace_order') == '2'\n        assert options.get('clock_24_hours') is True\n\n\nclass SettingsTest(TestCase):\n    @fixture\n    def path(self):\n        return reverse('sentry-account-settings')\n\n    def params(self, without=()):\n        params = {\n            'email': 'admin@localhost',\n            'name': 'Foo bar',\n        }\n        return dict((k, v) for k, v in six.iteritems(params) if k not in without)\n\n    def test_requires_authentication(self):\n        self.assertRequiresAuthentication(self.path)\n\n    def test_renders_with_required_context(self):\n        self.login_as(self.user)\n\n        resp = self.client.get(self.path)\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        assert 'form' in resp.context\n\n    def test_requires_email(self):\n        self.login_as(self.user)\n\n        resp = self.client.post(self.path, self.params(without=['email']))\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        assert 'form' in resp.context\n        assert 'email' in resp.context['form'].errors\n\n    def test_requires_name(self):\n        self.login_as(self.user)\n\n        resp = self.client.post(self.path, self.params(without=['name']))\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        assert 'form' in resp.context\n        assert 'name' in resp.context['form'].errors\n\n    def test_minimum_valid_params(self):\n        self.login_as(self.user)\n\n        params = self.params()\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 302\n        user = User.objects.get(id=self.user.id)\n        assert user.name == params['name']\n\n    def test_can_change_password_with_password(self):\n        old_nonce = self.user.session_nonce\n        self.login_as(self.user)\n\n        params = self.params()\n        params['password'] = 'admin'\n        params['new_password'] = 'foobar'\n        params['verify_new_password'] = 'foobar'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 302\n        user = User.objects.get(id=self.user.id)\n        assert user.check_password('foobar')\n        assert user.session_nonce != old_nonce\n\n    def test_cannot_change_password_with_invalid_password(self):\n        self.login_as(self.user)\n\n        params = self.params()\n        params['new_password'] = 'foobar'\n        params['verify_new_password'] = 'foobar'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        assert resp.context['form'].errors\n        user = User.objects.get(id=self.user.id)\n        assert not user.check_password('foobar')\n\n    def test_cannot_change_password_with_managed_user(self):\n        user = self.create_user('foo@example.com', is_managed=True)\n\n        self.login_as(user)\n\n        params = self.params()\n        params['email'] = user.email\n        params['password'] = 'admin'\n        params['new_password'] = 'foobar'\n        params['verify_new_password'] = 'foobar'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 302\n        user = User.objects.get(id=self.user.id)\n        assert not user.check_password('foobar')\n\n    def test_can_change_email_with_password(self):\n        self.login_as(self.user)\n\n        params = self.params()\n        params['password'] = 'admin'\n        params['email'] = 'bizbaz@example.com'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 302\n        user = User.objects.get(id=self.user.id)\n        assert user.email == 'bizbaz@example.com'\n\n    def test_can_change_email_without_set_password(self):\n        self.login_as(self.user)\n\n        self.user.update(password='')\n\n        params = self.params()\n        params['email'] = 'bizbaz@example.com'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 302\n        user = User.objects.get(id=self.user.id)\n        assert user.email == 'bizbaz@example.com'\n\n    def test_cannot_change_email_with_invalid_password(self):\n        self.login_as(self.user)\n\n        params = self.params()\n        params['email'] = 'bizbaz@example.com'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        assert resp.context['form'].errors\n        user = User.objects.get(id=self.user.id)\n        assert user.email == 'admin@localhost'\n\n    def test_settings_renders_with_verify_new_password(self):\n        user = self.create_user('foo@example.com')\n        self.login_as(user)\n        path = reverse('sentry-account-settings')\n        resp = self.client.get(path)\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        form = resp.context['form']\n        assert form.errors == {}\n        for field in ('name', 'email', 'new_password', 'verify_new_password', 'password'):\n            assert field in form.fields\n\n        self.assertContains(resp, 'New password')\n        self.assertContains(resp, 'Verify new password')\n\n    def test_settings_renders_without_new_password(self):\n        user = self.create_user('foo@example.com')\n        user.update(is_managed=True)\n        self.login_as(user)\n        path = reverse('sentry-account-settings')\n        resp = self.client.get(path)\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        form = resp.context['form']\n        assert form.errors == {}\n        for field in ('new_password', 'verify_new_password'):\n            assert field not in form.fields\n\n    def test_cannot_change_password_without_verify_password(self):\n        self.login_as(self.user)\n\n        params = self.params()\n        params['new_password'] = 'foobar'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        assert resp.context['form'].errors\n        user = User.objects.get(id=self.user.id)\n        assert not user.check_password('foobar')\n\n    def test_cannot_change_password_with_unequal_verify_password(self):\n        self.login_as(self.user)\n\n        params = self.params()\n        params['new_password'] = 'foobar'\n        params['verify_new_password'] = 'foobars'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/settings.html')\n        assert resp.context['form'].errors\n        user = User.objects.get(id=self.user.id)\n        assert not user.check_password('foobar')\n        assert not user.check_password('foobars')\n\n    def test_password_hash_invalidated_when_email_changes(self):\n        self.login_as(self.user)\n\n        LostPasswordHash.objects.create(user=self.user)\n\n        params = self.params()\n        params['password'] = 'admin'\n        params['email'] = 'bizbaz@example.com'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 302\n        user = User.objects.get(id=self.user.id)\n        assert user.email == 'bizbaz@example.com'\n        assert not LostPasswordHash.objects.filter(user=self.user).exists()\n\n    def test_password_hash_invalidated_when_password_changes(self):\n        old_nonce = self.user.session_nonce\n        self.login_as(self.user)\n\n        LostPasswordHash.objects.create(user=self.user)\n\n        params = self.params()\n        params['password'] = 'admin'\n        params['new_password'] = 'foobar'\n        params['verify_new_password'] = 'foobar'\n\n        resp = self.client.post(self.path, params)\n        assert resp.status_code == 302\n        user = User.objects.get(id=self.user.id)\n        assert user.check_password('foobar')\n        assert user.session_nonce != old_nonce\n        assert not LostPasswordHash.objects.filter(user=self.user).exists()\n\n\nclass ListIdentitiesTest(TestCase):\n    @fixture\n    def path(self):\n        return reverse('sentry-account-settings-identities')\n\n    def test_requires_authentication(self):\n        self.assertRequiresAuthentication(self.path)\n\n    def test_renders_with_required_context(self):\n        self.login_as(self.user)\n        UserSocialAuth.objects.create(user=self.user, provider='github')\n\n        resp = self.client.get(self.path)\n        assert resp.status_code == 200\n        self.assertTemplateUsed('sentry/account/identities.html')\n        assert 'identity_list' in resp.context\n        assert 'AUTH_PROVIDERS' in resp.context\n\n\nclass RecoverPasswordTest(TestCase):\n    @fixture\n    def path(self):\n        return reverse('sentry-account-recover')\n\n    def test_renders_with_required_context(self):\n        resp = self.client.get(self.path)\n        assert resp.status_code == 200\n        self.assertTemplateUsed(resp, 'sentry/account/recover/index.html')\n        assert 'form' in resp.context\n\n    def test_invalid_username(self):\n        resp = self.client.post(self.path, {\n            'user': 'nonexistent'\n        })\n        assert resp.status_code == 200\n        self.assertTemplateUsed(resp, 'sentry/account/recover/index.html')\n        assert 'form' in resp.context\n        assert 'user' in resp.context['form'].errors\n\n    def test_managed_account_is_invalid(self):\n        user = self.create_user('foo@example.com', is_managed=True)\n\n        resp = self.client.post(self.path, {\n            'user': user.email,\n        })\n        assert resp.status_code == 200\n        self.assertTemplateUsed(resp, 'sentry/account/recover/index.html')\n        assert 'form' in resp.context\n        assert 'user' in resp.context['form'].errors\n\n    @mock.patch('sentry.models.LostPasswordHash.send_email')\n    def test_valid_username(self, send_recover_mail):\n        resp = self.client.post(self.path, {\n            'user': self.user.username\n        })\n        assert resp.status_code == 200\n        self.assertTemplateUsed(resp, 'sentry/account/recover/sent.html')\n        assert 'email' in resp.context\n        send_recover_mail.call_count == 1\n\n    @mock.patch('sentry.models.LostPasswordHash.send_email')\n    def test_lost_password_hash_invalid_after_successful_login(self, send_recover_mail):\n        resp = self.client.post(self.path, {\n            'user': self.user.username\n        })\n        assert resp.status_code == 200\n        send_recover_mail.call_count == 1\n\n        assert LostPasswordHash.objects.get(user=self.user).is_valid()\n        self.login_as(self.user)\n        assert not LostPasswordHash.objects.filter(user=self.user).exists()\n\n\nclass RecoverPasswordConfirmTest(TestCase):\n    def setUp(self):\n        super(RecoverPasswordConfirmTest, self).setUp()\n        self.password_hash = LostPasswordHash.objects.create(user=self.user)\n\n    @fixture\n    def path(self):\n        return reverse(\n            'sentry-account-recover-confirm',\n            args=[\n                self.user.id,\n                self.password_hash.hash])\n\n    def test_valid_token(self):\n        resp = self.client.get(self.path)\n        assert resp.status_code == 200\n        self.assertTemplateUsed(resp, 'sentry/account/recover/confirm.html')\n\n    def test_invalid_token(self):\n        resp = self.client.get(reverse('sentry-account-recover-confirm', args=[1, 'adfadsf']))\n        assert resp.status_code == 200\n        self.assertTemplateUsed(resp, 'sentry/account/recover/failure.html')\n\n    def test_change_password(self):\n        old_nonce = self.user.session_nonce\n        resp = self.client.post(self.path, {\n            'password': 'bar',\n            'confirm_password': 'bar'\n        })\n        assert resp.status_code == 302\n        user = User.objects.get(id=self.user.id)\n        assert user.check_password('bar')\n        assert user.session_nonce != old_nonce\n        assert not LostPasswordHash.objects.filter(user=user).exists()\n\n\nclass ConfirmEmailSendTest(TestCase):\n    @mock.patch('sentry.models.User.send_confirm_emails')\n    def test_valid(self, send_confirm_email):\n        self.login_as(self.user)\n        UserEmail.objects.filter(user=self.user).update(is_verified=False)\n        resp = self.client.post(reverse('sentry-account-confirm-email-send'))\n        self.assertRedirects(resp, reverse('sentry-account-settings-emails'), status_code=302)\n        send_confirm_email.assert_called_once_with()\n\n    def test_get_request_not_valid(self):\n        self.login_as(self.user)\n        resp = self.client.get(reverse('sentry-account-confirm-email-send'))\n        assert resp.status_code == 405\n\n    @mock.patch('sentry.models.User.send_confirm_email_singular')\n    def test_send_single_email(self, send_confirm_email):\n        user = self.create_user('foo@example.com')\n        email = UserEmail.objects.create(user=user, email='bar@example.com')\n        email.save()\n        self.login_as(user)\n        self.client.post(reverse('sentry-account-confirm-email-send'),\n                         data={'primary-email': '', 'email': 'foo@example.com'},\n                         follow=True)\n        send_confirm_email.assert_called_once_with(UserEmail.get_primary_email(user))\n\n\nclass ConfirmEmailTest(TestCase):\n\n    def test_invalid(self):\n        self.user.save()\n        UserEmail.objects.get(email=self.user.email).update(is_verified=False)\n        resp = self.client.get(reverse('sentry-account-confirm-email',\n                                       args=[self.user.id, '5b1f2f266efa03b721cc9ea0d4742c5e']))\n        assert resp.status_code == 302\n        email = UserEmail.objects.get(email=self.user.email)\n        assert not email.is_verified\n\n    def test_valid(self):\n        self.user.save()\n        UserEmail.objects.get(email=self.user.email).update(is_verified=False)\n        self.login_as(self.user)\n        self.client.post(reverse('sentry-account-confirm-email-send'))\n        email = self.user.emails.first()\n        resp = self.client.get(reverse('sentry-account-confirm-email',\n                                       args=[self.user.id, email.validation_hash]))\n        self.assertRedirects(resp, reverse('sentry-account-settings-emails'), status_code=302)\n        email = self.user.emails.first()\n        assert email.is_verified\n        assert not email.hash_is_valid()\n\n\nclass DisconnectIdentityTest(TestCase):\n    @responses.activate\n    def test_simple(self):\n        self.login_as(self.user)\n\n        auth = UserSocialAuth.objects.create(\n            user=self.user,\n            provider='github',\n            extra_data={'access_token': 'abcdef'},\n        )\n\n        with self.settings(GITHUB_APP_ID='app_id', GITHUB_API_SECRET='secret'):\n            resp = self.client.post(reverse('sentry-account-disconnect-identity', args=[\n                auth.id,\n            ]))\n\n        assert resp['Location'] == 'http://testserver{}'.format(\n            reverse('sentry-account-settings-identities'),\n        )\n\n        assert not UserSocialAuth.objects.filter(id=auth.id).exists()\n\n    @responses.activate\n    def test_invalid_backend(self):\n        self.login_as(self.user)\n\n        auth = UserSocialAuth.objects.create(\n            user=self.user,\n            provider='invalid',\n            extra_data={'access_token': 'abcdef'},\n        )\n\n        with pytest.raises(Exception):\n            # this should just error hard\n            self.client.post(reverse('sentry-account-disconnect-identity', args=[\n                auth.id,\n            ]))\n", "description": "Sentry is a cross-platform crash reporting and aggregation platform.", "file_name": "tests.py", "id": "674637c45732eae22e6200e765554380", "language": "Python", "project_name": "sentry", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/getsentry-sentry/getsentry-sentry-6a9c7e2/tests/sentry/web/frontend/accounts/tests.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:23:24Z", "url": "https://github.com/getsentry/sentry", "wiki": false}