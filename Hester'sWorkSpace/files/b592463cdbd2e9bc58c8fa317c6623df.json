{"author": "ansible", "code": "\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: rax_clb_nodes\nshort_description: add, modify and remove nodes from a Rackspace Cloud Load Balancer\ndescription:\n  - Adds, modifies and removes nodes from a Rackspace Cloud Load Balancer\nversion_added: \"1.4\"\noptions:\n  address:\n    required: false\n    description:\n      - IP address or domain name of the node\n  condition:\n    required: false\n    choices:\n      - enabled\n      - disabled\n      - draining\n    description:\n      - Condition for the node, which determines its role within the load\n        balancer\n  load_balancer_id:\n    required: true\n    description:\n      - Load balancer id\n  node_id:\n    required: false\n    description:\n      - Node id\n  port:\n    required: false\n    description:\n      - Port number of the load balanced service on the node\n  state:\n    required: false\n    default: \"present\"\n    choices:\n      - present\n      - absent\n    description:\n      - Indicate desired state of the node\n  type:\n    required: false\n    choices:\n      - primary\n      - secondary\n    description:\n      - Type of node\n  wait:\n    required: false\n    default: \"no\"\n    choices:\n      - \"yes\"\n      - \"no\"\n    description:\n      - Wait for the load balancer to become active before returning\n  wait_timeout:\n    required: false\n    default: 30\n    description:\n      - How long to wait before giving up and returning an error\n  weight:\n    required: false\n    description:\n      - Weight of node\nauthor: \"Lukasz Kawczynski (@neuroid)\"\nextends_documentation_fragment:\n  - rackspace\n  - rackspace.openstack\n'''\n\nEXAMPLES = '''\n\n- local_action:\n    module: rax_clb_nodes\n    load_balancer_id: 71\n    address: 10.2.2.3\n    port: 80\n    condition: enabled\n    type: primary\n    wait: yes\n    credentials: /path/to/credentials\n\n\n- local_action:\n    module: rax_clb_nodes\n    load_balancer_id: 71\n    node_id: 410\n    condition: draining\n    wait: yes\n    credentials: /path/to/credentials\n\n\n- local_action:\n    module: rax_clb_nodes\n    load_balancer_id: 71\n    node_id: 410\n    state: absent\n    wait: yes\n    credentials: /path/to/credentials\n'''\n\nimport os\n\ntry:\n    import pyrax\n    HAS_PYRAX = True\nexcept ImportError:\n    HAS_PYRAX = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.rax import rax_argument_spec, rax_clb_node_to_dict, rax_required_together, setup_rax_module\n\n\ndef _activate_virtualenv(path):\n    activate_this = os.path.join(path, 'bin', 'activate_this.py')\n    with open(activate_this) as f:\n        code = compile(f.read(), activate_this, 'exec')\n        exec(code)\n\n\ndef _get_node(lb, node_id=None, address=None, port=None):\n    \n    for node in getattr(lb, 'nodes', []):\n        match_list = []\n        if node_id is not None:\n            match_list.append(getattr(node, 'id', None) == node_id)\n        if address is not None:\n            match_list.append(getattr(node, 'address', None) == address)\n        if port is not None:\n            match_list.append(getattr(node, 'port', None) == port)\n\n        if match_list and all(match_list):\n            return node\n\n    return None\n\n\ndef main():\n    argument_spec = rax_argument_spec()\n    argument_spec.update(\n        dict(\n            address=dict(),\n            condition=dict(choices=['enabled', 'disabled', 'draining']),\n            load_balancer_id=dict(required=True, type='int'),\n            node_id=dict(type='int'),\n            port=dict(type='int'),\n            state=dict(default='present', choices=['present', 'absent']),\n            type=dict(choices=['primary', 'secondary']),\n            virtualenv=dict(type='path'),\n            wait=dict(default=False, type='bool'),\n            wait_timeout=dict(default=30, type='int'),\n            weight=dict(type='int'),\n        )\n    )\n\n    module = AnsibleModule(\n        argument_spec=argument_spec,\n        required_together=rax_required_together(),\n    )\n\n    if not HAS_PYRAX:\n        module.fail_json(msg='pyrax is required for this module')\n\n    address = module.params['address']\n    condition = (module.params['condition'] and\n                 module.params['condition'].upper())\n    load_balancer_id = module.params['load_balancer_id']\n    node_id = module.params['node_id']\n    port = module.params['port']\n    state = module.params['state']\n    typ = module.params['type'] and module.params['type'].upper()\n    virtualenv = module.params['virtualenv']\n    wait = module.params['wait']\n    wait_timeout = module.params['wait_timeout'] or 1\n    weight = module.params['weight']\n\n    if virtualenv:\n        try:\n            _activate_virtualenv(virtualenv)\n        except IOError as e:\n            module.fail_json(msg='Failed to activate virtualenv %s (%s)' % (\n                                 virtualenv, e))\n\n    setup_rax_module(module, pyrax)\n\n    if not pyrax.cloud_loadbalancers:\n        module.fail_json(msg='Failed to instantiate client. This '\n                             'typically indicates an invalid region or an '\n                             'incorrectly capitalized region name.')\n\n    try:\n        lb = pyrax.cloud_loadbalancers.get(load_balancer_id)\n    except pyrax.exc.PyraxException as e:\n        module.fail_json(msg='%s' % e.message)\n\n    node = _get_node(lb, node_id, address, port)\n\n    result = rax_clb_node_to_dict(node)\n\n    if state == 'absent':\n        if not node:  \n            module.exit_json(changed=False, state=state)\n        try:\n            lb.delete_node(node)\n            result = {}\n        except pyrax.exc.NotFound:\n            module.exit_json(changed=False, state=state)\n        except pyrax.exc.PyraxException as e:\n            module.fail_json(msg='%s' % e.message)\n    else:  \n        if not node:\n            if node_id:  \n                msg = 'Node %d not found' % node_id\n                if lb.nodes:\n                    msg += (' (available nodes: %s)' %\n                            ', '.join([str(x.id) for x in lb.nodes]))\n                module.fail_json(msg=msg)\n            else:  \n                try:\n                    node = pyrax.cloudloadbalancers.Node(\n                        address=address, port=port, condition=condition,\n                        weight=weight, type=typ)\n                    resp, body = lb.add_nodes([node])\n                    result.update(body['nodes'][0])\n                except pyrax.exc.PyraxException as e:\n                    module.fail_json(msg='%s' % e.message)\n        else:  \n            mutable = {\n                'condition': condition,\n                'type': typ,\n                'weight': weight,\n            }\n\n            for name, value in mutable.items():\n                if value is None or value == getattr(node, name):\n                    mutable.pop(name)\n\n            if not mutable:\n                module.exit_json(changed=False, state=state, node=result)\n\n            try:\n                \n                \n                lb.update_node(node, diff=mutable)\n                result.update(mutable)\n            except pyrax.exc.PyraxException as e:\n                module.fail_json(msg='%s' % e.message)\n\n    if wait:\n        pyrax.utils.wait_until(lb, \"status\", \"ACTIVE\", interval=1,\n                               attempts=wait_timeout)\n        if lb.status != 'ACTIVE':\n            module.fail_json(\n                msg='Load balancer not active after %ds (current status: %s)' %\n                    (wait_timeout, lb.status.lower()))\n\n    kwargs = {'node': result} if result else {}\n    module.exit_json(changed=True, state=state, **kwargs)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "   return matching node             module  rax clb nodes short description  add  modify remove nodes rackspace cloud load balancer description      adds  modifies removes nodes rackspace cloud load balancer version added   1 4  options    address      required  false     description          ip address domain name node   condition      required  false     choices          enabled         disabled         draining     description          condition node  determines role within load         balancer   load balancer id      required  true     description          load balancer id   node id      required  false     description          node id   port      required  false     description          port number load balanced service node   state      required  false     default   present      choices          present         absent     description          indicate desired state node   type      required  false     choices          primary         secondary     description          type node   wait      required  false     default        choices           yes                description          wait load balancer become active returning   wait timeout      required  false     default  30     description          how long wait giving returning error   weight      required  false     description          weight node author   lukasz kawczynski ( neuroid)  extends documentation fragment      rackspace     rackspace openstack      examples         add new node load balancer   local action      module  rax clb nodes     load balancer id  71     address  10 2 2 3     port  80     condition  enabled     type  primary     wait  yes     credentials   path credentials    drain connections node   local action      module  rax clb nodes     load balancer id  71     node id  410     condition  draining     wait  yes     credentials   path credentials    remove node load balancer   local action      module  rax clb nodes     load balancer id  71     node id  410     state  absent     wait  yes     credentials   path credentials         usr bin python    copyright  ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    add new node load balancer    drain connections node    remove node load balancer    removing non existent node    present    updating non existent node    creating new node    updating existing node    the diff set explicitly update node weight    type  probably fixed pyrax ", "content": "#!/usr/bin/python\n# Copyright: Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: rax_clb_nodes\nshort_description: add, modify and remove nodes from a Rackspace Cloud Load Balancer\ndescription:\n  - Adds, modifies and removes nodes from a Rackspace Cloud Load Balancer\nversion_added: \"1.4\"\noptions:\n  address:\n    required: false\n    description:\n      - IP address or domain name of the node\n  condition:\n    required: false\n    choices:\n      - enabled\n      - disabled\n      - draining\n    description:\n      - Condition for the node, which determines its role within the load\n        balancer\n  load_balancer_id:\n    required: true\n    description:\n      - Load balancer id\n  node_id:\n    required: false\n    description:\n      - Node id\n  port:\n    required: false\n    description:\n      - Port number of the load balanced service on the node\n  state:\n    required: false\n    default: \"present\"\n    choices:\n      - present\n      - absent\n    description:\n      - Indicate desired state of the node\n  type:\n    required: false\n    choices:\n      - primary\n      - secondary\n    description:\n      - Type of node\n  wait:\n    required: false\n    default: \"no\"\n    choices:\n      - \"yes\"\n      - \"no\"\n    description:\n      - Wait for the load balancer to become active before returning\n  wait_timeout:\n    required: false\n    default: 30\n    description:\n      - How long to wait before giving up and returning an error\n  weight:\n    required: false\n    description:\n      - Weight of node\nauthor: \"Lukasz Kawczynski (@neuroid)\"\nextends_documentation_fragment:\n  - rackspace\n  - rackspace.openstack\n'''\n\nEXAMPLES = '''\n# Add a new node to the load balancer\n- local_action:\n    module: rax_clb_nodes\n    load_balancer_id: 71\n    address: 10.2.2.3\n    port: 80\n    condition: enabled\n    type: primary\n    wait: yes\n    credentials: /path/to/credentials\n\n# Drain connections from a node\n- local_action:\n    module: rax_clb_nodes\n    load_balancer_id: 71\n    node_id: 410\n    condition: draining\n    wait: yes\n    credentials: /path/to/credentials\n\n# Remove a node from the load balancer\n- local_action:\n    module: rax_clb_nodes\n    load_balancer_id: 71\n    node_id: 410\n    state: absent\n    wait: yes\n    credentials: /path/to/credentials\n'''\n\nimport os\n\ntry:\n    import pyrax\n    HAS_PYRAX = True\nexcept ImportError:\n    HAS_PYRAX = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.rax import rax_argument_spec, rax_clb_node_to_dict, rax_required_together, setup_rax_module\n\n\ndef _activate_virtualenv(path):\n    activate_this = os.path.join(path, 'bin', 'activate_this.py')\n    with open(activate_this) as f:\n        code = compile(f.read(), activate_this, 'exec')\n        exec(code)\n\n\ndef _get_node(lb, node_id=None, address=None, port=None):\n    \"\"\"Return a matching node\"\"\"\n    for node in getattr(lb, 'nodes', []):\n        match_list = []\n        if node_id is not None:\n            match_list.append(getattr(node, 'id', None) == node_id)\n        if address is not None:\n            match_list.append(getattr(node, 'address', None) == address)\n        if port is not None:\n            match_list.append(getattr(node, 'port', None) == port)\n\n        if match_list and all(match_list):\n            return node\n\n    return None\n\n\ndef main():\n    argument_spec = rax_argument_spec()\n    argument_spec.update(\n        dict(\n            address=dict(),\n            condition=dict(choices=['enabled', 'disabled', 'draining']),\n            load_balancer_id=dict(required=True, type='int'),\n            node_id=dict(type='int'),\n            port=dict(type='int'),\n            state=dict(default='present', choices=['present', 'absent']),\n            type=dict(choices=['primary', 'secondary']),\n            virtualenv=dict(type='path'),\n            wait=dict(default=False, type='bool'),\n            wait_timeout=dict(default=30, type='int'),\n            weight=dict(type='int'),\n        )\n    )\n\n    module = AnsibleModule(\n        argument_spec=argument_spec,\n        required_together=rax_required_together(),\n    )\n\n    if not HAS_PYRAX:\n        module.fail_json(msg='pyrax is required for this module')\n\n    address = module.params['address']\n    condition = (module.params['condition'] and\n                 module.params['condition'].upper())\n    load_balancer_id = module.params['load_balancer_id']\n    node_id = module.params['node_id']\n    port = module.params['port']\n    state = module.params['state']\n    typ = module.params['type'] and module.params['type'].upper()\n    virtualenv = module.params['virtualenv']\n    wait = module.params['wait']\n    wait_timeout = module.params['wait_timeout'] or 1\n    weight = module.params['weight']\n\n    if virtualenv:\n        try:\n            _activate_virtualenv(virtualenv)\n        except IOError as e:\n            module.fail_json(msg='Failed to activate virtualenv %s (%s)' % (\n                                 virtualenv, e))\n\n    setup_rax_module(module, pyrax)\n\n    if not pyrax.cloud_loadbalancers:\n        module.fail_json(msg='Failed to instantiate client. This '\n                             'typically indicates an invalid region or an '\n                             'incorrectly capitalized region name.')\n\n    try:\n        lb = pyrax.cloud_loadbalancers.get(load_balancer_id)\n    except pyrax.exc.PyraxException as e:\n        module.fail_json(msg='%s' % e.message)\n\n    node = _get_node(lb, node_id, address, port)\n\n    result = rax_clb_node_to_dict(node)\n\n    if state == 'absent':\n        if not node:  # Removing a non-existent node\n            module.exit_json(changed=False, state=state)\n        try:\n            lb.delete_node(node)\n            result = {}\n        except pyrax.exc.NotFound:\n            module.exit_json(changed=False, state=state)\n        except pyrax.exc.PyraxException as e:\n            module.fail_json(msg='%s' % e.message)\n    else:  # present\n        if not node:\n            if node_id:  # Updating a non-existent node\n                msg = 'Node %d not found' % node_id\n                if lb.nodes:\n                    msg += (' (available nodes: %s)' %\n                            ', '.join([str(x.id) for x in lb.nodes]))\n                module.fail_json(msg=msg)\n            else:  # Creating a new node\n                try:\n                    node = pyrax.cloudloadbalancers.Node(\n                        address=address, port=port, condition=condition,\n                        weight=weight, type=typ)\n                    resp, body = lb.add_nodes([node])\n                    result.update(body['nodes'][0])\n                except pyrax.exc.PyraxException as e:\n                    module.fail_json(msg='%s' % e.message)\n        else:  # Updating an existing node\n            mutable = {\n                'condition': condition,\n                'type': typ,\n                'weight': weight,\n            }\n\n            for name, value in mutable.items():\n                if value is None or value == getattr(node, name):\n                    mutable.pop(name)\n\n            if not mutable:\n                module.exit_json(changed=False, state=state, node=result)\n\n            try:\n                # The diff has to be set explicitly to update node's weight and\n                # type; this should probably be fixed in pyrax\n                lb.update_node(node, diff=mutable)\n                result.update(mutable)\n            except pyrax.exc.PyraxException as e:\n                module.fail_json(msg='%s' % e.message)\n\n    if wait:\n        pyrax.utils.wait_until(lb, \"status\", \"ACTIVE\", interval=1,\n                               attempts=wait_timeout)\n        if lb.status != 'ACTIVE':\n            module.fail_json(\n                msg='Load balancer not active after %ds (current status: %s)' %\n                    (wait_timeout, lb.status.lower()))\n\n    kwargs = {'node': result} if result else {}\n    module.exit_json(changed=True, state=state, **kwargs)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "rax_clb_nodes.py", "id": "b592463cdbd2e9bc58c8fa317c6623df", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/cloud/rackspace/rax_clb_nodes.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}