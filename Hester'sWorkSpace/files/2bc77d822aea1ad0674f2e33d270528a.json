{"author": "ansible", "code": "\n# -*- coding: utf-8 -*-\n\n# (c) 2015, Maciej Delmanowski <drybjed@gmail.com>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: virt_pool\nauthor: \"Maciej Delmanowski (@drybjed)\"\nversion_added: \"2.0\"\nshort_description: Manage libvirt storage pools\ndescription:\n    - Manage I(libvirt) storage pools.\noptions:\n    name:\n        required: false\n        aliases: [ \"pool\" ]\n        description:\n            - name of the storage pool being managed. Note that pool must be previously\n              defined with xml.\n    state:\n        required: false\n        choices: [ \"active\", \"inactive\", \"present\", \"absent\", \"undefined\", \"deleted\" ]\n        description:\n            - specify which state you want a storage pool to be in.\n              If 'active', pool will be started.\n              If 'present', ensure that pool is present but do not change its\n              state; if it's missing, you need to specify xml argument.\n              If 'inactive', pool will be stopped.\n              If 'undefined' or 'absent', pool will be removed from I(libvirt) configuration.\n              If 'deleted', pool contents will be deleted and then pool undefined.\n    command:\n        required: false\n        choices: [ \"define\", \"build\", \"create\", \"start\", \"stop\", \"destroy\",\n                   \"delete\", \"undefine\", \"get_xml\", \"list_pools\", \"facts\",\n                   \"info\", \"status\" ]\n        description:\n            - in addition to state management, various non-idempotent commands are available.\n              See examples.\n    autostart:\n        required: false\n        choices: [\"yes\", \"no\"]\n        description:\n            - Specify if a given storage pool should be started automatically on system boot.\n    uri:\n        required: false\n        default: \"qemu:///system\"\n        description:\n            - I(libvirt) connection uri.\n    xml:\n        required: false\n        description:\n            - XML document used with the define command.\n    mode:\n        required: false\n        choices: [ 'new', 'repair', 'resize', 'no_overwrite', 'overwrite', 'normal', 'zeroed' ]\n        description:\n            - Pass additional parameters to 'build' or 'delete' commands.\nrequirements:\n    - \"python >= 2.6\"\n    - \"python-libvirt\"\n    - \"python-lxml\"\n'''\n\nEXAMPLES = '''\n\n- virt_pool:\n    command: define\n    name: vms\n    xml: '{{ lookup(\"template\", \"pool/dir.xml.j2\") }}'\n\n\n- virt_pool:\n    command: build\n    name: vms\n\n\n- virt_pool:\n    command: create\n    name: vms\n\n\n- virt_pool:\n    command: list_pools\n\n\n- virt_pool:\n    command: get_xml\n    name: vms\n\n\n- virt_pool:\n    command: destroy\n    name: vms\n\n# Delete a storage pool (destroys contents)\n- virt_pool:\n    command: delete\n    name: vms\n\n\n- virt_pool:\n    command: undefine\n    name: vms\n\n\n\n- virt_pool:\n    command: facts\n\n\n- virt_pool:\n    command: info\n    uri: '{{ item }}'\n  with_items: '{{ libvirt_uris }}'\n  register: storage_pools\n\n# Ensure that a pool is active (needs to be defined and built first)\n- virt_pool:\n    state: active\n    name: vms\n\n\n- virt_pool:\n    state: inactive\n    name: vms\n\n\n- virt_pool:\n    autostart: yes\n    name: vms\n\n\n- virt_pool:\n    autostart: no\n    name: vms\n'''\n\ntry:\n    import libvirt\nexcept ImportError:\n    HAS_VIRT = False\nelse:\n    HAS_VIRT = True\n\ntry:\n    from lxml import etree\nexcept ImportError:\n    HAS_XML = False\nelse:\n    HAS_XML = True\n\nfrom ansible.module_utils.basic import AnsibleModule\n\n\nVIRT_FAILED = 1\nVIRT_SUCCESS = 0\nVIRT_UNAVAILABLE = 2\n\nALL_COMMANDS = []\nENTRY_COMMANDS = ['create', 'status', 'start', 'stop', 'build', 'delete',\n                  'undefine', 'destroy', 'get_xml', 'define', 'refresh']\nHOST_COMMANDS = ['list_pools', 'facts', 'info']\nALL_COMMANDS.extend(ENTRY_COMMANDS)\nALL_COMMANDS.extend(HOST_COMMANDS)\n\nENTRY_STATE_ACTIVE_MAP = {\n    0: \"inactive\",\n    1: \"active\"\n}\n\nENTRY_STATE_AUTOSTART_MAP = {\n    0: \"no\",\n    1: \"yes\"\n}\n\nENTRY_STATE_PERSISTENT_MAP = {\n    0: \"no\",\n    1: \"yes\"\n}\n\nENTRY_STATE_INFO_MAP = {\n    0: \"inactive\",\n    1: \"building\",\n    2: \"running\",\n    3: \"degraded\",\n    4: \"inaccessible\"\n}\n\nENTRY_BUILD_FLAGS_MAP = {\n    \"new\": 0,\n    \"repair\": 1,\n    \"resize\": 2,\n    \"no_overwrite\": 4,\n    \"overwrite\": 8\n}\n\nENTRY_DELETE_FLAGS_MAP = {\n    \"normal\": 0,\n    \"zeroed\": 1\n}\n\nALL_MODES = []\nALL_MODES.extend(ENTRY_BUILD_FLAGS_MAP.keys())\nALL_MODES.extend(ENTRY_DELETE_FLAGS_MAP.keys())\n\n\nclass EntryNotFound(Exception):\n    pass\n\n\nclass LibvirtConnection(object):\n\n    def __init__(self, uri, module):\n\n        self.module = module\n\n        conn = libvirt.open(uri)\n\n        if not conn:\n            raise Exception(\"hypervisor connection failure\")\n\n        self.conn = conn\n\n    def find_entry(self, entryid):\n        \n\n        results = []\n\n        \n        for name in self.conn.listStoragePools():\n            entry = self.conn.storagePoolLookupByName(name)\n            results.append(entry)\n\n        \n        for name in self.conn.listDefinedStoragePools():\n            entry = self.conn.storagePoolLookupByName(name)\n            results.append(entry)\n\n        if entryid == -1:\n            return results\n\n        for entry in results:\n            if entry.name() == entryid:\n                return entry\n\n        raise EntryNotFound(\"storage pool %s not found\" % entryid)\n\n    def create(self, entryid):\n        if not self.module.check_mode:\n            return self.find_entry(entryid).create()\n        else:\n            try:\n                state = self.find_entry(entryid).isActive()\n            except:\n                return self.module.exit_json(changed=True)\n            if not state:\n                return self.module.exit_json(changed=True)\n\n    def destroy(self, entryid):\n        if not self.module.check_mode:\n            return self.find_entry(entryid).destroy()\n        else:\n            if self.find_entry(entryid).isActive():\n                return self.module.exit_json(changed=True)\n\n    def undefine(self, entryid):\n        if not self.module.check_mode:\n            return self.find_entry(entryid).undefine()\n        else:\n            if not self.find_entry(entryid):\n                return self.module.exit_json(changed=True)\n\n    def get_status2(self, entry):\n        state = entry.isActive()\n        return ENTRY_STATE_ACTIVE_MAP.get(state, \"unknown\")\n\n    def get_status(self, entryid):\n        if not self.module.check_mode:\n            state = self.find_entry(entryid).isActive()\n            return ENTRY_STATE_ACTIVE_MAP.get(state, \"unknown\")\n        else:\n            try:\n                state = self.find_entry(entryid).isActive()\n                return ENTRY_STATE_ACTIVE_MAP.get(state, \"unknown\")\n            except:\n                return ENTRY_STATE_ACTIVE_MAP.get(\"inactive\", \"unknown\")\n\n    def get_uuid(self, entryid):\n        return self.find_entry(entryid).UUIDString()\n\n    def get_xml(self, entryid):\n        return self.find_entry(entryid).XMLDesc(0)\n\n    def get_info(self, entryid):\n        return self.find_entry(entryid).info()\n\n    def get_volume_count(self, entryid):\n        return self.find_entry(entryid).numOfVolumes()\n\n    def get_volume_names(self, entryid):\n        return self.find_entry(entryid).listVolumes()\n\n    def get_devices(self, entryid):\n        xml = etree.fromstring(self.find_entry(entryid).XMLDesc(0))\n        if xml.xpath('/pool/source/device'):\n            result = []\n            for device in xml.xpath('/pool/source/device'):\n                result.append(device.get('path'))\n        try:\n            return result\n        except:\n            raise ValueError('No devices specified')\n\n    def get_format(self, entryid):\n        xml = etree.fromstring(self.find_entry(entryid).XMLDesc(0))\n        try:\n            result = xml.xpath('/pool/source/format')[0].get('type')\n        except:\n            raise ValueError('Format not specified')\n        return result\n\n    def get_host(self, entryid):\n        xml = etree.fromstring(self.find_entry(entryid).XMLDesc(0))\n        try:\n            result = xml.xpath('/pool/source/host')[0].get('name')\n        except:\n            raise ValueError('Host not specified')\n        return result\n\n    def get_source_path(self, entryid):\n        xml = etree.fromstring(self.find_entry(entryid).XMLDesc(0))\n        try:\n            result = xml.xpath('/pool/source/dir')[0].get('path')\n        except:\n            raise ValueError('Source path not specified')\n        return result\n\n    def get_path(self, entryid):\n        xml = etree.fromstring(self.find_entry(entryid).XMLDesc(0))\n        return xml.xpath('/pool/target/path')[0].text\n\n    def get_type(self, entryid):\n        xml = etree.fromstring(self.find_entry(entryid).XMLDesc(0))\n        return xml.get('type')\n\n    def build(self, entryid, flags):\n        if not self.module.check_mode:\n            return self.find_entry(entryid).build(flags)\n        else:\n            try:\n                state = self.find_entry(entryid)\n            except:\n                return self.module.exit_json(changed=True)\n            if not state:\n                return self.module.exit_json(changed=True)\n\n    def delete(self, entryid, flags):\n        if not self.module.check_mode:\n            return self.find_entry(entryid).delete(flags)\n        else:\n            try:\n                state = self.find_entry(entryid)\n            except:\n                return self.module.exit_json(changed=True)\n            if state:\n                return self.module.exit_json(changed=True)\n\n    def get_autostart(self, entryid):\n        state = self.find_entry(entryid).autostart()\n        return ENTRY_STATE_AUTOSTART_MAP.get(state, \"unknown\")\n\n    def get_autostart2(self, entryid):\n        if not self.module.check_mode:\n            return self.find_entry(entryid).autostart()\n        else:\n            try:\n                return self.find_entry(entryid).autostart()\n            except:\n                return self.module.exit_json(changed=True)\n\n    def set_autostart(self, entryid, val):\n        if not self.module.check_mode:\n            return self.find_entry(entryid).setAutostart(val)\n        else:\n            try:\n                state = self.find_entry(entryid).autostart()\n            except:\n                return self.module.exit_json(changed=True)\n            if bool(state) != val:\n                return self.module.exit_json(changed=True)\n\n    def refresh(self, entryid):\n        return self.find_entry(entryid).refresh()\n\n    def get_persistent(self, entryid):\n        state = self.find_entry(entryid).isPersistent()\n        return ENTRY_STATE_PERSISTENT_MAP.get(state, \"unknown\")\n\n    def define_from_xml(self, entryid, xml):\n        if not self.module.check_mode:\n            return self.conn.storagePoolDefineXML(xml)\n        else:\n            try:\n                self.find_entry(entryid)\n            except:\n                return self.module.exit_json(changed=True)\n\n\nclass VirtStoragePool(object):\n\n    def __init__(self, uri, module):\n        self.module = module\n        self.uri = uri\n        self.conn = LibvirtConnection(self.uri, self.module)\n\n    def get_pool(self, entryid):\n        return self.conn.find_entry(entryid)\n\n    def list_pools(self, state=None):\n        results = []\n        for entry in self.conn.find_entry(-1):\n            if state:\n                if state == self.conn.get_status2(entry):\n                    results.append(entry.name())\n            else:\n                results.append(entry.name())\n        return results\n\n    def state(self):\n        results = []\n        for entry in self.list_pools():\n            state_blurb = self.conn.get_status(entry)\n            results.append(\"%s %s\" % (entry, state_blurb))\n        return results\n\n    def autostart(self, entryid):\n        return self.conn.set_autostart(entryid, True)\n\n    def get_autostart(self, entryid):\n        return self.conn.get_autostart2(entryid)\n\n    def set_autostart(self, entryid, state):\n        return self.conn.set_autostart(entryid, state)\n\n    def create(self, entryid):\n        return self.conn.create(entryid)\n\n    def start(self, entryid):\n        return self.conn.create(entryid)\n\n    def stop(self, entryid):\n        return self.conn.destroy(entryid)\n\n    def destroy(self, entryid):\n        return self.conn.destroy(entryid)\n\n    def undefine(self, entryid):\n        return self.conn.undefine(entryid)\n\n    def status(self, entryid):\n        return self.conn.get_status(entryid)\n\n    def get_xml(self, entryid):\n        return self.conn.get_xml(entryid)\n\n    def define(self, entryid, xml):\n        return self.conn.define_from_xml(entryid, xml)\n\n    def build(self, entryid, flags):\n        return self.conn.build(entryid, ENTRY_BUILD_FLAGS_MAP.get(flags, 0))\n\n    def delete(self, entryid, flags):\n        return self.conn.delete(entryid, ENTRY_DELETE_FLAGS_MAP.get(flags, 0))\n\n    def refresh(self, entryid):\n        return self.conn.refresh(entryid)\n\n    def info(self):\n        return self.facts(facts_mode='info')\n\n    def facts(self, facts_mode='facts'):\n        results = dict()\n        for entry in self.list_pools():\n            results[entry] = dict()\n            if self.conn.find_entry(entry):\n                data = self.conn.get_info(entry)\n                # libvirt returns maxMem, memory, and cpuTime as long()'s, which\n                \n                \n                \n                \n                results[entry] = {\n                    \"status\": ENTRY_STATE_INFO_MAP.get(data[0], \"unknown\"),\n                    \"size_total\": str(data[1]),\n                    \"size_used\": str(data[2]),\n                    \"size_available\": str(data[3]),\n                }\n                results[entry][\"autostart\"] = self.conn.get_autostart(entry)\n                results[entry][\"persistent\"] = self.conn.get_persistent(entry)\n                results[entry][\"state\"] = self.conn.get_status(entry)\n                results[entry][\"path\"] = self.conn.get_path(entry)\n                results[entry][\"type\"] = self.conn.get_type(entry)\n                results[entry][\"uuid\"] = self.conn.get_uuid(entry)\n                if self.conn.find_entry(entry).isActive():\n                    results[entry][\"volume_count\"] = self.conn.get_volume_count(entry)\n                    results[entry][\"volumes\"] = list()\n                    for volume in self.conn.get_volume_names(entry):\n                        results[entry][\"volumes\"].append(volume)\n                else:\n                    results[entry][\"volume_count\"] = -1\n\n                try:\n                    results[entry][\"host\"] = self.conn.get_host(entry)\n                except ValueError:\n                    pass\n\n                try:\n                    results[entry][\"source_path\"] = self.conn.get_source_path(entry)\n                except ValueError:\n                    pass\n\n                try:\n                    results[entry][\"format\"] = self.conn.get_format(entry)\n                except ValueError:\n                    pass\n\n                try:\n                    devices = self.conn.get_devices(entry)\n                    results[entry][\"devices\"] = devices\n                except ValueError:\n                    pass\n\n            else:\n                results[entry][\"state\"] = self.conn.get_status(entry)\n\n        facts = dict()\n        if facts_mode == 'facts':\n            facts[\"ansible_facts\"] = dict()\n            facts[\"ansible_facts\"][\"ansible_libvirt_pools\"] = results\n        elif facts_mode == 'info':\n            facts['pools'] = results\n        return facts\n\n\ndef core(module):\n\n    state = module.params.get('state', None)\n    name = module.params.get('name', None)\n    command = module.params.get('command', None)\n    uri = module.params.get('uri', None)\n    xml = module.params.get('xml', None)\n    autostart = module.params.get('autostart', None)\n    mode = module.params.get('mode', None)\n\n    v = VirtStoragePool(uri, module)\n    res = {}\n\n    if state and command == 'list_pools':\n        res = v.list_pools(state=state)\n        if not isinstance(res, dict):\n            res = {command: res}\n        return VIRT_SUCCESS, res\n\n    if state:\n        if not name:\n            module.fail_json(msg=\"state change requires a specified name\")\n\n        res['changed'] = False\n        if state in ['active']:\n            if v.status(name) is not 'active':\n                res['changed'] = True\n                res['msg'] = v.start(name)\n        elif state in ['present']:\n            try:\n                v.get_pool(name)\n            except EntryNotFound:\n                if not xml:\n                    module.fail_json(msg=\"storage pool '\" + name + \"' not present, but xml not specified\")\n                v.define(name, xml)\n                res = {'changed': True, 'created': name}\n        elif state in ['inactive']:\n            entries = v.list_pools()\n            if name in entries:\n                if v.status(name) is not 'inactive':\n                    res['changed'] = True\n                    res['msg'] = v.destroy(name)\n        elif state in ['undefined', 'absent']:\n            entries = v.list_pools()\n            if name in entries:\n                if v.status(name) is not 'inactive':\n                    v.destroy(name)\n                res['changed'] = True\n                res['msg'] = v.undefine(name)\n        elif state in ['deleted']:\n            entries = v.list_pools()\n            if name in entries:\n                if v.status(name) is not 'inactive':\n                    v.destroy(name)\n                v.delete(name, mode)\n                res['changed'] = True\n                res['msg'] = v.undefine(name)\n        else:\n            module.fail_json(msg=\"unexpected state\")\n\n        return VIRT_SUCCESS, res\n\n    if command:\n        if command in ENTRY_COMMANDS:\n            if not name:\n                module.fail_json(msg=\"%s requires 1 argument: name\" % command)\n            if command == 'define':\n                if not xml:\n                    module.fail_json(msg=\"define requires xml argument\")\n                try:\n                    v.get_pool(name)\n                except EntryNotFound:\n                    v.define(name, xml)\n                    res = {'changed': True, 'created': name}\n                return VIRT_SUCCESS, res\n            elif command == 'build':\n                res = v.build(name, mode)\n                if not isinstance(res, dict):\n                    res = {'changed': True, command: res}\n                return VIRT_SUCCESS, res\n            elif command == 'delete':\n                res = v.delete(name, mode)\n                if not isinstance(res, dict):\n                    res = {'changed': True, command: res}\n                return VIRT_SUCCESS, res\n            res = getattr(v, command)(name)\n            if not isinstance(res, dict):\n                res = {command: res}\n            return VIRT_SUCCESS, res\n\n        elif hasattr(v, command):\n            res = getattr(v, command)()\n            if not isinstance(res, dict):\n                res = {command: res}\n            return VIRT_SUCCESS, res\n\n        else:\n            module.fail_json(msg=\"Command %s not recognized\" % command)\n\n    if autostart is not None:\n        if not name:\n            module.fail_json(msg=\"state change requires a specified name\")\n\n        res['changed'] = False\n        if autostart:\n            if not v.get_autostart(name):\n                res['changed'] = True\n                res['msg'] = v.set_autostart(name, True)\n        else:\n            if v.get_autostart(name):\n                res['changed'] = True\n                res['msg'] = v.set_autostart(name, False)\n\n        return VIRT_SUCCESS, res\n\n    module.fail_json(msg=\"expected state or command parameter to be specified\")\n\n\ndef main():\n\n    module = AnsibleModule(\n        argument_spec=dict(\n            name=dict(aliases=['pool']),\n            state=dict(choices=['active', 'inactive', 'present', 'absent', 'undefined', 'deleted']),\n            command=dict(choices=ALL_COMMANDS),\n            uri=dict(default='qemu:///system'),\n            xml=dict(),\n            autostart=dict(type='bool'),\n            mode=dict(choices=ALL_MODES),\n        ),\n        supports_check_mode=True\n    )\n\n    if not HAS_VIRT:\n        module.fail_json(\n            msg='The `libvirt` module is not importable. Check the requirements.'\n        )\n\n    if not HAS_XML:\n        module.fail_json(\n            msg='The `lxml` module is not importable. Check the requirements.'\n        )\n\n    rc = VIRT_SUCCESS\n    try:\n        rc, result = core(module)\n    except Exception as e:\n        module.fail_json(msg=str(e))\n\n    if rc != 0:  \n        module.fail_json(rc=rc, msg=result)\n    else:\n        module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  virt pool author   maciej delmanowski ( drybjed)  version added   2 0  short description  manage libvirt storage pools description        manage i(libvirt) storage pools  options      name          required  false         aliases     pool            description                name storage pool managed  note pool must previously               defined xml      state          required  false         choices     active    inactive    present    absent    undefined    deleted            description                specify state want storage pool                if  active   pool started                if  present   ensure pool present change               state  missing  need specify xml argument                if  inactive   pool stopped                if  undefined   absent   pool removed i(libvirt) configuration                if  deleted   pool contents deleted pool undefined      command          required  false         choices     define    build    create    start    stop    destroy                       delete    undefine    get xml    list pools    facts                       info    status            description                addition state management  various non idempotent commands available                see examples      autostart          required  false         choices    yes              description                specify given storage pool started automatically system boot      uri          required  false         default   qemu    system          description                i(libvirt) connection uri      xml          required  false         description                xml document used define command      mode          required  false         choices     new    repair    resize    overwrite    overwrite    normal    zeroed            description                pass additional parameters  build   delete  commands  requirements         python    2 6         python libvirt         python lxml       examples         define new storage pool   virt pool      command  define     name  vms     xml      lookup( template    pool dir xml j2 )        build storage pool exist   virt pool      command  build     name  vms    start storage pool   virt pool      command  create     name  vms    list available pools   virt pool      command  list pools    get xml data specified pool   virt pool      command  get xml     name  vms    stop storage pool   virt pool      command  destroy     name  vms    delete storage pool (destroys contents)   virt pool      command  delete     name  vms    undefine storage pool   virt pool      command  undefine     name  vms    gather facts storage pools   facts available  ansible libvirt pools    virt pool      command  facts    gather information pools managed  libvirt  remotely using uri   virt pool      command  info     uri      item       items      libvirt uris       register  storage pools    ensure pool active (needs defined built first)   virt pool      state  active     name  vms    ensure pool inactive   virt pool      state  inactive     name  vms    ensure given pool started boot   virt pool      autostart  yes     name  vms    disable autostart given pool   virt pool      autostart      name  vms         usr bin python        coding  utf 8        (c) 2015  maciej delmanowski  drybjed gmail com     gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    define new storage pool    build storage pool exist    start storage pool    list available pools    get xml data specified pool    stop storage pool    delete storage pool (destroys contents)    undefine storage pool    gather facts storage pools    facts available  ansible libvirt pools     gather information pools managed  libvirt  remotely using uri    ensure pool active (needs defined built first)    ensure pool inactive    ensure given pool started boot    disable autostart given pool    entryid    1 returns list everything    get active entries    get inactive entries    libvirt returns maxmem  memory  cputime long()     xmlrpclib tries convert regular int serialization     this throws exceptions  convert strings    assume end xmlrpc connection figure things    care     something went wrong emit msg ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# (c) 2015, Maciej Delmanowski <drybjed@gmail.com>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: virt_pool\nauthor: \"Maciej Delmanowski (@drybjed)\"\nversion_added: \"2.0\"\nshort_description: Manage libvirt storage pools\ndescription:\n    - Manage I(libvirt) storage pools.\noptions:\n    name:\n        required: false\n        aliases: [ \"pool\" ]\n        description:\n            - name of the storage pool being managed. Note that pool must be previously\n              defined with xml.\n    state:\n        required: false\n        choices: [ \"active\", \"inactive\", \"present\", \"absent\", \"undefined\", \"deleted\" ]\n        description:\n            - specify which state you want a storage pool to be in.\n              If 'active', pool will be started.\n              If 'present', ensure that pool is present but do not change its\n              state; if it's missing, you need to specify xml argument.\n              If 'inactive', pool will be stopped.\n              If 'undefined' or 'absent', pool will be removed from I(libvirt) configuration.\n              If 'deleted', pool contents will be deleted and then pool undefined.\n    command:\n        required: false\n        choices: [ \"define\", \"build\", \"create\", \"start\", \"stop\", \"destroy\",\n                   \"delete\", \"undefine\", \"get_xml\", \"list_pools\", \"facts\",\n                   \"info\", \"status\" ]\n        description:\n            - in addition to state management, various non-idempotent commands are available.\n              See examples.\n    autostart:\n        required: false\n        choices: [\"yes\", \"no\"]\n        description:\n            - Specify if a given storage pool should be started automatically on system boot.\n    uri:\n        required: false\n        default: \"qemu:///system\"\n        description:\n            - I(libvirt) connection uri.\n    xml:\n        required: false\n        description:\n            - XML document used with the define command.\n    mode:\n        required: false\n        choices: [ 'new', 'repair', 'resize', 'no_overwrite', 'overwrite', 'normal', 'zeroed' ]\n        description:\n            - Pass additional parameters to 'build' or 'delete' commands.\nrequirements:\n    - \"python >= 2.6\"\n    - \"python-libvirt\"\n    - \"python-lxml\"\n'''\n\nEXAMPLES = '''\n# Define a new storage pool\n- virt_pool:\n    command: define\n    name: vms\n    xml: '{{ lookup(\"template\", \"pool/dir.xml.j2\") }}'\n\n# Build a storage pool if it does not exist\n- virt_pool:\n    command: build\n    name: vms\n\n# Start a storage pool\n- virt_pool:\n    command: create\n    name: vms\n\n# List available pools\n- virt_pool:\n    command: list_pools\n\n# Get XML data of a specified pool\n- virt_pool:\n    command: get_xml\n    name: vms\n\n# Stop a storage pool\n- virt_pool:\n    command: destroy\n    name: vms\n\n# Delete a storage pool (destroys contents)\n- virt_pool:\n    command: delete\n    name: vms\n\n# Undefine a storage pool\n- virt_pool:\n    command: undefine\n    name: vms\n\n# Gather facts about storage pools\n# Facts will be available as 'ansible_libvirt_pools'\n- virt_pool:\n    command: facts\n\n# Gather information about pools managed by 'libvirt' remotely using uri\n- virt_pool:\n    command: info\n    uri: '{{ item }}'\n  with_items: '{{ libvirt_uris }}'\n  register: storage_pools\n\n# Ensure that a pool is active (needs to be defined and built first)\n- virt_pool:\n    state: active\n    name: vms\n\n# Ensure that a pool is inactive\n- virt_pool:\n    state: inactive\n    name: vms\n\n# Ensure that a given pool will be started at boot\n- virt_pool:\n    autostart: yes\n    name: vms\n\n# Disable autostart for a given pool\n- virt_pool:\n    autostart: no\n    name: vms\n'''\n\ntry:\n    import libvirt\nexcept ImportError:\n    HAS_VIRT = False\nelse:\n    HAS_VIRT = True\n\ntry:\n    from lxml import etree\nexcept ImportError:\n    HAS_XML = False\nelse:\n    HAS_XML = True\n\nfrom ansible.module_utils.basic import AnsibleModule\n\n\nVIRT_FAILED = 1\nVIRT_SUCCESS = 0\nVIRT_UNAVAILABLE = 2\n\nALL_COMMANDS = []\nENTRY_COMMANDS = ['create', 'status', 'start', 'stop', 'build', 'delete',\n                  'undefine', 'destroy', 'get_xml', 'define', 'refresh']\nHOST_COMMANDS = ['list_pools', 'facts', 'info']\nALL_COMMANDS.extend(ENTRY_COMMANDS)\nALL_COMMANDS.extend(HOST_COMMANDS)\n\nENTRY_STATE_ACTIVE_MAP = {\n    0: \"inactive\",\n    1: \"active\"\n}\n\nENTRY_STATE_AUTOSTART_MAP = {\n    0: \"no\",\n    1: \"yes\"\n}\n\nENTRY_STATE_PERSISTENT_MAP = {\n    0: \"no\",\n    1: \"yes\"\n}\n\nENTRY_STATE_INFO_MAP = {\n    0: \"inactive\",\n    1: \"building\",\n    2: \"running\",\n    3: \"degraded\",\n    4: \"inaccessible\"\n}\n\nENTRY_BUILD_FLAGS_MAP = {\n    \"new\": 0,\n    \"repair\": 1,\n    \"resize\": 2,\n    \"no_overwrite\": 4,\n    \"overwrite\": 8\n}\n\nENTRY_DELETE_FLAGS_MAP = {\n    \"normal\": 0,\n    \"zeroed\": 1\n}\n\nALL_MODES = []\nALL_MODES.extend(ENTRY_BUILD_FLAGS_MAP.keys())\nALL_MODES.extend(ENTRY_DELETE_FLAGS_MAP.keys())\n\n\nclass EntryNotFound(Exception):\n    pass\n\n\nclass LibvirtConnection(object):\n\n    def __init__(self, uri, module):\n\n        self.module = module\n\n        conn = libvirt.open(uri)\n\n        if not conn:\n            raise Exception(\"hypervisor connection failure\")\n\n        self.conn = conn\n\n    def find_entry(self, entryid):\n        # entryid = -1 returns a list of everything\n\n        results = []\n\n        # Get active entries\n        for name in self.conn.listStoragePools():\n            entry = self.conn.storagePoolLookupByName(name)\n            results.append(entry)\n\n        # Get inactive entries\n        for name in self.conn.listDefinedStoragePools():\n            entry = self.conn.storagePoolLookupByName(name)\n            results.append(entry)\n\n        if entryid == -1:\n            return results\n\n        for entry in results:\n            if entry.name() == entryid:\n                return entry\n\n        raise EntryNotFound(\"storage pool %s not found\" % entryid)\n\n    def create(self, entryid):\n        if not self.module.check_mode:\n            return self.find_entry(entryid).create()\n        else:\n            try:\n                state = self.find_entry(entryid).isActive()\n            except:\n                return self.module.exit_json(changed=True)\n            if not state:\n                return self.module.exit_json(changed=True)\n\n    def destroy(self, entryid):\n        if not self.module.check_mode:\n            return self.find_entry(entryid).destroy()\n        else:\n            if self.find_entry(entryid).isActive():\n                return self.module.exit_json(changed=True)\n\n    def undefine(self, entryid):\n        if not self.module.check_mode:\n            return self.find_entry(entryid).undefine()\n        else:\n            if not self.find_entry(entryid):\n                return self.module.exit_json(changed=True)\n\n    def get_status2(self, entry):\n        state = entry.isActive()\n        return ENTRY_STATE_ACTIVE_MAP.get(state, \"unknown\")\n\n    def get_status(self, entryid):\n        if not self.module.check_mode:\n            state = self.find_entry(entryid).isActive()\n            return ENTRY_STATE_ACTIVE_MAP.get(state, \"unknown\")\n        else:\n            try:\n                state = self.find_entry(entryid).isActive()\n                return ENTRY_STATE_ACTIVE_MAP.get(state, \"unknown\")\n            except:\n                return ENTRY_STATE_ACTIVE_MAP.get(\"inactive\", \"unknown\")\n\n    def get_uuid(self, entryid):\n        return self.find_entry(entryid).UUIDString()\n\n    def get_xml(self, entryid):\n        return self.find_entry(entryid).XMLDesc(0)\n\n    def get_info(self, entryid):\n        return self.find_entry(entryid).info()\n\n    def get_volume_count(self, entryid):\n        return self.find_entry(entryid).numOfVolumes()\n\n    def get_volume_names(self, entryid):\n        return self.find_entry(entryid).listVolumes()\n\n    def get_devices(self, entryid):\n        xml = etree.fromstring(self.find_entry(entryid).XMLDesc(0))\n        if xml.xpath('/pool/source/device'):\n            result = []\n            for device in xml.xpath('/pool/source/device'):\n                result.append(device.get('path'))\n        try:\n            return result\n        except:\n            raise ValueError('No devices specified')\n\n    def get_format(self, entryid):\n        xml = etree.fromstring(self.find_entry(entryid).XMLDesc(0))\n        try:\n            result = xml.xpath('/pool/source/format')[0].get('type')\n        except:\n            raise ValueError('Format not specified')\n        return result\n\n    def get_host(self, entryid):\n        xml = etree.fromstring(self.find_entry(entryid).XMLDesc(0))\n        try:\n            result = xml.xpath('/pool/source/host')[0].get('name')\n        except:\n            raise ValueError('Host not specified')\n        return result\n\n    def get_source_path(self, entryid):\n        xml = etree.fromstring(self.find_entry(entryid).XMLDesc(0))\n        try:\n            result = xml.xpath('/pool/source/dir')[0].get('path')\n        except:\n            raise ValueError('Source path not specified')\n        return result\n\n    def get_path(self, entryid):\n        xml = etree.fromstring(self.find_entry(entryid).XMLDesc(0))\n        return xml.xpath('/pool/target/path')[0].text\n\n    def get_type(self, entryid):\n        xml = etree.fromstring(self.find_entry(entryid).XMLDesc(0))\n        return xml.get('type')\n\n    def build(self, entryid, flags):\n        if not self.module.check_mode:\n            return self.find_entry(entryid).build(flags)\n        else:\n            try:\n                state = self.find_entry(entryid)\n            except:\n                return self.module.exit_json(changed=True)\n            if not state:\n                return self.module.exit_json(changed=True)\n\n    def delete(self, entryid, flags):\n        if not self.module.check_mode:\n            return self.find_entry(entryid).delete(flags)\n        else:\n            try:\n                state = self.find_entry(entryid)\n            except:\n                return self.module.exit_json(changed=True)\n            if state:\n                return self.module.exit_json(changed=True)\n\n    def get_autostart(self, entryid):\n        state = self.find_entry(entryid).autostart()\n        return ENTRY_STATE_AUTOSTART_MAP.get(state, \"unknown\")\n\n    def get_autostart2(self, entryid):\n        if not self.module.check_mode:\n            return self.find_entry(entryid).autostart()\n        else:\n            try:\n                return self.find_entry(entryid).autostart()\n            except:\n                return self.module.exit_json(changed=True)\n\n    def set_autostart(self, entryid, val):\n        if not self.module.check_mode:\n            return self.find_entry(entryid).setAutostart(val)\n        else:\n            try:\n                state = self.find_entry(entryid).autostart()\n            except:\n                return self.module.exit_json(changed=True)\n            if bool(state) != val:\n                return self.module.exit_json(changed=True)\n\n    def refresh(self, entryid):\n        return self.find_entry(entryid).refresh()\n\n    def get_persistent(self, entryid):\n        state = self.find_entry(entryid).isPersistent()\n        return ENTRY_STATE_PERSISTENT_MAP.get(state, \"unknown\")\n\n    def define_from_xml(self, entryid, xml):\n        if not self.module.check_mode:\n            return self.conn.storagePoolDefineXML(xml)\n        else:\n            try:\n                self.find_entry(entryid)\n            except:\n                return self.module.exit_json(changed=True)\n\n\nclass VirtStoragePool(object):\n\n    def __init__(self, uri, module):\n        self.module = module\n        self.uri = uri\n        self.conn = LibvirtConnection(self.uri, self.module)\n\n    def get_pool(self, entryid):\n        return self.conn.find_entry(entryid)\n\n    def list_pools(self, state=None):\n        results = []\n        for entry in self.conn.find_entry(-1):\n            if state:\n                if state == self.conn.get_status2(entry):\n                    results.append(entry.name())\n            else:\n                results.append(entry.name())\n        return results\n\n    def state(self):\n        results = []\n        for entry in self.list_pools():\n            state_blurb = self.conn.get_status(entry)\n            results.append(\"%s %s\" % (entry, state_blurb))\n        return results\n\n    def autostart(self, entryid):\n        return self.conn.set_autostart(entryid, True)\n\n    def get_autostart(self, entryid):\n        return self.conn.get_autostart2(entryid)\n\n    def set_autostart(self, entryid, state):\n        return self.conn.set_autostart(entryid, state)\n\n    def create(self, entryid):\n        return self.conn.create(entryid)\n\n    def start(self, entryid):\n        return self.conn.create(entryid)\n\n    def stop(self, entryid):\n        return self.conn.destroy(entryid)\n\n    def destroy(self, entryid):\n        return self.conn.destroy(entryid)\n\n    def undefine(self, entryid):\n        return self.conn.undefine(entryid)\n\n    def status(self, entryid):\n        return self.conn.get_status(entryid)\n\n    def get_xml(self, entryid):\n        return self.conn.get_xml(entryid)\n\n    def define(self, entryid, xml):\n        return self.conn.define_from_xml(entryid, xml)\n\n    def build(self, entryid, flags):\n        return self.conn.build(entryid, ENTRY_BUILD_FLAGS_MAP.get(flags, 0))\n\n    def delete(self, entryid, flags):\n        return self.conn.delete(entryid, ENTRY_DELETE_FLAGS_MAP.get(flags, 0))\n\n    def refresh(self, entryid):\n        return self.conn.refresh(entryid)\n\n    def info(self):\n        return self.facts(facts_mode='info')\n\n    def facts(self, facts_mode='facts'):\n        results = dict()\n        for entry in self.list_pools():\n            results[entry] = dict()\n            if self.conn.find_entry(entry):\n                data = self.conn.get_info(entry)\n                # libvirt returns maxMem, memory, and cpuTime as long()'s, which\n                # xmlrpclib tries to convert to regular int's during serialization.\n                # This throws exceptions, so convert them to strings here and\n                # assume the other end of the xmlrpc connection can figure things\n                # out or doesn't care.\n                results[entry] = {\n                    \"status\": ENTRY_STATE_INFO_MAP.get(data[0], \"unknown\"),\n                    \"size_total\": str(data[1]),\n                    \"size_used\": str(data[2]),\n                    \"size_available\": str(data[3]),\n                }\n                results[entry][\"autostart\"] = self.conn.get_autostart(entry)\n                results[entry][\"persistent\"] = self.conn.get_persistent(entry)\n                results[entry][\"state\"] = self.conn.get_status(entry)\n                results[entry][\"path\"] = self.conn.get_path(entry)\n                results[entry][\"type\"] = self.conn.get_type(entry)\n                results[entry][\"uuid\"] = self.conn.get_uuid(entry)\n                if self.conn.find_entry(entry).isActive():\n                    results[entry][\"volume_count\"] = self.conn.get_volume_count(entry)\n                    results[entry][\"volumes\"] = list()\n                    for volume in self.conn.get_volume_names(entry):\n                        results[entry][\"volumes\"].append(volume)\n                else:\n                    results[entry][\"volume_count\"] = -1\n\n                try:\n                    results[entry][\"host\"] = self.conn.get_host(entry)\n                except ValueError:\n                    pass\n\n                try:\n                    results[entry][\"source_path\"] = self.conn.get_source_path(entry)\n                except ValueError:\n                    pass\n\n                try:\n                    results[entry][\"format\"] = self.conn.get_format(entry)\n                except ValueError:\n                    pass\n\n                try:\n                    devices = self.conn.get_devices(entry)\n                    results[entry][\"devices\"] = devices\n                except ValueError:\n                    pass\n\n            else:\n                results[entry][\"state\"] = self.conn.get_status(entry)\n\n        facts = dict()\n        if facts_mode == 'facts':\n            facts[\"ansible_facts\"] = dict()\n            facts[\"ansible_facts\"][\"ansible_libvirt_pools\"] = results\n        elif facts_mode == 'info':\n            facts['pools'] = results\n        return facts\n\n\ndef core(module):\n\n    state = module.params.get('state', None)\n    name = module.params.get('name', None)\n    command = module.params.get('command', None)\n    uri = module.params.get('uri', None)\n    xml = module.params.get('xml', None)\n    autostart = module.params.get('autostart', None)\n    mode = module.params.get('mode', None)\n\n    v = VirtStoragePool(uri, module)\n    res = {}\n\n    if state and command == 'list_pools':\n        res = v.list_pools(state=state)\n        if not isinstance(res, dict):\n            res = {command: res}\n        return VIRT_SUCCESS, res\n\n    if state:\n        if not name:\n            module.fail_json(msg=\"state change requires a specified name\")\n\n        res['changed'] = False\n        if state in ['active']:\n            if v.status(name) is not 'active':\n                res['changed'] = True\n                res['msg'] = v.start(name)\n        elif state in ['present']:\n            try:\n                v.get_pool(name)\n            except EntryNotFound:\n                if not xml:\n                    module.fail_json(msg=\"storage pool '\" + name + \"' not present, but xml not specified\")\n                v.define(name, xml)\n                res = {'changed': True, 'created': name}\n        elif state in ['inactive']:\n            entries = v.list_pools()\n            if name in entries:\n                if v.status(name) is not 'inactive':\n                    res['changed'] = True\n                    res['msg'] = v.destroy(name)\n        elif state in ['undefined', 'absent']:\n            entries = v.list_pools()\n            if name in entries:\n                if v.status(name) is not 'inactive':\n                    v.destroy(name)\n                res['changed'] = True\n                res['msg'] = v.undefine(name)\n        elif state in ['deleted']:\n            entries = v.list_pools()\n            if name in entries:\n                if v.status(name) is not 'inactive':\n                    v.destroy(name)\n                v.delete(name, mode)\n                res['changed'] = True\n                res['msg'] = v.undefine(name)\n        else:\n            module.fail_json(msg=\"unexpected state\")\n\n        return VIRT_SUCCESS, res\n\n    if command:\n        if command in ENTRY_COMMANDS:\n            if not name:\n                module.fail_json(msg=\"%s requires 1 argument: name\" % command)\n            if command == 'define':\n                if not xml:\n                    module.fail_json(msg=\"define requires xml argument\")\n                try:\n                    v.get_pool(name)\n                except EntryNotFound:\n                    v.define(name, xml)\n                    res = {'changed': True, 'created': name}\n                return VIRT_SUCCESS, res\n            elif command == 'build':\n                res = v.build(name, mode)\n                if not isinstance(res, dict):\n                    res = {'changed': True, command: res}\n                return VIRT_SUCCESS, res\n            elif command == 'delete':\n                res = v.delete(name, mode)\n                if not isinstance(res, dict):\n                    res = {'changed': True, command: res}\n                return VIRT_SUCCESS, res\n            res = getattr(v, command)(name)\n            if not isinstance(res, dict):\n                res = {command: res}\n            return VIRT_SUCCESS, res\n\n        elif hasattr(v, command):\n            res = getattr(v, command)()\n            if not isinstance(res, dict):\n                res = {command: res}\n            return VIRT_SUCCESS, res\n\n        else:\n            module.fail_json(msg=\"Command %s not recognized\" % command)\n\n    if autostart is not None:\n        if not name:\n            module.fail_json(msg=\"state change requires a specified name\")\n\n        res['changed'] = False\n        if autostart:\n            if not v.get_autostart(name):\n                res['changed'] = True\n                res['msg'] = v.set_autostart(name, True)\n        else:\n            if v.get_autostart(name):\n                res['changed'] = True\n                res['msg'] = v.set_autostart(name, False)\n\n        return VIRT_SUCCESS, res\n\n    module.fail_json(msg=\"expected state or command parameter to be specified\")\n\n\ndef main():\n\n    module = AnsibleModule(\n        argument_spec=dict(\n            name=dict(aliases=['pool']),\n            state=dict(choices=['active', 'inactive', 'present', 'absent', 'undefined', 'deleted']),\n            command=dict(choices=ALL_COMMANDS),\n            uri=dict(default='qemu:///system'),\n            xml=dict(),\n            autostart=dict(type='bool'),\n            mode=dict(choices=ALL_MODES),\n        ),\n        supports_check_mode=True\n    )\n\n    if not HAS_VIRT:\n        module.fail_json(\n            msg='The `libvirt` module is not importable. Check the requirements.'\n        )\n\n    if not HAS_XML:\n        module.fail_json(\n            msg='The `lxml` module is not importable. Check the requirements.'\n        )\n\n    rc = VIRT_SUCCESS\n    try:\n        rc, result = core(module)\n    except Exception as e:\n        module.fail_json(msg=str(e))\n\n    if rc != 0:  # something went wrong emit the msg\n        module.fail_json(rc=rc, msg=result)\n    else:\n        module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "virt_pool.py", "id": "2bc77d822aea1ad0674f2e33d270528a", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/cloud/misc/virt_pool.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}