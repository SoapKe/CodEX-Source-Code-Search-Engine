{"author": "nvbn", "code": "\n\nimport pytest\nfrom tests.utils import Rule, CorrectedCommand\nfrom thefuck import corrector, const\nfrom thefuck.system import Path\nfrom thefuck.types import Command\nfrom thefuck.corrector import get_corrected_commands, organize_commands\n\n\nclass TestGetRules(object):\n    @pytest.fixture\n    def glob(self, mocker):\n        results = {}\n        mocker.patch('thefuck.system.Path.glob',\n                     new_callable=lambda: lambda *_: results.pop('value', []))\n        return lambda value: results.update({'value': value})\n\n    @pytest.fixture(autouse=True)\n    def load_source(self, monkeypatch):\n        monkeypatch.setattr('thefuck.types.load_source',\n                            lambda x, _: Rule(x))\n\n    def _compare_names(self, rules, names):\n        assert {r.name for r in rules} == set(names)\n\n    @pytest.mark.parametrize('paths, conf_rules, exclude_rules, loaded_rules', [\n        (['git.py', 'bash.py'], const.DEFAULT_RULES, [], ['git', 'bash']),\n        (['git.py', 'bash.py'], ['git'], [], ['git']),\n        (['git.py', 'bash.py'], const.DEFAULT_RULES, ['git'], ['bash']),\n        (['git.py', 'bash.py'], ['git'], ['git'], [])])\n    def test_get_rules(self, glob, settings, paths, conf_rules, exclude_rules,\n                       loaded_rules):\n        glob([Path(path) for path in paths])\n        settings.update(rules=conf_rules,\n                        priority={},\n                        exclude_rules=exclude_rules)\n        rules = corrector.get_rules()\n        self._compare_names(rules, loaded_rules)\n\n\ndef test_get_corrected_commands(mocker):\n    command = Command('test', 'test')\n    rules = [Rule(match=lambda _: False),\n             Rule(match=lambda _: True,\n                  get_new_command=lambda x: x.script + '!', priority=100),\n             Rule(match=lambda _: True,\n                  get_new_command=lambda x: [x.script + '@', x.script + ';'],\n                  priority=60)]\n    mocker.patch('thefuck.corrector.get_rules', return_value=rules)\n    assert ([cmd.script for cmd in get_corrected_commands(command)]\n            == ['test!', 'test@', 'test;'])\n\n\ndef test_organize_commands():\n    \n    commands = [CorrectedCommand('ls'), CorrectedCommand('ls -la', priority=9000),\n                CorrectedCommand('ls -lh', priority=100),\n                CorrectedCommand(u'echo caf\u00e9', priority=200),\n                CorrectedCommand('ls -lh', priority=9999)]\n    assert list(organize_commands(iter(commands))) \\\n        == [CorrectedCommand('ls'), CorrectedCommand('ls -lh', priority=100),\n            CorrectedCommand(u'echo caf\u00e9', priority=200),\n            CorrectedCommand('ls -la', priority=9000)]\n", "comments": "Ensures that the function removes duplicates and sorts commands.\n.\n# -*- coding: utf-8 -*-\n", "content": "# -*- coding: utf-8 -*-\n\nimport pytest\nfrom tests.utils import Rule, CorrectedCommand\nfrom thefuck import corrector, const\nfrom thefuck.system import Path\nfrom thefuck.types import Command\nfrom thefuck.corrector import get_corrected_commands, organize_commands\n\n\nclass TestGetRules(object):\n    @pytest.fixture\n    def glob(self, mocker):\n        results = {}\n        mocker.patch('thefuck.system.Path.glob',\n                     new_callable=lambda: lambda *_: results.pop('value', []))\n        return lambda value: results.update({'value': value})\n\n    @pytest.fixture(autouse=True)\n    def load_source(self, monkeypatch):\n        monkeypatch.setattr('thefuck.types.load_source',\n                            lambda x, _: Rule(x))\n\n    def _compare_names(self, rules, names):\n        assert {r.name for r in rules} == set(names)\n\n    @pytest.mark.parametrize('paths, conf_rules, exclude_rules, loaded_rules', [\n        (['git.py', 'bash.py'], const.DEFAULT_RULES, [], ['git', 'bash']),\n        (['git.py', 'bash.py'], ['git'], [], ['git']),\n        (['git.py', 'bash.py'], const.DEFAULT_RULES, ['git'], ['bash']),\n        (['git.py', 'bash.py'], ['git'], ['git'], [])])\n    def test_get_rules(self, glob, settings, paths, conf_rules, exclude_rules,\n                       loaded_rules):\n        glob([Path(path) for path in paths])\n        settings.update(rules=conf_rules,\n                        priority={},\n                        exclude_rules=exclude_rules)\n        rules = corrector.get_rules()\n        self._compare_names(rules, loaded_rules)\n\n\ndef test_get_corrected_commands(mocker):\n    command = Command('test', 'test')\n    rules = [Rule(match=lambda _: False),\n             Rule(match=lambda _: True,\n                  get_new_command=lambda x: x.script + '!', priority=100),\n             Rule(match=lambda _: True,\n                  get_new_command=lambda x: [x.script + '@', x.script + ';'],\n                  priority=60)]\n    mocker.patch('thefuck.corrector.get_rules', return_value=rules)\n    assert ([cmd.script for cmd in get_corrected_commands(command)]\n            == ['test!', 'test@', 'test;'])\n\n\ndef test_organize_commands():\n    \"\"\"Ensures that the function removes duplicates and sorts commands.\"\"\"\n    commands = [CorrectedCommand('ls'), CorrectedCommand('ls -la', priority=9000),\n                CorrectedCommand('ls -lh', priority=100),\n                CorrectedCommand(u'echo caf\u00e9', priority=200),\n                CorrectedCommand('ls -lh', priority=9999)]\n    assert list(organize_commands(iter(commands))) \\\n        == [CorrectedCommand('ls'), CorrectedCommand('ls -lh', priority=100),\n            CorrectedCommand(u'echo caf\u00e9', priority=200),\n            CorrectedCommand('ls -la', priority=9000)]\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "test_corrector.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/tests/test_corrector.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}