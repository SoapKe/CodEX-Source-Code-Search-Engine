{"author": "yunjey", "code": "import torch\nimport torch.nn as nn\nimport torchvision.datasets as dsets\nimport torchvision.transforms as transforms\nfrom torch.autograd import Variable\n\n\n\ninput_size = 784\nhidden_size = 500\nnum_classes = 10\nnum_epochs = 5\nbatch_size = 100\nlearning_rate = 0.001\n\n\ntrain_dataset = dsets.MNIST(root='./data', \n                            train=True, \n                            transform=transforms.ToTensor(),  \n                            download=True)\n\ntest_dataset = dsets.MNIST(root='./data', \n                           train=False, \n                           transform=transforms.ToTensor())\n\n# Data Loader (Input Pipeline)\ntrain_loader = torch.utils.data.DataLoader(dataset=train_dataset, \n                                           batch_size=batch_size, \n                                           shuffle=True)\n\ntest_loader = torch.utils.data.DataLoader(dataset=test_dataset, \n                                          batch_size=batch_size, \n                                          shuffle=False)\n\n# Neural Network Model (1 hidden layer)\nclass Net(nn.Module):\n    def __init__(self, input_size, hidden_size, num_classes):\n        super(Net, self).__init__()\n        self.fc1 = nn.Linear(input_size, hidden_size) \n        self.relu = nn.ReLU()\n        self.fc2 = nn.Linear(hidden_size, num_classes)  \n    \n    def forward(self, x):\n        out = self.fc1(x)\n        out = self.relu(out)\n        out = self.fc2(out)\n        return out\n    \nnet = Net(input_size, hidden_size, num_classes)\nnet.cuda()   \n    \n\ncriterion = nn.CrossEntropyLoss()  \noptimizer = torch.optim.Adam(net.parameters(), lr=learning_rate)  \n\n\nfor epoch in range(num_epochs):\n    for i, (images, labels) in enumerate(train_loader):  \n        \n        images = Variable(images.view(-1, 28*28).cuda())\n        labels = Variable(labels.cuda())\n        \n        # Forward + Backward + Optimize\n        optimizer.zero_grad()  \n        outputs = net(images)\n        loss = criterion(outputs, labels)\n        loss.backward()\n        optimizer.step()\n        \n        if (i+1) % 100 == 0:\n            print ('Epoch [%d/%d], Step [%d/%d], Loss: %.4f' \n                   %(epoch+1, num_epochs, i+1, len(train_dataset)//batch_size, loss.data[0]))\n\n\ncorrect = 0\ntotal = 0\nfor images, labels in test_loader:\n    images = Variable(images.view(-1, 28*28)).cuda()\n    outputs = net(images)\n    _, predicted = torch.max(outputs.data, 1)\n    total += labels.size(0)\n    correct += (predicted.cpu() == labels).sum()\n\nprint('Accuracy of the network on the 10000 test images: %d %%' % (100 * correct / total))\n\n\ntorch.save(net.state_dict(), 'model.pkl')\n", "comments": "  hyper parameters     mnist dataset     data loader (input pipeline)    neural network model (1 hidden layer)    loss optimizer    train model    convert torch tensor variable    forward   backward   optimize    zero gradient buffer    test model    save model ", "content": "import torch\nimport torch.nn as nn\nimport torchvision.datasets as dsets\nimport torchvision.transforms as transforms\nfrom torch.autograd import Variable\n\n\n# Hyper Parameters \ninput_size = 784\nhidden_size = 500\nnum_classes = 10\nnum_epochs = 5\nbatch_size = 100\nlearning_rate = 0.001\n\n# MNIST Dataset \ntrain_dataset = dsets.MNIST(root='./data', \n                            train=True, \n                            transform=transforms.ToTensor(),  \n                            download=True)\n\ntest_dataset = dsets.MNIST(root='./data', \n                           train=False, \n                           transform=transforms.ToTensor())\n\n# Data Loader (Input Pipeline)\ntrain_loader = torch.utils.data.DataLoader(dataset=train_dataset, \n                                           batch_size=batch_size, \n                                           shuffle=True)\n\ntest_loader = torch.utils.data.DataLoader(dataset=test_dataset, \n                                          batch_size=batch_size, \n                                          shuffle=False)\n\n# Neural Network Model (1 hidden layer)\nclass Net(nn.Module):\n    def __init__(self, input_size, hidden_size, num_classes):\n        super(Net, self).__init__()\n        self.fc1 = nn.Linear(input_size, hidden_size) \n        self.relu = nn.ReLU()\n        self.fc2 = nn.Linear(hidden_size, num_classes)  \n    \n    def forward(self, x):\n        out = self.fc1(x)\n        out = self.relu(out)\n        out = self.fc2(out)\n        return out\n    \nnet = Net(input_size, hidden_size, num_classes)\nnet.cuda()   \n    \n# Loss and Optimizer\ncriterion = nn.CrossEntropyLoss()  \noptimizer = torch.optim.Adam(net.parameters(), lr=learning_rate)  \n\n# Train the Model\nfor epoch in range(num_epochs):\n    for i, (images, labels) in enumerate(train_loader):  \n        # Convert torch tensor to Variable\n        images = Variable(images.view(-1, 28*28).cuda())\n        labels = Variable(labels.cuda())\n        \n        # Forward + Backward + Optimize\n        optimizer.zero_grad()  # zero the gradient buffer\n        outputs = net(images)\n        loss = criterion(outputs, labels)\n        loss.backward()\n        optimizer.step()\n        \n        if (i+1) % 100 == 0:\n            print ('Epoch [%d/%d], Step [%d/%d], Loss: %.4f' \n                   %(epoch+1, num_epochs, i+1, len(train_dataset)//batch_size, loss.data[0]))\n\n# Test the Model\ncorrect = 0\ntotal = 0\nfor images, labels in test_loader:\n    images = Variable(images.view(-1, 28*28)).cuda()\n    outputs = net(images)\n    _, predicted = torch.max(outputs.data, 1)\n    total += labels.size(0)\n    correct += (predicted.cpu() == labels).sum()\n\nprint('Accuracy of the network on the 10000 test images: %d %%' % (100 * correct / total))\n\n# Save the Model\ntorch.save(net.state_dict(), 'model.pkl')\n", "description": "PyTorch Tutorial for Deep Learning Researchers", "file_name": "main-gpu.py", "id": "a907968d29347c47c25456e7d832d1ad", "language": "Python", "project_name": "pytorch-tutorial", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/yunjey-pytorch-tutorial/yunjey-pytorch-tutorial-6c785eb/tutorials/01-basics/feedforward_neural_network/main-gpu.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:24:45Z", "url": "https://github.com/yunjey/pytorch-tutorial", "wiki": true}