{"author": "keon", "code": "# def lengthLongestPath(input):\n    \n    \n    # for line in input.splitlines():\n        # print(\"---------------\")\n        # print(\"line:\", line)\n        # name = line.strip('\\t')\n        # print(\"name:\", name)\n        # depth = len(line) - len(name)\n        # print(\"depth:\", depth)\n        \n            # maxlen = max(maxlen, pathlen[depth] + len(name))\n        \n            # pathlen[depth + 1] = pathlen[depth] + len(name) + 1\n        # print(\"maxlen:\", maxlen)\n    \n\n# def lengthLongestPath(input):\n    # paths = input.split(\"\\n\")\n    # level = [0] * 10\n    \n    \n        # print(\"-------------\")\n        # levelIdx = path.rfind(\"\\t\")\n        # print(\"Path: \", path)\n        # print(\"path.rfind(\\\\t)\", path.rfind(\"\\t\"))\n        # print(\"levelIdx: \", levelIdx)\n        # print(\"level: \", level)\n        # level[levelIdx + 1] = level[levelIdx] + len(path) - levelIdx + 1\n        # print(\"level: \", level)\n        \n            # maxLength = max(maxLength, level[levelIdx+1] - 1)\n            # print(\"maxlen: \", maxLength)\n    \n\ndef length_longest_path(input):\n    \n    currlen, maxlen = 0, 0    \n    stack = []    \n    for s in input.split('\\n'):\n        print(\"---------\")\n        print(\"<path>:\", s)\n        depth = s.count('\\t')    \n        print(\"depth: \", depth)\n        print(\"stack: \", stack)\n        print(\"curlen: \", currlen)\n        while len(stack) > depth:    \n            currlen -= stack.pop()\n        stack.append(len(s.strip('\\t'))+1)   \n        currlen += stack[-1]    \n        print(\"stack: \", stack)\n        print(\"curlen: \", currlen)\n        if '.' in s:    \n            maxlen = max(maxlen, currlen-1)    \n    return maxlen\n\nst= \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdirectory1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"\nst2 = \"a\\n\\tb1\\n\\t\\tf1.txt\\n\\taaaaa\\n\\t\\tf2.txt\"\nprint(\"path:\", st2)\n\nprint(\"answer:\", lengthLongestPath(st2))\n\n", "comments": "         type input  str      rtype  int            def lengthlongestpath(input)     maxlen   0    pathlen    0  0     line input splitlines()     print(                 )    print( line    line)    name   line strip(  )    print( name    name)    depth   len(line)   len(name)    print( depth    depth)        name     maxlen   max(maxlen  pathlen depth    len(name))    else     pathlen depth   1    pathlen depth    len(name)   1    print( maxlen    maxlen)    return maxlen    def lengthlongestpath(input)     paths   input split(  n )    level    0    10    maxlength   0    path paths     print(               )    levelidx   path rfind(  )    print( path     path)    print( path rfind(  t)   path rfind(  ))    print( levelidx     levelidx)    print( level     level)    level levelidx   1    level levelidx    len(path)   levelidx   1    print( level     level)        path     maxlength   max(maxlength  level levelidx 1    1)    print( maxlen     maxlength)    return maxlength    running length max length    keep track name length    depth current dir file    go back correct depth    1 length        increase current length    update maxlen file     1 minus one     ", "content": "# def lengthLongestPath(input):\n    # maxlen = 0\n    # pathlen = {0: 0}\n    # for line in input.splitlines():\n        # print(\"---------------\")\n        # print(\"line:\", line)\n        # name = line.strip('\\t')\n        # print(\"name:\", name)\n        # depth = len(line) - len(name)\n        # print(\"depth:\", depth)\n        # if '.' in name:\n            # maxlen = max(maxlen, pathlen[depth] + len(name))\n        # else:\n            # pathlen[depth + 1] = pathlen[depth] + len(name) + 1\n        # print(\"maxlen:\", maxlen)\n    # return maxlen\n\n# def lengthLongestPath(input):\n    # paths = input.split(\"\\n\")\n    # level = [0] * 10\n    # maxLength = 0\n    # for path in paths:\n        # print(\"-------------\")\n        # levelIdx = path.rfind(\"\\t\")\n        # print(\"Path: \", path)\n        # print(\"path.rfind(\\\\t)\", path.rfind(\"\\t\"))\n        # print(\"levelIdx: \", levelIdx)\n        # print(\"level: \", level)\n        # level[levelIdx + 1] = level[levelIdx] + len(path) - levelIdx + 1\n        # print(\"level: \", level)\n        # if \".\" in path:\n            # maxLength = max(maxLength, level[levelIdx+1] - 1)\n            # print(\"maxlen: \", maxLength)\n    # return maxLength\n\ndef length_longest_path(input):\n    \"\"\"\n    :type input: str\n    :rtype: int\n    \"\"\"\n    currlen, maxlen = 0, 0    # running length and max length\n    stack = []    # keep track of the name length\n    for s in input.split('\\n'):\n        print(\"---------\")\n        print(\"<path>:\", s)\n        depth = s.count('\\t')    # the depth of current dir or file\n        print(\"depth: \", depth)\n        print(\"stack: \", stack)\n        print(\"curlen: \", currlen)\n        while len(stack) > depth:    # go back to the correct depth\n            currlen -= stack.pop()\n        stack.append(len(s.strip('\\t'))+1)   # 1 is the length of '/'\n        currlen += stack[-1]    # increase current length\n        print(\"stack: \", stack)\n        print(\"curlen: \", currlen)\n        if '.' in s:    # update maxlen only when it is a file\n            maxlen = max(maxlen, currlen-1)    # -1 is to minus one '/'\n    return maxlen\n\nst= \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdirectory1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"\nst2 = \"a\\n\\tb1\\n\\t\\tf1.txt\\n\\taaaaa\\n\\t\\tf2.txt\"\nprint(\"path:\", st2)\n\nprint(\"answer:\", lengthLongestPath(st2))\n\n", "description": "Minimal examples of data structures and algorithms in Python", "file_name": "longest_abs_path.py", "id": "5bdb9a63568abc791e2e0f507d46d574", "language": "Python", "project_name": "algorithms", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/keon-algorithms/keon-algorithms-abe4cb1/stack/longest_abs_path.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:56:36Z", "url": "https://github.com/keon/algorithms", "wiki": true}