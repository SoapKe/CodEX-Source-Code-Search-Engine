{"author": "ansible", "code": "\n -*- coding: utf-8 -*-\n\n Ansible module to manage PaloAltoNetworks Firewall\n (c) 2016, techbizdev <techbizdev@paloaltonetworks.com>\n\n This file is part of Ansible\n\n Ansible is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Ansible is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nDOCUMENTATION = '''\n---\nmodule: panos_cert_gen_ssh\nshort_description: generates a self-signed certificate using SSH protocol with SSH key\ndescription:\n    - This module generates a self-signed certificate that can be used by GlobalProtect client, SSL connector, or\n    - otherwise. Root certificate must be preset on the system first. This module depends on paramiko for ssh.\nauthor: \"Luigi Mori (@jtschichold), Ivan Bojer (@ivanbojer)\"\nversion_added: \"2.3\"\nrequirements:\n    - paramiko\nnotes:\n    - Checkmode is not supported.\noptions:\n    ip_address:\n        description:\n            - IP address (or hostname) of PAN-OS device being configured.\n        required: true\n    key_filename:\n        description:\n            - Location of the filename that is used for the auth. Either I(key_filename) or I(password) is required.\n        required: true\n    password:\n        description:\n            - Password credentials to use for auth. Either I(key_filename) or I(password) is required.\n        required: true\n    cert_friendly_name:\n        description:\n            - Human friendly certificate name (not CN but just a friendly name).\n        required: true\n    cert_cn:\n        description:\n            - Certificate CN (common name) embedded in the certificate signature.\n        required: true\n    signed_by:\n        description:\n            - Undersigning authority (CA) that MUST already be presents on the device.\n        required: true\n    rsa_nbits:\n        description:\n            - Number of bits used by the RSA algorithm for the certificate generation.\n        default: \"2048\"\n'''\n\nEXAMPLES = '''\n Generates a new self-signed certificate using ssh\n- name: generate self signed certificate\n  panos_cert_gen_ssh:\n    ip_address: \"192.168.1.1\"\n    password: \"paloalto\"\n    cert_cn: \"1.1.1.1\"\n    cert_friendly_name: \"test123\"\n    signed_by: \"root-ca\"\n'''\n\nRETURN = '''\n Default return values\n'''\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils._text import to_native\nimport time\n\ntry:\n    import paramiko\n    HAS_LIB = True\nexcept ImportError:\n    HAS_LIB = False\n\n_PROMPTBUFF = 4096\n\n\ndef wait_with_timeout(module, shell, prompt, timeout=60):\n    now = time.time()\n    result = \"\"\n    while True:\n        if shell.recv_ready():\n            result += shell.recv(_PROMPTBUFF)\n            endresult = result.strip()\n            if len(endresult) != 0 and endresult[-1] == prompt:\n                break\n\n        if time.time() - now > timeout:\n            module.fail_json(msg=\"Timeout waiting for prompt\")\n\n    return result\n\n\ndef generate_cert(module, ip_address, key_filename, password,\n                  cert_cn, cert_friendly_name, signed_by, rsa_nbits):\n    stdout = \"\"\n\n    client = paramiko.SSHClient()\n\n     add policy to accept all host keys, I haven't found\n     a way to retrieve the instance SSH key fingerprint from AWS\n    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n    if not key_filename:\n        client.connect(ip_address, username=\"admin\", password=password)\n    else:\n        client.connect(ip_address, username=\"admin\", key_filename=key_filename)\n\n    shell = client.invoke_shell()\n     wait for the shell to start\n    buff = wait_with_timeout(module, shell, \">\")\n    stdout += buff\n\n     generate self-signed certificate\n    if isinstance(cert_cn, list):\n        cert_cn = cert_cn[0]\n    cmd = 'request certificate generate signed-by {0} certificate-name {1} name {2} algorithm RSA rsa-nbits {3}\\n'.format(\n        signed_by, cert_friendly_name, cert_cn, rsa_nbits)\n    shell.send(cmd)\n\n     wait for the shell to complete\n    buff = wait_with_timeout(module, shell, \">\")\n    stdout += buff\n\n     exit\n    shell.send('exit\\n')\n\n    if 'Success' not in buff:\n        module.fail_json(msg=\"Error generating self signed certificate: \" + stdout)\n\n    client.close()\n    return stdout\n\n\ndef main():\n    argument_spec = dict(\n        ip_address=dict(required=True),\n        key_filename=dict(),\n        password=dict(no_log=True),\n        cert_cn=dict(required=True),\n        cert_friendly_name=dict(required=True),\n        rsa_nbits=dict(default='2048'),\n        signed_by=dict(required=True)\n\n    )\n    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=False,\n                           required_one_of=[['key_filename', 'password']])\n    if not HAS_LIB:\n        module.fail_json(msg='paramiko is required for this module')\n\n    ip_address = module.params[\"ip_address\"]\n    key_filename = module.params[\"key_filename\"]\n    password = module.params[\"password\"]\n    cert_cn = module.params[\"cert_cn\"]\n    cert_friendly_name = module.params[\"cert_friendly_name\"]\n    signed_by = module.params[\"signed_by\"]\n    rsa_nbits = module.params[\"rsa_nbits\"]\n\n    try:\n        stdout = generate_cert(module,\n                               ip_address,\n                               key_filename,\n                               password,\n                               cert_cn,\n                               cert_friendly_name,\n                               signed_by,\n                               rsa_nbits)\n    except Exception as exc:\n        module.fail_json(msg=to_native(exc))\n\n    module.exit_json(changed=True, msg=\"okey dokey\")\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  panos cert gen ssh short description  generates self signed certificate using ssh protocol ssh key description        this module generates self signed certificate used globalprotect client  ssl connector        otherwise  root certificate must preset system first  this module depends paramiko ssh  author   luigi mori ( jtschichold)  ivan bojer ( ivanbojer)  version added   2 3  requirements        paramiko notes        checkmode supported  options      ip address          description                ip address (or hostname) pan os device configured          required  true     key filename          description                location filename used auth  either i(key filename) i(password) required          required  true     password          description                password credentials use auth  either i(key filename) i(password) required          required  true     cert friendly name          description                human friendly certificate name (not cn friendly name)          required  true     cert cn          description                certificate cn (common name) embedded certificate signature          required  true     signed          description                undersigning authority (ca) must already presents device          required  true     rsa nbits          description                number bits used rsa algorithm certificate generation          default   2048       examples         generates new self signed certificate using ssh   name  generate self signed certificate   panos cert gen ssh      ip address   192 168 1 1      password   paloalto      cert cn   1 1 1 1      cert friendly name   test123      signed   root ca       return         default return values         usr bin python        coding  utf 8           ansible module manage paloaltonetworks firewall    (c) 2016  techbizdev  techbizdev paloaltonetworks com        this file part ansible       ansible free software  redistribute modify    terms gnu general public license published    free software foundation  either version 3 license     (at option) later version        ansible distributed hope useful     without any warranty  without even implied warranty    merchantability fitness for a particular purpose   see    gnu general public license details        you received copy gnu general public license    along ansible   if  see  http   www gnu org licenses       generates new self signed certificate using ssh    default return values    add policy accept host keys  i found    way retrieve instance ssh key fingerprint aws    wait shell start    generate self signed certificate    wait shell complete    exit ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n#\n# Ansible module to manage PaloAltoNetworks Firewall\n# (c) 2016, techbizdev <techbizdev@paloaltonetworks.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nDOCUMENTATION = '''\n---\nmodule: panos_cert_gen_ssh\nshort_description: generates a self-signed certificate using SSH protocol with SSH key\ndescription:\n    - This module generates a self-signed certificate that can be used by GlobalProtect client, SSL connector, or\n    - otherwise. Root certificate must be preset on the system first. This module depends on paramiko for ssh.\nauthor: \"Luigi Mori (@jtschichold), Ivan Bojer (@ivanbojer)\"\nversion_added: \"2.3\"\nrequirements:\n    - paramiko\nnotes:\n    - Checkmode is not supported.\noptions:\n    ip_address:\n        description:\n            - IP address (or hostname) of PAN-OS device being configured.\n        required: true\n    key_filename:\n        description:\n            - Location of the filename that is used for the auth. Either I(key_filename) or I(password) is required.\n        required: true\n    password:\n        description:\n            - Password credentials to use for auth. Either I(key_filename) or I(password) is required.\n        required: true\n    cert_friendly_name:\n        description:\n            - Human friendly certificate name (not CN but just a friendly name).\n        required: true\n    cert_cn:\n        description:\n            - Certificate CN (common name) embedded in the certificate signature.\n        required: true\n    signed_by:\n        description:\n            - Undersigning authority (CA) that MUST already be presents on the device.\n        required: true\n    rsa_nbits:\n        description:\n            - Number of bits used by the RSA algorithm for the certificate generation.\n        default: \"2048\"\n'''\n\nEXAMPLES = '''\n# Generates a new self-signed certificate using ssh\n- name: generate self signed certificate\n  panos_cert_gen_ssh:\n    ip_address: \"192.168.1.1\"\n    password: \"paloalto\"\n    cert_cn: \"1.1.1.1\"\n    cert_friendly_name: \"test123\"\n    signed_by: \"root-ca\"\n'''\n\nRETURN = '''\n# Default return values\n'''\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils._text import to_native\nimport time\n\ntry:\n    import paramiko\n    HAS_LIB = True\nexcept ImportError:\n    HAS_LIB = False\n\n_PROMPTBUFF = 4096\n\n\ndef wait_with_timeout(module, shell, prompt, timeout=60):\n    now = time.time()\n    result = \"\"\n    while True:\n        if shell.recv_ready():\n            result += shell.recv(_PROMPTBUFF)\n            endresult = result.strip()\n            if len(endresult) != 0 and endresult[-1] == prompt:\n                break\n\n        if time.time() - now > timeout:\n            module.fail_json(msg=\"Timeout waiting for prompt\")\n\n    return result\n\n\ndef generate_cert(module, ip_address, key_filename, password,\n                  cert_cn, cert_friendly_name, signed_by, rsa_nbits):\n    stdout = \"\"\n\n    client = paramiko.SSHClient()\n\n    # add policy to accept all host keys, I haven't found\n    # a way to retrieve the instance SSH key fingerprint from AWS\n    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n    if not key_filename:\n        client.connect(ip_address, username=\"admin\", password=password)\n    else:\n        client.connect(ip_address, username=\"admin\", key_filename=key_filename)\n\n    shell = client.invoke_shell()\n    # wait for the shell to start\n    buff = wait_with_timeout(module, shell, \">\")\n    stdout += buff\n\n    # generate self-signed certificate\n    if isinstance(cert_cn, list):\n        cert_cn = cert_cn[0]\n    cmd = 'request certificate generate signed-by {0} certificate-name {1} name {2} algorithm RSA rsa-nbits {3}\\n'.format(\n        signed_by, cert_friendly_name, cert_cn, rsa_nbits)\n    shell.send(cmd)\n\n    # wait for the shell to complete\n    buff = wait_with_timeout(module, shell, \">\")\n    stdout += buff\n\n    # exit\n    shell.send('exit\\n')\n\n    if 'Success' not in buff:\n        module.fail_json(msg=\"Error generating self signed certificate: \" + stdout)\n\n    client.close()\n    return stdout\n\n\ndef main():\n    argument_spec = dict(\n        ip_address=dict(required=True),\n        key_filename=dict(),\n        password=dict(no_log=True),\n        cert_cn=dict(required=True),\n        cert_friendly_name=dict(required=True),\n        rsa_nbits=dict(default='2048'),\n        signed_by=dict(required=True)\n\n    )\n    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=False,\n                           required_one_of=[['key_filename', 'password']])\n    if not HAS_LIB:\n        module.fail_json(msg='paramiko is required for this module')\n\n    ip_address = module.params[\"ip_address\"]\n    key_filename = module.params[\"key_filename\"]\n    password = module.params[\"password\"]\n    cert_cn = module.params[\"cert_cn\"]\n    cert_friendly_name = module.params[\"cert_friendly_name\"]\n    signed_by = module.params[\"signed_by\"]\n    rsa_nbits = module.params[\"rsa_nbits\"]\n\n    try:\n        stdout = generate_cert(module,\n                               ip_address,\n                               key_filename,\n                               password,\n                               cert_cn,\n                               cert_friendly_name,\n                               signed_by,\n                               rsa_nbits)\n    except Exception as exc:\n        module.fail_json(msg=to_native(exc))\n\n    module.exit_json(changed=True, msg=\"okey dokey\")\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "panos_cert_gen_ssh.py", "id": "a51d1acbc6d58c0e1c2b3d4b6aa84c06", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/network/panos/panos_cert_gen_ssh.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}