{"author": "HelloZeroNet", "code": "import time\n\nfrom Plugin import PluginManager\nfrom BootstrapperDb import BootstrapperDb\nfrom Crypt import CryptRsa\n\nif \"db\" not in locals().keys():  \n    db = BootstrapperDb()\n\n\n@PluginManager.registerTo(\"FileRequest\")\nclass FileRequestPlugin(object):\n    def actionAnnounce(self, params):\n        time_started = time.time()\n        s = time.time()\n        hashes = params[\"hashes\"]\n\n        if \"onion_signs\" in params and len(params[\"onion_signs\"]) == len(set(params[\"onions\"])):\n            \n            if time.time() - float(params[\"onion_sign_this\"]) < 3*60:  \n                onions_signed = []\n                \n                for onion_publickey, onion_sign in params[\"onion_signs\"].items():\n                    if CryptRsa.verify(params[\"onion_sign_this\"], onion_publickey, onion_sign):\n                        onions_signed.append(CryptRsa.publickeyToOnion(onion_publickey))\n                    else:\n                        break\n                \n                if sorted(onions_signed) == sorted(set(params[\"onions\"])):\n                    all_onions_signed = True\n                else:\n                    all_onions_signed = False\n            else:\n                \n                all_onions_signed = False\n        else:\n            \n            all_onions_signed = False\n\n        time_onion_check = time.time() - s\n\n        if \"ip4\" in params[\"add\"] and self.connection.ip != \"127.0.0.1\" and not self.connection.ip.endswith(\".onion\"):\n            ip4 = self.connection.ip\n        else:\n            ip4 = None\n\n        s = time.time()\n        \n        i = 0\n        onion_to_hash = {}\n        for onion in params.get(\"onions\", []):\n            if onion not in onion_to_hash:\n                onion_to_hash[onion] = []\n            onion_to_hash[onion].append(hashes[i])\n            i += 1\n\n        hashes_changed = 0\n        db.execute(\"BEGIN\")\n        for onion, onion_hashes in onion_to_hash.iteritems():\n            hashes_changed += db.peerAnnounce(\n                onion=onion,\n                port=params[\"port\"],\n                hashes=onion_hashes,\n                onion_signed=all_onions_signed\n            )\n        db.execute(\"END\")\n        time_db_onion = time.time() - s\n\n        s = time.time()\n        \n        if ip4:\n            hashes_changed += db.peerAnnounce(\n                ip4=ip4,\n                port=params[\"port\"],\n                hashes=hashes,\n                delete_missing_hashes=params.get(\"delete\")\n            )\n        time_db_ip4 = time.time() - s\n\n        s = time.time()\n        \n        back = {}\n        peers = []\n        if params.get(\"onions\") and not all_onions_signed and hashes_changed:\n            back[\"onion_sign_this\"] = \"%.0f\" % time.time()  \n\n        if len(hashes) > 500:\n            limit = 5\n            order = False\n        else:\n            limit = 30\n            order = True\n        for hash in hashes:\n            if time.time() - time_started > 1:  \n                self.connection.log(\"Announce time limit exceeded after %s/%s sites\" % (len(peers), len(hashes)))\n                break\n\n            hash_peers = db.peerList(\n                hash,\n                ip4=self.connection.ip, onions=onion_to_hash.keys(), port=params[\"port\"],\n                limit=min(limit, params[\"need_num\"]), need_types=params[\"need_types\"], order=order\n            )\n            peers.append(hash_peers)\n        time_peerlist = time.time() - s\n\n\n        back[\"peers\"] = peers\n        self.connection.log(\n            \"Announce %s sites (onions: %s, onion_check: %.3fs, db_onion: %.3fs, db_ip4: %.3fs, peerlist: %.3fs)\" %\n            (len(hashes), len(onion_to_hash), time_onion_check, time_db_onion, time_db_ip4, time_peerlist)\n        )\n        self.response(back)\n\n\n@PluginManager.registerTo(\"UiRequest\")\nclass UiRequestPlugin(object):\n    def actionStatsBootstrapper(self):\n        self.sendHeader()\n\n        \n        yield \"\"\"\n        <style>\n         * { font-family: monospace; white-space: pre }\n         table td, table th { text-align: right; padding: 0px 10px }\n        </style>\n        \"\"\"\n\n        hash_rows = db.execute(\"SELECT * FROM hash\").fetchall()\n        for hash_row in hash_rows:\n            peer_rows = db.execute(\n                \"SELECT * FROM peer LEFT JOIN peer_to_hash USING (peer_id) WHERE hash_id = :hash_id\",\n                {\"hash_id\": hash_row[\"hash_id\"]}\n            ).fetchall()\n\n            yield \"<br>%s (added: %s, peers: %s)<br>\" % (\n                str(hash_row[\"hash\"]).encode(\"hex\"), hash_row[\"date_added\"], len(peer_rows)\n            )\n            for peer_row in peer_rows:\n                yield \" - {ip4: <30} {onion: <30} added: {date_added}, announced: {date_announced}<br>\".format(**dict(peer_row))\n", "comments": "             style               font family  monospace  white space  pre            table td  table th   text align  right  padding  0px 10px             style                 share durin reloads    check sign correct    peer 3 minute sign message    check onion signs    check onion addresses signed announced onces    onion sign 3 minute    incorrect signs number    separatley add onions sites onions present    announce sites ip4 defined    query sites    send back nonce signing    1 sec limit request    style ", "content": "import time\n\nfrom Plugin import PluginManager\nfrom BootstrapperDb import BootstrapperDb\nfrom Crypt import CryptRsa\n\nif \"db\" not in locals().keys():  # Share durin reloads\n    db = BootstrapperDb()\n\n\n@PluginManager.registerTo(\"FileRequest\")\nclass FileRequestPlugin(object):\n    def actionAnnounce(self, params):\n        time_started = time.time()\n        s = time.time()\n        hashes = params[\"hashes\"]\n\n        if \"onion_signs\" in params and len(params[\"onion_signs\"]) == len(set(params[\"onions\"])):\n            # Check if all sign is correct\n            if time.time() - float(params[\"onion_sign_this\"]) < 3*60:  # Peer has 3 minute to sign the message\n                onions_signed = []\n                # Check onion signs\n                for onion_publickey, onion_sign in params[\"onion_signs\"].items():\n                    if CryptRsa.verify(params[\"onion_sign_this\"], onion_publickey, onion_sign):\n                        onions_signed.append(CryptRsa.publickeyToOnion(onion_publickey))\n                    else:\n                        break\n                # Check if the same onion addresses signed as the announced onces\n                if sorted(onions_signed) == sorted(set(params[\"onions\"])):\n                    all_onions_signed = True\n                else:\n                    all_onions_signed = False\n            else:\n                # Onion sign this out of 3 minute\n                all_onions_signed = False\n        else:\n            # Incorrect signs number\n            all_onions_signed = False\n\n        time_onion_check = time.time() - s\n\n        if \"ip4\" in params[\"add\"] and self.connection.ip != \"127.0.0.1\" and not self.connection.ip.endswith(\".onion\"):\n            ip4 = self.connection.ip\n        else:\n            ip4 = None\n\n        s = time.time()\n        # Separatley add onions to sites or at once if no onions present\n        i = 0\n        onion_to_hash = {}\n        for onion in params.get(\"onions\", []):\n            if onion not in onion_to_hash:\n                onion_to_hash[onion] = []\n            onion_to_hash[onion].append(hashes[i])\n            i += 1\n\n        hashes_changed = 0\n        db.execute(\"BEGIN\")\n        for onion, onion_hashes in onion_to_hash.iteritems():\n            hashes_changed += db.peerAnnounce(\n                onion=onion,\n                port=params[\"port\"],\n                hashes=onion_hashes,\n                onion_signed=all_onions_signed\n            )\n        db.execute(\"END\")\n        time_db_onion = time.time() - s\n\n        s = time.time()\n        # Announce all sites if ip4 defined\n        if ip4:\n            hashes_changed += db.peerAnnounce(\n                ip4=ip4,\n                port=params[\"port\"],\n                hashes=hashes,\n                delete_missing_hashes=params.get(\"delete\")\n            )\n        time_db_ip4 = time.time() - s\n\n        s = time.time()\n        # Query sites\n        back = {}\n        peers = []\n        if params.get(\"onions\") and not all_onions_signed and hashes_changed:\n            back[\"onion_sign_this\"] = \"%.0f\" % time.time()  # Send back nonce for signing\n\n        if len(hashes) > 500:\n            limit = 5\n            order = False\n        else:\n            limit = 30\n            order = True\n        for hash in hashes:\n            if time.time() - time_started > 1:  # 1 sec limit on request\n                self.connection.log(\"Announce time limit exceeded after %s/%s sites\" % (len(peers), len(hashes)))\n                break\n\n            hash_peers = db.peerList(\n                hash,\n                ip4=self.connection.ip, onions=onion_to_hash.keys(), port=params[\"port\"],\n                limit=min(limit, params[\"need_num\"]), need_types=params[\"need_types\"], order=order\n            )\n            peers.append(hash_peers)\n        time_peerlist = time.time() - s\n\n\n        back[\"peers\"] = peers\n        self.connection.log(\n            \"Announce %s sites (onions: %s, onion_check: %.3fs, db_onion: %.3fs, db_ip4: %.3fs, peerlist: %.3fs)\" %\n            (len(hashes), len(onion_to_hash), time_onion_check, time_db_onion, time_db_ip4, time_peerlist)\n        )\n        self.response(back)\n\n\n@PluginManager.registerTo(\"UiRequest\")\nclass UiRequestPlugin(object):\n    def actionStatsBootstrapper(self):\n        self.sendHeader()\n\n        # Style\n        yield \"\"\"\n        <style>\n         * { font-family: monospace; white-space: pre }\n         table td, table th { text-align: right; padding: 0px 10px }\n        </style>\n        \"\"\"\n\n        hash_rows = db.execute(\"SELECT * FROM hash\").fetchall()\n        for hash_row in hash_rows:\n            peer_rows = db.execute(\n                \"SELECT * FROM peer LEFT JOIN peer_to_hash USING (peer_id) WHERE hash_id = :hash_id\",\n                {\"hash_id\": hash_row[\"hash_id\"]}\n            ).fetchall()\n\n            yield \"<br>%s (added: %s, peers: %s)<br>\" % (\n                str(hash_row[\"hash\"]).encode(\"hex\"), hash_row[\"date_added\"], len(peer_rows)\n            )\n            for peer_row in peer_rows:\n                yield \" - {ip4: <30} {onion: <30} added: {date_added}, announced: {date_announced}<br>\".format(**dict(peer_row))\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "BootstrapperPlugin.py", "id": "89889b8fd7f4d2eb24bcc629b445cbbe", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/plugins/disabled-Bootstrapper/BootstrapperPlugin.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}