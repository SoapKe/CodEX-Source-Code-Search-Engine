{"author": "Valloric", "code": " Copyright (C) 2011, 2012  Google Inc.\n\n This file is part of YouCompleteMe.\n\n YouCompleteMe is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n YouCompleteMe is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import unicode_literals\nfrom __future__ import print_function\nfrom __future__ import division\nfrom __future__ import absolute_import\n Not installing aliases from python-future; it's unreliable and slow.\nfrom builtins import *   noqa\n\nfrom future.utils import iteritems\nfrom ycm import vimsupport\nfrom ycmd import user_options_store\nfrom ycmd import identifier_utils\n\nYCM_VAR_PREFIX = 'ycm_'\n\n\ndef BuildServerConf():\n  \"\"\"Builds a dictionary mapping YCM Vim user options to values. Option names\n  don't have the 'ycm_' prefix.\"\"\"\n   We only evaluate the keys of the vim globals and not the whole dictionary\n   to avoid unicode issues.\n   See https://github.com/Valloric/YouCompleteMe/pull/2151 for details.\n  keys = vimsupport.GetVimGlobalsKeys()\n  server_conf = {}\n  for key in keys:\n    if not key.startswith( YCM_VAR_PREFIX ):\n      continue\n    new_key = key[ len( YCM_VAR_PREFIX ): ]\n    new_value = vimsupport.VimExpressionToPythonType( 'g:' + key )\n    server_conf[ new_key ] = new_value\n\n  return server_conf\n\n\ndef LoadJsonDefaultsIntoVim():\n  defaults = user_options_store.DefaultOptions()\n  for key, value in iteritems( defaults ):\n    new_key = 'g:ycm_' + key\n    if not vimsupport.VariableExists( new_key ):\n      vimsupport.SetVariableValue( new_key, value )\n\n\ndef CurrentIdentifierFinished():\n  line, current_column = vimsupport.CurrentLineContentsAndCodepointColumn()\n  previous_char_index = current_column - 1\n  if previous_char_index < 0:\n    return True\n  filetype = vimsupport.CurrentFiletypes()[ 0 ]\n  regex = identifier_utils.IdentifierRegexForFiletype( filetype )\n\n  for match in regex.finditer( line ):\n    if match.end() == previous_char_index:\n      return True\n   If the whole line is whitespace, that means the user probably finished an\n   identifier on the previous line.\n  return line[ : current_column ].isspace()\n\n\ndef LastEnteredCharIsIdentifierChar():\n  line, current_column = vimsupport.CurrentLineContentsAndCodepointColumn()\n  if current_column - 1 < 0:\n    return False\n  filetype = vimsupport.CurrentFiletypes()[ 0 ]\n  return (\n    identifier_utils.StartOfLongestIdentifierEndingAtIndex(\n        line, current_column, filetype ) != current_column )\n\n\ndef AdjustCandidateInsertionText( candidates ):\n  \"\"\"This function adjusts the candidate insertion text to take into account the\n  text that's currently in front of the cursor.\n\n  For instance ('|' represents the cursor):\n    1. Buffer state: 'foo.||||' (the cursor at the end), but that would be much more difficult\n  to implement and is probably not worth doing.\n  \"\"\"\n\n  def NewCandidateInsertionText( to_insert, text_after_cursor ):\n    overlap_len = OverlapLength( to_insert, text_after_cursor )\n    if overlap_len:\n      return to_insert[ :-overlap_len ]\n    return to_insert\n\n  text_after_cursor = vimsupport.TextAfterCursor()\n  if not text_after_cursor:\n    return candidates\n\n  new_candidates = []\n  for candidate in candidates:\n    if isinstance( candidate, dict ):\n      new_candidate = candidate.copy()\n\n      if 'abbr' not in new_candidate:\n        new_candidate[ 'abbr' ] = new_candidate[ 'word' ]\n\n      new_candidate[ 'word' ] = NewCandidateInsertionText(\n        new_candidate[ 'word' ],\n        text_after_cursor )\n\n      new_candidates.append( new_candidate )\n\n    elif isinstance( candidate, str ) or isinstance( candidate, bytes ):\n      new_candidates.append(\n        { 'abbr': candidate,\n          'word': NewCandidateInsertionText( candidate, text_after_cursor ) } )\n  return new_candidates\n\n\ndef OverlapLength( left_string, right_string ):\n  \"\"\"Returns the length of the overlap between two strings.\n  Example: \"foo baro\" and \"baro zoo\" -> 4\n  \"\"\"\n  left_string_length = len( left_string )\n  right_string_length = len( right_string )\n\n  if not left_string_length or not right_string_length:\n    return 0\n\n   Truncate the longer string.\n  if left_string_length > right_string_length:\n    left_string = left_string[ -right_string_length: ]\n  elif left_string_length < right_string_length:\n    right_string = right_string[ :left_string_length ]\n\n  if left_string == right_string:\n    return min( left_string_length, right_string_length )\n\n   Start by looking for a single character match\n   and increase length until no match is found.\n  best = 0\n  length = 1\n  while True:\n    pattern = left_string[ -length: ]\n    found = right_string.find( pattern )\n    if found < 0:\n      return best\n    length += found\n    if left_string[ -length: ] == right_string[ :length ]:\n      best = length\n      length += 1\n", "comments": "   builds dictionary mapping ycm vim user options values  option names    ycm   prefix         we evaluate keys vim globals whole dictionary     avoid unicode issues      see https   github com valloric youcompleteme pull 2151 details    keys   vimsupport getvimglobalskeys()   server conf        key keys      key startswith( ycm var prefix )        continue     new key   key  len( ycm var prefix )        new value   vimsupport vimexpressiontopythontype(  g     key )     server conf  new key     new value    return server conf   def loadjsondefaultsintovim()    defaults   user options store defaultoptions()   key  value iteritems( defaults )      new key    g ycm     key     vimsupport variableexists( new key )        vimsupport setvariablevalue( new key  value )   def currentidentifierfinished()    line  current column   vimsupport currentlinecontentsandcodepointcolumn()   previous char index   current column   1   previous char index   0      return true   filetype   vimsupport currentfiletypes()  0     regex   identifier utils identifierregexforfiletype( filetype )    match regex finditer( line )      match end()    previous char index        return true     if whole line whitespace  means user probably finished     identifier previous line    return line    current column   isspace()   def lastenteredcharisidentifierchar()    line  current column   vimsupport currentlinecontentsandcodepointcolumn()   current column   1   0      return false   filetype   vimsupport currentfiletypes()  0     return (     identifier utils startoflongestidentifierendingatindex(         line  current column  filetype )    current column )   def adjustcandidateinsertiontext( candidates )       this function adjusts candidate insertion text take account   text currently front cursor     for instance (    represents cursor)      1  buffer state   foo  bar      2  a completion candidate  zoobar  shown user selects      3  buffer state   foo zoobar bar  instead  foo zoo bar      user wanted     this function changes candidates resolve issue     it could argued user actually wants final buffer state    foo zoobar   (the cursor end)  would much difficult   implement probably worth           def newcandidateinsertiontext( insert  text cursor )      overlap len   overlaplength( insert  text cursor )     overlap len        return insert    overlap len       return insert    text cursor   vimsupport textaftercursor()   text cursor      return candidates    new candidates        candidate candidates      isinstance( candidate  dict )        new candidate   candidate copy()         abbr  new candidate          new candidate   abbr      new candidate   word           new candidate   word      newcandidateinsertiontext(         new candidate   word             text cursor )        new candidates append( new candidate )      elif isinstance( candidate  str ) isinstance( candidate  bytes )        new candidates append(            abbr   candidate             word   newcandidateinsertiontext( candidate  text cursor )   )   return new candidates   def overlaplength( left string  right string )       returns length overlap two strings    example   foo baro   baro zoo     4          copyright (c) 2011  2012  google inc        this file part youcompleteme        youcompleteme free software  redistribute modify    terms gnu general public license published    free software foundation  either version 3 license     (at option) later version        youcompleteme distributed hope useful     without any warranty  without even implied warranty    merchantability fitness for a particular purpose   see    gnu general public license details        you received copy gnu general public license    along youcompleteme   if  see  http   www gnu org licenses       not installing aliases python future  unreliable slow     noqa    we evaluate keys vim globals whole dictionary    avoid unicode issues     see https   github com valloric youcompleteme pull 2151 details     if whole line whitespace  means user probably finished    identifier previous line     truncate longer string     start looking single character match    increase length match found  ", "content": "# Copyright (C) 2011, 2012  Google Inc.\n#\n# This file is part of YouCompleteMe.\n#\n# YouCompleteMe is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# YouCompleteMe is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import unicode_literals\nfrom __future__ import print_function\nfrom __future__ import division\nfrom __future__ import absolute_import\n# Not installing aliases from python-future; it's unreliable and slow.\nfrom builtins import *  # noqa\n\nfrom future.utils import iteritems\nfrom ycm import vimsupport\nfrom ycmd import user_options_store\nfrom ycmd import identifier_utils\n\nYCM_VAR_PREFIX = 'ycm_'\n\n\ndef BuildServerConf():\n  \"\"\"Builds a dictionary mapping YCM Vim user options to values. Option names\n  don't have the 'ycm_' prefix.\"\"\"\n  # We only evaluate the keys of the vim globals and not the whole dictionary\n  # to avoid unicode issues.\n  # See https://github.com/Valloric/YouCompleteMe/pull/2151 for details.\n  keys = vimsupport.GetVimGlobalsKeys()\n  server_conf = {}\n  for key in keys:\n    if not key.startswith( YCM_VAR_PREFIX ):\n      continue\n    new_key = key[ len( YCM_VAR_PREFIX ): ]\n    new_value = vimsupport.VimExpressionToPythonType( 'g:' + key )\n    server_conf[ new_key ] = new_value\n\n  return server_conf\n\n\ndef LoadJsonDefaultsIntoVim():\n  defaults = user_options_store.DefaultOptions()\n  for key, value in iteritems( defaults ):\n    new_key = 'g:ycm_' + key\n    if not vimsupport.VariableExists( new_key ):\n      vimsupport.SetVariableValue( new_key, value )\n\n\ndef CurrentIdentifierFinished():\n  line, current_column = vimsupport.CurrentLineContentsAndCodepointColumn()\n  previous_char_index = current_column - 1\n  if previous_char_index < 0:\n    return True\n  filetype = vimsupport.CurrentFiletypes()[ 0 ]\n  regex = identifier_utils.IdentifierRegexForFiletype( filetype )\n\n  for match in regex.finditer( line ):\n    if match.end() == previous_char_index:\n      return True\n  # If the whole line is whitespace, that means the user probably finished an\n  # identifier on the previous line.\n  return line[ : current_column ].isspace()\n\n\ndef LastEnteredCharIsIdentifierChar():\n  line, current_column = vimsupport.CurrentLineContentsAndCodepointColumn()\n  if current_column - 1 < 0:\n    return False\n  filetype = vimsupport.CurrentFiletypes()[ 0 ]\n  return (\n    identifier_utils.StartOfLongestIdentifierEndingAtIndex(\n        line, current_column, filetype ) != current_column )\n\n\ndef AdjustCandidateInsertionText( candidates ):\n  \"\"\"This function adjusts the candidate insertion text to take into account the\n  text that's currently in front of the cursor.\n\n  For instance ('|' represents the cursor):\n    1. Buffer state: 'foo.|bar'\n    2. A completion candidate of 'zoobar' is shown and the user selects it.\n    3. Buffer state: 'foo.zoobar|bar' instead of 'foo.zoo|bar' which is what the\n    user wanted.\n\n  This function changes candidates to resolve that issue.\n\n  It could be argued that the user actually wants the final buffer state to be\n  'foo.zoobar|' (the cursor at the end), but that would be much more difficult\n  to implement and is probably not worth doing.\n  \"\"\"\n\n  def NewCandidateInsertionText( to_insert, text_after_cursor ):\n    overlap_len = OverlapLength( to_insert, text_after_cursor )\n    if overlap_len:\n      return to_insert[ :-overlap_len ]\n    return to_insert\n\n  text_after_cursor = vimsupport.TextAfterCursor()\n  if not text_after_cursor:\n    return candidates\n\n  new_candidates = []\n  for candidate in candidates:\n    if isinstance( candidate, dict ):\n      new_candidate = candidate.copy()\n\n      if 'abbr' not in new_candidate:\n        new_candidate[ 'abbr' ] = new_candidate[ 'word' ]\n\n      new_candidate[ 'word' ] = NewCandidateInsertionText(\n        new_candidate[ 'word' ],\n        text_after_cursor )\n\n      new_candidates.append( new_candidate )\n\n    elif isinstance( candidate, str ) or isinstance( candidate, bytes ):\n      new_candidates.append(\n        { 'abbr': candidate,\n          'word': NewCandidateInsertionText( candidate, text_after_cursor ) } )\n  return new_candidates\n\n\ndef OverlapLength( left_string, right_string ):\n  \"\"\"Returns the length of the overlap between two strings.\n  Example: \"foo baro\" and \"baro zoo\" -> 4\n  \"\"\"\n  left_string_length = len( left_string )\n  right_string_length = len( right_string )\n\n  if not left_string_length or not right_string_length:\n    return 0\n\n  # Truncate the longer string.\n  if left_string_length > right_string_length:\n    left_string = left_string[ -right_string_length: ]\n  elif left_string_length < right_string_length:\n    right_string = right_string[ :left_string_length ]\n\n  if left_string == right_string:\n    return min( left_string_length, right_string_length )\n\n  # Start by looking for a single character match\n  # and increase length until no match is found.\n  best = 0\n  length = 1\n  while True:\n    pattern = left_string[ -length: ]\n    found = right_string.find( pattern )\n    if found < 0:\n      return best\n    length += found\n    if left_string[ -length: ] == right_string[ :length ]:\n      best = length\n      length += 1\n", "description": "A code-completion engine for Vim", "file_name": "base.py", "id": "09fbea6d8e252434f34b249eac23bdfc", "language": "Python", "project_name": "YouCompleteMe", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/Valloric-YouCompleteMe/Valloric-YouCompleteMe-d338141/python/ycm/base.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:58:33Z", "url": "https://github.com/Valloric/YouCompleteMe", "wiki": true}