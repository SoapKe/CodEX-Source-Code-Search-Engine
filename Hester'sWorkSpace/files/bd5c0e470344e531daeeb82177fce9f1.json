{"author": "nvbn", "code": "import sys\nfrom .conf import settings\nfrom .types import Rule\nfrom .system import Path\nfrom . import logs\n\n\ndef get_loaded_rules(rules_paths):\n    \n    corrected_commands = (\n        corrected for rule in get_rules()\n        if rule.is_match(command)\n        for corrected in rule.get_corrected_commands(command))\n    return organize_commands(corrected_commands)\n", "comments": "Yields all available rules.\n\n    :type rules_paths: [Path]\n    :rtype: Iterable[Rule]\n\n    \"\"\"\n    for path in rules_paths:\n        if path.name != '__init__.py':\n            rule = Rule.from_path(path)\n            if rule.is_enabled:\n                yield rule\n\n\ndef get_rules_import_paths():\n    \"\"\"Yields all rules import paths.\n\n    :rtype: Iterable[Path]\n\n    \"\"\"\n    # Bundled rules:\n    yield Path(__file__).parent.joinpath('rules')\n    # Rules defined by user:\n    yield settings.user_dir.joinpath('rules')\n    # Packages with third-party rules:\n    for path in sys.path:\n        for contrib_module in Path(path).glob('thefuck_contrib_*'):\n            contrib_rules = contrib_module.joinpath('rules')\n            if contrib_rules.is_dir():\n                yield contrib_rules\n\n\ndef get_rules():\n    \"\"\"Returns all enabled rules.\n\n    :rtype: [Rule]\n\n    \"\"\"\n    paths = [rule_path for path in get_rules_import_paths()\n             for rule_path in sorted(path.glob('*.py'))]\n    return sorted(get_loaded_rules(paths),\n                  key=lambda rule: rule.priority)\n\n\ndef organize_commands(corrected_commands):\n    \"\"\"Yields sorted commands without duplicates.\n\n    :type corrected_commands: Iterable[thefuck.types.CorrectedCommand]\n    :rtype: Iterable[thefuck.types.CorrectedCommand]\n\n    \"\"\"\n    try:\n        first_command = next(corrected_commands)\n        yield first_command\n    except StopIteration:\n        return\n\n    without_duplicates = {\n        command for command in sorted(\n            corrected_commands, key=lambda command: command.priority)\n        if command != first_command}\n\n    sorted_commands = sorted(\n        without_duplicates,\n        key=lambda corrected_command: corrected_command.priority)\n\n    logs.debug('Corrected commands: '.format(\n        ', '.join(u'{}'.format(cmd) for cmd in [first_command] + sorted_commands)))\n\n    for command in sorted_commands:\n        yield command\n\n\ndef get_corrected_commands(command):\n    \"\"\"Returns generator with sorted and unique corrected commands.\n\n    :type command: thefuck.types.Command\n    :rtype: Iterable[thefuck.types.CorrectedCommand]\n\n    \n \n", "content": "import sys\nfrom .conf import settings\nfrom .types import Rule\nfrom .system import Path\nfrom . import logs\n\n\ndef get_loaded_rules(rules_paths):\n    \"\"\"Yields all available rules.\n\n    :type rules_paths: [Path]\n    :rtype: Iterable[Rule]\n\n    \"\"\"\n    for path in rules_paths:\n        if path.name != '__init__.py':\n            rule = Rule.from_path(path)\n            if rule.is_enabled:\n                yield rule\n\n\ndef get_rules_import_paths():\n    \"\"\"Yields all rules import paths.\n\n    :rtype: Iterable[Path]\n\n    \"\"\"\n    # Bundled rules:\n    yield Path(__file__).parent.joinpath('rules')\n    # Rules defined by user:\n    yield settings.user_dir.joinpath('rules')\n    # Packages with third-party rules:\n    for path in sys.path:\n        for contrib_module in Path(path).glob('thefuck_contrib_*'):\n            contrib_rules = contrib_module.joinpath('rules')\n            if contrib_rules.is_dir():\n                yield contrib_rules\n\n\ndef get_rules():\n    \"\"\"Returns all enabled rules.\n\n    :rtype: [Rule]\n\n    \"\"\"\n    paths = [rule_path for path in get_rules_import_paths()\n             for rule_path in sorted(path.glob('*.py'))]\n    return sorted(get_loaded_rules(paths),\n                  key=lambda rule: rule.priority)\n\n\ndef organize_commands(corrected_commands):\n    \"\"\"Yields sorted commands without duplicates.\n\n    :type corrected_commands: Iterable[thefuck.types.CorrectedCommand]\n    :rtype: Iterable[thefuck.types.CorrectedCommand]\n\n    \"\"\"\n    try:\n        first_command = next(corrected_commands)\n        yield first_command\n    except StopIteration:\n        return\n\n    without_duplicates = {\n        command for command in sorted(\n            corrected_commands, key=lambda command: command.priority)\n        if command != first_command}\n\n    sorted_commands = sorted(\n        without_duplicates,\n        key=lambda corrected_command: corrected_command.priority)\n\n    logs.debug('Corrected commands: '.format(\n        ', '.join(u'{}'.format(cmd) for cmd in [first_command] + sorted_commands)))\n\n    for command in sorted_commands:\n        yield command\n\n\ndef get_corrected_commands(command):\n    \"\"\"Returns generator with sorted and unique corrected commands.\n\n    :type command: thefuck.types.Command\n    :rtype: Iterable[thefuck.types.CorrectedCommand]\n\n    \"\"\"\n    corrected_commands = (\n        corrected for rule in get_rules()\n        if rule.is_match(command)\n        for corrected in rule.get_corrected_commands(command))\n    return organize_commands(corrected_commands)\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "corrector.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/thefuck/corrector.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}