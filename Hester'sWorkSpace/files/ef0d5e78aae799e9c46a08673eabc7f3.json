{"author": "django", "code": "import datetime\nfrom unittest import skipIf, skipUnless\n\nfrom django.core.exceptions import FieldError\nfrom django.db import NotSupportedError, connection\nfrom django.db.models import (\n    F, RowRange, Value, ValueRange, Window, WindowFrame,\n)\nfrom django.db.models.aggregates import Avg, Max, Min, Sum\nfrom django.db.models.functions import (\n    CumeDist, DenseRank, ExtractYear, FirstValue, Lag, LastValue, Lead,\n    NthValue, Ntile, PercentRank, Rank, RowNumber, Upper,\n)\nfrom django.test import SimpleTestCase, TestCase, skipUnlessDBFeature\n\nfrom .models import Employee\n\n\n@skipUnlessDBFeature('supports_over_clause')\nclass WindowFunctionTests(TestCase):\n    @classmethod\n    def setUpTestData(cls):\n        Employee.objects.bulk_create([\n            Employee(name=e[0], salary=e[1], department=e[2], hire_date=e[3])\n            for e in [\n                ('Jones', 45000, 'Accounting', datetime.datetime(2005, 11, 1)),\n                ('Williams', 37000, 'Accounting', datetime.datetime(2009, 6, 1)),\n                ('Jenson', 45000, 'Accounting', datetime.datetime(2008, 4, 1)),\n                ('Adams', 50000, 'Accounting', datetime.datetime(2013, 7, 1)),\n                ('Smith', 55000, 'Sales', datetime.datetime(2007, 6, 1)),\n                ('Brown', 53000, 'Sales', datetime.datetime(2009, 9, 1)),\n                ('Johnson', 40000, 'Marketing', datetime.datetime(2012, 3, 1)),\n                ('Smith', 38000, 'Marketing', datetime.datetime(2009, 10, 1)),\n                ('Wilkinson', 60000, 'IT', datetime.datetime(2011, 3, 1)),\n                ('Moore', 34000, 'IT', datetime.datetime(2013, 8, 1)),\n                ('Miller', 100000, 'Management', datetime.datetime(2005, 6, 1)),\n                ('Johnson', 80000, 'Management', datetime.datetime(2005, 7, 1)),\n            ]\n        ])\n\n    def test_dense_rank(self):\n        qs = Employee.objects.annotate(rank=Window(\n            expression=DenseRank(),\n            order_by=ExtractYear(F('hire_date')).asc(),\n        ))\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 1),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 1),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 1),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 2),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 3),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 4),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 4),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 4),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 5),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 6),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 7),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 7),\n        ], lambda entry: (entry.name, entry.salary, entry.department, entry.hire_date, entry.rank), ordered=False)\n\n    def test_department_salary(self):\n        qs = Employee.objects.annotate(department_sum=Window(\n            expression=Sum('salary'),\n            partition_by=F('department'),\n            order_by=[F('hire_date').asc()],\n        )).order_by('department', 'department_sum')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 'Accounting', 45000, 45000),\n            ('Jenson', 'Accounting', 45000, 90000),\n            ('Williams', 'Accounting', 37000, 127000),\n            ('Adams', 'Accounting', 50000, 177000),\n            ('Wilkinson', 'IT', 60000, 60000),\n            ('Moore', 'IT', 34000, 94000),\n            ('Miller', 'Management', 100000, 100000),\n            ('Johnson', 'Management', 80000, 180000),\n            ('Smith', 'Marketing', 38000, 38000),\n            ('Johnson', 'Marketing', 40000, 78000),\n            ('Smith', 'Sales', 55000, 55000),\n            ('Brown', 'Sales', 53000, 108000),\n        ], lambda entry: (entry.name, entry.department, entry.salary, entry.department_sum))\n\n    def test_rank(self):\n        \"\"\"\n        Rank the employees based on the year they're were hired. Since there\n        are multiple employees hired in different years, this will contain\n        gaps.\n        \"\"\"\n        qs = Employee.objects.annotate(rank=Window(\n            expression=Rank(),\n            order_by=ExtractYear(F('hire_date')).asc(),\n        ))\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 1),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 1),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 1),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 4),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 5),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 6),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 6),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 6),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 9),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 10),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 11),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 11),\n        ], lambda entry: (entry.name, entry.salary, entry.department, entry.hire_date, entry.rank), ordered=False)\n\n    def test_row_number(self):\n        \"\"\"\n        The row number window function computes the number based on the order\n        in which the tuples were inserted. Depending on the backend,\n\n        Oracle requires an ordering-clause in the Window expression.\n        \"\"\"\n        qs = Employee.objects.annotate(row_number=Window(\n            expression=RowNumber(),\n            order_by=F('pk').asc(),\n        )).order_by('pk')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 'Accounting', 1),\n            ('Williams', 'Accounting', 2),\n            ('Jenson', 'Accounting', 3),\n            ('Adams', 'Accounting', 4),\n            ('Smith', 'Sales', 5),\n            ('Brown', 'Sales', 6),\n            ('Johnson', 'Marketing', 7),\n            ('Smith', 'Marketing', 8),\n            ('Wilkinson', 'IT', 9),\n            ('Moore', 'IT', 10),\n            ('Miller', 'Management', 11),\n            ('Johnson', 'Management', 12),\n        ], lambda entry: (entry.name, entry.department, entry.row_number))\n\n    @skipIf(connection.vendor == 'oracle', \"Oracle requires ORDER BY in row_number, ANSI:SQL doesn't\")\n    def test_row_number_no_ordering(self):\n        \"\"\"\n        The row number window function computes the number based on the order\n        in which the tuples were inserted.\n        \"\"\"\n        \n        qs = Employee.objects.annotate(row_number=Window(\n            expression=RowNumber(),\n        )).order_by('pk')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 'Accounting', 1),\n            ('Williams', 'Accounting', 2),\n            ('Jenson', 'Accounting', 3),\n            ('Adams', 'Accounting', 4),\n            ('Smith', 'Sales', 5),\n            ('Brown', 'Sales', 6),\n            ('Johnson', 'Marketing', 7),\n            ('Smith', 'Marketing', 8),\n            ('Wilkinson', 'IT', 9),\n            ('Moore', 'IT', 10),\n            ('Miller', 'Management', 11),\n            ('Johnson', 'Management', 12),\n        ], lambda entry: (entry.name, entry.department, entry.row_number))\n\n    def test_avg_salary_department(self):\n        qs = Employee.objects.annotate(avg_salary=Window(\n            expression=Avg('salary'),\n            order_by=F('department').asc(),\n            partition_by='department',\n        )).order_by('department', '-salary', 'name')\n        self.assertQuerysetEqual(qs, [\n            ('Adams', 50000, 'Accounting', 44250.00),\n            ('Jenson', 45000, 'Accounting', 44250.00),\n            ('Jones', 45000, 'Accounting', 44250.00),\n            ('Williams', 37000, 'Accounting', 44250.00),\n            ('Wilkinson', 60000, 'IT', 47000.00),\n            ('Moore', 34000, 'IT', 47000.00),\n            ('Miller', 100000, 'Management', 90000.00),\n            ('Johnson', 80000, 'Management', 90000.00),\n            ('Johnson', 40000, 'Marketing', 39000.00),\n            ('Smith', 38000, 'Marketing', 39000.00),\n            ('Smith', 55000, 'Sales', 54000.00),\n            ('Brown', 53000, 'Sales', 54000.00),\n        ], transform=lambda row: (row.name, row.salary, row.department, row.avg_salary))\n\n    def test_lag(self):\n        \"\"\"\n        Compute the difference between an employee's salary and the next\n        highest salary in the employee's department. Return None if the\n        employee has the lowest salary.\n        \"\"\"\n        qs = Employee.objects.annotate(lag=Window(\n            expression=Lag(expression='salary', offset=1),\n            partition_by=F('department'),\n            order_by=[F('salary').asc(), F('name').asc()],\n        )).order_by('department')\n        self.assertQuerysetEqual(qs, [\n            ('Williams', 37000, 'Accounting', None),\n            ('Jenson', 45000, 'Accounting', 37000),\n            ('Jones', 45000, 'Accounting', 45000),\n            ('Adams', 50000, 'Accounting', 45000),\n            ('Moore', 34000, 'IT', None),\n            ('Wilkinson', 60000, 'IT', 34000),\n            ('Johnson', 80000, 'Management', None),\n            ('Miller', 100000, 'Management', 80000),\n            ('Smith', 38000, 'Marketing', None),\n            ('Johnson', 40000, 'Marketing', 38000),\n            ('Brown', 53000, 'Sales', None),\n            ('Smith', 55000, 'Sales', 53000),\n        ], transform=lambda row: (row.name, row.salary, row.department, row.lag))\n\n    def test_first_value(self):\n        qs = Employee.objects.annotate(first_value=Window(\n            expression=FirstValue('salary'),\n            partition_by=F('department'),\n            order_by=F('hire_date').asc(),\n        )).order_by('department', 'hire_date')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 45000),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 45000),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 45000),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 60000),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 60000),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 100000),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 100000),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 38000),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 38000),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 55000),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 55000),\n        ], lambda row: (row.name, row.salary, row.department, row.hire_date, row.first_value))\n\n    def test_last_value(self):\n        qs = Employee.objects.annotate(last_value=Window(\n            expression=LastValue('hire_date'),\n            partition_by=F('department'),\n            order_by=F('hire_date').asc(),\n        ))\n        self.assertQuerysetEqual(qs, [\n            ('Adams', 'Accounting', datetime.date(2013, 7, 1), 50000, datetime.date(2013, 7, 1)),\n            ('Jenson', 'Accounting', datetime.date(2008, 4, 1), 45000, datetime.date(2008, 4, 1)),\n            ('Jones', 'Accounting', datetime.date(2005, 11, 1), 45000, datetime.date(2005, 11, 1)),\n            ('Williams', 'Accounting', datetime.date(2009, 6, 1), 37000, datetime.date(2009, 6, 1)),\n            ('Moore', 'IT', datetime.date(2013, 8, 1), 34000, datetime.date(2013, 8, 1)),\n            ('Wilkinson', 'IT', datetime.date(2011, 3, 1), 60000, datetime.date(2011, 3, 1)),\n            ('Miller', 'Management', datetime.date(2005, 6, 1), 100000, datetime.date(2005, 6, 1)),\n            ('Johnson', 'Management', datetime.date(2005, 7, 1), 80000, datetime.date(2005, 7, 1)),\n            ('Johnson', 'Marketing', datetime.date(2012, 3, 1), 40000, datetime.date(2012, 3, 1)),\n            ('Smith', 'Marketing', datetime.date(2009, 10, 1), 38000, datetime.date(2009, 10, 1)),\n            ('Brown', 'Sales', datetime.date(2009, 9, 1), 53000, datetime.date(2009, 9, 1)),\n            ('Smith', 'Sales', datetime.date(2007, 6, 1), 55000, datetime.date(2007, 6, 1)),\n        ], transform=lambda row: (row.name, row.department, row.hire_date, row.salary, row.last_value), ordered=False)\n\n    def test_function_list_of_values(self):\n        qs = Employee.objects.annotate(lead=Window(\n            expression=Lead(expression='salary'),\n            order_by=[F('hire_date').asc(), F('name').desc()],\n            partition_by='department',\n        )).values_list('name', 'salary', 'department', 'hire_date', 'lead')\n        self.assertNotIn('GROUP BY', str(qs.query))\n        self.assertSequenceEqual(qs, [\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 37000),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 50000),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), None),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 34000),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), None),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 80000),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), None),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 40000),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), None),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 53000),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), None),\n        ])\n\n    def test_min_department(self):\n        \"\"\"An alternative way to specify a query for FirstValue.\"\"\"\n        qs = Employee.objects.annotate(min_salary=Window(\n            expression=Min('salary'),\n            partition_by=F('department'),\n            order_by=[F('salary').asc(), F('name').asc()]\n        )).order_by('department', 'salary', 'name')\n        self.assertQuerysetEqual(qs, [\n            ('Williams', 'Accounting', 37000, 37000),\n            ('Jenson', 'Accounting', 45000, 37000),\n            ('Jones', 'Accounting', 45000, 37000),\n            ('Adams', 'Accounting', 50000, 37000),\n            ('Moore', 'IT', 34000, 34000),\n            ('Wilkinson', 'IT', 60000, 34000),\n            ('Johnson', 'Management', 80000, 80000),\n            ('Miller', 'Management', 100000, 80000),\n            ('Smith', 'Marketing', 38000, 38000),\n            ('Johnson', 'Marketing', 40000, 38000),\n            ('Brown', 'Sales', 53000, 53000),\n            ('Smith', 'Sales', 55000, 53000),\n        ], lambda row: (row.name, row.department, row.salary, row.min_salary))\n\n    def test_max_per_year(self):\n        \"\"\"\n        Find the maximum salary awarded in the same year as the\n        employee was hired, regardless of the department.\n        \"\"\"\n        qs = Employee.objects.annotate(max_salary_year=Window(\n            expression=Max('salary'),\n            order_by=ExtractYear('hire_date').asc(),\n            partition_by=ExtractYear('hire_date')\n        )).order_by(ExtractYear('hire_date'), 'salary')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 'Accounting', 45000, 2005, 100000),\n            ('Johnson', 'Management', 80000, 2005, 100000),\n            ('Miller', 'Management', 100000, 2005, 100000),\n            ('Smith', 'Sales', 55000, 2007, 55000),\n            ('Jenson', 'Accounting', 45000, 2008, 45000),\n            ('Williams', 'Accounting', 37000, 2009, 53000),\n            ('Smith', 'Marketing', 38000, 2009, 53000),\n            ('Brown', 'Sales', 53000, 2009, 53000),\n            ('Wilkinson', 'IT', 60000, 2011, 60000),\n            ('Johnson', 'Marketing', 40000, 2012, 40000),\n            ('Moore', 'IT', 34000, 2013, 50000),\n            ('Adams', 'Accounting', 50000, 2013, 50000),\n        ], lambda row: (row.name, row.department, row.salary, row.hire_date.year, row.max_salary_year))\n\n    def test_cume_dist(self):\n        \"\"\"\n        Compute the cumulative distribution for the employees based on the\n        salary in increasing order. Equal to rank/total number of rows (12).\n        \"\"\"\n        qs = Employee.objects.annotate(cume_dist=Window(\n            expression=CumeDist(),\n            order_by=F('salary').asc(),\n        )).order_by('salary', 'name')\n        \n        self.assertQuerysetEqual(qs, [\n            ('Moore', 'IT', 34000, 0.0833333333),\n            ('Williams', 'Accounting', 37000, 0.1666666667),\n            ('Smith', 'Marketing', 38000, 0.25),\n            ('Johnson', 'Marketing', 40000, 0.3333333333),\n            ('Jenson', 'Accounting', 45000, 0.5),\n            ('Jones', 'Accounting', 45000, 0.5),\n            ('Adams', 'Accounting', 50000, 0.5833333333),\n            ('Brown', 'Sales', 53000, 0.6666666667),\n            ('Smith', 'Sales', 55000, 0.75),\n            ('Wilkinson', 'IT', 60000, 0.8333333333),\n            ('Johnson', 'Management', 80000, 0.9166666667),\n            ('Miller', 'Management', 100000, 1),\n        ], lambda row: (row.name, row.department, row.salary, round(row.cume_dist, 10)))\n\n    def test_nthvalue(self):\n        qs = Employee.objects.annotate(\n            nth_value=Window(expression=NthValue(\n                expression='salary', nth=2),\n                order_by=[F('hire_date').asc(), F('name').desc()],\n                partition_by=F('department'),\n            )\n        ).order_by('department', 'hire_date', 'name')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 'Accounting', datetime.date(2005, 11, 1), 45000, None),\n            ('Jenson', 'Accounting', datetime.date(2008, 4, 1), 45000, 45000),\n            ('Williams', 'Accounting', datetime.date(2009, 6, 1), 37000, 45000),\n            ('Adams', 'Accounting', datetime.date(2013, 7, 1), 50000, 45000),\n            ('Wilkinson', 'IT', datetime.date(2011, 3, 1), 60000, None),\n            ('Moore', 'IT', datetime.date(2013, 8, 1), 34000, 34000),\n            ('Miller', 'Management', datetime.date(2005, 6, 1), 100000, None),\n            ('Johnson', 'Management', datetime.date(2005, 7, 1), 80000, 80000),\n            ('Smith', 'Marketing', datetime.date(2009, 10, 1), 38000, None),\n            ('Johnson', 'Marketing', datetime.date(2012, 3, 1), 40000, 40000),\n            ('Smith', 'Sales', datetime.date(2007, 6, 1), 55000, None),\n            ('Brown', 'Sales', datetime.date(2009, 9, 1), 53000, 53000),\n        ], lambda row: (row.name, row.department, row.hire_date, row.salary, row.nth_value))\n\n    def test_lead(self):\n        \"\"\"\n        Determine what the next person hired in the same department makes.\n        Because the dataset is ambiguous, the name is also part of the\n        ordering clause. No default is provided, so None/NULL should be\n        returned.\n        \"\"\"\n        qs = Employee.objects.annotate(lead=Window(\n            expression=Lead(expression='salary'),\n            order_by=[F('hire_date').asc(), F('name').desc()],\n            partition_by='department',\n        )).order_by('department')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 37000),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 50000),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), None),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 34000),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), None),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 80000),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), None),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 40000),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), None),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 53000),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), None),\n        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.lead))\n\n    def test_lead_offset(self):\n        \"\"\"\n        Determine what the person hired after someone makes. Due to\n        ambiguity, the name is also included in the ordering.\n        \"\"\"\n        qs = Employee.objects.annotate(lead=Window(\n            expression=Lead('salary', offset=2),\n            partition_by='department',\n            order_by=F('hire_date').asc(),\n        ))\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 37000),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 50000),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), None),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), None),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), None),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), None),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), None),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), None),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), None),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), None),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), None),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), None),\n        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.lead),\n            ordered=False\n        )\n\n    def test_lead_default(self):\n        qs = Employee.objects.annotate(lead_default=Window(\n            expression=Lead(expression='salary', offset=5, default=60000),\n            partition_by=F('department'),\n            order_by=F('department').asc(),\n        ))\n        self.assertEqual(list(qs.values_list('lead_default', flat=True).distinct()), [60000])\n\n    def test_ntile(self):\n        \"\"\"\n        Compute the group for each of the employees across the entire company,\n        based on how high the salary is for them. There are twelve employees\n        so it divides evenly into four groups.\n        \"\"\"\n        qs = Employee.objects.annotate(ntile=Window(\n            expression=Ntile(num_buckets=4),\n            order_by=F('salary').desc(),\n        )).order_by('ntile', '-salary', 'name')\n        self.assertQuerysetEqual(qs, [\n            ('Miller', 'Management', 100000, 1),\n            ('Johnson', 'Management', 80000, 1),\n            ('Wilkinson', 'IT', 60000, 1),\n            ('Smith', 'Sales', 55000, 2),\n            ('Brown', 'Sales', 53000, 2),\n            ('Adams', 'Accounting', 50000, 2),\n            ('Jenson', 'Accounting', 45000, 3),\n            ('Jones', 'Accounting', 45000, 3),\n            ('Johnson', 'Marketing', 40000, 3),\n            ('Smith', 'Marketing', 38000, 4),\n            ('Williams', 'Accounting', 37000, 4),\n            ('Moore', 'IT', 34000, 4),\n        ], lambda x: (x.name, x.department, x.salary, x.ntile))\n\n    def test_percent_rank(self):\n        \"\"\"\n        Calculate the percentage rank of the employees across the entire\n        company based on salary and name (in case of ambiguity).\n        \"\"\"\n        qs = Employee.objects.annotate(percent_rank=Window(\n            expression=PercentRank(),\n            order_by=[F('salary').asc(), F('name').asc()],\n        )).order_by('percent_rank')\n        \n        self.assertQuerysetEqual(qs, [\n            ('Moore', 'IT', 34000, 0.0),\n            ('Williams', 'Accounting', 37000, 0.0909090909),\n            ('Smith', 'Marketing', 38000, 0.1818181818),\n            ('Johnson', 'Marketing', 40000, 0.2727272727),\n            ('Jenson', 'Accounting', 45000, 0.3636363636),\n            ('Jones', 'Accounting', 45000, 0.4545454545),\n            ('Adams', 'Accounting', 50000, 0.5454545455),\n            ('Brown', 'Sales', 53000, 0.6363636364),\n            ('Smith', 'Sales', 55000, 0.7272727273),\n            ('Wilkinson', 'IT', 60000, 0.8181818182),\n            ('Johnson', 'Management', 80000, 0.9090909091),\n            ('Miller', 'Management', 100000, 1.0),\n        ], transform=lambda row: (row.name, row.department, row.salary, round(row.percent_rank, 10)))\n\n    def test_nth_returns_null(self):\n        \"\"\"\n        Find the nth row of the data set. None is returned since there are\n        fewer than 20 rows in the test data.\n        \"\"\"\n        qs = Employee.objects.annotate(nth_value=Window(\n            expression=NthValue('salary', nth=20),\n            order_by=F('salary').asc()\n        ))\n        self.assertEqual(list(qs.values_list('nth_value', flat=True).distinct()), [None])\n\n    def test_multiple_partitioning(self):\n        \"\"\"\n        Find the maximum salary for each department for people hired in the\n        same year.\n        \"\"\"\n        qs = Employee.objects.annotate(max=Window(\n            expression=Max('salary'),\n            partition_by=[F('department'), ExtractYear(F('hire_date'))],\n        )).order_by('department', 'hire_date', 'name')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 45000),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 37000),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 50000),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 60000),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 34000),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 100000),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 100000),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 38000),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 40000),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 55000),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 53000),\n        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.max))\n\n    def test_multiple_ordering(self):\n        \"\"\"\n        Accumulate the salaries over the departments based on hire_date.\n        If two people were hired on the same date in the same department, the\n        ordering clause will render a different result for those people.\n        \"\"\"\n        qs = Employee.objects.annotate(sum=Window(\n            expression=Sum('salary'),\n            partition_by='department',\n            order_by=[F('hire_date').asc(), F('name').asc()],\n        )).order_by('department', 'sum')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 90000),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 127000),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 177000),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 60000),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 94000),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 100000),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 180000),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 38000),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 78000),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 55000),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 108000),\n        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.sum))\n\n    @skipIf(connection.vendor == 'postgresql', 'n following/preceding not supported by PostgreSQL')\n    def test_range_n_preceding_and_following(self):\n        qs = Employee.objects.annotate(sum=Window(\n            expression=Sum('salary'),\n            order_by=F('salary').asc(),\n            partition_by='department',\n            frame=ValueRange(start=-2, end=2),\n        ))\n        self.assertIn('RANGE BETWEEN 2 PRECEDING AND 2 FOLLOWING', str(qs.query))\n        self.assertQuerysetEqual(qs, [\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 37000),\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 90000),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 90000),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 50000),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 53000),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 55000),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 40000),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 38000),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 60000),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 34000),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 100000),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 80000),\n        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.sum), ordered=False)\n\n    def test_range_unbound(self):\n        \"\"\"A query with RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING.\"\"\"\n        qs = Employee.objects.annotate(sum=Window(\n            expression=Sum('salary'),\n            partition_by='department',\n            order_by=[F('hire_date').asc(), F('name').asc()],\n            frame=ValueRange(start=None, end=None),\n        )).order_by('department', 'hire_date', 'name')\n        self.assertIn('RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING', str(qs.query))\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 'Accounting', 45000, datetime.date(2005, 11, 1), 177000),\n            ('Jenson', 'Accounting', 45000, datetime.date(2008, 4, 1), 177000),\n            ('Williams', 'Accounting', 37000, datetime.date(2009, 6, 1), 177000),\n            ('Adams', 'Accounting', 50000, datetime.date(2013, 7, 1), 177000),\n            ('Wilkinson', 'IT', 60000, datetime.date(2011, 3, 1), 94000),\n            ('Moore', 'IT', 34000, datetime.date(2013, 8, 1), 94000),\n            ('Miller', 'Management', 100000, datetime.date(2005, 6, 1), 180000),\n            ('Johnson', 'Management', 80000, datetime.date(2005, 7, 1), 180000),\n            ('Smith', 'Marketing', 38000, datetime.date(2009, 10, 1), 78000),\n            ('Johnson', 'Marketing', 40000, datetime.date(2012, 3, 1), 78000),\n            ('Smith', 'Sales', 55000, datetime.date(2007, 6, 1), 108000),\n            ('Brown', 'Sales', 53000, datetime.date(2009, 9, 1), 108000),\n        ], transform=lambda row: (row.name, row.department, row.salary, row.hire_date, row.sum))\n\n    def test_row_range_rank(self):\n        \"\"\"\n        A query with ROWS BETWEEN UNBOUNDED PRECEDING AND 3 FOLLOWING.\n        The resulting sum is the sum of the three next (if they exist) and all\n        previous rows according to the ordering clause.\n        \"\"\"\n        qs = Employee.objects.annotate(sum=Window(\n            expression=Sum('salary'),\n            order_by=[F('hire_date').asc(), F('name').desc()],\n            frame=RowRange(start=None, end=3),\n        )).order_by('sum', 'hire_date')\n        self.assertIn('ROWS BETWEEN UNBOUNDED PRECEDING AND 3 FOLLOWING', str(qs.query))\n        self.assertQuerysetEqual(qs, [\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 280000),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 325000),\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 362000),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 415000),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 453000),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 513000),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 553000),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 603000),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 637000),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 637000),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 637000),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 637000),\n        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.sum))\n\n    @skipUnlessDBFeature('can_distinct_on_fields')\n    def test_distinct_window_function(self):\n        \"\"\"\n        Window functions are not aggregates, and hence a query to filter out\n        duplicates may be useful.\n        \"\"\"\n        qs = Employee.objects.annotate(\n            sum=Window(\n                expression=Sum('salary'),\n                partition_by=ExtractYear('hire_date'),\n                order_by=ExtractYear('hire_date')\n            ),\n            year=ExtractYear('hire_date'),\n        ).values('year', 'sum').distinct('year').order_by('year')\n        results = [\n            {'year': 2005, 'sum': 225000}, {'year': 2007, 'sum': 55000},\n            {'year': 2008, 'sum': 45000}, {'year': 2009, 'sum': 128000},\n            {'year': 2011, 'sum': 60000}, {'year': 2012, 'sum': 40000},\n            {'year': 2013, 'sum': 84000},\n        ]\n        for idx, val in zip(range(len(results)), results):\n            with self.subTest(result=val):\n                self.assertEqual(qs[idx], val)\n\n    def test_fail_update(self):\n        \"\"\"Window expressions can't be used in an UPDATE statement.\"\"\"\n        msg = 'Window expressions are not allowed in this query'\n        with self.assertRaisesMessage(FieldError, msg):\n            Employee.objects.filter(department='Management').update(\n                salary=Window(expression=Max('salary'), partition_by='department'),\n            )\n\n    def test_fail_insert(self):\n        \"\"\"Window expressions can't be used in an INSERT statement.\"\"\"\n        msg = 'Window expressions are not allowed in this query'\n        with self.assertRaisesMessage(FieldError, msg):\n            Employee.objects.create(\n                name='Jameson', department='Management', hire_date=datetime.date(2007, 7, 1),\n                salary=Window(expression=Sum(Value(10000), order_by=F('pk').asc())),\n            )\n\n    def test_window_expression_within_subquery(self):\n        subquery_qs = Employee.objects.annotate(\n            highest=Window(FirstValue('id'), partition_by=F('department'), order_by=F('salary').desc())\n        ).values('highest')\n        highest_salary = Employee.objects.filter(pk__in=subquery_qs)\n        self.assertSequenceEqual(highest_salary.values('department', 'salary'), [\n            {'department': 'Accounting', 'salary': 50000},\n            {'department': 'Sales', 'salary': 55000},\n            {'department': 'Marketing', 'salary': 40000},\n            {'department': 'IT', 'salary': 60000},\n            {'department': 'Management', 'salary': 100000}\n        ])\n\n    def test_invalid_start_value_range(self):\n        msg = \"start argument must be a negative integer, zero, or None, but got '3'.\"\n        with self.assertRaisesMessage(ValueError, msg):\n            list(Employee.objects.annotate(test=Window(\n                expression=Sum('salary'),\n                order_by=F('hire_date').asc(),\n                frame=ValueRange(start=3),\n            )))\n\n    def test_invalid_end_value_range(self):\n        msg = \"end argument must be a positive integer, zero, or None, but got '-3'.\"\n        with self.assertRaisesMessage(ValueError, msg):\n            list(Employee.objects.annotate(test=Window(\n                expression=Sum('salary'),\n                order_by=F('hire_date').asc(),\n                frame=ValueRange(end=-3),\n            )))\n\n    def test_invalid_type_end_value_range(self):\n        msg = \"end argument must be a positive integer, zero, or None, but got 'a'.\"\n        with self.assertRaisesMessage(ValueError, msg):\n            list(Employee.objects.annotate(test=Window(\n                expression=Sum('salary'),\n                order_by=F('hire_date').asc(),\n                frame=ValueRange(end='a'),\n            )))\n\n    def test_invalid_type_start_value_range(self):\n        msg = \"start argument must be a negative integer, zero, or None, but got 'a'.\"\n        with self.assertRaisesMessage(ValueError, msg):\n            list(Employee.objects.annotate(test=Window(\n                expression=Sum('salary'),\n                frame=ValueRange(start='a'),\n            )))\n\n    def test_invalid_type_end_row_range(self):\n        msg = \"end argument must be a positive integer, zero, or None, but got 'a'.\"\n        with self.assertRaisesMessage(ValueError, msg):\n            list(Employee.objects.annotate(test=Window(\n                expression=Sum('salary'),\n                frame=RowRange(end='a'),\n            )))\n\n    @skipUnless(connection.vendor == 'postgresql', 'Frame construction not allowed on PostgreSQL')\n    def test_postgresql_illegal_range_frame_start(self):\n        msg = 'PostgreSQL only supports UNBOUNDED together with PRECEDING and FOLLOWING.'\n        with self.assertRaisesMessage(NotSupportedError, msg):\n            list(Employee.objects.annotate(test=Window(\n                expression=Sum('salary'),\n                order_by=F('hire_date').asc(),\n                frame=ValueRange(start=-1),\n            )))\n\n    @skipUnless(connection.vendor == 'postgresql', 'Frame construction not allowed on PostgreSQL')\n    def test_postgresql_illegal_range_frame_end(self):\n        msg = 'PostgreSQL only supports UNBOUNDED together with PRECEDING and FOLLOWING.'\n        with self.assertRaisesMessage(NotSupportedError, msg):\n            list(Employee.objects.annotate(test=Window(\n                expression=Sum('salary'),\n                order_by=F('hire_date').asc(),\n                frame=ValueRange(end=1),\n            )))\n\n    def test_invalid_type_start_row_range(self):\n        msg = \"start argument must be a negative integer, zero, or None, but got 'a'.\"\n        with self.assertRaisesMessage(ValueError, msg):\n            list(Employee.objects.annotate(test=Window(\n                expression=Sum('salary'),\n                order_by=F('hire_date').asc(),\n                frame=RowRange(start='a'),\n            )))\n\n\nclass NonQueryWindowTests(SimpleTestCase):\n    def test_window_repr(self):\n        self.assertEqual(\n            repr(Window(expression=Sum('salary'), partition_by='department')),\n            '<Window: Sum(F(salary)) OVER (PARTITION BY F(department))>'\n        )\n        self.assertEqual(\n            repr(Window(expression=Avg('salary'), order_by=F('department').asc())),\n            '<Window: Avg(F(salary)) OVER (ORDER BY OrderBy(F(department), descending=False))>'\n        )\n\n    def test_window_frame_repr(self):\n        self.assertEqual(\n            repr(RowRange(start=-1)),\n            '<RowRange: ROWS BETWEEN 1 PRECEDING AND UNBOUNDED FOLLOWING>'\n        )\n        self.assertEqual(\n            repr(ValueRange(start=None, end=1)),\n            '<ValueRange: RANGE BETWEEN UNBOUNDED PRECEDING AND 1 FOLLOWING>'\n        )\n        self.assertEqual(\n            repr(ValueRange(start=0, end=0)),\n            '<ValueRange: RANGE BETWEEN CURRENT ROW AND CURRENT ROW>'\n        )\n        self.assertEqual(\n            repr(RowRange(start=0, end=0)),\n            '<RowRange: ROWS BETWEEN CURRENT ROW AND CURRENT ROW>'\n        )\n\n    def test_empty_group_by_cols(self):\n        window = Window(expression=Sum('pk'))\n        self.assertEqual(window.get_group_by_cols(), [])\n        self.assertFalse(window.contains_aggregate)\n\n    def test_frame_empty_group_by_cols(self):\n        frame = WindowFrame()\n        self.assertEqual(frame.get_group_by_cols(), [])\n\n    def test_frame_window_frame_notimplemented(self):\n        frame = WindowFrame()\n        msg = 'Subclasses must implement window_frame_start_end().'\n        with self.assertRaisesMessage(NotImplementedError, msg):\n            frame.window_frame_start_end(None, None, None)\n\n    def test_invalid_filter(self):\n        msg = 'Window is disallowed in the filter clause'\n        with self.assertRaisesMessage(NotSupportedError, msg):\n            Employee.objects.annotate(dense_rank=Window(expression=DenseRank())).filter(dense_rank__gte=1)\n\n    def test_invalid_order_by(self):\n        msg = 'order_by must be either an Expression or a sequence of expressions'\n        with self.assertRaisesMessage(ValueError, msg):\n            Window(expression=Sum('power'), order_by='-horse')\n\n    def test_invalid_source_expression(self):\n        msg = \"Expression 'Upper' isn't compatible with OVER clauses.\"\n        with self.assertRaisesMessage(ValueError, msg):\n            Window(expression=Upper('name'))\n", "comments": "            rank employees based year hired  since         multiple employees hired different years  contain         gaps                      qs   employee objects annotate(rank window(             expression rank()              order extractyear(f( hire date )) asc()          ))         self assertquerysetequal(qs                ( jones   45000   accounting   datetime date(2005  11  1)  1)              ( miller   100000   management   datetime date(2005  6  1)  1)              ( johnson   80000   management   datetime date(2005  7  1)  1)              ( smith   55000   sales   datetime date(2007  6  1)  4)              ( jenson   45000   accounting   datetime date(2008  4  1)  5)              ( smith   38000   marketing   datetime date(2009  10  1)  6)              ( brown   53000   sales   datetime date(2009  9  1)  6)              ( williams   37000   accounting   datetime date(2009  6  1)  6)              ( wilkinson   60000   it   datetime date(2011  3  1)  9)              ( johnson   40000   marketing   datetime date(2012  3  1)  10)              ( moore   34000   it   datetime date(2013  8  1)  11)              ( adams   50000   accounting   datetime date(2013  7  1)  11)             lambda entry  (entry name  entry salary  entry department  entry hire date  entry rank)  ordered false)      def test row number(self)                      the row number window function computes number based order         tuples inserted  depending backend           oracle requires ordering clause window expression                      qs   employee objects annotate(row number window(             expression rownumber()              order f( pk ) asc()          )) order by( pk )         self assertquerysetequal(qs                ( jones    accounting   1)              ( williams    accounting   2)              ( jenson    accounting   3)              ( adams    accounting   4)              ( smith    sales   5)              ( brown    sales   6)              ( johnson    marketing   7)              ( smith    marketing   8)              ( wilkinson    it   9)              ( moore    it   10)              ( miller    management   11)              ( johnson    management   12)             lambda entry  (entry name  entry department  entry row number))       skipif(connection vendor     oracle    oracle requires order by row number  ansi sql )     def test row number ordering(self)                      the row number window function computes number based order         tuples inserted                        add default ordering consistent results across databases          qs   employee objects annotate(row number window(             expression rownumber()          )) order by( pk )         self assertquerysetequal(qs                ( jones    accounting   1)              ( williams    accounting   2)              ( jenson    accounting   3)              ( adams    accounting   4)              ( smith    sales   5)              ( brown    sales   6)              ( johnson    marketing   7)              ( smith    marketing   8)              ( wilkinson    it   9)              ( moore    it   10)              ( miller    management   11)              ( johnson    management   12)             lambda entry  (entry name  entry department  entry row number))      def test avg salary department(self)          qs   employee objects annotate(avg salary window(             expression avg( salary )              order f( department ) asc()              partition  department           )) order by( department     salary    name )         self assertquerysetequal(qs                ( adams   50000   accounting   44250 00)              ( jenson   45000   accounting   44250 00)              ( jones   45000   accounting   44250 00)              ( williams   37000   accounting   44250 00)              ( wilkinson   60000   it   47000 00)              ( moore   34000   it   47000 00)              ( miller   100000   management   90000 00)              ( johnson   80000   management   90000 00)              ( johnson   40000   marketing   39000 00)              ( smith   38000   marketing   39000 00)              ( smith   55000   sales   54000 00)              ( brown   53000   sales   54000 00)             transform lambda row  (row name  row salary  row department  row avg salary))      def test lag(self)                      compute difference employee salary next         highest salary employee department  return none         employee lowest salary                      qs   employee objects annotate(lag window(             expression lag(expression  salary   offset 1)              partition f( department )              order  f( salary ) asc()  f( name ) asc()           )) order by( department )         self assertquerysetequal(qs                ( williams   37000   accounting   none)              ( jenson   45000   accounting   37000)              ( jones   45000   accounting   45000)              ( adams   50000   accounting   45000)              ( moore   34000   it   none)              ( wilkinson   60000   it   34000)              ( johnson   80000   management   none)              ( miller   100000   management   80000)              ( smith   38000   marketing   none)              ( johnson   40000   marketing   38000)              ( brown   53000   sales   none)              ( smith   55000   sales   53000)             transform lambda row  (row name  row salary  row department  row lag))      def test first value(self)          qs   employee objects annotate(first value window(             expression firstvalue( salary )              partition f( department )              order f( hire date ) asc()          )) order by( department    hire date )         self assertquerysetequal(qs                ( jones   45000   accounting   datetime date(2005  11  1)  45000)              ( jenson   45000   accounting   datetime date(2008  4  1)  45000)              ( williams   37000   accounting   datetime date(2009  6  1)  45000)              ( adams   50000   accounting   datetime date(2013  7  1)  45000)              ( wilkinson   60000   it   datetime date(2011  3  1)  60000)              ( moore   34000   it   datetime date(2013  8  1)  60000)              ( miller   100000   management   datetime date(2005  6  1)  100000)              ( johnson   80000   management   datetime date(2005  7  1)  100000)              ( smith   38000   marketing   datetime date(2009  10  1)  38000)              ( johnson   40000   marketing   datetime date(2012  3  1)  38000)              ( smith   55000   sales   datetime date(2007  6  1)  55000)              ( brown   53000   sales   datetime date(2009  9  1)  55000)             lambda row  (row name  row salary  row department  row hire date  row first value))      def test last value(self)          qs   employee objects annotate(last value window(             expression lastvalue( hire date )              partition f( department )              order f( hire date ) asc()          ))         self assertquerysetequal(qs                ( adams    accounting   datetime date(2013  7  1)  50000  datetime date(2013  7  1))              ( jenson    accounting   datetime date(2008  4  1)  45000  datetime date(2008  4  1))              ( jones    accounting   datetime date(2005  11  1)  45000  datetime date(2005  11  1))              ( williams    accounting   datetime date(2009  6  1)  37000  datetime date(2009  6  1))              ( moore    it   datetime date(2013  8  1)  34000  datetime date(2013  8  1))              ( wilkinson    it   datetime date(2011  3  1)  60000  datetime date(2011  3  1))              ( miller    management   datetime date(2005  6  1)  100000  datetime date(2005  6  1))              ( johnson    management   datetime date(2005  7  1)  80000  datetime date(2005  7  1))              ( johnson    marketing   datetime date(2012  3  1)  40000  datetime date(2012  3  1))              ( smith    marketing   datetime date(2009  10  1)  38000  datetime date(2009  10  1))              ( brown    sales   datetime date(2009  9  1)  53000  datetime date(2009  9  1))              ( smith    sales   datetime date(2007  6  1)  55000  datetime date(2007  6  1))             transform lambda row  (row name  row department  row hire date  row salary  row last value)  ordered false)      def test function list values(self)          qs   employee objects annotate(lead window(             expression lead(expression  salary )              order  f( hire date ) asc()  f( name ) desc()               partition  department           )) values list( name    salary    department    hire date    lead )         self assertnotin( group by   str(qs query))         self assertsequenceequal(qs                ( jones   45000   accounting   datetime date(2005  11  1)  45000)              ( jenson   45000   accounting   datetime date(2008  4  1)  37000)              ( williams   37000   accounting   datetime date(2009  6  1)  50000)              ( adams   50000   accounting   datetime date(2013  7  1)  none)              ( wilkinson   60000   it   datetime date(2011  3  1)  34000)              ( moore   34000   it   datetime date(2013  8  1)  none)              ( miller   100000   management   datetime date(2005  6  1)  80000)              ( johnson   80000   management   datetime date(2005  7  1)  none)              ( smith   38000   marketing   datetime date(2009  10  1)  40000)              ( johnson   40000   marketing   datetime date(2012  3  1)  none)              ( smith   55000   sales   datetime date(2007  6  1)  53000)              ( brown   53000   sales   datetime date(2009  9  1)  none)           )      def test min department(self)             an alternative way specify query firstvalue             qs   employee objects annotate(min salary window(             expression min( salary )              partition f( department )              order  f( salary ) asc()  f( name ) asc()          )) order by( department    salary    name )         self assertquerysetequal(qs                ( williams    accounting   37000  37000)              ( jenson    accounting   45000  37000)              ( jones    accounting   45000  37000)              ( adams    accounting   50000  37000)              ( moore    it   34000  34000)              ( wilkinson    it   60000  34000)              ( johnson    management   80000  80000)              ( miller    management   100000  80000)              ( smith    marketing   38000  38000)              ( johnson    marketing   40000  38000)              ( brown    sales   53000  53000)              ( smith    sales   55000  53000)             lambda row  (row name  row department  row salary  row min salary))      def test max per year(self)                      find maximum salary awarded year         employee hired  regardless department                      qs   employee objects annotate(max salary year window(             expression max( salary )              order extractyear( hire date ) asc()              partition extractyear( hire date )         )) order by(extractyear( hire date )   salary )         self assertquerysetequal(qs                ( jones    accounting   45000  2005  100000)              ( johnson    management   80000  2005  100000)              ( miller    management   100000  2005  100000)              ( smith    sales   55000  2007  55000)              ( jenson    accounting   45000  2008  45000)              ( williams    accounting   37000  2009  53000)              ( smith    marketing   38000  2009  53000)              ( brown    sales   53000  2009  53000)              ( wilkinson    it   60000  2011  60000)              ( johnson    marketing   40000  2012  40000)              ( moore    it   34000  2013  50000)              ( adams    accounting   50000  2013  50000)             lambda row  (row name  row department  row salary  row hire date year  row max salary year))      def test cume dist(self)                      compute cumulative distribution employees based         salary increasing order  equal rank total number rows (12)                      qs   employee objects annotate(cume dist window(             expression cumedist()              order f( salary ) asc()          )) order by( salary    name )           round result cume dist oracle uses greater precision          self assertquerysetequal(qs                ( moore    it   34000  0 0833333333)              ( williams    accounting   37000  0 1666666667)              ( smith    marketing   38000  0 25)              ( johnson    marketing   40000  0 3333333333)              ( jenson    accounting   45000  0 5)              ( jones    accounting   45000  0 5)              ( adams    accounting   50000  0 5833333333)              ( brown    sales   53000  0 6666666667)              ( smith    sales   55000  0 75)              ( wilkinson    it   60000  0 8333333333)              ( johnson    management   80000  0 9166666667)              ( miller    management   100000  1)             lambda row  (row name  row department  row salary  round(row cume dist  10)))      def test nthvalue(self)          qs   employee objects annotate(             nth value window(expression nthvalue(                 expression  salary   nth 2)                  order  f( hire date ) asc()  f( name ) desc()                   partition f( department )              )         ) order by( department    hire date    name )         self assertquerysetequal(qs                ( jones    accounting   datetime date(2005  11  1)  45000  none)              ( jenson    accounting   datetime date(2008  4  1)  45000  45000)              ( williams    accounting   datetime date(2009  6  1)  37000  45000)              ( adams    accounting   datetime date(2013  7  1)  50000  45000)              ( wilkinson    it   datetime date(2011  3  1)  60000  none)              ( moore    it   datetime date(2013  8  1)  34000  34000)              ( miller    management   datetime date(2005  6  1)  100000  none)              ( johnson    management   datetime date(2005  7  1)  80000  80000)              ( smith    marketing   datetime date(2009  10  1)  38000  none)              ( johnson    marketing   datetime date(2012  3  1)  40000  40000)              ( smith    sales   datetime date(2007  6  1)  55000  none)              ( brown    sales   datetime date(2009  9  1)  53000  53000)             lambda row  (row name  row department  row hire date  row salary  row nth value))      def test lead(self)                      determine next person hired department makes          because dataset ambiguous  name also part         ordering clause  no default provided  none null         returned                      qs   employee objects annotate(lead window(             expression lead(expression  salary )              order  f( hire date ) asc()  f( name ) desc()               partition  department           )) order by( department )         self assertquerysetequal(qs                ( jones   45000   accounting   datetime date(2005  11  1)  45000)              ( jenson   45000   accounting   datetime date(2008  4  1)  37000)              ( williams   37000   accounting   datetime date(2009  6  1)  50000)              ( adams   50000   accounting   datetime date(2013  7  1)  none)              ( wilkinson   60000   it   datetime date(2011  3  1)  34000)              ( moore   34000   it   datetime date(2013  8  1)  none)              ( miller   100000   management   datetime date(2005  6  1)  80000)              ( johnson   80000   management   datetime date(2005  7  1)  none)              ( smith   38000   marketing   datetime date(2009  10  1)  40000)              ( johnson   40000   marketing   datetime date(2012  3  1)  none)              ( smith   55000   sales   datetime date(2007  6  1)  53000)              ( brown   53000   sales   datetime date(2009  9  1)  none)             transform lambda row  (row name  row salary  row department  row hire date  row lead))      def test lead offset(self)                      determine person hired someone makes  due         ambiguity  name also included ordering                      qs   employee objects annotate(lead window(             expression lead( salary   offset 2)              partition  department               order f( hire date ) asc()          ))         self assertquerysetequal(qs                ( jones   45000   accounting   datetime date(2005  11  1)  37000)              ( jenson   45000   accounting   datetime date(2008  4  1)  50000)              ( williams   37000   accounting   datetime date(2009  6  1)  none)              ( adams   50000   accounting   datetime date(2013  7  1)  none)              ( wilkinson   60000   it   datetime date(2011  3  1)  none)              ( moore   34000   it   datetime date(2013  8  1)  none)              ( johnson   80000   management   datetime date(2005  7  1)  none)              ( miller   100000   management   datetime date(2005  6  1)  none)              ( smith   38000   marketing   datetime date(2009  10  1)  none)              ( johnson   40000   marketing   datetime date(2012  3  1)  none)              ( smith   55000   sales   datetime date(2007  6  1)  none)              ( brown   53000   sales   datetime date(2009  9  1)  none)             transform lambda row  (row name  row salary  row department  row hire date  row lead)              ordered false         )      def test lead default(self)          qs   employee objects annotate(lead default window(             expression lead(expression  salary   offset 5  default 60000)              partition f( department )              order f( department ) asc()          ))         self assertequal(list(qs values list( lead default   flat true) distinct())   60000 )      def test ntile(self)                      compute group employees across entire company          based high salary  there twelve employees         divides evenly four groups                      qs   employee objects annotate(ntile window(             expression ntile(num buckets 4)              order f( salary ) desc()          )) order by( ntile     salary    name )         self assertquerysetequal(qs                ( miller    management   100000  1)              ( johnson    management   80000  1)              ( wilkinson    it   60000  1)              ( smith    sales   55000  2)              ( brown    sales   53000  2)              ( adams    accounting   50000  2)              ( jenson    accounting   45000  3)              ( jones    accounting   45000  3)              ( johnson    marketing   40000  3)              ( smith    marketing   38000  4)              ( williams    accounting   37000  4)              ( moore    it   34000  4)             lambda x  (x name  x department  x salary  x ntile))      def test percent rank(self)                      calculate percentage rank employees across entire         company based salary name (in case ambiguity)                      qs   employee objects annotate(percent rank window(             expression percentrank()              order  f( salary ) asc()  f( name ) asc()           )) order by( percent rank )           round account precision differences among databases          self assertquerysetequal(qs                ( moore    it   34000  0 0)              ( williams    accounting   37000  0 0909090909)              ( smith    marketing   38000  0 1818181818)              ( johnson    marketing   40000  0 2727272727)              ( jenson    accounting   45000  0 3636363636)              ( jones    accounting   45000  0 4545454545)              ( adams    accounting   50000  0 5454545455)              ( brown    sales   53000  0 6363636364)              ( smith    sales   55000  0 7272727273)              ( wilkinson    it   60000  0 8181818182)              ( johnson    management   80000  0 9090909091)              ( miller    management   100000  1 0)             transform lambda row  (row name  row department  row salary  round(row percent rank  10)))      def test nth returns null(self)                      find nth row data set  none returned since         fewer 20 rows test data                      qs   employee objects annotate(nth value window(             expression nthvalue( salary   nth 20)              order f( salary ) asc()         ))         self assertequal(list(qs values list( nth value   flat true) distinct())   none )      def test multiple partitioning(self)                      find maximum salary department people hired         year                      qs   employee objects annotate(max window(             expression max( salary )              partition  f( department )  extractyear(f( hire date ))           )) order by( department    hire date    name )         self assertquerysetequal(qs                ( jones   45000   accounting   datetime date(2005  11  1)  45000)              ( jenson   45000   accounting   datetime date(2008  4  1)  45000)              ( williams   37000   accounting   datetime date(2009  6  1)  37000)              ( adams   50000   accounting   datetime date(2013  7  1)  50000)              ( wilkinson   60000   it   datetime date(2011  3  1)  60000)              ( moore   34000   it   datetime date(2013  8  1)  34000)              ( miller   100000   management   datetime date(2005  6  1)  100000)              ( johnson   80000   management   datetime date(2005  7  1)  100000)              ( smith   38000   marketing   datetime date(2009  10  1)  38000)              ( johnson   40000   marketing   datetime date(2012  3  1)  40000)              ( smith   55000   sales   datetime date(2007  6  1)  55000)              ( brown   53000   sales   datetime date(2009  9  1)  53000)             transform lambda row  (row name  row salary  row department  row hire date  row max))      def test multiple ordering(self)                      accumulate salaries departments based hire date          if two people hired date department          ordering clause render different result people                      qs   employee objects annotate(sum window(             expression sum( salary )              partition  department               order  f( hire date ) asc()  f( name ) asc()           )) order by( department    sum )         self assertquerysetequal(qs                ( jones   45000   accounting   datetime date(2005  11  1)  45000)              ( jenson   45000   accounting   datetime date(2008  4  1)  90000)              ( williams   37000   accounting   datetime date(2009  6  1)  127000)              ( adams   50000   accounting   datetime date(2013  7  1)  177000)              ( wilkinson   60000   it   datetime date(2011  3  1)  60000)              ( moore   34000   it   datetime date(2013  8  1)  94000)              ( miller   100000   management   datetime date(2005  6  1)  100000)              ( johnson   80000   management   datetime date(2005  7  1)  180000)              ( smith   38000   marketing   datetime date(2009  10  1)  38000)              ( johnson   40000   marketing   datetime date(2012  3  1)  78000)              ( smith   55000   sales   datetime date(2007  6  1)  55000)              ( brown   53000   sales   datetime date(2009  9  1)  108000)             transform lambda row  (row name  row salary  row department  row hire date  row sum))       skipif(connection vendor     postgresql    n following preceding supported postgresql )     def test range n preceding following(self)          qs   employee objects annotate(sum window(             expression sum( salary )              order f( salary ) asc()              partition  department               frame valuerange(start  2  end 2)          ))         self assertin( range between 2 preceding and 2 following   str(qs query))         self assertquerysetequal(qs                ( williams   37000   accounting   datetime date(2009  6  1)  37000)              ( jones   45000   accounting   datetime date(2005  11  1)  90000)              ( jenson   45000   accounting   datetime date(2008  4  1)  90000)              ( adams   50000   accounting   datetime date(2013  7  1)  50000)              ( brown   53000   sales   datetime date(2009  9  1)  53000)              ( smith   55000   sales   datetime date(2007  6  1)  55000)              ( johnson   40000   marketing   datetime date(2012  3  1)  40000)              ( smith   38000   marketing   datetime date(2009  10  1)  38000)              ( wilkinson   60000   it   datetime date(2011  3  1)  60000)              ( moore   34000   it   datetime date(2013  8  1)  34000)              ( miller   100000   management   datetime date(2005  6  1)  100000)              ( johnson   80000   management   datetime date(2005  7  1)  80000)             transform lambda row  (row name  row salary  row department  row hire date  row sum)  ordered false)      def test range unbound(self)             a query range between unbounded preceding and unbounded following             qs   employee objects annotate(sum window(             expression sum( salary )              partition  department               order  f( hire date ) asc()  f( name ) asc()               frame valuerange(start none  end none)          )) order by( department    hire date    name )         self assertin( range between unbounded preceding and unbounded following   str(qs query))         self assertquerysetequal(qs                ( jones    accounting   45000  datetime date(2005  11  1)  177000)              ( jenson    accounting   45000  datetime date(2008  4  1)  177000)              ( williams    accounting   37000  datetime date(2009  6  1)  177000)              ( adams    accounting   50000  datetime date(2013  7  1)  177000)              ( wilkinson    it   60000  datetime date(2011  3  1)  94000)              ( moore    it   34000  datetime date(2013  8  1)  94000)              ( miller    management   100000  datetime date(2005  6  1)  180000)              ( johnson    management   80000  datetime date(2005  7  1)  180000)              ( smith    marketing   38000  datetime date(2009  10  1)  78000)              ( johnson    marketing   40000  datetime date(2012  3  1)  78000)              ( smith    sales   55000  datetime date(2007  6  1)  108000)              ( brown    sales   53000  datetime date(2009  9  1)  108000)             transform lambda row  (row name  row department  row salary  row hire date  row sum))      def test row range rank(self)                      a query rows between unbounded preceding and 3 following          the resulting sum sum three next (if exist)         previous rows according ordering clause                      qs   employee objects annotate(sum window(             expression sum( salary )              order  f( hire date ) asc()  f( name ) desc()               frame rowrange(start none  end 3)          )) order by( sum    hire date )         self assertin( rows between unbounded preceding and 3 following   str(qs query))         self assertquerysetequal(qs                ( miller   100000   management   datetime date(2005  6  1)  280000)              ( johnson   80000   management   datetime date(2005  7  1)  325000)              ( jones   45000   accounting   datetime date(2005  11  1)  362000)              ( smith   55000   sales   datetime date(2007  6  1)  415000)              ( jenson   45000   accounting   datetime date(2008  4  1)  453000)              ( williams   37000   accounting   datetime date(2009  6  1)  513000)              ( brown   53000   sales   datetime date(2009  9  1)  553000)              ( smith   38000   marketing   datetime date(2009  10  1)  603000)              ( wilkinson   60000   it   datetime date(2011  3  1)  637000)              ( johnson   40000   marketing   datetime date(2012  3  1)  637000)              ( adams   50000   accounting   datetime date(2013  7  1)  637000)              ( moore   34000   it   datetime date(2013  8  1)  637000)             transform lambda row  (row name  row salary  row department  row hire date  row sum))       skipunlessdbfeature( distinct fields )     def test distinct window function(self)                      window functions aggregates  hence query filter         duplicates may useful                      qs   employee objects annotate(             sum window(                 expression sum( salary )                  partition extractyear( hire date )                  order extractyear( hire date )             )              year extractyear( hire date )          ) values( year    sum ) distinct( year ) order by( year )         results                   year   2005   sum   225000     year   2007   sum   55000                 year   2008   sum   45000     year   2009   sum   128000                 year   2011   sum   60000     year   2012   sum   40000                 year   2013   sum   84000                     idx  val zip(range(len(results))  results)              self subtest(result val)                  self assertequal(qs idx   val)      def test fail update(self)             window expressions used update statement             msg    window expressions allowed query          self assertraisesmessage(fielderror  msg)              employee objects filter(department  management ) update(                 salary window(expression max( salary )  partition  department )              )      def test fail insert(self)             window expressions used insert statement        add default ordering consistent results across databases     round result cume dist oracle uses greater precision     round account precision differences among databases  ", "content": "import datetime\nfrom unittest import skipIf, skipUnless\n\nfrom django.core.exceptions import FieldError\nfrom django.db import NotSupportedError, connection\nfrom django.db.models import (\n    F, RowRange, Value, ValueRange, Window, WindowFrame,\n)\nfrom django.db.models.aggregates import Avg, Max, Min, Sum\nfrom django.db.models.functions import (\n    CumeDist, DenseRank, ExtractYear, FirstValue, Lag, LastValue, Lead,\n    NthValue, Ntile, PercentRank, Rank, RowNumber, Upper,\n)\nfrom django.test import SimpleTestCase, TestCase, skipUnlessDBFeature\n\nfrom .models import Employee\n\n\n@skipUnlessDBFeature('supports_over_clause')\nclass WindowFunctionTests(TestCase):\n    @classmethod\n    def setUpTestData(cls):\n        Employee.objects.bulk_create([\n            Employee(name=e[0], salary=e[1], department=e[2], hire_date=e[3])\n            for e in [\n                ('Jones', 45000, 'Accounting', datetime.datetime(2005, 11, 1)),\n                ('Williams', 37000, 'Accounting', datetime.datetime(2009, 6, 1)),\n                ('Jenson', 45000, 'Accounting', datetime.datetime(2008, 4, 1)),\n                ('Adams', 50000, 'Accounting', datetime.datetime(2013, 7, 1)),\n                ('Smith', 55000, 'Sales', datetime.datetime(2007, 6, 1)),\n                ('Brown', 53000, 'Sales', datetime.datetime(2009, 9, 1)),\n                ('Johnson', 40000, 'Marketing', datetime.datetime(2012, 3, 1)),\n                ('Smith', 38000, 'Marketing', datetime.datetime(2009, 10, 1)),\n                ('Wilkinson', 60000, 'IT', datetime.datetime(2011, 3, 1)),\n                ('Moore', 34000, 'IT', datetime.datetime(2013, 8, 1)),\n                ('Miller', 100000, 'Management', datetime.datetime(2005, 6, 1)),\n                ('Johnson', 80000, 'Management', datetime.datetime(2005, 7, 1)),\n            ]\n        ])\n\n    def test_dense_rank(self):\n        qs = Employee.objects.annotate(rank=Window(\n            expression=DenseRank(),\n            order_by=ExtractYear(F('hire_date')).asc(),\n        ))\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 1),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 1),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 1),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 2),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 3),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 4),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 4),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 4),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 5),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 6),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 7),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 7),\n        ], lambda entry: (entry.name, entry.salary, entry.department, entry.hire_date, entry.rank), ordered=False)\n\n    def test_department_salary(self):\n        qs = Employee.objects.annotate(department_sum=Window(\n            expression=Sum('salary'),\n            partition_by=F('department'),\n            order_by=[F('hire_date').asc()],\n        )).order_by('department', 'department_sum')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 'Accounting', 45000, 45000),\n            ('Jenson', 'Accounting', 45000, 90000),\n            ('Williams', 'Accounting', 37000, 127000),\n            ('Adams', 'Accounting', 50000, 177000),\n            ('Wilkinson', 'IT', 60000, 60000),\n            ('Moore', 'IT', 34000, 94000),\n            ('Miller', 'Management', 100000, 100000),\n            ('Johnson', 'Management', 80000, 180000),\n            ('Smith', 'Marketing', 38000, 38000),\n            ('Johnson', 'Marketing', 40000, 78000),\n            ('Smith', 'Sales', 55000, 55000),\n            ('Brown', 'Sales', 53000, 108000),\n        ], lambda entry: (entry.name, entry.department, entry.salary, entry.department_sum))\n\n    def test_rank(self):\n        \"\"\"\n        Rank the employees based on the year they're were hired. Since there\n        are multiple employees hired in different years, this will contain\n        gaps.\n        \"\"\"\n        qs = Employee.objects.annotate(rank=Window(\n            expression=Rank(),\n            order_by=ExtractYear(F('hire_date')).asc(),\n        ))\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 1),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 1),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 1),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 4),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 5),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 6),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 6),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 6),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 9),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 10),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 11),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 11),\n        ], lambda entry: (entry.name, entry.salary, entry.department, entry.hire_date, entry.rank), ordered=False)\n\n    def test_row_number(self):\n        \"\"\"\n        The row number window function computes the number based on the order\n        in which the tuples were inserted. Depending on the backend,\n\n        Oracle requires an ordering-clause in the Window expression.\n        \"\"\"\n        qs = Employee.objects.annotate(row_number=Window(\n            expression=RowNumber(),\n            order_by=F('pk').asc(),\n        )).order_by('pk')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 'Accounting', 1),\n            ('Williams', 'Accounting', 2),\n            ('Jenson', 'Accounting', 3),\n            ('Adams', 'Accounting', 4),\n            ('Smith', 'Sales', 5),\n            ('Brown', 'Sales', 6),\n            ('Johnson', 'Marketing', 7),\n            ('Smith', 'Marketing', 8),\n            ('Wilkinson', 'IT', 9),\n            ('Moore', 'IT', 10),\n            ('Miller', 'Management', 11),\n            ('Johnson', 'Management', 12),\n        ], lambda entry: (entry.name, entry.department, entry.row_number))\n\n    @skipIf(connection.vendor == 'oracle', \"Oracle requires ORDER BY in row_number, ANSI:SQL doesn't\")\n    def test_row_number_no_ordering(self):\n        \"\"\"\n        The row number window function computes the number based on the order\n        in which the tuples were inserted.\n        \"\"\"\n        # Add a default ordering for consistent results across databases.\n        qs = Employee.objects.annotate(row_number=Window(\n            expression=RowNumber(),\n        )).order_by('pk')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 'Accounting', 1),\n            ('Williams', 'Accounting', 2),\n            ('Jenson', 'Accounting', 3),\n            ('Adams', 'Accounting', 4),\n            ('Smith', 'Sales', 5),\n            ('Brown', 'Sales', 6),\n            ('Johnson', 'Marketing', 7),\n            ('Smith', 'Marketing', 8),\n            ('Wilkinson', 'IT', 9),\n            ('Moore', 'IT', 10),\n            ('Miller', 'Management', 11),\n            ('Johnson', 'Management', 12),\n        ], lambda entry: (entry.name, entry.department, entry.row_number))\n\n    def test_avg_salary_department(self):\n        qs = Employee.objects.annotate(avg_salary=Window(\n            expression=Avg('salary'),\n            order_by=F('department').asc(),\n            partition_by='department',\n        )).order_by('department', '-salary', 'name')\n        self.assertQuerysetEqual(qs, [\n            ('Adams', 50000, 'Accounting', 44250.00),\n            ('Jenson', 45000, 'Accounting', 44250.00),\n            ('Jones', 45000, 'Accounting', 44250.00),\n            ('Williams', 37000, 'Accounting', 44250.00),\n            ('Wilkinson', 60000, 'IT', 47000.00),\n            ('Moore', 34000, 'IT', 47000.00),\n            ('Miller', 100000, 'Management', 90000.00),\n            ('Johnson', 80000, 'Management', 90000.00),\n            ('Johnson', 40000, 'Marketing', 39000.00),\n            ('Smith', 38000, 'Marketing', 39000.00),\n            ('Smith', 55000, 'Sales', 54000.00),\n            ('Brown', 53000, 'Sales', 54000.00),\n        ], transform=lambda row: (row.name, row.salary, row.department, row.avg_salary))\n\n    def test_lag(self):\n        \"\"\"\n        Compute the difference between an employee's salary and the next\n        highest salary in the employee's department. Return None if the\n        employee has the lowest salary.\n        \"\"\"\n        qs = Employee.objects.annotate(lag=Window(\n            expression=Lag(expression='salary', offset=1),\n            partition_by=F('department'),\n            order_by=[F('salary').asc(), F('name').asc()],\n        )).order_by('department')\n        self.assertQuerysetEqual(qs, [\n            ('Williams', 37000, 'Accounting', None),\n            ('Jenson', 45000, 'Accounting', 37000),\n            ('Jones', 45000, 'Accounting', 45000),\n            ('Adams', 50000, 'Accounting', 45000),\n            ('Moore', 34000, 'IT', None),\n            ('Wilkinson', 60000, 'IT', 34000),\n            ('Johnson', 80000, 'Management', None),\n            ('Miller', 100000, 'Management', 80000),\n            ('Smith', 38000, 'Marketing', None),\n            ('Johnson', 40000, 'Marketing', 38000),\n            ('Brown', 53000, 'Sales', None),\n            ('Smith', 55000, 'Sales', 53000),\n        ], transform=lambda row: (row.name, row.salary, row.department, row.lag))\n\n    def test_first_value(self):\n        qs = Employee.objects.annotate(first_value=Window(\n            expression=FirstValue('salary'),\n            partition_by=F('department'),\n            order_by=F('hire_date').asc(),\n        )).order_by('department', 'hire_date')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 45000),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 45000),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 45000),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 60000),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 60000),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 100000),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 100000),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 38000),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 38000),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 55000),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 55000),\n        ], lambda row: (row.name, row.salary, row.department, row.hire_date, row.first_value))\n\n    def test_last_value(self):\n        qs = Employee.objects.annotate(last_value=Window(\n            expression=LastValue('hire_date'),\n            partition_by=F('department'),\n            order_by=F('hire_date').asc(),\n        ))\n        self.assertQuerysetEqual(qs, [\n            ('Adams', 'Accounting', datetime.date(2013, 7, 1), 50000, datetime.date(2013, 7, 1)),\n            ('Jenson', 'Accounting', datetime.date(2008, 4, 1), 45000, datetime.date(2008, 4, 1)),\n            ('Jones', 'Accounting', datetime.date(2005, 11, 1), 45000, datetime.date(2005, 11, 1)),\n            ('Williams', 'Accounting', datetime.date(2009, 6, 1), 37000, datetime.date(2009, 6, 1)),\n            ('Moore', 'IT', datetime.date(2013, 8, 1), 34000, datetime.date(2013, 8, 1)),\n            ('Wilkinson', 'IT', datetime.date(2011, 3, 1), 60000, datetime.date(2011, 3, 1)),\n            ('Miller', 'Management', datetime.date(2005, 6, 1), 100000, datetime.date(2005, 6, 1)),\n            ('Johnson', 'Management', datetime.date(2005, 7, 1), 80000, datetime.date(2005, 7, 1)),\n            ('Johnson', 'Marketing', datetime.date(2012, 3, 1), 40000, datetime.date(2012, 3, 1)),\n            ('Smith', 'Marketing', datetime.date(2009, 10, 1), 38000, datetime.date(2009, 10, 1)),\n            ('Brown', 'Sales', datetime.date(2009, 9, 1), 53000, datetime.date(2009, 9, 1)),\n            ('Smith', 'Sales', datetime.date(2007, 6, 1), 55000, datetime.date(2007, 6, 1)),\n        ], transform=lambda row: (row.name, row.department, row.hire_date, row.salary, row.last_value), ordered=False)\n\n    def test_function_list_of_values(self):\n        qs = Employee.objects.annotate(lead=Window(\n            expression=Lead(expression='salary'),\n            order_by=[F('hire_date').asc(), F('name').desc()],\n            partition_by='department',\n        )).values_list('name', 'salary', 'department', 'hire_date', 'lead')\n        self.assertNotIn('GROUP BY', str(qs.query))\n        self.assertSequenceEqual(qs, [\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 37000),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 50000),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), None),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 34000),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), None),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 80000),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), None),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 40000),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), None),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 53000),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), None),\n        ])\n\n    def test_min_department(self):\n        \"\"\"An alternative way to specify a query for FirstValue.\"\"\"\n        qs = Employee.objects.annotate(min_salary=Window(\n            expression=Min('salary'),\n            partition_by=F('department'),\n            order_by=[F('salary').asc(), F('name').asc()]\n        )).order_by('department', 'salary', 'name')\n        self.assertQuerysetEqual(qs, [\n            ('Williams', 'Accounting', 37000, 37000),\n            ('Jenson', 'Accounting', 45000, 37000),\n            ('Jones', 'Accounting', 45000, 37000),\n            ('Adams', 'Accounting', 50000, 37000),\n            ('Moore', 'IT', 34000, 34000),\n            ('Wilkinson', 'IT', 60000, 34000),\n            ('Johnson', 'Management', 80000, 80000),\n            ('Miller', 'Management', 100000, 80000),\n            ('Smith', 'Marketing', 38000, 38000),\n            ('Johnson', 'Marketing', 40000, 38000),\n            ('Brown', 'Sales', 53000, 53000),\n            ('Smith', 'Sales', 55000, 53000),\n        ], lambda row: (row.name, row.department, row.salary, row.min_salary))\n\n    def test_max_per_year(self):\n        \"\"\"\n        Find the maximum salary awarded in the same year as the\n        employee was hired, regardless of the department.\n        \"\"\"\n        qs = Employee.objects.annotate(max_salary_year=Window(\n            expression=Max('salary'),\n            order_by=ExtractYear('hire_date').asc(),\n            partition_by=ExtractYear('hire_date')\n        )).order_by(ExtractYear('hire_date'), 'salary')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 'Accounting', 45000, 2005, 100000),\n            ('Johnson', 'Management', 80000, 2005, 100000),\n            ('Miller', 'Management', 100000, 2005, 100000),\n            ('Smith', 'Sales', 55000, 2007, 55000),\n            ('Jenson', 'Accounting', 45000, 2008, 45000),\n            ('Williams', 'Accounting', 37000, 2009, 53000),\n            ('Smith', 'Marketing', 38000, 2009, 53000),\n            ('Brown', 'Sales', 53000, 2009, 53000),\n            ('Wilkinson', 'IT', 60000, 2011, 60000),\n            ('Johnson', 'Marketing', 40000, 2012, 40000),\n            ('Moore', 'IT', 34000, 2013, 50000),\n            ('Adams', 'Accounting', 50000, 2013, 50000),\n        ], lambda row: (row.name, row.department, row.salary, row.hire_date.year, row.max_salary_year))\n\n    def test_cume_dist(self):\n        \"\"\"\n        Compute the cumulative distribution for the employees based on the\n        salary in increasing order. Equal to rank/total number of rows (12).\n        \"\"\"\n        qs = Employee.objects.annotate(cume_dist=Window(\n            expression=CumeDist(),\n            order_by=F('salary').asc(),\n        )).order_by('salary', 'name')\n        # Round result of cume_dist because Oracle uses greater precision.\n        self.assertQuerysetEqual(qs, [\n            ('Moore', 'IT', 34000, 0.0833333333),\n            ('Williams', 'Accounting', 37000, 0.1666666667),\n            ('Smith', 'Marketing', 38000, 0.25),\n            ('Johnson', 'Marketing', 40000, 0.3333333333),\n            ('Jenson', 'Accounting', 45000, 0.5),\n            ('Jones', 'Accounting', 45000, 0.5),\n            ('Adams', 'Accounting', 50000, 0.5833333333),\n            ('Brown', 'Sales', 53000, 0.6666666667),\n            ('Smith', 'Sales', 55000, 0.75),\n            ('Wilkinson', 'IT', 60000, 0.8333333333),\n            ('Johnson', 'Management', 80000, 0.9166666667),\n            ('Miller', 'Management', 100000, 1),\n        ], lambda row: (row.name, row.department, row.salary, round(row.cume_dist, 10)))\n\n    def test_nthvalue(self):\n        qs = Employee.objects.annotate(\n            nth_value=Window(expression=NthValue(\n                expression='salary', nth=2),\n                order_by=[F('hire_date').asc(), F('name').desc()],\n                partition_by=F('department'),\n            )\n        ).order_by('department', 'hire_date', 'name')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 'Accounting', datetime.date(2005, 11, 1), 45000, None),\n            ('Jenson', 'Accounting', datetime.date(2008, 4, 1), 45000, 45000),\n            ('Williams', 'Accounting', datetime.date(2009, 6, 1), 37000, 45000),\n            ('Adams', 'Accounting', datetime.date(2013, 7, 1), 50000, 45000),\n            ('Wilkinson', 'IT', datetime.date(2011, 3, 1), 60000, None),\n            ('Moore', 'IT', datetime.date(2013, 8, 1), 34000, 34000),\n            ('Miller', 'Management', datetime.date(2005, 6, 1), 100000, None),\n            ('Johnson', 'Management', datetime.date(2005, 7, 1), 80000, 80000),\n            ('Smith', 'Marketing', datetime.date(2009, 10, 1), 38000, None),\n            ('Johnson', 'Marketing', datetime.date(2012, 3, 1), 40000, 40000),\n            ('Smith', 'Sales', datetime.date(2007, 6, 1), 55000, None),\n            ('Brown', 'Sales', datetime.date(2009, 9, 1), 53000, 53000),\n        ], lambda row: (row.name, row.department, row.hire_date, row.salary, row.nth_value))\n\n    def test_lead(self):\n        \"\"\"\n        Determine what the next person hired in the same department makes.\n        Because the dataset is ambiguous, the name is also part of the\n        ordering clause. No default is provided, so None/NULL should be\n        returned.\n        \"\"\"\n        qs = Employee.objects.annotate(lead=Window(\n            expression=Lead(expression='salary'),\n            order_by=[F('hire_date').asc(), F('name').desc()],\n            partition_by='department',\n        )).order_by('department')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 37000),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 50000),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), None),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 34000),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), None),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 80000),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), None),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 40000),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), None),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 53000),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), None),\n        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.lead))\n\n    def test_lead_offset(self):\n        \"\"\"\n        Determine what the person hired after someone makes. Due to\n        ambiguity, the name is also included in the ordering.\n        \"\"\"\n        qs = Employee.objects.annotate(lead=Window(\n            expression=Lead('salary', offset=2),\n            partition_by='department',\n            order_by=F('hire_date').asc(),\n        ))\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 37000),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 50000),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), None),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), None),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), None),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), None),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), None),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), None),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), None),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), None),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), None),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), None),\n        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.lead),\n            ordered=False\n        )\n\n    def test_lead_default(self):\n        qs = Employee.objects.annotate(lead_default=Window(\n            expression=Lead(expression='salary', offset=5, default=60000),\n            partition_by=F('department'),\n            order_by=F('department').asc(),\n        ))\n        self.assertEqual(list(qs.values_list('lead_default', flat=True).distinct()), [60000])\n\n    def test_ntile(self):\n        \"\"\"\n        Compute the group for each of the employees across the entire company,\n        based on how high the salary is for them. There are twelve employees\n        so it divides evenly into four groups.\n        \"\"\"\n        qs = Employee.objects.annotate(ntile=Window(\n            expression=Ntile(num_buckets=4),\n            order_by=F('salary').desc(),\n        )).order_by('ntile', '-salary', 'name')\n        self.assertQuerysetEqual(qs, [\n            ('Miller', 'Management', 100000, 1),\n            ('Johnson', 'Management', 80000, 1),\n            ('Wilkinson', 'IT', 60000, 1),\n            ('Smith', 'Sales', 55000, 2),\n            ('Brown', 'Sales', 53000, 2),\n            ('Adams', 'Accounting', 50000, 2),\n            ('Jenson', 'Accounting', 45000, 3),\n            ('Jones', 'Accounting', 45000, 3),\n            ('Johnson', 'Marketing', 40000, 3),\n            ('Smith', 'Marketing', 38000, 4),\n            ('Williams', 'Accounting', 37000, 4),\n            ('Moore', 'IT', 34000, 4),\n        ], lambda x: (x.name, x.department, x.salary, x.ntile))\n\n    def test_percent_rank(self):\n        \"\"\"\n        Calculate the percentage rank of the employees across the entire\n        company based on salary and name (in case of ambiguity).\n        \"\"\"\n        qs = Employee.objects.annotate(percent_rank=Window(\n            expression=PercentRank(),\n            order_by=[F('salary').asc(), F('name').asc()],\n        )).order_by('percent_rank')\n        # Round to account for precision differences among databases.\n        self.assertQuerysetEqual(qs, [\n            ('Moore', 'IT', 34000, 0.0),\n            ('Williams', 'Accounting', 37000, 0.0909090909),\n            ('Smith', 'Marketing', 38000, 0.1818181818),\n            ('Johnson', 'Marketing', 40000, 0.2727272727),\n            ('Jenson', 'Accounting', 45000, 0.3636363636),\n            ('Jones', 'Accounting', 45000, 0.4545454545),\n            ('Adams', 'Accounting', 50000, 0.5454545455),\n            ('Brown', 'Sales', 53000, 0.6363636364),\n            ('Smith', 'Sales', 55000, 0.7272727273),\n            ('Wilkinson', 'IT', 60000, 0.8181818182),\n            ('Johnson', 'Management', 80000, 0.9090909091),\n            ('Miller', 'Management', 100000, 1.0),\n        ], transform=lambda row: (row.name, row.department, row.salary, round(row.percent_rank, 10)))\n\n    def test_nth_returns_null(self):\n        \"\"\"\n        Find the nth row of the data set. None is returned since there are\n        fewer than 20 rows in the test data.\n        \"\"\"\n        qs = Employee.objects.annotate(nth_value=Window(\n            expression=NthValue('salary', nth=20),\n            order_by=F('salary').asc()\n        ))\n        self.assertEqual(list(qs.values_list('nth_value', flat=True).distinct()), [None])\n\n    def test_multiple_partitioning(self):\n        \"\"\"\n        Find the maximum salary for each department for people hired in the\n        same year.\n        \"\"\"\n        qs = Employee.objects.annotate(max=Window(\n            expression=Max('salary'),\n            partition_by=[F('department'), ExtractYear(F('hire_date'))],\n        )).order_by('department', 'hire_date', 'name')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 45000),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 37000),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 50000),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 60000),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 34000),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 100000),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 100000),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 38000),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 40000),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 55000),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 53000),\n        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.max))\n\n    def test_multiple_ordering(self):\n        \"\"\"\n        Accumulate the salaries over the departments based on hire_date.\n        If two people were hired on the same date in the same department, the\n        ordering clause will render a different result for those people.\n        \"\"\"\n        qs = Employee.objects.annotate(sum=Window(\n            expression=Sum('salary'),\n            partition_by='department',\n            order_by=[F('hire_date').asc(), F('name').asc()],\n        )).order_by('department', 'sum')\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 90000),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 127000),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 177000),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 60000),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 94000),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 100000),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 180000),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 38000),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 78000),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 55000),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 108000),\n        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.sum))\n\n    @skipIf(connection.vendor == 'postgresql', 'n following/preceding not supported by PostgreSQL')\n    def test_range_n_preceding_and_following(self):\n        qs = Employee.objects.annotate(sum=Window(\n            expression=Sum('salary'),\n            order_by=F('salary').asc(),\n            partition_by='department',\n            frame=ValueRange(start=-2, end=2),\n        ))\n        self.assertIn('RANGE BETWEEN 2 PRECEDING AND 2 FOLLOWING', str(qs.query))\n        self.assertQuerysetEqual(qs, [\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 37000),\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 90000),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 90000),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 50000),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 53000),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 55000),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 40000),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 38000),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 60000),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 34000),\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 100000),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 80000),\n        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.sum), ordered=False)\n\n    def test_range_unbound(self):\n        \"\"\"A query with RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING.\"\"\"\n        qs = Employee.objects.annotate(sum=Window(\n            expression=Sum('salary'),\n            partition_by='department',\n            order_by=[F('hire_date').asc(), F('name').asc()],\n            frame=ValueRange(start=None, end=None),\n        )).order_by('department', 'hire_date', 'name')\n        self.assertIn('RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING', str(qs.query))\n        self.assertQuerysetEqual(qs, [\n            ('Jones', 'Accounting', 45000, datetime.date(2005, 11, 1), 177000),\n            ('Jenson', 'Accounting', 45000, datetime.date(2008, 4, 1), 177000),\n            ('Williams', 'Accounting', 37000, datetime.date(2009, 6, 1), 177000),\n            ('Adams', 'Accounting', 50000, datetime.date(2013, 7, 1), 177000),\n            ('Wilkinson', 'IT', 60000, datetime.date(2011, 3, 1), 94000),\n            ('Moore', 'IT', 34000, datetime.date(2013, 8, 1), 94000),\n            ('Miller', 'Management', 100000, datetime.date(2005, 6, 1), 180000),\n            ('Johnson', 'Management', 80000, datetime.date(2005, 7, 1), 180000),\n            ('Smith', 'Marketing', 38000, datetime.date(2009, 10, 1), 78000),\n            ('Johnson', 'Marketing', 40000, datetime.date(2012, 3, 1), 78000),\n            ('Smith', 'Sales', 55000, datetime.date(2007, 6, 1), 108000),\n            ('Brown', 'Sales', 53000, datetime.date(2009, 9, 1), 108000),\n        ], transform=lambda row: (row.name, row.department, row.salary, row.hire_date, row.sum))\n\n    def test_row_range_rank(self):\n        \"\"\"\n        A query with ROWS BETWEEN UNBOUNDED PRECEDING AND 3 FOLLOWING.\n        The resulting sum is the sum of the three next (if they exist) and all\n        previous rows according to the ordering clause.\n        \"\"\"\n        qs = Employee.objects.annotate(sum=Window(\n            expression=Sum('salary'),\n            order_by=[F('hire_date').asc(), F('name').desc()],\n            frame=RowRange(start=None, end=3),\n        )).order_by('sum', 'hire_date')\n        self.assertIn('ROWS BETWEEN UNBOUNDED PRECEDING AND 3 FOLLOWING', str(qs.query))\n        self.assertQuerysetEqual(qs, [\n            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 280000),\n            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 325000),\n            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 362000),\n            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 415000),\n            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 453000),\n            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 513000),\n            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 553000),\n            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 603000),\n            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 637000),\n            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 637000),\n            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 637000),\n            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 637000),\n        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.sum))\n\n    @skipUnlessDBFeature('can_distinct_on_fields')\n    def test_distinct_window_function(self):\n        \"\"\"\n        Window functions are not aggregates, and hence a query to filter out\n        duplicates may be useful.\n        \"\"\"\n        qs = Employee.objects.annotate(\n            sum=Window(\n                expression=Sum('salary'),\n                partition_by=ExtractYear('hire_date'),\n                order_by=ExtractYear('hire_date')\n            ),\n            year=ExtractYear('hire_date'),\n        ).values('year', 'sum').distinct('year').order_by('year')\n        results = [\n            {'year': 2005, 'sum': 225000}, {'year': 2007, 'sum': 55000},\n            {'year': 2008, 'sum': 45000}, {'year': 2009, 'sum': 128000},\n            {'year': 2011, 'sum': 60000}, {'year': 2012, 'sum': 40000},\n            {'year': 2013, 'sum': 84000},\n        ]\n        for idx, val in zip(range(len(results)), results):\n            with self.subTest(result=val):\n                self.assertEqual(qs[idx], val)\n\n    def test_fail_update(self):\n        \"\"\"Window expressions can't be used in an UPDATE statement.\"\"\"\n        msg = 'Window expressions are not allowed in this query'\n        with self.assertRaisesMessage(FieldError, msg):\n            Employee.objects.filter(department='Management').update(\n                salary=Window(expression=Max('salary'), partition_by='department'),\n            )\n\n    def test_fail_insert(self):\n        \"\"\"Window expressions can't be used in an INSERT statement.\"\"\"\n        msg = 'Window expressions are not allowed in this query'\n        with self.assertRaisesMessage(FieldError, msg):\n            Employee.objects.create(\n                name='Jameson', department='Management', hire_date=datetime.date(2007, 7, 1),\n                salary=Window(expression=Sum(Value(10000), order_by=F('pk').asc())),\n            )\n\n    def test_window_expression_within_subquery(self):\n        subquery_qs = Employee.objects.annotate(\n            highest=Window(FirstValue('id'), partition_by=F('department'), order_by=F('salary').desc())\n        ).values('highest')\n        highest_salary = Employee.objects.filter(pk__in=subquery_qs)\n        self.assertSequenceEqual(highest_salary.values('department', 'salary'), [\n            {'department': 'Accounting', 'salary': 50000},\n            {'department': 'Sales', 'salary': 55000},\n            {'department': 'Marketing', 'salary': 40000},\n            {'department': 'IT', 'salary': 60000},\n            {'department': 'Management', 'salary': 100000}\n        ])\n\n    def test_invalid_start_value_range(self):\n        msg = \"start argument must be a negative integer, zero, or None, but got '3'.\"\n        with self.assertRaisesMessage(ValueError, msg):\n            list(Employee.objects.annotate(test=Window(\n                expression=Sum('salary'),\n                order_by=F('hire_date').asc(),\n                frame=ValueRange(start=3),\n            )))\n\n    def test_invalid_end_value_range(self):\n        msg = \"end argument must be a positive integer, zero, or None, but got '-3'.\"\n        with self.assertRaisesMessage(ValueError, msg):\n            list(Employee.objects.annotate(test=Window(\n                expression=Sum('salary'),\n                order_by=F('hire_date').asc(),\n                frame=ValueRange(end=-3),\n            )))\n\n    def test_invalid_type_end_value_range(self):\n        msg = \"end argument must be a positive integer, zero, or None, but got 'a'.\"\n        with self.assertRaisesMessage(ValueError, msg):\n            list(Employee.objects.annotate(test=Window(\n                expression=Sum('salary'),\n                order_by=F('hire_date').asc(),\n                frame=ValueRange(end='a'),\n            )))\n\n    def test_invalid_type_start_value_range(self):\n        msg = \"start argument must be a negative integer, zero, or None, but got 'a'.\"\n        with self.assertRaisesMessage(ValueError, msg):\n            list(Employee.objects.annotate(test=Window(\n                expression=Sum('salary'),\n                frame=ValueRange(start='a'),\n            )))\n\n    def test_invalid_type_end_row_range(self):\n        msg = \"end argument must be a positive integer, zero, or None, but got 'a'.\"\n        with self.assertRaisesMessage(ValueError, msg):\n            list(Employee.objects.annotate(test=Window(\n                expression=Sum('salary'),\n                frame=RowRange(end='a'),\n            )))\n\n    @skipUnless(connection.vendor == 'postgresql', 'Frame construction not allowed on PostgreSQL')\n    def test_postgresql_illegal_range_frame_start(self):\n        msg = 'PostgreSQL only supports UNBOUNDED together with PRECEDING and FOLLOWING.'\n        with self.assertRaisesMessage(NotSupportedError, msg):\n            list(Employee.objects.annotate(test=Window(\n                expression=Sum('salary'),\n                order_by=F('hire_date').asc(),\n                frame=ValueRange(start=-1),\n            )))\n\n    @skipUnless(connection.vendor == 'postgresql', 'Frame construction not allowed on PostgreSQL')\n    def test_postgresql_illegal_range_frame_end(self):\n        msg = 'PostgreSQL only supports UNBOUNDED together with PRECEDING and FOLLOWING.'\n        with self.assertRaisesMessage(NotSupportedError, msg):\n            list(Employee.objects.annotate(test=Window(\n                expression=Sum('salary'),\n                order_by=F('hire_date').asc(),\n                frame=ValueRange(end=1),\n            )))\n\n    def test_invalid_type_start_row_range(self):\n        msg = \"start argument must be a negative integer, zero, or None, but got 'a'.\"\n        with self.assertRaisesMessage(ValueError, msg):\n            list(Employee.objects.annotate(test=Window(\n                expression=Sum('salary'),\n                order_by=F('hire_date').asc(),\n                frame=RowRange(start='a'),\n            )))\n\n\nclass NonQueryWindowTests(SimpleTestCase):\n    def test_window_repr(self):\n        self.assertEqual(\n            repr(Window(expression=Sum('salary'), partition_by='department')),\n            '<Window: Sum(F(salary)) OVER (PARTITION BY F(department))>'\n        )\n        self.assertEqual(\n            repr(Window(expression=Avg('salary'), order_by=F('department').asc())),\n            '<Window: Avg(F(salary)) OVER (ORDER BY OrderBy(F(department), descending=False))>'\n        )\n\n    def test_window_frame_repr(self):\n        self.assertEqual(\n            repr(RowRange(start=-1)),\n            '<RowRange: ROWS BETWEEN 1 PRECEDING AND UNBOUNDED FOLLOWING>'\n        )\n        self.assertEqual(\n            repr(ValueRange(start=None, end=1)),\n            '<ValueRange: RANGE BETWEEN UNBOUNDED PRECEDING AND 1 FOLLOWING>'\n        )\n        self.assertEqual(\n            repr(ValueRange(start=0, end=0)),\n            '<ValueRange: RANGE BETWEEN CURRENT ROW AND CURRENT ROW>'\n        )\n        self.assertEqual(\n            repr(RowRange(start=0, end=0)),\n            '<RowRange: ROWS BETWEEN CURRENT ROW AND CURRENT ROW>'\n        )\n\n    def test_empty_group_by_cols(self):\n        window = Window(expression=Sum('pk'))\n        self.assertEqual(window.get_group_by_cols(), [])\n        self.assertFalse(window.contains_aggregate)\n\n    def test_frame_empty_group_by_cols(self):\n        frame = WindowFrame()\n        self.assertEqual(frame.get_group_by_cols(), [])\n\n    def test_frame_window_frame_notimplemented(self):\n        frame = WindowFrame()\n        msg = 'Subclasses must implement window_frame_start_end().'\n        with self.assertRaisesMessage(NotImplementedError, msg):\n            frame.window_frame_start_end(None, None, None)\n\n    def test_invalid_filter(self):\n        msg = 'Window is disallowed in the filter clause'\n        with self.assertRaisesMessage(NotSupportedError, msg):\n            Employee.objects.annotate(dense_rank=Window(expression=DenseRank())).filter(dense_rank__gte=1)\n\n    def test_invalid_order_by(self):\n        msg = 'order_by must be either an Expression or a sequence of expressions'\n        with self.assertRaisesMessage(ValueError, msg):\n            Window(expression=Sum('power'), order_by='-horse')\n\n    def test_invalid_source_expression(self):\n        msg = \"Expression 'Upper' isn't compatible with OVER clauses.\"\n        with self.assertRaisesMessage(ValueError, msg):\n            Window(expression=Upper('name'))\n", "description": "The Web framework for perfectionists with deadlines.", "file_name": "tests.py", "id": "ef0d5e78aae799e9c46a08673eabc7f3", "language": "Python", "project_name": "django", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/django-django/django-django-274e3e2/tests/expressions_window/tests.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:39:10Z", "url": "https://github.com/django/django", "wiki": false}