{"author": "Valloric", "code": " Copyright (C) 2011, 2012, 2013  Google Inc.\n\n This file is part of YouCompleteMe.\n\n YouCompleteMe is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n YouCompleteMe is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import unicode_literals\nfrom __future__ import print_function\nfrom __future__ import division\nfrom __future__ import absolute_import\n Not installing aliases from python-future; it's unreliable and slow.\nfrom builtins import *   noqa\n\nimport vim\nfrom ycm import vimsupport\nfrom ycmd import utils\nfrom ycmd.completers.completer import Completer\nfrom ycm.client.base_request import BaseRequest, HandleServerException\n\nOMNIFUNC_RETURNED_BAD_VALUE = 'Omnifunc returned bad value to YCM!'\nOMNIFUNC_NOT_LIST = ( 'Omnifunc did not return a list or a dict with a \"words\" '\n                     ' list when expected.' )\n\n\nclass OmniCompleter( Completer ):\n  def __init__( self, user_options ):\n    super( OmniCompleter, self ).__init__( user_options )\n    self._omnifunc = None\n\n\n  def SupportedFiletypes( self ):\n    return []\n\n\n  def ShouldUseCache( self ):\n    return bool( self.user_options[ 'cache_omnifunc' ] )\n\n\n  def ShouldUseNow( self, request_data ):\n    self._omnifunc = utils.ToUnicode( vim.eval( '&omnifunc' ) )\n    if not self._omnifunc:\n      return False\n    if self.ShouldUseCache():\n      return super( OmniCompleter, self ).ShouldUseNow( request_data )\n    return self.ShouldUseNowInner( request_data )\n\n\n  def ShouldUseNowInner( self, request_data ):\n    if request_data.get( 'force_semantic', False ):\n      return True\n    return super( OmniCompleter, self ).ShouldUseNowInner( request_data )\n\n\n  def ComputeCandidates( self, request_data ):\n    if self.ShouldUseCache():\n      return super( OmniCompleter, self ).ComputeCandidates( request_data )\n    if self.ShouldUseNowInner( request_data ):\n      return self.ComputeCandidatesInner( request_data )\n    return []\n\n\n  def ComputeCandidatesInner( self, request_data ):\n    if not self._omnifunc:\n      return []\n\n    try:\n      return_value = vimsupport.GetIntValue( self._omnifunc + '(1,\"\")' )\n      if return_value < 0:\n         FIXME: Technically, if the return is -1 we should raise an error\n        return []\n\n       Use the start column calculated by the omnifunc, rather than our own\n       interpretation. This is important for certain languages where our\n       identifier detection is either incorrect or not compatible with the\n       behaviour of the omnifunc. Note: do this before calling the omnifunc\n       because it affects the value returned by 'query'\n      request_data[ 'start_column' ] = return_value + 1\n\n       Calling directly the omnifunc may move the cursor position. This is the\n       case with the default Vim omnifunc for C-family languages\n       (ccompleteComplete) which calls searchdecl to find a declaration. This\n       function is supposed to move the cursor to the found declaration but it\n       doesn't when called through the omni completion mapping (CTRL-X CTRL-O).\n       So, we restore the cursor position after calling the omnifunc.\n      line, column = vimsupport.CurrentLineAndColumn()\n\n      omnifunc_call = [ self._omnifunc,\n                        \"(0,'\",\n                        vimsupport.EscapeForVim( request_data[ 'query' ] ),\n                        \"')\" ]\n      items = vim.eval( ''.join( omnifunc_call ) )\n\n      vimsupport.SetCurrentLineAndColumn( line, column )\n\n      if isinstance( items, dict ) and 'words' in items:\n        items = items[ 'words' ]\n\n      if not hasattr( items, '__iter__' ):\n        raise TypeError( OMNIFUNC_NOT_LIST )\n\n      return list( filter( bool, items ) )\n\n    except ( TypeError, ValueError, vim.error ) as error:\n      vimsupport.PostVimMessage(\n        OMNIFUNC_RETURNED_BAD_VALUE + ' ' + str( error ) )\n      return []\n\n\n  def FilterAndSortCandidatesInner( self, candidates, sort_property, query ):\n    request_data = {\n      'candidates': candidates,\n      'sort_property': sort_property,\n      'query': query\n    }\n\n    with HandleServerException():\n      return BaseRequest.PostDataToHandler( request_data,\n                                            'filter_and_sort_candidates' )\n    return candidates\n", "comments": "  copyright (c) 2011  2012  2013  google inc        this file part youcompleteme        youcompleteme free software  redistribute modify    terms gnu general public license published    free software foundation  either version 3 license     (at option) later version        youcompleteme distributed hope useful     without any warranty  without even implied warranty    merchantability fitness for a particular purpose   see    gnu general public license details        you received copy gnu general public license    along youcompleteme   if  see  http   www gnu org licenses       not installing aliases python future  unreliable slow     noqa    fixme  technically  return  1 raise error    use start column calculated omnifunc  rather    interpretation  this important certain languages    identifier detection either incorrect compatible    behaviour omnifunc  note  calling omnifunc    affects value returned  query     calling directly omnifunc may move cursor position  this    case default vim omnifunc c family languages    (ccomplete complete) calls searchdecl find declaration  this    function supposed move cursor found declaration    called omni completion mapping (ctrl x ctrl o)     so  restore cursor position calling omnifunc  ", "content": "# Copyright (C) 2011, 2012, 2013  Google Inc.\n#\n# This file is part of YouCompleteMe.\n#\n# YouCompleteMe is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# YouCompleteMe is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import unicode_literals\nfrom __future__ import print_function\nfrom __future__ import division\nfrom __future__ import absolute_import\n# Not installing aliases from python-future; it's unreliable and slow.\nfrom builtins import *  # noqa\n\nimport vim\nfrom ycm import vimsupport\nfrom ycmd import utils\nfrom ycmd.completers.completer import Completer\nfrom ycm.client.base_request import BaseRequest, HandleServerException\n\nOMNIFUNC_RETURNED_BAD_VALUE = 'Omnifunc returned bad value to YCM!'\nOMNIFUNC_NOT_LIST = ( 'Omnifunc did not return a list or a dict with a \"words\" '\n                     ' list when expected.' )\n\n\nclass OmniCompleter( Completer ):\n  def __init__( self, user_options ):\n    super( OmniCompleter, self ).__init__( user_options )\n    self._omnifunc = None\n\n\n  def SupportedFiletypes( self ):\n    return []\n\n\n  def ShouldUseCache( self ):\n    return bool( self.user_options[ 'cache_omnifunc' ] )\n\n\n  def ShouldUseNow( self, request_data ):\n    self._omnifunc = utils.ToUnicode( vim.eval( '&omnifunc' ) )\n    if not self._omnifunc:\n      return False\n    if self.ShouldUseCache():\n      return super( OmniCompleter, self ).ShouldUseNow( request_data )\n    return self.ShouldUseNowInner( request_data )\n\n\n  def ShouldUseNowInner( self, request_data ):\n    if request_data.get( 'force_semantic', False ):\n      return True\n    return super( OmniCompleter, self ).ShouldUseNowInner( request_data )\n\n\n  def ComputeCandidates( self, request_data ):\n    if self.ShouldUseCache():\n      return super( OmniCompleter, self ).ComputeCandidates( request_data )\n    if self.ShouldUseNowInner( request_data ):\n      return self.ComputeCandidatesInner( request_data )\n    return []\n\n\n  def ComputeCandidatesInner( self, request_data ):\n    if not self._omnifunc:\n      return []\n\n    try:\n      return_value = vimsupport.GetIntValue( self._omnifunc + '(1,\"\")' )\n      if return_value < 0:\n        # FIXME: Technically, if the return is -1 we should raise an error\n        return []\n\n      # Use the start column calculated by the omnifunc, rather than our own\n      # interpretation. This is important for certain languages where our\n      # identifier detection is either incorrect or not compatible with the\n      # behaviour of the omnifunc. Note: do this before calling the omnifunc\n      # because it affects the value returned by 'query'\n      request_data[ 'start_column' ] = return_value + 1\n\n      # Calling directly the omnifunc may move the cursor position. This is the\n      # case with the default Vim omnifunc for C-family languages\n      # (ccomplete#Complete) which calls searchdecl to find a declaration. This\n      # function is supposed to move the cursor to the found declaration but it\n      # doesn't when called through the omni completion mapping (CTRL-X CTRL-O).\n      # So, we restore the cursor position after calling the omnifunc.\n      line, column = vimsupport.CurrentLineAndColumn()\n\n      omnifunc_call = [ self._omnifunc,\n                        \"(0,'\",\n                        vimsupport.EscapeForVim( request_data[ 'query' ] ),\n                        \"')\" ]\n      items = vim.eval( ''.join( omnifunc_call ) )\n\n      vimsupport.SetCurrentLineAndColumn( line, column )\n\n      if isinstance( items, dict ) and 'words' in items:\n        items = items[ 'words' ]\n\n      if not hasattr( items, '__iter__' ):\n        raise TypeError( OMNIFUNC_NOT_LIST )\n\n      return list( filter( bool, items ) )\n\n    except ( TypeError, ValueError, vim.error ) as error:\n      vimsupport.PostVimMessage(\n        OMNIFUNC_RETURNED_BAD_VALUE + ' ' + str( error ) )\n      return []\n\n\n  def FilterAndSortCandidatesInner( self, candidates, sort_property, query ):\n    request_data = {\n      'candidates': candidates,\n      'sort_property': sort_property,\n      'query': query\n    }\n\n    with HandleServerException():\n      return BaseRequest.PostDataToHandler( request_data,\n                                            'filter_and_sort_candidates' )\n    return candidates\n", "description": "A code-completion engine for Vim", "file_name": "omni_completer.py", "id": "26ac72dc406e5fb7015fc65811c2218a", "language": "Python", "project_name": "YouCompleteMe", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/Valloric-YouCompleteMe/Valloric-YouCompleteMe-d338141/python/ycm/omni_completer.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:58:33Z", "url": "https://github.com/Valloric/YouCompleteMe", "wiki": true}