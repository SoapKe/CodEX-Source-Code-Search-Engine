{"author": "ansible", "code": "\nimport json\nimport os\nimport os.path\nimport re\nimport sys\nfrom collections import defaultdict\nfrom distutils.command.build_scripts import build_scripts as BuildScripts\nfrom distutils.command.sdist import sdist as SDist\n\ntry:\n    from setuptools import setup, find_packages\n    from setuptools.command.build_py import build_py as BuildPy\n    from setuptools.command.install_lib import install_lib as InstallLib\n    from setuptools.command.install_scripts import install_scripts as InstallScripts\nexcept ImportError:\n    print(\"Ansible now needs setuptools in order to build. Install it using\"\n          \" your package manager (usually python-setuptools) or via pip (pip\"\n          \" install setuptools).\")\n    sys.exit(1)\n\nsys.path.insert(0, os.path.abspath('lib'))\nfrom ansible.release import __version__, __author__\n\n\nSYMLINK_CACHE = 'SYMLINK_CACHE.json'\n\n\ndef _find_symlinks(topdir, extension=''):\n    \"\"\"Find symlinks that should be maintained\n\n    Maintained symlinks exist in the bin dir or are modules which have\n    aliases.  Our heuristic is that they are a link in a certain path which\n    point to a file in the same directory.\n    \"\"\"\n    symlinks = defaultdict(list)\n    for base_path, dirs, files in os.walk(topdir):\n        for filename in files:\n            filepath = os.path.join(base_path, filename)\n            if os.path.islink(filepath) and filename.endswith(extension):\n                target = os.readlink(filepath)\n                if os.path.dirname(target) == '':\n                    link = filepath[len(topdir):]\n                    if link.startswith('/'):\n                        link = link[1:]\n                    symlinks[os.path.basename(target)].append(link)\n    return symlinks\n\n\ndef _cache_symlinks(symlink_data):\n    with open(SYMLINK_CACHE, 'w') as f:\n        f.write(json.dumps(symlink_data))\n\n\ndef _maintain_symlinks(symlink_type, base_path):\n    \"\"\"Switch a real file into a symlink\"\"\"\n    try:\n        \n        \n        with open(SYMLINK_CACHE, 'r') as f:\n            symlink_data = json.loads(f.read())\n    except (IOError, OSError) as e:\n        \n        if e.errno == 2:\n            \n            \n            \n            symlink_data = {'script': _find_symlinks('bin'),\n                            'library': _find_symlinks('lib', '.py'),\n                            }\n\n            \n            \n            \n            if 'ansible-playbook' in symlink_data['script']['ansible']:\n                _cache_symlinks(symlink_data)\n            else:\n                raise\n        else:\n            raise\n    symlinks = symlink_data[symlink_type]\n\n    for source in symlinks:\n        for dest in symlinks[source]:\n            dest_path = os.path.join(base_path, dest)\n            if not os.path.islink(dest_path):\n                try:\n                    os.unlink(dest_path)\n                except OSError as e:\n                    if e.errno == 2:\n                        \n                        pass\n                os.symlink(source, dest_path)\n\n\nclass BuildPyCommand(BuildPy):\n    def run(self):\n        BuildPy.run(self)\n        _maintain_symlinks('library', self.build_lib)\n\n\nclass BuildScriptsCommand(BuildScripts):\n    def run(self):\n        BuildScripts.run(self)\n        _maintain_symlinks('script', self.build_dir)\n\n\nclass InstallLibCommand(InstallLib):\n    def run(self):\n        InstallLib.run(self)\n        _maintain_symlinks('library', self.install_dir)\n\n\nclass InstallScriptsCommand(InstallScripts):\n    def run(self):\n        InstallScripts.run(self)\n        _maintain_symlinks('script', self.install_dir)\n\n\nclass SDistCommand(SDist):\n    def run(self):\n        \n        \n        symlinks = {'script': _find_symlinks('bin'),\n                    'library': _find_symlinks('lib', '.py'),\n                    }\n        _cache_symlinks(symlinks)\n\n        SDist.run(self)\n\n\nwith open('requirements.txt') as requirements_file:\n    install_requirements = requirements_file.read().splitlines()\n    if not install_requirements:\n        print(\"Unable to read requirements from the requirements.txt file\"\n              \"That indicates this copy of the source code is incomplete.\")\n        sys.exit(2)\n\n\n\n\n\ncrypto_backend = os.environ.get('ANSIBLE_CRYPTO_BACKEND', None)\nif crypto_backend:\n    if crypto_backend.strip() == 'pycrypto':\n        \n        crypto_backend = 'pycrypto >= 2.6'\n\n    install_requirements = [r for r in install_requirements if not (r.lower().startswith('pycrypto') or r.lower().startswith('cryptography'))]\n    install_requirements.append(crypto_backend)\n\n\nextra_requirements = dict()\nextra_requirements_dir = 'packaging/requirements'\nfor extra_requirements_filename in os.listdir(extra_requirements_dir):\n    filename_match = re.search(r'^requirements-(\\w*).txt$', extra_requirements_filename)\n    if filename_match:\n        with open(os.path.join(extra_requirements_dir, extra_requirements_filename)) as extra_requirements_file:\n            extra_requirements[filename_match.group(1)] = extra_requirements_file.read().splitlines()\n\n\nsetup(\n    \n    \n    cmdclass={\n        'build_py': BuildPyCommand,\n        'build_scripts': BuildScriptsCommand,\n        'install_lib': InstallLibCommand,\n        'install_scripts': InstallScriptsCommand,\n        'sdist': SDistCommand,\n    },\n    name='ansible',\n    version=__version__,\n    description='Radically simple IT automation',\n    author=__author__,\n    author_email='info@ansible.com',\n    url='https://ansible.com/',\n    license='GPLv3+',\n    \n    \n    install_requires=install_requirements,\n    package_dir={'': 'lib'},\n    packages=find_packages('lib'),\n    package_data={\n        '': [\n            'module_utils/powershell/*.psm1',\n            'module_utils/powershell/*/*.psm1',\n            'modules/windows/*.ps1',\n            'modules/windows/*/*.ps1',\n            'galaxy/data/*/*.*',\n            'galaxy/data/*/*/.*',\n            'galaxy/data/*/*/*.*',\n            'galaxy/data/*/tests/inventory',\n            'config/base.yml',\n        ],\n    },\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Environment :: Console',\n        'Intended Audience :: Developers',\n        'Intended Audience :: Information Technology',\n        'Intended Audience :: System Administrators',\n        'License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)',\n        'Natural Language :: English',\n        'Operating System :: POSIX',\n        'Programming Language :: Python :: 2.6',\n        'Programming Language :: Python :: 2.7',\n        'Topic :: System :: Installation/Setup',\n        'Topic :: System :: Systems Administration',\n        'Topic :: Utilities',\n    ],\n    scripts=[\n        'bin/ansible',\n        'bin/ansible-playbook',\n        'bin/ansible-pull',\n        'bin/ansible-doc',\n        'bin/ansible-galaxy',\n        'bin/ansible-console',\n        'bin/ansible-connection',\n        'bin/ansible-vault',\n        'bin/ansible-config',\n        'bin/ansible-inventory',\n    ],\n    data_files=[],\n    extras_require=extra_requirements,\n    \n    zip_safe=False\n)\n", "comments": "   find symlinks maintained      maintained symlinks exist bin dir modules     aliases   our heuristic link certain path     point file directory              symlinks   defaultdict(list)     base path  dirs  files os walk(topdir)          filename files              filepath   os path join(base path  filename)             os path islink(filepath) filename endswith(extension)                  target   os readlink(filepath)                 os path dirname(target)                            link   filepath len(topdir)                       link startswith(   )                          link   link 1                       symlinks os path basename(target)  append(link)     return symlinks   def  cache symlinks(symlink data)      open(symlink cache   w ) f          f write(json dumps(symlink data))   def  maintain symlinks(symlink type  base path)         switch real file symlink       try cache first going git checkout sdist    time know going cache correctly    ioerror py2  oserror py3   both errno    symlinks cache exist   fallback trying create    cache   will work running directly git    checkout sdist created earlier     sanity check something know symlink    found   we take mean current directory    structure properly reflects symlinks git repo    file exist wanted    generate cache symlinks release sdist    command access symlinks git repo    pycrypto cryptography    we choose default allow user    override   this translates pip install sdist deciding    package install also runtime dependencies pkg resources    knows    attempt set version requirements    specify extra requirements installation    use distutils sdist symlinks expanded    use custom build reason    ansible also make use system copy python six    python selectors2 installed use bundled copy     installing zip files would break due references   file   ", "content": "\nimport json\nimport os\nimport os.path\nimport re\nimport sys\nfrom collections import defaultdict\nfrom distutils.command.build_scripts import build_scripts as BuildScripts\nfrom distutils.command.sdist import sdist as SDist\n\ntry:\n    from setuptools import setup, find_packages\n    from setuptools.command.build_py import build_py as BuildPy\n    from setuptools.command.install_lib import install_lib as InstallLib\n    from setuptools.command.install_scripts import install_scripts as InstallScripts\nexcept ImportError:\n    print(\"Ansible now needs setuptools in order to build. Install it using\"\n          \" your package manager (usually python-setuptools) or via pip (pip\"\n          \" install setuptools).\")\n    sys.exit(1)\n\nsys.path.insert(0, os.path.abspath('lib'))\nfrom ansible.release import __version__, __author__\n\n\nSYMLINK_CACHE = 'SYMLINK_CACHE.json'\n\n\ndef _find_symlinks(topdir, extension=''):\n    \"\"\"Find symlinks that should be maintained\n\n    Maintained symlinks exist in the bin dir or are modules which have\n    aliases.  Our heuristic is that they are a link in a certain path which\n    point to a file in the same directory.\n    \"\"\"\n    symlinks = defaultdict(list)\n    for base_path, dirs, files in os.walk(topdir):\n        for filename in files:\n            filepath = os.path.join(base_path, filename)\n            if os.path.islink(filepath) and filename.endswith(extension):\n                target = os.readlink(filepath)\n                if os.path.dirname(target) == '':\n                    link = filepath[len(topdir):]\n                    if link.startswith('/'):\n                        link = link[1:]\n                    symlinks[os.path.basename(target)].append(link)\n    return symlinks\n\n\ndef _cache_symlinks(symlink_data):\n    with open(SYMLINK_CACHE, 'w') as f:\n        f.write(json.dumps(symlink_data))\n\n\ndef _maintain_symlinks(symlink_type, base_path):\n    \"\"\"Switch a real file into a symlink\"\"\"\n    try:\n        # Try the cache first because going from git checkout to sdist is the\n        # only time we know that we're going to cache correctly\n        with open(SYMLINK_CACHE, 'r') as f:\n            symlink_data = json.loads(f.read())\n    except (IOError, OSError) as e:\n        # IOError on py2, OSError on py3.  Both have errno\n        if e.errno == 2:\n            # SYMLINKS_CACHE doesn't exist.  Fallback to trying to create the\n            # cache now.  Will work if we're running directly from a git\n            # checkout or from an sdist created earlier.\n            symlink_data = {'script': _find_symlinks('bin'),\n                            'library': _find_symlinks('lib', '.py'),\n                            }\n\n            # Sanity check that something we know should be a symlink was\n            # found.  We'll take that to mean that the current directory\n            # structure properly reflects symlinks in the git repo\n            if 'ansible-playbook' in symlink_data['script']['ansible']:\n                _cache_symlinks(symlink_data)\n            else:\n                raise\n        else:\n            raise\n    symlinks = symlink_data[symlink_type]\n\n    for source in symlinks:\n        for dest in symlinks[source]:\n            dest_path = os.path.join(base_path, dest)\n            if not os.path.islink(dest_path):\n                try:\n                    os.unlink(dest_path)\n                except OSError as e:\n                    if e.errno == 2:\n                        # File does not exist which is all we wanted\n                        pass\n                os.symlink(source, dest_path)\n\n\nclass BuildPyCommand(BuildPy):\n    def run(self):\n        BuildPy.run(self)\n        _maintain_symlinks('library', self.build_lib)\n\n\nclass BuildScriptsCommand(BuildScripts):\n    def run(self):\n        BuildScripts.run(self)\n        _maintain_symlinks('script', self.build_dir)\n\n\nclass InstallLibCommand(InstallLib):\n    def run(self):\n        InstallLib.run(self)\n        _maintain_symlinks('library', self.install_dir)\n\n\nclass InstallScriptsCommand(InstallScripts):\n    def run(self):\n        InstallScripts.run(self)\n        _maintain_symlinks('script', self.install_dir)\n\n\nclass SDistCommand(SDist):\n    def run(self):\n        # have to generate the cache of symlinks for release as sdist is the\n        # only command that has access to symlinks from the git repo\n        symlinks = {'script': _find_symlinks('bin'),\n                    'library': _find_symlinks('lib', '.py'),\n                    }\n        _cache_symlinks(symlinks)\n\n        SDist.run(self)\n\n\nwith open('requirements.txt') as requirements_file:\n    install_requirements = requirements_file.read().splitlines()\n    if not install_requirements:\n        print(\"Unable to read requirements from the requirements.txt file\"\n              \"That indicates this copy of the source code is incomplete.\")\n        sys.exit(2)\n\n# pycrypto or cryptography.   We choose a default but allow the user to\n# override it.  This translates into pip install of the sdist deciding what\n# package to install and also the runtime dependencies that pkg_resources\n# knows about\ncrypto_backend = os.environ.get('ANSIBLE_CRYPTO_BACKEND', None)\nif crypto_backend:\n    if crypto_backend.strip() == 'pycrypto':\n        # Attempt to set version requirements\n        crypto_backend = 'pycrypto >= 2.6'\n\n    install_requirements = [r for r in install_requirements if not (r.lower().startswith('pycrypto') or r.lower().startswith('cryptography'))]\n    install_requirements.append(crypto_backend)\n\n# specify any extra requirements for installation\nextra_requirements = dict()\nextra_requirements_dir = 'packaging/requirements'\nfor extra_requirements_filename in os.listdir(extra_requirements_dir):\n    filename_match = re.search(r'^requirements-(\\w*).txt$', extra_requirements_filename)\n    if filename_match:\n        with open(os.path.join(extra_requirements_dir, extra_requirements_filename)) as extra_requirements_file:\n            extra_requirements[filename_match.group(1)] = extra_requirements_file.read().splitlines()\n\n\nsetup(\n    # Use the distutils SDist so that symlinks are not expanded\n    # Use a custom Build for the same reason\n    cmdclass={\n        'build_py': BuildPyCommand,\n        'build_scripts': BuildScriptsCommand,\n        'install_lib': InstallLibCommand,\n        'install_scripts': InstallScriptsCommand,\n        'sdist': SDistCommand,\n    },\n    name='ansible',\n    version=__version__,\n    description='Radically simple IT automation',\n    author=__author__,\n    author_email='info@ansible.com',\n    url='https://ansible.com/',\n    license='GPLv3+',\n    # Ansible will also make use of a system copy of python-six and\n    # python-selectors2 if installed but use a Bundled copy if it's not.\n    install_requires=install_requirements,\n    package_dir={'': 'lib'},\n    packages=find_packages('lib'),\n    package_data={\n        '': [\n            'module_utils/powershell/*.psm1',\n            'module_utils/powershell/*/*.psm1',\n            'modules/windows/*.ps1',\n            'modules/windows/*/*.ps1',\n            'galaxy/data/*/*.*',\n            'galaxy/data/*/*/.*',\n            'galaxy/data/*/*/*.*',\n            'galaxy/data/*/tests/inventory',\n            'config/base.yml',\n        ],\n    },\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Environment :: Console',\n        'Intended Audience :: Developers',\n        'Intended Audience :: Information Technology',\n        'Intended Audience :: System Administrators',\n        'License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)',\n        'Natural Language :: English',\n        'Operating System :: POSIX',\n        'Programming Language :: Python :: 2.6',\n        'Programming Language :: Python :: 2.7',\n        'Topic :: System :: Installation/Setup',\n        'Topic :: System :: Systems Administration',\n        'Topic :: Utilities',\n    ],\n    scripts=[\n        'bin/ansible',\n        'bin/ansible-playbook',\n        'bin/ansible-pull',\n        'bin/ansible-doc',\n        'bin/ansible-galaxy',\n        'bin/ansible-console',\n        'bin/ansible-connection',\n        'bin/ansible-vault',\n        'bin/ansible-config',\n        'bin/ansible-inventory',\n    ],\n    data_files=[],\n    extras_require=extra_requirements,\n    # Installing as zip files would break due to references to __file__\n    zip_safe=False\n)\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "setup.py", "id": "759372fe0f10c8492043f73bbd0ce265", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/setup.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}