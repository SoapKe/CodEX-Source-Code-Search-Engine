{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom odoo import api, fields, models, _\nfrom odoo.addons import decimal_precision as dp\nfrom odoo.exceptions import UserError\nfrom odoo.tools import float_is_zero\nimport math\n\nclass ChangeProductionQty(models.TransientModel):\n    _name = 'change.production.qty'\n    _description = 'Change Quantity of Products'\n\n    \n    mo_id = fields.Many2one('mrp.production', 'Manufacturing Order', required=True)\n    product_qty = fields.Float(\n        'Quantity To Produce',\n        digits=dp.get_precision('Product Unit of Measure'), required=True)\n\n    @api.model\n    def default_get(self, fields):\n        res = super(ChangeProductionQty, self).default_get(fields)\n        if 'mo_id' in fields and not res.get('mo_id') and self._context.get('active_model') == 'mrp.production' and self._context.get('active_id'):\n            res['mo_id'] = self._context['active_id']\n        if 'product_qty' in fields and not res.get('product_qty') and res.get('mo_id'):\n            res['product_qty'] = self.env['mrp.production'].browse(res['mo_id']).product_qty\n        return res\n\n    @api.model\n    def _update_product_to_produce(self, production, qty):\n        production_move = production.move_finished_ids.filtered(lambda x:x.product_id.id == production.product_id.id and x.state not in ('done', 'cancel'))\n        if production_move:\n            production_move.write({'product_uom_qty': qty})\n        else:\n            production_move = production._generate_finished_moves()\n            production_move = production.move_finished_ids.filtered(lambda x : x.state not in ('done', 'cancel') and production.product_id.id == x.product_id.id)\n            production_move.write({'product_uom_qty': qty})\n\n    @api.multi\n    def change_prod_qty(self):\n        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')\n        for wizard in self:\n            production = wizard.mo_id\n            produced = sum(production.move_finished_ids.filtered(lambda m: m.product_id == production.product_id).mapped('quantity_done'))\n            if wizard.product_qty < produced:\n                raise UserError(_(\"You have already processed %d. Please input a quantity higher than %d \")%(produced, produced))\n            production.write({'product_qty': wizard.product_qty})\n            done_moves = production.move_finished_ids.filtered(lambda x: x.state == 'done' and x.product_id == production.product_id)\n            qty_produced = production.product_id.uom_id._compute_quantity(sum(done_moves.mapped('product_qty')), production.product_uom_id)\n            factor = production.product_uom_id._compute_quantity(production.product_qty - qty_produced, production.bom_id.product_uom_id) / production.bom_id.product_qty\n            boms, lines = production.bom_id.explode(production.product_id, factor, picking_type=production.bom_id.picking_type_id)\n            for line, line_data in lines:\n                production._update_raw_move(line, line_data)\n            operation_bom_qty = {}\n            for bom, bom_data in boms:\n                for operation in bom.routing_id.operation_ids:\n                    operation_bom_qty[operation.id] = bom_data['qty']\n            self._update_product_to_produce(production, production.product_qty - qty_produced)\n            moves = production.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel'))\n            moves._action_assign()\n            for wo in production.workorder_ids:\n                operation = wo.operation_id\n                if operation_bom_qty.get(operation.id):\n                    cycle_number = math.ceil(operation_bom_qty[operation.id] / operation.workcenter_id.capacity)  \n                    wo.duration_expected = (operation.workcenter_id.time_start +\n                                 operation.workcenter_id.time_stop +\n                                 cycle_number * operation.time_cycle * 100.0 / operation.workcenter_id.time_efficiency)\n                quantity = wo.qty_production - wo.qty_produced\n                if production.product_id.tracking == 'serial':\n                    quantity = 1.0 if not float_is_zero(quantity, precision_digits=precision) else 0.0\n                else:\n                    quantity = quantity if (quantity > 0) else 0\n                if float_is_zero(quantity, precision_digits=precision):\n                    wo.final_lot_id = False\n                    wo.active_move_line_ids.unlink()\n                wo.qty_producing = quantity\n                if wo.qty_produced < wo.qty_production and wo.state == 'done':\n                    wo.state = 'progress'\n                \n                \n                \n                moves_raw = production.move_raw_ids.filtered(lambda move: move.operation_id == operation and move.state not in ('done', 'cancel'))\n                if wo == production.workorder_ids[-1]:\n                    moves_raw |= production.move_raw_ids.filtered(lambda move: not move.operation_id)\n                moves_finished = production.move_finished_ids.filtered(lambda move: move.operation_id == operation) ?\n                moves_raw.mapped('move_line_ids').write({'workorder_id': wo.id})\n                (moves_finished + moves_raw).write({'workorder_id': wo.id})\n                if quantity > 0 and wo.move_raw_ids.filtered(lambda x: x.product_id.tracking != 'none') and not wo.active_move_line_ids:\n                    wo._generate_lot_ids()\n        return {}\n", "comments": "      coding  utf 8        part odoo  see license file full copyright licensing details     tde fixme  add production id field    todo  float round up    assign moves  last operation receive unassigned moves    todo  following could put function similar code  workorders create    todo  needed creating new moves   todo  code nothing  unless maybe products  ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom odoo import api, fields, models, _\nfrom odoo.addons import decimal_precision as dp\nfrom odoo.exceptions import UserError\nfrom odoo.tools import float_is_zero\nimport math\n\nclass ChangeProductionQty(models.TransientModel):\n    _name = 'change.production.qty'\n    _description = 'Change Quantity of Products'\n\n    # TDE FIXME: add production_id field\n    mo_id = fields.Many2one('mrp.production', 'Manufacturing Order', required=True)\n    product_qty = fields.Float(\n        'Quantity To Produce',\n        digits=dp.get_precision('Product Unit of Measure'), required=True)\n\n    @api.model\n    def default_get(self, fields):\n        res = super(ChangeProductionQty, self).default_get(fields)\n        if 'mo_id' in fields and not res.get('mo_id') and self._context.get('active_model') == 'mrp.production' and self._context.get('active_id'):\n            res['mo_id'] = self._context['active_id']\n        if 'product_qty' in fields and not res.get('product_qty') and res.get('mo_id'):\n            res['product_qty'] = self.env['mrp.production'].browse(res['mo_id']).product_qty\n        return res\n\n    @api.model\n    def _update_product_to_produce(self, production, qty):\n        production_move = production.move_finished_ids.filtered(lambda x:x.product_id.id == production.product_id.id and x.state not in ('done', 'cancel'))\n        if production_move:\n            production_move.write({'product_uom_qty': qty})\n        else:\n            production_move = production._generate_finished_moves()\n            production_move = production.move_finished_ids.filtered(lambda x : x.state not in ('done', 'cancel') and production.product_id.id == x.product_id.id)\n            production_move.write({'product_uom_qty': qty})\n\n    @api.multi\n    def change_prod_qty(self):\n        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')\n        for wizard in self:\n            production = wizard.mo_id\n            produced = sum(production.move_finished_ids.filtered(lambda m: m.product_id == production.product_id).mapped('quantity_done'))\n            if wizard.product_qty < produced:\n                raise UserError(_(\"You have already processed %d. Please input a quantity higher than %d \")%(produced, produced))\n            production.write({'product_qty': wizard.product_qty})\n            done_moves = production.move_finished_ids.filtered(lambda x: x.state == 'done' and x.product_id == production.product_id)\n            qty_produced = production.product_id.uom_id._compute_quantity(sum(done_moves.mapped('product_qty')), production.product_uom_id)\n            factor = production.product_uom_id._compute_quantity(production.product_qty - qty_produced, production.bom_id.product_uom_id) / production.bom_id.product_qty\n            boms, lines = production.bom_id.explode(production.product_id, factor, picking_type=production.bom_id.picking_type_id)\n            for line, line_data in lines:\n                production._update_raw_move(line, line_data)\n            operation_bom_qty = {}\n            for bom, bom_data in boms:\n                for operation in bom.routing_id.operation_ids:\n                    operation_bom_qty[operation.id] = bom_data['qty']\n            self._update_product_to_produce(production, production.product_qty - qty_produced)\n            moves = production.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel'))\n            moves._action_assign()\n            for wo in production.workorder_ids:\n                operation = wo.operation_id\n                if operation_bom_qty.get(operation.id):\n                    cycle_number = math.ceil(operation_bom_qty[operation.id] / operation.workcenter_id.capacity)  # TODO: float_round UP\n                    wo.duration_expected = (operation.workcenter_id.time_start +\n                                 operation.workcenter_id.time_stop +\n                                 cycle_number * operation.time_cycle * 100.0 / operation.workcenter_id.time_efficiency)\n                quantity = wo.qty_production - wo.qty_produced\n                if production.product_id.tracking == 'serial':\n                    quantity = 1.0 if not float_is_zero(quantity, precision_digits=precision) else 0.0\n                else:\n                    quantity = quantity if (quantity > 0) else 0\n                if float_is_zero(quantity, precision_digits=precision):\n                    wo.final_lot_id = False\n                    wo.active_move_line_ids.unlink()\n                wo.qty_producing = quantity\n                if wo.qty_produced < wo.qty_production and wo.state == 'done':\n                    wo.state = 'progress'\n                # assign moves; last operation receive all unassigned moves\n                # TODO: following could be put in a function as it is similar as code in _workorders_create\n                # TODO: only needed when creating new moves\n                moves_raw = production.move_raw_ids.filtered(lambda move: move.operation_id == operation and move.state not in ('done', 'cancel'))\n                if wo == production.workorder_ids[-1]:\n                    moves_raw |= production.move_raw_ids.filtered(lambda move: not move.operation_id)\n                moves_finished = production.move_finished_ids.filtered(lambda move: move.operation_id == operation) #TODO: code does nothing, unless maybe by_products?\n                moves_raw.mapped('move_line_ids').write({'workorder_id': wo.id})\n                (moves_finished + moves_raw).write({'workorder_id': wo.id})\n                if quantity > 0 and wo.move_raw_ids.filtered(lambda x: x.product_id.tracking != 'none') and not wo.active_move_line_ids:\n                    wo._generate_lot_ids()\n        return {}\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "change_production_qty.py", "id": "b8f74a53a603c69e597c68e715032855", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/mrp/wizard/change_production_qty.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}