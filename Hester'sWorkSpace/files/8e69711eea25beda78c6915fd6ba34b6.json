{"author": "littlecodersh", "code": "import os, time, re, io\nimport threading\nimport json, xml.dom.minidom\nimport random\nimport traceback, logging\ntry:\n    from httplib import BadStatusLine\nexcept ImportError:\n    from http.client import BadStatusLine\n\nimport requests\nfrom pyqrcode import QRCode\n\nfrom .. import config, utils\nfrom ..returnvalues import ReturnValue\nfrom ..storage.templates import wrap_user_dict\nfrom .contact import update_local_chatrooms, update_local_friends\nfrom .messages import produce_msg\n\nlogger = logging.getLogger('itchat')\n\ndef load_login(core):\n    core.login             = login\n    core.get_QRuuid        = get_QRuuid\n    core.get_QR            = get_QR\n    core.check_login       = check_login\n    core.web_init          = web_init\n    core.show_mobile_login = show_mobile_login\n    core.start_receiving   = start_receiving\n    core.get_msg           = get_msg\n    core.logout            = logout\n\ndef login(self, enableCmdQR=False, picDir=None, qrCallback=None,\n        loginCallback=None, exitCallback=None):\n    if self.alive or self.isLogging:\n        logger.warning('itchat has already logged in.')\n        return\n    self.isLogging = True\n    while self.isLogging:\n        uuid = push_login(self)\n        if uuid:\n            qrStorage = io.BytesIO()\n        else:\n            logger.info('Getting uuid of QR code.')\n            while not self.get_QRuuid():\n                time.sleep(1)\n            logger.info('Downloading QR code.')\n            qrStorage = self.get_QR(enableCmdQR=enableCmdQR,\n                picDir=picDir, qrCallback=qrCallback)\n            logger.info('Please scan the QR code to log in.')\n        isLoggedIn = False\n        while not isLoggedIn:\n            status = self.check_login()\n            if hasattr(qrCallback, '__call__'):\n                qrCallback(uuid=self.uuid, status=status, qrcode=qrStorage.getvalue())\n            if status == '200':\n                isLoggedIn = True\n            elif status == '201':\n                if isLoggedIn is not None:\n                    logger.info('Please press confirm on your phone.')\n                    isLoggedIn = None\n            elif status != '408':\n                break\n        if isLoggedIn:\n            break\n        elif self.isLogging:\n            logger.info('Log in time out, reloading QR code.')\n    else:\n        return \n    logger.info('Loading the contact, this may take a little while.')\n    self.web_init()\n    self.show_mobile_login()\n    self.get_contact(True)\n    if hasattr(loginCallback, '__call__'):\n        r = loginCallback()\n    else:\n        utils.clear_screen()\n        if os.path.exists(picDir or config.DEFAULT_QR):\n            os.remove(picDir or config.DEFAULT_QR)\n        logger.info('Login successfully as %s' % self.storageClass.nickName)\n    self.start_receiving(exitCallback)\n    self.isLogging = False\n\ndef push_login(core):\n    cookiesDict = core.s.cookies.get_dict()\n    if 'wxuin' in cookiesDict:\n        url = '%s/cgi-bin/mmwebwx-bin/webwxpushloginurl?uin=%s' % (\n            config.BASE_URL, cookiesDict['wxuin'])\n        headers = { 'User-Agent' : config.USER_AGENT }\n        r = core.s.get(url, headers=headers).json()\n        if 'uuid' in r and r.get('ret') in (0, '0'):\n            core.uuid = r['uuid']\n            return r['uuid']\n    return False\n\ndef get_QRuuid(self):\n    url = '%s/jslogin' % config.BASE_URL\n    params = {\n        'appid' : 'wx782c26e4c19acffb',\n        'fun'   : 'new', }\n    headers = { 'User-Agent' : config.USER_AGENT }\n    r = self.s.get(url, params=params, headers=headers)\n    regx = r'window.QRLogin.code = (\\d+); window.QRLogin.uuid = \"(\\S+?)\";'\n    data = re.search(regx, r.text)\n    if data and data.group(1) == '200':\n        self.uuid = data.group(2)\n        return self.uuid\n\ndef get_QR(self, uuid=None, enableCmdQR=False, picDir=None, qrCallback=None):\n    uuid = uuid or self.uuid\n    picDir = picDir or config.DEFAULT_QR\n    qrStorage = io.BytesIO()\n    qrCode = QRCode('https://login.weixin.qq.com/l/' + uuid)\n    qrCode.png(qrStorage, scale=10)\n    if hasattr(qrCallback, '__call__'):\n        qrCallback(uuid=uuid, status='0', qrcode=qrStorage.getvalue())\n    else:\n        if enableCmdQR:\n            utils.print_cmd_qr(qrCode.text(1), enableCmdQR=enableCmdQR)\n        else:\n            with open(picDir, 'wb') as f:\n                f.write(qrStorage.getvalue())\n            utils.print_qr(picDir)\n    return qrStorage\n\ndef check_login(self, uuid=None):\n    uuid = uuid or self.uuid\n    url = '%s/cgi-bin/mmwebwx-bin/login' % config.BASE_URL\n    localTime = int(time.time())\n    params = 'loginicon=true&uuid=%s&tip=1&r=%s&_=%s' % (\n        uuid, int(-localTime / 1579), localTime)\n    headers = { 'User-Agent' : config.USER_AGENT }\n    r = self.s.get(url, params=params, headers=headers)\n    regx = r'window.code=(\\d+)'\n    data = re.search(regx, r.text)\n    if data and data.group(1) == '200':\n        if process_login_info(self, r.text):\n            return '200'\n        else:\n            return '400'\n    elif data:\n        return data.group(1)\n    else:\n        return '400'\n\ndef process_login_info(core, loginContent):\n    ''' when finish login (scanning qrcode)\n     * syncUrl and fileUploadingUrl will be fetched\n     * deviceid and msgid will be generated\n     * skey, wxsid, wxuin, pass_ticket will be fetched\n    '''\n    regx = r'window.redirect_uri=\"(\\S+)\";'\n    core.loginInfo['url'] = re.search(regx, loginContent).group(1)\n    headers = { 'User-Agent' : config.USER_AGENT }\n    r = core.s.get(core.loginInfo['url'], headers=headers, allow_redirects=False)\n    core.loginInfo['url'] = core.loginInfo['url'][:core.loginInfo['url'].rfind('/')]\n    for indexUrl, detailedUrl in (\n            (\"wx2.qq.com\"      , (\"file.wx2.qq.com\", \"webpush.wx2.qq.com\")),\n            (\"wx8.qq.com\"      , (\"file.wx8.qq.com\", \"webpush.wx8.qq.com\")),\n            (\"qq.com\"          , (\"file.wx.qq.com\", \"webpush.wx.qq.com\")),\n            (\"web2.wechat.com\" , (\"file.web2.wechat.com\", \"webpush.web2.wechat.com\")),\n            (\"wechat.com\"      , (\"file.web.wechat.com\", \"webpush.web.wechat.com\"))):\n        fileUrl, syncUrl = ['https://%s/cgi-bin/mmwebwx-bin' % url for url in detailedUrl]\n        if indexUrl in core.loginInfo['url']:\n            core.loginInfo['fileUrl'], core.loginInfo['syncUrl'] = \\\n                fileUrl, syncUrl\n            break\n    else:\n        core.loginInfo['fileUrl'] = core.loginInfo['syncUrl'] = core.loginInfo['url']\n    core.loginInfo['deviceid'] = 'e' + repr(random.random())[2:17]\n    core.loginInfo['logintime'] = int(time.time() * 1e3)\n    core.loginInfo['BaseRequest'] = {}\n    for node in xml.dom.minidom.parseString(r.text).documentElement.childNodes:\n        if node.nodeName == 'skey':\n            core.loginInfo['skey'] = core.loginInfo['BaseRequest']['Skey'] = node.childNodes[0].data\n        elif node.nodeName == 'wxsid':\n            core.loginInfo['wxsid'] = core.loginInfo['BaseRequest']['Sid'] = node.childNodes[0].data\n        elif node.nodeName == 'wxuin':\n            core.loginInfo['wxuin'] = core.loginInfo['BaseRequest']['Uin'] = node.childNodes[0].data\n        elif node.nodeName == 'pass_ticket':\n            core.loginInfo['pass_ticket'] = core.loginInfo['BaseRequest']['DeviceID'] = node.childNodes[0].data\n    if not all([key in core.loginInfo for key in ('skey', 'wxsid', 'wxuin', 'pass_ticket')]):\n        logger.error('Your wechat account may be LIMITED to log in WEB wechat, error info:\\n%s' % r.text)\n        core.isLogging = False\n        return False\n    return True\n\ndef web_init(self):\n    url = '%s/webwxinit' % self.loginInfo['url']\n    params = {\n        'r': int(-time.time() / 1579),\n        'pass_ticket': self.loginInfo['pass_ticket'], }\n    data = { 'BaseRequest': self.loginInfo['BaseRequest'], }\n    headers = {\n        'ContentType': 'application/json; charset=UTF-8',\n        'User-Agent' : config.USER_AGENT, }\n    r = self.s.post(url, params=params, data=json.dumps(data), headers=headers)\n    dic = json.loads(r.content.decode('utf-8', 'replace'))\n    \n    utils.emoji_formatter(dic['User'], 'NickName')\n    self.loginInfo['InviteStartCount'] = int(dic['InviteStartCount'])\n    self.loginInfo['User'] = wrap_user_dict(utils.struct_friend_info(dic['User']))\n    self.memberList.append(self.loginInfo['User'])\n    self.loginInfo['SyncKey'] = dic['SyncKey']\n    self.loginInfo['synckey'] = '|'.join(['%s_%s' % (item['Key'], item['Val'])\n        for item in dic['SyncKey']['List']])\n    self.storageClass.userName = dic['User']['UserName']\n    self.storageClass.nickName = dic['User']['NickName']\n    \n    contactList = dic.get('ContactList', [])\n    chatroomList, otherList = [], []\n    for m in contactList:\n        if m['Sex'] != 0:\n            otherList.append(m)\n        elif '@@' in m['UserName']:\n            m['MemberList'] = [] \n            chatroomList.append(m)\n        elif '@' in m['UserName']:\n            \n            otherList.append(m)\n    if chatroomList:\n        update_local_chatrooms(self, chatroomList)\n    if otherList:\n        update_local_friends(self, otherList)\n    return dic\n\ndef show_mobile_login(self):\n    url = '%s/webwxstatusnotify?lang=zh_CN&pass_ticket=%s' % (\n        self.loginInfo['url'], self.loginInfo['pass_ticket'])\n    data = {\n        'BaseRequest'  : self.loginInfo['BaseRequest'],\n        'Code'         : 3,\n        'FromUserName' : self.storageClass.userName,\n        'ToUserName'   : self.storageClass.userName,\n        'ClientMsgId'  : int(time.time()), }\n    headers = {\n        'ContentType': 'application/json; charset=UTF-8',\n        'User-Agent' : config.USER_AGENT, }\n    r = self.s.post(url, data=json.dumps(data), headers=headers)\n    return ReturnValue(rawResponse=r)\n\ndef start_receiving(self, exitCallback=None, getReceivingFnOnly=False):\n    self.alive = True\n    def maintain_loop():\n        retryCount = 0\n        while self.alive:\n            try:\n                i = sync_check(self)\n                if i is None:\n                    self.alive = False\n                elif i == '0':\n                    pass\n                else:\n                    msgList, contactList = self.get_msg()\n                    if msgList:\n                        msgList = produce_msg(self, msgList)\n                        for msg in msgList:\n                            self.msgList.put(msg)\n                    if contactList:\n                        chatroomList, otherList = [], []\n                        for contact in contactList:\n                            if '@@' in contact['UserName']:\n                                chatroomList.append(contact)\n                            else:\n                                otherList.append(contact)\n                        chatroomMsg = update_local_chatrooms(self, chatroomList)\n                        chatroomMsg['User'] = self.loginInfo['User']\n                        self.msgList.put(chatroomMsg)\n                        update_local_friends(self, otherList)\n                retryCount = 0\n            except requests.exceptions.ReadTimeout:\n                pass\n            except:\n                retryCount += 1\n                logger.error(traceback.format_exc())\n                if self.receivingRetryCount < retryCount:\n                    self.alive = False\n                else:\n                    time.sleep(1)\n        self.logout()\n        if hasattr(exitCallback, '__call__'):\n            exitCallback()\n        else:\n            logger.info('LOG OUT!')\n    if getReceivingFnOnly:\n        return maintain_loop\n    else:\n        maintainThread = threading.Thread(target=maintain_loop)\n        maintainThread.setDaemon(True)\n        maintainThread.start()\n\ndef sync_check(self):\n    url = '%s/synccheck' % self.loginInfo.get('syncUrl', self.loginInfo['url'])\n    params = {\n        'r'        : int(time.time() * 1000),\n        'skey'     : self.loginInfo['skey'],\n        'sid'      : self.loginInfo['wxsid'],\n        'uin'      : self.loginInfo['wxuin'],\n        'deviceid' : self.loginInfo['deviceid'],\n        'synckey'  : self.loginInfo['synckey'],\n        '_'        : self.loginInfo['logintime'], }\n    headers = { 'User-Agent' : config.USER_AGENT }\n    self.loginInfo['logintime'] += 1\n    try:\n        r = self.s.get(url, params=params, headers=headers, timeout=config.TIMEOUT)\n    except requests.exceptions.ConnectionError as e:\n        try:\n            if not isinstance(e.args[0].args[1], BadStatusLine):\n                raise\n            \n            \n            \n            \n            return '2'\n        except:\n            raise\n    r.raise_for_status()\n    regx = r'window.synccheck={retcode:\"(\\d+)\",selector:\"(\\d+)\"}'\n    pm = re.search(regx, r.text)\n    if pm is None or pm.group(1) != '0':\n        logger.debug('Unexpected sync check result: %s' % r.text)\n        return None\n    return pm.group(2)\n\ndef get_msg(self):\n    url = '%s/webwxsync?sid=%s&skey=%s&pass_ticket=%s' % (\n        self.loginInfo['url'], self.loginInfo['wxsid'],\n        self.loginInfo['skey'],self.loginInfo['pass_ticket'])\n    data = {\n        'BaseRequest' : self.loginInfo['BaseRequest'],\n        'SyncKey'     : self.loginInfo['SyncKey'],\n        'rr'          : ~int(time.time()), }\n    headers = {\n        'ContentType': 'application/json; charset=UTF-8',\n        'User-Agent' : config.USER_AGENT }\n    r = self.s.post(url, data=json.dumps(data), headers=headers, timeout=config.TIMEOUT)\n    dic = json.loads(r.content.decode('utf-8', 'replace'))\n    if dic['BaseResponse']['Ret'] != 0: return None, None\n    self.loginInfo['SyncKey'] = dic['SyncKey']\n    self.loginInfo['synckey'] = '|'.join(['%s_%s' % (item['Key'], item['Val'])\n        for item in dic['SyncCheckKey']['List']])\n    return dic['AddMsgList'], dic['ModContactList']\n\ndef logout(self):\n    if self.alive:\n        url = '%s/webwxlogout' % self.loginInfo['url']\n        params = {\n            'redirect' : 1,\n            'type'     : 1,\n            'skey'     : self.loginInfo['skey'], }\n        headers = { 'User-Agent' : config.USER_AGENT }\n        self.s.get(url, params=params, headers=headers)\n        self.alive = False\n    self.isLogging = False\n    self.s.cookies.clear()\n    del self.chatroomList[:]\n    del self.memberList[:]\n    del self.mpList[:]\n    return ReturnValue({'BaseResponse': {\n        'ErrMsg': 'logout successfully.',\n        'Ret': 0, }})\n", "comments": "    finish login (scanning qrcode)        syncurl fileuploadingurl fetched        deviceid msgid generated        skey  wxsid  wxuin  pass ticket fetched            log process stopped user    deal login info    deal contact list returned init    let dirty info pollute list    mp dealt update local friends well    return package status  0       value like     6f 00 8a 9c 09 74 e4 d8 e0 14 bf 96 3a 56 a0 64 1b a4 25 5d 12 f4 31 a5 30 f1 c6 48 5f c3 75 6a 99 93    seems like status typing  i make achievement code remain like ", "content": "import os, time, re, io\nimport threading\nimport json, xml.dom.minidom\nimport random\nimport traceback, logging\ntry:\n    from httplib import BadStatusLine\nexcept ImportError:\n    from http.client import BadStatusLine\n\nimport requests\nfrom pyqrcode import QRCode\n\nfrom .. import config, utils\nfrom ..returnvalues import ReturnValue\nfrom ..storage.templates import wrap_user_dict\nfrom .contact import update_local_chatrooms, update_local_friends\nfrom .messages import produce_msg\n\nlogger = logging.getLogger('itchat')\n\ndef load_login(core):\n    core.login             = login\n    core.get_QRuuid        = get_QRuuid\n    core.get_QR            = get_QR\n    core.check_login       = check_login\n    core.web_init          = web_init\n    core.show_mobile_login = show_mobile_login\n    core.start_receiving   = start_receiving\n    core.get_msg           = get_msg\n    core.logout            = logout\n\ndef login(self, enableCmdQR=False, picDir=None, qrCallback=None,\n        loginCallback=None, exitCallback=None):\n    if self.alive or self.isLogging:\n        logger.warning('itchat has already logged in.')\n        return\n    self.isLogging = True\n    while self.isLogging:\n        uuid = push_login(self)\n        if uuid:\n            qrStorage = io.BytesIO()\n        else:\n            logger.info('Getting uuid of QR code.')\n            while not self.get_QRuuid():\n                time.sleep(1)\n            logger.info('Downloading QR code.')\n            qrStorage = self.get_QR(enableCmdQR=enableCmdQR,\n                picDir=picDir, qrCallback=qrCallback)\n            logger.info('Please scan the QR code to log in.')\n        isLoggedIn = False\n        while not isLoggedIn:\n            status = self.check_login()\n            if hasattr(qrCallback, '__call__'):\n                qrCallback(uuid=self.uuid, status=status, qrcode=qrStorage.getvalue())\n            if status == '200':\n                isLoggedIn = True\n            elif status == '201':\n                if isLoggedIn is not None:\n                    logger.info('Please press confirm on your phone.')\n                    isLoggedIn = None\n            elif status != '408':\n                break\n        if isLoggedIn:\n            break\n        elif self.isLogging:\n            logger.info('Log in time out, reloading QR code.')\n    else:\n        return # log in process is stopped by user\n    logger.info('Loading the contact, this may take a little while.')\n    self.web_init()\n    self.show_mobile_login()\n    self.get_contact(True)\n    if hasattr(loginCallback, '__call__'):\n        r = loginCallback()\n    else:\n        utils.clear_screen()\n        if os.path.exists(picDir or config.DEFAULT_QR):\n            os.remove(picDir or config.DEFAULT_QR)\n        logger.info('Login successfully as %s' % self.storageClass.nickName)\n    self.start_receiving(exitCallback)\n    self.isLogging = False\n\ndef push_login(core):\n    cookiesDict = core.s.cookies.get_dict()\n    if 'wxuin' in cookiesDict:\n        url = '%s/cgi-bin/mmwebwx-bin/webwxpushloginurl?uin=%s' % (\n            config.BASE_URL, cookiesDict['wxuin'])\n        headers = { 'User-Agent' : config.USER_AGENT }\n        r = core.s.get(url, headers=headers).json()\n        if 'uuid' in r and r.get('ret') in (0, '0'):\n            core.uuid = r['uuid']\n            return r['uuid']\n    return False\n\ndef get_QRuuid(self):\n    url = '%s/jslogin' % config.BASE_URL\n    params = {\n        'appid' : 'wx782c26e4c19acffb',\n        'fun'   : 'new', }\n    headers = { 'User-Agent' : config.USER_AGENT }\n    r = self.s.get(url, params=params, headers=headers)\n    regx = r'window.QRLogin.code = (\\d+); window.QRLogin.uuid = \"(\\S+?)\";'\n    data = re.search(regx, r.text)\n    if data and data.group(1) == '200':\n        self.uuid = data.group(2)\n        return self.uuid\n\ndef get_QR(self, uuid=None, enableCmdQR=False, picDir=None, qrCallback=None):\n    uuid = uuid or self.uuid\n    picDir = picDir or config.DEFAULT_QR\n    qrStorage = io.BytesIO()\n    qrCode = QRCode('https://login.weixin.qq.com/l/' + uuid)\n    qrCode.png(qrStorage, scale=10)\n    if hasattr(qrCallback, '__call__'):\n        qrCallback(uuid=uuid, status='0', qrcode=qrStorage.getvalue())\n    else:\n        if enableCmdQR:\n            utils.print_cmd_qr(qrCode.text(1), enableCmdQR=enableCmdQR)\n        else:\n            with open(picDir, 'wb') as f:\n                f.write(qrStorage.getvalue())\n            utils.print_qr(picDir)\n    return qrStorage\n\ndef check_login(self, uuid=None):\n    uuid = uuid or self.uuid\n    url = '%s/cgi-bin/mmwebwx-bin/login' % config.BASE_URL\n    localTime = int(time.time())\n    params = 'loginicon=true&uuid=%s&tip=1&r=%s&_=%s' % (\n        uuid, int(-localTime / 1579), localTime)\n    headers = { 'User-Agent' : config.USER_AGENT }\n    r = self.s.get(url, params=params, headers=headers)\n    regx = r'window.code=(\\d+)'\n    data = re.search(regx, r.text)\n    if data and data.group(1) == '200':\n        if process_login_info(self, r.text):\n            return '200'\n        else:\n            return '400'\n    elif data:\n        return data.group(1)\n    else:\n        return '400'\n\ndef process_login_info(core, loginContent):\n    ''' when finish login (scanning qrcode)\n     * syncUrl and fileUploadingUrl will be fetched\n     * deviceid and msgid will be generated\n     * skey, wxsid, wxuin, pass_ticket will be fetched\n    '''\n    regx = r'window.redirect_uri=\"(\\S+)\";'\n    core.loginInfo['url'] = re.search(regx, loginContent).group(1)\n    headers = { 'User-Agent' : config.USER_AGENT }\n    r = core.s.get(core.loginInfo['url'], headers=headers, allow_redirects=False)\n    core.loginInfo['url'] = core.loginInfo['url'][:core.loginInfo['url'].rfind('/')]\n    for indexUrl, detailedUrl in (\n            (\"wx2.qq.com\"      , (\"file.wx2.qq.com\", \"webpush.wx2.qq.com\")),\n            (\"wx8.qq.com\"      , (\"file.wx8.qq.com\", \"webpush.wx8.qq.com\")),\n            (\"qq.com\"          , (\"file.wx.qq.com\", \"webpush.wx.qq.com\")),\n            (\"web2.wechat.com\" , (\"file.web2.wechat.com\", \"webpush.web2.wechat.com\")),\n            (\"wechat.com\"      , (\"file.web.wechat.com\", \"webpush.web.wechat.com\"))):\n        fileUrl, syncUrl = ['https://%s/cgi-bin/mmwebwx-bin' % url for url in detailedUrl]\n        if indexUrl in core.loginInfo['url']:\n            core.loginInfo['fileUrl'], core.loginInfo['syncUrl'] = \\\n                fileUrl, syncUrl\n            break\n    else:\n        core.loginInfo['fileUrl'] = core.loginInfo['syncUrl'] = core.loginInfo['url']\n    core.loginInfo['deviceid'] = 'e' + repr(random.random())[2:17]\n    core.loginInfo['logintime'] = int(time.time() * 1e3)\n    core.loginInfo['BaseRequest'] = {}\n    for node in xml.dom.minidom.parseString(r.text).documentElement.childNodes:\n        if node.nodeName == 'skey':\n            core.loginInfo['skey'] = core.loginInfo['BaseRequest']['Skey'] = node.childNodes[0].data\n        elif node.nodeName == 'wxsid':\n            core.loginInfo['wxsid'] = core.loginInfo['BaseRequest']['Sid'] = node.childNodes[0].data\n        elif node.nodeName == 'wxuin':\n            core.loginInfo['wxuin'] = core.loginInfo['BaseRequest']['Uin'] = node.childNodes[0].data\n        elif node.nodeName == 'pass_ticket':\n            core.loginInfo['pass_ticket'] = core.loginInfo['BaseRequest']['DeviceID'] = node.childNodes[0].data\n    if not all([key in core.loginInfo for key in ('skey', 'wxsid', 'wxuin', 'pass_ticket')]):\n        logger.error('Your wechat account may be LIMITED to log in WEB wechat, error info:\\n%s' % r.text)\n        core.isLogging = False\n        return False\n    return True\n\ndef web_init(self):\n    url = '%s/webwxinit' % self.loginInfo['url']\n    params = {\n        'r': int(-time.time() / 1579),\n        'pass_ticket': self.loginInfo['pass_ticket'], }\n    data = { 'BaseRequest': self.loginInfo['BaseRequest'], }\n    headers = {\n        'ContentType': 'application/json; charset=UTF-8',\n        'User-Agent' : config.USER_AGENT, }\n    r = self.s.post(url, params=params, data=json.dumps(data), headers=headers)\n    dic = json.loads(r.content.decode('utf-8', 'replace'))\n    # deal with login info\n    utils.emoji_formatter(dic['User'], 'NickName')\n    self.loginInfo['InviteStartCount'] = int(dic['InviteStartCount'])\n    self.loginInfo['User'] = wrap_user_dict(utils.struct_friend_info(dic['User']))\n    self.memberList.append(self.loginInfo['User'])\n    self.loginInfo['SyncKey'] = dic['SyncKey']\n    self.loginInfo['synckey'] = '|'.join(['%s_%s' % (item['Key'], item['Val'])\n        for item in dic['SyncKey']['List']])\n    self.storageClass.userName = dic['User']['UserName']\n    self.storageClass.nickName = dic['User']['NickName']\n    # deal with contact list returned when init\n    contactList = dic.get('ContactList', [])\n    chatroomList, otherList = [], []\n    for m in contactList:\n        if m['Sex'] != 0:\n            otherList.append(m)\n        elif '@@' in m['UserName']:\n            m['MemberList'] = [] # don't let dirty info pollute the list\n            chatroomList.append(m)\n        elif '@' in m['UserName']:\n            # mp will be dealt in update_local_friends as well\n            otherList.append(m)\n    if chatroomList:\n        update_local_chatrooms(self, chatroomList)\n    if otherList:\n        update_local_friends(self, otherList)\n    return dic\n\ndef show_mobile_login(self):\n    url = '%s/webwxstatusnotify?lang=zh_CN&pass_ticket=%s' % (\n        self.loginInfo['url'], self.loginInfo['pass_ticket'])\n    data = {\n        'BaseRequest'  : self.loginInfo['BaseRequest'],\n        'Code'         : 3,\n        'FromUserName' : self.storageClass.userName,\n        'ToUserName'   : self.storageClass.userName,\n        'ClientMsgId'  : int(time.time()), }\n    headers = {\n        'ContentType': 'application/json; charset=UTF-8',\n        'User-Agent' : config.USER_AGENT, }\n    r = self.s.post(url, data=json.dumps(data), headers=headers)\n    return ReturnValue(rawResponse=r)\n\ndef start_receiving(self, exitCallback=None, getReceivingFnOnly=False):\n    self.alive = True\n    def maintain_loop():\n        retryCount = 0\n        while self.alive:\n            try:\n                i = sync_check(self)\n                if i is None:\n                    self.alive = False\n                elif i == '0':\n                    pass\n                else:\n                    msgList, contactList = self.get_msg()\n                    if msgList:\n                        msgList = produce_msg(self, msgList)\n                        for msg in msgList:\n                            self.msgList.put(msg)\n                    if contactList:\n                        chatroomList, otherList = [], []\n                        for contact in contactList:\n                            if '@@' in contact['UserName']:\n                                chatroomList.append(contact)\n                            else:\n                                otherList.append(contact)\n                        chatroomMsg = update_local_chatrooms(self, chatroomList)\n                        chatroomMsg['User'] = self.loginInfo['User']\n                        self.msgList.put(chatroomMsg)\n                        update_local_friends(self, otherList)\n                retryCount = 0\n            except requests.exceptions.ReadTimeout:\n                pass\n            except:\n                retryCount += 1\n                logger.error(traceback.format_exc())\n                if self.receivingRetryCount < retryCount:\n                    self.alive = False\n                else:\n                    time.sleep(1)\n        self.logout()\n        if hasattr(exitCallback, '__call__'):\n            exitCallback()\n        else:\n            logger.info('LOG OUT!')\n    if getReceivingFnOnly:\n        return maintain_loop\n    else:\n        maintainThread = threading.Thread(target=maintain_loop)\n        maintainThread.setDaemon(True)\n        maintainThread.start()\n\ndef sync_check(self):\n    url = '%s/synccheck' % self.loginInfo.get('syncUrl', self.loginInfo['url'])\n    params = {\n        'r'        : int(time.time() * 1000),\n        'skey'     : self.loginInfo['skey'],\n        'sid'      : self.loginInfo['wxsid'],\n        'uin'      : self.loginInfo['wxuin'],\n        'deviceid' : self.loginInfo['deviceid'],\n        'synckey'  : self.loginInfo['synckey'],\n        '_'        : self.loginInfo['logintime'], }\n    headers = { 'User-Agent' : config.USER_AGENT }\n    self.loginInfo['logintime'] += 1\n    try:\n        r = self.s.get(url, params=params, headers=headers, timeout=config.TIMEOUT)\n    except requests.exceptions.ConnectionError as e:\n        try:\n            if not isinstance(e.args[0].args[1], BadStatusLine):\n                raise\n            # will return a package with status '0 -'\n            # and value like:\n            # 6f:00:8a:9c:09:74:e4:d8:e0:14:bf:96:3a:56:a0:64:1b:a4:25:5d:12:f4:31:a5:30:f1:c6:48:5f:c3:75:6a:99:93\n            # seems like status of typing, but before I make further achievement code will remain like this\n            return '2'\n        except:\n            raise\n    r.raise_for_status()\n    regx = r'window.synccheck={retcode:\"(\\d+)\",selector:\"(\\d+)\"}'\n    pm = re.search(regx, r.text)\n    if pm is None or pm.group(1) != '0':\n        logger.debug('Unexpected sync check result: %s' % r.text)\n        return None\n    return pm.group(2)\n\ndef get_msg(self):\n    url = '%s/webwxsync?sid=%s&skey=%s&pass_ticket=%s' % (\n        self.loginInfo['url'], self.loginInfo['wxsid'],\n        self.loginInfo['skey'],self.loginInfo['pass_ticket'])\n    data = {\n        'BaseRequest' : self.loginInfo['BaseRequest'],\n        'SyncKey'     : self.loginInfo['SyncKey'],\n        'rr'          : ~int(time.time()), }\n    headers = {\n        'ContentType': 'application/json; charset=UTF-8',\n        'User-Agent' : config.USER_AGENT }\n    r = self.s.post(url, data=json.dumps(data), headers=headers, timeout=config.TIMEOUT)\n    dic = json.loads(r.content.decode('utf-8', 'replace'))\n    if dic['BaseResponse']['Ret'] != 0: return None, None\n    self.loginInfo['SyncKey'] = dic['SyncKey']\n    self.loginInfo['synckey'] = '|'.join(['%s_%s' % (item['Key'], item['Val'])\n        for item in dic['SyncCheckKey']['List']])\n    return dic['AddMsgList'], dic['ModContactList']\n\ndef logout(self):\n    if self.alive:\n        url = '%s/webwxlogout' % self.loginInfo['url']\n        params = {\n            'redirect' : 1,\n            'type'     : 1,\n            'skey'     : self.loginInfo['skey'], }\n        headers = { 'User-Agent' : config.USER_AGENT }\n        self.s.get(url, params=params, headers=headers)\n        self.alive = False\n    self.isLogging = False\n    self.s.cookies.clear()\n    del self.chatroomList[:]\n    del self.memberList[:]\n    del self.mpList[:]\n    return ReturnValue({'BaseResponse': {\n        'ErrMsg': 'logout successfully.',\n        'Ret': 0, }})\n", "description": "A complete and graceful API for Wechat. \u5fae\u4fe1\u4e2a\u4eba\u53f7\u63a5\u53e3\u3001\u5fae\u4fe1\u673a\u5668\u4eba\u53ca\u547d\u4ee4\u884c\u5fae\u4fe1\uff0c\u4e09\u5341\u884c\u5373\u53ef\u81ea\u5b9a\u4e49\u4e2a\u4eba\u53f7\u673a\u5668\u4eba\u3002", "file_name": "login.py", "id": "8e69711eea25beda78c6915fd6ba34b6", "language": "Python", "project_name": "ItChat", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/littlecodersh-ItChat/littlecodersh-ItChat-8622c3c/itchat/components/login.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:54:42Z", "url": "https://github.com/littlecodersh/ItChat", "wiki": true}