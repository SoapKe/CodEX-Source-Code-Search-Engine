{"author": "apache", "code": "# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nfrom datetime import datetime\nimport unittest\n\nfrom mock import Mock, patch\nimport pandas as pd\n\nfrom superset.utils import DTTM_ALIAS\nimport superset.viz as viz\n\n\nclass BaseVizTestCase(unittest.TestCase):\n    def test_constructor_exception_no_datasource(self):\n        form_data = {}\n        datasource = None\n        with self.assertRaises(Exception):\n            viz.BaseViz(datasource, form_data)\n\n    def test_get_fillna_returns_default_on_null_columns(self):\n        form_data = {\n            'viz_type': 'table',\n            'token': '12345',\n        }\n        datasource = {'type': 'table'}\n        test_viz = viz.BaseViz(datasource, form_data)\n        self.assertEqual(\n            test_viz.default_fillna,\n            test_viz.get_fillna_for_columns(),\n        )\n\n    def test_get_df_returns_empty_df(self):\n        datasource = Mock()\n        datasource.type = 'table'\n        mock_dttm_col = Mock()\n        mock_dttm_col.python_date_format = Mock()\n        datasource.get_col = Mock(return_value=mock_dttm_col)\n        form_data = {'dummy': 123}\n        query_obj = {'granularity': 'day'}\n        results = Mock()\n        results.query = Mock()\n        results.status = Mock()\n        results.error_message = None\n        results.df = Mock()\n        results.df.empty = True\n        datasource.query = Mock(return_value=results)\n        test_viz = viz.BaseViz(datasource, form_data)\n        result = test_viz.get_df(query_obj)\n        self.assertEqual(type(result), pd.DataFrame)\n        self.assertTrue(result.empty)\n\n    def test_get_df_handles_dttm_col(self):\n        datasource = Mock()\n        datasource.type = 'table'\n        datasource.offset = 1\n        mock_dttm_col = Mock()\n        mock_dttm_col.python_date_format = 'epoch_ms'\n        datasource.get_col = Mock(return_value=mock_dttm_col)\n        form_data = {'dummy': 123}\n        query_obj = {'granularity': 'day'}\n        results = Mock()\n        results.query = Mock()\n        results.status = Mock()\n        results.error_message = Mock()\n        df = Mock()\n        df.columns = [DTTM_ALIAS]\n        f_datetime = datetime(1960, 1, 1, 5, 0)\n        df.__getitem__ = Mock(return_value=pd.Series([f_datetime]))\n        df.__setitem__ = Mock()\n        df.replace = Mock()\n        df.fillna = Mock()\n        results.df = df\n        results.df.empty = False\n        datasource.query = Mock(return_value=results)\n        test_viz = viz.BaseViz(datasource, form_data)\n        test_viz.get_fillna_for_columns = Mock(return_value=0)\n        test_viz.get_df(query_obj)\n        mock_call = df.__setitem__.mock_calls[0]\n        self.assertEqual(mock_call[1][0], DTTM_ALIAS)\n        self.assertFalse(mock_call[1][1].empty)\n        self.assertEqual(mock_call[1][1][0], f_datetime)\n        mock_call = df.__setitem__.mock_calls[1]\n        self.assertEqual(mock_call[1][0], DTTM_ALIAS)\n        self.assertEqual(mock_call[1][1][0].hour, 6)\n        self.assertEqual(mock_call[1][1].dtype, 'datetime64[ns]')\n        mock_dttm_col.python_date_format = 'utc'\n        test_viz.get_df(query_obj)\n        mock_call = df.__setitem__.mock_calls[2]\n        self.assertEqual(mock_call[1][0], DTTM_ALIAS)\n        self.assertFalse(mock_call[1][1].empty)\n        self.assertEqual(mock_call[1][1][0].hour, 7)\n        mock_call = df.__setitem__.mock_calls[3]\n        self.assertEqual(mock_call[1][0], DTTM_ALIAS)\n        self.assertEqual(mock_call[1][1][0].hour, 6)\n        self.assertEqual(mock_call[1][1].dtype, 'datetime64[ns]')\n        mock_call = df.__setitem__.mock_calls[4]\n        self.assertEqual(mock_call[1][0], DTTM_ALIAS)\n        self.assertEqual(mock_call[1][1][0].hour, 7)\n        self.assertEqual(mock_call[1][1].dtype, 'datetime64[ns]')\n\n    def test_cache_timeout(self):\n        datasource = Mock()\n        datasource.cache_timeout = 156\n        test_viz = viz.BaseViz(datasource, form_data={})\n        self.assertEqual(156, test_viz.cache_timeout)\n        datasource.cache_timeout = None\n        datasource.database = Mock()\n        datasource.database.cache_timeout = 1666\n        self.assertEqual(1666, test_viz.cache_timeout)\n\n\nclass TableVizTestCase(unittest.TestCase):\n    def test_get_data_applies_percentage(self):\n        form_data = {\n            'percent_metrics': ['sum__A', 'avg__B'],\n            'metrics': ['sum__A', 'count', 'avg__C'],\n        }\n        datasource = Mock()\n        raw = {}\n        raw['sum__A'] = [15, 20, 25, 40]\n        raw['avg__B'] = [10, 20, 5, 15]\n        raw['avg__C'] = [11, 22, 33, 44]\n        raw['count'] = [6, 7, 8, 9]\n        raw['groupA'] = ['A', 'B', 'C', 'C']\n        raw['groupB'] = ['x', 'x', 'y', 'z']\n        df = pd.DataFrame(raw)\n        test_viz = viz.TableViz(datasource, form_data)\n        data = test_viz.get_data(df)\n        \n        self.assertEqual(set([\n            'groupA', 'groupB', 'count',\n            'sum__A', 'avg__C',\n            '%sum__A', '%avg__B',\n        ]), set(data['columns']))\n        expected = [\n            {\n                'groupA': 'A', 'groupB': 'x',\n                'count': 6, 'sum__A': 15, 'avg__C': 11,\n                '%sum__A': 0.15, '%avg__B': 0.2,\n            },\n            {\n                'groupA': 'B', 'groupB': 'x',\n                'count': 7, 'sum__A': 20, 'avg__C': 22,\n                '%sum__A': 0.2, '%avg__B': 0.4,\n            },\n            {\n                'groupA': 'C', 'groupB': 'y',\n                'count': 8, 'sum__A': 25, 'avg__C': 33,\n                '%sum__A': 0.25, '%avg__B': 0.1,\n            },\n            {\n                'groupA': 'C', 'groupB': 'z',\n                'count': 9, 'sum__A': 40, 'avg__C': 44,\n                '%sum__A': 0.40, '%avg__B': 0.3,\n            },\n        ]\n        self.assertEqual(expected, data['records'])\n\n    @patch('superset.viz.BaseViz.query_obj')\n    def test_query_obj_merges_percent_metrics(self, super_query_obj):\n        datasource = Mock()\n        form_data = {\n            'percent_metrics': ['sum__A', 'avg__B', 'max__Y'],\n            'metrics': ['sum__A', 'count', 'avg__C'],\n        }\n        test_viz = viz.TableViz(datasource, form_data)\n        f_query_obj = {\n            'metrics': form_data['metrics'],\n        }\n        super_query_obj.return_value = f_query_obj\n        query_obj = test_viz.query_obj()\n        self.assertEqual([\n            'sum__A', 'count', 'avg__C',\n            'avg__B', 'max__Y',\n        ], query_obj['metrics'])\n\n    @patch('superset.viz.BaseViz.query_obj')\n    def test_query_obj_throws_columns_and_metrics(self, super_query_obj):\n        datasource = Mock()\n        form_data = {\n            'all_columns': ['A', 'B'],\n            'metrics': ['x', 'y'],\n        }\n        super_query_obj.return_value = {}\n        test_viz = viz.TableViz(datasource, form_data)\n        with self.assertRaises(Exception):\n            test_viz.query_obj()\n        del form_data['metrics']\n        form_data['groupby'] = ['B', 'C']\n        test_viz = viz.TableViz(datasource, form_data)\n        with self.assertRaises(Exception):\n            test_viz.query_obj()\n\n    @patch('superset.viz.BaseViz.query_obj')\n    def test_query_obj_merges_all_columns(self, super_query_obj):\n        datasource = Mock()\n        form_data = {\n            'all_columns': ['colA', 'colB', 'colC'],\n            'order_by_cols': ['[\"colA\", \"colB\"]', '[\"colC\"]'],\n        }\n        super_query_obj.return_value = {\n            'columns': ['colD', 'colC'],\n            'groupby': ['colA', 'colB'],\n        }\n        test_viz = viz.TableViz(datasource, form_data)\n        query_obj = test_viz.query_obj()\n        self.assertEqual(form_data['all_columns'], query_obj['columns'])\n        self.assertEqual([], query_obj['groupby'])\n        self.assertEqual([['colA', 'colB'], ['colC']], query_obj['orderby'])\n\n    @patch('superset.viz.BaseViz.query_obj')\n    def test_query_obj_uses_sortby(self, super_query_obj):\n        datasource = Mock()\n        form_data = {\n            'timeseries_limit_metric': '__time__',\n            'order_desc': False,\n        }\n        super_query_obj.return_value = {\n            'metrics': ['colA', 'colB'],\n        }\n        test_viz = viz.TableViz(datasource, form_data)\n        query_obj = test_viz.query_obj()\n        self.assertEqual([\n            'colA', 'colB', '__time__',\n        ], query_obj['metrics'])\n        self.assertEqual([(\n            '__time__', True,\n        )], query_obj['orderby'])\n\n    def test_should_be_timeseries_raises_when_no_granularity(self):\n        datasource = Mock()\n        form_data = {'include_time': True}\n        test_viz = viz.TableViz(datasource, form_data)\n        with self.assertRaises(Exception):\n            test_viz.should_be_timeseries()\n\n\nclass PairedTTestTestCase(unittest.TestCase):\n    def test_get_data_transforms_dataframe(self):\n        form_data = {\n            'groupby': ['groupA', 'groupB', 'groupC'],\n            'metrics': ['metric1', 'metric2', 'metric3'],\n        }\n        datasource = {'type': 'table'}\n        \n        raw = {}\n        raw[DTTM_ALIAS] = [100, 200, 300, 100, 200, 300, 100, 200, 300]\n        raw['groupA'] = ['a1', 'a1', 'a1', 'b1', 'b1', 'b1', 'c1', 'c1', 'c1']\n        raw['groupB'] = ['a2', 'a2', 'a2', 'b2', 'b2', 'b2', 'c2', 'c2', 'c2']\n        raw['groupC'] = ['a3', 'a3', 'a3', 'b3', 'b3', 'b3', 'c3', 'c3', 'c3']\n        raw['metric1'] = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        raw['metric2'] = [10, 20, 30, 40, 50, 60, 70, 80, 90]\n        raw['metric3'] = [100, 200, 300, 400, 500, 600, 700, 800, 900]\n        df = pd.DataFrame(raw)\n        pairedTTestViz = viz.viz_types['paired_ttest'](datasource, form_data)\n        data = pairedTTestViz.get_data(df)\n        \n        expected = {\n            'metric1': [\n                {\n                    'values': [\n                        {'x': 100, 'y': 1},\n                        {'x': 200, 'y': 2},\n                        {'x': 300, 'y': 3}],\n                    'group': ('a1', 'a2', 'a3'),\n                },\n                {\n                    'values': [\n                        {'x': 100, 'y': 4},\n                        {'x': 200, 'y': 5},\n                        {'x': 300, 'y': 6}],\n                    'group': ('b1', 'b2', 'b3'),\n                },\n                {\n                    'values': [\n                        {'x': 100, 'y': 7},\n                        {'x': 200, 'y': 8},\n                        {'x': 300, 'y': 9}],\n                    'group': ('c1', 'c2', 'c3'),\n                },\n            ],\n            'metric2': [\n                {\n                    'values': [\n                        {'x': 100, 'y': 10},\n                        {'x': 200, 'y': 20},\n                        {'x': 300, 'y': 30}],\n                    'group': ('a1', 'a2', 'a3'),\n                },\n                {\n                    'values': [\n                        {'x': 100, 'y': 40},\n                        {'x': 200, 'y': 50},\n                        {'x': 300, 'y': 60}],\n                    'group': ('b1', 'b2', 'b3'),\n                },\n                {\n                    'values': [\n                        {'x': 100, 'y': 70},\n                        {'x': 200, 'y': 80},\n                        {'x': 300, 'y': 90}],\n                    'group': ('c1', 'c2', 'c3'),\n                },\n            ],\n            'metric3': [\n                {\n                    'values': [\n                        {'x': 100, 'y': 100},\n                        {'x': 200, 'y': 200},\n                        {'x': 300, 'y': 300}],\n                    'group': ('a1', 'a2', 'a3'),\n                },\n                {\n                    'values': [\n                        {'x': 100, 'y': 400},\n                        {'x': 200, 'y': 500},\n                        {'x': 300, 'y': 600}],\n                    'group': ('b1', 'b2', 'b3'),\n                },\n                {\n                    'values': [\n                        {'x': 100, 'y': 700},\n                        {'x': 200, 'y': 800},\n                        {'x': 300, 'y': 900}],\n                    'group': ('c1', 'c2', 'c3'),\n                },\n            ],\n        }\n        self.assertEqual(data, expected)\n\n    def test_get_data_empty_null_keys(self):\n        form_data = {\n            'groupby': [],\n            'metrics': ['', None],\n        }\n        datasource = {'type': 'table'}\n        \n        raw = {}\n        raw[DTTM_ALIAS] = [100, 200, 300]\n        raw[''] = [1, 2, 3]\n        raw[None] = [10, 20, 30]\n\n        df = pd.DataFrame(raw)\n        pairedTTestViz = viz.viz_types['paired_ttest'](datasource, form_data)\n        data = pairedTTestViz.get_data(df)\n        \n        expected = {\n            'N/A': [\n                {\n                    'values': [\n                        {'x': 100, 'y': 1},\n                        {'x': 200, 'y': 2},\n                        {'x': 300, 'y': 3}],\n                    'group': 'All',\n                },\n            ],\n            'NULL': [\n                {\n                    'values': [\n                        {'x': 100, 'y': 10},\n                        {'x': 200, 'y': 20},\n                        {'x': 300, 'y': 30}],\n                    'group': 'All',\n                },\n            ],\n        }\n        self.assertEqual(data, expected)\n\n\nclass PartitionVizTestCase(unittest.TestCase):\n\n    @patch('superset.viz.BaseViz.query_obj')\n    def test_query_obj_time_series_option(self, super_query_obj):\n        datasource = Mock()\n        form_data = {}\n        test_viz = viz.PartitionViz(datasource, form_data)\n        super_query_obj.return_value = {}\n        query_obj = test_viz.query_obj()\n        self.assertFalse(query_obj['is_timeseries'])\n        test_viz.form_data['time_series_option'] = 'agg_sum'\n        query_obj = test_viz.query_obj()\n        self.assertTrue(query_obj['is_timeseries'])\n\n    def test_levels_for_computes_levels(self):\n        raw = {}\n        raw[DTTM_ALIAS] = [100, 200, 300, 100, 200, 300, 100, 200, 300]\n        raw['groupA'] = ['a1', 'a1', 'a1', 'b1', 'b1', 'b1', 'c1', 'c1', 'c1']\n        raw['groupB'] = ['a2', 'a2', 'a2', 'b2', 'b2', 'b2', 'c2', 'c2', 'c2']\n        raw['groupC'] = ['a3', 'a3', 'a3', 'b3', 'b3', 'b3', 'c3', 'c3', 'c3']\n        raw['metric1'] = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        raw['metric2'] = [10, 20, 30, 40, 50, 60, 70, 80, 90]\n        raw['metric3'] = [100, 200, 300, 400, 500, 600, 700, 800, 900]\n        df = pd.DataFrame(raw)\n        groups = ['groupA', 'groupB', 'groupC']\n        time_op = 'agg_sum'\n        test_viz = viz.PartitionViz(Mock(), {})\n        levels = test_viz.levels_for(time_op, groups, df)\n        self.assertEqual(4, len(levels))\n        expected = {\n            DTTM_ALIAS: 1800,\n            'metric1': 45,\n            'metric2': 450,\n            'metric3': 4500,\n        }\n        self.assertEqual(expected, levels[0].to_dict())\n        expected = {\n            DTTM_ALIAS: {'a1': 600, 'b1': 600, 'c1': 600},\n            'metric1': {'a1': 6, 'b1': 15, 'c1': 24},\n            'metric2': {'a1': 60, 'b1': 150, 'c1': 240},\n            'metric3': {'a1': 600, 'b1': 1500, 'c1': 2400},\n        }\n        self.assertEqual(expected, levels[1].to_dict())\n        self.assertEqual(['groupA', 'groupB'], levels[2].index.names)\n        self.assertEqual(\n            ['groupA', 'groupB', 'groupC'],\n            levels[3].index.names,\n        )\n        time_op = 'agg_mean'\n        levels = test_viz.levels_for(time_op, groups, df)\n        self.assertEqual(4, len(levels))\n        expected = {\n            DTTM_ALIAS: 200.0,\n            'metric1': 5.0,\n            'metric2': 50.0,\n            'metric3': 500.0,\n        }\n        self.assertEqual(expected, levels[0].to_dict())\n        expected = {\n            DTTM_ALIAS: {'a1': 200, 'c1': 200, 'b1': 200},\n            'metric1': {'a1': 2, 'b1': 5, 'c1': 8},\n            'metric2': {'a1': 20, 'b1': 50, 'c1': 80},\n            'metric3': {'a1': 200, 'b1': 500, 'c1': 800},\n        }\n        self.assertEqual(expected, levels[1].to_dict())\n        self.assertEqual(['groupA', 'groupB'], levels[2].index.names)\n        self.assertEqual(\n            ['groupA', 'groupB', 'groupC'],\n            levels[3].index.names,\n        )\n\n    def test_levels_for_diff_computes_difference(self):\n        raw = {}\n        raw[DTTM_ALIAS] = [100, 200, 300, 100, 200, 300, 100, 200, 300]\n        raw['groupA'] = ['a1', 'a1', 'a1', 'b1', 'b1', 'b1', 'c1', 'c1', 'c1']\n        raw['groupB'] = ['a2', 'a2', 'a2', 'b2', 'b2', 'b2', 'c2', 'c2', 'c2']\n        raw['groupC'] = ['a3', 'a3', 'a3', 'b3', 'b3', 'b3', 'c3', 'c3', 'c3']\n        raw['metric1'] = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        raw['metric2'] = [10, 20, 30, 40, 50, 60, 70, 80, 90]\n        raw['metric3'] = [100, 200, 300, 400, 500, 600, 700, 800, 900]\n        df = pd.DataFrame(raw)\n        groups = ['groupA', 'groupB', 'groupC']\n        test_viz = viz.PartitionViz(Mock(), {})\n        time_op = 'point_diff'\n        levels = test_viz.levels_for_diff(time_op, groups, df)\n        expected = {\n            'metric1': 6,\n            'metric2': 60,\n            'metric3': 600,\n        }\n        self.assertEqual(expected, levels[0].to_dict())\n        expected = {\n            'metric1': {'a1': 2, 'b1': 2, 'c1': 2},\n            'metric2': {'a1': 20, 'b1': 20, 'c1': 20},\n            'metric3': {'a1': 200, 'b1': 200, 'c1': 200},\n        }\n        self.assertEqual(expected, levels[1].to_dict())\n        self.assertEqual(4, len(levels))\n        self.assertEqual(['groupA', 'groupB', 'groupC'], levels[3].index.names)\n\n    def test_levels_for_time_calls_process_data_and_drops_cols(self):\n        raw = {}\n        raw[DTTM_ALIAS] = [100, 200, 300, 100, 200, 300, 100, 200, 300]\n        raw['groupA'] = ['a1', 'a1', 'a1', 'b1', 'b1', 'b1', 'c1', 'c1', 'c1']\n        raw['groupB'] = ['a2', 'a2', 'a2', 'b2', 'b2', 'b2', 'c2', 'c2', 'c2']\n        raw['groupC'] = ['a3', 'a3', 'a3', 'b3', 'b3', 'b3', 'c3', 'c3', 'c3']\n        raw['metric1'] = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        raw['metric2'] = [10, 20, 30, 40, 50, 60, 70, 80, 90]\n        raw['metric3'] = [100, 200, 300, 400, 500, 600, 700, 800, 900]\n        df = pd.DataFrame(raw)\n        groups = ['groupA', 'groupB', 'groupC']\n        test_viz = viz.PartitionViz(Mock(), {'groupby': groups})\n\n        def return_args(df_drop, aggregate):\n            return df_drop\n        test_viz.process_data = Mock(side_effect=return_args)\n        levels = test_viz.levels_for_time(groups, df)\n        self.assertEqual(4, len(levels))\n        cols = [DTTM_ALIAS, 'metric1', 'metric2', 'metric3']\n        self.assertEqual(sorted(cols), sorted(levels[0].columns.tolist()))\n        cols += ['groupA']\n        self.assertEqual(sorted(cols), sorted(levels[1].columns.tolist()))\n        cols += ['groupB']\n        self.assertEqual(sorted(cols), sorted(levels[2].columns.tolist()))\n        cols += ['groupC']\n        self.assertEqual(sorted(cols), sorted(levels[3].columns.tolist()))\n        self.assertEqual(4, len(test_viz.process_data.mock_calls))\n\n    def test_nest_values_returns_hierarchy(self):\n        raw = {}\n        raw['groupA'] = ['a1', 'a1', 'a1', 'b1', 'b1', 'b1', 'c1', 'c1', 'c1']\n        raw['groupB'] = ['a2', 'a2', 'a2', 'b2', 'b2', 'b2', 'c2', 'c2', 'c2']\n        raw['groupC'] = ['a3', 'a3', 'a3', 'b3', 'b3', 'b3', 'c3', 'c3', 'c3']\n        raw['metric1'] = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        raw['metric2'] = [10, 20, 30, 40, 50, 60, 70, 80, 90]\n        raw['metric3'] = [100, 200, 300, 400, 500, 600, 700, 800, 900]\n        df = pd.DataFrame(raw)\n        test_viz = viz.PartitionViz(Mock(), {})\n        groups = ['groupA', 'groupB', 'groupC']\n        levels = test_viz.levels_for('agg_sum', groups, df)\n        nest = test_viz.nest_values(levels)\n        self.assertEqual(3, len(nest))\n        for i in range(0, 3):\n            self.assertEqual('metric' + str(i + 1), nest[i]['name'])\n        self.assertEqual(3, len(nest[0]['children']))\n        self.assertEqual(1, len(nest[0]['children'][0]['children']))\n        self.assertEqual(1, len(nest[0]['children'][0]['children'][0]['children']))\n\n    def test_nest_procs_returns_hierarchy(self):\n        raw = {}\n        raw[DTTM_ALIAS] = [100, 200, 300, 100, 200, 300, 100, 200, 300]\n        raw['groupA'] = ['a1', 'a1', 'a1', 'b1', 'b1', 'b1', 'c1', 'c1', 'c1']\n        raw['groupB'] = ['a2', 'a2', 'a2', 'b2', 'b2', 'b2', 'c2', 'c2', 'c2']\n        raw['groupC'] = ['a3', 'a3', 'a3', 'b3', 'b3', 'b3', 'c3', 'c3', 'c3']\n        raw['metric1'] = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        raw['metric2'] = [10, 20, 30, 40, 50, 60, 70, 80, 90]\n        raw['metric3'] = [100, 200, 300, 400, 500, 600, 700, 800, 900]\n        df = pd.DataFrame(raw)\n        test_viz = viz.PartitionViz(Mock(), {})\n        groups = ['groupA', 'groupB', 'groupC']\n        metrics = ['metric1', 'metric2', 'metric3']\n        procs = {}\n        for i in range(0, 4):\n            df_drop = df.drop(groups[i:], 1)\n            pivot = df_drop.pivot_table(\n                index=DTTM_ALIAS,\n                columns=groups[:i],\n                values=metrics,\n            )\n            procs[i] = pivot\n        nest = test_viz.nest_procs(procs)\n        self.assertEqual(3, len(nest))\n        for i in range(0, 3):\n            self.assertEqual('metric' + str(i + 1), nest[i]['name'])\n            self.assertEqual(None, nest[i].get('val'))\n        self.assertEqual(3, len(nest[0]['children']))\n        self.assertEqual(3, len(nest[0]['children'][0]['children']))\n        self.assertEqual(1, len(nest[0]['children'][0]['children'][0]['children']))\n        self.assertEqual(\n            1,\n            len(nest[0]['children']\n                [0]['children']\n                [0]['children']\n                [0]['children']),\n        )\n\n    def test_get_data_calls_correct_method(self):\n        test_viz = viz.PartitionViz(Mock(), {})\n        df = Mock()\n        with self.assertRaises(ValueError):\n            test_viz.get_data(df)\n        test_viz.levels_for = Mock(return_value=1)\n        test_viz.nest_values = Mock(return_value=1)\n        test_viz.form_data['groupby'] = ['groups']\n        test_viz.form_data['time_series_option'] = 'not_time'\n        test_viz.get_data(df)\n        self.assertEqual('agg_sum', test_viz.levels_for.mock_calls[0][1][0])\n        test_viz.form_data['time_series_option'] = 'agg_sum'\n        test_viz.get_data(df)\n        self.assertEqual('agg_sum', test_viz.levels_for.mock_calls[1][1][0])\n        test_viz.form_data['time_series_option'] = 'agg_mean'\n        test_viz.get_data(df)\n        self.assertEqual('agg_mean', test_viz.levels_for.mock_calls[2][1][0])\n        test_viz.form_data['time_series_option'] = 'point_diff'\n        test_viz.levels_for_diff = Mock(return_value=1)\n        test_viz.get_data(df)\n        self.assertEqual('point_diff', test_viz.levels_for_diff.mock_calls[0][1][0])\n        test_viz.form_data['time_series_option'] = 'point_percent'\n        test_viz.get_data(df)\n        self.assertEqual('point_percent', test_viz.levels_for_diff.mock_calls[1][1][0])\n        test_viz.form_data['time_series_option'] = 'point_factor'\n        test_viz.get_data(df)\n        self.assertEqual('point_factor', test_viz.levels_for_diff.mock_calls[2][1][0])\n        test_viz.levels_for_time = Mock(return_value=1)\n        test_viz.nest_procs = Mock(return_value=1)\n        test_viz.form_data['time_series_option'] = 'adv_anal'\n        test_viz.get_data(df)\n        self.assertEqual(1, len(test_viz.levels_for_time.mock_calls))\n        self.assertEqual(1, len(test_viz.nest_procs.mock_calls))\n        test_viz.form_data['time_series_option'] = 'time_series'\n        test_viz.get_data(df)\n        self.assertEqual('agg_sum', test_viz.levels_for.mock_calls[3][1][0])\n        self.assertEqual(7, len(test_viz.nest_values.mock_calls))\n\n\nclass RoseVisTestCase(unittest.TestCase):\n\n    def test_rose_vis_get_data(self):\n        raw = {}\n        t1 = pd.Timestamp('2000')\n        t2 = pd.Timestamp('2002')\n        t3 = pd.Timestamp('2004')\n        raw[DTTM_ALIAS] = [t1, t2, t3, t1, t2, t3, t1, t2, t3]\n        raw['groupA'] = ['a1', 'a1', 'a1', 'b1', 'b1', 'b1', 'c1', 'c1', 'c1']\n        raw['groupB'] = ['a2', 'a2', 'a2', 'b2', 'b2', 'b2', 'c2', 'c2', 'c2']\n        raw['groupC'] = ['a3', 'a3', 'a3', 'b3', 'b3', 'b3', 'c3', 'c3', 'c3']\n        raw['metric1'] = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        df = pd.DataFrame(raw)\n        fd = {\n            'metrics': ['metric1'],\n            'groupby': ['groupA'],\n        }\n        test_viz = viz.RoseViz(Mock(), fd)\n        test_viz.metrics = fd['metrics']\n        res = test_viz.get_data(df)\n        expected = {\n            946684800000000000: [\n                {'time': t1, 'value': 1, 'key': ('a1',), 'name': ('a1',)},\n                {'time': t1, 'value': 4, 'key': ('b1',), 'name': ('b1',)},\n                {'time': t1, 'value': 7, 'key': ('c1',), 'name': ('c1',)},\n            ],\n            1009843200000000000: [\n                {'time': t2, 'value': 2, 'key': ('a1',), 'name': ('a1',)},\n                {'time': t2, 'value': 5, 'key': ('b1',), 'name': ('b1',)},\n                {'time': t2, 'value': 8, 'key': ('c1',), 'name': ('c1',)},\n            ],\n            1072915200000000000: [\n                {'time': t3, 'value': 3, 'key': ('a1',), 'name': ('a1',)},\n                {'time': t3, 'value': 6, 'key': ('b1',), 'name': ('b1',)},\n                {'time': t3, 'value': 9, 'key': ('c1',), 'name': ('c1',)},\n            ],\n        }\n        self.assertEqual(expected, res)\n", "comments": "      coding  utf 8        check method correctly transforms data computes percents    test data    check method correctly transforms data    test data    check method correctly transforms data ", "content": "# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nfrom datetime import datetime\nimport unittest\n\nfrom mock import Mock, patch\nimport pandas as pd\n\nfrom superset.utils import DTTM_ALIAS\nimport superset.viz as viz\n\n\nclass BaseVizTestCase(unittest.TestCase):\n    def test_constructor_exception_no_datasource(self):\n        form_data = {}\n        datasource = None\n        with self.assertRaises(Exception):\n            viz.BaseViz(datasource, form_data)\n\n    def test_get_fillna_returns_default_on_null_columns(self):\n        form_data = {\n            'viz_type': 'table',\n            'token': '12345',\n        }\n        datasource = {'type': 'table'}\n        test_viz = viz.BaseViz(datasource, form_data)\n        self.assertEqual(\n            test_viz.default_fillna,\n            test_viz.get_fillna_for_columns(),\n        )\n\n    def test_get_df_returns_empty_df(self):\n        datasource = Mock()\n        datasource.type = 'table'\n        mock_dttm_col = Mock()\n        mock_dttm_col.python_date_format = Mock()\n        datasource.get_col = Mock(return_value=mock_dttm_col)\n        form_data = {'dummy': 123}\n        query_obj = {'granularity': 'day'}\n        results = Mock()\n        results.query = Mock()\n        results.status = Mock()\n        results.error_message = None\n        results.df = Mock()\n        results.df.empty = True\n        datasource.query = Mock(return_value=results)\n        test_viz = viz.BaseViz(datasource, form_data)\n        result = test_viz.get_df(query_obj)\n        self.assertEqual(type(result), pd.DataFrame)\n        self.assertTrue(result.empty)\n\n    def test_get_df_handles_dttm_col(self):\n        datasource = Mock()\n        datasource.type = 'table'\n        datasource.offset = 1\n        mock_dttm_col = Mock()\n        mock_dttm_col.python_date_format = 'epoch_ms'\n        datasource.get_col = Mock(return_value=mock_dttm_col)\n        form_data = {'dummy': 123}\n        query_obj = {'granularity': 'day'}\n        results = Mock()\n        results.query = Mock()\n        results.status = Mock()\n        results.error_message = Mock()\n        df = Mock()\n        df.columns = [DTTM_ALIAS]\n        f_datetime = datetime(1960, 1, 1, 5, 0)\n        df.__getitem__ = Mock(return_value=pd.Series([f_datetime]))\n        df.__setitem__ = Mock()\n        df.replace = Mock()\n        df.fillna = Mock()\n        results.df = df\n        results.df.empty = False\n        datasource.query = Mock(return_value=results)\n        test_viz = viz.BaseViz(datasource, form_data)\n        test_viz.get_fillna_for_columns = Mock(return_value=0)\n        test_viz.get_df(query_obj)\n        mock_call = df.__setitem__.mock_calls[0]\n        self.assertEqual(mock_call[1][0], DTTM_ALIAS)\n        self.assertFalse(mock_call[1][1].empty)\n        self.assertEqual(mock_call[1][1][0], f_datetime)\n        mock_call = df.__setitem__.mock_calls[1]\n        self.assertEqual(mock_call[1][0], DTTM_ALIAS)\n        self.assertEqual(mock_call[1][1][0].hour, 6)\n        self.assertEqual(mock_call[1][1].dtype, 'datetime64[ns]')\n        mock_dttm_col.python_date_format = 'utc'\n        test_viz.get_df(query_obj)\n        mock_call = df.__setitem__.mock_calls[2]\n        self.assertEqual(mock_call[1][0], DTTM_ALIAS)\n        self.assertFalse(mock_call[1][1].empty)\n        self.assertEqual(mock_call[1][1][0].hour, 7)\n        mock_call = df.__setitem__.mock_calls[3]\n        self.assertEqual(mock_call[1][0], DTTM_ALIAS)\n        self.assertEqual(mock_call[1][1][0].hour, 6)\n        self.assertEqual(mock_call[1][1].dtype, 'datetime64[ns]')\n        mock_call = df.__setitem__.mock_calls[4]\n        self.assertEqual(mock_call[1][0], DTTM_ALIAS)\n        self.assertEqual(mock_call[1][1][0].hour, 7)\n        self.assertEqual(mock_call[1][1].dtype, 'datetime64[ns]')\n\n    def test_cache_timeout(self):\n        datasource = Mock()\n        datasource.cache_timeout = 156\n        test_viz = viz.BaseViz(datasource, form_data={})\n        self.assertEqual(156, test_viz.cache_timeout)\n        datasource.cache_timeout = None\n        datasource.database = Mock()\n        datasource.database.cache_timeout = 1666\n        self.assertEqual(1666, test_viz.cache_timeout)\n\n\nclass TableVizTestCase(unittest.TestCase):\n    def test_get_data_applies_percentage(self):\n        form_data = {\n            'percent_metrics': ['sum__A', 'avg__B'],\n            'metrics': ['sum__A', 'count', 'avg__C'],\n        }\n        datasource = Mock()\n        raw = {}\n        raw['sum__A'] = [15, 20, 25, 40]\n        raw['avg__B'] = [10, 20, 5, 15]\n        raw['avg__C'] = [11, 22, 33, 44]\n        raw['count'] = [6, 7, 8, 9]\n        raw['groupA'] = ['A', 'B', 'C', 'C']\n        raw['groupB'] = ['x', 'x', 'y', 'z']\n        df = pd.DataFrame(raw)\n        test_viz = viz.TableViz(datasource, form_data)\n        data = test_viz.get_data(df)\n        # Check method correctly transforms data and computes percents\n        self.assertEqual(set([\n            'groupA', 'groupB', 'count',\n            'sum__A', 'avg__C',\n            '%sum__A', '%avg__B',\n        ]), set(data['columns']))\n        expected = [\n            {\n                'groupA': 'A', 'groupB': 'x',\n                'count': 6, 'sum__A': 15, 'avg__C': 11,\n                '%sum__A': 0.15, '%avg__B': 0.2,\n            },\n            {\n                'groupA': 'B', 'groupB': 'x',\n                'count': 7, 'sum__A': 20, 'avg__C': 22,\n                '%sum__A': 0.2, '%avg__B': 0.4,\n            },\n            {\n                'groupA': 'C', 'groupB': 'y',\n                'count': 8, 'sum__A': 25, 'avg__C': 33,\n                '%sum__A': 0.25, '%avg__B': 0.1,\n            },\n            {\n                'groupA': 'C', 'groupB': 'z',\n                'count': 9, 'sum__A': 40, 'avg__C': 44,\n                '%sum__A': 0.40, '%avg__B': 0.3,\n            },\n        ]\n        self.assertEqual(expected, data['records'])\n\n    @patch('superset.viz.BaseViz.query_obj')\n    def test_query_obj_merges_percent_metrics(self, super_query_obj):\n        datasource = Mock()\n        form_data = {\n            'percent_metrics': ['sum__A', 'avg__B', 'max__Y'],\n            'metrics': ['sum__A', 'count', 'avg__C'],\n        }\n        test_viz = viz.TableViz(datasource, form_data)\n        f_query_obj = {\n            'metrics': form_data['metrics'],\n        }\n        super_query_obj.return_value = f_query_obj\n        query_obj = test_viz.query_obj()\n        self.assertEqual([\n            'sum__A', 'count', 'avg__C',\n            'avg__B', 'max__Y',\n        ], query_obj['metrics'])\n\n    @patch('superset.viz.BaseViz.query_obj')\n    def test_query_obj_throws_columns_and_metrics(self, super_query_obj):\n        datasource = Mock()\n        form_data = {\n            'all_columns': ['A', 'B'],\n            'metrics': ['x', 'y'],\n        }\n        super_query_obj.return_value = {}\n        test_viz = viz.TableViz(datasource, form_data)\n        with self.assertRaises(Exception):\n            test_viz.query_obj()\n        del form_data['metrics']\n        form_data['groupby'] = ['B', 'C']\n        test_viz = viz.TableViz(datasource, form_data)\n        with self.assertRaises(Exception):\n            test_viz.query_obj()\n\n    @patch('superset.viz.BaseViz.query_obj')\n    def test_query_obj_merges_all_columns(self, super_query_obj):\n        datasource = Mock()\n        form_data = {\n            'all_columns': ['colA', 'colB', 'colC'],\n            'order_by_cols': ['[\"colA\", \"colB\"]', '[\"colC\"]'],\n        }\n        super_query_obj.return_value = {\n            'columns': ['colD', 'colC'],\n            'groupby': ['colA', 'colB'],\n        }\n        test_viz = viz.TableViz(datasource, form_data)\n        query_obj = test_viz.query_obj()\n        self.assertEqual(form_data['all_columns'], query_obj['columns'])\n        self.assertEqual([], query_obj['groupby'])\n        self.assertEqual([['colA', 'colB'], ['colC']], query_obj['orderby'])\n\n    @patch('superset.viz.BaseViz.query_obj')\n    def test_query_obj_uses_sortby(self, super_query_obj):\n        datasource = Mock()\n        form_data = {\n            'timeseries_limit_metric': '__time__',\n            'order_desc': False,\n        }\n        super_query_obj.return_value = {\n            'metrics': ['colA', 'colB'],\n        }\n        test_viz = viz.TableViz(datasource, form_data)\n        query_obj = test_viz.query_obj()\n        self.assertEqual([\n            'colA', 'colB', '__time__',\n        ], query_obj['metrics'])\n        self.assertEqual([(\n            '__time__', True,\n        )], query_obj['orderby'])\n\n    def test_should_be_timeseries_raises_when_no_granularity(self):\n        datasource = Mock()\n        form_data = {'include_time': True}\n        test_viz = viz.TableViz(datasource, form_data)\n        with self.assertRaises(Exception):\n            test_viz.should_be_timeseries()\n\n\nclass PairedTTestTestCase(unittest.TestCase):\n    def test_get_data_transforms_dataframe(self):\n        form_data = {\n            'groupby': ['groupA', 'groupB', 'groupC'],\n            'metrics': ['metric1', 'metric2', 'metric3'],\n        }\n        datasource = {'type': 'table'}\n        # Test data\n        raw = {}\n        raw[DTTM_ALIAS] = [100, 200, 300, 100, 200, 300, 100, 200, 300]\n        raw['groupA'] = ['a1', 'a1', 'a1', 'b1', 'b1', 'b1', 'c1', 'c1', 'c1']\n        raw['groupB'] = ['a2', 'a2', 'a2', 'b2', 'b2', 'b2', 'c2', 'c2', 'c2']\n        raw['groupC'] = ['a3', 'a3', 'a3', 'b3', 'b3', 'b3', 'c3', 'c3', 'c3']\n        raw['metric1'] = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        raw['metric2'] = [10, 20, 30, 40, 50, 60, 70, 80, 90]\n        raw['metric3'] = [100, 200, 300, 400, 500, 600, 700, 800, 900]\n        df = pd.DataFrame(raw)\n        pairedTTestViz = viz.viz_types['paired_ttest'](datasource, form_data)\n        data = pairedTTestViz.get_data(df)\n        # Check method correctly transforms data\n        expected = {\n            'metric1': [\n                {\n                    'values': [\n                        {'x': 100, 'y': 1},\n                        {'x': 200, 'y': 2},\n                        {'x': 300, 'y': 3}],\n                    'group': ('a1', 'a2', 'a3'),\n                },\n                {\n                    'values': [\n                        {'x': 100, 'y': 4},\n                        {'x': 200, 'y': 5},\n                        {'x': 300, 'y': 6}],\n                    'group': ('b1', 'b2', 'b3'),\n                },\n                {\n                    'values': [\n                        {'x': 100, 'y': 7},\n                        {'x': 200, 'y': 8},\n                        {'x': 300, 'y': 9}],\n                    'group': ('c1', 'c2', 'c3'),\n                },\n            ],\n            'metric2': [\n                {\n                    'values': [\n                        {'x': 100, 'y': 10},\n                        {'x': 200, 'y': 20},\n                        {'x': 300, 'y': 30}],\n                    'group': ('a1', 'a2', 'a3'),\n                },\n                {\n                    'values': [\n                        {'x': 100, 'y': 40},\n                        {'x': 200, 'y': 50},\n                        {'x': 300, 'y': 60}],\n                    'group': ('b1', 'b2', 'b3'),\n                },\n                {\n                    'values': [\n                        {'x': 100, 'y': 70},\n                        {'x': 200, 'y': 80},\n                        {'x': 300, 'y': 90}],\n                    'group': ('c1', 'c2', 'c3'),\n                },\n            ],\n            'metric3': [\n                {\n                    'values': [\n                        {'x': 100, 'y': 100},\n                        {'x': 200, 'y': 200},\n                        {'x': 300, 'y': 300}],\n                    'group': ('a1', 'a2', 'a3'),\n                },\n                {\n                    'values': [\n                        {'x': 100, 'y': 400},\n                        {'x': 200, 'y': 500},\n                        {'x': 300, 'y': 600}],\n                    'group': ('b1', 'b2', 'b3'),\n                },\n                {\n                    'values': [\n                        {'x': 100, 'y': 700},\n                        {'x': 200, 'y': 800},\n                        {'x': 300, 'y': 900}],\n                    'group': ('c1', 'c2', 'c3'),\n                },\n            ],\n        }\n        self.assertEqual(data, expected)\n\n    def test_get_data_empty_null_keys(self):\n        form_data = {\n            'groupby': [],\n            'metrics': ['', None],\n        }\n        datasource = {'type': 'table'}\n        # Test data\n        raw = {}\n        raw[DTTM_ALIAS] = [100, 200, 300]\n        raw[''] = [1, 2, 3]\n        raw[None] = [10, 20, 30]\n\n        df = pd.DataFrame(raw)\n        pairedTTestViz = viz.viz_types['paired_ttest'](datasource, form_data)\n        data = pairedTTestViz.get_data(df)\n        # Check method correctly transforms data\n        expected = {\n            'N/A': [\n                {\n                    'values': [\n                        {'x': 100, 'y': 1},\n                        {'x': 200, 'y': 2},\n                        {'x': 300, 'y': 3}],\n                    'group': 'All',\n                },\n            ],\n            'NULL': [\n                {\n                    'values': [\n                        {'x': 100, 'y': 10},\n                        {'x': 200, 'y': 20},\n                        {'x': 300, 'y': 30}],\n                    'group': 'All',\n                },\n            ],\n        }\n        self.assertEqual(data, expected)\n\n\nclass PartitionVizTestCase(unittest.TestCase):\n\n    @patch('superset.viz.BaseViz.query_obj')\n    def test_query_obj_time_series_option(self, super_query_obj):\n        datasource = Mock()\n        form_data = {}\n        test_viz = viz.PartitionViz(datasource, form_data)\n        super_query_obj.return_value = {}\n        query_obj = test_viz.query_obj()\n        self.assertFalse(query_obj['is_timeseries'])\n        test_viz.form_data['time_series_option'] = 'agg_sum'\n        query_obj = test_viz.query_obj()\n        self.assertTrue(query_obj['is_timeseries'])\n\n    def test_levels_for_computes_levels(self):\n        raw = {}\n        raw[DTTM_ALIAS] = [100, 200, 300, 100, 200, 300, 100, 200, 300]\n        raw['groupA'] = ['a1', 'a1', 'a1', 'b1', 'b1', 'b1', 'c1', 'c1', 'c1']\n        raw['groupB'] = ['a2', 'a2', 'a2', 'b2', 'b2', 'b2', 'c2', 'c2', 'c2']\n        raw['groupC'] = ['a3', 'a3', 'a3', 'b3', 'b3', 'b3', 'c3', 'c3', 'c3']\n        raw['metric1'] = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        raw['metric2'] = [10, 20, 30, 40, 50, 60, 70, 80, 90]\n        raw['metric3'] = [100, 200, 300, 400, 500, 600, 700, 800, 900]\n        df = pd.DataFrame(raw)\n        groups = ['groupA', 'groupB', 'groupC']\n        time_op = 'agg_sum'\n        test_viz = viz.PartitionViz(Mock(), {})\n        levels = test_viz.levels_for(time_op, groups, df)\n        self.assertEqual(4, len(levels))\n        expected = {\n            DTTM_ALIAS: 1800,\n            'metric1': 45,\n            'metric2': 450,\n            'metric3': 4500,\n        }\n        self.assertEqual(expected, levels[0].to_dict())\n        expected = {\n            DTTM_ALIAS: {'a1': 600, 'b1': 600, 'c1': 600},\n            'metric1': {'a1': 6, 'b1': 15, 'c1': 24},\n            'metric2': {'a1': 60, 'b1': 150, 'c1': 240},\n            'metric3': {'a1': 600, 'b1': 1500, 'c1': 2400},\n        }\n        self.assertEqual(expected, levels[1].to_dict())\n        self.assertEqual(['groupA', 'groupB'], levels[2].index.names)\n        self.assertEqual(\n            ['groupA', 'groupB', 'groupC'],\n            levels[3].index.names,\n        )\n        time_op = 'agg_mean'\n        levels = test_viz.levels_for(time_op, groups, df)\n        self.assertEqual(4, len(levels))\n        expected = {\n            DTTM_ALIAS: 200.0,\n            'metric1': 5.0,\n            'metric2': 50.0,\n            'metric3': 500.0,\n        }\n        self.assertEqual(expected, levels[0].to_dict())\n        expected = {\n            DTTM_ALIAS: {'a1': 200, 'c1': 200, 'b1': 200},\n            'metric1': {'a1': 2, 'b1': 5, 'c1': 8},\n            'metric2': {'a1': 20, 'b1': 50, 'c1': 80},\n            'metric3': {'a1': 200, 'b1': 500, 'c1': 800},\n        }\n        self.assertEqual(expected, levels[1].to_dict())\n        self.assertEqual(['groupA', 'groupB'], levels[2].index.names)\n        self.assertEqual(\n            ['groupA', 'groupB', 'groupC'],\n            levels[3].index.names,\n        )\n\n    def test_levels_for_diff_computes_difference(self):\n        raw = {}\n        raw[DTTM_ALIAS] = [100, 200, 300, 100, 200, 300, 100, 200, 300]\n        raw['groupA'] = ['a1', 'a1', 'a1', 'b1', 'b1', 'b1', 'c1', 'c1', 'c1']\n        raw['groupB'] = ['a2', 'a2', 'a2', 'b2', 'b2', 'b2', 'c2', 'c2', 'c2']\n        raw['groupC'] = ['a3', 'a3', 'a3', 'b3', 'b3', 'b3', 'c3', 'c3', 'c3']\n        raw['metric1'] = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        raw['metric2'] = [10, 20, 30, 40, 50, 60, 70, 80, 90]\n        raw['metric3'] = [100, 200, 300, 400, 500, 600, 700, 800, 900]\n        df = pd.DataFrame(raw)\n        groups = ['groupA', 'groupB', 'groupC']\n        test_viz = viz.PartitionViz(Mock(), {})\n        time_op = 'point_diff'\n        levels = test_viz.levels_for_diff(time_op, groups, df)\n        expected = {\n            'metric1': 6,\n            'metric2': 60,\n            'metric3': 600,\n        }\n        self.assertEqual(expected, levels[0].to_dict())\n        expected = {\n            'metric1': {'a1': 2, 'b1': 2, 'c1': 2},\n            'metric2': {'a1': 20, 'b1': 20, 'c1': 20},\n            'metric3': {'a1': 200, 'b1': 200, 'c1': 200},\n        }\n        self.assertEqual(expected, levels[1].to_dict())\n        self.assertEqual(4, len(levels))\n        self.assertEqual(['groupA', 'groupB', 'groupC'], levels[3].index.names)\n\n    def test_levels_for_time_calls_process_data_and_drops_cols(self):\n        raw = {}\n        raw[DTTM_ALIAS] = [100, 200, 300, 100, 200, 300, 100, 200, 300]\n        raw['groupA'] = ['a1', 'a1', 'a1', 'b1', 'b1', 'b1', 'c1', 'c1', 'c1']\n        raw['groupB'] = ['a2', 'a2', 'a2', 'b2', 'b2', 'b2', 'c2', 'c2', 'c2']\n        raw['groupC'] = ['a3', 'a3', 'a3', 'b3', 'b3', 'b3', 'c3', 'c3', 'c3']\n        raw['metric1'] = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        raw['metric2'] = [10, 20, 30, 40, 50, 60, 70, 80, 90]\n        raw['metric3'] = [100, 200, 300, 400, 500, 600, 700, 800, 900]\n        df = pd.DataFrame(raw)\n        groups = ['groupA', 'groupB', 'groupC']\n        test_viz = viz.PartitionViz(Mock(), {'groupby': groups})\n\n        def return_args(df_drop, aggregate):\n            return df_drop\n        test_viz.process_data = Mock(side_effect=return_args)\n        levels = test_viz.levels_for_time(groups, df)\n        self.assertEqual(4, len(levels))\n        cols = [DTTM_ALIAS, 'metric1', 'metric2', 'metric3']\n        self.assertEqual(sorted(cols), sorted(levels[0].columns.tolist()))\n        cols += ['groupA']\n        self.assertEqual(sorted(cols), sorted(levels[1].columns.tolist()))\n        cols += ['groupB']\n        self.assertEqual(sorted(cols), sorted(levels[2].columns.tolist()))\n        cols += ['groupC']\n        self.assertEqual(sorted(cols), sorted(levels[3].columns.tolist()))\n        self.assertEqual(4, len(test_viz.process_data.mock_calls))\n\n    def test_nest_values_returns_hierarchy(self):\n        raw = {}\n        raw['groupA'] = ['a1', 'a1', 'a1', 'b1', 'b1', 'b1', 'c1', 'c1', 'c1']\n        raw['groupB'] = ['a2', 'a2', 'a2', 'b2', 'b2', 'b2', 'c2', 'c2', 'c2']\n        raw['groupC'] = ['a3', 'a3', 'a3', 'b3', 'b3', 'b3', 'c3', 'c3', 'c3']\n        raw['metric1'] = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        raw['metric2'] = [10, 20, 30, 40, 50, 60, 70, 80, 90]\n        raw['metric3'] = [100, 200, 300, 400, 500, 600, 700, 800, 900]\n        df = pd.DataFrame(raw)\n        test_viz = viz.PartitionViz(Mock(), {})\n        groups = ['groupA', 'groupB', 'groupC']\n        levels = test_viz.levels_for('agg_sum', groups, df)\n        nest = test_viz.nest_values(levels)\n        self.assertEqual(3, len(nest))\n        for i in range(0, 3):\n            self.assertEqual('metric' + str(i + 1), nest[i]['name'])\n        self.assertEqual(3, len(nest[0]['children']))\n        self.assertEqual(1, len(nest[0]['children'][0]['children']))\n        self.assertEqual(1, len(nest[0]['children'][0]['children'][0]['children']))\n\n    def test_nest_procs_returns_hierarchy(self):\n        raw = {}\n        raw[DTTM_ALIAS] = [100, 200, 300, 100, 200, 300, 100, 200, 300]\n        raw['groupA'] = ['a1', 'a1', 'a1', 'b1', 'b1', 'b1', 'c1', 'c1', 'c1']\n        raw['groupB'] = ['a2', 'a2', 'a2', 'b2', 'b2', 'b2', 'c2', 'c2', 'c2']\n        raw['groupC'] = ['a3', 'a3', 'a3', 'b3', 'b3', 'b3', 'c3', 'c3', 'c3']\n        raw['metric1'] = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        raw['metric2'] = [10, 20, 30, 40, 50, 60, 70, 80, 90]\n        raw['metric3'] = [100, 200, 300, 400, 500, 600, 700, 800, 900]\n        df = pd.DataFrame(raw)\n        test_viz = viz.PartitionViz(Mock(), {})\n        groups = ['groupA', 'groupB', 'groupC']\n        metrics = ['metric1', 'metric2', 'metric3']\n        procs = {}\n        for i in range(0, 4):\n            df_drop = df.drop(groups[i:], 1)\n            pivot = df_drop.pivot_table(\n                index=DTTM_ALIAS,\n                columns=groups[:i],\n                values=metrics,\n            )\n            procs[i] = pivot\n        nest = test_viz.nest_procs(procs)\n        self.assertEqual(3, len(nest))\n        for i in range(0, 3):\n            self.assertEqual('metric' + str(i + 1), nest[i]['name'])\n            self.assertEqual(None, nest[i].get('val'))\n        self.assertEqual(3, len(nest[0]['children']))\n        self.assertEqual(3, len(nest[0]['children'][0]['children']))\n        self.assertEqual(1, len(nest[0]['children'][0]['children'][0]['children']))\n        self.assertEqual(\n            1,\n            len(nest[0]['children']\n                [0]['children']\n                [0]['children']\n                [0]['children']),\n        )\n\n    def test_get_data_calls_correct_method(self):\n        test_viz = viz.PartitionViz(Mock(), {})\n        df = Mock()\n        with self.assertRaises(ValueError):\n            test_viz.get_data(df)\n        test_viz.levels_for = Mock(return_value=1)\n        test_viz.nest_values = Mock(return_value=1)\n        test_viz.form_data['groupby'] = ['groups']\n        test_viz.form_data['time_series_option'] = 'not_time'\n        test_viz.get_data(df)\n        self.assertEqual('agg_sum', test_viz.levels_for.mock_calls[0][1][0])\n        test_viz.form_data['time_series_option'] = 'agg_sum'\n        test_viz.get_data(df)\n        self.assertEqual('agg_sum', test_viz.levels_for.mock_calls[1][1][0])\n        test_viz.form_data['time_series_option'] = 'agg_mean'\n        test_viz.get_data(df)\n        self.assertEqual('agg_mean', test_viz.levels_for.mock_calls[2][1][0])\n        test_viz.form_data['time_series_option'] = 'point_diff'\n        test_viz.levels_for_diff = Mock(return_value=1)\n        test_viz.get_data(df)\n        self.assertEqual('point_diff', test_viz.levels_for_diff.mock_calls[0][1][0])\n        test_viz.form_data['time_series_option'] = 'point_percent'\n        test_viz.get_data(df)\n        self.assertEqual('point_percent', test_viz.levels_for_diff.mock_calls[1][1][0])\n        test_viz.form_data['time_series_option'] = 'point_factor'\n        test_viz.get_data(df)\n        self.assertEqual('point_factor', test_viz.levels_for_diff.mock_calls[2][1][0])\n        test_viz.levels_for_time = Mock(return_value=1)\n        test_viz.nest_procs = Mock(return_value=1)\n        test_viz.form_data['time_series_option'] = 'adv_anal'\n        test_viz.get_data(df)\n        self.assertEqual(1, len(test_viz.levels_for_time.mock_calls))\n        self.assertEqual(1, len(test_viz.nest_procs.mock_calls))\n        test_viz.form_data['time_series_option'] = 'time_series'\n        test_viz.get_data(df)\n        self.assertEqual('agg_sum', test_viz.levels_for.mock_calls[3][1][0])\n        self.assertEqual(7, len(test_viz.nest_values.mock_calls))\n\n\nclass RoseVisTestCase(unittest.TestCase):\n\n    def test_rose_vis_get_data(self):\n        raw = {}\n        t1 = pd.Timestamp('2000')\n        t2 = pd.Timestamp('2002')\n        t3 = pd.Timestamp('2004')\n        raw[DTTM_ALIAS] = [t1, t2, t3, t1, t2, t3, t1, t2, t3]\n        raw['groupA'] = ['a1', 'a1', 'a1', 'b1', 'b1', 'b1', 'c1', 'c1', 'c1']\n        raw['groupB'] = ['a2', 'a2', 'a2', 'b2', 'b2', 'b2', 'c2', 'c2', 'c2']\n        raw['groupC'] = ['a3', 'a3', 'a3', 'b3', 'b3', 'b3', 'c3', 'c3', 'c3']\n        raw['metric1'] = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        df = pd.DataFrame(raw)\n        fd = {\n            'metrics': ['metric1'],\n            'groupby': ['groupA'],\n        }\n        test_viz = viz.RoseViz(Mock(), fd)\n        test_viz.metrics = fd['metrics']\n        res = test_viz.get_data(df)\n        expected = {\n            946684800000000000: [\n                {'time': t1, 'value': 1, 'key': ('a1',), 'name': ('a1',)},\n                {'time': t1, 'value': 4, 'key': ('b1',), 'name': ('b1',)},\n                {'time': t1, 'value': 7, 'key': ('c1',), 'name': ('c1',)},\n            ],\n            1009843200000000000: [\n                {'time': t2, 'value': 2, 'key': ('a1',), 'name': ('a1',)},\n                {'time': t2, 'value': 5, 'key': ('b1',), 'name': ('b1',)},\n                {'time': t2, 'value': 8, 'key': ('c1',), 'name': ('c1',)},\n            ],\n            1072915200000000000: [\n                {'time': t3, 'value': 3, 'key': ('a1',), 'name': ('a1',)},\n                {'time': t3, 'value': 6, 'key': ('b1',), 'name': ('b1',)},\n                {'time': t3, 'value': 9, 'key': ('c1',), 'name': ('c1',)},\n            ],\n        }\n        self.assertEqual(expected, res)\n", "description": "Apache Superset (incubating) is a modern, enterprise-ready business intelligence web application", "file_name": "viz_tests.py", "id": "42b10eb604db5d8696e5ac65a0851349", "language": "Python", "project_name": "incubator-superset", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/apache-incubator-superset/apache-incubator-superset-95a9b04/tests/viz_tests.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:41:03Z", "url": "https://github.com/apache/incubator-superset", "wiki": false}