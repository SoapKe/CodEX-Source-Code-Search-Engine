{"author": "tornadoweb", "code": "\n\n Copyright 2009 Facebook\n\n Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n not use this file except in compliance with the License. You may obtain\n a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n License for the specific language governing permissions and limitations\n under the License.\n\nimport logging\nimport tornado.escape\nimport tornado.ioloop\nimport tornado.web\nimport os.path\nimport uuid\n\nfrom tornado.concurrent import Future\nfrom tornado import gen\nfrom tornado.options import define, options, parse_command_line\n\ndefine(\"port\", default=8888, help=\"run on the given port\", type=int)\ndefine(\"debug\", default=False, help=\"run in debug mode\")\n\n\nclass MessageBuffer(object):\n    def __init__(self):\n        self.waiters = set()\n        self.cache = []\n        self.cache_size = 200\n\n    def wait_for_messages(self, cursor=None):\n         Construct a Future to return to our caller.  This allows\n         wait_for_messages to be yielded from a coroutine even though\n         it is not a coroutine itself.  We will set the result of the\n         Future when results are available.\n        result_future = Future()\n        if cursor:\n            new_count = 0\n            for msg in reversed(self.cache):\n                if msg[\"id\"] == cursor:\n                    break\n                new_count += 1\n            if new_count:\n                result_future.set_result(self.cache[-new_count:])\n                return result_future\n        self.waiters.add(result_future)\n        return result_future\n\n    def cancel_wait(self, future):\n        self.waiters.remove(future)\n         Set an empty result to unblock any coroutines waiting.\n        future.set_result([])\n\n    def new_messages(self, messages):\n        logging.info(\"Sending new message to %r listeners\", len(self.waiters))\n        for future in self.waiters:\n            future.set_result(messages)\n        self.waiters = set()\n        self.cache.extend(messages)\n        if len(self.cache) > self.cache_size:\n            self.cache = self.cache[-self.cache_size:]\n\n\n Making this a non-singleton is left as an exercise for the reader.\nglobal_message_buffer = MessageBuffer()\n\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.render(\"index.html\", messages=global_message_buffer.cache)\n\n\nclass MessageNewHandler(tornado.web.RequestHandler):\n    def post(self):\n        message = {\n            \"id\": str(uuid.uuid4()),\n            \"body\": self.get_argument(\"body\"),\n        }\n         to_basestring is necessary for Python 3's json encoder,\n         which doesn't accept byte strings.\n        message[\"html\"] = tornado.escape.to_basestring(\n            self.render_string(\"message.html\", message=message))\n        if self.get_argument(\"next\", None):\n            self.redirect(self.get_argument(\"next\"))\n        else:\n            self.write(message)\n        global_message_buffer.new_messages([message])\n\n\nclass MessageUpdatesHandler(tornado.web.RequestHandler):\n    @gen.coroutine\n    def post(self):\n        cursor = self.get_argument(\"cursor\", None)\n         Save the future returned by wait_for_messages so we can cancel\n         it in wait_for_messages\n        self.future = global_message_buffer.wait_for_messages(cursor=cursor)\n        messages = yield self.future\n        if self.request.connection.stream.closed():\n            return\n        self.write(dict(messages=messages))\n\n    def on_connection_close(self):\n        global_message_buffer.cancel_wait(self.future)\n\n\ndef main():\n    parse_command_line()\n    app = tornado.web.Application(\n        [\n            (r\"/\", MainHandler),\n            (r\"/a/message/new\", MessageNewHandler),\n            (r\"/a/message/updates\", MessageUpdatesHandler),\n        ],\n        cookie_secret=\"__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__\",\n        template_path=os.path.join(os.path.dirname(__file__), \"templates\"),\n        static_path=os.path.join(os.path.dirname(__file__), \"static\"),\n        xsrf_cookies=True,\n        debug=options.debug,\n    )\n    app.listen(options.port)\n    tornado.ioloop.IOLoop.current().start()\n\n\nif __name__ == \"__main__\":\n    main()\n", "comments": "   usr bin env python       copyright 2009 facebook       licensed apache license  version 2 0 (the  license )  may    use file except compliance license  you may obtain    copy license           http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis  without    warranties or conditions of any kind  either express implied  see    license specific language governing permissions limitations    license     construct future return caller   this allows    wait messages yielded coroutine even though    coroutine   we set result    future results available     set empty result unblock coroutines waiting     making non singleton left exercise reader     basestring necessary python 3 json encoder     accept byte strings     save future returned wait messages cancel    wait messages ", "content": "#!/usr/bin/env python\n#\n# Copyright 2009 Facebook\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport logging\nimport tornado.escape\nimport tornado.ioloop\nimport tornado.web\nimport os.path\nimport uuid\n\nfrom tornado.concurrent import Future\nfrom tornado import gen\nfrom tornado.options import define, options, parse_command_line\n\ndefine(\"port\", default=8888, help=\"run on the given port\", type=int)\ndefine(\"debug\", default=False, help=\"run in debug mode\")\n\n\nclass MessageBuffer(object):\n    def __init__(self):\n        self.waiters = set()\n        self.cache = []\n        self.cache_size = 200\n\n    def wait_for_messages(self, cursor=None):\n        # Construct a Future to return to our caller.  This allows\n        # wait_for_messages to be yielded from a coroutine even though\n        # it is not a coroutine itself.  We will set the result of the\n        # Future when results are available.\n        result_future = Future()\n        if cursor:\n            new_count = 0\n            for msg in reversed(self.cache):\n                if msg[\"id\"] == cursor:\n                    break\n                new_count += 1\n            if new_count:\n                result_future.set_result(self.cache[-new_count:])\n                return result_future\n        self.waiters.add(result_future)\n        return result_future\n\n    def cancel_wait(self, future):\n        self.waiters.remove(future)\n        # Set an empty result to unblock any coroutines waiting.\n        future.set_result([])\n\n    def new_messages(self, messages):\n        logging.info(\"Sending new message to %r listeners\", len(self.waiters))\n        for future in self.waiters:\n            future.set_result(messages)\n        self.waiters = set()\n        self.cache.extend(messages)\n        if len(self.cache) > self.cache_size:\n            self.cache = self.cache[-self.cache_size:]\n\n\n# Making this a non-singleton is left as an exercise for the reader.\nglobal_message_buffer = MessageBuffer()\n\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.render(\"index.html\", messages=global_message_buffer.cache)\n\n\nclass MessageNewHandler(tornado.web.RequestHandler):\n    def post(self):\n        message = {\n            \"id\": str(uuid.uuid4()),\n            \"body\": self.get_argument(\"body\"),\n        }\n        # to_basestring is necessary for Python 3's json encoder,\n        # which doesn't accept byte strings.\n        message[\"html\"] = tornado.escape.to_basestring(\n            self.render_string(\"message.html\", message=message))\n        if self.get_argument(\"next\", None):\n            self.redirect(self.get_argument(\"next\"))\n        else:\n            self.write(message)\n        global_message_buffer.new_messages([message])\n\n\nclass MessageUpdatesHandler(tornado.web.RequestHandler):\n    @gen.coroutine\n    def post(self):\n        cursor = self.get_argument(\"cursor\", None)\n        # Save the future returned by wait_for_messages so we can cancel\n        # it in wait_for_messages\n        self.future = global_message_buffer.wait_for_messages(cursor=cursor)\n        messages = yield self.future\n        if self.request.connection.stream.closed():\n            return\n        self.write(dict(messages=messages))\n\n    def on_connection_close(self):\n        global_message_buffer.cancel_wait(self.future)\n\n\ndef main():\n    parse_command_line()\n    app = tornado.web.Application(\n        [\n            (r\"/\", MainHandler),\n            (r\"/a/message/new\", MessageNewHandler),\n            (r\"/a/message/updates\", MessageUpdatesHandler),\n        ],\n        cookie_secret=\"__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__\",\n        template_path=os.path.join(os.path.dirname(__file__), \"templates\"),\n        static_path=os.path.join(os.path.dirname(__file__), \"static\"),\n        xsrf_cookies=True,\n        debug=options.debug,\n    )\n    app.listen(options.port)\n    tornado.ioloop.IOLoop.current().start()\n\n\nif __name__ == \"__main__\":\n    main()\n", "description": "Tornado is a Python web framework and asynchronous networking library, originally developed at FriendFeed.", "file_name": "chatdemo.py", "id": "78a3db4271842b696b80c1e368e56194", "language": "Python", "project_name": "tornado", "quality": "", "save_path": "/home/ubuntu/test_files/clean/test/tornadoweb-tornado/tornadoweb-tornado-62e43f6/demos/chat/chatdemo.py", "save_time": "", "source": "", "update_at": "2018-03-13T23:11:42Z", "url": "https://github.com/tornadoweb/tornado", "wiki": true}