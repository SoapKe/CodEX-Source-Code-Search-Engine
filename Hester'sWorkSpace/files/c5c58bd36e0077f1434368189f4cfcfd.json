{"author": "mopidy", "code": "\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport pykka\n\nfrom mopidy import audio\n\n\ndef create_proxy(config=None, mixer=None):\n    return DummyAudio.start(config, mixer).proxy()\n\n\n?\nclass DummyAudio(pykka.ThreadingActor):\n\n    def __init__(self, config=None, mixer=None):\n        super(DummyAudio, self).__init__()\n        self.state = audio.PlaybackState.STOPPED\n        self._volume = 0\n        self._position = 0\n        self._callback = None\n        self._uri = None\n        self._stream_changed = False\n        self._tags = {}\n        self._bad_uris = set()\n\n    def set_uri(self, uri):\n        assert self._uri is None, 'prepare change not called before set'\n        self._tags = {}\n        self._uri = uri\n        self._stream_changed = True\n\n    def set_appsrc(self, *args, **kwargs):\n        pass\n\n    def emit_data(self, buffer_):\n        pass\n\n    def emit_end_of_stream(self):\n        pass\n\n    def get_position(self):\n        return self._position\n\n    def set_position(self, position):\n        self._position = position\n        audio.AudioListener.send('position_changed', position=position)\n        return True\n\n    def start_playback(self):\n        return self._change_state(audio.PlaybackState.PLAYING)\n\n    def pause_playback(self):\n        return self._change_state(audio.PlaybackState.PAUSED)\n\n    def prepare_change(self):\n        self._uri = None\n        return True\n\n    def stop_playback(self):\n        return self._change_state(audio.PlaybackState.STOPPED)\n\n    def get_volume(self):\n        return self._volume\n\n    def set_volume(self, volume):\n        self._volume = volume\n        return True\n\n    def set_metadata(self, track):\n        pass\n\n    def get_current_tags(self):\n        return self._tags\n\n    def set_about_to_finish_callback(self, callback):\n        self._callback = callback\n\n    def enable_sync_handler(self):\n        pass\n\n    def wait_for_state_change(self):\n        pass\n\n    def _change_state(self, new_state):\n        if not self._uri:\n            return False\n\n        if new_state == audio.PlaybackState.STOPPED and self._uri:\n            self._stream_changed = True\n            self._uri = None\n\n        if self._uri is not None:\n            audio.AudioListener.send('position_changed', position=0)\n\n        if self._stream_changed:\n            self._stream_changed = False\n            audio.AudioListener.send('stream_changed', uri=self._uri)\n\n        old_state, self.state = self.state, new_state\n        audio.AudioListener.send(\n            'state_changed',\n            old_state=old_state, new_state=new_state, target_state=None)\n\n        if new_state == audio.PlaybackState.PLAYING:\n            self._tags['audio-codec'] = [u'fake info...']\n            audio.AudioListener.send('tags_changed', tags=['audio-codec'])\n\n        return self._uri not in self._bad_uris\n\n    def trigger_fake_playback_failure(self, uri):\n        self._bad_uris.add(uri)\n\n    def trigger_fake_tags_changed(self, tags):\n        self._tags.update(tags)\n        audio.AudioListener.send('tags_changed', tags=self._tags.keys())\n\n    def get_about_to_finish_callback(self):\n        \n        def wrapper():\n            if self._callback:\n                self.prepare_change()\n                self._callback()\n\n            if not self._uri or not self._callback:\n                self._tags = {}\n                audio.AudioListener.send('reached_end_of_stream')\n            else:\n                audio.AudioListener.send('position_changed', position=0)\n                audio.AudioListener.send('stream_changed', uri=self._uri)\n\n        return wrapper\n", "comments": "   a dummy audio actor use tests   this class implements audio api simplest way possible  it used tests core backends         todo  reset position track change     this needs called outside actor lock  ", "content": "\"\"\"A dummy audio actor for use in tests.\n\nThis class implements the audio API in the simplest way possible. It is used in\ntests of the core and backends.\n\"\"\"\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport pykka\n\nfrom mopidy import audio\n\n\ndef create_proxy(config=None, mixer=None):\n    return DummyAudio.start(config, mixer).proxy()\n\n\n# TODO: reset position on track change?\nclass DummyAudio(pykka.ThreadingActor):\n\n    def __init__(self, config=None, mixer=None):\n        super(DummyAudio, self).__init__()\n        self.state = audio.PlaybackState.STOPPED\n        self._volume = 0\n        self._position = 0\n        self._callback = None\n        self._uri = None\n        self._stream_changed = False\n        self._tags = {}\n        self._bad_uris = set()\n\n    def set_uri(self, uri):\n        assert self._uri is None, 'prepare change not called before set'\n        self._tags = {}\n        self._uri = uri\n        self._stream_changed = True\n\n    def set_appsrc(self, *args, **kwargs):\n        pass\n\n    def emit_data(self, buffer_):\n        pass\n\n    def emit_end_of_stream(self):\n        pass\n\n    def get_position(self):\n        return self._position\n\n    def set_position(self, position):\n        self._position = position\n        audio.AudioListener.send('position_changed', position=position)\n        return True\n\n    def start_playback(self):\n        return self._change_state(audio.PlaybackState.PLAYING)\n\n    def pause_playback(self):\n        return self._change_state(audio.PlaybackState.PAUSED)\n\n    def prepare_change(self):\n        self._uri = None\n        return True\n\n    def stop_playback(self):\n        return self._change_state(audio.PlaybackState.STOPPED)\n\n    def get_volume(self):\n        return self._volume\n\n    def set_volume(self, volume):\n        self._volume = volume\n        return True\n\n    def set_metadata(self, track):\n        pass\n\n    def get_current_tags(self):\n        return self._tags\n\n    def set_about_to_finish_callback(self, callback):\n        self._callback = callback\n\n    def enable_sync_handler(self):\n        pass\n\n    def wait_for_state_change(self):\n        pass\n\n    def _change_state(self, new_state):\n        if not self._uri:\n            return False\n\n        if new_state == audio.PlaybackState.STOPPED and self._uri:\n            self._stream_changed = True\n            self._uri = None\n\n        if self._uri is not None:\n            audio.AudioListener.send('position_changed', position=0)\n\n        if self._stream_changed:\n            self._stream_changed = False\n            audio.AudioListener.send('stream_changed', uri=self._uri)\n\n        old_state, self.state = self.state, new_state\n        audio.AudioListener.send(\n            'state_changed',\n            old_state=old_state, new_state=new_state, target_state=None)\n\n        if new_state == audio.PlaybackState.PLAYING:\n            self._tags['audio-codec'] = [u'fake info...']\n            audio.AudioListener.send('tags_changed', tags=['audio-codec'])\n\n        return self._uri not in self._bad_uris\n\n    def trigger_fake_playback_failure(self, uri):\n        self._bad_uris.add(uri)\n\n    def trigger_fake_tags_changed(self, tags):\n        self._tags.update(tags)\n        audio.AudioListener.send('tags_changed', tags=self._tags.keys())\n\n    def get_about_to_finish_callback(self):\n        # This needs to be called from outside the actor or we lock up.\n        def wrapper():\n            if self._callback:\n                self.prepare_change()\n                self._callback()\n\n            if not self._uri or not self._callback:\n                self._tags = {}\n                audio.AudioListener.send('reached_end_of_stream')\n            else:\n                audio.AudioListener.send('position_changed', position=0)\n                audio.AudioListener.send('stream_changed', uri=self._uri)\n\n        return wrapper\n", "description": "Mopidy is an extensible music server that plays music from local disk, Spotify, SoundCloud, Google Play Music, and more. You edit the playlist from any phone, tablet, or computer using a range of MPD and web clients.", "file_name": "dummy_audio.py", "id": "c5c58bd36e0077f1434368189f4cfcfd", "language": "Python", "project_name": "mopidy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mopidy-mopidy/mopidy-mopidy-79d42c3/tests/dummy_audio.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:12:51Z", "url": "https://github.com/mopidy/mopidy", "wiki": false}