{"author": "donnemartin", "code": "# -*- coding: utf-8 -*-\n\nclass QueryApi(object):\n\n    def __init__(self, memory_cache, reverse_index_cluster):\n        self.memory_cache = memory_cache\n        self.reverse_index_cluster = reverse_index_cluster\n\n    def parse_query(self, query):\n        \"\"\"Remove markup, break text into terms, deal with typos,\n        normalize capitalization, convert to use boolean operations.\n        \"\"\"\n        ...\n\n    def process_query(self, query):\n        query = self.parse_query(query)\n        results = self.memory_cache.get(query)\n        if results is None:\n            results = self.reverse_index_cluster.process_search(query)\n            self.memory_cache.set(query, results)\n        return results\n\n\nclass Node(object):\n\n    def __init__(self, query, results):\n        self.query = query\n        self.results = results\n\n\nclass LinkedList(object):\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def move_to_front(self, node):\n        ...\n\n    def append_to_front(self, node):\n        ...\n\n    def remove_from_tail(self):\n        ...\n\n\nclass Cache(object):\n\n    def __init__(self, MAX_SIZE):\n        self.MAX_SIZE = MAX_SIZE\n        self.size = 0\n        self.lookup = {}\n        self.linked_list = LinkedList()\n\n    def get(self, query)\n        \"\"\"Get the stored query result from the cache.\n\n        Accessing a node updates its position to the front of the LRU list.\n        \"\"\"\n        node = self.lookup[query]\n        if node is None:\n            return None\n        self.linked_list.move_to_front(node)\n        return node.results\n\n    def set(self, results, query):\n        \"\"\"Set the result for the given query key in the cache.\n\n        When updating an entry, updates its position to the front of the LRU list.\n        If the entry is new and the cache is at capacity, removes the oldest entry\n        before the new entry is added.\n        \"\"\"\n        node = self.map[query]\n        if node is not None:\n            \n            node.results = results\n            self.linked_list.move_to_front(node)\n        else:\n            \n            if self.size == self.MAX_SIZE:\n                \n                self.lookup.pop(self.linked_list.tail.query, None)\n                self.linked_list.remove_from_tail()\n            else:\n                self.size += 1\n            \n            new_node = Node(query, results)\n            self.linked_list.append_to_front(new_node)\n            self.lookup[query] = new_node\n", "comments": "   remove markup  break text terms  deal typos          normalize capitalization  convert use boolean operations                               def process query(self  query)          query   self parse query(query)         results   self memory cache get(query)         results none              results   self reverse index cluster process search(query)             self memory cache set(query  results)         return results   class node(object)       def   init  (self  query  results)          self query   query         self results   results   class linkedlist(object)       def   init  (self)          self head   none         self tail   none      def move front(self  node)                   def append front(self  node)                   def remove tail(self)                class cache(object)       def   init  (self  max size)          self max size   max size         self size   0         self lookup              self linked list   linkedlist()      def get(self  query)            get stored query result cache           accessing node updates position front lru list                      node   self lookup query          node none              return none         self linked list move front(node)         return node results      def set(self  results  query)             set result given query key cache           when updating entry  updates position front lru list          if entry new cache capacity  removes oldest entry         new entry added                     coding  utf 8        key exists cache  update value    key exist cache    remove oldest entry linked list lookup    add new key value ", "content": "# -*- coding: utf-8 -*-\n\nclass QueryApi(object):\n\n    def __init__(self, memory_cache, reverse_index_cluster):\n        self.memory_cache = memory_cache\n        self.reverse_index_cluster = reverse_index_cluster\n\n    def parse_query(self, query):\n        \"\"\"Remove markup, break text into terms, deal with typos,\n        normalize capitalization, convert to use boolean operations.\n        \"\"\"\n        ...\n\n    def process_query(self, query):\n        query = self.parse_query(query)\n        results = self.memory_cache.get(query)\n        if results is None:\n            results = self.reverse_index_cluster.process_search(query)\n            self.memory_cache.set(query, results)\n        return results\n\n\nclass Node(object):\n\n    def __init__(self, query, results):\n        self.query = query\n        self.results = results\n\n\nclass LinkedList(object):\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def move_to_front(self, node):\n        ...\n\n    def append_to_front(self, node):\n        ...\n\n    def remove_from_tail(self):\n        ...\n\n\nclass Cache(object):\n\n    def __init__(self, MAX_SIZE):\n        self.MAX_SIZE = MAX_SIZE\n        self.size = 0\n        self.lookup = {}\n        self.linked_list = LinkedList()\n\n    def get(self, query)\n        \"\"\"Get the stored query result from the cache.\n\n        Accessing a node updates its position to the front of the LRU list.\n        \"\"\"\n        node = self.lookup[query]\n        if node is None:\n            return None\n        self.linked_list.move_to_front(node)\n        return node.results\n\n    def set(self, results, query):\n        \"\"\"Set the result for the given query key in the cache.\n\n        When updating an entry, updates its position to the front of the LRU list.\n        If the entry is new and the cache is at capacity, removes the oldest entry\n        before the new entry is added.\n        \"\"\"\n        node = self.map[query]\n        if node is not None:\n            # Key exists in cache, update the value\n            node.results = results\n            self.linked_list.move_to_front(node)\n        else:\n            # Key does not exist in cache\n            if self.size == self.MAX_SIZE:\n                # Remove the oldest entry from the linked list and lookup\n                self.lookup.pop(self.linked_list.tail.query, None)\n                self.linked_list.remove_from_tail()\n            else:\n                self.size += 1\n            # Add the new key and value\n            new_node = Node(query, results)\n            self.linked_list.append_to_front(new_node)\n            self.lookup[query] = new_node\n", "description": "Learn how to design large-scale systems. Prep for the system design interview.  Includes Anki flashcards.", "file_name": "query_cache_snippets.py", "id": "f36c7d4488823913b3453bd54454496f", "language": "Python", "project_name": "system-design-primer", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/donnemartin-system-design-primer/donnemartin-system-design-primer-38a93dc/solutions/system_design/query_cache/query_cache_snippets.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:58:48Z", "url": "https://github.com/donnemartin/system-design-primer", "wiki": true}