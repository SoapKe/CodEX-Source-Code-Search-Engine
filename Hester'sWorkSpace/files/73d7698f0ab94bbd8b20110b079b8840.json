{"author": "ansible", "code": "\n# -*- coding: utf-8 -*-\n\n# (c) 2013, John Dewey <john@dewey.ws>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: rabbitmq_policy\nshort_description: Manage the state of policies in RabbitMQ.\ndescription:\n  - Manage the state of a policy in RabbitMQ.\nversion_added: \"1.5\"\nauthor: \"John Dewey (@retr0h)\"\noptions:\n  name:\n    description:\n      - The name of the policy to manage.\n    required: true\n  vhost:\n    description:\n      - The name of the vhost to apply to.\n    default: /\n  apply_to:\n    description:\n      - What the policy applies to. Requires RabbitMQ 3.2.0 or later.\n    default: all\n    choices: [all, exchanges, queues]\n    version_added: \"2.1\"\n  pattern:\n    description:\n      - A regex of queues to apply the policy to.\n    required: true\n  tags:\n    description:\n      - A dict or string describing the policy.\n    required: true\n  priority:\n    description:\n      - The priority of the policy.\n    default: 0\n  node:\n    description:\n      - Erlang node name of the rabbit we wish to configure.\n    default: rabbit\n  state:\n    description:\n      - The state of the policy.\n    default: present\n    choices: [present, absent]\n'''\n\nEXAMPLES = '''\n- name: ensure the default vhost contains the HA policy via a dict\n  rabbitmq_policy:\n    name: HA\n    pattern: .*\n  args:\n    tags:\n      ha-mode: all\n\n- name: ensure the default vhost contains the HA policy\n  rabbitmq_policy:\n    name: HA\n    pattern: .*\n    tags:\n      ha-mode: all\n'''\n\nimport json\nfrom ansible.module_utils.basic import AnsibleModule\n\n\nclass RabbitMqPolicy(object):\n\n    def __init__(self, module, name):\n        self._module = module\n        self._name = name\n        self._vhost = module.params['vhost']\n        self._pattern = module.params['pattern']\n        self._apply_to = module.params['apply_to']\n        self._tags = module.params['tags']\n        self._priority = module.params['priority']\n        self._node = module.params['node']\n        self._rabbitmqctl = module.get_bin_path('rabbitmqctl', True)\n\n    def _exec(self, args, run_in_check_mode=False):\n        if not self._module.check_mode or (self._module.check_mode and run_in_check_mode):\n            cmd = [self._rabbitmqctl, '-q', '-n', self._node]\n            args.insert(1, '-p')\n            args.insert(2, self._vhost)\n            rc, out, err = self._module.run_command(cmd + args, check_rc=True)\n            return out.splitlines()\n        return list()\n\n    def list(self):\n        policies = self._exec(['list_policies'], True)\n\n        for policy in policies:\n            if not policy:\n                continue\n            policy_name = policy.split('\\t')[1]\n            if policy_name == self._name:\n                return True\n        return False\n\n    def set(self):\n        args = ['set_policy']\n        args.append(self._name)\n        args.append(self._pattern)\n        args.append(json.dumps(self._tags))\n        args.append('--priority')\n        args.append(self._priority)\n        if self._apply_to != 'all':\n            args.append('--apply-to')\n            args.append(self._apply_to)\n        return self._exec(args)\n\n    def clear(self):\n        return self._exec(['clear_policy', self._name])\n\n\ndef main():\n    arg_spec = dict(\n        name=dict(required=True),\n        vhost=dict(default='/'),\n        pattern=dict(required=True),\n        apply_to=dict(default='all', choices=['all', 'exchanges', 'queues']),\n        tags=dict(type='dict', required=True),\n        priority=dict(default='0'),\n        node=dict(default='rabbit'),\n        state=dict(default='present', choices=['present', 'absent']),\n    )\n\n    module = AnsibleModule(\n        argument_spec=arg_spec,\n        supports_check_mode=True\n    )\n\n    name = module.params['name']\n    state = module.params['state']\n    rabbitmq_policy = RabbitMqPolicy(module, name)\n\n    result = dict(changed=False, name=name, state=state)\n    if rabbitmq_policy.list():\n        if state == 'absent':\n            rabbitmq_policy.clear()\n            result['changed'] = True\n        else:\n            result['changed'] = False\n    elif state == 'present':\n        rabbitmq_policy.set()\n        result['changed'] = True\n\n    module.exit_json(**result)\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  rabbitmq policy short description  manage state policies rabbitmq  description      manage state policy rabbitmq  version added   1 5  author   john dewey ( retr0h)  options    name      description          the name policy manage      required  true   vhost      description          the name vhost apply      default      apply      description          what policy applies  requires rabbitmq 3 2 0 later      default      choices    exchanges  queues      version added   2 1    pattern      description          a regex queues apply policy      required  true   tags      description          a dict string describing policy      required  true   priority      description          the priority policy      default  0   node      description          erlang node name rabbit wish configure      default  rabbit   state      description          the state policy      default  present     choices   present  absent       examples         name  ensure default vhost contains ha policy via dict   rabbitmq policy      name  ha     pattern       args      tags        ha mode     name  ensure default vhost contains ha policy   rabbitmq policy      name  ha     pattern         tags        ha mode          usr bin python        coding  utf 8        (c) 2013  john dewey  john dewey ws     gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt) ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# (c) 2013, John Dewey <john@dewey.ws>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: rabbitmq_policy\nshort_description: Manage the state of policies in RabbitMQ.\ndescription:\n  - Manage the state of a policy in RabbitMQ.\nversion_added: \"1.5\"\nauthor: \"John Dewey (@retr0h)\"\noptions:\n  name:\n    description:\n      - The name of the policy to manage.\n    required: true\n  vhost:\n    description:\n      - The name of the vhost to apply to.\n    default: /\n  apply_to:\n    description:\n      - What the policy applies to. Requires RabbitMQ 3.2.0 or later.\n    default: all\n    choices: [all, exchanges, queues]\n    version_added: \"2.1\"\n  pattern:\n    description:\n      - A regex of queues to apply the policy to.\n    required: true\n  tags:\n    description:\n      - A dict or string describing the policy.\n    required: true\n  priority:\n    description:\n      - The priority of the policy.\n    default: 0\n  node:\n    description:\n      - Erlang node name of the rabbit we wish to configure.\n    default: rabbit\n  state:\n    description:\n      - The state of the policy.\n    default: present\n    choices: [present, absent]\n'''\n\nEXAMPLES = '''\n- name: ensure the default vhost contains the HA policy via a dict\n  rabbitmq_policy:\n    name: HA\n    pattern: .*\n  args:\n    tags:\n      ha-mode: all\n\n- name: ensure the default vhost contains the HA policy\n  rabbitmq_policy:\n    name: HA\n    pattern: .*\n    tags:\n      ha-mode: all\n'''\n\nimport json\nfrom ansible.module_utils.basic import AnsibleModule\n\n\nclass RabbitMqPolicy(object):\n\n    def __init__(self, module, name):\n        self._module = module\n        self._name = name\n        self._vhost = module.params['vhost']\n        self._pattern = module.params['pattern']\n        self._apply_to = module.params['apply_to']\n        self._tags = module.params['tags']\n        self._priority = module.params['priority']\n        self._node = module.params['node']\n        self._rabbitmqctl = module.get_bin_path('rabbitmqctl', True)\n\n    def _exec(self, args, run_in_check_mode=False):\n        if not self._module.check_mode or (self._module.check_mode and run_in_check_mode):\n            cmd = [self._rabbitmqctl, '-q', '-n', self._node]\n            args.insert(1, '-p')\n            args.insert(2, self._vhost)\n            rc, out, err = self._module.run_command(cmd + args, check_rc=True)\n            return out.splitlines()\n        return list()\n\n    def list(self):\n        policies = self._exec(['list_policies'], True)\n\n        for policy in policies:\n            if not policy:\n                continue\n            policy_name = policy.split('\\t')[1]\n            if policy_name == self._name:\n                return True\n        return False\n\n    def set(self):\n        args = ['set_policy']\n        args.append(self._name)\n        args.append(self._pattern)\n        args.append(json.dumps(self._tags))\n        args.append('--priority')\n        args.append(self._priority)\n        if self._apply_to != 'all':\n            args.append('--apply-to')\n            args.append(self._apply_to)\n        return self._exec(args)\n\n    def clear(self):\n        return self._exec(['clear_policy', self._name])\n\n\ndef main():\n    arg_spec = dict(\n        name=dict(required=True),\n        vhost=dict(default='/'),\n        pattern=dict(required=True),\n        apply_to=dict(default='all', choices=['all', 'exchanges', 'queues']),\n        tags=dict(type='dict', required=True),\n        priority=dict(default='0'),\n        node=dict(default='rabbit'),\n        state=dict(default='present', choices=['present', 'absent']),\n    )\n\n    module = AnsibleModule(\n        argument_spec=arg_spec,\n        supports_check_mode=True\n    )\n\n    name = module.params['name']\n    state = module.params['state']\n    rabbitmq_policy = RabbitMqPolicy(module, name)\n\n    result = dict(changed=False, name=name, state=state)\n    if rabbitmq_policy.list():\n        if state == 'absent':\n            rabbitmq_policy.clear()\n            result['changed'] = True\n        else:\n            result['changed'] = False\n    elif state == 'present':\n        rabbitmq_policy.set()\n        result['changed'] = True\n\n    module.exit_json(**result)\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "rabbitmq_policy.py", "id": "73d7698f0ab94bbd8b20110b079b8840", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/messaging/rabbitmq_policy.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}