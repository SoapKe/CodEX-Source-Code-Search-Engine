{"author": "ansible", "code": "\n -*- coding: utf-8 -*-\n\n Copyright: (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>, and others\n Copyright: (c) 2016, Toshio Kuratomi <tkuratomi@ansible.com>\n\n GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['stableinterface'],\n                    'supported_by': 'core'}\n\nDOCUMENTATION = '''\n---\nmodule: command\nshort_description: Executes a command on a remote node\nversion_added: historical\ndescription:\n     - The C(command) module takes the command name followed by a list of space-delimited arguments.\n     - The given command will be executed on all selected nodes. It will not be\n       processed through the shell, so variables like C($HOME) and operations\n       like C(\"<\"), C(\">\"), C(\"|\"), C(\";\") and C(\"&\") will not work (use the M(shell)\n       module if you need these features).\n     - For Windows targets, use the M(win_command) module instead.\noptions:\n  free_form:\n    description:\n      - The command module takes a free form command to run.  There is no parameter actually named 'free form'.\n        See the examples!\n    required: yes\n  creates:\n    description:\n      - A filename or (since 2.0) glob pattern, when it already exists, this step will B(not) be run.\n  removes:\n    description:\n      - A filename or (since 2.0) glob pattern, when it does not exist, this step will B(not) be run.\n    version_added: \"0.8\"\n  chdir:\n    description:\n      - Change into this directory before running the command.\n    version_added: \"0.6\"\n  warn:\n    description:\n      - If command_warnings are on in ansible.cfg, do not warn about this particular line if set to C(no).\n    type: bool\n    default: 'yes'\n    version_added: \"1.8\"\n  stdin:\n    version_added: \"2.4\"\n    description:\n      - Set the stdin of the command directly to the specified value.\nnotes:\n    -  If you want to run a command through the shell (say you are using C(<), C(>), C(|), etc), you actually want the M(shell) module instead.\n       Parsing shell metacharacters can lead to unexpected commands being executed if quoting is not done correctly so it is more secure to\n       use the C(command) module when possible.\n    -  \" C(creates), C(removes), and C(chdir) can be specified after the command.\n       For instance, if you only want to run a command if a certain file does not exist, use this.\"\n    -  The C(executable) parameter is removed since version 2.4. If you have a need for this parameter, use the M(shell) module instead.\n    -  For Windows targets, use the M(win_command) module instead.\nauthor:\n    - Ansible Core Team\n    - Michael DeHaan\n'''\n\nEXAMPLES = '''\n- name: return motd to registered var\n  command: cat /etc/motd\n  register: mymotd\n\n- name: Run the command if the specified file does not exist.\n  command: /usr/bin/make_database.sh arg1 arg2 creates=/path/to/database\n\n You can also use the 'args' form to provide the options.\n- name: This command will change the working directory to somedir/ and will only run when /path/to/database doesn't exist.\n  command: /usr/bin/make_database.sh arg1 arg2\n  args:\n    chdir: somedir/\n    creates: /path/to/database\n\n- name: safely use templated variable to run command. Always use the quote filter to avoid injection issues.\n  command: cat {{ myfile|\n\nimport datetime\nimport glob\nimport os\nimport shlex\n\nfrom ansible.module_utils.basic import AnsibleModule\n\n\ndef check_command(module, commandline):\n    arguments = {'chown': 'owner', 'chmod': 'mode', 'chgrp': 'group',\n                 'ln': 'state=link', 'mkdir': 'state=directory',\n                 'rmdir': 'state=absent', 'rm': 'state=absent', 'touch': 'state=touch'}\n    commands = {'curl': 'get_url or uri', 'wget': 'get_url or uri',\n                'svn': 'subversion', 'service': 'service',\n                'mount': 'mount', 'rpm': 'yum, dnf or zypper', 'yum': 'yum', 'apt-get': 'apt',\n                'tar': 'unarchive', 'unzip': 'unarchive', 'sed': 'replace, lineinfile or template',\n                'dnf': 'dnf', 'zypper': 'zypper'}\n    become = ['sudo', 'su', 'pbrun', 'pfexec', 'runas', 'pmrun']\n    command = os.path.basename(commandline.split()[0])\n\n    disable_suffix = \"If you need to use command because {mod} is insufficient you can add\" \\\n                     \" warn=False to this command task or set command_warnings=False in\" \\\n                     \" ansible.cfg to get rid of this message.\"\n    substitutions = {'mod': None, 'cmd': command}\n\n    if command in arguments:\n        msg = \"Consider using the {mod} module with {subcmd} rather than running {cmd}.  \" + disable_suffix\n        substitutions['mod'] = 'file'\n        substitutions['subcmd'] = arguments[command]\n        module.warn(msg.format(**substitutions))\n\n    if command in commands:\n        msg = \"Consider using the {mod} module rather than running {cmd}.  \" + disable_suffix\n        substitutions['mod'] = commands[command]\n        module.warn(msg.format(**substitutions))\n\n    if command in become:\n        module.warn(\"Consider using 'become', 'become_method', and 'become_user' rather than running %s\" % (command,))\n\n\ndef main():\n\n     the command module is the one ansible module that does not take key=value args\n     hence don't copy this one if you are looking to build others!\n    module = AnsibleModule(\n        argument_spec=dict(\n            _raw_params=dict(),\n            _uses_shell=dict(type='bool', default=False),\n            chdir=dict(type='path'),\n            executable=dict(),\n            creates=dict(type='path'),\n            removes=dict(type='path'),\n             The default for this really comes from the action plugin\n            warn=dict(type='bool', default=True),\n            stdin=dict(required=False),\n        )\n    )\n\n    shell = module.params['_uses_shell']\n    chdir = module.params['chdir']\n    executable = module.params['executable']\n    args = module.params['_raw_params']\n    creates = module.params['creates']\n    removes = module.params['removes']\n    warn = module.params['warn']\n    stdin = module.params['stdin']\n\n    if not shell and executable:\n        module.warn(\"As of Ansible 2.4, the parameter 'executable' is no longer supported with the 'command' module. Not using '%s'.\" % executable)\n        executable = None\n\n    if not args or args.strip() == '':\n        module.fail_json(rc=256, msg=\"no command given\")\n\n    if chdir:\n        chdir = os.path.abspath(chdir)\n        os.chdir(chdir)\n\n    if creates:\n         do not run the command if the line contains creates=filename\n         and the filename already exists.  This allows idempotence\n         of command executions.\n        if glob.glob(creates):\n            module.exit_json(\n                cmd=args,\n                stdout=\"skipped, since %s exists\" % creates,\n                changed=False,\n                rc=0\n            )\n\n    if removes:\n         do not run the command if the line contains removes=filename\n         and the filename does not exist.  This allows idempotence\n         of command executions.\n        if not glob.glob(removes):\n            module.exit_json(\n                cmd=args,\n                stdout=\"skipped, since %s does not exist\" % removes,\n                changed=False,\n                rc=0\n            )\n\n    if warn:\n        check_command(module, args)\n\n    if not shell:\n        args = shlex.split(args)\n    startd = datetime.datetime.now()\n\n    rc, out, err = module.run_command(args, executable=executable, use_unsafe_shell=shell, encoding=None, data=stdin)\n\n    endd = datetime.datetime.now()\n    delta = endd - startd\n\n    result = dict(\n        cmd=args,\n        stdout=out.rstrip(b\"\\r\\n\"),\n        stderr=err.rstrip(b\"\\r\\n\"),\n        rc=rc,\n        start=str(startd),\n        end=str(endd),\n        delta=str(delta),\n        changed=True,\n    )\n\n    if rc != 0:\n        module.fail_json(msg='non-zero return code', **result)\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  command short description  executes command remote node version added  historical description         the c(command) module takes command name followed list space delimited arguments         the given command executed selected nodes  it        processed shell  variables like c( home) operations        like c(   )  c(   )  c(   )  c(   ) c(   ) work (use m(shell)        module need features)         for windows targets  use m(win command) module instead  options    free form      description          the command module takes free form command run   there parameter actually named  free form           see examples      required  yes   creates      description          a filename (since 2 0) glob pattern  already exists  step b(not) run    removes      description          a filename (since 2 0) glob pattern  exist  step b(not) run      version added   0 8    chdir      description          change directory running command      version added   0 6    warn      description          if command warnings ansible cfg  warn particular line set c(no)      type  bool     default   yes      version added   1 8    stdin      version added   2 4      description          set stdin command directly specified value  notes         if want run command shell (say using c( )  c( )  c( )  etc)  actually want m(shell) module instead         parsing shell metacharacters lead unexpected commands executed quoting done correctly secure        use c(command) module possible           c(creates)  c(removes)  c(chdir) specified command         for instance  want run command certain file exist  use          the c(executable) parameter removed since version 2 4  if need parameter  use m(shell) module instead         for windows targets  use m(win command) module instead  author        ansible core team       michael dehaan      examples         name  return motd registered var   command  cat  etc motd   register  mymotd    name  run command specified file exist    command   usr bin make database sh arg1 arg2 creates  path database    you also use  args  form provide options    name  this command change working directory somedir  run  path database exist    command   usr bin make database sh arg1 arg2   args      chdir  somedir      creates   path database    name  safely use templated variable run command  always use quote filter avoid injection issues    command  cat    myfile quote      register  myoutput      return       cmd    description  cmd run remote machine   returned  always   type  list   sample      echo     hello delta    description  cmd end time   cmd start time   returned  always   type  string   sample  0 00 00 001529 end    description  cmd end time   returned  always   type  string   sample   2017 09 29 22 03 48 084657  start    description  cmd start time   returned  always   type  string   sample   2017 09 29 22 03 48 083128          usr bin python        coding  utf 8        copyright  (c) 2012  michael dehaan  michael dehaan gmail com   others    copyright  (c) 2016  toshio kuratomi  tkuratomi ansible com        gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    you also use  args  form provide options     command module one ansible module take key value args    hence copy one looking build others     the default really comes action plugin    run command line contains creates filename    filename already exists   this allows idempotence    command executions     run command line contains removes filename    filename exist   this allows idempotence    command executions  ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>, and others\n# Copyright: (c) 2016, Toshio Kuratomi <tkuratomi@ansible.com>\n#\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['stableinterface'],\n                    'supported_by': 'core'}\n\nDOCUMENTATION = '''\n---\nmodule: command\nshort_description: Executes a command on a remote node\nversion_added: historical\ndescription:\n     - The C(command) module takes the command name followed by a list of space-delimited arguments.\n     - The given command will be executed on all selected nodes. It will not be\n       processed through the shell, so variables like C($HOME) and operations\n       like C(\"<\"), C(\">\"), C(\"|\"), C(\";\") and C(\"&\") will not work (use the M(shell)\n       module if you need these features).\n     - For Windows targets, use the M(win_command) module instead.\noptions:\n  free_form:\n    description:\n      - The command module takes a free form command to run.  There is no parameter actually named 'free form'.\n        See the examples!\n    required: yes\n  creates:\n    description:\n      - A filename or (since 2.0) glob pattern, when it already exists, this step will B(not) be run.\n  removes:\n    description:\n      - A filename or (since 2.0) glob pattern, when it does not exist, this step will B(not) be run.\n    version_added: \"0.8\"\n  chdir:\n    description:\n      - Change into this directory before running the command.\n    version_added: \"0.6\"\n  warn:\n    description:\n      - If command_warnings are on in ansible.cfg, do not warn about this particular line if set to C(no).\n    type: bool\n    default: 'yes'\n    version_added: \"1.8\"\n  stdin:\n    version_added: \"2.4\"\n    description:\n      - Set the stdin of the command directly to the specified value.\nnotes:\n    -  If you want to run a command through the shell (say you are using C(<), C(>), C(|), etc), you actually want the M(shell) module instead.\n       Parsing shell metacharacters can lead to unexpected commands being executed if quoting is not done correctly so it is more secure to\n       use the C(command) module when possible.\n    -  \" C(creates), C(removes), and C(chdir) can be specified after the command.\n       For instance, if you only want to run a command if a certain file does not exist, use this.\"\n    -  The C(executable) parameter is removed since version 2.4. If you have a need for this parameter, use the M(shell) module instead.\n    -  For Windows targets, use the M(win_command) module instead.\nauthor:\n    - Ansible Core Team\n    - Michael DeHaan\n'''\n\nEXAMPLES = '''\n- name: return motd to registered var\n  command: cat /etc/motd\n  register: mymotd\n\n- name: Run the command if the specified file does not exist.\n  command: /usr/bin/make_database.sh arg1 arg2 creates=/path/to/database\n\n# You can also use the 'args' form to provide the options.\n- name: This command will change the working directory to somedir/ and will only run when /path/to/database doesn't exist.\n  command: /usr/bin/make_database.sh arg1 arg2\n  args:\n    chdir: somedir/\n    creates: /path/to/database\n\n- name: safely use templated variable to run command. Always use the quote filter to avoid injection issues.\n  command: cat {{ myfile|quote }}\n  register: myoutput\n'''\n\nRETURN = '''\ncmd:\n  description: the cmd that was run on the remote machine\n  returned: always\n  type: list\n  sample:\n  - echo\n  - hello\ndelta:\n  description: cmd end time - cmd start time\n  returned: always\n  type: string\n  sample: 0:00:00.001529\nend:\n  description: cmd end time\n  returned: always\n  type: string\n  sample: '2017-09-29 22:03:48.084657'\nstart:\n  description: cmd start time\n  returned: always\n  type: string\n  sample: '2017-09-29 22:03:48.083128'\n'''\n\nimport datetime\nimport glob\nimport os\nimport shlex\n\nfrom ansible.module_utils.basic import AnsibleModule\n\n\ndef check_command(module, commandline):\n    arguments = {'chown': 'owner', 'chmod': 'mode', 'chgrp': 'group',\n                 'ln': 'state=link', 'mkdir': 'state=directory',\n                 'rmdir': 'state=absent', 'rm': 'state=absent', 'touch': 'state=touch'}\n    commands = {'curl': 'get_url or uri', 'wget': 'get_url or uri',\n                'svn': 'subversion', 'service': 'service',\n                'mount': 'mount', 'rpm': 'yum, dnf or zypper', 'yum': 'yum', 'apt-get': 'apt',\n                'tar': 'unarchive', 'unzip': 'unarchive', 'sed': 'replace, lineinfile or template',\n                'dnf': 'dnf', 'zypper': 'zypper'}\n    become = ['sudo', 'su', 'pbrun', 'pfexec', 'runas', 'pmrun']\n    command = os.path.basename(commandline.split()[0])\n\n    disable_suffix = \"If you need to use command because {mod} is insufficient you can add\" \\\n                     \" warn=False to this command task or set command_warnings=False in\" \\\n                     \" ansible.cfg to get rid of this message.\"\n    substitutions = {'mod': None, 'cmd': command}\n\n    if command in arguments:\n        msg = \"Consider using the {mod} module with {subcmd} rather than running {cmd}.  \" + disable_suffix\n        substitutions['mod'] = 'file'\n        substitutions['subcmd'] = arguments[command]\n        module.warn(msg.format(**substitutions))\n\n    if command in commands:\n        msg = \"Consider using the {mod} module rather than running {cmd}.  \" + disable_suffix\n        substitutions['mod'] = commands[command]\n        module.warn(msg.format(**substitutions))\n\n    if command in become:\n        module.warn(\"Consider using 'become', 'become_method', and 'become_user' rather than running %s\" % (command,))\n\n\ndef main():\n\n    # the command module is the one ansible module that does not take key=value args\n    # hence don't copy this one if you are looking to build others!\n    module = AnsibleModule(\n        argument_spec=dict(\n            _raw_params=dict(),\n            _uses_shell=dict(type='bool', default=False),\n            chdir=dict(type='path'),\n            executable=dict(),\n            creates=dict(type='path'),\n            removes=dict(type='path'),\n            # The default for this really comes from the action plugin\n            warn=dict(type='bool', default=True),\n            stdin=dict(required=False),\n        )\n    )\n\n    shell = module.params['_uses_shell']\n    chdir = module.params['chdir']\n    executable = module.params['executable']\n    args = module.params['_raw_params']\n    creates = module.params['creates']\n    removes = module.params['removes']\n    warn = module.params['warn']\n    stdin = module.params['stdin']\n\n    if not shell and executable:\n        module.warn(\"As of Ansible 2.4, the parameter 'executable' is no longer supported with the 'command' module. Not using '%s'.\" % executable)\n        executable = None\n\n    if not args or args.strip() == '':\n        module.fail_json(rc=256, msg=\"no command given\")\n\n    if chdir:\n        chdir = os.path.abspath(chdir)\n        os.chdir(chdir)\n\n    if creates:\n        # do not run the command if the line contains creates=filename\n        # and the filename already exists.  This allows idempotence\n        # of command executions.\n        if glob.glob(creates):\n            module.exit_json(\n                cmd=args,\n                stdout=\"skipped, since %s exists\" % creates,\n                changed=False,\n                rc=0\n            )\n\n    if removes:\n        # do not run the command if the line contains removes=filename\n        # and the filename does not exist.  This allows idempotence\n        # of command executions.\n        if not glob.glob(removes):\n            module.exit_json(\n                cmd=args,\n                stdout=\"skipped, since %s does not exist\" % removes,\n                changed=False,\n                rc=0\n            )\n\n    if warn:\n        check_command(module, args)\n\n    if not shell:\n        args = shlex.split(args)\n    startd = datetime.datetime.now()\n\n    rc, out, err = module.run_command(args, executable=executable, use_unsafe_shell=shell, encoding=None, data=stdin)\n\n    endd = datetime.datetime.now()\n    delta = endd - startd\n\n    result = dict(\n        cmd=args,\n        stdout=out.rstrip(b\"\\r\\n\"),\n        stderr=err.rstrip(b\"\\r\\n\"),\n        rc=rc,\n        start=str(startd),\n        end=str(endd),\n        delta=str(delta),\n        changed=True,\n    )\n\n    if rc != 0:\n        module.fail_json(msg='non-zero return code', **result)\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "command.py", "id": "0fc584246529a519fbf19869254ff953", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/commands/command.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}