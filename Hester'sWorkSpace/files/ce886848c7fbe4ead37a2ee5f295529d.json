{"author": "rg3", "code": "from __future__ import unicode_literals\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    clean_html,\n    determine_ext,\n    int_or_none,\n    qualities,\n    urlencode_postdata,\n    xpath_text,\n)\n\n\nclass NFBIE(InfoExtractor):\n    IE_NAME = 'nfb'\n    IE_DESC = 'National Film Board of Canada'\n    _VALID_URL = r'https?://(?:www\\.)?(?:nfb|onf)\\.ca/film/(?P<id>[\\da-z_-]+)'\n\n    _TEST = {\n        'url': 'https://www.nfb.ca/film/qallunaat_why_white_people_are_funny',\n        'info_dict': {\n            'id': 'qallunaat_why_white_people_are_funny',\n            'ext': 'flv',\n            'title': 'Qallunaat! Why White People Are Funny ',\n            'description': 'md5:6b8e32dde3abf91e58857b174916620c',\n            'duration': 3128,\n            'creator': 'Mark Sandiford',\n            'uploader': 'Mark Sandiford',\n        },\n        'params': {\n            \n            'skip_download': True,\n        }\n    }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        config = self._download_xml(\n            'https://www.nfb.ca/film/%s/player_config' % video_id,\n            video_id, 'Downloading player config XML',\n            data=urlencode_postdata({'getConfig': 'true'}),\n            headers={\n                'Content-Type': 'application/x-www-form-urlencoded',\n                'X-NFB-Referer': 'http://www.nfb.ca/medias/flash/NFBVideoPlayer.swf'\n            })\n\n        title, description, thumbnail, duration, uploader, author = [None] * 6\n        thumbnails, formats = [[]] * 2\n        subtitles = {}\n\n        for media in config.findall('./player/stream/media'):\n            if media.get('type') == 'posterImage':\n                quality_key = qualities(('low', 'high'))\n                thumbnails = []\n                for asset in media.findall('assets/asset'):\n                    asset_url = xpath_text(asset, 'default/url', default=None)\n                    if not asset_url:\n                        continue\n                    quality = asset.get('quality')\n                    thumbnails.append({\n                        'url': asset_url,\n                        'id': quality,\n                        'preference': quality_key(quality),\n                    })\n            elif media.get('type') == 'video':\n                title = xpath_text(media, 'title', fatal=True)\n                for asset in media.findall('assets/asset'):\n                    quality = asset.get('quality')\n                    height = int_or_none(self._search_regex(\n                        r'^(\\d+)[pP]$', quality or '', 'height', default=None))\n                    for node in asset:\n                        streamer = xpath_text(node, 'streamerURI', default=None)\n                        if not streamer:\n                            continue\n                        play_path = xpath_text(node, 'url', default=None)\n                        if not play_path:\n                            continue\n                        formats.append({\n                            'url': streamer,\n                            'app': streamer.split('/', 3)[3],\n                            'play_path': play_path,\n                            'rtmp_live': False,\n                            'ext': 'flv',\n                            'format_id': '%s-%s' % (node.tag, quality) if quality else node.tag,\n                            'height': height,\n                        })\n                self._sort_formats(formats)\n                description = clean_html(xpath_text(media, 'description'))\n                uploader = xpath_text(media, 'author')\n                duration = int_or_none(media.get('duration'))\n                for subtitle in media.findall('./subtitles/subtitle'):\n                    subtitle_url = xpath_text(subtitle, 'url', default=None)\n                    if not subtitle_url:\n                        continue\n                    lang = xpath_text(subtitle, 'lang', default='en')\n                    subtitles.setdefault(lang, []).append({\n                        'url': subtitle_url,\n                        'ext': (subtitle.get('format') or determine_ext(subtitle_url)).lower(),\n                    })\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'thumbnails': thumbnails,\n            'duration': duration,\n            'creator': uploader,\n            'uploader': uploader,\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n", "comments": "# rtmp download\n", "content": "from __future__ import unicode_literals\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    clean_html,\n    determine_ext,\n    int_or_none,\n    qualities,\n    urlencode_postdata,\n    xpath_text,\n)\n\n\nclass NFBIE(InfoExtractor):\n    IE_NAME = 'nfb'\n    IE_DESC = 'National Film Board of Canada'\n    _VALID_URL = r'https?://(?:www\\.)?(?:nfb|onf)\\.ca/film/(?P<id>[\\da-z_-]+)'\n\n    _TEST = {\n        'url': 'https://www.nfb.ca/film/qallunaat_why_white_people_are_funny',\n        'info_dict': {\n            'id': 'qallunaat_why_white_people_are_funny',\n            'ext': 'flv',\n            'title': 'Qallunaat! Why White People Are Funny ',\n            'description': 'md5:6b8e32dde3abf91e58857b174916620c',\n            'duration': 3128,\n            'creator': 'Mark Sandiford',\n            'uploader': 'Mark Sandiford',\n        },\n        'params': {\n            # rtmp download\n            'skip_download': True,\n        }\n    }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        config = self._download_xml(\n            'https://www.nfb.ca/film/%s/player_config' % video_id,\n            video_id, 'Downloading player config XML',\n            data=urlencode_postdata({'getConfig': 'true'}),\n            headers={\n                'Content-Type': 'application/x-www-form-urlencoded',\n                'X-NFB-Referer': 'http://www.nfb.ca/medias/flash/NFBVideoPlayer.swf'\n            })\n\n        title, description, thumbnail, duration, uploader, author = [None] * 6\n        thumbnails, formats = [[]] * 2\n        subtitles = {}\n\n        for media in config.findall('./player/stream/media'):\n            if media.get('type') == 'posterImage':\n                quality_key = qualities(('low', 'high'))\n                thumbnails = []\n                for asset in media.findall('assets/asset'):\n                    asset_url = xpath_text(asset, 'default/url', default=None)\n                    if not asset_url:\n                        continue\n                    quality = asset.get('quality')\n                    thumbnails.append({\n                        'url': asset_url,\n                        'id': quality,\n                        'preference': quality_key(quality),\n                    })\n            elif media.get('type') == 'video':\n                title = xpath_text(media, 'title', fatal=True)\n                for asset in media.findall('assets/asset'):\n                    quality = asset.get('quality')\n                    height = int_or_none(self._search_regex(\n                        r'^(\\d+)[pP]$', quality or '', 'height', default=None))\n                    for node in asset:\n                        streamer = xpath_text(node, 'streamerURI', default=None)\n                        if not streamer:\n                            continue\n                        play_path = xpath_text(node, 'url', default=None)\n                        if not play_path:\n                            continue\n                        formats.append({\n                            'url': streamer,\n                            'app': streamer.split('/', 3)[3],\n                            'play_path': play_path,\n                            'rtmp_live': False,\n                            'ext': 'flv',\n                            'format_id': '%s-%s' % (node.tag, quality) if quality else node.tag,\n                            'height': height,\n                        })\n                self._sort_formats(formats)\n                description = clean_html(xpath_text(media, 'description'))\n                uploader = xpath_text(media, 'author')\n                duration = int_or_none(media.get('duration'))\n                for subtitle in media.findall('./subtitles/subtitle'):\n                    subtitle_url = xpath_text(subtitle, 'url', default=None)\n                    if not subtitle_url:\n                        continue\n                    lang = xpath_text(subtitle, 'lang', default='en')\n                    subtitles.setdefault(lang, []).append({\n                        'url': subtitle_url,\n                        'ext': (subtitle.get('format') or determine_ext(subtitle_url)).lower(),\n                    })\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'thumbnails': thumbnails,\n            'duration': duration,\n            'creator': uploader,\n            'uploader': uploader,\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "nfb.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/nfb.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}