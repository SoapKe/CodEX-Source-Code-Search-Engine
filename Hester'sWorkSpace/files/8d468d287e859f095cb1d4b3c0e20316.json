{"author": "ansible", "code": "\n# -*- coding: utf-8 -*-\n\n# (c) 2016, Yanis Guenane <yanis+ansible@guenane.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: openssl_publickey\nauthor: \"Yanis Guenane (@Spredzy)\"\nversion_added: \"2.3\"\nshort_description: Generate an OpenSSL public key from its private key.\ndescription:\n    - \"This module allows one to (re)generate OpenSSL public keys from their private keys.\n       It uses the pyOpenSSL python library to interact with openssl. Keys are generated\n       in PEM format. This module works only if the version of PyOpenSSL is recent enough (> 16.0.0).\"\nrequirements:\n    - \"python-pyOpenSSL\"\noptions:\n    state:\n        required: false\n        default: \"present\"\n        choices: [ present, absent ]\n        description:\n            - Whether the public key should exist or not, taking action if the state is different from what is stated.\n    force:\n        required: false\n        default: False\n        choices: [ True, False ]\n        description:\n            - Should the key be regenerated even it it already exists\n    format:\n        required: false\n        default: PEM\n        choices: [ PEM, OpenSSH ]\n        description:\n            - The format of the public key.\n        version_added: \"2.4\"\n    path:\n        required: true\n        description:\n            - Name of the file in which the generated TLS/SSL public key will be written.\n    privatekey_path:\n        required: true\n        description:\n            - Path to the TLS/SSL private key from which to generate the public key.\n    privatekey_passphrase:\n        required: false\n        description:\n            - The passphrase for the privatekey.\n        version_added: \"2.4\"\nextends_documentation_fragment: files\n'''\n\nEXAMPLES = '''\n\n- openssl_publickey:\n    path: /etc/ssl/public/ansible.com.pem\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n\n\n- openssl_publickey:\n    path: /etc/ssl/public/ansible.com.pem\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    format: OpenSSH\n\n\n\n- openssl_publickey:\n    path: /etc/ssl/public/ansible.com.pem\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    privatekey_passphrase: ansible\n\n\n- openssl_publickey:\n    path: /etc/ssl/public/ansible.com.pem\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    force: True\n\n\n- openssl_publickey:\n    path: /etc/ssl/public/ansible.com.pem\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    state: absent\n'''\n\nRETURN = '''\nprivatekey:\n    description: Path to the TLS/SSL private key the public key was generated from\n    returned: changed or success\n    type: string\n    sample: /etc/ssl/private/ansible.com.pem\nformat:\n    description: The format of the public key (PEM, OpenSSH, ...)\n    returned: changed or success\n    type: string\n    sample: PEM\nfilename:\n    description: Path to the generated TLS/SSL public key file\n    returned: changed or success\n    type: string\n    sample: /etc/ssl/public/ansible.com.pem\nfingerprint:\n    description: The fingerprint of the public key. Fingerprint will be generated for each hashlib.algorithms available.\n                 Requires PyOpenSSL >= 16.0 for meaningful output.\n    returned: changed or success\n    type: dict\n    sample:\n      md5: \"84:75:71:72:8d:04:b5:6c:4d:37:6d:66:83:f5:4c:29\"\n      sha1: \"51:cc:7c:68:5d:eb:41:43:88:7e:1a:ae:c7:f8:24:72:ee:71:f6:10\"\n      sha224: \"b1:19:a6:6c:14:ac:33:1d:ed:18:50:d3:06:5c:b2:32:91:f1:f1:52:8c:cb:d5:75:e9:f5:9b:46\"\n      sha256: \"41:ab:c7:cb:d5:5f:30:60:46:99:ac:d4:00:70:cf:a1:76:4f:24:5d:10:24:57:5d:51:6e:09:97:df:2f:de:c7\"\n      sha384: \"85:39:50:4e:de:d9:19:33:40:70:ae:10:ab:59:24:19:51:c3:a2:e4:0b:1c:b1:6e:dd:b3:0c:d9:9e:6a:46:af:da:18:f8:ef:ae:2e:c0:9a:75:2c:9b:b3:0f:3a:5f:3d\"\n      sha512: \"fd:ed:5e:39:48:5f:9f:fe:7f:25:06:3f:79:08:cd:ee:a5:e7:b3:3d:13:82:87:1f:84:e1:f5:c7:28:77:53:94:86:56:38:69:f0:d9:35:22:01:1e:a6:60:...:0f:9b\"\n'''\n\nimport hashlib\nimport os\n\ntry:\n    from OpenSSL import crypto\n    from cryptography.hazmat.backends import default_backend\n    from cryptography.hazmat.primitives import serialization as crypto_serialization\nexcept ImportError:\n    pyopenssl_found = False\nelse:\n    pyopenssl_found = True\n\nfrom ansible.module_utils import crypto as crypto_utils\nfrom ansible.module_utils._text import to_native\nfrom ansible.module_utils.basic import AnsibleModule\n\n\nclass PublicKeyError(crypto_utils.OpenSSLObjectError):\n    pass\n\n\nclass PublicKey(crypto_utils.OpenSSLObject):\n\n    def __init__(self, module):\n        super(PublicKey, self).__init__(\n            module.params['path'],\n            module.params['state'],\n            module.params['force'],\n            module.check_mode\n        )\n        self.format = module.params['format']\n        self.privatekey_path = module.params['privatekey_path']\n        self.privatekey_passphrase = module.params['privatekey_passphrase']\n        self.privatekey = None\n        self.fingerprint = {}\n\n    def generate(self, module):\n        \"\"\"Generate the public key.\"\"\"\n\n        if not os.path.exists(self.privatekey_path):\n            raise PublicKeyError(\n                'The private key %s does not exist' % self.privatekey_path\n            )\n\n        if not self.check(module, perms_required=False) or self.force:\n            try:\n                if self.format == 'OpenSSH':\n                    privatekey_content = open(self.privatekey_path, 'rb').read()\n                    key = crypto_serialization.load_pem_private_key(privatekey_content,\n                                                                    password=self.privatekey_passphrase,\n                                                                    backend=default_backend())\n                    publickey_content = key.public_key().public_bytes(\n                        crypto_serialization.Encoding.OpenSSH,\n                        crypto_serialization.PublicFormat.OpenSSH\n                    )\n                else:\n                    self.privatekey = crypto_utils.load_privatekey(\n                        self.privatekey_path, self.privatekey_passphrase\n                    )\n                    publickey_content = crypto.dump_publickey(crypto.FILETYPE_PEM, self.privatekey)\n\n                with open(self.path, 'wb') as publickey_file:\n                    publickey_file.write(publickey_content)\n\n                self.changed = True\n            except (IOError, OSError) as exc:\n                raise PublicKeyError(exc)\n            except AttributeError as exc:\n                self.remove()\n                raise PublicKeyError('You need to have PyOpenSSL>=16.0.0 to generate public keys')\n\n        self.fingerprint = crypto_utils.get_fingerprint(\n            self.privatekey_path,\n            self.privatekey_passphrase\n        )\n        file_args = module.load_file_common_arguments(module.params)\n        if module.set_fs_attributes_if_different(file_args, False):\n            self.changed = True\n\n    def check(self, module, perms_required=True):\n        \"\"\"Ensure the resource is in its desired state.\"\"\"\n\n        state_and_perms = super(PublicKey, self).check(module, perms_required)\n\n        def _check_privatekey():\n            if not os.path.exists(self.privatekey_path):\n                return False\n\n            try:\n                publickey_content = open(self.path, 'rb').read()\n                if self.format == 'OpenSSH':\n                    current_publickey = crypto_serialization.load_ssh_public_key(publickey_content, backend=default_backend())\n                    publickey_content = current_publickey.public_bytes(crypto_serialization.Encoding.PEM,\n                                                                       crypto_serialization.PublicFormat.SubjectPublicKeyInfo)\n                current_publickey = crypto.dump_publickey(\n                    crypto.FILETYPE_ASN1,\n                    crypto.load_publickey(crypto.FILETYPE_PEM, publickey_content)\n                )\n            except (crypto.Error, ValueError):\n                return False\n\n            desired_publickey = crypto.dump_publickey(\n                crypto.FILETYPE_ASN1,\n                crypto_utils.load_privatekey(self.privatekey_path, self.privatekey_passphrase)\n            )\n\n            return current_publickey == desired_publickey\n\n        if not state_and_perms:\n            return state_and_perms\n\n        return _check_privatekey()\n\n    def dump(self):\n        \"\"\"Serialize the object into a dictionary.\"\"\"\n\n        result = {\n            'privatekey': self.privatekey_path,\n            'filename': self.path,\n            'format': self.format,\n            'changed': self.changed,\n            'fingerprint': self.fingerprint,\n        }\n\n        return result\n\n\ndef main():\n\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(default='present', choices=['present', 'absent'], type='str'),\n            force=dict(default=False, type='bool'),\n            path=dict(required=True, type='path'),\n            privatekey_path=dict(type='path'),\n            format=dict(type='str', choices=['PEM', 'OpenSSH'], default='PEM'),\n            privatekey_passphrase=dict(type='str', no_log=True),\n        ),\n        supports_check_mode=True,\n        add_file_common_args=True,\n        required_if=[('state', 'present', ['privatekey_path'])]\n    )\n\n    if not pyopenssl_found:\n        module.fail_json(msg='the python pyOpenSSL module is required')\n\n    base_dir = os.path.dirname(module.params['path'])\n    if not os.path.isdir(base_dir):\n        module.fail_json(\n            name=base_dir,\n            msg='The directory %s does not exist or the file is not a directory' % base_dir\n        )\n\n    public_key = PublicKey(module)\n\n    if public_key.state == 'present':\n\n        if module.check_mode:\n            result = public_key.dump()\n            result['changed'] = module.params['force'] or not public_key.check(module)\n            module.exit_json(**result)\n\n        try:\n            public_key.generate(module)\n        except PublicKeyError as exc:\n            module.fail_json(msg=to_native(exc))\n    else:\n\n        if module.check_mode:\n            result = public_key.dump()\n            result['changed'] = os.path.exists(module.params['path'])\n            module.exit_json(**result)\n\n        try:\n            public_key.remove()\n        except PublicKeyError as exc:\n            module.fail_json(msg=to_native(exc))\n\n    result = public_key.dump()\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "   generate public key              os path exists(self privatekey path)              raise publickeyerror(                  the private key  exist    self privatekey path             )          self check(module  perms required false) self force              try                  self format     openssh                       privatekey content   open(self privatekey path   rb ) read()                     key   crypto serialization load pem private key(privatekey content                                                                      password self privatekey passphrase                                                                      backend default backend())                     publickey content   key public key() public bytes(                         crypto serialization encoding openssh                          crypto serialization publicformat openssh                     )                 else                      self privatekey   crypto utils load privatekey(                         self privatekey path  self privatekey passphrase                     )                     publickey content   crypto dump publickey(crypto filetype pem  self privatekey)                  open(self path   wb ) publickey file                      publickey file write(publickey content)                  self changed   true             except (ioerror  oserror) exc                  raise publickeyerror(exc)             except attributeerror exc                  self remove()                 raise publickeyerror( you need pyopenssl  16 0 0 generate public keys )          self fingerprint   crypto utils get fingerprint(             self privatekey path              self privatekey passphrase         )         file args   module load file common arguments(module params)         module set fs attributes different(file args  false)              self changed   true      def check(self  module  perms required true)             ensure resource desired state              state perms   super(publickey  self) check(module  perms required)          def  check privatekey()              os path exists(self privatekey path)                  return false              try                  publickey content   open(self path   rb ) read()                 self format     openssh                       current publickey   crypto serialization load ssh public key(publickey content  backend default backend())                     publickey content   current publickey public bytes(crypto serialization encoding pem                                                                         crypto serialization publicformat subjectpublickeyinfo)                 current publickey   crypto dump publickey(                     crypto filetype asn1                      crypto load publickey(crypto filetype pem  publickey content)                 )             except (crypto error  valueerror)                  return false              desired publickey   crypto dump publickey(                 crypto filetype asn1                  crypto utils load privatekey(self privatekey path  self privatekey passphrase)             )              return current publickey    desired publickey          state perms              return state perms          return  check privatekey()      def dump(self)             serialize object dictionary              module  openssl publickey author   yanis guenane ( spredzy)  version added   2 3  short description  generate openssl public key private key  description         this module allows one (re)generate openssl public keys private keys         it uses pyopenssl python library interact openssl  keys generated        pem format  this module works version pyopenssl recent enough (  16 0 0)   requirements         python pyopenssl  options      state          required  false         default   present          choices    present  absent           description                whether public key exist  taking action state different stated      force          required  false         default  false         choices    true  false           description                should key regenerated even already exists     format          required  false         default  pem         choices    pem  openssh           description                the format public key          version added   2 4      path          required  true         description                name file generated tls ssl public key written      privatekey path          required  true         description                path tls ssl private key generate public key      privatekey passphrase          required  false         description                the passphrase privatekey          version added   2 4  extends documentation fragment  files      examples         generate openssl public key pem format    openssl publickey      path   etc ssl public ansible com pem     privatekey path   etc ssl private ansible com pem    generate openssl public key openssh v2 format    openssl publickey      path   etc ssl public ansible com pem     privatekey path   etc ssl private ansible com pem     format  openssh    generate openssl public key passphrase protected   private key   openssl publickey      path   etc ssl public ansible com pem     privatekey path   etc ssl private ansible com pem     privatekey passphrase  ansible    force regenerate openssl public key already exists   openssl publickey      path   etc ssl public ansible com pem     privatekey path   etc ssl private ansible com pem     force  true    remove openssl public key   openssl publickey      path   etc ssl public ansible com pem     privatekey path   etc ssl private ansible com pem     state  absent      return       privatekey      description  path tls ssl private key public key generated     returned  changed success     type  string     sample   etc ssl private ansible com pem format      description  the format public key (pem  openssh     )     returned  changed success     type  string     sample  pem filename      description  path generated tls ssl public key file     returned  changed success     type  string     sample   etc ssl public ansible com pem fingerprint      description  the fingerprint public key  fingerprint generated hashlib algorithms available                   requires pyopenssl    16 0 meaningful output      returned  changed success     type  dict     sample        md5   84 75 71 72 8d 04 b5 6c 4d 37 6d 66 83 f5 4c 29        sha1   51 cc 7c 68 5d eb 41 43 88 7e 1a ae c7 f8 24 72 ee 71 f6 10        sha224   b1 19 a6 6c 14 ac 33 1d ed 18 50 d3 06 5c b2 32 91 f1 f1 52 8c cb d5 75 e9 f5 9b 46        sha256   41 ab c7 cb d5 5f 30 60 46 99 ac d4 00 70 cf a1 76 4f 24 5d 10 24 57 5d 51 6e 09 97 df 2f de c7        sha384   85 39 50 4e de d9 19 33 40 70 ae 10 ab 59 24 19 51 c3 a2 e4 0b 1c b1 6e dd b3 0c d9 9e 6a 46 af da 18 f8 ef ae 2e c0 9a 75 2c 9b b3 0f 3a 5f 3d        sha512   fd ed 5e 39 48 5f 9f fe 7f 25 06 3f 79 08 cd ee a5 e7 b3 3d 13 82 87 1f 84 e1 f5 c7 28 77 53 94 86 56 38 69 f0 d9 35 22 01 1e a6 60     0f 9b          usr bin python        coding  utf 8        (c) 2016  yanis guenane  yanis ansible guenane org     gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    generate openssl public key pem format     generate openssl public key openssh v2 format     generate openssl public key passphrase protected    private key    force regenerate openssl public key already exists    remove openssl public key ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# (c) 2016, Yanis Guenane <yanis+ansible@guenane.org>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: openssl_publickey\nauthor: \"Yanis Guenane (@Spredzy)\"\nversion_added: \"2.3\"\nshort_description: Generate an OpenSSL public key from its private key.\ndescription:\n    - \"This module allows one to (re)generate OpenSSL public keys from their private keys.\n       It uses the pyOpenSSL python library to interact with openssl. Keys are generated\n       in PEM format. This module works only if the version of PyOpenSSL is recent enough (> 16.0.0).\"\nrequirements:\n    - \"python-pyOpenSSL\"\noptions:\n    state:\n        required: false\n        default: \"present\"\n        choices: [ present, absent ]\n        description:\n            - Whether the public key should exist or not, taking action if the state is different from what is stated.\n    force:\n        required: false\n        default: False\n        choices: [ True, False ]\n        description:\n            - Should the key be regenerated even it it already exists\n    format:\n        required: false\n        default: PEM\n        choices: [ PEM, OpenSSH ]\n        description:\n            - The format of the public key.\n        version_added: \"2.4\"\n    path:\n        required: true\n        description:\n            - Name of the file in which the generated TLS/SSL public key will be written.\n    privatekey_path:\n        required: true\n        description:\n            - Path to the TLS/SSL private key from which to generate the public key.\n    privatekey_passphrase:\n        required: false\n        description:\n            - The passphrase for the privatekey.\n        version_added: \"2.4\"\nextends_documentation_fragment: files\n'''\n\nEXAMPLES = '''\n# Generate an OpenSSL public key in PEM format.\n- openssl_publickey:\n    path: /etc/ssl/public/ansible.com.pem\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n\n# Generate an OpenSSL public key in OpenSSH v2 format.\n- openssl_publickey:\n    path: /etc/ssl/public/ansible.com.pem\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    format: OpenSSH\n\n# Generate an OpenSSL public key with a passphrase protected\n# private key\n- openssl_publickey:\n    path: /etc/ssl/public/ansible.com.pem\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    privatekey_passphrase: ansible\n\n# Force regenerate an OpenSSL public key if it already exists\n- openssl_publickey:\n    path: /etc/ssl/public/ansible.com.pem\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    force: True\n\n# Remove an OpenSSL public key\n- openssl_publickey:\n    path: /etc/ssl/public/ansible.com.pem\n    privatekey_path: /etc/ssl/private/ansible.com.pem\n    state: absent\n'''\n\nRETURN = '''\nprivatekey:\n    description: Path to the TLS/SSL private key the public key was generated from\n    returned: changed or success\n    type: string\n    sample: /etc/ssl/private/ansible.com.pem\nformat:\n    description: The format of the public key (PEM, OpenSSH, ...)\n    returned: changed or success\n    type: string\n    sample: PEM\nfilename:\n    description: Path to the generated TLS/SSL public key file\n    returned: changed or success\n    type: string\n    sample: /etc/ssl/public/ansible.com.pem\nfingerprint:\n    description: The fingerprint of the public key. Fingerprint will be generated for each hashlib.algorithms available.\n                 Requires PyOpenSSL >= 16.0 for meaningful output.\n    returned: changed or success\n    type: dict\n    sample:\n      md5: \"84:75:71:72:8d:04:b5:6c:4d:37:6d:66:83:f5:4c:29\"\n      sha1: \"51:cc:7c:68:5d:eb:41:43:88:7e:1a:ae:c7:f8:24:72:ee:71:f6:10\"\n      sha224: \"b1:19:a6:6c:14:ac:33:1d:ed:18:50:d3:06:5c:b2:32:91:f1:f1:52:8c:cb:d5:75:e9:f5:9b:46\"\n      sha256: \"41:ab:c7:cb:d5:5f:30:60:46:99:ac:d4:00:70:cf:a1:76:4f:24:5d:10:24:57:5d:51:6e:09:97:df:2f:de:c7\"\n      sha384: \"85:39:50:4e:de:d9:19:33:40:70:ae:10:ab:59:24:19:51:c3:a2:e4:0b:1c:b1:6e:dd:b3:0c:d9:9e:6a:46:af:da:18:f8:ef:ae:2e:c0:9a:75:2c:9b:b3:0f:3a:5f:3d\"\n      sha512: \"fd:ed:5e:39:48:5f:9f:fe:7f:25:06:3f:79:08:cd:ee:a5:e7:b3:3d:13:82:87:1f:84:e1:f5:c7:28:77:53:94:86:56:38:69:f0:d9:35:22:01:1e:a6:60:...:0f:9b\"\n'''\n\nimport hashlib\nimport os\n\ntry:\n    from OpenSSL import crypto\n    from cryptography.hazmat.backends import default_backend\n    from cryptography.hazmat.primitives import serialization as crypto_serialization\nexcept ImportError:\n    pyopenssl_found = False\nelse:\n    pyopenssl_found = True\n\nfrom ansible.module_utils import crypto as crypto_utils\nfrom ansible.module_utils._text import to_native\nfrom ansible.module_utils.basic import AnsibleModule\n\n\nclass PublicKeyError(crypto_utils.OpenSSLObjectError):\n    pass\n\n\nclass PublicKey(crypto_utils.OpenSSLObject):\n\n    def __init__(self, module):\n        super(PublicKey, self).__init__(\n            module.params['path'],\n            module.params['state'],\n            module.params['force'],\n            module.check_mode\n        )\n        self.format = module.params['format']\n        self.privatekey_path = module.params['privatekey_path']\n        self.privatekey_passphrase = module.params['privatekey_passphrase']\n        self.privatekey = None\n        self.fingerprint = {}\n\n    def generate(self, module):\n        \"\"\"Generate the public key.\"\"\"\n\n        if not os.path.exists(self.privatekey_path):\n            raise PublicKeyError(\n                'The private key %s does not exist' % self.privatekey_path\n            )\n\n        if not self.check(module, perms_required=False) or self.force:\n            try:\n                if self.format == 'OpenSSH':\n                    privatekey_content = open(self.privatekey_path, 'rb').read()\n                    key = crypto_serialization.load_pem_private_key(privatekey_content,\n                                                                    password=self.privatekey_passphrase,\n                                                                    backend=default_backend())\n                    publickey_content = key.public_key().public_bytes(\n                        crypto_serialization.Encoding.OpenSSH,\n                        crypto_serialization.PublicFormat.OpenSSH\n                    )\n                else:\n                    self.privatekey = crypto_utils.load_privatekey(\n                        self.privatekey_path, self.privatekey_passphrase\n                    )\n                    publickey_content = crypto.dump_publickey(crypto.FILETYPE_PEM, self.privatekey)\n\n                with open(self.path, 'wb') as publickey_file:\n                    publickey_file.write(publickey_content)\n\n                self.changed = True\n            except (IOError, OSError) as exc:\n                raise PublicKeyError(exc)\n            except AttributeError as exc:\n                self.remove()\n                raise PublicKeyError('You need to have PyOpenSSL>=16.0.0 to generate public keys')\n\n        self.fingerprint = crypto_utils.get_fingerprint(\n            self.privatekey_path,\n            self.privatekey_passphrase\n        )\n        file_args = module.load_file_common_arguments(module.params)\n        if module.set_fs_attributes_if_different(file_args, False):\n            self.changed = True\n\n    def check(self, module, perms_required=True):\n        \"\"\"Ensure the resource is in its desired state.\"\"\"\n\n        state_and_perms = super(PublicKey, self).check(module, perms_required)\n\n        def _check_privatekey():\n            if not os.path.exists(self.privatekey_path):\n                return False\n\n            try:\n                publickey_content = open(self.path, 'rb').read()\n                if self.format == 'OpenSSH':\n                    current_publickey = crypto_serialization.load_ssh_public_key(publickey_content, backend=default_backend())\n                    publickey_content = current_publickey.public_bytes(crypto_serialization.Encoding.PEM,\n                                                                       crypto_serialization.PublicFormat.SubjectPublicKeyInfo)\n                current_publickey = crypto.dump_publickey(\n                    crypto.FILETYPE_ASN1,\n                    crypto.load_publickey(crypto.FILETYPE_PEM, publickey_content)\n                )\n            except (crypto.Error, ValueError):\n                return False\n\n            desired_publickey = crypto.dump_publickey(\n                crypto.FILETYPE_ASN1,\n                crypto_utils.load_privatekey(self.privatekey_path, self.privatekey_passphrase)\n            )\n\n            return current_publickey == desired_publickey\n\n        if not state_and_perms:\n            return state_and_perms\n\n        return _check_privatekey()\n\n    def dump(self):\n        \"\"\"Serialize the object into a dictionary.\"\"\"\n\n        result = {\n            'privatekey': self.privatekey_path,\n            'filename': self.path,\n            'format': self.format,\n            'changed': self.changed,\n            'fingerprint': self.fingerprint,\n        }\n\n        return result\n\n\ndef main():\n\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(default='present', choices=['present', 'absent'], type='str'),\n            force=dict(default=False, type='bool'),\n            path=dict(required=True, type='path'),\n            privatekey_path=dict(type='path'),\n            format=dict(type='str', choices=['PEM', 'OpenSSH'], default='PEM'),\n            privatekey_passphrase=dict(type='str', no_log=True),\n        ),\n        supports_check_mode=True,\n        add_file_common_args=True,\n        required_if=[('state', 'present', ['privatekey_path'])]\n    )\n\n    if not pyopenssl_found:\n        module.fail_json(msg='the python pyOpenSSL module is required')\n\n    base_dir = os.path.dirname(module.params['path'])\n    if not os.path.isdir(base_dir):\n        module.fail_json(\n            name=base_dir,\n            msg='The directory %s does not exist or the file is not a directory' % base_dir\n        )\n\n    public_key = PublicKey(module)\n\n    if public_key.state == 'present':\n\n        if module.check_mode:\n            result = public_key.dump()\n            result['changed'] = module.params['force'] or not public_key.check(module)\n            module.exit_json(**result)\n\n        try:\n            public_key.generate(module)\n        except PublicKeyError as exc:\n            module.fail_json(msg=to_native(exc))\n    else:\n\n        if module.check_mode:\n            result = public_key.dump()\n            result['changed'] = os.path.exists(module.params['path'])\n            module.exit_json(**result)\n\n        try:\n            public_key.remove()\n        except PublicKeyError as exc:\n            module.fail_json(msg=to_native(exc))\n\n    result = public_key.dump()\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "openssl_publickey.py", "id": "8d468d287e859f095cb1d4b3c0e20316", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/crypto/openssl_publickey.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}