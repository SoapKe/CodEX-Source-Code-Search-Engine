{"author": "tgalal", "code": "import hashlib, hmac, sys\nfrom struct import pack\nfrom operator import xor\nfrom itertools import starmap\n\nclass RC4:\n    def __init__(self, key, drop):\n        self.s = []\n        self.i = 0;\n        self.j = 0;\n\n        self.s = [0] * 256\n\n        for i in range(0, len(self.s)):\n            self.s[i] = i\n\n        for i in range(0, len(self.s)):\n            self.j = (self.j + self.s[i] + key[i % len(key)]) % 256\n            RC4.swap(self.s, i, self.j)\n\n        self.j = 0;\n        self.cipher(bytearray(drop), 0, drop)\n\n\n    def cipher(self, data, offset, length):\n        while True:\n            num = length\n            length = num - 1\n\n            if num == 0: break\n\n            self.i = (self.i+1) % 256\n            self.j = (self.j + self.s[self.i]) % 256\n\n            RC4.swap(self.s, self.i, self.j)\n\n            num2 = offset\n            offset = num2 + 1\n\n            data[num2] = (data[num2] ^ self.s[(self.s[self.i] + self.s[self.j]) % 256])\n\n    @staticmethod\n    def swap(arr, i, j):\n        tmp = arr[i]\n        arr[i] = arr[j]\n        arr[j] = tmp\n\n\nclass KeyStream:\n\n    def __init__(self, key, macKey):\n        self.key = key if sys.version_info < (3, 0) else bytes(key)\n        self.rc4 = RC4(self.key, 0x300)\n        self.macKey = str(macKey) if sys.version_info < (3, 0) else bytes(macKey)\n        self.seq = 0\n\n    def computeMac(self, bytes_buffer, int_offset, int_length):\n        mac = hmac.new(self.macKey, None, hashlib.sha1)\n        updateData = bytes_buffer[int_offset:] + bytearray([self.seq >> 24, (self.seq >> 16) % 256, (self.seq >> 8) % 256, self.seq % 256])\n\n        try:\n            mac.update(updateData)\n        except TypeError: \n            mac.update(bytes(updateData))\n\n        self.seq += 1\n        return bytearray(mac.digest())\n\n    def decodeMessage(self, bufdata, macOffset, offset, length):\n        buf = bufdata[:-4]\n        hashed = bufdata[-4:]\n        numArray = self.computeMac(buf, 0, len(buf))\n\n        num = 0\n        while num < 4:\n            if numArray[macOffset + num] == hashed[num]:\n                num += 1\n            else:\n                raise Exception(\"INVALID MAC\")\n\n        self.rc4.cipher(buf, 0, len(buf))\n\n        return buf\n\n    def encodeMessage(self, buf, macOffset, offset, length):\n        self.rc4.cipher(buf, offset, length)\n        mac = self.computeMac(buf, offset, length)\n        output = buf[0:macOffset] + mac[0:4] + buf[macOffset+4:]\n        return output\n\n    @staticmethod\n    def generateKeys(password, nonce):\n        resultBytes = []\n\n        for i in range(1, 5):\n            currNonce = nonce + bytearray([i])\n            resultBytes.append(KeyStream.pbkdf2(password, currNonce, 2, 20))\n\n        return resultBytes\n\n    \n    #def pbkdf2( password, salt, itercount, keylen):\n    #    return bytearray(hashlib.pbkdf2_hmac('sha1', password, salt, itercount, keylen))\n\n    @staticmethod\n    def pbkdf2( password, salt, itercount, keylen, hashfn = hashlib.sha1 ):\n        def pbkdf2_F( h, salt, itercount, blocknum ):\n            def prf( h, data ):\n                hm = h.copy()\n                try:\n                    hm.update(bytearray(data))\n                except TypeError: \n                    hm.update(bytes(data))\n\n                d = hm.digest()\n                return bytearray(d)\n\n            U = prf( h, salt + pack('>i',blocknum ) )\n            T = U\n\n            for i in range(2, itercount + 1):\n                U = prf( h, U )\n                T = starmap(xor, zip(T, U))\n            return T\n\n        digest_size = hashfn().digest_size\n        l = int(keylen / digest_size)\n        if keylen % digest_size != 0:\n            l += 1\n        \n        h = hmac.new(bytes(password), None, hashfn )\n\n        T = bytearray()\n        for i in range(1, l+1):\n            tmp = pbkdf2_F( h, salt, itercount, i )\n            T.extend(tmp)\n        \n        return T[0: keylen]", "comments": " python3 support    staticmethod    use drop python 2 6 support   def pbkdf2( password  salt  itercount  keylen)        return bytearray(hashlib pbkdf2 hmac( sha1   password  salt  itercount  keylen))   python 3 support ", "content": "import hashlib, hmac, sys\nfrom struct import pack\nfrom operator import xor\nfrom itertools import starmap\n\nclass RC4:\n    def __init__(self, key, drop):\n        self.s = []\n        self.i = 0;\n        self.j = 0;\n\n        self.s = [0] * 256\n\n        for i in range(0, len(self.s)):\n            self.s[i] = i\n\n        for i in range(0, len(self.s)):\n            self.j = (self.j + self.s[i] + key[i % len(key)]) % 256\n            RC4.swap(self.s, i, self.j)\n\n        self.j = 0;\n        self.cipher(bytearray(drop), 0, drop)\n\n\n    def cipher(self, data, offset, length):\n        while True:\n            num = length\n            length = num - 1\n\n            if num == 0: break\n\n            self.i = (self.i+1) % 256\n            self.j = (self.j + self.s[self.i]) % 256\n\n            RC4.swap(self.s, self.i, self.j)\n\n            num2 = offset\n            offset = num2 + 1\n\n            data[num2] = (data[num2] ^ self.s[(self.s[self.i] + self.s[self.j]) % 256])\n\n    @staticmethod\n    def swap(arr, i, j):\n        tmp = arr[i]\n        arr[i] = arr[j]\n        arr[j] = tmp\n\n\nclass KeyStream:\n\n    def __init__(self, key, macKey):\n        self.key = key if sys.version_info < (3, 0) else bytes(key)\n        self.rc4 = RC4(self.key, 0x300)\n        self.macKey = str(macKey) if sys.version_info < (3, 0) else bytes(macKey)\n        self.seq = 0\n\n    def computeMac(self, bytes_buffer, int_offset, int_length):\n        mac = hmac.new(self.macKey, None, hashlib.sha1)\n        updateData = bytes_buffer[int_offset:] + bytearray([self.seq >> 24, (self.seq >> 16) % 256, (self.seq >> 8) % 256, self.seq % 256])\n\n        try:\n            mac.update(updateData)\n        except TypeError: #python3 support\n            mac.update(bytes(updateData))\n\n        self.seq += 1\n        return bytearray(mac.digest())\n\n    def decodeMessage(self, bufdata, macOffset, offset, length):\n        buf = bufdata[:-4]\n        hashed = bufdata[-4:]\n        numArray = self.computeMac(buf, 0, len(buf))\n\n        num = 0\n        while num < 4:\n            if numArray[macOffset + num] == hashed[num]:\n                num += 1\n            else:\n                raise Exception(\"INVALID MAC\")\n\n        self.rc4.cipher(buf, 0, len(buf))\n\n        return buf\n\n    def encodeMessage(self, buf, macOffset, offset, length):\n        self.rc4.cipher(buf, offset, length)\n        mac = self.computeMac(buf, offset, length)\n        output = buf[0:macOffset] + mac[0:4] + buf[macOffset+4:]\n        return output\n\n    @staticmethod\n    def generateKeys(password, nonce):\n        resultBytes = []\n\n        for i in range(1, 5):\n            currNonce = nonce + bytearray([i])\n            resultBytes.append(KeyStream.pbkdf2(password, currNonce, 2, 20))\n\n        return resultBytes\n\n    #@staticmethod  ##use if drop python-2.6 support\n    #def pbkdf2( password, salt, itercount, keylen):\n    #    return bytearray(hashlib.pbkdf2_hmac('sha1', password, salt, itercount, keylen))\n\n    @staticmethod\n    def pbkdf2( password, salt, itercount, keylen, hashfn = hashlib.sha1 ):\n        def pbkdf2_F( h, salt, itercount, blocknum ):\n            def prf( h, data ):\n                hm = h.copy()\n                try:\n                    hm.update(bytearray(data))\n                except TypeError: #python 3 support\n                    hm.update(bytes(data))\n\n                d = hm.digest()\n                return bytearray(d)\n\n            U = prf( h, salt + pack('>i',blocknum ) )\n            T = U\n\n            for i in range(2, itercount + 1):\n                U = prf( h, U )\n                T = starmap(xor, zip(T, U))\n            return T\n\n        digest_size = hashfn().digest_size\n        l = int(keylen / digest_size)\n        if keylen % digest_size != 0:\n            l += 1\n        \n        h = hmac.new(bytes(password), None, hashfn )\n\n        T = bytearray()\n        for i in range(1, l+1):\n            tmp = pbkdf2_F( h, salt, itercount, i )\n            T.extend(tmp)\n        \n        return T[0: keylen]", "description": "The python WhatsApp library", "file_name": "keystream.py", "id": "b7368e3c1690ed4d7b81cf0e8fd3fce0", "language": "Python", "project_name": "yowsup", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tgalal-yowsup/tgalal-yowsup-03795cc/yowsup/layers/auth/keystream.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:01:40Z", "url": "https://github.com/tgalal/yowsup", "wiki": true}