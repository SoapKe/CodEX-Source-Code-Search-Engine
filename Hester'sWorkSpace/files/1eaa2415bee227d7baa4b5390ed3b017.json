{"author": "ansible", "code": "\n -*- coding: utf-8 -*-\n\n (c) 2012, Mark Theunissen <mark.theunissen@gmail.com>\n\n GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: mysql_db\nshort_description: Add or remove MySQL databases from a remote host.\ndescription:\n   - Add or remove MySQL databases from a remote host.\nversion_added: \"0.6\"\noptions:\n  name:\n    description:\n      - name of the database to add or remove\n      - name=all May only be provided if I(state) is C(dump) or C(import).\n      - if name=all Works like --all-databases option for mysqldump (Added in 2.0)\n    required: true\n    aliases: [ db ]\n  state:\n    description:\n      - The database state\n    default: present\n    choices: [ \"present\", \"absent\", \"dump\", \"import\" ]\n  collation:\n    description:\n      - Collation mode (sorting). This only applies to new table/databases and does not update existing ones, this is a limitation of MySQL.\n  encoding:\n    description:\n      - Encoding mode to use, examples include C(utf8) or C(latin1_swedish_ci)\n  target:\n    description:\n      - Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL\n        files (C(.sql)) as well as bzip2 (C(.bz2)), gzip (C(.gz)) and xz (Added in 2.0) compressed files are supported.\n  single_transaction:\n    description:\n      - Execute the dump in a single transaction\n    type: bool\n    default: 'no'\n    version_added: \"2.1\"\n  quick:\n    description:\n      - Option used for dumping large tables\n    type: bool\n    default: 'yes'\n    version_added: \"2.1\"\nauthor: \"Ansible Core Team\"\nrequirements:\n   - mysql (command line binary)\n   - mysqldump (command line binary)\nnotes:\n   - Requires the python-mysqldb package on the remote host, as well as mysql and mysqldump binaries.\nextends_documentation_fragment: mysql\n'''\n\nEXAMPLES = '''\n- name: Create a new database with name 'bobdata'\n  mysql_db:\n    name: bobdata\n    state: present\n\n\n- name: Copy database dump file\n  copy:\n    src: dump.sql.bz2\n    dest: /tmp\n- name: Restore database\n  mysql_db:\n    name: my_db\n    state: import\n    target: /tmp/dump.sql.bz2\n\n- name: Dump all databases to hostname.sql\n  mysql_db:\n    state: dump\n    name: all\n    target: /tmp/{{ inventory_hostname }}.sql\n\n- name: Import file.sql similar to mysql -u <username> -p <password> < hostname.sql\n  mysql_db:\n    state: import\n    name: all\n    target: /tmp/{{ inventory_hostname }}.sql\n'''\n\nimport os\nimport pipes\nimport subprocess\nimport traceback\n\ntry:\n    import MySQLdb\nexcept ImportError:\n    mysqldb_found = False\nelse:\n    mysqldb_found = True\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.database import mysql_quote_identifier\nfrom ansible.module_utils.mysql import mysql_connect, mysqldb_found\nfrom ansible.module_utils._text import to_native\n\n\n\n\n\n\n\ndef db_exists(cursor, db):\n    res = cursor.execute(\"SHOW DATABASES LIKE %s\", (db.replace(\"_\", r\"\\_\"),))\n    return bool(res)\n\n\ndef db_delete(cursor, db):\n    query = \"DROP DATABASE %s\" % mysql_quote_identifier(db, 'database')\n    cursor.execute(query)\n    return True\n\n\ndef db_dump(module, host, user, password, db_name, target, all_databases, port, config_file, socket=None, ssl_cert=None, ssl_key=None, ssl_ca=None,\n            single_transaction=None, quick=None):\n    cmd = module.get_bin_path('mysqldump', True)\n     If defined, mysqldump demands --defaults-extra-file be the first option\n    if config_file:\n        cmd += \" --defaults-extra-file=%s\" % pipes.quote(config_file)\n    if user is not None:\n        cmd += \" --user=%s\" % pipes.quote(user)\n    if password is not None:\n        cmd += \" --password=%s\" % pipes.quote(password)\n    if ssl_cert is not None:\n        cmd += \" --ssl-cert=%s\" % pipes.quote(ssl_cert)\n    if ssl_key is not None:\n        cmd += \" --ssl-key=%s\" % pipes.quote(ssl_key)\n    if ssl_cert is not None:\n        cmd += \" --ssl-ca=%s\" % pipes.quote(ssl_ca)\n    if socket is not None:\n        cmd += \" --socket=%s\" % pipes.quote(socket)\n    else:\n        cmd += \" --host=%s --port=%i\" % (pipes.quote(host), port)\n    if all_databases:\n        cmd += \" --all-databases\"\n    else:\n        cmd += \" %s\" % pipes.quote(db_name)\n    if single_transaction:\n        cmd += \" --single-transaction=true\"\n    if quick:\n        cmd += \" --quick\"\n\n    path = None\n    if os.path.splitext(target)[-1] == '.gz':\n        path = module.get_bin_path('gzip', True)\n    elif os.path.splitext(target)[-1] == '.bz2':\n        path = module.get_bin_path('bzip2', True)\n    elif os.path.splitext(target)[-1] == '.xz':\n        path = module.get_bin_path('xz', True)\n\n    if path:\n        cmd = '%s | %s > %s' % (cmd, path, pipes.quote(target))\n    else:\n        cmd += \" > %s\" % pipes.quote(target)\n\n    rc, stdout, stderr = module.run_command(cmd, use_unsafe_shell=True)\n    return rc, stdout, stderr\n\n\ndef db_import(module, host, user, password, db_name, target, all_databases, port, config_file, socket=None, ssl_cert=None, ssl_key=None, ssl_ca=None):\n    if not os.path.exists(target):\n        return module.fail_json(msg=\"target %s does not exist on the host\" % target)\n\n    cmd = [module.get_bin_path('mysql', True)]\n     --defaults-file must go first, or errors out\n    if config_file:\n        cmd.append(\"--defaults-extra-file=%s\" % pipes.quote(config_file))\n    if user:\n        cmd.append(\"--user=%s\" % pipes.quote(user))\n    if password:\n        cmd.append(\"--password=%s\" % pipes.quote(password))\n    if socket is not None:\n        cmd.append(\"--socket=%s\" % pipes.quote(socket))\n    if ssl_cert is not None:\n        cmd.append(\"--ssl-cert=%s\" % pipes.quote(ssl_cert))\n    if ssl_key is not None:\n        cmd.append(\"--ssl-key=%s\" % pipes.quote(ssl_key))\n    if ssl_cert is not None:\n        cmd.append(\"--ssl-ca=%s\" % pipes.quote(ssl_ca))\n    else:\n        cmd.append(\"--host=%s\" % pipes.quote(host))\n        cmd.append(\"--port=%i\" % port)\n    if not all_databases:\n        cmd.append(\"-D\")\n        cmd.append(pipes.quote(db_name))\n\n    comp_prog_path = None\n    if os.path.splitext(target)[-1] == '.gz':\n        comp_prog_path = module.get_bin_path('gzip', required=True)\n    elif os.path.splitext(target)[-1] == '.bz2':\n        comp_prog_path = module.get_bin_path('bzip2', required=True)\n    elif os.path.splitext(target)[-1] == '.xz':\n        comp_prog_path = module.get_bin_path('xz', required=True)\n\n    if comp_prog_path:\n        p1 = subprocess.Popen([comp_prog_path, '-dc', target], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        p2 = subprocess.Popen(cmd, stdin=p1.stdout, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        (stdout2, stderr2) = p2.communicate()\n        p1.stdout.close()\n        p1.wait()\n        if p1.returncode != 0:\n            stderr1 = p1.stderr.read()\n            return p1.returncode, '', stderr1\n        else:\n            return p2.returncode, stdout2, stderr2\n    else:\n        cmd = ' '.join(cmd)\n        cmd += \" < %s\" % pipes.quote(target)\n        rc, stdout, stderr = module.run_command(cmd, use_unsafe_shell=True)\n        return rc, stdout, stderr\n\n\ndef db_create(cursor, db, encoding, collation):\n    query_params = dict(enc=encoding, collate=collation)\n    query = ['CREATE DATABASE %s' % mysql_quote_identifier(db, 'database')]\n    if encoding:\n        query.append(\"CHARACTER SET %(enc)s\")\n    if collation:\n        query.append(\"COLLATE %(collate)s\")\n    query = ' '.join(query)\n    cursor.execute(query, query_params)\n    return True\n\n\n Module execution.\n\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            login_user=dict(default=None),\n            login_password=dict(default=None, no_log=True),\n            login_host=dict(default=\"localhost\"),\n            login_port=dict(default=3306, type='int'),\n            login_unix_socket=dict(default=None),\n            name=dict(required=True, aliases=['db']),\n            encoding=dict(default=\"\"),\n            collation=dict(default=\"\"),\n            target=dict(default=None, type='path'),\n            state=dict(default=\"present\", choices=[\"absent\", \"present\", \"dump\", \"import\"]),\n            ssl_cert=dict(default=None, type='path'),\n            ssl_key=dict(default=None, type='path'),\n            ssl_ca=dict(default=None, type='path'),\n            connect_timeout=dict(default=30, type='int'),\n            config_file=dict(default=\"~/.my.cnf\", type='path'),\n            single_transaction=dict(default=False, type='bool'),\n            quick=dict(default=True, type='bool'),\n        ),\n        supports_check_mode=True\n    )\n\n    if not mysqldb_found:\n        module.fail_json(msg=\"The MySQL-python module is required.\")\n\n    db = module.params[\"name\"]\n    encoding = module.params[\"encoding\"]\n    collation = module.params[\"collation\"]\n    state = module.params[\"state\"]\n    target = module.params[\"target\"]\n    socket = module.params[\"login_unix_socket\"]\n    login_port = module.params[\"login_port\"]\n    if login_port < 0 or login_port > 65535:\n        module.fail_json(msg=\"login_port must be a valid unix port number (0-65535)\")\n    ssl_cert = module.params[\"ssl_cert\"]\n    ssl_key = module.params[\"ssl_key\"]\n    ssl_ca = module.params[\"ssl_ca\"]\n    connect_timeout = module.params['connect_timeout']\n    config_file = module.params['config_file']\n    login_password = module.params[\"login_password\"]\n    login_user = module.params[\"login_user\"]\n    login_host = module.params[\"login_host\"]\n    single_transaction = module.params[\"single_transaction\"]\n    quick = module.params[\"quick\"]\n\n    if state in ['dump', 'import']:\n        if target is None:\n            module.fail_json(msg=\"with state=%s target is required\" % state)\n        if db == 'all':\n            db = 'mysql'\n            all_databases = True\n        else:\n            all_databases = False\n    else:\n        if db == 'all':\n            module.fail_json(msg=\"name is not allowed to equal 'all' unless state equals import, or dump.\")\n    try:\n        cursor = mysql_connect(module, login_user, login_password, config_file, ssl_cert, ssl_key, ssl_ca,\n                               connect_timeout=connect_timeout)\n    except Exception as e:\n        if os.path.exists(config_file):\n            module.fail_json(msg=\"unable to connect to database, check login_user and login_password are correct or %s has the credentials. \"\n                                 \"Exception message: %s\" % (config_file, to_native(e)))\n        else:\n            module.fail_json(msg=\"unable to find %s. Exception message: %s\" % (config_file, to_native(e)))\n\n    changed = False\n    if not os.path.exists(config_file):\n        config_file = None\n    if db_exists(cursor, db):\n        if state == \"absent\":\n            if module.check_mode:\n                module.exit_json(changed=True, db=db)\n            else:\n                try:\n                    changed = db_delete(cursor, db)\n                except Exception as e:\n                    module.fail_json(msg=\"error deleting database: %s\" % to_native(e))\n                module.exit_json(changed=changed, db=db)\n\n        elif state == \"dump\":\n            if module.check_mode:\n                module.exit_json(changed=True, db=db)\n            else:\n                rc, stdout, stderr = db_dump(module, login_host, login_user,\n                                             login_password, db, target, all_databases,\n                                             login_port, config_file, socket, ssl_cert, ssl_key,\n                                             ssl_ca, single_transaction, quick)\n                if rc != 0:\n                    module.fail_json(msg=\"%s\" % stderr)\n                else:\n                    module.exit_json(changed=True, db=db, msg=stdout)\n\n        elif state == \"import\":\n            if module.check_mode:\n                module.exit_json(changed=True, db=db)\n            else:\n                rc, stdout, stderr = db_import(module, login_host, login_user,\n                                               login_password, db, target,\n                                               all_databases,\n                                               login_port, config_file,\n                                               socket, ssl_cert, ssl_key, ssl_ca)\n                if rc != 0:\n                    module.fail_json(msg=\"%s\" % stderr)\n                else:\n                    module.exit_json(changed=True, db=db, msg=stdout)\n\n        elif state == \"present\":\n            if module.check_mode:\n                module.exit_json(changed=False, db=db)\n            module.exit_json(changed=False, db=db)\n\n    else:\n        if state == \"present\":\n            if module.check_mode:\n                changed = True\n            else:\n                try:\n                    changed = db_create(cursor, db, encoding, collation)\n                except Exception as e:\n                    module.fail_json(msg=\"error creating database: %s\" % to_native(e),\n                                     exception=traceback.format_exc())\n            module.exit_json(changed=changed, db=db)\n\n        elif state == \"import\":\n            if module.check_mode:\n                module.exit_json(changed=True, db=db)\n            else:\n                try:\n                    changed = db_create(cursor, db, encoding, collation)\n                    if changed:\n                        rc, stdout, stderr = db_import(module, login_host, login_user,\n                                                       login_password, db, target, all_databases,\n                                                       login_port, config_file, socket, ssl_cert, ssl_key, ssl_ca)\n                        if rc != 0:\n                            module.fail_json(msg=\"%s\" % stderr)\n                        else:\n                            module.exit_json(changed=True, db=db, msg=stdout)\n                except Exception as e:\n                    module.fail_json(msg=\"error creating database: %s\" % to_native(e),\n                                     exception=traceback.format_exc())\n\n        elif state == \"absent\":\n            if module.check_mode:\n                module.exit_json(changed=False, db=db)\n            module.exit_json(changed=False, db=db)\n\n        elif state == \"dump\":\n            if module.check_mode:\n                module.exit_json(changed=False, db=db)\n            module.fail_json(msg=\"Cannot dump database %s - not found\" % (db))\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  mysql db short description  add remove mysql databases remote host  description       add remove mysql databases remote host  version added   0 6  options    name      description          name database add remove         name may provided i(state) c(dump) c(import)          name works like   databases option mysqldump (added 2 0)     required  true     aliases    db     state      description          the database state     default  present     choices     present    absent    dump    import      collation      description          collation mode (sorting)  this applies new table databases update existing ones  limitation mysql    encoding      description          encoding mode use  examples include c(utf8) c(latin1 swedish ci)   target      description          location  remote host  dump file read write  uncompressed sql         files (c( sql)) well bzip2 (c( bz2))  gzip (c( gz)) xz (added 2 0) compressed files supported    single transaction      description          execute dump single transaction     type  bool     default        version added   2 1    quick      description          option used dumping large tables     type  bool     default   yes      version added   2 1  author   ansible core team  requirements       mysql (command line binary)      mysqldump (command line binary) notes       requires python mysqldb package remote host  well mysql mysqldump binaries  extends documentation fragment  mysql      examples         name  create new database name  bobdata    mysql db      name  bobdata     state  present    copy database dump file remote host restore database  db    name  copy database dump file   copy      src  dump sql bz2     dest   tmp   name  restore database   mysql db      name  db     state  import     target   tmp dump sql bz2    name  dump databases hostname sql   mysql db      state  dump     name      target   tmp    inventory hostname    sql    name  import file sql similar mysql  u  username   p  password    hostname sql   mysql db      state  import     name      target   tmp    inventory hostname    sql         usr bin python        coding  utf 8        (c) 2012  mark theunissen  mark theunissen gmail com     sponsored four kitchens http   fourkitchens com     gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    copy database dump file remote host restore database  db                                                    mysql module specific support methods        if defined  mysqldump demands   defaults extra file first option      defaults file must go first  errors                                                   module execution     ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# (c) 2012, Mark Theunissen <mark.theunissen@gmail.com>\n# Sponsored by Four Kitchens http://fourkitchens.com.\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: mysql_db\nshort_description: Add or remove MySQL databases from a remote host.\ndescription:\n   - Add or remove MySQL databases from a remote host.\nversion_added: \"0.6\"\noptions:\n  name:\n    description:\n      - name of the database to add or remove\n      - name=all May only be provided if I(state) is C(dump) or C(import).\n      - if name=all Works like --all-databases option for mysqldump (Added in 2.0)\n    required: true\n    aliases: [ db ]\n  state:\n    description:\n      - The database state\n    default: present\n    choices: [ \"present\", \"absent\", \"dump\", \"import\" ]\n  collation:\n    description:\n      - Collation mode (sorting). This only applies to new table/databases and does not update existing ones, this is a limitation of MySQL.\n  encoding:\n    description:\n      - Encoding mode to use, examples include C(utf8) or C(latin1_swedish_ci)\n  target:\n    description:\n      - Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL\n        files (C(.sql)) as well as bzip2 (C(.bz2)), gzip (C(.gz)) and xz (Added in 2.0) compressed files are supported.\n  single_transaction:\n    description:\n      - Execute the dump in a single transaction\n    type: bool\n    default: 'no'\n    version_added: \"2.1\"\n  quick:\n    description:\n      - Option used for dumping large tables\n    type: bool\n    default: 'yes'\n    version_added: \"2.1\"\nauthor: \"Ansible Core Team\"\nrequirements:\n   - mysql (command line binary)\n   - mysqldump (command line binary)\nnotes:\n   - Requires the python-mysqldb package on the remote host, as well as mysql and mysqldump binaries.\nextends_documentation_fragment: mysql\n'''\n\nEXAMPLES = '''\n- name: Create a new database with name 'bobdata'\n  mysql_db:\n    name: bobdata\n    state: present\n\n# Copy database dump file to remote host and restore it to database 'my_db'\n- name: Copy database dump file\n  copy:\n    src: dump.sql.bz2\n    dest: /tmp\n- name: Restore database\n  mysql_db:\n    name: my_db\n    state: import\n    target: /tmp/dump.sql.bz2\n\n- name: Dump all databases to hostname.sql\n  mysql_db:\n    state: dump\n    name: all\n    target: /tmp/{{ inventory_hostname }}.sql\n\n- name: Import file.sql similar to mysql -u <username> -p <password> < hostname.sql\n  mysql_db:\n    state: import\n    name: all\n    target: /tmp/{{ inventory_hostname }}.sql\n'''\n\nimport os\nimport pipes\nimport subprocess\nimport traceback\n\ntry:\n    import MySQLdb\nexcept ImportError:\n    mysqldb_found = False\nelse:\n    mysqldb_found = True\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.database import mysql_quote_identifier\nfrom ansible.module_utils.mysql import mysql_connect, mysqldb_found\nfrom ansible.module_utils._text import to_native\n\n\n# ===========================================\n# MySQL module specific support methods.\n#\n\n\ndef db_exists(cursor, db):\n    res = cursor.execute(\"SHOW DATABASES LIKE %s\", (db.replace(\"_\", r\"\\_\"),))\n    return bool(res)\n\n\ndef db_delete(cursor, db):\n    query = \"DROP DATABASE %s\" % mysql_quote_identifier(db, 'database')\n    cursor.execute(query)\n    return True\n\n\ndef db_dump(module, host, user, password, db_name, target, all_databases, port, config_file, socket=None, ssl_cert=None, ssl_key=None, ssl_ca=None,\n            single_transaction=None, quick=None):\n    cmd = module.get_bin_path('mysqldump', True)\n    # If defined, mysqldump demands --defaults-extra-file be the first option\n    if config_file:\n        cmd += \" --defaults-extra-file=%s\" % pipes.quote(config_file)\n    if user is not None:\n        cmd += \" --user=%s\" % pipes.quote(user)\n    if password is not None:\n        cmd += \" --password=%s\" % pipes.quote(password)\n    if ssl_cert is not None:\n        cmd += \" --ssl-cert=%s\" % pipes.quote(ssl_cert)\n    if ssl_key is not None:\n        cmd += \" --ssl-key=%s\" % pipes.quote(ssl_key)\n    if ssl_cert is not None:\n        cmd += \" --ssl-ca=%s\" % pipes.quote(ssl_ca)\n    if socket is not None:\n        cmd += \" --socket=%s\" % pipes.quote(socket)\n    else:\n        cmd += \" --host=%s --port=%i\" % (pipes.quote(host), port)\n    if all_databases:\n        cmd += \" --all-databases\"\n    else:\n        cmd += \" %s\" % pipes.quote(db_name)\n    if single_transaction:\n        cmd += \" --single-transaction=true\"\n    if quick:\n        cmd += \" --quick\"\n\n    path = None\n    if os.path.splitext(target)[-1] == '.gz':\n        path = module.get_bin_path('gzip', True)\n    elif os.path.splitext(target)[-1] == '.bz2':\n        path = module.get_bin_path('bzip2', True)\n    elif os.path.splitext(target)[-1] == '.xz':\n        path = module.get_bin_path('xz', True)\n\n    if path:\n        cmd = '%s | %s > %s' % (cmd, path, pipes.quote(target))\n    else:\n        cmd += \" > %s\" % pipes.quote(target)\n\n    rc, stdout, stderr = module.run_command(cmd, use_unsafe_shell=True)\n    return rc, stdout, stderr\n\n\ndef db_import(module, host, user, password, db_name, target, all_databases, port, config_file, socket=None, ssl_cert=None, ssl_key=None, ssl_ca=None):\n    if not os.path.exists(target):\n        return module.fail_json(msg=\"target %s does not exist on the host\" % target)\n\n    cmd = [module.get_bin_path('mysql', True)]\n    # --defaults-file must go first, or errors out\n    if config_file:\n        cmd.append(\"--defaults-extra-file=%s\" % pipes.quote(config_file))\n    if user:\n        cmd.append(\"--user=%s\" % pipes.quote(user))\n    if password:\n        cmd.append(\"--password=%s\" % pipes.quote(password))\n    if socket is not None:\n        cmd.append(\"--socket=%s\" % pipes.quote(socket))\n    if ssl_cert is not None:\n        cmd.append(\"--ssl-cert=%s\" % pipes.quote(ssl_cert))\n    if ssl_key is not None:\n        cmd.append(\"--ssl-key=%s\" % pipes.quote(ssl_key))\n    if ssl_cert is not None:\n        cmd.append(\"--ssl-ca=%s\" % pipes.quote(ssl_ca))\n    else:\n        cmd.append(\"--host=%s\" % pipes.quote(host))\n        cmd.append(\"--port=%i\" % port)\n    if not all_databases:\n        cmd.append(\"-D\")\n        cmd.append(pipes.quote(db_name))\n\n    comp_prog_path = None\n    if os.path.splitext(target)[-1] == '.gz':\n        comp_prog_path = module.get_bin_path('gzip', required=True)\n    elif os.path.splitext(target)[-1] == '.bz2':\n        comp_prog_path = module.get_bin_path('bzip2', required=True)\n    elif os.path.splitext(target)[-1] == '.xz':\n        comp_prog_path = module.get_bin_path('xz', required=True)\n\n    if comp_prog_path:\n        p1 = subprocess.Popen([comp_prog_path, '-dc', target], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        p2 = subprocess.Popen(cmd, stdin=p1.stdout, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        (stdout2, stderr2) = p2.communicate()\n        p1.stdout.close()\n        p1.wait()\n        if p1.returncode != 0:\n            stderr1 = p1.stderr.read()\n            return p1.returncode, '', stderr1\n        else:\n            return p2.returncode, stdout2, stderr2\n    else:\n        cmd = ' '.join(cmd)\n        cmd += \" < %s\" % pipes.quote(target)\n        rc, stdout, stderr = module.run_command(cmd, use_unsafe_shell=True)\n        return rc, stdout, stderr\n\n\ndef db_create(cursor, db, encoding, collation):\n    query_params = dict(enc=encoding, collate=collation)\n    query = ['CREATE DATABASE %s' % mysql_quote_identifier(db, 'database')]\n    if encoding:\n        query.append(\"CHARACTER SET %(enc)s\")\n    if collation:\n        query.append(\"COLLATE %(collate)s\")\n    query = ' '.join(query)\n    cursor.execute(query, query_params)\n    return True\n\n# ===========================================\n# Module execution.\n#\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            login_user=dict(default=None),\n            login_password=dict(default=None, no_log=True),\n            login_host=dict(default=\"localhost\"),\n            login_port=dict(default=3306, type='int'),\n            login_unix_socket=dict(default=None),\n            name=dict(required=True, aliases=['db']),\n            encoding=dict(default=\"\"),\n            collation=dict(default=\"\"),\n            target=dict(default=None, type='path'),\n            state=dict(default=\"present\", choices=[\"absent\", \"present\", \"dump\", \"import\"]),\n            ssl_cert=dict(default=None, type='path'),\n            ssl_key=dict(default=None, type='path'),\n            ssl_ca=dict(default=None, type='path'),\n            connect_timeout=dict(default=30, type='int'),\n            config_file=dict(default=\"~/.my.cnf\", type='path'),\n            single_transaction=dict(default=False, type='bool'),\n            quick=dict(default=True, type='bool'),\n        ),\n        supports_check_mode=True\n    )\n\n    if not mysqldb_found:\n        module.fail_json(msg=\"The MySQL-python module is required.\")\n\n    db = module.params[\"name\"]\n    encoding = module.params[\"encoding\"]\n    collation = module.params[\"collation\"]\n    state = module.params[\"state\"]\n    target = module.params[\"target\"]\n    socket = module.params[\"login_unix_socket\"]\n    login_port = module.params[\"login_port\"]\n    if login_port < 0 or login_port > 65535:\n        module.fail_json(msg=\"login_port must be a valid unix port number (0-65535)\")\n    ssl_cert = module.params[\"ssl_cert\"]\n    ssl_key = module.params[\"ssl_key\"]\n    ssl_ca = module.params[\"ssl_ca\"]\n    connect_timeout = module.params['connect_timeout']\n    config_file = module.params['config_file']\n    login_password = module.params[\"login_password\"]\n    login_user = module.params[\"login_user\"]\n    login_host = module.params[\"login_host\"]\n    single_transaction = module.params[\"single_transaction\"]\n    quick = module.params[\"quick\"]\n\n    if state in ['dump', 'import']:\n        if target is None:\n            module.fail_json(msg=\"with state=%s target is required\" % state)\n        if db == 'all':\n            db = 'mysql'\n            all_databases = True\n        else:\n            all_databases = False\n    else:\n        if db == 'all':\n            module.fail_json(msg=\"name is not allowed to equal 'all' unless state equals import, or dump.\")\n    try:\n        cursor = mysql_connect(module, login_user, login_password, config_file, ssl_cert, ssl_key, ssl_ca,\n                               connect_timeout=connect_timeout)\n    except Exception as e:\n        if os.path.exists(config_file):\n            module.fail_json(msg=\"unable to connect to database, check login_user and login_password are correct or %s has the credentials. \"\n                                 \"Exception message: %s\" % (config_file, to_native(e)))\n        else:\n            module.fail_json(msg=\"unable to find %s. Exception message: %s\" % (config_file, to_native(e)))\n\n    changed = False\n    if not os.path.exists(config_file):\n        config_file = None\n    if db_exists(cursor, db):\n        if state == \"absent\":\n            if module.check_mode:\n                module.exit_json(changed=True, db=db)\n            else:\n                try:\n                    changed = db_delete(cursor, db)\n                except Exception as e:\n                    module.fail_json(msg=\"error deleting database: %s\" % to_native(e))\n                module.exit_json(changed=changed, db=db)\n\n        elif state == \"dump\":\n            if module.check_mode:\n                module.exit_json(changed=True, db=db)\n            else:\n                rc, stdout, stderr = db_dump(module, login_host, login_user,\n                                             login_password, db, target, all_databases,\n                                             login_port, config_file, socket, ssl_cert, ssl_key,\n                                             ssl_ca, single_transaction, quick)\n                if rc != 0:\n                    module.fail_json(msg=\"%s\" % stderr)\n                else:\n                    module.exit_json(changed=True, db=db, msg=stdout)\n\n        elif state == \"import\":\n            if module.check_mode:\n                module.exit_json(changed=True, db=db)\n            else:\n                rc, stdout, stderr = db_import(module, login_host, login_user,\n                                               login_password, db, target,\n                                               all_databases,\n                                               login_port, config_file,\n                                               socket, ssl_cert, ssl_key, ssl_ca)\n                if rc != 0:\n                    module.fail_json(msg=\"%s\" % stderr)\n                else:\n                    module.exit_json(changed=True, db=db, msg=stdout)\n\n        elif state == \"present\":\n            if module.check_mode:\n                module.exit_json(changed=False, db=db)\n            module.exit_json(changed=False, db=db)\n\n    else:\n        if state == \"present\":\n            if module.check_mode:\n                changed = True\n            else:\n                try:\n                    changed = db_create(cursor, db, encoding, collation)\n                except Exception as e:\n                    module.fail_json(msg=\"error creating database: %s\" % to_native(e),\n                                     exception=traceback.format_exc())\n            module.exit_json(changed=changed, db=db)\n\n        elif state == \"import\":\n            if module.check_mode:\n                module.exit_json(changed=True, db=db)\n            else:\n                try:\n                    changed = db_create(cursor, db, encoding, collation)\n                    if changed:\n                        rc, stdout, stderr = db_import(module, login_host, login_user,\n                                                       login_password, db, target, all_databases,\n                                                       login_port, config_file, socket, ssl_cert, ssl_key, ssl_ca)\n                        if rc != 0:\n                            module.fail_json(msg=\"%s\" % stderr)\n                        else:\n                            module.exit_json(changed=True, db=db, msg=stdout)\n                except Exception as e:\n                    module.fail_json(msg=\"error creating database: %s\" % to_native(e),\n                                     exception=traceback.format_exc())\n\n        elif state == \"absent\":\n            if module.check_mode:\n                module.exit_json(changed=False, db=db)\n            module.exit_json(changed=False, db=db)\n\n        elif state == \"dump\":\n            if module.check_mode:\n                module.exit_json(changed=False, db=db)\n            module.fail_json(msg=\"Cannot dump database %s - not found\" % (db))\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "mysql_db.py", "id": "1eaa2415bee227d7baa4b5390ed3b017", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/database/mysql/mysql_db.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}