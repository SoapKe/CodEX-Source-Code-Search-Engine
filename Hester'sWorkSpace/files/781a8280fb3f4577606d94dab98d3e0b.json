{"author": "tensorflow", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n\"\"\"Code to evaluate how well an RL Tuner conforms to music theory rules.\"\"\"\n\n internal imports\n\nimport numpy as np\nimport tensorflow as tf\n\nfrom magenta.models.rl_tuner import rl_tuner_ops\n\n\ndef compute_composition_stats(rl_tuner,\n                              num_compositions=10000,\n                              composition_length=32,\n                              key=None,\n                              tonic_note=rl_tuner_ops.C_MAJOR_TONIC):\n  \"\"\"Uses the model to create many compositions, stores statistics about them.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    num_compositions: The number of compositions to create.\n    composition_length: The number of beats in each composition.\n    key: The numeric values of notes belonging to this key. Defaults to\n      C-major if not provided.\n    tonic_note: The tonic/1st note of the desired key.\n  Returns:\n    A dictionary containing the computed statistics about the compositions.\n  \"\"\"\n  stat_dict = initialize_stat_dict()\n\n  for i in range(num_compositions):\n    stat_dict = compose_and_evaluate_piece(\n        rl_tuner,\n        stat_dict,\n        composition_length=composition_length,\n        key=key,\n        tonic_note=tonic_note)\n    if i % (num_compositions / 10) == 0:\n      stat_dict['num_compositions'] = i\n      stat_dict['total_notes'] = i * composition_length\n\n  stat_dict['num_compositions'] = num_compositions\n  stat_dict['total_notes'] = num_compositions * composition_length\n\n  tf.logging.info(get_stat_dict_string(stat_dict))\n\n  return stat_dict\n\n\n The following functions compute evaluation metrics to test whether the model\n trained successfully.\ndef get_stat_dict_string(stat_dict, print_interval_stats=True):\n  \"\"\"Makes string of interesting statistics from a composition stat_dict.\n\n  Args:\n    stat_dict: A dictionary storing statistics about a series of compositions.\n    print_interval_stats: If True, print additional stats about the number of\n      different intervals types.\n  Returns:\n    String containing several lines of formatted stats.\n  \"\"\"\n  tot_notes = float(stat_dict['total_notes'])\n  tot_comps = float(stat_dict['num_compositions'])\n\n  return_str = 'Total compositions: ' + str(tot_comps) + '\\n'\n  return_str += 'Total notes:' + str(tot_notes) + '\\n'\n\n  return_str += '\\tCompositions starting with tonic: '\n  return_str += str(float(stat_dict['num_starting_tonic'])) + '\\n'\n  return_str += '\\tCompositions with unique highest note:'\n  return_str += str(float(stat_dict['num_high_unique'])) + '\\n'\n  return_str += '\\tCompositions with unique lowest note:'\n  return_str += str(float(stat_dict['num_low_unique'])) + '\\n'\n  return_str += '\\tNumber of resolved leaps:'\n  return_str += str(float(stat_dict['num_resolved_leaps'])) + '\\n'\n  return_str += '\\tNumber of double leaps:'\n  return_str += str(float(stat_dict['num_leap_twice'])) + '\\n'\n  return_str += '\\tNotes not in key:' + str(float(\n      stat_dict['notes_not_in_key'])) + '\\n'\n  return_str += '\\tNotes in motif:' + str(float(\n      stat_dict['notes_in_motif'])) + '\\n'\n  return_str += '\\tNotes in repeated motif:'\n  return_str += str(float(stat_dict['notes_in_repeated_motif'])) + '\\n'\n  return_str += '\\tNotes excessively repeated:'\n  return_str += str(float(stat_dict['num_repeated_notes'])) + '\\n'\n  return_str += '\\n'\n\n  num_resolved = float(stat_dict['num_resolved_leaps'])\n  total_leaps = (float(stat_dict['num_leap_twice']) + num_resolved)\n  if total_leaps > 0:\n    percent_leaps_resolved = num_resolved / total_leaps\n  else:\n    percent_leaps_resolved = np.nan\n  return_str += '\\tPercent compositions starting with tonic:'\n  return_str += str(stat_dict['num_starting_tonic'] / tot_comps) + '\\n'\n  return_str += '\\tPercent compositions with unique highest note:'\n  return_str += str(float(stat_dict['num_high_unique']) / tot_comps) + '\\n'\n  return_str += '\\tPercent compositions with unique lowest note:'\n  return_str += str(float(stat_dict['num_low_unique']) / tot_comps) + '\\n'\n  return_str += '\\tPercent of leaps resolved:'\n  return_str += str(percent_leaps_resolved) + '\\n'\n  return_str += '\\tPercent notes not in key:'\n  return_str += str(float(stat_dict['notes_not_in_key']) / tot_notes) + '\\n'\n  return_str += '\\tPercent notes in motif:'\n  return_str += str(float(stat_dict['notes_in_motif']) / tot_notes) + '\\n'\n  return_str += '\\tPercent notes in repeated motif:'\n  return_str += str(stat_dict['notes_in_repeated_motif'] / tot_notes) + '\\n'\n  return_str += '\\tPercent notes excessively repeated:'\n  return_str += str(stat_dict['num_repeated_notes'] / tot_notes) + '\\n'\n  return_str += '\\n'\n\n  for lag in [1, 2, 3]:\n    avg_autocorr = np.nanmean(stat_dict['autocorrelation' + str(lag)])\n    return_str += '\\tAverage autocorrelation of lag' + str(lag) + ':'\n    return_str += str(avg_autocorr) + '\\n'\n\n  if print_interval_stats:\n    return_str += '\\n'\n    return_str += '\\tAvg. num octave jumps per composition:'\n    return_str += str(float(stat_dict['num_octave_jumps']) / tot_comps) + '\\n'\n    return_str += '\\tAvg. num sevenths per composition:'\n    return_str += str(float(stat_dict['num_sevenths']) / tot_comps) + '\\n'\n    return_str += '\\tAvg. num fifths per composition:'\n    return_str += str(float(stat_dict['num_fifths']) / tot_comps) + '\\n'\n    return_str += '\\tAvg. num sixths per composition:'\n    return_str += str(float(stat_dict['num_sixths']) / tot_comps) + '\\n'\n    return_str += '\\tAvg. num fourths per composition:'\n    return_str += str(float(stat_dict['num_fourths']) / tot_comps) + '\\n'\n    return_str += '\\tAvg. num rest intervals per composition:'\n    return_str += str(float(stat_dict['num_rest_intervals']) / tot_comps)\n    return_str += '\\n'\n    return_str += '\\tAvg. num seconds per composition:'\n    return_str += str(float(stat_dict['num_seconds']) / tot_comps) + '\\n'\n    return_str += '\\tAvg. num thirds per composition:'\n    return_str += str(float(stat_dict['num_thirds']) / tot_comps) + '\\n'\n    return_str += '\\tAvg. num in key preferred intervals per composition:'\n    return_str += str(\n        float(stat_dict['num_in_key_preferred_intervals']) / tot_comps) + '\\n'\n    return_str += '\\tAvg. num special rest intervals per composition:'\n    return_str += str(\n        float(stat_dict['num_special_rest_intervals']) / tot_comps) + '\\n'\n  return_str += '\\n'\n\n  return return_str\n\n\ndef compose_and_evaluate_piece(rl_tuner,\n                               stat_dict,\n                               composition_length=32,\n                               key=None,\n                               tonic_note=rl_tuner_ops.C_MAJOR_TONIC,\n                               sample_next_obs=True):\n  \"\"\"Composes a piece using the model, stores statistics about it in a dict.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    stat_dict: A dictionary storing statistics about a series of compositions.\n    composition_length: The number of beats in the composition.\n    key: The numeric values of notes belonging to this key. Defaults to\n      C-major if not provided.\n    tonic_note: The tonic/1st note of the desired key.\n    sample_next_obs: If True, each note will be sampled from the model's\n      output distribution. If False, each note will be the one with maximum\n      value according to the model.\n  Returns:\n    A dictionary updated to include statistics about the composition just\n    created.\n  \"\"\"\n  last_observation = rl_tuner.prime_internal_models()\n  rl_tuner.reset_composition()\n\n  for _ in range(composition_length):\n    if sample_next_obs:\n      action, new_observation, _ = rl_tuner.action(\n          last_observation,\n          0,\n          enable_random=False,\n          sample_next_obs=sample_next_obs)\n    else:\n      action, _ = rl_tuner.action(\n          last_observation,\n          0,\n          enable_random=False,\n          sample_next_obs=sample_next_obs)\n      new_observation = action\n\n    obs_note = np.argmax(new_observation)\n\n     Compute note by note stats as it composes.\n    stat_dict = add_interval_stat(rl_tuner, new_observation, stat_dict, key=key)\n    stat_dict = add_in_key_stat(obs_note, stat_dict, key=key)\n    stat_dict = add_tonic_start_stat(\n        rl_tuner, obs_note, stat_dict, tonic_note=tonic_note)\n    stat_dict = add_repeating_note_stat(rl_tuner, obs_note, stat_dict)\n    stat_dict = add_motif_stat(rl_tuner, new_observation, stat_dict)\n    stat_dict = add_repeated_motif_stat(rl_tuner, new_observation, stat_dict)\n    stat_dict = add_leap_stats(rl_tuner, new_observation, stat_dict)\n\n    rl_tuner.composition.append(np.argmax(new_observation))\n    rl_tuner.beat += 1\n    last_observation = new_observation\n\n  for lag in [1, 2, 3]:\n    stat_dict['autocorrelation' + str(lag)].append(\n        rl_tuner_ops.autocorrelate(rl_tuner.composition, lag))\n\n  add_high_low_unique_stats(rl_tuner, stat_dict)\n\n  return stat_dict\n\n\ndef initialize_stat_dict():\n  \"\"\"Initializes a dictionary which will hold statistics about compositions.\n\n  Returns:\n    A dictionary containing the appropriate fields initialized to 0 or an\n    empty list.\n  \"\"\"\n  stat_dict = dict()\n\n  for lag in [1, 2, 3]:\n    stat_dict['autocorrelation' + str(lag)] = []\n\n  stat_dict['notes_not_in_key'] = 0\n  stat_dict['notes_in_motif'] = 0\n  stat_dict['notes_in_repeated_motif'] = 0\n  stat_dict['num_starting_tonic'] = 0\n  stat_dict['num_repeated_notes'] = 0\n  stat_dict['num_octave_jumps'] = 0\n  stat_dict['num_fifths'] = 0\n  stat_dict['num_thirds'] = 0\n  stat_dict['num_sixths'] = 0\n  stat_dict['num_seconds'] = 0\n  stat_dict['num_fourths'] = 0\n  stat_dict['num_sevenths'] = 0\n  stat_dict['num_rest_intervals'] = 0\n  stat_dict['num_special_rest_intervals'] = 0\n  stat_dict['num_in_key_preferred_intervals'] = 0\n  stat_dict['num_resolved_leaps'] = 0\n  stat_dict['num_leap_twice'] = 0\n  stat_dict['num_high_unique'] = 0\n  stat_dict['num_low_unique'] = 0\n\n  return stat_dict\n\n\ndef add_interval_stat(rl_tuner, action, stat_dict, key=None):\n  \"\"\"Computes the melodic interval just played and adds it to a stat dict.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    action: One-hot encoding of the chosen action.\n    stat_dict: A dictionary containing fields for statistics about\n      compositions.\n    key: The numeric values of notes belonging to this key. Defaults to\n      C-major if not provided.\n  Returns:\n    A dictionary of composition statistics with fields updated to include new\n    intervals.\n  \"\"\"\n  interval, _, _ = rl_tuner.detect_sequential_interval(action, key)\n\n  if interval == 0:\n    return stat_dict\n\n  if interval == rl_tuner_ops.REST_INTERVAL:\n    stat_dict['num_rest_intervals'] += 1\n  elif interval == rl_tuner_ops.REST_INTERVAL_AFTER_THIRD_OR_FIFTH:\n    stat_dict['num_special_rest_intervals'] += 1\n  elif interval > rl_tuner_ops.OCTAVE:\n    stat_dict['num_octave_jumps'] += 1\n  elif interval == (rl_tuner_ops.IN_KEY_FIFTH or\n                    interval == rl_tuner_ops.IN_KEY_THIRD):\n    stat_dict['num_in_key_preferred_intervals'] += 1\n  elif interval == rl_tuner_ops.FIFTH:\n    stat_dict['num_fifths'] += 1\n  elif interval == rl_tuner_ops.THIRD:\n    stat_dict['num_thirds'] += 1\n  elif interval == rl_tuner_ops.SIXTH:\n    stat_dict['num_sixths'] += 1\n  elif interval == rl_tuner_ops.SECOND:\n    stat_dict['num_seconds'] += 1\n  elif interval == rl_tuner_ops.FOURTH:\n    stat_dict['num_fourths'] += 1\n  elif interval == rl_tuner_ops.SEVENTH:\n    stat_dict['num_sevenths'] += 1\n\n  return stat_dict\n\n\ndef add_in_key_stat(action_note, stat_dict, key=None):\n  \"\"\"Determines whether the note played was in key, and updates a stat dict.\n\n  Args:\n    action_note: An integer representing the chosen action.\n    stat_dict: A dictionary containing fields for statistics about\n      compositions.\n    key: The numeric values of notes belonging to this key. Defaults to\n      C-major if not provided.\n  Returns:\n    A dictionary of composition statistics with 'notes_not_in_key' field\n    updated.\n  \"\"\"\n  if key is None:\n    key = rl_tuner_ops.C_MAJOR_KEY\n\n  if action_note not in key:\n    stat_dict['notes_not_in_key'] += 1\n\n  return stat_dict\n\n\ndef add_tonic_start_stat(rl_tuner,\n                         action_note,\n                         stat_dict,\n                         tonic_note=rl_tuner_ops.C_MAJOR_TONIC):\n  \"\"\"Updates stat dict based on whether composition started with the tonic.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    action_note: An integer representing the chosen action.\n    stat_dict: A dictionary containing fields for statistics about\n      compositions.\n    tonic_note: The tonic/1st note of the desired key.\n  Returns:\n    A dictionary of composition statistics with 'num_starting_tonic' field\n    updated.\n  \"\"\"\n  if rl_tuner.beat == 0 and action_note == tonic_note:\n    stat_dict['num_starting_tonic'] += 1\n  return stat_dict\n\n\ndef add_repeating_note_stat(rl_tuner, action_note, stat_dict):\n  \"\"\"Updates stat dict if an excessively repeated note was played.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    action_note: An integer representing the chosen action.\n    stat_dict: A dictionary containing fields for statistics about\n      compositions.\n  Returns:\n    A dictionary of composition statistics with 'num_repeated_notes' field\n    updated.\n  \"\"\"\n  if rl_tuner.detect_repeating_notes(action_note):\n    stat_dict['num_repeated_notes'] += 1\n  return stat_dict\n\n\ndef add_motif_stat(rl_tuner, action, stat_dict):\n  \"\"\"Updates stat dict if a motif was just played.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    action: One-hot encoding of the chosen action.\n    stat_dict: A dictionary containing fields for statistics about\n      compositions.\n  Returns:\n    A dictionary of composition statistics with 'notes_in_motif' field\n    updated.\n  \"\"\"\n  composition = rl_tuner.composition + [np.argmax(action)]\n  motif, _ = rl_tuner.detect_last_motif(composition=composition)\n  if motif is not None:\n    stat_dict['notes_in_motif'] += 1\n  return stat_dict\n\n\ndef add_repeated_motif_stat(rl_tuner, action, stat_dict):\n  \"\"\"Updates stat dict if a repeated motif was just played.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    action: One-hot encoding of the chosen action.\n    stat_dict: A dictionary containing fields for statistics about\n      compositions.\n  Returns:\n    A dictionary of composition statistics with 'notes_in_repeated_motif'\n    field updated.\n  \"\"\"\n  is_repeated, _ = rl_tuner.detect_repeated_motif(action)\n  if is_repeated:\n    stat_dict['notes_in_repeated_motif'] += 1\n  return stat_dict\n\n\ndef add_leap_stats(rl_tuner, action, stat_dict):\n  \"\"\"Updates stat dict if a melodic leap was just made or resolved.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    action: One-hot encoding of the chosen action.\n    stat_dict: A dictionary containing fields for statistics about\n      compositions.\n  Returns:\n    A dictionary of composition statistics with leap-related fields updated.\n  \"\"\"\n  leap_outcome = rl_tuner.detect_leap_up_back(action)\n  if leap_outcome == rl_tuner_ops.LEAP_RESOLVED:\n    stat_dict['num_resolved_leaps'] += 1\n  elif leap_outcome == rl_tuner_ops.LEAP_DOUBLED:\n    stat_dict['num_leap_twice'] += 1\n  return stat_dict\n\n\ndef add_high_low_unique_stats(rl_tuner, stat_dict):\n  \"\"\"Updates stat dict if rl_tuner.composition has unique extrema notes.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    stat_dict: A dictionary containing fields for statistics about\n      compositions.\n  Returns:\n    A dictionary of composition statistics with 'notes_in_repeated_motif'\n    field updated.\n  \"\"\"\n  if rl_tuner.detect_high_unique(rl_tuner.composition):\n    stat_dict['num_high_unique'] += 1\n  if rl_tuner.detect_low_unique(rl_tuner.composition):\n    stat_dict['num_low_unique'] += 1\n\n  return stat_dict\n", "comments": "   code evaluate well rl tuner conforms music theory rules        internal imports  import numpy np import tensorflow tf  magenta models rl tuner import rl tuner ops   def compute composition stats(rl tuner                                num compositions 10000                                composition length 32                                key none                                tonic note rl tuner ops c major tonic)       uses model create many compositions  stores statistics     args      rl tuner  an rltuner object      num compositions  the number compositions create      composition length  the number beats composition      key  the numeric values notes belonging key  defaults       c major provided      tonic note  the tonic 1st note desired key    returns      a dictionary containing computed statistics compositions          stat dict   initialize stat dict()    range(num compositions)      stat dict   compose evaluate piece(         rl tuner          stat dict          composition length composition length          key key          tonic note tonic note)       (num compositions   10)    0        stat dict  num compositions           stat dict  total notes       composition length    stat dict  num compositions     num compositions   stat dict  total notes     num compositions   composition length    tf logging info(get stat dict string(stat dict))    return stat dict     the following functions compute evaluation metrics test whether model   trained successfully  def get stat dict string(stat dict  print interval stats true)       makes string interesting statistics composition stat dict     args      stat dict  a dictionary storing statistics series compositions      print interval stats  if true  print additional stats number       different intervals types    returns      string containing several lines formatted stats          tot notes   float(stat dict  total notes  )   tot comps   float(stat dict  num compositions  )    return str    total compositions      str(tot comps)     n    return str     total notes     str(tot notes)     n     return str      tcompositions starting tonic      return str    str(float(stat dict  num starting tonic  ))     n    return str      tcompositions unique highest note     return str    str(float(stat dict  num high unique  ))     n    return str      tcompositions unique lowest note     return str    str(float(stat dict  num low unique  ))     n    return str      tnumber resolved leaps     return str    str(float(stat dict  num resolved leaps  ))     n    return str      tnumber double leaps     return str    str(float(stat dict  num leap twice  ))     n    return str      tnotes key     str(float(       stat dict  notes key  ))     n    return str      tnotes motif     str(float(       stat dict  notes motif  ))     n    return str      tnotes repeated motif     return str    str(float(stat dict  notes repeated motif  ))     n    return str      tnotes excessively repeated     return str    str(float(stat dict  num repeated notes  ))     n    return str      n     num resolved   float(stat dict  num resolved leaps  )   total leaps   (float(stat dict  num leap twice  )   num resolved)   total leaps   0      percent leaps resolved   num resolved   total leaps   else      percent leaps resolved   np nan   return str      tpercent compositions starting tonic     return str    str(stat dict  num starting tonic     tot comps)     n    return str      tpercent compositions unique highest note     return str    str(float(stat dict  num high unique  )   tot comps)     n    return str      tpercent compositions unique lowest note     return str    str(float(stat dict  num low unique  )   tot comps)     n    return str      tpercent leaps resolved     return str    str(percent leaps resolved)     n    return str      tpercent notes key     return str    str(float(stat dict  notes key  )   tot notes)     n    return str      tpercent notes motif     return str    str(float(stat dict  notes motif  )   tot notes)     n    return str      tpercent notes repeated motif     return str    str(stat dict  notes repeated motif     tot notes)     n    return str      tpercent notes excessively repeated     return str    str(stat dict  num repeated notes     tot notes)     n    return str      n     lag  1  2  3       avg autocorr   np nanmean(stat dict  autocorrelation    str(lag) )     return str      taverage autocorrelation lag    str(lag)           return str    str(avg autocorr)     n     print interval stats      return str      n      return str      tavg  num octave jumps per composition       return str    str(float(stat dict  num octave jumps  )   tot comps)     n      return str      tavg  num sevenths per composition       return str    str(float(stat dict  num sevenths  )   tot comps)     n      return str      tavg  num fifths per composition       return str    str(float(stat dict  num fifths  )   tot comps)     n      return str      tavg  num sixths per composition       return str    str(float(stat dict  num sixths  )   tot comps)     n      return str      tavg  num fourths per composition       return str    str(float(stat dict  num fourths  )   tot comps)     n      return str      tavg  num rest intervals per composition       return str    str(float(stat dict  num rest intervals  )   tot comps)     return str      n      return str      tavg  num seconds per composition       return str    str(float(stat dict  num seconds  )   tot comps)     n      return str      tavg  num thirds per composition       return str    str(float(stat dict  num thirds  )   tot comps)     n      return str      tavg  num key preferred intervals per composition       return str    str(         float(stat dict  num key preferred intervals  )   tot comps)     n      return str      tavg  num special rest intervals per composition       return str    str(         float(stat dict  num special rest intervals  )   tot comps)     n    return str      n     return return str   def compose evaluate piece(rl tuner                                 stat dict                                 composition length 32                                 key none                                 tonic note rl tuner ops c major tonic                                 sample next obs true)       composes piece using model  stores statistics dict     args      rl tuner  an rltuner object      stat dict  a dictionary storing statistics series compositions      composition length  the number beats composition      key  the numeric values notes belonging key  defaults       c major provided      tonic note  the tonic 1st note desired key      sample next obs  if true  note sampled model       output distribution  if false  note one maximum       value according model    returns      a dictionary updated include statistics composition     created          last observation   rl tuner prime internal models()   rl tuner reset composition()      range(composition length)      sample next obs        action  new observation      rl tuner action(           last observation            0            enable random false            sample next obs sample next obs)     else        action      rl tuner action(           last observation            0            enable random false            sample next obs sample next obs)       new observation   action      obs note   np argmax(new observation)        compute note note stats composes      stat dict   add interval stat(rl tuner  new observation  stat dict  key key)     stat dict   add key stat(obs note  stat dict  key key)     stat dict   add tonic start stat(         rl tuner  obs note  stat dict  tonic note tonic note)     stat dict   add repeating note stat(rl tuner  obs note  stat dict)     stat dict   add motif stat(rl tuner  new observation  stat dict)     stat dict   add repeated motif stat(rl tuner  new observation  stat dict)     stat dict   add leap stats(rl tuner  new observation  stat dict)      rl tuner composition append(np argmax(new observation))     rl tuner beat    1     last observation   new observation    lag  1  2  3       stat dict  autocorrelation    str(lag)  append(         rl tuner ops autocorrelate(rl tuner composition  lag))    add high low unique stats(rl tuner  stat dict)    return stat dict   def initialize stat dict()       initializes dictionary hold statistics compositions     returns      a dictionary containing appropriate fields initialized 0     empty list          stat dict   dict()    lag  1  2  3       stat dict  autocorrelation    str(lag)          stat dict  notes key     0   stat dict  notes motif     0   stat dict  notes repeated motif     0   stat dict  num starting tonic     0   stat dict  num repeated notes     0   stat dict  num octave jumps     0   stat dict  num fifths     0   stat dict  num thirds     0   stat dict  num sixths     0   stat dict  num seconds     0   stat dict  num fourths     0   stat dict  num sevenths     0   stat dict  num rest intervals     0   stat dict  num special rest intervals     0   stat dict  num key preferred intervals     0   stat dict  num resolved leaps     0   stat dict  num leap twice     0   stat dict  num high unique     0   stat dict  num low unique     0    return stat dict   def add interval stat(rl tuner  action  stat dict  key none)       computes melodic interval played adds stat dict     args      rl tuner  an rltuner object      action  one hot encoding chosen action      stat dict  a dictionary containing fields statistics       compositions      key  the numeric values notes belonging key  defaults       c major provided    returns      a dictionary composition statistics fields updated include new     intervals          interval         rl tuner detect sequential interval(action  key)    interval    0      return stat dict    interval    rl tuner ops rest interval      stat dict  num rest intervals      1   elif interval    rl tuner ops rest interval after third or fifth      stat dict  num special rest intervals      1   elif interval   rl tuner ops octave      stat dict  num octave jumps      1   elif interval    (rl tuner ops in key fifth                     interval    rl tuner ops in key third)      stat dict  num key preferred intervals      1   elif interval    rl tuner ops fifth      stat dict  num fifths      1   elif interval    rl tuner ops third      stat dict  num thirds      1   elif interval    rl tuner ops sixth      stat dict  num sixths      1   elif interval    rl tuner ops second      stat dict  num seconds      1   elif interval    rl tuner ops fourth      stat dict  num fourths      1   elif interval    rl tuner ops seventh      stat dict  num sevenths      1    return stat dict   def add key stat(action note  stat dict  key none)       determines whether note played key  updates stat dict     args      action note  an integer representing chosen action      stat dict  a dictionary containing fields statistics       compositions      key  the numeric values notes belonging key  defaults       c major provided    returns      a dictionary composition statistics  notes key  field     updated          key none      key   rl tuner ops c major key    action note key      stat dict  notes key      1    return stat dict   def add tonic start stat(rl tuner                           action note                           stat dict                           tonic note rl tuner ops c major tonic)       updates stat dict based whether composition started tonic     args      rl tuner  an rltuner object      action note  an integer representing chosen action      stat dict  a dictionary containing fields statistics       compositions      tonic note  the tonic 1st note desired key    returns      a dictionary composition statistics  num starting tonic  field     updated          rl tuner beat    0 action note    tonic note      stat dict  num starting tonic      1   return stat dict   def add repeating note stat(rl tuner  action note  stat dict)       updates stat dict excessively repeated note played     args      rl tuner  an rltuner object      action note  an integer representing chosen action      stat dict  a dictionary containing fields statistics       compositions    returns      a dictionary composition statistics  num repeated notes  field     updated          rl tuner detect repeating notes(action note)      stat dict  num repeated notes      1   return stat dict   def add motif stat(rl tuner  action  stat dict)       updates stat dict motif played     args      rl tuner  an rltuner object      action  one hot encoding chosen action      stat dict  a dictionary containing fields statistics       compositions    returns      a dictionary composition statistics  notes motif  field     updated          composition   rl tuner composition    np argmax(action)    motif      rl tuner detect last motif(composition composition)   motif none      stat dict  notes motif      1   return stat dict   def add repeated motif stat(rl tuner  action  stat dict)       updates stat dict repeated motif played     args      rl tuner  an rltuner object      action  one hot encoding chosen action      stat dict  a dictionary containing fields statistics       compositions    returns      a dictionary composition statistics  notes repeated motif      field updated          repeated      rl tuner detect repeated motif(action)   repeated      stat dict  notes repeated motif      1   return stat dict   def add leap stats(rl tuner  action  stat dict)       updates stat dict melodic leap made resolved     args      rl tuner  an rltuner object      action  one hot encoding chosen action      stat dict  a dictionary containing fields statistics       compositions    returns      a dictionary composition statistics leap related fields updated          leap outcome   rl tuner detect leap back(action)   leap outcome    rl tuner ops leap resolved      stat dict  num resolved leaps      1   elif leap outcome    rl tuner ops leap doubled      stat dict  num leap twice      1   return stat dict   def add high low unique stats(rl tuner  stat dict)       updates stat dict rl tuner composition unique extrema notes     args      rl tuner  an rltuner object      stat dict  a dictionary containing fields statistics       compositions    returns      a dictionary composition statistics  notes repeated motif      field updated           copyright 2016 google inc  all rights reserved        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license          http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license     internal imports    the following functions compute evaluation metrics test whether model    trained successfully     compute note note stats composes  ", "content": "# Copyright 2016 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Code to evaluate how well an RL Tuner conforms to music theory rules.\"\"\"\n\n# internal imports\n\nimport numpy as np\nimport tensorflow as tf\n\nfrom magenta.models.rl_tuner import rl_tuner_ops\n\n\ndef compute_composition_stats(rl_tuner,\n                              num_compositions=10000,\n                              composition_length=32,\n                              key=None,\n                              tonic_note=rl_tuner_ops.C_MAJOR_TONIC):\n  \"\"\"Uses the model to create many compositions, stores statistics about them.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    num_compositions: The number of compositions to create.\n    composition_length: The number of beats in each composition.\n    key: The numeric values of notes belonging to this key. Defaults to\n      C-major if not provided.\n    tonic_note: The tonic/1st note of the desired key.\n  Returns:\n    A dictionary containing the computed statistics about the compositions.\n  \"\"\"\n  stat_dict = initialize_stat_dict()\n\n  for i in range(num_compositions):\n    stat_dict = compose_and_evaluate_piece(\n        rl_tuner,\n        stat_dict,\n        composition_length=composition_length,\n        key=key,\n        tonic_note=tonic_note)\n    if i % (num_compositions / 10) == 0:\n      stat_dict['num_compositions'] = i\n      stat_dict['total_notes'] = i * composition_length\n\n  stat_dict['num_compositions'] = num_compositions\n  stat_dict['total_notes'] = num_compositions * composition_length\n\n  tf.logging.info(get_stat_dict_string(stat_dict))\n\n  return stat_dict\n\n\n# The following functions compute evaluation metrics to test whether the model\n# trained successfully.\ndef get_stat_dict_string(stat_dict, print_interval_stats=True):\n  \"\"\"Makes string of interesting statistics from a composition stat_dict.\n\n  Args:\n    stat_dict: A dictionary storing statistics about a series of compositions.\n    print_interval_stats: If True, print additional stats about the number of\n      different intervals types.\n  Returns:\n    String containing several lines of formatted stats.\n  \"\"\"\n  tot_notes = float(stat_dict['total_notes'])\n  tot_comps = float(stat_dict['num_compositions'])\n\n  return_str = 'Total compositions: ' + str(tot_comps) + '\\n'\n  return_str += 'Total notes:' + str(tot_notes) + '\\n'\n\n  return_str += '\\tCompositions starting with tonic: '\n  return_str += str(float(stat_dict['num_starting_tonic'])) + '\\n'\n  return_str += '\\tCompositions with unique highest note:'\n  return_str += str(float(stat_dict['num_high_unique'])) + '\\n'\n  return_str += '\\tCompositions with unique lowest note:'\n  return_str += str(float(stat_dict['num_low_unique'])) + '\\n'\n  return_str += '\\tNumber of resolved leaps:'\n  return_str += str(float(stat_dict['num_resolved_leaps'])) + '\\n'\n  return_str += '\\tNumber of double leaps:'\n  return_str += str(float(stat_dict['num_leap_twice'])) + '\\n'\n  return_str += '\\tNotes not in key:' + str(float(\n      stat_dict['notes_not_in_key'])) + '\\n'\n  return_str += '\\tNotes in motif:' + str(float(\n      stat_dict['notes_in_motif'])) + '\\n'\n  return_str += '\\tNotes in repeated motif:'\n  return_str += str(float(stat_dict['notes_in_repeated_motif'])) + '\\n'\n  return_str += '\\tNotes excessively repeated:'\n  return_str += str(float(stat_dict['num_repeated_notes'])) + '\\n'\n  return_str += '\\n'\n\n  num_resolved = float(stat_dict['num_resolved_leaps'])\n  total_leaps = (float(stat_dict['num_leap_twice']) + num_resolved)\n  if total_leaps > 0:\n    percent_leaps_resolved = num_resolved / total_leaps\n  else:\n    percent_leaps_resolved = np.nan\n  return_str += '\\tPercent compositions starting with tonic:'\n  return_str += str(stat_dict['num_starting_tonic'] / tot_comps) + '\\n'\n  return_str += '\\tPercent compositions with unique highest note:'\n  return_str += str(float(stat_dict['num_high_unique']) / tot_comps) + '\\n'\n  return_str += '\\tPercent compositions with unique lowest note:'\n  return_str += str(float(stat_dict['num_low_unique']) / tot_comps) + '\\n'\n  return_str += '\\tPercent of leaps resolved:'\n  return_str += str(percent_leaps_resolved) + '\\n'\n  return_str += '\\tPercent notes not in key:'\n  return_str += str(float(stat_dict['notes_not_in_key']) / tot_notes) + '\\n'\n  return_str += '\\tPercent notes in motif:'\n  return_str += str(float(stat_dict['notes_in_motif']) / tot_notes) + '\\n'\n  return_str += '\\tPercent notes in repeated motif:'\n  return_str += str(stat_dict['notes_in_repeated_motif'] / tot_notes) + '\\n'\n  return_str += '\\tPercent notes excessively repeated:'\n  return_str += str(stat_dict['num_repeated_notes'] / tot_notes) + '\\n'\n  return_str += '\\n'\n\n  for lag in [1, 2, 3]:\n    avg_autocorr = np.nanmean(stat_dict['autocorrelation' + str(lag)])\n    return_str += '\\tAverage autocorrelation of lag' + str(lag) + ':'\n    return_str += str(avg_autocorr) + '\\n'\n\n  if print_interval_stats:\n    return_str += '\\n'\n    return_str += '\\tAvg. num octave jumps per composition:'\n    return_str += str(float(stat_dict['num_octave_jumps']) / tot_comps) + '\\n'\n    return_str += '\\tAvg. num sevenths per composition:'\n    return_str += str(float(stat_dict['num_sevenths']) / tot_comps) + '\\n'\n    return_str += '\\tAvg. num fifths per composition:'\n    return_str += str(float(stat_dict['num_fifths']) / tot_comps) + '\\n'\n    return_str += '\\tAvg. num sixths per composition:'\n    return_str += str(float(stat_dict['num_sixths']) / tot_comps) + '\\n'\n    return_str += '\\tAvg. num fourths per composition:'\n    return_str += str(float(stat_dict['num_fourths']) / tot_comps) + '\\n'\n    return_str += '\\tAvg. num rest intervals per composition:'\n    return_str += str(float(stat_dict['num_rest_intervals']) / tot_comps)\n    return_str += '\\n'\n    return_str += '\\tAvg. num seconds per composition:'\n    return_str += str(float(stat_dict['num_seconds']) / tot_comps) + '\\n'\n    return_str += '\\tAvg. num thirds per composition:'\n    return_str += str(float(stat_dict['num_thirds']) / tot_comps) + '\\n'\n    return_str += '\\tAvg. num in key preferred intervals per composition:'\n    return_str += str(\n        float(stat_dict['num_in_key_preferred_intervals']) / tot_comps) + '\\n'\n    return_str += '\\tAvg. num special rest intervals per composition:'\n    return_str += str(\n        float(stat_dict['num_special_rest_intervals']) / tot_comps) + '\\n'\n  return_str += '\\n'\n\n  return return_str\n\n\ndef compose_and_evaluate_piece(rl_tuner,\n                               stat_dict,\n                               composition_length=32,\n                               key=None,\n                               tonic_note=rl_tuner_ops.C_MAJOR_TONIC,\n                               sample_next_obs=True):\n  \"\"\"Composes a piece using the model, stores statistics about it in a dict.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    stat_dict: A dictionary storing statistics about a series of compositions.\n    composition_length: The number of beats in the composition.\n    key: The numeric values of notes belonging to this key. Defaults to\n      C-major if not provided.\n    tonic_note: The tonic/1st note of the desired key.\n    sample_next_obs: If True, each note will be sampled from the model's\n      output distribution. If False, each note will be the one with maximum\n      value according to the model.\n  Returns:\n    A dictionary updated to include statistics about the composition just\n    created.\n  \"\"\"\n  last_observation = rl_tuner.prime_internal_models()\n  rl_tuner.reset_composition()\n\n  for _ in range(composition_length):\n    if sample_next_obs:\n      action, new_observation, _ = rl_tuner.action(\n          last_observation,\n          0,\n          enable_random=False,\n          sample_next_obs=sample_next_obs)\n    else:\n      action, _ = rl_tuner.action(\n          last_observation,\n          0,\n          enable_random=False,\n          sample_next_obs=sample_next_obs)\n      new_observation = action\n\n    obs_note = np.argmax(new_observation)\n\n    # Compute note by note stats as it composes.\n    stat_dict = add_interval_stat(rl_tuner, new_observation, stat_dict, key=key)\n    stat_dict = add_in_key_stat(obs_note, stat_dict, key=key)\n    stat_dict = add_tonic_start_stat(\n        rl_tuner, obs_note, stat_dict, tonic_note=tonic_note)\n    stat_dict = add_repeating_note_stat(rl_tuner, obs_note, stat_dict)\n    stat_dict = add_motif_stat(rl_tuner, new_observation, stat_dict)\n    stat_dict = add_repeated_motif_stat(rl_tuner, new_observation, stat_dict)\n    stat_dict = add_leap_stats(rl_tuner, new_observation, stat_dict)\n\n    rl_tuner.composition.append(np.argmax(new_observation))\n    rl_tuner.beat += 1\n    last_observation = new_observation\n\n  for lag in [1, 2, 3]:\n    stat_dict['autocorrelation' + str(lag)].append(\n        rl_tuner_ops.autocorrelate(rl_tuner.composition, lag))\n\n  add_high_low_unique_stats(rl_tuner, stat_dict)\n\n  return stat_dict\n\n\ndef initialize_stat_dict():\n  \"\"\"Initializes a dictionary which will hold statistics about compositions.\n\n  Returns:\n    A dictionary containing the appropriate fields initialized to 0 or an\n    empty list.\n  \"\"\"\n  stat_dict = dict()\n\n  for lag in [1, 2, 3]:\n    stat_dict['autocorrelation' + str(lag)] = []\n\n  stat_dict['notes_not_in_key'] = 0\n  stat_dict['notes_in_motif'] = 0\n  stat_dict['notes_in_repeated_motif'] = 0\n  stat_dict['num_starting_tonic'] = 0\n  stat_dict['num_repeated_notes'] = 0\n  stat_dict['num_octave_jumps'] = 0\n  stat_dict['num_fifths'] = 0\n  stat_dict['num_thirds'] = 0\n  stat_dict['num_sixths'] = 0\n  stat_dict['num_seconds'] = 0\n  stat_dict['num_fourths'] = 0\n  stat_dict['num_sevenths'] = 0\n  stat_dict['num_rest_intervals'] = 0\n  stat_dict['num_special_rest_intervals'] = 0\n  stat_dict['num_in_key_preferred_intervals'] = 0\n  stat_dict['num_resolved_leaps'] = 0\n  stat_dict['num_leap_twice'] = 0\n  stat_dict['num_high_unique'] = 0\n  stat_dict['num_low_unique'] = 0\n\n  return stat_dict\n\n\ndef add_interval_stat(rl_tuner, action, stat_dict, key=None):\n  \"\"\"Computes the melodic interval just played and adds it to a stat dict.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    action: One-hot encoding of the chosen action.\n    stat_dict: A dictionary containing fields for statistics about\n      compositions.\n    key: The numeric values of notes belonging to this key. Defaults to\n      C-major if not provided.\n  Returns:\n    A dictionary of composition statistics with fields updated to include new\n    intervals.\n  \"\"\"\n  interval, _, _ = rl_tuner.detect_sequential_interval(action, key)\n\n  if interval == 0:\n    return stat_dict\n\n  if interval == rl_tuner_ops.REST_INTERVAL:\n    stat_dict['num_rest_intervals'] += 1\n  elif interval == rl_tuner_ops.REST_INTERVAL_AFTER_THIRD_OR_FIFTH:\n    stat_dict['num_special_rest_intervals'] += 1\n  elif interval > rl_tuner_ops.OCTAVE:\n    stat_dict['num_octave_jumps'] += 1\n  elif interval == (rl_tuner_ops.IN_KEY_FIFTH or\n                    interval == rl_tuner_ops.IN_KEY_THIRD):\n    stat_dict['num_in_key_preferred_intervals'] += 1\n  elif interval == rl_tuner_ops.FIFTH:\n    stat_dict['num_fifths'] += 1\n  elif interval == rl_tuner_ops.THIRD:\n    stat_dict['num_thirds'] += 1\n  elif interval == rl_tuner_ops.SIXTH:\n    stat_dict['num_sixths'] += 1\n  elif interval == rl_tuner_ops.SECOND:\n    stat_dict['num_seconds'] += 1\n  elif interval == rl_tuner_ops.FOURTH:\n    stat_dict['num_fourths'] += 1\n  elif interval == rl_tuner_ops.SEVENTH:\n    stat_dict['num_sevenths'] += 1\n\n  return stat_dict\n\n\ndef add_in_key_stat(action_note, stat_dict, key=None):\n  \"\"\"Determines whether the note played was in key, and updates a stat dict.\n\n  Args:\n    action_note: An integer representing the chosen action.\n    stat_dict: A dictionary containing fields for statistics about\n      compositions.\n    key: The numeric values of notes belonging to this key. Defaults to\n      C-major if not provided.\n  Returns:\n    A dictionary of composition statistics with 'notes_not_in_key' field\n    updated.\n  \"\"\"\n  if key is None:\n    key = rl_tuner_ops.C_MAJOR_KEY\n\n  if action_note not in key:\n    stat_dict['notes_not_in_key'] += 1\n\n  return stat_dict\n\n\ndef add_tonic_start_stat(rl_tuner,\n                         action_note,\n                         stat_dict,\n                         tonic_note=rl_tuner_ops.C_MAJOR_TONIC):\n  \"\"\"Updates stat dict based on whether composition started with the tonic.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    action_note: An integer representing the chosen action.\n    stat_dict: A dictionary containing fields for statistics about\n      compositions.\n    tonic_note: The tonic/1st note of the desired key.\n  Returns:\n    A dictionary of composition statistics with 'num_starting_tonic' field\n    updated.\n  \"\"\"\n  if rl_tuner.beat == 0 and action_note == tonic_note:\n    stat_dict['num_starting_tonic'] += 1\n  return stat_dict\n\n\ndef add_repeating_note_stat(rl_tuner, action_note, stat_dict):\n  \"\"\"Updates stat dict if an excessively repeated note was played.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    action_note: An integer representing the chosen action.\n    stat_dict: A dictionary containing fields for statistics about\n      compositions.\n  Returns:\n    A dictionary of composition statistics with 'num_repeated_notes' field\n    updated.\n  \"\"\"\n  if rl_tuner.detect_repeating_notes(action_note):\n    stat_dict['num_repeated_notes'] += 1\n  return stat_dict\n\n\ndef add_motif_stat(rl_tuner, action, stat_dict):\n  \"\"\"Updates stat dict if a motif was just played.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    action: One-hot encoding of the chosen action.\n    stat_dict: A dictionary containing fields for statistics about\n      compositions.\n  Returns:\n    A dictionary of composition statistics with 'notes_in_motif' field\n    updated.\n  \"\"\"\n  composition = rl_tuner.composition + [np.argmax(action)]\n  motif, _ = rl_tuner.detect_last_motif(composition=composition)\n  if motif is not None:\n    stat_dict['notes_in_motif'] += 1\n  return stat_dict\n\n\ndef add_repeated_motif_stat(rl_tuner, action, stat_dict):\n  \"\"\"Updates stat dict if a repeated motif was just played.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    action: One-hot encoding of the chosen action.\n    stat_dict: A dictionary containing fields for statistics about\n      compositions.\n  Returns:\n    A dictionary of composition statistics with 'notes_in_repeated_motif'\n    field updated.\n  \"\"\"\n  is_repeated, _ = rl_tuner.detect_repeated_motif(action)\n  if is_repeated:\n    stat_dict['notes_in_repeated_motif'] += 1\n  return stat_dict\n\n\ndef add_leap_stats(rl_tuner, action, stat_dict):\n  \"\"\"Updates stat dict if a melodic leap was just made or resolved.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    action: One-hot encoding of the chosen action.\n    stat_dict: A dictionary containing fields for statistics about\n      compositions.\n  Returns:\n    A dictionary of composition statistics with leap-related fields updated.\n  \"\"\"\n  leap_outcome = rl_tuner.detect_leap_up_back(action)\n  if leap_outcome == rl_tuner_ops.LEAP_RESOLVED:\n    stat_dict['num_resolved_leaps'] += 1\n  elif leap_outcome == rl_tuner_ops.LEAP_DOUBLED:\n    stat_dict['num_leap_twice'] += 1\n  return stat_dict\n\n\ndef add_high_low_unique_stats(rl_tuner, stat_dict):\n  \"\"\"Updates stat dict if rl_tuner.composition has unique extrema notes.\n\n  Args:\n    rl_tuner: An RLTuner object.\n    stat_dict: A dictionary containing fields for statistics about\n      compositions.\n  Returns:\n    A dictionary of composition statistics with 'notes_in_repeated_motif'\n    field updated.\n  \"\"\"\n  if rl_tuner.detect_high_unique(rl_tuner.composition):\n    stat_dict['num_high_unique'] += 1\n  if rl_tuner.detect_low_unique(rl_tuner.composition):\n    stat_dict['num_low_unique'] += 1\n\n  return stat_dict\n", "description": "Magenta: Music and Art Generation with Machine Intelligence", "file_name": "rl_tuner_eval_metrics.py", "id": "781a8280fb3f4577606d94dab98d3e0b", "language": "Python", "project_name": "magenta", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/tensorflow-magenta/tensorflow-magenta-c3eda3d/magenta/models/rl_tuner/rl_tuner_eval_metrics.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:52:33Z", "url": "https://github.com/tensorflow/magenta", "wiki": false}