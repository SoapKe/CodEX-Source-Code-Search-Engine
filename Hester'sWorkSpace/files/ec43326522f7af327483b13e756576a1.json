{"author": "mitmproxy", "code": "import os\nimport configparser\nimport pytest\nimport sys\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\n\nenable_coverage = False\ncoverage_values = []\ncoverage_passed = True\nno_full_cov = []\n\n\ndef pytest_addoption(parser):\n    parser.addoption('--full-cov',\n                     action='append',\n                     dest='full_cov',\n                     default=[],\n                     help=\"Require full test coverage of 100%% for this module/path/filename (multi-allowed). Default: none\")\n\n    parser.addoption('--no-full-cov',\n                     action='append',\n                     dest='no_full_cov',\n                     default=[],\n                     help=\"Exclude file from a parent 100%% coverage requirement (multi-allowed). Default: none\")\n\n\ndef pytest_configure(config):\n    global enable_coverage\n    global no_full_cov\n\n    enable_coverage = (\n        len(config.getoption('file_or_dir')) == 0 and\n        len(config.getoption('full_cov')) > 0 and\n        config.pluginmanager.getplugin(\"_cov\") is not None and\n        config.pluginmanager.getplugin(\"_cov\").cov_controller is not None and\n        config.pluginmanager.getplugin(\"_cov\").cov_controller.cov is not None\n    )\n\n    c = configparser.ConfigParser()\n    c.read(os.path.join(here, \"..\", \"setup.cfg\"))\n    fs = c['tool:full_coverage']['exclude'].split('\\n')\n    no_full_cov = config.option.no_full_cov + [f.strip() for f in fs]\n\n\n@pytest.hookimpl(hookwrapper=True)\ndef pytest_runtestloop(session):\n    global enable_coverage\n    global coverage_values\n    global coverage_passed\n    global no_full_cov\n\n    if not enable_coverage:\n        yield\n        return\n\n    cov = pytest.config.pluginmanager.getplugin(\"_cov\").cov_controller.cov\n\n    if os.name == 'nt':\n        cov.exclude('pragma: windows no cover')\n\n    if sys.platform == 'darwin':\n        cov.exclude('pragma: osx no cover')\n\n    if os.environ.get(\"OPENSSL\") == \"old\":\n        cov.exclude('pragma: openssl-old no cover')\n\n    yield\n\n    coverage_values = dict([(name, 0) for name in pytest.config.option.full_cov])\n\n    prefix = os.getcwd()\n\n    excluded_files = [os.path.normpath(f) for f in no_full_cov]\n    measured_files = [os.path.normpath(os.path.relpath(f, prefix)) for f in cov.get_data().measured_files()]\n    measured_files = [f for f in measured_files if not any(f.startswith(excluded_f) for excluded_f in excluded_files)]\n\n    for name in coverage_values.keys():\n        files = [f for f in measured_files if f.startswith(os.path.normpath(name))]\n        try:\n            with open(os.devnull, 'w') as null:\n                overall = cov.report(files, ignore_errors=True, file=null)\n                singles = [(s, cov.report(s, ignore_errors=True, file=null)) for s in files]\n                coverage_values[name] = (overall, singles)\n        except:\n            pass\n\n    if any(v < 100 for v, _ in coverage_values.values()):\n        \n        session.testsfailed += 1\n        coverage_passed = False\n\n\ndef pytest_terminal_summary(terminalreporter, exitstatus):\n    global enable_coverage\n    global coverage_values\n    global coverage_passed\n    global no_full_cov\n\n    if not enable_coverage:\n        return\n\n    terminalreporter.write('\\n')\n    if not coverage_passed:\n        markup = {'red': True, 'bold': True}\n        msg = \"FAIL: Full test coverage not reached!\\n\"\n        terminalreporter.write(msg, **markup)\n\n        for name in sorted(coverage_values.keys()):\n            msg = 'Coverage for {}: {:.2f}%\\n'.format(name, coverage_values[name][0])\n            if coverage_values[name][0] < 100:\n                markup = {'red': True, 'bold': True}\n                for s, v in sorted(coverage_values[name][1]):\n                    if v < 100:\n                        msg += '  {}: {:.2f}%\\n'.format(s, v)\n            else:\n                markup = {'green': True}\n            terminalreporter.write(msg, **markup)\n    else:\n        msg = 'SUCCESS: Full test coverage reached in modules and files:\\n'\n        msg += '{}\\n\\n'.format('\\n'.join(pytest.config.option.full_cov))\n        terminalreporter.write(msg, green=True)\n\n    msg = '\\nExcluded files:\\n'\n    for s in sorted(no_full_cov):\n        msg += \"  {}\\n\".format(s)\n    terminalreporter.write(msg)\n", "comments": "  make sure get exit testsfailed exit code ", "content": "import os\nimport configparser\nimport pytest\nimport sys\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\n\nenable_coverage = False\ncoverage_values = []\ncoverage_passed = True\nno_full_cov = []\n\n\ndef pytest_addoption(parser):\n    parser.addoption('--full-cov',\n                     action='append',\n                     dest='full_cov',\n                     default=[],\n                     help=\"Require full test coverage of 100%% for this module/path/filename (multi-allowed). Default: none\")\n\n    parser.addoption('--no-full-cov',\n                     action='append',\n                     dest='no_full_cov',\n                     default=[],\n                     help=\"Exclude file from a parent 100%% coverage requirement (multi-allowed). Default: none\")\n\n\ndef pytest_configure(config):\n    global enable_coverage\n    global no_full_cov\n\n    enable_coverage = (\n        len(config.getoption('file_or_dir')) == 0 and\n        len(config.getoption('full_cov')) > 0 and\n        config.pluginmanager.getplugin(\"_cov\") is not None and\n        config.pluginmanager.getplugin(\"_cov\").cov_controller is not None and\n        config.pluginmanager.getplugin(\"_cov\").cov_controller.cov is not None\n    )\n\n    c = configparser.ConfigParser()\n    c.read(os.path.join(here, \"..\", \"setup.cfg\"))\n    fs = c['tool:full_coverage']['exclude'].split('\\n')\n    no_full_cov = config.option.no_full_cov + [f.strip() for f in fs]\n\n\n@pytest.hookimpl(hookwrapper=True)\ndef pytest_runtestloop(session):\n    global enable_coverage\n    global coverage_values\n    global coverage_passed\n    global no_full_cov\n\n    if not enable_coverage:\n        yield\n        return\n\n    cov = pytest.config.pluginmanager.getplugin(\"_cov\").cov_controller.cov\n\n    if os.name == 'nt':\n        cov.exclude('pragma: windows no cover')\n\n    if sys.platform == 'darwin':\n        cov.exclude('pragma: osx no cover')\n\n    if os.environ.get(\"OPENSSL\") == \"old\":\n        cov.exclude('pragma: openssl-old no cover')\n\n    yield\n\n    coverage_values = dict([(name, 0) for name in pytest.config.option.full_cov])\n\n    prefix = os.getcwd()\n\n    excluded_files = [os.path.normpath(f) for f in no_full_cov]\n    measured_files = [os.path.normpath(os.path.relpath(f, prefix)) for f in cov.get_data().measured_files()]\n    measured_files = [f for f in measured_files if not any(f.startswith(excluded_f) for excluded_f in excluded_files)]\n\n    for name in coverage_values.keys():\n        files = [f for f in measured_files if f.startswith(os.path.normpath(name))]\n        try:\n            with open(os.devnull, 'w') as null:\n                overall = cov.report(files, ignore_errors=True, file=null)\n                singles = [(s, cov.report(s, ignore_errors=True, file=null)) for s in files]\n                coverage_values[name] = (overall, singles)\n        except:\n            pass\n\n    if any(v < 100 for v, _ in coverage_values.values()):\n        # make sure we get the EXIT_TESTSFAILED exit code\n        session.testsfailed += 1\n        coverage_passed = False\n\n\ndef pytest_terminal_summary(terminalreporter, exitstatus):\n    global enable_coverage\n    global coverage_values\n    global coverage_passed\n    global no_full_cov\n\n    if not enable_coverage:\n        return\n\n    terminalreporter.write('\\n')\n    if not coverage_passed:\n        markup = {'red': True, 'bold': True}\n        msg = \"FAIL: Full test coverage not reached!\\n\"\n        terminalreporter.write(msg, **markup)\n\n        for name in sorted(coverage_values.keys()):\n            msg = 'Coverage for {}: {:.2f}%\\n'.format(name, coverage_values[name][0])\n            if coverage_values[name][0] < 100:\n                markup = {'red': True, 'bold': True}\n                for s, v in sorted(coverage_values[name][1]):\n                    if v < 100:\n                        msg += '  {}: {:.2f}%\\n'.format(s, v)\n            else:\n                markup = {'green': True}\n            terminalreporter.write(msg, **markup)\n    else:\n        msg = 'SUCCESS: Full test coverage reached in modules and files:\\n'\n        msg += '{}\\n\\n'.format('\\n'.join(pytest.config.option.full_cov))\n        terminalreporter.write(msg, green=True)\n\n    msg = '\\nExcluded files:\\n'\n    for s in sorted(no_full_cov):\n        msg += \"  {}\\n\".format(s)\n    terminalreporter.write(msg)\n", "description": "An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers.", "file_name": "full_coverage_plugin.py", "id": "ec43326522f7af327483b13e756576a1", "language": "Python", "project_name": "mitmproxy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/mitmproxy-mitmproxy/mitmproxy-mitmproxy-0bc3f1f/test/full_coverage_plugin.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:23:46Z", "url": "https://github.com/mitmproxy/mitmproxy", "wiki": false}