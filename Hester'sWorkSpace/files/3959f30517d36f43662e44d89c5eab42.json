{"author": "XX-net", "code": "import time\nimport socket\nimport struct\nimport urlparse\nimport select\n\nimport pac_server\nimport global_var as g\nfrom socket_wrap import SocketWrap\nimport utils\nfrom smart_route import handle_ip_proxy, handle_domain_proxy, netloc_to_host_port\nfrom xlog import getLogger\nxlog = getLogger(\"smart_router\")\n\nSO_ORIGINAL_DST = 80\n\n\nclass ProxyServer():\n    handle_num = 0\n\n    def __init__(self, sock, client, args):\n        self.conn = sock\n        self.rfile = socket._fileobject(self.conn, \"rb\", -1)\n        self.wfile = socket._fileobject(self.conn, \"wb\", 0)\n        self.client_address = client\n\n        self.read_buffer = \"\"\n        self.buffer_start = 0\n        self.support_redirect = True\n\n    def try_redirect(self):\n        if not self.support_redirect:\n            return False\n\n        try:\n            dst = self.conn.getsockopt(socket.SOL_IP, SO_ORIGINAL_DST, 16)\n        except:\n            self.support_redirect = False\n            return False\n\n        try:\n            dst_port, srv_ip = struct.unpack(\"!2xH4s8x\", dst)\n            ip_str = socket.inet_ntoa(srv_ip)\n            if dst_port != g.config.proxy_port and not utils.is_private_ip(ip_str):\n                xlog.debug(\"Redirect to:%s:%d from:%s\", ip_str, dst_port, self.client_address)\n                handle_ip_proxy(self.conn, ip_str, dst_port, self.client_address)\n                return True\n            else:\n                return False\n        except Exception as e:\n            xlog.exception(\"redirect except:%r\", e)\n\n        return True\n\n    def handle(self):\n        self.__class__.handle_num += 1\n\n        if self.try_redirect():\n            return\n\n        sockets = [self.conn]\n        try:\n            r, w, e = select.select(sockets, [], [])\n            socks_version = self.conn.recv(1, socket.MSG_PEEK)\n            if not socks_version:\n                return\n\n            if socks_version == \"\\x04\":\n                self.socks4_handler()\n            elif socks_version == \"\\x05\":\n                self.socks5_handler()\n            elif socks_version == \"C\":\n                self.https_handler()\n            elif socks_version in [\"G\", \"P\", \"D\", \"O\", \"H\", \"T\"]:\n                self.http_handler()\n            else:\n                xlog.warn(\"socks version:%s[%s] not supported\", socks_version, utils.str2hex(socks_version))\n                return\n\n        except socket.error as e:\n            xlog.warn('socks handler read error:%r', e)\n        except Exception as e:\n            xlog.exception(\"any err:%r\", e)\n\n    def read_null_end_line(self):\n        sock = self.conn\n        sock.setblocking(0)\n        try:\n            while True:\n                n1 = self.read_buffer.find(\"\\x00\", self.buffer_start)\n                if n1 > -1:\n                    line = self.read_buffer[self.buffer_start:n1]\n                    self.buffer_start = n1 + 1\n                    return line\n\n                try:\n                    data = sock.recv(8192)\n                except socket.error as e:\n                    # logging.exception(\"e:%r\", e)\n                    if e.errno in [2, 11, 10035]:\n                        time.sleep(0.01)\n                        continue\n                    else:\n                        raise e\n\n                self.read_buffer += data\n        finally:\n            sock.setblocking(1)\n\n    def read_crlf_line(self):\n        sock = self.conn\n        sock.setblocking(0)\n        try:\n            while True:\n                n1 = self.read_buffer.find(\"\\r\\n\", self.buffer_start)\n                if n1 > -1:\n                    line = self.read_buffer[self.buffer_start:n1]\n                    self.buffer_start = n1 + 2\n                    return line\n\n                try:\n                    data = sock.recv(8192)\n                except socket.error as e:\n                    # logging.exception(\"e:%r\", e)\n                    if e.errno in [2, 11, 10035]:\n                        time.sleep(0.01)\n                        continue\n                    else:\n                        raise e\n\n                self.read_buffer += data\n        finally:\n            sock.setblocking(1)\n\n    def read_headers(self):\n        sock = self.conn\n        sock.setblocking(0)\n        try:\n            while True:\n                if self.read_buffer[self.buffer_start:] == \"\\r\\n\":\n                    self.buffer_start += 2\n                    return \"\"\n\n                n1 = self.read_buffer.find(\"\\r\\n\\r\\n\", self.buffer_start)\n                if n1 > -1:\n                    block = self.read_buffer[self.buffer_start:n1]\n                    self.buffer_start = n1 + 4\n                    return block\n\n                try:\n                    data = sock.recv(8192)\n                except socket.error as e:\n                    # logging.exception(\"e:%r\", e)\n                    if e.errno in [2, 11, 10035]:\n                        time.sleep(0.01)\n                        continue\n                    else:\n                        raise e\n\n                self.read_buffer += data\n        finally:\n            sock.setblocking(1)\n\n    def read_bytes(self, size):\n        sock = self.conn\n        sock.setblocking(1)\n        try:\n            while True:\n                left = len(self.read_buffer) - self.buffer_start\n                if left >= size:\n                    break\n\n                need = size - left\n\n                try:\n                    data = sock.recv(need)\n                except socket.error as e:\n                    # logging.exception(\"e:%r\", e)\n                    if e.errno in [2, 11, 10035]:\n                        time.sleep(0.01)\n                        continue\n                    else:\n                        raise e\n\n                if len(data):\n                    self.read_buffer += data\n                else:\n                    raise socket.error(\"recv fail\")\n        finally:\n            sock.setblocking(1)\n\n        data = self.read_buffer[self.buffer_start:self.buffer_start + size]\n        self.buffer_start += size\n        return data\n\n    def socks4_handler(self):\n        \n        sock = self.conn\n        socks_version = ord(self.read_bytes(1))\n        cmd = ord(self.read_bytes(1))\n        if cmd != 1:\n            xlog.warn(\"Socks4 cmd:%d not supported\", cmd)\n            return\n\n        data = self.read_bytes(6)\n        port = struct.unpack(\">H\", data[0:2])[0]\n        addr_pack = data[2:6]\n        if addr_pack[0:3] == '\\x00\\x00\\x00' and addr_pack[3] != '\\x00':\n            domain_mode = True\n        else:\n            ip = socket.inet_ntoa(addr_pack)\n            domain_mode = False\n\n        user_id = self.read_null_end_line()\n        if len(user_id):\n            xlog.debug(\"Socks4 user_id:%s\", user_id)\n\n        if domain_mode:\n            addr = self.read_null_end_line()\n        else:\n            addr = ip\n\n        reply = b\"\\x00\\x5a\" + addr_pack + struct.pack(\">H\", port)\n        sock.send(reply)\n\n        # xlog.debug(\"Socks4:%r to %s:%d\", self.client_address, addr, port)\n        handle_ip_proxy(sock, addr, port, self.client_address)\n\n    def socks5_handler(self):\n        sock = self.conn\n        socks_version = ord(self.read_bytes(1))\n        auth_mode_num = ord(self.read_bytes(1))\n        data = self.read_bytes(auth_mode_num)\n\n        sock.send(b\"\\x05\\x00\")  \n        try:\n            data = self.read_bytes(4)\n        except Exception as e:\n            xlog.debug(\"socks5 auth num:%d, list:%s\", auth_mode_num, utils.str2hex(data))\n            xlog.warn(\"socks5 protocol error:%r\", e)\n            return\n\n        socks_version = ord(data[0])\n        if socks_version != 5:\n            xlog.warn(\"request version:%d error\", socks_version)\n            return\n\n        command = ord(data[1])\n        if command != 1:  \n            xlog.warn(\"request not supported command mode:%d\", command)\n            sock.send(b\"\\x05\\x07\\x00\\x01\")  \n            return\n\n        addrtype_pack = data[3]\n        addrtype = ord(addrtype_pack)\n        if addrtype == 1:  \n            addr_pack = self.read_bytes(4)\n            addr = socket.inet_ntoa(addr_pack)\n        elif addrtype == 3:  \n            domain_len_pack = self.read_bytes(1)[0]\n            domain_len = ord(domain_len_pack)\n            domain = self.read_bytes(domain_len)\n            addr_pack = domain_len_pack + domain\n            addr = domain\n        elif addrtype == 4:  \n            addr_pack = self.read_bytes(16)\n            addr = socket.inet_ntop(socket.AF_INET6, addr_pack)\n        else:\n            xlog.warn(\"request address type unknown:%d\", addrtype)\n            sock.send(b\"\\x05\\x07\\x00\\x01\")  \n            return\n\n        port = struct.unpack('>H', self.rfile.read(2))[0]\n\n        # xlog.debug(\"socks5 %r connect to %s:%d\", self.client_address, addr, port)\n        reply = b\"\\x05\\x00\\x00\" + addrtype_pack + addr_pack + struct.pack(\">H\", port)\n        sock.send(reply)\n\n        if addrtype in [1, 4]:\n            handle_ip_proxy(sock, addr, port, self.client_address)\n        else:\n            handle_domain_proxy(sock, addr, port, self.client_address)\n\n    def https_handler(self):\n        line = self.read_crlf_line()\n        line = line.decode('iso-8859-1')\n        words = line.split()\n        if len(words) == 3:\n            command, path, version = words\n        elif len(words) == 2:\n            command, path = words\n            version = \"HTTP/1.1\"\n        else:\n            xlog.warn(\"https req line fail:%s\", line)\n            return\n\n        if command != \"CONNECT\":\n            xlog.warn(\"https req line fail:%s\", line)\n            return\n\n        host, _, port = path.rpartition(':')\n        host = host.encode()\n        port = int(port)\n\n        header_block = self.read_headers()\n        sock = self.conn\n\n        # xlog.debug(\"https %r connect to %s:%d\", self.client_address, host, port)\n        sock.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n')\n\n        handle_domain_proxy(sock, host, port, self.client_address)\n\n    def http_handler(self):\n        req_data = self.conn.recv(65537, socket.MSG_PEEK)\n        rp = req_data.split(\"\\r\\n\")\n        req_line = rp[0]\n\n        words = req_line.split()\n        if len(words) == 3:\n            method, url, http_version = words\n        elif len(words) == 2:\n            method, url = words\n            http_version = \"HTTP/1.1\"\n        else:\n            xlog.warn(\"http req line fail:%s\", req_line)\n            return\n\n        if url.lower().startswith(\"http://\"):\n            o = urlparse.urlparse(url)\n            host, port = netloc_to_host_port(o.netloc)\n\n            url_prex_len = url[7:].find(\"/\")\n            if url_prex_len >= 0:\n                url_prex_len += 7\n                path = url[url_prex_len:]\n            else:\n                url_prex_len = len(url)\n                path = \"/\"\n        else:\n            \n            xlog.debug(\"PAC %s %s from:%s\", method, url, self.client_address)\n            handler = pac_server.PacHandler(self.conn, self.client_address, None, xlog)\n            return handler.handle()\n\n        #req_d = self.conn.recv(len(req_line))\n        #req_d = req_d.replace(url, path)\n\n        sock = SocketWrap(self.conn, self.client_address[0], self.client_address[1])\n        sock.replace_pattern = [url[:url_prex_len], \"\"]\n\n        xlog.debug(\"http %r connect to %s:%d %s %s\", self.client_address, host, port, method, path)\n        handle_domain_proxy(sock, host, port, self.client_address)\n", "comments": "  logging exception( e  r   e)    logging exception( e  r   e)    logging exception( e  r   e)    logging exception( e  r   e)    socks4 socks4a    xlog debug( socks4  r     self client address  addr  port)    socks version 5  auth needed     1  tcp connect    command supported    ipv4    domain name    ipv6    command supported    xlog debug( socks5  r connect     self client address  addr  port)    xlog debug( https  r connect     self client address  host  port)    proxy request  pac   req   self conn recv(len(req line))   req   req replace(url  path) ", "content": "import time\nimport socket\nimport struct\nimport urlparse\nimport select\n\nimport pac_server\nimport global_var as g\nfrom socket_wrap import SocketWrap\nimport utils\nfrom smart_route import handle_ip_proxy, handle_domain_proxy, netloc_to_host_port\nfrom xlog import getLogger\nxlog = getLogger(\"smart_router\")\n\nSO_ORIGINAL_DST = 80\n\n\nclass ProxyServer():\n    handle_num = 0\n\n    def __init__(self, sock, client, args):\n        self.conn = sock\n        self.rfile = socket._fileobject(self.conn, \"rb\", -1)\n        self.wfile = socket._fileobject(self.conn, \"wb\", 0)\n        self.client_address = client\n\n        self.read_buffer = \"\"\n        self.buffer_start = 0\n        self.support_redirect = True\n\n    def try_redirect(self):\n        if not self.support_redirect:\n            return False\n\n        try:\n            dst = self.conn.getsockopt(socket.SOL_IP, SO_ORIGINAL_DST, 16)\n        except:\n            self.support_redirect = False\n            return False\n\n        try:\n            dst_port, srv_ip = struct.unpack(\"!2xH4s8x\", dst)\n            ip_str = socket.inet_ntoa(srv_ip)\n            if dst_port != g.config.proxy_port and not utils.is_private_ip(ip_str):\n                xlog.debug(\"Redirect to:%s:%d from:%s\", ip_str, dst_port, self.client_address)\n                handle_ip_proxy(self.conn, ip_str, dst_port, self.client_address)\n                return True\n            else:\n                return False\n        except Exception as e:\n            xlog.exception(\"redirect except:%r\", e)\n\n        return True\n\n    def handle(self):\n        self.__class__.handle_num += 1\n\n        if self.try_redirect():\n            return\n\n        sockets = [self.conn]\n        try:\n            r, w, e = select.select(sockets, [], [])\n            socks_version = self.conn.recv(1, socket.MSG_PEEK)\n            if not socks_version:\n                return\n\n            if socks_version == \"\\x04\":\n                self.socks4_handler()\n            elif socks_version == \"\\x05\":\n                self.socks5_handler()\n            elif socks_version == \"C\":\n                self.https_handler()\n            elif socks_version in [\"G\", \"P\", \"D\", \"O\", \"H\", \"T\"]:\n                self.http_handler()\n            else:\n                xlog.warn(\"socks version:%s[%s] not supported\", socks_version, utils.str2hex(socks_version))\n                return\n\n        except socket.error as e:\n            xlog.warn('socks handler read error:%r', e)\n        except Exception as e:\n            xlog.exception(\"any err:%r\", e)\n\n    def read_null_end_line(self):\n        sock = self.conn\n        sock.setblocking(0)\n        try:\n            while True:\n                n1 = self.read_buffer.find(\"\\x00\", self.buffer_start)\n                if n1 > -1:\n                    line = self.read_buffer[self.buffer_start:n1]\n                    self.buffer_start = n1 + 1\n                    return line\n\n                try:\n                    data = sock.recv(8192)\n                except socket.error as e:\n                    # logging.exception(\"e:%r\", e)\n                    if e.errno in [2, 11, 10035]:\n                        time.sleep(0.01)\n                        continue\n                    else:\n                        raise e\n\n                self.read_buffer += data\n        finally:\n            sock.setblocking(1)\n\n    def read_crlf_line(self):\n        sock = self.conn\n        sock.setblocking(0)\n        try:\n            while True:\n                n1 = self.read_buffer.find(\"\\r\\n\", self.buffer_start)\n                if n1 > -1:\n                    line = self.read_buffer[self.buffer_start:n1]\n                    self.buffer_start = n1 + 2\n                    return line\n\n                try:\n                    data = sock.recv(8192)\n                except socket.error as e:\n                    # logging.exception(\"e:%r\", e)\n                    if e.errno in [2, 11, 10035]:\n                        time.sleep(0.01)\n                        continue\n                    else:\n                        raise e\n\n                self.read_buffer += data\n        finally:\n            sock.setblocking(1)\n\n    def read_headers(self):\n        sock = self.conn\n        sock.setblocking(0)\n        try:\n            while True:\n                if self.read_buffer[self.buffer_start:] == \"\\r\\n\":\n                    self.buffer_start += 2\n                    return \"\"\n\n                n1 = self.read_buffer.find(\"\\r\\n\\r\\n\", self.buffer_start)\n                if n1 > -1:\n                    block = self.read_buffer[self.buffer_start:n1]\n                    self.buffer_start = n1 + 4\n                    return block\n\n                try:\n                    data = sock.recv(8192)\n                except socket.error as e:\n                    # logging.exception(\"e:%r\", e)\n                    if e.errno in [2, 11, 10035]:\n                        time.sleep(0.01)\n                        continue\n                    else:\n                        raise e\n\n                self.read_buffer += data\n        finally:\n            sock.setblocking(1)\n\n    def read_bytes(self, size):\n        sock = self.conn\n        sock.setblocking(1)\n        try:\n            while True:\n                left = len(self.read_buffer) - self.buffer_start\n                if left >= size:\n                    break\n\n                need = size - left\n\n                try:\n                    data = sock.recv(need)\n                except socket.error as e:\n                    # logging.exception(\"e:%r\", e)\n                    if e.errno in [2, 11, 10035]:\n                        time.sleep(0.01)\n                        continue\n                    else:\n                        raise e\n\n                if len(data):\n                    self.read_buffer += data\n                else:\n                    raise socket.error(\"recv fail\")\n        finally:\n            sock.setblocking(1)\n\n        data = self.read_buffer[self.buffer_start:self.buffer_start + size]\n        self.buffer_start += size\n        return data\n\n    def socks4_handler(self):\n        # Socks4 or Socks4a\n        sock = self.conn\n        socks_version = ord(self.read_bytes(1))\n        cmd = ord(self.read_bytes(1))\n        if cmd != 1:\n            xlog.warn(\"Socks4 cmd:%d not supported\", cmd)\n            return\n\n        data = self.read_bytes(6)\n        port = struct.unpack(\">H\", data[0:2])[0]\n        addr_pack = data[2:6]\n        if addr_pack[0:3] == '\\x00\\x00\\x00' and addr_pack[3] != '\\x00':\n            domain_mode = True\n        else:\n            ip = socket.inet_ntoa(addr_pack)\n            domain_mode = False\n\n        user_id = self.read_null_end_line()\n        if len(user_id):\n            xlog.debug(\"Socks4 user_id:%s\", user_id)\n\n        if domain_mode:\n            addr = self.read_null_end_line()\n        else:\n            addr = ip\n\n        reply = b\"\\x00\\x5a\" + addr_pack + struct.pack(\">H\", port)\n        sock.send(reply)\n\n        # xlog.debug(\"Socks4:%r to %s:%d\", self.client_address, addr, port)\n        handle_ip_proxy(sock, addr, port, self.client_address)\n\n    def socks5_handler(self):\n        sock = self.conn\n        socks_version = ord(self.read_bytes(1))\n        auth_mode_num = ord(self.read_bytes(1))\n        data = self.read_bytes(auth_mode_num)\n\n        sock.send(b\"\\x05\\x00\")  # socks version 5, no auth needed.\n        try:\n            data = self.read_bytes(4)\n        except Exception as e:\n            xlog.debug(\"socks5 auth num:%d, list:%s\", auth_mode_num, utils.str2hex(data))\n            xlog.warn(\"socks5 protocol error:%r\", e)\n            return\n\n        socks_version = ord(data[0])\n        if socks_version != 5:\n            xlog.warn(\"request version:%d error\", socks_version)\n            return\n\n        command = ord(data[1])\n        if command != 1:  # 1. Tcp connect\n            xlog.warn(\"request not supported command mode:%d\", command)\n            sock.send(b\"\\x05\\x07\\x00\\x01\")  # Command not supported\n            return\n\n        addrtype_pack = data[3]\n        addrtype = ord(addrtype_pack)\n        if addrtype == 1:  # IPv4\n            addr_pack = self.read_bytes(4)\n            addr = socket.inet_ntoa(addr_pack)\n        elif addrtype == 3:  # Domain name\n            domain_len_pack = self.read_bytes(1)[0]\n            domain_len = ord(domain_len_pack)\n            domain = self.read_bytes(domain_len)\n            addr_pack = domain_len_pack + domain\n            addr = domain\n        elif addrtype == 4:  # IPv6\n            addr_pack = self.read_bytes(16)\n            addr = socket.inet_ntop(socket.AF_INET6, addr_pack)\n        else:\n            xlog.warn(\"request address type unknown:%d\", addrtype)\n            sock.send(b\"\\x05\\x07\\x00\\x01\")  # Command not supported\n            return\n\n        port = struct.unpack('>H', self.rfile.read(2))[0]\n\n        # xlog.debug(\"socks5 %r connect to %s:%d\", self.client_address, addr, port)\n        reply = b\"\\x05\\x00\\x00\" + addrtype_pack + addr_pack + struct.pack(\">H\", port)\n        sock.send(reply)\n\n        if addrtype in [1, 4]:\n            handle_ip_proxy(sock, addr, port, self.client_address)\n        else:\n            handle_domain_proxy(sock, addr, port, self.client_address)\n\n    def https_handler(self):\n        line = self.read_crlf_line()\n        line = line.decode('iso-8859-1')\n        words = line.split()\n        if len(words) == 3:\n            command, path, version = words\n        elif len(words) == 2:\n            command, path = words\n            version = \"HTTP/1.1\"\n        else:\n            xlog.warn(\"https req line fail:%s\", line)\n            return\n\n        if command != \"CONNECT\":\n            xlog.warn(\"https req line fail:%s\", line)\n            return\n\n        host, _, port = path.rpartition(':')\n        host = host.encode()\n        port = int(port)\n\n        header_block = self.read_headers()\n        sock = self.conn\n\n        # xlog.debug(\"https %r connect to %s:%d\", self.client_address, host, port)\n        sock.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n')\n\n        handle_domain_proxy(sock, host, port, self.client_address)\n\n    def http_handler(self):\n        req_data = self.conn.recv(65537, socket.MSG_PEEK)\n        rp = req_data.split(\"\\r\\n\")\n        req_line = rp[0]\n\n        words = req_line.split()\n        if len(words) == 3:\n            method, url, http_version = words\n        elif len(words) == 2:\n            method, url = words\n            http_version = \"HTTP/1.1\"\n        else:\n            xlog.warn(\"http req line fail:%s\", req_line)\n            return\n\n        if url.lower().startswith(\"http://\"):\n            o = urlparse.urlparse(url)\n            host, port = netloc_to_host_port(o.netloc)\n\n            url_prex_len = url[7:].find(\"/\")\n            if url_prex_len >= 0:\n                url_prex_len += 7\n                path = url[url_prex_len:]\n            else:\n                url_prex_len = len(url)\n                path = \"/\"\n        else:\n            # not proxy request, should be PAC\n            xlog.debug(\"PAC %s %s from:%s\", method, url, self.client_address)\n            handler = pac_server.PacHandler(self.conn, self.client_address, None, xlog)\n            return handler.handle()\n\n        #req_d = self.conn.recv(len(req_line))\n        #req_d = req_d.replace(url, path)\n\n        sock = SocketWrap(self.conn, self.client_address[0], self.client_address[1])\n        sock.replace_pattern = [url[:url_prex_len], \"\"]\n\n        xlog.debug(\"http %r connect to %s:%d %s %s\", self.client_address, host, port, method, path)\n        handle_domain_proxy(sock, host, port, self.client_address)\n", "description": "a web proxy tool", "file_name": "proxy_handler.py", "id": "3959f30517d36f43662e44d89c5eab42", "language": "Python", "project_name": "XX-Net", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/XX-net-XX-Net/XX-net-XX-Net-673a005/code/default/smart_router/local/proxy_handler.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:03Z", "url": "https://github.com/XX-net/XX-Net", "wiki": true}