{"author": "keon", "code": "from unittest import TestCase\n\n\nclass HashTable(object):\n    \"\"\"\n    HashMap Data Type\n    HashMap() Create a new, empty map. It returns an empty map collection.\n    put(key, val) Add a new key-value pair to the map. If the key is already in the map then replace\n                    the old value with the new value.\n    get(key) Given a key, return the value stored in the map or None otherwise.\n    del_(key) or del map[key] Delete the key-value pair from the map using a statement of the form del map[key].\n    len() Return the number of key-value pairs stored in the map.\n    in Return True for a statement of the form key in map, if the given key is in the map, False otherwise.\n    \"\"\"\n\n    _empty = object()\n    _deleted = object()\n\n    def __init__(self, size=11):\n        self.size = size\n        self._len = 0\n        self._keys = [self._empty] * size  \n        self._values = [self._empty] * size  \n\n    def put(self, key, value):\n        initial_hash = hash_ = self.hash(key)\n\n        while True:\n            if self._keys[hash_] is self._empty or self._keys[hash_] is self._deleted:\n                \n                self._keys[hash_] = key\n                self._values[hash_] = value\n                self._len += 1\n                return\n            elif self._keys[hash_] == key:\n                \n                self._keys[hash_] = key\n                self._values[hash_] = value\n                return\n\n            hash_ = self._rehash(hash_)\n\n            if initial_hash == hash_:\n                \n                raise ValueError(\"Table is full\")\n\n    def get(self, key):\n        initial_hash = hash_ = self.hash(key)\n        while True:\n            if self._keys[hash_] is self._empty:\n                \n                return None\n            elif self._keys[hash_] == key:\n                \n                return self._values[hash_]\n\n            hash_ = self._rehash(hash_)\n            if initial_hash == hash_:\n                 and wrapped around\n                return None\n\n    def del_(self, key):\n        initial_hash = hash_ = self.hash(key)\n        while True:\n            if self._keys[hash_] is self._empty:\n                \n                return None\n            elif self._keys[hash_] == key:\n                , assign with deleted sentinel\n                self._keys[hash_] = self._deleted\n                self._values[hash_] = self._deleted\n                self._len -= 1\n                return\n\n            hash_ = self._rehash(hash_)\n            if initial_hash == hash_:\n                 and wrapped around\n                return None\n\n    def hash(self, key):\n        return key % self.size\n\n    def _rehash(self, old_hash):\n        \"\"\"\n        linear probing\n        \"\"\"\n        return (old_hash + 1) % self.size\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __delitem__(self, key):\n        return self.del_(key)\n\n    def __setitem__(self, key, value):\n        self.put(key, value)\n\n    def __len__(self):\n        return self._len\n\n\nclass ResizableHashTable(HashTable):\n    MIN_SIZE = 8\n\n    def __init__(self):\n        super().__init__(self.MIN_SIZE)\n\n    def put(self, key, value):\n        rv = super().put(key, value)\n        # increase size of dict * 2 if filled >= 2/3 size (like python dict)\n        if len(self) >= (self.size * 2) / 3:\n            self.__resize()\n\n    def __resize(self):\n        keys, values = self._keys, self._values\n        self.size *= 2  \n        self._len = 0\n        self._keys = [self._empty] * self.size\n        self._values = [self._empty] * self.size\n        for key, value in zip(keys, values):\n            if key is not self._empty and key is not self._deleted:\n                self.put(key, value)\n\n\nclass TestHashTable(TestCase):\n    def test_one_entry(self):\n        m = HashTable(10)\n        m.put(1, '1')\n        self.assertEqual('1', m.get(1))\n\n    def test_add_entry_bigger_than_table_size(self):\n        m = HashTable(10)\n        m.put(11, '1')\n        self.assertEqual('1', m.get(11))\n\n    def test_get_none_if_key_missing_and_hash_collision(self):\n        m = HashTable(10)\n        m.put(1, '1')\n        self.assertEqual(None, m.get(11))\n\n    def test_two_entries_with_same_hash(self):\n        m = HashTable(10)\n        m.put(1, '1')\n        m.put(11, '11')\n        self.assertEqual('1', m.get(1))\n        self.assertEqual('11', m.get(11))\n\n    def test_get_on_full_table_does_halts(self):\n        \n        m = HashTable(10)\n        for i in range(10, 20):\n            m.put(i, i)\n        self.assertEqual(None, m.get(1))\n\n    def test_delete_key(self):\n        m = HashTable(10)\n        m.put(1, 1)\n        m.del_(1)\n        self.assertEqual(None, m.get(1))\n\n    def test_delete_key_and_reassign(self):\n        m = HashTable(10)\n        m.put(1, 1)\n        del m[1]\n        m.put(1, 2)\n        self.assertEqual(2, m.get(1))\n\n    def test_assigning_to_full_table_throws_error(self):\n        m = HashTable(3)\n        m.put(1, 1)\n        m.put(2, 2)\n        m.put(3, 3)\n        with self.assertRaises(ValueError):\n            m.put(4, 4)\n\n    def test_len_trivial(self):\n        m = HashTable(10)\n        self.assertEqual(0, len(m))\n        for i in range(10):\n            m.put(i, i)\n            self.assertEqual(i + 1, len(m))\n\n    def test_len_after_deletions(self):\n        m = HashTable(10)\n        m.put(1, 1)\n        self.assertEqual(1, len(m))\n        m.del_(1)\n        self.assertEqual(0, len(m))\n        m.put(11, 42)\n        self.assertEqual(1, len(m))\n\n    def test_resizable_hash_table(self):\n        m = ResizableHashTable()\n        self.assertEqual(ResizableHashTable.MIN_SIZE, m.size)\n        for i in range(ResizableHashTable.MIN_SIZE):\n            m.put(i, 'foo')\n        self.assertEqual(ResizableHashTable.MIN_SIZE * 2, m.size)\n        self.assertEqual('foo', m.get(1))\n        self.assertEqual('foo', m.get(3))\n        self.assertEqual('foo', m.get(ResizableHashTable.MIN_SIZE - 1))\n", "comments": "        hashmap data type     hashmap() create new  empty map  it returns empty map collection      put(key  val) add new key value pair map  if key already map replace                     old value new value      get(key) given key  return value stored map none otherwise      del (key) del map key  delete key value pair map using statement form del map key       len() return number key value pairs stored map      return true statement form key map  given key map  false otherwise                empty   object()      deleted   object()      def   init  (self  size 11)          self size   size         self  len   0         self  keys    self  empty    size    keys         self  values    self  empty    size    values      def put(self  key  value)          initial hash   hash    self hash(key)          true              self  keys hash   self  empty self  keys hash   self  deleted                    assign hash  index                 self  keys hash     key                 self  values hash     value                 self  len    1                 return             elif self  keys hash      key                    key already exists  assign                 self  keys hash     key                 self  values hash     value                 return              hash    self  rehash(hash )              initial hash    hash                     table full                 raise valueerror( table full )      def get(self  key)          initial hash   hash    self hash(key)         true              self  keys hash   self  empty                    that key never assigned                 return none             elif self  keys hash      key                    key found                 return self  values hash                hash    self  rehash(hash )             initial hash    hash                     table full wrapped around                 return none      def del (self  key)          initial hash   hash    self hash(key)         true              self  keys hash   self  empty                    that key never assigned                 return none             elif self  keys hash      key                    key found  assign deleted sentinel                 self  keys hash     self  deleted                 self  values hash     self  deleted                 self  len    1                 return              hash    self  rehash(hash )             initial hash    hash                     table full wrapped around                 return none      def hash(self  key)          return key   self size      def  rehash(self  old hash)                      linear probing                keys    values    assign hash  index    key already exists  assign    table full    that key never assigned    key found    table full wrapped around    that key never assigned    key found  assign deleted sentinel    table full wrapped around    increase size dict   2 filled    2 3 size (like python dict)    new size    search forever ", "content": "from unittest import TestCase\n\n\nclass HashTable(object):\n    \"\"\"\n    HashMap Data Type\n    HashMap() Create a new, empty map. It returns an empty map collection.\n    put(key, val) Add a new key-value pair to the map. If the key is already in the map then replace\n                    the old value with the new value.\n    get(key) Given a key, return the value stored in the map or None otherwise.\n    del_(key) or del map[key] Delete the key-value pair from the map using a statement of the form del map[key].\n    len() Return the number of key-value pairs stored in the map.\n    in Return True for a statement of the form key in map, if the given key is in the map, False otherwise.\n    \"\"\"\n\n    _empty = object()\n    _deleted = object()\n\n    def __init__(self, size=11):\n        self.size = size\n        self._len = 0\n        self._keys = [self._empty] * size  # keys\n        self._values = [self._empty] * size  # values\n\n    def put(self, key, value):\n        initial_hash = hash_ = self.hash(key)\n\n        while True:\n            if self._keys[hash_] is self._empty or self._keys[hash_] is self._deleted:\n                # can assign to hash_ index\n                self._keys[hash_] = key\n                self._values[hash_] = value\n                self._len += 1\n                return\n            elif self._keys[hash_] == key:\n                # key already exists here, assign over\n                self._keys[hash_] = key\n                self._values[hash_] = value\n                return\n\n            hash_ = self._rehash(hash_)\n\n            if initial_hash == hash_:\n                # table is full\n                raise ValueError(\"Table is full\")\n\n    def get(self, key):\n        initial_hash = hash_ = self.hash(key)\n        while True:\n            if self._keys[hash_] is self._empty:\n                # That key was never assigned\n                return None\n            elif self._keys[hash_] == key:\n                # key found\n                return self._values[hash_]\n\n            hash_ = self._rehash(hash_)\n            if initial_hash == hash_:\n                # table is full and wrapped around\n                return None\n\n    def del_(self, key):\n        initial_hash = hash_ = self.hash(key)\n        while True:\n            if self._keys[hash_] is self._empty:\n                # That key was never assigned\n                return None\n            elif self._keys[hash_] == key:\n                # key found, assign with deleted sentinel\n                self._keys[hash_] = self._deleted\n                self._values[hash_] = self._deleted\n                self._len -= 1\n                return\n\n            hash_ = self._rehash(hash_)\n            if initial_hash == hash_:\n                # table is full and wrapped around\n                return None\n\n    def hash(self, key):\n        return key % self.size\n\n    def _rehash(self, old_hash):\n        \"\"\"\n        linear probing\n        \"\"\"\n        return (old_hash + 1) % self.size\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __delitem__(self, key):\n        return self.del_(key)\n\n    def __setitem__(self, key, value):\n        self.put(key, value)\n\n    def __len__(self):\n        return self._len\n\n\nclass ResizableHashTable(HashTable):\n    MIN_SIZE = 8\n\n    def __init__(self):\n        super().__init__(self.MIN_SIZE)\n\n    def put(self, key, value):\n        rv = super().put(key, value)\n        # increase size of dict * 2 if filled >= 2/3 size (like python dict)\n        if len(self) >= (self.size * 2) / 3:\n            self.__resize()\n\n    def __resize(self):\n        keys, values = self._keys, self._values\n        self.size *= 2  # this will be the new size\n        self._len = 0\n        self._keys = [self._empty] * self.size\n        self._values = [self._empty] * self.size\n        for key, value in zip(keys, values):\n            if key is not self._empty and key is not self._deleted:\n                self.put(key, value)\n\n\nclass TestHashTable(TestCase):\n    def test_one_entry(self):\n        m = HashTable(10)\n        m.put(1, '1')\n        self.assertEqual('1', m.get(1))\n\n    def test_add_entry_bigger_than_table_size(self):\n        m = HashTable(10)\n        m.put(11, '1')\n        self.assertEqual('1', m.get(11))\n\n    def test_get_none_if_key_missing_and_hash_collision(self):\n        m = HashTable(10)\n        m.put(1, '1')\n        self.assertEqual(None, m.get(11))\n\n    def test_two_entries_with_same_hash(self):\n        m = HashTable(10)\n        m.put(1, '1')\n        m.put(11, '11')\n        self.assertEqual('1', m.get(1))\n        self.assertEqual('11', m.get(11))\n\n    def test_get_on_full_table_does_halts(self):\n        # and does not search forever\n        m = HashTable(10)\n        for i in range(10, 20):\n            m.put(i, i)\n        self.assertEqual(None, m.get(1))\n\n    def test_delete_key(self):\n        m = HashTable(10)\n        m.put(1, 1)\n        m.del_(1)\n        self.assertEqual(None, m.get(1))\n\n    def test_delete_key_and_reassign(self):\n        m = HashTable(10)\n        m.put(1, 1)\n        del m[1]\n        m.put(1, 2)\n        self.assertEqual(2, m.get(1))\n\n    def test_assigning_to_full_table_throws_error(self):\n        m = HashTable(3)\n        m.put(1, 1)\n        m.put(2, 2)\n        m.put(3, 3)\n        with self.assertRaises(ValueError):\n            m.put(4, 4)\n\n    def test_len_trivial(self):\n        m = HashTable(10)\n        self.assertEqual(0, len(m))\n        for i in range(10):\n            m.put(i, i)\n            self.assertEqual(i + 1, len(m))\n\n    def test_len_after_deletions(self):\n        m = HashTable(10)\n        m.put(1, 1)\n        self.assertEqual(1, len(m))\n        m.del_(1)\n        self.assertEqual(0, len(m))\n        m.put(11, 42)\n        self.assertEqual(1, len(m))\n\n    def test_resizable_hash_table(self):\n        m = ResizableHashTable()\n        self.assertEqual(ResizableHashTable.MIN_SIZE, m.size)\n        for i in range(ResizableHashTable.MIN_SIZE):\n            m.put(i, 'foo')\n        self.assertEqual(ResizableHashTable.MIN_SIZE * 2, m.size)\n        self.assertEqual('foo', m.get(1))\n        self.assertEqual('foo', m.get(3))\n        self.assertEqual('foo', m.get(ResizableHashTable.MIN_SIZE - 1))\n", "description": "Minimal examples of data structures and algorithms in Python", "file_name": "hashtable.py", "id": "ed01e6b1f74388ce7e349749f8016277", "language": "Python", "project_name": "algorithms", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/keon-algorithms/keon-algorithms-ea43887/map/hashtable.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:53:29Z", "url": "https://github.com/keon/algorithms", "wiki": true}