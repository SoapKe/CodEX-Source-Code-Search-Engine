{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nimport re\nimport uuid\n\nfrom werkzeug import urls\n\nfrom odoo import api, fields, models, _\nfrom odoo.exceptions import UserError\nfrom odoo.tools import pycompat\n\nemails_split = re.compile(r\"[;,\\n\\r]+\")\nemail_validator = re.compile(r\"[^@]+@[^@]+\\.[^@]+\")\n\nclass SurveyMailComposeMessage(models.TransientModel):\n    _name = 'survey.mail.compose.message'\n    _inherit = 'mail.compose.message'\n    _description = 'Email composition wizard for Survey'\n\n    def default_survey_id(self):\n        context = self.env.context\n        if context.get('model') == 'survey.survey':\n            return context.get('res_id')\n\n    survey_id = fields.Many2one('survey.survey', string='Survey', default=default_survey_id, required=True)\n    public = fields.Selection([('public_link', 'Share the public web link to your audience.'),\n                                ('email_public_link', 'Send by email the public web link to your audience.'),\n                                ('email_private', 'Send private invitation to your audience (only one response per recipient and per invitation).')],\n                                string='Share options', default='public_link', required=True)\n    public_url = fields.Char(compute=\"_compute_survey_url\", string=\"Public url\")\n    public_url_html = fields.Char(compute=\"_compute_survey_url\", string=\"Public HTML web link\")\n    partner_ids = fields.Many2many('res.partner', 'survey_mail_compose_message_res_partner_rel', 'wizard_id', 'partner_id', string='Existing contacts')\n    attachment_ids = fields.Many2many('ir.attachment', 'survey_mail_compose_message_ir_attachments_rel', 'wizard_id', 'attachment_id', string='Attachments')\n    multi_email = fields.Text(string='List of emails', help=\"This list of emails of recipients will not be converted in contacts.\\\n        Emails must be separated by commas, semicolons or newline.\")\n    date_deadline = fields.Date(string=\"Deadline to which the invitation to respond is valid\",\n        help=\"Deadline to which the invitation to respond for this survey is valid. If the field is empty,\\\n        the invitation is still valid.\")\n\n    @api.depends('survey_id')\n    def _compute_survey_url(self):\n        for wizard in self:\n            wizard.public_url = wizard.survey_id.public_url\n            wizard.public_url_html = wizard.survey_id.public_url_html\n\n    @api.model\n    def default_get(self, fields):\n        res = super(SurveyMailComposeMessage, self).default_get(fields)\n        context = self.env.context\n        if context.get('active_model') == 'res.partner' and context.get('active_ids'):\n            res.update({'partner_ids': context['active_ids']})\n        return res\n\n    @api.onchange('multi_email')\n    def onchange_multi_email(self):\n        emails = list(set(emails_split.split(self.multi_email or \"\")))\n        emails_checked = []\n        error_message = \"\"\n        for email in emails:\n            email = email.strip()\n            if email:\n                if not email_validator.match(email):\n                    error_message += \"\\n'%s'\" % email\n                else:\n                    emails_checked.append(email)\n        if error_message:\n            raise UserError(_(\"Incorrect Email Address: %s\") % error_message)\n\n        emails_checked.sort()\n        self.multi_email = '\\n'.join(emails_checked)\n\n    \n    \n    \n    @api.multi\n    def send_mail(self, auto_commit=False):\n        \"\"\" Process the wizard content and proceed with sending the related\n            email(s), rendering any template patterns on the fly if needed \"\"\"\n\n        SurveyUserInput = self.env['survey.user_input']\n        Partner = self.env['res.partner']\n        Mail = self.env['mail.mail']\n\n        def create_response_and_send_mail(wizard, token, partner_id, email):\n            \"\"\" Create one mail by recipients and replace __URL__ by link with identification token \"\"\"\n            \n            url = wizard.survey_id.public_url\n\n            url = urls.url_parse(url).path[1:]  \n\n            if token:\n                url = url + '/' + token\n\n            \n            values = {\n                'model': None,\n                'res_id': None,\n                'subject': wizard.subject,\n                'body': wizard.body.replace(\"__URL__\", url),\n                'body_html': wizard.body.replace(\"__URL__\", url),\n                'parent_id': None,\n                'attachment_ids': wizard.attachment_ids and [(6, 0, wizard.attachment_ids.ids)] or None,\n                'email_from': wizard.email_from or None,\n                'auto_delete': True,\n            }\n            if partner_id:\n                values['recipient_ids'] = [(4, partner_id)]\n            else:\n                values['email_to'] = email\n            Mail.create(values).send()\n\n        def create_token(wizard, partner_id, email):\n            if context.get(\"survey_resent_token\"):\n                survey_user_input = SurveyUserInput.search([('survey_id', '=', wizard.survey_id.id),\n                    ('state', 'in', ['new', 'skip']), '|', ('partner_id', '=', partner_id),\n                    ('email', '=', email)], limit=1)\n                if survey_user_input:\n                    return survey_user_input.token\n            if wizard.public != 'email_private':\n                return None\n            else:\n                token = pycompat.text_type(uuid.uuid4())\n                \n                survey_user_input = SurveyUserInput.create({\n                    'survey_id': wizard.survey_id.id,\n                    'deadline': wizard.date_deadline,\n                    'date_create': fields.Datetime.now(),\n                    'type': 'link',\n                    'state': 'new',\n                    'token': token,\n                    'partner_id': partner_id,\n                    'email': email})\n                return survey_user_input.token\n\n        for wizard in self:\n            \n            if wizard.body.find(\"__URL__\") < 0:\n                raise UserError(_(\"The content of the text don't contain '__URL__'. \\\n                    __URL__ is automaticaly converted into the special url of the survey.\"))\n\n            context = self.env.context\n            if not wizard.multi_email and not wizard.partner_ids and (context.get('default_partner_ids') or context.get('default_multi_email')):\n                wizard.multi_email = context.get('default_multi_email')\n                wizard.partner_ids = context.get('default_partner_ids')\n\n            \n            emails_list = []\n            if wizard.multi_email:\n                emails = set(emails_split.split(wizard.multi_email)) - set(wizard.partner_ids.mapped('email'))\n                for email in emails:\n                    email = email.strip()\n                    if email_validator.match(email):\n                        emails_list.append(email)\n\n            \n            partner_list = []\n            for partner in wizard.partner_ids:\n                partner_list.append({'id': partner.id, 'email': partner.email})\n\n            if not len(emails_list) and not len(partner_list):\n                if wizard.model == 'res.partner' and wizard.res_id:\n                    return False\n                raise UserError(_(\"Please enter at least one valid recipient.\"))\n\n            for email in emails_list:\n                partner = Partner.search([('email', '=', email)], limit=1)\n                token = create_token(wizard, partner.id, email)\n                create_response_and_send_mail(wizard, token, partner.id, email)\n\n            for partner in partner_list:\n                token = create_token(wizard, partner['id'], partner['email'])\n                create_response_and_send_mail(wizard, token, partner['id'], partner['email'])\n\n        return {'type': 'ir.actions.act_window_close'}\n", "comments": "    process wizard content proceed sending related             email(s)  rendering template patterns fly needed              surveyuserinput   self env  survey user input           partner   self env  res partner           mail   self env  mail mail            def create response send mail(wizard  token  partner id  email)                  create one mail recipients replace   url   link identification token            coding  utf 8        part odoo  see license file full copyright licensing details                                                              wizard validation send                                                            set url    dirty hack avoid incorrect urls    post message    create response token    check   url   text    quick check email list    remove public anonymous access ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nimport re\nimport uuid\n\nfrom werkzeug import urls\n\nfrom odoo import api, fields, models, _\nfrom odoo.exceptions import UserError\nfrom odoo.tools import pycompat\n\nemails_split = re.compile(r\"[;,\\n\\r]+\")\nemail_validator = re.compile(r\"[^@]+@[^@]+\\.[^@]+\")\n\nclass SurveyMailComposeMessage(models.TransientModel):\n    _name = 'survey.mail.compose.message'\n    _inherit = 'mail.compose.message'\n    _description = 'Email composition wizard for Survey'\n\n    def default_survey_id(self):\n        context = self.env.context\n        if context.get('model') == 'survey.survey':\n            return context.get('res_id')\n\n    survey_id = fields.Many2one('survey.survey', string='Survey', default=default_survey_id, required=True)\n    public = fields.Selection([('public_link', 'Share the public web link to your audience.'),\n                                ('email_public_link', 'Send by email the public web link to your audience.'),\n                                ('email_private', 'Send private invitation to your audience (only one response per recipient and per invitation).')],\n                                string='Share options', default='public_link', required=True)\n    public_url = fields.Char(compute=\"_compute_survey_url\", string=\"Public url\")\n    public_url_html = fields.Char(compute=\"_compute_survey_url\", string=\"Public HTML web link\")\n    partner_ids = fields.Many2many('res.partner', 'survey_mail_compose_message_res_partner_rel', 'wizard_id', 'partner_id', string='Existing contacts')\n    attachment_ids = fields.Many2many('ir.attachment', 'survey_mail_compose_message_ir_attachments_rel', 'wizard_id', 'attachment_id', string='Attachments')\n    multi_email = fields.Text(string='List of emails', help=\"This list of emails of recipients will not be converted in contacts.\\\n        Emails must be separated by commas, semicolons or newline.\")\n    date_deadline = fields.Date(string=\"Deadline to which the invitation to respond is valid\",\n        help=\"Deadline to which the invitation to respond for this survey is valid. If the field is empty,\\\n        the invitation is still valid.\")\n\n    @api.depends('survey_id')\n    def _compute_survey_url(self):\n        for wizard in self:\n            wizard.public_url = wizard.survey_id.public_url\n            wizard.public_url_html = wizard.survey_id.public_url_html\n\n    @api.model\n    def default_get(self, fields):\n        res = super(SurveyMailComposeMessage, self).default_get(fields)\n        context = self.env.context\n        if context.get('active_model') == 'res.partner' and context.get('active_ids'):\n            res.update({'partner_ids': context['active_ids']})\n        return res\n\n    @api.onchange('multi_email')\n    def onchange_multi_email(self):\n        emails = list(set(emails_split.split(self.multi_email or \"\")))\n        emails_checked = []\n        error_message = \"\"\n        for email in emails:\n            email = email.strip()\n            if email:\n                if not email_validator.match(email):\n                    error_message += \"\\n'%s'\" % email\n                else:\n                    emails_checked.append(email)\n        if error_message:\n            raise UserError(_(\"Incorrect Email Address: %s\") % error_message)\n\n        emails_checked.sort()\n        self.multi_email = '\\n'.join(emails_checked)\n\n    #------------------------------------------------------\n    # Wizard validation and send\n    #------------------------------------------------------\n    @api.multi\n    def send_mail(self, auto_commit=False):\n        \"\"\" Process the wizard content and proceed with sending the related\n            email(s), rendering any template patterns on the fly if needed \"\"\"\n\n        SurveyUserInput = self.env['survey.user_input']\n        Partner = self.env['res.partner']\n        Mail = self.env['mail.mail']\n\n        def create_response_and_send_mail(wizard, token, partner_id, email):\n            \"\"\" Create one mail by recipients and replace __URL__ by link with identification token \"\"\"\n            #set url\n            url = wizard.survey_id.public_url\n\n            url = urls.url_parse(url).path[1:]  # dirty hack to avoid incorrect urls\n\n            if token:\n                url = url + '/' + token\n\n            # post the message\n            values = {\n                'model': None,\n                'res_id': None,\n                'subject': wizard.subject,\n                'body': wizard.body.replace(\"__URL__\", url),\n                'body_html': wizard.body.replace(\"__URL__\", url),\n                'parent_id': None,\n                'attachment_ids': wizard.attachment_ids and [(6, 0, wizard.attachment_ids.ids)] or None,\n                'email_from': wizard.email_from or None,\n                'auto_delete': True,\n            }\n            if partner_id:\n                values['recipient_ids'] = [(4, partner_id)]\n            else:\n                values['email_to'] = email\n            Mail.create(values).send()\n\n        def create_token(wizard, partner_id, email):\n            if context.get(\"survey_resent_token\"):\n                survey_user_input = SurveyUserInput.search([('survey_id', '=', wizard.survey_id.id),\n                    ('state', 'in', ['new', 'skip']), '|', ('partner_id', '=', partner_id),\n                    ('email', '=', email)], limit=1)\n                if survey_user_input:\n                    return survey_user_input.token\n            if wizard.public != 'email_private':\n                return None\n            else:\n                token = pycompat.text_type(uuid.uuid4())\n                # create response with token\n                survey_user_input = SurveyUserInput.create({\n                    'survey_id': wizard.survey_id.id,\n                    'deadline': wizard.date_deadline,\n                    'date_create': fields.Datetime.now(),\n                    'type': 'link',\n                    'state': 'new',\n                    'token': token,\n                    'partner_id': partner_id,\n                    'email': email})\n                return survey_user_input.token\n\n        for wizard in self:\n            # check if __URL__ is in the text\n            if wizard.body.find(\"__URL__\") < 0:\n                raise UserError(_(\"The content of the text don't contain '__URL__'. \\\n                    __URL__ is automaticaly converted into the special url of the survey.\"))\n\n            context = self.env.context\n            if not wizard.multi_email and not wizard.partner_ids and (context.get('default_partner_ids') or context.get('default_multi_email')):\n                wizard.multi_email = context.get('default_multi_email')\n                wizard.partner_ids = context.get('default_partner_ids')\n\n            # quick check of email list\n            emails_list = []\n            if wizard.multi_email:\n                emails = set(emails_split.split(wizard.multi_email)) - set(wizard.partner_ids.mapped('email'))\n                for email in emails:\n                    email = email.strip()\n                    if email_validator.match(email):\n                        emails_list.append(email)\n\n            # remove public anonymous access\n            partner_list = []\n            for partner in wizard.partner_ids:\n                partner_list.append({'id': partner.id, 'email': partner.email})\n\n            if not len(emails_list) and not len(partner_list):\n                if wizard.model == 'res.partner' and wizard.res_id:\n                    return False\n                raise UserError(_(\"Please enter at least one valid recipient.\"))\n\n            for email in emails_list:\n                partner = Partner.search([('email', '=', email)], limit=1)\n                token = create_token(wizard, partner.id, email)\n                create_response_and_send_mail(wizard, token, partner.id, email)\n\n            for partner in partner_list:\n                token = create_token(wizard, partner['id'], partner['email'])\n                create_response_and_send_mail(wizard, token, partner['id'], partner['email'])\n\n        return {'type': 'ir.actions.act_window_close'}\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "survey_email_compose_message.py", "id": "41cc0e664c49deee35dfd0a73b1ee9da", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/survey/wizard/survey_email_compose_message.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}