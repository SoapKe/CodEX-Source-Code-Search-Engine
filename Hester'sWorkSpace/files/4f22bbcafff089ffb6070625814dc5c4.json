{"author": "keon", "code": "\nclass Graph:\n    def __init__(self, vertices):\n        \n        self.V = vertices\n\n        \n        self.graph = {}\n\n        \n        self.tc = [[0 for j in range(self.V)] for i in range(self.V)]\n\n    \n    def add_edge(self, u, v):\n        if u in self.graph:\n            self.graph[u].append(v)\n        else:\n            self.graph[u] = [v]\n\n    \n    \n    def dfs_util(self, s, v):\n\n        \n        self.tc[s][v] = 1\n\n        \n        for i in self.graph[v]:\n            if self.tc[s][i] == 0:\n                self.dfs_util(s, i)\n\n    \n    ()\n    def transitive_closure(self):\n\n        \n        \n        for i in range(self.V):\n            self.dfs_util(i, i)\n        print(self.tc)\n\n\ng = Graph(4)\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 2)\ng.add_edge(2, 0)\ng.add_edge(2, 3)\ng.add_edge(3, 3)\n\nprint(\"Transitive closure matrix is\")\ng.transitive_closure()\n", "comments": "  this class represents directed graph using adjacency    no  vertices    default dictionary store graph    to store transitive closure    function add edge graph    a recursive dfs traversal function finds    reachable vertices    mark reachability v true     find vertices reachable v    the function find transitive closure  it uses    recursive dfs util()    call recursive helper function print dfs    traversal starting vertices one one ", "content": "# This class represents a directed graph using adjacency\nclass Graph:\n    def __init__(self, vertices):\n        # No. of vertices\n        self.V = vertices\n\n        # default dictionary to store graph\n        self.graph = {}\n\n        # To store transitive closure\n        self.tc = [[0 for j in range(self.V)] for i in range(self.V)]\n\n    # function to add an edge to graph\n    def add_edge(self, u, v):\n        if u in self.graph:\n            self.graph[u].append(v)\n        else:\n            self.graph[u] = [v]\n\n    # A recursive DFS traversal function that finds\n    # all reachable vertices for s\n    def dfs_util(self, s, v):\n\n        # Mark reachability from s to v as true.\n        self.tc[s][v] = 1\n\n        # Find all the vertices reachable through v\n        for i in self.graph[v]:\n            if self.tc[s][i] == 0:\n                self.dfs_util(s, i)\n\n    # The function to find transitive closure. It uses\n    # recursive dfs_util()\n    def transitive_closure(self):\n\n        # Call the recursive helper function to print DFS\n        # traversal starting from all vertices one by one\n        for i in range(self.V):\n            self.dfs_util(i, i)\n        print(self.tc)\n\n\ng = Graph(4)\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 2)\ng.add_edge(2, 0)\ng.add_edge(2, 3)\ng.add_edge(3, 3)\n\nprint(\"Transitive closure matrix is\")\ng.transitive_closure()\n", "description": "Minimal examples of data structures and algorithms in Python", "file_name": "Transitive_Closure_DFS.py", "id": "4f22bbcafff089ffb6070625814dc5c4", "language": "Python", "project_name": "algorithms", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/keon-algorithms/keon-algorithms-ea43887/graph/Transitive_Closure_DFS.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:53:29Z", "url": "https://github.com/keon/algorithms", "wiki": true}