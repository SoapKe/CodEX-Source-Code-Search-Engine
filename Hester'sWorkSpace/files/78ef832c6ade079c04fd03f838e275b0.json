{"author": "nvbn", "code": "import pytest\nimport json\nfrom six import StringIO\nfrom mock import MagicMock\nfrom thefuck.shells.generic import ShellConfiguration\nfrom thefuck.entrypoints.not_configured import main\n\n\n@pytest.fixture(autouse=True)\ndef usage_tracker(mocker):\n    return mocker.patch(\n        'thefuck.entrypoints.not_configured._get_not_configured_usage_tracker_path',\n        new_callable=MagicMock)\n\n\n@pytest.fixture(autouse=True)\ndef usage_tracker_io(usage_tracker):\n    io = StringIO()\n    usage_tracker.return_value \\\n                 .open.return_value \\\n                 .__enter__.return_value = io\n    return io\n\n\n@pytest.fixture(autouse=True)\ndef usage_tracker_exists(usage_tracker):\n    usage_tracker.return_value \\\n                 .exists.return_value = True\n    return usage_tracker.return_value.exists\n\n\ndef _assert_tracker_updated(usage_tracker_io, pid):\n    usage_tracker_io.seek(0)\n    info = json.load(usage_tracker_io)\n    assert info['pid'] == pid\n\n\ndef _change_tracker(usage_tracker_io, pid):\n    usage_tracker_io.truncate(0)\n    info = {'pid': pid, 'time': 0}\n    json.dump(info, usage_tracker_io)\n    usage_tracker_io.seek(0)\n\n\n@pytest.fixture(autouse=True)\ndef shell_pid(mocker):\n    return mocker.patch('thefuck.entrypoints.not_configured._get_shell_pid',\n                        new_callable=MagicMock)\n\n\n@pytest.fixture(autouse=True)\ndef shell(mocker):\n    shell = mocker.patch('thefuck.entrypoints.not_configured.shell',\n                         new_callable=MagicMock)\n    shell.get_history.return_value = []\n    shell.how_to_configure.return_value = ShellConfiguration(\n        content='eval $(thefuck --alias)',\n        path='/tmp/.bashrc',\n        reload='bash',\n        can_configure_automatically=True)\n    return shell\n\n\n@pytest.fixture(autouse=True)\ndef shell_config(mocker):\n    path_mock = mocker.patch('thefuck.entrypoints.not_configured.Path',\n                             new_callable=MagicMock)\n    return path_mock.return_value \\\n        .expanduser.return_value \\\n        .open.return_value \\\n        .__enter__.return_value\n\n\n@pytest.fixture(autouse=True)\ndef logs(mocker):\n    return mocker.patch('thefuck.entrypoints.not_configured.logs',\n                        new_callable=MagicMock)\n\n\ndef test_for_generic_shell(shell, logs):\n    shell.how_to_configure.return_value = None\n    main()\n    logs.how_to_configure_alias.assert_called_once()\n\n\ndef test_on_first_run(usage_tracker_io, usage_tracker_exists, shell_pid, logs):\n    shell_pid.return_value = 12\n    main()\n    usage_tracker_exists.return_value = False\n    _assert_tracker_updated(usage_tracker_io, 12)\n    logs.how_to_configure_alias.assert_called_once()\n\n\ndef test_on_run_after_other_commands(usage_tracker_io, shell_pid, shell, logs):\n    shell_pid.return_value = 12\n    shell.get_history.return_value = ['fuck', 'ls']\n    _change_tracker(usage_tracker_io, 12)\n    main()\n    logs.how_to_configure_alias.assert_called_once()\n\n\ndef test_on_first_run_from_current_shell(usage_tracker_io, shell_pid,\n                                         shell, logs):\n    shell.get_history.return_value = ['fuck']\n    shell_pid.return_value = 12\n    main()\n    _assert_tracker_updated(usage_tracker_io, 12)\n    logs.how_to_configure_alias.assert_called_once()\n\n\ndef test_when_cant_configure_automatically(shell_pid, shell, logs):\n    shell_pid.return_value = 12\n    shell.how_to_configure.return_value = ShellConfiguration(\n        content='eval $(thefuck --alias)',\n        path='/tmp/.bashrc',\n        reload='bash',\n        can_configure_automatically=False)\n    main()\n    logs.how_to_configure_alias.assert_called_once()\n\n\ndef test_when_already_configured(usage_tracker_io, shell_pid,\n                                 shell, shell_config, logs):\n    shell.get_history.return_value = ['fuck']\n    shell_pid.return_value = 12\n    _change_tracker(usage_tracker_io, 12)\n    shell_config.read.return_value = 'eval $(thefuck --alias)'\n    main()\n    logs.already_configured.assert_called_once()\n\n\ndef test_when_successfully_configured(usage_tracker_io, shell_pid,\n                                      shell, shell_config, logs):\n    shell.get_history.return_value = ['fuck']\n    shell_pid.return_value = 12\n    _change_tracker(usage_tracker_io, 12)\n    shell_config.read.return_value = ''\n    main()\n    shell_config.write.assert_any_call('eval $(thefuck --alias)')\n    logs.configured_successfully.assert_called_once()\n", "comments": "", "content": "import pytest\nimport json\nfrom six import StringIO\nfrom mock import MagicMock\nfrom thefuck.shells.generic import ShellConfiguration\nfrom thefuck.entrypoints.not_configured import main\n\n\n@pytest.fixture(autouse=True)\ndef usage_tracker(mocker):\n    return mocker.patch(\n        'thefuck.entrypoints.not_configured._get_not_configured_usage_tracker_path',\n        new_callable=MagicMock)\n\n\n@pytest.fixture(autouse=True)\ndef usage_tracker_io(usage_tracker):\n    io = StringIO()\n    usage_tracker.return_value \\\n                 .open.return_value \\\n                 .__enter__.return_value = io\n    return io\n\n\n@pytest.fixture(autouse=True)\ndef usage_tracker_exists(usage_tracker):\n    usage_tracker.return_value \\\n                 .exists.return_value = True\n    return usage_tracker.return_value.exists\n\n\ndef _assert_tracker_updated(usage_tracker_io, pid):\n    usage_tracker_io.seek(0)\n    info = json.load(usage_tracker_io)\n    assert info['pid'] == pid\n\n\ndef _change_tracker(usage_tracker_io, pid):\n    usage_tracker_io.truncate(0)\n    info = {'pid': pid, 'time': 0}\n    json.dump(info, usage_tracker_io)\n    usage_tracker_io.seek(0)\n\n\n@pytest.fixture(autouse=True)\ndef shell_pid(mocker):\n    return mocker.patch('thefuck.entrypoints.not_configured._get_shell_pid',\n                        new_callable=MagicMock)\n\n\n@pytest.fixture(autouse=True)\ndef shell(mocker):\n    shell = mocker.patch('thefuck.entrypoints.not_configured.shell',\n                         new_callable=MagicMock)\n    shell.get_history.return_value = []\n    shell.how_to_configure.return_value = ShellConfiguration(\n        content='eval $(thefuck --alias)',\n        path='/tmp/.bashrc',\n        reload='bash',\n        can_configure_automatically=True)\n    return shell\n\n\n@pytest.fixture(autouse=True)\ndef shell_config(mocker):\n    path_mock = mocker.patch('thefuck.entrypoints.not_configured.Path',\n                             new_callable=MagicMock)\n    return path_mock.return_value \\\n        .expanduser.return_value \\\n        .open.return_value \\\n        .__enter__.return_value\n\n\n@pytest.fixture(autouse=True)\ndef logs(mocker):\n    return mocker.patch('thefuck.entrypoints.not_configured.logs',\n                        new_callable=MagicMock)\n\n\ndef test_for_generic_shell(shell, logs):\n    shell.how_to_configure.return_value = None\n    main()\n    logs.how_to_configure_alias.assert_called_once()\n\n\ndef test_on_first_run(usage_tracker_io, usage_tracker_exists, shell_pid, logs):\n    shell_pid.return_value = 12\n    main()\n    usage_tracker_exists.return_value = False\n    _assert_tracker_updated(usage_tracker_io, 12)\n    logs.how_to_configure_alias.assert_called_once()\n\n\ndef test_on_run_after_other_commands(usage_tracker_io, shell_pid, shell, logs):\n    shell_pid.return_value = 12\n    shell.get_history.return_value = ['fuck', 'ls']\n    _change_tracker(usage_tracker_io, 12)\n    main()\n    logs.how_to_configure_alias.assert_called_once()\n\n\ndef test_on_first_run_from_current_shell(usage_tracker_io, shell_pid,\n                                         shell, logs):\n    shell.get_history.return_value = ['fuck']\n    shell_pid.return_value = 12\n    main()\n    _assert_tracker_updated(usage_tracker_io, 12)\n    logs.how_to_configure_alias.assert_called_once()\n\n\ndef test_when_cant_configure_automatically(shell_pid, shell, logs):\n    shell_pid.return_value = 12\n    shell.how_to_configure.return_value = ShellConfiguration(\n        content='eval $(thefuck --alias)',\n        path='/tmp/.bashrc',\n        reload='bash',\n        can_configure_automatically=False)\n    main()\n    logs.how_to_configure_alias.assert_called_once()\n\n\ndef test_when_already_configured(usage_tracker_io, shell_pid,\n                                 shell, shell_config, logs):\n    shell.get_history.return_value = ['fuck']\n    shell_pid.return_value = 12\n    _change_tracker(usage_tracker_io, 12)\n    shell_config.read.return_value = 'eval $(thefuck --alias)'\n    main()\n    logs.already_configured.assert_called_once()\n\n\ndef test_when_successfully_configured(usage_tracker_io, shell_pid,\n                                      shell, shell_config, logs):\n    shell.get_history.return_value = ['fuck']\n    shell_pid.return_value = 12\n    _change_tracker(usage_tracker_io, 12)\n    shell_config.read.return_value = ''\n    main()\n    shell_config.write.assert_any_call('eval $(thefuck --alias)')\n    logs.configured_successfully.assert_called_once()\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "test_not_configured.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/tests/entrypoints/test_not_configured.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}