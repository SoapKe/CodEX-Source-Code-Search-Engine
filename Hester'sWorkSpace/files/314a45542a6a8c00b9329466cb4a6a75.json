{"author": "p-e-w", "code": "\n\n Copyright (c) 2016-2017 Philipp Emanuel Weidmann <pew@worldwidemann.com>\n\n Nemo vir est qui mundum non reddat meliorem.\n\n Released under the terms of the GNU General Public License, version 3\n (https://gnu.org/licenses/gpl.html)\n\n\nfrom os.path import exists\nfrom os import O_WRONLY, O_RDWR, O_APPEND, O_CREAT, O_TRUNC\nfrom stat import S_IFCHR, S_IFBLK, S_IFIFO, S_IFSOCK\n\nfrom maybe import T, register_filter\n\n\nallowed_files = set([\"/dev/null\", \"/dev/zero\", \"/dev/tty\"])\n\n\ndef filter_open(process, path, flags):\n    if path in allowed_files:\n        return None, None\n    if (flags & O_CREAT) and not exists(path):\n        operation = \"%s %s\" % (T.cyan(\"create file\"), T.underline(path))\n    elif (flags & O_TRUNC) and exists(path):\n        operation = \"%s %s\" % (T.red(\"truncate file\"), T.underline(path))\n    else:\n        operation = None\n    if (flags & O_WRONLY) or (flags & O_RDWR) or (flags & O_APPEND) or (operation is not None):\n         File might be written to later, so we need to track the file descriptor\n        return_value = process.register_path(path)\n    else:\n        return_value = None\n    return operation, return_value\n\n\ndef filter_mknod(path, type):\n    if exists(path):\n        return None, None\n    elif (type & S_IFCHR):\n        label = \"create character special file\"\n    elif (type & S_IFBLK):\n        label = \"create block special file\"\n    elif (type & S_IFIFO):\n        label = \"create named pipe\"\n    elif (type & S_IFSOCK):\n        label = \"create socket\"\n    else:\n         mknod(2): \"Zero file type is equivalent to type S_IFREG\"\n        label = \"create file\"\n    return \"%s %s\" % (T.cyan(label), T.underline(path)), 0\n\n\ndef filter_write(process, file_descriptor, byte_count):\n    if process.is_tracked_descriptor(file_descriptor):\n        path = process.descriptor_path(file_descriptor)\n        return \"%s %s to %s\" % (T.red(\"write\"), T.bold(\"%d bytes\" % byte_count), T.underline(path)), byte_count\n    else:\n        return None, None\n\n\ndef filter_dup(process, file_descriptor_old, file_descriptor_new=None):\n    if process.is_tracked_descriptor(file_descriptor_old):\n         Copy tracked file descriptor\n        return None, process.register_path(process.descriptor_path(file_descriptor_old), file_descriptor_new)\n    else:\n        return None, None\n\n\nregister_filter(\"open\", lambda process, args:\n                filter_open(process, process.full_path(args[0]), args[1]))\nregister_filter(\"creat\", lambda process, args:\n                filter_open(process, process.full_path(args[0]), O_CREAT | O_WRONLY | O_TRUNC))\nregister_filter(\"openat\", lambda process, args:\n                filter_open(process, process.full_path(args[1], args[0]), args[2]))\nregister_filter(\"mknod\", lambda process, args:\n                filter_mknod(process.full_path(args[0]), args[1]))\nregister_filter(\"mknodat\", lambda process, args:\n                filter_mknod(process.full_path(args[1], args[0]), args[2]))\nregister_filter(\"write\", lambda process, args: filter_write(process, args[0], args[2]))\nregister_filter(\"pwrite\", lambda process, args: filter_write(process, args[0], args[2]))\n TODO: Actual byte count is iovcnt * iov.iov_len\nregister_filter(\"writev\", lambda process, args: filter_write(process, args[0], args[2]))\nregister_filter(\"pwritev\", lambda process, args: filter_write(process, args[0], args[2]))\nregister_filter(\"dup\", lambda process, args: filter_dup(process, args[0]))\nregister_filter(\"dup2\", lambda process, args: filter_dup(process, args[0], args[1]))\nregister_filter(\"dup3\", lambda process, args: filter_dup(process, args[0], args[1]))\n", "comments": "  maybe   see program deciding whether really want happen       copyright (c) 2016 2017 philipp emanuel weidmann  pew worldwidemann com        nemo vir est qui mundum non reddat meliorem        released terms gnu general public license  version 3    (https   gnu org licenses gpl html)    file might written later  need track file descriptor    mknod(2)   zero file type equivalent type s ifreg     copy tracked file descriptor    todo  actual byte count iovcnt   iov iov len ", "content": "# maybe - see what a program does before deciding whether you really want it to happen\n#\n# Copyright (c) 2016-2017 Philipp Emanuel Weidmann <pew@worldwidemann.com>\n#\n# Nemo vir est qui mundum non reddat meliorem.\n#\n# Released under the terms of the GNU General Public License, version 3\n# (https://gnu.org/licenses/gpl.html)\n\n\nfrom os.path import exists\nfrom os import O_WRONLY, O_RDWR, O_APPEND, O_CREAT, O_TRUNC\nfrom stat import S_IFCHR, S_IFBLK, S_IFIFO, S_IFSOCK\n\nfrom maybe import T, register_filter\n\n\nallowed_files = set([\"/dev/null\", \"/dev/zero\", \"/dev/tty\"])\n\n\ndef filter_open(process, path, flags):\n    if path in allowed_files:\n        return None, None\n    if (flags & O_CREAT) and not exists(path):\n        operation = \"%s %s\" % (T.cyan(\"create file\"), T.underline(path))\n    elif (flags & O_TRUNC) and exists(path):\n        operation = \"%s %s\" % (T.red(\"truncate file\"), T.underline(path))\n    else:\n        operation = None\n    if (flags & O_WRONLY) or (flags & O_RDWR) or (flags & O_APPEND) or (operation is not None):\n        # File might be written to later, so we need to track the file descriptor\n        return_value = process.register_path(path)\n    else:\n        return_value = None\n    return operation, return_value\n\n\ndef filter_mknod(path, type):\n    if exists(path):\n        return None, None\n    elif (type & S_IFCHR):\n        label = \"create character special file\"\n    elif (type & S_IFBLK):\n        label = \"create block special file\"\n    elif (type & S_IFIFO):\n        label = \"create named pipe\"\n    elif (type & S_IFSOCK):\n        label = \"create socket\"\n    else:\n        # mknod(2): \"Zero file type is equivalent to type S_IFREG\"\n        label = \"create file\"\n    return \"%s %s\" % (T.cyan(label), T.underline(path)), 0\n\n\ndef filter_write(process, file_descriptor, byte_count):\n    if process.is_tracked_descriptor(file_descriptor):\n        path = process.descriptor_path(file_descriptor)\n        return \"%s %s to %s\" % (T.red(\"write\"), T.bold(\"%d bytes\" % byte_count), T.underline(path)), byte_count\n    else:\n        return None, None\n\n\ndef filter_dup(process, file_descriptor_old, file_descriptor_new=None):\n    if process.is_tracked_descriptor(file_descriptor_old):\n        # Copy tracked file descriptor\n        return None, process.register_path(process.descriptor_path(file_descriptor_old), file_descriptor_new)\n    else:\n        return None, None\n\n\nregister_filter(\"open\", lambda process, args:\n                filter_open(process, process.full_path(args[0]), args[1]))\nregister_filter(\"creat\", lambda process, args:\n                filter_open(process, process.full_path(args[0]), O_CREAT | O_WRONLY | O_TRUNC))\nregister_filter(\"openat\", lambda process, args:\n                filter_open(process, process.full_path(args[1], args[0]), args[2]))\nregister_filter(\"mknod\", lambda process, args:\n                filter_mknod(process.full_path(args[0]), args[1]))\nregister_filter(\"mknodat\", lambda process, args:\n                filter_mknod(process.full_path(args[1], args[0]), args[2]))\nregister_filter(\"write\", lambda process, args: filter_write(process, args[0], args[2]))\nregister_filter(\"pwrite\", lambda process, args: filter_write(process, args[0], args[2]))\n# TODO: Actual byte count is iovcnt * iov.iov_len\nregister_filter(\"writev\", lambda process, args: filter_write(process, args[0], args[2]))\nregister_filter(\"pwritev\", lambda process, args: filter_write(process, args[0], args[2]))\nregister_filter(\"dup\", lambda process, args: filter_dup(process, args[0]))\nregister_filter(\"dup2\", lambda process, args: filter_dup(process, args[0], args[1]))\nregister_filter(\"dup3\", lambda process, args: filter_dup(process, args[0], args[1]))\n", "description": " :open_file_folder: :rabbit2: :tophat: See what a program does before deciding whether you really want it to happen.", "file_name": "create_write_file.py", "id": "314a45542a6a8c00b9329466cb4a6a75", "language": "Python", "project_name": "maybe", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/p-e-w-maybe/p-e-w-maybe-ec58230/maybe/filters/create_write_file.py", "save_time": "", "source": "", "update_at": "2018-03-16T19:18:43Z", "url": "https://github.com/p-e-w/maybe", "wiki": true}