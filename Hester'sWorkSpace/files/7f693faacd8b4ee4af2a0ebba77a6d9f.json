{"author": "ansible", "code": "\n# -*- coding: utf-8 -*-\n\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: atomic_container\nshort_description: Manage the containers on the atomic host platform\ndescription:\n    - Manage the containers on the atomic host platform\n    - Allows to manage the lifecycle of a container on the atomic host platform\nversion_added: \"2.4\"\nauthor: \"Giuseppe Scrivano (@giuseppe)\"\nnotes:\n    - Host should support C(atomic) command\nrequirements:\n    - atomic\n    - \"python >= 2.6\"\noptions:\n    backend:\n        description:\n          - Define the backend to use for the container\n        required: True\n        choices: [\"docker\", \"ostree\"]\n    name:\n        description:\n          - Name of the container\n        required: True\n    image:\n        description:\n          - The image to use to install the container\n        required: True\n    rootfs:\n        description:\n          - Define the rootfs of the image\n    state:\n        description:\n          - State of the container\n        required: True\n        choices: [\"latest\", \"absent\", \"rollback\"]\n        default: \"latest\"\n    mode:\n        description:\n          - Define if it is an user or a system container\n        required: True\n        choices: [\"user\", \"system\"]\n    values:\n        description:\n            - Values for the installation of the container.  This option is permitted only with mode 'user' or 'system'.\n              The values specified here will be used at installation time as --set arguments for atomic install.\n'''\n\nEXAMPLES = '''\n\n\n- atomic_container:\n    name: etcd\n    image: rhel/etcd\n    backend: ostree\n    state: latest\n    mode: system\n    values:\n        - ETCD_NAME=etcd.server\n\n\n- atomic_container:\n    name: etcd\n    image: rhel/etcd\n    backend: ostree\n    state: absent\n    mode: system\n'''\n\nRETURN = '''\nmsg:\n    description: The command standard output\n    returned: always\n    type: string\n    sample: [u'Using default tag: latest ...']\n'''\n\n\nimport traceback\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils._text import to_native\n\n\ndef do_install(module, mode, rootfs, container, image, values_list, backend):\n    system_list = [\"--system\"] if mode == 'system' else []\n    user_list = [\"--user\"] if mode == 'user' else []\n    rootfs_list = [\"--rootfs=%s\" % rootfs] if rootfs else []\n    args = ['atomic', 'install', \"--storage=%s\" % backend, '--name=%s' % container] + system_list + user_list + rootfs_list + values_list + [image]\n    rc, out, err = module.run_command(args, check_rc=False)\n    if rc != 0:\n        module.fail_json(rc=rc, msg=err)\n    else:\n        changed = \"Extracting\" in out or \"Copying blob\" in out\n        module.exit_json(msg=out, changed=changed)\n\n\ndef do_update(module, container, image, values_list):\n    args = ['atomic', 'containers', 'update', \"--rebase=%s\" % image] + values_list + [container]\n    rc, out, err = module.run_command(args, check_rc=False)\n    if rc != 0:\n        module.fail_json(rc=rc, msg=err)\n    else:\n        changed = \"Extracting\" in out or \"Copying blob\" in out\n        module.exit_json(msg=out, changed=changed)\n\n\ndef do_uninstall(module, name, backend):\n    args = ['atomic', 'uninstall', \"--storage=%s\" % backend, name]\n    rc, out, err = module.run_command(args, check_rc=False)\n    if rc != 0:\n        module.fail_json(rc=rc, msg=err)\n    module.exit_json(msg=out, changed=True)\n\n\ndef do_rollback(module, name):\n    args = ['atomic', 'containers', 'rollback', name]\n    rc, out, err = module.run_command(args, check_rc=False)\n    if rc != 0:\n        module.fail_json(rc=rc, msg=err)\n    else:\n        changed = \"Rolling back\" in out\n        module.exit_json(msg=out, changed=changed)\n\n\ndef core(module):\n    mode = module.params['mode']\n    name = module.params['name']\n    image = module.params['image']\n    rootfs = module.params['rootfs']\n    values = module.params['values']\n    backend = module.params['backend']\n    state = module.params['state']\n\n    module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C')\n    out = {}\n    err = {}\n    rc = 0\n\n    values_list = [\"--set=%s\" % x for x in values] if values else []\n\n    args = ['atomic', 'containers', 'list', '--no-trunc', '-n', '--all', '-f', 'backend=%s' % backend, '-f', 'container=%s' % name]\n    rc, out, err = module.run_command(args, check_rc=False)\n    if rc != 0:\n        module.fail_json(rc=rc, msg=err)\n        return\n    present = name in out\n\n    if state == 'present' and present:\n        module.exit_json(msg=out, changed=False)\n    elif (state in ['latest', 'present']) and not present:\n        do_install(module, mode, rootfs, name, image, values_list, backend)\n    elif state == 'latest':\n        do_update(module, name, image, values_list)\n    elif state == 'absent':\n        if not present:\n            module.exit_json(msg=\"The container is not present\", changed=False)\n        else:\n            do_uninstall(module, name, backend)\n    elif state == 'rollback':\n        do_rollback(module, name)\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            mode=dict(default=None, choices=['user', 'system']),\n            name=dict(default=None, required=True),\n            image=dict(default=None, required=True),\n            rootfs=dict(default=None),\n            state=dict(default='latest', choices=['present', 'absent', 'latest', 'rollback']),\n            backend=dict(default=None, required=True, choices=['docker', 'ostree']),\n            values=dict(type='list', default=[]),\n        ),\n    )\n\n    if module.params['values'] is not None and module.params['mode'] == 'default':\n        module.fail_json(msg=\"values is supported only with user or system mode\")\n\n    \n    rc, out, err = module.run_command('atomic -v', check_rc=False)\n    if rc != 0:\n        module.fail_json(msg=\"Error in running atomic command\", err=err)\n\n    try:\n        core(module)\n    except Exception as e:\n        module.fail_json(msg='Unanticipated error running atomic: %s' % to_native(e), exception=traceback.format_exc())\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  atomic container short description  manage containers atomic host platform description        manage containers atomic host platform       allows manage lifecycle container atomic host platform version added   2 4  author   giuseppe scrivano ( giuseppe)  notes        host support c(atomic) command requirements        atomic        python    2 6  options      backend          description              define backend use container         required  true         choices    docker    ostree       name          description              name container         required  true     image          description              the image use install container         required  true     rootfs          description              define rootfs image     state          description              state container         required  true         choices    latest    absent    rollback           default   latest      mode          description              define user system container         required  true         choices    user    system       values          description                values installation container   this option permitted mode  user   system                 the values specified used installation time   set arguments atomic install       examples          install etcd system container   atomic container      name  etcd     image  rhel etcd     backend  ostree     state  latest     mode  system     values            etcd name etcd server    uninstall etcd system container   atomic container      name  etcd     image  rhel etcd     backend  ostree     state  absent     mode  system      return       msg      description  the command standard output     returned  always     type  string     sample   u using default tag  latest               usr bin python        coding  utf 8        copyright  ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    install etcd system container    uninstall etcd system container    import module snippets    verify platform supports atomic command ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Copyright: Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: atomic_container\nshort_description: Manage the containers on the atomic host platform\ndescription:\n    - Manage the containers on the atomic host platform\n    - Allows to manage the lifecycle of a container on the atomic host platform\nversion_added: \"2.4\"\nauthor: \"Giuseppe Scrivano (@giuseppe)\"\nnotes:\n    - Host should support C(atomic) command\nrequirements:\n    - atomic\n    - \"python >= 2.6\"\noptions:\n    backend:\n        description:\n          - Define the backend to use for the container\n        required: True\n        choices: [\"docker\", \"ostree\"]\n    name:\n        description:\n          - Name of the container\n        required: True\n    image:\n        description:\n          - The image to use to install the container\n        required: True\n    rootfs:\n        description:\n          - Define the rootfs of the image\n    state:\n        description:\n          - State of the container\n        required: True\n        choices: [\"latest\", \"absent\", \"rollback\"]\n        default: \"latest\"\n    mode:\n        description:\n          - Define if it is an user or a system container\n        required: True\n        choices: [\"user\", \"system\"]\n    values:\n        description:\n            - Values for the installation of the container.  This option is permitted only with mode 'user' or 'system'.\n              The values specified here will be used at installation time as --set arguments for atomic install.\n'''\n\nEXAMPLES = '''\n\n# Install the etcd system container\n- atomic_container:\n    name: etcd\n    image: rhel/etcd\n    backend: ostree\n    state: latest\n    mode: system\n    values:\n        - ETCD_NAME=etcd.server\n\n# Uninstall the etcd system container\n- atomic_container:\n    name: etcd\n    image: rhel/etcd\n    backend: ostree\n    state: absent\n    mode: system\n'''\n\nRETURN = '''\nmsg:\n    description: The command standard output\n    returned: always\n    type: string\n    sample: [u'Using default tag: latest ...']\n'''\n\n# import module snippets\nimport traceback\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils._text import to_native\n\n\ndef do_install(module, mode, rootfs, container, image, values_list, backend):\n    system_list = [\"--system\"] if mode == 'system' else []\n    user_list = [\"--user\"] if mode == 'user' else []\n    rootfs_list = [\"--rootfs=%s\" % rootfs] if rootfs else []\n    args = ['atomic', 'install', \"--storage=%s\" % backend, '--name=%s' % container] + system_list + user_list + rootfs_list + values_list + [image]\n    rc, out, err = module.run_command(args, check_rc=False)\n    if rc != 0:\n        module.fail_json(rc=rc, msg=err)\n    else:\n        changed = \"Extracting\" in out or \"Copying blob\" in out\n        module.exit_json(msg=out, changed=changed)\n\n\ndef do_update(module, container, image, values_list):\n    args = ['atomic', 'containers', 'update', \"--rebase=%s\" % image] + values_list + [container]\n    rc, out, err = module.run_command(args, check_rc=False)\n    if rc != 0:\n        module.fail_json(rc=rc, msg=err)\n    else:\n        changed = \"Extracting\" in out or \"Copying blob\" in out\n        module.exit_json(msg=out, changed=changed)\n\n\ndef do_uninstall(module, name, backend):\n    args = ['atomic', 'uninstall', \"--storage=%s\" % backend, name]\n    rc, out, err = module.run_command(args, check_rc=False)\n    if rc != 0:\n        module.fail_json(rc=rc, msg=err)\n    module.exit_json(msg=out, changed=True)\n\n\ndef do_rollback(module, name):\n    args = ['atomic', 'containers', 'rollback', name]\n    rc, out, err = module.run_command(args, check_rc=False)\n    if rc != 0:\n        module.fail_json(rc=rc, msg=err)\n    else:\n        changed = \"Rolling back\" in out\n        module.exit_json(msg=out, changed=changed)\n\n\ndef core(module):\n    mode = module.params['mode']\n    name = module.params['name']\n    image = module.params['image']\n    rootfs = module.params['rootfs']\n    values = module.params['values']\n    backend = module.params['backend']\n    state = module.params['state']\n\n    module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C')\n    out = {}\n    err = {}\n    rc = 0\n\n    values_list = [\"--set=%s\" % x for x in values] if values else []\n\n    args = ['atomic', 'containers', 'list', '--no-trunc', '-n', '--all', '-f', 'backend=%s' % backend, '-f', 'container=%s' % name]\n    rc, out, err = module.run_command(args, check_rc=False)\n    if rc != 0:\n        module.fail_json(rc=rc, msg=err)\n        return\n    present = name in out\n\n    if state == 'present' and present:\n        module.exit_json(msg=out, changed=False)\n    elif (state in ['latest', 'present']) and not present:\n        do_install(module, mode, rootfs, name, image, values_list, backend)\n    elif state == 'latest':\n        do_update(module, name, image, values_list)\n    elif state == 'absent':\n        if not present:\n            module.exit_json(msg=\"The container is not present\", changed=False)\n        else:\n            do_uninstall(module, name, backend)\n    elif state == 'rollback':\n        do_rollback(module, name)\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            mode=dict(default=None, choices=['user', 'system']),\n            name=dict(default=None, required=True),\n            image=dict(default=None, required=True),\n            rootfs=dict(default=None),\n            state=dict(default='latest', choices=['present', 'absent', 'latest', 'rollback']),\n            backend=dict(default=None, required=True, choices=['docker', 'ostree']),\n            values=dict(type='list', default=[]),\n        ),\n    )\n\n    if module.params['values'] is not None and module.params['mode'] == 'default':\n        module.fail_json(msg=\"values is supported only with user or system mode\")\n\n    # Verify that the platform supports atomic command\n    rc, out, err = module.run_command('atomic -v', check_rc=False)\n    if rc != 0:\n        module.fail_json(msg=\"Error in running atomic command\", err=err)\n\n    try:\n        core(module)\n    except Exception as e:\n        module.fail_json(msg='Unanticipated error running atomic: %s' % to_native(e), exception=traceback.format_exc())\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "atomic_container.py", "id": "7f693faacd8b4ee4af2a0ebba77a6d9f", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/cloud/atomic/atomic_container.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}