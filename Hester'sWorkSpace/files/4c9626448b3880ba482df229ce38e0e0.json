{"author": "HelloZeroNet", "code": "import time\n\nfrom Plugin import PluginManager\nfrom util import helper\nfrom Crypt import CryptRsa\nfrom Config import config\n\nallow_reload = False  \ntime_full_announced = {}  \nconnection_pool = {}  \n\n\n\n@PluginManager.afterLoad\ndef importPeers():\n    global Peer\n    from Peer import Peer\n\n\n\ndef processPeerRes(tracker_address, site, peers):\n    added = 0\n    \n    found_ip4 = 0\n    for packed_address in peers[\"ip4\"]:\n        found_ip4 += 1\n        peer_ip, peer_port = helper.unpackAddress(packed_address)\n        if site.addPeer(peer_ip, peer_port):\n            added += 1\n    \n    found_onion = 0\n    for packed_address in peers[\"onion\"]:\n        found_onion += 1\n        peer_onion, peer_port = helper.unpackOnionAddress(packed_address)\n        if site.addPeer(peer_onion, peer_port):\n            added += 1\n\n    if added:\n        site.worker_manager.onPeers()\n        site.updateWebsocket(peers_added=added)\n    return added\n\n\n@PluginManager.registerTo(\"Site\")\nclass SitePlugin(object):\n    def announceTracker(self, tracker_protocol, tracker_address, fileserver_port=0, add_types=[], my_peer_id=\"\", mode=\"start\"):\n        if tracker_protocol != \"zero\":\n            return super(SitePlugin, self).announceTracker(\n                tracker_protocol, tracker_address, fileserver_port, add_types, my_peer_id, mode\n            )\n\n        s = time.time()\n\n        need_types = [\"ip4\"]\n        if self.connection_server and self.connection_server.tor_manager and self.connection_server.tor_manager.enabled:\n            need_types.append(\"onion\")\n\n        if mode == \"start\" or mode == \"more\":  \n            sites = [self]\n            full_announce = False\n        else:  \n            full_announce = True\n            if time.time() - time_full_announced.get(tracker_address, 0) < 60 * 5:  \n                return True\n            time_full_announced[tracker_address] = time.time()\n            from Site import SiteManager\n            sites = [site for site in SiteManager.site_manager.sites.values() if site.settings[\"serving\"]]\n\n        \n        request = {\n            \"hashes\": [], \"onions\": [], \"port\": fileserver_port, \"need_types\": need_types, \"need_num\": 20, \"add\": add_types\n        }\n        for site in sites:\n            if \"onion\" in add_types:\n                onion = self.connection_server.tor_manager.getOnion(site.address)\n                request[\"onions\"].append(onion)\n            request[\"hashes\"].append(site.address_hash)\n\n        \n        if full_announce:\n            request[\"delete\"] = True\n\n        \n        tracker = connection_pool.get(tracker_address)  \n        if not tracker:\n            tracker_ip, tracker_port = tracker_address.split(\":\")\n            tracker = Peer(tracker_ip, tracker_port, connection_server=self.connection_server)\n            connection_pool[tracker_address] = tracker\n        res = tracker.request(\"announce\", request)\n\n        if not res or \"peers\" not in res:\n            self.log.warning(\"Tracker error: zero://%s (%s)\" % (tracker_address, res))\n            if full_announce:\n                time_full_announced[tracker_address] = 0\n            return False\n\n        \n        site_index = 0\n        peers_added = 0\n        for site_res in res[\"peers\"]:\n            site = sites[site_index]\n            peers_added += processPeerRes(tracker_address, site, site_res)\n            site_index += 1\n\n        \n        if \"onion_sign_this\" in res:\n            self.log.debug(\"Signing %s for %s to add %s onions\" % (res[\"onion_sign_this\"], tracker_address, len(sites)))\n            request[\"onion_signs\"] = {}\n            request[\"onion_sign_this\"] = res[\"onion_sign_this\"]\n            request[\"need_num\"] = 0\n            for site in sites:\n                onion = self.connection_server.tor_manager.getOnion(site.address)\n                publickey = self.connection_server.tor_manager.getPublickey(onion)\n                if publickey not in request[\"onion_signs\"]:\n                    sign = CryptRsa.sign(res[\"onion_sign_this\"], self.connection_server.tor_manager.getPrivatekey(onion))\n                    request[\"onion_signs\"][publickey] = sign\n            res = tracker.request(\"announce\", request)\n            if not res or \"onion_sign_this\" in res:\n                self.log.warning(\"Tracker error: %s (Announce onion address to failed: %s)\" % (tracker_address, res))\n                if full_announce:\n                    time_full_announced[tracker_address] = 0\n                return False\n\n        if full_announce:\n            tracker.remove()  \n\n        self.log.debug(\n            \"Tracker result: zero://%s (sites: %s, new: %s)\" %\n            (tracker_address, site_index, peers_added)\n        )\n\n        return time.time() - s\n", "comments": "no source reload supported plugin tracker address: last announced site tracker tracker address: peer object we import plugin host clases plugins loaded process result got back tracker ip4 onion single: announce site multi: announce currently serving site no reannounce sites within 5 minute create request tracker remove sites announce sent request tracker re-use tracker connection possible add peers response site check need sign prove onion addresses close connection need next 5 minute", "content": "import time\n\nfrom Plugin import PluginManager\nfrom util import helper\nfrom Crypt import CryptRsa\nfrom Config import config\n\nallow_reload = False  # No source reload supported in this plugin\ntime_full_announced = {}  # Tracker address: Last announced all site to tracker\nconnection_pool = {}  # Tracker address: Peer object\n\n\n# We can only import plugin host clases after the plugins are loaded\n@PluginManager.afterLoad\ndef importPeers():\n    global Peer\n    from Peer import Peer\n\n\n# Process result got back from tracker\ndef processPeerRes(tracker_address, site, peers):\n    added = 0\n    # Ip4\n    found_ip4 = 0\n    for packed_address in peers[\"ip4\"]:\n        found_ip4 += 1\n        peer_ip, peer_port = helper.unpackAddress(packed_address)\n        if site.addPeer(peer_ip, peer_port):\n            added += 1\n    # Onion\n    found_onion = 0\n    for packed_address in peers[\"onion\"]:\n        found_onion += 1\n        peer_onion, peer_port = helper.unpackOnionAddress(packed_address)\n        if site.addPeer(peer_onion, peer_port):\n            added += 1\n\n    if added:\n        site.worker_manager.onPeers()\n        site.updateWebsocket(peers_added=added)\n    return added\n\n\n@PluginManager.registerTo(\"Site\")\nclass SitePlugin(object):\n    def announceTracker(self, tracker_protocol, tracker_address, fileserver_port=0, add_types=[], my_peer_id=\"\", mode=\"start\"):\n        if tracker_protocol != \"zero\":\n            return super(SitePlugin, self).announceTracker(\n                tracker_protocol, tracker_address, fileserver_port, add_types, my_peer_id, mode\n            )\n\n        s = time.time()\n\n        need_types = [\"ip4\"]\n        if self.connection_server and self.connection_server.tor_manager and self.connection_server.tor_manager.enabled:\n            need_types.append(\"onion\")\n\n        if mode == \"start\" or mode == \"more\":  # Single: Announce only this site\n            sites = [self]\n            full_announce = False\n        else:  # Multi: Announce all currently serving site\n            full_announce = True\n            if time.time() - time_full_announced.get(tracker_address, 0) < 60 * 5:  # No reannounce all sites within 5 minute\n                return True\n            time_full_announced[tracker_address] = time.time()\n            from Site import SiteManager\n            sites = [site for site in SiteManager.site_manager.sites.values() if site.settings[\"serving\"]]\n\n        # Create request\n        request = {\n            \"hashes\": [], \"onions\": [], \"port\": fileserver_port, \"need_types\": need_types, \"need_num\": 20, \"add\": add_types\n        }\n        for site in sites:\n            if \"onion\" in add_types:\n                onion = self.connection_server.tor_manager.getOnion(site.address)\n                request[\"onions\"].append(onion)\n            request[\"hashes\"].append(site.address_hash)\n\n        # Tracker can remove sites that we don't announce\n        if full_announce:\n            request[\"delete\"] = True\n\n        # Sent request to tracker\n        tracker = connection_pool.get(tracker_address)  # Re-use tracker connection if possible\n        if not tracker:\n            tracker_ip, tracker_port = tracker_address.split(\":\")\n            tracker = Peer(tracker_ip, tracker_port, connection_server=self.connection_server)\n            connection_pool[tracker_address] = tracker\n        res = tracker.request(\"announce\", request)\n\n        if not res or \"peers\" not in res:\n            self.log.warning(\"Tracker error: zero://%s (%s)\" % (tracker_address, res))\n            if full_announce:\n                time_full_announced[tracker_address] = 0\n            return False\n\n        # Add peers from response to site\n        site_index = 0\n        peers_added = 0\n        for site_res in res[\"peers\"]:\n            site = sites[site_index]\n            peers_added += processPeerRes(tracker_address, site, site_res)\n            site_index += 1\n\n        # Check if we need to sign prove the onion addresses\n        if \"onion_sign_this\" in res:\n            self.log.debug(\"Signing %s for %s to add %s onions\" % (res[\"onion_sign_this\"], tracker_address, len(sites)))\n            request[\"onion_signs\"] = {}\n            request[\"onion_sign_this\"] = res[\"onion_sign_this\"]\n            request[\"need_num\"] = 0\n            for site in sites:\n                onion = self.connection_server.tor_manager.getOnion(site.address)\n                publickey = self.connection_server.tor_manager.getPublickey(onion)\n                if publickey not in request[\"onion_signs\"]:\n                    sign = CryptRsa.sign(res[\"onion_sign_this\"], self.connection_server.tor_manager.getPrivatekey(onion))\n                    request[\"onion_signs\"][publickey] = sign\n            res = tracker.request(\"announce\", request)\n            if not res or \"onion_sign_this\" in res:\n                self.log.warning(\"Tracker error: %s (Announce onion address to failed: %s)\" % (tracker_address, res))\n                if full_announce:\n                    time_full_announced[tracker_address] = 0\n                return False\n\n        if full_announce:\n            tracker.remove()  # Close connection, we don't need it in next 5 minute\n\n        self.log.debug(\n            \"Tracker result: zero://%s (sites: %s, new: %s)\" %\n            (tracker_address, site_index, peers_added)\n        )\n\n        return time.time() - s\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "AnnounceZeroPlugin.py", "id": "4c9626448b3880ba482df229ce38e0e0", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-3bdb6a2/plugins/AnnounceZero/AnnounceZeroPlugin.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:21:08Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}