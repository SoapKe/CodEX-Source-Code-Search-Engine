{"author": "sympy", "code": "import warnings\n\nfrom sympy.multipledispatch.dispatcher import (Dispatcher, MDNotImplementedError,\n                                         MethodDispatcher, halt_ordering,\n                                         restart_ordering)\nfrom sympy.utilities.pytest import raises, XFAIL\n\n\ndef identity(x):\n    return x\n\n\ndef inc(x):\n    return x + 1\n\n\ndef dec(x):\n    return x - 1\n\n\ndef test_dispatcher():\n    f = Dispatcher('f')\n    f.add((int,), inc)\n    f.add((float,), dec)\n\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\", DeprecationWarning)\n        assert f.resolve((int,)) == inc\n    assert f.dispatch(int) is inc\n\n    assert f(1) == 2\n    assert f(1.0) == 0.0\n\n\ndef test_union_types():\n    f = Dispatcher('f')\n    f.register((int, float))(inc)\n\n    assert f(1) == 2\n    assert f(1.0) == 2.0\n\n\ndef test_dispatcher_as_decorator():\n    f = Dispatcher('f')\n\n    @f.register(int)\n    def inc(x):\n        return x + 1\n\n    @f.register(float)\n    def inc(x):\n        return x - 1\n\n    assert f(1) == 2\n    assert f(1.0) == 0.0\n\n\ndef test_register_instance_method():\n\n    class Test(object):\n        __init__ = MethodDispatcher('f')\n\n        @__init__.register(list)\n        def _init_list(self, data):\n            self.data = data\n\n        @__init__.register(object)\n        def _init_obj(self, datum):\n            self.data = [datum]\n\n    a = Test(3)\n    b = Test([3])\n    assert a.data == b.data\n\n\ndef test_on_ambiguity():\n    f = Dispatcher('f')\n\n    def identity(x): return x\n\n    ambiguities = [False]\n\n    def on_ambiguity(dispatcher, amb):\n        ambiguities[0] = True\n\n    f.add((object, object), identity, on_ambiguity=on_ambiguity)\n    assert not ambiguities[0]\n    f.add((object, float), identity, on_ambiguity=on_ambiguity)\n    assert not ambiguities[0]\n    f.add((float, object), identity, on_ambiguity=on_ambiguity)\n    assert ambiguities[0]\n\n\n@XFAIL\ndef test_raise_error_on_non_class():\n    f = Dispatcher('f')\n    assert raises(TypeError, lambda: f.add((1,), inc))\n\n\ndef test_docstring():\n\n    def one(x, y):\n        \"\"\" Docstring number one \"\"\"\n        return x + y\n\n    def two(x, y):\n        \"\"\" Docstring number two \"\"\"\n        return x + y\n\n    def three(x, y):\n        return x + y\n\n    master_doc = 'Doc of the multimethod itself'\n\n    f = Dispatcher('f', doc=master_doc)\n    f.add((object, object), one)\n    f.add((int, int), two)\n    f.add((float, float), three)\n\n    assert one.__doc__.strip() in f.__doc__\n    assert two.__doc__.strip() in f.__doc__\n    assert f.__doc__.find(one.__doc__.strip()) < \\\n        f.__doc__.find(two.__doc__.strip())\n    assert 'object, object' in f.__doc__\n    assert master_doc in f.__doc__\n\n\ndef test_help():\n    def one(x, y):\n        \"\"\" Docstring number one \"\"\"\n        return x + y\n\n    def two(x, y):\n        \"\"\" Docstring number two \"\"\"\n        return x + y\n\n    def three(x, y):\n        \"\"\" Docstring number three \"\"\"\n        return x + y\n\n    master_doc = 'Doc of the multimethod itself'\n\n    f = Dispatcher('f', doc=master_doc)\n    f.add((object, object), one)\n    f.add((int, int), two)\n    f.add((float, float), three)\n\n    assert f._help(1, 1) == two.__doc__\n    assert f._help(1.0, 2.0) == three.__doc__\n\n\ndef test_source():\n    def one(x, y):\n        \"\"\" Docstring number one \"\"\"\n        return x + y\n\n    def two(x, y):\n        \"\"\" Docstring number two \"\"\"\n        return x - y\n\n    master_doc = 'Doc of the multimethod itself'\n\n    f = Dispatcher('f', doc=master_doc)\n    f.add((int, int), one)\n    f.add((float, float), two)\n\n    assert 'x + y' in f._source(1, 1)\n    assert 'x - y' in f._source(1.0, 1.0)\n\n\n@XFAIL\ndef test_source_raises_on_missing_function():\n    f = Dispatcher('f')\n\n    assert raises(TypeError, lambda: f.source(1))\n\n\ndef test_halt_method_resolution():\n    g = [0]\n\n    def on_ambiguity(a, b):\n        g[0] += 1\n\n    f = Dispatcher('f')\n\n    halt_ordering()\n\n    def func(*args):\n        pass\n\n    f.add((int, object), func)\n    f.add((object, int), func)\n\n    assert g == [0]\n\n    restart_ordering(on_ambiguity=on_ambiguity)\n\n    assert g == [1]\n\n    assert set(f.ordering) == set([(int, object), (object, int)])\n\n\n@XFAIL\ndef test_no_implementations():\n    f = Dispatcher('f')\n    assert raises(NotImplementedError, lambda: f('hello'))\n\n\n@XFAIL\ndef test_register_stacking():\n    f = Dispatcher('f')\n\n    @f.register(list)\n    @f.register(tuple)\n    def rev(x):\n        return x[::-1]\n\n    assert f((1, 2, 3)) == (3, 2, 1)\n    assert f([1, 2, 3]) == [3, 2, 1]\n\n    assert raises(NotImplementedError, lambda: f('hello'))\n    assert rev('hello') == 'olleh'\n\n\ndef test_dispatch_method():\n    f = Dispatcher('f')\n\n    @f.register(list)\n    def rev(x):\n        return x[::-1]\n\n    @f.register(int, int)\n    def add(x, y):\n        return x + y\n\n    class MyList(list):\n        pass\n\n    assert f.dispatch(list) is rev\n    assert f.dispatch(MyList) is rev\n    assert f.dispatch(int, int) is add\n\n\n@XFAIL\ndef test_not_implemented():\n    f = Dispatcher('f')\n\n    @f.register(object)\n    def _(x):\n        return 'default'\n\n    @f.register(int)\n    def _(x):\n        if x % 2 == 0:\n            return 'even'\n        else:\n            raise MDNotImplementedError()\n\n    assert f('hello') == 'default'  \n    assert f(2) == 'even'          \n    assert f(3) == 'default'       \n    assert raises(NotImplementedError, lambda: f(1, 2))\n\n\n@XFAIL\ndef test_not_implemented_error():\n    f = Dispatcher('f')\n\n    @f.register(float)\n    def _(a):\n        raise MDNotImplementedError()\n\n    assert raises(NotImplementedError, lambda: f(1.0))\n", "comments": "    docstring number one             return x        def two(x  y)              docstring number two             return x        def three(x  y)          return x        master doc    doc multimethod       f   dispatcher( f   doc master doc)     f add((object  object)  one)     f add((int  int)  two)     f add((float  float)  three)      assert one   doc   strip() f   doc       assert two   doc   strip() f   doc       assert f   doc   find(one   doc   strip())             f   doc   find(two   doc   strip())     assert  object  object  f   doc       assert master doc f   doc     def test help()      def one(x  y)              docstring number one             return x        def two(x  y)              docstring number two             return x        def three(x  y)              docstring number three             return x        master doc    doc multimethod       f   dispatcher( f   doc master doc)     f add((object  object)  one)     f add((int  int)  two)     f add((float  float)  three)      assert f  help(1  1)    two   doc       assert f  help(1 0  2 0)    three   doc     def test source()      def one(x  y)              docstring number one             return x        def two(x  y)              docstring number two        default behavior    specialized behavior    fall bac default behavior ", "content": "import warnings\n\nfrom sympy.multipledispatch.dispatcher import (Dispatcher, MDNotImplementedError,\n                                         MethodDispatcher, halt_ordering,\n                                         restart_ordering)\nfrom sympy.utilities.pytest import raises, XFAIL\n\n\ndef identity(x):\n    return x\n\n\ndef inc(x):\n    return x + 1\n\n\ndef dec(x):\n    return x - 1\n\n\ndef test_dispatcher():\n    f = Dispatcher('f')\n    f.add((int,), inc)\n    f.add((float,), dec)\n\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\", DeprecationWarning)\n        assert f.resolve((int,)) == inc\n    assert f.dispatch(int) is inc\n\n    assert f(1) == 2\n    assert f(1.0) == 0.0\n\n\ndef test_union_types():\n    f = Dispatcher('f')\n    f.register((int, float))(inc)\n\n    assert f(1) == 2\n    assert f(1.0) == 2.0\n\n\ndef test_dispatcher_as_decorator():\n    f = Dispatcher('f')\n\n    @f.register(int)\n    def inc(x):\n        return x + 1\n\n    @f.register(float)\n    def inc(x):\n        return x - 1\n\n    assert f(1) == 2\n    assert f(1.0) == 0.0\n\n\ndef test_register_instance_method():\n\n    class Test(object):\n        __init__ = MethodDispatcher('f')\n\n        @__init__.register(list)\n        def _init_list(self, data):\n            self.data = data\n\n        @__init__.register(object)\n        def _init_obj(self, datum):\n            self.data = [datum]\n\n    a = Test(3)\n    b = Test([3])\n    assert a.data == b.data\n\n\ndef test_on_ambiguity():\n    f = Dispatcher('f')\n\n    def identity(x): return x\n\n    ambiguities = [False]\n\n    def on_ambiguity(dispatcher, amb):\n        ambiguities[0] = True\n\n    f.add((object, object), identity, on_ambiguity=on_ambiguity)\n    assert not ambiguities[0]\n    f.add((object, float), identity, on_ambiguity=on_ambiguity)\n    assert not ambiguities[0]\n    f.add((float, object), identity, on_ambiguity=on_ambiguity)\n    assert ambiguities[0]\n\n\n@XFAIL\ndef test_raise_error_on_non_class():\n    f = Dispatcher('f')\n    assert raises(TypeError, lambda: f.add((1,), inc))\n\n\ndef test_docstring():\n\n    def one(x, y):\n        \"\"\" Docstring number one \"\"\"\n        return x + y\n\n    def two(x, y):\n        \"\"\" Docstring number two \"\"\"\n        return x + y\n\n    def three(x, y):\n        return x + y\n\n    master_doc = 'Doc of the multimethod itself'\n\n    f = Dispatcher('f', doc=master_doc)\n    f.add((object, object), one)\n    f.add((int, int), two)\n    f.add((float, float), three)\n\n    assert one.__doc__.strip() in f.__doc__\n    assert two.__doc__.strip() in f.__doc__\n    assert f.__doc__.find(one.__doc__.strip()) < \\\n        f.__doc__.find(two.__doc__.strip())\n    assert 'object, object' in f.__doc__\n    assert master_doc in f.__doc__\n\n\ndef test_help():\n    def one(x, y):\n        \"\"\" Docstring number one \"\"\"\n        return x + y\n\n    def two(x, y):\n        \"\"\" Docstring number two \"\"\"\n        return x + y\n\n    def three(x, y):\n        \"\"\" Docstring number three \"\"\"\n        return x + y\n\n    master_doc = 'Doc of the multimethod itself'\n\n    f = Dispatcher('f', doc=master_doc)\n    f.add((object, object), one)\n    f.add((int, int), two)\n    f.add((float, float), three)\n\n    assert f._help(1, 1) == two.__doc__\n    assert f._help(1.0, 2.0) == three.__doc__\n\n\ndef test_source():\n    def one(x, y):\n        \"\"\" Docstring number one \"\"\"\n        return x + y\n\n    def two(x, y):\n        \"\"\" Docstring number two \"\"\"\n        return x - y\n\n    master_doc = 'Doc of the multimethod itself'\n\n    f = Dispatcher('f', doc=master_doc)\n    f.add((int, int), one)\n    f.add((float, float), two)\n\n    assert 'x + y' in f._source(1, 1)\n    assert 'x - y' in f._source(1.0, 1.0)\n\n\n@XFAIL\ndef test_source_raises_on_missing_function():\n    f = Dispatcher('f')\n\n    assert raises(TypeError, lambda: f.source(1))\n\n\ndef test_halt_method_resolution():\n    g = [0]\n\n    def on_ambiguity(a, b):\n        g[0] += 1\n\n    f = Dispatcher('f')\n\n    halt_ordering()\n\n    def func(*args):\n        pass\n\n    f.add((int, object), func)\n    f.add((object, int), func)\n\n    assert g == [0]\n\n    restart_ordering(on_ambiguity=on_ambiguity)\n\n    assert g == [1]\n\n    assert set(f.ordering) == set([(int, object), (object, int)])\n\n\n@XFAIL\ndef test_no_implementations():\n    f = Dispatcher('f')\n    assert raises(NotImplementedError, lambda: f('hello'))\n\n\n@XFAIL\ndef test_register_stacking():\n    f = Dispatcher('f')\n\n    @f.register(list)\n    @f.register(tuple)\n    def rev(x):\n        return x[::-1]\n\n    assert f((1, 2, 3)) == (3, 2, 1)\n    assert f([1, 2, 3]) == [3, 2, 1]\n\n    assert raises(NotImplementedError, lambda: f('hello'))\n    assert rev('hello') == 'olleh'\n\n\ndef test_dispatch_method():\n    f = Dispatcher('f')\n\n    @f.register(list)\n    def rev(x):\n        return x[::-1]\n\n    @f.register(int, int)\n    def add(x, y):\n        return x + y\n\n    class MyList(list):\n        pass\n\n    assert f.dispatch(list) is rev\n    assert f.dispatch(MyList) is rev\n    assert f.dispatch(int, int) is add\n\n\n@XFAIL\ndef test_not_implemented():\n    f = Dispatcher('f')\n\n    @f.register(object)\n    def _(x):\n        return 'default'\n\n    @f.register(int)\n    def _(x):\n        if x % 2 == 0:\n            return 'even'\n        else:\n            raise MDNotImplementedError()\n\n    assert f('hello') == 'default'  # default behavior\n    assert f(2) == 'even'          # specialized behavior\n    assert f(3) == 'default'       # fall bac to default behavior\n    assert raises(NotImplementedError, lambda: f(1, 2))\n\n\n@XFAIL\ndef test_not_implemented_error():\n    f = Dispatcher('f')\n\n    @f.register(float)\n    def _(a):\n        raise MDNotImplementedError()\n\n    assert raises(NotImplementedError, lambda: f(1.0))\n", "description": "A computer algebra system written in pure Python", "file_name": "test_dispatcher.py", "id": "6ca054d4f9435daacecf48367adef78d", "language": "Python", "project_name": "sympy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/sympy-sympy/sympy-sympy-205da79/sympy/multipledispatch/tests/test_dispatcher.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:35:56Z", "url": "https://github.com/sympy/sympy", "wiki": true}