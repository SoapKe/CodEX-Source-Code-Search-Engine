{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom odoo import api, fields, models, _\nfrom odoo.exceptions import ValidationError, UserError\n\nfrom odoo.addons import decimal_precision as dp\nfrom odoo.tools import float_is_zero\n\n\nclass EventType(models.Model):\n    _inherit = 'event.type'\n\n    @api.model\n    def _get_default_event_ticket_ids(self):\n        product = self.env.ref('event_sale.product_product_event', raise_if_not_found=False)\n        if not product:\n            return False\n        return [(0, 0, {\n            'name': _('Registration'),\n            'product_id': product.id,\n            'price': 0,\n        })]\n\n    use_ticketing = fields.Boolean('Ticketing')\n    event_ticket_ids = fields.One2many(\n        'event.event.ticket', 'event_type_id',\n        string='Tickets', default=_get_default_event_ticket_ids)\n\n    @api.onchange('name')\n    def _onchange_name(self):\n        if self.name:\n            self.event_ticket_ids.filtered(lambda ticket: ticket.name == _('Registration')).update({\n                'name': _('Registration for %s') % self.name\n            })\n\n\nclass Event(models.Model):\n    _inherit = 'event.event'\n\n    event_ticket_ids = fields.One2many(\n        'event.event.ticket', 'event_id', string='Event Ticket',\n        copy=True)\n\n    @api.onchange('event_type_id')\n    def _onchange_type(self):\n        super(Event, self)._onchange_type()\n        if self.event_type_id.use_ticketing:\n            self.event_ticket_ids = [(5, 0, 0)] + [\n                (0, 0, {\n                    'name': self.name and _('Registration for %s') % self.name or ticket.name,\n                    'product_id': ticket.product_id.id,\n                    'price': ticket.price,\n                })\n                for ticket in self.event_type_id.event_ticket_ids]\n\n    @api.multi\n    def _is_event_registrable(self):\n        self.ensure_one()\n        if not self.event_ticket_ids:\n            return True\n        return all(self.event_ticket_ids.with_context(active_test=False).mapped(lambda t: t.product_id.active))\n\nclass EventTicket(models.Model):\n    _name = 'event.event.ticket'\n    _description = 'Event Ticket'\n\n    def _default_product_id(self):\n        return self.env.ref('event_sale.product_product_event', raise_if_not_found=False)\n\n    name = fields.Char(string='Name', required=True, translate=True)\n    event_type_id = fields.Many2one('event.type', string='Event Category', ondelete='cascade')\n    event_id = fields.Many2one('event.event', string=\"Event\", ondelete='cascade')\n    product_id = fields.Many2one('product.product', string='Product',\n        required=True, domain=[(\"event_ok\", \"=\", True)],\n        default=_default_product_id)\n    registration_ids = fields.One2many('event.registration', 'event_ticket_id', string='Registrations')\n    price = fields.Float(string='Price', digits=dp.get_precision('Product Price'))\n    deadline = fields.Date(string=\"Sales End\")\n    is_expired = fields.Boolean(string='Is Expired', compute='_compute_is_expired')\n\n    price_reduce = fields.Float(string=\"Price Reduce\", compute=\"_compute_price_reduce\", digits=dp.get_precision('Product Price'))\n    price_reduce_taxinc = fields.Float(compute='_get_price_reduce_tax', string='Price Reduce Tax inc')\n    \n    seats_availability = fields.Selection([('limited', 'Limited'), ('unlimited', 'Unlimited')],\n        string='Available Seat', required=True, store=True, compute='_compute_seats', default=\"limited\")\n    seats_max = fields.Integer(string='Maximum Available Seats',\n       help=\"Define the number of available tickets. If you have too much registrations you will \"\n            \"not be able to sell tickets anymore. Set 0 to ignore this rule set as unlimited.\")\n    seats_reserved = fields.Integer(string='Reserved Seats', compute='_compute_seats', store=True)\n    seats_available = fields.Integer(string='Available Seats', compute='_compute_seats', store=True)\n    seats_unconfirmed = fields.Integer(string='Unconfirmed Seat Reservations', compute='_compute_seats', store=True)\n    seats_used = fields.Integer(compute='_compute_seats', store=True)\n\n    @api.multi\n    def _compute_is_expired(self):\n        for record in self:\n            if record.deadline:\n                current_date = fields.Date.context_today(record.with_context({'tz': record.event_id.date_tz}))\n                record.is_expired = record.deadline < current_date\n            else:\n                record.is_expired = False\n\n    @api.multi\n    def _compute_price_reduce(self):\n        for record in self:\n            product = record.product_id\n            discount = product.lst_price and (product.lst_price - product.price) / product.lst_price or 0.0\n            record.price_reduce = (1.0 - discount) * record.price\n\n    def _get_price_reduce_tax(self):\n        for record in self:\n            \n            tax_ids = record.sudo().product_id.taxes_id.filtered(lambda r: r.company_id == record.event_id.company_id)\n            taxes = tax_ids.compute_all(record.price_reduce, record.event_id.company_id.currency_id, 1.0, product=record.product_id)\n            record.price_reduce_taxinc = taxes['total_included']\n\n    @api.multi\n    @api.depends('seats_max', 'registration_ids.state')\n    def _compute_seats(self):\n        \"\"\" Determine reserved, available, reserved but unconfirmed and used seats. \"\"\"\n        # initialize fields to 0 + compute seats availability\n        for ticket in self:\n            ticket.seats_availability = 'unlimited' if ticket.seats_max == 0 else 'limited'\n            ticket.seats_unconfirmed = ticket.seats_reserved = ticket.seats_used = ticket.seats_available = 0\n        \n        if self.ids:\n            state_field = {\n                'draft': 'seats_unconfirmed',\n                'open': 'seats_reserved',\n                'done': 'seats_used',\n            }\n            query = \"\"\" SELECT event_ticket_id, state, count(event_id)\n                        FROM event_registration\n                        WHERE event_ticket_id IN %s AND state IN ('draft', 'open', 'done')\n                        GROUP BY event_ticket_id, state\n                    \"\"\"\n            self.env.cr.execute(query, (tuple(self.ids),))\n            for event_ticket_id, state, num in self.env.cr.fetchall():\n                ticket = self.browse(event_ticket_id)\n                ticket[state_field[state]] += num\n        \n        for ticket in self:\n            if ticket.seats_max > 0:\n                ticket.seats_available = ticket.seats_max - (ticket.seats_reserved + ticket.seats_used)\n\n    @api.multi\n    @api.constrains('registration_ids', 'seats_max')\n    def _check_seats_limit(self):\n        for record in self:\n            if record.seats_max and record.seats_available < 0:\n                raise ValidationError(_('No more available seats for the ticket'))\n\n    @api.constrains('event_type_id', 'event_id')\n    def _constrains_event(self):\n        if any(ticket.event_type_id and ticket.event_id for ticket in self):\n            raise UserError(_('Ticket should belong to either event category or event but not both'))\n\n    @api.onchange('product_id')\n    def _onchange_product_id(self):\n        self.price = self.product_id.list_price or 0\n\n\nclass EventRegistration(models.Model):\n    _inherit = 'event.registration'\n\n    event_ticket_id = fields.Many2one('event.event.ticket', string='Event Ticket')\n    \n    \n    # TDE FIXME: maybe add an onchange on sale_order_id + origin\n    sale_order_id = fields.Many2one('sale.order', string='Source Sales Order', ondelete='cascade')\n    sale_order_line_id = fields.Many2one('sale.order.line', string='Sales Order Line', ondelete='cascade')\n\n    @api.multi\n    @api.constrains('event_ticket_id', 'state')\n    def _check_ticket_seats_limit(self):\n        for record in self:\n            if record.event_ticket_id.seats_max and record.event_ticket_id.seats_available < 0:\n                raise ValidationError(_('No more available seats for this ticket'))\n\n    @api.multi\n    def _check_auto_confirmation(self):\n        res = super(EventRegistration, self)._check_auto_confirmation()\n        if res:\n            orders = self.env['sale.order'].search([('state', '=', 'draft'), ('id', 'in', self.mapped('sale_order_id').ids)], limit=1)\n            if orders:\n                res = False\n        return res\n\n    @api.model\n    def create(self, vals):\n        res = super(EventRegistration, self).create(vals)\n        if res.origin or res.sale_order_id:\n            res.message_post_with_view('mail.message_origin_link',\n                values={'self': res, 'origin': res.sale_order_id},\n                subtype_id=self.env.ref('mail.mt_note').id)\n        return res\n\n    @api.model\n    def _prepare_attendee_values(self, registration):\n        \"\"\" Override to add sale related stuff \"\"\"\n        line_id = registration.get('sale_order_line_id')\n        if line_id:\n            registration.setdefault('partner_id', line_id.order_id.partner_id)\n        att_data = super(EventRegistration, self)._prepare_attendee_values(registration)\n        if line_id:\n            att_data.update({\n                'event_id': line_id.event_id.id,\n                'event_id': line_id.event_id.id,\n                'event_ticket_id': line_id.event_ticket_id.id,\n                'origin': line_id.order_id.name,\n                'sale_order_id': line_id.order_id.id,\n                'sale_order_line_id': line_id.id,\n            })\n        return att_data\n\n    @api.multi\n    def summary(self):\n        res = super(EventRegistration, self).summary()\n        if self.event_ticket_id.product_id.image_medium:\n            res['image'] = '/web/image/product.product/%s/image_medium' % self.event_ticket_id.product_id.id\n        information = res.setdefault('information', {})\n        information.append((_('Name'), self.name))\n        information.append((_('Ticket'), self.event_ticket_id.name or _('None')))\n        order = self.sale_order_id.sudo()\n        order_line = self.sale_order_line_id.sudo()\n        if not order or float_is_zero(order_line.price_total, precision_digits=order.currency_id.rounding):\n            payment_status = _('Free')\n        elif not order.invoice_ids or any(invoice.state != 'paid' for invoice in order.invoice_ids):\n            payment_status = _('To pay')\n            res['alert'] = _('The registration must be paid')\n        else:\n            payment_status = _('Paid')\n        information.append((_('Payment'), payment_status))\n        return res\n", "comments": "    determine reserved  available  reserved unconfirmed used seats                initialize fields 0   compute seats availability         ticket self              ticket seats availability    unlimited  ticket seats max    0 else  limited              ticket seats unconfirmed   ticket seats reserved   ticket seats used   ticket seats available   0           aggregate registrations ticket state         self ids              state field                      draft    seats unconfirmed                    open    seats reserved                    done    seats used                             query       select event ticket id  state  count(event id)                         from event registration                         where event ticket id in  and state in ( draft    open    done )                         group by event ticket id  state                                     self env cr execute(query  (tuple(self ids) ))             event ticket id  state  num self env cr fetchall()                  ticket   self browse(event ticket id)                 ticket state field state      num           compute seats available         ticket self              ticket seats max   0                  ticket seats available   ticket seats max   (ticket seats reserved   ticket seats used)       api multi      api constrains( registration ids    seats max )     def  check seats limit(self)          record self              record seats max record seats available   0                  raise validationerror( ( no available seats ticket ))       api constrains( event type id    event id )     def  constrains event(self)          any(ticket event type id ticket event id ticket self)              raise usererror( ( ticket belong either event category event ))       api onchange( product id )     def  onchange product id(self)          self price   self product id list price 0   class eventregistration(models model)       inherit    event registration       event ticket id   fields many2one( event event ticket   string  event ticket )       addition origin generic fields  add real relational fields correctly       handle attendees linked sales orders lines       tde fixme  maybe add onchange sale order id   origin     sale order id   fields many2one( sale order   string  source sales order   ondelete  cascade )     sale order line id   fields many2one( sale order line   string  sales order line   ondelete  cascade )       api multi      api constrains( event ticket id    state )     def  check ticket seats limit(self)          record self              record event ticket id seats max record event ticket id seats available   0                  raise validationerror( ( no available seats ticket ))       api multi     def  check auto confirmation(self)          res   super(eventregistration  self)  check auto confirmation()         res              orders   self env  sale order   search( ( state         draft )  ( id      self mapped( sale order id ) ids)   limit 1)             orders                  res   false         return res       api model     def create(self  vals)          res   super(eventregistration  self) create(vals)         res origin res sale order id              res message post view( mail message origin link                   values   self   res   origin   res sale order id                   subtype id self env ref( mail mt note ) id)         return res       api model     def  prepare attendee values(self  registration)              override add sale related stuff            coding  utf 8        part odoo  see license file full copyright licensing details     seats fields    sudo necessary since field probably accessed website    initialize fields 0   compute seats availability    aggregate registrations ticket state    compute seats available    addition origin generic fields  add real relational fields correctly    handle attendees linked sales orders lines    tde fixme  maybe add onchange sale order id   origin ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom odoo import api, fields, models, _\nfrom odoo.exceptions import ValidationError, UserError\n\nfrom odoo.addons import decimal_precision as dp\nfrom odoo.tools import float_is_zero\n\n\nclass EventType(models.Model):\n    _inherit = 'event.type'\n\n    @api.model\n    def _get_default_event_ticket_ids(self):\n        product = self.env.ref('event_sale.product_product_event', raise_if_not_found=False)\n        if not product:\n            return False\n        return [(0, 0, {\n            'name': _('Registration'),\n            'product_id': product.id,\n            'price': 0,\n        })]\n\n    use_ticketing = fields.Boolean('Ticketing')\n    event_ticket_ids = fields.One2many(\n        'event.event.ticket', 'event_type_id',\n        string='Tickets', default=_get_default_event_ticket_ids)\n\n    @api.onchange('name')\n    def _onchange_name(self):\n        if self.name:\n            self.event_ticket_ids.filtered(lambda ticket: ticket.name == _('Registration')).update({\n                'name': _('Registration for %s') % self.name\n            })\n\n\nclass Event(models.Model):\n    _inherit = 'event.event'\n\n    event_ticket_ids = fields.One2many(\n        'event.event.ticket', 'event_id', string='Event Ticket',\n        copy=True)\n\n    @api.onchange('event_type_id')\n    def _onchange_type(self):\n        super(Event, self)._onchange_type()\n        if self.event_type_id.use_ticketing:\n            self.event_ticket_ids = [(5, 0, 0)] + [\n                (0, 0, {\n                    'name': self.name and _('Registration for %s') % self.name or ticket.name,\n                    'product_id': ticket.product_id.id,\n                    'price': ticket.price,\n                })\n                for ticket in self.event_type_id.event_ticket_ids]\n\n    @api.multi\n    def _is_event_registrable(self):\n        self.ensure_one()\n        if not self.event_ticket_ids:\n            return True\n        return all(self.event_ticket_ids.with_context(active_test=False).mapped(lambda t: t.product_id.active))\n\nclass EventTicket(models.Model):\n    _name = 'event.event.ticket'\n    _description = 'Event Ticket'\n\n    def _default_product_id(self):\n        return self.env.ref('event_sale.product_product_event', raise_if_not_found=False)\n\n    name = fields.Char(string='Name', required=True, translate=True)\n    event_type_id = fields.Many2one('event.type', string='Event Category', ondelete='cascade')\n    event_id = fields.Many2one('event.event', string=\"Event\", ondelete='cascade')\n    product_id = fields.Many2one('product.product', string='Product',\n        required=True, domain=[(\"event_ok\", \"=\", True)],\n        default=_default_product_id)\n    registration_ids = fields.One2many('event.registration', 'event_ticket_id', string='Registrations')\n    price = fields.Float(string='Price', digits=dp.get_precision('Product Price'))\n    deadline = fields.Date(string=\"Sales End\")\n    is_expired = fields.Boolean(string='Is Expired', compute='_compute_is_expired')\n\n    price_reduce = fields.Float(string=\"Price Reduce\", compute=\"_compute_price_reduce\", digits=dp.get_precision('Product Price'))\n    price_reduce_taxinc = fields.Float(compute='_get_price_reduce_tax', string='Price Reduce Tax inc')\n    # seats fields\n    seats_availability = fields.Selection([('limited', 'Limited'), ('unlimited', 'Unlimited')],\n        string='Available Seat', required=True, store=True, compute='_compute_seats', default=\"limited\")\n    seats_max = fields.Integer(string='Maximum Available Seats',\n       help=\"Define the number of available tickets. If you have too much registrations you will \"\n            \"not be able to sell tickets anymore. Set 0 to ignore this rule set as unlimited.\")\n    seats_reserved = fields.Integer(string='Reserved Seats', compute='_compute_seats', store=True)\n    seats_available = fields.Integer(string='Available Seats', compute='_compute_seats', store=True)\n    seats_unconfirmed = fields.Integer(string='Unconfirmed Seat Reservations', compute='_compute_seats', store=True)\n    seats_used = fields.Integer(compute='_compute_seats', store=True)\n\n    @api.multi\n    def _compute_is_expired(self):\n        for record in self:\n            if record.deadline:\n                current_date = fields.Date.context_today(record.with_context({'tz': record.event_id.date_tz}))\n                record.is_expired = record.deadline < current_date\n            else:\n                record.is_expired = False\n\n    @api.multi\n    def _compute_price_reduce(self):\n        for record in self:\n            product = record.product_id\n            discount = product.lst_price and (product.lst_price - product.price) / product.lst_price or 0.0\n            record.price_reduce = (1.0 - discount) * record.price\n\n    def _get_price_reduce_tax(self):\n        for record in self:\n            # sudo necessary here since the field is most probably accessed through the website\n            tax_ids = record.sudo().product_id.taxes_id.filtered(lambda r: r.company_id == record.event_id.company_id)\n            taxes = tax_ids.compute_all(record.price_reduce, record.event_id.company_id.currency_id, 1.0, product=record.product_id)\n            record.price_reduce_taxinc = taxes['total_included']\n\n    @api.multi\n    @api.depends('seats_max', 'registration_ids.state')\n    def _compute_seats(self):\n        \"\"\" Determine reserved, available, reserved but unconfirmed and used seats. \"\"\"\n        # initialize fields to 0 + compute seats availability\n        for ticket in self:\n            ticket.seats_availability = 'unlimited' if ticket.seats_max == 0 else 'limited'\n            ticket.seats_unconfirmed = ticket.seats_reserved = ticket.seats_used = ticket.seats_available = 0\n        # aggregate registrations by ticket and by state\n        if self.ids:\n            state_field = {\n                'draft': 'seats_unconfirmed',\n                'open': 'seats_reserved',\n                'done': 'seats_used',\n            }\n            query = \"\"\" SELECT event_ticket_id, state, count(event_id)\n                        FROM event_registration\n                        WHERE event_ticket_id IN %s AND state IN ('draft', 'open', 'done')\n                        GROUP BY event_ticket_id, state\n                    \"\"\"\n            self.env.cr.execute(query, (tuple(self.ids),))\n            for event_ticket_id, state, num in self.env.cr.fetchall():\n                ticket = self.browse(event_ticket_id)\n                ticket[state_field[state]] += num\n        # compute seats_available\n        for ticket in self:\n            if ticket.seats_max > 0:\n                ticket.seats_available = ticket.seats_max - (ticket.seats_reserved + ticket.seats_used)\n\n    @api.multi\n    @api.constrains('registration_ids', 'seats_max')\n    def _check_seats_limit(self):\n        for record in self:\n            if record.seats_max and record.seats_available < 0:\n                raise ValidationError(_('No more available seats for the ticket'))\n\n    @api.constrains('event_type_id', 'event_id')\n    def _constrains_event(self):\n        if any(ticket.event_type_id and ticket.event_id for ticket in self):\n            raise UserError(_('Ticket should belong to either event category or event but not both'))\n\n    @api.onchange('product_id')\n    def _onchange_product_id(self):\n        self.price = self.product_id.list_price or 0\n\n\nclass EventRegistration(models.Model):\n    _inherit = 'event.registration'\n\n    event_ticket_id = fields.Many2one('event.event.ticket', string='Event Ticket')\n    # in addition to origin generic fields, add real relational fields to correctly\n    # handle attendees linked to sales orders and their lines\n    # TDE FIXME: maybe add an onchange on sale_order_id + origin\n    sale_order_id = fields.Many2one('sale.order', string='Source Sales Order', ondelete='cascade')\n    sale_order_line_id = fields.Many2one('sale.order.line', string='Sales Order Line', ondelete='cascade')\n\n    @api.multi\n    @api.constrains('event_ticket_id', 'state')\n    def _check_ticket_seats_limit(self):\n        for record in self:\n            if record.event_ticket_id.seats_max and record.event_ticket_id.seats_available < 0:\n                raise ValidationError(_('No more available seats for this ticket'))\n\n    @api.multi\n    def _check_auto_confirmation(self):\n        res = super(EventRegistration, self)._check_auto_confirmation()\n        if res:\n            orders = self.env['sale.order'].search([('state', '=', 'draft'), ('id', 'in', self.mapped('sale_order_id').ids)], limit=1)\n            if orders:\n                res = False\n        return res\n\n    @api.model\n    def create(self, vals):\n        res = super(EventRegistration, self).create(vals)\n        if res.origin or res.sale_order_id:\n            res.message_post_with_view('mail.message_origin_link',\n                values={'self': res, 'origin': res.sale_order_id},\n                subtype_id=self.env.ref('mail.mt_note').id)\n        return res\n\n    @api.model\n    def _prepare_attendee_values(self, registration):\n        \"\"\" Override to add sale related stuff \"\"\"\n        line_id = registration.get('sale_order_line_id')\n        if line_id:\n            registration.setdefault('partner_id', line_id.order_id.partner_id)\n        att_data = super(EventRegistration, self)._prepare_attendee_values(registration)\n        if line_id:\n            att_data.update({\n                'event_id': line_id.event_id.id,\n                'event_id': line_id.event_id.id,\n                'event_ticket_id': line_id.event_ticket_id.id,\n                'origin': line_id.order_id.name,\n                'sale_order_id': line_id.order_id.id,\n                'sale_order_line_id': line_id.id,\n            })\n        return att_data\n\n    @api.multi\n    def summary(self):\n        res = super(EventRegistration, self).summary()\n        if self.event_ticket_id.product_id.image_medium:\n            res['image'] = '/web/image/product.product/%s/image_medium' % self.event_ticket_id.product_id.id\n        information = res.setdefault('information', {})\n        information.append((_('Name'), self.name))\n        information.append((_('Ticket'), self.event_ticket_id.name or _('None')))\n        order = self.sale_order_id.sudo()\n        order_line = self.sale_order_line_id.sudo()\n        if not order or float_is_zero(order_line.price_total, precision_digits=order.currency_id.rounding):\n            payment_status = _('Free')\n        elif not order.invoice_ids or any(invoice.state != 'paid' for invoice in order.invoice_ids):\n            payment_status = _('To pay')\n            res['alert'] = _('The registration must be paid')\n        else:\n            payment_status = _('Paid')\n        information.append((_('Payment'), payment_status))\n        return res\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "event.py", "id": "ac58fef1f07edff585cc9423b36c5124", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/event_sale/models/event.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}