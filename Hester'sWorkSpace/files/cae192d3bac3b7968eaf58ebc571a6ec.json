{"author": "django", "code": "import unittest\nfrom contextlib import contextmanager\n\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.db import connection\nfrom django.test import TestCase, override_settings\n\n\n@contextmanager\ndef get_connection():\n    new_connection = connection.copy()\n    yield new_connection\n    new_connection.close()\n\n\n@override_settings(DEBUG=True)\n@unittest.skipUnless(connection.vendor == 'mysql', 'MySQL tests')\nclass IsolationLevelTests(TestCase):\n\n    read_committed = 'read committed'\n    repeatable_read = 'repeatable read'\n    isolation_values = {\n        level: level.upper()\n        for level in (read_committed, repeatable_read)\n    }\n\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        configured_isolation_level = connection.isolation_level or cls.isolation_values[cls.repeatable_read]\n        cls.configured_isolation_level = configured_isolation_level.upper()\n        cls.other_isolation_level = (\n            cls.read_committed\n            if configured_isolation_level != cls.isolation_values[cls.read_committed]\n            else cls.repeatable_read\n        )\n\n    @staticmethod\n    def get_isolation_level(connection):\n        with connection.cursor() as cursor:\n            cursor.execute(\"SHOW VARIABLES WHERE variable_name IN ('transaction_isolation', 'tx_isolation')\")\n            return cursor.fetchone()[1].replace('-', ' ')\n\n    def test_auto_is_null_auto_config(self):\n        query = 'set sql_auto_is_null = 0'\n        connection.init_connection_state()\n        last_query = connection.queries[-1]['sql'].lower()\n        if connection.features.is_sql_auto_is_null_enabled:\n            self.assertIn(query, last_query)\n        else:\n            self.assertNotIn(query, last_query)\n\n    def test_connect_isolation_level(self):\n        self.assertEqual(self.get_isolation_level(connection), self.configured_isolation_level)\n\n    def test_setting_isolation_level(self):\n        with get_connection() as new_connection:\n            new_connection.settings_dict['OPTIONS']['isolation_level'] = self.other_isolation_level\n            self.assertEqual(\n                self.get_isolation_level(new_connection),\n                self.isolation_values[self.other_isolation_level]\n            )\n\n    def test_uppercase_isolation_level(self):\n        \n        with get_connection() as new_connection:\n            new_connection.settings_dict['OPTIONS']['isolation_level'] = self.other_isolation_level.upper()\n            self.assertEqual(\n                self.get_isolation_level(new_connection),\n                self.isolation_values[self.other_isolation_level]\n            )\n\n    def test_default_isolation_level(self):\n        \n        with get_connection() as new_connection:\n            new_connection.settings_dict['OPTIONS'].pop('isolation_level', None)\n            self.assertEqual(\n                self.get_isolation_level(new_connection),\n                self.isolation_values[self.read_committed]\n            )\n\n    def test_isolation_level_validation(self):\n        new_connection = connection.copy()\n        new_connection.settings_dict['OPTIONS']['isolation_level'] = 'xxx'\n        msg = (\n            \"Invalid transaction isolation level 'xxx' specified.\\n\"\n            \"Use one of 'read committed', 'read uncommitted', \"\n            \"'repeatable read', 'serializable', or None.\"\n        )\n        with self.assertRaisesMessage(ImproperlyConfigured, msg):\n            new_connection.cursor()\n", "comments": "  upper case values also accepted  isolation level      if specified settings  default read committed  ", "content": "import unittest\nfrom contextlib import contextmanager\n\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.db import connection\nfrom django.test import TestCase, override_settings\n\n\n@contextmanager\ndef get_connection():\n    new_connection = connection.copy()\n    yield new_connection\n    new_connection.close()\n\n\n@override_settings(DEBUG=True)\n@unittest.skipUnless(connection.vendor == 'mysql', 'MySQL tests')\nclass IsolationLevelTests(TestCase):\n\n    read_committed = 'read committed'\n    repeatable_read = 'repeatable read'\n    isolation_values = {\n        level: level.upper()\n        for level in (read_committed, repeatable_read)\n    }\n\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        configured_isolation_level = connection.isolation_level or cls.isolation_values[cls.repeatable_read]\n        cls.configured_isolation_level = configured_isolation_level.upper()\n        cls.other_isolation_level = (\n            cls.read_committed\n            if configured_isolation_level != cls.isolation_values[cls.read_committed]\n            else cls.repeatable_read\n        )\n\n    @staticmethod\n    def get_isolation_level(connection):\n        with connection.cursor() as cursor:\n            cursor.execute(\"SHOW VARIABLES WHERE variable_name IN ('transaction_isolation', 'tx_isolation')\")\n            return cursor.fetchone()[1].replace('-', ' ')\n\n    def test_auto_is_null_auto_config(self):\n        query = 'set sql_auto_is_null = 0'\n        connection.init_connection_state()\n        last_query = connection.queries[-1]['sql'].lower()\n        if connection.features.is_sql_auto_is_null_enabled:\n            self.assertIn(query, last_query)\n        else:\n            self.assertNotIn(query, last_query)\n\n    def test_connect_isolation_level(self):\n        self.assertEqual(self.get_isolation_level(connection), self.configured_isolation_level)\n\n    def test_setting_isolation_level(self):\n        with get_connection() as new_connection:\n            new_connection.settings_dict['OPTIONS']['isolation_level'] = self.other_isolation_level\n            self.assertEqual(\n                self.get_isolation_level(new_connection),\n                self.isolation_values[self.other_isolation_level]\n            )\n\n    def test_uppercase_isolation_level(self):\n        # Upper case values are also accepted in 'isolation_level'.\n        with get_connection() as new_connection:\n            new_connection.settings_dict['OPTIONS']['isolation_level'] = self.other_isolation_level.upper()\n            self.assertEqual(\n                self.get_isolation_level(new_connection),\n                self.isolation_values[self.other_isolation_level]\n            )\n\n    def test_default_isolation_level(self):\n        # If not specified in settings, the default is read committed.\n        with get_connection() as new_connection:\n            new_connection.settings_dict['OPTIONS'].pop('isolation_level', None)\n            self.assertEqual(\n                self.get_isolation_level(new_connection),\n                self.isolation_values[self.read_committed]\n            )\n\n    def test_isolation_level_validation(self):\n        new_connection = connection.copy()\n        new_connection.settings_dict['OPTIONS']['isolation_level'] = 'xxx'\n        msg = (\n            \"Invalid transaction isolation level 'xxx' specified.\\n\"\n            \"Use one of 'read committed', 'read uncommitted', \"\n            \"'repeatable read', 'serializable', or None.\"\n        )\n        with self.assertRaisesMessage(ImproperlyConfigured, msg):\n            new_connection.cursor()\n", "description": "The Web framework for perfectionists with deadlines.", "file_name": "tests.py", "id": "cae192d3bac3b7968eaf58ebc571a6ec", "language": "Python", "project_name": "django", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/django-django/django-django-acfc650/tests/backends/mysql/tests.py", "save_time": "", "source": "", "update_at": "2018-03-14T02:00:36Z", "url": "https://github.com/django/django", "wiki": false}