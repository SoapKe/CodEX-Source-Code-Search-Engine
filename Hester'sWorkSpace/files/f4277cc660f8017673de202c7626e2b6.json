{"author": "pallets", "code": "\n\n    logger = logging.getLogger('flask.app')\n\n    if app.debug and logger.level == logging.NOTSET:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n", "comments": "\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext://flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ['wsgi.errors'] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(logging.Formatter(\n    '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'\n))\n\n\ndef create_logger(app):\n    \"\"\"Get the ``'flask.app'`` logger and configure it if needed.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \n \n# -*- coding: utf-8 -*-\n", "content": "# -*- coding: utf-8 -*-\n\"\"\"\nflask.logging\n~~~~~~~~~~~~~\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport logging\nimport sys\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\n\n@LocalProxy\ndef wsgi_errors_stream():\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext://flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ['wsgi.errors'] if request else sys.stderr\n\n\ndef has_level_handler(logger):\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)\ndefault_handler.setFormatter(logging.Formatter(\n    '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'\n))\n\n\ndef create_logger(app):\n    \"\"\"Get the ``'flask.app'`` logger and configure it if needed.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger('flask.app')\n\n    if app.debug and logger.level == logging.NOTSET:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n", "description": "The Python micro framework for building web applications.", "file_name": "logging.py", "language": "Python", "project_name": "flask", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/pallets_flask/pallets-flask-a2ea186/flask/logging.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:52:03Z", "url": "https://github.com/pallets/flask", "wiki": false}