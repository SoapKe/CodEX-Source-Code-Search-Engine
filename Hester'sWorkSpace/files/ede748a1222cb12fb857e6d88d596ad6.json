{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport uuid\nimport xml.etree.ElementTree as etree\nimport json\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_etree_register_namespace,\n)\nfrom ..utils import (\n    extract_attributes,\n    xpath_with_ns,\n    xpath_element,\n    xpath_text,\n    int_or_none,\n    parse_duration,\n    ExtractorError,\n    determine_ext,\n)\n\n\nclass ITVIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?itv\\.com/hub/[^/]+/(?P<id>[0-9a-zA-Z]+)'\n    _GEO_COUNTRIES = ['GB']\n    _TESTS = [{\n        'url': 'http://www.itv.com/hub/mr-bean-animated-series/2a2936a0053',\n        'info_dict': {\n            'id': '2a2936a0053',\n            'ext': 'flv',\n            'title': 'Home Movie',\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }, {\n        \n        'url': 'https://www.itv.com/hub/through-the-keyhole/2a2271a0033',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        webpage = self._download_webpage(url, video_id)\n        params = extract_attributes(self._search_regex(\n            r'(?s)(<[^>]+id=\"video\"[^>]*>)', webpage, 'params'))\n\n        ns_map = {\n            'soapenv': 'http://schemas.xmlsoap.org/soap/envelope/',\n            'tem': 'http://tempuri.org/',\n            'itv': 'http://schemas.datacontract.org/2004/07/Itv.BB.Mercury.Common.Types',\n            'com': 'http://schemas.itv.com/2009/05/Common',\n        }\n        for ns, full_ns in ns_map.items():\n            compat_etree_register_namespace(ns, full_ns)\n\n        def _add_ns(name):\n            return xpath_with_ns(name, ns_map)\n\n        def _add_sub_element(element, name):\n            return etree.SubElement(element, _add_ns(name))\n\n        production_id = (\n            params.get('data-video-autoplay-id') or\n            '%s\n                params.get('data-video-episode-id') or\n                video_id.replace('a', '/')))\n\n        req_env = etree.Element(_add_ns('soapenv:Envelope'))\n        _add_sub_element(req_env, 'soapenv:Header')\n        body = _add_sub_element(req_env, 'soapenv:Body')\n        get_playlist = _add_sub_element(body, ('tem:GetPlaylist'))\n        request = _add_sub_element(get_playlist, 'tem:request')\n        _add_sub_element(request, 'itv:ProductionId').text = production_id\n        _add_sub_element(request, 'itv:RequestGuid').text = compat_str(uuid.uuid4()).upper()\n        vodcrid = _add_sub_element(request, 'itv:Vodcrid')\n        _add_sub_element(vodcrid, 'com:Id')\n        _add_sub_element(request, 'itv:Partition')\n        user_info = _add_sub_element(get_playlist, 'tem:userInfo')\n        _add_sub_element(user_info, 'itv:Broadcaster').text = 'Itv'\n        _add_sub_element(user_info, 'itv:DM')\n        _add_sub_element(user_info, 'itv:RevenueScienceValue')\n        _add_sub_element(user_info, 'itv:SessionId')\n        _add_sub_element(user_info, 'itv:SsoToken')\n        _add_sub_element(user_info, 'itv:UserToken')\n        site_info = _add_sub_element(get_playlist, 'tem:siteInfo')\n        _add_sub_element(site_info, 'itv:AdvertisingRestriction').text = 'None'\n        _add_sub_element(site_info, 'itv:AdvertisingSite').text = 'ITV'\n        _add_sub_element(site_info, 'itv:AdvertisingType').text = 'Any'\n        _add_sub_element(site_info, 'itv:Area').text = 'ITVPLAYER.VIDEO'\n        _add_sub_element(site_info, 'itv:Category')\n        _add_sub_element(site_info, 'itv:Platform').text = 'DotCom'\n        _add_sub_element(site_info, 'itv:Site').text = 'ItvCom'\n        device_info = _add_sub_element(get_playlist, 'tem:deviceInfo')\n        _add_sub_element(device_info, 'itv:ScreenSize').text = 'Big'\n        player_info = _add_sub_element(get_playlist, 'tem:playerInfo')\n        _add_sub_element(player_info, 'itv:Version').text = '2'\n\n        headers = self.geo_verification_headers()\n        headers.update({\n            'Content-Type': 'text/xml; charset=utf-8',\n            'SOAPAction': 'http://tempuri.org/PlaylistService/GetPlaylist',\n        })\n\n        info = self._search_json_ld(webpage, video_id, default={})\n        formats = []\n        subtitles = {}\n\n        def extract_subtitle(sub_url):\n            ext = determine_ext(sub_url, 'ttml')\n            subtitles.setdefault('en', []).append({\n                'url': sub_url,\n                'ext': 'ttml' if ext == 'xml' else ext,\n            })\n\n        resp_env = self._download_xml(\n            params['data-playlist-url'], video_id,\n            headers=headers, data=etree.tostring(req_env))\n        playlist = xpath_element(resp_env, './/Playlist')\n        if playlist is None:\n            fault_code = xpath_text(resp_env, './/faultcode')\n            fault_string = xpath_text(resp_env, './/faultstring')\n            if fault_code == 'InvalidGeoRegion':\n                self.raise_geo_restricted(\n                    msg=fault_string, countries=self._GEO_COUNTRIES)\n            elif fault_code != 'InvalidEntity':\n                raise ExtractorError(\n                    '%s said: %s' % (self.IE_NAME, fault_string), expected=True)\n            info.update({\n                'title': self._og_search_title(webpage),\n                'episode_title': params.get('data-video-episode'),\n                'series': params.get('data-video-title'),\n            })\n        else:\n            title = xpath_text(playlist, 'EpisodeTitle', default=None)\n            info.update({\n                'title': title,\n                'episode_title': title,\n                'episode_number': int_or_none(xpath_text(playlist, 'EpisodeNumber')),\n                'series': xpath_text(playlist, 'ProgrammeTitle'),\n                'duration': parse_duration(xpath_text(playlist, 'Duration')),\n            })\n            video_element = xpath_element(playlist, 'VideoEntries/Video', fatal=True)\n            media_files = xpath_element(video_element, 'MediaFiles', fatal=True)\n            rtmp_url = media_files.attrib['base']\n\n            for media_file in media_files.findall('MediaFile'):\n                play_path = xpath_text(media_file, 'URL')\n                if not play_path:\n                    continue\n                tbr = int_or_none(media_file.get('bitrate'), 1000)\n                f = {\n                    'format_id': 'rtmp' + ('-%d' % tbr if tbr else ''),\n                    'play_path': play_path,\n                    \n                    'player_url': 'http://www.itv.com/mercury/Mercury_VideoPlayer.swf',\n                    'page_url': url,\n                    'tbr': tbr,\n                    'ext': 'flv',\n                }\n                app = self._search_regex(\n                    'rtmpe?://[^/]+/(.+)$', rtmp_url, 'app', default=None)\n                if app:\n                    f.update({\n                        'url': rtmp_url.split('?', 1)[0],\n                        'app': app,\n                    })\n                else:\n                    f['url'] = rtmp_url\n                formats.append(f)\n\n            for caption_url in video_element.findall('ClosedCaptioningURIs/URL'):\n                if caption_url.text:\n                    extract_subtitle(caption_url.text)\n\n        ios_playlist_url = params.get('data-video-playlist') or params.get('data-video-id')\n        hmac = params.get('data-video-hmac')\n        if ios_playlist_url and hmac and re.match(r'https?://', ios_playlist_url):\n            headers = self.geo_verification_headers()\n            headers.update({\n                'Accept': 'application/vnd.itv.vod.playlist.v2+json',\n                'Content-Type': 'application/json',\n                'hmac': hmac.upper(),\n            })\n            ios_playlist = self._download_json(\n                ios_playlist_url, video_id, data=json.dumps({\n                    'user': {\n                        'itvUserId': '',\n                        'entitlements': [],\n                        'token': ''\n                    },\n                    'device': {\n                        'manufacturer': 'Safari',\n                        'model': '5',\n                        'os': {\n                            'name': 'Windows NT',\n                            'version': '6.1',\n                            'type': 'desktop'\n                        }\n                    },\n                    'client': {\n                        'version': '4.1',\n                        'id': 'browser'\n                    },\n                    'variantAvailability': {\n                        'featureset': {\n                            'min': ['hls', 'aes', 'outband-webvtt'],\n                            'max': ['hls', 'aes', 'outband-webvtt']\n                        },\n                        'platformTag': 'dotcom'\n                    }\n                }).encode(), headers=headers, fatal=False)\n            if ios_playlist:\n                video_data = ios_playlist.get('Playlist', {}).get('Video', {})\n                ios_base_url = video_data.get('Base')\n                for media_file in video_data.get('MediaFiles', []):\n                    href = media_file.get('Href')\n                    if not href:\n                        continue\n                    if ios_base_url:\n                        href = ios_base_url + href\n                    ext = determine_ext(href)\n                    if ext == 'm3u8':\n                        formats.extend(self._extract_m3u8_formats(\n                            href, video_id, 'mp4', entry_protocol='m3u8_native',\n                            m3u8_id='hls', fatal=False))\n                    else:\n                        formats.append({\n                            'url': href,\n                        })\n                subs = video_data.get('Subtitles')\n                if isinstance(subs, list):\n                    for sub in subs:\n                        if not isinstance(sub, dict):\n                            continue\n                        href = sub.get('Href')\n                        if isinstance(href, compat_str):\n                            extract_subtitle(href)\n                if not info.get('duration'):\n                    info['duration'] = parse_duration(video_data.get('Duration'))\n\n        self._sort_formats(formats)\n\n        info.update({\n            'id': video_id,\n            'formats': formats,\n            'subtitles': subtitles,\n        })\n        return info\n", "comments": "# coding: utf-8\n# rtmp download\n# unavailable via data-playlist-url\n#001' % (\n# Providing this swfVfy allows to avoid truncated downloads\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport uuid\nimport xml.etree.ElementTree as etree\nimport json\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_etree_register_namespace,\n)\nfrom ..utils import (\n    extract_attributes,\n    xpath_with_ns,\n    xpath_element,\n    xpath_text,\n    int_or_none,\n    parse_duration,\n    ExtractorError,\n    determine_ext,\n)\n\n\nclass ITVIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?itv\\.com/hub/[^/]+/(?P<id>[0-9a-zA-Z]+)'\n    _GEO_COUNTRIES = ['GB']\n    _TESTS = [{\n        'url': 'http://www.itv.com/hub/mr-bean-animated-series/2a2936a0053',\n        'info_dict': {\n            'id': '2a2936a0053',\n            'ext': 'flv',\n            'title': 'Home Movie',\n        },\n        'params': {\n            # rtmp download\n            'skip_download': True,\n        },\n    }, {\n        # unavailable via data-playlist-url\n        'url': 'https://www.itv.com/hub/through-the-keyhole/2a2271a0033',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        webpage = self._download_webpage(url, video_id)\n        params = extract_attributes(self._search_regex(\n            r'(?s)(<[^>]+id=\"video\"[^>]*>)', webpage, 'params'))\n\n        ns_map = {\n            'soapenv': 'http://schemas.xmlsoap.org/soap/envelope/',\n            'tem': 'http://tempuri.org/',\n            'itv': 'http://schemas.datacontract.org/2004/07/Itv.BB.Mercury.Common.Types',\n            'com': 'http://schemas.itv.com/2009/05/Common',\n        }\n        for ns, full_ns in ns_map.items():\n            compat_etree_register_namespace(ns, full_ns)\n\n        def _add_ns(name):\n            return xpath_with_ns(name, ns_map)\n\n        def _add_sub_element(element, name):\n            return etree.SubElement(element, _add_ns(name))\n\n        production_id = (\n            params.get('data-video-autoplay-id') or\n            '%s#001' % (\n                params.get('data-video-episode-id') or\n                video_id.replace('a', '/')))\n\n        req_env = etree.Element(_add_ns('soapenv:Envelope'))\n        _add_sub_element(req_env, 'soapenv:Header')\n        body = _add_sub_element(req_env, 'soapenv:Body')\n        get_playlist = _add_sub_element(body, ('tem:GetPlaylist'))\n        request = _add_sub_element(get_playlist, 'tem:request')\n        _add_sub_element(request, 'itv:ProductionId').text = production_id\n        _add_sub_element(request, 'itv:RequestGuid').text = compat_str(uuid.uuid4()).upper()\n        vodcrid = _add_sub_element(request, 'itv:Vodcrid')\n        _add_sub_element(vodcrid, 'com:Id')\n        _add_sub_element(request, 'itv:Partition')\n        user_info = _add_sub_element(get_playlist, 'tem:userInfo')\n        _add_sub_element(user_info, 'itv:Broadcaster').text = 'Itv'\n        _add_sub_element(user_info, 'itv:DM')\n        _add_sub_element(user_info, 'itv:RevenueScienceValue')\n        _add_sub_element(user_info, 'itv:SessionId')\n        _add_sub_element(user_info, 'itv:SsoToken')\n        _add_sub_element(user_info, 'itv:UserToken')\n        site_info = _add_sub_element(get_playlist, 'tem:siteInfo')\n        _add_sub_element(site_info, 'itv:AdvertisingRestriction').text = 'None'\n        _add_sub_element(site_info, 'itv:AdvertisingSite').text = 'ITV'\n        _add_sub_element(site_info, 'itv:AdvertisingType').text = 'Any'\n        _add_sub_element(site_info, 'itv:Area').text = 'ITVPLAYER.VIDEO'\n        _add_sub_element(site_info, 'itv:Category')\n        _add_sub_element(site_info, 'itv:Platform').text = 'DotCom'\n        _add_sub_element(site_info, 'itv:Site').text = 'ItvCom'\n        device_info = _add_sub_element(get_playlist, 'tem:deviceInfo')\n        _add_sub_element(device_info, 'itv:ScreenSize').text = 'Big'\n        player_info = _add_sub_element(get_playlist, 'tem:playerInfo')\n        _add_sub_element(player_info, 'itv:Version').text = '2'\n\n        headers = self.geo_verification_headers()\n        headers.update({\n            'Content-Type': 'text/xml; charset=utf-8',\n            'SOAPAction': 'http://tempuri.org/PlaylistService/GetPlaylist',\n        })\n\n        info = self._search_json_ld(webpage, video_id, default={})\n        formats = []\n        subtitles = {}\n\n        def extract_subtitle(sub_url):\n            ext = determine_ext(sub_url, 'ttml')\n            subtitles.setdefault('en', []).append({\n                'url': sub_url,\n                'ext': 'ttml' if ext == 'xml' else ext,\n            })\n\n        resp_env = self._download_xml(\n            params['data-playlist-url'], video_id,\n            headers=headers, data=etree.tostring(req_env))\n        playlist = xpath_element(resp_env, './/Playlist')\n        if playlist is None:\n            fault_code = xpath_text(resp_env, './/faultcode')\n            fault_string = xpath_text(resp_env, './/faultstring')\n            if fault_code == 'InvalidGeoRegion':\n                self.raise_geo_restricted(\n                    msg=fault_string, countries=self._GEO_COUNTRIES)\n            elif fault_code != 'InvalidEntity':\n                raise ExtractorError(\n                    '%s said: %s' % (self.IE_NAME, fault_string), expected=True)\n            info.update({\n                'title': self._og_search_title(webpage),\n                'episode_title': params.get('data-video-episode'),\n                'series': params.get('data-video-title'),\n            })\n        else:\n            title = xpath_text(playlist, 'EpisodeTitle', default=None)\n            info.update({\n                'title': title,\n                'episode_title': title,\n                'episode_number': int_or_none(xpath_text(playlist, 'EpisodeNumber')),\n                'series': xpath_text(playlist, 'ProgrammeTitle'),\n                'duration': parse_duration(xpath_text(playlist, 'Duration')),\n            })\n            video_element = xpath_element(playlist, 'VideoEntries/Video', fatal=True)\n            media_files = xpath_element(video_element, 'MediaFiles', fatal=True)\n            rtmp_url = media_files.attrib['base']\n\n            for media_file in media_files.findall('MediaFile'):\n                play_path = xpath_text(media_file, 'URL')\n                if not play_path:\n                    continue\n                tbr = int_or_none(media_file.get('bitrate'), 1000)\n                f = {\n                    'format_id': 'rtmp' + ('-%d' % tbr if tbr else ''),\n                    'play_path': play_path,\n                    # Providing this swfVfy allows to avoid truncated downloads\n                    'player_url': 'http://www.itv.com/mercury/Mercury_VideoPlayer.swf',\n                    'page_url': url,\n                    'tbr': tbr,\n                    'ext': 'flv',\n                }\n                app = self._search_regex(\n                    'rtmpe?://[^/]+/(.+)$', rtmp_url, 'app', default=None)\n                if app:\n                    f.update({\n                        'url': rtmp_url.split('?', 1)[0],\n                        'app': app,\n                    })\n                else:\n                    f['url'] = rtmp_url\n                formats.append(f)\n\n            for caption_url in video_element.findall('ClosedCaptioningURIs/URL'):\n                if caption_url.text:\n                    extract_subtitle(caption_url.text)\n\n        ios_playlist_url = params.get('data-video-playlist') or params.get('data-video-id')\n        hmac = params.get('data-video-hmac')\n        if ios_playlist_url and hmac and re.match(r'https?://', ios_playlist_url):\n            headers = self.geo_verification_headers()\n            headers.update({\n                'Accept': 'application/vnd.itv.vod.playlist.v2+json',\n                'Content-Type': 'application/json',\n                'hmac': hmac.upper(),\n            })\n            ios_playlist = self._download_json(\n                ios_playlist_url, video_id, data=json.dumps({\n                    'user': {\n                        'itvUserId': '',\n                        'entitlements': [],\n                        'token': ''\n                    },\n                    'device': {\n                        'manufacturer': 'Safari',\n                        'model': '5',\n                        'os': {\n                            'name': 'Windows NT',\n                            'version': '6.1',\n                            'type': 'desktop'\n                        }\n                    },\n                    'client': {\n                        'version': '4.1',\n                        'id': 'browser'\n                    },\n                    'variantAvailability': {\n                        'featureset': {\n                            'min': ['hls', 'aes', 'outband-webvtt'],\n                            'max': ['hls', 'aes', 'outband-webvtt']\n                        },\n                        'platformTag': 'dotcom'\n                    }\n                }).encode(), headers=headers, fatal=False)\n            if ios_playlist:\n                video_data = ios_playlist.get('Playlist', {}).get('Video', {})\n                ios_base_url = video_data.get('Base')\n                for media_file in video_data.get('MediaFiles', []):\n                    href = media_file.get('Href')\n                    if not href:\n                        continue\n                    if ios_base_url:\n                        href = ios_base_url + href\n                    ext = determine_ext(href)\n                    if ext == 'm3u8':\n                        formats.extend(self._extract_m3u8_formats(\n                            href, video_id, 'mp4', entry_protocol='m3u8_native',\n                            m3u8_id='hls', fatal=False))\n                    else:\n                        formats.append({\n                            'url': href,\n                        })\n                subs = video_data.get('Subtitles')\n                if isinstance(subs, list):\n                    for sub in subs:\n                        if not isinstance(sub, dict):\n                            continue\n                        href = sub.get('Href')\n                        if isinstance(href, compat_str):\n                            extract_subtitle(href)\n                if not info.get('duration'):\n                    info['duration'] = parse_duration(video_data.get('Duration'))\n\n        self._sort_formats(formats)\n\n        info.update({\n            'id': video_id,\n            'formats': formats,\n            'subtitles': subtitles,\n        })\n        return info\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "itv.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/itv.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}