{"author": "fabric", "code": "\"\"\"\nCurrent Fabric version constant plus version pretty-print method.\n\nThis functionality is contained in its own module to prevent circular import\nproblems with ``__init__.py`` (which is loaded by setup.py during installation,\nwhich in turn needs access to this version information.)\n\"\"\"\nfrom subprocess import Popen, PIPE\nfrom os.path import abspath, dirname\n\n\nVERSION = (1, 14, 0, 'final', 0)\n\n\ndef git_sha():\n    loc = abspath(dirname(__file__))\n    try:\n        p = Popen(\n            \"cd \\\"%s\\\" && git log -1 --format=format:%%h\" % loc,\n            shell=True,\n            stdout=PIPE,\n            stderr=PIPE\n        )\n        return p.communicate()[0]\n    \n    \n    except OSError:\n        return None\n\n\ndef get_version(form='short'):\n    \"\"\"\n    Return a version string for this package, based on `VERSION`.\n\n    Takes a single argument, ``form``, which should be one of the following\n    strings:\n\n    * ``branch``: just the major + minor, e.g. \"0.9\", \"1.0\".\n    * ``short`` (default): compact, e.g. \"0.9rc1\", \"0.9.0\". For package\n      filenames or SCM tag identifiers.\n    * ``normal``: human readable, e.g. \"0.9\", \"0.9.1\", \"0.9 beta 1\". For e.g.\n      documentation site headers.\n    * ``verbose``: like ``normal`` but fully explicit, e.g. \"0.9 final\". For\n      tag commit messages, or anywhere that it's important to remove ambiguity\n      between a branch and the first final release within that branch.\n    * ``all``: Returns all of the above, as a dict.\n    \"\"\"\n    \n    versions = {}\n    branch = \"%s.%s\" % (VERSION[0], VERSION[1])\n    tertiary = VERSION[2]\n    type_ = VERSION[3]\n    final = (type_ == \"final\")\n    type_num = VERSION[4]\n    firsts = \"\".join([x[0] for x in type_.split()])\n\n    \n    versions['branch'] = branch\n\n    \n    v = branch\n    if (tertiary or final):\n        v += \".\" + str(tertiary)\n    if not final:\n        v += firsts\n        if type_num:\n            v += str(type_num)\n    versions['short'] = v\n\n    \n    v = branch\n    if tertiary:\n        v += \".\" + str(tertiary)\n    if not final:\n        if type_num:\n            v += \" \" + type_ + \" \" + str(type_num)\n        else:\n            v += \" pre-\" + type_\n    versions['normal'] = v\n\n    \n    v = branch\n    if tertiary:\n        v += \".\" + str(tertiary)\n    if not final:\n        if type_num:\n            v += \" \" + type_ + \" \" + str(type_num)\n        else:\n            v += \" pre-\" + type_\n    else:\n        v += \" final\"\n    versions['verbose'] = v\n\n    try:\n        return versions[form]\n    except KeyError:\n        if form == 'all':\n            return versions\n        raise TypeError('\"%s\" is not a valid form specifier.' % form)\n\n__version__ = get_version('short')\n\nif __name__ == \"__main__\":\n    print(get_version('all'))\n", "comments": "    current fabric version constant plus version pretty print method   this functionality contained module prevent circular import problems     init   py   (which loaded setup py installation  turn needs access version information )     subprocess import popen  pipe os path import abspath  dirname   version   (1  14  0   final   0)   def git sha()      loc   abspath(dirname(  file  ))     try          p   popen(              cd         git log  1   format format   h    loc              shell true              stdout pipe              stderr pipe         )         return p communicate() 0        oserror occurs unix derived platforms lacking popen configured shell       default   bin sh  e g  android      except oserror          return none   def get version(form  short )              return version string package  based  version        takes single argument    form    one following     strings           branch    major   minor  e g   0 9    1 0           short   (default)  compact  e g   0 9rc1    0 9 0   for package       filenames scm tag identifiers          normal    human readable  e g   0 9    0 9 1    0 9 beta 1   for e g        documentation site headers          verbose    like   normal   fully explicit  e g   0 9 final   for       tag commit messages  anywhere important remove ambiguity       branch first final release within branch             returns  dict             oserror occurs unix derived platforms lacking popen configured shell    default   bin sh  e g  android     setup    branch    short    normal    verbose ", "content": "\"\"\"\nCurrent Fabric version constant plus version pretty-print method.\n\nThis functionality is contained in its own module to prevent circular import\nproblems with ``__init__.py`` (which is loaded by setup.py during installation,\nwhich in turn needs access to this version information.)\n\"\"\"\nfrom subprocess import Popen, PIPE\nfrom os.path import abspath, dirname\n\n\nVERSION = (1, 14, 0, 'final', 0)\n\n\ndef git_sha():\n    loc = abspath(dirname(__file__))\n    try:\n        p = Popen(\n            \"cd \\\"%s\\\" && git log -1 --format=format:%%h\" % loc,\n            shell=True,\n            stdout=PIPE,\n            stderr=PIPE\n        )\n        return p.communicate()[0]\n    # OSError occurs on Unix-derived platforms lacking Popen's configured shell\n    # default, /bin/sh. E.g. Android.\n    except OSError:\n        return None\n\n\ndef get_version(form='short'):\n    \"\"\"\n    Return a version string for this package, based on `VERSION`.\n\n    Takes a single argument, ``form``, which should be one of the following\n    strings:\n\n    * ``branch``: just the major + minor, e.g. \"0.9\", \"1.0\".\n    * ``short`` (default): compact, e.g. \"0.9rc1\", \"0.9.0\". For package\n      filenames or SCM tag identifiers.\n    * ``normal``: human readable, e.g. \"0.9\", \"0.9.1\", \"0.9 beta 1\". For e.g.\n      documentation site headers.\n    * ``verbose``: like ``normal`` but fully explicit, e.g. \"0.9 final\". For\n      tag commit messages, or anywhere that it's important to remove ambiguity\n      between a branch and the first final release within that branch.\n    * ``all``: Returns all of the above, as a dict.\n    \"\"\"\n    # Setup\n    versions = {}\n    branch = \"%s.%s\" % (VERSION[0], VERSION[1])\n    tertiary = VERSION[2]\n    type_ = VERSION[3]\n    final = (type_ == \"final\")\n    type_num = VERSION[4]\n    firsts = \"\".join([x[0] for x in type_.split()])\n\n    # Branch\n    versions['branch'] = branch\n\n    # Short\n    v = branch\n    if (tertiary or final):\n        v += \".\" + str(tertiary)\n    if not final:\n        v += firsts\n        if type_num:\n            v += str(type_num)\n    versions['short'] = v\n\n    # Normal\n    v = branch\n    if tertiary:\n        v += \".\" + str(tertiary)\n    if not final:\n        if type_num:\n            v += \" \" + type_ + \" \" + str(type_num)\n        else:\n            v += \" pre-\" + type_\n    versions['normal'] = v\n\n    # Verbose\n    v = branch\n    if tertiary:\n        v += \".\" + str(tertiary)\n    if not final:\n        if type_num:\n            v += \" \" + type_ + \" \" + str(type_num)\n        else:\n            v += \" pre-\" + type_\n    else:\n        v += \" final\"\n    versions['verbose'] = v\n\n    try:\n        return versions[form]\n    except KeyError:\n        if form == 'all':\n            return versions\n        raise TypeError('\"%s\" is not a valid form specifier.' % form)\n\n__version__ = get_version('short')\n\nif __name__ == \"__main__\":\n    print(get_version('all'))\n", "description": "Simple, Pythonic remote execution and deployment.", "file_name": "version.py", "id": "9c878e5204a8530213424439817373b3", "language": "Python", "project_name": "fabric", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/fabric-fabric/fabric-fabric-245402e/fabric/version.py", "save_time": "", "source": "", "update_at": "2018-03-13T12:02:14Z", "url": "https://github.com/fabric/fabric", "wiki": false}