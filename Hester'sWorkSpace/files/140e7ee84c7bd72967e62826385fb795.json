{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom collections import Counter\nfrom datetime import datetime\n\nfrom odoo import api, fields, models, _\nfrom odoo.addons import decimal_precision as dp\nfrom odoo.exceptions import UserError, ValidationError\nfrom odoo.tools import float_compare, float_round\n\nclass MrpProductProduce(models.TransientModel):\n    _name = \"mrp.product.produce\"\n    _description = \"Record Production\"\n\n    @api.model\n    def default_get(self, fields):\n        res = super(MrpProductProduce, self).default_get(fields)\n        if self._context and self._context.get('active_id'):\n            production = self.env['mrp.production'].browse(self._context['active_id'])\n            serial_finished = (production.product_id.tracking == 'serial')\n            if serial_finished:\n                todo_quantity = 1.0\n            else:\n                main_product_moves = production.move_finished_ids.filtered(lambda x: x.product_id.id == production.product_id.id)\n                todo_quantity = production.product_qty - sum(main_product_moves.mapped('quantity_done'))\n                todo_quantity = todo_quantity if (todo_quantity > 0) else 0\n            if 'production_id' in fields:\n                res['production_id'] = production.id\n            if 'product_id' in fields:\n                res['product_id'] = production.product_id.id\n            if 'product_uom_id' in fields:\n                res['product_uom_id'] = production.product_uom_id.id\n            if 'serial' in fields:\n                res['serial'] = bool(serial_finished)\n            if 'product_qty' in fields:\n                res['product_qty'] = todo_quantity\n            if 'produce_line_ids' in fields:\n                lines = []\n                for move in production.move_raw_ids.filtered(lambda x: (x.product_id.tracking != 'none') and x.state not in ('done', 'cancel') and x.bom_line_id):\n                    qty_to_consume = todo_quantity / move.bom_line_id.bom_id.product_qty * move.bom_line_id.product_qty\n                    for move_line in move.move_line_ids:\n                        if float_compare(qty_to_consume, 0.0, precision_rounding=move.product_uom.rounding) <= 0:\n                            break\n                        if move_line.lot_produced_id or float_compare(move_line.product_uom_qty, move_line.qty_done, precision_rounding=move.product_uom.rounding) <= 0:\n                            continue\n                        to_consume_in_line = min(qty_to_consume, move_line.product_uom_qty)\n                        lines.append({\n                            'move_id': move.id,\n                            'qty_to_consume': to_consume_in_line,\n                            'qty_done': 0.0,\n                            'lot_id': move_line.lot_id.id,\n                            'product_uom_id': move.product_uom.id,\n                            'product_id': move.product_id.id,\n                        })\n                        qty_to_consume -= to_consume_in_line\n                    if float_compare(qty_to_consume, 0.0, precision_rounding=move.product_uom.rounding) > 0:\n                        if move.product_id.tracking == 'serial':\n                            while float_compare(qty_to_consume, 0.0, precision_rounding=move.product_uom.rounding) > 0:\n                                lines.append({\n                                    'move_id': move.id,\n                                    'qty_to_consume': 1,\n                                    'qty_done': 0.0,\n                                    'product_uom_id': move.product_uom.id,\n                                    'product_id': move.product_id.id,\n                                })\n                                qty_to_consume -= 1\n                        else:\n                            lines.append({\n                                'move_id': move.id,\n                                'qty_to_consume': qty_to_consume,\n                                'qty_done': 0.0,\n                                'product_uom_id': move.product_uom.id,\n                                'product_id': move.product_id.id,\n                            })\n\n                res['produce_line_ids'] = [(0, 0, x) for x in lines]\n        return res\n\n    serial = fields.Boolean('Requires Serial')\n    production_id = fields.Many2one('mrp.production', 'Production')\n    product_id = fields.Many2one('product.product', 'Product')\n    product_qty = fields.Float(string='Quantity', digits=dp.get_precision('Product Unit of Measure'), required=True)\n    product_uom_id = fields.Many2one('product.uom', 'Unit of Measure')\n    lot_id = fields.Many2one('stock.production.lot', string='Lot')\n    produce_line_ids = fields.One2many('mrp.product.produce.line', 'product_produce_id', string='Product to Track')\n    product_tracking = fields.Selection(related=\"product_id.tracking\")\n\n    @api.multi\n    def do_produce(self):\n        # Nothing to do for lots since values are created using default data (stock.move.lots)\n        quantity = self.product_qty\n        if float_compare(quantity, 0, precision_rounding=self.product_uom_id.rounding) <= 0:\n            raise UserError(_(\"The production order for '%s' has no quantity specified\") % self.product_id.display_name)\n        for move in self.production_id.move_raw_ids:\n            \n            if move.product_id.tracking == 'none' and move.state not in ('done', 'cancel') and move.unit_factor:\n                rounding = move.product_uom.rounding\n                if self.product_id.tracking != 'none':\n                    qty_to_add = float_round(quantity * move.unit_factor, precision_rounding=rounding)\n                    move._generate_consumed_move_line(qty_to_add, self.lot_id)\n                else:\n                    move.quantity_done += float_round(quantity * move.unit_factor, precision_rounding=rounding)\n        for move in self.production_id.move_finished_ids:\n            if move.product_id.tracking == 'none' and move.state not in ('done', 'cancel'):\n                rounding = move.product_uom.rounding\n                if move.product_id.id == self.production_id.product_id.id:\n                    move.quantity_done += float_round(quantity, precision_rounding=rounding)\n                elif move.unit_factor:\n                    \n                    move.quantity_done += float_round(quantity * move.unit_factor, precision_rounding=rounding)\n        self.check_finished_move_lots()\n        if self.production_id.state == 'confirmed':\n            self.production_id.write({\n                'state': 'progress',\n                'date_start': datetime.now(),\n            })\n        return {'type': 'ir.actions.act_window_close'}\n\n    @api.multi\n    def check_finished_move_lots(self):\n        produce_move = self.production_id.move_finished_ids.filtered(lambda x: x.product_id == self.product_id and x.state not in ('done', 'cancel'))\n        if produce_move and produce_move.product_id.tracking != 'none':\n            if not self.lot_id:\n                raise UserError(_('You need to provide a lot for the finished product'))\n            existing_move_line = produce_move.move_line_ids.filtered(lambda x: x.lot_id == self.lot_id)\n            if existing_move_line:\n                if self.product_id.tracking == 'serial':\n                    raise UserError(_('You cannot produce the same serial number twice.'))\n                existing_move_line.product_uom_qty += self.product_qty\n                existing_move_line.qty_done += self.product_qty\n            else:\n                vals = {\n                  'move_id': produce_move.id,\n                  'product_id': produce_move.product_id.id,\n                  'production_id': self.production_id.id,\n                  'product_uom_qty': self.product_qty,\n                  'product_uom_id': produce_move.product_uom.id,\n                  'qty_done': self.product_qty,\n                  'lot_id': self.lot_id.id,\n                  'location_id': produce_move.location_id.id,\n                  'location_dest_id': produce_move.location_dest_id.id,\n                }\n                self.env['stock.move.line'].create(vals)\n\n        for pl in self.produce_line_ids:\n            if pl.qty_done:\n                if not pl.lot_id:\n                    raise UserError(_('Please enter a lot or serial number for %s !' % pl.product_id.name))\n                if not pl.move_id:\n                    \n                    move_id = self.production_id.move_raw_ids.filtered(lambda x: x.product_id == pl.product_id and x.state not in ('done', 'cancel'))\n                    if move_id:\n                        pl.move_id = move_id\n                    else:\n                        \n                        order = self.production_id\n                        pl.move_id = self.env['stock.move'].create({\n                                    'name': order.name,\n                                    'product_id': pl.product_id.id,\n                                    'product_uom': pl.product_uom_id.id,\n                                    'location_id': order.location_src_id.id,\n                                    'location_dest_id': self.product_id.property_stock_production.id,\n                                    'raw_material_production_id': order.id,\n                                    'group_id': order.procurement_group_id.id,\n                                    'origin': order.name,\n                                    'state': 'confirmed'})\n                pl.move_id._generate_consumed_move_line(pl.qty_done, self.lot_id, lot=pl.lot_id)\n        return True\n\n\nclass MrpProductProduceLine(models.TransientModel):\n    _name = \"mrp.product.produce.line\"\n    _description = \"Record Production Line\"\n\n    product_produce_id = fields.Many2one('mrp.product.produce')\n    product_id = fields.Many2one('product.product', 'Product')\n    lot_id = fields.Many2one('stock.production.lot', 'Lot')\n    qty_to_consume = fields.Float('To Consume')\n    product_uom_id = fields.Many2one('product.uom', 'Unit of Measure')\n    qty_done = fields.Float('Done')\n    move_id = fields.Many2one('stock.move')\n\n    @api.onchange('lot_id')\n    def _onchange_lot_id(self):\n        \"\"\" When the user is encoding a produce line for a tracked product, we apply some logic to\n        help him. This onchange will automatically switch `qty_done` to 1.0.\n        \"\"\"\n        res = {}\n        if self.product_id.tracking == 'serial':\n            self.qty_done = 1\n        return res\n\n    @api.onchange('qty_done')\n    def _onchange_qty_done(self):\n        \"\"\" When the user is encoding a produce line for a tracked product, we apply some logic to\n        help him. This onchange will warn him if he set `qty_done` to a non-supported value.\n        \"\"\"\n        res = {}\n        if self.product_id.tracking == 'serial':\n            if float_compare(self.qty_done, 1.0, precision_rounding=self.move_id.product_id.uom_id.rounding) != 0:\n                message = _('You can only process 1.0 %s for products with unique serial number.') % self.product_id.uom_id.name\n                res['warning'] = {'title': _('Warning'), 'message': message}\n        return res\n\n    @api.onchange('product_id')\n    def _onchange_product_id(self):\n        self.product_uom_id = self.product_id.uom_id.id\n", "comments": "    when user encoding produce line tracked product  apply logic         help  this onchange automatically switch  qty done  1 0                      res              self product id tracking     serial               self qty done   1         return res       api onchange( qty done )     def  onchange qty done(self)              when user encoding produce line tracked product  apply logic         help  this onchange warn set  qty done  non supported value                     coding  utf 8        part odoo  see license file full copyright licensing details     nothing lots since values created using default data (stock move lots)    todo currently possible guess user updated quantity hand automatically produce wizard     byproducts handling    find move id would match    create move put ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom collections import Counter\nfrom datetime import datetime\n\nfrom odoo import api, fields, models, _\nfrom odoo.addons import decimal_precision as dp\nfrom odoo.exceptions import UserError, ValidationError\nfrom odoo.tools import float_compare, float_round\n\nclass MrpProductProduce(models.TransientModel):\n    _name = \"mrp.product.produce\"\n    _description = \"Record Production\"\n\n    @api.model\n    def default_get(self, fields):\n        res = super(MrpProductProduce, self).default_get(fields)\n        if self._context and self._context.get('active_id'):\n            production = self.env['mrp.production'].browse(self._context['active_id'])\n            serial_finished = (production.product_id.tracking == 'serial')\n            if serial_finished:\n                todo_quantity = 1.0\n            else:\n                main_product_moves = production.move_finished_ids.filtered(lambda x: x.product_id.id == production.product_id.id)\n                todo_quantity = production.product_qty - sum(main_product_moves.mapped('quantity_done'))\n                todo_quantity = todo_quantity if (todo_quantity > 0) else 0\n            if 'production_id' in fields:\n                res['production_id'] = production.id\n            if 'product_id' in fields:\n                res['product_id'] = production.product_id.id\n            if 'product_uom_id' in fields:\n                res['product_uom_id'] = production.product_uom_id.id\n            if 'serial' in fields:\n                res['serial'] = bool(serial_finished)\n            if 'product_qty' in fields:\n                res['product_qty'] = todo_quantity\n            if 'produce_line_ids' in fields:\n                lines = []\n                for move in production.move_raw_ids.filtered(lambda x: (x.product_id.tracking != 'none') and x.state not in ('done', 'cancel') and x.bom_line_id):\n                    qty_to_consume = todo_quantity / move.bom_line_id.bom_id.product_qty * move.bom_line_id.product_qty\n                    for move_line in move.move_line_ids:\n                        if float_compare(qty_to_consume, 0.0, precision_rounding=move.product_uom.rounding) <= 0:\n                            break\n                        if move_line.lot_produced_id or float_compare(move_line.product_uom_qty, move_line.qty_done, precision_rounding=move.product_uom.rounding) <= 0:\n                            continue\n                        to_consume_in_line = min(qty_to_consume, move_line.product_uom_qty)\n                        lines.append({\n                            'move_id': move.id,\n                            'qty_to_consume': to_consume_in_line,\n                            'qty_done': 0.0,\n                            'lot_id': move_line.lot_id.id,\n                            'product_uom_id': move.product_uom.id,\n                            'product_id': move.product_id.id,\n                        })\n                        qty_to_consume -= to_consume_in_line\n                    if float_compare(qty_to_consume, 0.0, precision_rounding=move.product_uom.rounding) > 0:\n                        if move.product_id.tracking == 'serial':\n                            while float_compare(qty_to_consume, 0.0, precision_rounding=move.product_uom.rounding) > 0:\n                                lines.append({\n                                    'move_id': move.id,\n                                    'qty_to_consume': 1,\n                                    'qty_done': 0.0,\n                                    'product_uom_id': move.product_uom.id,\n                                    'product_id': move.product_id.id,\n                                })\n                                qty_to_consume -= 1\n                        else:\n                            lines.append({\n                                'move_id': move.id,\n                                'qty_to_consume': qty_to_consume,\n                                'qty_done': 0.0,\n                                'product_uom_id': move.product_uom.id,\n                                'product_id': move.product_id.id,\n                            })\n\n                res['produce_line_ids'] = [(0, 0, x) for x in lines]\n        return res\n\n    serial = fields.Boolean('Requires Serial')\n    production_id = fields.Many2one('mrp.production', 'Production')\n    product_id = fields.Many2one('product.product', 'Product')\n    product_qty = fields.Float(string='Quantity', digits=dp.get_precision('Product Unit of Measure'), required=True)\n    product_uom_id = fields.Many2one('product.uom', 'Unit of Measure')\n    lot_id = fields.Many2one('stock.production.lot', string='Lot')\n    produce_line_ids = fields.One2many('mrp.product.produce.line', 'product_produce_id', string='Product to Track')\n    product_tracking = fields.Selection(related=\"product_id.tracking\")\n\n    @api.multi\n    def do_produce(self):\n        # Nothing to do for lots since values are created using default data (stock.move.lots)\n        quantity = self.product_qty\n        if float_compare(quantity, 0, precision_rounding=self.product_uom_id.rounding) <= 0:\n            raise UserError(_(\"The production order for '%s' has no quantity specified\") % self.product_id.display_name)\n        for move in self.production_id.move_raw_ids:\n            # TODO currently not possible to guess if the user updated quantity by hand or automatically by the produce wizard.\n            if move.product_id.tracking == 'none' and move.state not in ('done', 'cancel') and move.unit_factor:\n                rounding = move.product_uom.rounding\n                if self.product_id.tracking != 'none':\n                    qty_to_add = float_round(quantity * move.unit_factor, precision_rounding=rounding)\n                    move._generate_consumed_move_line(qty_to_add, self.lot_id)\n                else:\n                    move.quantity_done += float_round(quantity * move.unit_factor, precision_rounding=rounding)\n        for move in self.production_id.move_finished_ids:\n            if move.product_id.tracking == 'none' and move.state not in ('done', 'cancel'):\n                rounding = move.product_uom.rounding\n                if move.product_id.id == self.production_id.product_id.id:\n                    move.quantity_done += float_round(quantity, precision_rounding=rounding)\n                elif move.unit_factor:\n                    # byproducts handling\n                    move.quantity_done += float_round(quantity * move.unit_factor, precision_rounding=rounding)\n        self.check_finished_move_lots()\n        if self.production_id.state == 'confirmed':\n            self.production_id.write({\n                'state': 'progress',\n                'date_start': datetime.now(),\n            })\n        return {'type': 'ir.actions.act_window_close'}\n\n    @api.multi\n    def check_finished_move_lots(self):\n        produce_move = self.production_id.move_finished_ids.filtered(lambda x: x.product_id == self.product_id and x.state not in ('done', 'cancel'))\n        if produce_move and produce_move.product_id.tracking != 'none':\n            if not self.lot_id:\n                raise UserError(_('You need to provide a lot for the finished product'))\n            existing_move_line = produce_move.move_line_ids.filtered(lambda x: x.lot_id == self.lot_id)\n            if existing_move_line:\n                if self.product_id.tracking == 'serial':\n                    raise UserError(_('You cannot produce the same serial number twice.'))\n                existing_move_line.product_uom_qty += self.product_qty\n                existing_move_line.qty_done += self.product_qty\n            else:\n                vals = {\n                  'move_id': produce_move.id,\n                  'product_id': produce_move.product_id.id,\n                  'production_id': self.production_id.id,\n                  'product_uom_qty': self.product_qty,\n                  'product_uom_id': produce_move.product_uom.id,\n                  'qty_done': self.product_qty,\n                  'lot_id': self.lot_id.id,\n                  'location_id': produce_move.location_id.id,\n                  'location_dest_id': produce_move.location_dest_id.id,\n                }\n                self.env['stock.move.line'].create(vals)\n\n        for pl in self.produce_line_ids:\n            if pl.qty_done:\n                if not pl.lot_id:\n                    raise UserError(_('Please enter a lot or serial number for %s !' % pl.product_id.name))\n                if not pl.move_id:\n                    # Find move_id that would match\n                    move_id = self.production_id.move_raw_ids.filtered(lambda x: x.product_id == pl.product_id and x.state not in ('done', 'cancel'))\n                    if move_id:\n                        pl.move_id = move_id\n                    else:\n                        # create a move and put it in there\n                        order = self.production_id\n                        pl.move_id = self.env['stock.move'].create({\n                                    'name': order.name,\n                                    'product_id': pl.product_id.id,\n                                    'product_uom': pl.product_uom_id.id,\n                                    'location_id': order.location_src_id.id,\n                                    'location_dest_id': self.product_id.property_stock_production.id,\n                                    'raw_material_production_id': order.id,\n                                    'group_id': order.procurement_group_id.id,\n                                    'origin': order.name,\n                                    'state': 'confirmed'})\n                pl.move_id._generate_consumed_move_line(pl.qty_done, self.lot_id, lot=pl.lot_id)\n        return True\n\n\nclass MrpProductProduceLine(models.TransientModel):\n    _name = \"mrp.product.produce.line\"\n    _description = \"Record Production Line\"\n\n    product_produce_id = fields.Many2one('mrp.product.produce')\n    product_id = fields.Many2one('product.product', 'Product')\n    lot_id = fields.Many2one('stock.production.lot', 'Lot')\n    qty_to_consume = fields.Float('To Consume')\n    product_uom_id = fields.Many2one('product.uom', 'Unit of Measure')\n    qty_done = fields.Float('Done')\n    move_id = fields.Many2one('stock.move')\n\n    @api.onchange('lot_id')\n    def _onchange_lot_id(self):\n        \"\"\" When the user is encoding a produce line for a tracked product, we apply some logic to\n        help him. This onchange will automatically switch `qty_done` to 1.0.\n        \"\"\"\n        res = {}\n        if self.product_id.tracking == 'serial':\n            self.qty_done = 1\n        return res\n\n    @api.onchange('qty_done')\n    def _onchange_qty_done(self):\n        \"\"\" When the user is encoding a produce line for a tracked product, we apply some logic to\n        help him. This onchange will warn him if he set `qty_done` to a non-supported value.\n        \"\"\"\n        res = {}\n        if self.product_id.tracking == 'serial':\n            if float_compare(self.qty_done, 1.0, precision_rounding=self.move_id.product_id.uom_id.rounding) != 0:\n                message = _('You can only process 1.0 %s for products with unique serial number.') % self.product_id.uom_id.name\n                res['warning'] = {'title': _('Warning'), 'message': message}\n        return res\n\n    @api.onchange('product_id')\n    def _onchange_product_id(self):\n        self.product_uom_id = self.product_id.uom_id.id\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "mrp_product_produce.py", "id": "140e7ee84c7bd72967e62826385fb795", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/mrp/wizard/mrp_product_produce.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}