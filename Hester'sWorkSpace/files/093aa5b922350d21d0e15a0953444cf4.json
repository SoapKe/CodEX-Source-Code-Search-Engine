{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    determine_ext,\n    determine_protocol,\n    parse_duration,\n    int_or_none,\n)\n\n\nclass Lecture2GoIE(InfoExtractor):\n    _VALID_URL = r'https?://lecture2go\\.uni-hamburg\\.de/veranstaltungen/-/v/(?P<id>\\d+)'\n    _TEST = {\n        'url': 'https://lecture2go.uni-hamburg.de/veranstaltungen/-/v/17473',\n        'md5': 'ac02b570883020d208d405d5a3fd2f7f',\n        'info_dict': {\n            'id': '17473',\n            'ext': 'mp4',\n            'title': '2 - Endliche Automaten und regul\u00e4re Sprachen',\n            'creator': 'Frank Heitmann',\n            'duration': 5220,\n        },\n        'params': {\n            \n            'skip_download': True,\n        }\n    }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        webpage = self._download_webpage(url, video_id)\n\n        title = self._html_search_regex(r'<em[^>]+class=\"title\">(.+)</em>', webpage, 'title')\n\n        formats = []\n        for url in set(re.findall(r'var\\s+playerUri\\d+\\s*=\\s*\"([^\"]+)\"', webpage)):\n            ext = determine_ext(url)\n            protocol = determine_protocol({'url': url})\n            if ext == 'f4m':\n                formats.extend(self._extract_f4m_formats(url, video_id, f4m_id='hds'))\n            elif ext == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(url, video_id, ext='mp4', m3u8_id='hls'))\n            else:\n                if protocol == 'rtmp':\n                    continue  \n                formats.append({\n                    'format_id': protocol,\n                    'url': url,\n                })\n\n        self._sort_formats(formats)\n\n        creator = self._html_search_regex(\n            r'<div[^>]+id=\"description\">([^<]+)</div>', webpage, 'creator', fatal=False)\n        duration = parse_duration(self._html_search_regex(\n            r'Duration:\\s*</em>\\s*<em[^>]*>([^<]+)</em>', webpage, 'duration', fatal=False))\n        view_count = int_or_none(self._html_search_regex(\n            r'Views:\\s*</em>\\s*<em[^>]+>(\\d+)</em>', webpage, 'view count', fatal=False))\n\n        return {\n            'id': video_id,\n            'title': title,\n            'formats': formats,\n            'creator': creator,\n            'duration': duration,\n            'view_count': view_count,\n        }\n", "comments": "# coding: utf-8\n# m3u8 download\n# XXX: currently broken\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    determine_ext,\n    determine_protocol,\n    parse_duration,\n    int_or_none,\n)\n\n\nclass Lecture2GoIE(InfoExtractor):\n    _VALID_URL = r'https?://lecture2go\\.uni-hamburg\\.de/veranstaltungen/-/v/(?P<id>\\d+)'\n    _TEST = {\n        'url': 'https://lecture2go.uni-hamburg.de/veranstaltungen/-/v/17473',\n        'md5': 'ac02b570883020d208d405d5a3fd2f7f',\n        'info_dict': {\n            'id': '17473',\n            'ext': 'mp4',\n            'title': '2 - Endliche Automaten und regul\u00e4re Sprachen',\n            'creator': 'Frank Heitmann',\n            'duration': 5220,\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        }\n    }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        webpage = self._download_webpage(url, video_id)\n\n        title = self._html_search_regex(r'<em[^>]+class=\"title\">(.+)</em>', webpage, 'title')\n\n        formats = []\n        for url in set(re.findall(r'var\\s+playerUri\\d+\\s*=\\s*\"([^\"]+)\"', webpage)):\n            ext = determine_ext(url)\n            protocol = determine_protocol({'url': url})\n            if ext == 'f4m':\n                formats.extend(self._extract_f4m_formats(url, video_id, f4m_id='hds'))\n            elif ext == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(url, video_id, ext='mp4', m3u8_id='hls'))\n            else:\n                if protocol == 'rtmp':\n                    continue  # XXX: currently broken\n                formats.append({\n                    'format_id': protocol,\n                    'url': url,\n                })\n\n        self._sort_formats(formats)\n\n        creator = self._html_search_regex(\n            r'<div[^>]+id=\"description\">([^<]+)</div>', webpage, 'creator', fatal=False)\n        duration = parse_duration(self._html_search_regex(\n            r'Duration:\\s*</em>\\s*<em[^>]*>([^<]+)</em>', webpage, 'duration', fatal=False))\n        view_count = int_or_none(self._html_search_regex(\n            r'Views:\\s*</em>\\s*<em[^>]+>(\\d+)</em>', webpage, 'view count', fatal=False))\n\n        return {\n            'id': video_id,\n            'title': title,\n            'formats': formats,\n            'creator': creator,\n            'duration': duration,\n            'view_count': view_count,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "lecture2go.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/lecture2go.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}