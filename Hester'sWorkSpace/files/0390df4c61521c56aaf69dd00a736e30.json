{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\nimport json\nimport zlib\n\nfrom hashlib import sha1\nfrom math import pow, sqrt, floor\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urllib_parse_urlencode,\n    compat_urllib_request,\n    compat_urlparse,\n)\nfrom ..utils import (\n    ExtractorError,\n    bytes_to_intlist,\n    intlist_to_bytes,\n    int_or_none,\n    lowercase_escape,\n    remove_end,\n    sanitized_Request,\n    unified_strdate,\n    urlencode_postdata,\n    xpath_text,\n    extract_attributes,\n)\nfrom ..aes import (\n    aes_cbc_decrypt,\n)\n\n\nclass CrunchyrollBaseIE(InfoExtractor):\n    _LOGIN_URL = 'https://www.crunchyroll.com/login'\n    _LOGIN_FORM = 'login_form'\n    _NETRC_MACHINE = 'crunchyroll'\n\n    def _call_rpc_api(self, method, video_id, note=None, data=None):\n        data = data or {}\n        data['req'] = 'RpcApi' + method\n        data = compat_urllib_parse_urlencode(data).encode('utf-8')\n        return self._download_xml(\n            'http://www.crunchyroll.com/xml/',\n            video_id, note, fatal=False, data=data, headers={\n                'Content-Type': 'application/x-www-form-urlencoded',\n            })\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n\n        self._download_webpage(\n            'https://www.crunchyroll.com/?a=formhandler',\n            None, 'Logging in', 'Wrong login info',\n            data=urlencode_postdata({\n                'formname': 'RpcApiUser_Login',\n                'next_url': 'https://www.crunchyroll.com/acct/membership',\n                'name': username,\n                'password': password,\n            }))\n\n        \n\n    def _real_initialize(self):\n        self._login()\n\n    def _download_webpage(self, url_or_request, *args, **kwargs):\n        request = (url_or_request if isinstance(url_or_request, compat_urllib_request.Request)\n                   else sanitized_Request(url_or_request))\n        \n        \n        \n        \n        \n        \n        \n        request.add_header('Accept-Language', '*')\n        return super(CrunchyrollBaseIE, self)._download_webpage(request, *args, **kwargs)\n\n    @staticmethod\n    def _add_skip_wall(url):\n        parsed_url = compat_urlparse.urlparse(url)\n        qs = compat_urlparse.parse_qs(parsed_url.query)\n        \n        \n        \n        \n        \n        qs['skip_wall'] = ['1']\n        return compat_urlparse.urlunparse(\n            parsed_url._replace(query=compat_urllib_parse_urlencode(qs, True)))\n\n\nclass CrunchyrollIE(CrunchyrollBaseIE):\n    _VALID_URL = r'https?://(?:(?P<prefix>www|m)\\.)?(?P<url>crunchyroll\\.(?:com|fr)/(?:media(?:-|/\\?id=)|[^/]*/[^/?&]*?)(?P<video_id>[0-9]+))(?:[/?&]|$)'\n    _TESTS = [{\n        'url': 'http://www.crunchyroll.com/wanna-be-the-strongest-in-the-world/episode-1-an-idol-wrestler-is-born-645513',\n        'info_dict': {\n            'id': '645513',\n            'ext': 'mp4',\n            'title': 'Wanna be the Strongest in the World Episode 1 \u2013 An Idol-Wrestler is Born!',\n            'description': 'md5:2d17137920c64f2f49981a7797d275ef',\n            'thumbnail': 'http://img1.ak.crunchyroll.com/i/spire1-tmb/20c6b5e10f1a47b10516877d3c039cae1380951166_full.jpg',\n            'uploader': 'Yomiuri Telecasting Corporation (YTV)',\n            'upload_date': '20131013',\n            'url': 're:(?!.*&amp)',\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }, {\n        'url': 'http://www.crunchyroll.com/media-589804/culture-japan-1',\n        'info_dict': {\n            'id': '589804',\n            'ext': 'flv',\n            'title': 'Culture Japan Episode 1 \u2013 Rebuilding Japan after the 3.11',\n            'description': 'md5:2fbc01f90b87e8e9137296f37b461c12',\n            'thumbnail': r're:^https?://.*\\.jpg$',\n            'uploader': 'Danny Choo Network',\n            'upload_date': '20120213',\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n        'skip': 'Video gone',\n    }, {\n        'url': 'http://www.crunchyroll.com/rezero-starting-life-in-another-world-/episode-5-the-morning-of-our-promise-is-still-distant-702409',\n        'info_dict': {\n            'id': '702409',\n            'ext': 'mp4',\n            'title': 'Re:ZERO -Starting Life in Another World- Episode 5 \u2013 The Morning of Our Promise Is Still Distant',\n            'description': 'md5:97664de1ab24bbf77a9c01918cb7dca9',\n            'thumbnail': r're:^https?://.*\\.jpg$',\n            'uploader': 'TV TOKYO',\n            'upload_date': '20160508',\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }, {\n        'url': 'http://www.crunchyroll.com/konosuba-gods-blessing-on-this-wonderful-world/episode-1-give-me-deliverance-from-this-judicial-injustice-727589',\n        'info_dict': {\n            'id': '727589',\n            'ext': 'mp4',\n            'title': \"KONOSUBA -God's blessing on this wonderful world! 2 Episode 1 \u2013 Give Me Deliverance From This Judicial Injustice!\",\n            'description': 'md5:cbcf05e528124b0f3a0a419fc805ea7d',\n            'thumbnail': r're:^https?://.*\\.jpg$',\n            'uploader': 'Kadokawa Pictures Inc.',\n            'upload_date': '20170118',\n            'series': \"KONOSUBA -God's blessing on this wonderful world!\",\n            'season': \"KONOSUBA -God's blessing on this wonderful world! 2\",\n            'season_number': 2,\n            'episode': 'Give Me Deliverance From This Judicial Injustice!',\n            'episode_number': 1,\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }, {\n        'url': 'http://www.crunchyroll.fr/girl-friend-beta/episode-11-goodbye-la-mode-661697',\n        'only_matching': True,\n    }, {\n        \n        'url': 'http://www.crunchyroll.com/cosplay-complex-ova/episode-1-the-birth-of-the-cosplay-club-565617',\n        'only_matching': True,\n    }, {\n        \n        'url': 'http://www.crunchyroll.com/11eyes/episode-1-piros-jszaka-red-night-535080',\n        'info_dict': {\n            'id': '535080',\n            'ext': 'mp4',\n            'title': '11eyes Episode 1 \u2013 Piros \u00e9jszaka - Red Night',\n            'description': 'Kakeru and Yuka are thrown into an alternate nightmarish world they call \"Red Night\".',\n            'uploader': 'Marvelous AQL Inc.',\n            'upload_date': '20091021',\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }, {\n        \n        'url': 'http://www.crunchyroll.com/hakuoki-reimeiroku/episode-1-dawn-of-the-divine-warriors-606899',\n        'info_dict': {\n            'id': '606899',\n            'ext': 'mp4',\n            'title': 'Hakuoki Reimeiroku Episode 1 \u2013 Dawn of the Divine Warriors',\n            'description': 'Ryunosuke was left to die, but Serizawa-san asked him a simple question \"Do you want to live?\"',\n            'uploader': 'Geneon Entertainment',\n            'upload_date': '20120717',\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }, {\n        \n        'url': 'http://www.crunchyroll.com/nyarko-san-another-crawling-chaos/episode-1-test-590532',\n        'info_dict': {\n            'id': '590532',\n            'ext': 'mp4',\n            'title': 'Haiyoru! Nyaruani (ONA) Episode 1 \u2013 Test',\n            'description': 'Mahiro and Nyaruko talk about official certification.',\n            'uploader': 'TV TOKYO',\n            'upload_date': '20120305',\n            'series': 'Nyarko-san: Another Crawling Chaos',\n            'season': 'Haiyoru! Nyaruani (ONA)',\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }]\n\n    _FORMAT_IDS = {\n        '360': ('60', '106'),\n        '480': ('61', '106'),\n        '720': ('62', '106'),\n        '1080': ('80', '108'),\n    }\n\n    def _decrypt_subtitles(self, data, iv, id):\n        data = bytes_to_intlist(compat_b64decode(data))\n        iv = bytes_to_intlist(compat_b64decode(iv))\n        id = int(id)\n\n        def obfuscate_key_aux(count, modulo, start):\n            output = list(start)\n            for _ in range(count):\n                output.append(output[-1] + output[-2])\n            \n            output = output[2:]\n            output = list(map(lambda x: x % modulo + 33, output))\n            return output\n\n        def obfuscate_key(key):\n            num1 = int(floor(pow(2, 25) * sqrt(6.9)))\n            num2 = (num1 ^ key) << 5\n            num3 = key ^ num1\n            num4 = num3 ^ (num3 >> 3) ^ num2\n            prefix = intlist_to_bytes(obfuscate_key_aux(20, 97, (1, 2)))\n            shaHash = bytes_to_intlist(sha1(prefix + str(num4).encode('ascii')).digest())\n            \n            return shaHash + [0] * 12\n\n        key = obfuscate_key(id)\n\n        decrypted_data = intlist_to_bytes(aes_cbc_decrypt(data, key, iv))\n        return zlib.decompress(decrypted_data)\n\n    def _convert_subtitles_to_srt(self, sub_root):\n        output = ''\n\n        for i, event in enumerate(sub_root.findall('./events/event'), 1):\n            start = event.attrib['start'].replace('.', ',')\n            end = event.attrib['end'].replace('.', ',')\n            text = event.attrib['text'].replace('\\\\N', '\\n')\n            output += '%d\\n%s --> %s\\n%s\\n\\n' % (i, start, end, text)\n        return output\n\n    def _convert_subtitles_to_ass(self, sub_root):\n        output = ''\n\n        def ass_bool(strvalue):\n            assvalue = '0'\n            if strvalue == '1':\n                assvalue = '-1'\n            return assvalue\n\n        output = '[Script Info]\\n'\n        output += 'Title: %s\\n' % sub_root.attrib['title']\n        output += 'ScriptType: v4.00+\\n'\n        output += 'WrapStyle: %s\\n' % sub_root.attrib['wrap_style']\n        output += 'PlayResX: %s\\n' % sub_root.attrib['play_res_x']\n        output += 'PlayResY: %s\\n' % sub_root.attrib['play_res_y']\n        output += \n        for event in sub_root.findall('./events/event'):\n            output += 'Dialogue: 0'\n            output += ',' + event.attrib['start']\n            output += ',' + event.attrib['end']\n            output += ',' + event.attrib['style']\n            output += ',' + event.attrib['name']\n            output += ',' + event.attrib['margin_l']\n            output += ',' + event.attrib['margin_r']\n            output += ',' + event.attrib['margin_v']\n            output += ',' + event.attrib['effect']\n            output += ',' + event.attrib['text']\n            output += '\\n'\n\n        return output\n\n    def _extract_subtitles(self, subtitle):\n        sub_root = compat_etree_fromstring(subtitle)\n        return [{\n            'ext': 'srt',\n            'data': self._convert_subtitles_to_srt(sub_root),\n        }, {\n            'ext': 'ass',\n            'data': self._convert_subtitles_to_ass(sub_root),\n        }]\n\n    def _get_subtitles(self, video_id, webpage):\n        subtitles = {}\n        for sub_id, sub_name in re.findall(r'\\bssid=([0-9]+)\"[^>]+?\\btitle=\"([^\"]+)', webpage):\n            sub_doc = self._call_rpc_api(\n                'Subtitle_GetXml', video_id,\n                'Downloading subtitles for ' + sub_name, data={\n                    'subtitle_script_id': sub_id,\n                })\n            if sub_doc is None:\n                continue\n            sid = sub_doc.get('id')\n            iv = xpath_text(sub_doc, 'iv', 'subtitle iv')\n            data = xpath_text(sub_doc, 'data', 'subtitle data')\n            if not sid or not iv or not data:\n                continue\n            subtitle = self._decrypt_subtitles(data, iv, sid).decode('utf-8')\n            lang_code = self._search_regex(r'lang_code=[\"\\']([^\"\\']+)', subtitle, 'subtitle_lang_code', fatal=False)\n            if not lang_code:\n                continue\n            subtitles[lang_code] = self._extract_subtitles(subtitle)\n        return subtitles\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        video_id = mobj.group('video_id')\n\n        if mobj.group('prefix') == 'm':\n            mobile_webpage = self._download_webpage(url, video_id, 'Downloading mobile webpage')\n            webpage_url = self._search_regex(r'<link rel=\"canonical\" href=\"([^\"]+)\" />', mobile_webpage, 'webpage_url')\n        else:\n            webpage_url = 'http://www.' + mobj.group('url')\n\n        webpage = self._download_webpage(\n            self._add_skip_wall(webpage_url), video_id,\n            headers=self.geo_verification_headers())\n        note_m = self._html_search_regex(\n            r'<div class=\"showmedia-trailer-notice\">(.+?)</div>',\n            webpage, 'trailer-notice', default='')\n        if note_m:\n            raise ExtractorError(note_m)\n\n        mobj = re.search(r'Page\\.messaging_box_controller\\.addItems\\(\\[(?P<msg>{.+?})\\]\\)', webpage)\n        if mobj:\n            msg = json.loads(mobj.group('msg'))\n            if msg.get('type') == 'error':\n                raise ExtractorError('crunchyroll returned error: %s' % msg['message_body'], expected=True)\n\n        if 'To view this, please log in to verify you are 18 or older.' in webpage:\n            self.raise_login_required()\n\n        video_title = self._html_search_regex(\n            r'(?s)<h1[^>]*>((?:(?!<h1).)*?<span[^>]+itemprop=[\"\\']title[\"\\'][^>]*>(?:(?!<h1).)+?)</h1>',\n            webpage, 'video_title')\n        video_title = re.sub(r' {2,}', ' ', video_title)\n        video_description = self._parse_json(self._html_search_regex(\n            r'<script[^>]*>\\s*.+?\\[media_id=%s\\].+?({.+?\"description\"\\s*:.+?})\\);' % video_id,\n            webpage, 'description', default='{}'), video_id).get('description')\n        if video_description:\n            video_description = lowercase_escape(video_description.replace(r'\\r\\n', '\\n'))\n        video_upload_date = self._html_search_regex(\n            [r'<div>Availability for free users:(.+?)</div>', r'<div>[^<>]+<span>\\s*(.+?\\d{4})\\s*</span></div>'],\n            webpage, 'video_upload_date', fatal=False, flags=re.DOTALL)\n        if video_upload_date:\n            video_upload_date = unified_strdate(video_upload_date)\n        video_uploader = self._html_search_regex(\n            \n            [r'<a[^>]+href=\"/publisher/[^\"]+\"[^>]*>([^<]+)</a>', r'<div>\\s*Publisher:\\s*<span>\\s*(.+?)\\s*</span>\\s*</div>'],\n            webpage, 'video_uploader', fatal=False)\n\n        available_fmts = []\n        for a, fmt in re.findall(r'(<a[^>]+token=[\"\\']showmedia\\.([0-9]{3,4})p[\"\\'][^>]+>)', webpage):\n            attrs = extract_attributes(a)\n            href = attrs.get('href')\n            if href and '/freetrial' in href:\n                continue\n            available_fmts.append(fmt)\n        if not available_fmts:\n            for p in (r'token=[\"\\']showmedia\\.([0-9]{3,4})p\"', r'showmedia\\.([0-9]{3,4})p'):\n                available_fmts = re.findall(p, webpage)\n                if available_fmts:\n                    break\n        video_encode_ids = []\n        formats = []\n        for fmt in available_fmts:\n            stream_quality, stream_format = self._FORMAT_IDS[fmt]\n            video_format = fmt + 'p'\n            stream_infos = []\n            streamdata = self._call_rpc_api(\n                'VideoPlayer_GetStandardConfig', video_id,\n                'Downloading media info for %s' % video_format, data={\n                    'media_id': video_id,\n                    'video_format': stream_format,\n                    'video_quality': stream_quality,\n                    'current_page': url,\n                })\n            if streamdata is not None:\n                stream_info = streamdata.find('./{default}preload/stream_info')\n                if stream_info is not None:\n                    stream_infos.append(stream_info)\n            stream_info = self._call_rpc_api(\n                'VideoEncode_GetStreamInfo', video_id,\n                'Downloading stream info for %s' % video_format, data={\n                    'media_id': video_id,\n                    'video_format': stream_format,\n                    'video_encode_quality': stream_quality,\n                })\n            if stream_info is not None:\n                stream_infos.append(stream_info)\n            for stream_info in stream_infos:\n                video_encode_id = xpath_text(stream_info, './video_encode_id')\n                if video_encode_id in video_encode_ids:\n                    continue\n                video_encode_ids.append(video_encode_id)\n\n                video_file = xpath_text(stream_info, './file')\n                if not video_file:\n                    continue\n                if video_file.startswith('http'):\n                    formats.extend(self._extract_m3u8_formats(\n                        video_file, video_id, 'mp4', entry_protocol='m3u8_native',\n                        m3u8_id='hls', fatal=False))\n                    continue\n\n                video_url = xpath_text(stream_info, './host')\n                if not video_url:\n                    continue\n                metadata = stream_info.find('./metadata')\n                format_info = {\n                    'format': video_format,\n                    'height': int_or_none(xpath_text(metadata, './height')),\n                    'width': int_or_none(xpath_text(metadata, './width')),\n                }\n\n                if '.fplive.net/' in video_url:\n                    video_url = re.sub(r'^rtmpe?://', 'http://', video_url.strip())\n                    parsed_video_url = compat_urlparse.urlparse(video_url)\n                    direct_video_url = compat_urlparse.urlunparse(parsed_video_url._replace(\n                        netloc='v.lvlt.crcdn.net',\n                        path='%s/%s' % (remove_end(parsed_video_url.path, '/'), video_file.split(':')[-1])))\n                    if self._is_valid_url(direct_video_url, video_id, video_format):\n                        format_info.update({\n                            'format_id': 'http-' + video_format,\n                            'url': direct_video_url,\n                        })\n                        formats.append(format_info)\n                        continue\n\n                format_info.update({\n                    'format_id': 'rtmp-' + video_format,\n                    'url': video_url,\n                    'play_path': video_file,\n                    'ext': 'flv',\n                })\n                formats.append(format_info)\n        self._sort_formats(formats, ('height', 'width', 'tbr', 'fps'))\n\n        metadata = self._call_rpc_api(\n            'VideoPlayer_GetMediaMetadata', video_id,\n            note='Downloading media info', data={\n                'media_id': video_id,\n            })\n\n        subtitles = self.extract_subtitles(video_id, webpage)\n\n        \n        series = self._html_search_regex(\n            r'(?s)<h\\d[^>]+\\bid=[\"\\']showmedia_about_episode_num[^>]+>(.+?)</h\\d',\n            webpage, 'series', fatal=False)\n        season = xpath_text(metadata, 'series_title')\n\n        episode = xpath_text(metadata, 'episode_title')\n        episode_number = int_or_none(xpath_text(metadata, 'episode_number'))\n\n        season_number = int_or_none(self._search_regex(\n            r'(?s)<h\\d[^>]+id=[\"\\']showmedia_about_episode_num[^>]+>.+?</h\\d>\\s*<h4>\\s*Season (\\d+)',\n            webpage, 'season number', default=None))\n\n        return {\n            'id': video_id,\n            'title': video_title,\n            'description': video_description,\n            'thumbnail': xpath_text(metadata, 'episode_image_url'),\n            'uploader': video_uploader,\n            'upload_date': video_upload_date,\n            'series': series,\n            'season': season,\n            'season_number': season_number,\n            'episode': episode,\n            'episode_number': episode_number,\n            'subtitles': subtitles,\n            'formats': formats,\n        }\n\n\nclass CrunchyrollShowPlaylistIE(CrunchyrollBaseIE):\n    IE_NAME = 'crunchyroll:playlist'\n    _VALID_URL = r'https?://(?:(?P<prefix>www|m)\\.)?(?P<url>crunchyroll\\.com/(?!(?:news|anime-news|library|forum|launchcalendar|lineup|store|comics|freetrial|login))(?P<id>[\\w\\-]+))/?(?:\\?|$)'\n\n    _TESTS = [{\n        'url': 'http://www.crunchyroll.com/a-bridge-to-the-starry-skies-hoshizora-e-kakaru-hashi',\n        'info_dict': {\n            'id': 'a-bridge-to-the-starry-skies-hoshizora-e-kakaru-hashi',\n            'title': 'A Bridge to the Starry Skies - Hoshizora e Kakaru Hashi'\n        },\n        'playlist_count': 13,\n    }, {\n        \n        'url': 'http://www.crunchyroll.com/cosplay-complex-ova',\n        'info_dict': {\n            'id': 'cosplay-complex-ova',\n            'title': 'Cosplay Complex OVA'\n        },\n        'playlist_count': 3,\n        'skip': 'Georestricted',\n    }, {\n        \n        'url': 'http://www.crunchyroll.com/ladies-versus-butlers?skip_wall=1',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        show_id = self._match_id(url)\n\n        webpage = self._download_webpage(\n            self._add_skip_wall(url), show_id,\n            headers=self.geo_verification_headers())\n        title = self._html_search_regex(\n            r'(?s)<h1[^>]*>\\s*<span itemprop=\"name\">(.*?)</span>',\n            webpage, 'title')\n        episode_paths = re.findall(\n            r'(?s)<li id=\"showview_videos_media_(\\d+)\"[^>]+>.*?<a href=\"([^\"]+)\"',\n            webpage)\n        entries = [\n            self.url_result('http://www.crunchyroll.com' + ep, 'Crunchyroll', ep_id)\n            for ep_id, ep in episode_paths\n        ]\n        entries.reverse()\n\n        return {\n            '_type': 'playlist',\n            'id': show_id,\n            'title': title,\n            'entries': entries,\n        }\n", "comments": "\n[V4+ Styles]\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n\"\"\"\n        for style in sub_root.findall('./styles/style'):\n            output += 'Style: ' + style.attrib['name']\n            output += ',' + style.attrib['font_name']\n            output += ',' + style.attrib['font_size']\n            output += ',' + style.attrib['primary_colour']\n            output += ',' + style.attrib['secondary_colour']\n            output += ',' + style.attrib['outline_colour']\n            output += ',' + style.attrib['back_colour']\n            output += ',' + ass_bool(style.attrib['bold'])\n            output += ',' + ass_bool(style.attrib['italic'])\n            output += ',' + ass_bool(style.attrib['underline'])\n            output += ',' + ass_bool(style.attrib['strikeout'])\n            output += ',' + style.attrib['scale_x']\n            output += ',' + style.attrib['scale_y']\n            output += ',' + style.attrib['spacing']\n            output += ',' + style.attrib['angle']\n            output += ',' + style.attrib['border_style']\n            output += ',' + style.attrib['outline']\n            output += ',' + style.attrib['shadow']\n            output += ',' + style.attrib['alignment']\n            output += ',' + style.attrib['margin_l']\n            output += ',' + style.attrib['margin_r']\n            output += ',' + style.attrib['margin_v']\n            output += ',' + style.attrib['encoding']\n            output += '\\n'\n\n        output += \"\"\"\n[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n\n\n\n\n        login_page = self._download_webpage(\n            self._LOGIN_URL, None, 'Downloading login page')\n\n        def is_logged(webpage):\n            return '<title>Redirecting' in webpage\n\n        # Already logged in\n        if is_logged(login_page):\n            return\n\n        login_form_str = self._search_regex(\n            r'(?P<form><form[^>]+?id=([\"\\'])%s\\2[^>]*>)' % self._LOGIN_FORM,\n            login_page, 'login form', group='form')\n\n        post_url = extract_attributes(login_form_str).get('action')\n        if not post_url:\n            post_url = self._LOGIN_URL\n        elif not post_url.startswith('http'):\n            post_url = compat_urlparse.urljoin(self._LOGIN_URL, post_url)\n\n        login_form = self._form_hidden_inputs(self._LOGIN_FORM, login_page)\n\n        login_form.update({\n            'login_form[name]': username,\n            'login_form[password]': password,\n        })\n\n        response = self._download_webpage(\n            post_url, None, 'Logging in', 'Wrong login info',\n            data=urlencode_postdata(login_form),\n            headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\n        # Successful login\n        if is_logged(response):\n            return\n\n        error = self._html_search_regex(\n            '(?s)<ul[^>]+class=[\"\\']messages[\"\\'][^>]*>(.+?)</ul>',\n            response, 'error message', default=None)\n        if error:\n            raise ExtractorError('Unable to login: %s' % error, expected=True)\n\n        raise ExtractorError('Unable to log in')\n        \n \n# coding: utf-8\n# Accept-Language must be set explicitly to accept any language to avoid issues\n# similar to https://github.com/rg3/youtube-dl/issues/6797.\n# Along with IP address Crunchyroll uses Accept-Language to guess whether georestriction\n# should be imposed or not (from what I can see it just takes the first language\n# ignoring the priority and requires it to correspond the IP). By the way this causes\n# Crunchyroll to not work in georestriction cases in some browsers that don't place\n# the locale lang first in header. However allowing any language seems to workaround the issue.\n# Always force skip_wall to bypass maturity wall, namely 18+ confirmation message:\n# > This content may be inappropriate for some people.\n# > Are you sure you want to continue?\n# since it's not disabled by default in crunchyroll account's settings.\n# See https://github.com/rg3/youtube-dl/issues/7202.\n# rtmp\n# rtmp\n# m3u8 download\n# m3u8 download\n# geo-restricted (US), 18+ maturity wall, non-premium available\n# A description with double quotes\n# Just test metadata extraction\n# make sure we can extract an uploader name that's not a link\n# just test metadata extraction\n# A video with a vastly different season name compared to the series name\n# Just test metadata extraction\n# cut off start values\n# Extend 160 Bit hash to 256 Bit\n# try looking for both an uploader that's a link and one that's not\n# webpage provide more accurate data than series_title from XML\n# geo-restricted (US), 18+ maturity wall, non-premium available\n# geo-restricted (US), 18+ maturity wall, non-premium will be available since 2015.11.14\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\nimport json\nimport zlib\n\nfrom hashlib import sha1\nfrom math import pow, sqrt, floor\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_b64decode,\n    compat_etree_fromstring,\n    compat_urllib_parse_urlencode,\n    compat_urllib_request,\n    compat_urlparse,\n)\nfrom ..utils import (\n    ExtractorError,\n    bytes_to_intlist,\n    intlist_to_bytes,\n    int_or_none,\n    lowercase_escape,\n    remove_end,\n    sanitized_Request,\n    unified_strdate,\n    urlencode_postdata,\n    xpath_text,\n    extract_attributes,\n)\nfrom ..aes import (\n    aes_cbc_decrypt,\n)\n\n\nclass CrunchyrollBaseIE(InfoExtractor):\n    _LOGIN_URL = 'https://www.crunchyroll.com/login'\n    _LOGIN_FORM = 'login_form'\n    _NETRC_MACHINE = 'crunchyroll'\n\n    def _call_rpc_api(self, method, video_id, note=None, data=None):\n        data = data or {}\n        data['req'] = 'RpcApi' + method\n        data = compat_urllib_parse_urlencode(data).encode('utf-8')\n        return self._download_xml(\n            'http://www.crunchyroll.com/xml/',\n            video_id, note, fatal=False, data=data, headers={\n                'Content-Type': 'application/x-www-form-urlencoded',\n            })\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n\n        self._download_webpage(\n            'https://www.crunchyroll.com/?a=formhandler',\n            None, 'Logging in', 'Wrong login info',\n            data=urlencode_postdata({\n                'formname': 'RpcApiUser_Login',\n                'next_url': 'https://www.crunchyroll.com/acct/membership',\n                'name': username,\n                'password': password,\n            }))\n\n        '''\n        login_page = self._download_webpage(\n            self._LOGIN_URL, None, 'Downloading login page')\n\n        def is_logged(webpage):\n            return '<title>Redirecting' in webpage\n\n        # Already logged in\n        if is_logged(login_page):\n            return\n\n        login_form_str = self._search_regex(\n            r'(?P<form><form[^>]+?id=([\"\\'])%s\\2[^>]*>)' % self._LOGIN_FORM,\n            login_page, 'login form', group='form')\n\n        post_url = extract_attributes(login_form_str).get('action')\n        if not post_url:\n            post_url = self._LOGIN_URL\n        elif not post_url.startswith('http'):\n            post_url = compat_urlparse.urljoin(self._LOGIN_URL, post_url)\n\n        login_form = self._form_hidden_inputs(self._LOGIN_FORM, login_page)\n\n        login_form.update({\n            'login_form[name]': username,\n            'login_form[password]': password,\n        })\n\n        response = self._download_webpage(\n            post_url, None, 'Logging in', 'Wrong login info',\n            data=urlencode_postdata(login_form),\n            headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\n        # Successful login\n        if is_logged(response):\n            return\n\n        error = self._html_search_regex(\n            '(?s)<ul[^>]+class=[\"\\']messages[\"\\'][^>]*>(.+?)</ul>',\n            response, 'error message', default=None)\n        if error:\n            raise ExtractorError('Unable to login: %s' % error, expected=True)\n\n        raise ExtractorError('Unable to log in')\n        '''\n\n    def _real_initialize(self):\n        self._login()\n\n    def _download_webpage(self, url_or_request, *args, **kwargs):\n        request = (url_or_request if isinstance(url_or_request, compat_urllib_request.Request)\n                   else sanitized_Request(url_or_request))\n        # Accept-Language must be set explicitly to accept any language to avoid issues\n        # similar to https://github.com/rg3/youtube-dl/issues/6797.\n        # Along with IP address Crunchyroll uses Accept-Language to guess whether georestriction\n        # should be imposed or not (from what I can see it just takes the first language\n        # ignoring the priority and requires it to correspond the IP). By the way this causes\n        # Crunchyroll to not work in georestriction cases in some browsers that don't place\n        # the locale lang first in header. However allowing any language seems to workaround the issue.\n        request.add_header('Accept-Language', '*')\n        return super(CrunchyrollBaseIE, self)._download_webpage(request, *args, **kwargs)\n\n    @staticmethod\n    def _add_skip_wall(url):\n        parsed_url = compat_urlparse.urlparse(url)\n        qs = compat_urlparse.parse_qs(parsed_url.query)\n        # Always force skip_wall to bypass maturity wall, namely 18+ confirmation message:\n        # > This content may be inappropriate for some people.\n        # > Are you sure you want to continue?\n        # since it's not disabled by default in crunchyroll account's settings.\n        # See https://github.com/rg3/youtube-dl/issues/7202.\n        qs['skip_wall'] = ['1']\n        return compat_urlparse.urlunparse(\n            parsed_url._replace(query=compat_urllib_parse_urlencode(qs, True)))\n\n\nclass CrunchyrollIE(CrunchyrollBaseIE):\n    _VALID_URL = r'https?://(?:(?P<prefix>www|m)\\.)?(?P<url>crunchyroll\\.(?:com|fr)/(?:media(?:-|/\\?id=)|[^/]*/[^/?&]*?)(?P<video_id>[0-9]+))(?:[/?&]|$)'\n    _TESTS = [{\n        'url': 'http://www.crunchyroll.com/wanna-be-the-strongest-in-the-world/episode-1-an-idol-wrestler-is-born-645513',\n        'info_dict': {\n            'id': '645513',\n            'ext': 'mp4',\n            'title': 'Wanna be the Strongest in the World Episode 1 \u2013 An Idol-Wrestler is Born!',\n            'description': 'md5:2d17137920c64f2f49981a7797d275ef',\n            'thumbnail': 'http://img1.ak.crunchyroll.com/i/spire1-tmb/20c6b5e10f1a47b10516877d3c039cae1380951166_full.jpg',\n            'uploader': 'Yomiuri Telecasting Corporation (YTV)',\n            'upload_date': '20131013',\n            'url': 're:(?!.*&amp)',\n        },\n        'params': {\n            # rtmp\n            'skip_download': True,\n        },\n    }, {\n        'url': 'http://www.crunchyroll.com/media-589804/culture-japan-1',\n        'info_dict': {\n            'id': '589804',\n            'ext': 'flv',\n            'title': 'Culture Japan Episode 1 \u2013 Rebuilding Japan after the 3.11',\n            'description': 'md5:2fbc01f90b87e8e9137296f37b461c12',\n            'thumbnail': r're:^https?://.*\\.jpg$',\n            'uploader': 'Danny Choo Network',\n            'upload_date': '20120213',\n        },\n        'params': {\n            # rtmp\n            'skip_download': True,\n        },\n        'skip': 'Video gone',\n    }, {\n        'url': 'http://www.crunchyroll.com/rezero-starting-life-in-another-world-/episode-5-the-morning-of-our-promise-is-still-distant-702409',\n        'info_dict': {\n            'id': '702409',\n            'ext': 'mp4',\n            'title': 'Re:ZERO -Starting Life in Another World- Episode 5 \u2013 The Morning of Our Promise Is Still Distant',\n            'description': 'md5:97664de1ab24bbf77a9c01918cb7dca9',\n            'thumbnail': r're:^https?://.*\\.jpg$',\n            'uploader': 'TV TOKYO',\n            'upload_date': '20160508',\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n    }, {\n        'url': 'http://www.crunchyroll.com/konosuba-gods-blessing-on-this-wonderful-world/episode-1-give-me-deliverance-from-this-judicial-injustice-727589',\n        'info_dict': {\n            'id': '727589',\n            'ext': 'mp4',\n            'title': \"KONOSUBA -God's blessing on this wonderful world! 2 Episode 1 \u2013 Give Me Deliverance From This Judicial Injustice!\",\n            'description': 'md5:cbcf05e528124b0f3a0a419fc805ea7d',\n            'thumbnail': r're:^https?://.*\\.jpg$',\n            'uploader': 'Kadokawa Pictures Inc.',\n            'upload_date': '20170118',\n            'series': \"KONOSUBA -God's blessing on this wonderful world!\",\n            'season': \"KONOSUBA -God's blessing on this wonderful world! 2\",\n            'season_number': 2,\n            'episode': 'Give Me Deliverance From This Judicial Injustice!',\n            'episode_number': 1,\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n    }, {\n        'url': 'http://www.crunchyroll.fr/girl-friend-beta/episode-11-goodbye-la-mode-661697',\n        'only_matching': True,\n    }, {\n        # geo-restricted (US), 18+ maturity wall, non-premium available\n        'url': 'http://www.crunchyroll.com/cosplay-complex-ova/episode-1-the-birth-of-the-cosplay-club-565617',\n        'only_matching': True,\n    }, {\n        # A description with double quotes\n        'url': 'http://www.crunchyroll.com/11eyes/episode-1-piros-jszaka-red-night-535080',\n        'info_dict': {\n            'id': '535080',\n            'ext': 'mp4',\n            'title': '11eyes Episode 1 \u2013 Piros \u00e9jszaka - Red Night',\n            'description': 'Kakeru and Yuka are thrown into an alternate nightmarish world they call \"Red Night\".',\n            'uploader': 'Marvelous AQL Inc.',\n            'upload_date': '20091021',\n        },\n        'params': {\n            # Just test metadata extraction\n            'skip_download': True,\n        },\n    }, {\n        # make sure we can extract an uploader name that's not a link\n        'url': 'http://www.crunchyroll.com/hakuoki-reimeiroku/episode-1-dawn-of-the-divine-warriors-606899',\n        'info_dict': {\n            'id': '606899',\n            'ext': 'mp4',\n            'title': 'Hakuoki Reimeiroku Episode 1 \u2013 Dawn of the Divine Warriors',\n            'description': 'Ryunosuke was left to die, but Serizawa-san asked him a simple question \"Do you want to live?\"',\n            'uploader': 'Geneon Entertainment',\n            'upload_date': '20120717',\n        },\n        'params': {\n            # just test metadata extraction\n            'skip_download': True,\n        },\n    }, {\n        # A video with a vastly different season name compared to the series name\n        'url': 'http://www.crunchyroll.com/nyarko-san-another-crawling-chaos/episode-1-test-590532',\n        'info_dict': {\n            'id': '590532',\n            'ext': 'mp4',\n            'title': 'Haiyoru! Nyaruani (ONA) Episode 1 \u2013 Test',\n            'description': 'Mahiro and Nyaruko talk about official certification.',\n            'uploader': 'TV TOKYO',\n            'upload_date': '20120305',\n            'series': 'Nyarko-san: Another Crawling Chaos',\n            'season': 'Haiyoru! Nyaruani (ONA)',\n        },\n        'params': {\n            # Just test metadata extraction\n            'skip_download': True,\n        },\n    }]\n\n    _FORMAT_IDS = {\n        '360': ('60', '106'),\n        '480': ('61', '106'),\n        '720': ('62', '106'),\n        '1080': ('80', '108'),\n    }\n\n    def _decrypt_subtitles(self, data, iv, id):\n        data = bytes_to_intlist(compat_b64decode(data))\n        iv = bytes_to_intlist(compat_b64decode(iv))\n        id = int(id)\n\n        def obfuscate_key_aux(count, modulo, start):\n            output = list(start)\n            for _ in range(count):\n                output.append(output[-1] + output[-2])\n            # cut off start values\n            output = output[2:]\n            output = list(map(lambda x: x % modulo + 33, output))\n            return output\n\n        def obfuscate_key(key):\n            num1 = int(floor(pow(2, 25) * sqrt(6.9)))\n            num2 = (num1 ^ key) << 5\n            num3 = key ^ num1\n            num4 = num3 ^ (num3 >> 3) ^ num2\n            prefix = intlist_to_bytes(obfuscate_key_aux(20, 97, (1, 2)))\n            shaHash = bytes_to_intlist(sha1(prefix + str(num4).encode('ascii')).digest())\n            # Extend 160 Bit hash to 256 Bit\n            return shaHash + [0] * 12\n\n        key = obfuscate_key(id)\n\n        decrypted_data = intlist_to_bytes(aes_cbc_decrypt(data, key, iv))\n        return zlib.decompress(decrypted_data)\n\n    def _convert_subtitles_to_srt(self, sub_root):\n        output = ''\n\n        for i, event in enumerate(sub_root.findall('./events/event'), 1):\n            start = event.attrib['start'].replace('.', ',')\n            end = event.attrib['end'].replace('.', ',')\n            text = event.attrib['text'].replace('\\\\N', '\\n')\n            output += '%d\\n%s --> %s\\n%s\\n\\n' % (i, start, end, text)\n        return output\n\n    def _convert_subtitles_to_ass(self, sub_root):\n        output = ''\n\n        def ass_bool(strvalue):\n            assvalue = '0'\n            if strvalue == '1':\n                assvalue = '-1'\n            return assvalue\n\n        output = '[Script Info]\\n'\n        output += 'Title: %s\\n' % sub_root.attrib['title']\n        output += 'ScriptType: v4.00+\\n'\n        output += 'WrapStyle: %s\\n' % sub_root.attrib['wrap_style']\n        output += 'PlayResX: %s\\n' % sub_root.attrib['play_res_x']\n        output += 'PlayResY: %s\\n' % sub_root.attrib['play_res_y']\n        output += \"\"\"\n[V4+ Styles]\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n\"\"\"\n        for style in sub_root.findall('./styles/style'):\n            output += 'Style: ' + style.attrib['name']\n            output += ',' + style.attrib['font_name']\n            output += ',' + style.attrib['font_size']\n            output += ',' + style.attrib['primary_colour']\n            output += ',' + style.attrib['secondary_colour']\n            output += ',' + style.attrib['outline_colour']\n            output += ',' + style.attrib['back_colour']\n            output += ',' + ass_bool(style.attrib['bold'])\n            output += ',' + ass_bool(style.attrib['italic'])\n            output += ',' + ass_bool(style.attrib['underline'])\n            output += ',' + ass_bool(style.attrib['strikeout'])\n            output += ',' + style.attrib['scale_x']\n            output += ',' + style.attrib['scale_y']\n            output += ',' + style.attrib['spacing']\n            output += ',' + style.attrib['angle']\n            output += ',' + style.attrib['border_style']\n            output += ',' + style.attrib['outline']\n            output += ',' + style.attrib['shadow']\n            output += ',' + style.attrib['alignment']\n            output += ',' + style.attrib['margin_l']\n            output += ',' + style.attrib['margin_r']\n            output += ',' + style.attrib['margin_v']\n            output += ',' + style.attrib['encoding']\n            output += '\\n'\n\n        output += \"\"\"\n[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n\"\"\"\n        for event in sub_root.findall('./events/event'):\n            output += 'Dialogue: 0'\n            output += ',' + event.attrib['start']\n            output += ',' + event.attrib['end']\n            output += ',' + event.attrib['style']\n            output += ',' + event.attrib['name']\n            output += ',' + event.attrib['margin_l']\n            output += ',' + event.attrib['margin_r']\n            output += ',' + event.attrib['margin_v']\n            output += ',' + event.attrib['effect']\n            output += ',' + event.attrib['text']\n            output += '\\n'\n\n        return output\n\n    def _extract_subtitles(self, subtitle):\n        sub_root = compat_etree_fromstring(subtitle)\n        return [{\n            'ext': 'srt',\n            'data': self._convert_subtitles_to_srt(sub_root),\n        }, {\n            'ext': 'ass',\n            'data': self._convert_subtitles_to_ass(sub_root),\n        }]\n\n    def _get_subtitles(self, video_id, webpage):\n        subtitles = {}\n        for sub_id, sub_name in re.findall(r'\\bssid=([0-9]+)\"[^>]+?\\btitle=\"([^\"]+)', webpage):\n            sub_doc = self._call_rpc_api(\n                'Subtitle_GetXml', video_id,\n                'Downloading subtitles for ' + sub_name, data={\n                    'subtitle_script_id': sub_id,\n                })\n            if sub_doc is None:\n                continue\n            sid = sub_doc.get('id')\n            iv = xpath_text(sub_doc, 'iv', 'subtitle iv')\n            data = xpath_text(sub_doc, 'data', 'subtitle data')\n            if not sid or not iv or not data:\n                continue\n            subtitle = self._decrypt_subtitles(data, iv, sid).decode('utf-8')\n            lang_code = self._search_regex(r'lang_code=[\"\\']([^\"\\']+)', subtitle, 'subtitle_lang_code', fatal=False)\n            if not lang_code:\n                continue\n            subtitles[lang_code] = self._extract_subtitles(subtitle)\n        return subtitles\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        video_id = mobj.group('video_id')\n\n        if mobj.group('prefix') == 'm':\n            mobile_webpage = self._download_webpage(url, video_id, 'Downloading mobile webpage')\n            webpage_url = self._search_regex(r'<link rel=\"canonical\" href=\"([^\"]+)\" />', mobile_webpage, 'webpage_url')\n        else:\n            webpage_url = 'http://www.' + mobj.group('url')\n\n        webpage = self._download_webpage(\n            self._add_skip_wall(webpage_url), video_id,\n            headers=self.geo_verification_headers())\n        note_m = self._html_search_regex(\n            r'<div class=\"showmedia-trailer-notice\">(.+?)</div>',\n            webpage, 'trailer-notice', default='')\n        if note_m:\n            raise ExtractorError(note_m)\n\n        mobj = re.search(r'Page\\.messaging_box_controller\\.addItems\\(\\[(?P<msg>{.+?})\\]\\)', webpage)\n        if mobj:\n            msg = json.loads(mobj.group('msg'))\n            if msg.get('type') == 'error':\n                raise ExtractorError('crunchyroll returned error: %s' % msg['message_body'], expected=True)\n\n        if 'To view this, please log in to verify you are 18 or older.' in webpage:\n            self.raise_login_required()\n\n        video_title = self._html_search_regex(\n            r'(?s)<h1[^>]*>((?:(?!<h1).)*?<span[^>]+itemprop=[\"\\']title[\"\\'][^>]*>(?:(?!<h1).)+?)</h1>',\n            webpage, 'video_title')\n        video_title = re.sub(r' {2,}', ' ', video_title)\n        video_description = self._parse_json(self._html_search_regex(\n            r'<script[^>]*>\\s*.+?\\[media_id=%s\\].+?({.+?\"description\"\\s*:.+?})\\);' % video_id,\n            webpage, 'description', default='{}'), video_id).get('description')\n        if video_description:\n            video_description = lowercase_escape(video_description.replace(r'\\r\\n', '\\n'))\n        video_upload_date = self._html_search_regex(\n            [r'<div>Availability for free users:(.+?)</div>', r'<div>[^<>]+<span>\\s*(.+?\\d{4})\\s*</span></div>'],\n            webpage, 'video_upload_date', fatal=False, flags=re.DOTALL)\n        if video_upload_date:\n            video_upload_date = unified_strdate(video_upload_date)\n        video_uploader = self._html_search_regex(\n            # try looking for both an uploader that's a link and one that's not\n            [r'<a[^>]+href=\"/publisher/[^\"]+\"[^>]*>([^<]+)</a>', r'<div>\\s*Publisher:\\s*<span>\\s*(.+?)\\s*</span>\\s*</div>'],\n            webpage, 'video_uploader', fatal=False)\n\n        available_fmts = []\n        for a, fmt in re.findall(r'(<a[^>]+token=[\"\\']showmedia\\.([0-9]{3,4})p[\"\\'][^>]+>)', webpage):\n            attrs = extract_attributes(a)\n            href = attrs.get('href')\n            if href and '/freetrial' in href:\n                continue\n            available_fmts.append(fmt)\n        if not available_fmts:\n            for p in (r'token=[\"\\']showmedia\\.([0-9]{3,4})p\"', r'showmedia\\.([0-9]{3,4})p'):\n                available_fmts = re.findall(p, webpage)\n                if available_fmts:\n                    break\n        video_encode_ids = []\n        formats = []\n        for fmt in available_fmts:\n            stream_quality, stream_format = self._FORMAT_IDS[fmt]\n            video_format = fmt + 'p'\n            stream_infos = []\n            streamdata = self._call_rpc_api(\n                'VideoPlayer_GetStandardConfig', video_id,\n                'Downloading media info for %s' % video_format, data={\n                    'media_id': video_id,\n                    'video_format': stream_format,\n                    'video_quality': stream_quality,\n                    'current_page': url,\n                })\n            if streamdata is not None:\n                stream_info = streamdata.find('./{default}preload/stream_info')\n                if stream_info is not None:\n                    stream_infos.append(stream_info)\n            stream_info = self._call_rpc_api(\n                'VideoEncode_GetStreamInfo', video_id,\n                'Downloading stream info for %s' % video_format, data={\n                    'media_id': video_id,\n                    'video_format': stream_format,\n                    'video_encode_quality': stream_quality,\n                })\n            if stream_info is not None:\n                stream_infos.append(stream_info)\n            for stream_info in stream_infos:\n                video_encode_id = xpath_text(stream_info, './video_encode_id')\n                if video_encode_id in video_encode_ids:\n                    continue\n                video_encode_ids.append(video_encode_id)\n\n                video_file = xpath_text(stream_info, './file')\n                if not video_file:\n                    continue\n                if video_file.startswith('http'):\n                    formats.extend(self._extract_m3u8_formats(\n                        video_file, video_id, 'mp4', entry_protocol='m3u8_native',\n                        m3u8_id='hls', fatal=False))\n                    continue\n\n                video_url = xpath_text(stream_info, './host')\n                if not video_url:\n                    continue\n                metadata = stream_info.find('./metadata')\n                format_info = {\n                    'format': video_format,\n                    'height': int_or_none(xpath_text(metadata, './height')),\n                    'width': int_or_none(xpath_text(metadata, './width')),\n                }\n\n                if '.fplive.net/' in video_url:\n                    video_url = re.sub(r'^rtmpe?://', 'http://', video_url.strip())\n                    parsed_video_url = compat_urlparse.urlparse(video_url)\n                    direct_video_url = compat_urlparse.urlunparse(parsed_video_url._replace(\n                        netloc='v.lvlt.crcdn.net',\n                        path='%s/%s' % (remove_end(parsed_video_url.path, '/'), video_file.split(':')[-1])))\n                    if self._is_valid_url(direct_video_url, video_id, video_format):\n                        format_info.update({\n                            'format_id': 'http-' + video_format,\n                            'url': direct_video_url,\n                        })\n                        formats.append(format_info)\n                        continue\n\n                format_info.update({\n                    'format_id': 'rtmp-' + video_format,\n                    'url': video_url,\n                    'play_path': video_file,\n                    'ext': 'flv',\n                })\n                formats.append(format_info)\n        self._sort_formats(formats, ('height', 'width', 'tbr', 'fps'))\n\n        metadata = self._call_rpc_api(\n            'VideoPlayer_GetMediaMetadata', video_id,\n            note='Downloading media info', data={\n                'media_id': video_id,\n            })\n\n        subtitles = self.extract_subtitles(video_id, webpage)\n\n        # webpage provide more accurate data than series_title from XML\n        series = self._html_search_regex(\n            r'(?s)<h\\d[^>]+\\bid=[\"\\']showmedia_about_episode_num[^>]+>(.+?)</h\\d',\n            webpage, 'series', fatal=False)\n        season = xpath_text(metadata, 'series_title')\n\n        episode = xpath_text(metadata, 'episode_title')\n        episode_number = int_or_none(xpath_text(metadata, 'episode_number'))\n\n        season_number = int_or_none(self._search_regex(\n            r'(?s)<h\\d[^>]+id=[\"\\']showmedia_about_episode_num[^>]+>.+?</h\\d>\\s*<h4>\\s*Season (\\d+)',\n            webpage, 'season number', default=None))\n\n        return {\n            'id': video_id,\n            'title': video_title,\n            'description': video_description,\n            'thumbnail': xpath_text(metadata, 'episode_image_url'),\n            'uploader': video_uploader,\n            'upload_date': video_upload_date,\n            'series': series,\n            'season': season,\n            'season_number': season_number,\n            'episode': episode,\n            'episode_number': episode_number,\n            'subtitles': subtitles,\n            'formats': formats,\n        }\n\n\nclass CrunchyrollShowPlaylistIE(CrunchyrollBaseIE):\n    IE_NAME = 'crunchyroll:playlist'\n    _VALID_URL = r'https?://(?:(?P<prefix>www|m)\\.)?(?P<url>crunchyroll\\.com/(?!(?:news|anime-news|library|forum|launchcalendar|lineup|store|comics|freetrial|login))(?P<id>[\\w\\-]+))/?(?:\\?|$)'\n\n    _TESTS = [{\n        'url': 'http://www.crunchyroll.com/a-bridge-to-the-starry-skies-hoshizora-e-kakaru-hashi',\n        'info_dict': {\n            'id': 'a-bridge-to-the-starry-skies-hoshizora-e-kakaru-hashi',\n            'title': 'A Bridge to the Starry Skies - Hoshizora e Kakaru Hashi'\n        },\n        'playlist_count': 13,\n    }, {\n        # geo-restricted (US), 18+ maturity wall, non-premium available\n        'url': 'http://www.crunchyroll.com/cosplay-complex-ova',\n        'info_dict': {\n            'id': 'cosplay-complex-ova',\n            'title': 'Cosplay Complex OVA'\n        },\n        'playlist_count': 3,\n        'skip': 'Georestricted',\n    }, {\n        # geo-restricted (US), 18+ maturity wall, non-premium will be available since 2015.11.14\n        'url': 'http://www.crunchyroll.com/ladies-versus-butlers?skip_wall=1',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        show_id = self._match_id(url)\n\n        webpage = self._download_webpage(\n            self._add_skip_wall(url), show_id,\n            headers=self.geo_verification_headers())\n        title = self._html_search_regex(\n            r'(?s)<h1[^>]*>\\s*<span itemprop=\"name\">(.*?)</span>',\n            webpage, 'title')\n        episode_paths = re.findall(\n            r'(?s)<li id=\"showview_videos_media_(\\d+)\"[^>]+>.*?<a href=\"([^\"]+)\"',\n            webpage)\n        entries = [\n            self.url_result('http://www.crunchyroll.com' + ep, 'Crunchyroll', ep_id)\n            for ep_id, ep in episode_paths\n        ]\n        entries.reverse()\n\n        return {\n            '_type': 'playlist',\n            'id': show_id,\n            'title': title,\n            'entries': entries,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "crunchyroll.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/crunchyroll.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}