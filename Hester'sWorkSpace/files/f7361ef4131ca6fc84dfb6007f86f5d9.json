{"author": "eliangcs", "code": "# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\n\nimport re\nimport six\n\ntry:\n    from collections import OrderedDict\nexcept ImportError:  \n    from ordereddict import OrderedDict\n\nfrom itertools import chain\n\nfrom prompt_toolkit.completion import Completer, Completion\nfrom six.moves.urllib.parse import urlparse\n\nfrom .completion import (ROOT_COMMANDS, ACTIONS, OPTION_NAMES, HEADER_NAMES,\n                         HEADER_VALUES)\n\n\nRULES = [\n    # (regex pattern, a method name in CompletionGenerator)\n    (r'((?:[^\\s\\'\"\\\\=:]|(?:\\\\.))+):((?:[^\\s\\'\"\\\\]|(?:\\\\.))*)$',\n     'header_values'),\n\n    (r'(get|head|post|put|patch|delete)\\s+', 'concat_mutations'),\n    (r'(httpie|curl)\\s+', 'preview'),\n    (r'rm\\s+\\-b\\s+', 'existing_body_params'),\n    (r'rm\\s+\\-h\\s+', 'existing_header_names'),\n    (r'rm\\s+\\-o\\s+', 'existing_option_names'),\n    (r'rm\\s+\\-q\\s+', 'existing_querystring_params'),\n\n    \n    \n    # '/foo/bar' => ('/foo/bar', 'bar')\n    # '/foo/bar/' => ('/foo/bar/', '')\n    # 'foo/bar' => ('foo/bar', 'bar')\n    (r'(ls|cd)\\s+(/?(?:[^/]+/)*([^/]*)/?)$', 'urlpaths'),\n    (r'^\\s*[^\\s]*$', 'root_commands')\n]\n\n\ndef compile_rules(rules):\n    compiled_rules = []\n    for pattern, meta_dict in rules:\n        regex = re.compile(pattern)\n        compiled_rules.append((regex, meta_dict))\n    return compiled_rules\n\nRULES = compile_rules(RULES)\n\n\ndef fuzzyfinder(text, collection):\n    \n    suggestions = []\n    if not isinstance(text, six.text_type):\n        text = six.u(text)\n    pat = '.*?'.join(map(re.escape, text))\n    regex = re.compile(pat, flags=re.IGNORECASE)\n    for item in collection:\n        r = regex.search(item)\n        if r:\n            suggestions.append((len(r.group()), r.start(), item))\n\n    return (z for _, _, z in sorted(suggestions))\n\n\ndef match_completions(cur_word, word_dict):\n    words = word_dict.keys()\n    suggestions = fuzzyfinder(cur_word, words)\n    for word in suggestions:\n        desc = word_dict.get(word, '')\n        yield Completion(word, -len(cur_word), display_meta=desc)\n\n\nclass CompletionGenerator(object):\n\n    def root_commands(self, context, match):\n        return chain(\n            self._generic_generate(ROOT_COMMANDS.keys(), {}, ROOT_COMMANDS),\n            self.actions(context, match),\n            self.concat_mutations(context, match)\n        )\n\n    def header_values(self, context, match):\n        header_name = match.group(1)\n        header_values = HEADER_VALUES.get(header_name)\n        if header_values:\n            for value in header_values:\n                yield value, header_name\n\n    def preview(self, context, match):\n        return chain(\n            self.actions(context, match),\n            self.concat_mutations(context, match)\n        )\n\n    def actions(self, context, match):\n        return self._generic_generate(ACTIONS.keys(), {}, ACTIONS)\n\n    def concat_mutations(self, context, match):\n        return chain(\n            self._generic_generate(context.body_params.keys(),\n                                   context.body_params, 'Body parameter'),\n            self._generic_generate(context.querystring_params.keys(),\n                                   context.querystring_params,\n                                   'Querystring parameter'),\n            self._generic_generate(HEADER_NAMES.keys(),\n                                   context.headers, HEADER_NAMES),\n            self._generic_generate(OPTION_NAMES.keys(),\n                                   context.options, OPTION_NAMES)\n        )\n\n    def existing_body_params(self, context, match):\n        params = context.body_params.copy()\n        params.update(context.body_json_params)\n        return self._generic_generate(params.keys(), params, 'Body parameter')\n\n    def existing_querystring_params(self, context, match):\n        return self._generic_generate(\n            context.querystring_params.keys(),\n            context.querystring_params, 'Querystring parameter')\n\n    def existing_header_names(self, context, match):\n        return self._generic_generate(context.headers.keys(),\n                                      context.headers, HEADER_NAMES)\n\n    def existing_option_names(self, context, match):\n        return self._generic_generate(context.options.keys(),\n                                      context.options, OPTION_NAMES)\n\n    def urlpaths(self, context, match):\n        path = urlparse(context.url).path.split('/')\n        overrided_path = match.group(2)\n        if overrided_path:\n            if overrided_path.startswith('/'):\n                \n                path = []\n            path += overrided_path.split('/')[:-1]\n        names = [\n            node.name for node in context.root.ls(*path)\n            if node.data.get('type') == 'dir'\n        ]\n        return self._generic_generate(names, {}, 'Endpoint')\n\n    def _generic_generate(self, names, values, descs):\n        for name in sorted(names):\n            if isinstance(descs, six.string_types):\n                desc = descs\n            else:\n                desc = descs.get(name, '')\n            if name in values:\n                value = values[name]\n                if value is None:\n                    desc += ' (on)'\n                else:\n                    value = six.text_type(value)\n                    if len(value) > 16:\n                        value = value[:13] + '...'\n                    desc += ' (=%s)' % value\n            yield name, desc\n\n\nclass HttpPromptCompleter(Completer):\n\n    def __init__(self, context):\n        self.context = context\n        self.comp_gen = CompletionGenerator()\n\n    def get_completions(self, document, complete_event):\n        cur_text = document.text_before_cursor\n        cur_word = None\n        word_dict = None\n\n        for regex, method_name in RULES:\n            match = regex.search(cur_text)\n            if match:\n                gen_completions = getattr(self.comp_gen, method_name)\n                completions = gen_completions(self.context, match)\n                word_dict = OrderedDict(completions)\n\n                groups = match.groups()\n                if len(groups) > 1:\n                    cur_word = groups[-1]\n                else:\n                    cur_word = document.get_word_before_cursor(WORD=True)\n\n                break\n\n        if word_dict:\n            for comp in match_completions(cur_word, word_dict):\n                yield comp\n", "comments": "   https   github com amjith fuzzyfinder           coding  utf 8        for python 2 6  nocover    (regex pattern  method name completiongenerator)    the last two captures full url path last part url    path  for example       foo bar     (  foo bar    bar )      foo bar      (  foo bar      )     foo bar     ( foo bar    bar )    absolute path ", "content": "# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\n\nimport re\nimport six\n\ntry:\n    from collections import OrderedDict\nexcept ImportError:  # For Python 2.6, nocover\n    from ordereddict import OrderedDict\n\nfrom itertools import chain\n\nfrom prompt_toolkit.completion import Completer, Completion\nfrom six.moves.urllib.parse import urlparse\n\nfrom .completion import (ROOT_COMMANDS, ACTIONS, OPTION_NAMES, HEADER_NAMES,\n                         HEADER_VALUES)\n\n\nRULES = [\n    # (regex pattern, a method name in CompletionGenerator)\n    (r'((?:[^\\s\\'\"\\\\=:]|(?:\\\\.))+):((?:[^\\s\\'\"\\\\]|(?:\\\\.))*)$',\n     'header_values'),\n\n    (r'(get|head|post|put|patch|delete)\\s+', 'concat_mutations'),\n    (r'(httpie|curl)\\s+', 'preview'),\n    (r'rm\\s+\\-b\\s+', 'existing_body_params'),\n    (r'rm\\s+\\-h\\s+', 'existing_header_names'),\n    (r'rm\\s+\\-o\\s+', 'existing_option_names'),\n    (r'rm\\s+\\-q\\s+', 'existing_querystring_params'),\n\n    # The last two captures are full URL path and the last part of the URL\n    # path. For example:\n    # '/foo/bar' => ('/foo/bar', 'bar')\n    # '/foo/bar/' => ('/foo/bar/', '')\n    # 'foo/bar' => ('foo/bar', 'bar')\n    (r'(ls|cd)\\s+(/?(?:[^/]+/)*([^/]*)/?)$', 'urlpaths'),\n    (r'^\\s*[^\\s]*$', 'root_commands')\n]\n\n\ndef compile_rules(rules):\n    compiled_rules = []\n    for pattern, meta_dict in rules:\n        regex = re.compile(pattern)\n        compiled_rules.append((regex, meta_dict))\n    return compiled_rules\n\nRULES = compile_rules(RULES)\n\n\ndef fuzzyfinder(text, collection):\n    \"\"\"https://github.com/amjith/fuzzyfinder\"\"\"\n    suggestions = []\n    if not isinstance(text, six.text_type):\n        text = six.u(text)\n    pat = '.*?'.join(map(re.escape, text))\n    regex = re.compile(pat, flags=re.IGNORECASE)\n    for item in collection:\n        r = regex.search(item)\n        if r:\n            suggestions.append((len(r.group()), r.start(), item))\n\n    return (z for _, _, z in sorted(suggestions))\n\n\ndef match_completions(cur_word, word_dict):\n    words = word_dict.keys()\n    suggestions = fuzzyfinder(cur_word, words)\n    for word in suggestions:\n        desc = word_dict.get(word, '')\n        yield Completion(word, -len(cur_word), display_meta=desc)\n\n\nclass CompletionGenerator(object):\n\n    def root_commands(self, context, match):\n        return chain(\n            self._generic_generate(ROOT_COMMANDS.keys(), {}, ROOT_COMMANDS),\n            self.actions(context, match),\n            self.concat_mutations(context, match)\n        )\n\n    def header_values(self, context, match):\n        header_name = match.group(1)\n        header_values = HEADER_VALUES.get(header_name)\n        if header_values:\n            for value in header_values:\n                yield value, header_name\n\n    def preview(self, context, match):\n        return chain(\n            self.actions(context, match),\n            self.concat_mutations(context, match)\n        )\n\n    def actions(self, context, match):\n        return self._generic_generate(ACTIONS.keys(), {}, ACTIONS)\n\n    def concat_mutations(self, context, match):\n        return chain(\n            self._generic_generate(context.body_params.keys(),\n                                   context.body_params, 'Body parameter'),\n            self._generic_generate(context.querystring_params.keys(),\n                                   context.querystring_params,\n                                   'Querystring parameter'),\n            self._generic_generate(HEADER_NAMES.keys(),\n                                   context.headers, HEADER_NAMES),\n            self._generic_generate(OPTION_NAMES.keys(),\n                                   context.options, OPTION_NAMES)\n        )\n\n    def existing_body_params(self, context, match):\n        params = context.body_params.copy()\n        params.update(context.body_json_params)\n        return self._generic_generate(params.keys(), params, 'Body parameter')\n\n    def existing_querystring_params(self, context, match):\n        return self._generic_generate(\n            context.querystring_params.keys(),\n            context.querystring_params, 'Querystring parameter')\n\n    def existing_header_names(self, context, match):\n        return self._generic_generate(context.headers.keys(),\n                                      context.headers, HEADER_NAMES)\n\n    def existing_option_names(self, context, match):\n        return self._generic_generate(context.options.keys(),\n                                      context.options, OPTION_NAMES)\n\n    def urlpaths(self, context, match):\n        path = urlparse(context.url).path.split('/')\n        overrided_path = match.group(2)\n        if overrided_path:\n            if overrided_path.startswith('/'):\n                # Absolute path\n                path = []\n            path += overrided_path.split('/')[:-1]\n        names = [\n            node.name for node in context.root.ls(*path)\n            if node.data.get('type') == 'dir'\n        ]\n        return self._generic_generate(names, {}, 'Endpoint')\n\n    def _generic_generate(self, names, values, descs):\n        for name in sorted(names):\n            if isinstance(descs, six.string_types):\n                desc = descs\n            else:\n                desc = descs.get(name, '')\n            if name in values:\n                value = values[name]\n                if value is None:\n                    desc += ' (on)'\n                else:\n                    value = six.text_type(value)\n                    if len(value) > 16:\n                        value = value[:13] + '...'\n                    desc += ' (=%s)' % value\n            yield name, desc\n\n\nclass HttpPromptCompleter(Completer):\n\n    def __init__(self, context):\n        self.context = context\n        self.comp_gen = CompletionGenerator()\n\n    def get_completions(self, document, complete_event):\n        cur_text = document.text_before_cursor\n        cur_word = None\n        word_dict = None\n\n        for regex, method_name in RULES:\n            match = regex.search(cur_text)\n            if match:\n                gen_completions = getattr(self.comp_gen, method_name)\n                completions = gen_completions(self.context, match)\n                word_dict = OrderedDict(completions)\n\n                groups = match.groups()\n                if len(groups) > 1:\n                    cur_word = groups[-1]\n                else:\n                    cur_word = document.get_word_before_cursor(WORD=True)\n\n                break\n\n        if word_dict:\n            for comp in match_completions(cur_word, word_dict):\n                yield comp\n", "description": "HTTPie + prompt_toolkit = an interactive command-line HTTP client featuring autocomplete and syntax highlighting", "file_name": "completer.py", "id": "f7361ef4131ca6fc84dfb6007f86f5d9", "language": "Python", "project_name": "http-prompt", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/eliangcs-http-prompt/eliangcs-http-prompt-87f1e9d/http_prompt/completer.py", "save_time": "", "source": "", "update_at": "2018-03-17T18:26:33Z", "url": "https://github.com/eliangcs/http-prompt", "wiki": true}