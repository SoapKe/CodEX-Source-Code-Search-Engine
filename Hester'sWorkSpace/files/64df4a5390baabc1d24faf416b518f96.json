{"author": "tgalal", "code": "class WriteEncoder:\n\n    def __init__(self, tokenDictionary):\n        self.tokenDictionary = tokenDictionary\n        self.streamStarted = False\n\n    def reset(self):\n        self.streamStarted = False\n\n    def getStreamStartBytes(self, domain, resource):\n        data = []\n        self.streamStarted = True\n        data.append(87)\n        data.append(65)\n        data.append(1)\n        data.append(6)\n\n        streamOpenAttributes = {\"to\": domain, \"resource\": resource}\n        self.writeListStart(len(streamOpenAttributes) * 2 + 1, data)\n        data.append(1);\n        self.writeAttributes(streamOpenAttributes, data)\n        return data\n\n    def protocolTreeNodeToBytes(self, node):\n        outBytes = []\n        self.writeInternal(node, outBytes)\n\n        return outBytes\n\n\n    def writeInternal(self, node, data):\n\n        x = 1 + \\\n        (0 if node.attributes is None else len(node.attributes) * 2) + \\\n        (0 if not node.hasChildren() else 1) + \\\n        (0 if node.data is None else 1)\n\n        self.writeListStart(x, data)\n\n\n        self.writeString(node.tag, data)\n        self.writeAttributes(node.attributes, data);\n\n\n        if node.data is not None:\n            self.writeBytes(node.data, data)\n\n        if node.hasChildren():\n            self.writeListStart(len(node.children), data);\n            for c in node.children:\n                self.writeInternal(c, data);\n\n\n    def writeAttributes(self, attributes, data):\n        if attributes is not None:\n            for key, value in attributes.items():\n                self.writeString(key, data);\n                self.writeString(value, data, True);\n\n\n    def writeBytes(self, bytes_, data, packed = False):\n        bytes__ = []\n        for b in bytes_:\n            if type(b) is int:\n                bytes__.append(b)\n            else:\n                bytes__.append(ord(b))\n\n\n        size = len(bytes__)\n        toWrite = bytes__\n        if size >= 0x100000:\n            data.append(254)\n            self.writeInt31(size, data)\n        elif size >= 0x100:\n            data.append(253)\n            self.writeInt20(size, data)\n        else:\n            r = None\n            if packed:\n                if size < 128:\n                    r = self.tryPackAndWriteHeader(255, bytes__, data)\n                    if r is None:\n                        r = self.tryPackAndWriteHeader(251, bytes__, data)\n\n            if r is None:\n                data.append(252)\n                self.writeInt8(size, data)\n            else:\n                toWrite = r\n\n        data.extend(toWrite)\n\n    def writeInt8(self, v, data):\n        data.append(v & 0xFF)\n\n\n    def writeInt16(self, v, data):\n        data.append((v & 0xFF00) >> 8);\n        data.append((v & 0xFF) >> 0);\n\n    def writeInt20(self, v, data):\n        data.append((0xF0000 & v) >> 16)\n        data.append((0xFF00 & v) >> 8)\n        data.append((v & 0xFF) >> 0)\n\n    def writeInt24(self, v, data):\n        data.append((v & 0xFF0000) >> 16)\n        data.append((v & 0xFF00) >> 8)\n        data.append((v & 0xFF) >> 0)\n\n    def writeInt31(self, v, data):\n        data.append((0x7F000000 & v) >> 24)\n        data.append((0xFF0000 & v) >> 16)\n        data.append((0xFF00 & v) >> 8)\n        data.append((v & 0xFF) >> 0)\n\n    def writeListStart(self, i, data):\n        if i == 0:\n            data.append(0)\n        elif i < 256:\n            data.append(248)\n            self.writeInt8(i, data)\n        else:\n            data.append(249)\n            self.writeInt16(i, data)\n\n    def writeToken(self, token, data):\n        if token <= 255 and token >=0:\n            data.append(token)\n        else:\n            raise ValueError(\"Invalid token: %s\" % token)\n\n\n    def writeString(self, tag, data, packed = False):\n        tok = self.tokenDictionary.getIndex(tag)\n        if tok:\n            index, secondary = tok\n            if secondary:\n                self.writeToken(236, data)\n            self.writeToken(index, data)\n        else:\n            at = '@'.encode() if type(tag) == bytes else '@'\n            try:\n                atIndex = tag.index(at)\n\n                if atIndex < 1:\n                    raise ValueError(\"atIndex < 1\")\n                else:\n                    server = tag[atIndex+1:]\n                    user = tag[0:atIndex]\n                    self.writeJid(user, server, data)\n            except ValueError:\n                self.writeBytes(self.encodeString(tag), data, packed)\n\n    def encodeString(self, string):\n        res = []\n\n        if type(string) == bytes:\n            for char in string:\n                res.append(char)\n        else:\n            for char in string:\n                res.append(ord(char))\n        return res;\n\n    def writeJid(self, user, server, data):\n        data.append(250)\n        if user is not None:\n            self.writeString(user, data, True)\n        else:\n            self.writeToken(0, data)\n        self.writeString(server, data)\n\n\n    def tryPackAndWriteHeader(self, v, headerData, data):\n        size = len(headerData)\n        if size >= 128:\n            return None\n\n        arr = [0] * int((size + 1) / 2)\n        for i in range(0, size):\n            packByte = self.packByte(v, headerData[i])\n            if packByte == -1:\n                arr = []\n                break\n            n2 = int(i / 2)\n            arr[n2] |= (packByte << 4 * (1 - i % 2))\n        if len(arr) > 0:\n            if size % 2 == 1:\n                arr[-1] |= 15 \n            data.append(v)\n            self.writeInt8(size %2 << 7 | len(arr), data)\n            return arr\n\n        return None\n\n\n\n    def packByte(self, v, n2):\n        if v == 251:\n            return self.packHex(n2)\n        if v == 255:\n            return self.packNibble(n2)\n        return -1\n\n    def packHex(self, n):\n        if n in range(48, 58):\n            return n - 48\n        if n in range(65, 71):\n            return 10 + (n - 65)\n        return -1\n\n    def packNibble(self, n):\n        if n in (45, 46):\n            return 10 + (n - 45)\n\n        if n in range(48, 58):\n            return n - 48\n\n        return -1\n", "comments": " 0xf ", "content": "class WriteEncoder:\n\n    def __init__(self, tokenDictionary):\n        self.tokenDictionary = tokenDictionary\n        self.streamStarted = False\n\n    def reset(self):\n        self.streamStarted = False\n\n    def getStreamStartBytes(self, domain, resource):\n        data = []\n        self.streamStarted = True\n        data.append(87)\n        data.append(65)\n        data.append(1)\n        data.append(6)\n\n        streamOpenAttributes = {\"to\": domain, \"resource\": resource}\n        self.writeListStart(len(streamOpenAttributes) * 2 + 1, data)\n        data.append(1);\n        self.writeAttributes(streamOpenAttributes, data)\n        return data\n\n    def protocolTreeNodeToBytes(self, node):\n        outBytes = []\n        self.writeInternal(node, outBytes)\n\n        return outBytes\n\n\n    def writeInternal(self, node, data):\n\n        x = 1 + \\\n        (0 if node.attributes is None else len(node.attributes) * 2) + \\\n        (0 if not node.hasChildren() else 1) + \\\n        (0 if node.data is None else 1)\n\n        self.writeListStart(x, data)\n\n\n        self.writeString(node.tag, data)\n        self.writeAttributes(node.attributes, data);\n\n\n        if node.data is not None:\n            self.writeBytes(node.data, data)\n\n        if node.hasChildren():\n            self.writeListStart(len(node.children), data);\n            for c in node.children:\n                self.writeInternal(c, data);\n\n\n    def writeAttributes(self, attributes, data):\n        if attributes is not None:\n            for key, value in attributes.items():\n                self.writeString(key, data);\n                self.writeString(value, data, True);\n\n\n    def writeBytes(self, bytes_, data, packed = False):\n        bytes__ = []\n        for b in bytes_:\n            if type(b) is int:\n                bytes__.append(b)\n            else:\n                bytes__.append(ord(b))\n\n\n        size = len(bytes__)\n        toWrite = bytes__\n        if size >= 0x100000:\n            data.append(254)\n            self.writeInt31(size, data)\n        elif size >= 0x100:\n            data.append(253)\n            self.writeInt20(size, data)\n        else:\n            r = None\n            if packed:\n                if size < 128:\n                    r = self.tryPackAndWriteHeader(255, bytes__, data)\n                    if r is None:\n                        r = self.tryPackAndWriteHeader(251, bytes__, data)\n\n            if r is None:\n                data.append(252)\n                self.writeInt8(size, data)\n            else:\n                toWrite = r\n\n        data.extend(toWrite)\n\n    def writeInt8(self, v, data):\n        data.append(v & 0xFF)\n\n\n    def writeInt16(self, v, data):\n        data.append((v & 0xFF00) >> 8);\n        data.append((v & 0xFF) >> 0);\n\n    def writeInt20(self, v, data):\n        data.append((0xF0000 & v) >> 16)\n        data.append((0xFF00 & v) >> 8)\n        data.append((v & 0xFF) >> 0)\n\n    def writeInt24(self, v, data):\n        data.append((v & 0xFF0000) >> 16)\n        data.append((v & 0xFF00) >> 8)\n        data.append((v & 0xFF) >> 0)\n\n    def writeInt31(self, v, data):\n        data.append((0x7F000000 & v) >> 24)\n        data.append((0xFF0000 & v) >> 16)\n        data.append((0xFF00 & v) >> 8)\n        data.append((v & 0xFF) >> 0)\n\n    def writeListStart(self, i, data):\n        if i == 0:\n            data.append(0)\n        elif i < 256:\n            data.append(248)\n            self.writeInt8(i, data)\n        else:\n            data.append(249)\n            self.writeInt16(i, data)\n\n    def writeToken(self, token, data):\n        if token <= 255 and token >=0:\n            data.append(token)\n        else:\n            raise ValueError(\"Invalid token: %s\" % token)\n\n\n    def writeString(self, tag, data, packed = False):\n        tok = self.tokenDictionary.getIndex(tag)\n        if tok:\n            index, secondary = tok\n            if secondary:\n                self.writeToken(236, data)\n            self.writeToken(index, data)\n        else:\n            at = '@'.encode() if type(tag) == bytes else '@'\n            try:\n                atIndex = tag.index(at)\n\n                if atIndex < 1:\n                    raise ValueError(\"atIndex < 1\")\n                else:\n                    server = tag[atIndex+1:]\n                    user = tag[0:atIndex]\n                    self.writeJid(user, server, data)\n            except ValueError:\n                self.writeBytes(self.encodeString(tag), data, packed)\n\n    def encodeString(self, string):\n        res = []\n\n        if type(string) == bytes:\n            for char in string:\n                res.append(char)\n        else:\n            for char in string:\n                res.append(ord(char))\n        return res;\n\n    def writeJid(self, user, server, data):\n        data.append(250)\n        if user is not None:\n            self.writeString(user, data, True)\n        else:\n            self.writeToken(0, data)\n        self.writeString(server, data)\n\n\n    def tryPackAndWriteHeader(self, v, headerData, data):\n        size = len(headerData)\n        if size >= 128:\n            return None\n\n        arr = [0] * int((size + 1) / 2)\n        for i in range(0, size):\n            packByte = self.packByte(v, headerData[i])\n            if packByte == -1:\n                arr = []\n                break\n            n2 = int(i / 2)\n            arr[n2] |= (packByte << 4 * (1 - i % 2))\n        if len(arr) > 0:\n            if size % 2 == 1:\n                arr[-1] |= 15 #0xF\n            data.append(v)\n            self.writeInt8(size %2 << 7 | len(arr), data)\n            return arr\n\n        return None\n\n\n\n    def packByte(self, v, n2):\n        if v == 251:\n            return self.packHex(n2)\n        if v == 255:\n            return self.packNibble(n2)\n        return -1\n\n    def packHex(self, n):\n        if n in range(48, 58):\n            return n - 48\n        if n in range(65, 71):\n            return 10 + (n - 65)\n        return -1\n\n    def packNibble(self, n):\n        if n in (45, 46):\n            return 10 + (n - 45)\n\n        if n in range(48, 58):\n            return n - 48\n\n        return -1\n", "description": "The python WhatsApp library", "file_name": "encoder.py", "id": "64df4a5390baabc1d24faf416b518f96", "language": "Python", "project_name": "yowsup", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tgalal-yowsup/tgalal-yowsup-03795cc/yowsup/layers/coder/encoder.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:01:40Z", "url": "https://github.com/tgalal/yowsup", "wiki": true}