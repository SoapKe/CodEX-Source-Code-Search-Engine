{"author": "nvbn", "code": "import os\nimport shlex\ntry:\n    from shutil import get_terminal_size\nexcept ImportError:\n    from backports.shutil_get_terminal_size import get_terminal_size\nimport six\nimport pyte\nfrom ..exceptions import ScriptNotInLog\nfrom .. import const, logs\n\n\ndef _group_by_calls(log):\n    ps1 = os.environ['PS1']\n    ps1_newlines = ps1.count('\\\\n') + ps1.count('\\n')\n    ps1_counter = 0\n\n    script_line = None\n    lines = []\n    for line in log:\n        try:\n            line = line.decode()\n        except UnicodeDecodeError:\n            continue\n\n        if const.USER_COMMAND_MARK in line or ps1_counter > 0:\n            if script_line and ps1_counter == 0:\n                yield script_line, lines\n\n            if ps1_newlines > 0:\n                if ps1_counter <= 0:\n                    ps1_counter = ps1_newlines\n                else:\n                    ps1_counter -= 1\n\n            script_line = line\n            lines = [line]\n        elif script_line is not None:\n            lines.append(line)\n\n    if script_line:\n        yield script_line, lines\n\n\ndef _get_script_group_lines(grouped, script):\n    parts = shlex.split(script)\n\n    for script_line, lines in reversed(grouped):\n        if all(part in script_line for part in parts):\n            return lines\n\n    raise ScriptNotInLog\n\n\ndef _get_output_lines(script, log_file):\n    lines = log_file.readlines()[-const.LOG_SIZE:]\n    grouped = list(_group_by_calls(lines))\n    script_lines = _get_script_group_lines(grouped, script)\n\n    screen = pyte.Screen(get_terminal_size().columns, len(script_lines))\n    stream = pyte.Stream(screen)\n    stream.feed(''.join(script_lines))\n    return screen.display\n\n\ndef _skip_old_lines(log_file):\n    size = os.path.getsize(os.environ['THEFUCK_OUTPUT_LOG'])\n    if size > const.LOG_SIZE_IN_BYTES:\n        log_file.seek(size - const.LOG_SIZE_IN_BYTES)\n\n\ndef get_output(script):\n    \n    if six.PY2:\n        logs.warn('Experimental instant mode is Python 3+ only')\n        return None\n\n    if 'THEFUCK_OUTPUT_LOG' not in os.environ:\n        logs.warn(\"Output log isn't specified\")\n        return None\n\n    if const.USER_COMMAND_MARK not in os.environ.get('PS1', ''):\n        logs.warn(\n            \"PS1 doesn't contain user command mark, please ensure \"\n            \"that PS1 is not changed after The Fuck alias initialization\")\n        return None\n\n    try:\n        with logs.debug_time(u'Read output from log'), \\\n                open(os.environ['THEFUCK_OUTPUT_LOG'], 'rb') as log_file:\n            _skip_old_lines(log_file)\n            lines = _get_output_lines(script, log_file)\n            output = '\\n'.join(lines).strip()\n            logs.debug(u'Received output: {}'.format(output))\n            return output\n    except OSError:\n        logs.warn(\"Can't read output log\")\n        return None\n    except ScriptNotInLog:\n        logs.warn(\"Script not found in output log\")\n        return None\n", "comments": "Reads script output from log.\n\n    :type script: str\n    :rtype: str | None\n\n    \n \n", "content": "import os\nimport shlex\ntry:\n    from shutil import get_terminal_size\nexcept ImportError:\n    from backports.shutil_get_terminal_size import get_terminal_size\nimport six\nimport pyte\nfrom ..exceptions import ScriptNotInLog\nfrom .. import const, logs\n\n\ndef _group_by_calls(log):\n    ps1 = os.environ['PS1']\n    ps1_newlines = ps1.count('\\\\n') + ps1.count('\\n')\n    ps1_counter = 0\n\n    script_line = None\n    lines = []\n    for line in log:\n        try:\n            line = line.decode()\n        except UnicodeDecodeError:\n            continue\n\n        if const.USER_COMMAND_MARK in line or ps1_counter > 0:\n            if script_line and ps1_counter == 0:\n                yield script_line, lines\n\n            if ps1_newlines > 0:\n                if ps1_counter <= 0:\n                    ps1_counter = ps1_newlines\n                else:\n                    ps1_counter -= 1\n\n            script_line = line\n            lines = [line]\n        elif script_line is not None:\n            lines.append(line)\n\n    if script_line:\n        yield script_line, lines\n\n\ndef _get_script_group_lines(grouped, script):\n    parts = shlex.split(script)\n\n    for script_line, lines in reversed(grouped):\n        if all(part in script_line for part in parts):\n            return lines\n\n    raise ScriptNotInLog\n\n\ndef _get_output_lines(script, log_file):\n    lines = log_file.readlines()[-const.LOG_SIZE:]\n    grouped = list(_group_by_calls(lines))\n    script_lines = _get_script_group_lines(grouped, script)\n\n    screen = pyte.Screen(get_terminal_size().columns, len(script_lines))\n    stream = pyte.Stream(screen)\n    stream.feed(''.join(script_lines))\n    return screen.display\n\n\ndef _skip_old_lines(log_file):\n    size = os.path.getsize(os.environ['THEFUCK_OUTPUT_LOG'])\n    if size > const.LOG_SIZE_IN_BYTES:\n        log_file.seek(size - const.LOG_SIZE_IN_BYTES)\n\n\ndef get_output(script):\n    \"\"\"Reads script output from log.\n\n    :type script: str\n    :rtype: str | None\n\n    \"\"\"\n    if six.PY2:\n        logs.warn('Experimental instant mode is Python 3+ only')\n        return None\n\n    if 'THEFUCK_OUTPUT_LOG' not in os.environ:\n        logs.warn(\"Output log isn't specified\")\n        return None\n\n    if const.USER_COMMAND_MARK not in os.environ.get('PS1', ''):\n        logs.warn(\n            \"PS1 doesn't contain user command mark, please ensure \"\n            \"that PS1 is not changed after The Fuck alias initialization\")\n        return None\n\n    try:\n        with logs.debug_time(u'Read output from log'), \\\n                open(os.environ['THEFUCK_OUTPUT_LOG'], 'rb') as log_file:\n            _skip_old_lines(log_file)\n            lines = _get_output_lines(script, log_file)\n            output = '\\n'.join(lines).strip()\n            logs.debug(u'Received output: {}'.format(output))\n            return output\n    except OSError:\n        logs.warn(\"Can't read output log\")\n        return None\n    except ScriptNotInLog:\n        logs.warn(\"Script not found in output log\")\n        return None\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "read_log.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/thefuck/output_readers/read_log.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}