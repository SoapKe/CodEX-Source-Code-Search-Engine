{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom odoo import api, fields, models, _\nfrom odoo.tools import html2plaintext\n\n\nclass Stage(models.Model):\n\n    _name = \"note.stage\"\n    _description = \"Note Stage\"\n    _order = 'sequence'\n\n    name = fields.Char('Stage Name', translate=True, required=True)\n    sequence = fields.Integer(help=\"Used to order the note stages\", default=1)\n    user_id = fields.Many2one('res.users', string='Owner', required=True, ondelete='cascade', default=lambda self: self.env.uid, help=\"Owner of the note stage\")\n    fold = fields.Boolean('Folded by Default')\n\n\nclass Tag(models.Model):\n\n    _name = \"note.tag\"\n    _description = \"Note Tag\"\n\n    name = fields.Char('Tag Name', required=True, translate=True)\n    color = fields.Integer('Color Index')\n\n    _sql_constraints = [\n        ('name_uniq', 'unique (name)', \"Tag name already exists !\"),\n    ]\n\n\nclass Note(models.Model):\n\n    _name = 'note.note'\n    _inherit = ['mail.thread', 'mail.activity.mixin']\n    _description = \"Note\"\n    _order = 'sequence'\n\n    def _get_default_stage_id(self):\n        return self.env['note.stage'].search([('user_id', '=', self.env.uid)], limit=1)\n\n    name = fields.Text(compute='_compute_name', string='Note Summary', store=True)\n    user_id = fields.Many2one('res.users', string='Owner', default=lambda self: self.env.uid)\n    memo = fields.Html('Note Content')\n    sequence = fields.Integer('Sequence')\n    stage_id = fields.Many2one('note.stage', compute='_compute_stage_id',\n        inverse='_inverse_stage_id', string='Stage')\n    stage_ids = fields.Many2many('note.stage', 'note_stage_rel', 'note_id', 'stage_id',\n        string='Stages of Users',  default=_get_default_stage_id)\n    open = fields.Boolean(string='Active', default=True)\n    date_done = fields.Date('Date done')\n    color = fields.Integer(string='Color Index')\n    tag_ids = fields.Many2many('note.tag', 'note_tags_rel', 'note_id', 'tag_id', string='Tags')\n\n    @api.depends('memo')\n    def _compute_name(self):\n        \n        for note in self:\n            text = html2plaintext(note.memo) if note.memo else ''\n            note.name = text.strip().replace('*', '').split(\"\\n\")[0]\n\n    @api.multi\n    def _compute_stage_id(self):\n        for note in self:\n            for stage in note.stage_ids.filtered(lambda stage: stage.user_id == self.env.user):\n                note.stage_id = stage\n\n    @api.multi\n    def _inverse_stage_id(self):\n        for note in self.filtered('stage_id'):\n            note.stage_ids = note.stage_id + note.stage_ids.filtered(lambda stage: stage.user_id != self.env.user)\n\n    @api.model\n    def name_create(self, name):\n        return self.create({'memo': name}).name_get()[0]\n\n    @api.model\n    def read_group(self, domain, fields, groupby, offset=0, limit=None, orderby=False, lazy=True):\n        if groupby and groupby[0] == \"stage_id\":\n            stages = self.env['note.stage'].search([('user_id', '=', self.env.uid)])\n            if stages:  \n                result = [{  \n                    '__context': {'group_by': groupby[1:]},\n                    '__domain': domain + [('stage_ids.id', '=', stage.id)],\n                    'stage_id': (stage.id, stage.name),\n                    'stage_id_count': self.search_count(domain + [('stage_ids', '=', stage.id)]),\n                    '__fold': stage.fold,\n                } for stage in stages]\n\n                \n                nb_notes_ws = self.search_count(domain + [('stage_ids', 'not in', stages.ids)])\n                if nb_notes_ws:\n                    \n                    dom_not_in = ('stage_ids', 'not in', stages.ids)\n                    if result and result[0]['stage_id'][0] == stages[0].id:\n                        dom_in = result[0]['__domain'].pop()\n                        result[0]['__domain'] = domain + ['|', dom_in, dom_not_in]\n                        result[0]['stage_id_count'] += nb_notes_ws\n                    else:\n                        \n                        result = [{\n                            '__context': {'group_by': groupby[1:]},\n                            '__domain': domain + [dom_not_in],\n                            'stage_id': (stages[0].id, stages[0].name),\n                            'stage_id_count': nb_notes_ws,\n                            '__fold': stages[0].name,\n                        }] + result\n            else:  \n                nb_notes_ws = self.search_count(domain)\n                if nb_notes_ws:\n                    result = [{  \n                        '__context': {'group_by': groupby[1:]},\n                        '__domain': domain,\n                        'stage_id': False,\n                        'stage_id_count': nb_notes_ws\n                    }]\n                else:\n                    result = []\n            return result\n        return super(Note, self).read_group(domain, fields, groupby, offset=offset, limit=limit, orderby=orderby, lazy=lazy)\n\n    @api.multi\n    def action_close(self):\n        return self.write({'open': False, 'date_done': fields.date.today()})\n\n    @api.multi\n    def action_open(self):\n        return self.write({'open': True})\n", "comments": "    read first line memo determine note name            coding  utf 8        part odoo  see license file full copyright licensing details     user stages    notes stage stages user    note without user stage    add note first column first stage    add first stage column    stage ids empty  get note without user stage    notes unknown stage ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom odoo import api, fields, models, _\nfrom odoo.tools import html2plaintext\n\n\nclass Stage(models.Model):\n\n    _name = \"note.stage\"\n    _description = \"Note Stage\"\n    _order = 'sequence'\n\n    name = fields.Char('Stage Name', translate=True, required=True)\n    sequence = fields.Integer(help=\"Used to order the note stages\", default=1)\n    user_id = fields.Many2one('res.users', string='Owner', required=True, ondelete='cascade', default=lambda self: self.env.uid, help=\"Owner of the note stage\")\n    fold = fields.Boolean('Folded by Default')\n\n\nclass Tag(models.Model):\n\n    _name = \"note.tag\"\n    _description = \"Note Tag\"\n\n    name = fields.Char('Tag Name', required=True, translate=True)\n    color = fields.Integer('Color Index')\n\n    _sql_constraints = [\n        ('name_uniq', 'unique (name)', \"Tag name already exists !\"),\n    ]\n\n\nclass Note(models.Model):\n\n    _name = 'note.note'\n    _inherit = ['mail.thread', 'mail.activity.mixin']\n    _description = \"Note\"\n    _order = 'sequence'\n\n    def _get_default_stage_id(self):\n        return self.env['note.stage'].search([('user_id', '=', self.env.uid)], limit=1)\n\n    name = fields.Text(compute='_compute_name', string='Note Summary', store=True)\n    user_id = fields.Many2one('res.users', string='Owner', default=lambda self: self.env.uid)\n    memo = fields.Html('Note Content')\n    sequence = fields.Integer('Sequence')\n    stage_id = fields.Many2one('note.stage', compute='_compute_stage_id',\n        inverse='_inverse_stage_id', string='Stage')\n    stage_ids = fields.Many2many('note.stage', 'note_stage_rel', 'note_id', 'stage_id',\n        string='Stages of Users',  default=_get_default_stage_id)\n    open = fields.Boolean(string='Active', default=True)\n    date_done = fields.Date('Date done')\n    color = fields.Integer(string='Color Index')\n    tag_ids = fields.Many2many('note.tag', 'note_tags_rel', 'note_id', 'tag_id', string='Tags')\n\n    @api.depends('memo')\n    def _compute_name(self):\n        \"\"\" Read the first line of the memo to determine the note name \"\"\"\n        for note in self:\n            text = html2plaintext(note.memo) if note.memo else ''\n            note.name = text.strip().replace('*', '').split(\"\\n\")[0]\n\n    @api.multi\n    def _compute_stage_id(self):\n        for note in self:\n            for stage in note.stage_ids.filtered(lambda stage: stage.user_id == self.env.user):\n                note.stage_id = stage\n\n    @api.multi\n    def _inverse_stage_id(self):\n        for note in self.filtered('stage_id'):\n            note.stage_ids = note.stage_id + note.stage_ids.filtered(lambda stage: stage.user_id != self.env.user)\n\n    @api.model\n    def name_create(self, name):\n        return self.create({'memo': name}).name_get()[0]\n\n    @api.model\n    def read_group(self, domain, fields, groupby, offset=0, limit=None, orderby=False, lazy=True):\n        if groupby and groupby[0] == \"stage_id\":\n            stages = self.env['note.stage'].search([('user_id', '=', self.env.uid)])\n            if stages:  # if the user has some stages\n                result = [{  # notes by stage for stages user\n                    '__context': {'group_by': groupby[1:]},\n                    '__domain': domain + [('stage_ids.id', '=', stage.id)],\n                    'stage_id': (stage.id, stage.name),\n                    'stage_id_count': self.search_count(domain + [('stage_ids', '=', stage.id)]),\n                    '__fold': stage.fold,\n                } for stage in stages]\n\n                # note without user's stage\n                nb_notes_ws = self.search_count(domain + [('stage_ids', 'not in', stages.ids)])\n                if nb_notes_ws:\n                    # add note to the first column if it's the first stage\n                    dom_not_in = ('stage_ids', 'not in', stages.ids)\n                    if result and result[0]['stage_id'][0] == stages[0].id:\n                        dom_in = result[0]['__domain'].pop()\n                        result[0]['__domain'] = domain + ['|', dom_in, dom_not_in]\n                        result[0]['stage_id_count'] += nb_notes_ws\n                    else:\n                        # add the first stage column\n                        result = [{\n                            '__context': {'group_by': groupby[1:]},\n                            '__domain': domain + [dom_not_in],\n                            'stage_id': (stages[0].id, stages[0].name),\n                            'stage_id_count': nb_notes_ws,\n                            '__fold': stages[0].name,\n                        }] + result\n            else:  # if stage_ids is empty, get note without user's stage\n                nb_notes_ws = self.search_count(domain)\n                if nb_notes_ws:\n                    result = [{  # notes for unknown stage\n                        '__context': {'group_by': groupby[1:]},\n                        '__domain': domain,\n                        'stage_id': False,\n                        'stage_id_count': nb_notes_ws\n                    }]\n                else:\n                    result = []\n            return result\n        return super(Note, self).read_group(domain, fields, groupby, offset=offset, limit=limit, orderby=orderby, lazy=lazy)\n\n    @api.multi\n    def action_close(self):\n        return self.write({'open': False, 'date_done': fields.date.today()})\n\n    @api.multi\n    def action_open(self):\n        return self.write({'open': True})\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "note.py", "id": "356be0ed9d0e5914cd7dc511ae60edad", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/note/models/note.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}