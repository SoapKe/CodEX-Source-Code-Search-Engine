{"author": "ansible", "code": "\n -*- coding: utf-8 -*-\n\n Copyright: Ansible Project\n GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: ipmi_boot\nshort_description: Management of order of boot devices\ndescription:\n  - Use this module to manage order of boot devices\nversion_added: \"2.2\"\noptions:\n  name:\n    description:\n      - Hostname or ip address of the BMC.\n    required: true\n  port:\n    description:\n      - Remote RMCP port.\n    default: 623\n  user:\n    description:\n      - Username to use to connect to the BMC.\n    required: true\n  password:\n    description:\n      - Password to connect to the BMC.\n    required: true\n  bootdev:\n    description:\n      - Set boot device to use on next reboot\n    required: true\n    choices:\n      - network -- Request network boot\n      - floppy -- Boot from floppy\n      - hd -- Boot from hard drive\n      - safe -- Boot from hard drive, requesting 'safe mode'\n      - optical -- boot from CD/DVD/BD drive\n      - setup -- Boot into setup utility\n      - default -- remove any IPMI directed boot device request\n  state:\n    description:\n      - Whether to ensure that boot devices is desired.\n    default: present\n    choices:\n        - present -- Request system turn on\n        - absent -- Request system turn on\n  persistent:\n    description:\n      - If set, ask that system firmware uses this device beyond next boot.\n        Be aware many systems do not honor this.\n    type: bool\n    default: 'no'\n  uefiboot:\n    description:\n      - If set, request UEFI boot explicitly.\n        Strictly speaking, the spec suggests that if not set, the system should BIOS boot and offers no \"don't care\" option.\n        In practice, this flag not being set does not preclude UEFI boot on any system I've encountered.\n    type: bool\n    default: 'no'\nrequirements:\n  - \"python >= 2.6\"\n  - pyghmi\nauthor: \"Bulat Gaifullin (gaifullinbf@gmail.com)\"\n'''\n\nRETURN = '''\nbootdev:\n    description: The boot device name which will be used beyond next boot.\n    returned: success\n    type: string\n    sample: default\npersistent:\n    description: If True, system firmware will use this device beyond next boot.\n    returned: success\n    type: bool\n    sample: false\nuefimode:\n    description: If True, system firmware will use UEFI boot explicitly beyond next boot.\n    returned: success\n    type: bool\n    sample: false\n'''\n\nEXAMPLES = '''\n Ensure bootdevice is HD.\n- ipmi_boot:\n    name: test.testdomain.com\n    user: admin\n    password: password\n    bootdev: hd\n\n Ensure bootdevice is not Network\n- ipmi_boot:\n    name: test.testdomain.com\n    user: admin\n    password: password\n    bootdev: network\n    state: absent\n'''\n\ntry:\n    from pyghmi.ipmi import command\nexcept ImportError:\n    command = None\n\nfrom ansible.module_utils.basic import AnsibleModule\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            name=dict(required=True),\n            port=dict(default=623, type='int'),\n            user=dict(required=True, no_log=True),\n            password=dict(required=True, no_log=True),\n            state=dict(default='present', choices=['present', 'absent']),\n            bootdev=dict(required=True, choices=['network', 'hd', 'floppy', 'safe', 'optical', 'setup', 'default']),\n            persistent=dict(default=False, type='bool'),\n            uefiboot=dict(default=False, type='bool')\n        ),\n        supports_check_mode=True,\n    )\n\n    if command is None:\n        module.fail_json(msg='the python pyghmi module is required')\n\n    name = module.params['name']\n    port = module.params['port']\n    user = module.params['user']\n    password = module.params['password']\n    state = module.params['state']\n    bootdev = module.params['bootdev']\n    persistent = module.params['persistent']\n    uefiboot = module.params['uefiboot']\n    request = dict()\n\n    if state == 'absent' and bootdev == 'default':\n        module.fail_json(msg=\"The bootdev 'default' cannot be used with state 'absent'.\")\n\n     --- run command ---\n    try:\n        ipmi_cmd = command.Command(\n            bmc=name, userid=user, password=password, port=port\n        )\n        module.debug('ipmi instantiated - name: \"%s\"' % name)\n        current = ipmi_cmd.get_bootdev()\n         uefimode may not supported by BMC, so use desired value as default\n        current.setdefault('uefimode', uefiboot)\n        if state == 'present' and current != dict(bootdev=bootdev, persistent=persistent, uefimode=uefiboot):\n            request = dict(bootdev=bootdev, uefiboot=uefiboot, persist=persistent)\n        elif state == 'absent' and current['bootdev'] == bootdev:\n            request = dict(bootdev='default')\n        else:\n            module.exit_json(changed=False, **current)\n\n        if module.check_mode:\n            response = dict(bootdev=request['bootdev'])\n        else:\n            response = ipmi_cmd.set_bootdev(**request)\n\n        if 'error' in response:\n            module.fail_json(msg=response['error'])\n\n        if 'persist' in request:\n            response['persistent'] = request['persist']\n        if 'uefiboot' in request:\n            response['uefimode'] = request['uefiboot']\n\n        module.exit_json(changed=True, **response)\n    except Exception as e:\n        module.fail_json(msg=str(e))\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  ipmi boot short description  management order boot devices description      use module manage order boot devices version added   2 2  options    name      description          hostname ip address bmc      required  true   port      description          remote rmcp port      default  623   user      description          username use connect bmc      required  true   password      description          password connect bmc      required  true   bootdev      description          set boot device use next reboot     required  true     choices          network    request network boot         floppy    boot floppy         hd    boot hard drive         safe    boot hard drive  requesting  safe mode          optical    boot cd dvd bd drive         setup    boot setup utility         default    remove ipmi directed boot device request   state      description          whether ensure boot devices desired      default  present     choices            present    request system turn           absent    request system turn   persistent      description          if set  ask system firmware uses device beyond next boot          be aware many systems honor      type  bool     default      uefiboot      description          if set  request uefi boot explicitly          strictly speaking  spec suggests set  system bios boot offers  care  option          in practice  flag set preclude uefi boot system i encountered      type  bool     default    requirements       python    2 6      pyghmi author   bulat gaifullin (gaifullinbf gmail com)       return       bootdev      description  the boot device name used beyond next boot      returned  success     type  string     sample  default persistent      description  if true  system firmware use device beyond next boot      returned  success     type  bool     sample  false uefimode      description  if true  system firmware use uefi boot explicitly beyond next boot      returned  success     type  bool     sample  false      examples         ensure bootdevice hd    ipmi boot      name  test testdomain com     user  admin     password  password     bootdev  hd    ensure bootdevice network   ipmi boot      name  test testdomain com     user  admin     password  password     bootdev  network     state  absent         usr bin python        coding  utf 8           copyright  ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    ensure bootdevice hd     ensure bootdevice network        run command        uefimode may supported bmc  use desired value default ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n#\n# Copyright: Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: ipmi_boot\nshort_description: Management of order of boot devices\ndescription:\n  - Use this module to manage order of boot devices\nversion_added: \"2.2\"\noptions:\n  name:\n    description:\n      - Hostname or ip address of the BMC.\n    required: true\n  port:\n    description:\n      - Remote RMCP port.\n    default: 623\n  user:\n    description:\n      - Username to use to connect to the BMC.\n    required: true\n  password:\n    description:\n      - Password to connect to the BMC.\n    required: true\n  bootdev:\n    description:\n      - Set boot device to use on next reboot\n    required: true\n    choices:\n      - network -- Request network boot\n      - floppy -- Boot from floppy\n      - hd -- Boot from hard drive\n      - safe -- Boot from hard drive, requesting 'safe mode'\n      - optical -- boot from CD/DVD/BD drive\n      - setup -- Boot into setup utility\n      - default -- remove any IPMI directed boot device request\n  state:\n    description:\n      - Whether to ensure that boot devices is desired.\n    default: present\n    choices:\n        - present -- Request system turn on\n        - absent -- Request system turn on\n  persistent:\n    description:\n      - If set, ask that system firmware uses this device beyond next boot.\n        Be aware many systems do not honor this.\n    type: bool\n    default: 'no'\n  uefiboot:\n    description:\n      - If set, request UEFI boot explicitly.\n        Strictly speaking, the spec suggests that if not set, the system should BIOS boot and offers no \"don't care\" option.\n        In practice, this flag not being set does not preclude UEFI boot on any system I've encountered.\n    type: bool\n    default: 'no'\nrequirements:\n  - \"python >= 2.6\"\n  - pyghmi\nauthor: \"Bulat Gaifullin (gaifullinbf@gmail.com)\"\n'''\n\nRETURN = '''\nbootdev:\n    description: The boot device name which will be used beyond next boot.\n    returned: success\n    type: string\n    sample: default\npersistent:\n    description: If True, system firmware will use this device beyond next boot.\n    returned: success\n    type: bool\n    sample: false\nuefimode:\n    description: If True, system firmware will use UEFI boot explicitly beyond next boot.\n    returned: success\n    type: bool\n    sample: false\n'''\n\nEXAMPLES = '''\n# Ensure bootdevice is HD.\n- ipmi_boot:\n    name: test.testdomain.com\n    user: admin\n    password: password\n    bootdev: hd\n\n# Ensure bootdevice is not Network\n- ipmi_boot:\n    name: test.testdomain.com\n    user: admin\n    password: password\n    bootdev: network\n    state: absent\n'''\n\ntry:\n    from pyghmi.ipmi import command\nexcept ImportError:\n    command = None\n\nfrom ansible.module_utils.basic import AnsibleModule\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            name=dict(required=True),\n            port=dict(default=623, type='int'),\n            user=dict(required=True, no_log=True),\n            password=dict(required=True, no_log=True),\n            state=dict(default='present', choices=['present', 'absent']),\n            bootdev=dict(required=True, choices=['network', 'hd', 'floppy', 'safe', 'optical', 'setup', 'default']),\n            persistent=dict(default=False, type='bool'),\n            uefiboot=dict(default=False, type='bool')\n        ),\n        supports_check_mode=True,\n    )\n\n    if command is None:\n        module.fail_json(msg='the python pyghmi module is required')\n\n    name = module.params['name']\n    port = module.params['port']\n    user = module.params['user']\n    password = module.params['password']\n    state = module.params['state']\n    bootdev = module.params['bootdev']\n    persistent = module.params['persistent']\n    uefiboot = module.params['uefiboot']\n    request = dict()\n\n    if state == 'absent' and bootdev == 'default':\n        module.fail_json(msg=\"The bootdev 'default' cannot be used with state 'absent'.\")\n\n    # --- run command ---\n    try:\n        ipmi_cmd = command.Command(\n            bmc=name, userid=user, password=password, port=port\n        )\n        module.debug('ipmi instantiated - name: \"%s\"' % name)\n        current = ipmi_cmd.get_bootdev()\n        # uefimode may not supported by BMC, so use desired value as default\n        current.setdefault('uefimode', uefiboot)\n        if state == 'present' and current != dict(bootdev=bootdev, persistent=persistent, uefimode=uefiboot):\n            request = dict(bootdev=bootdev, uefiboot=uefiboot, persist=persistent)\n        elif state == 'absent' and current['bootdev'] == bootdev:\n            request = dict(bootdev='default')\n        else:\n            module.exit_json(changed=False, **current)\n\n        if module.check_mode:\n            response = dict(bootdev=request['bootdev'])\n        else:\n            response = ipmi_cmd.set_bootdev(**request)\n\n        if 'error' in response:\n            module.fail_json(msg=response['error'])\n\n        if 'persist' in request:\n            response['persistent'] = request['persist']\n        if 'uefiboot' in request:\n            response['uefimode'] = request['uefiboot']\n\n        module.exit_json(changed=True, **response)\n    except Exception as e:\n        module.fail_json(msg=str(e))\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "ipmi_boot.py", "id": "73bd72ee35e62f018f9aae0fa58fd902", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/remote_management/ipmi/ipmi_boot.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}