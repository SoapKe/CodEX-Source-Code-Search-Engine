{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_urllib_parse_urlparse,\n    compat_urlparse,\n)\nfrom ..utils import (\n    determine_ext,\n    extract_attributes,\n    int_or_none,\n    js_to_json,\n    mimetype2ext,\n    orderedSet,\n    parse_iso8601,\n)\n\n\nclass CondeNastIE(InfoExtractor):\n    \n\n    \n    \n    _SITES = {\n        'allure': 'Allure',\n        'architecturaldigest': 'Architectural Digest',\n        'arstechnica': 'Ars Technica',\n        'bonappetit': 'Bon App\u00e9tit',\n        'brides': 'Brides',\n        'cnevids': 'Cond\u00e9 Nast',\n        'cntraveler': 'Cond\u00e9 Nast Traveler',\n        'details': 'Details',\n        'epicurious': 'Epicurious',\n        'glamour': 'Glamour',\n        'golfdigest': 'Golf Digest',\n        'gq': 'GQ',\n        'newyorker': 'The New Yorker',\n        'self': 'SELF',\n        'teenvogue': 'Teen Vogue',\n        'vanityfair': 'Vanity Fair',\n        'vogue': 'Vogue',\n        'wired': 'WIRED',\n        'wmagazine': 'W Magazine',\n    }\n\n    _VALID_URL = r % '|'.join(_SITES.keys())\n    IE_DESC = 'Cond\u00e9 Nast media group: %s' % ', '.join(sorted(_SITES.values()))\n\n    EMBED_URL = r'(?:https?:)?//player(?:-backend)?\\.(?:%s)\\.com/(?:embed(?:js)?|(?:script|inline)/video)/.+?' % '|'.join(_SITES.keys())\n\n    _TESTS = [{\n        'url': 'http://video.wired.com/watch/3d-printed-speakers-lit-with-led',\n        'md5': '1921f713ed48aabd715691f774c451f7',\n        'info_dict': {\n            'id': '5171b343c2b4c00dd0c1ccb3',\n            'ext': 'mp4',\n            'title': '3D Printed Speakers Lit With LED',\n            'description': 'Check out these beautiful 3D printed LED speakers.  You can\\'t actually buy them, but LumiGeek is working on a board that will let you make you\\'re own.',\n            'uploader': 'wired',\n            'upload_date': '20130314',\n            'timestamp': 1363219200,\n        }\n    }, {\n        'url': 'http://video.gq.com/watch/the-closer-with-keith-olbermann-the-only-true-surprise-trump-s-an-idiot?c=series',\n        'info_dict': {\n            'id': '58d1865bfd2e6126e2000015',\n            'ext': 'mp4',\n            'title': 'The Only True Surprise? Trump\u2019s an Idiot',\n            'uploader': 'gq',\n            'upload_date': '20170321',\n            'timestamp': 1490126427,\n        },\n    }, {\n        \n        'url': 'http://player.cnevids.com/embedjs/55f9cf8b61646d1acf00000c/5511d76261646d5566020000.js',\n        'md5': 'f1a6f9cafb7083bab74a710f65d08999',\n        'info_dict': {\n            'id': '55f9cf8b61646d1acf00000c',\n            'ext': 'mp4',\n            'title': '3D printed TSA Travel Sentry keys really do open TSA locks',\n            'uploader': 'arstechnica',\n            'upload_date': '20150916',\n            'timestamp': 1442434955,\n        }\n    }, {\n        'url': 'https://player.cnevids.com/inline/video/59138decb57ac36b83000005.js?target=js-cne-player',\n        'only_matching': True,\n    }, {\n        'url': 'http://player-backend.cnevids.com/script/video/59138decb57ac36b83000005.js',\n        'only_matching': True,\n    }]\n\n    def _extract_series(self, url, webpage):\n        title = self._html_search_regex(\n            r'(?s)<div class=\"cne-series-info\">.*?<h1>(.+?)</h1>',\n            webpage, 'series title')\n        url_object = compat_urllib_parse_urlparse(url)\n        base_url = '%s://%s' % (url_object.scheme, url_object.netloc)\n        m_paths = re.finditer(\n            r'(?s)<p class=\"cne-thumb-title\">.*?<a href=\"(/watch/.+?)[\"\\?]', webpage)\n        paths = orderedSet(m.group(1) for m in m_paths)\n        build_url = lambda path: compat_urlparse.urljoin(base_url, path)\n        entries = [self.url_result(build_url(path), 'CondeNast') for path in paths]\n        return self.playlist_result(entries, playlist_title=title)\n\n    def _extract_video_params(self, webpage, display_id):\n        query = self._parse_json(\n            self._search_regex(\n                r'(?s)var\\s+params\\s*=\\s*({.+?})[;,]', webpage, 'player params',\n                default='{}'),\n            display_id, transform_source=js_to_json, fatal=False)\n        if query:\n            query['videoId'] = self._search_regex(\n                r'(?:data-video-id=|currentVideoId\\s*=\\s*)[\"\\']([\\da-f]+)',\n                webpage, 'video id', default=None)\n        else:\n            params = extract_attributes(self._search_regex(\n                r'(<[^>]+data-js=\"video-player\"[^>]+>)',\n                webpage, 'player params element'))\n            query.update({\n                'videoId': params['data-video'],\n                'playerId': params['data-player'],\n                'target': params['id'],\n            })\n        return query\n\n    def _extract_video(self, params):\n        video_id = params['videoId']\n\n        video_info = None\n\n        \n        query = params.copy()\n        query['embedType'] = 'inline'\n        info_page = self._download_json(\n            'http://player.cnevids.com/embed-api.json', video_id,\n            'Downloading embed info', fatal=False, query=query)\n\n        \n        if not info_page:\n            if params.get('playerId'):\n                info_page = self._download_json(\n                    'http://player.cnevids.com/player/video.js', video_id,\n                    'Downloading video info', fatal=False, query=params)\n        if info_page:\n            video_info = info_page.get('video')\n        if not video_info:\n            info_page = self._download_webpage(\n                'http://player.cnevids.com/player/loader.js',\n                video_id, 'Downloading loader info', query=params)\n        if not video_info:\n            info_page = self._download_webpage(\n                'https://player.cnevids.com/inline/video/%s.js' % video_id,\n                video_id, 'Downloading inline info', query={\n                    'target': params.get('target', 'embedplayer')\n                })\n\n        if not video_info:\n            video_info = self._parse_json(\n                self._search_regex(\n                    r'(?s)var\\s+config\\s*=\\s*({.+?});', info_page, 'config'),\n                video_id, transform_source=js_to_json)['video']\n\n        title = video_info['title']\n\n        formats = []\n        for fdata in video_info['sources']:\n            src = fdata.get('src')\n            if not src:\n                continue\n            ext = mimetype2ext(fdata.get('type')) or determine_ext(src)\n            if ext == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    src, video_id, 'mp4', entry_protocol='m3u8_native',\n                    m3u8_id='hls', fatal=False))\n                continue\n            quality = fdata.get('quality')\n            formats.append({\n                'format_id': ext + ('-%s' % quality if quality else ''),\n                'url': src,\n                'ext': ext,\n                'quality': 1 if quality == 'high' else 0,\n            })\n        self._sort_formats(formats)\n\n        return {\n            'id': video_id,\n            'formats': formats,\n            'title': title,\n            'thumbnail': video_info.get('poster_frame'),\n            'uploader': video_info.get('brand'),\n            'duration': int_or_none(video_info.get('duration')),\n            'tags': video_info.get('tags'),\n            'series': video_info.get('series_title'),\n            'season': video_info.get('season_title'),\n            'timestamp': parse_iso8601(video_info.get('premiere_date')),\n            'categories': video_info.get('categories'),\n        }\n\n    def _real_extract(self, url):\n        video_id, player_id, target, url_type, display_id = re.match(self._VALID_URL, url).groups()\n\n        if video_id:\n            return self._extract_video({\n                'videoId': video_id,\n                'playerId': player_id,\n                'target': target,\n            })\n\n        webpage = self._download_webpage(url, display_id)\n\n        if url_type == 'series':\n            return self._extract_series(url, webpage)\n        else:\n            params = self._extract_video_params(webpage, display_id)\n            info = self._search_json_ld(\n                webpage, display_id, fatal=False)\n            info.update(self._extract_video(params))\n            return info\n", "comments": "\n    Cond\u00e9 Nast is a media group, some of its sites use a custom HTML5 player\n    that works the same in all of them.\n    \n \n(?x)https?://(?:video|www|player(?:-backend)?)\\.(?:%s)\\.com/\n        (?:\n            (?:\n                embed(?:js)?|\n                (?:script|inline)/video\n            )/(?P<id>[0-9a-f]{24})(?:/(?P<player_id>[0-9a-f]{24}))?(?:.+?\\btarget=(?P<target>[^&]+))?|\n            (?P<type>watch|series|video)/(?P<display_id>[^/?#]+)\n        )\n)\n# coding: utf-8\n# The keys are the supported sites and the values are the name to be shown\n# to the user and in the extractor description.\n# JS embed\n# New API path\n# Old fallbacks\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_urllib_parse_urlparse,\n    compat_urlparse,\n)\nfrom ..utils import (\n    determine_ext,\n    extract_attributes,\n    int_or_none,\n    js_to_json,\n    mimetype2ext,\n    orderedSet,\n    parse_iso8601,\n)\n\n\nclass CondeNastIE(InfoExtractor):\n    \"\"\"\n    Cond\u00e9 Nast is a media group, some of its sites use a custom HTML5 player\n    that works the same in all of them.\n    \"\"\"\n\n    # The keys are the supported sites and the values are the name to be shown\n    # to the user and in the extractor description.\n    _SITES = {\n        'allure': 'Allure',\n        'architecturaldigest': 'Architectural Digest',\n        'arstechnica': 'Ars Technica',\n        'bonappetit': 'Bon App\u00e9tit',\n        'brides': 'Brides',\n        'cnevids': 'Cond\u00e9 Nast',\n        'cntraveler': 'Cond\u00e9 Nast Traveler',\n        'details': 'Details',\n        'epicurious': 'Epicurious',\n        'glamour': 'Glamour',\n        'golfdigest': 'Golf Digest',\n        'gq': 'GQ',\n        'newyorker': 'The New Yorker',\n        'self': 'SELF',\n        'teenvogue': 'Teen Vogue',\n        'vanityfair': 'Vanity Fair',\n        'vogue': 'Vogue',\n        'wired': 'WIRED',\n        'wmagazine': 'W Magazine',\n    }\n\n    _VALID_URL = r'''(?x)https?://(?:video|www|player(?:-backend)?)\\.(?:%s)\\.com/\n        (?:\n            (?:\n                embed(?:js)?|\n                (?:script|inline)/video\n            )/(?P<id>[0-9a-f]{24})(?:/(?P<player_id>[0-9a-f]{24}))?(?:.+?\\btarget=(?P<target>[^&]+))?|\n            (?P<type>watch|series|video)/(?P<display_id>[^/?#]+)\n        )''' % '|'.join(_SITES.keys())\n    IE_DESC = 'Cond\u00e9 Nast media group: %s' % ', '.join(sorted(_SITES.values()))\n\n    EMBED_URL = r'(?:https?:)?//player(?:-backend)?\\.(?:%s)\\.com/(?:embed(?:js)?|(?:script|inline)/video)/.+?' % '|'.join(_SITES.keys())\n\n    _TESTS = [{\n        'url': 'http://video.wired.com/watch/3d-printed-speakers-lit-with-led',\n        'md5': '1921f713ed48aabd715691f774c451f7',\n        'info_dict': {\n            'id': '5171b343c2b4c00dd0c1ccb3',\n            'ext': 'mp4',\n            'title': '3D Printed Speakers Lit With LED',\n            'description': 'Check out these beautiful 3D printed LED speakers.  You can\\'t actually buy them, but LumiGeek is working on a board that will let you make you\\'re own.',\n            'uploader': 'wired',\n            'upload_date': '20130314',\n            'timestamp': 1363219200,\n        }\n    }, {\n        'url': 'http://video.gq.com/watch/the-closer-with-keith-olbermann-the-only-true-surprise-trump-s-an-idiot?c=series',\n        'info_dict': {\n            'id': '58d1865bfd2e6126e2000015',\n            'ext': 'mp4',\n            'title': 'The Only True Surprise? Trump\u2019s an Idiot',\n            'uploader': 'gq',\n            'upload_date': '20170321',\n            'timestamp': 1490126427,\n        },\n    }, {\n        # JS embed\n        'url': 'http://player.cnevids.com/embedjs/55f9cf8b61646d1acf00000c/5511d76261646d5566020000.js',\n        'md5': 'f1a6f9cafb7083bab74a710f65d08999',\n        'info_dict': {\n            'id': '55f9cf8b61646d1acf00000c',\n            'ext': 'mp4',\n            'title': '3D printed TSA Travel Sentry keys really do open TSA locks',\n            'uploader': 'arstechnica',\n            'upload_date': '20150916',\n            'timestamp': 1442434955,\n        }\n    }, {\n        'url': 'https://player.cnevids.com/inline/video/59138decb57ac36b83000005.js?target=js-cne-player',\n        'only_matching': True,\n    }, {\n        'url': 'http://player-backend.cnevids.com/script/video/59138decb57ac36b83000005.js',\n        'only_matching': True,\n    }]\n\n    def _extract_series(self, url, webpage):\n        title = self._html_search_regex(\n            r'(?s)<div class=\"cne-series-info\">.*?<h1>(.+?)</h1>',\n            webpage, 'series title')\n        url_object = compat_urllib_parse_urlparse(url)\n        base_url = '%s://%s' % (url_object.scheme, url_object.netloc)\n        m_paths = re.finditer(\n            r'(?s)<p class=\"cne-thumb-title\">.*?<a href=\"(/watch/.+?)[\"\\?]', webpage)\n        paths = orderedSet(m.group(1) for m in m_paths)\n        build_url = lambda path: compat_urlparse.urljoin(base_url, path)\n        entries = [self.url_result(build_url(path), 'CondeNast') for path in paths]\n        return self.playlist_result(entries, playlist_title=title)\n\n    def _extract_video_params(self, webpage, display_id):\n        query = self._parse_json(\n            self._search_regex(\n                r'(?s)var\\s+params\\s*=\\s*({.+?})[;,]', webpage, 'player params',\n                default='{}'),\n            display_id, transform_source=js_to_json, fatal=False)\n        if query:\n            query['videoId'] = self._search_regex(\n                r'(?:data-video-id=|currentVideoId\\s*=\\s*)[\"\\']([\\da-f]+)',\n                webpage, 'video id', default=None)\n        else:\n            params = extract_attributes(self._search_regex(\n                r'(<[^>]+data-js=\"video-player\"[^>]+>)',\n                webpage, 'player params element'))\n            query.update({\n                'videoId': params['data-video'],\n                'playerId': params['data-player'],\n                'target': params['id'],\n            })\n        return query\n\n    def _extract_video(self, params):\n        video_id = params['videoId']\n\n        video_info = None\n\n        # New API path\n        query = params.copy()\n        query['embedType'] = 'inline'\n        info_page = self._download_json(\n            'http://player.cnevids.com/embed-api.json', video_id,\n            'Downloading embed info', fatal=False, query=query)\n\n        # Old fallbacks\n        if not info_page:\n            if params.get('playerId'):\n                info_page = self._download_json(\n                    'http://player.cnevids.com/player/video.js', video_id,\n                    'Downloading video info', fatal=False, query=params)\n        if info_page:\n            video_info = info_page.get('video')\n        if not video_info:\n            info_page = self._download_webpage(\n                'http://player.cnevids.com/player/loader.js',\n                video_id, 'Downloading loader info', query=params)\n        if not video_info:\n            info_page = self._download_webpage(\n                'https://player.cnevids.com/inline/video/%s.js' % video_id,\n                video_id, 'Downloading inline info', query={\n                    'target': params.get('target', 'embedplayer')\n                })\n\n        if not video_info:\n            video_info = self._parse_json(\n                self._search_regex(\n                    r'(?s)var\\s+config\\s*=\\s*({.+?});', info_page, 'config'),\n                video_id, transform_source=js_to_json)['video']\n\n        title = video_info['title']\n\n        formats = []\n        for fdata in video_info['sources']:\n            src = fdata.get('src')\n            if not src:\n                continue\n            ext = mimetype2ext(fdata.get('type')) or determine_ext(src)\n            if ext == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    src, video_id, 'mp4', entry_protocol='m3u8_native',\n                    m3u8_id='hls', fatal=False))\n                continue\n            quality = fdata.get('quality')\n            formats.append({\n                'format_id': ext + ('-%s' % quality if quality else ''),\n                'url': src,\n                'ext': ext,\n                'quality': 1 if quality == 'high' else 0,\n            })\n        self._sort_formats(formats)\n\n        return {\n            'id': video_id,\n            'formats': formats,\n            'title': title,\n            'thumbnail': video_info.get('poster_frame'),\n            'uploader': video_info.get('brand'),\n            'duration': int_or_none(video_info.get('duration')),\n            'tags': video_info.get('tags'),\n            'series': video_info.get('series_title'),\n            'season': video_info.get('season_title'),\n            'timestamp': parse_iso8601(video_info.get('premiere_date')),\n            'categories': video_info.get('categories'),\n        }\n\n    def _real_extract(self, url):\n        video_id, player_id, target, url_type, display_id = re.match(self._VALID_URL, url).groups()\n\n        if video_id:\n            return self._extract_video({\n                'videoId': video_id,\n                'playerId': player_id,\n                'target': target,\n            })\n\n        webpage = self._download_webpage(url, display_id)\n\n        if url_type == 'series':\n            return self._extract_series(url, webpage)\n        else:\n            params = self._extract_video_params(webpage, display_id)\n            info = self._search_json_ld(\n                webpage, display_id, fatal=False)\n            info.update(self._extract_video(params))\n            return info\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "condenast.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/condenast.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}