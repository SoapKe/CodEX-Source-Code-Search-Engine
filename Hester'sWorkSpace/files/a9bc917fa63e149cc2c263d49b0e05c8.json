{"author": "mitmproxy", "code": "import io\nimport contextlib\nimport os\nimport sys\nimport glob\nimport multiprocessing\nimport configparser\nimport itertools\nimport pytest\n\n\ndef run_tests(src, test, fail):\n    stderr = io.StringIO()\n    stdout = io.StringIO()\n    with contextlib.redirect_stderr(stderr):\n        with contextlib.redirect_stdout(stdout):\n            e = pytest.main([\n                '-qq',\n                '--disable-pytest-warnings',\n                '--no-faulthandler',\n                '--cov', src.replace('.py', '').replace('/', '.'),\n                '--cov-fail-under', '100',\n                '--cov-report', 'term-missing:skip-covered',\n                test\n            ])\n\n    if e == 0:\n        if fail:\n            print(\"UNEXPECTED SUCCESS:\", src, \"Please remove this file from setup.cfg tool:individual_coverage/exclude.\")\n            e = 42\n        else:\n            print(\"SUCCESS:           \", src)\n    else:\n        if fail:\n            print(\"IGNORING FAIL:     \", src)\n            e = 0\n        else:\n            cov = [l for l in stdout.getvalue().split(\"\\n\") if (src in l) or (\"was never imported\" in l)]\n            if len(cov) == 1:\n                print(\"FAIL:              \", cov[0])\n            else:\n                print(\"FAIL:              \", src, test, stdout.getvalue(), stdout.getvalue())\n                print(stderr.getvalue())\n                print(stdout.getvalue())\n\n    sys.exit(e)\n\n\ndef start_pytest(src, test, fail):\n    \n    proc = multiprocessing.Process(target=run_tests, args=(src, test, fail))\n    proc.start()\n    proc.join()\n    return (src, test, proc.exitcode)\n\n\ndef main():\n    c = configparser.ConfigParser()\n    c.read('setup.cfg')\n    fs = c['tool:individual_coverage']['exclude'].strip().split('\\n')\n    no_individual_cov = [f.strip() for f in fs]\n\n    excluded = ['mitmproxy/contrib/', 'mitmproxy/test/', 'mitmproxy/tools/', 'mitmproxy/platform/']\n    src_files = glob.glob('mitmproxy/**/*.py', recursive=True) + glob.glob('pathod/**/*.py', recursive=True)\n    src_files = [f for f in src_files if os.path.basename(f) != '__init__.py']\n    src_files = [f for f in src_files if not any(os.path.normpath(p) in f for p in excluded)]\n\n    ps = []\n    for src in sorted(src_files):\n        test = os.path.join(\"test\", os.path.dirname(src), \"test_\" + os.path.basename(src))\n        if os.path.isfile(test):\n            ps.append((src, test, src in no_individual_cov))\n\n    result = list(itertools.starmap(start_pytest, ps))\n\n    if any(e != 0 for _, _, e in result):\n        sys.exit(1)\n        pass\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "  run pytest new process  otherwise imports modules might conflict ", "content": "import io\nimport contextlib\nimport os\nimport sys\nimport glob\nimport multiprocessing\nimport configparser\nimport itertools\nimport pytest\n\n\ndef run_tests(src, test, fail):\n    stderr = io.StringIO()\n    stdout = io.StringIO()\n    with contextlib.redirect_stderr(stderr):\n        with contextlib.redirect_stdout(stdout):\n            e = pytest.main([\n                '-qq',\n                '--disable-pytest-warnings',\n                '--no-faulthandler',\n                '--cov', src.replace('.py', '').replace('/', '.'),\n                '--cov-fail-under', '100',\n                '--cov-report', 'term-missing:skip-covered',\n                test\n            ])\n\n    if e == 0:\n        if fail:\n            print(\"UNEXPECTED SUCCESS:\", src, \"Please remove this file from setup.cfg tool:individual_coverage/exclude.\")\n            e = 42\n        else:\n            print(\"SUCCESS:           \", src)\n    else:\n        if fail:\n            print(\"IGNORING FAIL:     \", src)\n            e = 0\n        else:\n            cov = [l for l in stdout.getvalue().split(\"\\n\") if (src in l) or (\"was never imported\" in l)]\n            if len(cov) == 1:\n                print(\"FAIL:              \", cov[0])\n            else:\n                print(\"FAIL:              \", src, test, stdout.getvalue(), stdout.getvalue())\n                print(stderr.getvalue())\n                print(stdout.getvalue())\n\n    sys.exit(e)\n\n\ndef start_pytest(src, test, fail):\n    # run pytest in a new process, otherwise imports and modules might conflict\n    proc = multiprocessing.Process(target=run_tests, args=(src, test, fail))\n    proc.start()\n    proc.join()\n    return (src, test, proc.exitcode)\n\n\ndef main():\n    c = configparser.ConfigParser()\n    c.read('setup.cfg')\n    fs = c['tool:individual_coverage']['exclude'].strip().split('\\n')\n    no_individual_cov = [f.strip() for f in fs]\n\n    excluded = ['mitmproxy/contrib/', 'mitmproxy/test/', 'mitmproxy/tools/', 'mitmproxy/platform/']\n    src_files = glob.glob('mitmproxy/**/*.py', recursive=True) + glob.glob('pathod/**/*.py', recursive=True)\n    src_files = [f for f in src_files if os.path.basename(f) != '__init__.py']\n    src_files = [f for f in src_files if not any(os.path.normpath(p) in f for p in excluded)]\n\n    ps = []\n    for src in sorted(src_files):\n        test = os.path.join(\"test\", os.path.dirname(src), \"test_\" + os.path.basename(src))\n        if os.path.isfile(test):\n            ps.append((src, test, src in no_individual_cov))\n\n    result = list(itertools.starmap(start_pytest, ps))\n\n    if any(e != 0 for _, _, e in result):\n        sys.exit(1)\n        pass\n\n\nif __name__ == '__main__':\n    main()\n", "description": "An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers.", "file_name": "individual_coverage.py", "id": "a9bc917fa63e149cc2c263d49b0e05c8", "language": "Python", "project_name": "mitmproxy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/mitmproxy-mitmproxy/mitmproxy-mitmproxy-0bc3f1f/test/individual_coverage.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:23:46Z", "url": "https://github.com/mitmproxy/mitmproxy", "wiki": false}