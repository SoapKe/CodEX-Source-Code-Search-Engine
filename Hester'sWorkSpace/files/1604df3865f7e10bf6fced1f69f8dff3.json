{"author": "sympy", "code": "from sympy.multipledispatch import dispatch, Dispatcher\nfrom sympy.core import Basic, Expr, Function, Add, Mul, Pow, Dummy, Integer\nfrom sympy import Min, Max, Set, sympify, Lambda, symbols, exp, log, S, oo\nfrom sympy.core.numbers import Infinity, NegativeInfinity, Zero\nfrom sympy.sets import (imageset, Interval, FiniteSet, Union, ImageSet,\n    ProductSet, EmptySet, Intersection)\nfrom sympy.core.function import FunctionClass\nfrom sympy.logic.boolalg import And, Or, Not, true, false\n\n\n_x, _y = symbols(\"x y\")\n\n\n@dispatch(Basic, Basic)\ndef _set_pow(x, y):\n    return None\n\n@dispatch(Set, Set)\ndef _set_pow(x, y):\n    return ImageSet(Lambda((_x, _y), (_x ** _y)), x, y)\n\n@dispatch(Expr, Expr)\ndef _set_pow(x, y):\n    return x**y\n\n@dispatch(Interval, Zero)\ndef _set_pow(x, z):\n    return FiniteSet(S.One)\n\n@dispatch(Interval, Integer)\ndef _set_pow(x, exponent):\n    \n    s1 = x.start**exponent\n    s2 = x.end**exponent\n    if ((s2 > s1) if exponent > 0 else (x.end > -x.start)) == True:\n        left_open = x.left_open\n        right_open = x.right_open\n        \n        sleft = s2\n    else:\n        \n        left_open = x.right_open\n        right_open = x.left_open\n        sleft = s1\n\n    if x.start.is_positive:\n        return Interval(\n            Min(s1, s2),\n            Max(s1, s2), left_open, right_open)\n    elif x.end.is_negative:\n        return Interval(\n            Min(s1, s2),\n            Max(s1, s2), left_open, right_open)\n\n    \n    if exponent.is_odd:\n        if exponent.is_negative:\n            if x.start.is_zero:\n                return Interval(s2, oo, x.right_open)\n            if x.end.is_zero:\n                return Interval(-oo, s1, True, x.left_open)\n            return Union(Interval(-oo, s1, True, x.left_open), Interval(s2, oo, x.right_open))\n        else:\n            return Interval(s1, s2, x.left_open, x.right_open)\n    elif exponent.is_even:\n        if exponent.is_negative:\n            if x.start.is_zero:\n                return Interval(s2, oo, x.right_open)\n            if x.end.is_zero:\n                return Interval(s1, oo, x.left_open)\n            return Interval(0, oo)\n        else:\n            return Interval(S.Zero, sleft, S.Zero not in x, left_open)\n\n@dispatch(Interval, Infinity)\ndef _set_pow(b, e):\n    ?\n    if b.start.is_nonnegative:\n        if b.end < 1:\n            return FiniteSet(S.Zero)\n        if b.start > 1:\n            return FiniteSet(S.Infinity)\n        return Interval(0, oo)\n    elif b.end.is_negative:\n        if b.start > -1:\n            return FiniteSet(S.Zero)\n        if b.end < -1:\n            return FiniteSet(-oo, oo)\n        return Interval(-oo, oo)\n    else:\n        if b.start > -1:\n            if b.end < 1:\n                return FiniteSet(S.Zero)\n            return Interval(0, oo)\n        return Interval(-oo, oo)\n\n@dispatch(Interval, NegativeInfinity)\ndef _set_pow(b, e):\n    from sympy.sets.setexpr import set_div\n    return _set_pow(set_div(S.One, b), oo)\n", "comments": "        powers interval arithmetic     https   en wikipedia org wiki interval arithmetic            todo  handle unevaluated condition     todo   s2   s1  could unevaluated     case x start   0 x end   0     todo  add logic open intervals  ", "content": "from sympy.multipledispatch import dispatch, Dispatcher\nfrom sympy.core import Basic, Expr, Function, Add, Mul, Pow, Dummy, Integer\nfrom sympy import Min, Max, Set, sympify, Lambda, symbols, exp, log, S, oo\nfrom sympy.core.numbers import Infinity, NegativeInfinity, Zero\nfrom sympy.sets import (imageset, Interval, FiniteSet, Union, ImageSet,\n    ProductSet, EmptySet, Intersection)\nfrom sympy.core.function import FunctionClass\nfrom sympy.logic.boolalg import And, Or, Not, true, false\n\n\n_x, _y = symbols(\"x y\")\n\n\n@dispatch(Basic, Basic)\ndef _set_pow(x, y):\n    return None\n\n@dispatch(Set, Set)\ndef _set_pow(x, y):\n    return ImageSet(Lambda((_x, _y), (_x ** _y)), x, y)\n\n@dispatch(Expr, Expr)\ndef _set_pow(x, y):\n    return x**y\n\n@dispatch(Interval, Zero)\ndef _set_pow(x, z):\n    return FiniteSet(S.One)\n\n@dispatch(Interval, Integer)\ndef _set_pow(x, exponent):\n    \"\"\"\n    Powers in interval arithmetic\n    https://en.wikipedia.org/wiki/Interval_arithmetic\n    \"\"\"\n    s1 = x.start**exponent\n    s2 = x.end**exponent\n    if ((s2 > s1) if exponent > 0 else (x.end > -x.start)) == True:\n        left_open = x.left_open\n        right_open = x.right_open\n        # TODO: handle unevaluated condition.\n        sleft = s2\n    else:\n        # TODO: `s2 > s1` could be unevaluated.\n        left_open = x.right_open\n        right_open = x.left_open\n        sleft = s1\n\n    if x.start.is_positive:\n        return Interval(\n            Min(s1, s2),\n            Max(s1, s2), left_open, right_open)\n    elif x.end.is_negative:\n        return Interval(\n            Min(s1, s2),\n            Max(s1, s2), left_open, right_open)\n\n    # Case where x.start < 0 and x.end > 0:\n    if exponent.is_odd:\n        if exponent.is_negative:\n            if x.start.is_zero:\n                return Interval(s2, oo, x.right_open)\n            if x.end.is_zero:\n                return Interval(-oo, s1, True, x.left_open)\n            return Union(Interval(-oo, s1, True, x.left_open), Interval(s2, oo, x.right_open))\n        else:\n            return Interval(s1, s2, x.left_open, x.right_open)\n    elif exponent.is_even:\n        if exponent.is_negative:\n            if x.start.is_zero:\n                return Interval(s2, oo, x.right_open)\n            if x.end.is_zero:\n                return Interval(s1, oo, x.left_open)\n            return Interval(0, oo)\n        else:\n            return Interval(S.Zero, sleft, S.Zero not in x, left_open)\n\n@dispatch(Interval, Infinity)\ndef _set_pow(b, e):\n    # TODO: add logic for open intervals?\n    if b.start.is_nonnegative:\n        if b.end < 1:\n            return FiniteSet(S.Zero)\n        if b.start > 1:\n            return FiniteSet(S.Infinity)\n        return Interval(0, oo)\n    elif b.end.is_negative:\n        if b.start > -1:\n            return FiniteSet(S.Zero)\n        if b.end < -1:\n            return FiniteSet(-oo, oo)\n        return Interval(-oo, oo)\n    else:\n        if b.start > -1:\n            if b.end < 1:\n                return FiniteSet(S.Zero)\n            return Interval(0, oo)\n        return Interval(-oo, oo)\n\n@dispatch(Interval, NegativeInfinity)\ndef _set_pow(b, e):\n    from sympy.sets.setexpr import set_div\n    return _set_pow(set_div(S.One, b), oo)\n", "description": "A computer algebra system written in pure Python", "file_name": "power.py", "id": "1604df3865f7e10bf6fced1f69f8dff3", "language": "Python", "project_name": "sympy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/sympy-sympy/sympy-sympy-205da79/sympy/sets/handlers/power.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:35:56Z", "url": "https://github.com/sympy/sympy", "wiki": true}