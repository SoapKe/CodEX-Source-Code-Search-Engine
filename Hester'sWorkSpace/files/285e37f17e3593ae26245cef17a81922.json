{"author": "keon", "code": "\"\"\"\nIt's similar to how human solve Sudoku.\n\ncreate a hash table (dictionary) val to store possible values in every location.\nEach time, start from the location with fewest possible values, choose one value\nfrom it and then update the board and possible values at other locations.\nIf this update is valid, keep solving (DFS). If this update is invalid (leaving\nzero possible values at some locations) or this value doesn't lead to the\nsolution, undo the updates and then choose the next value.\nSince we calculated val at the beginning and start filling the board from the\nlocation with fewest possible values, the amount of calculation and thus the\nruntime can be significantly reduced:\n\n\nThe run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest\npython solutions here.\n\n\nThe PossibleVals function may be further simplified/optimized, but it works just\nfine for now. (it would look less lengthy if we are allowed to use numpy array\nfor the board lol).\n\"\"\"\n\ndef solveSudoku(self, board):\n    self.board = board\n    self.val = self.PossibleVals()\n    self.Solver()\n\ndef PossibleVals(self):\n    a = \"123456789\"\n    d, val = {}, {}\n    for i in xrange(9):\n        for j in xrange(9):\n            ele = self.board[i][j]\n            if ele != \".\":\n                d[(\"r\", i)] = d.get((\"r\", i), []) + [ele]\n                d[(\"c\", j)] = d.get((\"c\", j), []) + [ele]\n                d[(i//3, j//3)] = d.get((i//3, j//3), []) + [ele]\n            else:\n                val[(i,j)] = []\n    for (i,j) in val.keys():\n        inval = d.get((\"r\",i),[])+d.get((\"c\",j),[])+d.get((i/3,j/3),[])\n        val[(i,j)] = [n for n in a if n not in inval ]\n    return val\n\ndef Solver(self):\n    if len(self.val)==0:\n        return True\n    kee = min(self.val.keys(), key=lambda x: len(self.val[x]))\n    nums = self.val[kee]\n    for n in nums:\n        update = {kee:self.val[kee]}\n        if self.ValidOne(n, kee, update): \n            if self.Solver(): \n                return True\n        self.undo(kee, update) \n    return False\n\ndef ValidOne(self, n, kee, update):\n    self.board[kee[0]][kee[1]] = n\n    del self.val[kee]\n    i, j = kee\n    for ind in self.val.keys():\n        if n in self.val[ind]:\n            if ind[0]==i or ind[1]==j or (ind[0]/3,ind[1]/3)==(i/3,j/3):\n                update[ind] = n\n                self.val[ind].remove(n)\n                if len(self.val[ind])==0:\n                    return False\n    return True\n\ndef undo(self, kee, update):\n    self.board[kee[0]][kee[1]]=\".\"\n    for k in update:\n        if k not in self.val:\n            self.val[k]= update[k]\n        else:\n            self.val[k].append(update[k])\n    return None\n", "comments": "    it similar human solve sudoku   create hash table (dictionary) val store possible values every location  each time  start location fewest possible values  choose one value update board possible values locations  if update valid  keep solving (dfs)  if update invalid (leaving zero possible values locations) value lead solution  undo updates choose next value  since calculated val beginning start filling board location fewest possible values  amount calculation thus runtime significantly reduced    the run time 48 68 ms leetcode oj  seems among fastest python solutions    the possiblevals function may simplified optimized  works fine  (it would look less lengthy allowed use numpy array board lol)         valid choice    keep solving    invalid choice solve    undo ", "content": "\"\"\"\nIt's similar to how human solve Sudoku.\n\ncreate a hash table (dictionary) val to store possible values in every location.\nEach time, start from the location with fewest possible values, choose one value\nfrom it and then update the board and possible values at other locations.\nIf this update is valid, keep solving (DFS). If this update is invalid (leaving\nzero possible values at some locations) or this value doesn't lead to the\nsolution, undo the updates and then choose the next value.\nSince we calculated val at the beginning and start filling the board from the\nlocation with fewest possible values, the amount of calculation and thus the\nruntime can be significantly reduced:\n\n\nThe run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest\npython solutions here.\n\n\nThe PossibleVals function may be further simplified/optimized, but it works just\nfine for now. (it would look less lengthy if we are allowed to use numpy array\nfor the board lol).\n\"\"\"\n\ndef solveSudoku(self, board):\n    self.board = board\n    self.val = self.PossibleVals()\n    self.Solver()\n\ndef PossibleVals(self):\n    a = \"123456789\"\n    d, val = {}, {}\n    for i in xrange(9):\n        for j in xrange(9):\n            ele = self.board[i][j]\n            if ele != \".\":\n                d[(\"r\", i)] = d.get((\"r\", i), []) + [ele]\n                d[(\"c\", j)] = d.get((\"c\", j), []) + [ele]\n                d[(i//3, j//3)] = d.get((i//3, j//3), []) + [ele]\n            else:\n                val[(i,j)] = []\n    for (i,j) in val.keys():\n        inval = d.get((\"r\",i),[])+d.get((\"c\",j),[])+d.get((i/3,j/3),[])\n        val[(i,j)] = [n for n in a if n not in inval ]\n    return val\n\ndef Solver(self):\n    if len(self.val)==0:\n        return True\n    kee = min(self.val.keys(), key=lambda x: len(self.val[x]))\n    nums = self.val[kee]\n    for n in nums:\n        update = {kee:self.val[kee]}\n        if self.ValidOne(n, kee, update): # valid choice\n            if self.Solver(): # keep solving\n                return True\n        self.undo(kee, update) # invalid choice or didn't solve it => undo\n    return False\n\ndef ValidOne(self, n, kee, update):\n    self.board[kee[0]][kee[1]] = n\n    del self.val[kee]\n    i, j = kee\n    for ind in self.val.keys():\n        if n in self.val[ind]:\n            if ind[0]==i or ind[1]==j or (ind[0]/3,ind[1]/3)==(i/3,j/3):\n                update[ind] = n\n                self.val[ind].remove(n)\n                if len(self.val[ind])==0:\n                    return False\n    return True\n\ndef undo(self, kee, update):\n    self.board[kee[0]][kee[1]]=\".\"\n    for k in update:\n        if k not in self.val:\n            self.val[k]= update[k]\n        else:\n            self.val[k].append(update[k])\n    return None\n", "description": "Minimal examples of data structures and algorithms in Python", "file_name": "sudoku_solver.py", "id": "285e37f17e3593ae26245cef17a81922", "language": "Python", "project_name": "algorithms", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/keon-algorithms/keon-algorithms-ea43887/dfs/sudoku_solver.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:53:29Z", "url": "https://github.com/keon/algorithms", "wiki": true}