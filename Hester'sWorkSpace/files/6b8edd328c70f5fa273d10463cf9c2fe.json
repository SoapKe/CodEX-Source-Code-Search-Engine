{"author": "django", "code": "import datetime\nimport unittest\n\nfrom django.apps.registry import Apps\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.test import TestCase\n\nfrom .models import (\n    CustomPKModel, FlexibleDatePost, ModelToValidate, Post, UniqueErrorsModel,\n    UniqueFieldsModel, UniqueForDateModel, UniqueTogetherModel,\n)\n\n\nclass GetUniqueCheckTests(unittest.TestCase):\n    def test_unique_fields_get_collected(self):\n        m = UniqueFieldsModel()\n        self.assertEqual(\n            ([(UniqueFieldsModel, ('id',)),\n              (UniqueFieldsModel, ('unique_charfield',)),\n              (UniqueFieldsModel, ('unique_integerfield',))],\n             []),\n            m._get_unique_checks()\n        )\n\n    def test_unique_together_gets_picked_up_and_converted_to_tuple(self):\n        m = UniqueTogetherModel()\n        self.assertEqual(\n            ([(UniqueTogetherModel, ('ifield', 'cfield')),\n              (UniqueTogetherModel, ('ifield', 'efield')),\n              (UniqueTogetherModel, ('id',))],\n             []),\n            m._get_unique_checks()\n        )\n\n    def test_unique_together_normalization(self):\n        \"\"\"\n        Test the Meta.unique_together normalization with different sorts of\n        objects.\n        \"\"\"\n        data = {\n            '2-tuple': (('foo', 'bar'), (('foo', 'bar'),)),\n            'list': (['foo', 'bar'], (('foo', 'bar'),)),\n            'already normalized': ((('foo', 'bar'), ('bar', 'baz')),\n                                   (('foo', 'bar'), ('bar', 'baz'))),\n            'set': ({('foo', 'bar'), ('bar', 'baz')},  \n                    (('foo', 'bar'), ('bar', 'baz'))),\n        }\n\n        for unique_together, normalized in data.values():\n            class M(models.Model):\n                foo = models.IntegerField()\n                bar = models.IntegerField()\n                baz = models.IntegerField()\n\n                Meta = type('Meta', (), {\n                    'unique_together': unique_together,\n                    'apps': Apps()\n                })\n\n            checks, _ = M()._get_unique_checks()\n            for t in normalized:\n                check = (M, t)\n                self.assertIn(check, checks)\n\n    def test_primary_key_is_considered_unique(self):\n        m = CustomPKModel()\n        self.assertEqual(([(CustomPKModel, ('my_pk_field',))], []), m._get_unique_checks())\n\n    def test_unique_for_date_gets_picked_up(self):\n        m = UniqueForDateModel()\n        self.assertEqual((\n            [(UniqueForDateModel, ('id',))],\n            [(UniqueForDateModel, 'date', 'count', 'start_date'),\n             (UniqueForDateModel, 'year', 'count', 'end_date'),\n             (UniqueForDateModel, 'month', 'order', 'end_date')]\n        ), m._get_unique_checks()\n        )\n\n    def test_unique_for_date_exclusion(self):\n        m = UniqueForDateModel()\n        self.assertEqual((\n            [(UniqueForDateModel, ('id',))],\n            [(UniqueForDateModel, 'year', 'count', 'end_date'),\n             (UniqueForDateModel, 'month', 'order', 'end_date')]\n        ), m._get_unique_checks(exclude='start_date')\n        )\n\n\nclass PerformUniqueChecksTest(TestCase):\n    def test_primary_key_unique_check_not_performed_when_adding_and_pk_not_specified(self):\n        \n        with self.assertNumQueries(0):\n            mtv = ModelToValidate(number=10, name='Some Name')\n            setattr(mtv, '_adding', True)\n            mtv.full_clean()\n\n    def test_primary_key_unique_check_performed_when_adding_and_pk_specified(self):\n        \n        with self.assertNumQueries(1):\n            mtv = ModelToValidate(number=10, name='Some Name', id=123)\n            setattr(mtv, '_adding', True)\n            mtv.full_clean()\n\n    def test_primary_key_unique_check_not_performed_when_not_adding(self):\n        \n        with self.assertNumQueries(0):\n            mtv = ModelToValidate(number=10, name='Some Name')\n            mtv.full_clean()\n\n    def test_unique_for_date(self):\n        Post.objects.create(\n            title=\"Django 1.0 is released\", slug=\"Django 1.0\",\n            subtitle=\"Finally\", posted=datetime.date(2008, 9, 3),\n        )\n        p = Post(title=\"Django 1.0 is released\", posted=datetime.date(2008, 9, 3))\n        with self.assertRaises(ValidationError) as cm:\n            p.full_clean()\n        self.assertEqual(cm.exception.message_dict, {'title': ['Title must be unique for Posted date.']})\n\n        \n        p = Post(title=\"Work on Django 1.1 begins\", posted=datetime.date(2008, 9, 3))\n        p.full_clean()\n\n        \n        p = Post(title=\"Django 1.0 is released\", posted=datetime.datetime(2008, 9, 4))\n        p.full_clean()\n\n        p = Post(slug=\"Django 1.0\", posted=datetime.datetime(2008, 1, 1))\n        with self.assertRaises(ValidationError) as cm:\n            p.full_clean()\n        self.assertEqual(cm.exception.message_dict, {'slug': ['Slug must be unique for Posted year.']})\n\n        p = Post(subtitle=\"Finally\", posted=datetime.datetime(2008, 9, 30))\n        with self.assertRaises(ValidationError) as cm:\n            p.full_clean()\n        self.assertEqual(cm.exception.message_dict, {'subtitle': ['Subtitle must be unique for Posted month.']})\n\n        p = Post(title=\"Django 1.0 is released\")\n        with self.assertRaises(ValidationError) as cm:\n            p.full_clean()\n        self.assertEqual(cm.exception.message_dict, {'posted': ['This field cannot be null.']})\n\n    def test_unique_for_date_with_nullable_date(self):\n        \"\"\"\n        unique_for_date/year/month checks shouldn't trigger when the\n        associated DateField is None.\n        \"\"\"\n        FlexibleDatePost.objects.create(\n            title=\"Django 1.0 is released\", slug=\"Django 1.0\",\n            subtitle=\"Finally\", posted=datetime.date(2008, 9, 3),\n        )\n        p = FlexibleDatePost(title=\"Django 1.0 is released\")\n        p.full_clean()\n\n        p = FlexibleDatePost(slug=\"Django 1.0\")\n        p.full_clean()\n\n        p = FlexibleDatePost(subtitle=\"Finally\")\n        p.full_clean()\n\n    def test_unique_errors(self):\n        UniqueErrorsModel.objects.create(name='Some Name', no=10)\n        m = UniqueErrorsModel(name='Some Name', no=11)\n        with self.assertRaises(ValidationError) as cm:\n            m.full_clean()\n        self.assertEqual(cm.exception.message_dict, {'name': ['Custom unique name message.']})\n\n        m = UniqueErrorsModel(name='Some Other Name', no=10)\n        with self.assertRaises(ValidationError) as cm:\n            m.full_clean()\n        self.assertEqual(cm.exception.message_dict, {'no': ['Custom unique number message.']})\n", "comments": "            test meta unique together normalization different sorts         objects                      data                  2 tuple   (( foo    bar )  (( foo    bar ) ))               list   (  foo    bar    (( foo    bar ) ))               already normalized   ((( foo    bar )  ( bar    baz ))                                     (( foo    bar )  ( bar    baz )))               set   ( ( foo    bar )  ( bar    baz )      ref  21469                     (( foo    bar )  ( bar    baz )))                     unique together  normalized data values()              class m(models model)                  foo   models integerfield()                 bar   models integerfield()                 baz   models integerfield()                  meta   type( meta   ()                         unique together   unique together                       apps   apps()                  )              checks      m()  get unique checks()             normalized                  check   (m  t)                 self assertin(check  checks)      def test primary key considered unique(self)            custompkmodel()         self assertequal(( (custompkmodel  ( pk field  ))     )   get unique checks())      def test unique date gets picked up(self)            uniquefordatemodel()         self assertequal((              (uniquefordatemodel  ( id  ))                (uniquefordatemodel   date    count    start date )               (uniquefordatemodel   year    count    end date )               (uniquefordatemodel   month    order    end date )          )   get unique checks()         )      def test unique date exclusion(self)            uniquefordatemodel()         self assertequal((              (uniquefordatemodel  ( id  ))                (uniquefordatemodel   year    count    end date )               (uniquefordatemodel   month    order    end date )          )   get unique checks(exclude  start date )         )   class performuniquecheckstest(testcase)      def test primary key unique check performed adding pk specified(self)            regression test  12560         self assertnumqueries(0)              mtv   modeltovalidate(number 10  name  some name )             setattr(mtv    adding   true)             mtv full clean()      def test primary key unique check performed adding pk specified(self)            regression test  12560         self assertnumqueries(1)              mtv   modeltovalidate(number 10  name  some name   id 123)             setattr(mtv    adding   true)             mtv full clean()      def test primary key unique check performed adding(self)            regression test  12132         self assertnumqueries(0)              mtv   modeltovalidate(number 10  name  some name )             mtv full clean()      def test unique date(self)          post objects create(             title  django 1 0 released   slug  django 1 0               subtitle  finally   posted datetime date(2008  9  3)          )         p   post(title  django 1 0 released   posted datetime date(2008  9  3))         self assertraises(validationerror) cm              p full clean()         self assertequal(cm exception message dict    title     title must unique posted date    )            should work without errors         p   post(title  work django 1 1 begins   posted datetime date(2008  9  3))         p full clean()            should work without errors         p   post(title  django 1 0 released   posted datetime datetime(2008  9  4))         p full clean()          p   post(slug  django 1 0   posted datetime datetime(2008  1  1))         self assertraises(validationerror) cm              p full clean()         self assertequal(cm exception message dict    slug     slug must unique posted year    )          p   post(subtitle  finally   posted datetime datetime(2008  9  30))         self assertraises(validationerror) cm              p full clean()         self assertequal(cm exception message dict    subtitle     subtitle must unique posted month    )          p   post(title  django 1 0 released )         self assertraises(validationerror) cm              p full clean()         self assertequal(cm exception message dict    posted     this field cannot null    )      def test unique date nullable date(self)                      unique date year month checks trigger         associated datefield none                 ref  21469    regression test  12560    regression test  12560    regression test  12132    should work without errors    should work without errors ", "content": "import datetime\nimport unittest\n\nfrom django.apps.registry import Apps\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.test import TestCase\n\nfrom .models import (\n    CustomPKModel, FlexibleDatePost, ModelToValidate, Post, UniqueErrorsModel,\n    UniqueFieldsModel, UniqueForDateModel, UniqueTogetherModel,\n)\n\n\nclass GetUniqueCheckTests(unittest.TestCase):\n    def test_unique_fields_get_collected(self):\n        m = UniqueFieldsModel()\n        self.assertEqual(\n            ([(UniqueFieldsModel, ('id',)),\n              (UniqueFieldsModel, ('unique_charfield',)),\n              (UniqueFieldsModel, ('unique_integerfield',))],\n             []),\n            m._get_unique_checks()\n        )\n\n    def test_unique_together_gets_picked_up_and_converted_to_tuple(self):\n        m = UniqueTogetherModel()\n        self.assertEqual(\n            ([(UniqueTogetherModel, ('ifield', 'cfield')),\n              (UniqueTogetherModel, ('ifield', 'efield')),\n              (UniqueTogetherModel, ('id',))],\n             []),\n            m._get_unique_checks()\n        )\n\n    def test_unique_together_normalization(self):\n        \"\"\"\n        Test the Meta.unique_together normalization with different sorts of\n        objects.\n        \"\"\"\n        data = {\n            '2-tuple': (('foo', 'bar'), (('foo', 'bar'),)),\n            'list': (['foo', 'bar'], (('foo', 'bar'),)),\n            'already normalized': ((('foo', 'bar'), ('bar', 'baz')),\n                                   (('foo', 'bar'), ('bar', 'baz'))),\n            'set': ({('foo', 'bar'), ('bar', 'baz')},  # Ref #21469\n                    (('foo', 'bar'), ('bar', 'baz'))),\n        }\n\n        for unique_together, normalized in data.values():\n            class M(models.Model):\n                foo = models.IntegerField()\n                bar = models.IntegerField()\n                baz = models.IntegerField()\n\n                Meta = type('Meta', (), {\n                    'unique_together': unique_together,\n                    'apps': Apps()\n                })\n\n            checks, _ = M()._get_unique_checks()\n            for t in normalized:\n                check = (M, t)\n                self.assertIn(check, checks)\n\n    def test_primary_key_is_considered_unique(self):\n        m = CustomPKModel()\n        self.assertEqual(([(CustomPKModel, ('my_pk_field',))], []), m._get_unique_checks())\n\n    def test_unique_for_date_gets_picked_up(self):\n        m = UniqueForDateModel()\n        self.assertEqual((\n            [(UniqueForDateModel, ('id',))],\n            [(UniqueForDateModel, 'date', 'count', 'start_date'),\n             (UniqueForDateModel, 'year', 'count', 'end_date'),\n             (UniqueForDateModel, 'month', 'order', 'end_date')]\n        ), m._get_unique_checks()\n        )\n\n    def test_unique_for_date_exclusion(self):\n        m = UniqueForDateModel()\n        self.assertEqual((\n            [(UniqueForDateModel, ('id',))],\n            [(UniqueForDateModel, 'year', 'count', 'end_date'),\n             (UniqueForDateModel, 'month', 'order', 'end_date')]\n        ), m._get_unique_checks(exclude='start_date')\n        )\n\n\nclass PerformUniqueChecksTest(TestCase):\n    def test_primary_key_unique_check_not_performed_when_adding_and_pk_not_specified(self):\n        # Regression test for #12560\n        with self.assertNumQueries(0):\n            mtv = ModelToValidate(number=10, name='Some Name')\n            setattr(mtv, '_adding', True)\n            mtv.full_clean()\n\n    def test_primary_key_unique_check_performed_when_adding_and_pk_specified(self):\n        # Regression test for #12560\n        with self.assertNumQueries(1):\n            mtv = ModelToValidate(number=10, name='Some Name', id=123)\n            setattr(mtv, '_adding', True)\n            mtv.full_clean()\n\n    def test_primary_key_unique_check_not_performed_when_not_adding(self):\n        # Regression test for #12132\n        with self.assertNumQueries(0):\n            mtv = ModelToValidate(number=10, name='Some Name')\n            mtv.full_clean()\n\n    def test_unique_for_date(self):\n        Post.objects.create(\n            title=\"Django 1.0 is released\", slug=\"Django 1.0\",\n            subtitle=\"Finally\", posted=datetime.date(2008, 9, 3),\n        )\n        p = Post(title=\"Django 1.0 is released\", posted=datetime.date(2008, 9, 3))\n        with self.assertRaises(ValidationError) as cm:\n            p.full_clean()\n        self.assertEqual(cm.exception.message_dict, {'title': ['Title must be unique for Posted date.']})\n\n        # Should work without errors\n        p = Post(title=\"Work on Django 1.1 begins\", posted=datetime.date(2008, 9, 3))\n        p.full_clean()\n\n        # Should work without errors\n        p = Post(title=\"Django 1.0 is released\", posted=datetime.datetime(2008, 9, 4))\n        p.full_clean()\n\n        p = Post(slug=\"Django 1.0\", posted=datetime.datetime(2008, 1, 1))\n        with self.assertRaises(ValidationError) as cm:\n            p.full_clean()\n        self.assertEqual(cm.exception.message_dict, {'slug': ['Slug must be unique for Posted year.']})\n\n        p = Post(subtitle=\"Finally\", posted=datetime.datetime(2008, 9, 30))\n        with self.assertRaises(ValidationError) as cm:\n            p.full_clean()\n        self.assertEqual(cm.exception.message_dict, {'subtitle': ['Subtitle must be unique for Posted month.']})\n\n        p = Post(title=\"Django 1.0 is released\")\n        with self.assertRaises(ValidationError) as cm:\n            p.full_clean()\n        self.assertEqual(cm.exception.message_dict, {'posted': ['This field cannot be null.']})\n\n    def test_unique_for_date_with_nullable_date(self):\n        \"\"\"\n        unique_for_date/year/month checks shouldn't trigger when the\n        associated DateField is None.\n        \"\"\"\n        FlexibleDatePost.objects.create(\n            title=\"Django 1.0 is released\", slug=\"Django 1.0\",\n            subtitle=\"Finally\", posted=datetime.date(2008, 9, 3),\n        )\n        p = FlexibleDatePost(title=\"Django 1.0 is released\")\n        p.full_clean()\n\n        p = FlexibleDatePost(slug=\"Django 1.0\")\n        p.full_clean()\n\n        p = FlexibleDatePost(subtitle=\"Finally\")\n        p.full_clean()\n\n    def test_unique_errors(self):\n        UniqueErrorsModel.objects.create(name='Some Name', no=10)\n        m = UniqueErrorsModel(name='Some Name', no=11)\n        with self.assertRaises(ValidationError) as cm:\n            m.full_clean()\n        self.assertEqual(cm.exception.message_dict, {'name': ['Custom unique name message.']})\n\n        m = UniqueErrorsModel(name='Some Other Name', no=10)\n        with self.assertRaises(ValidationError) as cm:\n            m.full_clean()\n        self.assertEqual(cm.exception.message_dict, {'no': ['Custom unique number message.']})\n", "description": "The Web framework for perfectionists with deadlines.", "file_name": "test_unique.py", "id": "6b8edd328c70f5fa273d10463cf9c2fe", "language": "Python", "project_name": "django", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/django-django/django-django-acfc650/tests/validation/test_unique.py", "save_time": "", "source": "", "update_at": "2018-03-14T02:00:36Z", "url": "https://github.com/django/django", "wiki": false}