{"author": "mitmproxy", "code": "import time\n\nfrom mitmproxy.utils import strutils\nfrom mitmproxy.utils import human\n\n\ndef write_raw(fp, lines, timestamp=True):\n    if fp:\n        if timestamp:\n            fp.write(human.format_timestamp(time.time()))\n        for i in lines:\n            fp.write(i)\n        fp.write(\"\\n\")\n        fp.flush()\n\n\nclass LogCtx:\n\n    def __init__(self, fp, hex, timestamp, rfile, wfile):\n        self.lines = []\n        self.fp = fp\n        self.suppressed = False\n        self.hex = hex\n        self.timestamp = timestamp\n        self.rfile, self.wfile = rfile, wfile\n\n    def __enter__(self):\n        if self.wfile:\n            self.wfile.start_log()\n        if self.rfile:\n            self.rfile.start_log()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        wlog = self.wfile.get_log() if self.wfile else None\n        rlog = self.rfile.get_log() if self.rfile else None\n        if self.suppressed or not self.fp:\n            return\n        if wlog:\n            self(\"Bytes written:\")\n            self.dump(wlog, self.hex)\n        if rlog:\n            self(\"Bytes read:\")\n            self.dump(rlog, self.hex)\n        if self.lines:\n            write_raw(\n                self.fp,\n                [\n                    \"\\n\".join(self.lines),\n                ],\n                timestamp = self.timestamp\n            )\n        if exc_value:\n            raise exc_value\n\n    def suppress(self):\n        self.suppressed = True\n\n    def dump(self, data, hexdump):\n        if hexdump:\n            for line in strutils.hexdump(data):\n                self(\"\\t%s %s %s\" % line)\n        else:\n            data = strutils.always_str(\n                strutils.escape_control_characters(\n                    data\n                        .decode(\"ascii\", \"replace\")\n                        .replace(u\"\\ufffd\", u\".\")\n                )\n            )\n            for i in data.split(\"\\n\"):\n                self(\"\\t%s\" % i)\n\n    def __call__(self, line):\n        self.lines.append(line)\n\n\nclass ConnectionLogger:\n    def __init__(self, fp, hex, timestamp, rfile, wfile):\n        self.fp = fp\n        self.hex = hex\n        self.rfile, self.wfile = rfile, wfile\n        self.timestamp = timestamp\n\n    def ctx(self):\n        return LogCtx(self.fp, self.hex, self.timestamp, self.rfile, self.wfile)\n\n    def write(self, lines):\n        write_raw(self.fp, lines, timestamp=self.timestamp)\n", "comments": "", "content": "import time\n\nfrom mitmproxy.utils import strutils\nfrom mitmproxy.utils import human\n\n\ndef write_raw(fp, lines, timestamp=True):\n    if fp:\n        if timestamp:\n            fp.write(human.format_timestamp(time.time()))\n        for i in lines:\n            fp.write(i)\n        fp.write(\"\\n\")\n        fp.flush()\n\n\nclass LogCtx:\n\n    def __init__(self, fp, hex, timestamp, rfile, wfile):\n        self.lines = []\n        self.fp = fp\n        self.suppressed = False\n        self.hex = hex\n        self.timestamp = timestamp\n        self.rfile, self.wfile = rfile, wfile\n\n    def __enter__(self):\n        if self.wfile:\n            self.wfile.start_log()\n        if self.rfile:\n            self.rfile.start_log()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        wlog = self.wfile.get_log() if self.wfile else None\n        rlog = self.rfile.get_log() if self.rfile else None\n        if self.suppressed or not self.fp:\n            return\n        if wlog:\n            self(\"Bytes written:\")\n            self.dump(wlog, self.hex)\n        if rlog:\n            self(\"Bytes read:\")\n            self.dump(rlog, self.hex)\n        if self.lines:\n            write_raw(\n                self.fp,\n                [\n                    \"\\n\".join(self.lines),\n                ],\n                timestamp = self.timestamp\n            )\n        if exc_value:\n            raise exc_value\n\n    def suppress(self):\n        self.suppressed = True\n\n    def dump(self, data, hexdump):\n        if hexdump:\n            for line in strutils.hexdump(data):\n                self(\"\\t%s %s %s\" % line)\n        else:\n            data = strutils.always_str(\n                strutils.escape_control_characters(\n                    data\n                        .decode(\"ascii\", \"replace\")\n                        .replace(u\"\\ufffd\", u\".\")\n                )\n            )\n            for i in data.split(\"\\n\"):\n                self(\"\\t%s\" % i)\n\n    def __call__(self, line):\n        self.lines.append(line)\n\n\nclass ConnectionLogger:\n    def __init__(self, fp, hex, timestamp, rfile, wfile):\n        self.fp = fp\n        self.hex = hex\n        self.rfile, self.wfile = rfile, wfile\n        self.timestamp = timestamp\n\n    def ctx(self):\n        return LogCtx(self.fp, self.hex, self.timestamp, self.rfile, self.wfile)\n\n    def write(self, lines):\n        write_raw(self.fp, lines, timestamp=self.timestamp)\n", "description": "An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers.", "file_name": "log.py", "id": "51ccd9ae5f9b0e85690ee3df59bdbaf5", "language": "Python", "project_name": "mitmproxy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mitmproxy-mitmproxy/mitmproxy-mitmproxy-3c7725a/pathod/log.py", "save_time": "", "source": "", "update_at": "2018-03-18T11:30:56Z", "url": "https://github.com/mitmproxy/mitmproxy", "wiki": false}