{"author": "django", "code": "import pickle\nimport time\nfrom datetime import datetime\n\nfrom django.template import engines\nfrom django.template.response import (\n    ContentNotRenderedError, SimpleTemplateResponse, TemplateResponse,\n)\nfrom django.test import (\n    RequestFactory, SimpleTestCase, modify_settings, override_settings,\n)\nfrom django.test.utils import require_jinja2\nfrom django.utils.deprecation import MiddlewareMixin\n\nfrom .utils import TEMPLATE_DIR\n\n\ndef test_processor(request):\n    return {'processors': 'yes'}\n\n\ntest_processor_name = 'template_tests.test_response.test_processor'\n\n\n\nclass CustomURLConfMiddleware(MiddlewareMixin):\n    def process_request(self, request):\n        request.urlconf = 'template_tests.alternate_urls'\n\n\nclass SimpleTemplateResponseTest(SimpleTestCase):\n\n    def _response(self, template='foo', *args, **kwargs):\n        template = engines['django'].from_string(template)\n        return SimpleTemplateResponse(template, *args, **kwargs)\n\n    def test_template_resolving(self):\n        response = SimpleTemplateResponse('first/test.html')\n        response.render()\n        self.assertEqual(response.content, b'First template\\n')\n\n        templates = ['foo.html', 'second/test.html', 'first/test.html']\n        response = SimpleTemplateResponse(templates)\n        response.render()\n        self.assertEqual(response.content, b'Second template\\n')\n\n        response = self._response()\n        response.render()\n        self.assertEqual(response.content, b'foo')\n\n    def test_explicit_baking(self):\n        \n        response = self._response()\n        self.assertFalse(response.is_rendered)\n        response.render()\n        self.assertTrue(response.is_rendered)\n\n    def test_render(self):\n        \n        response = self._response().render()\n        self.assertEqual(response.content, b'foo')\n\n        \n        template = engines['django'].from_string('bar{{ baz }}')\n        response.template_name = template\n        response.render()\n        self.assertEqual(response.content, b'foo')\n\n        \n        \n        response.content = 'bar'\n        self.assertEqual(response.content, b'bar')\n\n    def test_iteration_unrendered(self):\n        \n        response = self._response()\n        self.assertFalse(response.is_rendered)\n\n        def iteration():\n            for x in response:\n                pass\n        with self.assertRaises(ContentNotRenderedError):\n            iteration()\n        self.assertFalse(response.is_rendered)\n\n    def test_iteration_rendered(self):\n        \n        response = self._response().render()\n        res = [x for x in response]\n        self.assertEqual(res, [b'foo'])\n\n    def test_content_access_unrendered(self):\n        \n        response = self._response()\n        self.assertFalse(response.is_rendered)\n        with self.assertRaises(ContentNotRenderedError):\n            response.content\n        self.assertFalse(response.is_rendered)\n\n    def test_content_access_rendered(self):\n        \n        response = self._response().render()\n        self.assertEqual(response.content, b'foo')\n\n    def test_set_content(self):\n        \n        response = self._response()\n        self.assertFalse(response.is_rendered)\n        response.content = 'spam'\n        self.assertTrue(response.is_rendered)\n        self.assertEqual(response.content, b'spam')\n        response.content = 'baz'\n        self.assertEqual(response.content, b'baz')\n\n    def test_dict_context(self):\n        response = self._response('{{ foo }}{{ processors }}',\n                                  {'foo': 'bar'})\n        self.assertEqual(response.context_data, {'foo': 'bar'})\n        response.render()\n        self.assertEqual(response.content, b'bar')\n\n    def test_kwargs(self):\n        response = self._response(content_type='application/json', status=504, charset='ascii')\n        self.assertEqual(response['content-type'], 'application/json')\n        self.assertEqual(response.status_code, 504)\n        self.assertEqual(response.charset, 'ascii')\n\n    def test_args(self):\n        response = SimpleTemplateResponse('', {}, 'application/json', 504)\n        self.assertEqual(response['content-type'], 'application/json')\n        self.assertEqual(response.status_code, 504)\n\n    @require_jinja2\n    def test_using(self):\n        response = SimpleTemplateResponse('template_tests/using.html').render()\n        self.assertEqual(response.content, b'DTL\\n')\n        response = SimpleTemplateResponse('template_tests/using.html', using='django').render()\n        self.assertEqual(response.content, b'DTL\\n')\n        response = SimpleTemplateResponse('template_tests/using.html', using='jinja2').render()\n        self.assertEqual(response.content, b'Jinja2\\n')\n\n    def test_post_callbacks(self):\n        \"Rendering a template response triggers the post-render callbacks\"\n        post = []\n\n        def post1(obj):\n            post.append('post1')\n\n        def post2(obj):\n            post.append('post2')\n\n        response = SimpleTemplateResponse('first/test.html', {})\n        response.add_post_render_callback(post1)\n        response.add_post_render_callback(post2)\n\n        \n        response.render()\n        self.assertEqual(response.content, b'First template\\n')\n        self.assertEqual(post, ['post1', 'post2'])\n\n    def test_pickling(self):\n        \n        # known to be unpicklable (e.g., a function).\n        response = SimpleTemplateResponse('first/test.html', {\n            'value': 123,\n            'fn': datetime.now,\n        })\n        with self.assertRaises(ContentNotRenderedError):\n            pickle.dumps(response)\n\n        \n        response.render()\n        pickled_response = pickle.dumps(response)\n        unpickled_response = pickle.loads(pickled_response)\n\n        self.assertEqual(unpickled_response.content, response.content)\n        self.assertEqual(unpickled_response['content-type'], response['content-type'])\n        self.assertEqual(unpickled_response.status_code, response.status_code)\n\n        \n        \n        template_attrs = ('template_name', 'context_data', '_post_render_callbacks')\n        for attr in template_attrs:\n            self.assertFalse(hasattr(unpickled_response, attr))\n\n        \n        for attr in template_attrs:\n            with self.assertRaises(AttributeError):\n                getattr(unpickled_response, attr)\n\n    def test_repickling(self):\n        response = SimpleTemplateResponse('first/test.html', {\n            'value': 123,\n            'fn': datetime.now,\n        })\n        with self.assertRaises(ContentNotRenderedError):\n            pickle.dumps(response)\n\n        response.render()\n        pickled_response = pickle.dumps(response)\n        unpickled_response = pickle.loads(pickled_response)\n        pickle.dumps(unpickled_response)\n\n    def test_pickling_cookie(self):\n        response = SimpleTemplateResponse('first/test.html', {\n            'value': 123,\n            'fn': datetime.now,\n        })\n\n        response.cookies['key'] = 'value'\n\n        response.render()\n        pickled_response = pickle.dumps(response, pickle.HIGHEST_PROTOCOL)\n        unpickled_response = pickle.loads(pickled_response)\n\n        self.assertEqual(unpickled_response.cookies['key'].value, 'value')\n\n\n@override_settings(TEMPLATES=[{\n    'BACKEND': 'django.template.backends.django.DjangoTemplates',\n    'DIRS': [TEMPLATE_DIR],\n    'OPTIONS': {\n        'context_processors': [test_processor_name],\n    },\n}])\nclass TemplateResponseTest(SimpleTestCase):\n\n    def setUp(self):\n        self.factory = RequestFactory()\n\n    def _response(self, template='foo', *args, **kwargs):\n        self._request = self.factory.get('/')\n        template = engines['django'].from_string(template)\n        return TemplateResponse(self._request, template, *args, **kwargs)\n\n    def test_render(self):\n        response = self._response('{{ foo }}{{ processors }}').render()\n        self.assertEqual(response.content, b'yes')\n\n    def test_render_with_requestcontext(self):\n        response = self._response('{{ foo }}{{ processors }}',\n                                  {'foo': 'bar'}).render()\n        self.assertEqual(response.content, b'baryes')\n\n    def test_context_processor_priority(self):\n        \n        response = self._response('{{ foo }}{{ processors }}',\n                                  {'processors': 'no'}).render()\n        self.assertEqual(response.content, b'no')\n\n    def test_kwargs(self):\n        response = self._response(content_type='application/json', status=504)\n        self.assertEqual(response['content-type'], 'application/json')\n        self.assertEqual(response.status_code, 504)\n\n    def test_args(self):\n        response = TemplateResponse(self.factory.get('/'), '', {},\n                                    'application/json', 504)\n        self.assertEqual(response['content-type'], 'application/json')\n        self.assertEqual(response.status_code, 504)\n\n    @require_jinja2\n    def test_using(self):\n        request = self.factory.get('/')\n        response = TemplateResponse(request, 'template_tests/using.html').render()\n        self.assertEqual(response.content, b'DTL\\n')\n        response = TemplateResponse(request, 'template_tests/using.html', using='django').render()\n        self.assertEqual(response.content, b'DTL\\n')\n        response = TemplateResponse(request, 'template_tests/using.html', using='jinja2').render()\n        self.assertEqual(response.content, b'Jinja2\\n')\n\n    def test_pickling(self):\n        \n        # known to be unpicklable (e.g., a function).\n        response = TemplateResponse(\n            self.factory.get('/'),\n            'first/test.html', {\n                'value': 123,\n                'fn': datetime.now,\n            }\n        )\n        with self.assertRaises(ContentNotRenderedError):\n            pickle.dumps(response)\n\n        \n        response.render()\n        pickled_response = pickle.dumps(response)\n        unpickled_response = pickle.loads(pickled_response)\n\n        self.assertEqual(unpickled_response.content, response.content)\n        self.assertEqual(unpickled_response['content-type'], response['content-type'])\n        self.assertEqual(unpickled_response.status_code, response.status_code)\n\n        \n        \n        template_attrs = (\n            'template_name',\n            'context_data',\n            '_post_render_callbacks',\n            '_request',\n        )\n        for attr in template_attrs:\n            self.assertFalse(hasattr(unpickled_response, attr))\n\n        \n        for attr in template_attrs:\n            with self.assertRaises(AttributeError):\n                getattr(unpickled_response, attr)\n\n    def test_repickling(self):\n        response = SimpleTemplateResponse('first/test.html', {\n            'value': 123,\n            'fn': datetime.now,\n        })\n        with self.assertRaises(ContentNotRenderedError):\n            pickle.dumps(response)\n\n        response.render()\n        pickled_response = pickle.dumps(response)\n        unpickled_response = pickle.loads(pickled_response)\n        pickle.dumps(unpickled_response)\n\n\n@modify_settings(MIDDLEWARE={'append': ['template_tests.test_response.CustomURLConfMiddleware']})\n@override_settings(ROOT_URLCONF='template_tests.urls')\nclass CustomURLConfTest(SimpleTestCase):\n\n    def test_custom_urlconf(self):\n        response = self.client.get('/template_response_view/')\n        self.assertContains(response, 'This is where you can find the snark: /snark/')\n\n\n@modify_settings(\n    MIDDLEWARE={\n        'append': [\n            'django.middleware.cache.FetchFromCacheMiddleware',\n            'django.middleware.cache.UpdateCacheMiddleware',\n        ],\n    },\n)\n@override_settings(CACHE_MIDDLEWARE_SECONDS=2.0, ROOT_URLCONF='template_tests.alternate_urls')\nclass CacheMiddlewareTest(SimpleTestCase):\n\n    def test_middleware_caching(self):\n        response = self.client.get('/template_response_view/')\n        self.assertEqual(response.status_code, 200)\n\n        time.sleep(1.0)\n\n        response2 = self.client.get('/template_response_view/')\n        self.assertEqual(response2.status_code, 200)\n\n        self.assertEqual(response.content, response2.content)\n\n        time.sleep(2.0)\n\n        \n        response2 = self.client.get('/template_response_view/')\n        self.assertEqual(response2.status_code, 200)\n\n        self.assertNotEqual(response.content, response2.content)\n", "comments": "  a test middleware installs temporary urlconf    explicit baking    response rendered without render call    rebaking change rendered content    rendered content overridden manually    setting content    unrendered response raises exception iteration    iteration works rendered responses    unrendered response raises exception content accessed    rendered response content accessed    content overridden    when content rendered  callbacks invoked      create template response  the context    known unpicklable (e g   function)     but render response  pickle        unpickled response    template related attributes  rendered       requesting attributes raises exception    context processors overridden passed context    create template response  the context    known unpicklable (e g   function)     but render response  pickle        unpickled response    template related attributes  rendered       requesting attributes raises exception    let cache expire test ", "content": "import pickle\nimport time\nfrom datetime import datetime\n\nfrom django.template import engines\nfrom django.template.response import (\n    ContentNotRenderedError, SimpleTemplateResponse, TemplateResponse,\n)\nfrom django.test import (\n    RequestFactory, SimpleTestCase, modify_settings, override_settings,\n)\nfrom django.test.utils import require_jinja2\nfrom django.utils.deprecation import MiddlewareMixin\n\nfrom .utils import TEMPLATE_DIR\n\n\ndef test_processor(request):\n    return {'processors': 'yes'}\n\n\ntest_processor_name = 'template_tests.test_response.test_processor'\n\n\n# A test middleware that installs a temporary URLConf\nclass CustomURLConfMiddleware(MiddlewareMixin):\n    def process_request(self, request):\n        request.urlconf = 'template_tests.alternate_urls'\n\n\nclass SimpleTemplateResponseTest(SimpleTestCase):\n\n    def _response(self, template='foo', *args, **kwargs):\n        template = engines['django'].from_string(template)\n        return SimpleTemplateResponse(template, *args, **kwargs)\n\n    def test_template_resolving(self):\n        response = SimpleTemplateResponse('first/test.html')\n        response.render()\n        self.assertEqual(response.content, b'First template\\n')\n\n        templates = ['foo.html', 'second/test.html', 'first/test.html']\n        response = SimpleTemplateResponse(templates)\n        response.render()\n        self.assertEqual(response.content, b'Second template\\n')\n\n        response = self._response()\n        response.render()\n        self.assertEqual(response.content, b'foo')\n\n    def test_explicit_baking(self):\n        # explicit baking\n        response = self._response()\n        self.assertFalse(response.is_rendered)\n        response.render()\n        self.assertTrue(response.is_rendered)\n\n    def test_render(self):\n        # response is not re-rendered without the render call\n        response = self._response().render()\n        self.assertEqual(response.content, b'foo')\n\n        # rebaking doesn't change the rendered content\n        template = engines['django'].from_string('bar{{ baz }}')\n        response.template_name = template\n        response.render()\n        self.assertEqual(response.content, b'foo')\n\n        # but rendered content can be overridden by manually\n        # setting content\n        response.content = 'bar'\n        self.assertEqual(response.content, b'bar')\n\n    def test_iteration_unrendered(self):\n        # unrendered response raises an exception on iteration\n        response = self._response()\n        self.assertFalse(response.is_rendered)\n\n        def iteration():\n            for x in response:\n                pass\n        with self.assertRaises(ContentNotRenderedError):\n            iteration()\n        self.assertFalse(response.is_rendered)\n\n    def test_iteration_rendered(self):\n        # iteration works for rendered responses\n        response = self._response().render()\n        res = [x for x in response]\n        self.assertEqual(res, [b'foo'])\n\n    def test_content_access_unrendered(self):\n        # unrendered response raises an exception when content is accessed\n        response = self._response()\n        self.assertFalse(response.is_rendered)\n        with self.assertRaises(ContentNotRenderedError):\n            response.content\n        self.assertFalse(response.is_rendered)\n\n    def test_content_access_rendered(self):\n        # rendered response content can be accessed\n        response = self._response().render()\n        self.assertEqual(response.content, b'foo')\n\n    def test_set_content(self):\n        # content can be overridden\n        response = self._response()\n        self.assertFalse(response.is_rendered)\n        response.content = 'spam'\n        self.assertTrue(response.is_rendered)\n        self.assertEqual(response.content, b'spam')\n        response.content = 'baz'\n        self.assertEqual(response.content, b'baz')\n\n    def test_dict_context(self):\n        response = self._response('{{ foo }}{{ processors }}',\n                                  {'foo': 'bar'})\n        self.assertEqual(response.context_data, {'foo': 'bar'})\n        response.render()\n        self.assertEqual(response.content, b'bar')\n\n    def test_kwargs(self):\n        response = self._response(content_type='application/json', status=504, charset='ascii')\n        self.assertEqual(response['content-type'], 'application/json')\n        self.assertEqual(response.status_code, 504)\n        self.assertEqual(response.charset, 'ascii')\n\n    def test_args(self):\n        response = SimpleTemplateResponse('', {}, 'application/json', 504)\n        self.assertEqual(response['content-type'], 'application/json')\n        self.assertEqual(response.status_code, 504)\n\n    @require_jinja2\n    def test_using(self):\n        response = SimpleTemplateResponse('template_tests/using.html').render()\n        self.assertEqual(response.content, b'DTL\\n')\n        response = SimpleTemplateResponse('template_tests/using.html', using='django').render()\n        self.assertEqual(response.content, b'DTL\\n')\n        response = SimpleTemplateResponse('template_tests/using.html', using='jinja2').render()\n        self.assertEqual(response.content, b'Jinja2\\n')\n\n    def test_post_callbacks(self):\n        \"Rendering a template response triggers the post-render callbacks\"\n        post = []\n\n        def post1(obj):\n            post.append('post1')\n\n        def post2(obj):\n            post.append('post2')\n\n        response = SimpleTemplateResponse('first/test.html', {})\n        response.add_post_render_callback(post1)\n        response.add_post_render_callback(post2)\n\n        # When the content is rendered, all the callbacks are invoked, too.\n        response.render()\n        self.assertEqual(response.content, b'First template\\n')\n        self.assertEqual(post, ['post1', 'post2'])\n\n    def test_pickling(self):\n        # Create a template response. The context is\n        # known to be unpicklable (e.g., a function).\n        response = SimpleTemplateResponse('first/test.html', {\n            'value': 123,\n            'fn': datetime.now,\n        })\n        with self.assertRaises(ContentNotRenderedError):\n            pickle.dumps(response)\n\n        # But if we render the response, we can pickle it.\n        response.render()\n        pickled_response = pickle.dumps(response)\n        unpickled_response = pickle.loads(pickled_response)\n\n        self.assertEqual(unpickled_response.content, response.content)\n        self.assertEqual(unpickled_response['content-type'], response['content-type'])\n        self.assertEqual(unpickled_response.status_code, response.status_code)\n\n        # ...and the unpickled response doesn't have the\n        # template-related attributes, so it can't be re-rendered\n        template_attrs = ('template_name', 'context_data', '_post_render_callbacks')\n        for attr in template_attrs:\n            self.assertFalse(hasattr(unpickled_response, attr))\n\n        # ...and requesting any of those attributes raises an exception\n        for attr in template_attrs:\n            with self.assertRaises(AttributeError):\n                getattr(unpickled_response, attr)\n\n    def test_repickling(self):\n        response = SimpleTemplateResponse('first/test.html', {\n            'value': 123,\n            'fn': datetime.now,\n        })\n        with self.assertRaises(ContentNotRenderedError):\n            pickle.dumps(response)\n\n        response.render()\n        pickled_response = pickle.dumps(response)\n        unpickled_response = pickle.loads(pickled_response)\n        pickle.dumps(unpickled_response)\n\n    def test_pickling_cookie(self):\n        response = SimpleTemplateResponse('first/test.html', {\n            'value': 123,\n            'fn': datetime.now,\n        })\n\n        response.cookies['key'] = 'value'\n\n        response.render()\n        pickled_response = pickle.dumps(response, pickle.HIGHEST_PROTOCOL)\n        unpickled_response = pickle.loads(pickled_response)\n\n        self.assertEqual(unpickled_response.cookies['key'].value, 'value')\n\n\n@override_settings(TEMPLATES=[{\n    'BACKEND': 'django.template.backends.django.DjangoTemplates',\n    'DIRS': [TEMPLATE_DIR],\n    'OPTIONS': {\n        'context_processors': [test_processor_name],\n    },\n}])\nclass TemplateResponseTest(SimpleTestCase):\n\n    def setUp(self):\n        self.factory = RequestFactory()\n\n    def _response(self, template='foo', *args, **kwargs):\n        self._request = self.factory.get('/')\n        template = engines['django'].from_string(template)\n        return TemplateResponse(self._request, template, *args, **kwargs)\n\n    def test_render(self):\n        response = self._response('{{ foo }}{{ processors }}').render()\n        self.assertEqual(response.content, b'yes')\n\n    def test_render_with_requestcontext(self):\n        response = self._response('{{ foo }}{{ processors }}',\n                                  {'foo': 'bar'}).render()\n        self.assertEqual(response.content, b'baryes')\n\n    def test_context_processor_priority(self):\n        # context processors should be overridden by passed-in context\n        response = self._response('{{ foo }}{{ processors }}',\n                                  {'processors': 'no'}).render()\n        self.assertEqual(response.content, b'no')\n\n    def test_kwargs(self):\n        response = self._response(content_type='application/json', status=504)\n        self.assertEqual(response['content-type'], 'application/json')\n        self.assertEqual(response.status_code, 504)\n\n    def test_args(self):\n        response = TemplateResponse(self.factory.get('/'), '', {},\n                                    'application/json', 504)\n        self.assertEqual(response['content-type'], 'application/json')\n        self.assertEqual(response.status_code, 504)\n\n    @require_jinja2\n    def test_using(self):\n        request = self.factory.get('/')\n        response = TemplateResponse(request, 'template_tests/using.html').render()\n        self.assertEqual(response.content, b'DTL\\n')\n        response = TemplateResponse(request, 'template_tests/using.html', using='django').render()\n        self.assertEqual(response.content, b'DTL\\n')\n        response = TemplateResponse(request, 'template_tests/using.html', using='jinja2').render()\n        self.assertEqual(response.content, b'Jinja2\\n')\n\n    def test_pickling(self):\n        # Create a template response. The context is\n        # known to be unpicklable (e.g., a function).\n        response = TemplateResponse(\n            self.factory.get('/'),\n            'first/test.html', {\n                'value': 123,\n                'fn': datetime.now,\n            }\n        )\n        with self.assertRaises(ContentNotRenderedError):\n            pickle.dumps(response)\n\n        # But if we render the response, we can pickle it.\n        response.render()\n        pickled_response = pickle.dumps(response)\n        unpickled_response = pickle.loads(pickled_response)\n\n        self.assertEqual(unpickled_response.content, response.content)\n        self.assertEqual(unpickled_response['content-type'], response['content-type'])\n        self.assertEqual(unpickled_response.status_code, response.status_code)\n\n        # ...and the unpickled response doesn't have the\n        # template-related attributes, so it can't be re-rendered\n        template_attrs = (\n            'template_name',\n            'context_data',\n            '_post_render_callbacks',\n            '_request',\n        )\n        for attr in template_attrs:\n            self.assertFalse(hasattr(unpickled_response, attr))\n\n        # ...and requesting any of those attributes raises an exception\n        for attr in template_attrs:\n            with self.assertRaises(AttributeError):\n                getattr(unpickled_response, attr)\n\n    def test_repickling(self):\n        response = SimpleTemplateResponse('first/test.html', {\n            'value': 123,\n            'fn': datetime.now,\n        })\n        with self.assertRaises(ContentNotRenderedError):\n            pickle.dumps(response)\n\n        response.render()\n        pickled_response = pickle.dumps(response)\n        unpickled_response = pickle.loads(pickled_response)\n        pickle.dumps(unpickled_response)\n\n\n@modify_settings(MIDDLEWARE={'append': ['template_tests.test_response.CustomURLConfMiddleware']})\n@override_settings(ROOT_URLCONF='template_tests.urls')\nclass CustomURLConfTest(SimpleTestCase):\n\n    def test_custom_urlconf(self):\n        response = self.client.get('/template_response_view/')\n        self.assertContains(response, 'This is where you can find the snark: /snark/')\n\n\n@modify_settings(\n    MIDDLEWARE={\n        'append': [\n            'django.middleware.cache.FetchFromCacheMiddleware',\n            'django.middleware.cache.UpdateCacheMiddleware',\n        ],\n    },\n)\n@override_settings(CACHE_MIDDLEWARE_SECONDS=2.0, ROOT_URLCONF='template_tests.alternate_urls')\nclass CacheMiddlewareTest(SimpleTestCase):\n\n    def test_middleware_caching(self):\n        response = self.client.get('/template_response_view/')\n        self.assertEqual(response.status_code, 200)\n\n        time.sleep(1.0)\n\n        response2 = self.client.get('/template_response_view/')\n        self.assertEqual(response2.status_code, 200)\n\n        self.assertEqual(response.content, response2.content)\n\n        time.sleep(2.0)\n\n        # Let the cache expire and test again\n        response2 = self.client.get('/template_response_view/')\n        self.assertEqual(response2.status_code, 200)\n\n        self.assertNotEqual(response.content, response2.content)\n", "description": "The Web framework for perfectionists with deadlines.", "file_name": "test_response.py", "id": "09600e77d2c5603ca75b74b3c6172132", "language": "Python", "project_name": "django", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/django-django/django-django-274e3e2/tests/template_tests/test_response.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:39:10Z", "url": "https://github.com/django/django", "wiki": false}