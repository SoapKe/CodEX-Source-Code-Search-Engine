{"author": "ansible", "code": "\n\n# (c) 2013, Paul Durivage <paul.durivage@rackspace.com>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: rax_files\nshort_description: Manipulate Rackspace Cloud Files Containers\ndescription:\n  - Manipulate Rackspace Cloud Files Containers\nversion_added: \"1.5\"\noptions:\n  clear_meta:\n    description:\n      - Optionally clear existing metadata when applying metadata to existing containers.\n        Selecting this option is only appropriate when setting type=meta\n    choices:\n      - \"yes\"\n      - \"no\"\n    default: \"no\"\n  container:\n    description:\n      - The container to use for container or metadata operations.\n    required: true\n  meta:\n    description:\n      - A hash of items to set as metadata values on a container\n  private:\n    description:\n      - Used to set a container as private, removing it from the CDN.  B(Warning!)\n        Private containers, if previously made public, can have live objects\n        available until the TTL on cached objects expires\n  public:\n    description:\n      - Used to set a container as public, available via the Cloud Files CDN\n  region:\n    description:\n      - Region to create an instance in\n    default: DFW\n  state:\n    description:\n      - Indicate desired state of the resource\n    choices: ['present', 'absent']\n    default: present\n  ttl:\n    description:\n      - In seconds, set a container-wide TTL for all objects cached on CDN edge nodes.\n        Setting a TTL is only appropriate for containers that are public\n  type:\n    description:\n      - Type of object to do work on, i.e. metadata object or a container object\n    choices:\n      - file\n      - meta\n    default: file\n  web_error:\n    description:\n       - Sets an object to be presented as the HTTP error page when accessed by the CDN URL\n  web_index:\n    description:\n       - Sets an object to be presented as the HTTP index page when accessed by the CDN URL\nauthor: \"Paul Durivage (@angstwad)\"\nextends_documentation_fragment:\n  - rackspace\n  - rackspace.openstack\n'''\n\nEXAMPLES = '''\n- name: \"Test Cloud Files Containers\"\n  hosts: local\n  gather_facts: no\n  tasks:\n    - name: \"List all containers\"\n      rax_files:\n        state: list\n\n    - name: \"Create container called 'mycontainer'\"\n      rax_files:\n        container: mycontainer\n\n    - name: \"Create container 'mycontainer2' with metadata\"\n      rax_files:\n        container: mycontainer2\n        meta:\n          key: value\n          file_for: someuser@example.com\n\n    - name: \"Set a container's web index page\"\n      rax_files:\n        container: mycontainer\n        web_index: index.html\n\n    - name: \"Set a container's web error page\"\n      rax_files:\n        container: mycontainer\n        web_error: error.html\n\n    - name: \"Make container public\"\n      rax_files:\n        container: mycontainer\n        public: yes\n\n    - name: \"Make container public with a 24 hour TTL\"\n      rax_files:\n        container: mycontainer\n        public: yes\n        ttl: 86400\n\n    - name: \"Make container private\"\n      rax_files:\n        container: mycontainer\n        private: yes\n\n- name: \"Test Cloud Files Containers Metadata Storage\"\n  hosts: local\n  gather_facts: no\n  tasks:\n    - name: \"Get mycontainer2 metadata\"\n      rax_files:\n        container: mycontainer2\n        type: meta\n\n    - name: \"Set mycontainer2 metadata\"\n      rax_files:\n        container: mycontainer2\n        type: meta\n        meta:\n          uploaded_by: someuser@example.com\n\n    - name: \"Remove mycontainer2 metadata\"\n      rax_files:\n        container: \"mycontainer2\"\n        type: meta\n        state: absent\n        meta:\n          key: \"\"\n          file_for: \"\"\n'''\n\ntry:\n    import pyrax\n    HAS_PYRAX = True\nexcept ImportError as e:\n    HAS_PYRAX = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.rax import rax_argument_spec, rax_required_together, setup_rax_module\n\n\nEXIT_DICT = dict(success=True)\nMETA_PREFIX = 'x-container-meta-'\n\n\ndef _get_container(module, cf, container):\n    try:\n        return cf.get_container(container)\n    except pyrax.exc.NoSuchContainer as e:\n        module.fail_json(msg=e.message)\n\n\ndef _fetch_meta(module, container):\n    EXIT_DICT['meta'] = dict()\n    try:\n        for k, v in container.get_metadata().items():\n            split_key = k.split(META_PREFIX)[-1]\n            EXIT_DICT['meta'][split_key] = v\n    except Exception as e:\n        module.fail_json(msg=e.message)\n\n\ndef meta(cf, module, container_, state, meta_, clear_meta):\n    c = _get_container(module, cf, container_)\n\n    if meta_ and state == 'present':\n        try:\n            meta_set = c.set_metadata(meta_, clear=clear_meta)\n        except Exception as e:\n            module.fail_json(msg=e.message)\n    elif meta_ and state == 'absent':\n        remove_results = []\n        for k, v in meta_.items():\n            c.remove_metadata_key(k)\n            remove_results.append(k)\n            EXIT_DICT['deleted_meta_keys'] = remove_results\n    elif state == 'absent':\n        remove_results = []\n        for k, v in c.get_metadata().items():\n            c.remove_metadata_key(k)\n            remove_results.append(k)\n            EXIT_DICT['deleted_meta_keys'] = remove_results\n\n    _fetch_meta(module, c)\n    _locals = locals().keys()\n\n    EXIT_DICT['container'] = c.name\n    if 'meta_set' in _locals or 'remove_results' in _locals:\n        EXIT_DICT['changed'] = True\n\n    module.exit_json(**EXIT_DICT)\n\n\ndef container(cf, module, container_, state, meta_, clear_meta, ttl, public,\n              private, web_index, web_error):\n    if public and private:\n        module.fail_json(msg='container cannot be simultaneously '\n                             'set to public and private')\n\n    if state == 'absent' and (meta_ or clear_meta or public or private or web_index or web_error):\n        module.fail_json(msg='state cannot be omitted when setting/removing '\n                             'attributes on a container')\n\n    if state == 'list':\n        \n        EXIT_DICT['containers'] = cf.list_containers()\n        module.exit_json(**EXIT_DICT)\n\n    try:\n        c = cf.get_container(container_)\n    except pyrax.exc.NoSuchContainer as e:\n        \n        if state == 'present':\n            try:\n                c = cf.create_container(container_)\n            except Exception as e:\n                module.fail_json(msg=e.message)\n            else:\n                EXIT_DICT['changed'] = True\n                EXIT_DICT['created'] = True\n        else:\n            module.fail_json(msg=e.message)\n    else:\n        \n        \n        if state == 'absent':\n            try:\n                cont_deleted = c.delete()\n            except Exception as e:\n                module.fail_json(msg=e.message)\n            else:\n                EXIT_DICT['deleted'] = True\n\n    if meta_:\n        try:\n            meta_set = c.set_metadata(meta_, clear=clear_meta)\n        except Exception as e:\n            module.fail_json(msg=e.message)\n        finally:\n            _fetch_meta(module, c)\n\n    if ttl:\n        try:\n            c.cdn_ttl = ttl\n        except Exception as e:\n            module.fail_json(msg=e.message)\n        else:\n            EXIT_DICT['ttl'] = c.cdn_ttl\n\n    if public:\n        try:\n            cont_public = c.make_public()\n        except Exception as e:\n            module.fail_json(msg=e.message)\n        else:\n            EXIT_DICT['container_urls'] = dict(url=c.cdn_uri,\n                                               ssl_url=c.cdn_ssl_uri,\n                                               streaming_url=c.cdn_streaming_uri,\n                                               ios_uri=c.cdn_ios_uri)\n\n    if private:\n        try:\n            cont_private = c.make_private()\n        except Exception as e:\n            module.fail_json(msg=e.message)\n        else:\n            EXIT_DICT['set_private'] = True\n\n    if web_index:\n        try:\n            cont_web_index = c.set_web_index_page(web_index)\n        except Exception as e:\n            module.fail_json(msg=e.message)\n        else:\n            EXIT_DICT['set_index'] = True\n        finally:\n            _fetch_meta(module, c)\n\n    if web_error:\n        try:\n            cont_err_index = c.set_web_error_page(web_error)\n        except Exception as e:\n            module.fail_json(msg=e.message)\n        else:\n            EXIT_DICT['set_error'] = True\n        finally:\n            _fetch_meta(module, c)\n\n    EXIT_DICT['container'] = c.name\n    EXIT_DICT['objs_in_container'] = c.object_count\n    EXIT_DICT['total_bytes'] = c.total_bytes\n\n    _locals = locals().keys()\n    if ('cont_deleted' in _locals\n            or 'meta_set' in _locals\n            or 'cont_public' in _locals\n            or 'cont_private' in _locals\n            or 'cont_web_index' in _locals\n            or 'cont_err_index' in _locals):\n        EXIT_DICT['changed'] = True\n\n    module.exit_json(**EXIT_DICT)\n\n\ndef cloudfiles(module, container_, state, meta_, clear_meta, typ, ttl, public,\n               private, web_index, web_error):\n    \n    cf = pyrax.cloudfiles\n\n    if cf is None:\n        module.fail_json(msg='Failed to instantiate client. This '\n                             'typically indicates an invalid region or an '\n                             'incorrectly capitalized region name.')\n\n    if typ == \"container\":\n        container(cf, module, container_, state, meta_, clear_meta, ttl,\n                  public, private, web_index, web_error)\n    else:\n        meta(cf, module, container_, state, meta_, clear_meta)\n\n\ndef main():\n    argument_spec = rax_argument_spec()\n    argument_spec.update(\n        dict(\n            container=dict(),\n            state=dict(choices=['present', 'absent', 'list'],\n                       default='present'),\n            meta=dict(type='dict', default=dict()),\n            clear_meta=dict(default=False, type='bool'),\n            type=dict(choices=['container', 'meta'], default='container'),\n            ttl=dict(type='int'),\n            public=dict(default=False, type='bool'),\n            private=dict(default=False, type='bool'),\n            web_index=dict(),\n            web_error=dict()\n        )\n    )\n\n    module = AnsibleModule(\n        argument_spec=argument_spec,\n        required_together=rax_required_together()\n    )\n\n    if not HAS_PYRAX:\n        module.fail_json(msg='pyrax is required for this module')\n\n    container_ = module.params.get('container')\n    state = module.params.get('state')\n    meta_ = module.params.get('meta')\n    clear_meta = module.params.get('clear_meta')\n    typ = module.params.get('type')\n    ttl = module.params.get('ttl')\n    public = module.params.get('public')\n    private = module.params.get('private')\n    web_index = module.params.get('web_index')\n    web_error = module.params.get('web_error')\n\n    if state in ['present', 'absent'] and not container_:\n        module.fail_json(msg='please specify a container name')\n    if clear_meta and not typ == 'meta':\n        module.fail_json(msg='clear_meta can only be used when setting '\n                             'metadata')\n\n    setup_rax_module(module, pyrax)\n    cloudfiles(module, container_, state, meta_, clear_meta, typ, ttl, public,\n               private, web_index, web_error)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "    dispatch work metadata file objects              module  rax files short description  manipulate rackspace cloud files containers description      manipulate rackspace cloud files containers version added   1 5  options    clear meta      description          optionally clear existing metadata applying metadata existing containers          selecting option appropriate setting type meta     choices           yes                default      container      description          the container use container metadata operations      required  true   meta      description          a hash items set metadata values container   private      description          used set container private  removing cdn   b(warning )         private containers  previously made public  live objects         available ttl cached objects expires   public      description          used set container public  available via cloud files cdn   region      description          region create instance     default  dfw   state      description          indicate desired state resource     choices    present    absent       default  present   ttl      description          in seconds  set container wide ttl objects cached cdn edge nodes          setting ttl appropriate containers public   type      description          type object work  e  metadata object container object     choices          file         meta     default  file   web error      description           sets object presented http error page accessed cdn url   web index      description           sets object presented http index page accessed cdn url author   paul durivage ( angstwad)  extends documentation fragment      rackspace     rackspace openstack      examples         name   test cloud files containers    hosts  local   gather facts    tasks        name   list containers        rax files          state  list        name   create container called  mycontainer         rax files          container  mycontainer        name   create container  mycontainer2  metadata        rax files          container  mycontainer2         meta            key  value           file  someuser example com        name   set container web index page        rax files          container  mycontainer         web index  index html        name   set container web error page        rax files          container  mycontainer         web error  error html        name   make container public        rax files          container  mycontainer         public  yes        name   make container public 24 hour ttl        rax files          container  mycontainer         public  yes         ttl  86400        name   make container private        rax files          container  mycontainer         private  yes    name   test cloud files containers metadata storage    hosts  local   gather facts    tasks        name   get mycontainer2 metadata        rax files          container  mycontainer2         type  meta        name   set mycontainer2 metadata        rax files          container  mycontainer2         type  meta         meta            uploaded  someuser example com        name   remove mycontainer2 metadata        rax files          container   mycontainer2          type  meta         state  absent         meta            key               file             usr bin python    (c) 2013  paul durivage  paul durivage rackspace com     gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    we care attributes specified  let list containers    make container state present  otherwise bomb    successfully grabbed container object    delete state absent ", "content": "#!/usr/bin/python\n\n# (c) 2013, Paul Durivage <paul.durivage@rackspace.com>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: rax_files\nshort_description: Manipulate Rackspace Cloud Files Containers\ndescription:\n  - Manipulate Rackspace Cloud Files Containers\nversion_added: \"1.5\"\noptions:\n  clear_meta:\n    description:\n      - Optionally clear existing metadata when applying metadata to existing containers.\n        Selecting this option is only appropriate when setting type=meta\n    choices:\n      - \"yes\"\n      - \"no\"\n    default: \"no\"\n  container:\n    description:\n      - The container to use for container or metadata operations.\n    required: true\n  meta:\n    description:\n      - A hash of items to set as metadata values on a container\n  private:\n    description:\n      - Used to set a container as private, removing it from the CDN.  B(Warning!)\n        Private containers, if previously made public, can have live objects\n        available until the TTL on cached objects expires\n  public:\n    description:\n      - Used to set a container as public, available via the Cloud Files CDN\n  region:\n    description:\n      - Region to create an instance in\n    default: DFW\n  state:\n    description:\n      - Indicate desired state of the resource\n    choices: ['present', 'absent']\n    default: present\n  ttl:\n    description:\n      - In seconds, set a container-wide TTL for all objects cached on CDN edge nodes.\n        Setting a TTL is only appropriate for containers that are public\n  type:\n    description:\n      - Type of object to do work on, i.e. metadata object or a container object\n    choices:\n      - file\n      - meta\n    default: file\n  web_error:\n    description:\n       - Sets an object to be presented as the HTTP error page when accessed by the CDN URL\n  web_index:\n    description:\n       - Sets an object to be presented as the HTTP index page when accessed by the CDN URL\nauthor: \"Paul Durivage (@angstwad)\"\nextends_documentation_fragment:\n  - rackspace\n  - rackspace.openstack\n'''\n\nEXAMPLES = '''\n- name: \"Test Cloud Files Containers\"\n  hosts: local\n  gather_facts: no\n  tasks:\n    - name: \"List all containers\"\n      rax_files:\n        state: list\n\n    - name: \"Create container called 'mycontainer'\"\n      rax_files:\n        container: mycontainer\n\n    - name: \"Create container 'mycontainer2' with metadata\"\n      rax_files:\n        container: mycontainer2\n        meta:\n          key: value\n          file_for: someuser@example.com\n\n    - name: \"Set a container's web index page\"\n      rax_files:\n        container: mycontainer\n        web_index: index.html\n\n    - name: \"Set a container's web error page\"\n      rax_files:\n        container: mycontainer\n        web_error: error.html\n\n    - name: \"Make container public\"\n      rax_files:\n        container: mycontainer\n        public: yes\n\n    - name: \"Make container public with a 24 hour TTL\"\n      rax_files:\n        container: mycontainer\n        public: yes\n        ttl: 86400\n\n    - name: \"Make container private\"\n      rax_files:\n        container: mycontainer\n        private: yes\n\n- name: \"Test Cloud Files Containers Metadata Storage\"\n  hosts: local\n  gather_facts: no\n  tasks:\n    - name: \"Get mycontainer2 metadata\"\n      rax_files:\n        container: mycontainer2\n        type: meta\n\n    - name: \"Set mycontainer2 metadata\"\n      rax_files:\n        container: mycontainer2\n        type: meta\n        meta:\n          uploaded_by: someuser@example.com\n\n    - name: \"Remove mycontainer2 metadata\"\n      rax_files:\n        container: \"mycontainer2\"\n        type: meta\n        state: absent\n        meta:\n          key: \"\"\n          file_for: \"\"\n'''\n\ntry:\n    import pyrax\n    HAS_PYRAX = True\nexcept ImportError as e:\n    HAS_PYRAX = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.rax import rax_argument_spec, rax_required_together, setup_rax_module\n\n\nEXIT_DICT = dict(success=True)\nMETA_PREFIX = 'x-container-meta-'\n\n\ndef _get_container(module, cf, container):\n    try:\n        return cf.get_container(container)\n    except pyrax.exc.NoSuchContainer as e:\n        module.fail_json(msg=e.message)\n\n\ndef _fetch_meta(module, container):\n    EXIT_DICT['meta'] = dict()\n    try:\n        for k, v in container.get_metadata().items():\n            split_key = k.split(META_PREFIX)[-1]\n            EXIT_DICT['meta'][split_key] = v\n    except Exception as e:\n        module.fail_json(msg=e.message)\n\n\ndef meta(cf, module, container_, state, meta_, clear_meta):\n    c = _get_container(module, cf, container_)\n\n    if meta_ and state == 'present':\n        try:\n            meta_set = c.set_metadata(meta_, clear=clear_meta)\n        except Exception as e:\n            module.fail_json(msg=e.message)\n    elif meta_ and state == 'absent':\n        remove_results = []\n        for k, v in meta_.items():\n            c.remove_metadata_key(k)\n            remove_results.append(k)\n            EXIT_DICT['deleted_meta_keys'] = remove_results\n    elif state == 'absent':\n        remove_results = []\n        for k, v in c.get_metadata().items():\n            c.remove_metadata_key(k)\n            remove_results.append(k)\n            EXIT_DICT['deleted_meta_keys'] = remove_results\n\n    _fetch_meta(module, c)\n    _locals = locals().keys()\n\n    EXIT_DICT['container'] = c.name\n    if 'meta_set' in _locals or 'remove_results' in _locals:\n        EXIT_DICT['changed'] = True\n\n    module.exit_json(**EXIT_DICT)\n\n\ndef container(cf, module, container_, state, meta_, clear_meta, ttl, public,\n              private, web_index, web_error):\n    if public and private:\n        module.fail_json(msg='container cannot be simultaneously '\n                             'set to public and private')\n\n    if state == 'absent' and (meta_ or clear_meta or public or private or web_index or web_error):\n        module.fail_json(msg='state cannot be omitted when setting/removing '\n                             'attributes on a container')\n\n    if state == 'list':\n        # We don't care if attributes are specified, let's list containers\n        EXIT_DICT['containers'] = cf.list_containers()\n        module.exit_json(**EXIT_DICT)\n\n    try:\n        c = cf.get_container(container_)\n    except pyrax.exc.NoSuchContainer as e:\n        # Make the container if state=present, otherwise bomb out\n        if state == 'present':\n            try:\n                c = cf.create_container(container_)\n            except Exception as e:\n                module.fail_json(msg=e.message)\n            else:\n                EXIT_DICT['changed'] = True\n                EXIT_DICT['created'] = True\n        else:\n            module.fail_json(msg=e.message)\n    else:\n        # Successfully grabbed a container object\n        # Delete if state is absent\n        if state == 'absent':\n            try:\n                cont_deleted = c.delete()\n            except Exception as e:\n                module.fail_json(msg=e.message)\n            else:\n                EXIT_DICT['deleted'] = True\n\n    if meta_:\n        try:\n            meta_set = c.set_metadata(meta_, clear=clear_meta)\n        except Exception as e:\n            module.fail_json(msg=e.message)\n        finally:\n            _fetch_meta(module, c)\n\n    if ttl:\n        try:\n            c.cdn_ttl = ttl\n        except Exception as e:\n            module.fail_json(msg=e.message)\n        else:\n            EXIT_DICT['ttl'] = c.cdn_ttl\n\n    if public:\n        try:\n            cont_public = c.make_public()\n        except Exception as e:\n            module.fail_json(msg=e.message)\n        else:\n            EXIT_DICT['container_urls'] = dict(url=c.cdn_uri,\n                                               ssl_url=c.cdn_ssl_uri,\n                                               streaming_url=c.cdn_streaming_uri,\n                                               ios_uri=c.cdn_ios_uri)\n\n    if private:\n        try:\n            cont_private = c.make_private()\n        except Exception as e:\n            module.fail_json(msg=e.message)\n        else:\n            EXIT_DICT['set_private'] = True\n\n    if web_index:\n        try:\n            cont_web_index = c.set_web_index_page(web_index)\n        except Exception as e:\n            module.fail_json(msg=e.message)\n        else:\n            EXIT_DICT['set_index'] = True\n        finally:\n            _fetch_meta(module, c)\n\n    if web_error:\n        try:\n            cont_err_index = c.set_web_error_page(web_error)\n        except Exception as e:\n            module.fail_json(msg=e.message)\n        else:\n            EXIT_DICT['set_error'] = True\n        finally:\n            _fetch_meta(module, c)\n\n    EXIT_DICT['container'] = c.name\n    EXIT_DICT['objs_in_container'] = c.object_count\n    EXIT_DICT['total_bytes'] = c.total_bytes\n\n    _locals = locals().keys()\n    if ('cont_deleted' in _locals\n            or 'meta_set' in _locals\n            or 'cont_public' in _locals\n            or 'cont_private' in _locals\n            or 'cont_web_index' in _locals\n            or 'cont_err_index' in _locals):\n        EXIT_DICT['changed'] = True\n\n    module.exit_json(**EXIT_DICT)\n\n\ndef cloudfiles(module, container_, state, meta_, clear_meta, typ, ttl, public,\n               private, web_index, web_error):\n    \"\"\" Dispatch from here to work with metadata or file objects \"\"\"\n    cf = pyrax.cloudfiles\n\n    if cf is None:\n        module.fail_json(msg='Failed to instantiate client. This '\n                             'typically indicates an invalid region or an '\n                             'incorrectly capitalized region name.')\n\n    if typ == \"container\":\n        container(cf, module, container_, state, meta_, clear_meta, ttl,\n                  public, private, web_index, web_error)\n    else:\n        meta(cf, module, container_, state, meta_, clear_meta)\n\n\ndef main():\n    argument_spec = rax_argument_spec()\n    argument_spec.update(\n        dict(\n            container=dict(),\n            state=dict(choices=['present', 'absent', 'list'],\n                       default='present'),\n            meta=dict(type='dict', default=dict()),\n            clear_meta=dict(default=False, type='bool'),\n            type=dict(choices=['container', 'meta'], default='container'),\n            ttl=dict(type='int'),\n            public=dict(default=False, type='bool'),\n            private=dict(default=False, type='bool'),\n            web_index=dict(),\n            web_error=dict()\n        )\n    )\n\n    module = AnsibleModule(\n        argument_spec=argument_spec,\n        required_together=rax_required_together()\n    )\n\n    if not HAS_PYRAX:\n        module.fail_json(msg='pyrax is required for this module')\n\n    container_ = module.params.get('container')\n    state = module.params.get('state')\n    meta_ = module.params.get('meta')\n    clear_meta = module.params.get('clear_meta')\n    typ = module.params.get('type')\n    ttl = module.params.get('ttl')\n    public = module.params.get('public')\n    private = module.params.get('private')\n    web_index = module.params.get('web_index')\n    web_error = module.params.get('web_error')\n\n    if state in ['present', 'absent'] and not container_:\n        module.fail_json(msg='please specify a container name')\n    if clear_meta and not typ == 'meta':\n        module.fail_json(msg='clear_meta can only be used when setting '\n                             'metadata')\n\n    setup_rax_module(module, pyrax)\n    cloudfiles(module, container_, state, meta_, clear_meta, typ, ttl, public,\n               private, web_index, web_error)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "rax_files.py", "id": "02a6d3e9c88ae5d7bf9942aefa618bf3", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/cloud/rackspace/rax_files.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}