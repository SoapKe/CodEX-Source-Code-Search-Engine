{"author": "tensorflow", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================\n\nimport os, sys\nimport numpy as np\nfrom tensorflow.python.platform import app\nfrom tensorflow.python.platform import flags\nimport logging\nimport src.utils as utils\nimport cfgs.config_common as cc\n\n\nimport tensorflow as tf\n\n\nrgb_resnet_v2_50_path = 'data/init_models/resnet_v2_50/model.ckpt-5136169'\nd_resnet_v2_50_path = 'data/init_models/distill_rgb_to_d_resnet_v2_50/model.ckpt-120002'\n\ndef get_default_args():\n  summary_args = utils.Foo(display_interval=1, test_iters=26,\n                           arop_full_summary_iters=14)\n\n  control_args = utils.Foo(train=False, test=False,\n                           force_batchnorm_is_training_at_test=False,\n                           reset_rng_seed=False, only_eval_when_done=False,\n                           test_mode=None)\n  return summary_args, control_args\n\ndef get_default_cmp_args():\n  batch_norm_param = {'center': True, 'scale': True,\n                      'activation_fn':tf.nn.relu}\n\n  mapper_arch_args = utils.Foo(\n      dim_reduce_neurons=64,\n      fc_neurons=[1024, 1024],\n      fc_out_size=8,\n      fc_out_neurons=64,\n      encoder='resnet_v2_50',\n      deconv_neurons=[64, 32, 16, 8, 4, 2],\n      deconv_strides=[2, 2, 2, 2, 2, 2],\n      deconv_layers_per_block=2,\n      deconv_kernel_size=4,\n      fc_dropout=0.5,\n      combine_type='wt_avg_logits',\n      batch_norm_param=batch_norm_param)\n\n  readout_maps_arch_args = utils.Foo(\n      num_neurons=[],\n      strides=[],\n      kernel_size=None,\n      layers_per_block=None)\n\n  arch_args = utils.Foo(\n      vin_val_neurons=8, vin_action_neurons=8, vin_ks=3, vin_share_wts=False,\n      pred_neurons=[64, 64], pred_batch_norm_param=batch_norm_param,\n      conv_on_value_map=0, fr_neurons=16, fr_ver='v2', fr_inside_neurons=64,\n      fr_stride=1, crop_remove_each=30, value_crop_size=4,\n      action_sample_type='sample', action_sample_combine_type='one_or_other',\n      sample_gt_prob_type='inverse_sigmoid_decay', dagger_sample_bn_false=True,\n      vin_num_iters=36, isd_k=750., use_agent_loc=False, multi_scale=True,\n      readout_maps=False, rom_arch=readout_maps_arch_args)\n\n  return arch_args, mapper_arch_args\n\ndef get_arch_vars(arch_str):\n  if arch_str == '': vals = []\n  else: vals = arch_str.split('_')\n  ks = ['var1', 'var2', 'var3']\n  ks = ks[:len(vals)]\n  \n   Exp Ver.\n  if len(vals) == 0: ks.append('var1'); vals.append('v0')\n   custom arch.\n  if len(vals) == 1: ks.append('var2'); vals.append('')\n   map scape for projection baseline.\n  if len(vals) == 2: ks.append('var3'); vals.append('fr2')\n\n  assert(len(vals) == 3)\n\n  vars = utils.Foo()\n  for k, v in zip(ks, vals):\n    setattr(vars, k, v)\n\n  logging.error('arch_vars: %s', vars)\n  return vars\n\ndef process_arch_str(args, arch_str):\n   This function modifies args.\n  args.arch, args.mapper_arch = get_default_cmp_args()\n\n  arch_vars = get_arch_vars(arch_str)\n\n  args.navtask.task_params.outputs.ego_maps = True\n  args.navtask.task_params.outputs.ego_goal_imgs = True\n  args.navtask.task_params.outputs.egomotion = True\n  args.navtask.task_params.toy_problem = False\n\n  if arch_vars.var1 == 'lmap':\n    args = process_arch_learned_map(args, arch_vars)\n\n  elif arch_vars.var1 == 'pmap':\n    args = process_arch_projected_map(args, arch_vars)\n\n  else:\n    logging.fatal('arch_vars.var1 should be lmap or pmap, but is %s', arch_vars.var1)\n    assert(False)\n\n  return args\n\ndef process_arch_learned_map(args, arch_vars):\n   Multiscale vision based system.\n  args.navtask.task_params.input_type = 'vision'\n  args.navtask.task_params.outputs.images = True\n  \n  if args.navtask.camera_param.modalities[0] == 'rgb':\n    args.solver.pretrained_path = rgb_resnet_v2_50_path\n  elif args.navtask.camera_param.modalities[0] == 'depth':\n    args.solver.pretrained_path = d_resnet_v2_50_path\n\n  if arch_vars.var2 == 'Ssc':\n    sc = 1./args.navtask.task_params.step_size\n    args.arch.vin_num_iters = 40\n    args.navtask.task_params.map_scales = [sc]\n    max_dist = args.navtask.task_params.max_dist * \\\n        args.navtask.task_params.num_goals\n    args.navtask.task_params.map_crop_sizes = [2*max_dist]\n\n    args.arch.fr_stride = 1\n    args.arch.vin_action_neurons = 8\n    args.arch.vin_val_neurons = 3\n    args.arch.fr_inside_neurons = 32\n\n    args.mapper_arch.pad_map_with_zeros_each = [24]\n    args.mapper_arch.deconv_neurons = [64, 32, 16]\n    args.mapper_arch.deconv_strides = [1, 2, 1]\n\n  elif (arch_vars.var2 == 'Msc' or arch_vars.var2 == 'MscROMms' or\n        arch_vars.var2 == 'MscROMss' or arch_vars.var2 == 'MscNoVin'):\n     Code for multi-scale planner.\n    args.arch.vin_num_iters = 8\n    args.arch.crop_remove_each = 4\n    args.arch.value_crop_size = 8\n\n    sc = 1./args.navtask.task_params.step_size\n    max_dist = args.navtask.task_params.max_dist * \\\n        args.navtask.task_params.num_goals\n    n_scales = np.log2(float(max_dist) / float(args.arch.vin_num_iters))\n    n_scales = int(np.ceil(n_scales)+1)\n\n    args.navtask.task_params.map_scales = \\\n        list(sc*(0.5**(np.arange(n_scales))[::-1]))\n    args.navtask.task_params.map_crop_sizes = [16 for x in range(n_scales)]\n\n    args.arch.fr_stride = 1\n    args.arch.vin_action_neurons = 8\n    args.arch.vin_val_neurons = 3\n    args.arch.fr_inside_neurons = 32\n\n    args.mapper_arch.pad_map_with_zeros_each = [0 for _ in range(n_scales)]\n    args.mapper_arch.deconv_neurons = [64*n_scales, 32*n_scales, 16*n_scales]\n    args.mapper_arch.deconv_strides = [1, 2, 1]\n\n    if arch_vars.var2 == 'MscNoVin':\n       No planning version.\n      args.arch.fr_stride = [1, 2, 1, 2]\n      args.arch.vin_action_neurons = None\n      args.arch.vin_val_neurons = 16\n      args.arch.fr_inside_neurons = 32\n\n      args.arch.crop_remove_each = 0\n      args.arch.value_crop_size = 4\n      args.arch.vin_num_iters = 0\n\n    elif arch_vars.var2 == 'MscROMms' or arch_vars.var2 == 'MscROMss':\n       Code with read outs, MscROMms flattens and reads out,\n       MscROMss does not flatten and produces output at multiple scales.\n      args.navtask.task_params.outputs.readout_maps = True\n      args.navtask.task_params.map_resize_method = 'antialiasing'\n      args.arch.readout_maps = True\n\n      if arch_vars.var2 == 'MscROMms':\n        args.arch.rom_arch.num_neurons = [64, 1]\n        args.arch.rom_arch.kernel_size = 4\n        args.arch.rom_arch.strides = [2,2]\n        args.arch.rom_arch.layers_per_block = 2\n\n        args.navtask.task_params.readout_maps_crop_sizes = [64]\n        args.navtask.task_params.readout_maps_scales = [sc]\n\n      elif arch_vars.var2 == 'MscROMss':\n        args.arch.rom_arch.num_neurons = \\\n            [64, len(args.navtask.task_params.map_scales)]\n        args.arch.rom_arch.kernel_size = 4\n        args.arch.rom_arch.strides = [1,1]\n        args.arch.rom_arch.layers_per_block = 1\n\n        args.navtask.task_params.readout_maps_crop_sizes = \\\n            args.navtask.task_params.map_crop_sizes\n        args.navtask.task_params.readout_maps_scales = \\\n            args.navtask.task_params.map_scales\n\n  else:\n    logging.fatal('arch_vars.var2 not one of Msc, MscROMms, MscROMss, MscNoVin.')\n    assert(False)\n\n  map_channels = args.mapper_arch.deconv_neurons[-1] / \\\n    (2*len(args.navtask.task_params.map_scales))\n  args.navtask.task_params.map_channels = map_channels\n  \n  return args\n\ndef process_arch_projected_map(args, arch_vars):\n   Single scale vision based system which does not use a mapper but instead\n   uses an analytically estimated map.\n  ds = int(arch_vars.var3[2])\n  args.navtask.task_params.input_type = 'analytical_counts'\n  args.navtask.task_params.outputs.analytical_counts = True\n\n  assert(args.navtask.task_params.modalities[0] == 'depth')\n  args.navtask.camera_param.img_channels = None\n\n  analytical_counts = utils.Foo(map_sizes=[512/ds],\n                                xy_resolution=[5.*ds],\n                                z_bins=[[-10, 10, 150, 200]],\n                                non_linearity=[arch_vars.var2])\n  args.navtask.task_params.analytical_counts = analytical_counts\n\n  sc = 1./ds\n  args.arch.vin_num_iters = 36\n  args.navtask.task_params.map_scales = [sc]\n  args.navtask.task_params.map_crop_sizes = [512/ds]\n\n  args.arch.fr_stride = [1,2]\n  args.arch.vin_action_neurons = 8\n  args.arch.vin_val_neurons = 3\n  args.arch.fr_inside_neurons = 32\n\n  map_channels = len(analytical_counts.z_bins[0]) + 1\n  args.navtask.task_params.map_channels = map_channels\n  args.solver.freeze_conv = False\n\n  return args\n\ndef get_args_for_config(config_name):\n  args = utils.Foo()\n\n  args.summary, args.control = get_default_args()\n\n  exp_name, mode_str = config_name.split('+')\n  arch_str, solver_str, navtask_str = exp_name.split('.')\n  logging.error('config_name: %s', config_name)\n  logging.error('arch_str: %s', arch_str)\n  logging.error('navtask_str: %s', navtask_str)\n  logging.error('solver_str: %s', solver_str)\n  logging.error('mode_str: %s', mode_str)\n\n  args.solver = cc.process_solver_str(solver_str)\n  args.navtask = cc.process_navtask_str(navtask_str)\n\n  args = process_arch_str(args, arch_str)\n  args.arch.isd_k = args.solver.isd_k\n\n   Train, test, etc.\n  mode, imset = mode_str.split('_')\n  args = cc.adjust_args_for_mode(args, mode)\n  args.navtask.building_names = args.navtask.dataset.get_split(imset)\n  args.control.test_name = '{:s}_on_{:s}'.format(mode, imset)\n\n   Log the arguments\n  logging.error('%s', args)\n  return args\n", "comments": "  copyright 2016 the tensorflow authors all rights reserved        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license           http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license                                                                                       exp ver     custom arch     map scape projection baseline     this function modifies args     multiscale vision based system     code multi scale planner     no planning version     code read outs  mscromms flattens reads     mscromss flatten produces output multiple scales     single scale vision based system use mapper instead    uses analytically estimated map     train  test  etc     log arguments ", "content": "# Copyright 2016 The TensorFlow Authors All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\nimport os, sys\nimport numpy as np\nfrom tensorflow.python.platform import app\nfrom tensorflow.python.platform import flags\nimport logging\nimport src.utils as utils\nimport cfgs.config_common as cc\n\n\nimport tensorflow as tf\n\n\nrgb_resnet_v2_50_path = 'data/init_models/resnet_v2_50/model.ckpt-5136169'\nd_resnet_v2_50_path = 'data/init_models/distill_rgb_to_d_resnet_v2_50/model.ckpt-120002'\n\ndef get_default_args():\n  summary_args = utils.Foo(display_interval=1, test_iters=26,\n                           arop_full_summary_iters=14)\n\n  control_args = utils.Foo(train=False, test=False,\n                           force_batchnorm_is_training_at_test=False,\n                           reset_rng_seed=False, only_eval_when_done=False,\n                           test_mode=None)\n  return summary_args, control_args\n\ndef get_default_cmp_args():\n  batch_norm_param = {'center': True, 'scale': True,\n                      'activation_fn':tf.nn.relu}\n\n  mapper_arch_args = utils.Foo(\n      dim_reduce_neurons=64,\n      fc_neurons=[1024, 1024],\n      fc_out_size=8,\n      fc_out_neurons=64,\n      encoder='resnet_v2_50',\n      deconv_neurons=[64, 32, 16, 8, 4, 2],\n      deconv_strides=[2, 2, 2, 2, 2, 2],\n      deconv_layers_per_block=2,\n      deconv_kernel_size=4,\n      fc_dropout=0.5,\n      combine_type='wt_avg_logits',\n      batch_norm_param=batch_norm_param)\n\n  readout_maps_arch_args = utils.Foo(\n      num_neurons=[],\n      strides=[],\n      kernel_size=None,\n      layers_per_block=None)\n\n  arch_args = utils.Foo(\n      vin_val_neurons=8, vin_action_neurons=8, vin_ks=3, vin_share_wts=False,\n      pred_neurons=[64, 64], pred_batch_norm_param=batch_norm_param,\n      conv_on_value_map=0, fr_neurons=16, fr_ver='v2', fr_inside_neurons=64,\n      fr_stride=1, crop_remove_each=30, value_crop_size=4,\n      action_sample_type='sample', action_sample_combine_type='one_or_other',\n      sample_gt_prob_type='inverse_sigmoid_decay', dagger_sample_bn_false=True,\n      vin_num_iters=36, isd_k=750., use_agent_loc=False, multi_scale=True,\n      readout_maps=False, rom_arch=readout_maps_arch_args)\n\n  return arch_args, mapper_arch_args\n\ndef get_arch_vars(arch_str):\n  if arch_str == '': vals = []\n  else: vals = arch_str.split('_')\n  ks = ['var1', 'var2', 'var3']\n  ks = ks[:len(vals)]\n  \n  # Exp Ver.\n  if len(vals) == 0: ks.append('var1'); vals.append('v0')\n  # custom arch.\n  if len(vals) == 1: ks.append('var2'); vals.append('')\n  # map scape for projection baseline.\n  if len(vals) == 2: ks.append('var3'); vals.append('fr2')\n\n  assert(len(vals) == 3)\n\n  vars = utils.Foo()\n  for k, v in zip(ks, vals):\n    setattr(vars, k, v)\n\n  logging.error('arch_vars: %s', vars)\n  return vars\n\ndef process_arch_str(args, arch_str):\n  # This function modifies args.\n  args.arch, args.mapper_arch = get_default_cmp_args()\n\n  arch_vars = get_arch_vars(arch_str)\n\n  args.navtask.task_params.outputs.ego_maps = True\n  args.navtask.task_params.outputs.ego_goal_imgs = True\n  args.navtask.task_params.outputs.egomotion = True\n  args.navtask.task_params.toy_problem = False\n\n  if arch_vars.var1 == 'lmap':\n    args = process_arch_learned_map(args, arch_vars)\n\n  elif arch_vars.var1 == 'pmap':\n    args = process_arch_projected_map(args, arch_vars)\n\n  else:\n    logging.fatal('arch_vars.var1 should be lmap or pmap, but is %s', arch_vars.var1)\n    assert(False)\n\n  return args\n\ndef process_arch_learned_map(args, arch_vars):\n  # Multiscale vision based system.\n  args.navtask.task_params.input_type = 'vision'\n  args.navtask.task_params.outputs.images = True\n  \n  if args.navtask.camera_param.modalities[0] == 'rgb':\n    args.solver.pretrained_path = rgb_resnet_v2_50_path\n  elif args.navtask.camera_param.modalities[0] == 'depth':\n    args.solver.pretrained_path = d_resnet_v2_50_path\n\n  if arch_vars.var2 == 'Ssc':\n    sc = 1./args.navtask.task_params.step_size\n    args.arch.vin_num_iters = 40\n    args.navtask.task_params.map_scales = [sc]\n    max_dist = args.navtask.task_params.max_dist * \\\n        args.navtask.task_params.num_goals\n    args.navtask.task_params.map_crop_sizes = [2*max_dist]\n\n    args.arch.fr_stride = 1\n    args.arch.vin_action_neurons = 8\n    args.arch.vin_val_neurons = 3\n    args.arch.fr_inside_neurons = 32\n\n    args.mapper_arch.pad_map_with_zeros_each = [24]\n    args.mapper_arch.deconv_neurons = [64, 32, 16]\n    args.mapper_arch.deconv_strides = [1, 2, 1]\n\n  elif (arch_vars.var2 == 'Msc' or arch_vars.var2 == 'MscROMms' or\n        arch_vars.var2 == 'MscROMss' or arch_vars.var2 == 'MscNoVin'):\n    # Code for multi-scale planner.\n    args.arch.vin_num_iters = 8\n    args.arch.crop_remove_each = 4\n    args.arch.value_crop_size = 8\n\n    sc = 1./args.navtask.task_params.step_size\n    max_dist = args.navtask.task_params.max_dist * \\\n        args.navtask.task_params.num_goals\n    n_scales = np.log2(float(max_dist) / float(args.arch.vin_num_iters))\n    n_scales = int(np.ceil(n_scales)+1)\n\n    args.navtask.task_params.map_scales = \\\n        list(sc*(0.5**(np.arange(n_scales))[::-1]))\n    args.navtask.task_params.map_crop_sizes = [16 for x in range(n_scales)]\n\n    args.arch.fr_stride = 1\n    args.arch.vin_action_neurons = 8\n    args.arch.vin_val_neurons = 3\n    args.arch.fr_inside_neurons = 32\n\n    args.mapper_arch.pad_map_with_zeros_each = [0 for _ in range(n_scales)]\n    args.mapper_arch.deconv_neurons = [64*n_scales, 32*n_scales, 16*n_scales]\n    args.mapper_arch.deconv_strides = [1, 2, 1]\n\n    if arch_vars.var2 == 'MscNoVin':\n      # No planning version.\n      args.arch.fr_stride = [1, 2, 1, 2]\n      args.arch.vin_action_neurons = None\n      args.arch.vin_val_neurons = 16\n      args.arch.fr_inside_neurons = 32\n\n      args.arch.crop_remove_each = 0\n      args.arch.value_crop_size = 4\n      args.arch.vin_num_iters = 0\n\n    elif arch_vars.var2 == 'MscROMms' or arch_vars.var2 == 'MscROMss':\n      # Code with read outs, MscROMms flattens and reads out,\n      # MscROMss does not flatten and produces output at multiple scales.\n      args.navtask.task_params.outputs.readout_maps = True\n      args.navtask.task_params.map_resize_method = 'antialiasing'\n      args.arch.readout_maps = True\n\n      if arch_vars.var2 == 'MscROMms':\n        args.arch.rom_arch.num_neurons = [64, 1]\n        args.arch.rom_arch.kernel_size = 4\n        args.arch.rom_arch.strides = [2,2]\n        args.arch.rom_arch.layers_per_block = 2\n\n        args.navtask.task_params.readout_maps_crop_sizes = [64]\n        args.navtask.task_params.readout_maps_scales = [sc]\n\n      elif arch_vars.var2 == 'MscROMss':\n        args.arch.rom_arch.num_neurons = \\\n            [64, len(args.navtask.task_params.map_scales)]\n        args.arch.rom_arch.kernel_size = 4\n        args.arch.rom_arch.strides = [1,1]\n        args.arch.rom_arch.layers_per_block = 1\n\n        args.navtask.task_params.readout_maps_crop_sizes = \\\n            args.navtask.task_params.map_crop_sizes\n        args.navtask.task_params.readout_maps_scales = \\\n            args.navtask.task_params.map_scales\n\n  else:\n    logging.fatal('arch_vars.var2 not one of Msc, MscROMms, MscROMss, MscNoVin.')\n    assert(False)\n\n  map_channels = args.mapper_arch.deconv_neurons[-1] / \\\n    (2*len(args.navtask.task_params.map_scales))\n  args.navtask.task_params.map_channels = map_channels\n  \n  return args\n\ndef process_arch_projected_map(args, arch_vars):\n  # Single scale vision based system which does not use a mapper but instead\n  # uses an analytically estimated map.\n  ds = int(arch_vars.var3[2])\n  args.navtask.task_params.input_type = 'analytical_counts'\n  args.navtask.task_params.outputs.analytical_counts = True\n\n  assert(args.navtask.task_params.modalities[0] == 'depth')\n  args.navtask.camera_param.img_channels = None\n\n  analytical_counts = utils.Foo(map_sizes=[512/ds],\n                                xy_resolution=[5.*ds],\n                                z_bins=[[-10, 10, 150, 200]],\n                                non_linearity=[arch_vars.var2])\n  args.navtask.task_params.analytical_counts = analytical_counts\n\n  sc = 1./ds\n  args.arch.vin_num_iters = 36\n  args.navtask.task_params.map_scales = [sc]\n  args.navtask.task_params.map_crop_sizes = [512/ds]\n\n  args.arch.fr_stride = [1,2]\n  args.arch.vin_action_neurons = 8\n  args.arch.vin_val_neurons = 3\n  args.arch.fr_inside_neurons = 32\n\n  map_channels = len(analytical_counts.z_bins[0]) + 1\n  args.navtask.task_params.map_channels = map_channels\n  args.solver.freeze_conv = False\n\n  return args\n\ndef get_args_for_config(config_name):\n  args = utils.Foo()\n\n  args.summary, args.control = get_default_args()\n\n  exp_name, mode_str = config_name.split('+')\n  arch_str, solver_str, navtask_str = exp_name.split('.')\n  logging.error('config_name: %s', config_name)\n  logging.error('arch_str: %s', arch_str)\n  logging.error('navtask_str: %s', navtask_str)\n  logging.error('solver_str: %s', solver_str)\n  logging.error('mode_str: %s', mode_str)\n\n  args.solver = cc.process_solver_str(solver_str)\n  args.navtask = cc.process_navtask_str(navtask_str)\n\n  args = process_arch_str(args, arch_str)\n  args.arch.isd_k = args.solver.isd_k\n\n  # Train, test, etc.\n  mode, imset = mode_str.split('_')\n  args = cc.adjust_args_for_mode(args, mode)\n  args.navtask.building_names = args.navtask.dataset.get_split(imset)\n  args.control.test_name = '{:s}_on_{:s}'.format(mode, imset)\n\n  # Log the arguments\n  logging.error('%s', args)\n  return args\n", "description": "Models and examples built with TensorFlow", "file_name": "config_cmp.py", "id": "5632b0eb3f924cf08dd1b1b1ba645cf6", "language": "Python", "project_name": "models", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/tensorflow-models/tensorflow-models-086d914/research/cognitive_mapping_and_planning/cfgs/config_cmp.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:59:19Z", "url": "https://github.com/tensorflow/models", "wiki": true}