{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom odoo import api, fields, tools, models, _\nfrom odoo.exceptions import UserError\n\n\nclass ProductUoMCategory(models.Model):\n    _name = 'product.uom.categ'\n    _description = 'Product UoM Categories'\n\n    name = fields.Char('Name', required=True, translate=True)\n\n\nclass ProductUoM(models.Model):\n    _name = 'product.uom'\n    _description = 'Product Unit of Measure'\n    _order = \"name\"\n\n    name = fields.Char('Unit of Measure', required=True, translate=True)\n    category_id = fields.Many2one(\n        'product.uom.categ', 'Category', required=True, ondelete='cascade',\n        help=\"Conversion between Units of Measure can only occur if they belong to the same category. The conversion will be made based on the ratios.\")\n    factor = fields.Float(\n        'Ratio', default=1.0, digits=0, required=True,  \n        help='How much bigger or smaller this unit is compared to the reference Unit of Measure for this category: 1 * (reference unit) = ratio * (this unit)')\n    factor_inv = fields.Float(\n        'Bigger Ratio', compute='_compute_factor_inv', digits=0,  \n        readonly=True, required=True,\n        help='How many times this Unit of Measure is bigger than the reference Unit of Measure in this category: 1 * (this unit) = ratio * (reference unit)')\n    rounding = fields.Float(\n        'Rounding Precision', default=0.01, digits=0, required=True,\n        help=\"The computed quantity will be a multiple of this value. \"\n             \"Use 1.0 for a Unit of Measure that cannot be further split, such as a piece.\")\n    active = fields.Boolean('Active', default=True, help=\"Uncheck the active field to disable a unit of measure without deleting it.\")\n    uom_type = fields.Selection([\n        ('bigger', 'Bigger than the reference Unit of Measure'),\n        ('reference', 'Reference Unit of Measure for this category'),\n        ('smaller', 'Smaller than the reference Unit of Measure')], 'Type',\n        default='reference', required=1)\n\n    _sql_constraints = [\n        ('factor_gt_zero', 'CHECK (factor!=0)', 'The conversion ratio for a unit of measure cannot be 0!'),\n        ('rounding_gt_zero', 'CHECK (rounding>0)', 'The rounding precision must be greater than 0!')\n    ]\n\n    @api.one\n    @api.depends('factor')\n    def _compute_factor_inv(self):\n        self.factor_inv = self.factor and (1.0 / self.factor) or 0.0\n\n    @api.onchange('uom_type')\n    def _onchange_uom_type(self):\n        if self.uom_type == 'reference':\n            self.factor = 1\n\n    @api.model\n    def create(self, values):\n        if 'factor_inv' in values:\n            factor_inv = values.pop('factor_inv')\n            values['factor'] = factor_inv and (1.0 / factor_inv) or 0.0\n        return super(ProductUoM, self).create(values)\n\n    @api.multi\n    def write(self, values):\n        if 'factor_inv' in values:\n            factor_inv = values.pop('factor_inv')\n            values['factor'] = factor_inv and (1.0 / factor_inv) or 0.0\n        return super(ProductUoM, self).write(values)\n\n    @api.model\n    def name_create(self, name):\n        \n        values = {\n            self._rec_name: name,\n            'factor': 1\n        }\n        \n        \n        if not self._context.get('default_category_id'):\n            EnglishUoMCateg = self.env['product.uom.categ'].with_context({})\n            misc_category = EnglishUoMCateg.search([('name', '=', 'Unsorted/Imported Units')])\n            if misc_category:\n                values['category_id'] = misc_category.id\n            else:\n                values['category_id'] = EnglishUoMCateg.name_create('Unsorted/Imported Units')[0]\n        new_uom = self.create(values)\n        return new_uom.name_get()[0]\n\n    @api.multi\n    def _compute_quantity(self, qty, to_unit, round=True, rounding_method='UP'):\n        if not self:\n            return qty\n        self.ensure_one()\n        if self.category_id.id != to_unit.category_id.id:\n            if self._context.get('raise-exception', True):\n                raise UserError(_('Conversion from Product UoM %s to Default UoM %s is not possible as they both belong to different Category!.') % (self.name, to_unit.name))\n            else:\n                return qty\n        amount = qty / self.factor\n        if to_unit:\n            amount = amount * to_unit.factor\n            if round:\n                amount = tools.float_round(amount, precision_rounding=to_unit.rounding, rounding_method=rounding_method)\n        return amount\n\n    @api.multi\n    def _compute_price(self, price, to_unit):\n        self.ensure_one()\n        if not self or not price or not to_unit or self == to_unit:\n            return price\n        if self.category_id.id != to_unit.category_id.id:\n            return price\n        amount = price * self.factor\n        if to_unit:\n            amount = amount / to_unit.factor\n        return amount\n", "comments": "    the uom category factor required  add temporary values         imported uoms            coding  utf 8        part odoo  see license file full copyright licensing details     force numeric unlimited precision    force numeric unlimited precision    look category based english name  e  context purpose     todo  find way translated created actually used ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom odoo import api, fields, tools, models, _\nfrom odoo.exceptions import UserError\n\n\nclass ProductUoMCategory(models.Model):\n    _name = 'product.uom.categ'\n    _description = 'Product UoM Categories'\n\n    name = fields.Char('Name', required=True, translate=True)\n\n\nclass ProductUoM(models.Model):\n    _name = 'product.uom'\n    _description = 'Product Unit of Measure'\n    _order = \"name\"\n\n    name = fields.Char('Unit of Measure', required=True, translate=True)\n    category_id = fields.Many2one(\n        'product.uom.categ', 'Category', required=True, ondelete='cascade',\n        help=\"Conversion between Units of Measure can only occur if they belong to the same category. The conversion will be made based on the ratios.\")\n    factor = fields.Float(\n        'Ratio', default=1.0, digits=0, required=True,  # force NUMERIC with unlimited precision\n        help='How much bigger or smaller this unit is compared to the reference Unit of Measure for this category: 1 * (reference unit) = ratio * (this unit)')\n    factor_inv = fields.Float(\n        'Bigger Ratio', compute='_compute_factor_inv', digits=0,  # force NUMERIC with unlimited precision\n        readonly=True, required=True,\n        help='How many times this Unit of Measure is bigger than the reference Unit of Measure in this category: 1 * (this unit) = ratio * (reference unit)')\n    rounding = fields.Float(\n        'Rounding Precision', default=0.01, digits=0, required=True,\n        help=\"The computed quantity will be a multiple of this value. \"\n             \"Use 1.0 for a Unit of Measure that cannot be further split, such as a piece.\")\n    active = fields.Boolean('Active', default=True, help=\"Uncheck the active field to disable a unit of measure without deleting it.\")\n    uom_type = fields.Selection([\n        ('bigger', 'Bigger than the reference Unit of Measure'),\n        ('reference', 'Reference Unit of Measure for this category'),\n        ('smaller', 'Smaller than the reference Unit of Measure')], 'Type',\n        default='reference', required=1)\n\n    _sql_constraints = [\n        ('factor_gt_zero', 'CHECK (factor!=0)', 'The conversion ratio for a unit of measure cannot be 0!'),\n        ('rounding_gt_zero', 'CHECK (rounding>0)', 'The rounding precision must be greater than 0!')\n    ]\n\n    @api.one\n    @api.depends('factor')\n    def _compute_factor_inv(self):\n        self.factor_inv = self.factor and (1.0 / self.factor) or 0.0\n\n    @api.onchange('uom_type')\n    def _onchange_uom_type(self):\n        if self.uom_type == 'reference':\n            self.factor = 1\n\n    @api.model\n    def create(self, values):\n        if 'factor_inv' in values:\n            factor_inv = values.pop('factor_inv')\n            values['factor'] = factor_inv and (1.0 / factor_inv) or 0.0\n        return super(ProductUoM, self).create(values)\n\n    @api.multi\n    def write(self, values):\n        if 'factor_inv' in values:\n            factor_inv = values.pop('factor_inv')\n            values['factor'] = factor_inv and (1.0 / factor_inv) or 0.0\n        return super(ProductUoM, self).write(values)\n\n    @api.model\n    def name_create(self, name):\n        \"\"\" The UoM category and factor are required, so we'll have to add temporary values\n        for imported UoMs \"\"\"\n        values = {\n            self._rec_name: name,\n            'factor': 1\n        }\n        # look for the category based on the english name, i.e. no context on purpose!\n        # TODO: should find a way to have it translated but not created until actually used\n        if not self._context.get('default_category_id'):\n            EnglishUoMCateg = self.env['product.uom.categ'].with_context({})\n            misc_category = EnglishUoMCateg.search([('name', '=', 'Unsorted/Imported Units')])\n            if misc_category:\n                values['category_id'] = misc_category.id\n            else:\n                values['category_id'] = EnglishUoMCateg.name_create('Unsorted/Imported Units')[0]\n        new_uom = self.create(values)\n        return new_uom.name_get()[0]\n\n    @api.multi\n    def _compute_quantity(self, qty, to_unit, round=True, rounding_method='UP'):\n        if not self:\n            return qty\n        self.ensure_one()\n        if self.category_id.id != to_unit.category_id.id:\n            if self._context.get('raise-exception', True):\n                raise UserError(_('Conversion from Product UoM %s to Default UoM %s is not possible as they both belong to different Category!.') % (self.name, to_unit.name))\n            else:\n                return qty\n        amount = qty / self.factor\n        if to_unit:\n            amount = amount * to_unit.factor\n            if round:\n                amount = tools.float_round(amount, precision_rounding=to_unit.rounding, rounding_method=rounding_method)\n        return amount\n\n    @api.multi\n    def _compute_price(self, price, to_unit):\n        self.ensure_one()\n        if not self or not price or not to_unit or self == to_unit:\n            return price\n        if self.category_id.id != to_unit.category_id.id:\n            return price\n        amount = price * self.factor\n        if to_unit:\n            amount = amount / to_unit.factor\n        return amount\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "product_uom.py", "id": "a20c9707bd7ea4ea762bed5e601c3217", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/product/models/product_uom.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}