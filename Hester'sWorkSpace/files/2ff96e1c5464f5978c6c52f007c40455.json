{"author": "pandas-dev", "code": "import numpy as np\nimport pandas.util.testing as tm\nfrom pandas import (Series, date_range, DatetimeIndex, Index, RangeIndex,\n                    Float64Index)\n\nfrom .pandas_vb_common import setup  \n\n\nclass SetOperations(object):\n\n    goal_time = 0.2\n    params = (['datetime', 'date_string', 'int', 'strings'],\n              ['intersection', 'union', 'symmetric_difference'])\n    param_names = ['dtype', 'method']\n\n    def setup(self, dtype, method):\n        N = 10**5\n        dates_left = date_range('1/1/2000', periods=N, freq='T')\n        fmt = '%Y-%m-%d %H:%M:%S'\n        date_str_left = Index(dates_left.strftime(fmt))\n        int_left = Index(np.arange(N))\n        str_left = tm.makeStringIndex(N)\n        data = {'datetime': {'left': dates_left, 'right': dates_left[:-1]},\n                'date_string': {'left': date_str_left,\n                                'right': date_str_left[:-1]},\n                'int': {'left': int_left, 'right': int_left[:-1]},\n                'strings': {'left': str_left, 'right': str_left[:-1]}}\n        self.left = data[dtype]['left']\n        self.right = data[dtype]['right']\n\n    def time_operation(self, dtype, method):\n        getattr(self.left, method)(self.right)\n\n\nclass SetDisjoint(object):\n\n    goal_time = 0.2\n\n    def setup(self):\n        N = 10**5\n        B = N + 20000\n        self.datetime_left = DatetimeIndex(range(N))\n        self.datetime_right = DatetimeIndex(range(N, B))\n\n    def time_datetime_difference_disjoint(self):\n        self.datetime_left.difference(self.datetime_right)\n\n\nclass Datetime(object):\n\n    goal_time = 0.2\n\n    def setup(self):\n        self.dr = date_range('20000101', freq='D', periods=10000)\n\n    def time_is_dates_only(self):\n        self.dr._is_dates_only\n\n\nclass Ops(object):\n\n    sample_time = 0.2\n    params = ['float', 'int']\n    param_names = ['dtype']\n\n    def setup(self, dtype):\n        N = 10**6\n        indexes = {'int': 'makeIntIndex', 'float': 'makeFloatIndex'}\n        self.index = getattr(tm, indexes[dtype])(N)\n\n    def time_add(self, dtype):\n        self.index + 2\n\n    def time_subtract(self, dtype):\n        self.index - 2\n\n    def time_multiply(self, dtype):\n        self.index * 2\n\n    def time_divide(self, dtype):\n        self.index / 2\n\n    def time_modulo(self, dtype):\n        self.index % 2\n\n\nclass Range(object):\n\n    goal_time = 0.2\n\n    def setup(self):\n        self.idx_inc = RangeIndex(start=0, stop=10**7, step=3)\n        self.idx_dec = RangeIndex(start=10**7, stop=-1, step=-3)\n\n    def time_max(self):\n        self.idx_inc.max()\n\n    def time_max_trivial(self):\n        self.idx_dec.max()\n\n    def time_min(self):\n        self.idx_dec.min()\n\n    def time_min_trivial(self):\n        self.idx_inc.min()\n\n\nclass IndexAppend(object):\n\n    goal_time = 0.2\n\n    def setup(self):\n\n        N = 10000\n        self.range_idx = RangeIndex(0, 100)\n        self.int_idx = self.range_idx.astype(int)\n        self.obj_idx = self.int_idx.astype(str)\n        self.range_idxs = []\n        self.int_idxs = []\n        self.object_idxs = []\n        for i in range(1, N):\n            r_idx = RangeIndex(i * 100, (i + 1) * 100)\n            self.range_idxs.append(r_idx)\n            i_idx = r_idx.astype(int)\n            self.int_idxs.append(i_idx)\n            o_idx = i_idx.astype(str)\n            self.object_idxs.append(o_idx)\n\n    def time_append_range_list(self):\n        self.range_idx.append(self.range_idxs)\n\n    def time_append_int_list(self):\n        self.int_idx.append(self.int_idxs)\n\n    def time_append_obj_list(self):\n        self.obj_idx.append(self.object_idxs)\n\n\nclass Indexing(object):\n\n    goal_time = 0.2\n    params = ['String', 'Float', 'Int']\n    param_names = ['dtype']\n\n    def setup(self, dtype):\n        N = 10**6\n        self.idx = getattr(tm, 'make{}Index'.format(dtype))(N)\n        self.array_mask = (np.arange(N) % 3) == 0\n        self.series_mask = Series(self.array_mask)\n        self.sorted = self.idx.sort_values()\n        half = N // 2\n        self.non_unique = self.idx[:half].append(self.idx[:half])\n        self.non_unique_sorted = self.sorted[:half].append(self.sorted[:half])\n        self.key = self.sorted[N // 4]\n\n    def time_boolean_array(self, dtype):\n        self.idx[self.array_mask]\n\n    def time_boolean_series(self, dtype):\n        self.idx[self.series_mask]\n\n    def time_get(self, dtype):\n        self.idx[1]\n\n    def time_slice(self, dtype):\n        self.idx[:-1]\n\n    def time_slice_step(self, dtype):\n        self.idx[::2]\n\n    def time_get_loc(self, dtype):\n        self.idx.get_loc(self.key)\n\n    def time_get_loc_sorted(self, dtype):\n        self.sorted.get_loc(self.key)\n\n    def time_get_loc_non_unique(self, dtype):\n        self.non_unique.get_loc(self.key)\n\n    def time_get_loc_non_unique_sorted(self, dtype):\n        self.non_unique_sorted.get_loc(self.key)\n\n\nclass Float64IndexMethod(object):\n    \n    goal_time = 0.2\n\n    def setup(self):\n        N = 100000\n        a = np.arange(N)\n        self.ind = Float64Index(a * 4.8000000418824129e-08)\n\n    def time_get_loc(self):\n        self.ind.get_loc(0)\n", "comments": "noqa gh 13166", "content": "import numpy as np\nimport pandas.util.testing as tm\nfrom pandas import (Series, date_range, DatetimeIndex, Index, RangeIndex,\n                    Float64Index)\n\nfrom .pandas_vb_common import setup  # noqa\n\n\nclass SetOperations(object):\n\n    goal_time = 0.2\n    params = (['datetime', 'date_string', 'int', 'strings'],\n              ['intersection', 'union', 'symmetric_difference'])\n    param_names = ['dtype', 'method']\n\n    def setup(self, dtype, method):\n        N = 10**5\n        dates_left = date_range('1/1/2000', periods=N, freq='T')\n        fmt = '%Y-%m-%d %H:%M:%S'\n        date_str_left = Index(dates_left.strftime(fmt))\n        int_left = Index(np.arange(N))\n        str_left = tm.makeStringIndex(N)\n        data = {'datetime': {'left': dates_left, 'right': dates_left[:-1]},\n                'date_string': {'left': date_str_left,\n                                'right': date_str_left[:-1]},\n                'int': {'left': int_left, 'right': int_left[:-1]},\n                'strings': {'left': str_left, 'right': str_left[:-1]}}\n        self.left = data[dtype]['left']\n        self.right = data[dtype]['right']\n\n    def time_operation(self, dtype, method):\n        getattr(self.left, method)(self.right)\n\n\nclass SetDisjoint(object):\n\n    goal_time = 0.2\n\n    def setup(self):\n        N = 10**5\n        B = N + 20000\n        self.datetime_left = DatetimeIndex(range(N))\n        self.datetime_right = DatetimeIndex(range(N, B))\n\n    def time_datetime_difference_disjoint(self):\n        self.datetime_left.difference(self.datetime_right)\n\n\nclass Datetime(object):\n\n    goal_time = 0.2\n\n    def setup(self):\n        self.dr = date_range('20000101', freq='D', periods=10000)\n\n    def time_is_dates_only(self):\n        self.dr._is_dates_only\n\n\nclass Ops(object):\n\n    sample_time = 0.2\n    params = ['float', 'int']\n    param_names = ['dtype']\n\n    def setup(self, dtype):\n        N = 10**6\n        indexes = {'int': 'makeIntIndex', 'float': 'makeFloatIndex'}\n        self.index = getattr(tm, indexes[dtype])(N)\n\n    def time_add(self, dtype):\n        self.index + 2\n\n    def time_subtract(self, dtype):\n        self.index - 2\n\n    def time_multiply(self, dtype):\n        self.index * 2\n\n    def time_divide(self, dtype):\n        self.index / 2\n\n    def time_modulo(self, dtype):\n        self.index % 2\n\n\nclass Range(object):\n\n    goal_time = 0.2\n\n    def setup(self):\n        self.idx_inc = RangeIndex(start=0, stop=10**7, step=3)\n        self.idx_dec = RangeIndex(start=10**7, stop=-1, step=-3)\n\n    def time_max(self):\n        self.idx_inc.max()\n\n    def time_max_trivial(self):\n        self.idx_dec.max()\n\n    def time_min(self):\n        self.idx_dec.min()\n\n    def time_min_trivial(self):\n        self.idx_inc.min()\n\n\nclass IndexAppend(object):\n\n    goal_time = 0.2\n\n    def setup(self):\n\n        N = 10000\n        self.range_idx = RangeIndex(0, 100)\n        self.int_idx = self.range_idx.astype(int)\n        self.obj_idx = self.int_idx.astype(str)\n        self.range_idxs = []\n        self.int_idxs = []\n        self.object_idxs = []\n        for i in range(1, N):\n            r_idx = RangeIndex(i * 100, (i + 1) * 100)\n            self.range_idxs.append(r_idx)\n            i_idx = r_idx.astype(int)\n            self.int_idxs.append(i_idx)\n            o_idx = i_idx.astype(str)\n            self.object_idxs.append(o_idx)\n\n    def time_append_range_list(self):\n        self.range_idx.append(self.range_idxs)\n\n    def time_append_int_list(self):\n        self.int_idx.append(self.int_idxs)\n\n    def time_append_obj_list(self):\n        self.obj_idx.append(self.object_idxs)\n\n\nclass Indexing(object):\n\n    goal_time = 0.2\n    params = ['String', 'Float', 'Int']\n    param_names = ['dtype']\n\n    def setup(self, dtype):\n        N = 10**6\n        self.idx = getattr(tm, 'make{}Index'.format(dtype))(N)\n        self.array_mask = (np.arange(N) % 3) == 0\n        self.series_mask = Series(self.array_mask)\n        self.sorted = self.idx.sort_values()\n        half = N // 2\n        self.non_unique = self.idx[:half].append(self.idx[:half])\n        self.non_unique_sorted = self.sorted[:half].append(self.sorted[:half])\n        self.key = self.sorted[N // 4]\n\n    def time_boolean_array(self, dtype):\n        self.idx[self.array_mask]\n\n    def time_boolean_series(self, dtype):\n        self.idx[self.series_mask]\n\n    def time_get(self, dtype):\n        self.idx[1]\n\n    def time_slice(self, dtype):\n        self.idx[:-1]\n\n    def time_slice_step(self, dtype):\n        self.idx[::2]\n\n    def time_get_loc(self, dtype):\n        self.idx.get_loc(self.key)\n\n    def time_get_loc_sorted(self, dtype):\n        self.sorted.get_loc(self.key)\n\n    def time_get_loc_non_unique(self, dtype):\n        self.non_unique.get_loc(self.key)\n\n    def time_get_loc_non_unique_sorted(self, dtype):\n        self.non_unique_sorted.get_loc(self.key)\n\n\nclass Float64IndexMethod(object):\n    # GH 13166\n    goal_time = 0.2\n\n    def setup(self):\n        N = 100000\n        a = np.arange(N)\n        self.ind = Float64Index(a * 4.8000000418824129e-08)\n\n    def time_get_loc(self):\n        self.ind.get_loc(0)\n", "description": "Flexible and powerful data analysis / manipulation library for Python, providing labeled data structures similar to R data.frame objects, statistical functions, and much more", "file_name": "index_object.py", "id": "2ff96e1c5464f5978c6c52f007c40455", "language": "Python", "project_name": "pandas", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/pandas-dev-pandas/pandas-dev-pandas-3783ccc/asv_bench/benchmarks/index_object.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:47:21Z", "url": "https://github.com/pandas-dev/pandas", "wiki": true}