{"author": "ansible", "code": "\n\n Copyright: Ansible Project\n GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = \"\"\"\n---\nmodule: sros_command\nversion_added: \"2.2\"\nauthor: \"Peter Sprygada (@privateip)\"\nshort_description: Run commands on remote devices running Nokia SR OS\ndescription:\n  - Sends arbitrary commands to an SR OS node and returns the results\n    read from the device. This module includes an argument that will\n    cause the module to wait for a specific condition before returning\n    or timing out if the condition is not met.\n  - This module does not support running commands in configuration mode.\n    Please use M(sros_config) to configure SR OS devices.\nextends_documentation_fragment: sros\noptions:\n  commands:\n    description:\n      - List of commands to send to the remote SR OS device over the\n        configured provider. The resulting output from the command\n        is returned. If the I(wait_for) argument is provided, the\n        module is not returned until the condition is satisfied or\n        the number of retries has expired.\n    required: true\n  wait_for:\n    description:\n      - List of conditions to evaluate against the output of the\n        command. The task will wait for each condition to be true\n        before moving forward. If the conditional is not true\n        within the configured number of retries, the task fails.\n        See examples.\n    aliases: ['waitfor']\n  match:\n    description:\n      - The I(match) argument is used in conjunction with the\n        I(wait_for) argument to specify the match policy.  Valid\n        values are C(all) or C(any).  If the value is set to C(all)\n        then all conditionals in the wait_for must be satisfied.  If\n        the value is set to C(any) then only one of the values must be\n        satisfied.\n    default: all\n    choices: ['any', 'all']\n  retries:\n    description:\n      - Specifies the number of retries a command should by tried\n        before it is considered failed. The command is run on the\n        target device every retry and evaluated against the\n        I(wait_for) conditions.\n    default: 10\n  interval:\n    description:\n      - Configures the interval in seconds to wait between retries\n        of the command. If the command does not pass the specified\n        conditions, the interval indicates how long to wait before\n        trying the command again.\n    default: 1\n\"\"\"\n\nEXAMPLES = \"\"\"\n Note: examples below use the following provider dict to handle\n       transport and authentication to the node.\n---\nvars:\n  cli:\n    host: \"{{ inventory_hostname }}\"\n    username: admin\n    password: admin\n    transport: cli\n\n---\ntasks:\n  - name: run show version on remote devices\n    sros_command:\n      commands: show version\n      provider: \"{{ cli }}\"\n\n  - name: run show version and check to see if output contains sros\n    sros_command:\n      commands: show version\n      wait_for: result[0] contains sros\n      provider: \"{{ cli }}\"\n\n  - name: run multiple commands on remote nodes\n    sros_command:\n      commands:\n        - show version\n        - show port detail\n      provider: \"{{ cli }}\"\n\n  - name: run multiple commands and evaluate the output\n    sros_command:\n      commands:\n        - show version\n        - show port detail\n      wait_for:\n        - result[0] contains TiMOS-B-14.0.R4\n      provider: \"{{ cli }}\"\n\"\"\"\n\nRETURN = \"\"\"\nstdout:\n  description: The set of responses from the commands\n  returned: always apart from low level errors (such as action plugin)\n  type: list\n  sample: ['...', '...']\n\nstdout_lines:\n  description: The value of stdout split into a list\n  returned: always apart from low level errors (such as action plugin)\n  type: list\n  sample: [['...', '...'], ['...'], ['...']]\n\nfailed_conditions:\n  description: The list of conditionals that have failed\n  returned: failed\n  type: list\n  sample: ['...', '...']\n\"\"\"\nimport time\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.network.common.parsing import Conditional\nfrom ansible.module_utils.network.common.utils import ComplexList\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils.network.sros.sros import run_commands, sros_argument_spec, check_args\n\n\ndef to_lines(stdout):\n    for item in stdout:\n        if isinstance(item, string_types):\n            item = str(item).split('\\n')\n        yield item\n\n\ndef parse_commands(module, warnings):\n    command = ComplexList(dict(\n        command=dict(key=True),\n        prompt=dict(),\n        answer=dict()\n    ), module)\n    commands = command(module.params['commands'])\n    for index, item in enumerate(commands):\n        if module.check_mode and not item['command'].startswith('show'):\n            warnings.append(\n                'only show commands are supported when using check mode, not '\n                'executing `%s`' % item['command']\n            )\n        elif item['command'].startswith('conf'):\n            module.fail_json(\n                msg='sros_command does not support running config mode '\n                    'commands.  Please use sros_config instead'\n            )\n    return commands\n\n\ndef main():\n    \"\"\"main entry point for module execution\n    \"\"\"\n    argument_spec = dict(\n        commands=dict(type='list', required=True),\n\n        wait_for=dict(type='list', aliases=['waitfor']),\n        match=dict(default='all', choices=['all', 'any']),\n\n        retries=dict(default=10, type='int'),\n        interval=dict(default=1, type='int')\n    )\n\n    argument_spec.update(sros_argument_spec)\n\n    module = AnsibleModule(argument_spec=argument_spec,\n                           supports_check_mode=True)\n\n    result = {'changed': False}\n\n    warnings = list()\n    check_args(module, warnings)\n    commands = parse_commands(module, warnings)\n    result['warnings'] = warnings\n\n    wait_for = module.params['wait_for'] or list()\n    conditionals = [Conditional(c) for c in wait_for]\n\n    retries = module.params['retries']\n    interval = module.params['interval']\n    match = module.params['match']\n\n    while retries > 0:\n        responses = run_commands(module, commands)\n\n        for item in list(conditionals):\n            if item(responses):\n                if match == 'any':\n                    conditionals = list()\n                    break\n                conditionals.remove(item)\n\n        if not conditionals:\n            break\n\n        time.sleep(interval)\n        retries -= 1\n\n    if conditionals:\n        failed_conditions = [item.raw for item in conditionals]\n        msg = 'One or more conditional statements have not been satisfied'\n        module.fail_json(msg=msg, failed_conditions=failed_conditions)\n\n    result = {\n        'changed': False,\n        'stdout': responses,\n        'stdout_lines': list(to_lines(responses))\n    }\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  sros command version added   2 2  author   peter sprygada ( privateip)  short description  run commands remote devices running nokia sr os description      sends arbitrary commands sr os node returns results     read device  this module includes argument     cause module wait specific condition returning     timing condition met      this module support running commands configuration mode      please use m(sros config) configure sr os devices  extends documentation fragment  sros options    commands      description          list commands send remote sr os device         configured provider  the resulting output command         returned  if i(wait for) argument provided          module returned condition satisfied         number retries expired      required  true   wait      description          list conditions evaluate output         command  the task wait condition true         moving forward  if conditional true         within configured number retries  task fails          see examples      aliases    waitfor     match      description          the i(match) argument used conjunction         i(wait for) argument specify match policy   valid         values c(all) c(any)   if value set c(all)         conditionals wait must satisfied   if         value set c(any) one values must         satisfied      default      choices           retries      description          specifies number retries command tried         considered failed  the command run         target device every retry evaluated         i(wait for) conditions      default  10   interval      description          configures interval seconds wait retries         command  if command pass specified         conditions  interval indicates long wait         trying command      default  1      examples         note  examples use following provider dict handle         transport authentication node      vars    cli      host      inventory hostname         username  admin     password  admin     transport  cli      tasks      name  run show version remote devices     sros command        commands  show version       provider      cli          name  run show version check see output contains sros     sros command        commands  show version       wait  result 0  contains sros       provider      cli          name  run multiple commands remote nodes     sros command        commands            show version           show port detail       provider      cli          name  run multiple commands evaluate output     sros command        commands            show version           show port detail       wait            result 0  contains timos b 14 0 r4       provider      cli          return       stdout    description  the set responses commands   returned  always apart low level errors (such action plugin)   type  list   sample                  stdout lines    description  the value stdout split list   returned  always apart low level errors (such action plugin)   type  list   sample                                      failed conditions    description  the list conditionals failed   returned  failed   type  list   sample                     import time  ansible module utils basic import ansiblemodule ansible module utils network common parsing import conditional ansible module utils network common utils import complexlist ansible module utils six import string types ansible module utils network sros sros import run commands  sros argument spec  check args   def lines(stdout)      item stdout          isinstance(item  string types)              item   str(item) split(  n )         yield item   def parse commands(module  warnings)      command   complexlist(dict(         command dict(key true)          prompt dict()          answer dict()     )  module)     commands   command(module params  commands  )     index  item enumerate(commands)          module check mode item  command   startswith( show )              warnings append(                  show commands supported using check mode                     executing       item  command               )         elif item  command   startswith( conf )              module fail json(                 msg  sros command support running config mode                        commands   please use sros config instead              )     return commands   def main()         main entry point module execution             usr bin python       copyright  ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    note  examples use following provider dict handle          transport authentication node  ", "content": "#!/usr/bin/python\n#\n# Copyright: Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = \"\"\"\n---\nmodule: sros_command\nversion_added: \"2.2\"\nauthor: \"Peter Sprygada (@privateip)\"\nshort_description: Run commands on remote devices running Nokia SR OS\ndescription:\n  - Sends arbitrary commands to an SR OS node and returns the results\n    read from the device. This module includes an argument that will\n    cause the module to wait for a specific condition before returning\n    or timing out if the condition is not met.\n  - This module does not support running commands in configuration mode.\n    Please use M(sros_config) to configure SR OS devices.\nextends_documentation_fragment: sros\noptions:\n  commands:\n    description:\n      - List of commands to send to the remote SR OS device over the\n        configured provider. The resulting output from the command\n        is returned. If the I(wait_for) argument is provided, the\n        module is not returned until the condition is satisfied or\n        the number of retries has expired.\n    required: true\n  wait_for:\n    description:\n      - List of conditions to evaluate against the output of the\n        command. The task will wait for each condition to be true\n        before moving forward. If the conditional is not true\n        within the configured number of retries, the task fails.\n        See examples.\n    aliases: ['waitfor']\n  match:\n    description:\n      - The I(match) argument is used in conjunction with the\n        I(wait_for) argument to specify the match policy.  Valid\n        values are C(all) or C(any).  If the value is set to C(all)\n        then all conditionals in the wait_for must be satisfied.  If\n        the value is set to C(any) then only one of the values must be\n        satisfied.\n    default: all\n    choices: ['any', 'all']\n  retries:\n    description:\n      - Specifies the number of retries a command should by tried\n        before it is considered failed. The command is run on the\n        target device every retry and evaluated against the\n        I(wait_for) conditions.\n    default: 10\n  interval:\n    description:\n      - Configures the interval in seconds to wait between retries\n        of the command. If the command does not pass the specified\n        conditions, the interval indicates how long to wait before\n        trying the command again.\n    default: 1\n\"\"\"\n\nEXAMPLES = \"\"\"\n# Note: examples below use the following provider dict to handle\n#       transport and authentication to the node.\n---\nvars:\n  cli:\n    host: \"{{ inventory_hostname }}\"\n    username: admin\n    password: admin\n    transport: cli\n\n---\ntasks:\n  - name: run show version on remote devices\n    sros_command:\n      commands: show version\n      provider: \"{{ cli }}\"\n\n  - name: run show version and check to see if output contains sros\n    sros_command:\n      commands: show version\n      wait_for: result[0] contains sros\n      provider: \"{{ cli }}\"\n\n  - name: run multiple commands on remote nodes\n    sros_command:\n      commands:\n        - show version\n        - show port detail\n      provider: \"{{ cli }}\"\n\n  - name: run multiple commands and evaluate the output\n    sros_command:\n      commands:\n        - show version\n        - show port detail\n      wait_for:\n        - result[0] contains TiMOS-B-14.0.R4\n      provider: \"{{ cli }}\"\n\"\"\"\n\nRETURN = \"\"\"\nstdout:\n  description: The set of responses from the commands\n  returned: always apart from low level errors (such as action plugin)\n  type: list\n  sample: ['...', '...']\n\nstdout_lines:\n  description: The value of stdout split into a list\n  returned: always apart from low level errors (such as action plugin)\n  type: list\n  sample: [['...', '...'], ['...'], ['...']]\n\nfailed_conditions:\n  description: The list of conditionals that have failed\n  returned: failed\n  type: list\n  sample: ['...', '...']\n\"\"\"\nimport time\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.network.common.parsing import Conditional\nfrom ansible.module_utils.network.common.utils import ComplexList\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils.network.sros.sros import run_commands, sros_argument_spec, check_args\n\n\ndef to_lines(stdout):\n    for item in stdout:\n        if isinstance(item, string_types):\n            item = str(item).split('\\n')\n        yield item\n\n\ndef parse_commands(module, warnings):\n    command = ComplexList(dict(\n        command=dict(key=True),\n        prompt=dict(),\n        answer=dict()\n    ), module)\n    commands = command(module.params['commands'])\n    for index, item in enumerate(commands):\n        if module.check_mode and not item['command'].startswith('show'):\n            warnings.append(\n                'only show commands are supported when using check mode, not '\n                'executing `%s`' % item['command']\n            )\n        elif item['command'].startswith('conf'):\n            module.fail_json(\n                msg='sros_command does not support running config mode '\n                    'commands.  Please use sros_config instead'\n            )\n    return commands\n\n\ndef main():\n    \"\"\"main entry point for module execution\n    \"\"\"\n    argument_spec = dict(\n        commands=dict(type='list', required=True),\n\n        wait_for=dict(type='list', aliases=['waitfor']),\n        match=dict(default='all', choices=['all', 'any']),\n\n        retries=dict(default=10, type='int'),\n        interval=dict(default=1, type='int')\n    )\n\n    argument_spec.update(sros_argument_spec)\n\n    module = AnsibleModule(argument_spec=argument_spec,\n                           supports_check_mode=True)\n\n    result = {'changed': False}\n\n    warnings = list()\n    check_args(module, warnings)\n    commands = parse_commands(module, warnings)\n    result['warnings'] = warnings\n\n    wait_for = module.params['wait_for'] or list()\n    conditionals = [Conditional(c) for c in wait_for]\n\n    retries = module.params['retries']\n    interval = module.params['interval']\n    match = module.params['match']\n\n    while retries > 0:\n        responses = run_commands(module, commands)\n\n        for item in list(conditionals):\n            if item(responses):\n                if match == 'any':\n                    conditionals = list()\n                    break\n                conditionals.remove(item)\n\n        if not conditionals:\n            break\n\n        time.sleep(interval)\n        retries -= 1\n\n    if conditionals:\n        failed_conditions = [item.raw for item in conditionals]\n        msg = 'One or more conditional statements have not been satisfied'\n        module.fail_json(msg=msg, failed_conditions=failed_conditions)\n\n    result = {\n        'changed': False,\n        'stdout': responses,\n        'stdout_lines': list(to_lines(responses))\n    }\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "sros_command.py", "id": "1705569d9b6efbfccb60185cfacd4b1b", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/network/sros/sros_command.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}