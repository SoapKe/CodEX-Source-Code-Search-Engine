{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    int_or_none,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    def _call_api(self, url, player, referrer, video_id, item):\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item,\n            headers={\n                'Referer': referrer,\n                'Api-Auth': 'Bearer %s' % player['apiToken'],\n            })\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?]+)\\.html'\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh')\n\n    _TESTS = [{\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': 'die-magie-der-farben-von-koenigspurpur-und-jeansblau-100',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = caption.get('uri')\n            if subtitle_url and isinstance(subtitle_url, compat_str):\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = meta.get('url')\n        if not format_url or not isinstance(format_url, compat_str):\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'portal')\n\n        ptmd = self._call_api(\n            urljoin(url, ptmd_path), player, url, video_id, 'metadata')\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            video_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                if not isinstance(layout_url, compat_str):\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(ptmd),\n            'formats': formats,\n        }\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], player, url, video_id, 'content')\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        document = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)['document']\n\n        title = document['titel']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(video_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(try_get(\n                document, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_count': 21,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_count': 4,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\n", "comments": "\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \n \n# coding: utf-8\n#&]+)'\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    int_or_none,\n    NO_DEFAULT,\n    orderedSet,\n    parse_codecs,\n    qualities,\n    try_get,\n    unified_timestamp,\n    update_url_query,\n    urljoin,\n)\n\n\nclass ZDFBaseIE(InfoExtractor):\n    def _call_api(self, url, player, referrer, video_id, item):\n        return self._download_json(\n            url, video_id, 'Downloading JSON %s' % item,\n            headers={\n                'Referer': referrer,\n                'Api-Auth': 'Bearer %s' % player['apiToken'],\n            })\n\n    def _extract_player(self, webpage, video_id, fatal=True):\n        return self._parse_json(\n            self._search_regex(\n                r'(?s)data-zdfplayer-jsb=([\"\\'])(?P<json>{.+?})\\1', webpage,\n                'player JSON', default='{}' if not fatal else NO_DEFAULT,\n                group='json'),\n            video_id)\n\n\nclass ZDFIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?]+)\\.html'\n    _QUALITIES = ('auto', 'low', 'med', 'high', 'veryhigh')\n\n    _TESTS = [{\n        'url': 'https://www.zdf.de/dokumentation/terra-x/die-magie-der-farben-von-koenigspurpur-und-jeansblau-100.html',\n        'info_dict': {\n            'id': 'die-magie-der-farben-von-koenigspurpur-und-jeansblau-100',\n            'ext': 'mp4',\n            'title': 'Die Magie der Farben (2/2)',\n            'description': 'md5:a89da10c928c6235401066b60a6d5c1a',\n            'duration': 2615,\n            'timestamp': 1465021200,\n            'upload_date': '20160604',\n        },\n    }, {\n        'url': 'https://www.zdf.de/service-und-hilfe/die-neue-zdf-mediathek/zdfmediathek-trailer-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/die-lebenden-und-die-toten-1---ein-taunuskrimi-100.html',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e/planet-e-uebersichtsseite-weitere-dokumentationen-von-planet-e-100.html',\n        'only_matching': True,\n    }]\n\n    @staticmethod\n    def _extract_subtitles(src):\n        subtitles = {}\n        for caption in try_get(src, lambda x: x['captions'], list) or []:\n            subtitle_url = caption.get('uri')\n            if subtitle_url and isinstance(subtitle_url, compat_str):\n                lang = caption.get('language', 'deu')\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitle_url,\n                })\n        return subtitles\n\n    def _extract_format(self, video_id, formats, format_urls, meta):\n        format_url = meta.get('url')\n        if not format_url or not isinstance(format_url, compat_str):\n            return\n        if format_url in format_urls:\n            return\n        format_urls.add(format_url)\n        mime_type = meta.get('mimeType')\n        ext = determine_ext(format_url)\n        if mime_type == 'application/x-mpegURL' or ext == 'm3u8':\n            formats.extend(self._extract_m3u8_formats(\n                format_url, video_id, 'mp4', m3u8_id='hls',\n                entry_protocol='m3u8_native', fatal=False))\n        elif mime_type == 'application/f4m+xml' or ext == 'f4m':\n            formats.extend(self._extract_f4m_formats(\n                update_url_query(format_url, {'hdcore': '3.7.0'}), video_id, f4m_id='hds', fatal=False))\n        else:\n            f = parse_codecs(meta.get('mimeCodec'))\n            format_id = ['http']\n            for p in (meta.get('type'), meta.get('quality')):\n                if p and isinstance(p, compat_str):\n                    format_id.append(p)\n            f.update({\n                'url': format_url,\n                'format_id': '-'.join(format_id),\n                'format_note': meta.get('quality'),\n                'language': meta.get('language'),\n                'quality': qualities(self._QUALITIES)(meta.get('quality')),\n                'preference': -10,\n            })\n            formats.append(f)\n\n    def _extract_entry(self, url, player, content, video_id):\n        title = content.get('title') or content['teaserHeadline']\n\n        t = content['mainVideoContent']['http://zdf.de/rels/target']\n\n        ptmd_path = t.get('http://zdf.de/rels/streams/ptmd')\n\n        if not ptmd_path:\n            ptmd_path = t[\n                'http://zdf.de/rels/streams/ptmd-template'].replace(\n                '{playerId}', 'portal')\n\n        ptmd = self._call_api(\n            urljoin(url, ptmd_path), player, url, video_id, 'metadata')\n\n        formats = []\n        track_uris = set()\n        for p in ptmd['priorityList']:\n            formitaeten = p.get('formitaeten')\n            if not isinstance(formitaeten, list):\n                continue\n            for f in formitaeten:\n                f_qualities = f.get('qualities')\n                if not isinstance(f_qualities, list):\n                    continue\n                for quality in f_qualities:\n                    tracks = try_get(quality, lambda x: x['audio']['tracks'], list)\n                    if not tracks:\n                        continue\n                    for track in tracks:\n                        self._extract_format(\n                            video_id, formats, track_uris, {\n                                'url': track.get('uri'),\n                                'type': f.get('type'),\n                                'mimeType': f.get('mimeType'),\n                                'quality': quality.get('quality'),\n                                'language': track.get('language'),\n                            })\n        self._sort_formats(formats)\n\n        thumbnails = []\n        layouts = try_get(\n            content, lambda x: x['teaserImageRef']['layouts'], dict)\n        if layouts:\n            for layout_key, layout_url in layouts.items():\n                if not isinstance(layout_url, compat_str):\n                    continue\n                thumbnail = {\n                    'url': layout_url,\n                    'format_id': layout_key,\n                }\n                mobj = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)', layout_key)\n                if mobj:\n                    thumbnail.update({\n                        'width': int(mobj.group('width')),\n                        'height': int(mobj.group('height')),\n                    })\n                thumbnails.append(thumbnail)\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': content.get('leadParagraph') or content.get('teasertext'),\n            'duration': int_or_none(t.get('duration')),\n            'timestamp': unified_timestamp(content.get('editorialDate')),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(ptmd),\n            'formats': formats,\n        }\n\n    def _extract_regular(self, url, player, video_id):\n        content = self._call_api(\n            player['content'], player, url, video_id, 'content')\n        return self._extract_entry(player['content'], player, content, video_id)\n\n    def _extract_mobile(self, video_id):\n        document = self._download_json(\n            'https://zdf-cdn.live.cellular.de/mediathekV2/document/%s' % video_id,\n            video_id)['document']\n\n        title = document['titel']\n\n        formats = []\n        format_urls = set()\n        for f in document['formitaeten']:\n            self._extract_format(video_id, formats, format_urls, f)\n        self._sort_formats(formats)\n\n        thumbnails = []\n        teaser_bild = document.get('teaserBild')\n        if isinstance(teaser_bild, dict):\n            for thumbnail_key, thumbnail in teaser_bild.items():\n                thumbnail_url = try_get(\n                    thumbnail, lambda x: x['url'], compat_str)\n                if thumbnail_url:\n                    thumbnails.append({\n                        'url': thumbnail_url,\n                        'id': thumbnail_key,\n                        'width': int_or_none(thumbnail.get('width')),\n                        'height': int_or_none(thumbnail.get('height')),\n                    })\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': document.get('beschreibung'),\n            'duration': int_or_none(document.get('length')),\n            'timestamp': unified_timestamp(try_get(\n                document, lambda x: x['meta']['editorialDate'], compat_str)),\n            'thumbnails': thumbnails,\n            'subtitles': self._extract_subtitles(document),\n            'formats': formats,\n        }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id, fatal=False)\n        if webpage:\n            player = self._extract_player(webpage, url, fatal=False)\n            if player:\n                return self._extract_regular(url, player, video_id)\n\n        return self._extract_mobile(video_id)\n\n\nclass ZDFChannelIE(ZDFBaseIE):\n    _VALID_URL = r'https?://www\\.zdf\\.de/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n    _TESTS = [{\n        'url': 'https://www.zdf.de/sport/das-aktuelle-sportstudio',\n        'info_dict': {\n            'id': 'das-aktuelle-sportstudio',\n            'title': 'das aktuelle sportstudio | ZDF',\n        },\n        'playlist_count': 21,\n    }, {\n        'url': 'https://www.zdf.de/dokumentation/planet-e',\n        'info_dict': {\n            'id': 'planet-e',\n            'title': 'planet e.',\n        },\n        'playlist_count': 4,\n    }, {\n        'url': 'https://www.zdf.de/filme/taunuskrimi/',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if ZDFIE.suitable(url) else super(ZDFChannelIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, channel_id)\n\n        entries = [\n            self.url_result(item_url, ie=ZDFIE.ie_key())\n            for item_url in orderedSet(re.findall(\n                r'data-plusbar-url=[\"\\'](http.+?\\.html)', webpage))]\n\n        return self.playlist_result(\n            entries, channel_id, self._og_search_title(webpage, fatal=False))\n\n        r\"\"\"\n        player = self._extract_player(webpage, channel_id)\n\n        channel_id = self._search_regex(\n            r'docId\\s*:\\s*([\"\\'])(?P<id>(?!\\1).+?)\\1', webpage,\n            'channel id', group='id')\n\n        channel = self._call_api(\n            'https://api.zdf.de/content/documents/%s.json' % channel_id,\n            player, url, channel_id)\n\n        items = []\n        for module in channel['module']:\n            for teaser in try_get(module, lambda x: x['teaser'], list) or []:\n                t = try_get(\n                    teaser, lambda x: x['http://zdf.de/rels/target'], dict)\n                if not t:\n                    continue\n                items.extend(try_get(\n                    t,\n                    lambda x: x['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                    list) or [])\n            items.extend(try_get(\n                module,\n                lambda x: x['filterRef']['resultsWithVideo']['http://zdf.de/rels/search/results'],\n                list) or [])\n\n        entries = []\n        entry_urls = set()\n        for item in items:\n            t = try_get(item, lambda x: x['http://zdf.de/rels/target'], dict)\n            if not t:\n                continue\n            sharing_url = t.get('http://zdf.de/rels/sharing-url')\n            if not sharing_url or not isinstance(sharing_url, compat_str):\n                continue\n            if sharing_url in entry_urls:\n                continue\n            entry_urls.add(sharing_url)\n            entries.append(self.url_result(\n                sharing_url, ie=ZDFIE.ie_key(), video_id=t.get('id')))\n\n        return self.playlist_result(entries, channel_id, channel.get('title'))\n        \"\"\"\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "zdf.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/zdf.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}