{"author": "ansible", "code": "\n# -*- coding: utf-8 -*-\n\n# (c) 2017, Ansible by Red Hat, inc\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'network'}\n\n\nDOCUMENTATION = \"\"\"\n---\nmodule: junos_user\nversion_added: \"2.3\"\nauthor: \"Peter Sprygada (@privateip)\"\nshort_description: Manage local user accounts on Juniper JUNOS devices\ndescription:\n  - This module manages locally configured user accounts on remote\n    network devices running the JUNOS operating system.  It provides\n    a set of arguments for creating, removing and updating locally\n    defined accounts\nextends_documentation_fragment: junos\noptions:\n  aggregate:\n    description:\n      - The C(aggregate) argument defines a list of users to be configured\n        on the remote device.  The list of users will be compared against\n        the current users and only changes will be added or removed from\n        the device configuration.  This argument is mutually exclusive with\n        the name argument.\n    version_added: \"2.4\"\n    aliases: ['users', 'collection']\n  name:\n    description:\n      - The C(name) argument defines the username of the user to be created\n        on the system.  This argument must follow appropriate usernaming\n        conventions for the target device running JUNOS.  This argument is\n        mutually exclusive with the C(aggregate) argument.\n  full_name:\n    description:\n      - The C(full_name) argument provides the full name of the user\n        account to be created on the remote device.  This argument accepts\n        any text string value.\n  role:\n    description:\n      - The C(role) argument defines the role of the user account on the\n        remote system.  User accounts can have more than one role\n        configured.\n    choices: ['operator', 'read-only', 'super-user', 'unauthorized']\n  sshkey:\n    description:\n      - The C(sshkey) argument defines the public SSH key to be configured\n        for the user account on the remote system.  This argument must\n        be a valid SSH key\n  purge:\n    description:\n      - The C(purge) argument instructs the module to consider the\n        users definition absolute.  It will remove any previously configured\n        users on the device with the exception of the current defined\n        set of aggregate.\n    type: bool\n    default: 'no'\n  state:\n    description:\n      - The C(state) argument configures the state of the user definitions\n        as it relates to the device operational configuration.  When set\n        to I(present), the user should be configured in the device active\n        configuration and when set to I(absent) the user should not be\n        in the device active configuration\n    default: present\n    choices: ['present', 'absent']\n  active:\n    description:\n      - Specifies whether or not the configuration is active or deactivated\n    type: bool\n    default: 'yes'\n    version_added: \"2.4\"\nrequirements:\n  - ncclient (>=v0.5.2)\nnotes:\n  - This module requires the netconf system service be enabled on\n    the remote device being managed.\n  - Tested against vSRX JUNOS version 15.1X49-D15.4, vqfx-10000 JUNOS Version 15.1X53-D60.4.\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: create new user account\n  junos_user:\n    name: ansible\n    role: super-user\n    sshkey: \"{{ lookup('file', '~/.ssh/ansible.pub') }}\"\n    state: present\n\n- name: remove a user account\n  junos_user:\n    name: ansible\n    state: absent\n\n- name: remove all user accounts except ansible\n  junos_user:\n    aggregate:\n    - name: ansible\n    purge: yes\n\n- name: Create list of users\n  junos_user:\n    aggregate:\n      - {name: test_user1, full_name: test_user2, role: operator, state: present}\n      - {name: test_user2, full_name: test_user2, role: read-only, state: present}\n\n- name: Delete list of users\n  junos_user:\n    aggregate:\n      - {name: test_user1, full_name: test_user2, role: operator, state: absent}\n      - {name: test_user2, full_name: test_user2, role: read-only, state: absent}\n\"\"\"\n\nRETURN = \"\"\"\ndiff.prepared:\n  description: Configuration difference before and after applying change.\n  returned: when configuration is changed and diff option is enabled.\n  type: string\n  sample: >\n          [edit system login]\n          +    user test-user {\n          +        uid 2005;\n          +        class read-only;\n          +    }\n\"\"\"\nfrom functools import partial\n\nfrom copy import deepcopy\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.network.common.utils import remove_default_spec\nfrom ansible.module_utils.network.junos.junos import junos_argument_spec, get_connection\nfrom ansible.module_utils.network.junos.junos import commit_configuration, discard_changes\nfrom ansible.module_utils.network.junos.junos import load_config, locked_config\nfrom ansible.module_utils.six import iteritems\n\ntry:\n    from lxml.etree import Element, SubElement, tostring\nexcept ImportError:\n    from xml.etree.ElementTree import Element, SubElement, tostring\n\nROLES = ['operator', 'read-only', 'super-user', 'unauthorized']\nUSE_PERSISTENT_CONNECTION = True\n\n\ndef handle_purge(module, want):\n    want_users = [item['name'] for item in want]\n    element = Element('system')\n    login = SubElement(element, 'login')\n\n    conn = get_connection(module)\n    reply = conn.execute_rpc(tostring(Element('get-configuration')), ignore_warning=False)\n    users = reply.xpath('configuration/system/login/user/name')\n    if users:\n        for item in users:\n            name = item.text\n            if name not in want_users and name != 'root':\n                user = SubElement(login, 'user', {'operation': 'delete'})\n                SubElement(user, 'name').text = name\n    if element.xpath('/system/login/user/name'):\n        return element\n\n\ndef map_obj_to_ele(module, want):\n    element = Element('system')\n    login = SubElement(element, 'login')\n\n    for item in want:\n        if item['state'] != 'present':\n            if item['name'] == 'root':\n                module.fail_json(msg=\"cannot delete the 'root' account.\")\n            operation = 'delete'\n        else:\n            operation = 'merge'\n\n        user = SubElement(login, 'user', {'operation': operation})\n\n        SubElement(user, 'name').text = item['name']\n\n        if operation == 'merge':\n            if item['active']:\n                user.set('active', 'active')\n            else:\n                user.set('inactive', 'inactive')\n\n            if item['role']:\n                SubElement(user, 'class').text = item['role']\n\n            if item.get('full_name'):\n                SubElement(user, 'full-name').text = item['full_name']\n\n            if item.get('sshkey'):\n                auth = SubElement(user, 'authentication')\n                ssh_rsa = SubElement(auth, 'ssh-rsa')\n                key = SubElement(ssh_rsa, 'name').text = item['sshkey']\n\n    return element\n\n\ndef get_param_value(key, item, module):\n    \n    if not item.get(key):\n        value = module.params[key]\n\n    \n    else:\n        value_type = module.argument_spec[key].get('type', 'str')\n        type_checker = module._CHECK_ARGUMENT_TYPES_DISPATCHER[value_type]\n        type_checker(item[key])\n        value = item[key]\n\n    # validate the param value (if validator func exists)\n    validator = globals().get('validate_%s' % key)\n    if all((value, validator)):\n        validator(value, module)\n\n    return value\n\n\ndef map_params_to_obj(module):\n    aggregate = module.params['aggregate']\n    if not aggregate:\n        if not module.params['name'] and module.params['purge']:\n            return list()\n        elif not module.params['name']:\n            module.fail_json(msg='missing required argument: name')\n        else:\n            collection = [{'name': module.params['name']}]\n    else:\n        collection = list()\n        for item in aggregate:\n            if not isinstance(item, dict):\n                collection.append({'username': item})\n            elif 'name' not in item:\n                module.fail_json(msg='missing required argument: name')\n            else:\n                collection.append(item)\n\n    objects = list()\n\n    for item in collection:\n        get_value = partial(get_param_value, item=item, module=module)\n        item.update({\n            'full_name': get_value('full_name'),\n            'role': get_value('role'),\n            'sshkey': get_value('sshkey'),\n            'state': get_value('state'),\n            'active': get_value('active')\n        })\n\n        for key, value in iteritems(item):\n            # validate the param value (if validator func exists)\n            validator = globals().get('validate_%s' % key)\n            if all((value, validator)):\n                validator(value, module)\n\n        objects.append(item)\n\n    return objects\n\n\ndef main():\n    \"\"\" main entry point for module execution\n    \"\"\"\n    element_spec = dict(\n        name=dict(),\n        full_name=dict(),\n        role=dict(choices=ROLES),\n        sshkey=dict(),\n        state=dict(choices=['present', 'absent'], default='present'),\n        active=dict(type='bool', default=True)\n    )\n\n    aggregate_spec = deepcopy(element_spec)\n    aggregate_spec['name'] = dict(required=True)\n\n    \n    remove_default_spec(aggregate_spec)\n\n    argument_spec = dict(\n        aggregate=dict(type='list', elements='dict', options=aggregate_spec, aliases=['collection', 'users']),\n        purge=dict(default=False, type='bool')\n    )\n\n    argument_spec.update(element_spec)\n    argument_spec.update(junos_argument_spec)\n\n    mutually_exclusive = [['aggregate', 'name']]\n\n    module = AnsibleModule(argument_spec=argument_spec,\n                           mutually_exclusive=mutually_exclusive,\n                           supports_check_mode=True)\n\n    warnings = list()\n    result = {'changed': False, 'warnings': warnings}\n\n    want = map_params_to_obj(module)\n    ele = map_obj_to_ele(module, want)\n\n    purge_request = None\n    if module.params['purge']:\n        purge_request = handle_purge(module, want)\n\n    with locked_config(module):\n        if purge_request:\n            load_config(module, tostring(purge_request), warnings, action='replace')\n        diff = load_config(module, tostring(ele), warnings, action='merge')\n\n        commit = not module.check_mode\n        if diff:\n            if commit:\n                commit_configuration(module)\n            else:\n                discard_changes(module)\n            result['changed'] = True\n\n            if module._diff:\n                result['diff'] = {'prepared': diff}\n\n    module.exit_json(**result)\n\nif __name__ == \"__main__\":\n    main()\n", "comments": "        module  junos user version added   2 3  author   peter sprygada ( privateip)  short description  manage local user accounts juniper junos devices description      this module manages locally configured user accounts remote     network devices running junos operating system   it provides     set arguments creating  removing updating locally     defined accounts extends documentation fragment  junos options    aggregate      description          the c(aggregate) argument defines list users configured         remote device   the list users compared         current users changes added removed         device configuration   this argument mutually exclusive         name argument      version added   2 4      aliases    users    collection     name      description          the c(name) argument defines username user created         system   this argument must follow appropriate usernaming         conventions target device running junos   this argument         mutually exclusive c(aggregate) argument    full name      description          the c(full name) argument provides full name user         account created remote device   this argument accepts         text string value    role      description          the c(role) argument defines role user account         remote system   user accounts one role         configured      choices    operator    read    super user    unauthorized     sshkey      description          the c(sshkey) argument defines public ssh key configured         user account remote system   this argument must         valid ssh key   purge      description          the c(purge) argument instructs module consider         users definition absolute   it remove previously configured         users device exception current defined         set aggregate      type  bool     default      state      description          the c(state) argument configures state user definitions         relates device operational configuration   when set         i(present)  user configured device active         configuration set i(absent) user         device active configuration     default  present     choices    present    absent     active      description          specifies whether configuration active deactivated     type  bool     default   yes      version added   2 4  requirements      ncclient (  v0 5 2) notes      this module requires netconf system service enabled     remote device managed      tested vsrx junos version 15 1x49 d15 4  vqfx 10000 junos version 15 1x53 d60 4       examples         name  create new user account   junos user      name  ansible     role  super user     sshkey      lookup( file       ssh ansible pub )         state  present    name  remove user account   junos user      name  ansible     state  absent    name  remove user accounts except ansible   junos user      aggregate        name  ansible     purge  yes    name  create list users   junos user      aggregate           name  test user1  full name  test user2  role  operator  state  present           name  test user2  full name  test user2  role  read  state  present     name  delete list users   junos user      aggregate           name  test user1  full name  test user2  role  operator  state  absent           name  test user2  full name  test user2  role  read  state  absent       return       diff prepared    description  configuration difference applying change    returned  configuration changed diff option enabled    type  string   sample               edit system login                 user test user                      uid 2005                     class read                       functools import partial  copy import deepcopy  ansible module utils basic import ansiblemodule ansible module utils network common utils import remove default spec ansible module utils network junos junos import junos argument spec  get connection ansible module utils network junos junos import commit configuration  discard changes ansible module utils network junos junos import load config  locked config ansible module utils six import iteritems  try      lxml etree import element  subelement  tostring except importerror      xml etree elementtree import element  subelement  tostring  roles     operator    read    super user    unauthorized   use persistent connection   true   def handle purge(module  want)      want users    item  name   item want      element   element( system )     login   subelement(element   login )      conn   get connection(module)     reply   conn execute rpc(tostring(element( get configuration ))  ignore warning false)     users   reply xpath( configuration system login user name )     users          item users              name   item text             name want users name     root                   user   subelement(login   user     operation    delete  )                 subelement(user   name ) text   name     element xpath(  system login user name )          return element   def map obj ele(module  want)      element   element( system )     login   subelement(element   login )      item want          item  state       present               item  name       root                   module fail json(msg  cannot delete  root  account  )             operation    delete          else              operation    merge           user   subelement(login   user     operation   operation )          subelement(user   name ) text   item  name            operation     merge               item  active                    user set( active    active )             else                  user set( inactive    inactive )              item  role                    subelement(user   class ) text   item  role                item get( full name )                  subelement(user   full name ) text   item  full name                item get( sshkey )                  auth   subelement(user   authentication )                 ssh rsa   subelement(auth   ssh rsa )                 key   subelement(ssh rsa   name ) text   item  sshkey        return element   def get param value(key  item  module)        key exist item  get module params     item get(key)          value   module params key         key exist  type check validate     else          value type   module argument spec key  get( type    str )         type checker   module  check argument types dispatcher value type          type checker(item key )         value   item key         validate param value (if validator func exists)     validator   globals() get( validate     key)     all((value  validator))          validator(value  module)      return value   def map params obj(module)      aggregate   module params  aggregate       aggregate          module params  name   module params  purge                return list()         elif module params  name                module fail json(msg  missing required argument  name )         else              collection      name   module params  name         else          collection   list()         item aggregate              isinstance(item  dict)                  collection append(  username   item )             elif  name  item                  module fail json(msg  missing required argument  name )             else                  collection append(item)      objects   list()      item collection          get value   partial(get param value  item item  module module)         item update(               full name   get value( full name )               role   get value( role )               sshkey   get value( sshkey )               state   get value( state )               active   get value( active )          )          key  value iteritems(item)                validate param value (if validator func exists)             validator   globals() get( validate     key)             all((value  validator))                  validator(value  module)          objects append(item)      return objects   def main()          main entry point module execution             usr bin python        coding  utf 8        (c) 2017  ansible red hat  inc    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    key exist item  get module params    key exist  type check validate    validate param value (if validator func exists)    validate param value (if validator func exists)    remove default aggregate spec  handle common arguments ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# (c) 2017, Ansible by Red Hat, inc\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'network'}\n\n\nDOCUMENTATION = \"\"\"\n---\nmodule: junos_user\nversion_added: \"2.3\"\nauthor: \"Peter Sprygada (@privateip)\"\nshort_description: Manage local user accounts on Juniper JUNOS devices\ndescription:\n  - This module manages locally configured user accounts on remote\n    network devices running the JUNOS operating system.  It provides\n    a set of arguments for creating, removing and updating locally\n    defined accounts\nextends_documentation_fragment: junos\noptions:\n  aggregate:\n    description:\n      - The C(aggregate) argument defines a list of users to be configured\n        on the remote device.  The list of users will be compared against\n        the current users and only changes will be added or removed from\n        the device configuration.  This argument is mutually exclusive with\n        the name argument.\n    version_added: \"2.4\"\n    aliases: ['users', 'collection']\n  name:\n    description:\n      - The C(name) argument defines the username of the user to be created\n        on the system.  This argument must follow appropriate usernaming\n        conventions for the target device running JUNOS.  This argument is\n        mutually exclusive with the C(aggregate) argument.\n  full_name:\n    description:\n      - The C(full_name) argument provides the full name of the user\n        account to be created on the remote device.  This argument accepts\n        any text string value.\n  role:\n    description:\n      - The C(role) argument defines the role of the user account on the\n        remote system.  User accounts can have more than one role\n        configured.\n    choices: ['operator', 'read-only', 'super-user', 'unauthorized']\n  sshkey:\n    description:\n      - The C(sshkey) argument defines the public SSH key to be configured\n        for the user account on the remote system.  This argument must\n        be a valid SSH key\n  purge:\n    description:\n      - The C(purge) argument instructs the module to consider the\n        users definition absolute.  It will remove any previously configured\n        users on the device with the exception of the current defined\n        set of aggregate.\n    type: bool\n    default: 'no'\n  state:\n    description:\n      - The C(state) argument configures the state of the user definitions\n        as it relates to the device operational configuration.  When set\n        to I(present), the user should be configured in the device active\n        configuration and when set to I(absent) the user should not be\n        in the device active configuration\n    default: present\n    choices: ['present', 'absent']\n  active:\n    description:\n      - Specifies whether or not the configuration is active or deactivated\n    type: bool\n    default: 'yes'\n    version_added: \"2.4\"\nrequirements:\n  - ncclient (>=v0.5.2)\nnotes:\n  - This module requires the netconf system service be enabled on\n    the remote device being managed.\n  - Tested against vSRX JUNOS version 15.1X49-D15.4, vqfx-10000 JUNOS Version 15.1X53-D60.4.\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: create new user account\n  junos_user:\n    name: ansible\n    role: super-user\n    sshkey: \"{{ lookup('file', '~/.ssh/ansible.pub') }}\"\n    state: present\n\n- name: remove a user account\n  junos_user:\n    name: ansible\n    state: absent\n\n- name: remove all user accounts except ansible\n  junos_user:\n    aggregate:\n    - name: ansible\n    purge: yes\n\n- name: Create list of users\n  junos_user:\n    aggregate:\n      - {name: test_user1, full_name: test_user2, role: operator, state: present}\n      - {name: test_user2, full_name: test_user2, role: read-only, state: present}\n\n- name: Delete list of users\n  junos_user:\n    aggregate:\n      - {name: test_user1, full_name: test_user2, role: operator, state: absent}\n      - {name: test_user2, full_name: test_user2, role: read-only, state: absent}\n\"\"\"\n\nRETURN = \"\"\"\ndiff.prepared:\n  description: Configuration difference before and after applying change.\n  returned: when configuration is changed and diff option is enabled.\n  type: string\n  sample: >\n          [edit system login]\n          +    user test-user {\n          +        uid 2005;\n          +        class read-only;\n          +    }\n\"\"\"\nfrom functools import partial\n\nfrom copy import deepcopy\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.network.common.utils import remove_default_spec\nfrom ansible.module_utils.network.junos.junos import junos_argument_spec, get_connection\nfrom ansible.module_utils.network.junos.junos import commit_configuration, discard_changes\nfrom ansible.module_utils.network.junos.junos import load_config, locked_config\nfrom ansible.module_utils.six import iteritems\n\ntry:\n    from lxml.etree import Element, SubElement, tostring\nexcept ImportError:\n    from xml.etree.ElementTree import Element, SubElement, tostring\n\nROLES = ['operator', 'read-only', 'super-user', 'unauthorized']\nUSE_PERSISTENT_CONNECTION = True\n\n\ndef handle_purge(module, want):\n    want_users = [item['name'] for item in want]\n    element = Element('system')\n    login = SubElement(element, 'login')\n\n    conn = get_connection(module)\n    reply = conn.execute_rpc(tostring(Element('get-configuration')), ignore_warning=False)\n    users = reply.xpath('configuration/system/login/user/name')\n    if users:\n        for item in users:\n            name = item.text\n            if name not in want_users and name != 'root':\n                user = SubElement(login, 'user', {'operation': 'delete'})\n                SubElement(user, 'name').text = name\n    if element.xpath('/system/login/user/name'):\n        return element\n\n\ndef map_obj_to_ele(module, want):\n    element = Element('system')\n    login = SubElement(element, 'login')\n\n    for item in want:\n        if item['state'] != 'present':\n            if item['name'] == 'root':\n                module.fail_json(msg=\"cannot delete the 'root' account.\")\n            operation = 'delete'\n        else:\n            operation = 'merge'\n\n        user = SubElement(login, 'user', {'operation': operation})\n\n        SubElement(user, 'name').text = item['name']\n\n        if operation == 'merge':\n            if item['active']:\n                user.set('active', 'active')\n            else:\n                user.set('inactive', 'inactive')\n\n            if item['role']:\n                SubElement(user, 'class').text = item['role']\n\n            if item.get('full_name'):\n                SubElement(user, 'full-name').text = item['full_name']\n\n            if item.get('sshkey'):\n                auth = SubElement(user, 'authentication')\n                ssh_rsa = SubElement(auth, 'ssh-rsa')\n                key = SubElement(ssh_rsa, 'name').text = item['sshkey']\n\n    return element\n\n\ndef get_param_value(key, item, module):\n    # if key doesn't exist in the item, get it from module.params\n    if not item.get(key):\n        value = module.params[key]\n\n    # if key does exist, do a type check on it to validate it\n    else:\n        value_type = module.argument_spec[key].get('type', 'str')\n        type_checker = module._CHECK_ARGUMENT_TYPES_DISPATCHER[value_type]\n        type_checker(item[key])\n        value = item[key]\n\n    # validate the param value (if validator func exists)\n    validator = globals().get('validate_%s' % key)\n    if all((value, validator)):\n        validator(value, module)\n\n    return value\n\n\ndef map_params_to_obj(module):\n    aggregate = module.params['aggregate']\n    if not aggregate:\n        if not module.params['name'] and module.params['purge']:\n            return list()\n        elif not module.params['name']:\n            module.fail_json(msg='missing required argument: name')\n        else:\n            collection = [{'name': module.params['name']}]\n    else:\n        collection = list()\n        for item in aggregate:\n            if not isinstance(item, dict):\n                collection.append({'username': item})\n            elif 'name' not in item:\n                module.fail_json(msg='missing required argument: name')\n            else:\n                collection.append(item)\n\n    objects = list()\n\n    for item in collection:\n        get_value = partial(get_param_value, item=item, module=module)\n        item.update({\n            'full_name': get_value('full_name'),\n            'role': get_value('role'),\n            'sshkey': get_value('sshkey'),\n            'state': get_value('state'),\n            'active': get_value('active')\n        })\n\n        for key, value in iteritems(item):\n            # validate the param value (if validator func exists)\n            validator = globals().get('validate_%s' % key)\n            if all((value, validator)):\n                validator(value, module)\n\n        objects.append(item)\n\n    return objects\n\n\ndef main():\n    \"\"\" main entry point for module execution\n    \"\"\"\n    element_spec = dict(\n        name=dict(),\n        full_name=dict(),\n        role=dict(choices=ROLES),\n        sshkey=dict(),\n        state=dict(choices=['present', 'absent'], default='present'),\n        active=dict(type='bool', default=True)\n    )\n\n    aggregate_spec = deepcopy(element_spec)\n    aggregate_spec['name'] = dict(required=True)\n\n    # remove default in aggregate spec, to handle common arguments\n    remove_default_spec(aggregate_spec)\n\n    argument_spec = dict(\n        aggregate=dict(type='list', elements='dict', options=aggregate_spec, aliases=['collection', 'users']),\n        purge=dict(default=False, type='bool')\n    )\n\n    argument_spec.update(element_spec)\n    argument_spec.update(junos_argument_spec)\n\n    mutually_exclusive = [['aggregate', 'name']]\n\n    module = AnsibleModule(argument_spec=argument_spec,\n                           mutually_exclusive=mutually_exclusive,\n                           supports_check_mode=True)\n\n    warnings = list()\n    result = {'changed': False, 'warnings': warnings}\n\n    want = map_params_to_obj(module)\n    ele = map_obj_to_ele(module, want)\n\n    purge_request = None\n    if module.params['purge']:\n        purge_request = handle_purge(module, want)\n\n    with locked_config(module):\n        if purge_request:\n            load_config(module, tostring(purge_request), warnings, action='replace')\n        diff = load_config(module, tostring(ele), warnings, action='merge')\n\n        commit = not module.check_mode\n        if diff:\n            if commit:\n                commit_configuration(module)\n            else:\n                discard_changes(module)\n            result['changed'] = True\n\n            if module._diff:\n                result['diff'] = {'prepared': diff}\n\n    module.exit_json(**result)\n\nif __name__ == \"__main__\":\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "junos_user.py", "id": "296a32ccb77c814c43a7b2638e5ddfdb", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/network/junos/junos_user.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}