{"author": "ansible", "code": "\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: rax_scaling_group\nshort_description: Manipulate Rackspace Cloud Autoscale Groups\ndescription:\n    - Manipulate Rackspace Cloud Autoscale Groups\nversion_added: 1.7\noptions:\n  config_drive:\n    description:\n      - Attach read-only configuration drive to server as label config-2\n    type: bool\n    default: 'no'\n    version_added: 1.8\n  cooldown:\n    description:\n      - The period of time, in seconds, that must pass before any scaling can\n        occur after the previous scaling. Must be an integer between 0 and\n        86400 (24 hrs).\n  disk_config:\n    description:\n      - Disk partitioning strategy\n    choices:\n      - auto\n      - manual\n    default: auto\n  files:\n    description:\n      - 'Files to insert into the instance. Hash of C(remotepath: localpath)'\n  flavor:\n    description:\n      - flavor to use for the instance\n    required: true\n  image:\n    description:\n      - image to use for the instance. Can be an C(id), C(human_id) or C(name)\n    required: true\n  key_name:\n    description:\n      - key pair to use on the instance\n  loadbalancers:\n    description:\n      - List of load balancer C(id) and C(port) hashes\n  max_entities:\n    description:\n      - The maximum number of entities that are allowed in the scaling group.\n        Must be an integer between 0 and 1000.\n    required: true\n  meta:\n    description:\n      - A hash of metadata to associate with the instance\n  min_entities:\n    description:\n      - The minimum number of entities that are allowed in the scaling group.\n        Must be an integer between 0 and 1000.\n    required: true\n  name:\n    description:\n      - Name to give the scaling group\n    required: true\n  networks:\n    description:\n      - The network to attach to the instances. If specified, you must include\n        ALL networks including the public and private interfaces. Can be C(id)\n        or C(label).\n    default:\n      - public\n      - private\n  server_name:\n    description:\n      - The base name for servers created by Autoscale\n    required: true\n  state:\n    description:\n      - Indicate desired state of the resource\n    choices:\n      - present\n      - absent\n    default: present\n  user_data:\n    description:\n      - Data to be uploaded to the servers config drive. This option implies\n        I(config_drive). Can be a file path or a string\n    version_added: 1.8\n  wait:\n    description:\n      - wait for the scaling group to finish provisioning the minimum amount of\n        servers\n    type: bool\n    default: 'no'\n  wait_timeout:\n    description:\n      - how long before wait gives up, in seconds\n    default: 300\nauthor: \"Matt Martz (@sivel)\"\nextends_documentation_fragment:\n  - rackspace\n  - rackspace.openstack\n'''\n\nEXAMPLES = '''\n---\n- hosts: localhost\n  gather_facts: false\n  connection: local\n  tasks:\n    - rax_scaling_group:\n        credentials: ~/.raxpub\n        region: ORD\n        cooldown: 300\n        flavor: performance1-1\n        image: bb02b1a3-bc77-4d17-ab5b-421d89850fca\n        min_entities: 5\n        max_entities: 10\n        name: ASG Test\n        server_name: asgtest\n        loadbalancers:\n            - id: 228385\n              port: 80\n      register: asg\n'''\n\nimport base64\nimport json\nimport os\nimport time\n\ntry:\n    import pyrax\n    HAS_PYRAX = True\nexcept ImportError:\n    HAS_PYRAX = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.rax import (rax_argument_spec, rax_find_image, rax_find_network,\n                                      rax_required_together, rax_to_dict, setup_rax_module)\nfrom ansible.module_utils.six import string_types\n\n\ndef rax_asg(module, cooldown=300, disk_config=None, files=None, flavor=None,\n            image=None, key_name=None, loadbalancers=None, meta=None,\n            min_entities=0, max_entities=0, name=None, networks=None,\n            server_name=None, state='present', user_data=None,\n            config_drive=False, wait=True, wait_timeout=300):\n    files = {} if files is None else files\n    loadbalancers = [] if loadbalancers is None else loadbalancers\n    meta = {} if meta is None else meta\n    networks = [] if networks is None else networks\n\n    changed = False\n\n    au = pyrax.autoscale\n    if not au:\n        module.fail_json(msg='Failed to instantiate clients. This '\n                             'typically indicates an invalid region or an '\n                             'incorrectly capitalized region name.')\n\n    if user_data:\n        config_drive = True\n\n    if user_data and os.path.isfile(user_data):\n        try:\n            f = open(user_data)\n            user_data = f.read()\n            f.close()\n        except Exception as e:\n            module.fail_json(msg='Failed to load %s' % user_data)\n\n    if state == 'present':\n        \n        if meta:\n            for k, v in meta.items():\n                if isinstance(v, list):\n                    meta[k] = ','.join(['%s' % i for i in v])\n                elif isinstance(v, dict):\n                    meta[k] = json.dumps(v)\n                elif not isinstance(v, string_types):\n                    meta[k] = '%s' % v\n\n        if image:\n            image = rax_find_image(module, pyrax, image)\n\n        nics = []\n        if networks:\n            for network in networks:\n                nics.extend(rax_find_network(module, pyrax, network))\n\n            for nic in nics:\n                \n                \n                \n                if nic.get('net-id'):\n                    nic.update(uuid=nic['net-id'])\n                    del nic['net-id']\n\n        \n        personality = []\n        if files:\n            for rpath in files.keys():\n                lpath = os.path.expanduser(files[rpath])\n                try:\n                    f = open(lpath, 'r')\n                    personality.append({\n                        'path': rpath,\n                        'contents': f.read()\n                    })\n                    f.close()\n                except Exception as e:\n                    module.fail_json(msg='Failed to load %s' % lpath)\n\n        lbs = []\n        if loadbalancers:\n            for lb in loadbalancers:\n                try:\n                    lb_id = int(lb.get('id'))\n                except (ValueError, TypeError):\n                    module.fail_json(msg='Load balancer ID is not an integer: '\n                                         '%s' % lb.get('id'))\n                try:\n                    port = int(lb.get('port'))\n                except (ValueError, TypeError):\n                    module.fail_json(msg='Load balancer port is not an '\n                                         'integer: %s' % lb.get('port'))\n                if not lb_id or not port:\n                    continue\n                lbs.append((lb_id, port))\n\n        try:\n            sg = au.find(name=name)\n        except pyrax.exceptions.NoUniqueMatch as e:\n            module.fail_json(msg='%s' % e.message)\n        except pyrax.exceptions.NotFound:\n            try:\n                sg = au.create(name, cooldown=cooldown,\n                               min_entities=min_entities,\n                               max_entities=max_entities,\n                               launch_config_type='launch_server',\n                               server_name=server_name, image=image,\n                               flavor=flavor, disk_config=disk_config,\n                               metadata=meta, personality=personality,\n                               networks=nics, load_balancers=lbs,\n                               key_name=key_name, config_drive=config_drive,\n                               user_data=user_data)\n                changed = True\n            except Exception as e:\n                module.fail_json(msg='%s' % e.message)\n\n        if not changed:\n            \n            group_args = {}\n            if cooldown != sg.cooldown:\n                group_args['cooldown'] = cooldown\n\n            if min_entities != sg.min_entities:\n                group_args['min_entities'] = min_entities\n\n            if max_entities != sg.max_entities:\n                group_args['max_entities'] = max_entities\n\n            if group_args:\n                changed = True\n                sg.update(**group_args)\n\n            \n            lc = sg.get_launch_config()\n            lc_args = {}\n            if server_name != lc.get('name'):\n                lc_args['server_name'] = server_name\n\n            if image != lc.get('image'):\n                lc_args['image'] = image\n\n            if flavor != lc.get('flavor'):\n                lc_args['flavor'] = flavor\n\n            disk_config = disk_config or 'AUTO'\n            if ((disk_config or lc.get('disk_config')) and\n                    disk_config != lc.get('disk_config', 'AUTO')):\n                lc_args['disk_config'] = disk_config\n\n            if (meta or lc.get('meta')) and meta != lc.get('metadata'):\n                lc_args['metadata'] = meta\n\n            test_personality = []\n            for p in personality:\n                test_personality.append({\n                    'path': p['path'],\n                    'contents': base64.b64encode(p['contents'])\n                })\n            if ((test_personality or lc.get('personality')) and\n                    test_personality != lc.get('personality')):\n                lc_args['personality'] = personality\n\n            if nics != lc.get('networks'):\n                lc_args['networks'] = nics\n\n            if lbs != lc.get('load_balancers'):\n                \n                lc_args['load_balancers'] = sg.manager._resolve_lbs(lbs)\n\n            if key_name != lc.get('key_name'):\n                lc_args['key_name'] = key_name\n\n            if config_drive != lc.get('config_drive', False):\n                lc_args['config_drive'] = config_drive\n\n            if (user_data and\n                    base64.b64encode(user_data) != lc.get('user_data')):\n                lc_args['user_data'] = user_data\n\n            if lc_args:\n                \n                if 'flavor' not in lc_args:\n                    lc_args['flavor'] = lc.get('flavor')\n                changed = True\n                sg.update_launch_config(**lc_args)\n\n            sg.get()\n\n        if wait:\n            end_time = time.time() + wait_timeout\n            infinite = wait_timeout == 0\n            while infinite or time.time() < end_time:\n                state = sg.get_state()\n                if state[\"pending_capacity\"] == 0:\n                    break\n\n                time.sleep(5)\n\n        module.exit_json(changed=changed, autoscale_group=rax_to_dict(sg))\n\n    else:\n        try:\n            sg = au.find(name=name)\n            sg.delete()\n            changed = True\n        except pyrax.exceptions.NotFound as e:\n            sg = {}\n        except Exception as e:\n            module.fail_json(msg='%s' % e.message)\n\n        module.exit_json(changed=changed, autoscale_group=rax_to_dict(sg))\n\n\ndef main():\n    argument_spec = rax_argument_spec()\n    argument_spec.update(\n        dict(\n            config_drive=dict(default=False, type='bool'),\n            cooldown=dict(type='int', default=300),\n            disk_config=dict(choices=['auto', 'manual']),\n            files=dict(type='dict', default={}),\n            flavor=dict(required=True),\n            image=dict(required=True),\n            key_name=dict(),\n            loadbalancers=dict(type='list'),\n            meta=dict(type='dict', default={}),\n            min_entities=dict(type='int', required=True),\n            max_entities=dict(type='int', required=True),\n            name=dict(required=True),\n            networks=dict(type='list', default=['public', 'private']),\n            server_name=dict(required=True),\n            state=dict(default='present', choices=['present', 'absent']),\n            user_data=dict(no_log=True),\n            wait=dict(default=False, type='bool'),\n            wait_timeout=dict(default=300),\n        )\n    )\n\n    module = AnsibleModule(\n        argument_spec=argument_spec,\n        required_together=rax_required_together(),\n    )\n\n    if not HAS_PYRAX:\n        module.fail_json(msg='pyrax is required for this module')\n\n    config_drive = module.params.get('config_drive')\n    cooldown = module.params.get('cooldown')\n    disk_config = module.params.get('disk_config')\n    if disk_config:\n        disk_config = disk_config.upper()\n    files = module.params.get('files')\n    flavor = module.params.get('flavor')\n    image = module.params.get('image')\n    key_name = module.params.get('key_name')\n    loadbalancers = module.params.get('loadbalancers')\n    meta = module.params.get('meta')\n    min_entities = module.params.get('min_entities')\n    max_entities = module.params.get('max_entities')\n    name = module.params.get('name')\n    networks = module.params.get('networks')\n    server_name = module.params.get('server_name')\n    state = module.params.get('state')\n    user_data = module.params.get('user_data')\n\n    if not 0 <= min_entities <= 1000 or not 0 <= max_entities <= 1000:\n        module.fail_json(msg='min_entities and max_entities must be an '\n                             'integer between 0 and 1000')\n\n    if not 0 <= cooldown <= 86400:\n        module.fail_json(msg='cooldown must be an integer between 0 and 86400')\n\n    setup_rax_module(module, pyrax)\n\n    rax_asg(module, cooldown=cooldown, disk_config=disk_config,\n            files=files, flavor=flavor, image=image, meta=meta,\n            key_name=key_name, loadbalancers=loadbalancers,\n            min_entities=min_entities, max_entities=max_entities,\n            name=name, networks=networks, server_name=server_name,\n            state=state, config_drive=config_drive, user_data=user_data)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  rax scaling group short description  manipulate rackspace cloud autoscale groups description        manipulate rackspace cloud autoscale groups version added  1 7 options    config drive      description          attach read configuration drive server label config 2     type  bool     default        version added  1 8   cooldown      description          the period time  seconds  must pass scaling         occur previous scaling  must integer 0         86400 (24 hrs)    disk config      description          disk partitioning strategy     choices          auto         manual     default  auto   files      description           files insert instance  hash c(remotepath  localpath)    flavor      description          flavor use instance     required  true   image      description          image use instance  can c(id)  c(human id) c(name)     required  true   key name      description          key pair use instance   loadbalancers      description          list load balancer c(id) c(port) hashes   max entities      description          the maximum number entities allowed scaling group          must integer 0 1000      required  true   meta      description          a hash metadata associate instance   min entities      description          the minimum number entities allowed scaling group          must integer 0 1000      required  true   name      description          name give scaling group     required  true   networks      description          the network attach instances  if specified  must include         all networks including public private interfaces  can c(id)         c(label)      default          public         private   server name      description          the base name servers created autoscale     required  true   state      description          indicate desired state resource     choices          present         absent     default  present   user data      description          data uploaded servers config drive  this option implies         i(config drive)  can file path string     version added  1 8   wait      description          wait scaling group finish provisioning minimum amount         servers     type  bool     default      wait timeout      description          long wait gives  seconds     default  300 author   matt martz ( sivel)  extends documentation fragment      rackspace     rackspace openstack      examples             hosts  localhost   gather facts  false   connection  local   tasks        rax scaling group          credentials     raxpub         region  ord         cooldown  300         flavor  performance1 1         image  bb02b1a3 bc77 4d17 ab5b 421d89850fca         min entities  5         max entities  10         name  asg test         server name  asgtest         loadbalancers                id  228385               port  80       register  asg         usr bin python    copyright  ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    normalize ensure metadata values strings    pyrax currently returning net id  need uuid    check makes forward compatible time    pyrax uses uuid instead    handle file contents    scaling group updates    launch configuration updates    work around https   github com rackspace pyrax pull 393    work around https   github com rackspace pyrax pull 389 ", "content": "#!/usr/bin/python\n# Copyright: Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: rax_scaling_group\nshort_description: Manipulate Rackspace Cloud Autoscale Groups\ndescription:\n    - Manipulate Rackspace Cloud Autoscale Groups\nversion_added: 1.7\noptions:\n  config_drive:\n    description:\n      - Attach read-only configuration drive to server as label config-2\n    type: bool\n    default: 'no'\n    version_added: 1.8\n  cooldown:\n    description:\n      - The period of time, in seconds, that must pass before any scaling can\n        occur after the previous scaling. Must be an integer between 0 and\n        86400 (24 hrs).\n  disk_config:\n    description:\n      - Disk partitioning strategy\n    choices:\n      - auto\n      - manual\n    default: auto\n  files:\n    description:\n      - 'Files to insert into the instance. Hash of C(remotepath: localpath)'\n  flavor:\n    description:\n      - flavor to use for the instance\n    required: true\n  image:\n    description:\n      - image to use for the instance. Can be an C(id), C(human_id) or C(name)\n    required: true\n  key_name:\n    description:\n      - key pair to use on the instance\n  loadbalancers:\n    description:\n      - List of load balancer C(id) and C(port) hashes\n  max_entities:\n    description:\n      - The maximum number of entities that are allowed in the scaling group.\n        Must be an integer between 0 and 1000.\n    required: true\n  meta:\n    description:\n      - A hash of metadata to associate with the instance\n  min_entities:\n    description:\n      - The minimum number of entities that are allowed in the scaling group.\n        Must be an integer between 0 and 1000.\n    required: true\n  name:\n    description:\n      - Name to give the scaling group\n    required: true\n  networks:\n    description:\n      - The network to attach to the instances. If specified, you must include\n        ALL networks including the public and private interfaces. Can be C(id)\n        or C(label).\n    default:\n      - public\n      - private\n  server_name:\n    description:\n      - The base name for servers created by Autoscale\n    required: true\n  state:\n    description:\n      - Indicate desired state of the resource\n    choices:\n      - present\n      - absent\n    default: present\n  user_data:\n    description:\n      - Data to be uploaded to the servers config drive. This option implies\n        I(config_drive). Can be a file path or a string\n    version_added: 1.8\n  wait:\n    description:\n      - wait for the scaling group to finish provisioning the minimum amount of\n        servers\n    type: bool\n    default: 'no'\n  wait_timeout:\n    description:\n      - how long before wait gives up, in seconds\n    default: 300\nauthor: \"Matt Martz (@sivel)\"\nextends_documentation_fragment:\n  - rackspace\n  - rackspace.openstack\n'''\n\nEXAMPLES = '''\n---\n- hosts: localhost\n  gather_facts: false\n  connection: local\n  tasks:\n    - rax_scaling_group:\n        credentials: ~/.raxpub\n        region: ORD\n        cooldown: 300\n        flavor: performance1-1\n        image: bb02b1a3-bc77-4d17-ab5b-421d89850fca\n        min_entities: 5\n        max_entities: 10\n        name: ASG Test\n        server_name: asgtest\n        loadbalancers:\n            - id: 228385\n              port: 80\n      register: asg\n'''\n\nimport base64\nimport json\nimport os\nimport time\n\ntry:\n    import pyrax\n    HAS_PYRAX = True\nexcept ImportError:\n    HAS_PYRAX = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.rax import (rax_argument_spec, rax_find_image, rax_find_network,\n                                      rax_required_together, rax_to_dict, setup_rax_module)\nfrom ansible.module_utils.six import string_types\n\n\ndef rax_asg(module, cooldown=300, disk_config=None, files=None, flavor=None,\n            image=None, key_name=None, loadbalancers=None, meta=None,\n            min_entities=0, max_entities=0, name=None, networks=None,\n            server_name=None, state='present', user_data=None,\n            config_drive=False, wait=True, wait_timeout=300):\n    files = {} if files is None else files\n    loadbalancers = [] if loadbalancers is None else loadbalancers\n    meta = {} if meta is None else meta\n    networks = [] if networks is None else networks\n\n    changed = False\n\n    au = pyrax.autoscale\n    if not au:\n        module.fail_json(msg='Failed to instantiate clients. This '\n                             'typically indicates an invalid region or an '\n                             'incorrectly capitalized region name.')\n\n    if user_data:\n        config_drive = True\n\n    if user_data and os.path.isfile(user_data):\n        try:\n            f = open(user_data)\n            user_data = f.read()\n            f.close()\n        except Exception as e:\n            module.fail_json(msg='Failed to load %s' % user_data)\n\n    if state == 'present':\n        # Normalize and ensure all metadata values are strings\n        if meta:\n            for k, v in meta.items():\n                if isinstance(v, list):\n                    meta[k] = ','.join(['%s' % i for i in v])\n                elif isinstance(v, dict):\n                    meta[k] = json.dumps(v)\n                elif not isinstance(v, string_types):\n                    meta[k] = '%s' % v\n\n        if image:\n            image = rax_find_image(module, pyrax, image)\n\n        nics = []\n        if networks:\n            for network in networks:\n                nics.extend(rax_find_network(module, pyrax, network))\n\n            for nic in nics:\n                # pyrax is currently returning net-id, but we need uuid\n                # this check makes this forward compatible for a time when\n                # pyrax uses uuid instead\n                if nic.get('net-id'):\n                    nic.update(uuid=nic['net-id'])\n                    del nic['net-id']\n\n        # Handle the file contents\n        personality = []\n        if files:\n            for rpath in files.keys():\n                lpath = os.path.expanduser(files[rpath])\n                try:\n                    f = open(lpath, 'r')\n                    personality.append({\n                        'path': rpath,\n                        'contents': f.read()\n                    })\n                    f.close()\n                except Exception as e:\n                    module.fail_json(msg='Failed to load %s' % lpath)\n\n        lbs = []\n        if loadbalancers:\n            for lb in loadbalancers:\n                try:\n                    lb_id = int(lb.get('id'))\n                except (ValueError, TypeError):\n                    module.fail_json(msg='Load balancer ID is not an integer: '\n                                         '%s' % lb.get('id'))\n                try:\n                    port = int(lb.get('port'))\n                except (ValueError, TypeError):\n                    module.fail_json(msg='Load balancer port is not an '\n                                         'integer: %s' % lb.get('port'))\n                if not lb_id or not port:\n                    continue\n                lbs.append((lb_id, port))\n\n        try:\n            sg = au.find(name=name)\n        except pyrax.exceptions.NoUniqueMatch as e:\n            module.fail_json(msg='%s' % e.message)\n        except pyrax.exceptions.NotFound:\n            try:\n                sg = au.create(name, cooldown=cooldown,\n                               min_entities=min_entities,\n                               max_entities=max_entities,\n                               launch_config_type='launch_server',\n                               server_name=server_name, image=image,\n                               flavor=flavor, disk_config=disk_config,\n                               metadata=meta, personality=personality,\n                               networks=nics, load_balancers=lbs,\n                               key_name=key_name, config_drive=config_drive,\n                               user_data=user_data)\n                changed = True\n            except Exception as e:\n                module.fail_json(msg='%s' % e.message)\n\n        if not changed:\n            # Scaling Group Updates\n            group_args = {}\n            if cooldown != sg.cooldown:\n                group_args['cooldown'] = cooldown\n\n            if min_entities != sg.min_entities:\n                group_args['min_entities'] = min_entities\n\n            if max_entities != sg.max_entities:\n                group_args['max_entities'] = max_entities\n\n            if group_args:\n                changed = True\n                sg.update(**group_args)\n\n            # Launch Configuration Updates\n            lc = sg.get_launch_config()\n            lc_args = {}\n            if server_name != lc.get('name'):\n                lc_args['server_name'] = server_name\n\n            if image != lc.get('image'):\n                lc_args['image'] = image\n\n            if flavor != lc.get('flavor'):\n                lc_args['flavor'] = flavor\n\n            disk_config = disk_config or 'AUTO'\n            if ((disk_config or lc.get('disk_config')) and\n                    disk_config != lc.get('disk_config', 'AUTO')):\n                lc_args['disk_config'] = disk_config\n\n            if (meta or lc.get('meta')) and meta != lc.get('metadata'):\n                lc_args['metadata'] = meta\n\n            test_personality = []\n            for p in personality:\n                test_personality.append({\n                    'path': p['path'],\n                    'contents': base64.b64encode(p['contents'])\n                })\n            if ((test_personality or lc.get('personality')) and\n                    test_personality != lc.get('personality')):\n                lc_args['personality'] = personality\n\n            if nics != lc.get('networks'):\n                lc_args['networks'] = nics\n\n            if lbs != lc.get('load_balancers'):\n                # Work around for https://github.com/rackspace/pyrax/pull/393\n                lc_args['load_balancers'] = sg.manager._resolve_lbs(lbs)\n\n            if key_name != lc.get('key_name'):\n                lc_args['key_name'] = key_name\n\n            if config_drive != lc.get('config_drive', False):\n                lc_args['config_drive'] = config_drive\n\n            if (user_data and\n                    base64.b64encode(user_data) != lc.get('user_data')):\n                lc_args['user_data'] = user_data\n\n            if lc_args:\n                # Work around for https://github.com/rackspace/pyrax/pull/389\n                if 'flavor' not in lc_args:\n                    lc_args['flavor'] = lc.get('flavor')\n                changed = True\n                sg.update_launch_config(**lc_args)\n\n            sg.get()\n\n        if wait:\n            end_time = time.time() + wait_timeout\n            infinite = wait_timeout == 0\n            while infinite or time.time() < end_time:\n                state = sg.get_state()\n                if state[\"pending_capacity\"] == 0:\n                    break\n\n                time.sleep(5)\n\n        module.exit_json(changed=changed, autoscale_group=rax_to_dict(sg))\n\n    else:\n        try:\n            sg = au.find(name=name)\n            sg.delete()\n            changed = True\n        except pyrax.exceptions.NotFound as e:\n            sg = {}\n        except Exception as e:\n            module.fail_json(msg='%s' % e.message)\n\n        module.exit_json(changed=changed, autoscale_group=rax_to_dict(sg))\n\n\ndef main():\n    argument_spec = rax_argument_spec()\n    argument_spec.update(\n        dict(\n            config_drive=dict(default=False, type='bool'),\n            cooldown=dict(type='int', default=300),\n            disk_config=dict(choices=['auto', 'manual']),\n            files=dict(type='dict', default={}),\n            flavor=dict(required=True),\n            image=dict(required=True),\n            key_name=dict(),\n            loadbalancers=dict(type='list'),\n            meta=dict(type='dict', default={}),\n            min_entities=dict(type='int', required=True),\n            max_entities=dict(type='int', required=True),\n            name=dict(required=True),\n            networks=dict(type='list', default=['public', 'private']),\n            server_name=dict(required=True),\n            state=dict(default='present', choices=['present', 'absent']),\n            user_data=dict(no_log=True),\n            wait=dict(default=False, type='bool'),\n            wait_timeout=dict(default=300),\n        )\n    )\n\n    module = AnsibleModule(\n        argument_spec=argument_spec,\n        required_together=rax_required_together(),\n    )\n\n    if not HAS_PYRAX:\n        module.fail_json(msg='pyrax is required for this module')\n\n    config_drive = module.params.get('config_drive')\n    cooldown = module.params.get('cooldown')\n    disk_config = module.params.get('disk_config')\n    if disk_config:\n        disk_config = disk_config.upper()\n    files = module.params.get('files')\n    flavor = module.params.get('flavor')\n    image = module.params.get('image')\n    key_name = module.params.get('key_name')\n    loadbalancers = module.params.get('loadbalancers')\n    meta = module.params.get('meta')\n    min_entities = module.params.get('min_entities')\n    max_entities = module.params.get('max_entities')\n    name = module.params.get('name')\n    networks = module.params.get('networks')\n    server_name = module.params.get('server_name')\n    state = module.params.get('state')\n    user_data = module.params.get('user_data')\n\n    if not 0 <= min_entities <= 1000 or not 0 <= max_entities <= 1000:\n        module.fail_json(msg='min_entities and max_entities must be an '\n                             'integer between 0 and 1000')\n\n    if not 0 <= cooldown <= 86400:\n        module.fail_json(msg='cooldown must be an integer between 0 and 86400')\n\n    setup_rax_module(module, pyrax)\n\n    rax_asg(module, cooldown=cooldown, disk_config=disk_config,\n            files=files, flavor=flavor, image=image, meta=meta,\n            key_name=key_name, loadbalancers=loadbalancers,\n            min_entities=min_entities, max_entities=max_entities,\n            name=name, networks=networks, server_name=server_name,\n            state=state, config_drive=config_drive, user_data=user_data)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "rax_scaling_group.py", "id": "8621d13f87329ec82f945f3a7432369a", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/cloud/rackspace/rax_scaling_group.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}