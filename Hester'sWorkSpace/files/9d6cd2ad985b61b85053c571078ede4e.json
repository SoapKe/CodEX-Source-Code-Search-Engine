{"author": "facebook", "code": " Copyright (c) 2017-present, Facebook, Inc.\n\n\n This source code is licensed under the BSD-style license found in the\n LICENSE file in the root directory of this source tree. An additional grant\n of patent rights can be found in the PATENTS file in the same directory.\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nimport itertools\nimport numpy as np\nimport pandas as pd\n\n fb-block 1 start\nimport os\nfrom unittest import TestCase\nfrom fbprophet import Prophet\n\nDATA = pd.read_csv(\n    os.path.join(os.path.dirname(__file__), 'data.csv'),\n    parse_dates=['ds'],\n)\nDATA2 = pd.read_csv(\n    os.path.join(os.path.dirname(__file__), 'data2.csv'),\n    parse_dates=['ds'],\n)\n fb-block 1 end\n fb-block 2\n\n\nclass TestProphet(TestCase):\n\n    def test_fit_predict(self):\n        N = DATA.shape[0]\n        train = DATA.head(N // 2)\n        future = DATA.tail(N // 2)\n\n        forecaster = Prophet()\n        forecaster.fit(train)\n        forecaster.predict(future)\n\n    def test_fit_predict_no_seasons(self):\n        N = DATA.shape[0]\n        train = DATA.head(N // 2)\n        future = DATA.tail(N // 2)\n\n        forecaster = Prophet(weekly_seasonality=False, yearly_seasonality=False)\n        forecaster.fit(train)\n        forecaster.predict(future)\n\n    def test_fit_predict_no_changepoints(self):\n        N = DATA.shape[0]\n        train = DATA.head(N // 2)\n        future = DATA.tail(N // 2)\n\n        forecaster = Prophet(n_changepoints=0)\n        forecaster.fit(train)\n        forecaster.predict(future)\n\n    def test_fit_changepoint_not_in_history(self):\n        train = DATA[(DATA['ds'] < '2013-01-01') | (DATA['ds'] > '2014-01-01')]\n        future = pd.DataFrame({'ds': DATA['ds']})\n        forecaster = Prophet(changepoints=['2013-06-06'])\n        forecaster.fit(train)\n        forecaster.predict(future)\n\n    def test_fit_predict_duplicates(self):\n        N = DATA.shape[0]\n        train1 = DATA.head(N // 2).copy()\n        train2 = DATA.head(N // 2).copy()\n        train2['y'] += 10\n        train = train1.append(train2)\n        future = pd.DataFrame({'ds': DATA['ds'].tail(N // 2)})\n        forecaster = Prophet()\n        forecaster.fit(train)\n        forecaster.predict(future)\n\n    def test_fit_predict_constant_history(self):\n        N = DATA.shape[0]\n        train = DATA.head(N // 2).copy()\n        train['y'] = 20\n        future = pd.DataFrame({'ds': DATA['ds'].tail(N // 2)})\n        m = Prophet()\n        m.fit(train)\n        fcst = m.predict(future)\n        self.assertEqual(fcst['yhat'].values[-1], 20)\n        train['y'] = 0\n        future = pd.DataFrame({'ds': DATA['ds'].tail(N // 2)})\n        m = Prophet()\n        m.fit(train)\n        fcst = m.predict(future)\n        self.assertEqual(fcst['yhat'].values[-1], 0)\n\n    def test_setup_dataframe(self):\n        m = Prophet()\n        N = DATA.shape[0]\n        history = DATA.head(N // 2).copy()\n\n        history = m.setup_dataframe(history, initialize_scales=True)\n\n        self.assertTrue('t' in history)\n        self.assertEqual(history['t'].min(), 0.0)\n        self.assertEqual(history['t'].max(), 1.0)\n\n        self.assertTrue('y_scaled' in history)\n        self.assertEqual(history['y_scaled'].max(), 1.0)\n\n    def test_logistic_floor(self):\n        m = Prophet(growth='logistic')\n        N = DATA.shape[0]\n        history = DATA.head(N // 2).copy()\n        history['floor'] = 10.\n        history['cap'] = 80.\n        future = DATA.tail(N // 2).copy()\n        future['cap'] = 80.\n        future['floor'] = 10.\n        m.fit(history, algorithm='Newton')\n        self.assertTrue(m.logistic_floor)\n        self.assertTrue('floor' in m.history)\n        self.assertAlmostEqual(m.history['y_scaled'][0], 1.)\n        fcst1 = m.predict(future)\n\n        m2 = Prophet(growth='logistic')\n        history2 = history.copy()\n        history2['y'] += 10.\n        history2['floor'] += 10.\n        history2['cap'] += 10.\n        future['cap'] += 10.\n        future['floor'] += 10.\n        m2.fit(history2, algorithm='Newton')\n        self.assertAlmostEqual(m2.history['y_scaled'][0], 1.)\n        fcst2 = m2.predict(future)\n        fcst2['yhat'] -= 10.\n         Check for approximate shift invariance\n        self.assertTrue((np.abs(fcst1['yhat'] - fcst2['yhat']) < 1).all())\n\n    def test_get_changepoints(self):\n        m = Prophet()\n        N = DATA.shape[0]\n        history = DATA.head(N // 2).copy()\n\n        history = m.setup_dataframe(history, initialize_scales=True)\n        m.history = history\n\n        m.set_changepoints()\n\n        cp = m.changepoints_t\n        self.assertEqual(cp.shape[0], m.n_changepoints)\n        self.assertEqual(len(cp.shape), 1)\n        self.assertTrue(cp.min() > 0)\n        self.assertTrue(cp.max() < N)\n\n        mat = m.get_changepoint_matrix()\n        self.assertEqual(mat.shape[0], N // 2)\n        self.assertEqual(mat.shape[1], m.n_changepoints)\n\n    def test_get_zero_changepoints(self):\n        m = Prophet(n_changepoints=0)\n        N = DATA.shape[0]\n        history = DATA.head(N // 2).copy()\n\n        history = m.setup_dataframe(history, initialize_scales=True)\n        m.history = history\n\n        m.set_changepoints()\n        cp = m.changepoints_t\n        self.assertEqual(cp.shape[0], 1)\n        self.assertEqual(cp[0], 0)\n\n        mat = m.get_changepoint_matrix()\n        self.assertEqual(mat.shape[0], N // 2)\n        self.assertEqual(mat.shape[1], 1)\n\n    def test_override_n_changepoints(self):\n        m = Prophet()\n        history = DATA.head(20).copy()\n\n        history = m.setup_dataframe(history, initialize_scales=True)\n        m.history = history\n\n        m.set_changepoints()\n        self.assertEqual(m.n_changepoints, 15)\n        cp = m.changepoints_t\n        self.assertEqual(cp.shape[0], 15)\n\n    def test_fourier_series_weekly(self):\n        mat = Prophet.fourier_series(DATA['ds'], 7, 3)\n         These are from the R forecast package directly.\n        true_values = np.array([\n            0.7818315, 0.6234898, 0.9749279, -0.2225209, 0.4338837, -0.9009689,\n        ])\n        self.assertAlmostEqual(np.sum((mat[0] - true_values)**2), 0.0)\n\n    def test_fourier_series_yearly(self):\n        mat = Prophet.fourier_series(DATA['ds'], 365.25, 3)\n         These are from the R forecast package directly.\n        true_values = np.array([\n            0.7006152, -0.7135393, -0.9998330, 0.01827656, 0.7262249, 0.6874572,\n        ])\n        self.assertAlmostEqual(np.sum((mat[0] - true_values)**2), 0.0)\n\n    def test_growth_init(self):\n        model = Prophet(growth='logistic')\n        history = DATA.iloc[:468].copy()\n        history['cap'] = history['y'].max()\n\n        history = model.setup_dataframe(history, initialize_scales=True)\n\n        k, m = model.linear_growth_init(history)\n        self.assertAlmostEqual(k, 0.3055671)\n        self.assertAlmostEqual(m, 0.5307511)\n\n        k, m = model.logistic_growth_init(history)\n\n        self.assertAlmostEqual(k, 1.507925, places=4)\n        self.assertAlmostEqual(m, -0.08167497, places=4)\n\n    def test_piecewise_linear(self):\n        model = Prophet()\n\n        t = np.arange(11.)\n        m = 0\n        k = 1.0\n        deltas = np.array([0.5])\n        changepoint_ts = np.array([5])\n\n        y = model.piecewise_linear(t, deltas, k, m, changepoint_ts)\n        y_true = np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0,\n                           6.5, 8.0, 9.5, 11.0, 12.5])\n        self.assertEqual((y - y_true).sum(), 0.0)\n\n        t = t[8:]\n        y_true = y_true[8:]\n        y = model.piecewise_linear(t, deltas, k, m, changepoint_ts)\n        self.assertEqual((y - y_true).sum(), 0.0)\n\n    def test_piecewise_logistic(self):\n        model = Prophet()\n\n        t = np.arange(11.)\n        cap = np.ones(11) * 10\n        m = 0\n        k = 1.0\n        deltas = np.array([0.5])\n        changepoint_ts = np.array([5])\n\n        y = model.piecewise_logistic(t, cap, deltas, k, m, changepoint_ts)\n        y_true = np.array([5.000000, 7.310586, 8.807971, 9.525741, 9.820138,\n                           9.933071, 9.984988, 9.996646, 9.999252, 9.999833,\n                           9.999963])\n        self.assertAlmostEqual((y - y_true).sum(), 0.0, places=5)\n\n        t = t[8:]\n        y_true = y_true[8:]\n        cap = cap[8:]\n        y = model.piecewise_logistic(t, cap, deltas, k, m, changepoint_ts)\n        self.assertAlmostEqual((y - y_true).sum(), 0.0, places=5)\n\n    def test_holidays(self):\n        holidays = pd.DataFrame({\n            'ds': pd.to_datetime(['2016-12-25']),\n            'holiday': ['xmas'],\n            'lower_window': [-1],\n            'upper_window': [0],\n        })\n        model = Prophet(holidays=holidays)\n        df = pd.DataFrame({\n            'ds': pd.date_range('2016-12-20', '2016-12-31')\n        })\n        feats, priors = model.make_holiday_features(df['ds'])\n         11 columns generated even though only 8 overlap\n        self.assertEqual(feats.shape, (df.shape[0], 2))\n        self.assertEqual((feats.sum(0) - np.array([1.0, 1.0])).sum(), 0)\n        self.assertEqual(priors, [10., 10.])   Default prior\n\n        holidays = pd.DataFrame({\n            'ds': pd.to_datetime(['2016-12-25']),\n            'holiday': ['xmas'],\n            'lower_window': [-1],\n            'upper_window': [10],\n        })\n        feats, priors = Prophet(holidays=holidays).make_holiday_features(df['ds'])\n         12 columns generated even though only 8 overlap\n        self.assertEqual(feats.shape, (df.shape[0], 12))\n        self.assertEqual(priors, list(10. * np.ones(12)))\n         Check prior specifications\n        holidays = pd.DataFrame({\n            'ds': pd.to_datetime(['2016-12-25', '2017-12-25']),\n            'holiday': ['xmas', 'xmas'],\n            'lower_window': [-1, -1],\n            'upper_window': [0, 0],\n            'prior_scale': [5., 5.],\n        })\n        feats, priors = Prophet(holidays=holidays).make_holiday_features(df['ds'])\n        self.assertEqual(priors, [5., 5.])\n         2 different priors\n        holidays2 = pd.DataFrame({\n            'ds': pd.to_datetime(['2012-06-06', '2013-06-06']),\n            'holiday': ['seans-bday'] * 2,\n            'lower_window': [0] * 2,\n            'upper_window': [1] * 2,\n            'prior_scale': [8] * 2,\n        })\n        holidays2 = pd.concat((holidays, holidays2))\n        feats, priors = Prophet(holidays=holidays2).make_holiday_features(df['ds'])\n        self.assertEqual(priors, [8., 8., 5., 5.])\n        holidays2 = pd.DataFrame({\n            'ds': pd.to_datetime(['2012-06-06', '2013-06-06']),\n            'holiday': ['seans-bday'] * 2,\n            'lower_window': [0] * 2,\n            'upper_window': [1] * 2,\n        })\n        holidays2 = pd.concat((holidays, holidays2))\n        feats, priors = Prophet(\n            holidays=holidays2, holidays_prior_scale=4\n        ).make_holiday_features(df['ds'])\n        self.assertEqual(priors, [4., 4., 5., 5.])\n         Check incompatible priors\n        holidays = pd.DataFrame({\n            'ds': pd.to_datetime(['2016-12-25', '2016-12-27']),\n            'holiday': ['xmasish', 'xmasish'],\n            'lower_window': [-1, -1],\n            'upper_window': [0, 0],\n            'prior_scale': [5., 6.],\n        })\n        with self.assertRaises(ValueError):\n            Prophet(holidays=holidays).make_holiday_features(df['ds'])\n\n    def test_fit_with_holidays(self):\n        holidays = pd.DataFrame({\n            'ds': pd.to_datetime(['2012-06-06', '2013-06-06']),\n            'holiday': ['seans-bday'] * 2,\n            'lower_window': [0] * 2,\n            'upper_window': [1] * 2,\n        })\n        model = Prophet(holidays=holidays, uncertainty_samples=0)\n        model.fit(DATA).predict()\n\n    def test_make_future_dataframe(self):\n        N = 468\n        train = DATA.head(N // 2)\n        forecaster = Prophet()\n        forecaster.fit(train)\n        future = forecaster.make_future_dataframe(periods=3, freq='D',\n                                                  include_history=False)\n        correct = pd.DatetimeIndex(['2013-04-26', '2013-04-27', '2013-04-28'])\n        self.assertEqual(len(future), 3)\n        for i in range(3):\n            self.assertEqual(future.iloc[i]['ds'], correct[i])\n\n        future = forecaster.make_future_dataframe(periods=3, freq='M',\n                                                  include_history=False)\n        correct = pd.DatetimeIndex(['2013-04-30', '2013-05-31', '2013-06-30'])\n        self.assertEqual(len(future), 3)\n        for i in range(3):\n            self.assertEqual(future.iloc[i]['ds'], correct[i])\n\n    def test_auto_weekly_seasonality(self):\n         Should be enabled\n        N = 15\n        train = DATA.head(N)\n        m = Prophet()\n        self.assertEqual(m.weekly_seasonality, 'auto')\n        m.fit(train)\n        self.assertIn('weekly', m.seasonalities)\n        self.assertEqual(m.seasonalities['weekly'],\n                         {'period': 7, 'fourier_order': 3, 'prior_scale': 10.})\n         Should be disabled due to too short history\n        N = 9\n        train = DATA.head(N)\n        m = Prophet()\n        m.fit(train)\n        self.assertNotIn('weekly', m.seasonalities)\n        m = Prophet(weekly_seasonality=True)\n        m.fit(train)\n        self.assertIn('weekly', m.seasonalities)\n         Should be False due to weekly spacing\n        train = DATA.iloc[::7, :]\n        m = Prophet()\n        m.fit(train)\n        self.assertNotIn('weekly', m.seasonalities)\n        m = Prophet(weekly_seasonality=2, seasonality_prior_scale=3.)\n        m.fit(DATA)\n        self.assertEqual(m.seasonalities['weekly'],\n                         {'period': 7, 'fourier_order': 2, 'prior_scale': 3.})\n\n    def test_auto_yearly_seasonality(self):\n         Should be enabled\n        m = Prophet()\n        self.assertEqual(m.yearly_seasonality, 'auto')\n        m.fit(DATA)\n        self.assertIn('yearly', m.seasonalities)\n        self.assertEqual(\n            m.seasonalities['yearly'],\n            {'period': 365.25, 'fourier_order': 10, 'prior_scale': 10.},\n        )\n         Should be disabled due to too short history\n        N = 240\n        train = DATA.head(N)\n        m = Prophet()\n        m.fit(train)\n        self.assertNotIn('yearly', m.seasonalities)\n        m = Prophet(yearly_seasonality=True)\n        m.fit(train)\n        self.assertIn('yearly', m.seasonalities)\n        m = Prophet(yearly_seasonality=7, seasonality_prior_scale=3.)\n        m.fit(DATA)\n        self.assertEqual(\n            m.seasonalities['yearly'],\n            {'period': 365.25, 'fourier_order': 7, 'prior_scale': 3.},\n        )\n\n    def test_auto_daily_seasonality(self):\n         Should be enabled\n        m = Prophet()\n        self.assertEqual(m.daily_seasonality, 'auto')\n        m.fit(DATA2)\n        self.assertIn('daily', m.seasonalities)\n        self.assertEqual(m.seasonalities['daily'],\n                         {'period': 1, 'fourier_order': 4, 'prior_scale': 10.})\n         Should be disabled due to too short history\n        N = 430\n        train = DATA2.head(N)\n        m = Prophet()\n        m.fit(train)\n        self.assertNotIn('daily', m.seasonalities)\n        m = Prophet(daily_seasonality=True)\n        m.fit(train)\n        self.assertIn('daily', m.seasonalities)\n        m = Prophet(daily_seasonality=7, seasonality_prior_scale=3.)\n        m.fit(DATA2)\n        self.assertEqual(m.seasonalities['daily'],\n                         {'period': 1, 'fourier_order': 7, 'prior_scale': 3.})\n        m = Prophet()\n        m.fit(DATA)\n        self.assertNotIn('daily', m.seasonalities)\n\n    def test_subdaily_holidays(self):\n        holidays = pd.DataFrame({\n            'ds': pd.to_datetime(['2017-01-02']),\n            'holiday': ['special_day'],\n        })\n        m = Prophet(holidays=holidays)\n        m.fit(DATA2)\n        fcst = m.predict()\n        self.assertEqual(sum(fcst['special_day'] == 0), 575)\n\n    def test_custom_seasonality(self):\n        holidays = pd.DataFrame({\n            'ds': pd.to_datetime(['2017-01-02']),\n            'holiday': ['special_day'],\n            'prior_scale': [4.],\n        })\n        m = Prophet(holidays=holidays)\n        m.add_seasonality(name='monthly', period=30, fourier_order=5,\n                          prior_scale=2.)\n        self.assertEqual(m.seasonalities['monthly'],\n                         {'period': 30, 'fourier_order': 5, 'prior_scale': 2.})\n        with self.assertRaises(ValueError):\n            m.add_seasonality(name='special_day', period=30, fourier_order=5)\n        with self.assertRaises(ValueError):\n            m.add_seasonality(name='trend', period=30, fourier_order=5)\n        m.add_seasonality(name='weekly', period=30, fourier_order=5)\n         Test priors\n        m = Prophet(holidays=holidays, yearly_seasonality=False)\n        m.add_seasonality(name='monthly', period=30, fourier_order=5,\n                          prior_scale=2.)\n        m.fit(DATA.copy())\n        seasonal_features, prior_scales = m.make_all_seasonality_features(\n            m.history)\n        if seasonal_features.columns[0] == 'monthly_delim_1':\n            true = [2.] * 10 + [10.] * 6 + [4.]\n        else:\n            true = [10.] * 6 + [2.] * 10 + [4.]\n        self.assertEqual(prior_scales, true)\n\n    def test_added_regressors(self):\n        m = Prophet()\n        m.add_regressor('binary_feature', prior_scale=0.2)\n        m.add_regressor('numeric_feature', prior_scale=0.5)\n        m.add_regressor('binary_feature2', standardize=True)\n        df = DATA.copy()\n        df['binary_feature'] = [0] * 255 + [1] * 255\n        df['numeric_feature'] = range(510)\n        with self.assertRaises(ValueError):\n             Require all regressors in df\n            m.fit(df)\n        df['binary_feature2'] = [1] * 100 + [0] * 410\n        m.fit(df)\n         Check that standardizations are correctly set\n        self.assertEqual(\n            m.extra_regressors['binary_feature'],\n            {'prior_scale': 0.2, 'mu': 0, 'std': 1, 'standardize': 'auto'},\n        )\n        self.assertEqual(\n            m.extra_regressors['numeric_feature']['prior_scale'], 0.5)\n        self.assertEqual(\n            m.extra_regressors['numeric_feature']['mu'], 254.5)\n        self.assertAlmostEqual(\n            m.extra_regressors['numeric_feature']['std'], 147.368585, places=5)\n        self.assertEqual(\n            m.extra_regressors['binary_feature2']['prior_scale'], 10.)\n        self.assertAlmostEqual(\n            m.extra_regressors['binary_feature2']['mu'], 0.1960784, places=5)\n        self.assertAlmostEqual(\n            m.extra_regressors['binary_feature2']['std'], 0.3974183, places=5)\n         Check that standardization is done correctly\n        df2 = m.setup_dataframe(df.copy())\n        self.assertEqual(df2['binary_feature'][0], 0)\n        self.assertAlmostEqual(df2['numeric_feature'][0], -1.726962, places=4)\n        self.assertAlmostEqual(df2['binary_feature2'][0], 2.022859, places=4)\n         Check that feature matrix and prior scales are correctly constructed\n        seasonal_features, prior_scales = m.make_all_seasonality_features(df2)\n        self.assertIn('binary_feature', seasonal_features)\n        self.assertIn('numeric_feature', seasonal_features)\n        self.assertIn('binary_feature2', seasonal_features)\n        self.assertEqual(seasonal_features.shape[1], 29)\n        self.assertEqual(set(prior_scales[26:]), set([0.2, 0.5, 10.]))\n         Check that forecast components are reasonable\n        future = pd.DataFrame({\n            'ds': ['2014-06-01'],\n            'binary_feature': [0],\n            'numeric_feature': [10],\n        })\n        with self.assertRaises(ValueError):\n            m.predict(future)\n        future['binary_feature2'] = 0\n        fcst = m.predict(future)\n        self.assertEqual(fcst.shape[1], 31)\n        self.assertEqual(fcst['binary_feature'][0], 0)\n        self.assertAlmostEqual(\n            fcst['extra_regressors'][0],\n            fcst['numeric_feature'][0] + fcst['binary_feature2'][0],\n        )\n        self.assertAlmostEqual(\n            fcst['seasonalities'][0],\n            fcst['yearly'][0] + fcst['weekly'][0],\n        )\n        self.assertAlmostEqual(\n            fcst['seasonal'][0],\n            fcst['seasonalities'][0] + fcst['extra_regressors'][0],\n        )\n        self.assertAlmostEqual(\n            fcst['yhat'][0],\n            fcst['trend'][0] + fcst['seasonal'][0],\n        )\n         Check fails if constant extra regressor\n        df['constant_feature'] = 5\n        m = Prophet()\n        m.add_regressor('constant_feature')\n        with self.assertRaises(ValueError):\n            m.fit(df.copy())\n\n    def test_copy(self):\n        df = DATA.copy()\n        df['cap'] = 200.\n        df['binary_feature'] = [0] * 255 + [1] * 255\n         These values are created except for its default values\n        holiday = pd.DataFrame(\n            {'ds': pd.to_datetime(['2016-12-25']), 'holiday': ['x']})\n        products = itertools.product(\n            ['linear', 'logistic'],   growth\n            [None, pd.to_datetime(['2016-12-25'])],   changepoints\n            [3],   n_changepoints\n            [True, False],   yearly_seasonality\n            [True, False],   weekly_seasonality\n            [True, False],   daily_seasonality\n            [None, holiday],   holidays\n            [1.1],   seasonality_prior_scale\n            [1.1],   holidays_prior_scale\n            [0.1],   changepoint_prior_scale\n            [100],   mcmc_samples\n            [0.9],   interval_width\n            [200]   uncertainty_samples\n        )\n         Values should be copied correctly\n        for product in products:\n            m1 = Prophet(*product)\n            m1.history = m1.setup_dataframe(\n                df.copy(), initialize_scales=True)\n            m1.set_auto_seasonalities()\n            m2 = m1.copy()\n            self.assertEqual(m1.growth, m2.growth)\n            self.assertEqual(m1.n_changepoints, m2.n_changepoints)\n            self.assertEqual(m1.changepoints, m2.changepoints)\n            self.assertEqual(False, m2.yearly_seasonality)\n            self.assertEqual(False, m2.weekly_seasonality)\n            self.assertEqual(False, m2.daily_seasonality)\n            self.assertEqual(\n                m1.yearly_seasonality, 'yearly' in m2.seasonalities)\n            self.assertEqual(\n                m1.weekly_seasonality, 'weekly' in m2.seasonalities)\n            self.assertEqual(\n                m1.daily_seasonality, 'daily' in m2.seasonalities)\n            if m1.holidays is None:\n                self.assertEqual(m1.holidays, m2.holidays)\n            else:\n                self.assertTrue((m1.holidays == m2.holidays).values.all())\n            self.assertEqual(m1.seasonality_prior_scale, m2.seasonality_prior_scale)\n            self.assertEqual(m1.changepoint_prior_scale, m2.changepoint_prior_scale)\n            self.assertEqual(m1.holidays_prior_scale, m2.holidays_prior_scale)\n            self.assertEqual(m1.mcmc_samples, m2.mcmc_samples)\n            self.assertEqual(m1.interval_width, m2.interval_width)\n            self.assertEqual(m1.uncertainty_samples, m2.uncertainty_samples)\n\n         Check for cutoff and custom seasonality and extra regressors\n        changepoints = pd.date_range('2012-06-15', '2012-09-15')\n        cutoff = pd.Timestamp('2012-07-25')\n        m1 = Prophet(changepoints=changepoints)\n        m1.add_seasonality('custom', 10, 5)\n        m1.add_regressor('binary_feature')\n        m1.fit(df)\n        m2 = m1.copy(cutoff=cutoff)\n        changepoints = changepoints[changepoints <= cutoff]\n        self.assertTrue((changepoints == m2.changepoints).all())\n        self.assertTrue('custom' in m2.seasonalities)\n        self.assertTrue('binary_feature' in m2.extra_regressors)\n", "comments": "  copyright (c) 2017 present  facebook  inc     all rights reserved        this source code licensed bsd style license found    license file root directory source tree  an additional grant    patent rights found patents file directory     fb block 1 start    fb block 1 end    fb block 2    check approximate shift invariance    these r forecast package directly     these r forecast package directly     11 columns generated even though 8 overlap    default prior    12 columns generated even though 8 overlap    check prior specifications    2 different priors    check incompatible priors    should enabled    should disabled due short history    should false due weekly spacing    should enabled    should disabled due short history    should enabled    should disabled due short history    test priors    require regressors df    check standardizations correctly set    check standardization done correctly    check feature matrix prior scales correctly constructed    check forecast components reasonable    check fails constant extra regressor    these values created except default values    growth    changepoints    n changepoints    yearly seasonality    weekly seasonality    daily seasonality    holidays    seasonality prior scale    holidays prior scale    changepoint prior scale    mcmc samples    interval width    uncertainty samples    values copied correctly    check cutoff custom seasonality extra regressors ", "content": "# Copyright (c) 2017-present, Facebook, Inc.\n# All rights reserved.\n#\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree. An additional grant\n# of patent rights can be found in the PATENTS file in the same directory.\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nimport itertools\nimport numpy as np\nimport pandas as pd\n\n# fb-block 1 start\nimport os\nfrom unittest import TestCase\nfrom fbprophet import Prophet\n\nDATA = pd.read_csv(\n    os.path.join(os.path.dirname(__file__), 'data.csv'),\n    parse_dates=['ds'],\n)\nDATA2 = pd.read_csv(\n    os.path.join(os.path.dirname(__file__), 'data2.csv'),\n    parse_dates=['ds'],\n)\n# fb-block 1 end\n# fb-block 2\n\n\nclass TestProphet(TestCase):\n\n    def test_fit_predict(self):\n        N = DATA.shape[0]\n        train = DATA.head(N // 2)\n        future = DATA.tail(N // 2)\n\n        forecaster = Prophet()\n        forecaster.fit(train)\n        forecaster.predict(future)\n\n    def test_fit_predict_no_seasons(self):\n        N = DATA.shape[0]\n        train = DATA.head(N // 2)\n        future = DATA.tail(N // 2)\n\n        forecaster = Prophet(weekly_seasonality=False, yearly_seasonality=False)\n        forecaster.fit(train)\n        forecaster.predict(future)\n\n    def test_fit_predict_no_changepoints(self):\n        N = DATA.shape[0]\n        train = DATA.head(N // 2)\n        future = DATA.tail(N // 2)\n\n        forecaster = Prophet(n_changepoints=0)\n        forecaster.fit(train)\n        forecaster.predict(future)\n\n    def test_fit_changepoint_not_in_history(self):\n        train = DATA[(DATA['ds'] < '2013-01-01') | (DATA['ds'] > '2014-01-01')]\n        future = pd.DataFrame({'ds': DATA['ds']})\n        forecaster = Prophet(changepoints=['2013-06-06'])\n        forecaster.fit(train)\n        forecaster.predict(future)\n\n    def test_fit_predict_duplicates(self):\n        N = DATA.shape[0]\n        train1 = DATA.head(N // 2).copy()\n        train2 = DATA.head(N // 2).copy()\n        train2['y'] += 10\n        train = train1.append(train2)\n        future = pd.DataFrame({'ds': DATA['ds'].tail(N // 2)})\n        forecaster = Prophet()\n        forecaster.fit(train)\n        forecaster.predict(future)\n\n    def test_fit_predict_constant_history(self):\n        N = DATA.shape[0]\n        train = DATA.head(N // 2).copy()\n        train['y'] = 20\n        future = pd.DataFrame({'ds': DATA['ds'].tail(N // 2)})\n        m = Prophet()\n        m.fit(train)\n        fcst = m.predict(future)\n        self.assertEqual(fcst['yhat'].values[-1], 20)\n        train['y'] = 0\n        future = pd.DataFrame({'ds': DATA['ds'].tail(N // 2)})\n        m = Prophet()\n        m.fit(train)\n        fcst = m.predict(future)\n        self.assertEqual(fcst['yhat'].values[-1], 0)\n\n    def test_setup_dataframe(self):\n        m = Prophet()\n        N = DATA.shape[0]\n        history = DATA.head(N // 2).copy()\n\n        history = m.setup_dataframe(history, initialize_scales=True)\n\n        self.assertTrue('t' in history)\n        self.assertEqual(history['t'].min(), 0.0)\n        self.assertEqual(history['t'].max(), 1.0)\n\n        self.assertTrue('y_scaled' in history)\n        self.assertEqual(history['y_scaled'].max(), 1.0)\n\n    def test_logistic_floor(self):\n        m = Prophet(growth='logistic')\n        N = DATA.shape[0]\n        history = DATA.head(N // 2).copy()\n        history['floor'] = 10.\n        history['cap'] = 80.\n        future = DATA.tail(N // 2).copy()\n        future['cap'] = 80.\n        future['floor'] = 10.\n        m.fit(history, algorithm='Newton')\n        self.assertTrue(m.logistic_floor)\n        self.assertTrue('floor' in m.history)\n        self.assertAlmostEqual(m.history['y_scaled'][0], 1.)\n        fcst1 = m.predict(future)\n\n        m2 = Prophet(growth='logistic')\n        history2 = history.copy()\n        history2['y'] += 10.\n        history2['floor'] += 10.\n        history2['cap'] += 10.\n        future['cap'] += 10.\n        future['floor'] += 10.\n        m2.fit(history2, algorithm='Newton')\n        self.assertAlmostEqual(m2.history['y_scaled'][0], 1.)\n        fcst2 = m2.predict(future)\n        fcst2['yhat'] -= 10.\n        # Check for approximate shift invariance\n        self.assertTrue((np.abs(fcst1['yhat'] - fcst2['yhat']) < 1).all())\n\n    def test_get_changepoints(self):\n        m = Prophet()\n        N = DATA.shape[0]\n        history = DATA.head(N // 2).copy()\n\n        history = m.setup_dataframe(history, initialize_scales=True)\n        m.history = history\n\n        m.set_changepoints()\n\n        cp = m.changepoints_t\n        self.assertEqual(cp.shape[0], m.n_changepoints)\n        self.assertEqual(len(cp.shape), 1)\n        self.assertTrue(cp.min() > 0)\n        self.assertTrue(cp.max() < N)\n\n        mat = m.get_changepoint_matrix()\n        self.assertEqual(mat.shape[0], N // 2)\n        self.assertEqual(mat.shape[1], m.n_changepoints)\n\n    def test_get_zero_changepoints(self):\n        m = Prophet(n_changepoints=0)\n        N = DATA.shape[0]\n        history = DATA.head(N // 2).copy()\n\n        history = m.setup_dataframe(history, initialize_scales=True)\n        m.history = history\n\n        m.set_changepoints()\n        cp = m.changepoints_t\n        self.assertEqual(cp.shape[0], 1)\n        self.assertEqual(cp[0], 0)\n\n        mat = m.get_changepoint_matrix()\n        self.assertEqual(mat.shape[0], N // 2)\n        self.assertEqual(mat.shape[1], 1)\n\n    def test_override_n_changepoints(self):\n        m = Prophet()\n        history = DATA.head(20).copy()\n\n        history = m.setup_dataframe(history, initialize_scales=True)\n        m.history = history\n\n        m.set_changepoints()\n        self.assertEqual(m.n_changepoints, 15)\n        cp = m.changepoints_t\n        self.assertEqual(cp.shape[0], 15)\n\n    def test_fourier_series_weekly(self):\n        mat = Prophet.fourier_series(DATA['ds'], 7, 3)\n        # These are from the R forecast package directly.\n        true_values = np.array([\n            0.7818315, 0.6234898, 0.9749279, -0.2225209, 0.4338837, -0.9009689,\n        ])\n        self.assertAlmostEqual(np.sum((mat[0] - true_values)**2), 0.0)\n\n    def test_fourier_series_yearly(self):\n        mat = Prophet.fourier_series(DATA['ds'], 365.25, 3)\n        # These are from the R forecast package directly.\n        true_values = np.array([\n            0.7006152, -0.7135393, -0.9998330, 0.01827656, 0.7262249, 0.6874572,\n        ])\n        self.assertAlmostEqual(np.sum((mat[0] - true_values)**2), 0.0)\n\n    def test_growth_init(self):\n        model = Prophet(growth='logistic')\n        history = DATA.iloc[:468].copy()\n        history['cap'] = history['y'].max()\n\n        history = model.setup_dataframe(history, initialize_scales=True)\n\n        k, m = model.linear_growth_init(history)\n        self.assertAlmostEqual(k, 0.3055671)\n        self.assertAlmostEqual(m, 0.5307511)\n\n        k, m = model.logistic_growth_init(history)\n\n        self.assertAlmostEqual(k, 1.507925, places=4)\n        self.assertAlmostEqual(m, -0.08167497, places=4)\n\n    def test_piecewise_linear(self):\n        model = Prophet()\n\n        t = np.arange(11.)\n        m = 0\n        k = 1.0\n        deltas = np.array([0.5])\n        changepoint_ts = np.array([5])\n\n        y = model.piecewise_linear(t, deltas, k, m, changepoint_ts)\n        y_true = np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0,\n                           6.5, 8.0, 9.5, 11.0, 12.5])\n        self.assertEqual((y - y_true).sum(), 0.0)\n\n        t = t[8:]\n        y_true = y_true[8:]\n        y = model.piecewise_linear(t, deltas, k, m, changepoint_ts)\n        self.assertEqual((y - y_true).sum(), 0.0)\n\n    def test_piecewise_logistic(self):\n        model = Prophet()\n\n        t = np.arange(11.)\n        cap = np.ones(11) * 10\n        m = 0\n        k = 1.0\n        deltas = np.array([0.5])\n        changepoint_ts = np.array([5])\n\n        y = model.piecewise_logistic(t, cap, deltas, k, m, changepoint_ts)\n        y_true = np.array([5.000000, 7.310586, 8.807971, 9.525741, 9.820138,\n                           9.933071, 9.984988, 9.996646, 9.999252, 9.999833,\n                           9.999963])\n        self.assertAlmostEqual((y - y_true).sum(), 0.0, places=5)\n\n        t = t[8:]\n        y_true = y_true[8:]\n        cap = cap[8:]\n        y = model.piecewise_logistic(t, cap, deltas, k, m, changepoint_ts)\n        self.assertAlmostEqual((y - y_true).sum(), 0.0, places=5)\n\n    def test_holidays(self):\n        holidays = pd.DataFrame({\n            'ds': pd.to_datetime(['2016-12-25']),\n            'holiday': ['xmas'],\n            'lower_window': [-1],\n            'upper_window': [0],\n        })\n        model = Prophet(holidays=holidays)\n        df = pd.DataFrame({\n            'ds': pd.date_range('2016-12-20', '2016-12-31')\n        })\n        feats, priors = model.make_holiday_features(df['ds'])\n        # 11 columns generated even though only 8 overlap\n        self.assertEqual(feats.shape, (df.shape[0], 2))\n        self.assertEqual((feats.sum(0) - np.array([1.0, 1.0])).sum(), 0)\n        self.assertEqual(priors, [10., 10.])  # Default prior\n\n        holidays = pd.DataFrame({\n            'ds': pd.to_datetime(['2016-12-25']),\n            'holiday': ['xmas'],\n            'lower_window': [-1],\n            'upper_window': [10],\n        })\n        feats, priors = Prophet(holidays=holidays).make_holiday_features(df['ds'])\n        # 12 columns generated even though only 8 overlap\n        self.assertEqual(feats.shape, (df.shape[0], 12))\n        self.assertEqual(priors, list(10. * np.ones(12)))\n        # Check prior specifications\n        holidays = pd.DataFrame({\n            'ds': pd.to_datetime(['2016-12-25', '2017-12-25']),\n            'holiday': ['xmas', 'xmas'],\n            'lower_window': [-1, -1],\n            'upper_window': [0, 0],\n            'prior_scale': [5., 5.],\n        })\n        feats, priors = Prophet(holidays=holidays).make_holiday_features(df['ds'])\n        self.assertEqual(priors, [5., 5.])\n        # 2 different priors\n        holidays2 = pd.DataFrame({\n            'ds': pd.to_datetime(['2012-06-06', '2013-06-06']),\n            'holiday': ['seans-bday'] * 2,\n            'lower_window': [0] * 2,\n            'upper_window': [1] * 2,\n            'prior_scale': [8] * 2,\n        })\n        holidays2 = pd.concat((holidays, holidays2))\n        feats, priors = Prophet(holidays=holidays2).make_holiday_features(df['ds'])\n        self.assertEqual(priors, [8., 8., 5., 5.])\n        holidays2 = pd.DataFrame({\n            'ds': pd.to_datetime(['2012-06-06', '2013-06-06']),\n            'holiday': ['seans-bday'] * 2,\n            'lower_window': [0] * 2,\n            'upper_window': [1] * 2,\n        })\n        holidays2 = pd.concat((holidays, holidays2))\n        feats, priors = Prophet(\n            holidays=holidays2, holidays_prior_scale=4\n        ).make_holiday_features(df['ds'])\n        self.assertEqual(priors, [4., 4., 5., 5.])\n        # Check incompatible priors\n        holidays = pd.DataFrame({\n            'ds': pd.to_datetime(['2016-12-25', '2016-12-27']),\n            'holiday': ['xmasish', 'xmasish'],\n            'lower_window': [-1, -1],\n            'upper_window': [0, 0],\n            'prior_scale': [5., 6.],\n        })\n        with self.assertRaises(ValueError):\n            Prophet(holidays=holidays).make_holiday_features(df['ds'])\n\n    def test_fit_with_holidays(self):\n        holidays = pd.DataFrame({\n            'ds': pd.to_datetime(['2012-06-06', '2013-06-06']),\n            'holiday': ['seans-bday'] * 2,\n            'lower_window': [0] * 2,\n            'upper_window': [1] * 2,\n        })\n        model = Prophet(holidays=holidays, uncertainty_samples=0)\n        model.fit(DATA).predict()\n\n    def test_make_future_dataframe(self):\n        N = 468\n        train = DATA.head(N // 2)\n        forecaster = Prophet()\n        forecaster.fit(train)\n        future = forecaster.make_future_dataframe(periods=3, freq='D',\n                                                  include_history=False)\n        correct = pd.DatetimeIndex(['2013-04-26', '2013-04-27', '2013-04-28'])\n        self.assertEqual(len(future), 3)\n        for i in range(3):\n            self.assertEqual(future.iloc[i]['ds'], correct[i])\n\n        future = forecaster.make_future_dataframe(periods=3, freq='M',\n                                                  include_history=False)\n        correct = pd.DatetimeIndex(['2013-04-30', '2013-05-31', '2013-06-30'])\n        self.assertEqual(len(future), 3)\n        for i in range(3):\n            self.assertEqual(future.iloc[i]['ds'], correct[i])\n\n    def test_auto_weekly_seasonality(self):\n        # Should be enabled\n        N = 15\n        train = DATA.head(N)\n        m = Prophet()\n        self.assertEqual(m.weekly_seasonality, 'auto')\n        m.fit(train)\n        self.assertIn('weekly', m.seasonalities)\n        self.assertEqual(m.seasonalities['weekly'],\n                         {'period': 7, 'fourier_order': 3, 'prior_scale': 10.})\n        # Should be disabled due to too short history\n        N = 9\n        train = DATA.head(N)\n        m = Prophet()\n        m.fit(train)\n        self.assertNotIn('weekly', m.seasonalities)\n        m = Prophet(weekly_seasonality=True)\n        m.fit(train)\n        self.assertIn('weekly', m.seasonalities)\n        # Should be False due to weekly spacing\n        train = DATA.iloc[::7, :]\n        m = Prophet()\n        m.fit(train)\n        self.assertNotIn('weekly', m.seasonalities)\n        m = Prophet(weekly_seasonality=2, seasonality_prior_scale=3.)\n        m.fit(DATA)\n        self.assertEqual(m.seasonalities['weekly'],\n                         {'period': 7, 'fourier_order': 2, 'prior_scale': 3.})\n\n    def test_auto_yearly_seasonality(self):\n        # Should be enabled\n        m = Prophet()\n        self.assertEqual(m.yearly_seasonality, 'auto')\n        m.fit(DATA)\n        self.assertIn('yearly', m.seasonalities)\n        self.assertEqual(\n            m.seasonalities['yearly'],\n            {'period': 365.25, 'fourier_order': 10, 'prior_scale': 10.},\n        )\n        # Should be disabled due to too short history\n        N = 240\n        train = DATA.head(N)\n        m = Prophet()\n        m.fit(train)\n        self.assertNotIn('yearly', m.seasonalities)\n        m = Prophet(yearly_seasonality=True)\n        m.fit(train)\n        self.assertIn('yearly', m.seasonalities)\n        m = Prophet(yearly_seasonality=7, seasonality_prior_scale=3.)\n        m.fit(DATA)\n        self.assertEqual(\n            m.seasonalities['yearly'],\n            {'period': 365.25, 'fourier_order': 7, 'prior_scale': 3.},\n        )\n\n    def test_auto_daily_seasonality(self):\n        # Should be enabled\n        m = Prophet()\n        self.assertEqual(m.daily_seasonality, 'auto')\n        m.fit(DATA2)\n        self.assertIn('daily', m.seasonalities)\n        self.assertEqual(m.seasonalities['daily'],\n                         {'period': 1, 'fourier_order': 4, 'prior_scale': 10.})\n        # Should be disabled due to too short history\n        N = 430\n        train = DATA2.head(N)\n        m = Prophet()\n        m.fit(train)\n        self.assertNotIn('daily', m.seasonalities)\n        m = Prophet(daily_seasonality=True)\n        m.fit(train)\n        self.assertIn('daily', m.seasonalities)\n        m = Prophet(daily_seasonality=7, seasonality_prior_scale=3.)\n        m.fit(DATA2)\n        self.assertEqual(m.seasonalities['daily'],\n                         {'period': 1, 'fourier_order': 7, 'prior_scale': 3.})\n        m = Prophet()\n        m.fit(DATA)\n        self.assertNotIn('daily', m.seasonalities)\n\n    def test_subdaily_holidays(self):\n        holidays = pd.DataFrame({\n            'ds': pd.to_datetime(['2017-01-02']),\n            'holiday': ['special_day'],\n        })\n        m = Prophet(holidays=holidays)\n        m.fit(DATA2)\n        fcst = m.predict()\n        self.assertEqual(sum(fcst['special_day'] == 0), 575)\n\n    def test_custom_seasonality(self):\n        holidays = pd.DataFrame({\n            'ds': pd.to_datetime(['2017-01-02']),\n            'holiday': ['special_day'],\n            'prior_scale': [4.],\n        })\n        m = Prophet(holidays=holidays)\n        m.add_seasonality(name='monthly', period=30, fourier_order=5,\n                          prior_scale=2.)\n        self.assertEqual(m.seasonalities['monthly'],\n                         {'period': 30, 'fourier_order': 5, 'prior_scale': 2.})\n        with self.assertRaises(ValueError):\n            m.add_seasonality(name='special_day', period=30, fourier_order=5)\n        with self.assertRaises(ValueError):\n            m.add_seasonality(name='trend', period=30, fourier_order=5)\n        m.add_seasonality(name='weekly', period=30, fourier_order=5)\n        # Test priors\n        m = Prophet(holidays=holidays, yearly_seasonality=False)\n        m.add_seasonality(name='monthly', period=30, fourier_order=5,\n                          prior_scale=2.)\n        m.fit(DATA.copy())\n        seasonal_features, prior_scales = m.make_all_seasonality_features(\n            m.history)\n        if seasonal_features.columns[0] == 'monthly_delim_1':\n            true = [2.] * 10 + [10.] * 6 + [4.]\n        else:\n            true = [10.] * 6 + [2.] * 10 + [4.]\n        self.assertEqual(prior_scales, true)\n\n    def test_added_regressors(self):\n        m = Prophet()\n        m.add_regressor('binary_feature', prior_scale=0.2)\n        m.add_regressor('numeric_feature', prior_scale=0.5)\n        m.add_regressor('binary_feature2', standardize=True)\n        df = DATA.copy()\n        df['binary_feature'] = [0] * 255 + [1] * 255\n        df['numeric_feature'] = range(510)\n        with self.assertRaises(ValueError):\n            # Require all regressors in df\n            m.fit(df)\n        df['binary_feature2'] = [1] * 100 + [0] * 410\n        m.fit(df)\n        # Check that standardizations are correctly set\n        self.assertEqual(\n            m.extra_regressors['binary_feature'],\n            {'prior_scale': 0.2, 'mu': 0, 'std': 1, 'standardize': 'auto'},\n        )\n        self.assertEqual(\n            m.extra_regressors['numeric_feature']['prior_scale'], 0.5)\n        self.assertEqual(\n            m.extra_regressors['numeric_feature']['mu'], 254.5)\n        self.assertAlmostEqual(\n            m.extra_regressors['numeric_feature']['std'], 147.368585, places=5)\n        self.assertEqual(\n            m.extra_regressors['binary_feature2']['prior_scale'], 10.)\n        self.assertAlmostEqual(\n            m.extra_regressors['binary_feature2']['mu'], 0.1960784, places=5)\n        self.assertAlmostEqual(\n            m.extra_regressors['binary_feature2']['std'], 0.3974183, places=5)\n        # Check that standardization is done correctly\n        df2 = m.setup_dataframe(df.copy())\n        self.assertEqual(df2['binary_feature'][0], 0)\n        self.assertAlmostEqual(df2['numeric_feature'][0], -1.726962, places=4)\n        self.assertAlmostEqual(df2['binary_feature2'][0], 2.022859, places=4)\n        # Check that feature matrix and prior scales are correctly constructed\n        seasonal_features, prior_scales = m.make_all_seasonality_features(df2)\n        self.assertIn('binary_feature', seasonal_features)\n        self.assertIn('numeric_feature', seasonal_features)\n        self.assertIn('binary_feature2', seasonal_features)\n        self.assertEqual(seasonal_features.shape[1], 29)\n        self.assertEqual(set(prior_scales[26:]), set([0.2, 0.5, 10.]))\n        # Check that forecast components are reasonable\n        future = pd.DataFrame({\n            'ds': ['2014-06-01'],\n            'binary_feature': [0],\n            'numeric_feature': [10],\n        })\n        with self.assertRaises(ValueError):\n            m.predict(future)\n        future['binary_feature2'] = 0\n        fcst = m.predict(future)\n        self.assertEqual(fcst.shape[1], 31)\n        self.assertEqual(fcst['binary_feature'][0], 0)\n        self.assertAlmostEqual(\n            fcst['extra_regressors'][0],\n            fcst['numeric_feature'][0] + fcst['binary_feature2'][0],\n        )\n        self.assertAlmostEqual(\n            fcst['seasonalities'][0],\n            fcst['yearly'][0] + fcst['weekly'][0],\n        )\n        self.assertAlmostEqual(\n            fcst['seasonal'][0],\n            fcst['seasonalities'][0] + fcst['extra_regressors'][0],\n        )\n        self.assertAlmostEqual(\n            fcst['yhat'][0],\n            fcst['trend'][0] + fcst['seasonal'][0],\n        )\n        # Check fails if constant extra regressor\n        df['constant_feature'] = 5\n        m = Prophet()\n        m.add_regressor('constant_feature')\n        with self.assertRaises(ValueError):\n            m.fit(df.copy())\n\n    def test_copy(self):\n        df = DATA.copy()\n        df['cap'] = 200.\n        df['binary_feature'] = [0] * 255 + [1] * 255\n        # These values are created except for its default values\n        holiday = pd.DataFrame(\n            {'ds': pd.to_datetime(['2016-12-25']), 'holiday': ['x']})\n        products = itertools.product(\n            ['linear', 'logistic'],  # growth\n            [None, pd.to_datetime(['2016-12-25'])],  # changepoints\n            [3],  # n_changepoints\n            [True, False],  # yearly_seasonality\n            [True, False],  # weekly_seasonality\n            [True, False],  # daily_seasonality\n            [None, holiday],  # holidays\n            [1.1],  # seasonality_prior_scale\n            [1.1],  # holidays_prior_scale\n            [0.1],  # changepoint_prior_scale\n            [100],  # mcmc_samples\n            [0.9],  # interval_width\n            [200]  # uncertainty_samples\n        )\n        # Values should be copied correctly\n        for product in products:\n            m1 = Prophet(*product)\n            m1.history = m1.setup_dataframe(\n                df.copy(), initialize_scales=True)\n            m1.set_auto_seasonalities()\n            m2 = m1.copy()\n            self.assertEqual(m1.growth, m2.growth)\n            self.assertEqual(m1.n_changepoints, m2.n_changepoints)\n            self.assertEqual(m1.changepoints, m2.changepoints)\n            self.assertEqual(False, m2.yearly_seasonality)\n            self.assertEqual(False, m2.weekly_seasonality)\n            self.assertEqual(False, m2.daily_seasonality)\n            self.assertEqual(\n                m1.yearly_seasonality, 'yearly' in m2.seasonalities)\n            self.assertEqual(\n                m1.weekly_seasonality, 'weekly' in m2.seasonalities)\n            self.assertEqual(\n                m1.daily_seasonality, 'daily' in m2.seasonalities)\n            if m1.holidays is None:\n                self.assertEqual(m1.holidays, m2.holidays)\n            else:\n                self.assertTrue((m1.holidays == m2.holidays).values.all())\n            self.assertEqual(m1.seasonality_prior_scale, m2.seasonality_prior_scale)\n            self.assertEqual(m1.changepoint_prior_scale, m2.changepoint_prior_scale)\n            self.assertEqual(m1.holidays_prior_scale, m2.holidays_prior_scale)\n            self.assertEqual(m1.mcmc_samples, m2.mcmc_samples)\n            self.assertEqual(m1.interval_width, m2.interval_width)\n            self.assertEqual(m1.uncertainty_samples, m2.uncertainty_samples)\n\n        # Check for cutoff and custom seasonality and extra regressors\n        changepoints = pd.date_range('2012-06-15', '2012-09-15')\n        cutoff = pd.Timestamp('2012-07-25')\n        m1 = Prophet(changepoints=changepoints)\n        m1.add_seasonality('custom', 10, 5)\n        m1.add_regressor('binary_feature')\n        m1.fit(df)\n        m2 = m1.copy(cutoff=cutoff)\n        changepoints = changepoints[changepoints <= cutoff]\n        self.assertTrue((changepoints == m2.changepoints).all())\n        self.assertTrue('custom' in m2.seasonalities)\n        self.assertTrue('binary_feature' in m2.extra_regressors)\n", "description": "Tool for producing high quality forecasts for time series data that has multiple seasonality with linear or non-linear growth.", "file_name": "test_prophet.py", "id": "9d6cd2ad985b61b85053c571078ede4e", "language": "Python", "project_name": "prophet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/facebook-prophet/facebook-prophet-792278f/python/fbprophet/tests/test_prophet.py", "save_time": "", "source": "", "update_at": "2018-03-18T17:15:21Z", "url": "https://github.com/facebook/prophet", "wiki": false}