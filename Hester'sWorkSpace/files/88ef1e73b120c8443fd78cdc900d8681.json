{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport base64\nimport json\nimport random\nimport re\n\nfrom .common import InfoExtractor\nfrom ..aes import (\n    aes_cbc_decrypt,\n    aes_cbc_encrypt,\n)\nfrom ..compat import compat_b64decode\nfrom ..utils import (\n    bytes_to_intlist,\n    bytes_to_long,\n    extract_attributes,\n    ExtractorError,\n    intlist_to_bytes,\n    js_to_json,\n    int_or_none,\n    long_to_bytes,\n    pkcs1pad,\n)\n\n\nclass DaisukiMottoIE(InfoExtractor):\n    _VALID_URL = r'https?://motto\\.daisuki\\.net/framewatch/embed/[^/]+/(?P<id>[0-9a-zA-Z]{3})'\n\n    _TEST = {\n        'url': 'http://motto.daisuki.net/framewatch/embed/embedDRAGONBALLSUPERUniverseSurvivalsaga/V2e/760/428',\n        'info_dict': {\n            'id': 'V2e',\n            'ext': 'mp4',\n            'title': '\n            'subtitles': {\n                'mul': [{\n                    'ext': 'ttml',\n                }],\n            },\n        },\n        'params': {\n            'skip_download': True,  \n        },\n    }\n\n    \n    _RSA_KEY = (0xc5524c25e8e14b366b3754940beeb6f96cb7e2feef0b932c7659a0c5c3bf173d602464c2df73d693b513ae06ff1be8f367529ab30bf969c5640522181f2a0c51ea546ae120d3d8d908595e4eff765b389cde080a1ef7f1bbfb07411cc568db73b7f521cedf270cbfbe0ddbc29b1ac9d0f2d8f4359098caffee6d07915020077d, 65537)\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id)\n\n        flashvars = self._parse_json(self._search_regex(\n            r'(?s)var\\s+flashvars\\s*=\\s*({.+?});', webpage, 'flashvars'),\n            video_id, transform_source=js_to_json)\n\n        iv = [0] * 16\n\n        data = {}\n        for key in ('device_cd', 'mv_id', 'ss1_prm', 'ss2_prm', 'ss3_prm', 'ss_id'):\n            data[key] = flashvars.get(key, '')\n\n        encrypted_rtn = None\n\n        \n        for idx in range(5):\n            aes_key = [random.randint(0, 254) for _ in range(32)]\n            padded_aeskey = intlist_to_bytes(pkcs1pad(aes_key, 128))\n\n            n, e = self._RSA_KEY\n            encrypted_aeskey = long_to_bytes(pow(bytes_to_long(padded_aeskey), e, n))\n            init_data = self._download_json(\n                'http://motto.daisuki.net/fastAPI/bgn/init/',\n                video_id, query={\n                    's': flashvars.get('s', ''),\n                    'c': flashvars.get('ss3_prm', ''),\n                    'e': url,\n                    'd': base64.b64encode(intlist_to_bytes(aes_cbc_encrypt(\n                        bytes_to_intlist(json.dumps(data)),\n                        aes_key, iv))).decode('ascii'),\n                    'a': base64.b64encode(encrypted_aeskey).decode('ascii'),\n                }, note='Downloading JSON metadata' + (' (try \n\n            if 'rtn' in init_data:\n                encrypted_rtn = init_data['rtn']\n                break\n\n            self._sleep(5, video_id)\n\n        if encrypted_rtn is None:\n            raise ExtractorError('Failed to fetch init data')\n\n        rtn = self._parse_json(\n            intlist_to_bytes(aes_cbc_decrypt(bytes_to_intlist(\n                compat_b64decode(encrypted_rtn)),\n                aes_key, iv)).decode('utf-8').rstrip('\\0'),\n            video_id)\n\n        title = rtn['title_str']\n\n        formats = self._extract_m3u8_formats(\n            rtn['play_url'], video_id, ext='mp4', entry_protocol='m3u8_native')\n\n        subtitles = {}\n        caption_url = rtn.get('caption_url')\n        if caption_url:\n            \n            subtitles['mul'] = [{\n                'url': caption_url,\n                'ext': 'ttml',\n            }]\n\n        return {\n            'id': video_id,\n            'title': title,\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n\n\nclass DaisukiMottoPlaylistIE(InfoExtractor):\n    _VALID_URL = r'https?://motto\\.daisuki\\.net/(?P<id>information)/'\n\n    _TEST = {\n        'url': 'http://motto.daisuki.net/information/',\n        'info_dict': {\n            'title': 'DRAGON BALL SUPER',\n        },\n        'playlist_mincount': 117,\n    }\n\n    def _real_extract(self, url):\n        playlist_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, playlist_id)\n\n        entries = []\n        for li in re.findall(r'(<li[^>]+?data-product_id=\"[a-zA-Z0-9]{3}\"[^>]+>)', webpage):\n            attr = extract_attributes(li)\n            ad_id = attr.get('data-ad_id')\n            product_id = attr.get('data-product_id')\n            if ad_id and product_id:\n                episode_id = attr.get('data-chapter')\n                entries.append({\n                    '_type': 'url_transparent',\n                    'url': 'http://motto.daisuki.net/framewatch/embed/%s/%s/760/428' % (ad_id, product_id),\n                    'episode_id': episode_id,\n                    'episode_number': int_or_none(episode_id),\n                    'ie_key': 'DaisukiMotto',\n                })\n\n        return self.playlist_result(entries, playlist_title='DRAGON BALL SUPER')\n", "comments": "#117 SHOWDOWN OF LOVE! ANDROIDS VS UNIVERSE 2!!',\n# AES-encrypted HLS stream\n# The public key in PEM format can be found in clientlibs_anime_watch.min.js\n# Some AES keys are rejected. Try it with different AES keys\n#%d)' % (idx + 1) if idx > 0 else ''))\n# mul: multiple languages\n", "content": "from __future__ import unicode_literals\n\nimport base64\nimport json\nimport random\nimport re\n\nfrom .common import InfoExtractor\nfrom ..aes import (\n    aes_cbc_decrypt,\n    aes_cbc_encrypt,\n)\nfrom ..compat import compat_b64decode\nfrom ..utils import (\n    bytes_to_intlist,\n    bytes_to_long,\n    extract_attributes,\n    ExtractorError,\n    intlist_to_bytes,\n    js_to_json,\n    int_or_none,\n    long_to_bytes,\n    pkcs1pad,\n)\n\n\nclass DaisukiMottoIE(InfoExtractor):\n    _VALID_URL = r'https?://motto\\.daisuki\\.net/framewatch/embed/[^/]+/(?P<id>[0-9a-zA-Z]{3})'\n\n    _TEST = {\n        'url': 'http://motto.daisuki.net/framewatch/embed/embedDRAGONBALLSUPERUniverseSurvivalsaga/V2e/760/428',\n        'info_dict': {\n            'id': 'V2e',\n            'ext': 'mp4',\n            'title': '#117 SHOWDOWN OF LOVE! ANDROIDS VS UNIVERSE 2!!',\n            'subtitles': {\n                'mul': [{\n                    'ext': 'ttml',\n                }],\n            },\n        },\n        'params': {\n            'skip_download': True,  # AES-encrypted HLS stream\n        },\n    }\n\n    # The public key in PEM format can be found in clientlibs_anime_watch.min.js\n    _RSA_KEY = (0xc5524c25e8e14b366b3754940beeb6f96cb7e2feef0b932c7659a0c5c3bf173d602464c2df73d693b513ae06ff1be8f367529ab30bf969c5640522181f2a0c51ea546ae120d3d8d908595e4eff765b389cde080a1ef7f1bbfb07411cc568db73b7f521cedf270cbfbe0ddbc29b1ac9d0f2d8f4359098caffee6d07915020077d, 65537)\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id)\n\n        flashvars = self._parse_json(self._search_regex(\n            r'(?s)var\\s+flashvars\\s*=\\s*({.+?});', webpage, 'flashvars'),\n            video_id, transform_source=js_to_json)\n\n        iv = [0] * 16\n\n        data = {}\n        for key in ('device_cd', 'mv_id', 'ss1_prm', 'ss2_prm', 'ss3_prm', 'ss_id'):\n            data[key] = flashvars.get(key, '')\n\n        encrypted_rtn = None\n\n        # Some AES keys are rejected. Try it with different AES keys\n        for idx in range(5):\n            aes_key = [random.randint(0, 254) for _ in range(32)]\n            padded_aeskey = intlist_to_bytes(pkcs1pad(aes_key, 128))\n\n            n, e = self._RSA_KEY\n            encrypted_aeskey = long_to_bytes(pow(bytes_to_long(padded_aeskey), e, n))\n            init_data = self._download_json(\n                'http://motto.daisuki.net/fastAPI/bgn/init/',\n                video_id, query={\n                    's': flashvars.get('s', ''),\n                    'c': flashvars.get('ss3_prm', ''),\n                    'e': url,\n                    'd': base64.b64encode(intlist_to_bytes(aes_cbc_encrypt(\n                        bytes_to_intlist(json.dumps(data)),\n                        aes_key, iv))).decode('ascii'),\n                    'a': base64.b64encode(encrypted_aeskey).decode('ascii'),\n                }, note='Downloading JSON metadata' + (' (try #%d)' % (idx + 1) if idx > 0 else ''))\n\n            if 'rtn' in init_data:\n                encrypted_rtn = init_data['rtn']\n                break\n\n            self._sleep(5, video_id)\n\n        if encrypted_rtn is None:\n            raise ExtractorError('Failed to fetch init data')\n\n        rtn = self._parse_json(\n            intlist_to_bytes(aes_cbc_decrypt(bytes_to_intlist(\n                compat_b64decode(encrypted_rtn)),\n                aes_key, iv)).decode('utf-8').rstrip('\\0'),\n            video_id)\n\n        title = rtn['title_str']\n\n        formats = self._extract_m3u8_formats(\n            rtn['play_url'], video_id, ext='mp4', entry_protocol='m3u8_native')\n\n        subtitles = {}\n        caption_url = rtn.get('caption_url')\n        if caption_url:\n            # mul: multiple languages\n            subtitles['mul'] = [{\n                'url': caption_url,\n                'ext': 'ttml',\n            }]\n\n        return {\n            'id': video_id,\n            'title': title,\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n\n\nclass DaisukiMottoPlaylistIE(InfoExtractor):\n    _VALID_URL = r'https?://motto\\.daisuki\\.net/(?P<id>information)/'\n\n    _TEST = {\n        'url': 'http://motto.daisuki.net/information/',\n        'info_dict': {\n            'title': 'DRAGON BALL SUPER',\n        },\n        'playlist_mincount': 117,\n    }\n\n    def _real_extract(self, url):\n        playlist_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, playlist_id)\n\n        entries = []\n        for li in re.findall(r'(<li[^>]+?data-product_id=\"[a-zA-Z0-9]{3}\"[^>]+>)', webpage):\n            attr = extract_attributes(li)\n            ad_id = attr.get('data-ad_id')\n            product_id = attr.get('data-product_id')\n            if ad_id and product_id:\n                episode_id = attr.get('data-chapter')\n                entries.append({\n                    '_type': 'url_transparent',\n                    'url': 'http://motto.daisuki.net/framewatch/embed/%s/%s/760/428' % (ad_id, product_id),\n                    'episode_id': episode_id,\n                    'episode_number': int_or_none(episode_id),\n                    'ie_key': 'DaisukiMotto',\n                })\n\n        return self.playlist_result(entries, playlist_title='DRAGON BALL SUPER')\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "daisuki.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/daisuki.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}