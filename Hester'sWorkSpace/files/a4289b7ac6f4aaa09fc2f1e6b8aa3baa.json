{"author": "ansible", "code": " (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n\n This file is part of Ansible\n\n Ansible is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Ansible is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\nimport stat\n\nfrom ansible.cli import CLI\nfrom ansible.errors import AnsibleError, AnsibleOptionsError\nfrom ansible.executor.playbook_executor import PlaybookExecutor\nfrom ansible.playbook.block import Block\nfrom ansible.playbook.play_context import PlayContext\n\ntry:\n    from __main__ import display\nexcept ImportError:\n    from ansible.utils.display import Display\n    display = Display()\n\n\nclass PlaybookCLI(CLI):\n    ''' the tool to run *Ansible playbooks*, which are a configuration and multinode deployment system.\n        See the project home page (https://docs.ansible.com) for more information. '''\n\n    def parse(self):\n\n         create parser for CLI options\n        parser = CLI.base_parser(\n            usage=\"%prog [options] playbook.yml [playbook2 ...]\",\n            connect_opts=True,\n            meta_opts=True,\n            runas_opts=True,\n            subset_opts=True,\n            check_opts=True,\n            inventory_opts=True,\n            runtask_opts=True,\n            vault_opts=True,\n            fork_opts=True,\n            module_opts=True,\n            desc=\"Runs Ansible playbooks, executing the defined tasks on the targeted hosts.\",\n        )\n\n         ansible playbook specific opts\n        parser.add_option('--list-tasks', dest='listtasks', action='store_true',\n                          help=\"list all tasks that would be executed\")\n        parser.add_option('--list-tags', dest='listtags', action='store_true',\n                          help=\"list all available tags\")\n        parser.add_option('--step', dest='step', action='store_true',\n                          help=\"one-step-at-a-time: confirm each task before running\")\n        parser.add_option('--start-at-task', dest='start_at_task',\n                          help=\"start the playbook at the task matching this name\")\n\n        self.parser = parser\n        super(PlaybookCLI, self).parse()\n\n        if len(self.args) == 0:\n            raise AnsibleOptionsError(\"You must specify a playbook file to run\")\n\n        display.verbosity = self.options.verbosity\n        self.validate_conflicts(runas_opts=True, vault_opts=True, fork_opts=True)\n\n    def run(self):\n\n        super(PlaybookCLI, self).run()\n\n         Note: slightly wrong, this is written so that implicit localhost\n         Manage passwords\n        sshpass = None\n        becomepass = None\n        passwords = {}\n\n         initial error check, to make sure all specified playbooks are accessible\n         before we start running anything through the playbook executor\n        for playbook in self.args:\n            if not os.path.exists(playbook):\n                raise AnsibleError(\"the playbook: %s could not be found\" % playbook)\n            if not (os.path.isfile(playbook) or stat.S_ISFIFO(os.stat(playbook).st_mode)):\n                raise AnsibleError(\"the playbook: %s does not appear to be a file\" % playbook)\n\n         don't deal with privilege escalation or passwords when we don't need to\n        if not self.options.listhosts and not self.options.listtasks and not self.options.listtags and not self.options.syntax:\n            self.normalize_become_options()\n            (sshpass, becomepass) = self.ask_passwords()\n            passwords = {'conn_pass': sshpass, 'become_pass': becomepass}\n\n        loader, inventory, variable_manager = self._play_prereqs(self.options)\n\n         (which is not returned in list_hosts()) is taken into account for\n         warning if inventory is empty.  But it can't be taken into account for\n         checking if limit doesn't match any hosts.  Instead we don't worry about\n         limit if only implicit localhost was in inventory to start with.\n        \n         Fix this when we rewrite inventory by making localhost a real host (and thus show up in list_hosts())\n        hosts = CLI.get_host_list(inventory, self.options.subset)\n\n         flush fact cache if requested\n        if self.options.flush_cache:\n            self._flush_cache(inventory, variable_manager)\n\n         create the playbook executor, which manages running the plays via a task queue manager\n        pbex = PlaybookExecutor(playbooks=self.args, inventory=inventory, variable_manager=variable_manager, loader=loader, options=self.options,\n                                passwords=passwords)\n\n        results = pbex.run()\n\n        if isinstance(results, list):\n            for p in results:\n\n                display.display('\\nplaybook: %s' % p['playbook'])\n                for idx, play in enumerate(p['plays']):\n                    if play._included_path is not None:\n                        loader.set_basedir(play._included_path)\n                    else:\n                        pb_dir = os.path.realpath(os.path.dirname(p['playbook']))\n                        loader.set_basedir(pb_dir)\n\n                    msg = \"\\n  play %d (%s): %s\" % (idx + 1, ','.join(play.hosts), play.name)\n                    mytags = set(play.tags)\n                    msg += '\\tTAGS: [%s]' % (','.join(mytags))\n\n                    if self.options.listhosts:\n                        playhosts = set(inventory.get_hosts(play.hosts))\n                        msg += \"\\n    pattern: %s\\n    hosts (%d):\" % (play.hosts, len(playhosts))\n                        for host in playhosts:\n                            msg += \"\\n      %s\" % host\n\n                    display.display(msg)\n\n                    all_tags = set()\n                    if self.options.listtags or self.options.listtasks:\n                        taskmsg = ''\n                        if self.options.listtasks:\n                            taskmsg = '    tasks:\\n'\n\n                        def _process_block(b):\n                            taskmsg = ''\n                            for task in b.block:\n                                if isinstance(task, Block):\n                                    taskmsg += _process_block(task)\n                                else:\n                                    if task.action == 'meta':\n                                        continue\n\n                                    all_tags.update(task.tags)\n                                    if self.options.listtasks:\n                                        cur_tags = list(mytags.union(set(task.tags)))\n                                        cur_tags.sort()\n                                        if task.name:\n                                            taskmsg += \"      %s\" % task.get_name()\n                                        else:\n                                            taskmsg += \"      %s\" % task.action\n                                        taskmsg += \"\\tTAGS: [%s]\\n\" % ', '.join(cur_tags)\n\n                            return taskmsg\n\n                        all_vars = variable_manager.get_vars(play=play)\n                        play_context = PlayContext(play=play, options=self.options)\n                        for block in play.compile():\n                            block = block.filter_tagged_tasks(play_context, all_vars)\n                            if not block.has_tasks():\n                                continue\n                            taskmsg += _process_block(block)\n\n                        if self.options.listtags:\n                            cur_tags = list(mytags.union(all_tags))\n                            cur_tags.sort()\n                            taskmsg += \"      TASK TAGS: [%s]\\n\" % ', '.join(cur_tags)\n\n                        display.display(taskmsg)\n\n            return 0\n        else:\n            return results\n\n    def _flush_cache(self, inventory, variable_manager):\n        for host in inventory.list_hosts():\n            hostname = host.get_name()\n            variable_manager.clear_facts(hostname)\n", "comments": "    tool run  ansible playbooks   configuration multinode deployment system          see project home page (https   docs ansible com) information         (c) 2012  michael dehaan  michael dehaan gmail com        this file part ansible       ansible free software  redistribute modify    terms gnu general public license published    free software foundation  either version 3 license     (at option) later version        ansible distributed hope useful     without any warranty  without even implied warranty    merchantability fitness for a particular purpose   see    gnu general public license details        you received copy gnu general public license    along ansible   if  see  http   www gnu org licenses                                                                 create parser cli options    ansible playbook specific opts    note  slightly wrong  written implicit localhost    manage passwords    initial error check  make sure specified playbooks accessible    start running anything playbook executor    deal privilege escalation passwords need    (which returned list hosts()) taken account    warning inventory empty   but taken account    checking limit match hosts   instead worry    limit implicit localhost inventory start        fix rewrite inventory making localhost real host (and thus show list hosts())    flush fact cache requested    create playbook executor  manages running plays via task queue manager    ( s)      (idx   1      join(play hosts)  play name) ", "content": "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n########################################################\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\nimport stat\n\nfrom ansible.cli import CLI\nfrom ansible.errors import AnsibleError, AnsibleOptionsError\nfrom ansible.executor.playbook_executor import PlaybookExecutor\nfrom ansible.playbook.block import Block\nfrom ansible.playbook.play_context import PlayContext\n\ntry:\n    from __main__ import display\nexcept ImportError:\n    from ansible.utils.display import Display\n    display = Display()\n\n\nclass PlaybookCLI(CLI):\n    ''' the tool to run *Ansible playbooks*, which are a configuration and multinode deployment system.\n        See the project home page (https://docs.ansible.com) for more information. '''\n\n    def parse(self):\n\n        # create parser for CLI options\n        parser = CLI.base_parser(\n            usage=\"%prog [options] playbook.yml [playbook2 ...]\",\n            connect_opts=True,\n            meta_opts=True,\n            runas_opts=True,\n            subset_opts=True,\n            check_opts=True,\n            inventory_opts=True,\n            runtask_opts=True,\n            vault_opts=True,\n            fork_opts=True,\n            module_opts=True,\n            desc=\"Runs Ansible playbooks, executing the defined tasks on the targeted hosts.\",\n        )\n\n        # ansible playbook specific opts\n        parser.add_option('--list-tasks', dest='listtasks', action='store_true',\n                          help=\"list all tasks that would be executed\")\n        parser.add_option('--list-tags', dest='listtags', action='store_true',\n                          help=\"list all available tags\")\n        parser.add_option('--step', dest='step', action='store_true',\n                          help=\"one-step-at-a-time: confirm each task before running\")\n        parser.add_option('--start-at-task', dest='start_at_task',\n                          help=\"start the playbook at the task matching this name\")\n\n        self.parser = parser\n        super(PlaybookCLI, self).parse()\n\n        if len(self.args) == 0:\n            raise AnsibleOptionsError(\"You must specify a playbook file to run\")\n\n        display.verbosity = self.options.verbosity\n        self.validate_conflicts(runas_opts=True, vault_opts=True, fork_opts=True)\n\n    def run(self):\n\n        super(PlaybookCLI, self).run()\n\n        # Note: slightly wrong, this is written so that implicit localhost\n        # Manage passwords\n        sshpass = None\n        becomepass = None\n        passwords = {}\n\n        # initial error check, to make sure all specified playbooks are accessible\n        # before we start running anything through the playbook executor\n        for playbook in self.args:\n            if not os.path.exists(playbook):\n                raise AnsibleError(\"the playbook: %s could not be found\" % playbook)\n            if not (os.path.isfile(playbook) or stat.S_ISFIFO(os.stat(playbook).st_mode)):\n                raise AnsibleError(\"the playbook: %s does not appear to be a file\" % playbook)\n\n        # don't deal with privilege escalation or passwords when we don't need to\n        if not self.options.listhosts and not self.options.listtasks and not self.options.listtags and not self.options.syntax:\n            self.normalize_become_options()\n            (sshpass, becomepass) = self.ask_passwords()\n            passwords = {'conn_pass': sshpass, 'become_pass': becomepass}\n\n        loader, inventory, variable_manager = self._play_prereqs(self.options)\n\n        # (which is not returned in list_hosts()) is taken into account for\n        # warning if inventory is empty.  But it can't be taken into account for\n        # checking if limit doesn't match any hosts.  Instead we don't worry about\n        # limit if only implicit localhost was in inventory to start with.\n        #\n        # Fix this when we rewrite inventory by making localhost a real host (and thus show up in list_hosts())\n        hosts = CLI.get_host_list(inventory, self.options.subset)\n\n        # flush fact cache if requested\n        if self.options.flush_cache:\n            self._flush_cache(inventory, variable_manager)\n\n        # create the playbook executor, which manages running the plays via a task queue manager\n        pbex = PlaybookExecutor(playbooks=self.args, inventory=inventory, variable_manager=variable_manager, loader=loader, options=self.options,\n                                passwords=passwords)\n\n        results = pbex.run()\n\n        if isinstance(results, list):\n            for p in results:\n\n                display.display('\\nplaybook: %s' % p['playbook'])\n                for idx, play in enumerate(p['plays']):\n                    if play._included_path is not None:\n                        loader.set_basedir(play._included_path)\n                    else:\n                        pb_dir = os.path.realpath(os.path.dirname(p['playbook']))\n                        loader.set_basedir(pb_dir)\n\n                    msg = \"\\n  play #%d (%s): %s\" % (idx + 1, ','.join(play.hosts), play.name)\n                    mytags = set(play.tags)\n                    msg += '\\tTAGS: [%s]' % (','.join(mytags))\n\n                    if self.options.listhosts:\n                        playhosts = set(inventory.get_hosts(play.hosts))\n                        msg += \"\\n    pattern: %s\\n    hosts (%d):\" % (play.hosts, len(playhosts))\n                        for host in playhosts:\n                            msg += \"\\n      %s\" % host\n\n                    display.display(msg)\n\n                    all_tags = set()\n                    if self.options.listtags or self.options.listtasks:\n                        taskmsg = ''\n                        if self.options.listtasks:\n                            taskmsg = '    tasks:\\n'\n\n                        def _process_block(b):\n                            taskmsg = ''\n                            for task in b.block:\n                                if isinstance(task, Block):\n                                    taskmsg += _process_block(task)\n                                else:\n                                    if task.action == 'meta':\n                                        continue\n\n                                    all_tags.update(task.tags)\n                                    if self.options.listtasks:\n                                        cur_tags = list(mytags.union(set(task.tags)))\n                                        cur_tags.sort()\n                                        if task.name:\n                                            taskmsg += \"      %s\" % task.get_name()\n                                        else:\n                                            taskmsg += \"      %s\" % task.action\n                                        taskmsg += \"\\tTAGS: [%s]\\n\" % ', '.join(cur_tags)\n\n                            return taskmsg\n\n                        all_vars = variable_manager.get_vars(play=play)\n                        play_context = PlayContext(play=play, options=self.options)\n                        for block in play.compile():\n                            block = block.filter_tagged_tasks(play_context, all_vars)\n                            if not block.has_tasks():\n                                continue\n                            taskmsg += _process_block(block)\n\n                        if self.options.listtags:\n                            cur_tags = list(mytags.union(all_tags))\n                            cur_tags.sort()\n                            taskmsg += \"      TASK TAGS: [%s]\\n\" % ', '.join(cur_tags)\n\n                        display.display(taskmsg)\n\n            return 0\n        else:\n            return results\n\n    def _flush_cache(self, inventory, variable_manager):\n        for host in inventory.list_hosts():\n            hostname = host.get_name()\n            variable_manager.clear_facts(hostname)\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "playbook.py", "id": "a4289b7ac6f4aaa09fc2f1e6b8aa3baa", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/cli/playbook.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}