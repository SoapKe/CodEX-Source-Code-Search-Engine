{"author": "tgalal", "code": "from .layer_base import AxolotlBaseLayer\nfrom yowsup.layers import YowLayerEvent, EventCallback\nfrom yowsup.layers.network.layer import YowNetworkLayer\nfrom axolotl.util.keyhelper import KeyHelper\nfrom yowsup.layers.axolotl.protocolentities import *\nfrom yowsup.layers.auth.layer_authentication import YowAuthenticationProtocolLayer\nfrom yowsup.layers.protocol_acks.protocolentities import OutgoingAckProtocolEntity\nfrom axolotl.util.hexutil import HexUtil\nfrom axolotl.ecc.curve import Curve\nimport logging\nimport binascii\nimport sys\n\nlogger = logging.getLogger(__name__)\n\nclass AxolotlControlLayer(AxolotlBaseLayer):\n    _STATE_INIT = 0\n    _STATE_GENKEYS = 1\n    _STATE_HASKEYS = 2\n    _COUNT_PREKEYS = 200\n    EVENT_PREKEYS_SET = \"org.openwhatsapp.yowsup.events.axololt.setkeys\"\n\n    def __init__(self):\n        super(AxolotlControlLayer, self).__init__()\n        self.state = self.__class__._STATE_INIT\n\n    def onNewStoreSet(self, store):\n        super(AxolotlControlLayer, self).onNewStoreSet(store)\n        if store is not None:\n            self.state = self.__class__._STATE_HASKEYS if  store.getLocalRegistrationId() is not None \\\n                else self.__class__._STATE_INIT\n\n    def send(self, node):\n        self.toLower(node)\n\n    def receive(self, protocolTreeNode):\n        \n        if not self.processIqRegistry(protocolTreeNode):\n            if protocolTreeNode.tag == \"notification\" and protocolTreeNode[\"type\"] == \"encrypt\":\n                self.onEncryptNotification(protocolTreeNode)\n                return\n            self.toUpper(protocolTreeNode)\n\n    def isInitState(self):\n        return self.store == None or self.state == self.__class__._STATE_INIT\n\n    def isGenKeysState(self):\n        return self.state == self.__class__._STATE_GENKEYS\n\n\n    def onEncryptNotification(self, protocolTreeNode):\n        entity = EncryptNotification.fromProtocolTreeNode(protocolTreeNode)\n        ack = OutgoingAckProtocolEntity(protocolTreeNode[\"id\"], \"notification\", protocolTreeNode[\"type\"], protocolTreeNode[\"from\"])\n        self.toLower(ack.toProtocolTreeNode())\n        self.sendKeys(fresh=False, countPreKeys = self.__class__._COUNT_PREKEYS - entity.getCount())\n\n    @EventCallback(EVENT_PREKEYS_SET)\n    def onPreKeysSet(self, yowLayerEvent):\n        self.sendKeys(fresh=False)\n\n    @EventCallback(YowNetworkLayer.EVENT_STATE_CONNECTED)\n    def onConnected(self, yowLayerEvent):\n        if self.isInitState():\n            self.setProp(YowAuthenticationProtocolLayer.PROP_PASSIVE, True)\n\n    @EventCallback(YowAuthenticationProtocolLayer.EVENT_AUTHED)\n    def onAuthed(self, yowLayerEvent):\n        if yowLayerEvent.getArg(\"passive\") and self.isInitState():\n            logger.info(\"Axolotl layer is generating keys\")\n            self.sendKeys()\n\n    @EventCallback(YowNetworkLayer.EVENT_STATE_DISCONNECTED)\n    def onDisconnected(self, yowLayerEvent):\n        if self.isGenKeysState():\n            \n            ?\n            self.setProp(YowAuthenticationProtocolLayer.PROP_PASSIVE, False)\n            self.state = self.__class__._STATE_HASKEYS\n            self.getLayerInterface(YowNetworkLayer).connect()\n        else:\n            self.store = None\n    \n    def sendKeys(self, fresh = True, countPreKeys = _COUNT_PREKEYS):\n        identityKeyPair     = KeyHelper.generateIdentityKeyPair() if fresh else self.store.getIdentityKeyPair()\n        registrationId      = KeyHelper.generateRegistrationId() if fresh else self.store.getLocalRegistrationId()\n        preKeys             = KeyHelper.generatePreKeys(KeyHelper.getRandomSequence(), countPreKeys)\n        signedPreKey        = KeyHelper.generateSignedPreKey(identityKeyPair, KeyHelper.getRandomSequence(65536))\n        preKeysDict = {}\n        for preKey in preKeys:\n            keyPair = preKey.getKeyPair()\n            preKeysDict[self.adjustId(preKey.getId())] = self.adjustArray(keyPair.getPublicKey().serialize()[1:])\n\n        signedKeyTuple = (self.adjustId(signedPreKey.getId()),\n                          self.adjustArray(signedPreKey.getKeyPair().getPublicKey().serialize()[1:]),\n                          self.adjustArray(signedPreKey.getSignature()))\n\n        setKeysIq = SetKeysIqProtocolEntity(self.adjustArray(identityKeyPair.getPublicKey().serialize()[1:]), signedKeyTuple, preKeysDict, Curve.DJB_TYPE, self.adjustId(registrationId))\n\n        onResult = lambda _, __: self.persistKeys(registrationId, identityKeyPair, preKeys, signedPreKey, fresh)\n        self._sendIq(setKeysIq, onResult, self.onSentKeysError)\n\n    def persistKeys(self, registrationId, identityKeyPair, preKeys, signedPreKey, fresh):\n        total = len(preKeys)\n        curr = 0\n        prevPercentage = 0\n\n        if fresh:\n            self.store.storeLocalData(registrationId, identityKeyPair)\n        self.store.storeSignedPreKey(signedPreKey.getId(), signedPreKey)\n\n        for preKey in preKeys:\n            self.store.storePreKey(preKey.getId(), preKey)\n            curr += 1\n            currPercentage = int((curr * 100) / total)\n            if currPercentage == prevPercentage:\n                continue\n            prevPercentage = currPercentage\n            #logger.debug(\"%s\" % currPercentage + \"%\")\n            sys.stdout.write(\"Storing prekeys %d%% \\r\" % (currPercentage))\n            sys.stdout.flush()\n\n        if fresh:\n            self.state = self.__class__._STATE_GENKEYS\n            self.broadcastEvent(YowLayerEvent(YowNetworkLayer.EVENT_STATE_DISCONNECT))\n\n    def onSentKeysError(self, errorNode, keysEntity):\n        raise Exception(\"Sent keys were not accepted\")\n\n    def adjustArray(self, arr):\n        return HexUtil.decodeHex(binascii.hexlify(arr))\n\n    def adjustId(self, _id):\n        _id = format(_id, 'x')\n        zfiller = len(_id) if len(_id) % 2 == 0 else len(_id) + 1\n        _id = _id.zfill(zfiller if zfiller > 6 else 6)\n        # if len(_id) % 2:\n        #     _id = \"0\" + _id\n        return binascii.unhexlify(_id)\n", "comments": "             type protocoltreenode  protocoltreenode               requested disconnect layer switch passive   need traverse upper layers       keys set get   logger debug(     currpercentage      )    len( id)   2          id    0     id ", "content": "from .layer_base import AxolotlBaseLayer\nfrom yowsup.layers import YowLayerEvent, EventCallback\nfrom yowsup.layers.network.layer import YowNetworkLayer\nfrom axolotl.util.keyhelper import KeyHelper\nfrom yowsup.layers.axolotl.protocolentities import *\nfrom yowsup.layers.auth.layer_authentication import YowAuthenticationProtocolLayer\nfrom yowsup.layers.protocol_acks.protocolentities import OutgoingAckProtocolEntity\nfrom axolotl.util.hexutil import HexUtil\nfrom axolotl.ecc.curve import Curve\nimport logging\nimport binascii\nimport sys\n\nlogger = logging.getLogger(__name__)\n\nclass AxolotlControlLayer(AxolotlBaseLayer):\n    _STATE_INIT = 0\n    _STATE_GENKEYS = 1\n    _STATE_HASKEYS = 2\n    _COUNT_PREKEYS = 200\n    EVENT_PREKEYS_SET = \"org.openwhatsapp.yowsup.events.axololt.setkeys\"\n\n    def __init__(self):\n        super(AxolotlControlLayer, self).__init__()\n        self.state = self.__class__._STATE_INIT\n\n    def onNewStoreSet(self, store):\n        super(AxolotlControlLayer, self).onNewStoreSet(store)\n        if store is not None:\n            self.state = self.__class__._STATE_HASKEYS if  store.getLocalRegistrationId() is not None \\\n                else self.__class__._STATE_INIT\n\n    def send(self, node):\n        self.toLower(node)\n\n    def receive(self, protocolTreeNode):\n        \"\"\"\n        :type protocolTreeNode: ProtocolTreeNode\n        \"\"\"\n        if not self.processIqRegistry(protocolTreeNode):\n            if protocolTreeNode.tag == \"notification\" and protocolTreeNode[\"type\"] == \"encrypt\":\n                self.onEncryptNotification(protocolTreeNode)\n                return\n            self.toUpper(protocolTreeNode)\n\n    def isInitState(self):\n        return self.store == None or self.state == self.__class__._STATE_INIT\n\n    def isGenKeysState(self):\n        return self.state == self.__class__._STATE_GENKEYS\n\n\n    def onEncryptNotification(self, protocolTreeNode):\n        entity = EncryptNotification.fromProtocolTreeNode(protocolTreeNode)\n        ack = OutgoingAckProtocolEntity(protocolTreeNode[\"id\"], \"notification\", protocolTreeNode[\"type\"], protocolTreeNode[\"from\"])\n        self.toLower(ack.toProtocolTreeNode())\n        self.sendKeys(fresh=False, countPreKeys = self.__class__._COUNT_PREKEYS - entity.getCount())\n\n    @EventCallback(EVENT_PREKEYS_SET)\n    def onPreKeysSet(self, yowLayerEvent):\n        self.sendKeys(fresh=False)\n\n    @EventCallback(YowNetworkLayer.EVENT_STATE_CONNECTED)\n    def onConnected(self, yowLayerEvent):\n        if self.isInitState():\n            self.setProp(YowAuthenticationProtocolLayer.PROP_PASSIVE, True)\n\n    @EventCallback(YowAuthenticationProtocolLayer.EVENT_AUTHED)\n    def onAuthed(self, yowLayerEvent):\n        if yowLayerEvent.getArg(\"passive\") and self.isInitState():\n            logger.info(\"Axolotl layer is generating keys\")\n            self.sendKeys()\n\n    @EventCallback(YowNetworkLayer.EVENT_STATE_DISCONNECTED)\n    def onDisconnected(self, yowLayerEvent):\n        if self.isGenKeysState():\n            #we requested this disconnect in this layer to switch off passive\n            #no need to traverse it to upper layers?\n            self.setProp(YowAuthenticationProtocolLayer.PROP_PASSIVE, False)\n            self.state = self.__class__._STATE_HASKEYS\n            self.getLayerInterface(YowNetworkLayer).connect()\n        else:\n            self.store = None\n    ### keys set and get\n    def sendKeys(self, fresh = True, countPreKeys = _COUNT_PREKEYS):\n        identityKeyPair     = KeyHelper.generateIdentityKeyPair() if fresh else self.store.getIdentityKeyPair()\n        registrationId      = KeyHelper.generateRegistrationId() if fresh else self.store.getLocalRegistrationId()\n        preKeys             = KeyHelper.generatePreKeys(KeyHelper.getRandomSequence(), countPreKeys)\n        signedPreKey        = KeyHelper.generateSignedPreKey(identityKeyPair, KeyHelper.getRandomSequence(65536))\n        preKeysDict = {}\n        for preKey in preKeys:\n            keyPair = preKey.getKeyPair()\n            preKeysDict[self.adjustId(preKey.getId())] = self.adjustArray(keyPair.getPublicKey().serialize()[1:])\n\n        signedKeyTuple = (self.adjustId(signedPreKey.getId()),\n                          self.adjustArray(signedPreKey.getKeyPair().getPublicKey().serialize()[1:]),\n                          self.adjustArray(signedPreKey.getSignature()))\n\n        setKeysIq = SetKeysIqProtocolEntity(self.adjustArray(identityKeyPair.getPublicKey().serialize()[1:]), signedKeyTuple, preKeysDict, Curve.DJB_TYPE, self.adjustId(registrationId))\n\n        onResult = lambda _, __: self.persistKeys(registrationId, identityKeyPair, preKeys, signedPreKey, fresh)\n        self._sendIq(setKeysIq, onResult, self.onSentKeysError)\n\n    def persistKeys(self, registrationId, identityKeyPair, preKeys, signedPreKey, fresh):\n        total = len(preKeys)\n        curr = 0\n        prevPercentage = 0\n\n        if fresh:\n            self.store.storeLocalData(registrationId, identityKeyPair)\n        self.store.storeSignedPreKey(signedPreKey.getId(), signedPreKey)\n\n        for preKey in preKeys:\n            self.store.storePreKey(preKey.getId(), preKey)\n            curr += 1\n            currPercentage = int((curr * 100) / total)\n            if currPercentage == prevPercentage:\n                continue\n            prevPercentage = currPercentage\n            #logger.debug(\"%s\" % currPercentage + \"%\")\n            sys.stdout.write(\"Storing prekeys %d%% \\r\" % (currPercentage))\n            sys.stdout.flush()\n\n        if fresh:\n            self.state = self.__class__._STATE_GENKEYS\n            self.broadcastEvent(YowLayerEvent(YowNetworkLayer.EVENT_STATE_DISCONNECT))\n\n    def onSentKeysError(self, errorNode, keysEntity):\n        raise Exception(\"Sent keys were not accepted\")\n\n    def adjustArray(self, arr):\n        return HexUtil.decodeHex(binascii.hexlify(arr))\n\n    def adjustId(self, _id):\n        _id = format(_id, 'x')\n        zfiller = len(_id) if len(_id) % 2 == 0 else len(_id) + 1\n        _id = _id.zfill(zfiller if zfiller > 6 else 6)\n        # if len(_id) % 2:\n        #     _id = \"0\" + _id\n        return binascii.unhexlify(_id)\n", "description": "The python WhatsApp library", "file_name": "layer_control.py", "id": "e41b3bca98afd970740bd1b34276d114", "language": "Python", "project_name": "yowsup", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tgalal-yowsup/tgalal-yowsup-03795cc/yowsup/layers/axolotl/layer_control.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:01:40Z", "url": "https://github.com/tgalal/yowsup", "wiki": true}