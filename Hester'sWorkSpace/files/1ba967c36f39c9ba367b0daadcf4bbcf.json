{"author": "tensorflow", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\"\"\"Create a dataset of SequenceExamples from NoteSequence protos.\n\nThis script will extract pianoroll tracks from NoteSequence protos and save\nthem to TensorFlow's SequenceExample protos for input to the RNN-NADE models.\n\"\"\"\n\nimport os\n\n internal imports\n\nimport tensorflow as tf\n\nfrom magenta.models.pianoroll_rnn_nade import pianoroll_rnn_nade_model\nimport magenta.music as mm\nfrom magenta.pipelines import dag_pipeline\nfrom magenta.pipelines import note_sequence_pipelines\nfrom magenta.pipelines import pipeline\nfrom magenta.pipelines import pipelines_common\nfrom magenta.protobuf import music_pb2\n\nFLAGS = tf.app.flags.FLAGS\ntf.app.flags.DEFINE_string('input', None,\n                           'TFRecord to read NoteSequence protos from.')\ntf.app.flags.DEFINE_string('output_dir', None,\n                           'Directory to write training and eval TFRecord '\n                           'files. The TFRecord files are populated with '\n                           'SequenceExample protos.')\ntf.app.flags.DEFINE_float('eval_ratio', 0.1,\n                          'Fraction of input to set aside for eval set. '\n                          'Partition is randomly selected.')\ntf.app.flags.DEFINE_string('config', 'rnn-nade',\n                           'Which config to use.')\ntf.app.flags.DEFINE_string('log', 'INFO',\n                           'The threshold for what messages will be logged '\n                           'DEBUG, INFO, WARN, ERROR, or FATAL.')\n\n\nclass PianorollSequenceExtractor(pipeline.Pipeline):\n  \"\"\"Extracts pianoroll tracks from a quantized NoteSequence.\"\"\"\n\n  def __init__(self, min_steps, max_steps, name=None):\n    super(PianorollSequenceExtractor, self).__init__(\n        input_type=music_pb2.NoteSequence,\n        output_type=mm.PianorollSequence,\n        name=name)\n    self._min_steps = min_steps\n    self._max_steps = max_steps\n\n  def transform(self, quantized_sequence):\n    pianoroll_seqs, stats = mm.extract_pianoroll_sequences(\n        quantized_sequence,\n        min_steps_discard=self._min_steps,\n        max_steps_truncate=self._max_steps)\n    self._set_stats(stats)\n    return pianoroll_seqs\n\n\ndef get_pipeline(config, min_steps, max_steps, eval_ratio):\n  \"\"\"Returns the Pipeline instance which creates the RNN dataset.\n\n  Args:\n    config: An EventSequenceRnnConfig.\n    min_steps: Minimum number of steps for an extracted sequence.\n    max_steps: Maximum number of steps for an extracted sequence.\n    eval_ratio: Fraction of input to set aside for evaluation set.\n\n  Returns:\n    A pipeline.Pipeline instance.\n  \"\"\"\n   Transpose up to a major third in either direction.\n  transposition_range = range(-4, 5)\n\n  partitioner = pipelines_common.RandomPartition(\n      music_pb2.NoteSequence,\n      ['eval_pianoroll_tracks', 'training_pianoroll_tracks'],\n      [eval_ratio])\n  dag = {partitioner: dag_pipeline.DagInput(music_pb2.NoteSequence)}\n\n  for mode in ['eval', 'training']:\n    time_change_splitter = note_sequence_pipelines.TimeChangeSplitter(\n        name='TimeChangeSplitter_' + mode)\n    quantizer = note_sequence_pipelines.Quantizer(\n        steps_per_quarter=config.steps_per_quarter, name='Quantizer_' + mode)\n    transposition_pipeline = note_sequence_pipelines.TranspositionPipeline(\n        transposition_range, name='TranspositionPipeline_' + mode)\n    pianoroll_extractor = PianorollSequenceExtractor(\n        min_steps=min_steps, max_steps=max_steps,\n        name='PianorollExtractor_' + mode)\n    encoder_pipeline = mm.EncoderPipeline(\n        mm.PianorollSequence, config.encoder_decoder,\n        name='EncoderPipeline_' + mode)\n\n    dag[time_change_splitter] = partitioner[mode + '_pianoroll_tracks']\n    dag[quantizer] = time_change_splitter\n    dag[transposition_pipeline] = quantizer\n    dag[pianoroll_extractor] = transposition_pipeline\n    dag[encoder_pipeline] = pianoroll_extractor\n    dag[dag_pipeline.DagOutput(mode + '_pianoroll_tracks')] = encoder_pipeline\n\n  return dag_pipeline.DAGPipeline(dag)\n\n\ndef main(unused_argv):\n  tf.logging.set_verbosity(FLAGS.log)\n\n  pipeline_instance = get_pipeline(\n      min_steps=80,   5 measures\n      max_steps=2048,\n      eval_ratio=FLAGS.eval_ratio,\n      config=pianoroll_rnn_nade_model.default_configs[FLAGS.config])\n\n  input_dir = os.path.expanduser(FLAGS.input)\n  output_dir = os.path.expanduser(FLAGS.output_dir)\n  pipeline.run_pipeline_serial(\n      pipeline_instance,\n      pipeline.tf_record_iterator(input_dir, pipeline_instance.input_type),\n      output_dir)\n\n\ndef console_entry_point():\n  tf.app.run(main)\n\n\nif __name__ == '__main__':\n  console_entry_point()\n", "comments": "   create dataset sequenceexamples notesequence protos   this script extract pianoroll tracks notesequence protos save tensorflow sequenceexample protos input rnn nade models       import os    internal imports  import tensorflow tf  magenta models pianoroll rnn nade import pianoroll rnn nade model import magenta music mm magenta pipelines import dag pipeline magenta pipelines import note sequence pipelines magenta pipelines import pipeline magenta pipelines import pipelines common magenta protobuf import music pb2  flags   tf app flags flags tf app flags define string( input   none                              tfrecord read notesequence protos  ) tf app flags define string( output dir   none                              directory write training eval tfrecord                               files  the tfrecord files populated                               sequenceexample protos  ) tf app flags define float( eval ratio   0 1                             fraction input set aside eval set                               partition randomly selected  ) tf app flags define string( config    rnn nade                               which config use  ) tf app flags define string( log    info                               the threshold messages logged                               debug  info  warn  error  fatal  )   class pianorollsequenceextractor(pipeline pipeline)       extracts pianoroll tracks quantized notesequence        def   init  (self  min steps  max steps  name none)      super(pianorollsequenceextractor  self)   init  (         input type music pb2 notesequence          output type mm pianorollsequence          name name)     self  min steps   min steps     self  max steps   max steps    def transform(self  quantized sequence)      pianoroll seqs  stats   mm extract pianoroll sequences(         quantized sequence          min steps discard self  min steps          max steps truncate self  max steps)     self  set stats(stats)     return pianoroll seqs   def get pipeline(config  min steps  max steps  eval ratio)       returns pipeline instance creates rnn dataset     args      config  an eventsequencernnconfig      min steps  minimum number steps extracted sequence      max steps  maximum number steps extracted sequence      eval ratio  fraction input set aside evaluation set     returns      a pipeline pipeline instance           copyright 2017 google inc  all rights reserved        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license          http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license     internal imports    transpose major third either direction     5 measures ", "content": "# Copyright 2017 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Create a dataset of SequenceExamples from NoteSequence protos.\n\nThis script will extract pianoroll tracks from NoteSequence protos and save\nthem to TensorFlow's SequenceExample protos for input to the RNN-NADE models.\n\"\"\"\n\nimport os\n\n# internal imports\n\nimport tensorflow as tf\n\nfrom magenta.models.pianoroll_rnn_nade import pianoroll_rnn_nade_model\nimport magenta.music as mm\nfrom magenta.pipelines import dag_pipeline\nfrom magenta.pipelines import note_sequence_pipelines\nfrom magenta.pipelines import pipeline\nfrom magenta.pipelines import pipelines_common\nfrom magenta.protobuf import music_pb2\n\nFLAGS = tf.app.flags.FLAGS\ntf.app.flags.DEFINE_string('input', None,\n                           'TFRecord to read NoteSequence protos from.')\ntf.app.flags.DEFINE_string('output_dir', None,\n                           'Directory to write training and eval TFRecord '\n                           'files. The TFRecord files are populated with '\n                           'SequenceExample protos.')\ntf.app.flags.DEFINE_float('eval_ratio', 0.1,\n                          'Fraction of input to set aside for eval set. '\n                          'Partition is randomly selected.')\ntf.app.flags.DEFINE_string('config', 'rnn-nade',\n                           'Which config to use.')\ntf.app.flags.DEFINE_string('log', 'INFO',\n                           'The threshold for what messages will be logged '\n                           'DEBUG, INFO, WARN, ERROR, or FATAL.')\n\n\nclass PianorollSequenceExtractor(pipeline.Pipeline):\n  \"\"\"Extracts pianoroll tracks from a quantized NoteSequence.\"\"\"\n\n  def __init__(self, min_steps, max_steps, name=None):\n    super(PianorollSequenceExtractor, self).__init__(\n        input_type=music_pb2.NoteSequence,\n        output_type=mm.PianorollSequence,\n        name=name)\n    self._min_steps = min_steps\n    self._max_steps = max_steps\n\n  def transform(self, quantized_sequence):\n    pianoroll_seqs, stats = mm.extract_pianoroll_sequences(\n        quantized_sequence,\n        min_steps_discard=self._min_steps,\n        max_steps_truncate=self._max_steps)\n    self._set_stats(stats)\n    return pianoroll_seqs\n\n\ndef get_pipeline(config, min_steps, max_steps, eval_ratio):\n  \"\"\"Returns the Pipeline instance which creates the RNN dataset.\n\n  Args:\n    config: An EventSequenceRnnConfig.\n    min_steps: Minimum number of steps for an extracted sequence.\n    max_steps: Maximum number of steps for an extracted sequence.\n    eval_ratio: Fraction of input to set aside for evaluation set.\n\n  Returns:\n    A pipeline.Pipeline instance.\n  \"\"\"\n  # Transpose up to a major third in either direction.\n  transposition_range = range(-4, 5)\n\n  partitioner = pipelines_common.RandomPartition(\n      music_pb2.NoteSequence,\n      ['eval_pianoroll_tracks', 'training_pianoroll_tracks'],\n      [eval_ratio])\n  dag = {partitioner: dag_pipeline.DagInput(music_pb2.NoteSequence)}\n\n  for mode in ['eval', 'training']:\n    time_change_splitter = note_sequence_pipelines.TimeChangeSplitter(\n        name='TimeChangeSplitter_' + mode)\n    quantizer = note_sequence_pipelines.Quantizer(\n        steps_per_quarter=config.steps_per_quarter, name='Quantizer_' + mode)\n    transposition_pipeline = note_sequence_pipelines.TranspositionPipeline(\n        transposition_range, name='TranspositionPipeline_' + mode)\n    pianoroll_extractor = PianorollSequenceExtractor(\n        min_steps=min_steps, max_steps=max_steps,\n        name='PianorollExtractor_' + mode)\n    encoder_pipeline = mm.EncoderPipeline(\n        mm.PianorollSequence, config.encoder_decoder,\n        name='EncoderPipeline_' + mode)\n\n    dag[time_change_splitter] = partitioner[mode + '_pianoroll_tracks']\n    dag[quantizer] = time_change_splitter\n    dag[transposition_pipeline] = quantizer\n    dag[pianoroll_extractor] = transposition_pipeline\n    dag[encoder_pipeline] = pianoroll_extractor\n    dag[dag_pipeline.DagOutput(mode + '_pianoroll_tracks')] = encoder_pipeline\n\n  return dag_pipeline.DAGPipeline(dag)\n\n\ndef main(unused_argv):\n  tf.logging.set_verbosity(FLAGS.log)\n\n  pipeline_instance = get_pipeline(\n      min_steps=80,  # 5 measures\n      max_steps=2048,\n      eval_ratio=FLAGS.eval_ratio,\n      config=pianoroll_rnn_nade_model.default_configs[FLAGS.config])\n\n  input_dir = os.path.expanduser(FLAGS.input)\n  output_dir = os.path.expanduser(FLAGS.output_dir)\n  pipeline.run_pipeline_serial(\n      pipeline_instance,\n      pipeline.tf_record_iterator(input_dir, pipeline_instance.input_type),\n      output_dir)\n\n\ndef console_entry_point():\n  tf.app.run(main)\n\n\nif __name__ == '__main__':\n  console_entry_point()\n", "description": "Magenta: Music and Art Generation with Machine Intelligence", "file_name": "pianoroll_rnn_nade_create_dataset.py", "id": "1ba967c36f39c9ba367b0daadcf4bbcf", "language": "Python", "project_name": "magenta", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/tensorflow-magenta/tensorflow-magenta-c3eda3d/magenta/models/pianoroll_rnn_nade/pianoroll_rnn_nade_create_dataset.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:52:33Z", "url": "https://github.com/tensorflow/magenta", "wiki": false}