{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport collections\nimport io\nimport zlib\n\nfrom .compat import (\n    compat_str,\n    compat_struct_unpack,\n)\nfrom .utils import (\n    ExtractorError,\n)\n\n\ndef _extract_tags(file_contents):\n    if file_contents[1:3] != b'WS':\n        raise ExtractorError(\n            'Not an SWF file; header is %r' % file_contents[:3])\n    if file_contents[:1] == b'C':\n        content = zlib.decompress(file_contents[8:])\n    else:\n        raise NotImplementedError(\n            'Unsupported compression format %r' %\n            file_contents[:1])\n\n    \n    framesize_nbits = compat_struct_unpack('!B', content[:1])[0] >> 3\n    framesize_len = (5 + 4 * framesize_nbits + 7) // 8\n\n    pos = framesize_len + 2 + 2\n    while pos < len(content):\n        header16 = compat_struct_unpack('<H', content[pos:pos + 2])[0]\n        pos += 2\n        tag_code = header16 >> 6\n        tag_len = header16 & 0x3f\n        if tag_len == 0x3f:\n            tag_len = compat_struct_unpack('<I', content[pos:pos + 4])[0]\n            pos += 4\n        assert pos + tag_len <= len(content), \\\n            ('Tag %d ends at %d+%d - that\\'s longer than the file (%d)'\n                % (tag_code, pos, tag_len, len(content)))\n        yield (tag_code, content[pos:pos + tag_len])\n        pos += tag_len\n\n\nclass _AVMClass_Object(object):\n    def __init__(self, avm_class):\n        self.avm_class = avm_class\n\n    def __repr__(self):\n        return '%s\n\n\nclass _ScopeDict(dict):\n    def __init__(self, avm_class):\n        super(_ScopeDict, self).__init__()\n        self.avm_class = avm_class\n\n    def __repr__(self):\n        return '%s__Scope(%s)' % (\n            self.avm_class.name,\n            super(_ScopeDict, self).__repr__())\n\n\nclass _AVMClass(object):\n    def __init__(self, name_idx, name, static_properties=None):\n        self.name_idx = name_idx\n        self.name = name\n        self.method_names = {}\n        self.method_idxs = {}\n        self.methods = {}\n        self.method_pyfunctions = {}\n        self.static_properties = static_properties if static_properties else {}\n\n        self.variables = _ScopeDict(self)\n        self.constants = {}\n\n    def make_object(self):\n        return _AVMClass_Object(self)\n\n    def __repr__(self):\n        return '_AVMClass(%s)' % (self.name)\n\n    def register_methods(self, methods):\n        self.method_names.update(methods.items())\n        self.method_idxs.update(dict(\n            (idx, name)\n            for name, idx in methods.items()))\n\n\nclass _Multiname(object):\n    def __init__(self, kind):\n        self.kind = kind\n\n    def __repr__(self):\n        return '[MULTINAME kind: 0x%x]' % self.kind\n\n\ndef _read_int(reader):\n    res = 0\n    shift = 0\n    for _ in range(5):\n        buf = reader.read(1)\n        assert len(buf) == 1\n        b = compat_struct_unpack('<B', buf)[0]\n        res = res | ((b & 0x7f) << shift)\n        if b & 0x80 == 0:\n            break\n        shift += 7\n    return res\n\n\ndef _u30(reader):\n    res = _read_int(reader)\n    assert res & 0xf0000000 == 0\n    return res\n\n\n_u32 = _read_int\n\n\ndef _s32(reader):\n    v = _read_int(reader)\n    if v & 0x80000000 != 0:\n        v = - ((v ^ 0xffffffff) + 1)\n    return v\n\n\ndef _s24(reader):\n    bs = reader.read(3)\n    assert len(bs) == 3\n    last_byte = b'\\xff' if (ord(bs[2:3]) >= 0x80) else b'\\x00'\n    return compat_struct_unpack('<i', bs + last_byte)[0]\n\n\ndef _read_string(reader):\n    slen = _u30(reader)\n    resb = reader.read(slen)\n    assert len(resb) == slen\n    return resb.decode('utf-8')\n\n\ndef _read_bytes(count, reader):\n    assert count >= 0\n    resb = reader.read(count)\n    assert len(resb) == count\n    return resb\n\n\ndef _read_byte(reader):\n    resb = _read_bytes(1, reader=reader)\n    res = compat_struct_unpack('<B', resb)[0]\n    return res\n\n\nStringClass = _AVMClass('(no name idx)', 'String')\nByteArrayClass = _AVMClass('(no name idx)', 'ByteArray')\nTimerClass = _AVMClass('(no name idx)', 'Timer')\nTimerEventClass = _AVMClass('(no name idx)', 'TimerEvent', {'TIMER': 'timer'})\n_builtin_classes = {\n    StringClass.name: StringClass,\n    ByteArrayClass.name: ByteArrayClass,\n    TimerClass.name: TimerClass,\n    TimerEventClass.name: TimerEventClass,\n}\n\n\nclass _Undefined(object):\n    def __bool__(self):\n        return False\n    __nonzero__ = __bool__\n\n    def __hash__(self):\n        return 0\n\n    def __str__(self):\n        return 'undefined'\n    __repr__ = __str__\n\n\nundefined = _Undefined()\n\n\nclass SWFInterpreter(object):\n    def __init__(self, file_contents):\n        self._patched_functions = {\n            (TimerClass, 'addEventListener'): lambda params: undefined,\n        }\n        code_tag = next(tag\n                        for tag_code, tag in _extract_tags(file_contents)\n                        if tag_code == 82)\n        p = code_tag.index(b'\\0', 4) + 1\n        code_reader = io.BytesIO(code_tag[p:])\n\n        \n\n        \n        u30 = lambda *args: _u30(*args, reader=code_reader)\n        s32 = lambda *args: _s32(*args, reader=code_reader)\n        u32 = lambda *args: _u32(*args, reader=code_reader)\n        read_bytes = lambda *args: _read_bytes(*args, reader=code_reader)\n        read_byte = lambda *args: _read_byte(*args, reader=code_reader)\n\n        \n        read_bytes(2 + 2)\n\n        \n        int_count = u30()\n        self.constant_ints = [0]\n        for _c in range(1, int_count):\n            self.constant_ints.append(s32())\n        self.constant_uints = [0]\n        uint_count = u30()\n        for _c in range(1, uint_count):\n            self.constant_uints.append(u32())\n        double_count = u30()\n        read_bytes(max(0, (double_count - 1)) * 8)\n        string_count = u30()\n        self.constant_strings = ['']\n        for _c in range(1, string_count):\n            s = _read_string(code_reader)\n            self.constant_strings.append(s)\n        namespace_count = u30()\n        for _c in range(1, namespace_count):\n            read_bytes(1)  \n            u30()  \n        ns_set_count = u30()\n        for _c in range(1, ns_set_count):\n            count = u30()\n            for _c2 in range(count):\n                u30()\n        multiname_count = u30()\n        MULTINAME_SIZES = {\n            0x07: 2,  \n            0x0d: 2,  \n            0x0f: 1,  \n            0x10: 1,  \n            0x11: 0,  \n            0x12: 0,  \n            0x09: 2,  \n            0x0e: 2,  \n            0x1b: 1,  \n            0x1c: 1,  \n        }\n        self.multinames = ['']\n        for _c in range(1, multiname_count):\n            kind = u30()\n            assert kind in MULTINAME_SIZES, 'Invalid multiname kind %r' % kind\n            if kind == 0x07:\n                u30()  \n                name_idx = u30()\n                self.multinames.append(self.constant_strings[name_idx])\n            elif kind == 0x09:\n                name_idx = u30()\n                u30()\n                self.multinames.append(self.constant_strings[name_idx])\n            else:\n                self.multinames.append(_Multiname(kind))\n                for _c2 in range(MULTINAME_SIZES[kind]):\n                    u30()\n\n        \n        method_count = u30()\n        MethodInfo = collections.namedtuple(\n            'MethodInfo',\n            ['NEED_ARGUMENTS', 'NEED_REST'])\n        method_infos = []\n        for method_id in range(method_count):\n            param_count = u30()\n            u30()  \n            for _ in range(param_count):\n                u30()  \n            u30()  \n            flags = read_byte()\n            if flags & 0x08 != 0:\n                \n                option_count = u30()\n                for c in range(option_count):\n                    u30()  \n                    read_bytes(1)  \n            if flags & 0x80 != 0:\n                \n                for _ in range(param_count):\n                    u30()  \n            mi = MethodInfo(flags & 0x01 != 0, flags & 0x04 != 0)\n            method_infos.append(mi)\n\n        \n        metadata_count = u30()\n        for _c in range(metadata_count):\n            u30()  \n            item_count = u30()\n            for _c2 in range(item_count):\n                u30()  \n                u30()  \n\n        def parse_traits_info():\n            trait_name_idx = u30()\n            kind_full = read_byte()\n            kind = kind_full & 0x0f\n            attrs = kind_full >> 4\n            methods = {}\n            constants = None\n            if kind == 0x00:  \n                u30()  \n                u30()  \n                vindex = u30()\n                if vindex != 0:\n                    read_byte()  \n            elif kind == 0x06:  \n                u30()  \n                u30()  \n                vindex = u30()\n                vkind = 'any'\n                if vindex != 0:\n                    vkind = read_byte()\n                if vkind == 0x03:  \n                    value = self.constant_ints[vindex]\n                elif vkind == 0x04:  \n                    value = self.constant_uints[vindex]\n                else:\n                    return {}, None  \n                constants = {self.multinames[trait_name_idx]: value}\n            elif kind in (0x01, 0x02, 0x03):  \n                u30()  \n                method_idx = u30()\n                methods[self.multinames[trait_name_idx]] = method_idx\n            elif kind == 0x04:  \n                u30()  \n                u30()  \n            elif kind == 0x05:  \n                u30()  \n                function_idx = u30()\n                methods[function_idx] = self.multinames[trait_name_idx]\n            else:\n                raise ExtractorError('Unsupported trait kind %d' % kind)\n\n            if attrs & 0x4 != 0:  \n                metadata_count = u30()\n                for _c3 in range(metadata_count):\n                    u30()  \n\n            return methods, constants\n\n        \n        class_count = u30()\n        classes = []\n        for class_id in range(class_count):\n            name_idx = u30()\n\n            cname = self.multinames[name_idx]\n            avm_class = _AVMClass(name_idx, cname)\n            classes.append(avm_class)\n\n            u30()  \n            flags = read_byte()\n            if flags & 0x08 != 0:  \n                u30()  \n            intrf_count = u30()\n            for _c2 in range(intrf_count):\n                u30()\n            u30()  \n            trait_count = u30()\n            for _c2 in range(trait_count):\n                trait_methods, trait_constants = parse_traits_info()\n                avm_class.register_methods(trait_methods)\n                if trait_constants:\n                    avm_class.constants.update(trait_constants)\n\n        assert len(classes) == class_count\n        self._classes_by_name = dict((c.name, c) for c in classes)\n\n        for avm_class in classes:\n            avm_class.cinit_idx = u30()\n            trait_count = u30()\n            for _c2 in range(trait_count):\n                trait_methods, trait_constants = parse_traits_info()\n                avm_class.register_methods(trait_methods)\n                if trait_constants:\n                    avm_class.constants.update(trait_constants)\n\n        \n        script_count = u30()\n        for _c in range(script_count):\n            u30()  \n            trait_count = u30()\n            for _c2 in range(trait_count):\n                parse_traits_info()\n\n        \n        method_body_count = u30()\n        Method = collections.namedtuple('Method', ['code', 'local_count'])\n        self._all_methods = []\n        for _c in range(method_body_count):\n            method_idx = u30()\n            u30()  \n            local_count = u30()\n            u30()  \n            u30()  \n            code_length = u30()\n            code = read_bytes(code_length)\n            m = Method(code, local_count)\n            self._all_methods.append(m)\n            for avm_class in classes:\n                if method_idx in avm_class.method_idxs:\n                    avm_class.methods[avm_class.method_idxs[method_idx]] = m\n            exception_count = u30()\n            for _c2 in range(exception_count):\n                u30()  \n                u30()  \n                u30()  \n                u30()  \n                u30()  \n            trait_count = u30()\n            for _c2 in range(trait_count):\n                parse_traits_info()\n\n        assert p + code_reader.tell() == len(code_tag)\n\n    def patch_function(self, avm_class, func_name, f):\n        self._patched_functions[(avm_class, func_name)] = f\n\n    def extract_class(self, class_name, call_cinit=True):\n        try:\n            res = self._classes_by_name[class_name]\n        except KeyError:\n            raise ExtractorError('Class %r not found' % class_name)\n\n        if call_cinit and hasattr(res, 'cinit_idx'):\n            res.register_methods({'$cinit': res.cinit_idx})\n            res.methods['$cinit'] = self._all_methods[res.cinit_idx]\n            cinit = self.extract_function(res, '$cinit')\n            cinit([])\n\n        return res\n\n    def extract_function(self, avm_class, func_name):\n        p = self._patched_functions.get((avm_class, func_name))\n        if p:\n            return p\n        if func_name in avm_class.method_pyfunctions:\n            return avm_class.method_pyfunctions[func_name]\n        if func_name in self._classes_by_name:\n            return self._classes_by_name[func_name].make_object()\n        if func_name not in avm_class.methods:\n            raise ExtractorError('Cannot find function %s.%s' % (\n                avm_class.name, func_name))\n        m = avm_class.methods[func_name]\n\n        def resfunc(args):\n            \n            coder = io.BytesIO(m.code)\n            s24 = lambda: _s24(coder)\n            u30 = lambda: _u30(coder)\n\n            registers = [avm_class.variables] + list(args) + [None] * m.local_count\n            stack = []\n            scopes = collections.deque([\n                self._classes_by_name, avm_class.constants, avm_class.variables])\n            while True:\n                opcode = _read_byte(coder)\n                if opcode == 9:  \n                    pass  \n                elif opcode == 16:  \n                    offset = s24()\n                    coder.seek(coder.tell() + offset)\n                elif opcode == 17:  \n                    offset = s24()\n                    value = stack.pop()\n                    if value:\n                        coder.seek(coder.tell() + offset)\n                elif opcode == 18:  \n                    offset = s24()\n                    value = stack.pop()\n                    if not value:\n                        coder.seek(coder.tell() + offset)\n                elif opcode == 19:  \n                    offset = s24()\n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    if value2 == value1:\n                        coder.seek(coder.tell() + offset)\n                elif opcode == 20:  \n                    offset = s24()\n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    if value2 != value1:\n                        coder.seek(coder.tell() + offset)\n                elif opcode == 21:  \n                    offset = s24()\n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    if value1 < value2:\n                        coder.seek(coder.tell() + offset)\n                elif opcode == 32:  \n                    stack.append(None)\n                elif opcode == 33:  \n                    stack.append(undefined)\n                elif opcode == 36:  \n                    v = _read_byte(coder)\n                    stack.append(v)\n                elif opcode == 37:  \n                    v = u30()\n                    stack.append(v)\n                elif opcode == 38:  \n                    stack.append(True)\n                elif opcode == 39:  \n                    stack.append(False)\n                elif opcode == 40:  \n                    stack.append(float('NaN'))\n                elif opcode == 42:  \n                    value = stack[-1]\n                    stack.append(value)\n                elif opcode == 44:  \n                    idx = u30()\n                    stack.append(self.constant_strings[idx])\n                elif opcode == 48:  \n                    new_scope = stack.pop()\n                    scopes.append(new_scope)\n                elif opcode == 66:  \n                    arg_count = u30()\n                    args = list(reversed(\n                        [stack.pop() for _ in range(arg_count)]))\n                    obj = stack.pop()\n                    res = obj.avm_class.make_object()\n                    stack.append(res)\n                elif opcode == 70:  \n                    index = u30()\n                    mname = self.multinames[index]\n                    arg_count = u30()\n                    args = list(reversed(\n                        [stack.pop() for _ in range(arg_count)]))\n                    obj = stack.pop()\n\n                    if obj == StringClass:\n                        if mname == 'String':\n                            assert len(args) == 1\n                            assert isinstance(args[0], (\n                                int, compat_str, _Undefined))\n                            if args[0] == undefined:\n                                res = 'undefined'\n                            else:\n                                res = compat_str(args[0])\n                            stack.append(res)\n                            continue\n                        else:\n                            raise NotImplementedError(\n                                'Function String.%s is not yet implemented'\n                                % mname)\n                    elif isinstance(obj, _AVMClass_Object):\n                        func = self.extract_function(obj.avm_class, mname)\n                        res = func(args)\n                        stack.append(res)\n                        continue\n                    elif isinstance(obj, _AVMClass):\n                        func = self.extract_function(obj, mname)\n                        res = func(args)\n                        stack.append(res)\n                        continue\n                    elif isinstance(obj, _ScopeDict):\n                        if mname in obj.avm_class.method_names:\n                            func = self.extract_function(obj.avm_class, mname)\n                            res = func(args)\n                        else:\n                            res = obj[mname]\n                        stack.append(res)\n                        continue\n                    elif isinstance(obj, compat_str):\n                        if mname == 'split':\n                            assert len(args) == 1\n                            assert isinstance(args[0], compat_str)\n                            if args[0] == '':\n                                res = list(obj)\n                            else:\n                                res = obj.split(args[0])\n                            stack.append(res)\n                            continue\n                        elif mname == 'charCodeAt':\n                            assert len(args) <= 1\n                            idx = 0 if len(args) == 0 else args[0]\n                            assert isinstance(idx, int)\n                            res = ord(obj[idx])\n                            stack.append(res)\n                            continue\n                    elif isinstance(obj, list):\n                        if mname == 'slice':\n                            assert len(args) == 1\n                            assert isinstance(args[0], int)\n                            res = obj[args[0]:]\n                            stack.append(res)\n                            continue\n                        elif mname == 'join':\n                            assert len(args) == 1\n                            assert isinstance(args[0], compat_str)\n                            res = args[0].join(obj)\n                            stack.append(res)\n                            continue\n                    raise NotImplementedError(\n                        'Unsupported property %r on %r'\n                        % (mname, obj))\n                elif opcode == 71:  \n                    res = undefined\n                    return res\n                elif opcode == 72:  \n                    res = stack.pop()\n                    return res\n                elif opcode == 73:  \n                    \n                    arg_count = u30()\n                    args = list(reversed(\n                        [stack.pop() for _ in range(arg_count)]))\n                    obj = stack.pop()\n                elif opcode == 74:  \n                    index = u30()\n                    arg_count = u30()\n                    args = list(reversed(\n                        [stack.pop() for _ in range(arg_count)]))\n                    obj = stack.pop()\n\n                    mname = self.multinames[index]\n                    assert isinstance(obj, _AVMClass)\n\n                    \n                    \n                    stack.append(obj.make_object())\n                elif opcode == 79:  \n                    index = u30()\n                    mname = self.multinames[index]\n                    arg_count = u30()\n                    args = list(reversed(\n                        [stack.pop() for _ in range(arg_count)]))\n                    obj = stack.pop()\n                    if isinstance(obj, _AVMClass_Object):\n                        func = self.extract_function(obj.avm_class, mname)\n                        res = func(args)\n                        assert res is undefined\n                        continue\n                    if isinstance(obj, _ScopeDict):\n                        assert mname in obj.avm_class.method_names\n                        func = self.extract_function(obj.avm_class, mname)\n                        res = func(args)\n                        assert res is undefined\n                        continue\n                    if mname == 'reverse':\n                        assert isinstance(obj, list)\n                        obj.reverse()\n                    else:\n                        raise NotImplementedError(\n                            'Unsupported (void) property %r on %r'\n                            % (mname, obj))\n                elif opcode == 86:  \n                    arg_count = u30()\n                    arr = []\n                    for i in range(arg_count):\n                        arr.append(stack.pop())\n                    arr = arr[::-1]\n                    stack.append(arr)\n                elif opcode == 93:  \n                    index = u30()\n                    mname = self.multinames[index]\n                    for s in reversed(scopes):\n                        if mname in s:\n                            res = s\n                            break\n                    else:\n                        res = scopes[0]\n                    if mname not in res and mname in _builtin_classes:\n                        stack.append(_builtin_classes[mname])\n                    else:\n                        stack.append(res[mname])\n                elif opcode == 94:  \n                    index = u30()\n                    mname = self.multinames[index]\n                    for s in reversed(scopes):\n                        if mname in s:\n                            res = s\n                            break\n                    else:\n                        res = avm_class.variables\n                    stack.append(res)\n                elif opcode == 96:  \n                    index = u30()\n                    mname = self.multinames[index]\n                    for s in reversed(scopes):\n                        if mname in s:\n                            scope = s\n                            break\n                    else:\n                        scope = avm_class.variables\n\n                    if mname in scope:\n                        res = scope[mname]\n                    elif mname in _builtin_classes:\n                        res = _builtin_classes[mname]\n                    else:\n                        \n                        \n                        res = undefined\n                    stack.append(res)\n                elif opcode == 97:  \n                    index = u30()\n                    value = stack.pop()\n                    idx = self.multinames[index]\n                    if isinstance(idx, _Multiname):\n                        idx = stack.pop()\n                    obj = stack.pop()\n                    obj[idx] = value\n                elif opcode == 98:  \n                    index = u30()\n                    stack.append(registers[index])\n                elif opcode == 99:  \n                    index = u30()\n                    value = stack.pop()\n                    registers[index] = value\n                elif opcode == 102:  \n                    index = u30()\n                    pname = self.multinames[index]\n                    if pname == 'length':\n                        obj = stack.pop()\n                        assert isinstance(obj, (compat_str, list))\n                        stack.append(len(obj))\n                    elif isinstance(pname, compat_str):  \n                        obj = stack.pop()\n                        if isinstance(obj, _AVMClass):\n                            res = obj.static_properties[pname]\n                            stack.append(res)\n                            continue\n\n                        assert isinstance(obj, (dict, _ScopeDict)),\\\n                            'Accessing member %r on %r' % (pname, obj)\n                        res = obj.get(pname, undefined)\n                        stack.append(res)\n                    else:  \n                        idx = stack.pop()\n                        assert isinstance(idx, int)\n                        obj = stack.pop()\n                        assert isinstance(obj, list)\n                        stack.append(obj[idx])\n                elif opcode == 104:  \n                    index = u30()\n                    value = stack.pop()\n                    idx = self.multinames[index]\n                    if isinstance(idx, _Multiname):\n                        idx = stack.pop()\n                    obj = stack.pop()\n                    obj[idx] = value\n                elif opcode == 115:  \n                    value = stack.pop()\n                    intvalue = int(value)\n                    stack.append(intvalue)\n                elif opcode == 128:  \n                    u30()\n                elif opcode == 130:  \n                    value = stack.pop()\n                    \n                    stack.append(value)\n                elif opcode == 133:  \n                    assert isinstance(stack[-1], (type(None), compat_str))\n                elif opcode == 147:  \n                    value = stack.pop()\n                    assert isinstance(value, int)\n                    stack.append(value - 1)\n                elif opcode == 149:  \n                    value = stack.pop()\n                    return {\n                        _Undefined: 'undefined',\n                        compat_str: 'String',\n                        int: 'Number',\n                        float: 'Number',\n                    }[type(value)]\n                elif opcode == 160:  \n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    res = value1 + value2\n                    stack.append(res)\n                elif opcode == 161:  \n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    res = value1 - value2\n                    stack.append(res)\n                elif opcode == 162:  \n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    res = value1 * value2\n                    stack.append(res)\n                elif opcode == 164:  \n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    res = value1 % value2\n                    stack.append(res)\n                elif opcode == 168:  \n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    assert isinstance(value1, int)\n                    assert isinstance(value2, int)\n                    res = value1 & value2\n                    stack.append(res)\n                elif opcode == 171:  \n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    result = value1 == value2\n                    stack.append(result)\n                elif opcode == 175:  \n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    result = value1 >= value2\n                    stack.append(result)\n                elif opcode == 192:  \n                    value = stack.pop()\n                    assert isinstance(value, int)\n                    stack.append(value + 1)\n                elif opcode == 208:  \n                    stack.append(registers[0])\n                elif opcode == 209:  \n                    stack.append(registers[1])\n                elif opcode == 210:  \n                    stack.append(registers[2])\n                elif opcode == 211:  \n                    stack.append(registers[3])\n                elif opcode == 212:  \n                    registers[0] = stack.pop()\n                elif opcode == 213:  \n                    registers[1] = stack.pop()\n                elif opcode == 214:  \n                    registers[2] = stack.pop()\n                elif opcode == 215:  \n                    registers[3] = stack.pop()\n                else:\n                    raise NotImplementedError(\n                        'Unsupported opcode %d' % opcode)\n\n        avm_class.method_pyfunctions[func_name] = resfunc\n        return resfunc\n", "comments": "# Determine number of bits in framesize rectangle\n#%x' % (self.avm_class.name, id(self))\n# Parse ABC (AVM2 ByteCode)\n# Define a couple convenience methods\n# minor_version + major_version\n# Constant pool\n# kind\n# name\n# QName\n# QNameA\n# RTQName\n# RTQNameA\n# RTQNameL\n# RTQNameLA\n# Multiname\n# MultinameA\n# MultinameL\n# MultinameLA\n# namespace_idx\n# Methods\n# return type\n# param type\n# name index (always 0 for youtube)\n# Options present\n# val\n# kind\n# Param names present\n# param name\n# Metadata\n# name\n# key\n# value\n# Slot\n# Slot id\n# type_name_idx\n# vkind\n# Const\n# Slot id\n# type_name_idx\n# Constant_Int\n# Constant_UInt\n# Ignore silently for now\n# Method / Getter / Setter\n# disp_id\n# Class\n# slot_id\n# classi\n# Function\n# slot_id\n# Metadata present\n# metadata index\n# Classes\n# super_name idx\n# Protected namespace is present\n# protected_ns_idx\n# iinit\n# Scripts\n# init\n# Method bodies\n# max_stack\n# init_scope_depth\n# max_scope_depth\n# from\n# to\n# target\n# exc_type\n# var_name\n# Helper functions\n# label\n# Spec says: \"Do nothing.\"\n# jump\n# iftrue\n# iffalse\n# ifeq\n# ifne\n# iflt\n# pushnull\n# pushundefined\n# pushbyte\n# pushshort\n# pushtrue\n# pushfalse\n# pushnan\n# dup\n# pushstring\n# pushscope\n# construct\n# callproperty\n# returnvoid\n# returnvalue\n# constructsuper\n# Not yet implemented, just hope it works without it\n# constructproperty\n# We do not actually call the constructor for now;\n# we just pretend it does nothing\n# callpropvoid\n# newarray\n# findpropstrict\n# findproperty\n# getlex\n# Assume uninitialized\n# TODO warn here\n# setproperty\n# getlocal\n# setlocal\n# getproperty\n# Member access\n# Assume attribute access\n# initproperty\n# convert_\n# coerce\n# coerce_a\n# um, yes, it's any value\n# coerce_s\n# decrement\n# typeof\n# add\n# subtract\n# multiply\n# modulo\n# bitand\n# equals\n# greaterequals\n# increment_i\n# getlocal_0\n# getlocal_1\n# getlocal_2\n# getlocal_3\n# setlocal_0\n# setlocal_1\n# setlocal_2\n# setlocal_3\n", "content": "from __future__ import unicode_literals\n\nimport collections\nimport io\nimport zlib\n\nfrom .compat import (\n    compat_str,\n    compat_struct_unpack,\n)\nfrom .utils import (\n    ExtractorError,\n)\n\n\ndef _extract_tags(file_contents):\n    if file_contents[1:3] != b'WS':\n        raise ExtractorError(\n            'Not an SWF file; header is %r' % file_contents[:3])\n    if file_contents[:1] == b'C':\n        content = zlib.decompress(file_contents[8:])\n    else:\n        raise NotImplementedError(\n            'Unsupported compression format %r' %\n            file_contents[:1])\n\n    # Determine number of bits in framesize rectangle\n    framesize_nbits = compat_struct_unpack('!B', content[:1])[0] >> 3\n    framesize_len = (5 + 4 * framesize_nbits + 7) // 8\n\n    pos = framesize_len + 2 + 2\n    while pos < len(content):\n        header16 = compat_struct_unpack('<H', content[pos:pos + 2])[0]\n        pos += 2\n        tag_code = header16 >> 6\n        tag_len = header16 & 0x3f\n        if tag_len == 0x3f:\n            tag_len = compat_struct_unpack('<I', content[pos:pos + 4])[0]\n            pos += 4\n        assert pos + tag_len <= len(content), \\\n            ('Tag %d ends at %d+%d - that\\'s longer than the file (%d)'\n                % (tag_code, pos, tag_len, len(content)))\n        yield (tag_code, content[pos:pos + tag_len])\n        pos += tag_len\n\n\nclass _AVMClass_Object(object):\n    def __init__(self, avm_class):\n        self.avm_class = avm_class\n\n    def __repr__(self):\n        return '%s#%x' % (self.avm_class.name, id(self))\n\n\nclass _ScopeDict(dict):\n    def __init__(self, avm_class):\n        super(_ScopeDict, self).__init__()\n        self.avm_class = avm_class\n\n    def __repr__(self):\n        return '%s__Scope(%s)' % (\n            self.avm_class.name,\n            super(_ScopeDict, self).__repr__())\n\n\nclass _AVMClass(object):\n    def __init__(self, name_idx, name, static_properties=None):\n        self.name_idx = name_idx\n        self.name = name\n        self.method_names = {}\n        self.method_idxs = {}\n        self.methods = {}\n        self.method_pyfunctions = {}\n        self.static_properties = static_properties if static_properties else {}\n\n        self.variables = _ScopeDict(self)\n        self.constants = {}\n\n    def make_object(self):\n        return _AVMClass_Object(self)\n\n    def __repr__(self):\n        return '_AVMClass(%s)' % (self.name)\n\n    def register_methods(self, methods):\n        self.method_names.update(methods.items())\n        self.method_idxs.update(dict(\n            (idx, name)\n            for name, idx in methods.items()))\n\n\nclass _Multiname(object):\n    def __init__(self, kind):\n        self.kind = kind\n\n    def __repr__(self):\n        return '[MULTINAME kind: 0x%x]' % self.kind\n\n\ndef _read_int(reader):\n    res = 0\n    shift = 0\n    for _ in range(5):\n        buf = reader.read(1)\n        assert len(buf) == 1\n        b = compat_struct_unpack('<B', buf)[0]\n        res = res | ((b & 0x7f) << shift)\n        if b & 0x80 == 0:\n            break\n        shift += 7\n    return res\n\n\ndef _u30(reader):\n    res = _read_int(reader)\n    assert res & 0xf0000000 == 0\n    return res\n\n\n_u32 = _read_int\n\n\ndef _s32(reader):\n    v = _read_int(reader)\n    if v & 0x80000000 != 0:\n        v = - ((v ^ 0xffffffff) + 1)\n    return v\n\n\ndef _s24(reader):\n    bs = reader.read(3)\n    assert len(bs) == 3\n    last_byte = b'\\xff' if (ord(bs[2:3]) >= 0x80) else b'\\x00'\n    return compat_struct_unpack('<i', bs + last_byte)[0]\n\n\ndef _read_string(reader):\n    slen = _u30(reader)\n    resb = reader.read(slen)\n    assert len(resb) == slen\n    return resb.decode('utf-8')\n\n\ndef _read_bytes(count, reader):\n    assert count >= 0\n    resb = reader.read(count)\n    assert len(resb) == count\n    return resb\n\n\ndef _read_byte(reader):\n    resb = _read_bytes(1, reader=reader)\n    res = compat_struct_unpack('<B', resb)[0]\n    return res\n\n\nStringClass = _AVMClass('(no name idx)', 'String')\nByteArrayClass = _AVMClass('(no name idx)', 'ByteArray')\nTimerClass = _AVMClass('(no name idx)', 'Timer')\nTimerEventClass = _AVMClass('(no name idx)', 'TimerEvent', {'TIMER': 'timer'})\n_builtin_classes = {\n    StringClass.name: StringClass,\n    ByteArrayClass.name: ByteArrayClass,\n    TimerClass.name: TimerClass,\n    TimerEventClass.name: TimerEventClass,\n}\n\n\nclass _Undefined(object):\n    def __bool__(self):\n        return False\n    __nonzero__ = __bool__\n\n    def __hash__(self):\n        return 0\n\n    def __str__(self):\n        return 'undefined'\n    __repr__ = __str__\n\n\nundefined = _Undefined()\n\n\nclass SWFInterpreter(object):\n    def __init__(self, file_contents):\n        self._patched_functions = {\n            (TimerClass, 'addEventListener'): lambda params: undefined,\n        }\n        code_tag = next(tag\n                        for tag_code, tag in _extract_tags(file_contents)\n                        if tag_code == 82)\n        p = code_tag.index(b'\\0', 4) + 1\n        code_reader = io.BytesIO(code_tag[p:])\n\n        # Parse ABC (AVM2 ByteCode)\n\n        # Define a couple convenience methods\n        u30 = lambda *args: _u30(*args, reader=code_reader)\n        s32 = lambda *args: _s32(*args, reader=code_reader)\n        u32 = lambda *args: _u32(*args, reader=code_reader)\n        read_bytes = lambda *args: _read_bytes(*args, reader=code_reader)\n        read_byte = lambda *args: _read_byte(*args, reader=code_reader)\n\n        # minor_version + major_version\n        read_bytes(2 + 2)\n\n        # Constant pool\n        int_count = u30()\n        self.constant_ints = [0]\n        for _c in range(1, int_count):\n            self.constant_ints.append(s32())\n        self.constant_uints = [0]\n        uint_count = u30()\n        for _c in range(1, uint_count):\n            self.constant_uints.append(u32())\n        double_count = u30()\n        read_bytes(max(0, (double_count - 1)) * 8)\n        string_count = u30()\n        self.constant_strings = ['']\n        for _c in range(1, string_count):\n            s = _read_string(code_reader)\n            self.constant_strings.append(s)\n        namespace_count = u30()\n        for _c in range(1, namespace_count):\n            read_bytes(1)  # kind\n            u30()  # name\n        ns_set_count = u30()\n        for _c in range(1, ns_set_count):\n            count = u30()\n            for _c2 in range(count):\n                u30()\n        multiname_count = u30()\n        MULTINAME_SIZES = {\n            0x07: 2,  # QName\n            0x0d: 2,  # QNameA\n            0x0f: 1,  # RTQName\n            0x10: 1,  # RTQNameA\n            0x11: 0,  # RTQNameL\n            0x12: 0,  # RTQNameLA\n            0x09: 2,  # Multiname\n            0x0e: 2,  # MultinameA\n            0x1b: 1,  # MultinameL\n            0x1c: 1,  # MultinameLA\n        }\n        self.multinames = ['']\n        for _c in range(1, multiname_count):\n            kind = u30()\n            assert kind in MULTINAME_SIZES, 'Invalid multiname kind %r' % kind\n            if kind == 0x07:\n                u30()  # namespace_idx\n                name_idx = u30()\n                self.multinames.append(self.constant_strings[name_idx])\n            elif kind == 0x09:\n                name_idx = u30()\n                u30()\n                self.multinames.append(self.constant_strings[name_idx])\n            else:\n                self.multinames.append(_Multiname(kind))\n                for _c2 in range(MULTINAME_SIZES[kind]):\n                    u30()\n\n        # Methods\n        method_count = u30()\n        MethodInfo = collections.namedtuple(\n            'MethodInfo',\n            ['NEED_ARGUMENTS', 'NEED_REST'])\n        method_infos = []\n        for method_id in range(method_count):\n            param_count = u30()\n            u30()  # return type\n            for _ in range(param_count):\n                u30()  # param type\n            u30()  # name index (always 0 for youtube)\n            flags = read_byte()\n            if flags & 0x08 != 0:\n                # Options present\n                option_count = u30()\n                for c in range(option_count):\n                    u30()  # val\n                    read_bytes(1)  # kind\n            if flags & 0x80 != 0:\n                # Param names present\n                for _ in range(param_count):\n                    u30()  # param name\n            mi = MethodInfo(flags & 0x01 != 0, flags & 0x04 != 0)\n            method_infos.append(mi)\n\n        # Metadata\n        metadata_count = u30()\n        for _c in range(metadata_count):\n            u30()  # name\n            item_count = u30()\n            for _c2 in range(item_count):\n                u30()  # key\n                u30()  # value\n\n        def parse_traits_info():\n            trait_name_idx = u30()\n            kind_full = read_byte()\n            kind = kind_full & 0x0f\n            attrs = kind_full >> 4\n            methods = {}\n            constants = None\n            if kind == 0x00:  # Slot\n                u30()  # Slot id\n                u30()  # type_name_idx\n                vindex = u30()\n                if vindex != 0:\n                    read_byte()  # vkind\n            elif kind == 0x06:  # Const\n                u30()  # Slot id\n                u30()  # type_name_idx\n                vindex = u30()\n                vkind = 'any'\n                if vindex != 0:\n                    vkind = read_byte()\n                if vkind == 0x03:  # Constant_Int\n                    value = self.constant_ints[vindex]\n                elif vkind == 0x04:  # Constant_UInt\n                    value = self.constant_uints[vindex]\n                else:\n                    return {}, None  # Ignore silently for now\n                constants = {self.multinames[trait_name_idx]: value}\n            elif kind in (0x01, 0x02, 0x03):  # Method / Getter / Setter\n                u30()  # disp_id\n                method_idx = u30()\n                methods[self.multinames[trait_name_idx]] = method_idx\n            elif kind == 0x04:  # Class\n                u30()  # slot_id\n                u30()  # classi\n            elif kind == 0x05:  # Function\n                u30()  # slot_id\n                function_idx = u30()\n                methods[function_idx] = self.multinames[trait_name_idx]\n            else:\n                raise ExtractorError('Unsupported trait kind %d' % kind)\n\n            if attrs & 0x4 != 0:  # Metadata present\n                metadata_count = u30()\n                for _c3 in range(metadata_count):\n                    u30()  # metadata index\n\n            return methods, constants\n\n        # Classes\n        class_count = u30()\n        classes = []\n        for class_id in range(class_count):\n            name_idx = u30()\n\n            cname = self.multinames[name_idx]\n            avm_class = _AVMClass(name_idx, cname)\n            classes.append(avm_class)\n\n            u30()  # super_name idx\n            flags = read_byte()\n            if flags & 0x08 != 0:  # Protected namespace is present\n                u30()  # protected_ns_idx\n            intrf_count = u30()\n            for _c2 in range(intrf_count):\n                u30()\n            u30()  # iinit\n            trait_count = u30()\n            for _c2 in range(trait_count):\n                trait_methods, trait_constants = parse_traits_info()\n                avm_class.register_methods(trait_methods)\n                if trait_constants:\n                    avm_class.constants.update(trait_constants)\n\n        assert len(classes) == class_count\n        self._classes_by_name = dict((c.name, c) for c in classes)\n\n        for avm_class in classes:\n            avm_class.cinit_idx = u30()\n            trait_count = u30()\n            for _c2 in range(trait_count):\n                trait_methods, trait_constants = parse_traits_info()\n                avm_class.register_methods(trait_methods)\n                if trait_constants:\n                    avm_class.constants.update(trait_constants)\n\n        # Scripts\n        script_count = u30()\n        for _c in range(script_count):\n            u30()  # init\n            trait_count = u30()\n            for _c2 in range(trait_count):\n                parse_traits_info()\n\n        # Method bodies\n        method_body_count = u30()\n        Method = collections.namedtuple('Method', ['code', 'local_count'])\n        self._all_methods = []\n        for _c in range(method_body_count):\n            method_idx = u30()\n            u30()  # max_stack\n            local_count = u30()\n            u30()  # init_scope_depth\n            u30()  # max_scope_depth\n            code_length = u30()\n            code = read_bytes(code_length)\n            m = Method(code, local_count)\n            self._all_methods.append(m)\n            for avm_class in classes:\n                if method_idx in avm_class.method_idxs:\n                    avm_class.methods[avm_class.method_idxs[method_idx]] = m\n            exception_count = u30()\n            for _c2 in range(exception_count):\n                u30()  # from\n                u30()  # to\n                u30()  # target\n                u30()  # exc_type\n                u30()  # var_name\n            trait_count = u30()\n            for _c2 in range(trait_count):\n                parse_traits_info()\n\n        assert p + code_reader.tell() == len(code_tag)\n\n    def patch_function(self, avm_class, func_name, f):\n        self._patched_functions[(avm_class, func_name)] = f\n\n    def extract_class(self, class_name, call_cinit=True):\n        try:\n            res = self._classes_by_name[class_name]\n        except KeyError:\n            raise ExtractorError('Class %r not found' % class_name)\n\n        if call_cinit and hasattr(res, 'cinit_idx'):\n            res.register_methods({'$cinit': res.cinit_idx})\n            res.methods['$cinit'] = self._all_methods[res.cinit_idx]\n            cinit = self.extract_function(res, '$cinit')\n            cinit([])\n\n        return res\n\n    def extract_function(self, avm_class, func_name):\n        p = self._patched_functions.get((avm_class, func_name))\n        if p:\n            return p\n        if func_name in avm_class.method_pyfunctions:\n            return avm_class.method_pyfunctions[func_name]\n        if func_name in self._classes_by_name:\n            return self._classes_by_name[func_name].make_object()\n        if func_name not in avm_class.methods:\n            raise ExtractorError('Cannot find function %s.%s' % (\n                avm_class.name, func_name))\n        m = avm_class.methods[func_name]\n\n        def resfunc(args):\n            # Helper functions\n            coder = io.BytesIO(m.code)\n            s24 = lambda: _s24(coder)\n            u30 = lambda: _u30(coder)\n\n            registers = [avm_class.variables] + list(args) + [None] * m.local_count\n            stack = []\n            scopes = collections.deque([\n                self._classes_by_name, avm_class.constants, avm_class.variables])\n            while True:\n                opcode = _read_byte(coder)\n                if opcode == 9:  # label\n                    pass  # Spec says: \"Do nothing.\"\n                elif opcode == 16:  # jump\n                    offset = s24()\n                    coder.seek(coder.tell() + offset)\n                elif opcode == 17:  # iftrue\n                    offset = s24()\n                    value = stack.pop()\n                    if value:\n                        coder.seek(coder.tell() + offset)\n                elif opcode == 18:  # iffalse\n                    offset = s24()\n                    value = stack.pop()\n                    if not value:\n                        coder.seek(coder.tell() + offset)\n                elif opcode == 19:  # ifeq\n                    offset = s24()\n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    if value2 == value1:\n                        coder.seek(coder.tell() + offset)\n                elif opcode == 20:  # ifne\n                    offset = s24()\n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    if value2 != value1:\n                        coder.seek(coder.tell() + offset)\n                elif opcode == 21:  # iflt\n                    offset = s24()\n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    if value1 < value2:\n                        coder.seek(coder.tell() + offset)\n                elif opcode == 32:  # pushnull\n                    stack.append(None)\n                elif opcode == 33:  # pushundefined\n                    stack.append(undefined)\n                elif opcode == 36:  # pushbyte\n                    v = _read_byte(coder)\n                    stack.append(v)\n                elif opcode == 37:  # pushshort\n                    v = u30()\n                    stack.append(v)\n                elif opcode == 38:  # pushtrue\n                    stack.append(True)\n                elif opcode == 39:  # pushfalse\n                    stack.append(False)\n                elif opcode == 40:  # pushnan\n                    stack.append(float('NaN'))\n                elif opcode == 42:  # dup\n                    value = stack[-1]\n                    stack.append(value)\n                elif opcode == 44:  # pushstring\n                    idx = u30()\n                    stack.append(self.constant_strings[idx])\n                elif opcode == 48:  # pushscope\n                    new_scope = stack.pop()\n                    scopes.append(new_scope)\n                elif opcode == 66:  # construct\n                    arg_count = u30()\n                    args = list(reversed(\n                        [stack.pop() for _ in range(arg_count)]))\n                    obj = stack.pop()\n                    res = obj.avm_class.make_object()\n                    stack.append(res)\n                elif opcode == 70:  # callproperty\n                    index = u30()\n                    mname = self.multinames[index]\n                    arg_count = u30()\n                    args = list(reversed(\n                        [stack.pop() for _ in range(arg_count)]))\n                    obj = stack.pop()\n\n                    if obj == StringClass:\n                        if mname == 'String':\n                            assert len(args) == 1\n                            assert isinstance(args[0], (\n                                int, compat_str, _Undefined))\n                            if args[0] == undefined:\n                                res = 'undefined'\n                            else:\n                                res = compat_str(args[0])\n                            stack.append(res)\n                            continue\n                        else:\n                            raise NotImplementedError(\n                                'Function String.%s is not yet implemented'\n                                % mname)\n                    elif isinstance(obj, _AVMClass_Object):\n                        func = self.extract_function(obj.avm_class, mname)\n                        res = func(args)\n                        stack.append(res)\n                        continue\n                    elif isinstance(obj, _AVMClass):\n                        func = self.extract_function(obj, mname)\n                        res = func(args)\n                        stack.append(res)\n                        continue\n                    elif isinstance(obj, _ScopeDict):\n                        if mname in obj.avm_class.method_names:\n                            func = self.extract_function(obj.avm_class, mname)\n                            res = func(args)\n                        else:\n                            res = obj[mname]\n                        stack.append(res)\n                        continue\n                    elif isinstance(obj, compat_str):\n                        if mname == 'split':\n                            assert len(args) == 1\n                            assert isinstance(args[0], compat_str)\n                            if args[0] == '':\n                                res = list(obj)\n                            else:\n                                res = obj.split(args[0])\n                            stack.append(res)\n                            continue\n                        elif mname == 'charCodeAt':\n                            assert len(args) <= 1\n                            idx = 0 if len(args) == 0 else args[0]\n                            assert isinstance(idx, int)\n                            res = ord(obj[idx])\n                            stack.append(res)\n                            continue\n                    elif isinstance(obj, list):\n                        if mname == 'slice':\n                            assert len(args) == 1\n                            assert isinstance(args[0], int)\n                            res = obj[args[0]:]\n                            stack.append(res)\n                            continue\n                        elif mname == 'join':\n                            assert len(args) == 1\n                            assert isinstance(args[0], compat_str)\n                            res = args[0].join(obj)\n                            stack.append(res)\n                            continue\n                    raise NotImplementedError(\n                        'Unsupported property %r on %r'\n                        % (mname, obj))\n                elif opcode == 71:  # returnvoid\n                    res = undefined\n                    return res\n                elif opcode == 72:  # returnvalue\n                    res = stack.pop()\n                    return res\n                elif opcode == 73:  # constructsuper\n                    # Not yet implemented, just hope it works without it\n                    arg_count = u30()\n                    args = list(reversed(\n                        [stack.pop() for _ in range(arg_count)]))\n                    obj = stack.pop()\n                elif opcode == 74:  # constructproperty\n                    index = u30()\n                    arg_count = u30()\n                    args = list(reversed(\n                        [stack.pop() for _ in range(arg_count)]))\n                    obj = stack.pop()\n\n                    mname = self.multinames[index]\n                    assert isinstance(obj, _AVMClass)\n\n                    # We do not actually call the constructor for now;\n                    # we just pretend it does nothing\n                    stack.append(obj.make_object())\n                elif opcode == 79:  # callpropvoid\n                    index = u30()\n                    mname = self.multinames[index]\n                    arg_count = u30()\n                    args = list(reversed(\n                        [stack.pop() for _ in range(arg_count)]))\n                    obj = stack.pop()\n                    if isinstance(obj, _AVMClass_Object):\n                        func = self.extract_function(obj.avm_class, mname)\n                        res = func(args)\n                        assert res is undefined\n                        continue\n                    if isinstance(obj, _ScopeDict):\n                        assert mname in obj.avm_class.method_names\n                        func = self.extract_function(obj.avm_class, mname)\n                        res = func(args)\n                        assert res is undefined\n                        continue\n                    if mname == 'reverse':\n                        assert isinstance(obj, list)\n                        obj.reverse()\n                    else:\n                        raise NotImplementedError(\n                            'Unsupported (void) property %r on %r'\n                            % (mname, obj))\n                elif opcode == 86:  # newarray\n                    arg_count = u30()\n                    arr = []\n                    for i in range(arg_count):\n                        arr.append(stack.pop())\n                    arr = arr[::-1]\n                    stack.append(arr)\n                elif opcode == 93:  # findpropstrict\n                    index = u30()\n                    mname = self.multinames[index]\n                    for s in reversed(scopes):\n                        if mname in s:\n                            res = s\n                            break\n                    else:\n                        res = scopes[0]\n                    if mname not in res and mname in _builtin_classes:\n                        stack.append(_builtin_classes[mname])\n                    else:\n                        stack.append(res[mname])\n                elif opcode == 94:  # findproperty\n                    index = u30()\n                    mname = self.multinames[index]\n                    for s in reversed(scopes):\n                        if mname in s:\n                            res = s\n                            break\n                    else:\n                        res = avm_class.variables\n                    stack.append(res)\n                elif opcode == 96:  # getlex\n                    index = u30()\n                    mname = self.multinames[index]\n                    for s in reversed(scopes):\n                        if mname in s:\n                            scope = s\n                            break\n                    else:\n                        scope = avm_class.variables\n\n                    if mname in scope:\n                        res = scope[mname]\n                    elif mname in _builtin_classes:\n                        res = _builtin_classes[mname]\n                    else:\n                        # Assume uninitialized\n                        # TODO warn here\n                        res = undefined\n                    stack.append(res)\n                elif opcode == 97:  # setproperty\n                    index = u30()\n                    value = stack.pop()\n                    idx = self.multinames[index]\n                    if isinstance(idx, _Multiname):\n                        idx = stack.pop()\n                    obj = stack.pop()\n                    obj[idx] = value\n                elif opcode == 98:  # getlocal\n                    index = u30()\n                    stack.append(registers[index])\n                elif opcode == 99:  # setlocal\n                    index = u30()\n                    value = stack.pop()\n                    registers[index] = value\n                elif opcode == 102:  # getproperty\n                    index = u30()\n                    pname = self.multinames[index]\n                    if pname == 'length':\n                        obj = stack.pop()\n                        assert isinstance(obj, (compat_str, list))\n                        stack.append(len(obj))\n                    elif isinstance(pname, compat_str):  # Member access\n                        obj = stack.pop()\n                        if isinstance(obj, _AVMClass):\n                            res = obj.static_properties[pname]\n                            stack.append(res)\n                            continue\n\n                        assert isinstance(obj, (dict, _ScopeDict)),\\\n                            'Accessing member %r on %r' % (pname, obj)\n                        res = obj.get(pname, undefined)\n                        stack.append(res)\n                    else:  # Assume attribute access\n                        idx = stack.pop()\n                        assert isinstance(idx, int)\n                        obj = stack.pop()\n                        assert isinstance(obj, list)\n                        stack.append(obj[idx])\n                elif opcode == 104:  # initproperty\n                    index = u30()\n                    value = stack.pop()\n                    idx = self.multinames[index]\n                    if isinstance(idx, _Multiname):\n                        idx = stack.pop()\n                    obj = stack.pop()\n                    obj[idx] = value\n                elif opcode == 115:  # convert_\n                    value = stack.pop()\n                    intvalue = int(value)\n                    stack.append(intvalue)\n                elif opcode == 128:  # coerce\n                    u30()\n                elif opcode == 130:  # coerce_a\n                    value = stack.pop()\n                    # um, yes, it's any value\n                    stack.append(value)\n                elif opcode == 133:  # coerce_s\n                    assert isinstance(stack[-1], (type(None), compat_str))\n                elif opcode == 147:  # decrement\n                    value = stack.pop()\n                    assert isinstance(value, int)\n                    stack.append(value - 1)\n                elif opcode == 149:  # typeof\n                    value = stack.pop()\n                    return {\n                        _Undefined: 'undefined',\n                        compat_str: 'String',\n                        int: 'Number',\n                        float: 'Number',\n                    }[type(value)]\n                elif opcode == 160:  # add\n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    res = value1 + value2\n                    stack.append(res)\n                elif opcode == 161:  # subtract\n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    res = value1 - value2\n                    stack.append(res)\n                elif opcode == 162:  # multiply\n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    res = value1 * value2\n                    stack.append(res)\n                elif opcode == 164:  # modulo\n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    res = value1 % value2\n                    stack.append(res)\n                elif opcode == 168:  # bitand\n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    assert isinstance(value1, int)\n                    assert isinstance(value2, int)\n                    res = value1 & value2\n                    stack.append(res)\n                elif opcode == 171:  # equals\n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    result = value1 == value2\n                    stack.append(result)\n                elif opcode == 175:  # greaterequals\n                    value2 = stack.pop()\n                    value1 = stack.pop()\n                    result = value1 >= value2\n                    stack.append(result)\n                elif opcode == 192:  # increment_i\n                    value = stack.pop()\n                    assert isinstance(value, int)\n                    stack.append(value + 1)\n                elif opcode == 208:  # getlocal_0\n                    stack.append(registers[0])\n                elif opcode == 209:  # getlocal_1\n                    stack.append(registers[1])\n                elif opcode == 210:  # getlocal_2\n                    stack.append(registers[2])\n                elif opcode == 211:  # getlocal_3\n                    stack.append(registers[3])\n                elif opcode == 212:  # setlocal_0\n                    registers[0] = stack.pop()\n                elif opcode == 213:  # setlocal_1\n                    registers[1] = stack.pop()\n                elif opcode == 214:  # setlocal_2\n                    registers[2] = stack.pop()\n                elif opcode == 215:  # setlocal_3\n                    registers[3] = stack.pop()\n                else:\n                    raise NotImplementedError(\n                        'Unsupported opcode %d' % opcode)\n\n        avm_class.method_pyfunctions[func_name] = resfunc\n        return resfunc\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "swfinterp.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/swfinterp.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}