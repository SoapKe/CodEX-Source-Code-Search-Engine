{"author": "tensorflow", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\nimport mmap\nimport numpy as np\nimport os\n\nfrom six import string_types\n\n\nclass Vecs(object):\n  def __init__(self, vocab_filename, rows_filename, cols_filename=None):\n    \"\"\"Initializes the vectors from a text vocabulary and binary data.\"\"\"\n    with open(vocab_filename, 'r') as lines:\n      self.vocab = [line.split()[0] for line in lines]\n      self.word_to_idx = {word: idx for idx, word in enumerate(self.vocab)}\n\n    n = len(self.vocab)\n\n    with open(rows_filename, 'r') as rows_fh:\n      rows_fh.seek(0, os.SEEK_END)\n      size = rows_fh.tell()\n\n       Make sure that the file size seems reasonable.\n      if size % (4 * n) != 0:\n        raise IOError(\n            'unexpected file size for binary vector file %s' % rows_filename)\n\n       Memory map the rows.\n      dim = size / (4 * n)\n      rows_mm = mmap.mmap(rows_fh.fileno(), 0, prot=mmap.PROT_READ)\n      rows = np.matrix(\n          np.frombuffer(rows_mm, dtype=np.float32).reshape(n, dim))\n\n       If column vectors were specified, then open them and add them to the\n       row vectors.\n      if cols_filename:\n        with open(cols_filename, 'r') as cols_fh:\n          cols_mm = mmap.mmap(cols_fh.fileno(), 0, prot=mmap.PROT_READ)\n          cols_fh.seek(0, os.SEEK_END)\n          if cols_fh.tell() != size:\n            raise IOError('row and column vector files have different sizes')\n\n          cols = np.matrix(\n              np.frombuffer(cols_mm, dtype=np.float32).reshape(n, dim))\n\n          rows += cols\n          cols_mm.close()\n\n       Normalize so that dot products are just cosine similarity.\n      self.vecs = rows / np.linalg.norm(rows, axis=1).reshape(n, 1)\n      rows_mm.close()\n\n  def similarity(self, word1, word2):\n    \"\"\"Computes the similarity of two tokens.\"\"\"\n    idx1 = self.word_to_idx.get(word1)\n    idx2 = self.word_to_idx.get(word2)\n    if not idx1 or not idx2:\n      return None\n\n    return float(self.vecs[idx1] * self.vecs[idx2].transpose())\n\n  def neighbors(self, query):\n    \"\"\"Returns the nearest neighbors to the query (a word or vector).\"\"\"\n    if isinstance(query, string_types):\n      idx = self.word_to_idx.get(query)\n      if idx is None:\n        return None\n\n      query = self.vecs[idx]\n\n    neighbors = self.vecs * query.transpose()\n\n    return sorted(\n      zip(self.vocab, neighbors.flat),\n      key=lambda kv: kv[1], reverse=True)\n\n  def lookup(self, word):\n    \"\"\"Returns the embedding for a token, or None if no embedding exists.\"\"\"\n    idx = self.word_to_idx.get(word)\n    return None if idx is None else self.vecs[idx]\n", "comments": "   initializes vectors text vocabulary binary data         open(vocab filename   r ) lines        self vocab    line split() 0  line lines        self word idx    word  idx idx  word enumerate(self vocab)       n   len(self vocab)      open(rows filename   r ) rows fh        rows fh seek(0  os seek end)       size   rows fh tell()          make sure file size seems reasonable        size   (4   n)    0          raise ioerror(              unexpected file size binary vector file     rows filename)          memory map rows        dim   size   (4   n)       rows mm   mmap mmap(rows fh fileno()  0  prot mmap prot read)       rows   np matrix(           np frombuffer(rows mm  dtype np float32) reshape(n  dim))          if column vectors specified  open add         row vectors        cols filename          open(cols filename   r ) cols fh            cols mm   mmap mmap(cols fh fileno()  0  prot mmap prot read)           cols fh seek(0  os seek end)           cols fh tell()    size              raise ioerror( row column vector files different sizes )            cols   np matrix(               np frombuffer(cols mm  dtype np float32) reshape(n  dim))            rows    cols           cols mm close()          normalize dot products cosine similarity        self vecs   rows   np linalg norm(rows  axis 1) reshape(n  1)       rows mm close()    def similarity(self  word1  word2)         computes similarity two tokens         idx1   self word idx get(word1)     idx2   self word idx get(word2)     idx1 idx2        return none      return float(self vecs idx1    self vecs idx2  transpose())    def neighbors(self  query)         returns nearest neighbors query (a word vector)         isinstance(query  string types)        idx   self word idx get(query)       idx none          return none        query   self vecs idx       neighbors   self vecs   query transpose()      return sorted(       zip(self vocab  neighbors flat)        key lambda kv  kv 1   reverse true)    def lookup(self  word)         returns embedding token  none embedding exists        copyright 2016 google inc  all rights reserved        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license           http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license     make sure file size seems reasonable     memory map rows     if column vectors specified  open add    row vectors     normalize dot products cosine similarity  ", "content": "# Copyright 2016 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport mmap\nimport numpy as np\nimport os\n\nfrom six import string_types\n\n\nclass Vecs(object):\n  def __init__(self, vocab_filename, rows_filename, cols_filename=None):\n    \"\"\"Initializes the vectors from a text vocabulary and binary data.\"\"\"\n    with open(vocab_filename, 'r') as lines:\n      self.vocab = [line.split()[0] for line in lines]\n      self.word_to_idx = {word: idx for idx, word in enumerate(self.vocab)}\n\n    n = len(self.vocab)\n\n    with open(rows_filename, 'r') as rows_fh:\n      rows_fh.seek(0, os.SEEK_END)\n      size = rows_fh.tell()\n\n      # Make sure that the file size seems reasonable.\n      if size % (4 * n) != 0:\n        raise IOError(\n            'unexpected file size for binary vector file %s' % rows_filename)\n\n      # Memory map the rows.\n      dim = size / (4 * n)\n      rows_mm = mmap.mmap(rows_fh.fileno(), 0, prot=mmap.PROT_READ)\n      rows = np.matrix(\n          np.frombuffer(rows_mm, dtype=np.float32).reshape(n, dim))\n\n      # If column vectors were specified, then open them and add them to the\n      # row vectors.\n      if cols_filename:\n        with open(cols_filename, 'r') as cols_fh:\n          cols_mm = mmap.mmap(cols_fh.fileno(), 0, prot=mmap.PROT_READ)\n          cols_fh.seek(0, os.SEEK_END)\n          if cols_fh.tell() != size:\n            raise IOError('row and column vector files have different sizes')\n\n          cols = np.matrix(\n              np.frombuffer(cols_mm, dtype=np.float32).reshape(n, dim))\n\n          rows += cols\n          cols_mm.close()\n\n      # Normalize so that dot products are just cosine similarity.\n      self.vecs = rows / np.linalg.norm(rows, axis=1).reshape(n, 1)\n      rows_mm.close()\n\n  def similarity(self, word1, word2):\n    \"\"\"Computes the similarity of two tokens.\"\"\"\n    idx1 = self.word_to_idx.get(word1)\n    idx2 = self.word_to_idx.get(word2)\n    if not idx1 or not idx2:\n      return None\n\n    return float(self.vecs[idx1] * self.vecs[idx2].transpose())\n\n  def neighbors(self, query):\n    \"\"\"Returns the nearest neighbors to the query (a word or vector).\"\"\"\n    if isinstance(query, string_types):\n      idx = self.word_to_idx.get(query)\n      if idx is None:\n        return None\n\n      query = self.vecs[idx]\n\n    neighbors = self.vecs * query.transpose()\n\n    return sorted(\n      zip(self.vocab, neighbors.flat),\n      key=lambda kv: kv[1], reverse=True)\n\n  def lookup(self, word):\n    \"\"\"Returns the embedding for a token, or None if no embedding exists.\"\"\"\n    idx = self.word_to_idx.get(word)\n    return None if idx is None else self.vecs[idx]\n", "description": "Models and examples built with TensorFlow", "file_name": "vecs.py", "id": "643b5ca81d526159cfc420696bf85980", "language": "Python", "project_name": "models", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/tensorflow-models/tensorflow-models-086d914/research/swivel/vecs.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:59:19Z", "url": "https://github.com/tensorflow/models", "wiki": true}