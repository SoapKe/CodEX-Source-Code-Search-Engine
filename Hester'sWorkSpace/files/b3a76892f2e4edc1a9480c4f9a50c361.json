{"author": "tqdm", "code": "\n# -*- coding: utf-8 -*-\n\nimport os\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from distutils.core import setup\nimport sys\nfrom subprocess import check_call\nfrom io import open as io_open\n\n\nimport shlex\ntry:  \n    import ConfigParser\n    import StringIO\nexcept ImportError:  \n    \n    import configparser as ConfigParser\n    import io as StringIO\nimport re\n\n\n__version__ = None\nversion_file = os.path.join(os.path.dirname(__file__), 'tqdm', '_version.py')\nwith io_open(version_file, mode='r') as fd:\n    exec(fd.read())\n\n\n\nRE_MAKE_CMD = re.compile('^\\t(@\\+?)(make)?', flags=re.M)\n\n\ndef parse_makefile_aliases(filepath):\n    \n\n    \n    \n    ini_str = '[root]\\n'\n    with io_open(filepath, mode='r') as fd:\n        ini_str = ini_str + RE_MAKE_CMD.sub('\\t', fd.read())\n    ini_fp = StringIO.StringIO(ini_str)\n    \n    config = ConfigParser.RawConfigParser()\n    config.readfp(ini_fp)\n    \n    aliases = config.options('root')\n\n    \n    commands = {}\n    for alias in aliases:\n        if alias.lower() in ['.phony']:\n            continue\n        \n        commands[alias] = config.get('root', alias).lstrip('\\n').split('\\n')\n\n    \n    \n    \n    \n    \n    \n\n    \n    aliases_todo = list(commands.keys())\n    \n    commands_new = {}\n    \n    while aliases_todo:\n        \n        alias = aliases_todo.pop(0)\n        \n        commands_new[alias] = []\n        \n        for cmd in commands[alias]:\n            # Ignore self-referencing (alias points to itself)\n            if cmd == alias:\n                pass\n            \n            elif cmd in aliases and cmd in commands_new:\n                \n                commands_new[alias].extend(commands_new[cmd])\n            \n            \n            elif cmd in aliases and cmd not in commands_new:\n                \n                # to reference this one wrongly (as it is empty)\n                del commands_new[alias]\n                aliases_todo.append(alias)\n                break\n            # Full command (no aliases)\n            else:\n                commands_new[alias].append(cmd)\n    commands = commands_new\n    del commands_new\n\n    \n    # for alias in commands.keys():\n    #     commands['make_'+alias] = commands[alias]\n    #     del commands[alias]\n\n    return commands\n\n\ndef execute_makefile_commands(commands, alias, verbose=False):\n    cmds = commands[alias]\n    for cmd in cmds:\n        \n        # (incl quoted strings and comments)\n        parsed_cmd = shlex.split(cmd, comments=True)\n        # Execute command if not empty (ie, not just a comment)\n        if parsed_cmd:\n            if verbose:\n                print(\"Running command: \" + cmd)\n            # Launch the command and wait to finish (synchronized call)\n            check_call(parsed_cmd,\n                       cwd=os.path.dirname(os.path.abspath(__file__)))\n\n\n\n\n\n\nif sys.argv[1].lower().strip() == 'make':\n    \n    fpath = os.path.join(os.path.dirname(__file__), 'Makefile')\n    \n    commands = parse_makefile_aliases(fpath)\n\n    # If no alias (only `python setup.py make`), print the list of aliases\n    if len(sys.argv) < 3 or sys.argv[-1] == '--help':\n        print(\"Shortcut to use commands via aliases. List of aliases:\")\n        print('\\n'.join(alias for alias in sorted(commands.keys())))\n\n    \n    else:\n        arg = sys.argv[-1]\n        # if unit testing, we do nothing (we just checked the makefile parsing)\n        if arg == 'none':\n            sys.exit(0)\n        \n        elif arg in commands.keys():\n            execute_makefile_commands(commands, arg, verbose=True)\n        \n        else:\n            raise Exception(\"Provided alias cannot be found: make \" + arg)\n    \n    \n    \n    sys.exit(0)\n\n\n\n\nREADME_rst = ''\nfndoc = os.path.join(os.path.dirname(__file__), 'README.rst')\nwith io_open(fndoc, mode='r', encoding='utf-8') as fd:\n    README_rst = fd.read()\n\nsetup(\n    name='tqdm',\n    version=__version__,\n    description='Fast, Extensible Progress Meter',\n    license='MPLv2.0, MIT Licences',\n    author='Noam Yorav-Raphael',\n    author_email='noamraph@gmail.com',\n    url='https://github.com/tqdm/tqdm',\n    maintainer='tqdm developers',\n    maintainer_email='python.tqdm@gmail.com',\n    platforms=['any'],\n    packages=['tqdm'],\n    entry_points={'console_scripts': ['tqdm=tqdm._main:main'], },\n    data_files=[('man/man1', ['tqdm.1'])],\n    package_data={'': ['CONTRIBUTING.md', 'LICENCE', 'examples/*.py']},\n    long_description=README_rst,\n    classifiers=[\n        \n        # (https://pypi.python.org/pypi?%3Aaction=list_classifiers)\n        'Development Status :: 5 - Production/Stable',\n        'Environment :: Console',\n        'Environment :: MacOS X',\n        'Environment :: Other Environment',\n        'Environment :: Win32 (MS Windows)',\n        'Environment :: X11 Applications',\n        'Framework :: IPython',\n        'Intended Audience :: Developers',\n        'Intended Audience :: Education',\n        'Intended Audience :: End Users/Desktop',\n        'Intended Audience :: Other Audience',\n        'Intended Audience :: System Administrators',\n        'License :: OSI Approved :: MIT License',\n        'License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)',\n        'Operating System :: MacOS :: MacOS X',\n        'Operating System :: Microsoft :: Windows',\n        'Operating System :: POSIX',\n        'Operating System :: POSIX :: BSD',\n        'Operating System :: POSIX :: BSD :: FreeBSD',\n        'Operating System :: POSIX :: Linux',\n        'Operating System :: POSIX :: SunOS/Solaris',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.6',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.2',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: Implementation',\n        'Programming Language :: Python :: Implementation :: IronPython',\n        'Programming Language :: Python :: Implementation :: PyPy',\n        'Topic :: Desktop Environment',\n        'Topic :: Education :: Testing',\n        'Topic :: Office/Business',\n        'Topic :: Other/Nonlisted Topic',\n        'Topic :: Software Development :: Libraries',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n        'Topic :: Software Development :: User Interfaces',\n        'Topic :: System :: Logging',\n        'Topic :: System :: Monitoring',\n        'Topic :: System :: Shells',\n        'Topic :: Terminals',\n        'Topic :: Utilities'\n    ],\n    keywords='progressbar progressmeter progress bar meter'\n             ' rate eta console terminal time',\n    test_suite='nose.collector',\n    tests_require=['nose', 'flake8', 'coverage'],\n)\n", "comments": "        parse makefile find commands substitute variables  expects     makefile aliases line return command       returns dict  list commands alias              usr bin env python        coding  utf 8        for makefile parsing    pragma  cover    pragma  cover    python 3 compatibility    get version tqdm  version py    makefile auxiliary functions         parsing makefile using configparser    adding fake section make makefile valid ini file    parse using configparser    fetch list aliases       extracting commands alias    strip first line return  split line return       commands substitution    loop aliases substituted commands     check command alias  one command    substituted alias  try right away  if    possible alias points aliases   stop    put current alias back queue processed later     create queue aliases process    create dict hold full commands    loop processed aliases    pick first alias queue    create new entry resulting dict    for command alias    ignore self referencing (alias points itself)    substitute full command    append commands referenced alias    delay substituting another alias  waiting alias    substituted first    delete current entry avoid aliases    reference one wrongly (as empty)    full command (no aliases)       prepending prefix avoid conflicts standard setup py commands    alias commands keys()         commands  make   alias    commands alias         del commands alias     parse string shell like fashion    (incl quoted strings comments)    execute command empty (ie  comment)    launch command wait finish (synchronized call)    main setup py config      executing makefile commands specified    filename makefile    parse makefile  substitute aliases extract commands    if alias (only  python setup py make )  print list aliases    else process commands alias    unit testing  nothing (we checked makefile parsing)    else alias exists  execute commands    else alias cannot found    stop processing setup py     it important avoid setup py raising error command    standard    python package config      trove classifiers    (https   pypi python org pypi  3aaction list classifiers) ", "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport os\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from distutils.core import setup\nimport sys\nfrom subprocess import check_call\nfrom io import open as io_open\n\n# For Makefile parsing\nimport shlex\ntry:  # pragma: no cover\n    import ConfigParser\n    import StringIO\nexcept ImportError:  # pragma: no cover\n    # Python 3 compatibility\n    import configparser as ConfigParser\n    import io as StringIO\nimport re\n\n# Get version from tqdm/_version.py\n__version__ = None\nversion_file = os.path.join(os.path.dirname(__file__), 'tqdm', '_version.py')\nwith io_open(version_file, mode='r') as fd:\n    exec(fd.read())\n\n# Makefile auxiliary functions #\n\nRE_MAKE_CMD = re.compile('^\\t(@\\+?)(make)?', flags=re.M)\n\n\ndef parse_makefile_aliases(filepath):\n    \"\"\"\n    Parse a makefile to find commands and substitute variables. Expects a\n    makefile with only aliases and a line return between each command.\n\n    Returns a dict, with a list of commands for each alias.\n    \"\"\"\n\n    # -- Parsing the Makefile using ConfigParser\n    # Adding a fake section to make the Makefile a valid Ini file\n    ini_str = '[root]\\n'\n    with io_open(filepath, mode='r') as fd:\n        ini_str = ini_str + RE_MAKE_CMD.sub('\\t', fd.read())\n    ini_fp = StringIO.StringIO(ini_str)\n    # Parse using ConfigParser\n    config = ConfigParser.RawConfigParser()\n    config.readfp(ini_fp)\n    # Fetch the list of aliases\n    aliases = config.options('root')\n\n    # -- Extracting commands for each alias\n    commands = {}\n    for alias in aliases:\n        if alias.lower() in ['.phony']:\n            continue\n        # strip the first line return, and then split by any line return\n        commands[alias] = config.get('root', alias).lstrip('\\n').split('\\n')\n\n    # -- Commands substitution\n    # Loop until all aliases are substituted by their commands:\n    # Check each command of each alias, and if there is one command that is to\n    # be substituted by an alias, try to do it right away. If this is not\n    # possible because this alias itself points to other aliases , then stop\n    # and put the current alias back in the queue to be processed again later.\n\n    # Create the queue of aliases to process\n    aliases_todo = list(commands.keys())\n    # Create the dict that will hold the full commands\n    commands_new = {}\n    # Loop until we have processed all aliases\n    while aliases_todo:\n        # Pick the first alias in the queue\n        alias = aliases_todo.pop(0)\n        # Create a new entry in the resulting dict\n        commands_new[alias] = []\n        # For each command of this alias\n        for cmd in commands[alias]:\n            # Ignore self-referencing (alias points to itself)\n            if cmd == alias:\n                pass\n            # Substitute full command\n            elif cmd in aliases and cmd in commands_new:\n                # Append all the commands referenced by the alias\n                commands_new[alias].extend(commands_new[cmd])\n            # Delay substituting another alias, waiting for the other alias to\n            # be substituted first\n            elif cmd in aliases and cmd not in commands_new:\n                # Delete the current entry to avoid other aliases\n                # to reference this one wrongly (as it is empty)\n                del commands_new[alias]\n                aliases_todo.append(alias)\n                break\n            # Full command (no aliases)\n            else:\n                commands_new[alias].append(cmd)\n    commands = commands_new\n    del commands_new\n\n    # -- Prepending prefix to avoid conflicts with standard setup.py commands\n    # for alias in commands.keys():\n    #     commands['make_'+alias] = commands[alias]\n    #     del commands[alias]\n\n    return commands\n\n\ndef execute_makefile_commands(commands, alias, verbose=False):\n    cmds = commands[alias]\n    for cmd in cmds:\n        # Parse string in a shell-like fashion\n        # (incl quoted strings and comments)\n        parsed_cmd = shlex.split(cmd, comments=True)\n        # Execute command if not empty (ie, not just a comment)\n        if parsed_cmd:\n            if verbose:\n                print(\"Running command: \" + cmd)\n            # Launch the command and wait to finish (synchronized call)\n            check_call(parsed_cmd,\n                       cwd=os.path.dirname(os.path.abspath(__file__)))\n\n\n# Main setup.py config #\n\n\n# Executing makefile commands if specified\nif sys.argv[1].lower().strip() == 'make':\n    # Filename of the makefile\n    fpath = os.path.join(os.path.dirname(__file__), 'Makefile')\n    # Parse the makefile, substitute the aliases and extract the commands\n    commands = parse_makefile_aliases(fpath)\n\n    # If no alias (only `python setup.py make`), print the list of aliases\n    if len(sys.argv) < 3 or sys.argv[-1] == '--help':\n        print(\"Shortcut to use commands via aliases. List of aliases:\")\n        print('\\n'.join(alias for alias in sorted(commands.keys())))\n\n    # Else process the commands for this alias\n    else:\n        arg = sys.argv[-1]\n        # if unit testing, we do nothing (we just checked the makefile parsing)\n        if arg == 'none':\n            sys.exit(0)\n        # else if the alias exists, we execute its commands\n        elif arg in commands.keys():\n            execute_makefile_commands(commands, arg, verbose=True)\n        # else the alias cannot be found\n        else:\n            raise Exception(\"Provided alias cannot be found: make \" + arg)\n    # Stop the processing of setup.py here:\n    # It's important to avoid setup.py raising an error because of the command\n    # not being standard\n    sys.exit(0)\n\n\n# Python package config #\n\nREADME_rst = ''\nfndoc = os.path.join(os.path.dirname(__file__), 'README.rst')\nwith io_open(fndoc, mode='r', encoding='utf-8') as fd:\n    README_rst = fd.read()\n\nsetup(\n    name='tqdm',\n    version=__version__,\n    description='Fast, Extensible Progress Meter',\n    license='MPLv2.0, MIT Licences',\n    author='Noam Yorav-Raphael',\n    author_email='noamraph@gmail.com',\n    url='https://github.com/tqdm/tqdm',\n    maintainer='tqdm developers',\n    maintainer_email='python.tqdm@gmail.com',\n    platforms=['any'],\n    packages=['tqdm'],\n    entry_points={'console_scripts': ['tqdm=tqdm._main:main'], },\n    data_files=[('man/man1', ['tqdm.1'])],\n    package_data={'': ['CONTRIBUTING.md', 'LICENCE', 'examples/*.py']},\n    long_description=README_rst,\n    classifiers=[\n        # Trove classifiers\n        # (https://pypi.python.org/pypi?%3Aaction=list_classifiers)\n        'Development Status :: 5 - Production/Stable',\n        'Environment :: Console',\n        'Environment :: MacOS X',\n        'Environment :: Other Environment',\n        'Environment :: Win32 (MS Windows)',\n        'Environment :: X11 Applications',\n        'Framework :: IPython',\n        'Intended Audience :: Developers',\n        'Intended Audience :: Education',\n        'Intended Audience :: End Users/Desktop',\n        'Intended Audience :: Other Audience',\n        'Intended Audience :: System Administrators',\n        'License :: OSI Approved :: MIT License',\n        'License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)',\n        'Operating System :: MacOS :: MacOS X',\n        'Operating System :: Microsoft :: Windows',\n        'Operating System :: POSIX',\n        'Operating System :: POSIX :: BSD',\n        'Operating System :: POSIX :: BSD :: FreeBSD',\n        'Operating System :: POSIX :: Linux',\n        'Operating System :: POSIX :: SunOS/Solaris',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.6',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.2',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: Implementation',\n        'Programming Language :: Python :: Implementation :: IronPython',\n        'Programming Language :: Python :: Implementation :: PyPy',\n        'Topic :: Desktop Environment',\n        'Topic :: Education :: Testing',\n        'Topic :: Office/Business',\n        'Topic :: Other/Nonlisted Topic',\n        'Topic :: Software Development :: Libraries',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n        'Topic :: Software Development :: User Interfaces',\n        'Topic :: System :: Logging',\n        'Topic :: System :: Monitoring',\n        'Topic :: System :: Shells',\n        'Topic :: Terminals',\n        'Topic :: Utilities'\n    ],\n    keywords='progressbar progressmeter progress bar meter'\n             ' rate eta console terminal time',\n    test_suite='nose.collector',\n    tests_require=['nose', 'flake8', 'coverage'],\n)\n", "description": "A fast, extensible progress bar for Python and CLI", "file_name": "setup.py", "id": "b3a76892f2e4edc1a9480c4f9a50c361", "language": "Python", "project_name": "tqdm", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tqdm-tqdm/tqdm-tqdm-d861caa/setup.py", "save_time": "", "source": "", "update_at": "2018-03-18T17:06:37Z", "url": "https://github.com/tqdm/tqdm", "wiki": true}