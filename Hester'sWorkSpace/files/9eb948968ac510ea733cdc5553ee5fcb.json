{"author": "XX-net", "code": "import time\nimport socket\nimport struct\nimport urlparse\nimport io\nimport ssl\n\nimport utils\nimport simple_http_server\nfrom socket_wrap import SocketWrap\nimport global_var as g\nfrom gae_proxy.local import check_local_network\n\nfrom xlog import getLogger\nxlog = getLogger(\"smart_router\")\n\n\nSO_ORIGINAL_DST = 80\n\n\n\nfake_host = \"\"\n\n\nclass ConnectFail(Exception):\n    pass\n\n\nclass RedirectHttpsFail(Exception):\n    pass\n\n\nclass SniNotExist(Exception):\n    pass\n\n\nclass SslWrapFail(Exception):\n    pass\n\n\nclass XTunnelNotRunning(Exception):\n    pass\n\n\ndef is_gae_workable():\n    if not g.gae_proxy:\n        return False\n\n    return g.gae_proxy.apis.is_workable()\n\n\ndef is_x_tunnel_workable():\n    if not g.x_tunnel:\n        return False\n\n    return g.x_tunnel.apis.is_workable()\n\n\ndef is_clienthello(data):\n    if len(data) < 20:\n        return False\n    if data.startswith('\\x16\\x03'):\n        \n        length, = struct.unpack('>h', data[3:5])\n        return len(data) == 5 + length\n    elif data[0] == '\\x80' and data[2:4] == '\\x01\\x03':\n        \n        return len(data) == 2 + ord(data[1])\n    else:\n        return False\n\n\ndef have_ipv6(ips):\n    for ip in ips:\n        if \":\" in ip:\n            return True\n\n    return False\n\n\ndef extract_sni_name(packet):\n    if not packet.startswith('\\x16\\x03'):\n        return\n\n    stream = io.BytesIO(packet)\n    stream.read(0x2b)\n    session_id_length = ord(stream.read(1))\n    stream.read(session_id_length)\n    cipher_suites_length, = struct.unpack('>h', stream.read(2))\n    stream.read(cipher_suites_length+2)\n    extensions_length, = struct.unpack('>h', stream.read(2))\n    \n    while True:\n        data = stream.read(2)\n        if not data:\n            break\n        etype, = struct.unpack('>h', data)\n        elen, = struct.unpack('>h', stream.read(2))\n        edata = stream.read(elen)\n        if etype == 0:\n            server_name = edata[5:]\n            return server_name\n\n\ndef netloc_to_host_port(netloc, default_port=80):\n    if \":\" in netloc:\n        host, _, port = netloc.rpartition(':')\n        port = int(port)\n    else:\n        host = netloc\n        port = default_port\n    return host, port\n\n\ndef get_sni(sock, left_buf=\"\"):\n    if left_buf:\n        leadbyte = left_buf[0]\n    else:\n        leadbyte = sock.recv(1, socket.MSG_PEEK)\n\n    if leadbyte in ('\\x80', '\\x16'):\n        if leadbyte == '\\x16':\n            for _ in xrange(2):\n                leaddata = left_buf + sock.recv(1024, socket.MSG_PEEK)\n                if is_clienthello(leaddata):\n                    try:\n                        server_name = extract_sni_name(leaddata)\n                        return server_name\n                    except:\n                        break\n\n        raise SniNotExist\n\n    elif leadbyte not in [\"G\", \"P\", \"D\", \"O\", \"H\", \"T\"]:\n        raise SniNotExist\n\n    leaddata = \"\"\n    for _ in xrange(2):\n        leaddata = left_buf + sock.recv(1024, socket.MSG_PEEK)\n        if leaddata:\n            break\n        else:\n            time.sleep(0.1)\n            continue\n    if not leaddata:\n        raise SniNotExist\n\n    n1 = leaddata.find(\"\\r\\n\")\n    if n1 <= -1:\n        raise SniNotExist\n\n    req_line = leaddata[:n1]\n    words = req_line.split()\n    if len(words) == 3:\n        method, url, http_version = words\n    elif len(words) == 2:\n        method, url = words\n        http_version = \"HTTP/1.1\"\n    else:\n        raise SniNotExist\n\n    if method not in [\"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\", \"TRACE\", \"PATCH\"]:\n        raise SniNotExist\n\n    n2 = leaddata.find(\"\\r\\n\\r\\n\", n1)\n    if n2 <= -1:\n        raise SniNotExist\n    header_block = leaddata[n1+2:n2]\n\n    lines = header_block.split(\"\\r\\n\")\n    \n    host = None\n    for line in lines:\n        key, _, value = line.rpartition(\":\")\n        value = value.strip()\n        if key.lower() == \"host\":\n            host, port = netloc_to_host_port(value)\n            break\n    if host is None:\n        raise SniNotExist\n\n    return host\n\n\ndef do_direct(sock, host, ips, port, client_address, left_buf=\"\"):\n    if not g.config.auto_direct:\n        raise ConnectFail()\n\n    remote_sock = g.connect_manager.get_conn(host, ips, port)\n    if not remote_sock:\n        raise ConnectFail()\n\n    xlog.debug(\"host:%s:%d direct connect %s success\", host, port, remote_sock.ip)\n    if left_buf:\n        remote_sock.send(left_buf)\n    g.pipe_socks.add_socks(sock, remote_sock)\n\n\ndef do_redirect_https(sock, host, ips, port, client_address, left_buf=\"\"):\n    if not g.config.auto_direct:\n        raise ConnectFail()\n\n    remote_sock = g.connect_manager.get_conn(host, ips, 443)\n    if not remote_sock:\n        raise RedirectHttpsFail()\n\n    try:\n        ssl_sock = ssl.wrap_socket(remote_sock._sock)\n    except Exception as e:\n        raise RedirectHttpsFail()\n\n    xlog.debug(\"host:%s:%d redirect_https connect %s success\", host, port, remote_sock.ip)\n\n    if left_buf:\n        ssl_sock.send(left_buf)\n    sw = SocketWrap(ssl_sock, remote_sock.ip, port, host)\n    sock.recved_times = 3\n    g.pipe_socks.add_socks(sock, sw)\n\n\ndef do_socks(sock, host, port, client_address, left_buf=\"\"):\n    if not g.x_tunnel:\n        raise XTunnelNotRunning()\n\n    try:\n        conn_id = g.x_tunnel.proxy_session.create_conn(sock, host, port)\n    except Exception as e:\n        xlog.warn(\"do_sock to %s:%d, x_tunnel fail:%r\", host, port, e)\n        raise XTunnelNotRunning()\n\n    if not conn_id:\n        xlog.warn(\"x_tunnel create conn fail\")\n        raise XTunnelNotRunning()\n\n    # xlog.debug(\"do_socks %r connect to %s:%d conn_id:%d\", client_address, host, port, conn_id)\n    if left_buf:\n        g.x_tunnel.global_var.session.conn_list[conn_id].transfer_received_data(left_buf)\n    g.x_tunnel.global_var.session.conn_list[conn_id].start(block=True)\n\n\ndef do_gae(sock, host, port, client_address, left_buf=\"\"):\n    sock.setblocking(1)\n    if left_buf:\n        ssl_sock = sock\n        schema = \"http\"\n    else:\n        leadbyte = sock.recv(1, socket.MSG_PEEK)\n        if leadbyte in ('\\x80', '\\x16'):\n            try:\n                ssl_sock = g.gae_proxy.proxy_handler.wrap_ssl(sock._sock, host, port, client_address)\n            except Exception as e:\n                raise SslWrapFail()\n\n            schema = \"https\"\n        else:\n            ssl_sock = sock\n            schema = \"http\"\n\n    ssl_sock.setblocking(1)\n    xlog.debug(\"host:%s:%d do gae\", host, port)\n    req = g.gae_proxy.proxy_handler.GAEProxyHandler(ssl_sock, client_address, None, xlog)\n    req.parse_request()\n\n    if req.path[0] == '/':\n        req.path = '%s://%s%s' % (schema, req.headers['Host'], req.path)\n\n    if req.path in [\"http://www.twitter.com/xxnet\", \"https://www.twitter.com/xxnet\"]:\n        \n        \n        xlog.debug(\"CONNECT %s %s\", req.command, req.path)\n        req.wfile.write(req.self_check_response_data)\n        ssl_sock.close()\n        return\n\n    req.parsed_url = urlparse.urlparse(req.path)\n    req.do_METHOD()\n\n\ndef try_loop(scense, rule_list, sock, host, port, client_address, left_buf=\"\"):\n    start_time = time.time()\n\n    for rule in rule_list:\n        try:\n            if rule == \"redirect_https\":\n                if port != 80:\n                    continue\n\n                ips = g.dns_srv.query(host)\n                do_redirect_https(sock, host, ips, port, client_address, left_buf)\n                xlog.info(\"%s %s:%d redirect_https\", scense, host, port)\n                return\n\n            elif rule == \"direct\":\n                ips = g.dns_srv.query(host)\n                do_direct(sock, host, ips, port, client_address, left_buf)\n                xlog.info(\"%s %s:%d direct\", scense, host, port)\n                return\n\n            elif rule == \"gae\":\n                if not is_gae_workable() and host != fake_host:\n                    xlog.debug(\"%s gae host:%s:%d, but gae not work\", scense, host, port)\n                    continue\n\n                try:\n                    sni_host = get_sni(sock, left_buf)\n                    xlog.info(\"%s %s:%d gae\", scense, host, port)\n                    do_gae(sock, host, port, client_address, left_buf)\n                    return\n                except SniNotExist:\n                    xlog.debug(\"%s domain:%s get sni fail\", scense, host)\n                    continue\n                except (SslWrapFail, simple_http_server.ParseReqFail) as e:\n                    xlog.warn(\"%s domain:%s sni:%s fail:%r\", scense, host, sni_host, e)\n                    g.domain_cache.report_gae_deny(host, port)\n                    sock.close()\n                    return\n                except simple_http_server.GetReqTimeout:\n                    \n                    xlog.debug(\"%s host:%s:%d try gae, GetReqTimeout:%d\", scense, host, port,\n                             (time.time() - start_time) * 1000)\n                    sock.close()\n                    return\n                except Exception as e:\n                    xlog.exception(\"%s host:%s:%d rule:%s except:%r\", scense, host, port, rule, e)\n                    g.domain_cache.report_gae_deny(host, port)\n                    sock.close()\n                    return\n\n            elif rule == \"socks\":\n                xlog.info(\"%s %s:%d socks\", scense, host, port)\n                do_socks(sock, host, port, client_address, left_buf)\n                return\n            elif rule == \"black\":\n                xlog.info(\"%s to:%s:%d black\", scense, host, port)\n                sock.close()\n                return\n            else:\n                xlog.error(\"%s %s:%d rule:%s unknown\", scense, host, port, host, rule)\n                sock.close()\n                return\n        except Exception as e:\n            xlog.debug(\"%s %s to %s:%d except:%r\", scense, rule, host, port, e)\n\n    xlog.info(\"%s %s to %s:%d fail\", scense, rule_list, host, port)\n    sock.close()\n    return\n\n\ndef handle_ip_proxy(sock, ip, port, client_address):\n    if not isinstance(sock, SocketWrap):\n        sock = SocketWrap(sock, client_address[0], client_address[1])\n\n    rule = g.user_rules.check_host(ip, port)\n    if not rule:\n        if utils.is_private_ip(ip):\n            rule = \"direct\"\n\n    if rule:\n        return try_loop(\"ip user\", [rule], sock, ip, port, client_address)\n\n    if g.config.auto_direct and g.ip_region.check_ip(ip):\n        rule_list = [\"direct\", \"gae\", \"socks\", \"redirect_https\"]\n    else:\n        if g.config.auto_direct or g.config.auto_gae:\n            try:\n                host = get_sni(sock)\n                if host:\n                    return handle_domain_proxy(sock, host, port, client_address)\n            except SniNotExist as e:\n                xlog.debug(\"ip:%s:%d get sni fail\", ip, port)\n\n        if not g.config.auto_direct:\n            rule_list = [\"socks\"]\n        else:\n            record = g.ip_cache.get(ip)\n            if record and record[\"r\"] == \"socks\":\n                rule_list = [\"socks\"]\n            else:\n                rule_list = [\"direct\", \"socks\"]\n\n    if not g.config.auto_direct and \"direct\" in rule_list:\n        try:\n            rule_list.remove(\"direct\")\n            rule_list.remove(\"redirect_https\")\n        except:\n            pass\n\n    if not g.config.auto_gae and \"gae\" in rule_list:\n        try:\n            rule_list.remove(\"gae\")\n        except:\n            pass\n\n    try_loop(\"ip\", rule_list, sock, ip, port, client_address)\n\n\ndef handle_domain_proxy(sock, host, port, client_address, left_buf=\"\"):\n    global fake_host\n    if not fake_host and g.gae_proxy:\n        fake_host = g.gae_proxy.web_control.get_fake_host()\n\n    if not isinstance(sock, SocketWrap):\n        sock = SocketWrap(sock, client_address[0], client_address[1])\n\n    sock.target = \"%s:%d\" % (host, port)\n    rule = g.user_rules.check_host(host, port)\n    if not rule:\n        if host == fake_host:\n            rule = \"gae\"\n        elif utils.check_ip_valid(host) and utils.is_private_ip(host):\n            rule = \"direct\"\n\n    if rule:\n        return try_loop(\"domain user\", [rule], sock, host, port, client_address, left_buf)\n\n    if g.config.block_advertisement and g.gfwlist.is_advertisement(host):\n        xlog.info(\"block advertisement %s:%d\", host, port)\n        sock.close()\n        return\n\n    #ips = g.dns_srv.query(host)\n    #if check_local_network.IPv6.is_ok() and have_ipv6(ips) and port == 443:\n    #    rule_list = [\"direct\", \"gae\", \"socks\", \"redirect_https\"]\n    \n\n    record = g.domain_cache.get(host)\n    if record and record[\"r\"] != \"unknown\":\n        rule = record[\"r\"]\n        if rule == \"gae\":\n            rule_list = [\"gae\", \"socks\", \"redirect_https\", \"direct\"]\n        else:\n            rule_list = [\"direct\", \"gae\", \"socks\", \"redirect_https\"]\n\n        if not g.domain_cache.accept_gae(host):\n            rule_list.remove(\"gae\")\n    elif g.gfwlist.is_white(host):\n        rule_list = [\"direct\", \"gae\", \"socks\", \"redirect_https\"]\n    elif g.gfwlist.check(host):\n        rule_list = [\"gae\", \"socks\", \"redirect_https\", \"direct\"]\n    else:\n        ips = g.dns_srv.query(host)\n        if g.ip_region.check_ips(ips):\n            rule_list = [\"direct\", \"gae\", \"socks\", \"redirect_https\"]\n        else:\n            rule_list = [\"gae\", \"socks\", \"redirect_https\", \"direct\"]\n\n    if not g.config.auto_direct and \"direct\" in rule_list:\n        try:\n            rule_list.remove(\"direct\")\n            rule_list.remove(\"redirect_https\")\n        except:\n            pass\n\n    if not g.config.auto_gae and \"gae\" in rule_list:\n        try:\n            rule_list.remove(\"gae\")\n        except:\n            pass\n\n    try_loop(\"domain\", rule_list, sock, host, port, client_address, left_buf)\n", "comments": "  tlsv12 tlsv11 tlsv1 sslv3    sslv23    extensions         path   url    xlog debug( socks  r connect   conn id    client address  host  port  conn id)    web ui status page    auto detect browser proxy setting work    happen sometimes  known    ips   g dns srv query(host)   check local network ipv6 ok() ipv6(ips) port    443        rule list     direct    gae    socks    redirect https      gae faster direct  ", "content": "import time\nimport socket\nimport struct\nimport urlparse\nimport io\nimport ssl\n\nimport utils\nimport simple_http_server\nfrom socket_wrap import SocketWrap\nimport global_var as g\nfrom gae_proxy.local import check_local_network\n\nfrom xlog import getLogger\nxlog = getLogger(\"smart_router\")\n\n\nSO_ORIGINAL_DST = 80\n\n\n\nfake_host = \"\"\n\n\nclass ConnectFail(Exception):\n    pass\n\n\nclass RedirectHttpsFail(Exception):\n    pass\n\n\nclass SniNotExist(Exception):\n    pass\n\n\nclass SslWrapFail(Exception):\n    pass\n\n\nclass XTunnelNotRunning(Exception):\n    pass\n\n\ndef is_gae_workable():\n    if not g.gae_proxy:\n        return False\n\n    return g.gae_proxy.apis.is_workable()\n\n\ndef is_x_tunnel_workable():\n    if not g.x_tunnel:\n        return False\n\n    return g.x_tunnel.apis.is_workable()\n\n\ndef is_clienthello(data):\n    if len(data) < 20:\n        return False\n    if data.startswith('\\x16\\x03'):\n        # TLSv12/TLSv11/TLSv1/SSLv3\n        length, = struct.unpack('>h', data[3:5])\n        return len(data) == 5 + length\n    elif data[0] == '\\x80' and data[2:4] == '\\x01\\x03':\n        # SSLv23\n        return len(data) == 2 + ord(data[1])\n    else:\n        return False\n\n\ndef have_ipv6(ips):\n    for ip in ips:\n        if \":\" in ip:\n            return True\n\n    return False\n\n\ndef extract_sni_name(packet):\n    if not packet.startswith('\\x16\\x03'):\n        return\n\n    stream = io.BytesIO(packet)\n    stream.read(0x2b)\n    session_id_length = ord(stream.read(1))\n    stream.read(session_id_length)\n    cipher_suites_length, = struct.unpack('>h', stream.read(2))\n    stream.read(cipher_suites_length+2)\n    extensions_length, = struct.unpack('>h', stream.read(2))\n    # extensions = {}\n    while True:\n        data = stream.read(2)\n        if not data:\n            break\n        etype, = struct.unpack('>h', data)\n        elen, = struct.unpack('>h', stream.read(2))\n        edata = stream.read(elen)\n        if etype == 0:\n            server_name = edata[5:]\n            return server_name\n\n\ndef netloc_to_host_port(netloc, default_port=80):\n    if \":\" in netloc:\n        host, _, port = netloc.rpartition(':')\n        port = int(port)\n    else:\n        host = netloc\n        port = default_port\n    return host, port\n\n\ndef get_sni(sock, left_buf=\"\"):\n    if left_buf:\n        leadbyte = left_buf[0]\n    else:\n        leadbyte = sock.recv(1, socket.MSG_PEEK)\n\n    if leadbyte in ('\\x80', '\\x16'):\n        if leadbyte == '\\x16':\n            for _ in xrange(2):\n                leaddata = left_buf + sock.recv(1024, socket.MSG_PEEK)\n                if is_clienthello(leaddata):\n                    try:\n                        server_name = extract_sni_name(leaddata)\n                        return server_name\n                    except:\n                        break\n\n        raise SniNotExist\n\n    elif leadbyte not in [\"G\", \"P\", \"D\", \"O\", \"H\", \"T\"]:\n        raise SniNotExist\n\n    leaddata = \"\"\n    for _ in xrange(2):\n        leaddata = left_buf + sock.recv(1024, socket.MSG_PEEK)\n        if leaddata:\n            break\n        else:\n            time.sleep(0.1)\n            continue\n    if not leaddata:\n        raise SniNotExist\n\n    n1 = leaddata.find(\"\\r\\n\")\n    if n1 <= -1:\n        raise SniNotExist\n\n    req_line = leaddata[:n1]\n    words = req_line.split()\n    if len(words) == 3:\n        method, url, http_version = words\n    elif len(words) == 2:\n        method, url = words\n        http_version = \"HTTP/1.1\"\n    else:\n        raise SniNotExist\n\n    if method not in [\"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\", \"TRACE\", \"PATCH\"]:\n        raise SniNotExist\n\n    n2 = leaddata.find(\"\\r\\n\\r\\n\", n1)\n    if n2 <= -1:\n        raise SniNotExist\n    header_block = leaddata[n1+2:n2]\n\n    lines = header_block.split(\"\\r\\n\")\n    # path = url\n    host = None\n    for line in lines:\n        key, _, value = line.rpartition(\":\")\n        value = value.strip()\n        if key.lower() == \"host\":\n            host, port = netloc_to_host_port(value)\n            break\n    if host is None:\n        raise SniNotExist\n\n    return host\n\n\ndef do_direct(sock, host, ips, port, client_address, left_buf=\"\"):\n    if not g.config.auto_direct:\n        raise ConnectFail()\n\n    remote_sock = g.connect_manager.get_conn(host, ips, port)\n    if not remote_sock:\n        raise ConnectFail()\n\n    xlog.debug(\"host:%s:%d direct connect %s success\", host, port, remote_sock.ip)\n    if left_buf:\n        remote_sock.send(left_buf)\n    g.pipe_socks.add_socks(sock, remote_sock)\n\n\ndef do_redirect_https(sock, host, ips, port, client_address, left_buf=\"\"):\n    if not g.config.auto_direct:\n        raise ConnectFail()\n\n    remote_sock = g.connect_manager.get_conn(host, ips, 443)\n    if not remote_sock:\n        raise RedirectHttpsFail()\n\n    try:\n        ssl_sock = ssl.wrap_socket(remote_sock._sock)\n    except Exception as e:\n        raise RedirectHttpsFail()\n\n    xlog.debug(\"host:%s:%d redirect_https connect %s success\", host, port, remote_sock.ip)\n\n    if left_buf:\n        ssl_sock.send(left_buf)\n    sw = SocketWrap(ssl_sock, remote_sock.ip, port, host)\n    sock.recved_times = 3\n    g.pipe_socks.add_socks(sock, sw)\n\n\ndef do_socks(sock, host, port, client_address, left_buf=\"\"):\n    if not g.x_tunnel:\n        raise XTunnelNotRunning()\n\n    try:\n        conn_id = g.x_tunnel.proxy_session.create_conn(sock, host, port)\n    except Exception as e:\n        xlog.warn(\"do_sock to %s:%d, x_tunnel fail:%r\", host, port, e)\n        raise XTunnelNotRunning()\n\n    if not conn_id:\n        xlog.warn(\"x_tunnel create conn fail\")\n        raise XTunnelNotRunning()\n\n    # xlog.debug(\"do_socks %r connect to %s:%d conn_id:%d\", client_address, host, port, conn_id)\n    if left_buf:\n        g.x_tunnel.global_var.session.conn_list[conn_id].transfer_received_data(left_buf)\n    g.x_tunnel.global_var.session.conn_list[conn_id].start(block=True)\n\n\ndef do_gae(sock, host, port, client_address, left_buf=\"\"):\n    sock.setblocking(1)\n    if left_buf:\n        ssl_sock = sock\n        schema = \"http\"\n    else:\n        leadbyte = sock.recv(1, socket.MSG_PEEK)\n        if leadbyte in ('\\x80', '\\x16'):\n            try:\n                ssl_sock = g.gae_proxy.proxy_handler.wrap_ssl(sock._sock, host, port, client_address)\n            except Exception as e:\n                raise SslWrapFail()\n\n            schema = \"https\"\n        else:\n            ssl_sock = sock\n            schema = \"http\"\n\n    ssl_sock.setblocking(1)\n    xlog.debug(\"host:%s:%d do gae\", host, port)\n    req = g.gae_proxy.proxy_handler.GAEProxyHandler(ssl_sock, client_address, None, xlog)\n    req.parse_request()\n\n    if req.path[0] == '/':\n        req.path = '%s://%s%s' % (schema, req.headers['Host'], req.path)\n\n    if req.path in [\"http://www.twitter.com/xxnet\", \"https://www.twitter.com/xxnet\"]:\n        # for web_ui status page\n        # auto detect browser proxy setting is work\n        xlog.debug(\"CONNECT %s %s\", req.command, req.path)\n        req.wfile.write(req.self_check_response_data)\n        ssl_sock.close()\n        return\n\n    req.parsed_url = urlparse.urlparse(req.path)\n    req.do_METHOD()\n\n\ndef try_loop(scense, rule_list, sock, host, port, client_address, left_buf=\"\"):\n    start_time = time.time()\n\n    for rule in rule_list:\n        try:\n            if rule == \"redirect_https\":\n                if port != 80:\n                    continue\n\n                ips = g.dns_srv.query(host)\n                do_redirect_https(sock, host, ips, port, client_address, left_buf)\n                xlog.info(\"%s %s:%d redirect_https\", scense, host, port)\n                return\n\n            elif rule == \"direct\":\n                ips = g.dns_srv.query(host)\n                do_direct(sock, host, ips, port, client_address, left_buf)\n                xlog.info(\"%s %s:%d direct\", scense, host, port)\n                return\n\n            elif rule == \"gae\":\n                if not is_gae_workable() and host != fake_host:\n                    xlog.debug(\"%s gae host:%s:%d, but gae not work\", scense, host, port)\n                    continue\n\n                try:\n                    sni_host = get_sni(sock, left_buf)\n                    xlog.info(\"%s %s:%d gae\", scense, host, port)\n                    do_gae(sock, host, port, client_address, left_buf)\n                    return\n                except SniNotExist:\n                    xlog.debug(\"%s domain:%s get sni fail\", scense, host)\n                    continue\n                except (SslWrapFail, simple_http_server.ParseReqFail) as e:\n                    xlog.warn(\"%s domain:%s sni:%s fail:%r\", scense, host, sni_host, e)\n                    g.domain_cache.report_gae_deny(host, port)\n                    sock.close()\n                    return\n                except simple_http_server.GetReqTimeout:\n                    # Happen sometimes, don't known why.\n                    xlog.debug(\"%s host:%s:%d try gae, GetReqTimeout:%d\", scense, host, port,\n                             (time.time() - start_time) * 1000)\n                    sock.close()\n                    return\n                except Exception as e:\n                    xlog.exception(\"%s host:%s:%d rule:%s except:%r\", scense, host, port, rule, e)\n                    g.domain_cache.report_gae_deny(host, port)\n                    sock.close()\n                    return\n\n            elif rule == \"socks\":\n                xlog.info(\"%s %s:%d socks\", scense, host, port)\n                do_socks(sock, host, port, client_address, left_buf)\n                return\n            elif rule == \"black\":\n                xlog.info(\"%s to:%s:%d black\", scense, host, port)\n                sock.close()\n                return\n            else:\n                xlog.error(\"%s %s:%d rule:%s unknown\", scense, host, port, host, rule)\n                sock.close()\n                return\n        except Exception as e:\n            xlog.debug(\"%s %s to %s:%d except:%r\", scense, rule, host, port, e)\n\n    xlog.info(\"%s %s to %s:%d fail\", scense, rule_list, host, port)\n    sock.close()\n    return\n\n\ndef handle_ip_proxy(sock, ip, port, client_address):\n    if not isinstance(sock, SocketWrap):\n        sock = SocketWrap(sock, client_address[0], client_address[1])\n\n    rule = g.user_rules.check_host(ip, port)\n    if not rule:\n        if utils.is_private_ip(ip):\n            rule = \"direct\"\n\n    if rule:\n        return try_loop(\"ip user\", [rule], sock, ip, port, client_address)\n\n    if g.config.auto_direct and g.ip_region.check_ip(ip):\n        rule_list = [\"direct\", \"gae\", \"socks\", \"redirect_https\"]\n    else:\n        if g.config.auto_direct or g.config.auto_gae:\n            try:\n                host = get_sni(sock)\n                if host:\n                    return handle_domain_proxy(sock, host, port, client_address)\n            except SniNotExist as e:\n                xlog.debug(\"ip:%s:%d get sni fail\", ip, port)\n\n        if not g.config.auto_direct:\n            rule_list = [\"socks\"]\n        else:\n            record = g.ip_cache.get(ip)\n            if record and record[\"r\"] == \"socks\":\n                rule_list = [\"socks\"]\n            else:\n                rule_list = [\"direct\", \"socks\"]\n\n    if not g.config.auto_direct and \"direct\" in rule_list:\n        try:\n            rule_list.remove(\"direct\")\n            rule_list.remove(\"redirect_https\")\n        except:\n            pass\n\n    if not g.config.auto_gae and \"gae\" in rule_list:\n        try:\n            rule_list.remove(\"gae\")\n        except:\n            pass\n\n    try_loop(\"ip\", rule_list, sock, ip, port, client_address)\n\n\ndef handle_domain_proxy(sock, host, port, client_address, left_buf=\"\"):\n    global fake_host\n    if not fake_host and g.gae_proxy:\n        fake_host = g.gae_proxy.web_control.get_fake_host()\n\n    if not isinstance(sock, SocketWrap):\n        sock = SocketWrap(sock, client_address[0], client_address[1])\n\n    sock.target = \"%s:%d\" % (host, port)\n    rule = g.user_rules.check_host(host, port)\n    if not rule:\n        if host == fake_host:\n            rule = \"gae\"\n        elif utils.check_ip_valid(host) and utils.is_private_ip(host):\n            rule = \"direct\"\n\n    if rule:\n        return try_loop(\"domain user\", [rule], sock, host, port, client_address, left_buf)\n\n    if g.config.block_advertisement and g.gfwlist.is_advertisement(host):\n        xlog.info(\"block advertisement %s:%d\", host, port)\n        sock.close()\n        return\n\n    #ips = g.dns_srv.query(host)\n    #if check_local_network.IPv6.is_ok() and have_ipv6(ips) and port == 443:\n    #    rule_list = [\"direct\", \"gae\", \"socks\", \"redirect_https\"]\n    # gae is more faster then direct.\n\n    record = g.domain_cache.get(host)\n    if record and record[\"r\"] != \"unknown\":\n        rule = record[\"r\"]\n        if rule == \"gae\":\n            rule_list = [\"gae\", \"socks\", \"redirect_https\", \"direct\"]\n        else:\n            rule_list = [\"direct\", \"gae\", \"socks\", \"redirect_https\"]\n\n        if not g.domain_cache.accept_gae(host):\n            rule_list.remove(\"gae\")\n    elif g.gfwlist.is_white(host):\n        rule_list = [\"direct\", \"gae\", \"socks\", \"redirect_https\"]\n    elif g.gfwlist.check(host):\n        rule_list = [\"gae\", \"socks\", \"redirect_https\", \"direct\"]\n    else:\n        ips = g.dns_srv.query(host)\n        if g.ip_region.check_ips(ips):\n            rule_list = [\"direct\", \"gae\", \"socks\", \"redirect_https\"]\n        else:\n            rule_list = [\"gae\", \"socks\", \"redirect_https\", \"direct\"]\n\n    if not g.config.auto_direct and \"direct\" in rule_list:\n        try:\n            rule_list.remove(\"direct\")\n            rule_list.remove(\"redirect_https\")\n        except:\n            pass\n\n    if not g.config.auto_gae and \"gae\" in rule_list:\n        try:\n            rule_list.remove(\"gae\")\n        except:\n            pass\n\n    try_loop(\"domain\", rule_list, sock, host, port, client_address, left_buf)\n", "description": "a web proxy tool", "file_name": "smart_route.py", "id": "9eb948968ac510ea733cdc5553ee5fcb", "language": "Python", "project_name": "XX-Net", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/XX-net-XX-Net/XX-net-XX-Net-673a005/code/default/smart_router/local/smart_route.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:03Z", "url": "https://github.com/XX-net/XX-Net", "wiki": true}