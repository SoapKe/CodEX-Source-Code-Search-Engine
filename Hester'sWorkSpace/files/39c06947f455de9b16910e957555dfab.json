{"author": "donnemartin", "code": "from __future__ import division\n\nimport sys\n\n\nclass MinHeap(object):\n\n    def __init__(self):\n        self.array = []\n\n    def __len__(self):\n        return len(self.array)\n\n    def extract_min(self):\n        if not self.array:\n            return None\n        if len(self.array) == 1:\n            return self.array.pop(0)\n        minimum = self.array[0]\n        \n        self.array[0] = self.array.pop(-1)\n        self._bubble_down(index=0)\n        return minimum\n\n    def peek_min(self):\n        return self.array[0] if self.array else None\n\n    def insert(self, key):\n        if key is None:\n            raise TypeError('key cannot be None')\n        self.array.append(key)\n        self._bubble_up(index=len(self.array)-1)\n\n    def _bubble_up(self, index):\n        if index == 0:\n            return\n        index_parent = (index-1) // 2\n        if self.array[index] < self.array[index_parent]:\n            \n            self.array[index], self.array[index_parent] = \\\n                self.array[index_parent], self.array[index]\n            self._bubble_up(index_parent)\n\n    def _bubble_down(self, index):\n        min_child_index = self._find_smaller_child(index)\n        if min_child_index == -1:\n            return\n        if self.array[index] > self.array[min_child_index]:\n            \n            self.array[index], self.array[min_child_index] = \\\n                self.array[min_child_index], self.array[index]\n            self._bubble_down(min_child_index)\n\n    def _find_smaller_child(self, index):\n        left_child_index = 2 * index + 1\n        right_child_index = 2 * index + 2\n        if right_child_index >= len(self.array):\n            if left_child_index >= len(self.array):\n                return -1\n            else:\n                return left_child_index\n        else:\n            if self.array[left_child_index] < self.array[right_child_index]:\n                return left_child_index\n            else:\n                return right_child_index", "comments": "move last element root swap indices recurse swap indices recurse", "content": "from __future__ import division\n\nimport sys\n\n\nclass MinHeap(object):\n\n    def __init__(self):\n        self.array = []\n\n    def __len__(self):\n        return len(self.array)\n\n    def extract_min(self):\n        if not self.array:\n            return None\n        if len(self.array) == 1:\n            return self.array.pop(0)\n        minimum = self.array[0]\n        # Move the last element to the root\n        self.array[0] = self.array.pop(-1)\n        self._bubble_down(index=0)\n        return minimum\n\n    def peek_min(self):\n        return self.array[0] if self.array else None\n\n    def insert(self, key):\n        if key is None:\n            raise TypeError('key cannot be None')\n        self.array.append(key)\n        self._bubble_up(index=len(self.array)-1)\n\n    def _bubble_up(self, index):\n        if index == 0:\n            return\n        index_parent = (index-1) // 2\n        if self.array[index] < self.array[index_parent]:\n            # Swap the indices and recurse\n            self.array[index], self.array[index_parent] = \\\n                self.array[index_parent], self.array[index]\n            self._bubble_up(index_parent)\n\n    def _bubble_down(self, index):\n        min_child_index = self._find_smaller_child(index)\n        if min_child_index == -1:\n            return\n        if self.array[index] > self.array[min_child_index]:\n            # Swap the indices and recurse\n            self.array[index], self.array[min_child_index] = \\\n                self.array[min_child_index], self.array[index]\n            self._bubble_down(min_child_index)\n\n    def _find_smaller_child(self, index):\n        left_child_index = 2 * index + 1\n        right_child_index = 2 * index + 2\n        if right_child_index >= len(self.array):\n            if left_child_index >= len(self.array):\n                return -1\n            else:\n                return left_child_index\n        else:\n            if self.array[left_child_index] < self.array[right_child_index]:\n                return left_child_index\n            else:\n                return right_child_index", "description": "Interactive Python coding interview challenges (algorithms and data structures).  Includes Anki flashcards.", "file_name": "min_heap.py", "id": "39c06947f455de9b16910e957555dfab", "language": "Python", "project_name": "interactive-coding-challenges", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/donnemartin-interactive-coding-challenges/donnemartin-interactive-coding-challenges-6eb3114/graphs_trees/min_heap/min_heap.py", "save_time": "", "source": "", "update_at": "2018-03-13T21:01:52Z", "url": "https://github.com/donnemartin/interactive-coding-challenges", "wiki": true}