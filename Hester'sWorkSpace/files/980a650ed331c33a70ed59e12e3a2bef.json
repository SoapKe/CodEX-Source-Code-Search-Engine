{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    parse_duration,\n    unified_strdate,\n    str_to_int,\n    int_or_none,\n    float_or_none,\n    ISO639Utils,\n    determine_ext,\n)\n\n\nclass AdobeTVBaseIE(InfoExtractor):\n    _API_BASE_URL = 'http://tv.adobe.com/api/v4/'\n\n\nclass AdobeTVIE(AdobeTVBaseIE):\n    _VALID_URL = r'https?://tv\\.adobe\\.com/(?:(?P<language>fr|de|es|jp)/)?watch/(?P<show_urlname>[^/]+)/(?P<id>[^/]+)'\n\n    _TEST = {\n        'url': 'http://tv.adobe.com/watch/the-complete-picture-with-julieanne-kost/quick-tip-how-to-draw-a-circle-around-an-object-in-photoshop/',\n        'md5': '9bc5727bcdd55251f35ad311ca74fa1e',\n        'info_dict': {\n            'id': '10981',\n            'ext': 'mp4',\n            'title': 'Quick Tip - How to Draw a Circle Around an Object in Photoshop',\n            'description': 'md5:99ec318dc909d7ba2a1f2b038f7d2311',\n            'thumbnail': r're:https?://.*\\.jpg$',\n            'upload_date': '20110914',\n            'duration': 60,\n            'view_count': int,\n        },\n    }\n\n    def _real_extract(self, url):\n        language, show_urlname, urlname = re.match(self._VALID_URL, url).groups()\n        if not language:\n            language = 'en'\n\n        video_data = self._download_json(\n            self._API_BASE_URL + 'episode/get/?language=%s&show_urlname=%s&urlname=%s&disclosure=standard' % (language, show_urlname, urlname),\n            urlname)['data'][0]\n\n        formats = [{\n            'url': source['url'],\n            'format_id': source.get('quality_level') or source['url'].split('-')[-1].split('.')[0] or None,\n            'width': int_or_none(source.get('width')),\n            'height': int_or_none(source.get('height')),\n            'tbr': int_or_none(source.get('video_data_rate')),\n        } for source in video_data['videos']]\n        self._sort_formats(formats)\n\n        return {\n            'id': compat_str(video_data['id']),\n            'title': video_data['title'],\n            'description': video_data.get('description'),\n            'thumbnail': video_data.get('thumbnail'),\n            'upload_date': unified_strdate(video_data.get('start_date')),\n            'duration': parse_duration(video_data.get('duration')),\n            'view_count': str_to_int(video_data.get('playcount')),\n            'formats': formats,\n        }\n\n\nclass AdobeTVPlaylistBaseIE(AdobeTVBaseIE):\n    def _parse_page_data(self, page_data):\n        return [self.url_result(self._get_element_url(element_data)) for element_data in page_data]\n\n    def _extract_playlist_entries(self, url, display_id):\n        page = self._download_json(url, display_id)\n        entries = self._parse_page_data(page['data'])\n        for page_num in range(2, page['paging']['pages'] + 1):\n            entries.extend(self._parse_page_data(\n                self._download_json(url + '&page=%d' % page_num, display_id)['data']))\n        return entries\n\n\nclass AdobeTVShowIE(AdobeTVPlaylistBaseIE):\n    _VALID_URL = r'https?://tv\\.adobe\\.com/(?:(?P<language>fr|de|es|jp)/)?show/(?P<id>[^/]+)'\n\n    _TEST = {\n        'url': 'http://tv.adobe.com/show/the-complete-picture-with-julieanne-kost',\n        'info_dict': {\n            'id': '36',\n            'title': 'The Complete Picture with Julieanne Kost',\n            'description': 'md5:fa50867102dcd1aa0ddf2ab039311b27',\n        },\n        'playlist_mincount': 136,\n    }\n\n    def _get_element_url(self, element_data):\n        return element_data['urls'][0]\n\n    def _real_extract(self, url):\n        language, show_urlname = re.match(self._VALID_URL, url).groups()\n        if not language:\n            language = 'en'\n        query = 'language=%s&show_urlname=%s' % (language, show_urlname)\n\n        show_data = self._download_json(self._API_BASE_URL + 'show/get/?%s' % query, show_urlname)['data'][0]\n\n        return self.playlist_result(\n            self._extract_playlist_entries(self._API_BASE_URL + 'episode/?%s' % query, show_urlname),\n            compat_str(show_data['id']),\n            show_data['show_name'],\n            show_data['show_description'])\n\n\nclass AdobeTVChannelIE(AdobeTVPlaylistBaseIE):\n    _VALID_URL = r'https?://tv\\.adobe\\.com/(?:(?P<language>fr|de|es|jp)/)?channel/(?P<id>[^/]+)(?:/(?P<category_urlname>[^/]+))?'\n\n    _TEST = {\n        'url': 'http://tv.adobe.com/channel/development',\n        'info_dict': {\n            'id': 'development',\n        },\n        'playlist_mincount': 96,\n    }\n\n    def _get_element_url(self, element_data):\n        return element_data['url']\n\n    def _real_extract(self, url):\n        language, channel_urlname, category_urlname = re.match(self._VALID_URL, url).groups()\n        if not language:\n            language = 'en'\n        query = 'language=%s&channel_urlname=%s' % (language, channel_urlname)\n        if category_urlname:\n            query += '&category_urlname=%s' % category_urlname\n\n        return self.playlist_result(\n            self._extract_playlist_entries(self._API_BASE_URL + 'show/?%s' % query, channel_urlname),\n            channel_urlname)\n\n\nclass AdobeTVVideoIE(InfoExtractor):\n    _VALID_URL = r'https?://video\\.tv\\.adobe\\.com/v/(?P<id>\\d+)'\n\n    _TEST = {\n        \n        'url': 'https://video.tv.adobe.com/v/2456/',\n        'md5': '43662b577c018ad707a63766462b1e87',\n        'info_dict': {\n            'id': '2456',\n            'ext': 'mp4',\n            'title': 'New experience with Acrobat DC',\n            'description': 'New experience with Acrobat DC',\n            'duration': 248.667,\n        },\n    }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        webpage = self._download_webpage(url, video_id)\n\n        video_data = self._parse_json(self._search_regex(\n            r'var\\s+bridge\\s*=\\s*([^;]+);', webpage, 'bridged data'), video_id)\n\n        formats = [{\n            'format_id': '%s-%s' % (determine_ext(source['src']), source.get('height')),\n            'url': source['src'],\n            'width': int_or_none(source.get('width')),\n            'height': int_or_none(source.get('height')),\n            'tbr': int_or_none(source.get('bitrate')),\n        } for source in video_data['sources']]\n        self._sort_formats(formats)\n\n        \n        \n        duration = max(filter(None, [\n            float_or_none(source.get('duration'), scale=1000)\n            for source in video_data['sources']]))\n\n        subtitles = {}\n        for translation in video_data.get('translations', []):\n            lang_id = translation.get('language_w3c') or ISO639Utils.long2short(translation['language_medium'])\n            if lang_id not in subtitles:\n                subtitles[lang_id] = []\n            subtitles[lang_id].append({\n                'url': translation['vttPath'],\n                'ext': 'vtt',\n            })\n\n        return {\n            'id': video_id,\n            'formats': formats,\n            'title': video_data['title'],\n            'description': video_data.get('description'),\n            'thumbnail': video_data['video'].get('poster'),\n            'duration': duration,\n            'subtitles': subtitles,\n        }\n", "comments": "# From https://helpx.adobe.com/acrobat/how-to/new-experience-acrobat-dc.html?set=acrobat--get-started--essential-beginners\n# For both metadata and downloaded files the duration varies among\n# formats. I just pick the max one\n", "content": "from __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    parse_duration,\n    unified_strdate,\n    str_to_int,\n    int_or_none,\n    float_or_none,\n    ISO639Utils,\n    determine_ext,\n)\n\n\nclass AdobeTVBaseIE(InfoExtractor):\n    _API_BASE_URL = 'http://tv.adobe.com/api/v4/'\n\n\nclass AdobeTVIE(AdobeTVBaseIE):\n    _VALID_URL = r'https?://tv\\.adobe\\.com/(?:(?P<language>fr|de|es|jp)/)?watch/(?P<show_urlname>[^/]+)/(?P<id>[^/]+)'\n\n    _TEST = {\n        'url': 'http://tv.adobe.com/watch/the-complete-picture-with-julieanne-kost/quick-tip-how-to-draw-a-circle-around-an-object-in-photoshop/',\n        'md5': '9bc5727bcdd55251f35ad311ca74fa1e',\n        'info_dict': {\n            'id': '10981',\n            'ext': 'mp4',\n            'title': 'Quick Tip - How to Draw a Circle Around an Object in Photoshop',\n            'description': 'md5:99ec318dc909d7ba2a1f2b038f7d2311',\n            'thumbnail': r're:https?://.*\\.jpg$',\n            'upload_date': '20110914',\n            'duration': 60,\n            'view_count': int,\n        },\n    }\n\n    def _real_extract(self, url):\n        language, show_urlname, urlname = re.match(self._VALID_URL, url).groups()\n        if not language:\n            language = 'en'\n\n        video_data = self._download_json(\n            self._API_BASE_URL + 'episode/get/?language=%s&show_urlname=%s&urlname=%s&disclosure=standard' % (language, show_urlname, urlname),\n            urlname)['data'][0]\n\n        formats = [{\n            'url': source['url'],\n            'format_id': source.get('quality_level') or source['url'].split('-')[-1].split('.')[0] or None,\n            'width': int_or_none(source.get('width')),\n            'height': int_or_none(source.get('height')),\n            'tbr': int_or_none(source.get('video_data_rate')),\n        } for source in video_data['videos']]\n        self._sort_formats(formats)\n\n        return {\n            'id': compat_str(video_data['id']),\n            'title': video_data['title'],\n            'description': video_data.get('description'),\n            'thumbnail': video_data.get('thumbnail'),\n            'upload_date': unified_strdate(video_data.get('start_date')),\n            'duration': parse_duration(video_data.get('duration')),\n            'view_count': str_to_int(video_data.get('playcount')),\n            'formats': formats,\n        }\n\n\nclass AdobeTVPlaylistBaseIE(AdobeTVBaseIE):\n    def _parse_page_data(self, page_data):\n        return [self.url_result(self._get_element_url(element_data)) for element_data in page_data]\n\n    def _extract_playlist_entries(self, url, display_id):\n        page = self._download_json(url, display_id)\n        entries = self._parse_page_data(page['data'])\n        for page_num in range(2, page['paging']['pages'] + 1):\n            entries.extend(self._parse_page_data(\n                self._download_json(url + '&page=%d' % page_num, display_id)['data']))\n        return entries\n\n\nclass AdobeTVShowIE(AdobeTVPlaylistBaseIE):\n    _VALID_URL = r'https?://tv\\.adobe\\.com/(?:(?P<language>fr|de|es|jp)/)?show/(?P<id>[^/]+)'\n\n    _TEST = {\n        'url': 'http://tv.adobe.com/show/the-complete-picture-with-julieanne-kost',\n        'info_dict': {\n            'id': '36',\n            'title': 'The Complete Picture with Julieanne Kost',\n            'description': 'md5:fa50867102dcd1aa0ddf2ab039311b27',\n        },\n        'playlist_mincount': 136,\n    }\n\n    def _get_element_url(self, element_data):\n        return element_data['urls'][0]\n\n    def _real_extract(self, url):\n        language, show_urlname = re.match(self._VALID_URL, url).groups()\n        if not language:\n            language = 'en'\n        query = 'language=%s&show_urlname=%s' % (language, show_urlname)\n\n        show_data = self._download_json(self._API_BASE_URL + 'show/get/?%s' % query, show_urlname)['data'][0]\n\n        return self.playlist_result(\n            self._extract_playlist_entries(self._API_BASE_URL + 'episode/?%s' % query, show_urlname),\n            compat_str(show_data['id']),\n            show_data['show_name'],\n            show_data['show_description'])\n\n\nclass AdobeTVChannelIE(AdobeTVPlaylistBaseIE):\n    _VALID_URL = r'https?://tv\\.adobe\\.com/(?:(?P<language>fr|de|es|jp)/)?channel/(?P<id>[^/]+)(?:/(?P<category_urlname>[^/]+))?'\n\n    _TEST = {\n        'url': 'http://tv.adobe.com/channel/development',\n        'info_dict': {\n            'id': 'development',\n        },\n        'playlist_mincount': 96,\n    }\n\n    def _get_element_url(self, element_data):\n        return element_data['url']\n\n    def _real_extract(self, url):\n        language, channel_urlname, category_urlname = re.match(self._VALID_URL, url).groups()\n        if not language:\n            language = 'en'\n        query = 'language=%s&channel_urlname=%s' % (language, channel_urlname)\n        if category_urlname:\n            query += '&category_urlname=%s' % category_urlname\n\n        return self.playlist_result(\n            self._extract_playlist_entries(self._API_BASE_URL + 'show/?%s' % query, channel_urlname),\n            channel_urlname)\n\n\nclass AdobeTVVideoIE(InfoExtractor):\n    _VALID_URL = r'https?://video\\.tv\\.adobe\\.com/v/(?P<id>\\d+)'\n\n    _TEST = {\n        # From https://helpx.adobe.com/acrobat/how-to/new-experience-acrobat-dc.html?set=acrobat--get-started--essential-beginners\n        'url': 'https://video.tv.adobe.com/v/2456/',\n        'md5': '43662b577c018ad707a63766462b1e87',\n        'info_dict': {\n            'id': '2456',\n            'ext': 'mp4',\n            'title': 'New experience with Acrobat DC',\n            'description': 'New experience with Acrobat DC',\n            'duration': 248.667,\n        },\n    }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        webpage = self._download_webpage(url, video_id)\n\n        video_data = self._parse_json(self._search_regex(\n            r'var\\s+bridge\\s*=\\s*([^;]+);', webpage, 'bridged data'), video_id)\n\n        formats = [{\n            'format_id': '%s-%s' % (determine_ext(source['src']), source.get('height')),\n            'url': source['src'],\n            'width': int_or_none(source.get('width')),\n            'height': int_or_none(source.get('height')),\n            'tbr': int_or_none(source.get('bitrate')),\n        } for source in video_data['sources']]\n        self._sort_formats(formats)\n\n        # For both metadata and downloaded files the duration varies among\n        # formats. I just pick the max one\n        duration = max(filter(None, [\n            float_or_none(source.get('duration'), scale=1000)\n            for source in video_data['sources']]))\n\n        subtitles = {}\n        for translation in video_data.get('translations', []):\n            lang_id = translation.get('language_w3c') or ISO639Utils.long2short(translation['language_medium'])\n            if lang_id not in subtitles:\n                subtitles[lang_id] = []\n            subtitles[lang_id].append({\n                'url': translation['vttPath'],\n                'ext': 'vtt',\n            })\n\n        return {\n            'id': video_id,\n            'formats': formats,\n            'title': video_data['title'],\n            'description': video_data.get('description'),\n            'thumbnail': video_data['video'].get('poster'),\n            'duration': duration,\n            'subtitles': subtitles,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "adobetv.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/adobetv.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}