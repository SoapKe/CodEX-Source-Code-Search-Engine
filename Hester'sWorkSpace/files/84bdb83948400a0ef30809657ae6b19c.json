{"author": "jakubroztocil", "code": "\n    args = decode_args(args, env.stdin_encoding)\n    plugin_manager.load_installed_plugins()\n\n    def log_error(msg, *args, **kwargs):\n        msg = msg % args\n        level = kwargs.get('level', 'error')\n        assert level in ['error', 'warning']\n        env.stderr.write('\\nhttp: %s: %s\\n' % (level, msg))\n\n    from httpie.cli import parser\n\n    if env.config.default_options:\n        args = env.config.default_options + args\n\n    if custom_log_error:\n        log_error = custom_log_error\n\n    include_debug_info = '--debug' in args\n    include_traceback = include_debug_info or '--traceback' in args\n\n    if include_debug_info:\n        print_debug_info(env)\n        if args == ['--debug']:\n            return ExitStatus.OK\n\n    exit_status = ExitStatus.OK\n\n    try:\n        parsed_args = parser.parse_args(args=args, env=env)\n    except KeyboardInterrupt:\n        env.stderr.write('\\n')\n        if include_traceback:\n            raise\n        exit_status = ExitStatus.ERROR_CTRL_C\n    except SystemExit as e:\n        if e.code != ExitStatus.OK:\n            env.stderr.write('\\n')\n            if include_traceback:\n                raise\n            exit_status = ExitStatus.ERROR\n    else:\n        try:\n            exit_status = program(\n                args=parsed_args,\n                env=env,\n                log_error=log_error,\n            )\n        except KeyboardInterrupt:\n            env.stderr.write('\\n')\n            if include_traceback:\n                raise\n            exit_status = ExitStatus.ERROR_CTRL_C\n        except SystemExit as e:\n            if e.code != ExitStatus.OK:\n                env.stderr.write('\\n')\n                if include_traceback:\n                    raise\n                exit_status = ExitStatus.ERROR\n        except requests.Timeout:\n            exit_status = ExitStatus.ERROR_TIMEOUT\n            log_error('Request timed out (%ss).', parsed_args.timeout)\n        except requests.TooManyRedirects:\n            exit_status = ExitStatus.ERROR_TOO_MANY_REDIRECTS\n            log_error('Too many redirects (--max-redirects=%s).',\n                      parsed_args.max_redirects)\n        except Exception as e:\n            \n            msg = str(e)\n            if hasattr(e, 'request'):\n                request = e.request\n                if hasattr(request, 'url'):\n                    msg += ' while doing %s request to URL: %s' % (\n                        request.method, request.url)\n            log_error('%s: %s', type(e).__name__, msg)\n            if include_traceback:\n                raise\n            exit_status = ExitStatus.ERROR\n\n    return exit_status\n", "comments": "This module provides the main functionality of HTTPie.\n\nInvocation flow:\n\n  1. Read, validate and process the input (args, `stdin`).\n  2. Create and send a request.\n  3. Stream, and possibly process and format, the parts\n     of the request-response exchange selected by output options.\n  4. Simultaneously write to `stdout`\n  5. Exit.\n\n\"\"\"\nimport sys\nimport errno\nimport platform\n\nimport requests\nfrom requests import __version__ as requests_version\nfrom pygments import __version__ as pygments_version\n\nfrom httpie import __version__ as httpie_version, ExitStatus\nfrom httpie.compat import str, bytes, is_py3\nfrom httpie.client import get_response\nfrom httpie.downloads import Downloader\nfrom httpie.context import Environment\nfrom httpie.plugins import plugin_manager\nfrom httpie.output.streams import (\n    build_output_stream,\n    write_stream,\n    write_stream_with_colors_win_py3\n)\n\n\ndef get_exit_status(http_status, follow=False):\n    \"\"\"Translate HTTP status code to exit status code.\"\"\"\n    if 300 <= http_status <= 399 and not follow:\n        # Redirect\n        return ExitStatus.ERROR_HTTP_3XX\n    elif 400 <= http_status <= 499:\n        # Client Error\n        return ExitStatus.ERROR_HTTP_4XX\n    elif 500 <= http_status <= 599:\n        # Server Error\n        return ExitStatus.ERROR_HTTP_5XX\n    else:\n        return ExitStatus.OK\n\n\ndef print_debug_info(env):\n    env.stderr.writelines([\n        'HTTPie %s\\n' % httpie_version,\n        'Requests %s\\n' % requests_version,\n        'Pygments %s\\n' % pygments_version,\n        'Python %s\\n%s\\n' % (sys.version, sys.executable),\n        '%s %s' % (platform.system(), platform.release()),\n    ])\n    env.stderr.write('\\n\\n')\n    env.stderr.write(repr(env))\n    env.stderr.write('\\n')\n\n\ndef decode_args(args, stdin_encoding):\n    \"\"\"\n    Convert all bytes args to str\n    by decoding them using stdin encoding.\n\n    \"\"\"\n    return [\n        arg.decode(stdin_encoding)\n        if type(arg) == bytes else arg\n        for arg in args\n    ]\n\n\ndef program(args, env, log_error):\n    \"\"\"\n    The main program without error handling\n\n    :param args: parsed args (argparse.Namespace)\n    :type env: Environment\n    :param log_error: error log function\n    :return: status code\n\n    \"\"\"\n    exit_status = ExitStatus.OK\n    downloader = None\n    show_traceback = args.debug or args.traceback\n\n    try:\n        if args.download:\n            args.follow = True  # --download implies --follow.\n            downloader = Downloader(\n                output_file=args.output_file,\n                progress_file=env.stderr,\n                resume=args.download_resume\n            )\n            downloader.pre_request(args.headers)\n\n        final_response = get_response(args, config_dir=env.config.directory)\n        if args.all:\n            responses = final_response.history + [final_response]\n        else:\n            responses = [final_response]\n\n        for response in responses:\n\n            if args.check_status or downloader:\n                exit_status = get_exit_status(\n                    http_status=response.status_code,\n                    follow=args.follow\n                )\n                if not env.stdout_isatty and exit_status != ExitStatus.OK:\n                    log_error(\n                        'HTTP %s %s', response.raw.status, response.raw.reason,\n                        level='warning'\n                    )\n\n            write_stream_kwargs = {\n                'stream': build_output_stream(\n                    args=args,\n                    env=env,\n                    request=response.request,\n                    response=response,\n                    output_options=(\n                        args.output_options\n                        if response is final_response\n                        else args.output_options_history\n                    )\n                ),\n                # NOTE: `env.stdout` will in fact be `stderr` with `--download`\n                'outfile': env.stdout,\n                'flush': env.stdout_isatty or args.stream\n            }\n            try:\n                if env.is_windows and is_py3 and 'colors' in args.prettify:\n                    write_stream_with_colors_win_py3(**write_stream_kwargs)\n                else:\n                    write_stream(**write_stream_kwargs)\n            except IOError as e:\n                if not show_traceback and e.errno == errno.EPIPE:\n                    # Ignore broken pipes unless --traceback.\n                    env.stderr.write('\\n')\n                else:\n                    raise\n\n        if downloader and exit_status == ExitStatus.OK:\n            # Last response body download.\n            download_stream, download_to = downloader.start(final_response)\n            write_stream(\n                stream=download_stream,\n                outfile=download_to,\n                flush=False,\n            )\n            downloader.finish()\n            if downloader.interrupted:\n                exit_status = ExitStatus.ERROR\n                log_error('Incomplete download: size=%d; downloaded=%d' % (\n                    downloader.status.total_size,\n                    downloader.status.downloaded\n                ))\n        return exit_status\n\n    finally:\n        if downloader and not downloader.finished:\n            downloader.failed()\n\n        if (not isinstance(args, list) and args.output_file and\n                args.output_file_specified):\n            args.output_file.close()\n\n\ndef main(args=sys.argv[1:], env=Environment(), custom_log_error=None):\n    \"\"\"\n    The main function.\n\n    Pre-process args, handle some special types of invocations,\n    and run the main program with error handling.\n\n    Return exit status code.\n\n    \n \n# TODO: Further distinction between expected and unexpected errors.\n", "content": "\"\"\"This module provides the main functionality of HTTPie.\n\nInvocation flow:\n\n  1. Read, validate and process the input (args, `stdin`).\n  2. Create and send a request.\n  3. Stream, and possibly process and format, the parts\n     of the request-response exchange selected by output options.\n  4. Simultaneously write to `stdout`\n  5. Exit.\n\n\"\"\"\nimport sys\nimport errno\nimport platform\n\nimport requests\nfrom requests import __version__ as requests_version\nfrom pygments import __version__ as pygments_version\n\nfrom httpie import __version__ as httpie_version, ExitStatus\nfrom httpie.compat import str, bytes, is_py3\nfrom httpie.client import get_response\nfrom httpie.downloads import Downloader\nfrom httpie.context import Environment\nfrom httpie.plugins import plugin_manager\nfrom httpie.output.streams import (\n    build_output_stream,\n    write_stream,\n    write_stream_with_colors_win_py3\n)\n\n\ndef get_exit_status(http_status, follow=False):\n    \"\"\"Translate HTTP status code to exit status code.\"\"\"\n    if 300 <= http_status <= 399 and not follow:\n        # Redirect\n        return ExitStatus.ERROR_HTTP_3XX\n    elif 400 <= http_status <= 499:\n        # Client Error\n        return ExitStatus.ERROR_HTTP_4XX\n    elif 500 <= http_status <= 599:\n        # Server Error\n        return ExitStatus.ERROR_HTTP_5XX\n    else:\n        return ExitStatus.OK\n\n\ndef print_debug_info(env):\n    env.stderr.writelines([\n        'HTTPie %s\\n' % httpie_version,\n        'Requests %s\\n' % requests_version,\n        'Pygments %s\\n' % pygments_version,\n        'Python %s\\n%s\\n' % (sys.version, sys.executable),\n        '%s %s' % (platform.system(), platform.release()),\n    ])\n    env.stderr.write('\\n\\n')\n    env.stderr.write(repr(env))\n    env.stderr.write('\\n')\n\n\ndef decode_args(args, stdin_encoding):\n    \"\"\"\n    Convert all bytes args to str\n    by decoding them using stdin encoding.\n\n    \"\"\"\n    return [\n        arg.decode(stdin_encoding)\n        if type(arg) == bytes else arg\n        for arg in args\n    ]\n\n\ndef program(args, env, log_error):\n    \"\"\"\n    The main program without error handling\n\n    :param args: parsed args (argparse.Namespace)\n    :type env: Environment\n    :param log_error: error log function\n    :return: status code\n\n    \"\"\"\n    exit_status = ExitStatus.OK\n    downloader = None\n    show_traceback = args.debug or args.traceback\n\n    try:\n        if args.download:\n            args.follow = True  # --download implies --follow.\n            downloader = Downloader(\n                output_file=args.output_file,\n                progress_file=env.stderr,\n                resume=args.download_resume\n            )\n            downloader.pre_request(args.headers)\n\n        final_response = get_response(args, config_dir=env.config.directory)\n        if args.all:\n            responses = final_response.history + [final_response]\n        else:\n            responses = [final_response]\n\n        for response in responses:\n\n            if args.check_status or downloader:\n                exit_status = get_exit_status(\n                    http_status=response.status_code,\n                    follow=args.follow\n                )\n                if not env.stdout_isatty and exit_status != ExitStatus.OK:\n                    log_error(\n                        'HTTP %s %s', response.raw.status, response.raw.reason,\n                        level='warning'\n                    )\n\n            write_stream_kwargs = {\n                'stream': build_output_stream(\n                    args=args,\n                    env=env,\n                    request=response.request,\n                    response=response,\n                    output_options=(\n                        args.output_options\n                        if response is final_response\n                        else args.output_options_history\n                    )\n                ),\n                # NOTE: `env.stdout` will in fact be `stderr` with `--download`\n                'outfile': env.stdout,\n                'flush': env.stdout_isatty or args.stream\n            }\n            try:\n                if env.is_windows and is_py3 and 'colors' in args.prettify:\n                    write_stream_with_colors_win_py3(**write_stream_kwargs)\n                else:\n                    write_stream(**write_stream_kwargs)\n            except IOError as e:\n                if not show_traceback and e.errno == errno.EPIPE:\n                    # Ignore broken pipes unless --traceback.\n                    env.stderr.write('\\n')\n                else:\n                    raise\n\n        if downloader and exit_status == ExitStatus.OK:\n            # Last response body download.\n            download_stream, download_to = downloader.start(final_response)\n            write_stream(\n                stream=download_stream,\n                outfile=download_to,\n                flush=False,\n            )\n            downloader.finish()\n            if downloader.interrupted:\n                exit_status = ExitStatus.ERROR\n                log_error('Incomplete download: size=%d; downloaded=%d' % (\n                    downloader.status.total_size,\n                    downloader.status.downloaded\n                ))\n        return exit_status\n\n    finally:\n        if downloader and not downloader.finished:\n            downloader.failed()\n\n        if (not isinstance(args, list) and args.output_file and\n                args.output_file_specified):\n            args.output_file.close()\n\n\ndef main(args=sys.argv[1:], env=Environment(), custom_log_error=None):\n    \"\"\"\n    The main function.\n\n    Pre-process args, handle some special types of invocations,\n    and run the main program with error handling.\n\n    Return exit status code.\n\n    \"\"\"\n    args = decode_args(args, env.stdin_encoding)\n    plugin_manager.load_installed_plugins()\n\n    def log_error(msg, *args, **kwargs):\n        msg = msg % args\n        level = kwargs.get('level', 'error')\n        assert level in ['error', 'warning']\n        env.stderr.write('\\nhttp: %s: %s\\n' % (level, msg))\n\n    from httpie.cli import parser\n\n    if env.config.default_options:\n        args = env.config.default_options + args\n\n    if custom_log_error:\n        log_error = custom_log_error\n\n    include_debug_info = '--debug' in args\n    include_traceback = include_debug_info or '--traceback' in args\n\n    if include_debug_info:\n        print_debug_info(env)\n        if args == ['--debug']:\n            return ExitStatus.OK\n\n    exit_status = ExitStatus.OK\n\n    try:\n        parsed_args = parser.parse_args(args=args, env=env)\n    except KeyboardInterrupt:\n        env.stderr.write('\\n')\n        if include_traceback:\n            raise\n        exit_status = ExitStatus.ERROR_CTRL_C\n    except SystemExit as e:\n        if e.code != ExitStatus.OK:\n            env.stderr.write('\\n')\n            if include_traceback:\n                raise\n            exit_status = ExitStatus.ERROR\n    else:\n        try:\n            exit_status = program(\n                args=parsed_args,\n                env=env,\n                log_error=log_error,\n            )\n        except KeyboardInterrupt:\n            env.stderr.write('\\n')\n            if include_traceback:\n                raise\n            exit_status = ExitStatus.ERROR_CTRL_C\n        except SystemExit as e:\n            if e.code != ExitStatus.OK:\n                env.stderr.write('\\n')\n                if include_traceback:\n                    raise\n                exit_status = ExitStatus.ERROR\n        except requests.Timeout:\n            exit_status = ExitStatus.ERROR_TIMEOUT\n            log_error('Request timed out (%ss).', parsed_args.timeout)\n        except requests.TooManyRedirects:\n            exit_status = ExitStatus.ERROR_TOO_MANY_REDIRECTS\n            log_error('Too many redirects (--max-redirects=%s).',\n                      parsed_args.max_redirects)\n        except Exception as e:\n            # TODO: Further distinction between expected and unexpected errors.\n            msg = str(e)\n            if hasattr(e, 'request'):\n                request = e.request\n                if hasattr(request, 'url'):\n                    msg += ' while doing %s request to URL: %s' % (\n                        request.method, request.url)\n            log_error('%s: %s', type(e).__name__, msg)\n            if include_traceback:\n                raise\n            exit_status = ExitStatus.ERROR\n\n    return exit_status\n", "description": "Modern command line HTTP client \u2013 user-friendly curl alternative with intuitive UI, JSON support, syntax highlighting, wget-like downloads, extensions, etc.  https://httpie.org", "file_name": "core.py", "language": "Python", "project_name": "httpie", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/jakubroztocil_httpie/jakubroztocil-httpie-0f4dce9/httpie/core.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:20:06Z", "url": "https://github.com/jakubroztocil/httpie", "wiki": false}