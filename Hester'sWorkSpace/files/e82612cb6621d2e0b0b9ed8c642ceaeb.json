{"author": "littlecodersh", "code": "import logging, traceback, sys, threading\ntry:\n    import Queue\nexcept ImportError:\n    import queue as Queue\n\nfrom ..log import set_logging\nfrom ..utils import test_connect\nfrom ..storage import templates\n\nlogger = logging.getLogger('itchat')\n\ndef load_register(core):\n    core.auto_login       = auto_login\n    core.configured_reply = configured_reply\n    core.msg_register     = msg_register\n    core.run              = run\n\ndef auto_login(self, hotReload=False, statusStorageDir='itchat.pkl',\n        enableCmdQR=False, picDir=None, qrCallback=None,\n        loginCallback=None, exitCallback=None):\n    if not test_connect():\n        logger.info(\"You can't get access to internet or wechat domain, so exit.\")\n        sys.exit()\n    self.useHotReload = hotReload\n    self.hotReloadDir = statusStorageDir\n    if hotReload:\n        if self.load_login_status(statusStorageDir,\n                loginCallback=loginCallback, exitCallback=exitCallback):\n            return\n        self.login(enableCmdQR=enableCmdQR, picDir=picDir, qrCallback=qrCallback,\n            loginCallback=loginCallback, exitCallback=exitCallback)\n        self.dump_login_status(statusStorageDir)\n    else:\n        self.login(enableCmdQR=enableCmdQR, picDir=picDir, qrCallback=qrCallback,\n            loginCallback=loginCallback, exitCallback=exitCallback)\n\ndef configured_reply(self):\n    ''' determine the type of message and reply if its method is defined\n        however, I use a strange way to determine whether a msg is from massive platform\n        I haven't found a better solution here\n        The main problem I'm worrying about is the mismatching of new friends added on phone\n        If you have any good idea, pleeeease report an issue. I will be more than grateful.\n    '''\n    try:\n        msg = self.msgList.get(timeout=1)\n    except Queue.Empty:\n        pass\n    else:\n        if isinstance(msg['User'], templates.User):\n            replyFn = self.functionDict['FriendChat'].get(msg['Type'])\n        elif isinstance(msg['User'], templates.MassivePlatform):\n            replyFn = self.functionDict['MpChat'].get(msg['Type'])\n        elif isinstance(msg['User'], templates.Chatroom):\n            replyFn = self.functionDict['GroupChat'].get(msg['Type'])\n        if replyFn is None:\n            r = None\n        else:\n            try:\n                r = replyFn(msg)\n                if r is not None:\n                    self.send(r, msg.get('FromUserName'))\n            except:\n                logger.warning(traceback.format_exc())\n\ndef msg_register(self, msgType, isFriendChat=False, isGroupChat=False, isMpChat=False):\n    ''' a decorator constructor\n        return a specific decorator based on information given '''\n    if not (isinstance(msgType, list) or isinstance(msgType, tuple)):\n        msgType = [msgType]\n    def _msg_register(fn):\n        for _msgType in msgType:\n            if isFriendChat:\n                self.functionDict['FriendChat'][_msgType] = fn\n            if isGroupChat:\n                self.functionDict['GroupChat'][_msgType] = fn\n            if isMpChat:\n                self.functionDict['MpChat'][_msgType] = fn\n            if not any((isFriendChat, isGroupChat, isMpChat)):\n                self.functionDict['FriendChat'][_msgType] = fn\n        return fn\n    return _msg_register\n\ndef run(self, debug=False, blockThread=True):\n    logger.info('Start auto replying.')\n    if debug:\n        set_logging(loggingLevel=logging.DEBUG)\n    def reply_fn():\n        try:\n            while self.alive:\n                self.configured_reply()\n        except KeyboardInterrupt:\n            if self.useHotReload:\n                self.dump_login_status()\n            self.alive = False\n            logger.debug('itchat received an ^C and exit.')\n            logger.info('Bye~')\n    if blockThread:\n        reply_fn()\n    else:\n        replyThread = threading.Thread(target=reply_fn)\n        replyThread.setDaemon(True)\n        replyThread.start()\n", "comments": "    determine type message reply method defined         however  i use strange way determine whether msg massive platform         i found better solution         the main problem i worrying mismatching new friends added phone         if good idea  pleeeease report issue  i grateful              try          msg   self msglist get(timeout 1)     except queue empty          pass     else          isinstance(msg  user    templates user)              replyfn   self functiondict  friendchat   get(msg  type  )         elif isinstance(msg  user    templates massiveplatform)              replyfn   self functiondict  mpchat   get(msg  type  )         elif isinstance(msg  user    templates chatroom)              replyfn   self functiondict  groupchat   get(msg  type  )         replyfn none              r   none         else              try                  r   replyfn(msg)                 r none                      self send(r  msg get( fromusername ))             except                  logger warning(traceback format exc())  def msg register(self  msgtype  isfriendchat false  isgroupchat false  ismpchat false)          decorator constructor         return specific decorator based information given     ", "content": "import logging, traceback, sys, threading\ntry:\n    import Queue\nexcept ImportError:\n    import queue as Queue\n\nfrom ..log import set_logging\nfrom ..utils import test_connect\nfrom ..storage import templates\n\nlogger = logging.getLogger('itchat')\n\ndef load_register(core):\n    core.auto_login       = auto_login\n    core.configured_reply = configured_reply\n    core.msg_register     = msg_register\n    core.run              = run\n\ndef auto_login(self, hotReload=False, statusStorageDir='itchat.pkl',\n        enableCmdQR=False, picDir=None, qrCallback=None,\n        loginCallback=None, exitCallback=None):\n    if not test_connect():\n        logger.info(\"You can't get access to internet or wechat domain, so exit.\")\n        sys.exit()\n    self.useHotReload = hotReload\n    self.hotReloadDir = statusStorageDir\n    if hotReload:\n        if self.load_login_status(statusStorageDir,\n                loginCallback=loginCallback, exitCallback=exitCallback):\n            return\n        self.login(enableCmdQR=enableCmdQR, picDir=picDir, qrCallback=qrCallback,\n            loginCallback=loginCallback, exitCallback=exitCallback)\n        self.dump_login_status(statusStorageDir)\n    else:\n        self.login(enableCmdQR=enableCmdQR, picDir=picDir, qrCallback=qrCallback,\n            loginCallback=loginCallback, exitCallback=exitCallback)\n\ndef configured_reply(self):\n    ''' determine the type of message and reply if its method is defined\n        however, I use a strange way to determine whether a msg is from massive platform\n        I haven't found a better solution here\n        The main problem I'm worrying about is the mismatching of new friends added on phone\n        If you have any good idea, pleeeease report an issue. I will be more than grateful.\n    '''\n    try:\n        msg = self.msgList.get(timeout=1)\n    except Queue.Empty:\n        pass\n    else:\n        if isinstance(msg['User'], templates.User):\n            replyFn = self.functionDict['FriendChat'].get(msg['Type'])\n        elif isinstance(msg['User'], templates.MassivePlatform):\n            replyFn = self.functionDict['MpChat'].get(msg['Type'])\n        elif isinstance(msg['User'], templates.Chatroom):\n            replyFn = self.functionDict['GroupChat'].get(msg['Type'])\n        if replyFn is None:\n            r = None\n        else:\n            try:\n                r = replyFn(msg)\n                if r is not None:\n                    self.send(r, msg.get('FromUserName'))\n            except:\n                logger.warning(traceback.format_exc())\n\ndef msg_register(self, msgType, isFriendChat=False, isGroupChat=False, isMpChat=False):\n    ''' a decorator constructor\n        return a specific decorator based on information given '''\n    if not (isinstance(msgType, list) or isinstance(msgType, tuple)):\n        msgType = [msgType]\n    def _msg_register(fn):\n        for _msgType in msgType:\n            if isFriendChat:\n                self.functionDict['FriendChat'][_msgType] = fn\n            if isGroupChat:\n                self.functionDict['GroupChat'][_msgType] = fn\n            if isMpChat:\n                self.functionDict['MpChat'][_msgType] = fn\n            if not any((isFriendChat, isGroupChat, isMpChat)):\n                self.functionDict['FriendChat'][_msgType] = fn\n        return fn\n    return _msg_register\n\ndef run(self, debug=False, blockThread=True):\n    logger.info('Start auto replying.')\n    if debug:\n        set_logging(loggingLevel=logging.DEBUG)\n    def reply_fn():\n        try:\n            while self.alive:\n                self.configured_reply()\n        except KeyboardInterrupt:\n            if self.useHotReload:\n                self.dump_login_status()\n            self.alive = False\n            logger.debug('itchat received an ^C and exit.')\n            logger.info('Bye~')\n    if blockThread:\n        reply_fn()\n    else:\n        replyThread = threading.Thread(target=reply_fn)\n        replyThread.setDaemon(True)\n        replyThread.start()\n", "description": "A complete and graceful API for Wechat. \u5fae\u4fe1\u4e2a\u4eba\u53f7\u63a5\u53e3\u3001\u5fae\u4fe1\u673a\u5668\u4eba\u53ca\u547d\u4ee4\u884c\u5fae\u4fe1\uff0c\u4e09\u5341\u884c\u5373\u53ef\u81ea\u5b9a\u4e49\u4e2a\u4eba\u53f7\u673a\u5668\u4eba\u3002", "file_name": "register.py", "id": "e82612cb6621d2e0b0b9ed8c642ceaeb", "language": "Python", "project_name": "ItChat", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/littlecodersh-ItChat/littlecodersh-ItChat-8622c3c/itchat/components/register.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:54:42Z", "url": "https://github.com/littlecodersh/ItChat", "wiki": true}