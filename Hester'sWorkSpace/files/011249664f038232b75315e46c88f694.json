{"author": "ansible", "code": "\n -*- coding: utf-8 -*-\n\n (c) 2017, Ansible by Red Hat, inc\n\n This file is part of Ansible by Red Hat\n\n Ansible is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Ansible is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'network'}\n\n\nDOCUMENTATION = \"\"\"\n---\nmodule: vyos_interface\nversion_added: \"2.4\"\nauthor: \"Ganesh Nalawade (@ganeshrn)\"\nshort_description: Manage Interface on VyOS network devices\ndescription:\n  - This module provides declarative management of Interfaces\n    on VyOS network devices.\nnotes:\n  - Tested against VYOS 1.1.7\noptions:\n  name:\n    description:\n      - Name of the Interface.\n    required: true\n  description:\n    description:\n      - Description of Interface.\n  enabled:\n    description:\n      - Interface link status.\n  speed:\n    description:\n      - Interface link speed.\n  mtu:\n    description:\n      - Maximum size of transmit packet.\n  duplex:\n    description:\n      - Interface link status.\n    default: auto\n    choices: ['full', 'half', 'auto']\n  delay:\n    description:\n      - Time in seconds to wait before checking for the operational state on remote\n        device. This wait is applicable for operational state argument which are\n        I(state) with values C(up)/C(down) and I(neighbors).\n    default: 10\n  neighbors:\n    description:\n      - Check the operational state of given interface C(name) for LLDP neighbor.\n      - The following suboptions are available.\n    suboptions:\n        host:\n          description:\n            - \"LLDP neighbor host for given interface C(name).\"\n        port:\n          description:\n            - \"LLDP neighbor port to which given interface C(name) is connected.\"\n    version_added: 2.5\n  aggregate:\n    description: List of Interfaces definitions.\n  state:\n    description:\n      - State of the Interface configuration, C(up) means present and\n        operationally up and C(down) means present and operationally C(down)\n    default: present\n    choices: ['present', 'absent', 'up', 'down']\nextends_documentation_fragment: vyos\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: configure interface\n  vyos_interface:\n    name: eth0\n    description: test-interface\n\n- name: remove interface\n  vyos_interface:\n    name: eth0\n    state: absent\n\n- name: make interface down\n  vyos_interface:\n    name: eth0\n    enabled: False\n\n- name: make interface up\n  vyos_interface:\n    name: eth0\n    enabled: True\n\n- name: Configure interface speed, mtu, duplex\n  vyos_interface:\n    name: eth5\n    state: present\n    speed: 100\n    mtu: 256\n    duplex: full\n\n- name: Set interface using aggregate\n  vyos_interface:\n    aggregate:\n      - { name: eth1, description: test-interface-1,  speed: 100, duplex: half, mtu: 512}\n      - { name: eth2, description: test-interface-2,  speed: 1000, duplex: full, mtu: 256}\n\n- name: Disable interface on aggregate\n  net_interface:\n    aggregate:\n      - name: eth1\n      - name: eth2\n    enabled: False\n\n- name: Delete interface using aggregate\n  net_interface:\n    aggregate:\n      - name: eth1\n      - name: eth2\n    state: absent\n\n- name: Check lldp neighbors intent arguments\n  vyos_interface:\n    name: eth0\n    neighbors:\n    - port: eth0\n      host: netdev\n\n- name: Config + intent\n  vyos_interface:\n    name: eth1\n    enabled: False\n    state: down\n\"\"\"\n\nRETURN = \"\"\"\ncommands:\n  description: The list of configuration mode commands to send to the device\n  returned: always, except for the platforms that use Netconf transport to manage the device.\n  type: list\n  sample:\n    - set interfaces ethernet eth0 description \"test-interface\"\n    - set interfaces ethernet eth0 speed 100\n    - set interfaces ethernet eth0 mtu 256\n    - set interfaces ethernet eth0 duplex full\n\"\"\"\nimport re\n\nfrom copy import deepcopy\nfrom time import sleep\n\nfrom ansible.module_utils._text import to_text\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.connection import exec_command\nfrom ansible.module_utils.network.common.utils import conditional, remove_default_spec\nfrom ansible.module_utils.network.vyos.vyos import load_config, get_config\nfrom ansible.module_utils.network.vyos.vyos import vyos_argument_spec\n\n\ndef search_obj_in_list(name, lst):\n    for o in lst:\n        if o['name'] == name:\n            return o\n\n    return None\n\n\ndef map_obj_to_commands(updates):\n    commands = list()\n    want, have = updates\n\n    params = ('speed', 'description', 'duplex', 'mtu')\n    for w in want:\n        name = w['name']\n        disable = w['disable']\n        state = w['state']\n\n        obj_in_have = search_obj_in_list(name, have)\n        set_interface = 'set interfaces ethernet ' + name\n        delete_interface = 'delete interfaces ethernet ' + name\n\n        if state == 'absent' and obj_in_have:\n            commands.append(delete_interface)\n        elif state in ('present', 'up', 'down'):\n            if obj_in_have:\n                for item in params:\n                    value = w.get(item)\n\n                    if value and value != obj_in_have.get(item):\n                        commands.append(set_interface + ' ' + item + ' ' + str(value))\n\n                if disable and not obj_in_have.get('disable', False):\n                    commands.append(set_interface + ' disable')\n                elif not disable and obj_in_have.get('disable', False):\n                    commands.append(delete_interface + ' disable')\n            else:\n                commands.append(set_interface)\n                for item in params:\n                    value = w.get(item)\n                    if value:\n                        commands.append(set_interface + ' ' + item + ' ' + str(value))\n\n                if disable:\n                    commands.append(set_interface + ' disable')\n    return commands\n\n\ndef map_config_to_obj(module):\n    data = get_config(module)\n    obj = []\n    for line in data.split('\\n'):\n        if line.startswith('set interfaces ethernet'):\n            match = re.search(r'set interfaces ethernet (\\S+)', line, re.M)\n            name = match.group(1)\n            if name:\n                interface = {}\n                for item in obj:\n                    if item['name'] == name:\n                        interface = item\n                        break\n\n                if not interface:\n                    interface = {'name': name}\n                    obj.append(interface)\n\n                match = re.search(r'%s (\\S+)' % name, line, re.M)\n                if match:\n                    param = match.group(1)\n                    if param == 'description':\n                        match = re.search(r'description (\\S+)', line, re.M)\n                        description = match.group(1).strip(\"'\")\n                        interface['description'] = description\n                    elif param == 'speed':\n                        match = re.search(r'speed (\\S+)', line, re.M)\n                        speed = match.group(1).strip(\"'\")\n                        interface['speed'] = speed\n                    elif param == 'mtu':\n                        match = re.search(r'mtu (\\S+)', line, re.M)\n                        mtu = match.group(1).strip(\"'\")\n                        interface['mtu'] = int(mtu)\n                    elif param == 'duplex':\n                        match = re.search(r'duplex (\\S+)', line, re.M)\n                        duplex = match.group(1).strip(\"'\")\n                        interface['duplex'] = duplex\n                    elif param.strip(\"'\") == 'disable':\n                        interface['disable'] = True\n\n    return obj\n\n\ndef map_params_to_obj(module):\n    obj = []\n    aggregate = module.params.get('aggregate')\n    if aggregate:\n        for item in aggregate:\n            for key in item:\n                if item.get(key) is None:\n                    item[key] = module.params[key]\n\n            d = item.copy()\n            if d['enabled']:\n                d['disable'] = False\n            else:\n                d['disable'] = True\n\n            obj.append(d)\n    else:\n        params = {\n            'name': module.params['name'],\n            'description': module.params['description'],\n            'speed': module.params['speed'],\n            'mtu': module.params['mtu'],\n            'duplex': module.params['duplex'],\n            'delay': module.params['delay'],\n            'state': module.params['state'],\n            'neighbors': module.params['neighbors']\n        }\n\n        if module.params['enabled']:\n            params.update({'disable': False})\n        else:\n            params.update({'disable': True})\n\n        obj.append(params)\n    return obj\n\n\ndef check_declarative_intent_params(module, want, result):\n    failed_conditions = []\n    have_neighbors = None\n    for w in want:\n        want_state = w.get('state')\n        want_neighbors = w.get('neighbors')\n\n        if want_state not in ('up', 'down') and not want_neighbors:\n            continue\n\n        if result['changed']:\n            sleep(w['delay'])\n\n        command = 'show interfaces ethernet %s' % w['name']\n        rc, out, err = exec_command(module, command)\n        if rc != 0:\n            module.fail_json(msg=to_text(err, errors='surrogate_then_replace'), command=command, rc=rc)\n\n        if want_state in ('up', 'down'):\n            match = re.search(r'%s (\\w+)' % 'state', out, re.M)\n            have_state = None\n            if match:\n                have_state = match.group(1)\n            if have_state is None or not conditional(want_state, have_state.strip().lower()):\n                failed_conditions.append('state ' + 'eq(%s)' % want_state)\n\n        if want_neighbors:\n            have_host = []\n            have_port = []\n            if have_neighbors is None:\n                rc, have_neighbors, err = exec_command(module, 'show lldp neighbors detail')\n                if rc != 0:\n                    module.fail_json(msg=to_text(err, errors='surrogate_then_replace'), command=command, rc=rc)\n\n            if have_neighbors:\n                lines = have_neighbors.strip().split('Interface: ')\n                for line in lines:\n                    field = line.split('\\n')\n                    if field[0].split(',')[0].strip() == w['name']:\n                        for item in field:\n                            if item.strip().startswith('SysName:'):\n                                have_host.append(item.split(':')[1].strip())\n                            if item.strip().startswith('PortDescr:'):\n                                have_port.append(item.split(':')[1].strip())\n            for item in want_neighbors:\n                host = item.get('host')\n                port = item.get('port')\n                if host and host not in have_host:\n                    failed_conditions.append('host ' + host)\n                if port and port not in have_port:\n                    failed_conditions.append('port ' + port)\n\n    return failed_conditions\n\n\ndef main():\n    \"\"\" main entry point for module execution\n    \"\"\"\n    neighbors_spec = dict(\n        host=dict(),\n        port=dict()\n    )\n\n    element_spec = dict(\n        name=dict(),\n        description=dict(),\n        speed=dict(),\n        mtu=dict(type='int'),\n        duplex=dict(choices=['full', 'half', 'auto']),\n        enabled=dict(default=True, type='bool'),\n        neighbors=dict(type='list', elements='dict', options=neighbors_spec),\n        delay=dict(default=10, type='int'),\n        state=dict(default='present',\n                   choices=['present', 'absent', 'up', 'down'])\n    )\n\n    aggregate_spec = deepcopy(element_spec)\n    aggregate_spec['name'] = dict(required=True)\n\n     remove default in aggregate spec, to handle common arguments\n    remove_default_spec(aggregate_spec)\n\n    argument_spec = dict(\n        aggregate=dict(type='list', elements='dict', options=aggregate_spec),\n    )\n\n    argument_spec.update(element_spec)\n    argument_spec.update(vyos_argument_spec)\n\n    required_one_of = [['name', 'aggregate']]\n    mutually_exclusive = [['name', 'aggregate']]\n\n    required_together = (['speed', 'duplex'])\n    module = AnsibleModule(argument_spec=argument_spec,\n                           required_one_of=required_one_of,\n                           mutually_exclusive=mutually_exclusive,\n                           required_together=required_together,\n                           supports_check_mode=True)\n\n    warnings = list()\n\n    result = {'changed': False}\n\n    if warnings:\n        result['warnings'] = warnings\n\n    want = map_params_to_obj(module)\n    have = map_config_to_obj(module)\n\n    commands = map_obj_to_commands((want, have))\n    result['commands'] = commands\n\n    if commands:\n        commit = not module.check_mode\n        diff = load_config(module, commands, commit=commit)\n        if diff:\n            if module._diff:\n                result['diff'] = {'prepared': diff}\n        result['changed'] = True\n\n    failed_conditions = check_declarative_intent_params(module, want, result)\n\n    if failed_conditions:\n        msg = 'One or more conditional statements have not been satisfied'\n        module.fail_json(msg=msg, failed_conditions=failed_conditions)\n    module.exit_json(**result)\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  vyos interface version added   2 4  author   ganesh nalawade ( ganeshrn)  short description  manage interface vyos network devices description      this module provides declarative management interfaces     vyos network devices  notes      tested vyos 1 1 7 options    name      description          name interface      required  true   description      description          description interface    enabled      description          interface link status    speed      description          interface link speed    mtu      description          maximum size transmit packet    duplex      description          interface link status      default  auto     choices    full    half    auto     delay      description          time seconds wait checking operational state remote         device  this wait applicable operational state argument         i(state) values c(up) c(down) i(neighbors)      default  10   neighbors      description          check operational state given interface c(name) lldp neighbor          the following suboptions available      suboptions          host            description                 lldp neighbor host given interface c(name)           port            description                 lldp neighbor port given interface c(name) connected       version added  2 5   aggregate      description  list interfaces definitions    state      description          state interface configuration  c(up) means present         operationally c(down) means present operationally c(down)     default  present     choices    present    absent         extends documentation fragment  vyos      examples         name  configure interface   vyos interface      name  eth0     description  test interface    name  remove interface   vyos interface      name  eth0     state  absent    name  make interface   vyos interface      name  eth0     enabled  false    name  make interface   vyos interface      name  eth0     enabled  true    name  configure interface speed  mtu  duplex   vyos interface      name  eth5     state  present     speed  100     mtu  256     duplex  full    name  set interface using aggregate   vyos interface      aggregate            name  eth1  description  test interface 1   speed  100  duplex  half  mtu  512            name  eth2  description  test interface 2   speed  1000  duplex  full  mtu  256     name  disable interface aggregate   net interface      aggregate          name  eth1         name  eth2     enabled  false    name  delete interface using aggregate   net interface      aggregate          name  eth1         name  eth2     state  absent    name  check lldp neighbors intent arguments   vyos interface      name  eth0     neighbors        port  eth0       host  netdev    name  config   intent   vyos interface      name  eth1     enabled  false     state       return       commands    description  the list configuration mode commands send device   returned  always  except platforms use netconf transport manage device    type  list   sample        set interfaces ethernet eth0 description  test interface        set interfaces ethernet eth0 speed 100       set interfaces ethernet eth0 mtu 256       set interfaces ethernet eth0 duplex full     import  copy import deepcopy time import sleep  ansible module utils  text import text ansible module utils basic import ansiblemodule ansible module utils connection import exec command ansible module utils network common utils import conditional  remove default spec ansible module utils network vyos vyos import load config  get config ansible module utils network vyos vyos import vyos argument spec   def search obj list(name  lst)      lst           name      name              return      return none   def map obj commands(updates)      commands   list()     want    updates      params   ( speed    description    duplex    mtu )     w want          name   w  name           disable   w  disable           state   w  state            obj   search obj list(name  have)         set interface    set interfaces ethernet     name         delete interface    delete interfaces ethernet     name          state     absent  obj              commands append(delete interface)         elif state ( present       )              obj                  item params                      value   w get(item)                      value value    obj get(item)                          commands append(set interface         item         str(value))                  disable obj get( disable   false)                      commands append(set interface     disable )                 elif disable obj get( disable   false)                      commands append(delete interface     disable )             else                  commands append(set interface)                 item params                      value   w get(item)                     value                          commands append(set interface         item         str(value))                  disable                      commands append(set interface     disable )     return commands   def map config obj(module)      data   get config(module)     obj          line data split(  n )          line startswith( set interfaces ethernet )              match   search(r set interfaces ethernet ( s )   line  m)             name   match group(1)             name                  interface                      item obj                      item  name      name                          interface   item                         break                  interface                      interface     name   name                      obj append(interface)                  match   search(r  ( s )    name  line  m)                 match                      param   match group(1)                     param     description                           match   search(r description ( s )   line  m)                         description   match group(1) strip(   )                         interface  description     description                     elif param     speed                           match   search(r speed ( s )   line  m)                         speed   match group(1) strip(   )                         interface  speed     speed                     elif param     mtu                           match   search(r mtu ( s )   line  m)                         mtu   match group(1) strip(   )                         interface  mtu     int(mtu)                     elif param     duplex                           match   search(r duplex ( s )   line  m)                         duplex   match group(1) strip(   )                         interface  duplex     duplex                     elif param strip(   )     disable                           interface  disable     true      return obj   def map params obj(module)      obj          aggregate   module params get( aggregate )     aggregate          item aggregate              key item                  item get(key) none                      item key    module params key                 item copy()              enabled                     disable     false             else                   disable     true              obj append(d)     else          params                  name   module params  name                 description   module params  description                 speed   module params  speed                 mtu   module params  mtu                 duplex   module params  duplex                 delay   module params  delay                 state   module params  state                 neighbors   module params  neighbors                      module params  enabled                params update(  disable   false )         else              params update(  disable   true )          obj append(params)     return obj   def check declarative intent params(module  want  result)      failed conditions          neighbors   none     w want          want state   w get( state )         want neighbors   w get( neighbors )          want state (    ) want neighbors              continue          result  changed                sleep(w  delay  )          command    show interfaces ethernet     w  name           rc   err   exec command(module  command)         rc    0              module fail json(msg text(err  errors  surrogate replace )  command command  rc rc)          want state (    )              match   search(r  ( w )     state    m)             state   none             match                  state   match group(1)             state none conditional(want state  state strip() lower())                  failed conditions append( state      eq( s)    want state)          want neighbors              host                  port                  neighbors none                  rc  neighbors  err   exec command(module   show lldp neighbors detail )                 rc    0                      module fail json(msg text(err  errors  surrogate replace )  command command  rc rc)              neighbors                  lines   neighbors strip() split( interface   )                 line lines                      field   line split(  n )                     field 0  split(   ) 0  strip()    w  name                            item field                              item strip() startswith( sysname  )                                  host append(item split(   ) 1  strip())                             item strip() startswith( portdescr  )                                  port append(item split(   ) 1  strip())             item want neighbors                  host   item get( host )                 port   item get( port )                 host host host                      failed conditions append( host     host)                 port port port                      failed conditions append( port     port)      return failed conditions   def main()          main entry point module execution             usr bin python        coding  utf 8        (c) 2017  ansible red hat  inc       this file part ansible red hat       ansible free software  redistribute modify    terms gnu general public license published    free software foundation  either version 3 license     (at option) later version        ansible distributed hope useful     without any warranty  without even implied warranty    merchantability fitness for a particular purpose   see    gnu general public license details        you received copy gnu general public license    along ansible   if  see  http   www gnu org licenses          remove default aggregate spec  handle common arguments ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# (c) 2017, Ansible by Red Hat, inc\n#\n# This file is part of Ansible by Red Hat\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'network'}\n\n\nDOCUMENTATION = \"\"\"\n---\nmodule: vyos_interface\nversion_added: \"2.4\"\nauthor: \"Ganesh Nalawade (@ganeshrn)\"\nshort_description: Manage Interface on VyOS network devices\ndescription:\n  - This module provides declarative management of Interfaces\n    on VyOS network devices.\nnotes:\n  - Tested against VYOS 1.1.7\noptions:\n  name:\n    description:\n      - Name of the Interface.\n    required: true\n  description:\n    description:\n      - Description of Interface.\n  enabled:\n    description:\n      - Interface link status.\n  speed:\n    description:\n      - Interface link speed.\n  mtu:\n    description:\n      - Maximum size of transmit packet.\n  duplex:\n    description:\n      - Interface link status.\n    default: auto\n    choices: ['full', 'half', 'auto']\n  delay:\n    description:\n      - Time in seconds to wait before checking for the operational state on remote\n        device. This wait is applicable for operational state argument which are\n        I(state) with values C(up)/C(down) and I(neighbors).\n    default: 10\n  neighbors:\n    description:\n      - Check the operational state of given interface C(name) for LLDP neighbor.\n      - The following suboptions are available.\n    suboptions:\n        host:\n          description:\n            - \"LLDP neighbor host for given interface C(name).\"\n        port:\n          description:\n            - \"LLDP neighbor port to which given interface C(name) is connected.\"\n    version_added: 2.5\n  aggregate:\n    description: List of Interfaces definitions.\n  state:\n    description:\n      - State of the Interface configuration, C(up) means present and\n        operationally up and C(down) means present and operationally C(down)\n    default: present\n    choices: ['present', 'absent', 'up', 'down']\nextends_documentation_fragment: vyos\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: configure interface\n  vyos_interface:\n    name: eth0\n    description: test-interface\n\n- name: remove interface\n  vyos_interface:\n    name: eth0\n    state: absent\n\n- name: make interface down\n  vyos_interface:\n    name: eth0\n    enabled: False\n\n- name: make interface up\n  vyos_interface:\n    name: eth0\n    enabled: True\n\n- name: Configure interface speed, mtu, duplex\n  vyos_interface:\n    name: eth5\n    state: present\n    speed: 100\n    mtu: 256\n    duplex: full\n\n- name: Set interface using aggregate\n  vyos_interface:\n    aggregate:\n      - { name: eth1, description: test-interface-1,  speed: 100, duplex: half, mtu: 512}\n      - { name: eth2, description: test-interface-2,  speed: 1000, duplex: full, mtu: 256}\n\n- name: Disable interface on aggregate\n  net_interface:\n    aggregate:\n      - name: eth1\n      - name: eth2\n    enabled: False\n\n- name: Delete interface using aggregate\n  net_interface:\n    aggregate:\n      - name: eth1\n      - name: eth2\n    state: absent\n\n- name: Check lldp neighbors intent arguments\n  vyos_interface:\n    name: eth0\n    neighbors:\n    - port: eth0\n      host: netdev\n\n- name: Config + intent\n  vyos_interface:\n    name: eth1\n    enabled: False\n    state: down\n\"\"\"\n\nRETURN = \"\"\"\ncommands:\n  description: The list of configuration mode commands to send to the device\n  returned: always, except for the platforms that use Netconf transport to manage the device.\n  type: list\n  sample:\n    - set interfaces ethernet eth0 description \"test-interface\"\n    - set interfaces ethernet eth0 speed 100\n    - set interfaces ethernet eth0 mtu 256\n    - set interfaces ethernet eth0 duplex full\n\"\"\"\nimport re\n\nfrom copy import deepcopy\nfrom time import sleep\n\nfrom ansible.module_utils._text import to_text\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.connection import exec_command\nfrom ansible.module_utils.network.common.utils import conditional, remove_default_spec\nfrom ansible.module_utils.network.vyos.vyos import load_config, get_config\nfrom ansible.module_utils.network.vyos.vyos import vyos_argument_spec\n\n\ndef search_obj_in_list(name, lst):\n    for o in lst:\n        if o['name'] == name:\n            return o\n\n    return None\n\n\ndef map_obj_to_commands(updates):\n    commands = list()\n    want, have = updates\n\n    params = ('speed', 'description', 'duplex', 'mtu')\n    for w in want:\n        name = w['name']\n        disable = w['disable']\n        state = w['state']\n\n        obj_in_have = search_obj_in_list(name, have)\n        set_interface = 'set interfaces ethernet ' + name\n        delete_interface = 'delete interfaces ethernet ' + name\n\n        if state == 'absent' and obj_in_have:\n            commands.append(delete_interface)\n        elif state in ('present', 'up', 'down'):\n            if obj_in_have:\n                for item in params:\n                    value = w.get(item)\n\n                    if value and value != obj_in_have.get(item):\n                        commands.append(set_interface + ' ' + item + ' ' + str(value))\n\n                if disable and not obj_in_have.get('disable', False):\n                    commands.append(set_interface + ' disable')\n                elif not disable and obj_in_have.get('disable', False):\n                    commands.append(delete_interface + ' disable')\n            else:\n                commands.append(set_interface)\n                for item in params:\n                    value = w.get(item)\n                    if value:\n                        commands.append(set_interface + ' ' + item + ' ' + str(value))\n\n                if disable:\n                    commands.append(set_interface + ' disable')\n    return commands\n\n\ndef map_config_to_obj(module):\n    data = get_config(module)\n    obj = []\n    for line in data.split('\\n'):\n        if line.startswith('set interfaces ethernet'):\n            match = re.search(r'set interfaces ethernet (\\S+)', line, re.M)\n            name = match.group(1)\n            if name:\n                interface = {}\n                for item in obj:\n                    if item['name'] == name:\n                        interface = item\n                        break\n\n                if not interface:\n                    interface = {'name': name}\n                    obj.append(interface)\n\n                match = re.search(r'%s (\\S+)' % name, line, re.M)\n                if match:\n                    param = match.group(1)\n                    if param == 'description':\n                        match = re.search(r'description (\\S+)', line, re.M)\n                        description = match.group(1).strip(\"'\")\n                        interface['description'] = description\n                    elif param == 'speed':\n                        match = re.search(r'speed (\\S+)', line, re.M)\n                        speed = match.group(1).strip(\"'\")\n                        interface['speed'] = speed\n                    elif param == 'mtu':\n                        match = re.search(r'mtu (\\S+)', line, re.M)\n                        mtu = match.group(1).strip(\"'\")\n                        interface['mtu'] = int(mtu)\n                    elif param == 'duplex':\n                        match = re.search(r'duplex (\\S+)', line, re.M)\n                        duplex = match.group(1).strip(\"'\")\n                        interface['duplex'] = duplex\n                    elif param.strip(\"'\") == 'disable':\n                        interface['disable'] = True\n\n    return obj\n\n\ndef map_params_to_obj(module):\n    obj = []\n    aggregate = module.params.get('aggregate')\n    if aggregate:\n        for item in aggregate:\n            for key in item:\n                if item.get(key) is None:\n                    item[key] = module.params[key]\n\n            d = item.copy()\n            if d['enabled']:\n                d['disable'] = False\n            else:\n                d['disable'] = True\n\n            obj.append(d)\n    else:\n        params = {\n            'name': module.params['name'],\n            'description': module.params['description'],\n            'speed': module.params['speed'],\n            'mtu': module.params['mtu'],\n            'duplex': module.params['duplex'],\n            'delay': module.params['delay'],\n            'state': module.params['state'],\n            'neighbors': module.params['neighbors']\n        }\n\n        if module.params['enabled']:\n            params.update({'disable': False})\n        else:\n            params.update({'disable': True})\n\n        obj.append(params)\n    return obj\n\n\ndef check_declarative_intent_params(module, want, result):\n    failed_conditions = []\n    have_neighbors = None\n    for w in want:\n        want_state = w.get('state')\n        want_neighbors = w.get('neighbors')\n\n        if want_state not in ('up', 'down') and not want_neighbors:\n            continue\n\n        if result['changed']:\n            sleep(w['delay'])\n\n        command = 'show interfaces ethernet %s' % w['name']\n        rc, out, err = exec_command(module, command)\n        if rc != 0:\n            module.fail_json(msg=to_text(err, errors='surrogate_then_replace'), command=command, rc=rc)\n\n        if want_state in ('up', 'down'):\n            match = re.search(r'%s (\\w+)' % 'state', out, re.M)\n            have_state = None\n            if match:\n                have_state = match.group(1)\n            if have_state is None or not conditional(want_state, have_state.strip().lower()):\n                failed_conditions.append('state ' + 'eq(%s)' % want_state)\n\n        if want_neighbors:\n            have_host = []\n            have_port = []\n            if have_neighbors is None:\n                rc, have_neighbors, err = exec_command(module, 'show lldp neighbors detail')\n                if rc != 0:\n                    module.fail_json(msg=to_text(err, errors='surrogate_then_replace'), command=command, rc=rc)\n\n            if have_neighbors:\n                lines = have_neighbors.strip().split('Interface: ')\n                for line in lines:\n                    field = line.split('\\n')\n                    if field[0].split(',')[0].strip() == w['name']:\n                        for item in field:\n                            if item.strip().startswith('SysName:'):\n                                have_host.append(item.split(':')[1].strip())\n                            if item.strip().startswith('PortDescr:'):\n                                have_port.append(item.split(':')[1].strip())\n            for item in want_neighbors:\n                host = item.get('host')\n                port = item.get('port')\n                if host and host not in have_host:\n                    failed_conditions.append('host ' + host)\n                if port and port not in have_port:\n                    failed_conditions.append('port ' + port)\n\n    return failed_conditions\n\n\ndef main():\n    \"\"\" main entry point for module execution\n    \"\"\"\n    neighbors_spec = dict(\n        host=dict(),\n        port=dict()\n    )\n\n    element_spec = dict(\n        name=dict(),\n        description=dict(),\n        speed=dict(),\n        mtu=dict(type='int'),\n        duplex=dict(choices=['full', 'half', 'auto']),\n        enabled=dict(default=True, type='bool'),\n        neighbors=dict(type='list', elements='dict', options=neighbors_spec),\n        delay=dict(default=10, type='int'),\n        state=dict(default='present',\n                   choices=['present', 'absent', 'up', 'down'])\n    )\n\n    aggregate_spec = deepcopy(element_spec)\n    aggregate_spec['name'] = dict(required=True)\n\n    # remove default in aggregate spec, to handle common arguments\n    remove_default_spec(aggregate_spec)\n\n    argument_spec = dict(\n        aggregate=dict(type='list', elements='dict', options=aggregate_spec),\n    )\n\n    argument_spec.update(element_spec)\n    argument_spec.update(vyos_argument_spec)\n\n    required_one_of = [['name', 'aggregate']]\n    mutually_exclusive = [['name', 'aggregate']]\n\n    required_together = (['speed', 'duplex'])\n    module = AnsibleModule(argument_spec=argument_spec,\n                           required_one_of=required_one_of,\n                           mutually_exclusive=mutually_exclusive,\n                           required_together=required_together,\n                           supports_check_mode=True)\n\n    warnings = list()\n\n    result = {'changed': False}\n\n    if warnings:\n        result['warnings'] = warnings\n\n    want = map_params_to_obj(module)\n    have = map_config_to_obj(module)\n\n    commands = map_obj_to_commands((want, have))\n    result['commands'] = commands\n\n    if commands:\n        commit = not module.check_mode\n        diff = load_config(module, commands, commit=commit)\n        if diff:\n            if module._diff:\n                result['diff'] = {'prepared': diff}\n        result['changed'] = True\n\n    failed_conditions = check_declarative_intent_params(module, want, result)\n\n    if failed_conditions:\n        msg = 'One or more conditional statements have not been satisfied'\n        module.fail_json(msg=msg, failed_conditions=failed_conditions)\n    module.exit_json(**result)\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "vyos_interface.py", "id": "011249664f038232b75315e46c88f694", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/network/vyos/vyos_interface.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}