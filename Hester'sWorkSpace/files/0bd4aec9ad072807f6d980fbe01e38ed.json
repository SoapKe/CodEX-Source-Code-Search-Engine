{"author": "sympy", "code": "from sympy.algebras.quaternion import Quaternion\nfrom sympy import symbols, re, im, Add, Mul, I, Abs\nfrom sympy import cos, sin, sqrt, conjugate, exp, log, acos, E, pi\nfrom sympy.utilities.pytest import raises\nfrom sympy import Matrix\nfrom sympy import diff, integrate, trigsimp\nfrom sympy import S, Rational\n\nx, y, z, w = symbols(\"x y z w\")\n\ndef test_quaternion_construction():\n    q = Quaternion(x, y, z, w)\n    assert q + q == Quaternion(2*x, 2*y, 2*z, 2*w)\n\n    q2 = Quaternion.from_axis_angle((sqrt(3)/3, sqrt(3)/3, sqrt(3)/3), 2*pi/3)\n    assert q2 == Quaternion(Rational(1/2), Rational(1/2),\n                            Rational(1/2), Rational(1,2))\n\n    M = Matrix([[cos(x), -sin(x), 0], [sin(x), cos(x), 0], [0, 0, 1]])\n    q3 = trigsimp(Quaternion.from_rotation_matrix(M))\n    assert q3 == Quaternion(sqrt(2)*sqrt(cos(x) + 1)/2, 0, 0, sqrt(-2*cos(x) + 2)/2)\n\n\ndef test_quaternion_complex_real_addition():\n    a = symbols(\"a\", complex=True)\n    b = symbols(\"b\", real=True)\n    \n    c = symbols(\"c\", commutative=False)\n\n    q = Quaternion(x, y, z, w)\n    assert a + q == Quaternion(x + re(a), y + im(a), z, w)\n    assert 1 + q == Quaternion(1 + x, y, z, w)\n    assert I + q == Quaternion(x, 1 + y, z, w)\n    assert b + q == Quaternion(x + b, y, z, w)\n    assert c + q == Add(c, Quaternion(x, y, z, w), evaluate=False)\n    assert q * c == Mul(Quaternion(x, y, z, w), c, evaluate=False)\n    assert c * q == Mul(c, Quaternion(x, y, z, w), evaluate=False)\n\n    assert -q == Quaternion(-x, -y, -z, -w)\n\n    q1 = Quaternion(3 + 4*I, 2 + 5*I, 0, 7 + 8*I, real_field = False)\n    q2 = Quaternion(1, 4, 7, 8)\n\n    assert q1 + (2 + 3*I) == Quaternion(5 + 7*I, 2 + 5*I, 0, 7 + 8*I)\n    assert q2 + (2 + 3*I) == Quaternion(3, 7, 7, 8)\n    assert q1 * (2 + 3*I) == \\\n    Quaternion((2 + 3*I)*(3 + 4*I), (2 + 3*I)*(2 + 5*I), 0, (2 + 3*I)*(7 + 8*I))\n    assert q2 * (2 + 3*I) == Quaternion(-10, 11, 38, -5)\n\n\ndef test_quaternion_functions():\n    q = Quaternion(x, y, z, w)\n    q1 = Quaternion(1, 2, 3, 4)\n    q0 = Quaternion(0, 0, 0, 0)\n\n    assert conjugate(q) == Quaternion(x, -y, -z, -w)\n    assert q.norm() == sqrt(w**2 + x**2 + y**2 + z**2)\n    assert q.normalize() == Quaternion(x, y, z, w) / sqrt(w**2 + x**2 + y**2 + z**2)\n    assert q.inverse() == Quaternion(x, -y, -z, -w) / (w**2 + x**2 + y**2 + z**2)\n    raises(ValueError, lambda: q0.inverse())\n    assert q.pow(2) == Quaternion(-w**2 + x**2 - y**2 - z**2, 2*x*y, 2*x*z, 2*w*x)\n    assert q1.pow(-2) == Quaternion(-S(7)/225, -S(1)/225, -S(1)/150, -S(2)/225)\n    assert q1.pow(-0.5) == NotImplemented\n\n    assert q1.exp() == \\\n    Quaternion(E * cos(sqrt(29)),\n               2 * sqrt(29) * E * sin(sqrt(29)) / 29,\n               3 * sqrt(29) * E * sin(sqrt(29)) / 29,\n               4 * sqrt(29) * E * sin(sqrt(29)) / 29)\n    assert q1._ln() == \\\n    Quaternion(log(sqrt(30)),\n               2 * sqrt(29) * acos(sqrt(30)/30) / 29,\n               3 * sqrt(29) * acos(sqrt(30)/30) / 29,\n               4 * sqrt(29) * acos(sqrt(30)/30) / 29)\n\n    assert q1.pow_cos_sin(2) == \\\n    Quaternion(30 * cos(2 * acos(sqrt(30)/30)),\n               60 * sqrt(29) * sin(2 * acos(sqrt(30)/30)) / 29,\n               90 * sqrt(29) * sin(2 * acos(sqrt(30)/30)) / 29,\n               120 * sqrt(29) * sin(2 * acos(sqrt(30)/30)) / 29)\n\n    assert diff(Quaternion(x, x, x, x), x) == Quaternion(1, 1, 1, 1)\n\n    assert integrate(Quaternion(x, x, x, x), x) == \\\n    Quaternion(x**2 / 2, x**2 / 2, x**2 / 2, x**2 / 2)\n\n    assert Quaternion.rotate_point((1, 1, 1), q1) == (1 / 5, 1, 7 / 5)\n\n\ndef test_quaternion_conversions():\n    q1 = Quaternion(1, 2, 3, 4)\n\n    assert q1.to_axis_angle() == ((2 * sqrt(29)/29,\n                                   3 * sqrt(29)/29,\n                                   4 * sqrt(29)/29),\n                                   2 * acos(sqrt(30)/30))\n\n    assert q1.to_rotation_matrix() == Matrix([[-S(2)/3, S(2)/15, S(11)/15],\n                                     [S(2)/3, -S(1)/3, S(14)/15],\n                                     [S(1)/3, S(14)/15, S(2)/15]])\n\n    assert q1.to_rotation_matrix((1, 1, 1)) == Matrix([[-S(2)/3, S(2)/15, S(11)/15, S(4)/5],\n                                                  [S(2)/3, -S(1)/3, S(14)/15, -S(4)/15],\n                                                  [S(1)/3, S(14)/15, S(2)/15, -S(2)/5],\n                                                  [S(0), S(0), S(0), S(1)]])\n\n    theta = symbols(\"theta\", real=True)\n    q2 = Quaternion(cos(theta/2), 0, 0, sin(theta/2))\n\n    assert trigsimp(q2.to_rotation_matrix()) == Matrix([\n                                               [cos(theta), -sin(theta), 0],\n                                               [sin(theta),  cos(theta), 0],\n                                               [0,           0,          1]])\n\n    assert q2.to_axis_angle() == ((0, 0, sin(theta/2)/Abs(sin(theta/2))),\n                                   2*acos(cos(theta/2)))\n\n    assert trigsimp(q2.to_rotation_matrix((1, 1, 1))) == Matrix([\n               [cos(theta), -sin(theta), 0, sin(theta) - cos(theta) + 1],\n               [sin(theta),  cos(theta), 0, -sin(theta) - cos(theta) + 1],\n               [0,           0,          1,  0],\n               [0,           0,          0,  1]])\n", "comments": "  this symbol complex  ", "content": "from sympy.algebras.quaternion import Quaternion\nfrom sympy import symbols, re, im, Add, Mul, I, Abs\nfrom sympy import cos, sin, sqrt, conjugate, exp, log, acos, E, pi\nfrom sympy.utilities.pytest import raises\nfrom sympy import Matrix\nfrom sympy import diff, integrate, trigsimp\nfrom sympy import S, Rational\n\nx, y, z, w = symbols(\"x y z w\")\n\ndef test_quaternion_construction():\n    q = Quaternion(x, y, z, w)\n    assert q + q == Quaternion(2*x, 2*y, 2*z, 2*w)\n\n    q2 = Quaternion.from_axis_angle((sqrt(3)/3, sqrt(3)/3, sqrt(3)/3), 2*pi/3)\n    assert q2 == Quaternion(Rational(1/2), Rational(1/2),\n                            Rational(1/2), Rational(1,2))\n\n    M = Matrix([[cos(x), -sin(x), 0], [sin(x), cos(x), 0], [0, 0, 1]])\n    q3 = trigsimp(Quaternion.from_rotation_matrix(M))\n    assert q3 == Quaternion(sqrt(2)*sqrt(cos(x) + 1)/2, 0, 0, sqrt(-2*cos(x) + 2)/2)\n\n\ndef test_quaternion_complex_real_addition():\n    a = symbols(\"a\", complex=True)\n    b = symbols(\"b\", real=True)\n    # This symbol is not complex:\n    c = symbols(\"c\", commutative=False)\n\n    q = Quaternion(x, y, z, w)\n    assert a + q == Quaternion(x + re(a), y + im(a), z, w)\n    assert 1 + q == Quaternion(1 + x, y, z, w)\n    assert I + q == Quaternion(x, 1 + y, z, w)\n    assert b + q == Quaternion(x + b, y, z, w)\n    assert c + q == Add(c, Quaternion(x, y, z, w), evaluate=False)\n    assert q * c == Mul(Quaternion(x, y, z, w), c, evaluate=False)\n    assert c * q == Mul(c, Quaternion(x, y, z, w), evaluate=False)\n\n    assert -q == Quaternion(-x, -y, -z, -w)\n\n    q1 = Quaternion(3 + 4*I, 2 + 5*I, 0, 7 + 8*I, real_field = False)\n    q2 = Quaternion(1, 4, 7, 8)\n\n    assert q1 + (2 + 3*I) == Quaternion(5 + 7*I, 2 + 5*I, 0, 7 + 8*I)\n    assert q2 + (2 + 3*I) == Quaternion(3, 7, 7, 8)\n    assert q1 * (2 + 3*I) == \\\n    Quaternion((2 + 3*I)*(3 + 4*I), (2 + 3*I)*(2 + 5*I), 0, (2 + 3*I)*(7 + 8*I))\n    assert q2 * (2 + 3*I) == Quaternion(-10, 11, 38, -5)\n\n\ndef test_quaternion_functions():\n    q = Quaternion(x, y, z, w)\n    q1 = Quaternion(1, 2, 3, 4)\n    q0 = Quaternion(0, 0, 0, 0)\n\n    assert conjugate(q) == Quaternion(x, -y, -z, -w)\n    assert q.norm() == sqrt(w**2 + x**2 + y**2 + z**2)\n    assert q.normalize() == Quaternion(x, y, z, w) / sqrt(w**2 + x**2 + y**2 + z**2)\n    assert q.inverse() == Quaternion(x, -y, -z, -w) / (w**2 + x**2 + y**2 + z**2)\n    raises(ValueError, lambda: q0.inverse())\n    assert q.pow(2) == Quaternion(-w**2 + x**2 - y**2 - z**2, 2*x*y, 2*x*z, 2*w*x)\n    assert q1.pow(-2) == Quaternion(-S(7)/225, -S(1)/225, -S(1)/150, -S(2)/225)\n    assert q1.pow(-0.5) == NotImplemented\n\n    assert q1.exp() == \\\n    Quaternion(E * cos(sqrt(29)),\n               2 * sqrt(29) * E * sin(sqrt(29)) / 29,\n               3 * sqrt(29) * E * sin(sqrt(29)) / 29,\n               4 * sqrt(29) * E * sin(sqrt(29)) / 29)\n    assert q1._ln() == \\\n    Quaternion(log(sqrt(30)),\n               2 * sqrt(29) * acos(sqrt(30)/30) / 29,\n               3 * sqrt(29) * acos(sqrt(30)/30) / 29,\n               4 * sqrt(29) * acos(sqrt(30)/30) / 29)\n\n    assert q1.pow_cos_sin(2) == \\\n    Quaternion(30 * cos(2 * acos(sqrt(30)/30)),\n               60 * sqrt(29) * sin(2 * acos(sqrt(30)/30)) / 29,\n               90 * sqrt(29) * sin(2 * acos(sqrt(30)/30)) / 29,\n               120 * sqrt(29) * sin(2 * acos(sqrt(30)/30)) / 29)\n\n    assert diff(Quaternion(x, x, x, x), x) == Quaternion(1, 1, 1, 1)\n\n    assert integrate(Quaternion(x, x, x, x), x) == \\\n    Quaternion(x**2 / 2, x**2 / 2, x**2 / 2, x**2 / 2)\n\n    assert Quaternion.rotate_point((1, 1, 1), q1) == (1 / 5, 1, 7 / 5)\n\n\ndef test_quaternion_conversions():\n    q1 = Quaternion(1, 2, 3, 4)\n\n    assert q1.to_axis_angle() == ((2 * sqrt(29)/29,\n                                   3 * sqrt(29)/29,\n                                   4 * sqrt(29)/29),\n                                   2 * acos(sqrt(30)/30))\n\n    assert q1.to_rotation_matrix() == Matrix([[-S(2)/3, S(2)/15, S(11)/15],\n                                     [S(2)/3, -S(1)/3, S(14)/15],\n                                     [S(1)/3, S(14)/15, S(2)/15]])\n\n    assert q1.to_rotation_matrix((1, 1, 1)) == Matrix([[-S(2)/3, S(2)/15, S(11)/15, S(4)/5],\n                                                  [S(2)/3, -S(1)/3, S(14)/15, -S(4)/15],\n                                                  [S(1)/3, S(14)/15, S(2)/15, -S(2)/5],\n                                                  [S(0), S(0), S(0), S(1)]])\n\n    theta = symbols(\"theta\", real=True)\n    q2 = Quaternion(cos(theta/2), 0, 0, sin(theta/2))\n\n    assert trigsimp(q2.to_rotation_matrix()) == Matrix([\n                                               [cos(theta), -sin(theta), 0],\n                                               [sin(theta),  cos(theta), 0],\n                                               [0,           0,          1]])\n\n    assert q2.to_axis_angle() == ((0, 0, sin(theta/2)/Abs(sin(theta/2))),\n                                   2*acos(cos(theta/2)))\n\n    assert trigsimp(q2.to_rotation_matrix((1, 1, 1))) == Matrix([\n               [cos(theta), -sin(theta), 0, sin(theta) - cos(theta) + 1],\n               [sin(theta),  cos(theta), 0, -sin(theta) - cos(theta) + 1],\n               [0,           0,          1,  0],\n               [0,           0,          0,  1]])\n", "description": "A computer algebra system written in pure Python", "file_name": "test_quaternion.py", "id": "0bd4aec9ad072807f6d980fbe01e38ed", "language": "Python", "project_name": "sympy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/sympy-sympy/sympy-sympy-205da79/sympy/algebras/tests/test_quaternion.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:35:56Z", "url": "https://github.com/sympy/sympy", "wiki": true}