{"author": "eliangcs", "code": "from __future__ import unicode_literals\n\nimport json\nimport os\nimport re\nimport sys\n\nimport click\n\nfrom httpie.plugins import FormatterPlugin  \nfrom httpie.output.formatters.colors import Solarized256Style\nfrom prompt_toolkit import prompt, AbortAction\nfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory\nfrom prompt_toolkit.history import FileHistory\nfrom prompt_toolkit.layout.lexers import PygmentsLexer\nfrom prompt_toolkit.styles.from_pygments import style_from_pygments\nfrom pygments.styles import get_style_by_name\nfrom pygments.util import ClassNotFound\nfrom six.moves.http_cookies import SimpleCookie\nfrom six.moves.urllib.request import urlopen, pathname2url\n\nfrom . import __version__\nfrom . import config\nfrom .completer import HttpPromptCompleter\nfrom .context import Context\nfrom .contextio import load_context, save_context\nfrom .execution import execute\nfrom .lexer import HttpPromptLexer\nfrom .utils import smart_quote\nfrom .xdg import get_data_dir\n\n\n\nclick.disable_unicode_literals_warning = True\n\n\ndef fix_incomplete_url(url):\n    if url.startswith(('s://', '://')):\n        url = 'http' + url\n    elif url.startswith('//'):\n        url = 'http:' + url\n    elif not url.startswith(('http://', 'https://')):\n        url = 'http://' + url\n    return url\n\n\ndef update_cookies(base_value, cookies):\n    cookie = SimpleCookie(base_value)\n    for k, v in cookies.items():\n        cookie[k] = v\n    return cookie.output(header='', sep=';').lstrip()\n\n\nclass ExecutionListener(object):\n\n    def __init__(self, cfg):\n        self.cfg = cfg\n\n    def context_changed(self, context):\n        \n        save_context(context)\n\n    def response_returned(self, context, response):\n        if not response.cookies:\n            return\n\n        cookie_pref = self.cfg.get('set_cookies') or 'auto'\n        if cookie_pref == 'auto' or (\n                cookie_pref == 'ask' and\n                click.confirm(\"Cookies incoming! Do you want to set them?\")):\n            existing_cookie = context.headers.get('Cookie')\n            new_cookie = update_cookies(existing_cookie, response.cookies)\n            context.headers['Cookie'] = new_cookie\n            click.secho('Cookies set: %s' % new_cookie)\n\n\ndef normalize_url(ctx, param, value):\n    if value:\n        if not re.search(r'^\\w+://', value):\n            value = 'file:' + pathname2url(os.path.abspath(value))\n        return value\n    return None\n\n\n@click.command(context_settings=dict(\n    ignore_unknown_options=True,\n))\n@click.option('--spec', help=\"OpenAPI/Swagger specification file.\",\n              callback=normalize_url)\n@click.option('--env', help=\"Environment file to preload.\",\n              type=click.Path(exists=True))\n@click.argument('url', default='')\n@click.argument('http_options', nargs=-1, type=click.UNPROCESSED)\n@click.version_option(message='%(version)s')\ndef cli(spec, env, url, http_options):\n    click.echo('Version: %s' % __version__)\n\n    copied, config_path = config.initialize()\n    if copied:\n        click.echo('Config file not found. Initialized a new one: %s' %\n                   config_path)\n\n    cfg = config.load()\n\n    \n    os.environ['PAGER'] = cfg['pager']\n    os.environ['LESS'] = '-RXF'\n\n    if spec:\n        f = urlopen(spec)\n        try:\n            content = f.read().decode('utf-8')\n            try:\n                spec = json.loads(content)\n            except json.JSONDecodeError:\n                click.secho(\"Warning: Specification file '%s' is not JSON\" %\n                            spec, err=True, fg='red')\n                spec = None\n        finally:\n            f.close()\n\n    if url:\n        url = fix_incomplete_url(url)\n    context = Context(url, spec=spec)\n\n    output_style = cfg.get('output_style')\n    if output_style:\n        context.options['--style'] = output_style\n\n    \n    history = FileHistory(os.path.join(get_data_dir(), 'history'))\n    lexer = PygmentsLexer(HttpPromptLexer)\n    completer = HttpPromptCompleter(context)\n    try:\n        style_class = get_style_by_name(cfg['command_style'])\n    except ClassNotFound:\n        style_class = Solarized256Style\n    style = style_from_pygments(style_class)\n\n    listener = ExecutionListener(cfg)\n\n    if len(sys.argv) == 1:\n        \n        load_context(context)\n    else:\n        if env:\n            load_context(context, env)\n            if url:\n                \n                context.url = url\n\n        if http_options:\n            # Execute HTTPie options from CLI (can overwrite env file values)\n            http_options = [smart_quote(a) for a in http_options]\n            execute(' '.join(http_options), context, listener=listener)\n\n    while True:\n        try:\n            text = prompt('%s> ' % context.url, completer=completer,\n                          lexer=lexer, style=style, history=history,\n                          auto_suggest=AutoSuggestFromHistory(),\n                          on_abort=AbortAction.RETRY, vi_mode=cfg['vi'])\n        except EOFError:\n            break  \n        else:\n            execute(text, context, listener=listener, style=style_class)\n            if context.should_exit:\n                break\n\n    click.echo(\"Goodbye!\")\n", "comments": "  noqa  avoid cyclic import    xxx  http   click pocoo org python3  unicode literals    dump current context http prompt format    override pager less options    for prompt toolkit    load previous context nothing defined    overwrite env url default    execute httpie options cli (can overwrite env file values)    control d pressed ", "content": "from __future__ import unicode_literals\n\nimport json\nimport os\nimport re\nimport sys\n\nimport click\n\nfrom httpie.plugins import FormatterPlugin  # noqa, avoid cyclic import\nfrom httpie.output.formatters.colors import Solarized256Style\nfrom prompt_toolkit import prompt, AbortAction\nfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory\nfrom prompt_toolkit.history import FileHistory\nfrom prompt_toolkit.layout.lexers import PygmentsLexer\nfrom prompt_toolkit.styles.from_pygments import style_from_pygments\nfrom pygments.styles import get_style_by_name\nfrom pygments.util import ClassNotFound\nfrom six.moves.http_cookies import SimpleCookie\nfrom six.moves.urllib.request import urlopen, pathname2url\n\nfrom . import __version__\nfrom . import config\nfrom .completer import HttpPromptCompleter\nfrom .context import Context\nfrom .contextio import load_context, save_context\nfrom .execution import execute\nfrom .lexer import HttpPromptLexer\nfrom .utils import smart_quote\nfrom .xdg import get_data_dir\n\n\n# XXX: http://click.pocoo.org/python3/#unicode-literals\nclick.disable_unicode_literals_warning = True\n\n\ndef fix_incomplete_url(url):\n    if url.startswith(('s://', '://')):\n        url = 'http' + url\n    elif url.startswith('//'):\n        url = 'http:' + url\n    elif not url.startswith(('http://', 'https://')):\n        url = 'http://' + url\n    return url\n\n\ndef update_cookies(base_value, cookies):\n    cookie = SimpleCookie(base_value)\n    for k, v in cookies.items():\n        cookie[k] = v\n    return cookie.output(header='', sep=';').lstrip()\n\n\nclass ExecutionListener(object):\n\n    def __init__(self, cfg):\n        self.cfg = cfg\n\n    def context_changed(self, context):\n        # Dump the current context to HTTP Prompt format\n        save_context(context)\n\n    def response_returned(self, context, response):\n        if not response.cookies:\n            return\n\n        cookie_pref = self.cfg.get('set_cookies') or 'auto'\n        if cookie_pref == 'auto' or (\n                cookie_pref == 'ask' and\n                click.confirm(\"Cookies incoming! Do you want to set them?\")):\n            existing_cookie = context.headers.get('Cookie')\n            new_cookie = update_cookies(existing_cookie, response.cookies)\n            context.headers['Cookie'] = new_cookie\n            click.secho('Cookies set: %s' % new_cookie)\n\n\ndef normalize_url(ctx, param, value):\n    if value:\n        if not re.search(r'^\\w+://', value):\n            value = 'file:' + pathname2url(os.path.abspath(value))\n        return value\n    return None\n\n\n@click.command(context_settings=dict(\n    ignore_unknown_options=True,\n))\n@click.option('--spec', help=\"OpenAPI/Swagger specification file.\",\n              callback=normalize_url)\n@click.option('--env', help=\"Environment file to preload.\",\n              type=click.Path(exists=True))\n@click.argument('url', default='')\n@click.argument('http_options', nargs=-1, type=click.UNPROCESSED)\n@click.version_option(message='%(version)s')\ndef cli(spec, env, url, http_options):\n    click.echo('Version: %s' % __version__)\n\n    copied, config_path = config.initialize()\n    if copied:\n        click.echo('Config file not found. Initialized a new one: %s' %\n                   config_path)\n\n    cfg = config.load()\n\n    # Override pager/less options\n    os.environ['PAGER'] = cfg['pager']\n    os.environ['LESS'] = '-RXF'\n\n    if spec:\n        f = urlopen(spec)\n        try:\n            content = f.read().decode('utf-8')\n            try:\n                spec = json.loads(content)\n            except json.JSONDecodeError:\n                click.secho(\"Warning: Specification file '%s' is not JSON\" %\n                            spec, err=True, fg='red')\n                spec = None\n        finally:\n            f.close()\n\n    if url:\n        url = fix_incomplete_url(url)\n    context = Context(url, spec=spec)\n\n    output_style = cfg.get('output_style')\n    if output_style:\n        context.options['--style'] = output_style\n\n    # For prompt-toolkit\n    history = FileHistory(os.path.join(get_data_dir(), 'history'))\n    lexer = PygmentsLexer(HttpPromptLexer)\n    completer = HttpPromptCompleter(context)\n    try:\n        style_class = get_style_by_name(cfg['command_style'])\n    except ClassNotFound:\n        style_class = Solarized256Style\n    style = style_from_pygments(style_class)\n\n    listener = ExecutionListener(cfg)\n\n    if len(sys.argv) == 1:\n        # load previous context if nothing defined\n        load_context(context)\n    else:\n        if env:\n            load_context(context, env)\n            if url:\n                # Overwrite the env url if not default\n                context.url = url\n\n        if http_options:\n            # Execute HTTPie options from CLI (can overwrite env file values)\n            http_options = [smart_quote(a) for a in http_options]\n            execute(' '.join(http_options), context, listener=listener)\n\n    while True:\n        try:\n            text = prompt('%s> ' % context.url, completer=completer,\n                          lexer=lexer, style=style, history=history,\n                          auto_suggest=AutoSuggestFromHistory(),\n                          on_abort=AbortAction.RETRY, vi_mode=cfg['vi'])\n        except EOFError:\n            break  # Control-D pressed\n        else:\n            execute(text, context, listener=listener, style=style_class)\n            if context.should_exit:\n                break\n\n    click.echo(\"Goodbye!\")\n", "description": "HTTPie + prompt_toolkit = an interactive command-line HTTP client featuring autocomplete and syntax highlighting", "file_name": "cli.py", "id": "1c2c917482689b84a7f437c4c207da51", "language": "Python", "project_name": "http-prompt", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/eliangcs-http-prompt/eliangcs-http-prompt-87f1e9d/http_prompt/cli.py", "save_time": "", "source": "", "update_at": "2018-03-17T18:26:33Z", "url": "https://github.com/eliangcs/http-prompt", "wiki": true}