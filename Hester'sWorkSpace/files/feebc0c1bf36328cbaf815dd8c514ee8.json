{"author": "facebookresearch", "code": " Copyright (c) 2017-present, Facebook, Inc.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n\n\"\"\"Construct minibatches for Mask R-CNN training when keypoints are enabled.\nHandles the minibatch blobs that are specific to training Mask R-CNN for\nkeypoint detection. Other blobs that are generic to RPN or Fast/er R-CNN are\nhandled by their respecitive roi_data modules.\n\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nimport logging\nimport numpy as np\n\nfrom core.config import cfg\nimport utils.blob as blob_utils\nimport utils.keypoints as keypoint_utils\n\nlogger = logging.getLogger(__name__)\n\n\ndef add_keypoint_rcnn_blobs(\n    blobs, roidb, fg_rois_per_image, fg_inds, im_scale, batch_idx\n):\n    \"\"\"Add Mask R-CNN keypoint specific blobs to the given blobs dictionary.\"\"\"\n     Note: gt_inds must match how they're computed in\n     datasets.json_dataset._merge_proposal_boxes_into_roidb\n    gt_inds = np.where(roidb['gt_classes'] > 0)[0]\n    max_overlaps = roidb['max_overlaps']\n    gt_keypoints = roidb['gt_keypoints']\n\n    ind_kp = gt_inds[roidb['box_to_gt_ind_map']]\n    within_box = _within_box(gt_keypoints[ind_kp, :, :], roidb['boxes'])\n    vis_kp = gt_keypoints[ind_kp, 2, :] > 0\n    is_visible = np.sum(np.logical_and(vis_kp, within_box), axis=1) > 0\n    kp_fg_inds = np.where(\n        np.logical_and(max_overlaps >= cfg.TRAIN.FG_THRESH, is_visible)\n    )[0]\n\n    kp_fg_rois_per_this_image = np.minimum(fg_rois_per_image, kp_fg_inds.size)\n    if kp_fg_inds.size > kp_fg_rois_per_this_image:\n        kp_fg_inds = np.random.choice(\n            kp_fg_inds, size=kp_fg_rois_per_this_image, replace=False\n        )\n\n    sampled_fg_rois = roidb['boxes'][kp_fg_inds]\n    box_to_gt_ind_map = roidb['box_to_gt_ind_map'][kp_fg_inds]\n\n    num_keypoints = gt_keypoints.shape[2]\n    sampled_keypoints = -np.ones(\n        (len(sampled_fg_rois), gt_keypoints.shape[1], num_keypoints),\n        dtype=gt_keypoints.dtype\n    )\n    for ii in range(len(sampled_fg_rois)):\n        ind = box_to_gt_ind_map[ii]\n        if ind >= 0:\n            sampled_keypoints[ii, :, :] = gt_keypoints[gt_inds[ind], :, :]\n            assert np.sum(sampled_keypoints[ii, 2, :]) > 0\n\n    heats, weights = keypoint_utils.keypoints_to_heatmap_labels(\n        sampled_keypoints, sampled_fg_rois\n    )\n\n    shape = (sampled_fg_rois.shape[0] * cfg.KRCNN.NUM_KEYPOINTS, 1)\n    heats = heats.reshape(shape)\n    weights = weights.reshape(shape)\n\n    sampled_fg_rois *= im_scale\n    repeated_batch_idx = batch_idx * blob_utils.ones(\n        (sampled_fg_rois.shape[0], 1)\n    )\n    sampled_fg_rois = np.hstack((repeated_batch_idx, sampled_fg_rois))\n\n    blobs['keypoint_rois'] = sampled_fg_rois\n    blobs['keypoint_locations_int32'] = heats.astype(np.int32, copy=False)\n    blobs['keypoint_weights'] = weights\n\n\ndef finalize_keypoint_minibatch(blobs, valid):\n    \"\"\"Finalize the minibatch after blobs for all minibatch images have been\n    collated.\n    \"\"\"\n    min_count = cfg.KRCNN.MIN_KEYPOINT_COUNT_FOR_VALID_MINIBATCH\n    num_visible_keypoints = np.sum(blobs['keypoint_weights'])\n    valid = (\n        valid and len(blobs['keypoint_weights']) > 0 and\n        num_visible_keypoints > min_count\n    )\n     Normalizer to use if cfg.KRCNN.NORMALIZE_BY_VISIBLE_KEYPOINTS is False.\n     See modeling.model_builder.add_keypoint_losses\n    norm = num_visible_keypoints / (\n        cfg.TRAIN.IMS_PER_BATCH * cfg.TRAIN.BATCH_SIZE_PER_IM *\n        cfg.TRAIN.FG_FRACTION * cfg.KRCNN.NUM_KEYPOINTS\n    )\n    blobs['keypoint_loss_normalizer'] = np.array(norm, dtype=np.float32)\n    return valid\n\n\ndef _within_box(points, boxes):\n    \"\"\"Validate which keypoints are contained inside a given box.\n\n    points: Nx2xK\n    boxes: Nx4\n    output: NxK\n    \"\"\"\n    x_within = np.logical_and(\n        points[:, 0, :] >= np.expand_dims(boxes[:, 0], axis=1),\n        points[:, 0, :] <= np.expand_dims(boxes[:, 2], axis=1)\n    )\n    y_within = np.logical_and(\n        points[:, 1, :] >= np.expand_dims(boxes[:, 1], axis=1),\n        points[:, 1, :] <= np.expand_dims(boxes[:, 3], axis=1)\n    )\n    return np.logical_and(x_within, y_within)\n", "comments": "   construct minibatches mask r cnn training keypoints enabled  handles minibatch blobs specific training mask r cnn keypoint detection  other blobs generic rpn fast er r cnn handled respecitive roi data modules         future   import absolute import   future   import division   future   import print function   future   import unicode literals  import logging import numpy np  core config import cfg import utils blob blob utils import utils keypoints keypoint utils  logger   logging getlogger(  name  )   def add keypoint rcnn blobs(     blobs  roidb  fg rois per image  fg inds  im scale  batch idx )         add mask r cnn keypoint specific blobs given blobs dictionary           note  gt inds must match computed       datasets json dataset  merge proposal boxes roidb     gt inds   np where(roidb  gt classes     0) 0      max overlaps   roidb  max overlaps       gt keypoints   roidb  gt keypoints        ind kp   gt inds roidb  box gt ind map        within box    within box(gt keypoints ind kp         roidb  boxes  )     vis kp   gt keypoints ind kp  2       0     visible   np sum(np logical and(vis kp  within box)  axis 1)   0     kp fg inds   np where(         np logical and(max overlaps    cfg train fg thresh  visible)     ) 0       kp fg rois per image   np minimum(fg rois per image  kp fg inds size)     kp fg inds size   kp fg rois per image          kp fg inds   np random choice(             kp fg inds  size kp fg rois per image  replace false         )      sampled fg rois   roidb  boxes   kp fg inds      box gt ind map   roidb  box gt ind map   kp fg inds       num keypoints   gt keypoints shape 2      sampled keypoints    np ones(         (len(sampled fg rois)  gt keypoints shape 1   num keypoints)          dtype gt keypoints dtype     )     ii range(len(sampled fg rois))          ind   box gt ind map ii          ind    0              sampled keypoints ii          gt keypoints gt inds ind                     assert np sum(sampled keypoints ii  2    )   0      heats  weights   keypoint utils keypoints heatmap labels(         sampled keypoints  sampled fg rois     )      shape   (sampled fg rois shape 0    cfg krcnn num keypoints  1)     heats   heats reshape(shape)     weights   weights reshape(shape)      sampled fg rois    im scale     repeated batch idx   batch idx   blob utils ones(         (sampled fg rois shape 0   1)     )     sampled fg rois   np hstack((repeated batch idx  sampled fg rois))      blobs  keypoint rois     sampled fg rois     blobs  keypoint locations int32     heats astype(np int32  copy false)     blobs  keypoint weights     weights   def finalize keypoint minibatch(blobs  valid)         finalize minibatch blobs minibatch images     collated              min count   cfg krcnn min keypoint count for valid minibatch     num visible keypoints   np sum(blobs  keypoint weights  )     valid   (         valid len(blobs  keypoint weights  )   0         num visible keypoints   min count     )       normalizer use cfg krcnn normalize by visible keypoints false        see modeling model builder add keypoint losses     norm   num visible keypoints   (         cfg train ims per batch   cfg train batch size per im           cfg train fg fraction   cfg krcnn num keypoints     )     blobs  keypoint loss normalizer     np array(norm  dtype np float32)     return valid   def  within box(points  boxes)         validate keypoints contained inside given box       points  nx2xk     boxes  nx4     output  nxk            copyright (c) 2017 present  facebook  inc        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license           http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license                                                                                     note  gt inds must match computed    datasets json dataset  merge proposal boxes roidb    normalizer use cfg krcnn normalize by visible keypoints false     see modeling model builder add keypoint losses ", "content": "# Copyright (c) 2017-present, Facebook, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n##############################################################################\n\n\"\"\"Construct minibatches for Mask R-CNN training when keypoints are enabled.\nHandles the minibatch blobs that are specific to training Mask R-CNN for\nkeypoint detection. Other blobs that are generic to RPN or Fast/er R-CNN are\nhandled by their respecitive roi_data modules.\n\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nimport logging\nimport numpy as np\n\nfrom core.config import cfg\nimport utils.blob as blob_utils\nimport utils.keypoints as keypoint_utils\n\nlogger = logging.getLogger(__name__)\n\n\ndef add_keypoint_rcnn_blobs(\n    blobs, roidb, fg_rois_per_image, fg_inds, im_scale, batch_idx\n):\n    \"\"\"Add Mask R-CNN keypoint specific blobs to the given blobs dictionary.\"\"\"\n    # Note: gt_inds must match how they're computed in\n    # datasets.json_dataset._merge_proposal_boxes_into_roidb\n    gt_inds = np.where(roidb['gt_classes'] > 0)[0]\n    max_overlaps = roidb['max_overlaps']\n    gt_keypoints = roidb['gt_keypoints']\n\n    ind_kp = gt_inds[roidb['box_to_gt_ind_map']]\n    within_box = _within_box(gt_keypoints[ind_kp, :, :], roidb['boxes'])\n    vis_kp = gt_keypoints[ind_kp, 2, :] > 0\n    is_visible = np.sum(np.logical_and(vis_kp, within_box), axis=1) > 0\n    kp_fg_inds = np.where(\n        np.logical_and(max_overlaps >= cfg.TRAIN.FG_THRESH, is_visible)\n    )[0]\n\n    kp_fg_rois_per_this_image = np.minimum(fg_rois_per_image, kp_fg_inds.size)\n    if kp_fg_inds.size > kp_fg_rois_per_this_image:\n        kp_fg_inds = np.random.choice(\n            kp_fg_inds, size=kp_fg_rois_per_this_image, replace=False\n        )\n\n    sampled_fg_rois = roidb['boxes'][kp_fg_inds]\n    box_to_gt_ind_map = roidb['box_to_gt_ind_map'][kp_fg_inds]\n\n    num_keypoints = gt_keypoints.shape[2]\n    sampled_keypoints = -np.ones(\n        (len(sampled_fg_rois), gt_keypoints.shape[1], num_keypoints),\n        dtype=gt_keypoints.dtype\n    )\n    for ii in range(len(sampled_fg_rois)):\n        ind = box_to_gt_ind_map[ii]\n        if ind >= 0:\n            sampled_keypoints[ii, :, :] = gt_keypoints[gt_inds[ind], :, :]\n            assert np.sum(sampled_keypoints[ii, 2, :]) > 0\n\n    heats, weights = keypoint_utils.keypoints_to_heatmap_labels(\n        sampled_keypoints, sampled_fg_rois\n    )\n\n    shape = (sampled_fg_rois.shape[0] * cfg.KRCNN.NUM_KEYPOINTS, 1)\n    heats = heats.reshape(shape)\n    weights = weights.reshape(shape)\n\n    sampled_fg_rois *= im_scale\n    repeated_batch_idx = batch_idx * blob_utils.ones(\n        (sampled_fg_rois.shape[0], 1)\n    )\n    sampled_fg_rois = np.hstack((repeated_batch_idx, sampled_fg_rois))\n\n    blobs['keypoint_rois'] = sampled_fg_rois\n    blobs['keypoint_locations_int32'] = heats.astype(np.int32, copy=False)\n    blobs['keypoint_weights'] = weights\n\n\ndef finalize_keypoint_minibatch(blobs, valid):\n    \"\"\"Finalize the minibatch after blobs for all minibatch images have been\n    collated.\n    \"\"\"\n    min_count = cfg.KRCNN.MIN_KEYPOINT_COUNT_FOR_VALID_MINIBATCH\n    num_visible_keypoints = np.sum(blobs['keypoint_weights'])\n    valid = (\n        valid and len(blobs['keypoint_weights']) > 0 and\n        num_visible_keypoints > min_count\n    )\n    # Normalizer to use if cfg.KRCNN.NORMALIZE_BY_VISIBLE_KEYPOINTS is False.\n    # See modeling.model_builder.add_keypoint_losses\n    norm = num_visible_keypoints / (\n        cfg.TRAIN.IMS_PER_BATCH * cfg.TRAIN.BATCH_SIZE_PER_IM *\n        cfg.TRAIN.FG_FRACTION * cfg.KRCNN.NUM_KEYPOINTS\n    )\n    blobs['keypoint_loss_normalizer'] = np.array(norm, dtype=np.float32)\n    return valid\n\n\ndef _within_box(points, boxes):\n    \"\"\"Validate which keypoints are contained inside a given box.\n\n    points: Nx2xK\n    boxes: Nx4\n    output: NxK\n    \"\"\"\n    x_within = np.logical_and(\n        points[:, 0, :] >= np.expand_dims(boxes[:, 0], axis=1),\n        points[:, 0, :] <= np.expand_dims(boxes[:, 2], axis=1)\n    )\n    y_within = np.logical_and(\n        points[:, 1, :] >= np.expand_dims(boxes[:, 1], axis=1),\n        points[:, 1, :] <= np.expand_dims(boxes[:, 3], axis=1)\n    )\n    return np.logical_and(x_within, y_within)\n", "description": "FAIR's research platform for object detection research, implementing popular algorithms like Mask R-CNN and RetinaNet.", "file_name": "keypoint_rcnn.py", "id": "feebc0c1bf36328cbaf815dd8c514ee8", "language": "Python", "project_name": "Detectron", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/facebookresearch-Detectron/facebookresearch-Detectron-958b0ad/lib/roi_data/keypoint_rcnn.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:01:25Z", "url": "https://github.com/facebookresearch/Detectron", "wiki": false}