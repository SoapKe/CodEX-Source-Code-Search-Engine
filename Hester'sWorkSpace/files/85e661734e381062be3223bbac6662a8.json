{"author": "getsentry", "code": "# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, print_function\n\nimport os\nimport datetime\nimport json\nimport logging\nimport mock\nimport six\nimport zlib\n\nfrom sentry import tagstore\nfrom django.conf import settings\nfrom django.core.urlresolvers import reverse\nfrom django.test.utils import override_settings\nfrom django.utils import timezone\nfrom exam import fixture\nfrom gzip import GzipFile\nfrom raven import Client\nfrom six import StringIO\n\nfrom sentry.models import (Group, Event)\nfrom sentry.testutils import TestCase, TransactionTestCase\nfrom sentry.testutils.helpers import get_auth_header\nfrom sentry.utils.settings import (validate_settings, ConfigurationError, import_string)\n\nDEPENDENCY_TEST_DATA = {\n    \"postgresql\": (\n        'DATABASES', 'psycopg2.extensions', \"database engine\",\n        \"django.db.backends.postgresql_psycopg2\", {\n            'default': {\n                'ENGINE': \"django.db.backends.postgresql_psycopg2\",\n                'NAME': 'test',\n                'USER': 'root',\n                'PASSWORD': '',\n                'HOST': 'localhost',\n                'PORT': ''\n            }\n        }\n    ),\n    \"mysql\": (\n        'DATABASES', 'MySQLdb', \"database engine\", \"django.db.backends.mysql\", {\n            'default': {\n                'ENGINE': \"django.db.backends.mysql\",\n                'NAME': 'test',\n                'USER': 'root',\n                'PASSWORD': '',\n                'HOST': 'localhost',\n                'PORT': ''\n            }\n        }\n    ),\n    \"oracle\": (\n        'DATABASES', 'cx_Oracle', \"database engine\", \"django.db.backends.oracle\", {\n            'default': {\n                'ENGINE': \"django.db.backends.oracle\",\n                'NAME': 'test',\n                'USER': 'root',\n                'PASSWORD': '',\n                'HOST': 'localhost',\n                'PORT': ''\n            }\n        }\n    ),\n    \"memcache\": (\n        'CACHES', 'memcache', \"caching backend\",\n        \"django.core.cache.backends.memcached.MemcachedCache\", {\n            'default': {\n                'BACKEND': \"django.core.cache.backends.memcached.MemcachedCache\",\n                'LOCATION': '127.0.0.1:11211',\n            }\n        }\n    ),\n    \"pylibmc\": (\n        'CACHES', 'pylibmc', \"caching backend\", \"django.core.cache.backends.memcached.PyLibMCCache\",\n        {\n            'default': {\n                'BACKEND': \"django.core.cache.backends.memcached.PyLibMCCache\",\n                'LOCATION': '127.0.0.1:11211',\n            }\n        }\n    ),\n}\n\n\ndef get_fixture_path(name):\n    return os.path.join(os.path.dirname(__file__), 'fixtures', name)\n\n\ndef load_fixture(name):\n    with open(get_fixture_path(name)) as fp:\n        return fp.read()\n\n\nclass AssertHandler(logging.Handler):\n    def emit(self, entry):\n        raise AssertionError(entry.message)\n\n\nclass RavenIntegrationTest(TransactionTestCase):\n    \n\n    def setUp(self):\n        self.user = self.create_user('coreapi@example.com')\n        self.project = self.create_project()\n        self.pk = self.project.key_set.get_or_create()[0]\n\n        self.configure_sentry_errors()\n\n    def configure_sentry_errors(self):\n        assert_handler = AssertHandler()\n        sentry_errors = logging.getLogger('sentry.errors')\n        sentry_errors.addHandler(assert_handler)\n        sentry_errors.setLevel(logging.DEBUG)\n\n        def remove_handler():\n            sentry_errors.handlers.pop(sentry_errors.handlers.index(assert_handler))\n\n        self.addCleanup(remove_handler)\n\n    def sendRemote(self, url, data, headers={}):\n        content_type = headers.pop('Content-Type', None)\n        headers = dict(\n            ('HTTP_' + k.replace('-', '_').upper(), v) for k, v in six.iteritems(headers)\n        )\n        if isinstance(data, six.text_type):\n            data = data.encode('utf-8')\n        resp = self.client.post(\n            reverse('sentry-api-store', args=[self.pk.project_id]),\n            data=data,\n            content_type=content_type,\n            **headers\n        )\n        assert resp.status_code == 200, resp.content\n\n    @mock.patch('raven.base.Client.send_remote')\n    def test_basic(self, send_remote):\n        send_remote.side_effect = self.sendRemote\n        client = Client(\n            dsn='http://%s:%s@localhost:8000/%s' %\n            (self.pk.public_key, self.pk.secret_key, self.pk.project_id)\n        )\n\n        with self.tasks():\n            client.captureMessage(message='foo')\n\n        assert send_remote.call_count is 1\n        assert Group.objects.count() == 1\n        group = Group.objects.get()\n        assert group.event_set.count() == 1\n        instance = group.event_set.get()\n        assert instance.data['sentry.interfaces.Message']['message'] == 'foo'\n\n\nclass SentryRemoteTest(TestCase):\n    @fixture\n    def path(self):\n        return reverse('sentry-api-store')\n\n    def test_minimal(self):\n        kwargs = {'message': 'hello', 'tags': {'foo': 'bar'}}\n\n        resp = self._postWithHeader(kwargs)\n\n        assert resp.status_code == 200, resp.content\n\n        event_id = json.loads(resp.content)['id']\n        instance = Event.objects.get(event_id=event_id)\n\n        assert instance.message == 'hello'\n\n        assert tagstore.get_tag_key(self.project.id, None, 'foo') is not None\n        assert tagstore.get_tag_value(self.project.id, None, 'foo', 'bar') is not None\n        assert tagstore.get_group_tag_key(\n            self.project.id, instance.group_id, None, 'foo') is not None\n        assert tagstore.get_group_tag_value(\n            instance.project_id,\n            instance.group_id,\n            None,\n            'foo',\n            'bar') is not None\n\n    def test_timestamp(self):\n        timestamp = timezone.now().replace(\n            microsecond=0, tzinfo=timezone.utc\n        ) - datetime.timedelta(hours=1)\n        kwargs = {u'message': 'hello', 'timestamp': timestamp.strftime('%s.%f')}\n        resp = self._postWithSignature(kwargs)\n        assert resp.status_code == 200, resp.content\n        instance = Event.objects.get()\n        assert instance.message == 'hello'\n        assert instance.datetime == timestamp\n        group = instance.group\n        assert group.first_seen == timestamp\n        assert group.last_seen == timestamp\n\n    def test_timestamp_as_iso(self):\n        timestamp = timezone.now().replace(\n            microsecond=0, tzinfo=timezone.utc\n        ) - datetime.timedelta(hours=1)\n        kwargs = {u'message': 'hello', 'timestamp': timestamp.strftime('%Y-%m-%dT%H:%M:%S.%f')}\n        resp = self._postWithSignature(kwargs)\n        assert resp.status_code == 200, resp.content\n        instance = Event.objects.get()\n        assert instance.message == 'hello'\n        assert instance.datetime == timestamp\n        group = instance.group\n        assert group.first_seen == timestamp\n        assert group.last_seen == timestamp\n\n    def test_ungzipped_data(self):\n        kwargs = {'message': 'hello'}\n        resp = self._postWithSignature(kwargs)\n        assert resp.status_code == 200\n        instance = Event.objects.get()\n        assert instance.message == 'hello'\n\n    @override_settings(SENTRY_ALLOW_ORIGIN='sentry.io')\n    def test_correct_data_with_get(self):\n        kwargs = {'message': 'hello'}\n        resp = self._getWithReferer(kwargs)\n        assert resp.status_code == 200, resp.content\n        instance = Event.objects.get()\n        assert instance.message == 'hello'\n\n    @override_settings(SENTRY_ALLOW_ORIGIN='sentry.io')\n    def test_get_without_referer(self):\n        self.project.update_option('sentry:origins', '')\n        kwargs = {'message': 'hello'}\n        resp = self._getWithReferer(kwargs, referer=None, protocol='4')\n        assert resp.status_code == 403, (resp.status_code, resp.get('X-Sentry-Error'))\n\n    @override_settings(SENTRY_ALLOW_ORIGIN='*')\n    def test_get_without_referer_allowed(self):\n        self.project.update_option('sentry:origins', '')\n        kwargs = {'message': 'hello'}\n        resp = self._getWithReferer(kwargs, referer=None, protocol='4')\n        assert resp.status_code == 200, (resp.status_code, resp.get('X-Sentry-Error'))\n\n    @override_settings(SENTRY_ALLOW_ORIGIN='sentry.io')\n    def test_correct_data_with_post_referer(self):\n        kwargs = {'message': 'hello'}\n        resp = self._postWithReferer(kwargs)\n        assert resp.status_code == 200, resp.content\n        instance = Event.objects.get()\n        assert instance.message == 'hello'\n\n    @override_settings(SENTRY_ALLOW_ORIGIN='sentry.io')\n    def test_post_without_referer(self):\n        self.project.update_option('sentry:origins', '')\n        kwargs = {'message': 'hello'}\n        resp = self._postWithReferer(kwargs, referer=None, protocol='4')\n        assert resp.status_code == 403, (resp.status_code, resp.get('X-Sentry-Error'))\n\n    @override_settings(SENTRY_ALLOW_ORIGIN='*')\n    def test_post_without_referer_allowed(self):\n        self.project.update_option('sentry:origins', '')\n        kwargs = {'message': 'hello'}\n        resp = self._postWithReferer(kwargs, referer=None, protocol='4')\n        assert resp.status_code == 403, (resp.status_code, resp.get('X-Sentry-Error'))\n\n    def test_signature(self):\n        kwargs = {'message': 'hello'}\n\n        resp = self._postWithSignature(kwargs)\n\n        assert resp.status_code == 200, resp.content\n\n        instance = Event.objects.get()\n\n        assert instance.message == 'hello'\n\n    def test_content_encoding_deflate(self):\n        kwargs = {'message': 'hello'}\n\n        message = zlib.compress(json.dumps(kwargs))\n\n        key = self.projectkey.public_key\n        secret = self.projectkey.secret_key\n\n        with self.tasks():\n            resp = self.client.post(\n                self.path,\n                message,\n                content_type='application/octet-stream',\n                HTTP_CONTENT_ENCODING='deflate',\n                HTTP_X_SENTRY_AUTH=get_auth_header('_postWithHeader', key, secret),\n            )\n\n        assert resp.status_code == 200, resp.content\n\n        event_id = json.loads(resp.content)['id']\n        instance = Event.objects.get(event_id=event_id)\n\n        assert instance.message == 'hello'\n\n    def test_content_encoding_gzip(self):\n        kwargs = {'message': 'hello'}\n\n        message = json.dumps(kwargs)\n\n        fp = StringIO()\n\n        try:\n            f = GzipFile(fileobj=fp, mode='w')\n            f.write(message)\n        finally:\n            f.close()\n\n        key = self.projectkey.public_key\n        secret = self.projectkey.secret_key\n\n        with self.tasks():\n            resp = self.client.post(\n                self.path,\n                fp.getvalue(),\n                content_type='application/octet-stream',\n                HTTP_CONTENT_ENCODING='gzip',\n                HTTP_X_SENTRY_AUTH=get_auth_header('_postWithHeader', key, secret),\n            )\n\n        assert resp.status_code == 200, resp.content\n\n        event_id = json.loads(resp.content)['id']\n        instance = Event.objects.get(event_id=event_id)\n\n        assert instance.message == 'hello'\n\n    def test_protocol_v2_0_without_secret_key(self):\n        kwargs = {'message': 'hello'}\n\n        resp = self._postWithHeader(\n            data=kwargs,\n            key=self.projectkey.public_key,\n            protocol='2.0',\n        )\n\n        assert resp.status_code == 200, resp.content\n\n        event_id = json.loads(resp.content)['id']\n        instance = Event.objects.get(event_id=event_id)\n\n        assert instance.message == 'hello'\n\n    def test_protocol_v3(self):\n        kwargs = {'message': 'hello'}\n\n        resp = self._postWithHeader(\n            data=kwargs,\n            key=self.projectkey.public_key,\n            secret=self.projectkey.secret_key,\n            protocol='3',\n        )\n\n        assert resp.status_code == 200, resp.content\n\n        event_id = json.loads(resp.content)['id']\n        instance = Event.objects.get(event_id=event_id)\n\n        assert instance.message == 'hello'\n\n    def test_protocol_v4(self):\n        kwargs = {'message': 'hello'}\n\n        resp = self._postWithHeader(\n            data=kwargs,\n            key=self.projectkey.public_key,\n            secret=self.projectkey.secret_key,\n            protocol='4',\n        )\n\n        assert resp.status_code == 200, resp.content\n\n        event_id = json.loads(resp.content)['id']\n        instance = Event.objects.get(event_id=event_id)\n\n        assert instance.message == 'hello'\n\n    def test_protocol_v5(self):\n        kwargs = {'message': 'hello'}\n\n        resp = self._postWithHeader(\n            data=kwargs,\n            key=self.projectkey.public_key,\n            secret=self.projectkey.secret_key,\n            protocol='5',\n        )\n\n        assert resp.status_code == 200, resp.content\n\n        event_id = json.loads(resp.content)['id']\n        instance = Event.objects.get(event_id=event_id)\n\n        assert instance.message == 'hello'\n\n    def test_protocol_v6(self):\n        kwargs = {'message': 'hello'}\n\n        resp = self._postWithHeader(\n            data=kwargs,\n            key=self.projectkey.public_key,\n            secret=self.projectkey.secret_key,\n            protocol='6',\n        )\n\n        assert resp.status_code == 200, resp.content\n\n        event_id = json.loads(resp.content)['id']\n        instance = Event.objects.get(event_id=event_id)\n\n        assert instance.message == 'hello'\n\n\nclass DepdendencyTest(TestCase):\n    def raise_import_error(self, package):\n        def callable(package_name):\n            if package_name != package:\n                return import_string(package_name)\n            raise ImportError(\"No module named %s\" % (package, ))\n\n        return callable\n\n    @mock.patch('django.conf.settings', mock.Mock())\n    @mock.patch('sentry.utils.settings.import_string')\n    def validate_dependency(\n        self, key, package, dependency_type, dependency, setting_value, import_string\n    ):\n\n        import_string.side_effect = self.raise_import_error(package)\n\n        with self.settings(**{key: setting_value}):\n            with self.assertRaises(ConfigurationError):\n                validate_settings(settings)\n\n    def test_validate_fails_on_postgres(self):\n        self.validate_dependency(*DEPENDENCY_TEST_DATA['postgresql'])\n\n    def test_validate_fails_on_mysql(self):\n        self.validate_dependency(*DEPENDENCY_TEST_DATA['mysql'])\n\n    def test_validate_fails_on_oracle(self):\n        self.validate_dependency(*DEPENDENCY_TEST_DATA['oracle'])\n\n    def test_validate_fails_on_memcache(self):\n        self.validate_dependency(*DEPENDENCY_TEST_DATA['memcache'])\n\n    def test_validate_fails_on_pylibmc(self):\n        self.validate_dependency(*DEPENDENCY_TEST_DATA['pylibmc'])\n\n\ndef get_fixtures(name):\n    path = os.path.join(os.path.dirname(__file__), 'fixtures/csp', name)\n    try:\n        with open(path + '_input.json', 'rb') as fp1:\n            input = fp1.read()\n    except IOError:\n        input = None\n\n    try:\n        with open(path + '_output.json', 'rb') as fp2:\n            output = json.load(fp2)\n    except IOError:\n        output = None\n\n    return input, output\n\n\nclass CspReportTest(TestCase):\n    def assertReportCreated(self, input, output):\n        resp = self._postCspWithHeader(input)\n        assert resp.status_code == 201, resp.content\n        assert Event.objects.count() == 1\n        e = Event.objects.all()[0]\n        Event.objects.bind_nodes([e], 'data')\n        assert output['message'] == e.data['sentry.interfaces.Message']['message']\n        for key, value in six.iteritems(output['tags']):\n            assert e.get_tag(key) == value\n        self.assertDictContainsSubset(output['data'], e.data.data, e.data.data)\n\n    def assertReportRejected(self, input):\n        resp = self._postCspWithHeader(input)\n        assert resp.status_code in (400, 403), resp.content\n\n    def test_chrome_blocked_asset(self):\n        self.assertReportCreated(*get_fixtures('chrome_blocked_asset'))\n\n    def test_firefox_missing_effective_uri(self):\n        input, _ = get_fixtures('firefox_blocked_asset')\n        self.assertReportRejected(input)\n", "comments": "        this mocks test server specifically tests behavior would     happen raven      sentry http communication                 coding  utf 8     ", "content": "# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, print_function\n\nimport os\nimport datetime\nimport json\nimport logging\nimport mock\nimport six\nimport zlib\n\nfrom sentry import tagstore\nfrom django.conf import settings\nfrom django.core.urlresolvers import reverse\nfrom django.test.utils import override_settings\nfrom django.utils import timezone\nfrom exam import fixture\nfrom gzip import GzipFile\nfrom raven import Client\nfrom six import StringIO\n\nfrom sentry.models import (Group, Event)\nfrom sentry.testutils import TestCase, TransactionTestCase\nfrom sentry.testutils.helpers import get_auth_header\nfrom sentry.utils.settings import (validate_settings, ConfigurationError, import_string)\n\nDEPENDENCY_TEST_DATA = {\n    \"postgresql\": (\n        'DATABASES', 'psycopg2.extensions', \"database engine\",\n        \"django.db.backends.postgresql_psycopg2\", {\n            'default': {\n                'ENGINE': \"django.db.backends.postgresql_psycopg2\",\n                'NAME': 'test',\n                'USER': 'root',\n                'PASSWORD': '',\n                'HOST': 'localhost',\n                'PORT': ''\n            }\n        }\n    ),\n    \"mysql\": (\n        'DATABASES', 'MySQLdb', \"database engine\", \"django.db.backends.mysql\", {\n            'default': {\n                'ENGINE': \"django.db.backends.mysql\",\n                'NAME': 'test',\n                'USER': 'root',\n                'PASSWORD': '',\n                'HOST': 'localhost',\n                'PORT': ''\n            }\n        }\n    ),\n    \"oracle\": (\n        'DATABASES', 'cx_Oracle', \"database engine\", \"django.db.backends.oracle\", {\n            'default': {\n                'ENGINE': \"django.db.backends.oracle\",\n                'NAME': 'test',\n                'USER': 'root',\n                'PASSWORD': '',\n                'HOST': 'localhost',\n                'PORT': ''\n            }\n        }\n    ),\n    \"memcache\": (\n        'CACHES', 'memcache', \"caching backend\",\n        \"django.core.cache.backends.memcached.MemcachedCache\", {\n            'default': {\n                'BACKEND': \"django.core.cache.backends.memcached.MemcachedCache\",\n                'LOCATION': '127.0.0.1:11211',\n            }\n        }\n    ),\n    \"pylibmc\": (\n        'CACHES', 'pylibmc', \"caching backend\", \"django.core.cache.backends.memcached.PyLibMCCache\",\n        {\n            'default': {\n                'BACKEND': \"django.core.cache.backends.memcached.PyLibMCCache\",\n                'LOCATION': '127.0.0.1:11211',\n            }\n        }\n    ),\n}\n\n\ndef get_fixture_path(name):\n    return os.path.join(os.path.dirname(__file__), 'fixtures', name)\n\n\ndef load_fixture(name):\n    with open(get_fixture_path(name)) as fp:\n        return fp.read()\n\n\nclass AssertHandler(logging.Handler):\n    def emit(self, entry):\n        raise AssertionError(entry.message)\n\n\nclass RavenIntegrationTest(TransactionTestCase):\n    \"\"\"\n    This mocks the test server and specifically tests behavior that would\n    happen between Raven <--> Sentry over HTTP communication.\n    \"\"\"\n\n    def setUp(self):\n        self.user = self.create_user('coreapi@example.com')\n        self.project = self.create_project()\n        self.pk = self.project.key_set.get_or_create()[0]\n\n        self.configure_sentry_errors()\n\n    def configure_sentry_errors(self):\n        assert_handler = AssertHandler()\n        sentry_errors = logging.getLogger('sentry.errors')\n        sentry_errors.addHandler(assert_handler)\n        sentry_errors.setLevel(logging.DEBUG)\n\n        def remove_handler():\n            sentry_errors.handlers.pop(sentry_errors.handlers.index(assert_handler))\n\n        self.addCleanup(remove_handler)\n\n    def sendRemote(self, url, data, headers={}):\n        content_type = headers.pop('Content-Type', None)\n        headers = dict(\n            ('HTTP_' + k.replace('-', '_').upper(), v) for k, v in six.iteritems(headers)\n        )\n        if isinstance(data, six.text_type):\n            data = data.encode('utf-8')\n        resp = self.client.post(\n            reverse('sentry-api-store', args=[self.pk.project_id]),\n            data=data,\n            content_type=content_type,\n            **headers\n        )\n        assert resp.status_code == 200, resp.content\n\n    @mock.patch('raven.base.Client.send_remote')\n    def test_basic(self, send_remote):\n        send_remote.side_effect = self.sendRemote\n        client = Client(\n            dsn='http://%s:%s@localhost:8000/%s' %\n            (self.pk.public_key, self.pk.secret_key, self.pk.project_id)\n        )\n\n        with self.tasks():\n            client.captureMessage(message='foo')\n\n        assert send_remote.call_count is 1\n        assert Group.objects.count() == 1\n        group = Group.objects.get()\n        assert group.event_set.count() == 1\n        instance = group.event_set.get()\n        assert instance.data['sentry.interfaces.Message']['message'] == 'foo'\n\n\nclass SentryRemoteTest(TestCase):\n    @fixture\n    def path(self):\n        return reverse('sentry-api-store')\n\n    def test_minimal(self):\n        kwargs = {'message': 'hello', 'tags': {'foo': 'bar'}}\n\n        resp = self._postWithHeader(kwargs)\n\n        assert resp.status_code == 200, resp.content\n\n        event_id = json.loads(resp.content)['id']\n        instance = Event.objects.get(event_id=event_id)\n\n        assert instance.message == 'hello'\n\n        assert tagstore.get_tag_key(self.project.id, None, 'foo') is not None\n        assert tagstore.get_tag_value(self.project.id, None, 'foo', 'bar') is not None\n        assert tagstore.get_group_tag_key(\n            self.project.id, instance.group_id, None, 'foo') is not None\n        assert tagstore.get_group_tag_value(\n            instance.project_id,\n            instance.group_id,\n            None,\n            'foo',\n            'bar') is not None\n\n    def test_timestamp(self):\n        timestamp = timezone.now().replace(\n            microsecond=0, tzinfo=timezone.utc\n        ) - datetime.timedelta(hours=1)\n        kwargs = {u'message': 'hello', 'timestamp': timestamp.strftime('%s.%f')}\n        resp = self._postWithSignature(kwargs)\n        assert resp.status_code == 200, resp.content\n        instance = Event.objects.get()\n        assert instance.message == 'hello'\n        assert instance.datetime == timestamp\n        group = instance.group\n        assert group.first_seen == timestamp\n        assert group.last_seen == timestamp\n\n    def test_timestamp_as_iso(self):\n        timestamp = timezone.now().replace(\n            microsecond=0, tzinfo=timezone.utc\n        ) - datetime.timedelta(hours=1)\n        kwargs = {u'message': 'hello', 'timestamp': timestamp.strftime('%Y-%m-%dT%H:%M:%S.%f')}\n        resp = self._postWithSignature(kwargs)\n        assert resp.status_code == 200, resp.content\n        instance = Event.objects.get()\n        assert instance.message == 'hello'\n        assert instance.datetime == timestamp\n        group = instance.group\n        assert group.first_seen == timestamp\n        assert group.last_seen == timestamp\n\n    def test_ungzipped_data(self):\n        kwargs = {'message': 'hello'}\n        resp = self._postWithSignature(kwargs)\n        assert resp.status_code == 200\n        instance = Event.objects.get()\n        assert instance.message == 'hello'\n\n    @override_settings(SENTRY_ALLOW_ORIGIN='sentry.io')\n    def test_correct_data_with_get(self):\n        kwargs = {'message': 'hello'}\n        resp = self._getWithReferer(kwargs)\n        assert resp.status_code == 200, resp.content\n        instance = Event.objects.get()\n        assert instance.message == 'hello'\n\n    @override_settings(SENTRY_ALLOW_ORIGIN='sentry.io')\n    def test_get_without_referer(self):\n        self.project.update_option('sentry:origins', '')\n        kwargs = {'message': 'hello'}\n        resp = self._getWithReferer(kwargs, referer=None, protocol='4')\n        assert resp.status_code == 403, (resp.status_code, resp.get('X-Sentry-Error'))\n\n    @override_settings(SENTRY_ALLOW_ORIGIN='*')\n    def test_get_without_referer_allowed(self):\n        self.project.update_option('sentry:origins', '')\n        kwargs = {'message': 'hello'}\n        resp = self._getWithReferer(kwargs, referer=None, protocol='4')\n        assert resp.status_code == 200, (resp.status_code, resp.get('X-Sentry-Error'))\n\n    @override_settings(SENTRY_ALLOW_ORIGIN='sentry.io')\n    def test_correct_data_with_post_referer(self):\n        kwargs = {'message': 'hello'}\n        resp = self._postWithReferer(kwargs)\n        assert resp.status_code == 200, resp.content\n        instance = Event.objects.get()\n        assert instance.message == 'hello'\n\n    @override_settings(SENTRY_ALLOW_ORIGIN='sentry.io')\n    def test_post_without_referer(self):\n        self.project.update_option('sentry:origins', '')\n        kwargs = {'message': 'hello'}\n        resp = self._postWithReferer(kwargs, referer=None, protocol='4')\n        assert resp.status_code == 403, (resp.status_code, resp.get('X-Sentry-Error'))\n\n    @override_settings(SENTRY_ALLOW_ORIGIN='*')\n    def test_post_without_referer_allowed(self):\n        self.project.update_option('sentry:origins', '')\n        kwargs = {'message': 'hello'}\n        resp = self._postWithReferer(kwargs, referer=None, protocol='4')\n        assert resp.status_code == 403, (resp.status_code, resp.get('X-Sentry-Error'))\n\n    def test_signature(self):\n        kwargs = {'message': 'hello'}\n\n        resp = self._postWithSignature(kwargs)\n\n        assert resp.status_code == 200, resp.content\n\n        instance = Event.objects.get()\n\n        assert instance.message == 'hello'\n\n    def test_content_encoding_deflate(self):\n        kwargs = {'message': 'hello'}\n\n        message = zlib.compress(json.dumps(kwargs))\n\n        key = self.projectkey.public_key\n        secret = self.projectkey.secret_key\n\n        with self.tasks():\n            resp = self.client.post(\n                self.path,\n                message,\n                content_type='application/octet-stream',\n                HTTP_CONTENT_ENCODING='deflate',\n                HTTP_X_SENTRY_AUTH=get_auth_header('_postWithHeader', key, secret),\n            )\n\n        assert resp.status_code == 200, resp.content\n\n        event_id = json.loads(resp.content)['id']\n        instance = Event.objects.get(event_id=event_id)\n\n        assert instance.message == 'hello'\n\n    def test_content_encoding_gzip(self):\n        kwargs = {'message': 'hello'}\n\n        message = json.dumps(kwargs)\n\n        fp = StringIO()\n\n        try:\n            f = GzipFile(fileobj=fp, mode='w')\n            f.write(message)\n        finally:\n            f.close()\n\n        key = self.projectkey.public_key\n        secret = self.projectkey.secret_key\n\n        with self.tasks():\n            resp = self.client.post(\n                self.path,\n                fp.getvalue(),\n                content_type='application/octet-stream',\n                HTTP_CONTENT_ENCODING='gzip',\n                HTTP_X_SENTRY_AUTH=get_auth_header('_postWithHeader', key, secret),\n            )\n\n        assert resp.status_code == 200, resp.content\n\n        event_id = json.loads(resp.content)['id']\n        instance = Event.objects.get(event_id=event_id)\n\n        assert instance.message == 'hello'\n\n    def test_protocol_v2_0_without_secret_key(self):\n        kwargs = {'message': 'hello'}\n\n        resp = self._postWithHeader(\n            data=kwargs,\n            key=self.projectkey.public_key,\n            protocol='2.0',\n        )\n\n        assert resp.status_code == 200, resp.content\n\n        event_id = json.loads(resp.content)['id']\n        instance = Event.objects.get(event_id=event_id)\n\n        assert instance.message == 'hello'\n\n    def test_protocol_v3(self):\n        kwargs = {'message': 'hello'}\n\n        resp = self._postWithHeader(\n            data=kwargs,\n            key=self.projectkey.public_key,\n            secret=self.projectkey.secret_key,\n            protocol='3',\n        )\n\n        assert resp.status_code == 200, resp.content\n\n        event_id = json.loads(resp.content)['id']\n        instance = Event.objects.get(event_id=event_id)\n\n        assert instance.message == 'hello'\n\n    def test_protocol_v4(self):\n        kwargs = {'message': 'hello'}\n\n        resp = self._postWithHeader(\n            data=kwargs,\n            key=self.projectkey.public_key,\n            secret=self.projectkey.secret_key,\n            protocol='4',\n        )\n\n        assert resp.status_code == 200, resp.content\n\n        event_id = json.loads(resp.content)['id']\n        instance = Event.objects.get(event_id=event_id)\n\n        assert instance.message == 'hello'\n\n    def test_protocol_v5(self):\n        kwargs = {'message': 'hello'}\n\n        resp = self._postWithHeader(\n            data=kwargs,\n            key=self.projectkey.public_key,\n            secret=self.projectkey.secret_key,\n            protocol='5',\n        )\n\n        assert resp.status_code == 200, resp.content\n\n        event_id = json.loads(resp.content)['id']\n        instance = Event.objects.get(event_id=event_id)\n\n        assert instance.message == 'hello'\n\n    def test_protocol_v6(self):\n        kwargs = {'message': 'hello'}\n\n        resp = self._postWithHeader(\n            data=kwargs,\n            key=self.projectkey.public_key,\n            secret=self.projectkey.secret_key,\n            protocol='6',\n        )\n\n        assert resp.status_code == 200, resp.content\n\n        event_id = json.loads(resp.content)['id']\n        instance = Event.objects.get(event_id=event_id)\n\n        assert instance.message == 'hello'\n\n\nclass DepdendencyTest(TestCase):\n    def raise_import_error(self, package):\n        def callable(package_name):\n            if package_name != package:\n                return import_string(package_name)\n            raise ImportError(\"No module named %s\" % (package, ))\n\n        return callable\n\n    @mock.patch('django.conf.settings', mock.Mock())\n    @mock.patch('sentry.utils.settings.import_string')\n    def validate_dependency(\n        self, key, package, dependency_type, dependency, setting_value, import_string\n    ):\n\n        import_string.side_effect = self.raise_import_error(package)\n\n        with self.settings(**{key: setting_value}):\n            with self.assertRaises(ConfigurationError):\n                validate_settings(settings)\n\n    def test_validate_fails_on_postgres(self):\n        self.validate_dependency(*DEPENDENCY_TEST_DATA['postgresql'])\n\n    def test_validate_fails_on_mysql(self):\n        self.validate_dependency(*DEPENDENCY_TEST_DATA['mysql'])\n\n    def test_validate_fails_on_oracle(self):\n        self.validate_dependency(*DEPENDENCY_TEST_DATA['oracle'])\n\n    def test_validate_fails_on_memcache(self):\n        self.validate_dependency(*DEPENDENCY_TEST_DATA['memcache'])\n\n    def test_validate_fails_on_pylibmc(self):\n        self.validate_dependency(*DEPENDENCY_TEST_DATA['pylibmc'])\n\n\ndef get_fixtures(name):\n    path = os.path.join(os.path.dirname(__file__), 'fixtures/csp', name)\n    try:\n        with open(path + '_input.json', 'rb') as fp1:\n            input = fp1.read()\n    except IOError:\n        input = None\n\n    try:\n        with open(path + '_output.json', 'rb') as fp2:\n            output = json.load(fp2)\n    except IOError:\n        output = None\n\n    return input, output\n\n\nclass CspReportTest(TestCase):\n    def assertReportCreated(self, input, output):\n        resp = self._postCspWithHeader(input)\n        assert resp.status_code == 201, resp.content\n        assert Event.objects.count() == 1\n        e = Event.objects.all()[0]\n        Event.objects.bind_nodes([e], 'data')\n        assert output['message'] == e.data['sentry.interfaces.Message']['message']\n        for key, value in six.iteritems(output['tags']):\n            assert e.get_tag(key) == value\n        self.assertDictContainsSubset(output['data'], e.data.data, e.data.data)\n\n    def assertReportRejected(self, input):\n        resp = self._postCspWithHeader(input)\n        assert resp.status_code in (400, 403), resp.content\n\n    def test_chrome_blocked_asset(self):\n        self.assertReportCreated(*get_fixtures('chrome_blocked_asset'))\n\n    def test_firefox_missing_effective_uri(self):\n        input, _ = get_fixtures('firefox_blocked_asset')\n        self.assertReportRejected(input)\n", "description": "Sentry is a cross-platform crash reporting and aggregation platform.", "file_name": "tests.py", "id": "85e661734e381062be3223bbac6662a8", "language": "Python", "project_name": "sentry", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/getsentry-sentry/getsentry-sentry-6a9c7e2/tests/integration/tests.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:23:24Z", "url": "https://github.com/getsentry/sentry", "wiki": false}