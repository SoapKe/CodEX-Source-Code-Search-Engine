{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport json\nimport re\n\nfrom .common import InfoExtractor\n\nfrom ..compat import compat_str\nfrom ..utils import (\n    int_or_none,\n    try_get,\n)\n\n\nclass TEDIE(InfoExtractor):\n    IE_NAME = 'ted'\n    _VALID_URL = r\n\n        webpage = self._download_webpage(url, name,\n                                         'Downloading playlist webpage')\n        info = self._extract_info(webpage)\n\n        playlist_info = try_get(\n            info, lambda x: x['__INITIAL_DATA__']['playlist'],\n            dict) or info['playlist']\n\n        playlist_entries = [\n            self.url_result('http://www.ted.com/talks/' + talk['slug'], self.ie_key())\n            for talk in try_get(\n                info, lambda x: x['__INITIAL_DATA__']['talks'],\n                dict) or info['talks']\n        ]\n        return self.playlist_result(\n            playlist_entries,\n            playlist_id=compat_str(playlist_info['id']),\n            playlist_title=playlist_info['title'])\n\n    def _talk_info(self, url, video_name):\n        webpage = self._download_webpage(url, video_name)\n\n        info = self._extract_info(webpage)\n\n        talk_info = try_get(\n            info, lambda x: x['__INITIAL_DATA__']['talks'][0],\n            dict) or info['talks'][0]\n\n        title = talk_info['title'].strip()\n\n        external = talk_info.get('external')\n        if external:\n            service = external['service']\n            self.to_screen('Found video from %s' % service)\n            ext_url = None\n            if service.lower() == 'youtube':\n                ext_url = external.get('code')\n            return {\n                '_type': 'url',\n                'url': ext_url or external['uri'],\n            }\n\n        native_downloads = try_get(\n            talk_info, lambda x: x['downloads']['nativeDownloads'],\n            dict) or talk_info['nativeDownloads']\n\n        formats = [{\n            'url': format_url,\n            'format_id': format_id,\n            'format': format_id,\n        } for (format_id, format_url) in native_downloads.items() if format_url is not None]\n        if formats:\n            for f in formats:\n                finfo = self._NATIVE_FORMATS.get(f['format_id'])\n                if finfo:\n                    f.update(finfo)\n\n        player_talk = talk_info['player_talks'][0]\n\n        resources_ = player_talk.get('resources') or talk_info.get('resources')\n\n        http_url = None\n        for format_id, resources in resources_.items():\n            if format_id == 'h264':\n                for resource in resources:\n                    h264_url = resource.get('file')\n                    if not h264_url:\n                        continue\n                    bitrate = int_or_none(resource.get('bitrate'))\n                    formats.append({\n                        'url': h264_url,\n                        'format_id': '%s-%sk' % (format_id, bitrate),\n                        'tbr': bitrate,\n                    })\n                    if re.search(r'\\d+k', h264_url):\n                        http_url = h264_url\n            elif format_id == 'rtmp':\n                streamer = talk_info.get('streamer')\n                if not streamer:\n                    continue\n                for resource in resources:\n                    formats.append({\n                        'format_id': '%s-%s' % (format_id, resource.get('name')),\n                        'url': streamer,\n                        'play_path': resource['file'],\n                        'ext': 'flv',\n                        'width': int_or_none(resource.get('width')),\n                        'height': int_or_none(resource.get('height')),\n                        'tbr': int_or_none(resource.get('bitrate')),\n                    })\n            elif format_id == 'hls':\n                formats.extend(self._extract_m3u8_formats(\n                    resources.get('stream'), video_name, 'mp4', m3u8_id=format_id, fatal=False))\n\n        m3u8_formats = list(filter(\n            lambda f: f.get('protocol') == 'm3u8' and f.get('vcodec') != 'none',\n            formats))\n        if http_url:\n            for m3u8_format in m3u8_formats:\n                bitrate = self._search_regex(r'(\\d+k)', m3u8_format['url'], 'bitrate', default=None)\n                if not bitrate:\n                    continue\n                f = m3u8_format.copy()\n                f.update({\n                    'url': re.sub(r'\\d+k', bitrate, http_url),\n                    'format_id': m3u8_format['format_id'].replace('hls', 'http'),\n                    'protocol': 'http',\n                })\n                formats.append(f)\n\n        audio_download = talk_info.get('audioDownload')\n        if audio_download:\n            formats.append({\n                'url': audio_download,\n                'format_id': 'audio',\n                'vcodec': 'none',\n            })\n\n        self._sort_formats(formats)\n\n        video_id = compat_str(talk_info['id'])\n\n        return {\n            'id': video_id,\n            'title': title,\n            'uploader': player_talk.get('speaker') or talk_info.get('speaker'),\n            'thumbnail': player_talk.get('thumb') or talk_info.get('thumb'),\n            'description': self._og_search_description(webpage),\n            'subtitles': self._get_subtitles(video_id, talk_info),\n            'formats': formats,\n            'duration': talk_info.get('duration'),\n        }\n\n    def _get_subtitles(self, video_id, talk_info):\n        sub_lang_list = {}\n        for language in try_get(\n                talk_info,\n                (lambda x: x['downloads']['languages'],\n                 lambda x: x['languages']), list):\n            lang_code = language.get('languageCode') or language.get('ianaCode')\n            if not lang_code:\n                continue\n            sub_lang_list[lang_code] = [\n                {\n                    'url': 'http://www.ted.com/talks/subtitles/id/%s/lang/%s/format/%s' % (video_id, lang_code, ext),\n                    'ext': ext,\n                }\n                for ext in ['ted', 'srt']\n            ]\n        return sub_lang_list\n\n    def _watch_info(self, url, name):\n        webpage = self._download_webpage(url, name)\n\n        config_json = self._html_search_regex(\n            r'\"pages\\.jwplayer\"\\s*,\\s*({.+?})\\s*\\)\\s*</script>',\n            webpage, 'config', default=None)\n        if not config_json:\n            embed_url = self._search_regex(\n                r\"<iframe[^>]+class='pages-video-embed__video__object'[^>]+src='([^']+)'\", webpage, 'embed url')\n            return self.url_result(self._proto_relative_url(embed_url))\n        config = json.loads(config_json)['config']\n        video_url = config['video']['url']\n        thumbnail = config.get('image', {}).get('url')\n\n        title = self._html_search_regex(\n            r\"(?s)<h1(?:\\s+class='[^']+')?>(.+?)</h1>\", webpage, 'title')\n        description = self._html_search_regex(\n            [\n                r'(?s)<h4 class=\"[^\"]+\" id=\"h3--about-this-talk\">.*?</h4>(.*?)</div>',\n                r'(?s)<p><strong>About this talk:</strong>\\s+(.*?)</p>',\n            ],\n            webpage, 'description', fatal=False)\n\n        return {\n            'id': name,\n            'url': video_url,\n            'title': title,\n            'thumbnail': thumbnail,\n            'description': description,\n        }\n", "comments": "(?x)\n        (?P<proto>https?://)\n        (?P<type>www|embed(?:-ssl)?)(?P<urlmain>\\.ted\\.com/\n        (\n            (?P<type_playlist>playlists(?:/\\d+)?) # We have a playlist\n            |\n            ((?P<type_talk>talks)) # We have a simple talk\n            |\n            (?P<type_watch>watch)/[^/]+/[^/]+\n        )\n        (/lang/(.*?))? # The url may contain the language\n        /(?P<name>[\\w-]+) # Here goes the name and then \".html\"\n        .*)$\n        '''\n    _TESTS = [{\n        'url': 'http://www.ted.com/talks/dan_dennett_on_our_consciousness.html',\n        'md5': '0de43ac406aa3e4ea74b66c9c7789b13',\n        'info_dict': {\n            'id': '102',\n            'ext': 'mp4',\n            'title': 'The illusion of consciousness',\n            'description': ('Philosopher Dan Dennett makes a compelling '\n                            'argument that not only don\\'t we understand our own '\n                            'consciousness, but that half the time our brains are '\n                            'actively fooling us.'),\n            'uploader': 'Dan Dennett',\n            'width': 853,\n            'duration': 1308,\n        }\n    }, {\n        'url': 'http://www.ted.com/watch/ted-institute/ted-bcg/vishal-sikka-the-beauty-and-power-of-algorithms',\n        'md5': 'b899ac15e345fb39534d913f7606082b',\n        'info_dict': {\n            'id': 'tSVI8ta_P4w',\n            'ext': 'mp4',\n            'title': 'Vishal Sikka: The beauty and power of algorithms',\n            'thumbnail': r're:^https?://.+\\.jpg',\n            'description': 'md5:6261fdfe3e02f4f579cbbfc00aff73f4',\n            'upload_date': '20140122',\n            'uploader_id': 'TEDInstitute',\n            'uploader': 'TED Institute',\n        },\n        'add_ie': ['Youtube'],\n    }, {\n        'url': 'http://www.ted.com/talks/gabby_giffords_and_mark_kelly_be_passionate_be_courageous_be_your_best',\n        'md5': '71b3ab2f4233012dce09d515c9c39ce2',\n        'info_dict': {\n            'id': '1972',\n            'ext': 'mp4',\n            'title': 'Be passionate. Be courageous. Be your best.',\n            'uploader': 'Gabby Giffords and Mark Kelly',\n            'description': 'md5:5174aed4d0f16021b704120360f72b92',\n            'duration': 1128,\n        },\n    }, {\n        'url': 'http://www.ted.com/playlists/who_are_the_hackers',\n        'info_dict': {\n            'id': '10',\n            'title': 'Who are the hackers?',\n        },\n        'playlist_mincount': 6,\n    }, {\n        # contains a youtube video\n        'url': 'https://www.ted.com/talks/douglas_adams_parrots_the_universe_and_everything',\n        'add_ie': ['Youtube'],\n        'info_dict': {\n            'id': '_ZG8HBuDjgc',\n            'ext': 'webm',\n            'title': 'Douglas Adams: Parrots the Universe and Everything',\n            'description': 'md5:01ad1e199c49ac640cb1196c0e9016af',\n            'uploader': 'University of California Television (UCTV)',\n            'uploader_id': 'UCtelevision',\n            'upload_date': '20080522',\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }, {\n        # YouTube video\n        'url': 'http://www.ted.com/talks/jeffrey_kluger_the_sibling_bond',\n        'add_ie': ['Youtube'],\n        'info_dict': {\n            'id': 'aFBIPO-P7LM',\n            'ext': 'mp4',\n            'title': 'The hidden power of siblings: Jeff Kluger at TEDxAsheville',\n            'description': 'md5:3d7a4f50d95ca5dd67104e2a20f43fe1',\n            'uploader': 'TEDx Talks',\n            'uploader_id': 'TEDxTalks',\n            'upload_date': '20111216',\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }]\n\n    _NATIVE_FORMATS = {\n        'low': {'width': 320, 'height': 180},\n        'medium': {'width': 512, 'height': 288},\n        'high': {'width': 854, 'height': 480},\n    }\n\n    def _extract_info(self, webpage):\n        info_json = self._search_regex(\n            r'(?s)q\\(\\s*\"\\w+.init\"\\s*,\\s*({.+})\\)\\s*</script>',\n            webpage, 'info json')\n        return json.loads(info_json)\n\n    def _real_extract(self, url):\n        m = re.match(self._VALID_URL, url, re.VERBOSE)\n        if m.group('type').startswith('embed'):\n            desktop_url = m.group('proto') + 'www' + m.group('urlmain')\n            return self.url_result(desktop_url, 'TED')\n        name = m.group('name')\n        if m.group('type_talk'):\n            return self._talk_info(url, name)\n        elif m.group('type_watch'):\n            return self._watch_info(url, name)\n        else:\n            return self._playlist_videos_info(url, name)\n\n    def _playlist_videos_info(self, url, name):\n        '''Returns the videos of the playlist\nt\n", "content": "from __future__ import unicode_literals\n\nimport json\nimport re\n\nfrom .common import InfoExtractor\n\nfrom ..compat import compat_str\nfrom ..utils import (\n    int_or_none,\n    try_get,\n)\n\n\nclass TEDIE(InfoExtractor):\n    IE_NAME = 'ted'\n    _VALID_URL = r'''(?x)\n        (?P<proto>https?://)\n        (?P<type>www|embed(?:-ssl)?)(?P<urlmain>\\.ted\\.com/\n        (\n            (?P<type_playlist>playlists(?:/\\d+)?) # We have a playlist\n            |\n            ((?P<type_talk>talks)) # We have a simple talk\n            |\n            (?P<type_watch>watch)/[^/]+/[^/]+\n        )\n        (/lang/(.*?))? # The url may contain the language\n        /(?P<name>[\\w-]+) # Here goes the name and then \".html\"\n        .*)$\n        '''\n    _TESTS = [{\n        'url': 'http://www.ted.com/talks/dan_dennett_on_our_consciousness.html',\n        'md5': '0de43ac406aa3e4ea74b66c9c7789b13',\n        'info_dict': {\n            'id': '102',\n            'ext': 'mp4',\n            'title': 'The illusion of consciousness',\n            'description': ('Philosopher Dan Dennett makes a compelling '\n                            'argument that not only don\\'t we understand our own '\n                            'consciousness, but that half the time our brains are '\n                            'actively fooling us.'),\n            'uploader': 'Dan Dennett',\n            'width': 853,\n            'duration': 1308,\n        }\n    }, {\n        'url': 'http://www.ted.com/watch/ted-institute/ted-bcg/vishal-sikka-the-beauty-and-power-of-algorithms',\n        'md5': 'b899ac15e345fb39534d913f7606082b',\n        'info_dict': {\n            'id': 'tSVI8ta_P4w',\n            'ext': 'mp4',\n            'title': 'Vishal Sikka: The beauty and power of algorithms',\n            'thumbnail': r're:^https?://.+\\.jpg',\n            'description': 'md5:6261fdfe3e02f4f579cbbfc00aff73f4',\n            'upload_date': '20140122',\n            'uploader_id': 'TEDInstitute',\n            'uploader': 'TED Institute',\n        },\n        'add_ie': ['Youtube'],\n    }, {\n        'url': 'http://www.ted.com/talks/gabby_giffords_and_mark_kelly_be_passionate_be_courageous_be_your_best',\n        'md5': '71b3ab2f4233012dce09d515c9c39ce2',\n        'info_dict': {\n            'id': '1972',\n            'ext': 'mp4',\n            'title': 'Be passionate. Be courageous. Be your best.',\n            'uploader': 'Gabby Giffords and Mark Kelly',\n            'description': 'md5:5174aed4d0f16021b704120360f72b92',\n            'duration': 1128,\n        },\n    }, {\n        'url': 'http://www.ted.com/playlists/who_are_the_hackers',\n        'info_dict': {\n            'id': '10',\n            'title': 'Who are the hackers?',\n        },\n        'playlist_mincount': 6,\n    }, {\n        # contains a youtube video\n        'url': 'https://www.ted.com/talks/douglas_adams_parrots_the_universe_and_everything',\n        'add_ie': ['Youtube'],\n        'info_dict': {\n            'id': '_ZG8HBuDjgc',\n            'ext': 'webm',\n            'title': 'Douglas Adams: Parrots the Universe and Everything',\n            'description': 'md5:01ad1e199c49ac640cb1196c0e9016af',\n            'uploader': 'University of California Television (UCTV)',\n            'uploader_id': 'UCtelevision',\n            'upload_date': '20080522',\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }, {\n        # YouTube video\n        'url': 'http://www.ted.com/talks/jeffrey_kluger_the_sibling_bond',\n        'add_ie': ['Youtube'],\n        'info_dict': {\n            'id': 'aFBIPO-P7LM',\n            'ext': 'mp4',\n            'title': 'The hidden power of siblings: Jeff Kluger at TEDxAsheville',\n            'description': 'md5:3d7a4f50d95ca5dd67104e2a20f43fe1',\n            'uploader': 'TEDx Talks',\n            'uploader_id': 'TEDxTalks',\n            'upload_date': '20111216',\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }]\n\n    _NATIVE_FORMATS = {\n        'low': {'width': 320, 'height': 180},\n        'medium': {'width': 512, 'height': 288},\n        'high': {'width': 854, 'height': 480},\n    }\n\n    def _extract_info(self, webpage):\n        info_json = self._search_regex(\n            r'(?s)q\\(\\s*\"\\w+.init\"\\s*,\\s*({.+})\\)\\s*</script>',\n            webpage, 'info json')\n        return json.loads(info_json)\n\n    def _real_extract(self, url):\n        m = re.match(self._VALID_URL, url, re.VERBOSE)\n        if m.group('type').startswith('embed'):\n            desktop_url = m.group('proto') + 'www' + m.group('urlmain')\n            return self.url_result(desktop_url, 'TED')\n        name = m.group('name')\n        if m.group('type_talk'):\n            return self._talk_info(url, name)\n        elif m.group('type_watch'):\n            return self._watch_info(url, name)\n        else:\n            return self._playlist_videos_info(url, name)\n\n    def _playlist_videos_info(self, url, name):\n        '''Returns the videos of the playlist'''\n\n        webpage = self._download_webpage(url, name,\n                                         'Downloading playlist webpage')\n        info = self._extract_info(webpage)\n\n        playlist_info = try_get(\n            info, lambda x: x['__INITIAL_DATA__']['playlist'],\n            dict) or info['playlist']\n\n        playlist_entries = [\n            self.url_result('http://www.ted.com/talks/' + talk['slug'], self.ie_key())\n            for talk in try_get(\n                info, lambda x: x['__INITIAL_DATA__']['talks'],\n                dict) or info['talks']\n        ]\n        return self.playlist_result(\n            playlist_entries,\n            playlist_id=compat_str(playlist_info['id']),\n            playlist_title=playlist_info['title'])\n\n    def _talk_info(self, url, video_name):\n        webpage = self._download_webpage(url, video_name)\n\n        info = self._extract_info(webpage)\n\n        talk_info = try_get(\n            info, lambda x: x['__INITIAL_DATA__']['talks'][0],\n            dict) or info['talks'][0]\n\n        title = talk_info['title'].strip()\n\n        external = talk_info.get('external')\n        if external:\n            service = external['service']\n            self.to_screen('Found video from %s' % service)\n            ext_url = None\n            if service.lower() == 'youtube':\n                ext_url = external.get('code')\n            return {\n                '_type': 'url',\n                'url': ext_url or external['uri'],\n            }\n\n        native_downloads = try_get(\n            talk_info, lambda x: x['downloads']['nativeDownloads'],\n            dict) or talk_info['nativeDownloads']\n\n        formats = [{\n            'url': format_url,\n            'format_id': format_id,\n            'format': format_id,\n        } for (format_id, format_url) in native_downloads.items() if format_url is not None]\n        if formats:\n            for f in formats:\n                finfo = self._NATIVE_FORMATS.get(f['format_id'])\n                if finfo:\n                    f.update(finfo)\n\n        player_talk = talk_info['player_talks'][0]\n\n        resources_ = player_talk.get('resources') or talk_info.get('resources')\n\n        http_url = None\n        for format_id, resources in resources_.items():\n            if format_id == 'h264':\n                for resource in resources:\n                    h264_url = resource.get('file')\n                    if not h264_url:\n                        continue\n                    bitrate = int_or_none(resource.get('bitrate'))\n                    formats.append({\n                        'url': h264_url,\n                        'format_id': '%s-%sk' % (format_id, bitrate),\n                        'tbr': bitrate,\n                    })\n                    if re.search(r'\\d+k', h264_url):\n                        http_url = h264_url\n            elif format_id == 'rtmp':\n                streamer = talk_info.get('streamer')\n                if not streamer:\n                    continue\n                for resource in resources:\n                    formats.append({\n                        'format_id': '%s-%s' % (format_id, resource.get('name')),\n                        'url': streamer,\n                        'play_path': resource['file'],\n                        'ext': 'flv',\n                        'width': int_or_none(resource.get('width')),\n                        'height': int_or_none(resource.get('height')),\n                        'tbr': int_or_none(resource.get('bitrate')),\n                    })\n            elif format_id == 'hls':\n                formats.extend(self._extract_m3u8_formats(\n                    resources.get('stream'), video_name, 'mp4', m3u8_id=format_id, fatal=False))\n\n        m3u8_formats = list(filter(\n            lambda f: f.get('protocol') == 'm3u8' and f.get('vcodec') != 'none',\n            formats))\n        if http_url:\n            for m3u8_format in m3u8_formats:\n                bitrate = self._search_regex(r'(\\d+k)', m3u8_format['url'], 'bitrate', default=None)\n                if not bitrate:\n                    continue\n                f = m3u8_format.copy()\n                f.update({\n                    'url': re.sub(r'\\d+k', bitrate, http_url),\n                    'format_id': m3u8_format['format_id'].replace('hls', 'http'),\n                    'protocol': 'http',\n                })\n                formats.append(f)\n\n        audio_download = talk_info.get('audioDownload')\n        if audio_download:\n            formats.append({\n                'url': audio_download,\n                'format_id': 'audio',\n                'vcodec': 'none',\n            })\n\n        self._sort_formats(formats)\n\n        video_id = compat_str(talk_info['id'])\n\n        return {\n            'id': video_id,\n            'title': title,\n            'uploader': player_talk.get('speaker') or talk_info.get('speaker'),\n            'thumbnail': player_talk.get('thumb') or talk_info.get('thumb'),\n            'description': self._og_search_description(webpage),\n            'subtitles': self._get_subtitles(video_id, talk_info),\n            'formats': formats,\n            'duration': talk_info.get('duration'),\n        }\n\n    def _get_subtitles(self, video_id, talk_info):\n        sub_lang_list = {}\n        for language in try_get(\n                talk_info,\n                (lambda x: x['downloads']['languages'],\n                 lambda x: x['languages']), list):\n            lang_code = language.get('languageCode') or language.get('ianaCode')\n            if not lang_code:\n                continue\n            sub_lang_list[lang_code] = [\n                {\n                    'url': 'http://www.ted.com/talks/subtitles/id/%s/lang/%s/format/%s' % (video_id, lang_code, ext),\n                    'ext': ext,\n                }\n                for ext in ['ted', 'srt']\n            ]\n        return sub_lang_list\n\n    def _watch_info(self, url, name):\n        webpage = self._download_webpage(url, name)\n\n        config_json = self._html_search_regex(\n            r'\"pages\\.jwplayer\"\\s*,\\s*({.+?})\\s*\\)\\s*</script>',\n            webpage, 'config', default=None)\n        if not config_json:\n            embed_url = self._search_regex(\n                r\"<iframe[^>]+class='pages-video-embed__video__object'[^>]+src='([^']+)'\", webpage, 'embed url')\n            return self.url_result(self._proto_relative_url(embed_url))\n        config = json.loads(config_json)['config']\n        video_url = config['video']['url']\n        thumbnail = config.get('image', {}).get('url')\n\n        title = self._html_search_regex(\n            r\"(?s)<h1(?:\\s+class='[^']+')?>(.+?)</h1>\", webpage, 'title')\n        description = self._html_search_regex(\n            [\n                r'(?s)<h4 class=\"[^\"]+\" id=\"h3--about-this-talk\">.*?</h4>(.*?)</div>',\n                r'(?s)<p><strong>About this talk:</strong>\\s+(.*?)</p>',\n            ],\n            webpage, 'description', fatal=False)\n\n        return {\n            'id': name,\n            'url': video_url,\n            'title': title,\n            'thumbnail': thumbnail,\n            'description': description,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "ted.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/ted.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}