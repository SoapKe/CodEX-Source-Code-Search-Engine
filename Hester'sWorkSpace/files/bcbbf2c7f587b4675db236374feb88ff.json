{"author": "rg3", "code": "from __future__ import unicode_literals\n\nfrom .fragment import FragmentFD\nfrom ..compat import compat_urllib_error\nfrom ..utils import urljoin\n\n\nclass DashSegmentsFD(FragmentFD):\n    \n\n    FD_NAME = 'dashsegments'\n\n    def real_download(self, filename, info_dict):\n        fragment_base_url = info_dict.get('fragment_base_url')\n        fragments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(fragments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        frag_index = 0\n        for i, fragment in enumerate(fragments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            \n            \n            fatal = i == 0 or not skip_unavailable_fragments\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    fragment_url = fragment.get('url')\n                    if not fragment_url:\n                        assert fragment_base_url\n                        fragment_url = urljoin(fragment_base_url, fragment['path'])\n                    success, frag_content = self._download_fragment(ctx, fragment_url, info_dict)\n                    if not success:\n                        return False\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    \n                    \n                    \n                    \n                    \n                    \n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if not fatal:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n", "comments": "\n    Download segments in a DASH manifest\n    \n \n# In DASH, the first segment contains necessary headers to\n# generate a valid MP4 file, so always abort for the first segment\n# YouTube may often return 404 HTTP error for a fragment causing the\n# whole download to fail. However if the same fragment is immediately\n# retried with the same request data this usually succeeds (1-2 attemps\n# is usually enough) thus allowing to download the whole file successfully.\n# To be future-proof we will retry all fragments that fail with any\n# HTTP error.\n", "content": "from __future__ import unicode_literals\n\nfrom .fragment import FragmentFD\nfrom ..compat import compat_urllib_error\nfrom ..utils import urljoin\n\n\nclass DashSegmentsFD(FragmentFD):\n    \"\"\"\n    Download segments in a DASH manifest\n    \"\"\"\n\n    FD_NAME = 'dashsegments'\n\n    def real_download(self, filename, info_dict):\n        fragment_base_url = info_dict.get('fragment_base_url')\n        fragments = info_dict['fragments'][:1] if self.params.get(\n            'test', False) else info_dict['fragments']\n\n        ctx = {\n            'filename': filename,\n            'total_frags': len(fragments),\n        }\n\n        self._prepare_and_start_frag_download(ctx)\n\n        fragment_retries = self.params.get('fragment_retries', 0)\n        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n\n        frag_index = 0\n        for i, fragment in enumerate(fragments):\n            frag_index += 1\n            if frag_index <= ctx['fragment_index']:\n                continue\n            # In DASH, the first segment contains necessary headers to\n            # generate a valid MP4 file, so always abort for the first segment\n            fatal = i == 0 or not skip_unavailable_fragments\n            count = 0\n            while count <= fragment_retries:\n                try:\n                    fragment_url = fragment.get('url')\n                    if not fragment_url:\n                        assert fragment_base_url\n                        fragment_url = urljoin(fragment_base_url, fragment['path'])\n                    success, frag_content = self._download_fragment(ctx, fragment_url, info_dict)\n                    if not success:\n                        return False\n                    self._append_fragment(ctx, frag_content)\n                    break\n                except compat_urllib_error.HTTPError as err:\n                    # YouTube may often return 404 HTTP error for a fragment causing the\n                    # whole download to fail. However if the same fragment is immediately\n                    # retried with the same request data this usually succeeds (1-2 attemps\n                    # is usually enough) thus allowing to download the whole file successfully.\n                    # To be future-proof we will retry all fragments that fail with any\n                    # HTTP error.\n                    count += 1\n                    if count <= fragment_retries:\n                        self.report_retry_fragment(err, frag_index, count, fragment_retries)\n            if count > fragment_retries:\n                if not fatal:\n                    self.report_skip_fragment(frag_index)\n                    continue\n                self.report_error('giving up after %s fragment retries' % fragment_retries)\n                return False\n\n        self._finish_frag_download(ctx)\n\n        return True\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "dash.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/downloader/dash.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}