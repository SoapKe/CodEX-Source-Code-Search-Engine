{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport json\nimport os\n\nfrom .common import InfoExtractor\nfrom ..aes import aes_cbc_decrypt\nfrom ..compat import (\n    compat_b64decode,\n    compat_ord,\n)\nfrom ..utils import (\n    bytes_to_intlist,\n    ExtractorError,\n    float_or_none,\n    intlist_to_bytes,\n    srt_subtitles_timecode,\n    strip_or_none,\n    urljoin,\n)\n\n\nclass ADNIE(InfoExtractor):\n    IE_DESC = 'Anime Digital Network'\n    _VALID_URL = r'https?://(?:www\\.)?animedigitalnetwork\\.fr/video/[^/]+/(?P<id>\\d+)'\n    _TEST = {\n        'url': 'http://animedigitalnetwork.fr/video/blue-exorcist-kyoto-saga/7778-episode-1-debut-des-hostilites',\n        'md5': 'e497370d847fd79d9d4c74be55575c7a',\n        'info_dict': {\n            'id': '7778',\n            'ext': 'mp4',\n            'title': 'Blue Exorcist - Ky\u00f4to Saga - \u00c9pisode 1',\n            'description': 'md5:2f7b5aa76edbc1a7a92cedcda8a528d5',\n        }\n    }\n    _BASE_URL = 'http://animedigitalnetwork.fr'\n\n    def _get_subtitles(self, sub_path, video_id):\n        if not sub_path:\n            return None\n\n        enc_subtitles = self._download_webpage(\n            urljoin(self._BASE_URL, sub_path),\n            video_id, fatal=False, headers={\n                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:53.0) Gecko/20100101 Firefox/53.0',\n            })\n        if not enc_subtitles:\n            return None\n\n        \n        dec_subtitles = intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode(enc_subtitles[24:])),\n            bytes_to_intlist(b'\\xc8\\x6e\\x06\\xbc\\xbe\\xc6\\x49\\xf5\\x88\\x0d\\xc8\\x47\\xc4\\x27\\x0c\\x60'),\n            bytes_to_intlist(compat_b64decode(enc_subtitles[:24]))\n        ))\n        subtitles_json = self._parse_json(\n            dec_subtitles[:-compat_ord(dec_subtitles[-1])].decode(),\n            None, fatal=False)\n        if not subtitles_json:\n            return None\n\n        subtitles = {}\n        for sub_lang, sub in subtitles_json.items():\n            srt = ''\n            for num, current in enumerate(sub):\n                start, end, text = (\n                    float_or_none(current.get('startTime')),\n                    float_or_none(current.get('endTime')),\n                    current.get('text'))\n                if start is None or end is None or text is None:\n                    continue\n                srt += os.linesep.join(\n                    (\n                        '%d' % num,\n                        '%s --> %s' % (\n                            srt_subtitles_timecode(start),\n                            srt_subtitles_timecode(end)),\n                        text,\n                        os.linesep,\n                    ))\n\n            if sub_lang == 'vostf':\n                sub_lang = 'fr'\n            subtitles.setdefault(sub_lang, []).extend([{\n                'ext': 'json',\n                'data': json.dumps(sub),\n            }, {\n                'ext': 'srt',\n                'data': srt,\n            }])\n        return subtitles\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        webpage = self._download_webpage(url, video_id)\n        player_config = self._parse_json(self._search_regex(\n            r'playerConfig\\s*=\\s*({.+});', webpage, 'player config'), video_id)\n\n        video_info = {}\n        video_info_str = self._search_regex(\n            r'videoInfo\\s*=\\s*({.+});', webpage,\n            'video info', fatal=False)\n        if video_info_str:\n            video_info = self._parse_json(\n                video_info_str, video_id, fatal=False) or {}\n\n        options = player_config.get('options') or {}\n        metas = options.get('metas') or {}\n        links = player_config.get('links') or {}\n        sub_path = player_config.get('subtitles')\n        error = None\n        if not links:\n            links_url = player_config.get('linksurl') or options['videoUrl']\n            links_data = self._download_json(urljoin(\n                self._BASE_URL, links_url), video_id)\n            links = links_data.get('links') or {}\n            metas = metas or links_data.get('meta') or {}\n            sub_path = sub_path or links_data.get('subtitles')\n            error = links_data.get('error')\n        title = metas.get('title') or video_info['title']\n\n        formats = []\n        for format_id, qualities in links.items():\n            if not isinstance(qualities, dict):\n                continue\n            for load_balancer_url in qualities.values():\n                load_balancer_data = self._download_json(\n                    load_balancer_url, video_id, fatal=False) or {}\n                m3u8_url = load_balancer_data.get('location')\n                if not m3u8_url:\n                    continue\n                m3u8_formats = self._extract_m3u8_formats(\n                    m3u8_url, video_id, 'mp4', 'm3u8_native',\n                    m3u8_id=format_id, fatal=False)\n                if format_id == 'vf':\n                    for f in m3u8_formats:\n                        f['language'] = 'fr'\n                formats.extend(m3u8_formats)\n        if not error:\n            error = options.get('error')\n        if not formats and error:\n            raise ExtractorError('%s said: %s' % (self.IE_NAME, error), expected=True)\n        self._sort_formats(formats)\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': strip_or_none(metas.get('summary') or video_info.get('resume')),\n            'thumbnail': video_info.get('image'),\n            'formats': formats,\n            'subtitles': self.extract_subtitles(sub_path, video_id),\n            'episode': metas.get('subtitle') or video_info.get('videoTitle'),\n            'series': video_info.get('playlistTitle'),\n        }\n", "comments": "# coding: utf-8\n# http://animedigitalnetwork.fr/components/com_vodvideo/videojs/adn-vjs.min.js\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport json\nimport os\n\nfrom .common import InfoExtractor\nfrom ..aes import aes_cbc_decrypt\nfrom ..compat import (\n    compat_b64decode,\n    compat_ord,\n)\nfrom ..utils import (\n    bytes_to_intlist,\n    ExtractorError,\n    float_or_none,\n    intlist_to_bytes,\n    srt_subtitles_timecode,\n    strip_or_none,\n    urljoin,\n)\n\n\nclass ADNIE(InfoExtractor):\n    IE_DESC = 'Anime Digital Network'\n    _VALID_URL = r'https?://(?:www\\.)?animedigitalnetwork\\.fr/video/[^/]+/(?P<id>\\d+)'\n    _TEST = {\n        'url': 'http://animedigitalnetwork.fr/video/blue-exorcist-kyoto-saga/7778-episode-1-debut-des-hostilites',\n        'md5': 'e497370d847fd79d9d4c74be55575c7a',\n        'info_dict': {\n            'id': '7778',\n            'ext': 'mp4',\n            'title': 'Blue Exorcist - Ky\u00f4to Saga - \u00c9pisode 1',\n            'description': 'md5:2f7b5aa76edbc1a7a92cedcda8a528d5',\n        }\n    }\n    _BASE_URL = 'http://animedigitalnetwork.fr'\n\n    def _get_subtitles(self, sub_path, video_id):\n        if not sub_path:\n            return None\n\n        enc_subtitles = self._download_webpage(\n            urljoin(self._BASE_URL, sub_path),\n            video_id, fatal=False, headers={\n                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:53.0) Gecko/20100101 Firefox/53.0',\n            })\n        if not enc_subtitles:\n            return None\n\n        # http://animedigitalnetwork.fr/components/com_vodvideo/videojs/adn-vjs.min.js\n        dec_subtitles = intlist_to_bytes(aes_cbc_decrypt(\n            bytes_to_intlist(compat_b64decode(enc_subtitles[24:])),\n            bytes_to_intlist(b'\\xc8\\x6e\\x06\\xbc\\xbe\\xc6\\x49\\xf5\\x88\\x0d\\xc8\\x47\\xc4\\x27\\x0c\\x60'),\n            bytes_to_intlist(compat_b64decode(enc_subtitles[:24]))\n        ))\n        subtitles_json = self._parse_json(\n            dec_subtitles[:-compat_ord(dec_subtitles[-1])].decode(),\n            None, fatal=False)\n        if not subtitles_json:\n            return None\n\n        subtitles = {}\n        for sub_lang, sub in subtitles_json.items():\n            srt = ''\n            for num, current in enumerate(sub):\n                start, end, text = (\n                    float_or_none(current.get('startTime')),\n                    float_or_none(current.get('endTime')),\n                    current.get('text'))\n                if start is None or end is None or text is None:\n                    continue\n                srt += os.linesep.join(\n                    (\n                        '%d' % num,\n                        '%s --> %s' % (\n                            srt_subtitles_timecode(start),\n                            srt_subtitles_timecode(end)),\n                        text,\n                        os.linesep,\n                    ))\n\n            if sub_lang == 'vostf':\n                sub_lang = 'fr'\n            subtitles.setdefault(sub_lang, []).extend([{\n                'ext': 'json',\n                'data': json.dumps(sub),\n            }, {\n                'ext': 'srt',\n                'data': srt,\n            }])\n        return subtitles\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        webpage = self._download_webpage(url, video_id)\n        player_config = self._parse_json(self._search_regex(\n            r'playerConfig\\s*=\\s*({.+});', webpage, 'player config'), video_id)\n\n        video_info = {}\n        video_info_str = self._search_regex(\n            r'videoInfo\\s*=\\s*({.+});', webpage,\n            'video info', fatal=False)\n        if video_info_str:\n            video_info = self._parse_json(\n                video_info_str, video_id, fatal=False) or {}\n\n        options = player_config.get('options') or {}\n        metas = options.get('metas') or {}\n        links = player_config.get('links') or {}\n        sub_path = player_config.get('subtitles')\n        error = None\n        if not links:\n            links_url = player_config.get('linksurl') or options['videoUrl']\n            links_data = self._download_json(urljoin(\n                self._BASE_URL, links_url), video_id)\n            links = links_data.get('links') or {}\n            metas = metas or links_data.get('meta') or {}\n            sub_path = sub_path or links_data.get('subtitles')\n            error = links_data.get('error')\n        title = metas.get('title') or video_info['title']\n\n        formats = []\n        for format_id, qualities in links.items():\n            if not isinstance(qualities, dict):\n                continue\n            for load_balancer_url in qualities.values():\n                load_balancer_data = self._download_json(\n                    load_balancer_url, video_id, fatal=False) or {}\n                m3u8_url = load_balancer_data.get('location')\n                if not m3u8_url:\n                    continue\n                m3u8_formats = self._extract_m3u8_formats(\n                    m3u8_url, video_id, 'mp4', 'm3u8_native',\n                    m3u8_id=format_id, fatal=False)\n                if format_id == 'vf':\n                    for f in m3u8_formats:\n                        f['language'] = 'fr'\n                formats.extend(m3u8_formats)\n        if not error:\n            error = options.get('error')\n        if not formats and error:\n            raise ExtractorError('%s said: %s' % (self.IE_NAME, error), expected=True)\n        self._sort_formats(formats)\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': strip_or_none(metas.get('summary') or video_info.get('resume')),\n            'thumbnail': video_info.get('image'),\n            'formats': formats,\n            'subtitles': self.extract_subtitles(sub_path, video_id),\n            'episode': metas.get('subtitle') or video_info.get('videoTitle'),\n            'series': video_info.get('playlistTitle'),\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "adn.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/adn.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}