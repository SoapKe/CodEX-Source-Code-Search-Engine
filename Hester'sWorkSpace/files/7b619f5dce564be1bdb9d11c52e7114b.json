{"author": "django", "code": "import warnings\n\nfrom django.test import SimpleTestCase\nfrom django.utils.deprecation import (\n    DeprecationInstanceCheck, RemovedInNextVersionWarning, RenameMethodsBase,\n)\n\n\nclass RenameManagerMethods(RenameMethodsBase):\n    renamed_methods = (\n        ('old', 'new', DeprecationWarning),\n    )\n\n\nclass RenameMethodsTests(SimpleTestCase):\n    \"\"\"\n    Tests the `RenameMethodsBase` type introduced to rename `get_query_set`\n    to `get_queryset` across the code base following \n    \"\"\"\n\n    def test_class_definition_warnings(self):\n        \"\"\"\n        Ensure a warning is raised upon class definition to suggest renaming\n        the faulty method.\n        \"\"\"\n        with warnings.catch_warnings(record=True) as recorded:\n            warnings.simplefilter('always')\n\n            class Manager(metaclass=RenameManagerMethods):\n                def old(self):\n                    pass\n            self.assertEqual(len(recorded), 1)\n            msg = str(recorded[0].message)\n            self.assertEqual(msg, '`Manager.old` method should be renamed `new`.')\n\n    def test_get_new_defined(self):\n        \"\"\"\n        Ensure `old` complains and not `new` when only `new` is defined.\n        \"\"\"\n        with warnings.catch_warnings(record=True) as recorded:\n            warnings.simplefilter('ignore')\n\n            class Manager(metaclass=RenameManagerMethods):\n                def new(self):\n                    pass\n            warnings.simplefilter('always')\n            manager = Manager()\n            manager.new()\n            self.assertEqual(len(recorded), 0)\n            manager.old()\n            self.assertEqual(len(recorded), 1)\n            msg = str(recorded.pop().message)\n            self.assertEqual(msg, '`Manager.old` is deprecated, use `new` instead.')\n\n    def test_get_old_defined(self):\n        \"\"\"\n        Ensure `old` complains when only `old` is defined.\n        \"\"\"\n        with warnings.catch_warnings(record=True) as recorded:\n            warnings.simplefilter('ignore')\n\n            class Manager(metaclass=RenameManagerMethods):\n                def old(self):\n                    pass\n            warnings.simplefilter('always')\n            manager = Manager()\n            manager.new()\n            self.assertEqual(len(recorded), 0)\n            manager.old()\n            self.assertEqual(len(recorded), 1)\n            msg = str(recorded.pop().message)\n            self.assertEqual(msg, '`Manager.old` is deprecated, use `new` instead.')\n\n    def test_deprecated_subclass_renamed(self):\n        \"\"\"\n        Ensure the correct warnings are raised when a class that didn't rename\n        `old` subclass one that did.\n        \"\"\"\n        with warnings.catch_warnings(record=True) as recorded:\n            warnings.simplefilter('ignore')\n\n            class Renamed(metaclass=RenameManagerMethods):\n                def new(self):\n                    pass\n\n            class Deprecated(Renamed):\n                def old(self):\n                    super().old()\n            warnings.simplefilter('always')\n            deprecated = Deprecated()\n            deprecated.new()\n            self.assertEqual(len(recorded), 1)\n            msg = str(recorded.pop().message)\n            self.assertEqual(msg, '`Renamed.old` is deprecated, use `new` instead.')\n            recorded[:] = []\n            deprecated.old()\n            self.assertEqual(len(recorded), 2)\n            msgs = [str(warning.message) for warning in recorded]\n            self.assertEqual(msgs, [\n                '`Deprecated.old` is deprecated, use `new` instead.',\n                '`Renamed.old` is deprecated, use `new` instead.',\n            ])\n\n    def test_renamed_subclass_deprecated(self):\n        \"\"\"\n        Ensure the correct warnings are raised when a class that renamed\n        `old` subclass one that didn't.\n        \"\"\"\n        with warnings.catch_warnings(record=True) as recorded:\n            warnings.simplefilter('ignore')\n\n            class Deprecated(metaclass=RenameManagerMethods):\n                def old(self):\n                    pass\n\n            class Renamed(Deprecated):\n                def new(self):\n                    super().new()\n            warnings.simplefilter('always')\n            renamed = Renamed()\n            renamed.new()\n            self.assertEqual(len(recorded), 0)\n            renamed.old()\n            self.assertEqual(len(recorded), 1)\n            msg = str(recorded.pop().message)\n            self.assertEqual(msg, '`Renamed.old` is deprecated, use `new` instead.')\n\n    def test_deprecated_subclass_renamed_and_mixins(self):\n        \"\"\"\n        Ensure the correct warnings are raised when a subclass inherit from a\n        class that renamed `old` and mixins that may or may not have renamed\n        `new`.\n        \"\"\"\n        with warnings.catch_warnings(record=True) as recorded:\n            warnings.simplefilter('ignore')\n\n            class Renamed(metaclass=RenameManagerMethods):\n                def new(self):\n                    pass\n\n            class RenamedMixin:\n                def new(self):\n                    super().new()\n\n            class DeprecatedMixin:\n                def old(self):\n                    super().old()\n\n            class Deprecated(DeprecatedMixin, RenamedMixin, Renamed):\n                pass\n            warnings.simplefilter('always')\n            deprecated = Deprecated()\n            deprecated.new()\n            self.assertEqual(len(recorded), 1)\n            msg = str(recorded.pop().message)\n            self.assertEqual(msg, '`RenamedMixin.old` is deprecated, use `new` instead.')\n            deprecated.old()\n            self.assertEqual(len(recorded), 2)\n            msgs = [str(warning.message) for warning in recorded]\n            self.assertEqual(msgs, [\n                '`DeprecatedMixin.old` is deprecated, use `new` instead.',\n                '`RenamedMixin.old` is deprecated, use `new` instead.',\n            ])\n\n\nclass DeprecationInstanceCheckTest(SimpleTestCase):\n    def test_warning(self):\n        class Manager(metaclass=DeprecationInstanceCheck):\n            alternative = 'fake.path.Foo'\n            deprecation_warning = RemovedInNextVersionWarning\n\n        msg = '`Manager` is deprecated, use `fake.path.Foo` instead.'\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', category=RemovedInNextVersionWarning)\n            with self.assertRaisesMessage(RemovedInNextVersionWarning, msg):\n                isinstance(object, Manager)\n", "comments": "        tests  renamemethodsbase  type introduced rename  get query set       get queryset  across code base following  15363               def test class definition warnings(self)                      ensure warning raised upon class definition suggest renaming         faulty method                      warnings catch warnings(record true) recorded              warnings simplefilter( always )              class manager(metaclass renamemanagermethods)                  def old(self)                      pass             self assertequal(len(recorded)  1)             msg   str(recorded 0  message)             self assertequal(msg    manager old  method renamed  new   )      def test get new defined(self)                      ensure  old  complains  new   new  defined                      warnings catch warnings(record true) recorded              warnings simplefilter( ignore )              class manager(metaclass renamemanagermethods)                  def new(self)                      pass             warnings simplefilter( always )             manager   manager()             manager new()             self assertequal(len(recorded)  0)             manager old()             self assertequal(len(recorded)  1)             msg   str(recorded pop() message)             self assertequal(msg    manager old  deprecated  use  new  instead  )      def test get old defined(self)                      ensure  old  complains  old  defined                      warnings catch warnings(record true) recorded              warnings simplefilter( ignore )              class manager(metaclass renamemanagermethods)                  def old(self)                      pass             warnings simplefilter( always )             manager   manager()             manager new()             self assertequal(len(recorded)  0)             manager old()             self assertequal(len(recorded)  1)             msg   str(recorded pop() message)             self assertequal(msg    manager old  deprecated  use  new  instead  )      def test deprecated subclass renamed(self)                      ensure correct warnings raised class rename          old  subclass one                      warnings catch warnings(record true) recorded              warnings simplefilter( ignore )              class renamed(metaclass renamemanagermethods)                  def new(self)                      pass              class deprecated(renamed)                  def old(self)                      super() old()             warnings simplefilter( always )             deprecated   deprecated()             deprecated new()             self assertequal(len(recorded)  1)             msg   str(recorded pop() message)             self assertequal(msg    renamed old  deprecated  use  new  instead  )             recorded                     deprecated old()             self assertequal(len(recorded)  2)             msgs    str(warning message) warning recorded              self assertequal(msgs                      deprecated old  deprecated  use  new  instead                      renamed old  deprecated  use  new  instead                 )      def test renamed subclass deprecated(self)                      ensure correct warnings raised class renamed          old  subclass one                      warnings catch warnings(record true) recorded              warnings simplefilter( ignore )              class deprecated(metaclass renamemanagermethods)                  def old(self)                      pass              class renamed(deprecated)                  def new(self)                      super() new()             warnings simplefilter( always )             renamed   renamed()             renamed new()             self assertequal(len(recorded)  0)             renamed old()             self assertequal(len(recorded)  1)             msg   str(recorded pop() message)             self assertequal(msg    renamed old  deprecated  use  new  instead  )      def test deprecated subclass renamed mixins(self)                      ensure correct warnings raised subclass inherit         class renamed  old  mixins may may renamed          new                 15363  ", "content": "import warnings\n\nfrom django.test import SimpleTestCase\nfrom django.utils.deprecation import (\n    DeprecationInstanceCheck, RemovedInNextVersionWarning, RenameMethodsBase,\n)\n\n\nclass RenameManagerMethods(RenameMethodsBase):\n    renamed_methods = (\n        ('old', 'new', DeprecationWarning),\n    )\n\n\nclass RenameMethodsTests(SimpleTestCase):\n    \"\"\"\n    Tests the `RenameMethodsBase` type introduced to rename `get_query_set`\n    to `get_queryset` across the code base following #15363.\n    \"\"\"\n\n    def test_class_definition_warnings(self):\n        \"\"\"\n        Ensure a warning is raised upon class definition to suggest renaming\n        the faulty method.\n        \"\"\"\n        with warnings.catch_warnings(record=True) as recorded:\n            warnings.simplefilter('always')\n\n            class Manager(metaclass=RenameManagerMethods):\n                def old(self):\n                    pass\n            self.assertEqual(len(recorded), 1)\n            msg = str(recorded[0].message)\n            self.assertEqual(msg, '`Manager.old` method should be renamed `new`.')\n\n    def test_get_new_defined(self):\n        \"\"\"\n        Ensure `old` complains and not `new` when only `new` is defined.\n        \"\"\"\n        with warnings.catch_warnings(record=True) as recorded:\n            warnings.simplefilter('ignore')\n\n            class Manager(metaclass=RenameManagerMethods):\n                def new(self):\n                    pass\n            warnings.simplefilter('always')\n            manager = Manager()\n            manager.new()\n            self.assertEqual(len(recorded), 0)\n            manager.old()\n            self.assertEqual(len(recorded), 1)\n            msg = str(recorded.pop().message)\n            self.assertEqual(msg, '`Manager.old` is deprecated, use `new` instead.')\n\n    def test_get_old_defined(self):\n        \"\"\"\n        Ensure `old` complains when only `old` is defined.\n        \"\"\"\n        with warnings.catch_warnings(record=True) as recorded:\n            warnings.simplefilter('ignore')\n\n            class Manager(metaclass=RenameManagerMethods):\n                def old(self):\n                    pass\n            warnings.simplefilter('always')\n            manager = Manager()\n            manager.new()\n            self.assertEqual(len(recorded), 0)\n            manager.old()\n            self.assertEqual(len(recorded), 1)\n            msg = str(recorded.pop().message)\n            self.assertEqual(msg, '`Manager.old` is deprecated, use `new` instead.')\n\n    def test_deprecated_subclass_renamed(self):\n        \"\"\"\n        Ensure the correct warnings are raised when a class that didn't rename\n        `old` subclass one that did.\n        \"\"\"\n        with warnings.catch_warnings(record=True) as recorded:\n            warnings.simplefilter('ignore')\n\n            class Renamed(metaclass=RenameManagerMethods):\n                def new(self):\n                    pass\n\n            class Deprecated(Renamed):\n                def old(self):\n                    super().old()\n            warnings.simplefilter('always')\n            deprecated = Deprecated()\n            deprecated.new()\n            self.assertEqual(len(recorded), 1)\n            msg = str(recorded.pop().message)\n            self.assertEqual(msg, '`Renamed.old` is deprecated, use `new` instead.')\n            recorded[:] = []\n            deprecated.old()\n            self.assertEqual(len(recorded), 2)\n            msgs = [str(warning.message) for warning in recorded]\n            self.assertEqual(msgs, [\n                '`Deprecated.old` is deprecated, use `new` instead.',\n                '`Renamed.old` is deprecated, use `new` instead.',\n            ])\n\n    def test_renamed_subclass_deprecated(self):\n        \"\"\"\n        Ensure the correct warnings are raised when a class that renamed\n        `old` subclass one that didn't.\n        \"\"\"\n        with warnings.catch_warnings(record=True) as recorded:\n            warnings.simplefilter('ignore')\n\n            class Deprecated(metaclass=RenameManagerMethods):\n                def old(self):\n                    pass\n\n            class Renamed(Deprecated):\n                def new(self):\n                    super().new()\n            warnings.simplefilter('always')\n            renamed = Renamed()\n            renamed.new()\n            self.assertEqual(len(recorded), 0)\n            renamed.old()\n            self.assertEqual(len(recorded), 1)\n            msg = str(recorded.pop().message)\n            self.assertEqual(msg, '`Renamed.old` is deprecated, use `new` instead.')\n\n    def test_deprecated_subclass_renamed_and_mixins(self):\n        \"\"\"\n        Ensure the correct warnings are raised when a subclass inherit from a\n        class that renamed `old` and mixins that may or may not have renamed\n        `new`.\n        \"\"\"\n        with warnings.catch_warnings(record=True) as recorded:\n            warnings.simplefilter('ignore')\n\n            class Renamed(metaclass=RenameManagerMethods):\n                def new(self):\n                    pass\n\n            class RenamedMixin:\n                def new(self):\n                    super().new()\n\n            class DeprecatedMixin:\n                def old(self):\n                    super().old()\n\n            class Deprecated(DeprecatedMixin, RenamedMixin, Renamed):\n                pass\n            warnings.simplefilter('always')\n            deprecated = Deprecated()\n            deprecated.new()\n            self.assertEqual(len(recorded), 1)\n            msg = str(recorded.pop().message)\n            self.assertEqual(msg, '`RenamedMixin.old` is deprecated, use `new` instead.')\n            deprecated.old()\n            self.assertEqual(len(recorded), 2)\n            msgs = [str(warning.message) for warning in recorded]\n            self.assertEqual(msgs, [\n                '`DeprecatedMixin.old` is deprecated, use `new` instead.',\n                '`RenamedMixin.old` is deprecated, use `new` instead.',\n            ])\n\n\nclass DeprecationInstanceCheckTest(SimpleTestCase):\n    def test_warning(self):\n        class Manager(metaclass=DeprecationInstanceCheck):\n            alternative = 'fake.path.Foo'\n            deprecation_warning = RemovedInNextVersionWarning\n\n        msg = '`Manager` is deprecated, use `fake.path.Foo` instead.'\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', category=RemovedInNextVersionWarning)\n            with self.assertRaisesMessage(RemovedInNextVersionWarning, msg):\n                isinstance(object, Manager)\n", "description": "The Web framework for perfectionists with deadlines.", "file_name": "tests.py", "id": "7b619f5dce564be1bdb9d11c52e7114b", "language": "Python", "project_name": "django", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/django-django/django-django-acfc650/tests/deprecation/tests.py", "save_time": "", "source": "", "update_at": "2018-03-14T02:00:36Z", "url": "https://github.com/django/django", "wiki": false}