{"author": "odoo", "code": "\n\nimport json\nimport logging\n\nimport dateutil.parser\nimport pytz\nfrom werkzeug import urls\n\nfrom odoo import api, fields, models, _\nfrom odoo.addons.payment.models.payment_acquirer import ValidationError\nfrom odoo.addons.payment_paypal.controllers.main import PaypalController\nfrom odoo.tools.float_utils import float_compare\n\n\n_logger = logging.getLogger(__name__)\n\n\nclass AcquirerPaypal(models.Model):\n    _inherit = 'payment.acquirer'\n\n    provider = fields.Selection(selection_add=[('paypal', 'Paypal')])\n    paypal_email_account = fields.Char('Paypal Email ID', required_if_provider='paypal', groups='base.group_user')\n    paypal_seller_account = fields.Char(\n        'Paypal Merchant ID', groups='base.group_user',\n        help='The Merchant ID is used to ensure communications coming from Paypal are valid and secured.')\n    paypal_use_ipn = fields.Boolean('Use IPN', default=True, help='Paypal Instant Payment Notification', groups='base.group_user')\n    paypal_pdt_token = fields.Char(string='Paypal PDT Token', required_if_provider='paypal', help='Payment Data Transfer allows you to receive notification of successful payments as they are made.', groups='base.group_user')\n    \n    paypal_api_enabled = fields.Boolean('Use Rest API', default=False)\n    paypal_api_username = fields.Char('Rest API Username', groups='base.group_user')\n    paypal_api_password = fields.Char('Rest API Password', groups='base.group_user')\n    paypal_api_access_token = fields.Char('Access Token', groups='base.group_user')\n    paypal_api_access_token_validity = fields.Datetime('Access Token Validity', groups='base.group_user')\n    \n    fees_dom_fixed = fields.Float(default=0.35)\n    fees_dom_var = fields.Float(default=3.4)\n    fees_int_fixed = fields.Float(default=0.35)\n    fees_int_var = fields.Float(default=3.9)\n\n    def _get_feature_support(self):\n        \"\"\"Get advanced feature support by provider.\n\n        Each provider should add its technical in the corresponding\n        key for the following features:\n            * fees: support payment fees computations\n            * authorize: support authorizing payment (separates\n                         authorization and capture)\n            * tokenize: support saving payment data in a payment.tokenize\n                        object\n        \"\"\"\n        res = super(AcquirerPaypal, self)._get_feature_support()\n        res['fees'].append('paypal')\n        return res\n\n    @api.model\n    def _get_paypal_urls(self, environment):\n        \"\"\" Paypal URLS \"\"\"\n        if environment == 'prod':\n            return {\n                'paypal_form_url': 'https://www.paypal.com/cgi-bin/webscr',\n                'paypal_rest_url': 'https://api.paypal.com/v1/oauth2/token',\n            }\n        else:\n            return {\n                'paypal_form_url': 'https://www.sandbox.paypal.com/cgi-bin/webscr',\n                'paypal_rest_url': 'https://api.sandbox.paypal.com/v1/oauth2/token',\n            }\n\n    @api.multi\n    def paypal_compute_fees(self, amount, currency_id, country_id):\n        \"\"\" Compute paypal fees.\n\n            :param float amount: the amount to pay\n            :param integer country_id: an ID of a res.country, or None. This is\n                                       the customer's country, to be compared to\n                                       the acquirer company country.\n            :return float fees: computed fees\n        \"\"\"\n        if not self.fees_active:\n            return 0.0\n        country = self.env['res.country'].browse(country_id)\n        if country and self.company_id.country_id.id == country.id:\n            percentage = self.fees_dom_var\n            fixed = self.fees_dom_fixed\n        else:\n            percentage = self.fees_int_var\n            fixed = self.fees_int_fixed\n        fees = (percentage / 100.0 * amount + fixed) / (1 - percentage / 100.0)\n        return fees\n\n    @api.multi\n    def paypal_form_generate_values(self, values):\n        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')\n\n        paypal_tx_values = dict(values)\n        paypal_tx_values.update({\n            'cmd': '_xclick',\n            'business': self.paypal_email_account,\n            'item_name': '%s: %s' % (self.company_id.name, values['reference']),\n            'item_number': values['reference'],\n            'amount': values['amount'],\n            'currency_code': values['currency'] and values['currency'].name or '',\n            'address1': values.get('partner_address'),\n            'city': values.get('partner_city'),\n            'country': values.get('partner_country') and values.get('partner_country').code or '',\n            'state': values.get('partner_state') and (values.get('partner_state').code or values.get('partner_state').name) or '',\n            'email': values.get('partner_email'),\n            'zip_code': values.get('partner_zip'),\n            'first_name': values.get('partner_first_name'),\n            'last_name': values.get('partner_last_name'),\n            'paypal_return': urls.url_join(base_url, PaypalController._return_url),\n            'notify_url': urls.url_join(base_url, PaypalController._notify_url),\n            'cancel_return': urls.url_join(base_url, PaypalController._cancel_url),\n            'handling': '%.2f' % paypal_tx_values.pop('fees', 0.0) if self.fees_active else False,\n            'custom': json.dumps({'return_url': '%s' % paypal_tx_values.pop('return_url')}) if paypal_tx_values.get('return_url') else False,\n        })\n        return paypal_tx_values\n\n    @api.multi\n    def paypal_get_form_action_url(self):\n        return self._get_paypal_urls(self.environment)['paypal_form_url']\n\n\nclass TxPaypal(models.Model):\n    _inherit = 'payment.transaction'\n\n    paypal_txn_type = fields.Char('Transaction type')\n\n    \n    \n    \n\n    @api.model\n    def _paypal_form_get_tx_from_data(self, data):\n        reference, txn_id = data.get('item_number'), data.get('txn_id')\n        if not reference or not txn_id:\n            error_msg = _('Paypal: received data with missing reference (%s) or txn_id (%s)') % (reference, txn_id)\n            _logger.info(error_msg)\n            raise ValidationError(error_msg)\n\n        ?\n        txs = self.env['payment.transaction'].search([('reference', '=', reference)])\n        if not txs or len(txs) > 1:\n            error_msg = 'Paypal: received data for reference %s' % (reference)\n            if not txs:\n                error_msg += '; no order found'\n            else:\n                error_msg += '; multiple order found'\n            _logger.info(error_msg)\n            raise ValidationError(error_msg)\n        return txs[0]\n\n    @api.multi\n    def _paypal_form_get_invalid_parameters(self, data):\n        invalid_parameters = []\n        _logger.info('Received a notification from Paypal with IPN version %s', data.get('notify_version'))\n        if data.get('test_ipn'):\n            _logger.warning(\n                'Received a notification from Paypal using sandbox'\n            ),\n\n        \n        if self.acquirer_reference and data.get('txn_id') != self.acquirer_reference:\n            invalid_parameters.append(('txn_id', data.get('txn_id'), self.acquirer_reference))\n        \n        if float_compare(float(data.get('mc_gross', '0.0')), (self.amount + self.fees), 2) != 0:\n            invalid_parameters.append(('mc_gross', data.get('mc_gross'), '%.2f' % self.amount))  # mc_gross is amount + fees\n        if data.get('mc_currency') != self.currency_id.name:\n            invalid_parameters.append(('mc_currency', data.get('mc_currency'), self.currency_id.name))\n        if 'handling_amount' in data and float_compare(float(data.get('handling_amount')), self.fees, 2) != 0:\n            invalid_parameters.append(('handling_amount', data.get('handling_amount'), self.fees))\n        \n        if self.payment_token_id and data.get('payer_id') != self.payment_token_id.acquirer_ref:\n            invalid_parameters.append(('payer_id', data.get('payer_id'), self.payment_token_id.acquirer_ref))\n        \n        if data.get('receiver_id') and self.acquirer_id.paypal_seller_account and data['receiver_id'] != self.acquirer_id.paypal_seller_account:\n            invalid_parameters.append(('receiver_id', data.get('receiver_id'), self.acquirer_id.paypal_seller_account))\n        if not data.get('receiver_id') or not self.acquirer_id.paypal_seller_account:\n            \n            # In Paypal, this is possible to configure as receiver_email a different email than the business email (the login email)\n            \n            \n            \n            \n            if data.get('receiver_email') != self.acquirer_id.paypal_email_account:\n                invalid_parameters.append(('receiver_email', data.get('receiver_email'), self.acquirer_id.paypal_email_account))\n\n        return invalid_parameters\n\n    @api.multi\n    def _paypal_form_validate(self, data):\n        status = data.get('payment_status')\n        res = {\n            'acquirer_reference': data.get('txn_id'),\n            'paypal_txn_type': data.get('payment_type'),\n        }\n        if status in ['Completed', 'Processed']:\n            _logger.info('Validated Paypal payment for tx %s: set as done' % (self.reference))\n            try:\n                \n                tzinfos = {\n                    'PST': -8 * 3600,\n                    'PDT': -7 * 3600,\n                }\n                date_validate = dateutil.parser.parse(data.get('payment_date'), tzinfos=tzinfos).astimezone(pytz.utc)\n            except:\n                date_validate = fields.Datetime.now()\n            res.update(state='done', date_validate=date_validate)\n            return self.write(res)\n        elif status in ['Pending', 'Expired']:\n            _logger.info('Received notification for Paypal payment %s: set as pending' % (self.reference))\n            res.update(state='pending', state_message=data.get('pending_reason', ''))\n            return self.write(res)\n        else:\n            error = 'Received unrecognized status for Paypal payment %s: %s, set as error' % (self.reference, status)\n            _logger.info(error)\n            res.update(state='error', state_message=error)\n            return self.write(res)\n", "comments": "   get advanced feature support provider           each provider add technical corresponding         key following features                fees  support payment fees computations               authorize  support authorizing payment (separates                          authorization capture)               tokenize  support saving payment data payment tokenize                         object                     res   super(acquirerpaypal  self)  get feature support()         res  fees   append( paypal )         return res       api model     def  get paypal urls(self  environment)              paypal urls             environment     prod               return                    paypal form url    https   www paypal com cgi bin webscr                    paypal rest url    https   api paypal com v1 oauth2 token                         else              return                    paypal form url    https   www sandbox paypal com cgi bin webscr                    paypal rest url    https   api sandbox paypal com v1 oauth2 token                       api multi     def paypal compute fees(self  amount  currency id  country id)              compute paypal fees                param float amount  amount pay              param integer country id  id res country  none  this                                        customer country  compared                                        acquirer company country               return float fees  computed fees                coding  utf 8    server 2 server    default paypal fees                                                          form related methods                                                          find tx     tdenote use txn id      todo  txn id  shoudl false draft  set afterwards  verified txn details    check buyed    mc gross amount   fees    check buyer    check seller    check receiver email receiver id checked     in paypal  possible configure receiver email different email business email (the login email)    in odoo  one field paypal email  business email  this possible set receiver email    different business email  therefore  want configuration paypal  obliged fill    merchant id paypal payment acquirer odoo  check performed variable instead receiver email     at least one two checks must done  avoid fraudsters     dateutil pytz recognize abbreviations pdt pst ", "content": "# coding: utf-8\n\nimport json\nimport logging\n\nimport dateutil.parser\nimport pytz\nfrom werkzeug import urls\n\nfrom odoo import api, fields, models, _\nfrom odoo.addons.payment.models.payment_acquirer import ValidationError\nfrom odoo.addons.payment_paypal.controllers.main import PaypalController\nfrom odoo.tools.float_utils import float_compare\n\n\n_logger = logging.getLogger(__name__)\n\n\nclass AcquirerPaypal(models.Model):\n    _inherit = 'payment.acquirer'\n\n    provider = fields.Selection(selection_add=[('paypal', 'Paypal')])\n    paypal_email_account = fields.Char('Paypal Email ID', required_if_provider='paypal', groups='base.group_user')\n    paypal_seller_account = fields.Char(\n        'Paypal Merchant ID', groups='base.group_user',\n        help='The Merchant ID is used to ensure communications coming from Paypal are valid and secured.')\n    paypal_use_ipn = fields.Boolean('Use IPN', default=True, help='Paypal Instant Payment Notification', groups='base.group_user')\n    paypal_pdt_token = fields.Char(string='Paypal PDT Token', required_if_provider='paypal', help='Payment Data Transfer allows you to receive notification of successful payments as they are made.', groups='base.group_user')\n    # Server 2 server\n    paypal_api_enabled = fields.Boolean('Use Rest API', default=False)\n    paypal_api_username = fields.Char('Rest API Username', groups='base.group_user')\n    paypal_api_password = fields.Char('Rest API Password', groups='base.group_user')\n    paypal_api_access_token = fields.Char('Access Token', groups='base.group_user')\n    paypal_api_access_token_validity = fields.Datetime('Access Token Validity', groups='base.group_user')\n    # Default paypal fees\n    fees_dom_fixed = fields.Float(default=0.35)\n    fees_dom_var = fields.Float(default=3.4)\n    fees_int_fixed = fields.Float(default=0.35)\n    fees_int_var = fields.Float(default=3.9)\n\n    def _get_feature_support(self):\n        \"\"\"Get advanced feature support by provider.\n\n        Each provider should add its technical in the corresponding\n        key for the following features:\n            * fees: support payment fees computations\n            * authorize: support authorizing payment (separates\n                         authorization and capture)\n            * tokenize: support saving payment data in a payment.tokenize\n                        object\n        \"\"\"\n        res = super(AcquirerPaypal, self)._get_feature_support()\n        res['fees'].append('paypal')\n        return res\n\n    @api.model\n    def _get_paypal_urls(self, environment):\n        \"\"\" Paypal URLS \"\"\"\n        if environment == 'prod':\n            return {\n                'paypal_form_url': 'https://www.paypal.com/cgi-bin/webscr',\n                'paypal_rest_url': 'https://api.paypal.com/v1/oauth2/token',\n            }\n        else:\n            return {\n                'paypal_form_url': 'https://www.sandbox.paypal.com/cgi-bin/webscr',\n                'paypal_rest_url': 'https://api.sandbox.paypal.com/v1/oauth2/token',\n            }\n\n    @api.multi\n    def paypal_compute_fees(self, amount, currency_id, country_id):\n        \"\"\" Compute paypal fees.\n\n            :param float amount: the amount to pay\n            :param integer country_id: an ID of a res.country, or None. This is\n                                       the customer's country, to be compared to\n                                       the acquirer company country.\n            :return float fees: computed fees\n        \"\"\"\n        if not self.fees_active:\n            return 0.0\n        country = self.env['res.country'].browse(country_id)\n        if country and self.company_id.country_id.id == country.id:\n            percentage = self.fees_dom_var\n            fixed = self.fees_dom_fixed\n        else:\n            percentage = self.fees_int_var\n            fixed = self.fees_int_fixed\n        fees = (percentage / 100.0 * amount + fixed) / (1 - percentage / 100.0)\n        return fees\n\n    @api.multi\n    def paypal_form_generate_values(self, values):\n        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')\n\n        paypal_tx_values = dict(values)\n        paypal_tx_values.update({\n            'cmd': '_xclick',\n            'business': self.paypal_email_account,\n            'item_name': '%s: %s' % (self.company_id.name, values['reference']),\n            'item_number': values['reference'],\n            'amount': values['amount'],\n            'currency_code': values['currency'] and values['currency'].name or '',\n            'address1': values.get('partner_address'),\n            'city': values.get('partner_city'),\n            'country': values.get('partner_country') and values.get('partner_country').code or '',\n            'state': values.get('partner_state') and (values.get('partner_state').code or values.get('partner_state').name) or '',\n            'email': values.get('partner_email'),\n            'zip_code': values.get('partner_zip'),\n            'first_name': values.get('partner_first_name'),\n            'last_name': values.get('partner_last_name'),\n            'paypal_return': urls.url_join(base_url, PaypalController._return_url),\n            'notify_url': urls.url_join(base_url, PaypalController._notify_url),\n            'cancel_return': urls.url_join(base_url, PaypalController._cancel_url),\n            'handling': '%.2f' % paypal_tx_values.pop('fees', 0.0) if self.fees_active else False,\n            'custom': json.dumps({'return_url': '%s' % paypal_tx_values.pop('return_url')}) if paypal_tx_values.get('return_url') else False,\n        })\n        return paypal_tx_values\n\n    @api.multi\n    def paypal_get_form_action_url(self):\n        return self._get_paypal_urls(self.environment)['paypal_form_url']\n\n\nclass TxPaypal(models.Model):\n    _inherit = 'payment.transaction'\n\n    paypal_txn_type = fields.Char('Transaction type')\n\n    # --------------------------------------------------\n    # FORM RELATED METHODS\n    # --------------------------------------------------\n\n    @api.model\n    def _paypal_form_get_tx_from_data(self, data):\n        reference, txn_id = data.get('item_number'), data.get('txn_id')\n        if not reference or not txn_id:\n            error_msg = _('Paypal: received data with missing reference (%s) or txn_id (%s)') % (reference, txn_id)\n            _logger.info(error_msg)\n            raise ValidationError(error_msg)\n\n        # find tx -> @TDENOTE use txn_id ?\n        txs = self.env['payment.transaction'].search([('reference', '=', reference)])\n        if not txs or len(txs) > 1:\n            error_msg = 'Paypal: received data for reference %s' % (reference)\n            if not txs:\n                error_msg += '; no order found'\n            else:\n                error_msg += '; multiple order found'\n            _logger.info(error_msg)\n            raise ValidationError(error_msg)\n        return txs[0]\n\n    @api.multi\n    def _paypal_form_get_invalid_parameters(self, data):\n        invalid_parameters = []\n        _logger.info('Received a notification from Paypal with IPN version %s', data.get('notify_version'))\n        if data.get('test_ipn'):\n            _logger.warning(\n                'Received a notification from Paypal using sandbox'\n            ),\n\n        # TODO: txn_id: shoudl be false at draft, set afterwards, and verified with txn details\n        if self.acquirer_reference and data.get('txn_id') != self.acquirer_reference:\n            invalid_parameters.append(('txn_id', data.get('txn_id'), self.acquirer_reference))\n        # check what is buyed\n        if float_compare(float(data.get('mc_gross', '0.0')), (self.amount + self.fees), 2) != 0:\n            invalid_parameters.append(('mc_gross', data.get('mc_gross'), '%.2f' % self.amount))  # mc_gross is amount + fees\n        if data.get('mc_currency') != self.currency_id.name:\n            invalid_parameters.append(('mc_currency', data.get('mc_currency'), self.currency_id.name))\n        if 'handling_amount' in data and float_compare(float(data.get('handling_amount')), self.fees, 2) != 0:\n            invalid_parameters.append(('handling_amount', data.get('handling_amount'), self.fees))\n        # check buyer\n        if self.payment_token_id and data.get('payer_id') != self.payment_token_id.acquirer_ref:\n            invalid_parameters.append(('payer_id', data.get('payer_id'), self.payment_token_id.acquirer_ref))\n        # check seller\n        if data.get('receiver_id') and self.acquirer_id.paypal_seller_account and data['receiver_id'] != self.acquirer_id.paypal_seller_account:\n            invalid_parameters.append(('receiver_id', data.get('receiver_id'), self.acquirer_id.paypal_seller_account))\n        if not data.get('receiver_id') or not self.acquirer_id.paypal_seller_account:\n            # Check receiver_email only if receiver_id was not checked.\n            # In Paypal, this is possible to configure as receiver_email a different email than the business email (the login email)\n            # In Odoo, there is only one field for the Paypal email: the business email. This isn't possible to set a receiver_email\n            # different than the business email. Therefore, if you want such a configuration in your Paypal, you are then obliged to fill\n            # the Merchant ID in the Paypal payment acquirer in Odoo, so the check is performed on this variable instead of the receiver_email.\n            # At least one of the two checks must be done, to avoid fraudsters.\n            if data.get('receiver_email') != self.acquirer_id.paypal_email_account:\n                invalid_parameters.append(('receiver_email', data.get('receiver_email'), self.acquirer_id.paypal_email_account))\n\n        return invalid_parameters\n\n    @api.multi\n    def _paypal_form_validate(self, data):\n        status = data.get('payment_status')\n        res = {\n            'acquirer_reference': data.get('txn_id'),\n            'paypal_txn_type': data.get('payment_type'),\n        }\n        if status in ['Completed', 'Processed']:\n            _logger.info('Validated Paypal payment for tx %s: set as done' % (self.reference))\n            try:\n                # dateutil and pytz don't recognize abbreviations PDT/PST\n                tzinfos = {\n                    'PST': -8 * 3600,\n                    'PDT': -7 * 3600,\n                }\n                date_validate = dateutil.parser.parse(data.get('payment_date'), tzinfos=tzinfos).astimezone(pytz.utc)\n            except:\n                date_validate = fields.Datetime.now()\n            res.update(state='done', date_validate=date_validate)\n            return self.write(res)\n        elif status in ['Pending', 'Expired']:\n            _logger.info('Received notification for Paypal payment %s: set as pending' % (self.reference))\n            res.update(state='pending', state_message=data.get('pending_reason', ''))\n            return self.write(res)\n        else:\n            error = 'Received unrecognized status for Paypal payment %s: %s, set as error' % (self.reference, status)\n            _logger.info(error)\n            res.update(state='error', state_message=error)\n            return self.write(res)\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "payment.py", "id": "d38a8af609b8a5a2cba8c89afe979c71", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/payment_paypal/models/payment.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}