{"author": "HelloZeroNet", "code": "import re\nimport time\nimport cgi\n\nimport gevent\n\nfrom Plugin import PluginManager\nfrom Config import config\nfrom util import helper\nfrom Translate import Translate\n\nif \"_\" not in locals():\n    _ = Translate(\"plugins/OptionalManager/languages/\")\n\n@PluginManager.registerTo(\"UiWebsocket\")\nclass UiWebsocketPlugin(object):\n    def __init__(self, *args, **kwargs):\n        self.time_peer_numbers_updated = 0\n        super(UiWebsocketPlugin, self).__init__(*args, **kwargs)\n\n    def actionSiteSign(self, to, privatekey=None, inner_path=\"content.json\", *args, **kwargs):\n        \n        content_db = self.site.content_manager.contents.db\n        content_inner_dir = helper.getDirname(inner_path)\n        content_db.my_optional_files[self.site.address + \"/\" + content_inner_dir] = time.time()\n        if len(content_db.my_optional_files) > 50:  \n            oldest_key = min(\n                content_db.my_optional_files.iterkeys(),\n                key=(lambda key: content_db.my_optional_files[key])\n            )\n            del content_db.my_optional_files[oldest_key]\n\n        return super(UiWebsocketPlugin, self).actionSiteSign(to, privatekey, inner_path, *args, **kwargs)\n\n    def updatePeerNumbers(self):\n        content_db = self.site.content_manager.contents.db\n        content_db.updatePeerNumbers()\n        self.site.updateWebsocket(peernumber_updated=True)\n\n    def addBigfileInfo(self, row):\n        content_db = self.site.content_manager.contents.db\n        site = content_db.sites[row[\"address\"]]\n        if not site.settings.get(\"has_bigfile\"):\n            return False\n\n        file_info = site.content_manager.getFileInfo(row[\"inner_path\"])\n        if not file_info or not file_info.get(\"piece_size\"):\n            return False\n\n        sha512 = file_info[\"sha512\"]\n        if sha512 in site.storage.piecefields:\n            piecefield = site.storage.piecefields[sha512].tostring()\n        else:\n            piecefield = None\n\n        if piecefield:\n            row[\"pieces\"] = len(piecefield)\n            row[\"pieces_downloaded\"] = piecefield.count(\"1\")\n            row[\"downloaded_percent\"] = 100 * row[\"pieces_downloaded\"] / row[\"pieces\"]\n            row[\"bytes_downloaded\"] = row[\"pieces_downloaded\"] * file_info[\"piece_size\"]\n            row[\"is_downloading\"] = bool(next((task for task in site.worker_manager.tasks if task[\"inner_path\"].startswith(row[\"inner_path\"])), False))\n\n        \n        row[\"peer_seed\"] = 0\n        row[\"peer_leech\"] = 0\n        for peer in site.peers.itervalues():\n            if not peer.time_piecefields_updated or sha512 not in peer.piecefields:\n                continue\n            peer_piecefield = peer.piecefields[sha512].tostring()\n            if not peer_piecefield:\n                continue\n            if peer_piecefield == \"1\" * len(peer_piecefield):\n                row[\"peer_seed\"] += 1\n            else:\n                row[\"peer_leech\"] += 1\n\n        \n        if piecefield:\n            if row[\"pieces_downloaded\"] == row[\"pieces\"]:\n                row[\"peer_seed\"] += 1\n            else:\n                row[\"peer_leech\"] += 1\n\n        return True\n\n    \n\n    def actionOptionalFileList(self, to, address=None, orderby=\"time_downloaded DESC\", limit=10, filter=\"downloaded\"):\n        if not address:\n            address = self.site.address\n\n        \n        content_db = self.site.content_manager.contents.db\n        if time.time() - content_db.time_peer_numbers_updated > 60 * 1 and time.time() - self.time_peer_numbers_updated > 60 * 5:\n            \n            self.time_peer_numbers_updated = time.time()\n            gevent.spawn(self.updatePeerNumbers)\n\n        if address == \"all\" and \"ADMIN\" not in self.permissions:\n            return self.response(to, {\"error\": \"Forbidden\"})\n\n        if not self.hasSitePermission(address):\n            return self.response(to, {\"error\": \"Forbidden\"})\n\n        if not all([re.match(\"^[a-z_*/+-]+( DESC| ASC|)$\", part.strip()) for part in orderby.split(\",\")]):\n            return self.response(to, \"Invalid order_by\")\n\n        if type(limit) != int:\n            return self.response(to, \"Invalid limit\")\n\n        back = []\n        content_db = self.site.content_manager.contents.db\n\n        wheres = {}\n        if \"bigfile\" in filter:\n            wheres[\"size >\"] = 1024 * 1024 * 10\n        if \"downloaded\" in filter:\n            wheres[\"is_downloaded\"] = 1\n\n        if address == \"all\":\n            join = \"LEFT JOIN site USING (site_id)\"\n        else:\n            wheres[\"site_id\"] = content_db.site_ids[address]\n            join = \"\"\n\n        query = \"SELECT * FROM file_optional %s WHERE ? ORDER BY %s LIMIT %s\" % (join, orderby, limit)\n\n        for row in content_db.execute(query, wheres):\n            row = dict(row)\n            if address != \"all\":\n                row[\"address\"] = address\n\n            if row[\"size\"] > 1024 * 1024:\n                has_info = self.addBigfileInfo(row)\n            else:\n                has_info = False\n\n            if not has_info:\n                if row[\"is_downloaded\"]:\n                    row[\"bytes_downloaded\"] = row[\"size\"]\n                    row[\"downloaded_percent\"] = 100\n                else:\n                    row[\"bytes_downloaded\"] = 0\n                    row[\"downloaded_percent\"] = 0\n\n            back.append(row)\n        self.response(to, back)\n\n    def actionOptionalFileInfo(self, to, inner_path):\n        content_db = self.site.content_manager.contents.db\n        site_id = content_db.site_ids[self.site.address]\n\n        \n        if time.time() - content_db.time_peer_numbers_updated > 60 * 1 and time.time() - self.time_peer_numbers_updated > 60 * 5:\n            \n            self.time_peer_numbers_updated = time.time()\n            gevent.spawn(self.updatePeerNumbers)\n\n        query = \"SELECT * FROM file_optional WHERE site_id = :site_id AND inner_path = :inner_path LIMIT 1\"\n        res = content_db.execute(query, {\"site_id\": site_id, \"inner_path\": inner_path})\n        row = next(res, None)\n        if row:\n            row = dict(row)\n            if row[\"size\"] > 1024 * 1024:\n                row[\"address\"] = self.site.address\n                self.addBigfileInfo(row)\n            self.response(to, row)\n        else:\n            self.response(to, None)\n\n    def setPin(self, inner_path, is_pinned, address=None):\n        if not address:\n            address = self.site.address\n\n        if not self.hasSitePermission(address):\n            return {\"error\": \"Forbidden\"}\n\n        site = self.server.sites[address]\n\n        content_db = site.content_manager.contents.db\n        site_id = content_db.site_ids[site.address]\n        content_db.execute(\"UPDATE file_optional SET is_pinned = %s WHERE ?\" % is_pinned, {\"site_id\": site_id, \"inner_path\": inner_path})\n\n        return \"ok\"\n\n    def actionOptionalFilePin(self, to, inner_path, address=None):\n        back = self.setPin(inner_path, 1, address)\n        if back == \"ok\":\n            self.cmd(\"notification\", [\"done\", _[\"Pinned %s files\"] % len(inner_path) if type(inner_path) is list else 1, 5000])\n        self.response(to, back)\n\n    def actionOptionalFileUnpin(self, to, inner_path, address=None):\n        back = self.setPin(inner_path, 0, address)\n        if back == \"ok\":\n            self.cmd(\"notification\", [\"done\", _[\"Removed pin from %s files\"] % len(inner_path) if type(inner_path) is list else 1, 5000])\n        self.response(to, back)\n\n    def actionOptionalFileDelete(self, to, inner_path, address=None):\n        if not address:\n            address = self.site.address\n\n        if not self.hasSitePermission(address):\n            return self.response(to, {\"error\": \"Forbidden\"})\n\n        site = self.server.sites[address]\n\n        content_db = site.content_manager.contents.db\n        site_id = content_db.site_ids[site.address]\n\n        res = content_db.execute(\"SELECT * FROM file_optional WHERE ? LIMIT 1\", {\"site_id\": site_id, \"inner_path\": inner_path, \"is_downloaded\": 1})\n        row = next(res, None)\n\n        if not row:\n            return self.response(to, {\"error\": \"Not found in content.db\"})\n\n        removed = site.content_manager.optionalRemove(inner_path, row[\"hash_id\"], row[\"size\"])\n        \n        #    return self.response(to, {\"error\": \"Not found in hash_id: %s\" % row[\"hash_id\"]})\n\n        content_db.execute(\"UPDATE file_optional SET is_downloaded = 0, is_pinned = 0, peer = peer - 1 WHERE ?\", {\"site_id\": site_id, \"inner_path\": inner_path})\n\n        try:\n            site.storage.delete(inner_path)\n        except Exception as err:\n            return self.response(to, {\"error\": \"File delete error: %s\" % err})\n        site.updateWebsocket(file_delete=inner_path)\n\n        self.response(to, \"ok\")\n\n\n    \n\n    def actionOptionalLimitStats(self, to):\n        if \"ADMIN\" not in self.site.settings[\"permissions\"]:\n            return self.response(to, \"Forbidden\")\n\n        back = {}\n        back[\"limit\"] = config.optional_limit\n        back[\"used\"] = self.site.content_manager.contents.db.execute(\n            \"SELECT SUM(size) FROM file_optional WHERE is_downloaded = 1 AND is_pinned = 0\"\n        ).fetchone()[0]\n        back[\"free\"] = helper.getFreeSpace()\n\n        self.response(to, back)\n\n    def actionOptionalLimitSet(self, to, limit):\n        if \"ADMIN\" not in self.site.settings[\"permissions\"]:\n            return self.response(to, {\"error\": \"Forbidden\"})\n        config.optional_limit = re.sub(\"\\.0+$\", \"\", limit)  \n        config.saveValue(\"optional_limit\", limit)\n        self.response(to, \"ok\")\n\n    \n\n    def actionOptionalHelpList(self, to, address=None):\n        if not address:\n            address = self.site.address\n\n        if not self.hasSitePermission(address):\n            return self.response(to, {\"error\": \"Forbidden\"})\n\n        site = self.server.sites[address]\n\n        self.response(to, site.settings.get(\"optional_help\", {}))\n\n    def actionOptionalHelp(self, to, directory, title, address=None):\n        if not address:\n            address = self.site.address\n\n        if not self.hasSitePermission(address):\n            return self.response(to, {\"error\": \"Forbidden\"})\n\n        site = self.server.sites[address]\n        content_db = site.content_manager.contents.db\n        site_id = content_db.site_ids[address]\n\n        if \"optional_help\" not in site.settings:\n            site.settings[\"optional_help\"] = {}\n\n        stats = content_db.execute(\n            \"SELECT COUNT(*) AS num, SUM(size) AS size FROM file_optional WHERE site_id = :site_id AND inner_path LIKE :inner_path\",\n            {\"site_id\": site_id, \"inner_path\": directory + \"%\"}\n        ).fetchone()\n        stats = dict(stats)\n\n        if not stats[\"size\"]:\n            stats[\"size\"] = 0\n        if not stats[\"num\"]:\n            stats[\"num\"] = 0\n\n        self.cmd(\"notification\", [\n            \"done\",\n            _[\"You started to help distribute <b>%s</b>.<br><small>Directory: %s</small>\"] %\n            (cgi.escape(title), cgi.escape(directory)),\n            10000\n        ])\n\n        site.settings[\"optional_help\"][directory] = title\n\n        self.response(to, dict(stats))\n\n    def actionOptionalHelpRemove(self, to, directory, address=None):\n        if not address:\n            address = self.site.address\n\n        if not self.hasSitePermission(address):\n            return self.response(to, {\"error\": \"Forbidden\"})\n\n        site = self.server.sites[address]\n\n        try:\n            del site.settings[\"optional_help\"][directory]\n            self.response(to, \"ok\")\n        except Exception:\n            self.response(to, {\"error\": \"Not found\"})\n\n    def cbOptionalHelpAll(self, to, site, value):\n        site.settings[\"autodownloadoptional\"] = value\n        self.response(to, value)\n\n    def actionOptionalHelpAll(self, to, value, address=None):\n        if not address:\n            address = self.site.address\n\n        if not self.hasSitePermission(address):\n            return self.response(to, {\"error\": \"Forbidden\"})\n\n        site = self.server.sites[address]\n\n        if value:\n            if \"ADMIN\" in self.site.settings[\"permissions\"]:\n                self.cbOptionalHelpAll(to, site, True)\n            else:\n                site_title = site.content_manager.contents[\"content.json\"].get(\"title\", address)\n                self.cmd(\n                    \"confirm\",\n                    [\n                        _[\"Help distribute all new optional files on site <b>%s</b>\"] % cgi.escape(site_title),\n                        _[\"Yes, I want to help!\"]\n                    ],\n                    lambda (res): self.cbOptionalHelpAll(to, site, True)\n                )\n        else:\n            site.settings[\"autodownloadoptional\"] = False\n            self.response(to, False)\n", "comments": "  add file content db set pinned    keep last 50    add leech   seed stats    add    optional file functions    update peer numbers necessary    start new thread avoid blocking    update peer numbers necessary    start new thread avoid blocking    removed        return self response(to    error    not found hash id      row  hash id   )    limit functions    remove unnecessary digits end    distribute help functions ", "content": "import re\nimport time\nimport cgi\n\nimport gevent\n\nfrom Plugin import PluginManager\nfrom Config import config\nfrom util import helper\nfrom Translate import Translate\n\nif \"_\" not in locals():\n    _ = Translate(\"plugins/OptionalManager/languages/\")\n\n@PluginManager.registerTo(\"UiWebsocket\")\nclass UiWebsocketPlugin(object):\n    def __init__(self, *args, **kwargs):\n        self.time_peer_numbers_updated = 0\n        super(UiWebsocketPlugin, self).__init__(*args, **kwargs)\n\n    def actionSiteSign(self, to, privatekey=None, inner_path=\"content.json\", *args, **kwargs):\n        # Add file to content.db and set it as pinned\n        content_db = self.site.content_manager.contents.db\n        content_inner_dir = helper.getDirname(inner_path)\n        content_db.my_optional_files[self.site.address + \"/\" + content_inner_dir] = time.time()\n        if len(content_db.my_optional_files) > 50:  # Keep only last 50\n            oldest_key = min(\n                content_db.my_optional_files.iterkeys(),\n                key=(lambda key: content_db.my_optional_files[key])\n            )\n            del content_db.my_optional_files[oldest_key]\n\n        return super(UiWebsocketPlugin, self).actionSiteSign(to, privatekey, inner_path, *args, **kwargs)\n\n    def updatePeerNumbers(self):\n        content_db = self.site.content_manager.contents.db\n        content_db.updatePeerNumbers()\n        self.site.updateWebsocket(peernumber_updated=True)\n\n    def addBigfileInfo(self, row):\n        content_db = self.site.content_manager.contents.db\n        site = content_db.sites[row[\"address\"]]\n        if not site.settings.get(\"has_bigfile\"):\n            return False\n\n        file_info = site.content_manager.getFileInfo(row[\"inner_path\"])\n        if not file_info or not file_info.get(\"piece_size\"):\n            return False\n\n        sha512 = file_info[\"sha512\"]\n        if sha512 in site.storage.piecefields:\n            piecefield = site.storage.piecefields[sha512].tostring()\n        else:\n            piecefield = None\n\n        if piecefield:\n            row[\"pieces\"] = len(piecefield)\n            row[\"pieces_downloaded\"] = piecefield.count(\"1\")\n            row[\"downloaded_percent\"] = 100 * row[\"pieces_downloaded\"] / row[\"pieces\"]\n            row[\"bytes_downloaded\"] = row[\"pieces_downloaded\"] * file_info[\"piece_size\"]\n            row[\"is_downloading\"] = bool(next((task for task in site.worker_manager.tasks if task[\"inner_path\"].startswith(row[\"inner_path\"])), False))\n\n        # Add leech / seed stats\n        row[\"peer_seed\"] = 0\n        row[\"peer_leech\"] = 0\n        for peer in site.peers.itervalues():\n            if not peer.time_piecefields_updated or sha512 not in peer.piecefields:\n                continue\n            peer_piecefield = peer.piecefields[sha512].tostring()\n            if not peer_piecefield:\n                continue\n            if peer_piecefield == \"1\" * len(peer_piecefield):\n                row[\"peer_seed\"] += 1\n            else:\n                row[\"peer_leech\"] += 1\n\n        # Add myself\n        if piecefield:\n            if row[\"pieces_downloaded\"] == row[\"pieces\"]:\n                row[\"peer_seed\"] += 1\n            else:\n                row[\"peer_leech\"] += 1\n\n        return True\n\n    # Optional file functions\n\n    def actionOptionalFileList(self, to, address=None, orderby=\"time_downloaded DESC\", limit=10, filter=\"downloaded\"):\n        if not address:\n            address = self.site.address\n\n        # Update peer numbers if necessary\n        content_db = self.site.content_manager.contents.db\n        if time.time() - content_db.time_peer_numbers_updated > 60 * 1 and time.time() - self.time_peer_numbers_updated > 60 * 5:\n            # Start in new thread to avoid blocking\n            self.time_peer_numbers_updated = time.time()\n            gevent.spawn(self.updatePeerNumbers)\n\n        if address == \"all\" and \"ADMIN\" not in self.permissions:\n            return self.response(to, {\"error\": \"Forbidden\"})\n\n        if not self.hasSitePermission(address):\n            return self.response(to, {\"error\": \"Forbidden\"})\n\n        if not all([re.match(\"^[a-z_*/+-]+( DESC| ASC|)$\", part.strip()) for part in orderby.split(\",\")]):\n            return self.response(to, \"Invalid order_by\")\n\n        if type(limit) != int:\n            return self.response(to, \"Invalid limit\")\n\n        back = []\n        content_db = self.site.content_manager.contents.db\n\n        wheres = {}\n        if \"bigfile\" in filter:\n            wheres[\"size >\"] = 1024 * 1024 * 10\n        if \"downloaded\" in filter:\n            wheres[\"is_downloaded\"] = 1\n\n        if address == \"all\":\n            join = \"LEFT JOIN site USING (site_id)\"\n        else:\n            wheres[\"site_id\"] = content_db.site_ids[address]\n            join = \"\"\n\n        query = \"SELECT * FROM file_optional %s WHERE ? ORDER BY %s LIMIT %s\" % (join, orderby, limit)\n\n        for row in content_db.execute(query, wheres):\n            row = dict(row)\n            if address != \"all\":\n                row[\"address\"] = address\n\n            if row[\"size\"] > 1024 * 1024:\n                has_info = self.addBigfileInfo(row)\n            else:\n                has_info = False\n\n            if not has_info:\n                if row[\"is_downloaded\"]:\n                    row[\"bytes_downloaded\"] = row[\"size\"]\n                    row[\"downloaded_percent\"] = 100\n                else:\n                    row[\"bytes_downloaded\"] = 0\n                    row[\"downloaded_percent\"] = 0\n\n            back.append(row)\n        self.response(to, back)\n\n    def actionOptionalFileInfo(self, to, inner_path):\n        content_db = self.site.content_manager.contents.db\n        site_id = content_db.site_ids[self.site.address]\n\n        # Update peer numbers if necessary\n        if time.time() - content_db.time_peer_numbers_updated > 60 * 1 and time.time() - self.time_peer_numbers_updated > 60 * 5:\n            # Start in new thread to avoid blocking\n            self.time_peer_numbers_updated = time.time()\n            gevent.spawn(self.updatePeerNumbers)\n\n        query = \"SELECT * FROM file_optional WHERE site_id = :site_id AND inner_path = :inner_path LIMIT 1\"\n        res = content_db.execute(query, {\"site_id\": site_id, \"inner_path\": inner_path})\n        row = next(res, None)\n        if row:\n            row = dict(row)\n            if row[\"size\"] > 1024 * 1024:\n                row[\"address\"] = self.site.address\n                self.addBigfileInfo(row)\n            self.response(to, row)\n        else:\n            self.response(to, None)\n\n    def setPin(self, inner_path, is_pinned, address=None):\n        if not address:\n            address = self.site.address\n\n        if not self.hasSitePermission(address):\n            return {\"error\": \"Forbidden\"}\n\n        site = self.server.sites[address]\n\n        content_db = site.content_manager.contents.db\n        site_id = content_db.site_ids[site.address]\n        content_db.execute(\"UPDATE file_optional SET is_pinned = %s WHERE ?\" % is_pinned, {\"site_id\": site_id, \"inner_path\": inner_path})\n\n        return \"ok\"\n\n    def actionOptionalFilePin(self, to, inner_path, address=None):\n        back = self.setPin(inner_path, 1, address)\n        if back == \"ok\":\n            self.cmd(\"notification\", [\"done\", _[\"Pinned %s files\"] % len(inner_path) if type(inner_path) is list else 1, 5000])\n        self.response(to, back)\n\n    def actionOptionalFileUnpin(self, to, inner_path, address=None):\n        back = self.setPin(inner_path, 0, address)\n        if back == \"ok\":\n            self.cmd(\"notification\", [\"done\", _[\"Removed pin from %s files\"] % len(inner_path) if type(inner_path) is list else 1, 5000])\n        self.response(to, back)\n\n    def actionOptionalFileDelete(self, to, inner_path, address=None):\n        if not address:\n            address = self.site.address\n\n        if not self.hasSitePermission(address):\n            return self.response(to, {\"error\": \"Forbidden\"})\n\n        site = self.server.sites[address]\n\n        content_db = site.content_manager.contents.db\n        site_id = content_db.site_ids[site.address]\n\n        res = content_db.execute(\"SELECT * FROM file_optional WHERE ? LIMIT 1\", {\"site_id\": site_id, \"inner_path\": inner_path, \"is_downloaded\": 1})\n        row = next(res, None)\n\n        if not row:\n            return self.response(to, {\"error\": \"Not found in content.db\"})\n\n        removed = site.content_manager.optionalRemove(inner_path, row[\"hash_id\"], row[\"size\"])\n        # if not removed:\n        #    return self.response(to, {\"error\": \"Not found in hash_id: %s\" % row[\"hash_id\"]})\n\n        content_db.execute(\"UPDATE file_optional SET is_downloaded = 0, is_pinned = 0, peer = peer - 1 WHERE ?\", {\"site_id\": site_id, \"inner_path\": inner_path})\n\n        try:\n            site.storage.delete(inner_path)\n        except Exception as err:\n            return self.response(to, {\"error\": \"File delete error: %s\" % err})\n        site.updateWebsocket(file_delete=inner_path)\n\n        self.response(to, \"ok\")\n\n\n    # Limit functions\n\n    def actionOptionalLimitStats(self, to):\n        if \"ADMIN\" not in self.site.settings[\"permissions\"]:\n            return self.response(to, \"Forbidden\")\n\n        back = {}\n        back[\"limit\"] = config.optional_limit\n        back[\"used\"] = self.site.content_manager.contents.db.execute(\n            \"SELECT SUM(size) FROM file_optional WHERE is_downloaded = 1 AND is_pinned = 0\"\n        ).fetchone()[0]\n        back[\"free\"] = helper.getFreeSpace()\n\n        self.response(to, back)\n\n    def actionOptionalLimitSet(self, to, limit):\n        if \"ADMIN\" not in self.site.settings[\"permissions\"]:\n            return self.response(to, {\"error\": \"Forbidden\"})\n        config.optional_limit = re.sub(\"\\.0+$\", \"\", limit)  # Remove unnecessary digits from end\n        config.saveValue(\"optional_limit\", limit)\n        self.response(to, \"ok\")\n\n    # Distribute help functions\n\n    def actionOptionalHelpList(self, to, address=None):\n        if not address:\n            address = self.site.address\n\n        if not self.hasSitePermission(address):\n            return self.response(to, {\"error\": \"Forbidden\"})\n\n        site = self.server.sites[address]\n\n        self.response(to, site.settings.get(\"optional_help\", {}))\n\n    def actionOptionalHelp(self, to, directory, title, address=None):\n        if not address:\n            address = self.site.address\n\n        if not self.hasSitePermission(address):\n            return self.response(to, {\"error\": \"Forbidden\"})\n\n        site = self.server.sites[address]\n        content_db = site.content_manager.contents.db\n        site_id = content_db.site_ids[address]\n\n        if \"optional_help\" not in site.settings:\n            site.settings[\"optional_help\"] = {}\n\n        stats = content_db.execute(\n            \"SELECT COUNT(*) AS num, SUM(size) AS size FROM file_optional WHERE site_id = :site_id AND inner_path LIKE :inner_path\",\n            {\"site_id\": site_id, \"inner_path\": directory + \"%\"}\n        ).fetchone()\n        stats = dict(stats)\n\n        if not stats[\"size\"]:\n            stats[\"size\"] = 0\n        if not stats[\"num\"]:\n            stats[\"num\"] = 0\n\n        self.cmd(\"notification\", [\n            \"done\",\n            _[\"You started to help distribute <b>%s</b>.<br><small>Directory: %s</small>\"] %\n            (cgi.escape(title), cgi.escape(directory)),\n            10000\n        ])\n\n        site.settings[\"optional_help\"][directory] = title\n\n        self.response(to, dict(stats))\n\n    def actionOptionalHelpRemove(self, to, directory, address=None):\n        if not address:\n            address = self.site.address\n\n        if not self.hasSitePermission(address):\n            return self.response(to, {\"error\": \"Forbidden\"})\n\n        site = self.server.sites[address]\n\n        try:\n            del site.settings[\"optional_help\"][directory]\n            self.response(to, \"ok\")\n        except Exception:\n            self.response(to, {\"error\": \"Not found\"})\n\n    def cbOptionalHelpAll(self, to, site, value):\n        site.settings[\"autodownloadoptional\"] = value\n        self.response(to, value)\n\n    def actionOptionalHelpAll(self, to, value, address=None):\n        if not address:\n            address = self.site.address\n\n        if not self.hasSitePermission(address):\n            return self.response(to, {\"error\": \"Forbidden\"})\n\n        site = self.server.sites[address]\n\n        if value:\n            if \"ADMIN\" in self.site.settings[\"permissions\"]:\n                self.cbOptionalHelpAll(to, site, True)\n            else:\n                site_title = site.content_manager.contents[\"content.json\"].get(\"title\", address)\n                self.cmd(\n                    \"confirm\",\n                    [\n                        _[\"Help distribute all new optional files on site <b>%s</b>\"] % cgi.escape(site_title),\n                        _[\"Yes, I want to help!\"]\n                    ],\n                    lambda (res): self.cbOptionalHelpAll(to, site, True)\n                )\n        else:\n            site.settings[\"autodownloadoptional\"] = False\n            self.response(to, False)\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "UiWebsocketPlugin.py", "id": "e8bfe3649fc1b6415ee28377198ae18f", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/plugins/OptionalManager/UiWebsocketPlugin.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}