{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_HTTPError\nfrom ..utils import (\n    determine_ext,\n    int_or_none,\n    js_to_json,\n    ExtractorError,\n    urlencode_postdata\n)\n\n\nclass FunimationIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?funimation(?:\\.com|now\\.uk)/shows/[^/]+/(?P<id>[^/?\n\n    _NETRC_MACHINE = 'funimation'\n    _TOKEN = None\n\n    _TESTS = [{\n        'url': 'https://www.funimation.com/shows/hacksign/role-play/',\n        'info_dict': {\n            'id': '91144',\n            'display_id': 'role-play',\n            'ext': 'mp4',\n            'title': '.hack//SIGN - Role Play',\n            'description': 'md5:b602bdc15eef4c9bbb201bb6e6a4a2dd',\n            'thumbnail': r're:https?://.*\\.jpg',\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }, {\n        'url': 'https://www.funimation.com/shows/attack-on-titan-junior-high/broadcast-dub-preview/',\n        'info_dict': {\n            'id': '210051',\n            'display_id': 'broadcast-dub-preview',\n            'ext': 'mp4',\n            'title': 'Attack on Titan: Junior High - Broadcast Dub Preview',\n            'thumbnail': r're:https?://.*\\.(?:jpg|png)',\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }, {\n        'url': 'https://www.funimationnow.uk/shows/puzzle-dragons-x/drop-impact/simulcast/',\n        'only_matching': True,\n    }]\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n        try:\n            data = self._download_json(\n                'https://prod-api-funimationnow.dadcdigital.com/api/auth/login/',\n                None, 'Logging in', data=urlencode_postdata({\n                    'username': username,\n                    'password': password,\n                }))\n            self._TOKEN = data['token']\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError) and e.cause.code == 401:\n                error = self._parse_json(e.cause.read().decode(), None)['error']\n                raise ExtractorError(error, expected=True)\n            raise\n\n    def _real_initialize(self):\n        self._login()\n\n    def _real_extract(self, url):\n        display_id = self._match_id(url)\n        webpage = self._download_webpage(url, display_id)\n\n        def _search_kane(name):\n            return self._search_regex(\n                r\"KANE_customdimensions\\.%s\\s*=\\s*'([^']+)';\" % name,\n                webpage, name, default=None)\n\n        title_data = self._parse_json(self._search_regex(\n            r'TITLE_DATA\\s*=\\s*({[^}]+})',\n            webpage, 'title data', default=''),\n            display_id, js_to_json, fatal=False) or {}\n\n        video_id = title_data.get('id') or self._search_regex([\n            r\"KANE_customdimensions.videoID\\s*=\\s*'(\\d+)';\",\n            r'<iframe[^>]+src=\"/player/(\\d+)\"',\n        ], webpage, 'video_id', default=None)\n        if not video_id:\n            player_url = self._html_search_meta([\n                'al:web:url',\n                'og:video:url',\n                'og:video:secure_url',\n            ], webpage, fatal=True)\n            video_id = self._search_regex(r'/player/(\\d+)', player_url, 'video id')\n\n        title = episode = title_data.get('title') or _search_kane('videoTitle') or self._og_search_title(webpage)\n        series = _search_kane('showName')\n        if series:\n            title = '%s - %s' % (series, title)\n        description = self._html_search_meta(['description', 'og:description'], webpage, fatal=True)\n\n        try:\n            headers = {}\n            if self._TOKEN:\n                headers['Authorization'] = 'Token %s' % self._TOKEN\n            sources = self._download_json(\n                'https://prod-api-funimationnow.dadcdigital.com/api/source/catalog/video/%s/signed/' % video_id,\n                video_id, headers=headers)['items']\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError) and e.cause.code == 403:\n                error = self._parse_json(e.cause.read(), video_id)['errors'][0]\n                raise ExtractorError('%s said: %s' % (\n                    self.IE_NAME, error.get('detail') or error.get('title')), expected=True)\n            raise\n\n        formats = []\n        for source in sources:\n            source_url = source.get('src')\n            if not source_url:\n                continue\n            source_type = source.get('videoType') or determine_ext(source_url)\n            if source_type == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    source_url, video_id, 'mp4',\n                    m3u8_id='hls', fatal=False))\n            else:\n                formats.append({\n                    'format_id': source_type,\n                    'url': source_url,\n                })\n        self._sort_formats(formats)\n\n        return {\n            'id': video_id,\n            'display_id': display_id,\n            'title': title,\n            'description': description,\n            'thumbnail': self._og_search_thumbnail(webpage),\n            'series': series,\n            'season_number': int_or_none(title_data.get('seasonNum') or _search_kane('season')),\n            'episode_number': int_or_none(title_data.get('episodeNum')),\n            'episode': episode,\n            'season_id': title_data.get('seriesId'),\n            'formats': formats,\n        }\n", "comments": "# coding: utf-8\n#&]+)'\n# m3u8 download\n# m3u8 download\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_HTTPError\nfrom ..utils import (\n    determine_ext,\n    int_or_none,\n    js_to_json,\n    ExtractorError,\n    urlencode_postdata\n)\n\n\nclass FunimationIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?funimation(?:\\.com|now\\.uk)/shows/[^/]+/(?P<id>[^/?#&]+)'\n\n    _NETRC_MACHINE = 'funimation'\n    _TOKEN = None\n\n    _TESTS = [{\n        'url': 'https://www.funimation.com/shows/hacksign/role-play/',\n        'info_dict': {\n            'id': '91144',\n            'display_id': 'role-play',\n            'ext': 'mp4',\n            'title': '.hack//SIGN - Role Play',\n            'description': 'md5:b602bdc15eef4c9bbb201bb6e6a4a2dd',\n            'thumbnail': r're:https?://.*\\.jpg',\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n    }, {\n        'url': 'https://www.funimation.com/shows/attack-on-titan-junior-high/broadcast-dub-preview/',\n        'info_dict': {\n            'id': '210051',\n            'display_id': 'broadcast-dub-preview',\n            'ext': 'mp4',\n            'title': 'Attack on Titan: Junior High - Broadcast Dub Preview',\n            'thumbnail': r're:https?://.*\\.(?:jpg|png)',\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n    }, {\n        'url': 'https://www.funimationnow.uk/shows/puzzle-dragons-x/drop-impact/simulcast/',\n        'only_matching': True,\n    }]\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n        try:\n            data = self._download_json(\n                'https://prod-api-funimationnow.dadcdigital.com/api/auth/login/',\n                None, 'Logging in', data=urlencode_postdata({\n                    'username': username,\n                    'password': password,\n                }))\n            self._TOKEN = data['token']\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError) and e.cause.code == 401:\n                error = self._parse_json(e.cause.read().decode(), None)['error']\n                raise ExtractorError(error, expected=True)\n            raise\n\n    def _real_initialize(self):\n        self._login()\n\n    def _real_extract(self, url):\n        display_id = self._match_id(url)\n        webpage = self._download_webpage(url, display_id)\n\n        def _search_kane(name):\n            return self._search_regex(\n                r\"KANE_customdimensions\\.%s\\s*=\\s*'([^']+)';\" % name,\n                webpage, name, default=None)\n\n        title_data = self._parse_json(self._search_regex(\n            r'TITLE_DATA\\s*=\\s*({[^}]+})',\n            webpage, 'title data', default=''),\n            display_id, js_to_json, fatal=False) or {}\n\n        video_id = title_data.get('id') or self._search_regex([\n            r\"KANE_customdimensions.videoID\\s*=\\s*'(\\d+)';\",\n            r'<iframe[^>]+src=\"/player/(\\d+)\"',\n        ], webpage, 'video_id', default=None)\n        if not video_id:\n            player_url = self._html_search_meta([\n                'al:web:url',\n                'og:video:url',\n                'og:video:secure_url',\n            ], webpage, fatal=True)\n            video_id = self._search_regex(r'/player/(\\d+)', player_url, 'video id')\n\n        title = episode = title_data.get('title') or _search_kane('videoTitle') or self._og_search_title(webpage)\n        series = _search_kane('showName')\n        if series:\n            title = '%s - %s' % (series, title)\n        description = self._html_search_meta(['description', 'og:description'], webpage, fatal=True)\n\n        try:\n            headers = {}\n            if self._TOKEN:\n                headers['Authorization'] = 'Token %s' % self._TOKEN\n            sources = self._download_json(\n                'https://prod-api-funimationnow.dadcdigital.com/api/source/catalog/video/%s/signed/' % video_id,\n                video_id, headers=headers)['items']\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError) and e.cause.code == 403:\n                error = self._parse_json(e.cause.read(), video_id)['errors'][0]\n                raise ExtractorError('%s said: %s' % (\n                    self.IE_NAME, error.get('detail') or error.get('title')), expected=True)\n            raise\n\n        formats = []\n        for source in sources:\n            source_url = source.get('src')\n            if not source_url:\n                continue\n            source_type = source.get('videoType') or determine_ext(source_url)\n            if source_type == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    source_url, video_id, 'mp4',\n                    m3u8_id='hls', fatal=False))\n            else:\n                formats.append({\n                    'format_id': source_type,\n                    'url': source_url,\n                })\n        self._sort_formats(formats)\n\n        return {\n            'id': video_id,\n            'display_id': display_id,\n            'title': title,\n            'description': description,\n            'thumbnail': self._og_search_thumbnail(webpage),\n            'series': series,\n            'season_number': int_or_none(title_data.get('seasonNum') or _search_kane('season')),\n            'episode_number': int_or_none(title_data.get('episodeNum')),\n            'episode': episode,\n            'season_id': title_data.get('seriesId'),\n            'formats': formats,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "funimation.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/funimation.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}