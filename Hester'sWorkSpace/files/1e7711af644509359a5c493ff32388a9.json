{"author": "openai", "code": "\n\"\"\"\n  This is a small server that accepts connections on a websocket port and writes it to a file.\n\n  The purpose is to allow a universe-env with a built-in bot to record the actions it's taking\n  as a demonstration. So the demonstration includes a botactions.jsonl file that gets used instead\n  of the vnc client log. (The vnc client log is still recorded and needed to fully parse the VNC\n  protocol.)\n\n  It's much simpler than reward_recorder.py, because it doesn't have to also talk to the agent.\n  It just takes json messages over a websocket and appends them separated by newlines to the log file.\n\n  The ws port is 15986 unless overridden with --listen-address\n  The log file is /tmp/demo/botactions.jsonl unless overridden with --botaction-logfile\n\"\"\"\nimport argparse\nimport logging\nimport sys\nimport json\nfrom autobahn.twisted import websocket\nfrom universe.twisty import reactor\nlogger = logging.getLogger()\n\nclass BotactionRecordingServer(websocket.WebSocketServerProtocol, object):\n\n    _next_id = 1\n    @classmethod\n    def next_id(cls):\n        id = cls._next_id\n        cls._next_id += 1\n        return id\n\n    logfile_path='/tmp/demo/botactions.jsonl'\n\n    def __init__(self):\n        super(BotactionRecordingServer, self).__init__()\n        self.id = self.next_id()\n        self._closed = False\n        self.file = None\n\n        logger.info(\"[BotactionRecordingServer] [%d] Wrote version number\", self.id)\n\n    def _emit(self, rec):\n        if self.file:\n            self.file.write(json.dumps(rec) + '\\n');\n            self.file.flush()\n\n    def onConnect(self, request):\n        logger.info('[BotactionRecordingServer] [%d] Client connecting: %s. Writing to %s', self.id, request.peer, self.logfile_path)\n        self.file = open(self.logfile_path, 'w', encoding='utf-8')\n        self._emit({\n            'version': 1,\n            'session_id': self.id,\n            '_debug_version': '0.0.1',  \n        })\n\n    def onOpen(self):\n        logger.info(\"[BotactionRecordingServer] [%d] Websocket connection established\", self.id)\n\n    def onClose(self, wasClean, code, reason):\n        logger.info('[BotactionRecordingServer] [%d] Client connection closed: %s', self.id, reason)\n        if self.file:\n            self.file.close()\n            self.file = None\n\n        self._closed = True\n\n    def onMessage(self, msg, binary):\n        logger.debug('[BotactionRecordingServer] [%d] Received message from client: %s', self.id, msg)\n\n        self._emit(json.loads(msg.decode('utf-8')));\n\ndef main():\n    parser = argparse.ArgumentParser(description=None)\n    parser.add_argument('-v', '--verbose', action='count', dest='verbosity', default=0, help='Set verbosity.')\n    parser.add_argument('-l', '--listen-address', default='127.0.0.1:15896', help='Address to listen on')\n    parser.add_argument('-o', '--botaction-logfile', default='/tmp/demo/botactions.jsonl', help='Filename for timestamped log of bot actions.')\n    args = parser.parse_args()\n\n    BotactionRecordingServer.logfile_path = args.botaction_logfile\n\n    if args.verbosity == 0:\n        logger.setLevel(logging.INFO)\n    elif args.verbosity >= 1:\n        logger.setLevel(logging.DEBUG)\n\n    factory = websocket.WebSocketServerFactory()\n    factory.protocol = BotactionRecordingServer\n\n    host, port = args.listen_address.split(':')\n    port = int(port)\n    logger.info('Listening on %s:%s', host, port)\n    reactor.listenTCP(port, factory)\n    reactor.run()\n    return 0\n\nif __name__ == '__main__':\n    sys.exit(main())\n", "comments": "      this small server accepts connections websocket port writes file     the purpose allow universe env built bot record actions taking   demonstration  so demonstration includes botactions jsonl file gets used instead   vnc client log  (the vnc client log still recorded needed fully parse vnc   protocol )    it much simpler reward recorder py  also talk agent    it takes json messages websocket appends separated newlines log file     the ws port 15986 unless overridden   listen address   the log file  tmp demo botactions jsonl unless overridden   botaction logfile         usr bin env python    give internal version debugging corrupt reward demo files   todo  pull setup py host docker image ", "content": "#!/usr/bin/env python\n\"\"\"\n  This is a small server that accepts connections on a websocket port and writes it to a file.\n\n  The purpose is to allow a universe-env with a built-in bot to record the actions it's taking\n  as a demonstration. So the demonstration includes a botactions.jsonl file that gets used instead\n  of the vnc client log. (The vnc client log is still recorded and needed to fully parse the VNC\n  protocol.)\n\n  It's much simpler than reward_recorder.py, because it doesn't have to also talk to the agent.\n  It just takes json messages over a websocket and appends them separated by newlines to the log file.\n\n  The ws port is 15986 unless overridden with --listen-address\n  The log file is /tmp/demo/botactions.jsonl unless overridden with --botaction-logfile\n\"\"\"\nimport argparse\nimport logging\nimport sys\nimport json\nfrom autobahn.twisted import websocket\nfrom universe.twisty import reactor\nlogger = logging.getLogger()\n\nclass BotactionRecordingServer(websocket.WebSocketServerProtocol, object):\n\n    _next_id = 1\n    @classmethod\n    def next_id(cls):\n        id = cls._next_id\n        cls._next_id += 1\n        return id\n\n    logfile_path='/tmp/demo/botactions.jsonl'\n\n    def __init__(self):\n        super(BotactionRecordingServer, self).__init__()\n        self.id = self.next_id()\n        self._closed = False\n        self.file = None\n\n        logger.info(\"[BotactionRecordingServer] [%d] Wrote version number\", self.id)\n\n    def _emit(self, rec):\n        if self.file:\n            self.file.write(json.dumps(rec) + '\\n');\n            self.file.flush()\n\n    def onConnect(self, request):\n        logger.info('[BotactionRecordingServer] [%d] Client connecting: %s. Writing to %s', self.id, request.peer, self.logfile_path)\n        self.file = open(self.logfile_path, 'w', encoding='utf-8')\n        self._emit({\n            'version': 1,\n            'session_id': self.id,\n            '_debug_version': '0.0.1',  # Give this an internal version for debugging corrupt reward.demo files # TODO, pull this from setup.py or the host docker image\n        })\n\n    def onOpen(self):\n        logger.info(\"[BotactionRecordingServer] [%d] Websocket connection established\", self.id)\n\n    def onClose(self, wasClean, code, reason):\n        logger.info('[BotactionRecordingServer] [%d] Client connection closed: %s', self.id, reason)\n        if self.file:\n            self.file.close()\n            self.file = None\n\n        self._closed = True\n\n    def onMessage(self, msg, binary):\n        logger.debug('[BotactionRecordingServer] [%d] Received message from client: %s', self.id, msg)\n\n        self._emit(json.loads(msg.decode('utf-8')));\n\ndef main():\n    parser = argparse.ArgumentParser(description=None)\n    parser.add_argument('-v', '--verbose', action='count', dest='verbosity', default=0, help='Set verbosity.')\n    parser.add_argument('-l', '--listen-address', default='127.0.0.1:15896', help='Address to listen on')\n    parser.add_argument('-o', '--botaction-logfile', default='/tmp/demo/botactions.jsonl', help='Filename for timestamped log of bot actions.')\n    args = parser.parse_args()\n\n    BotactionRecordingServer.logfile_path = args.botaction_logfile\n\n    if args.verbosity == 0:\n        logger.setLevel(logging.INFO)\n    elif args.verbosity >= 1:\n        logger.setLevel(logging.DEBUG)\n\n    factory = websocket.WebSocketServerFactory()\n    factory.protocol = BotactionRecordingServer\n\n    host, port = args.listen_address.split(':')\n    port = int(port)\n    logger.info('Listening on %s:%s', host, port)\n    reactor.listenTCP(port, factory)\n    reactor.run()\n    return 0\n\nif __name__ == '__main__':\n    sys.exit(main())\n", "description": "Universe: a software platform for measuring and training an AI's general intelligence across the world's supply of games, websites and other applications.", "file_name": "botaction_recorder.py", "id": "1e7711af644509359a5c493ff32388a9", "language": "Python", "project_name": "universe", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/openai-universe/openai-universe-f95a5fe/example/recorders/botaction_recorder.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:39:09Z", "url": "https://github.com/openai/universe", "wiki": true}