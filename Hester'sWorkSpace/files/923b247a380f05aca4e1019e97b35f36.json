{"author": "mitmproxy", "code": "import typing\n\nfrom mitmproxy import controller\nfrom mitmproxy import flow\nfrom mitmproxy import http\nfrom mitmproxy import tcp\nfrom mitmproxy import websocket\n\nEvents = frozenset([\n    \"clientconnect\",\n    \"clientdisconnect\",\n    \"serverconnect\",\n    \"serverdisconnect\",\n    \n    \"tcp_start\",\n    \"tcp_message\",\n    \"tcp_error\",\n    \"tcp_end\",\n    \n    \"http_connect\",\n    \"request\",\n    \"requestheaders\",\n    \"response\",\n    \"responseheaders\",\n    \"error\",\n    \n    \"websocket_handshake\",\n    \"websocket_start\",\n    \"websocket_message\",\n    \"websocket_error\",\n    \"websocket_end\",\n    \n    \"next_layer\",\n    \"configure\",\n    \"done\",\n    \"log\",\n    \"load\",\n    \"running\",\n    \"tick\",\n    \"update\",\n])\n\nTEventGenerator = typing.Iterator[typing.Tuple[str, typing.Any]]\n\n\ndef _iterate_http(f: http.HTTPFlow) -> TEventGenerator:\n    if f.request:\n        yield \"requestheaders\", f\n        yield \"request\", f\n    if f.response:\n        yield \"responseheaders\", f\n        yield \"response\", f\n    if f.error:\n        yield \"error\", f\n\n\ndef _iterate_websocket(f: websocket.WebSocketFlow) -> TEventGenerator:\n    messages = f.messages\n    f.messages = []\n    f.reply = controller.DummyReply()\n    yield \"websocket_start\", f\n    while messages:\n        f.messages.append(messages.pop(0))\n        yield \"websocket_message\", f\n    if f.error:\n        yield \"websocket_error\", f\n    yield \"websocket_end\", f\n\n\ndef _iterate_tcp(f: tcp.TCPFlow) -> TEventGenerator:\n    messages = f.messages\n    f.messages = []\n    f.reply = controller.DummyReply()\n    yield \"tcp_start\", f\n    while messages:\n        f.messages.append(messages.pop(0))\n        yield \"tcp_message\", f\n    if f.error:\n        yield \"tcp_error\", f\n    yield \"tcp_end\", f\n\n\n_iterate_map = {\n    http.HTTPFlow: _iterate_http,\n    websocket.WebSocketFlow: _iterate_websocket,\n    tcp.TCPFlow: _iterate_tcp,\n}  # type: typing.Dict[typing.Type[flow.Flow], typing.Callable[[typing.Any], TEventGenerator]]\n\n\ndef iterate(f: flow.Flow) -> TEventGenerator:\n    try:\n        e = _iterate_map[type(f)]\n    except KeyError as err:\n        raise TypeError(\"Unknown flow type: {}\".format(f)) from err\n    else:\n        yield from e(f)\n", "comments": "  tcp    http    websocket    misc    type  typing dict typing type flow flow   typing callable  typing any   teventgenerator   ", "content": "import typing\n\nfrom mitmproxy import controller\nfrom mitmproxy import flow\nfrom mitmproxy import http\nfrom mitmproxy import tcp\nfrom mitmproxy import websocket\n\nEvents = frozenset([\n    \"clientconnect\",\n    \"clientdisconnect\",\n    \"serverconnect\",\n    \"serverdisconnect\",\n    # TCP\n    \"tcp_start\",\n    \"tcp_message\",\n    \"tcp_error\",\n    \"tcp_end\",\n    # HTTP\n    \"http_connect\",\n    \"request\",\n    \"requestheaders\",\n    \"response\",\n    \"responseheaders\",\n    \"error\",\n    # WebSocket\n    \"websocket_handshake\",\n    \"websocket_start\",\n    \"websocket_message\",\n    \"websocket_error\",\n    \"websocket_end\",\n    # misc\n    \"next_layer\",\n    \"configure\",\n    \"done\",\n    \"log\",\n    \"load\",\n    \"running\",\n    \"tick\",\n    \"update\",\n])\n\nTEventGenerator = typing.Iterator[typing.Tuple[str, typing.Any]]\n\n\ndef _iterate_http(f: http.HTTPFlow) -> TEventGenerator:\n    if f.request:\n        yield \"requestheaders\", f\n        yield \"request\", f\n    if f.response:\n        yield \"responseheaders\", f\n        yield \"response\", f\n    if f.error:\n        yield \"error\", f\n\n\ndef _iterate_websocket(f: websocket.WebSocketFlow) -> TEventGenerator:\n    messages = f.messages\n    f.messages = []\n    f.reply = controller.DummyReply()\n    yield \"websocket_start\", f\n    while messages:\n        f.messages.append(messages.pop(0))\n        yield \"websocket_message\", f\n    if f.error:\n        yield \"websocket_error\", f\n    yield \"websocket_end\", f\n\n\ndef _iterate_tcp(f: tcp.TCPFlow) -> TEventGenerator:\n    messages = f.messages\n    f.messages = []\n    f.reply = controller.DummyReply()\n    yield \"tcp_start\", f\n    while messages:\n        f.messages.append(messages.pop(0))\n        yield \"tcp_message\", f\n    if f.error:\n        yield \"tcp_error\", f\n    yield \"tcp_end\", f\n\n\n_iterate_map = {\n    http.HTTPFlow: _iterate_http,\n    websocket.WebSocketFlow: _iterate_websocket,\n    tcp.TCPFlow: _iterate_tcp,\n}  # type: typing.Dict[typing.Type[flow.Flow], typing.Callable[[typing.Any], TEventGenerator]]\n\n\ndef iterate(f: flow.Flow) -> TEventGenerator:\n    try:\n        e = _iterate_map[type(f)]\n    except KeyError as err:\n        raise TypeError(\"Unknown flow type: {}\".format(f)) from err\n    else:\n        yield from e(f)\n", "description": "An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers.", "file_name": "eventsequence.py", "id": "923b247a380f05aca4e1019e97b35f36", "language": "Python", "project_name": "mitmproxy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mitmproxy-mitmproxy/mitmproxy-mitmproxy-3c7725a/mitmproxy/eventsequence.py", "save_time": "", "source": "", "update_at": "2018-03-18T11:30:56Z", "url": "https://github.com/mitmproxy/mitmproxy", "wiki": false}