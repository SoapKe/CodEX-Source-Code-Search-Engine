{"author": "HelloZeroNet", "code": "\n# -*- coding: utf-8 -*-\n\n#  Copyright (C) 2011 Yann GUIBET <yannguibet@gmail.com>\n\n\nfrom hashlib import sha512\nfrom pyelliptic.openssl import OpenSSL\nfrom pyelliptic.cipher import Cipher\nfrom pyelliptic.hash import hmac_sha256, equals\nfrom struct import pack, unpack\n\n\nclass ECC:\n    \"\"\"\n    Asymmetric encryption with Elliptic Curve Cryptography (ECC)\n    ECDH, ECDSA and ECIES\n\n        import pyelliptic\n\n        alice = pyelliptic.ECC() \n        bob = pyelliptic.ECC(curve='sect571r1')\n\n        ciphertext = alice.encrypt(\"Hello Bob\", bob.get_pubkey())\n        print bob.decrypt(ciphertext)\n\n        signature = bob.sign(\"Hello Alice\")\n        \n        print pyelliptic.ECC(\n            pubkey=bob.get_pubkey()).verify(signature, \"Hello Alice\")\n\n        \n        try:\n            key = alice.get_ecdh_key(bob.get_pubkey())\n        except: print(\"For ECDH key agreement,\\\n                      the keys must be defined on the same curve !\")\n\n        alice = pyelliptic.ECC(curve='sect571r1')\n        print alice.get_ecdh_key(bob.get_pubkey()).encode('hex')\n        print bob.get_ecdh_key(alice.get_pubkey()).encode('hex')\n\n    \"\"\"\n    def __init__(self, pubkey=None, privkey=None, pubkey_x=None,\n                 pubkey_y=None, raw_privkey=None, curve='sect283r1'):\n        \"\"\"\n        For a normal and High level use, specifie pubkey,\n        privkey (if you need) and the curve\n        \"\"\"\n        if type(curve) == str:\n            self.curve = OpenSSL.get_curve(curve)\n        else:\n            self.curve = curve\n\n        if pubkey_x is not None and pubkey_y is not None:\n            self._set_keys(pubkey_x, pubkey_y, raw_privkey)\n        elif pubkey is not None:\n            curve, pubkey_x, pubkey_y, i = ECC._decode_pubkey(pubkey)\n            if privkey is not None:\n                curve2, raw_privkey, i = ECC._decode_privkey(privkey)\n                if curve != curve2:\n                    raise Exception(\"Bad ECC keys ...\")\n            self.curve = curve\n            self._set_keys(pubkey_x, pubkey_y, raw_privkey)\n        else:\n            self.privkey, self.pubkey_x, self.pubkey_y = self._generate()\n\n    def _set_keys(self, pubkey_x, pubkey_y, privkey):\n        if self.raw_check_key(privkey, pubkey_x, pubkey_y) < 0:\n            self.pubkey_x = None\n            self.pubkey_y = None\n            self.privkey = None\n            raise Exception(\"Bad ECC keys ...\")\n        else:\n            self.pubkey_x = pubkey_x\n            self.pubkey_y = pubkey_y\n            self.privkey = privkey\n\n    @staticmethod\n    def get_curves():\n        \"\"\"\n        static method, returns the list of all the curves available\n        \"\"\"\n        return OpenSSL.curves.keys()\n\n    def get_curve(self):\n        return OpenSSL.get_curve_by_id(self.curve)\n\n    def get_curve_id(self):\n        return self.curve\n\n    def get_pubkey(self):\n        \"\"\"\n        High level function which returns :\n        curve(2) + len_of_pubkeyX(2) + pubkeyX + len_of_pubkeyY + pubkeyY\n        \"\"\"\n        return b''.join((pack('!H', self.curve),\n                         pack('!H', len(self.pubkey_x)),\n                         self.pubkey_x,\n                         pack('!H', len(self.pubkey_y)),\n                         self.pubkey_y\n                         ))\n\n    def get_privkey(self):\n        \"\"\"\n        High level function which returns\n        curve(2) + len_of_privkey(2) + privkey\n        \"\"\"\n        return b''.join((pack('!H', self.curve),\n                         pack('!H', len(self.privkey)),\n                         self.privkey\n                         ))\n\n    @staticmethod\n    def _decode_pubkey(pubkey):\n        i = 0\n        curve = unpack('!H', pubkey[i:i + 2])[0]\n        i += 2\n        tmplen = unpack('!H', pubkey[i:i + 2])[0]\n        i += 2\n        pubkey_x = pubkey[i:i + tmplen]\n        i += tmplen\n        tmplen = unpack('!H', pubkey[i:i + 2])[0]\n        i += 2\n        pubkey_y = pubkey[i:i + tmplen]\n        i += tmplen\n        return curve, pubkey_x, pubkey_y, i\n\n    @staticmethod\n    def _decode_privkey(privkey):\n        i = 0\n        curve = unpack('!H', privkey[i:i + 2])[0]\n        i += 2\n        tmplen = unpack('!H', privkey[i:i + 2])[0]\n        i += 2\n        privkey = privkey[i:i + tmplen]\n        i += tmplen\n        return curve, privkey, i\n\n    def _generate(self):\n        try:\n            pub_key_x = OpenSSL.BN_new()\n            pub_key_y = OpenSSL.BN_new()\n\n            key = OpenSSL.EC_KEY_new_by_curve_name(self.curve)\n            if key == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_new_by_curve_name FAIL ...\")\n            if (OpenSSL.EC_KEY_generate_key(key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_generate_key FAIL ...\")\n            if (OpenSSL.EC_KEY_check_key(key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_check_key FAIL ...\")\n            priv_key = OpenSSL.EC_KEY_get0_private_key(key)\n\n            group = OpenSSL.EC_KEY_get0_group(key)\n            pub_key = OpenSSL.EC_KEY_get0_public_key(key)\n\n            if (OpenSSL.EC_POINT_get_affine_coordinates_GFp(group, pub_key,\n                                                            pub_key_x,\n                                                            pub_key_y, 0\n                                                            )) == 0:\n                raise Exception(\n                    \"[OpenSSL] EC_POINT_get_affine_coordinates_GFp FAIL ...\")\n\n            privkey = OpenSSL.malloc(0, OpenSSL.BN_num_bytes(priv_key))\n            pubkeyx = OpenSSL.malloc(0, OpenSSL.BN_num_bytes(pub_key_x))\n            pubkeyy = OpenSSL.malloc(0, OpenSSL.BN_num_bytes(pub_key_y))\n            OpenSSL.BN_bn2bin(priv_key, privkey)\n            privkey = privkey.raw\n            OpenSSL.BN_bn2bin(pub_key_x, pubkeyx)\n            pubkeyx = pubkeyx.raw\n            OpenSSL.BN_bn2bin(pub_key_y, pubkeyy)\n            pubkeyy = pubkeyy.raw\n            self.raw_check_key(privkey, pubkeyx, pubkeyy)\n\n            return privkey, pubkeyx, pubkeyy\n\n        finally:\n            OpenSSL.EC_KEY_free(key)\n            OpenSSL.BN_free(pub_key_x)\n            OpenSSL.BN_free(pub_key_y)\n\n    def get_ecdh_key(self, pubkey):\n        \"\"\"\n        High level function. Compute public key with the local private key\n        and returns a 512bits shared key\n        \"\"\"\n        curve, pubkey_x, pubkey_y, i = ECC._decode_pubkey(pubkey)\n        if curve != self.curve:\n            raise Exception(\"ECC keys must be from the same curve !\")\n        return sha512(self.raw_get_ecdh_key(pubkey_x, pubkey_y)).digest()\n\n    def raw_get_ecdh_key(self, pubkey_x, pubkey_y):\n        try:\n            ecdh_keybuffer = OpenSSL.malloc(0, 32)\n\n            other_key = OpenSSL.EC_KEY_new_by_curve_name(self.curve)\n            if other_key == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_new_by_curve_name FAIL ...\")\n\n            other_pub_key_x = OpenSSL.BN_bin2bn(pubkey_x, len(pubkey_x), 0)\n            other_pub_key_y = OpenSSL.BN_bin2bn(pubkey_y, len(pubkey_y), 0)\n\n            other_group = OpenSSL.EC_KEY_get0_group(other_key)\n            other_pub_key = OpenSSL.EC_POINT_new(other_group)\n\n            if (OpenSSL.EC_POINT_set_affine_coordinates_GFp(other_group,\n                                                            other_pub_key,\n                                                            other_pub_key_x,\n                                                            other_pub_key_y,\n                                                            0)) == 0:\n                raise Exception(\n                    \"[OpenSSL] EC_POINT_set_affine_coordinates_GFp FAIL ...\")\n            if (OpenSSL.EC_KEY_set_public_key(other_key, other_pub_key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_set_public_key FAIL ...\")\n            if (OpenSSL.EC_KEY_check_key(other_key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_check_key FAIL ...\")\n\n            own_key = OpenSSL.EC_KEY_new_by_curve_name(self.curve)\n            if own_key == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_new_by_curve_name FAIL ...\")\n            own_priv_key = OpenSSL.BN_bin2bn(\n                self.privkey, len(self.privkey), 0)\n\n            if (OpenSSL.EC_KEY_set_private_key(own_key, own_priv_key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_set_private_key FAIL ...\")\n\n            if OpenSSL._hexversion > 0x10100000 and not OpenSSL._libreSSL:\n                OpenSSL.EC_KEY_set_method(own_key, OpenSSL.EC_KEY_OpenSSL())\n            else:\n                OpenSSL.ECDH_set_method(own_key, OpenSSL.ECDH_OpenSSL())\n            ecdh_keylen = OpenSSL.ECDH_compute_key(\n                ecdh_keybuffer, 32, other_pub_key, own_key, 0)\n\n            if ecdh_keylen != 32:\n                raise Exception(\"[OpenSSL] ECDH keylen FAIL ...\")\n\n            return ecdh_keybuffer.raw\n\n        finally:\n            OpenSSL.EC_KEY_free(other_key)\n            OpenSSL.BN_free(other_pub_key_x)\n            OpenSSL.BN_free(other_pub_key_y)\n            OpenSSL.EC_POINT_free(other_pub_key)\n            OpenSSL.EC_KEY_free(own_key)\n            OpenSSL.BN_free(own_priv_key)\n\n    def check_key(self, privkey, pubkey):\n        \"\"\"\n        Check the public key and the private key.\n        The private key is optional (replace by None)\n        \"\"\"\n        curve, pubkey_x, pubkey_y, i = ECC._decode_pubkey(pubkey)\n        if privkey is None:\n            raw_privkey = None\n            curve2 = curve\n        else:\n            curve2, raw_privkey, i = ECC._decode_privkey(privkey)\n        if curve != curve2:\n            raise Exception(\"Bad public and private key\")\n        return self.raw_check_key(raw_privkey, pubkey_x, pubkey_y, curve)\n\n    def raw_check_key(self, privkey, pubkey_x, pubkey_y, curve=None):\n        if curve is None:\n            curve = self.curve\n        elif type(curve) == str:\n            curve = OpenSSL.get_curve(curve)\n        else:\n            curve = curve\n        try:\n            key = OpenSSL.EC_KEY_new_by_curve_name(curve)\n            if key == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_new_by_curve_name FAIL ...\")\n            if privkey is not None:\n                priv_key = OpenSSL.BN_bin2bn(privkey, len(privkey), 0)\n            pub_key_x = OpenSSL.BN_bin2bn(pubkey_x, len(pubkey_x), 0)\n            pub_key_y = OpenSSL.BN_bin2bn(pubkey_y, len(pubkey_y), 0)\n\n            if privkey is not None:\n                if (OpenSSL.EC_KEY_set_private_key(key, priv_key)) == 0:\n                    raise Exception(\n                        \"[OpenSSL] EC_KEY_set_private_key FAIL ...\")\n\n            group = OpenSSL.EC_KEY_get0_group(key)\n            pub_key = OpenSSL.EC_POINT_new(group)\n\n            if (OpenSSL.EC_POINT_set_affine_coordinates_GFp(group, pub_key,\n                                                            pub_key_x,\n                                                            pub_key_y,\n                                                            0)) == 0:\n                raise Exception(\n                    \"[OpenSSL] EC_POINT_set_affine_coordinates_GFp FAIL ...\")\n            if (OpenSSL.EC_KEY_set_public_key(key, pub_key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_set_public_key FAIL ...\")\n            if (OpenSSL.EC_KEY_check_key(key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_check_key FAIL ...\")\n            return 0\n\n        finally:\n            OpenSSL.EC_KEY_free(key)\n            OpenSSL.BN_free(pub_key_x)\n            OpenSSL.BN_free(pub_key_y)\n            OpenSSL.EC_POINT_free(pub_key)\n            if privkey is not None:\n                OpenSSL.BN_free(priv_key)\n\n    def sign(self, inputb, digest_alg=OpenSSL.digest_ecdsa_sha1):\n        \"\"\"\n        Sign the input with ECDSA method and returns the signature\n        \"\"\"\n        try:\n            size = len(inputb)\n            buff = OpenSSL.malloc(inputb, size)\n            digest = OpenSSL.malloc(0, 64)\n            if OpenSSL._hexversion > 0x10100000 and not OpenSSL._libreSSL:\n                md_ctx = OpenSSL.EVP_MD_CTX_new()\n            else:\n                md_ctx = OpenSSL.EVP_MD_CTX_create()\n            dgst_len = OpenSSL.pointer(OpenSSL.c_int(0))\n            siglen = OpenSSL.pointer(OpenSSL.c_int(0))\n            sig = OpenSSL.malloc(0, 151)\n\n            key = OpenSSL.EC_KEY_new_by_curve_name(self.curve)\n            if key == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_new_by_curve_name FAIL ...\")\n\n            priv_key = OpenSSL.BN_bin2bn(self.privkey, len(self.privkey), 0)\n            pub_key_x = OpenSSL.BN_bin2bn(self.pubkey_x, len(self.pubkey_x), 0)\n            pub_key_y = OpenSSL.BN_bin2bn(self.pubkey_y, len(self.pubkey_y), 0)\n\n            if (OpenSSL.EC_KEY_set_private_key(key, priv_key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_set_private_key FAIL ...\")\n\n            group = OpenSSL.EC_KEY_get0_group(key)\n            pub_key = OpenSSL.EC_POINT_new(group)\n\n            if (OpenSSL.EC_POINT_set_affine_coordinates_GFp(group, pub_key,\n                                                            pub_key_x,\n                                                            pub_key_y,\n                                                            0)) == 0:\n                raise Exception(\n                    \"[OpenSSL] EC_POINT_set_affine_coordinates_GFp FAIL ...\")\n            if (OpenSSL.EC_KEY_set_public_key(key, pub_key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_set_public_key FAIL ...\")\n            if (OpenSSL.EC_KEY_check_key(key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_check_key FAIL ...\")\n\n            if OpenSSL._hexversion > 0x10100000 and not OpenSSL._libreSSL:\n                OpenSSL.EVP_MD_CTX_new(md_ctx)\n            else:\n                OpenSSL.EVP_MD_CTX_init(md_ctx)\n            OpenSSL.EVP_DigestInit_ex(md_ctx, digest_alg(), None)\n\n            if (OpenSSL.EVP_DigestUpdate(md_ctx, buff, size)) == 0:\n                raise Exception(\"[OpenSSL] EVP_DigestUpdate FAIL ...\")\n            OpenSSL.EVP_DigestFinal_ex(md_ctx, digest, dgst_len)\n            OpenSSL.ECDSA_sign(0, digest, dgst_len.contents, sig, siglen, key)\n            if (OpenSSL.ECDSA_verify(0, digest, dgst_len.contents, sig,\n                                     siglen.contents, key)) != 1:\n                raise Exception(\"[OpenSSL] ECDSA_verify FAIL ...\")\n\n            return sig.raw[:siglen.contents.value]\n\n        finally:\n            OpenSSL.EC_KEY_free(key)\n            OpenSSL.BN_free(pub_key_x)\n            OpenSSL.BN_free(pub_key_y)\n            OpenSSL.BN_free(priv_key)\n            OpenSSL.EC_POINT_free(pub_key)\n            if OpenSSL._hexversion > 0x10100000 and not OpenSSL._libreSSL:\n                OpenSSL.EVP_MD_CTX_free(md_ctx)\n            else:\n                OpenSSL.EVP_MD_CTX_destroy(md_ctx)\n            pass\n\n    def verify(self, sig, inputb, digest_alg=OpenSSL.digest_ecdsa_sha1):\n        \"\"\"\n        Verify the signature with the input and the local public key.\n        Returns a boolean\n        \"\"\"\n        try:\n            bsig = OpenSSL.malloc(sig, len(sig))\n            binputb = OpenSSL.malloc(inputb, len(inputb))\n            digest = OpenSSL.malloc(0, 64)\n            dgst_len = OpenSSL.pointer(OpenSSL.c_int(0))\n            if OpenSSL._hexversion > 0x10100000 and not OpenSSL._libreSSL:\n                md_ctx = OpenSSL.EVP_MD_CTX_new()\n            else:\n                md_ctx = OpenSSL.EVP_MD_CTX_create()\n            key = OpenSSL.EC_KEY_new_by_curve_name(self.curve)\n\n            if key == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_new_by_curve_name FAIL ...\")\n\n            pub_key_x = OpenSSL.BN_bin2bn(self.pubkey_x, len(self.pubkey_x), 0)\n            pub_key_y = OpenSSL.BN_bin2bn(self.pubkey_y, len(self.pubkey_y), 0)\n            group = OpenSSL.EC_KEY_get0_group(key)\n            pub_key = OpenSSL.EC_POINT_new(group)\n\n            if (OpenSSL.EC_POINT_set_affine_coordinates_GFp(group, pub_key,\n                                                            pub_key_x,\n                                                            pub_key_y,\n                                                            0)) == 0:\n                raise Exception(\n                    \"[OpenSSL] EC_POINT_set_affine_coordinates_GFp FAIL ...\")\n            if (OpenSSL.EC_KEY_set_public_key(key, pub_key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_set_public_key FAIL ...\")\n            if (OpenSSL.EC_KEY_check_key(key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_check_key FAIL ...\")\n            if OpenSSL._hexversion > 0x10100000 and not OpenSSL._libreSSL:\n                OpenSSL.EVP_MD_CTX_new(md_ctx)\n            else:\n                OpenSSL.EVP_MD_CTX_init(md_ctx)\n            OpenSSL.EVP_DigestInit_ex(md_ctx, digest_alg(), None)\n            if (OpenSSL.EVP_DigestUpdate(md_ctx, binputb, len(inputb))) == 0:\n                raise Exception(\"[OpenSSL] EVP_DigestUpdate FAIL ...\")\n\n            OpenSSL.EVP_DigestFinal_ex(md_ctx, digest, dgst_len)\n            ret = OpenSSL.ECDSA_verify(\n                0, digest, dgst_len.contents, bsig, len(sig), key)\n\n            if ret == -1:\n                return False  \n            else:\n                if ret == 0:\n                    return False  \n                else:\n                    return True  \n            return False\n\n        finally:\n            OpenSSL.EC_KEY_free(key)\n            OpenSSL.BN_free(pub_key_x)\n            OpenSSL.BN_free(pub_key_y)\n            OpenSSL.EC_POINT_free(pub_key)\n            if OpenSSL._hexversion > 0x10100000 and not OpenSSL._libreSSL:\n                OpenSSL.EVP_MD_CTX_free(md_ctx)\n            else:\n                OpenSSL.EVP_MD_CTX_destroy(md_ctx)\n\n    @staticmethod\n    def encrypt(data, pubkey, ephemcurve=None, ciphername='aes-256-cbc'):\n        \"\"\"\n        Encrypt data with ECIES method using the public key of the recipient.\n        \"\"\"\n        curve, pubkey_x, pubkey_y, i = ECC._decode_pubkey(pubkey)\n        return ECC.raw_encrypt(data, pubkey_x, pubkey_y, curve=curve,\n                               ephemcurve=ephemcurve, ciphername=ciphername)\n\n    @staticmethod\n    def raw_encrypt(data, pubkey_x, pubkey_y, curve='sect283r1',\n                    ephemcurve=None, ciphername='aes-256-cbc'):\n        if ephemcurve is None:\n            ephemcurve = curve\n        ephem = ECC(curve=ephemcurve)\n        key = sha512(ephem.raw_get_ecdh_key(pubkey_x, pubkey_y)).digest()\n        key_e, key_m = key[:32], key[32:]\n        pubkey = ephem.get_pubkey()\n        iv = OpenSSL.rand(OpenSSL.get_cipher(ciphername).get_blocksize())\n        ctx = Cipher(key_e, iv, 1, ciphername)\n        ciphertext = iv + pubkey + ctx.ciphering(data)\n        mac = hmac_sha256(key_m, ciphertext)\n        return ciphertext + mac\n\n    def decrypt(self, data, ciphername='aes-256-cbc'):\n        \"\"\"\n        Decrypt data with ECIES method using the local private key\n        \"\"\"\n        blocksize = OpenSSL.get_cipher(ciphername).get_blocksize()\n        iv = data[:blocksize]\n        i = blocksize\n        curve, pubkey_x, pubkey_y, i2 = ECC._decode_pubkey(data[i:])\n        i += i2\n        ciphertext = data[i:len(data)-32]\n        i += len(ciphertext)\n        mac = data[i:]\n        key = sha512(self.raw_get_ecdh_key(pubkey_x, pubkey_y)).digest()\n        key_e, key_m = key[:32], key[32:]\n        if not equals(hmac_sha256(key_m, data[:len(data) - 32]), mac):\n            raise RuntimeError(\"Fail to verify data\")\n        ctx = Cipher(key_e, iv, 0, ciphername)\n        return ctx.ciphering(ciphertext)\n", "comments": "        asymmetric encryption elliptic curve cryptography (ecc)     ecdh  ecdsa ecies          import pyelliptic          alice   pyelliptic ecc()   default curve  sect283r1         bob   pyelliptic ecc(curve  sect571r1 )          ciphertext   alice encrypt( hello bob   bob get pubkey())         print bob decrypt(ciphertext)          signature   bob sign( hello alice )           alice job           print pyelliptic ecc(             pubkey bob get pubkey()) verify(signature   hello alice )            error             try              key   alice get ecdh key(bob get pubkey())         except  print( for ecdh key agreement                         keys must defined curve   )          alice   pyelliptic ecc(curve  sect571r1 )         print alice get ecdh key(bob get pubkey()) encode( hex )         print bob get ecdh key(alice get pubkey()) encode( hex )              def   init  (self  pubkey none  privkey none  pubkey x none                   pubkey none  raw privkey none  curve  sect283r1 )                      for normal high level use  specifie pubkey          privkey (if need) curve                     type(curve)    str              self curve   openssl get curve(curve)         else              self curve   curve          pubkey x none pubkey none              self  set keys(pubkey x  pubkey  raw privkey)         elif pubkey none              curve  pubkey x  pubkey    ecc  decode pubkey(pubkey)             privkey none                  curve2  raw privkey    ecc  decode privkey(privkey)                 curve    curve2                      raise exception( bad ecc keys     )             self curve   curve             self  set keys(pubkey x  pubkey  raw privkey)         else              self privkey  self pubkey x  self pubkey   self  generate()      def  set keys(self  pubkey x  pubkey  privkey)          self raw check key(privkey  pubkey x  pubkey y)   0              self pubkey x   none             self pubkey   none             self privkey   none             raise exception( bad ecc keys     )         else              self pubkey x   pubkey x             self pubkey   pubkey             self privkey   privkey       staticmethod     def get curves()                      static method  returns list curves available                     return openssl curves keys()      def get curve(self)          return openssl get curve id(self curve)      def get curve id(self)          return self curve      def get pubkey(self)                      high level function returns           curve(2)   len pubkeyx(2)   pubkeyx   len pubkeyy   pubkeyy                     return b   join((pack(  h   self curve)                           pack(  h   len(self pubkey x))                           self pubkey x                           pack(  h   len(self pubkey y))                           self pubkey                          ))      def get privkey(self)                      high level function returns         curve(2)   len privkey(2)   privkey                     return b   join((pack(  h   self curve)                           pack(  h   len(self privkey))                           self privkey                          ))       staticmethod     def  decode pubkey(pubkey)            0         curve   unpack(  h   pubkey   2 ) 0             2         tmplen   unpack(  h   pubkey   2 ) 0             2         pubkey x   pubkey   tmplen             tmplen         tmplen   unpack(  h   pubkey   2 ) 0             2         pubkey   pubkey   tmplen             tmplen         return curve  pubkey x  pubkey        staticmethod     def  decode privkey(privkey)            0         curve   unpack(  h   privkey   2 ) 0             2         tmplen   unpack(  h   privkey   2 ) 0             2         privkey   privkey   tmplen             tmplen         return curve  privkey       def  generate(self)          try              pub key x   openssl bn new()             pub key   openssl bn new()              key   openssl ec key new curve name(self curve)             key    0                  raise exception(  openssl  ec key new curve name fail     )             (openssl ec key generate key(key))    0                  raise exception(  openssl  ec key generate key fail     )             (openssl ec key check key(key))    0                  raise exception(  openssl  ec key check key fail     )             priv key   openssl ec key get0 private key(key)              group   openssl ec key get0 group(key)             pub key   openssl ec key get0 public key(key)              (openssl ec point get affine coordinates gfp(group  pub key                                                              pub key x                                                              pub key  0                                                             ))    0                  raise exception(                       openssl  ec point get affine coordinates gfp fail     )              privkey   openssl malloc(0  openssl bn num bytes(priv key))             pubkeyx   openssl malloc(0  openssl bn num bytes(pub key x))             pubkeyy   openssl malloc(0  openssl bn num bytes(pub key y))             openssl bn bn2bin(priv key  privkey)             privkey   privkey raw             openssl bn bn2bin(pub key x  pubkeyx)             pubkeyx   pubkeyx raw             openssl bn bn2bin(pub key  pubkeyy)             pubkeyy   pubkeyy raw             self raw check key(privkey  pubkeyx  pubkeyy)              return privkey  pubkeyx  pubkeyy          finally              openssl ec key free(key)             openssl bn free(pub key x)             openssl bn free(pub key y)      def get ecdh key(self  pubkey)                      high level function  compute public key local private key         returns 512bits shared key                     curve  pubkey x  pubkey    ecc  decode pubkey(pubkey)         curve    self curve              raise exception( ecc keys must curve   )         return sha512(self raw get ecdh key(pubkey x  pubkey y)) digest()      def raw get ecdh key(self  pubkey x  pubkey y)          try              ecdh keybuffer   openssl malloc(0  32)              key   openssl ec key new curve name(self curve)             key    0                  raise exception(  openssl  ec key new curve name fail     )              pub key x   openssl bn bin2bn(pubkey x  len(pubkey x)  0)             pub key   openssl bn bin2bn(pubkey  len(pubkey y)  0)              group   openssl ec key get0 group(other key)             pub key   openssl ec point new(other group)              (openssl ec point set affine coordinates gfp(other group                                                              pub key                                                              pub key x                                                              pub key                                                              0))    0                  raise exception(                       openssl  ec point set affine coordinates gfp fail     )             (openssl ec key set public key(other key  pub key))    0                  raise exception(  openssl  ec key set public key fail     )             (openssl ec key check key(other key))    0                  raise exception(  openssl  ec key check key fail     )              key   openssl ec key new curve name(self curve)             key    0                  raise exception(  openssl  ec key new curve name fail     )             priv key   openssl bn bin2bn(                 self privkey  len(self privkey)  0)              (openssl ec key set private key(own key  priv key))    0                  raise exception(  openssl  ec key set private key fail     )              openssl  hexversion   0x10100000 openssl  libressl                  openssl ec key set method(own key  openssl ec key openssl())             else                  openssl ecdh set method(own key  openssl ecdh openssl())             ecdh keylen   openssl ecdh compute key(                 ecdh keybuffer  32  pub key  key  0)              ecdh keylen    32                  raise exception(  openssl  ecdh keylen fail     )              return ecdh keybuffer raw          finally              openssl ec key free(other key)             openssl bn free(other pub key x)             openssl bn free(other pub key y)             openssl ec point free(other pub key)             openssl ec key free(own key)             openssl bn free(own priv key)      def check key(self  privkey  pubkey)                      check public key private key          the private key optional (replace none)                     curve  pubkey x  pubkey    ecc  decode pubkey(pubkey)         privkey none              raw privkey   none             curve2   curve         else              curve2  raw privkey    ecc  decode privkey(privkey)         curve    curve2              raise exception( bad public private key )         return self raw check key(raw privkey  pubkey x  pubkey  curve)      def raw check key(self  privkey  pubkey x  pubkey  curve none)          curve none              curve   self curve         elif type(curve)    str              curve   openssl get curve(curve)         else              curve   curve         try              key   openssl ec key new curve name(curve)             key    0                  raise exception(  openssl  ec key new curve name fail     )             privkey none                  priv key   openssl bn bin2bn(privkey  len(privkey)  0)             pub key x   openssl bn bin2bn(pubkey x  len(pubkey x)  0)             pub key   openssl bn bin2bn(pubkey  len(pubkey y)  0)              privkey none                  (openssl ec key set private key(key  priv key))    0                      raise exception(                           openssl  ec key set private key fail     )              group   openssl ec key get0 group(key)             pub key   openssl ec point new(group)              (openssl ec point set affine coordinates gfp(group  pub key                                                              pub key x                                                              pub key                                                              0))    0                  raise exception(                       openssl  ec point set affine coordinates gfp fail     )             (openssl ec key set public key(key  pub key))    0                  raise exception(  openssl  ec key set public key fail     )             (openssl ec key check key(key))    0                  raise exception(  openssl  ec key check key fail     )             return 0          finally              openssl ec key free(key)             openssl bn free(pub key x)             openssl bn free(pub key y)             openssl ec point free(pub key)             privkey none                  openssl bn free(priv key)      def sign(self  inputb  digest alg openssl digest ecdsa sha1)                      sign input ecdsa method returns signature                     try              size   len(inputb)             buff   openssl malloc(inputb  size)             digest   openssl malloc(0  64)             openssl  hexversion   0x10100000 openssl  libressl                  md ctx   openssl evp md ctx new()             else                  md ctx   openssl evp md ctx create()             dgst len   openssl pointer(openssl c int(0))             siglen   openssl pointer(openssl c int(0))             sig   openssl malloc(0  151)              key   openssl ec key new curve name(self curve)             key    0                  raise exception(  openssl  ec key new curve name fail     )              priv key   openssl bn bin2bn(self privkey  len(self privkey)  0)             pub key x   openssl bn bin2bn(self pubkey x  len(self pubkey x)  0)             pub key   openssl bn bin2bn(self pubkey  len(self pubkey y)  0)              (openssl ec key set private key(key  priv key))    0                  raise exception(  openssl  ec key set private key fail     )              group   openssl ec key get0 group(key)             pub key   openssl ec point new(group)              (openssl ec point set affine coordinates gfp(group  pub key                                                              pub key x                                                              pub key                                                              0))    0                  raise exception(                       openssl  ec point set affine coordinates gfp fail     )             (openssl ec key set public key(key  pub key))    0                  raise exception(  openssl  ec key set public key fail     )             (openssl ec key check key(key))    0                  raise exception(  openssl  ec key check key fail     )              openssl  hexversion   0x10100000 openssl  libressl                  openssl evp md ctx new(md ctx)             else                  openssl evp md ctx init(md ctx)             openssl evp digestinit ex(md ctx  digest alg()  none)              (openssl evp digestupdate(md ctx  buff  size))    0                  raise exception(  openssl  evp digestupdate fail     )             openssl evp digestfinal ex(md ctx  digest  dgst len)             openssl ecdsa sign(0  digest  dgst len contents  sig  siglen  key)             (openssl ecdsa verify(0  digest  dgst len contents  sig                                       siglen contents  key))    1                  raise exception(  openssl  ecdsa verify fail     )              return sig raw  siglen contents value           finally              openssl ec key free(key)             openssl bn free(pub key x)             openssl bn free(pub key y)             openssl bn free(priv key)             openssl ec point free(pub key)             openssl  hexversion   0x10100000 openssl  libressl                  openssl evp md ctx free(md ctx)             else                  openssl evp md ctx destroy(md ctx)             pass      def verify(self  sig  inputb  digest alg openssl digest ecdsa sha1)                      verify signature input local public key          returns boolean                     try              bsig   openssl malloc(sig  len(sig))             binputb   openssl malloc(inputb  len(inputb))             digest   openssl malloc(0  64)             dgst len   openssl pointer(openssl c int(0))             openssl  hexversion   0x10100000 openssl  libressl                  md ctx   openssl evp md ctx new()             else                  md ctx   openssl evp md ctx create()             key   openssl ec key new curve name(self curve)              key    0                  raise exception(  openssl  ec key new curve name fail     )              pub key x   openssl bn bin2bn(self pubkey x  len(self pubkey x)  0)             pub key   openssl bn bin2bn(self pubkey  len(self pubkey y)  0)             group   openssl ec key get0 group(key)             pub key   openssl ec point new(group)              (openssl ec point set affine coordinates gfp(group  pub key                                                              pub key x                                                              pub key                                                              0))    0                  raise exception(                       openssl  ec point set affine coordinates gfp fail     )             (openssl ec key set public key(key  pub key))    0                  raise exception(  openssl  ec key set public key fail     )             (openssl ec key check key(key))    0                  raise exception(  openssl  ec key check key fail     )             openssl  hexversion   0x10100000 openssl  libressl                  openssl evp md ctx new(md ctx)             else                  openssl evp md ctx init(md ctx)             openssl evp digestinit ex(md ctx  digest alg()  none)             (openssl evp digestupdate(md ctx  binputb  len(inputb)))    0                  raise exception(  openssl  evp digestupdate fail     )              openssl evp digestfinal ex(md ctx  digest  dgst len)             ret   openssl ecdsa verify(                 0  digest  dgst len contents  bsig  len(sig)  key)              ret     1                  return false    fail check             else                  ret    0                      return false    bad signature                   else                      return true    good             return false          finally              openssl ec key free(key)             openssl bn free(pub key x)             openssl bn free(pub key y)             openssl ec point free(pub key)             openssl  hexversion   0x10100000 openssl  libressl                  openssl evp md ctx free(md ctx)             else                  openssl evp md ctx destroy(md ctx)       staticmethod     def encrypt(data  pubkey  ephemcurve none  ciphername  aes 256 cbc )                      encrypt data ecies method using public key recipient                      curve  pubkey x  pubkey    ecc  decode pubkey(pubkey)         return ecc raw encrypt(data  pubkey x  pubkey  curve curve                                 ephemcurve ephemcurve  ciphername ciphername)       staticmethod     def raw encrypt(data  pubkey x  pubkey  curve  sect283r1                       ephemcurve none  ciphername  aes 256 cbc )          ephemcurve none              ephemcurve   curve         ephem   ecc(curve ephemcurve)         key   sha512(ephem raw get ecdh key(pubkey x  pubkey y)) digest()         key e  key   key  32   key 32           pubkey   ephem get pubkey()         iv   openssl rand(openssl get cipher(ciphername) get blocksize())         ctx   cipher(key e  iv  1  ciphername)         ciphertext   iv   pubkey   ctx ciphering(data)         mac   hmac sha256(key  ciphertext)         return ciphertext   mac      def decrypt(self  data  ciphername  aes 256 cbc )                      decrypt data ecies method using local private key                 usr bin env python        coding  utf 8         copyright (c) 2011 yann guibet  yannguibet gmail com      see license details     default curve  sect283r1    alice job      error        fail check    bad signature      good ", "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n#  Copyright (C) 2011 Yann GUIBET <yannguibet@gmail.com>\n#  See LICENSE for details.\n\nfrom hashlib import sha512\nfrom pyelliptic.openssl import OpenSSL\nfrom pyelliptic.cipher import Cipher\nfrom pyelliptic.hash import hmac_sha256, equals\nfrom struct import pack, unpack\n\n\nclass ECC:\n    \"\"\"\n    Asymmetric encryption with Elliptic Curve Cryptography (ECC)\n    ECDH, ECDSA and ECIES\n\n        import pyelliptic\n\n        alice = pyelliptic.ECC() # default curve: sect283r1\n        bob = pyelliptic.ECC(curve='sect571r1')\n\n        ciphertext = alice.encrypt(\"Hello Bob\", bob.get_pubkey())\n        print bob.decrypt(ciphertext)\n\n        signature = bob.sign(\"Hello Alice\")\n        # alice's job :\n        print pyelliptic.ECC(\n            pubkey=bob.get_pubkey()).verify(signature, \"Hello Alice\")\n\n        # ERROR !!!\n        try:\n            key = alice.get_ecdh_key(bob.get_pubkey())\n        except: print(\"For ECDH key agreement,\\\n                      the keys must be defined on the same curve !\")\n\n        alice = pyelliptic.ECC(curve='sect571r1')\n        print alice.get_ecdh_key(bob.get_pubkey()).encode('hex')\n        print bob.get_ecdh_key(alice.get_pubkey()).encode('hex')\n\n    \"\"\"\n    def __init__(self, pubkey=None, privkey=None, pubkey_x=None,\n                 pubkey_y=None, raw_privkey=None, curve='sect283r1'):\n        \"\"\"\n        For a normal and High level use, specifie pubkey,\n        privkey (if you need) and the curve\n        \"\"\"\n        if type(curve) == str:\n            self.curve = OpenSSL.get_curve(curve)\n        else:\n            self.curve = curve\n\n        if pubkey_x is not None and pubkey_y is not None:\n            self._set_keys(pubkey_x, pubkey_y, raw_privkey)\n        elif pubkey is not None:\n            curve, pubkey_x, pubkey_y, i = ECC._decode_pubkey(pubkey)\n            if privkey is not None:\n                curve2, raw_privkey, i = ECC._decode_privkey(privkey)\n                if curve != curve2:\n                    raise Exception(\"Bad ECC keys ...\")\n            self.curve = curve\n            self._set_keys(pubkey_x, pubkey_y, raw_privkey)\n        else:\n            self.privkey, self.pubkey_x, self.pubkey_y = self._generate()\n\n    def _set_keys(self, pubkey_x, pubkey_y, privkey):\n        if self.raw_check_key(privkey, pubkey_x, pubkey_y) < 0:\n            self.pubkey_x = None\n            self.pubkey_y = None\n            self.privkey = None\n            raise Exception(\"Bad ECC keys ...\")\n        else:\n            self.pubkey_x = pubkey_x\n            self.pubkey_y = pubkey_y\n            self.privkey = privkey\n\n    @staticmethod\n    def get_curves():\n        \"\"\"\n        static method, returns the list of all the curves available\n        \"\"\"\n        return OpenSSL.curves.keys()\n\n    def get_curve(self):\n        return OpenSSL.get_curve_by_id(self.curve)\n\n    def get_curve_id(self):\n        return self.curve\n\n    def get_pubkey(self):\n        \"\"\"\n        High level function which returns :\n        curve(2) + len_of_pubkeyX(2) + pubkeyX + len_of_pubkeyY + pubkeyY\n        \"\"\"\n        return b''.join((pack('!H', self.curve),\n                         pack('!H', len(self.pubkey_x)),\n                         self.pubkey_x,\n                         pack('!H', len(self.pubkey_y)),\n                         self.pubkey_y\n                         ))\n\n    def get_privkey(self):\n        \"\"\"\n        High level function which returns\n        curve(2) + len_of_privkey(2) + privkey\n        \"\"\"\n        return b''.join((pack('!H', self.curve),\n                         pack('!H', len(self.privkey)),\n                         self.privkey\n                         ))\n\n    @staticmethod\n    def _decode_pubkey(pubkey):\n        i = 0\n        curve = unpack('!H', pubkey[i:i + 2])[0]\n        i += 2\n        tmplen = unpack('!H', pubkey[i:i + 2])[0]\n        i += 2\n        pubkey_x = pubkey[i:i + tmplen]\n        i += tmplen\n        tmplen = unpack('!H', pubkey[i:i + 2])[0]\n        i += 2\n        pubkey_y = pubkey[i:i + tmplen]\n        i += tmplen\n        return curve, pubkey_x, pubkey_y, i\n\n    @staticmethod\n    def _decode_privkey(privkey):\n        i = 0\n        curve = unpack('!H', privkey[i:i + 2])[0]\n        i += 2\n        tmplen = unpack('!H', privkey[i:i + 2])[0]\n        i += 2\n        privkey = privkey[i:i + tmplen]\n        i += tmplen\n        return curve, privkey, i\n\n    def _generate(self):\n        try:\n            pub_key_x = OpenSSL.BN_new()\n            pub_key_y = OpenSSL.BN_new()\n\n            key = OpenSSL.EC_KEY_new_by_curve_name(self.curve)\n            if key == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_new_by_curve_name FAIL ...\")\n            if (OpenSSL.EC_KEY_generate_key(key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_generate_key FAIL ...\")\n            if (OpenSSL.EC_KEY_check_key(key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_check_key FAIL ...\")\n            priv_key = OpenSSL.EC_KEY_get0_private_key(key)\n\n            group = OpenSSL.EC_KEY_get0_group(key)\n            pub_key = OpenSSL.EC_KEY_get0_public_key(key)\n\n            if (OpenSSL.EC_POINT_get_affine_coordinates_GFp(group, pub_key,\n                                                            pub_key_x,\n                                                            pub_key_y, 0\n                                                            )) == 0:\n                raise Exception(\n                    \"[OpenSSL] EC_POINT_get_affine_coordinates_GFp FAIL ...\")\n\n            privkey = OpenSSL.malloc(0, OpenSSL.BN_num_bytes(priv_key))\n            pubkeyx = OpenSSL.malloc(0, OpenSSL.BN_num_bytes(pub_key_x))\n            pubkeyy = OpenSSL.malloc(0, OpenSSL.BN_num_bytes(pub_key_y))\n            OpenSSL.BN_bn2bin(priv_key, privkey)\n            privkey = privkey.raw\n            OpenSSL.BN_bn2bin(pub_key_x, pubkeyx)\n            pubkeyx = pubkeyx.raw\n            OpenSSL.BN_bn2bin(pub_key_y, pubkeyy)\n            pubkeyy = pubkeyy.raw\n            self.raw_check_key(privkey, pubkeyx, pubkeyy)\n\n            return privkey, pubkeyx, pubkeyy\n\n        finally:\n            OpenSSL.EC_KEY_free(key)\n            OpenSSL.BN_free(pub_key_x)\n            OpenSSL.BN_free(pub_key_y)\n\n    def get_ecdh_key(self, pubkey):\n        \"\"\"\n        High level function. Compute public key with the local private key\n        and returns a 512bits shared key\n        \"\"\"\n        curve, pubkey_x, pubkey_y, i = ECC._decode_pubkey(pubkey)\n        if curve != self.curve:\n            raise Exception(\"ECC keys must be from the same curve !\")\n        return sha512(self.raw_get_ecdh_key(pubkey_x, pubkey_y)).digest()\n\n    def raw_get_ecdh_key(self, pubkey_x, pubkey_y):\n        try:\n            ecdh_keybuffer = OpenSSL.malloc(0, 32)\n\n            other_key = OpenSSL.EC_KEY_new_by_curve_name(self.curve)\n            if other_key == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_new_by_curve_name FAIL ...\")\n\n            other_pub_key_x = OpenSSL.BN_bin2bn(pubkey_x, len(pubkey_x), 0)\n            other_pub_key_y = OpenSSL.BN_bin2bn(pubkey_y, len(pubkey_y), 0)\n\n            other_group = OpenSSL.EC_KEY_get0_group(other_key)\n            other_pub_key = OpenSSL.EC_POINT_new(other_group)\n\n            if (OpenSSL.EC_POINT_set_affine_coordinates_GFp(other_group,\n                                                            other_pub_key,\n                                                            other_pub_key_x,\n                                                            other_pub_key_y,\n                                                            0)) == 0:\n                raise Exception(\n                    \"[OpenSSL] EC_POINT_set_affine_coordinates_GFp FAIL ...\")\n            if (OpenSSL.EC_KEY_set_public_key(other_key, other_pub_key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_set_public_key FAIL ...\")\n            if (OpenSSL.EC_KEY_check_key(other_key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_check_key FAIL ...\")\n\n            own_key = OpenSSL.EC_KEY_new_by_curve_name(self.curve)\n            if own_key == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_new_by_curve_name FAIL ...\")\n            own_priv_key = OpenSSL.BN_bin2bn(\n                self.privkey, len(self.privkey), 0)\n\n            if (OpenSSL.EC_KEY_set_private_key(own_key, own_priv_key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_set_private_key FAIL ...\")\n\n            if OpenSSL._hexversion > 0x10100000 and not OpenSSL._libreSSL:\n                OpenSSL.EC_KEY_set_method(own_key, OpenSSL.EC_KEY_OpenSSL())\n            else:\n                OpenSSL.ECDH_set_method(own_key, OpenSSL.ECDH_OpenSSL())\n            ecdh_keylen = OpenSSL.ECDH_compute_key(\n                ecdh_keybuffer, 32, other_pub_key, own_key, 0)\n\n            if ecdh_keylen != 32:\n                raise Exception(\"[OpenSSL] ECDH keylen FAIL ...\")\n\n            return ecdh_keybuffer.raw\n\n        finally:\n            OpenSSL.EC_KEY_free(other_key)\n            OpenSSL.BN_free(other_pub_key_x)\n            OpenSSL.BN_free(other_pub_key_y)\n            OpenSSL.EC_POINT_free(other_pub_key)\n            OpenSSL.EC_KEY_free(own_key)\n            OpenSSL.BN_free(own_priv_key)\n\n    def check_key(self, privkey, pubkey):\n        \"\"\"\n        Check the public key and the private key.\n        The private key is optional (replace by None)\n        \"\"\"\n        curve, pubkey_x, pubkey_y, i = ECC._decode_pubkey(pubkey)\n        if privkey is None:\n            raw_privkey = None\n            curve2 = curve\n        else:\n            curve2, raw_privkey, i = ECC._decode_privkey(privkey)\n        if curve != curve2:\n            raise Exception(\"Bad public and private key\")\n        return self.raw_check_key(raw_privkey, pubkey_x, pubkey_y, curve)\n\n    def raw_check_key(self, privkey, pubkey_x, pubkey_y, curve=None):\n        if curve is None:\n            curve = self.curve\n        elif type(curve) == str:\n            curve = OpenSSL.get_curve(curve)\n        else:\n            curve = curve\n        try:\n            key = OpenSSL.EC_KEY_new_by_curve_name(curve)\n            if key == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_new_by_curve_name FAIL ...\")\n            if privkey is not None:\n                priv_key = OpenSSL.BN_bin2bn(privkey, len(privkey), 0)\n            pub_key_x = OpenSSL.BN_bin2bn(pubkey_x, len(pubkey_x), 0)\n            pub_key_y = OpenSSL.BN_bin2bn(pubkey_y, len(pubkey_y), 0)\n\n            if privkey is not None:\n                if (OpenSSL.EC_KEY_set_private_key(key, priv_key)) == 0:\n                    raise Exception(\n                        \"[OpenSSL] EC_KEY_set_private_key FAIL ...\")\n\n            group = OpenSSL.EC_KEY_get0_group(key)\n            pub_key = OpenSSL.EC_POINT_new(group)\n\n            if (OpenSSL.EC_POINT_set_affine_coordinates_GFp(group, pub_key,\n                                                            pub_key_x,\n                                                            pub_key_y,\n                                                            0)) == 0:\n                raise Exception(\n                    \"[OpenSSL] EC_POINT_set_affine_coordinates_GFp FAIL ...\")\n            if (OpenSSL.EC_KEY_set_public_key(key, pub_key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_set_public_key FAIL ...\")\n            if (OpenSSL.EC_KEY_check_key(key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_check_key FAIL ...\")\n            return 0\n\n        finally:\n            OpenSSL.EC_KEY_free(key)\n            OpenSSL.BN_free(pub_key_x)\n            OpenSSL.BN_free(pub_key_y)\n            OpenSSL.EC_POINT_free(pub_key)\n            if privkey is not None:\n                OpenSSL.BN_free(priv_key)\n\n    def sign(self, inputb, digest_alg=OpenSSL.digest_ecdsa_sha1):\n        \"\"\"\n        Sign the input with ECDSA method and returns the signature\n        \"\"\"\n        try:\n            size = len(inputb)\n            buff = OpenSSL.malloc(inputb, size)\n            digest = OpenSSL.malloc(0, 64)\n            if OpenSSL._hexversion > 0x10100000 and not OpenSSL._libreSSL:\n                md_ctx = OpenSSL.EVP_MD_CTX_new()\n            else:\n                md_ctx = OpenSSL.EVP_MD_CTX_create()\n            dgst_len = OpenSSL.pointer(OpenSSL.c_int(0))\n            siglen = OpenSSL.pointer(OpenSSL.c_int(0))\n            sig = OpenSSL.malloc(0, 151)\n\n            key = OpenSSL.EC_KEY_new_by_curve_name(self.curve)\n            if key == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_new_by_curve_name FAIL ...\")\n\n            priv_key = OpenSSL.BN_bin2bn(self.privkey, len(self.privkey), 0)\n            pub_key_x = OpenSSL.BN_bin2bn(self.pubkey_x, len(self.pubkey_x), 0)\n            pub_key_y = OpenSSL.BN_bin2bn(self.pubkey_y, len(self.pubkey_y), 0)\n\n            if (OpenSSL.EC_KEY_set_private_key(key, priv_key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_set_private_key FAIL ...\")\n\n            group = OpenSSL.EC_KEY_get0_group(key)\n            pub_key = OpenSSL.EC_POINT_new(group)\n\n            if (OpenSSL.EC_POINT_set_affine_coordinates_GFp(group, pub_key,\n                                                            pub_key_x,\n                                                            pub_key_y,\n                                                            0)) == 0:\n                raise Exception(\n                    \"[OpenSSL] EC_POINT_set_affine_coordinates_GFp FAIL ...\")\n            if (OpenSSL.EC_KEY_set_public_key(key, pub_key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_set_public_key FAIL ...\")\n            if (OpenSSL.EC_KEY_check_key(key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_check_key FAIL ...\")\n\n            if OpenSSL._hexversion > 0x10100000 and not OpenSSL._libreSSL:\n                OpenSSL.EVP_MD_CTX_new(md_ctx)\n            else:\n                OpenSSL.EVP_MD_CTX_init(md_ctx)\n            OpenSSL.EVP_DigestInit_ex(md_ctx, digest_alg(), None)\n\n            if (OpenSSL.EVP_DigestUpdate(md_ctx, buff, size)) == 0:\n                raise Exception(\"[OpenSSL] EVP_DigestUpdate FAIL ...\")\n            OpenSSL.EVP_DigestFinal_ex(md_ctx, digest, dgst_len)\n            OpenSSL.ECDSA_sign(0, digest, dgst_len.contents, sig, siglen, key)\n            if (OpenSSL.ECDSA_verify(0, digest, dgst_len.contents, sig,\n                                     siglen.contents, key)) != 1:\n                raise Exception(\"[OpenSSL] ECDSA_verify FAIL ...\")\n\n            return sig.raw[:siglen.contents.value]\n\n        finally:\n            OpenSSL.EC_KEY_free(key)\n            OpenSSL.BN_free(pub_key_x)\n            OpenSSL.BN_free(pub_key_y)\n            OpenSSL.BN_free(priv_key)\n            OpenSSL.EC_POINT_free(pub_key)\n            if OpenSSL._hexversion > 0x10100000 and not OpenSSL._libreSSL:\n                OpenSSL.EVP_MD_CTX_free(md_ctx)\n            else:\n                OpenSSL.EVP_MD_CTX_destroy(md_ctx)\n            pass\n\n    def verify(self, sig, inputb, digest_alg=OpenSSL.digest_ecdsa_sha1):\n        \"\"\"\n        Verify the signature with the input and the local public key.\n        Returns a boolean\n        \"\"\"\n        try:\n            bsig = OpenSSL.malloc(sig, len(sig))\n            binputb = OpenSSL.malloc(inputb, len(inputb))\n            digest = OpenSSL.malloc(0, 64)\n            dgst_len = OpenSSL.pointer(OpenSSL.c_int(0))\n            if OpenSSL._hexversion > 0x10100000 and not OpenSSL._libreSSL:\n                md_ctx = OpenSSL.EVP_MD_CTX_new()\n            else:\n                md_ctx = OpenSSL.EVP_MD_CTX_create()\n            key = OpenSSL.EC_KEY_new_by_curve_name(self.curve)\n\n            if key == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_new_by_curve_name FAIL ...\")\n\n            pub_key_x = OpenSSL.BN_bin2bn(self.pubkey_x, len(self.pubkey_x), 0)\n            pub_key_y = OpenSSL.BN_bin2bn(self.pubkey_y, len(self.pubkey_y), 0)\n            group = OpenSSL.EC_KEY_get0_group(key)\n            pub_key = OpenSSL.EC_POINT_new(group)\n\n            if (OpenSSL.EC_POINT_set_affine_coordinates_GFp(group, pub_key,\n                                                            pub_key_x,\n                                                            pub_key_y,\n                                                            0)) == 0:\n                raise Exception(\n                    \"[OpenSSL] EC_POINT_set_affine_coordinates_GFp FAIL ...\")\n            if (OpenSSL.EC_KEY_set_public_key(key, pub_key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_set_public_key FAIL ...\")\n            if (OpenSSL.EC_KEY_check_key(key)) == 0:\n                raise Exception(\"[OpenSSL] EC_KEY_check_key FAIL ...\")\n            if OpenSSL._hexversion > 0x10100000 and not OpenSSL._libreSSL:\n                OpenSSL.EVP_MD_CTX_new(md_ctx)\n            else:\n                OpenSSL.EVP_MD_CTX_init(md_ctx)\n            OpenSSL.EVP_DigestInit_ex(md_ctx, digest_alg(), None)\n            if (OpenSSL.EVP_DigestUpdate(md_ctx, binputb, len(inputb))) == 0:\n                raise Exception(\"[OpenSSL] EVP_DigestUpdate FAIL ...\")\n\n            OpenSSL.EVP_DigestFinal_ex(md_ctx, digest, dgst_len)\n            ret = OpenSSL.ECDSA_verify(\n                0, digest, dgst_len.contents, bsig, len(sig), key)\n\n            if ret == -1:\n                return False  # Fail to Check\n            else:\n                if ret == 0:\n                    return False  # Bad signature !\n                else:\n                    return True  # Good\n            return False\n\n        finally:\n            OpenSSL.EC_KEY_free(key)\n            OpenSSL.BN_free(pub_key_x)\n            OpenSSL.BN_free(pub_key_y)\n            OpenSSL.EC_POINT_free(pub_key)\n            if OpenSSL._hexversion > 0x10100000 and not OpenSSL._libreSSL:\n                OpenSSL.EVP_MD_CTX_free(md_ctx)\n            else:\n                OpenSSL.EVP_MD_CTX_destroy(md_ctx)\n\n    @staticmethod\n    def encrypt(data, pubkey, ephemcurve=None, ciphername='aes-256-cbc'):\n        \"\"\"\n        Encrypt data with ECIES method using the public key of the recipient.\n        \"\"\"\n        curve, pubkey_x, pubkey_y, i = ECC._decode_pubkey(pubkey)\n        return ECC.raw_encrypt(data, pubkey_x, pubkey_y, curve=curve,\n                               ephemcurve=ephemcurve, ciphername=ciphername)\n\n    @staticmethod\n    def raw_encrypt(data, pubkey_x, pubkey_y, curve='sect283r1',\n                    ephemcurve=None, ciphername='aes-256-cbc'):\n        if ephemcurve is None:\n            ephemcurve = curve\n        ephem = ECC(curve=ephemcurve)\n        key = sha512(ephem.raw_get_ecdh_key(pubkey_x, pubkey_y)).digest()\n        key_e, key_m = key[:32], key[32:]\n        pubkey = ephem.get_pubkey()\n        iv = OpenSSL.rand(OpenSSL.get_cipher(ciphername).get_blocksize())\n        ctx = Cipher(key_e, iv, 1, ciphername)\n        ciphertext = iv + pubkey + ctx.ciphering(data)\n        mac = hmac_sha256(key_m, ciphertext)\n        return ciphertext + mac\n\n    def decrypt(self, data, ciphername='aes-256-cbc'):\n        \"\"\"\n        Decrypt data with ECIES method using the local private key\n        \"\"\"\n        blocksize = OpenSSL.get_cipher(ciphername).get_blocksize()\n        iv = data[:blocksize]\n        i = blocksize\n        curve, pubkey_x, pubkey_y, i2 = ECC._decode_pubkey(data[i:])\n        i += i2\n        ciphertext = data[i:len(data)-32]\n        i += len(ciphertext)\n        mac = data[i:]\n        key = sha512(self.raw_get_ecdh_key(pubkey_x, pubkey_y)).digest()\n        key_e, key_m = key[:32], key[32:]\n        if not equals(hmac_sha256(key_m, data[:len(data) - 32]), mac):\n            raise RuntimeError(\"Fail to verify data\")\n        ctx = Cipher(key_e, iv, 0, ciphername)\n        return ctx.ciphering(ciphertext)\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "ecc.py", "id": "09a712d0f742e8060d016142098e8a9b", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/lib/pyelliptic/ecc.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}