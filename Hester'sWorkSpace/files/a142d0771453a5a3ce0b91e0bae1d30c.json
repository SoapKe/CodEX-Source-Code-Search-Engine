{"author": "rg3", "code": "\n\n\nfrom __future__ import unicode_literals\n\n__license__ = 'Public Domain'\n\nimport codecs\nimport io\nimport os\nimport random\nimport sys\n\n\nfrom .options import (\n    parseOpts,\n)\nfrom .compat import (\n    compat_getpass,\n    compat_shlex_split,\n    workaround_optparse_bug9161,\n)\nfrom .utils import (\n    DateRange,\n    decodeOption,\n    DEFAULT_OUTTMPL,\n    DownloadError,\n    expand_path,\n    match_filter_func,\n    MaxDownloadsReached,\n    preferredencoding,\n    read_batch_urls,\n    SameFileError,\n    setproctitle,\n    std_headers,\n    write_string,\n    render_table,\n)\nfrom .update import update_self\nfrom .downloader import (\n    FileDownloader,\n)\nfrom .extractor import gen_extractors, list_extractors\nfrom .extractor.adobepass import MSO_INFO\nfrom .YoutubeDL import YoutubeDL\n\n\ndef _real_main(argv=None):\n    \n    if sys.platform == 'win32':\n        \n        codecs.register(lambda name: codecs.lookup('utf-8') if name == 'cp65001' else None)\n\n    workaround_optparse_bug9161()\n\n    setproctitle('youtube-dl')\n\n    parser, opts, args = parseOpts(argv)\n\n    \n    if opts.user_agent is not None:\n        std_headers['User-Agent'] = opts.user_agent\n\n    \n    if opts.referer is not None:\n        std_headers['Referer'] = opts.referer\n\n    \n    if opts.headers is not None:\n        for h in opts.headers:\n            if ':' not in h:\n                parser.error('wrong header formatting, it should be key:value, not \"%s\"' % h)\n            key, value = h.split(':', 1)\n            if opts.verbose:\n                write_string('[debug] Adding header from command line option %s:%s\\n' % (key, value))\n            std_headers[key] = value\n\n    \n    if opts.dump_user_agent:\n        write_string(std_headers['User-Agent'] + '\\n', out=sys.stdout)\n        sys.exit(0)\n\n    \n    batch_urls = []\n    if opts.batchfile is not None:\n        try:\n            if opts.batchfile == '-':\n                batchfd = sys.stdin\n            else:\n                batchfd = io.open(\n                    expand_path(opts.batchfile),\n                    'r', encoding='utf-8', errors='ignore')\n            batch_urls = read_batch_urls(batchfd)\n            if opts.verbose:\n                write_string('[debug] Batch file urls: ' + repr(batch_urls) + '\\n')\n        except IOError:\n            sys.exit('ERROR: batch file could not be read')\n    all_urls = batch_urls + [url.strip() for url in args]  \n    _enc = preferredencoding()\n    all_urls = [url.decode(_enc, 'ignore') if isinstance(url, bytes) else url for url in all_urls]\n\n    if opts.list_extractors:\n        for ie in list_extractors(opts.age_limit):\n            write_string(ie.IE_NAME + (' (CURRENTLY BROKEN)' if not ie._WORKING else '') + '\\n', out=sys.stdout)\n            matchedUrls = [url for url in all_urls if ie.suitable(url)]\n            for mu in matchedUrls:\n                write_string('  ' + mu + '\\n', out=sys.stdout)\n        sys.exit(0)\n    if opts.list_extractor_descriptions:\n        for ie in list_extractors(opts.age_limit):\n            if not ie._WORKING:\n                continue\n            desc = getattr(ie, 'IE_DESC', ie.IE_NAME)\n            if desc is False:\n                continue\n            if hasattr(ie, 'SEARCH_KEY'):\n                _SEARCHES = ('cute kittens', 'slithering pythons', 'falling cat', 'angry poodle', 'purple fish', 'running tortoise', 'sleeping bunny', 'burping cow')\n                _COUNTS = ('', '5', '10', 'all')\n                desc += ' (Example: \"%s%s:%s\" )' % (ie.SEARCH_KEY, random.choice(_COUNTS), random.choice(_SEARCHES))\n            write_string(desc + '\\n', out=sys.stdout)\n        sys.exit(0)\n    if opts.ap_list_mso:\n        table = [[mso_id, mso_info['name']] for mso_id, mso_info in MSO_INFO.items()]\n        write_string('Supported TV Providers:\\n' + render_table(['mso', 'mso name'], table) + '\\n', out=sys.stdout)\n        sys.exit(0)\n\n    \n    if opts.usenetrc and (opts.username is not None or opts.password is not None):\n        parser.error('using .netrc conflicts with giving username/password')\n    if opts.password is not None and opts.username is None:\n        parser.error('account username missing\\n')\n    if opts.ap_password is not None and opts.ap_username is None:\n        parser.error('TV Provider account username missing\\n')\n    if opts.outtmpl is not None and (opts.usetitle or opts.autonumber or opts.useid):\n        parser.error('using output template conflicts with using title, video ID or auto number')\n    if opts.autonumber_size is not None:\n        if opts.autonumber_size <= 0:\n            parser.error('auto number size must be positive')\n    if opts.autonumber_start is not None:\n        if opts.autonumber_start < 0:\n            parser.error('auto number start must be positive or 0')\n    if opts.usetitle and opts.useid:\n        parser.error('using title conflicts with using video ID')\n    if opts.username is not None and opts.password is None:\n        opts.password = compat_getpass('Type account password and press [Return]: ')\n    if opts.ap_username is not None and opts.ap_password is None:\n        opts.ap_password = compat_getpass('Type TV provider account password and press [Return]: ')\n    if opts.ratelimit is not None:\n        numeric_limit = FileDownloader.parse_bytes(opts.ratelimit)\n        if numeric_limit is None:\n            parser.error('invalid rate limit specified')\n        opts.ratelimit = numeric_limit\n    if opts.min_filesize is not None:\n        numeric_limit = FileDownloader.parse_bytes(opts.min_filesize)\n        if numeric_limit is None:\n            parser.error('invalid min_filesize specified')\n        opts.min_filesize = numeric_limit\n    if opts.max_filesize is not None:\n        numeric_limit = FileDownloader.parse_bytes(opts.max_filesize)\n        if numeric_limit is None:\n            parser.error('invalid max_filesize specified')\n        opts.max_filesize = numeric_limit\n    if opts.sleep_interval is not None:\n        if opts.sleep_interval < 0:\n            parser.error('sleep interval must be positive or 0')\n    if opts.max_sleep_interval is not None:\n        if opts.max_sleep_interval < 0:\n            parser.error('max sleep interval must be positive or 0')\n        if opts.max_sleep_interval < opts.sleep_interval:\n            parser.error('max sleep interval must be greater than or equal to min sleep interval')\n    else:\n        opts.max_sleep_interval = opts.sleep_interval\n    if opts.ap_mso and opts.ap_mso not in MSO_INFO:\n        parser.error('Unsupported TV Provider, use --ap-list-mso to get a list of supported TV Providers')\n\n    def parse_retries(retries):\n        if retries in ('inf', 'infinite'):\n            parsed_retries = float('inf')\n        else:\n            try:\n                parsed_retries = int(retries)\n            except (TypeError, ValueError):\n                parser.error('invalid retry count specified')\n        return parsed_retries\n    if opts.retries is not None:\n        opts.retries = parse_retries(opts.retries)\n    if opts.fragment_retries is not None:\n        opts.fragment_retries = parse_retries(opts.fragment_retries)\n    if opts.buffersize is not None:\n        numeric_buffersize = FileDownloader.parse_bytes(opts.buffersize)\n        if numeric_buffersize is None:\n            parser.error('invalid buffer size specified')\n        opts.buffersize = numeric_buffersize\n    if opts.http_chunk_size is not None:\n        numeric_chunksize = FileDownloader.parse_bytes(opts.http_chunk_size)\n        if not numeric_chunksize:\n            parser.error('invalid http chunk size specified')\n        opts.http_chunk_size = numeric_chunksize\n    if opts.playliststart <= 0:\n        raise ValueError('Playlist start must be positive')\n    if opts.playlistend not in (-1, None) and opts.playlistend < opts.playliststart:\n        raise ValueError('Playlist end must be greater than playlist start')\n    if opts.extractaudio:\n        if opts.audioformat not in ['best', 'aac', 'flac', 'mp3', 'm4a', 'opus', 'vorbis', 'wav']:\n            parser.error('invalid audio format specified')\n    if opts.audioquality:\n        opts.audioquality = opts.audioquality.strip('k').strip('K')\n        if not opts.audioquality.isdigit():\n            parser.error('invalid audio quality specified')\n    if opts.recodevideo is not None:\n        if opts.recodevideo not in ['mp4', 'flv', 'webm', 'ogg', 'mkv', 'avi']:\n            parser.error('invalid video recode format specified')\n    if opts.convertsubtitles is not None:\n        if opts.convertsubtitles not in ['srt', 'vtt', 'ass', 'lrc']:\n            parser.error('invalid subtitle format specified')\n\n    if opts.date is not None:\n        date = DateRange.day(opts.date)\n    else:\n        date = DateRange(opts.dateafter, opts.datebefore)\n\n    \n    if opts.extractaudio and not opts.keepvideo and opts.format is None:\n        opts.format = 'bestaudio/best'\n\n    \n    \n    if opts.allsubtitles and not opts.writeautomaticsub:\n        opts.writesubtitles = True\n\n    outtmpl = ((opts.outtmpl is not None and opts.outtmpl) or\n               (opts.format == '-1' and opts.usetitle and '%(title)s-%(id)s-%(format)s.%(ext)s') or\n               (opts.format == '-1' and '%(id)s-%(format)s.%(ext)s') or\n               (opts.usetitle and opts.autonumber and '%(autonumber)s-%(title)s-%(id)s.%(ext)s') or\n               (opts.usetitle and '%(title)s-%(id)s.%(ext)s') or\n               (opts.useid and '%(id)s.%(ext)s') or\n               (opts.autonumber and '%(autonumber)s-%(id)s.%(ext)s') or\n               DEFAULT_OUTTMPL)\n    if not os.path.splitext(outtmpl)[1] and opts.extractaudio:\n        parser.error('Cannot download a video and extract audio into the same'\n                     ' file! Use \"{0}.%(ext)s\" instead of \"{0}\" as the output'\n                     ' template'.format(outtmpl))\n\n    any_getting = opts.geturl or opts.gettitle or opts.getid or opts.getthumbnail or opts.getdescription or opts.getfilename or opts.getformat or opts.getduration or opts.dumpjson or opts.dump_single_json\n    any_printing = opts.print_json\n    download_archive_fn = expand_path(opts.download_archive) if opts.download_archive is not None else opts.download_archive\n\n    \n    postprocessors = []\n    if opts.metafromtitle:\n        postprocessors.append({\n            'key': 'MetadataFromTitle',\n            'titleformat': opts.metafromtitle\n        })\n    if opts.extractaudio:\n        postprocessors.append({\n            'key': 'FFmpegExtractAudio',\n            'preferredcodec': opts.audioformat,\n            'preferredquality': opts.audioquality,\n            'nopostoverwrites': opts.nopostoverwrites,\n        })\n    if opts.recodevideo:\n        postprocessors.append({\n            'key': 'FFmpegVideoConvertor',\n            'preferedformat': opts.recodevideo,\n        })\n    \n    \n    \n    \n    \n    \n    \n    \n    if opts.addmetadata:\n        postprocessors.append({'key': 'FFmpegMetadata'})\n    if opts.convertsubtitles:\n        postprocessors.append({\n            'key': 'FFmpegSubtitlesConvertor',\n            'format': opts.convertsubtitles,\n        })\n    if opts.embedsubtitles:\n        postprocessors.append({\n            'key': 'FFmpegEmbedSubtitle',\n        })\n    if opts.embedthumbnail:\n        already_have_thumbnail = opts.writethumbnail or opts.write_all_thumbnails\n        postprocessors.append({\n            'key': 'EmbedThumbnail',\n            'already_have_thumbnail': already_have_thumbnail\n        })\n        if not already_have_thumbnail:\n            opts.writethumbnail = True\n    \n    \n    if opts.xattrs:\n        postprocessors.append({'key': 'XAttrMetadata'})\n    \n    \n    if opts.exec_cmd:\n        postprocessors.append({\n            'key': 'ExecAfterDownload',\n            'exec_cmd': opts.exec_cmd,\n        })\n    external_downloader_args = None\n    if opts.external_downloader_args:\n        external_downloader_args = compat_shlex_split(opts.external_downloader_args)\n    postprocessor_args = None\n    if opts.postprocessor_args:\n        postprocessor_args = compat_shlex_split(opts.postprocessor_args)\n    match_filter = (\n        None if opts.match_filter is None\n        else match_filter_func(opts.match_filter))\n\n    ydl_opts = {\n        'usenetrc': opts.usenetrc,\n        'username': opts.username,\n        'password': opts.password,\n        'twofactor': opts.twofactor,\n        'videopassword': opts.videopassword,\n        'ap_mso': opts.ap_mso,\n        'ap_username': opts.ap_username,\n        'ap_password': opts.ap_password,\n        'quiet': (opts.quiet or any_getting or any_printing),\n        'no_warnings': opts.no_warnings,\n        'forceurl': opts.geturl,\n        'forcetitle': opts.gettitle,\n        'forceid': opts.getid,\n        'forcethumbnail': opts.getthumbnail,\n        'forcedescription': opts.getdescription,\n        'forceduration': opts.getduration,\n        'forcefilename': opts.getfilename,\n        'forceformat': opts.getformat,\n        'forcejson': opts.dumpjson or opts.print_json,\n        'dump_single_json': opts.dump_single_json,\n        'simulate': opts.simulate or any_getting,\n        'skip_download': opts.skip_download,\n        'format': opts.format,\n        'listformats': opts.listformats,\n        'outtmpl': outtmpl,\n        'autonumber_size': opts.autonumber_size,\n        'autonumber_start': opts.autonumber_start,\n        'restrictfilenames': opts.restrictfilenames,\n        'ignoreerrors': opts.ignoreerrors,\n        'force_generic_extractor': opts.force_generic_extractor,\n        'ratelimit': opts.ratelimit,\n        'nooverwrites': opts.nooverwrites,\n        'retries': opts.retries,\n        'fragment_retries': opts.fragment_retries,\n        'skip_unavailable_fragments': opts.skip_unavailable_fragments,\n        'keep_fragments': opts.keep_fragments,\n        'buffersize': opts.buffersize,\n        'noresizebuffer': opts.noresizebuffer,\n        'http_chunk_size': opts.http_chunk_size,\n        'continuedl': opts.continue_dl,\n        'noprogress': opts.noprogress,\n        'progress_with_newline': opts.progress_with_newline,\n        'playliststart': opts.playliststart,\n        'playlistend': opts.playlistend,\n        'playlistreverse': opts.playlist_reverse,\n        'playlistrandom': opts.playlist_random,\n        'noplaylist': opts.noplaylist,\n        'logtostderr': opts.outtmpl == '-',\n        'consoletitle': opts.consoletitle,\n        'nopart': opts.nopart,\n        'updatetime': opts.updatetime,\n        'writedescription': opts.writedescription,\n        'writeannotations': opts.writeannotations,\n        'writeinfojson': opts.writeinfojson,\n        'writethumbnail': opts.writethumbnail,\n        'write_all_thumbnails': opts.write_all_thumbnails,\n        'writesubtitles': opts.writesubtitles,\n        'writeautomaticsub': opts.writeautomaticsub,\n        'allsubtitles': opts.allsubtitles,\n        'listsubtitles': opts.listsubtitles,\n        'subtitlesformat': opts.subtitlesformat,\n        'subtitleslangs': opts.subtitleslangs,\n        'matchtitle': decodeOption(opts.matchtitle),\n        'rejecttitle': decodeOption(opts.rejecttitle),\n        'max_downloads': opts.max_downloads,\n        'prefer_free_formats': opts.prefer_free_formats,\n        'verbose': opts.verbose,\n        'dump_intermediate_pages': opts.dump_intermediate_pages,\n        'write_pages': opts.write_pages,\n        'test': opts.test,\n        'keepvideo': opts.keepvideo,\n        'min_filesize': opts.min_filesize,\n        'max_filesize': opts.max_filesize,\n        'min_views': opts.min_views,\n        'max_views': opts.max_views,\n        'daterange': date,\n        'cachedir': opts.cachedir,\n        'youtube_print_sig_code': opts.youtube_print_sig_code,\n        'age_limit': opts.age_limit,\n        'download_archive': download_archive_fn,\n        'cookiefile': opts.cookiefile,\n        'nocheckcertificate': opts.no_check_certificate,\n        'prefer_insecure': opts.prefer_insecure,\n        'proxy': opts.proxy,\n        'socket_timeout': opts.socket_timeout,\n        'bidi_workaround': opts.bidi_workaround,\n        'debug_printtraffic': opts.debug_printtraffic,\n        'prefer_ffmpeg': opts.prefer_ffmpeg,\n        'include_ads': opts.include_ads,\n        'default_search': opts.default_search,\n        'youtube_include_dash_manifest': opts.youtube_include_dash_manifest,\n        'encoding': opts.encoding,\n        'extract_flat': opts.extract_flat,\n        'mark_watched': opts.mark_watched,\n        'merge_output_format': opts.merge_output_format,\n        'postprocessors': postprocessors,\n        'fixup': opts.fixup,\n        'source_address': opts.source_address,\n        'call_home': opts.call_home,\n        'sleep_interval': opts.sleep_interval,\n        'max_sleep_interval': opts.max_sleep_interval,\n        'external_downloader': opts.external_downloader,\n        'list_thumbnails': opts.list_thumbnails,\n        'playlist_items': opts.playlist_items,\n        'xattr_set_filesize': opts.xattr_set_filesize,\n        'match_filter': match_filter,\n        'no_color': opts.no_color,\n        'ffmpeg_location': opts.ffmpeg_location,\n        'hls_prefer_native': opts.hls_prefer_native,\n        'hls_use_mpegts': opts.hls_use_mpegts,\n        'external_downloader_args': external_downloader_args,\n        'postprocessor_args': postprocessor_args,\n        'cn_verification_proxy': opts.cn_verification_proxy,\n        'geo_verification_proxy': opts.geo_verification_proxy,\n        'config_location': opts.config_location,\n        'geo_bypass': opts.geo_bypass,\n        'geo_bypass_country': opts.geo_bypass_country,\n        \n        'autonumber': opts.autonumber if opts.autonumber is True else None,\n        'usetitle': opts.usetitle if opts.usetitle is True else None,\n    }\n\n    with YoutubeDL(ydl_opts) as ydl:\n        \n        if opts.update_self:\n            update_self(ydl.to_screen, opts.verbose, ydl._opener)\n\n        \n        if opts.rm_cachedir:\n            ydl.cache.remove()\n\n        \n        if (len(all_urls) < 1) and (opts.load_info_filename is None):\n            if opts.update_self or opts.rm_cachedir:\n                sys.exit()\n\n            ydl.warn_if_short_id(sys.argv[1:] if argv is None else argv)\n            parser.error(\n                'You must provide at least one URL.\\n'\n                'Type youtube-dl --help to see a list of all options.')\n\n        try:\n            if opts.load_info_filename is not None:\n                retcode = ydl.download_with_info_file(expand_path(opts.load_info_filename))\n            else:\n                retcode = ydl.download(all_urls)\n        except MaxDownloadsReached:\n            ydl.to_screen('--max-download limit reached, aborting.')\n            retcode = 101\n\n    sys.exit(retcode)\n\n\ndef main(argv=None):\n    try:\n        _real_main(argv)\n    except DownloadError:\n        sys.exit(1)\n    except SameFileError:\n        sys.exit('ERROR: fixed output name but more than one file to download')\n    except KeyboardInterrupt:\n        sys.exit('\\nERROR: Interrupted by user')\n\n\n__all__ = ['main', 'YoutubeDL', 'gen_extractors', 'list_extractors']\n", "comments": "#!/usr/bin/env python\n# coding: utf-8\n# Compatibility fixes for Windows\n# https://github.com/rg3/youtube-dl/issues/820\n# Set user agent\n# Set referer\n# Custom HTTP headers\n# Dump user agent\n# Batch file verification\n# batch_urls are already striped in read_batch_urls\n# Conflicting, missing and erroneous options\n# Do not download videos when there are audio-only formats\n# --all-sub automatically sets --write-sub if --write-auto-sub is not given\n# this was the old behaviour if only --all-sub was given.\n# PostProcessors\n# FFmpegMetadataPP should be run after FFmpegVideoConvertorPP and\n# FFmpegExtractAudioPP as containers before conversion may not support\n# metadata (3gp, webm, etc.)\n# And this post-processor should be placed before other metadata\n# manipulating post-processors (FFmpegEmbedSubtitle) to prevent loss of\n# extra metadata. By default ffmpeg preserves metadata applicable for both\n# source and target containers. From this point the container won't change,\n# so metadata can be added here.\n# XAttrMetadataPP should be run after post-processors that may change file\n# contents\n# Please keep ExecAfterDownload towards the bottom as it allows the user to modify the final file in any way.\n# So if the user is able to remove the file before your postprocessor runs it might cause a few problems.\n# just for deprecation check\n# Update version\n# Remove cache dir\n# Maybe do nothing\n", "content": "#!/usr/bin/env python\n# coding: utf-8\n\nfrom __future__ import unicode_literals\n\n__license__ = 'Public Domain'\n\nimport codecs\nimport io\nimport os\nimport random\nimport sys\n\n\nfrom .options import (\n    parseOpts,\n)\nfrom .compat import (\n    compat_getpass,\n    compat_shlex_split,\n    workaround_optparse_bug9161,\n)\nfrom .utils import (\n    DateRange,\n    decodeOption,\n    DEFAULT_OUTTMPL,\n    DownloadError,\n    expand_path,\n    match_filter_func,\n    MaxDownloadsReached,\n    preferredencoding,\n    read_batch_urls,\n    SameFileError,\n    setproctitle,\n    std_headers,\n    write_string,\n    render_table,\n)\nfrom .update import update_self\nfrom .downloader import (\n    FileDownloader,\n)\nfrom .extractor import gen_extractors, list_extractors\nfrom .extractor.adobepass import MSO_INFO\nfrom .YoutubeDL import YoutubeDL\n\n\ndef _real_main(argv=None):\n    # Compatibility fixes for Windows\n    if sys.platform == 'win32':\n        # https://github.com/rg3/youtube-dl/issues/820\n        codecs.register(lambda name: codecs.lookup('utf-8') if name == 'cp65001' else None)\n\n    workaround_optparse_bug9161()\n\n    setproctitle('youtube-dl')\n\n    parser, opts, args = parseOpts(argv)\n\n    # Set user agent\n    if opts.user_agent is not None:\n        std_headers['User-Agent'] = opts.user_agent\n\n    # Set referer\n    if opts.referer is not None:\n        std_headers['Referer'] = opts.referer\n\n    # Custom HTTP headers\n    if opts.headers is not None:\n        for h in opts.headers:\n            if ':' not in h:\n                parser.error('wrong header formatting, it should be key:value, not \"%s\"' % h)\n            key, value = h.split(':', 1)\n            if opts.verbose:\n                write_string('[debug] Adding header from command line option %s:%s\\n' % (key, value))\n            std_headers[key] = value\n\n    # Dump user agent\n    if opts.dump_user_agent:\n        write_string(std_headers['User-Agent'] + '\\n', out=sys.stdout)\n        sys.exit(0)\n\n    # Batch file verification\n    batch_urls = []\n    if opts.batchfile is not None:\n        try:\n            if opts.batchfile == '-':\n                batchfd = sys.stdin\n            else:\n                batchfd = io.open(\n                    expand_path(opts.batchfile),\n                    'r', encoding='utf-8', errors='ignore')\n            batch_urls = read_batch_urls(batchfd)\n            if opts.verbose:\n                write_string('[debug] Batch file urls: ' + repr(batch_urls) + '\\n')\n        except IOError:\n            sys.exit('ERROR: batch file could not be read')\n    all_urls = batch_urls + [url.strip() for url in args]  # batch_urls are already striped in read_batch_urls\n    _enc = preferredencoding()\n    all_urls = [url.decode(_enc, 'ignore') if isinstance(url, bytes) else url for url in all_urls]\n\n    if opts.list_extractors:\n        for ie in list_extractors(opts.age_limit):\n            write_string(ie.IE_NAME + (' (CURRENTLY BROKEN)' if not ie._WORKING else '') + '\\n', out=sys.stdout)\n            matchedUrls = [url for url in all_urls if ie.suitable(url)]\n            for mu in matchedUrls:\n                write_string('  ' + mu + '\\n', out=sys.stdout)\n        sys.exit(0)\n    if opts.list_extractor_descriptions:\n        for ie in list_extractors(opts.age_limit):\n            if not ie._WORKING:\n                continue\n            desc = getattr(ie, 'IE_DESC', ie.IE_NAME)\n            if desc is False:\n                continue\n            if hasattr(ie, 'SEARCH_KEY'):\n                _SEARCHES = ('cute kittens', 'slithering pythons', 'falling cat', 'angry poodle', 'purple fish', 'running tortoise', 'sleeping bunny', 'burping cow')\n                _COUNTS = ('', '5', '10', 'all')\n                desc += ' (Example: \"%s%s:%s\" )' % (ie.SEARCH_KEY, random.choice(_COUNTS), random.choice(_SEARCHES))\n            write_string(desc + '\\n', out=sys.stdout)\n        sys.exit(0)\n    if opts.ap_list_mso:\n        table = [[mso_id, mso_info['name']] for mso_id, mso_info in MSO_INFO.items()]\n        write_string('Supported TV Providers:\\n' + render_table(['mso', 'mso name'], table) + '\\n', out=sys.stdout)\n        sys.exit(0)\n\n    # Conflicting, missing and erroneous options\n    if opts.usenetrc and (opts.username is not None or opts.password is not None):\n        parser.error('using .netrc conflicts with giving username/password')\n    if opts.password is not None and opts.username is None:\n        parser.error('account username missing\\n')\n    if opts.ap_password is not None and opts.ap_username is None:\n        parser.error('TV Provider account username missing\\n')\n    if opts.outtmpl is not None and (opts.usetitle or opts.autonumber or opts.useid):\n        parser.error('using output template conflicts with using title, video ID or auto number')\n    if opts.autonumber_size is not None:\n        if opts.autonumber_size <= 0:\n            parser.error('auto number size must be positive')\n    if opts.autonumber_start is not None:\n        if opts.autonumber_start < 0:\n            parser.error('auto number start must be positive or 0')\n    if opts.usetitle and opts.useid:\n        parser.error('using title conflicts with using video ID')\n    if opts.username is not None and opts.password is None:\n        opts.password = compat_getpass('Type account password and press [Return]: ')\n    if opts.ap_username is not None and opts.ap_password is None:\n        opts.ap_password = compat_getpass('Type TV provider account password and press [Return]: ')\n    if opts.ratelimit is not None:\n        numeric_limit = FileDownloader.parse_bytes(opts.ratelimit)\n        if numeric_limit is None:\n            parser.error('invalid rate limit specified')\n        opts.ratelimit = numeric_limit\n    if opts.min_filesize is not None:\n        numeric_limit = FileDownloader.parse_bytes(opts.min_filesize)\n        if numeric_limit is None:\n            parser.error('invalid min_filesize specified')\n        opts.min_filesize = numeric_limit\n    if opts.max_filesize is not None:\n        numeric_limit = FileDownloader.parse_bytes(opts.max_filesize)\n        if numeric_limit is None:\n            parser.error('invalid max_filesize specified')\n        opts.max_filesize = numeric_limit\n    if opts.sleep_interval is not None:\n        if opts.sleep_interval < 0:\n            parser.error('sleep interval must be positive or 0')\n    if opts.max_sleep_interval is not None:\n        if opts.max_sleep_interval < 0:\n            parser.error('max sleep interval must be positive or 0')\n        if opts.max_sleep_interval < opts.sleep_interval:\n            parser.error('max sleep interval must be greater than or equal to min sleep interval')\n    else:\n        opts.max_sleep_interval = opts.sleep_interval\n    if opts.ap_mso and opts.ap_mso not in MSO_INFO:\n        parser.error('Unsupported TV Provider, use --ap-list-mso to get a list of supported TV Providers')\n\n    def parse_retries(retries):\n        if retries in ('inf', 'infinite'):\n            parsed_retries = float('inf')\n        else:\n            try:\n                parsed_retries = int(retries)\n            except (TypeError, ValueError):\n                parser.error('invalid retry count specified')\n        return parsed_retries\n    if opts.retries is not None:\n        opts.retries = parse_retries(opts.retries)\n    if opts.fragment_retries is not None:\n        opts.fragment_retries = parse_retries(opts.fragment_retries)\n    if opts.buffersize is not None:\n        numeric_buffersize = FileDownloader.parse_bytes(opts.buffersize)\n        if numeric_buffersize is None:\n            parser.error('invalid buffer size specified')\n        opts.buffersize = numeric_buffersize\n    if opts.http_chunk_size is not None:\n        numeric_chunksize = FileDownloader.parse_bytes(opts.http_chunk_size)\n        if not numeric_chunksize:\n            parser.error('invalid http chunk size specified')\n        opts.http_chunk_size = numeric_chunksize\n    if opts.playliststart <= 0:\n        raise ValueError('Playlist start must be positive')\n    if opts.playlistend not in (-1, None) and opts.playlistend < opts.playliststart:\n        raise ValueError('Playlist end must be greater than playlist start')\n    if opts.extractaudio:\n        if opts.audioformat not in ['best', 'aac', 'flac', 'mp3', 'm4a', 'opus', 'vorbis', 'wav']:\n            parser.error('invalid audio format specified')\n    if opts.audioquality:\n        opts.audioquality = opts.audioquality.strip('k').strip('K')\n        if not opts.audioquality.isdigit():\n            parser.error('invalid audio quality specified')\n    if opts.recodevideo is not None:\n        if opts.recodevideo not in ['mp4', 'flv', 'webm', 'ogg', 'mkv', 'avi']:\n            parser.error('invalid video recode format specified')\n    if opts.convertsubtitles is not None:\n        if opts.convertsubtitles not in ['srt', 'vtt', 'ass', 'lrc']:\n            parser.error('invalid subtitle format specified')\n\n    if opts.date is not None:\n        date = DateRange.day(opts.date)\n    else:\n        date = DateRange(opts.dateafter, opts.datebefore)\n\n    # Do not download videos when there are audio-only formats\n    if opts.extractaudio and not opts.keepvideo and opts.format is None:\n        opts.format = 'bestaudio/best'\n\n    # --all-sub automatically sets --write-sub if --write-auto-sub is not given\n    # this was the old behaviour if only --all-sub was given.\n    if opts.allsubtitles and not opts.writeautomaticsub:\n        opts.writesubtitles = True\n\n    outtmpl = ((opts.outtmpl is not None and opts.outtmpl) or\n               (opts.format == '-1' and opts.usetitle and '%(title)s-%(id)s-%(format)s.%(ext)s') or\n               (opts.format == '-1' and '%(id)s-%(format)s.%(ext)s') or\n               (opts.usetitle and opts.autonumber and '%(autonumber)s-%(title)s-%(id)s.%(ext)s') or\n               (opts.usetitle and '%(title)s-%(id)s.%(ext)s') or\n               (opts.useid and '%(id)s.%(ext)s') or\n               (opts.autonumber and '%(autonumber)s-%(id)s.%(ext)s') or\n               DEFAULT_OUTTMPL)\n    if not os.path.splitext(outtmpl)[1] and opts.extractaudio:\n        parser.error('Cannot download a video and extract audio into the same'\n                     ' file! Use \"{0}.%(ext)s\" instead of \"{0}\" as the output'\n                     ' template'.format(outtmpl))\n\n    any_getting = opts.geturl or opts.gettitle or opts.getid or opts.getthumbnail or opts.getdescription or opts.getfilename or opts.getformat or opts.getduration or opts.dumpjson or opts.dump_single_json\n    any_printing = opts.print_json\n    download_archive_fn = expand_path(opts.download_archive) if opts.download_archive is not None else opts.download_archive\n\n    # PostProcessors\n    postprocessors = []\n    if opts.metafromtitle:\n        postprocessors.append({\n            'key': 'MetadataFromTitle',\n            'titleformat': opts.metafromtitle\n        })\n    if opts.extractaudio:\n        postprocessors.append({\n            'key': 'FFmpegExtractAudio',\n            'preferredcodec': opts.audioformat,\n            'preferredquality': opts.audioquality,\n            'nopostoverwrites': opts.nopostoverwrites,\n        })\n    if opts.recodevideo:\n        postprocessors.append({\n            'key': 'FFmpegVideoConvertor',\n            'preferedformat': opts.recodevideo,\n        })\n    # FFmpegMetadataPP should be run after FFmpegVideoConvertorPP and\n    # FFmpegExtractAudioPP as containers before conversion may not support\n    # metadata (3gp, webm, etc.)\n    # And this post-processor should be placed before other metadata\n    # manipulating post-processors (FFmpegEmbedSubtitle) to prevent loss of\n    # extra metadata. By default ffmpeg preserves metadata applicable for both\n    # source and target containers. From this point the container won't change,\n    # so metadata can be added here.\n    if opts.addmetadata:\n        postprocessors.append({'key': 'FFmpegMetadata'})\n    if opts.convertsubtitles:\n        postprocessors.append({\n            'key': 'FFmpegSubtitlesConvertor',\n            'format': opts.convertsubtitles,\n        })\n    if opts.embedsubtitles:\n        postprocessors.append({\n            'key': 'FFmpegEmbedSubtitle',\n        })\n    if opts.embedthumbnail:\n        already_have_thumbnail = opts.writethumbnail or opts.write_all_thumbnails\n        postprocessors.append({\n            'key': 'EmbedThumbnail',\n            'already_have_thumbnail': already_have_thumbnail\n        })\n        if not already_have_thumbnail:\n            opts.writethumbnail = True\n    # XAttrMetadataPP should be run after post-processors that may change file\n    # contents\n    if opts.xattrs:\n        postprocessors.append({'key': 'XAttrMetadata'})\n    # Please keep ExecAfterDownload towards the bottom as it allows the user to modify the final file in any way.\n    # So if the user is able to remove the file before your postprocessor runs it might cause a few problems.\n    if opts.exec_cmd:\n        postprocessors.append({\n            'key': 'ExecAfterDownload',\n            'exec_cmd': opts.exec_cmd,\n        })\n    external_downloader_args = None\n    if opts.external_downloader_args:\n        external_downloader_args = compat_shlex_split(opts.external_downloader_args)\n    postprocessor_args = None\n    if opts.postprocessor_args:\n        postprocessor_args = compat_shlex_split(opts.postprocessor_args)\n    match_filter = (\n        None if opts.match_filter is None\n        else match_filter_func(opts.match_filter))\n\n    ydl_opts = {\n        'usenetrc': opts.usenetrc,\n        'username': opts.username,\n        'password': opts.password,\n        'twofactor': opts.twofactor,\n        'videopassword': opts.videopassword,\n        'ap_mso': opts.ap_mso,\n        'ap_username': opts.ap_username,\n        'ap_password': opts.ap_password,\n        'quiet': (opts.quiet or any_getting or any_printing),\n        'no_warnings': opts.no_warnings,\n        'forceurl': opts.geturl,\n        'forcetitle': opts.gettitle,\n        'forceid': opts.getid,\n        'forcethumbnail': opts.getthumbnail,\n        'forcedescription': opts.getdescription,\n        'forceduration': opts.getduration,\n        'forcefilename': opts.getfilename,\n        'forceformat': opts.getformat,\n        'forcejson': opts.dumpjson or opts.print_json,\n        'dump_single_json': opts.dump_single_json,\n        'simulate': opts.simulate or any_getting,\n        'skip_download': opts.skip_download,\n        'format': opts.format,\n        'listformats': opts.listformats,\n        'outtmpl': outtmpl,\n        'autonumber_size': opts.autonumber_size,\n        'autonumber_start': opts.autonumber_start,\n        'restrictfilenames': opts.restrictfilenames,\n        'ignoreerrors': opts.ignoreerrors,\n        'force_generic_extractor': opts.force_generic_extractor,\n        'ratelimit': opts.ratelimit,\n        'nooverwrites': opts.nooverwrites,\n        'retries': opts.retries,\n        'fragment_retries': opts.fragment_retries,\n        'skip_unavailable_fragments': opts.skip_unavailable_fragments,\n        'keep_fragments': opts.keep_fragments,\n        'buffersize': opts.buffersize,\n        'noresizebuffer': opts.noresizebuffer,\n        'http_chunk_size': opts.http_chunk_size,\n        'continuedl': opts.continue_dl,\n        'noprogress': opts.noprogress,\n        'progress_with_newline': opts.progress_with_newline,\n        'playliststart': opts.playliststart,\n        'playlistend': opts.playlistend,\n        'playlistreverse': opts.playlist_reverse,\n        'playlistrandom': opts.playlist_random,\n        'noplaylist': opts.noplaylist,\n        'logtostderr': opts.outtmpl == '-',\n        'consoletitle': opts.consoletitle,\n        'nopart': opts.nopart,\n        'updatetime': opts.updatetime,\n        'writedescription': opts.writedescription,\n        'writeannotations': opts.writeannotations,\n        'writeinfojson': opts.writeinfojson,\n        'writethumbnail': opts.writethumbnail,\n        'write_all_thumbnails': opts.write_all_thumbnails,\n        'writesubtitles': opts.writesubtitles,\n        'writeautomaticsub': opts.writeautomaticsub,\n        'allsubtitles': opts.allsubtitles,\n        'listsubtitles': opts.listsubtitles,\n        'subtitlesformat': opts.subtitlesformat,\n        'subtitleslangs': opts.subtitleslangs,\n        'matchtitle': decodeOption(opts.matchtitle),\n        'rejecttitle': decodeOption(opts.rejecttitle),\n        'max_downloads': opts.max_downloads,\n        'prefer_free_formats': opts.prefer_free_formats,\n        'verbose': opts.verbose,\n        'dump_intermediate_pages': opts.dump_intermediate_pages,\n        'write_pages': opts.write_pages,\n        'test': opts.test,\n        'keepvideo': opts.keepvideo,\n        'min_filesize': opts.min_filesize,\n        'max_filesize': opts.max_filesize,\n        'min_views': opts.min_views,\n        'max_views': opts.max_views,\n        'daterange': date,\n        'cachedir': opts.cachedir,\n        'youtube_print_sig_code': opts.youtube_print_sig_code,\n        'age_limit': opts.age_limit,\n        'download_archive': download_archive_fn,\n        'cookiefile': opts.cookiefile,\n        'nocheckcertificate': opts.no_check_certificate,\n        'prefer_insecure': opts.prefer_insecure,\n        'proxy': opts.proxy,\n        'socket_timeout': opts.socket_timeout,\n        'bidi_workaround': opts.bidi_workaround,\n        'debug_printtraffic': opts.debug_printtraffic,\n        'prefer_ffmpeg': opts.prefer_ffmpeg,\n        'include_ads': opts.include_ads,\n        'default_search': opts.default_search,\n        'youtube_include_dash_manifest': opts.youtube_include_dash_manifest,\n        'encoding': opts.encoding,\n        'extract_flat': opts.extract_flat,\n        'mark_watched': opts.mark_watched,\n        'merge_output_format': opts.merge_output_format,\n        'postprocessors': postprocessors,\n        'fixup': opts.fixup,\n        'source_address': opts.source_address,\n        'call_home': opts.call_home,\n        'sleep_interval': opts.sleep_interval,\n        'max_sleep_interval': opts.max_sleep_interval,\n        'external_downloader': opts.external_downloader,\n        'list_thumbnails': opts.list_thumbnails,\n        'playlist_items': opts.playlist_items,\n        'xattr_set_filesize': opts.xattr_set_filesize,\n        'match_filter': match_filter,\n        'no_color': opts.no_color,\n        'ffmpeg_location': opts.ffmpeg_location,\n        'hls_prefer_native': opts.hls_prefer_native,\n        'hls_use_mpegts': opts.hls_use_mpegts,\n        'external_downloader_args': external_downloader_args,\n        'postprocessor_args': postprocessor_args,\n        'cn_verification_proxy': opts.cn_verification_proxy,\n        'geo_verification_proxy': opts.geo_verification_proxy,\n        'config_location': opts.config_location,\n        'geo_bypass': opts.geo_bypass,\n        'geo_bypass_country': opts.geo_bypass_country,\n        # just for deprecation check\n        'autonumber': opts.autonumber if opts.autonumber is True else None,\n        'usetitle': opts.usetitle if opts.usetitle is True else None,\n    }\n\n    with YoutubeDL(ydl_opts) as ydl:\n        # Update version\n        if opts.update_self:\n            update_self(ydl.to_screen, opts.verbose, ydl._opener)\n\n        # Remove cache dir\n        if opts.rm_cachedir:\n            ydl.cache.remove()\n\n        # Maybe do nothing\n        if (len(all_urls) < 1) and (opts.load_info_filename is None):\n            if opts.update_self or opts.rm_cachedir:\n                sys.exit()\n\n            ydl.warn_if_short_id(sys.argv[1:] if argv is None else argv)\n            parser.error(\n                'You must provide at least one URL.\\n'\n                'Type youtube-dl --help to see a list of all options.')\n\n        try:\n            if opts.load_info_filename is not None:\n                retcode = ydl.download_with_info_file(expand_path(opts.load_info_filename))\n            else:\n                retcode = ydl.download(all_urls)\n        except MaxDownloadsReached:\n            ydl.to_screen('--max-download limit reached, aborting.')\n            retcode = 101\n\n    sys.exit(retcode)\n\n\ndef main(argv=None):\n    try:\n        _real_main(argv)\n    except DownloadError:\n        sys.exit(1)\n    except SameFileError:\n        sys.exit('ERROR: fixed output name but more than one file to download')\n    except KeyboardInterrupt:\n        sys.exit('\\nERROR: Interrupted by user')\n\n\n__all__ = ['main', 'YoutubeDL', 'gen_extractors', 'list_extractors']\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "__init__.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/__init__.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}