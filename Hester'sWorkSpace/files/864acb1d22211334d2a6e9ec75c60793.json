{"author": "mwaskom", "code": "import numpy as np\nimport pandas as pd\nimport scipy\nfrom scipy import stats, spatial\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import rgb2hex\n\nfrom distutils.version import LooseVersion\n\nimport nose.tools as nt\nimport numpy.testing as npt\nfrom numpy.testing.decorators import skipif\n\nfrom .. import categorical as cat\nfrom .. import palettes\n\n\npandas_has_categoricals = LooseVersion(pd.__version__) >= \"0.15\"\nmpl_barplot_change = LooseVersion(\"2.0.1\")\n\n\nclass CategoricalFixture(object):\n    \"\"\"Test boxplot (also base class for things like violinplots).\"\"\"\n    rs = np.random.RandomState(30)\n    n_total = 60\n    x = rs.randn(int(n_total / 3), 3)\n    x_df = pd.DataFrame(x, columns=pd.Series(list(\"XYZ\"), name=\"big\"))\n    y = pd.Series(rs.randn(n_total), name=\"y_data\")\n    g = pd.Series(np.repeat(list(\"abc\"), int(n_total / 3)), name=\"small\")\n    h = pd.Series(np.tile(list(\"mn\"), int(n_total / 2)), name=\"medium\")\n    u = pd.Series(np.tile(list(\"jkh\"), int(n_total / 3)))\n    df = pd.DataFrame(dict(y=y, g=g, h=h, u=u))\n    x_df[\"W\"] = g\n\n\nclass TestCategoricalPlotter(CategoricalFixture):\n\n    def test_wide_df_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        \n        p.establish_variables(data=self.x_df)\n\n        \n        for x, y, in zip(p.plot_data, self.x_df[[\"X\", \"Y\", \"Z\"]].values.T):\n            npt.assert_array_equal(x, y)\n\n        \n        nt.assert_equal(p.orient, \"v\")\n        nt.assert_is(p.plot_hues, None)\n        nt.assert_is(p.group_label, \"big\")\n        nt.assert_is(p.value_label, None)\n\n        \n        p.establish_variables(data=self.x_df, orient=\"horiz\")\n        nt.assert_equal(p.orient, \"h\")\n\n        \n        with nt.assert_raises(ValueError):\n            p.establish_variables(hue=\"d\", data=self.x_df)\n\n    def test_1d_input_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        \n        x_1d_array = self.x.ravel()\n        p.establish_variables(data=x_1d_array)\n        nt.assert_equal(len(p.plot_data), 1)\n        nt.assert_equal(len(p.plot_data[0]), self.n_total)\n        nt.assert_is(p.group_label, None)\n        nt.assert_is(p.value_label, None)\n\n         in list form\n        x_1d_list = x_1d_array.tolist()\n        p.establish_variables(data=x_1d_list)\n        nt.assert_equal(len(p.plot_data), 1)\n        nt.assert_equal(len(p.plot_data[0]), self.n_total)\n        nt.assert_is(p.group_label, None)\n        nt.assert_is(p.value_label, None)\n\n        \n        x_notreally_1d = np.array([self.x.ravel(),\n                                   self.x.ravel()[:int(self.n_total / 2)]])\n        p.establish_variables(data=x_notreally_1d)\n        nt.assert_equal(len(p.plot_data), 2)\n        nt.assert_equal(len(p.plot_data[0]), self.n_total)\n        nt.assert_equal(len(p.plot_data[1]), self.n_total / 2)\n        nt.assert_is(p.group_label, None)\n        nt.assert_is(p.value_label, None)\n\n    def test_2d_input_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        x = self.x[:, 0]\n\n        \n        p.establish_variables(data=x[:, np.newaxis])\n        nt.assert_equal(len(p.plot_data), 1)\n        nt.assert_equal(len(p.plot_data[0]), self.x.shape[0])\n        nt.assert_is(p.group_label, None)\n        nt.assert_is(p.value_label, None)\n\n        \n        p.establish_variables(data=x[np.newaxis, :])\n        nt.assert_equal(len(p.plot_data), 1)\n        nt.assert_equal(len(p.plot_data[0]), self.x.shape[0])\n        nt.assert_is(p.group_label, None)\n        nt.assert_is(p.value_label, None)\n\n    def test_3d_input_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        \n        x = np.zeros((5, 5, 5))\n        with nt.assert_raises(ValueError):\n            p.establish_variables(data=x)\n\n    def test_list_of_array_input_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        \n        x_list = self.x.T.tolist()\n        p.establish_variables(data=x_list)\n        nt.assert_equal(len(p.plot_data), 3)\n\n        lengths = [len(v_i) for v_i in p.plot_data]\n        nt.assert_equal(lengths, [self.n_total / 3] * 3)\n\n        nt.assert_is(p.group_label, None)\n        nt.assert_is(p.value_label, None)\n\n    def test_wide_array_input_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        \n        p.establish_variables(data=self.x)\n        nt.assert_equal(np.shape(p.plot_data), (3, self.n_total / 3))\n        npt.assert_array_equal(p.plot_data, self.x.T)\n\n        nt.assert_is(p.group_label, None)\n        nt.assert_is(p.value_label, None)\n\n    def test_single_long_direct_inputs(self):\n\n        p = cat._CategoricalPlotter()\n\n        \n        p.establish_variables(x=self.y)\n        npt.assert_equal(p.plot_data, [self.y])\n        nt.assert_equal(p.orient, \"h\")\n        nt.assert_equal(p.value_label, \"y_data\")\n        nt.assert_is(p.group_label, None)\n\n        \n        p.establish_variables(y=self.y)\n        npt.assert_equal(p.plot_data, [self.y])\n        nt.assert_equal(p.orient, \"v\")\n        nt.assert_equal(p.value_label, \"y_data\")\n        nt.assert_is(p.group_label, None)\n\n        \n        p.establish_variables(y=self.y.values)\n        npt.assert_equal(p.plot_data, [self.y])\n        nt.assert_equal(p.orient, \"v\")\n        nt.assert_is(p.value_label, None)\n        nt.assert_is(p.group_label, None)\n\n    def test_single_long_indirect_inputs(self):\n\n        p = cat._CategoricalPlotter()\n\n        \n        p.establish_variables(x=\"y\", data=self.df)\n        npt.assert_equal(p.plot_data, [self.y])\n        nt.assert_equal(p.orient, \"h\")\n        nt.assert_equal(p.value_label, \"y\")\n        nt.assert_is(p.group_label, None)\n\n        \n        p.establish_variables(y=\"y\", data=self.df)\n        npt.assert_equal(p.plot_data, [self.y])\n        nt.assert_equal(p.orient, \"v\")\n        nt.assert_equal(p.value_label, \"y\")\n        nt.assert_is(p.group_label, None)\n\n    def test_longform_groupby(self):\n\n        p = cat._CategoricalPlotter()\n\n        \n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(len(p.plot_data), 3)\n        nt.assert_equal(len(p.plot_hues), 3)\n        nt.assert_equal(p.orient, \"v\")\n        nt.assert_equal(p.value_label, \"y\")\n        nt.assert_equal(p.group_label, \"g\")\n        nt.assert_equal(p.hue_title, \"h\")\n\n        for group, vals in zip([\"a\", \"b\", \"c\"], p.plot_data):\n            npt.assert_array_equal(vals, self.y[self.g == group])\n\n        for group, hues in zip([\"a\", \"b\", \"c\"], p.plot_hues):\n            npt.assert_array_equal(hues, self.h[self.g == group])\n\n        \n        p.establish_variables(\"g\", self.y.values, \"h\", self.df)\n        nt.assert_is(p.value_label, None)\n        nt.assert_equal(p.group_label, \"g\")\n\n        for group, vals in zip([\"a\", \"b\", \"c\"], p.plot_data):\n            npt.assert_array_equal(vals, self.y[self.g == group])\n\n        \n        p.establish_variables(\"g\", \"y\", self.h.values, self.df)\n\n        for group, hues in zip([\"a\", \"b\", \"c\"], p.plot_hues):\n            npt.assert_array_equal(hues, self.h[self.g == group])\n\n        \n        if pandas_has_categoricals:\n            df = self.df.copy()\n            df.g = df.g.astype(\"category\")\n\n            \n            p.establish_variables(\"y\", \"g\", \"h\", data=df)\n            nt.assert_equal(len(p.plot_data), 3)\n            nt.assert_equal(len(p.plot_hues), 3)\n            nt.assert_equal(p.orient, \"h\")\n            nt.assert_equal(p.value_label, \"y\")\n            nt.assert_equal(p.group_label, \"g\")\n            nt.assert_equal(p.hue_title, \"h\")\n\n            for group, vals in zip([\"a\", \"b\", \"c\"], p.plot_data):\n                npt.assert_array_equal(vals, self.y[self.g == group])\n\n            for group, hues in zip([\"a\", \"b\", \"c\"], p.plot_hues):\n                npt.assert_array_equal(hues, self.h[self.g == group])\n\n    def test_input_validation(self):\n\n        p = cat._CategoricalPlotter()\n\n        kws = dict(x=\"g\", y=\"y\", hue=\"h\", units=\"u\", data=self.df)\n        for input in [\"x\", \"y\", \"hue\", \"units\"]:\n            input_kws = kws.copy()\n            input_kws[input] = \"bad_input\"\n            with nt.assert_raises(ValueError):\n                p.establish_variables(**input_kws)\n\n    def test_order(self):\n\n        p = cat._CategoricalPlotter()\n\n        \n        p.establish_variables(data=self.x_df)\n        nt.assert_equal(p.group_names, [\"X\", \"Y\", \"Z\"])\n\n        \n        p.establish_variables(data=self.x_df, order=[\"Y\", \"Z\", \"X\"])\n        nt.assert_equal(p.group_names, [\"Y\", \"Z\", \"X\"])\n\n        for group, vals in zip([\"Y\", \"Z\", \"X\"], p.plot_data):\n            npt.assert_array_equal(vals, self.x_df[group])\n\n        with nt.assert_raises(ValueError):\n            p.establish_variables(data=self.x, order=[1, 2, 0])\n\n        \n        p.establish_variables(\"g\", \"y\", data=self.df)\n        nt.assert_equal(p.group_names, [\"a\", \"b\", \"c\"])\n\n        \n        p.establish_variables(\"g\", \"y\", data=self.df, order=[\"b\", \"a\", \"c\"])\n        nt.assert_equal(p.group_names, [\"b\", \"a\", \"c\"])\n\n        for group, vals in zip([\"b\", \"a\", \"c\"], p.plot_data):\n            npt.assert_array_equal(vals, self.y[self.g == group])\n\n        \n        if pandas_has_categoricals:\n            df = self.df.copy()\n            df.g = df.g.astype(\"category\")\n            df.g = df.g.cat.reorder_categories([\"c\", \"b\", \"a\"])\n            p.establish_variables(\"g\", \"y\", data=df)\n            nt.assert_equal(p.group_names, [\"c\", \"b\", \"a\"])\n\n            for group, vals in zip([\"c\", \"b\", \"a\"], p.plot_data):\n                npt.assert_array_equal(vals, self.y[self.g == group])\n\n            df.g = (df.g.cat.add_categories(\"d\")\n                        .cat.reorder_categories([\"c\", \"b\", \"d\", \"a\"]))\n            p.establish_variables(\"g\", \"y\", data=df)\n            nt.assert_equal(p.group_names, [\"c\", \"b\", \"d\", \"a\"])\n\n    def test_hue_order(self):\n\n        p = cat._CategoricalPlotter()\n\n        \n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(p.hue_names, [\"m\", \"n\"])\n\n        \n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df,\n                              hue_order=[\"n\", \"m\"])\n        nt.assert_equal(p.hue_names, [\"n\", \"m\"])\n\n         from a categorical hue input\n        if pandas_has_categoricals:\n            df = self.df.copy()\n            df.h = df.h.astype(\"category\")\n            df.h = df.h.cat.reorder_categories([\"n\", \"m\"])\n            p.establish_variables(\"g\", \"y\", \"h\", data=df)\n            nt.assert_equal(p.hue_names, [\"n\", \"m\"])\n\n            df.h = (df.h.cat.add_categories(\"o\")\n                        .cat.reorder_categories([\"o\", \"m\", \"n\"]))\n            p.establish_variables(\"g\", \"y\", \"h\", data=df)\n            nt.assert_equal(p.hue_names, [\"o\", \"m\", \"n\"])\n\n    def test_plot_units(self):\n\n        p = cat._CategoricalPlotter()\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_is(p.plot_units, None)\n\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df, units=\"u\")\n        for group, units in zip([\"a\", \"b\", \"c\"], p.plot_units):\n            npt.assert_array_equal(units, self.u[self.g == group])\n\n    def test_infer_orient(self):\n\n        p = cat._CategoricalPlotter()\n\n        cats = pd.Series([\"a\", \"b\", \"c\"] * 10)\n        nums = pd.Series(self.rs.randn(30))\n\n        nt.assert_equal(p.infer_orient(cats, nums), \"v\")\n        nt.assert_equal(p.infer_orient(nums, cats), \"h\")\n        nt.assert_equal(p.infer_orient(nums, None), \"h\")\n        nt.assert_equal(p.infer_orient(None, nums), \"v\")\n        nt.assert_equal(p.infer_orient(nums, nums, \"vert\"), \"v\")\n        nt.assert_equal(p.infer_orient(nums, nums, \"hori\"), \"h\")\n\n        with nt.assert_raises(ValueError):\n            p.infer_orient(cats, cats)\n\n        if pandas_has_categoricals:\n            cats = pd.Series([0, 1, 2] * 10, dtype=\"category\")\n            nt.assert_equal(p.infer_orient(cats, nums), \"v\")\n            nt.assert_equal(p.infer_orient(nums, cats), \"h\")\n\n            with nt.assert_raises(ValueError):\n                p.infer_orient(cats, cats)\n\n    def test_default_palettes(self):\n\n        p = cat._CategoricalPlotter()\n\n        \n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(None, None, 1)\n        nt.assert_equal(p.colors, palettes.color_palette(n_colors=3))\n\n        \n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        p.establish_colors(None, None, 1)\n        nt.assert_equal(p.colors, palettes.color_palette(n_colors=2))\n\n    def test_default_palette_with_many_levels(self):\n\n        with palettes.color_palette([\"blue\", \"red\"], 2):\n            p = cat._CategoricalPlotter()\n            p.establish_variables(\"g\", \"y\", data=self.df)\n            p.establish_colors(None, None, 1)\n            npt.assert_array_equal(p.colors, palettes.husl_palette(3, l=.7))\n\n    def test_specific_color(self):\n\n        p = cat._CategoricalPlotter()\n\n        \n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(\"blue\", None, 1)\n        blue_rgb = mpl.colors.colorConverter.to_rgb(\"blue\")\n        nt.assert_equal(p.colors, [blue_rgb] * 3)\n\n        \n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        p.establish_colors(\"#ff0022\", None, 1)\n        rgba_array = np.array(palettes.light_palette(\"#ff0022\", 2))\n        npt.assert_array_almost_equal(p.colors,\n                                      rgba_array[:, :3])\n\n    def test_specific_palette(self):\n\n        p = cat._CategoricalPlotter()\n\n        \n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(None, \"dark\", 1)\n        nt.assert_equal(p.colors, palettes.color_palette(\"dark\", 3))\n\n        \n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        p.establish_colors(None, \"muted\", 1)\n        nt.assert_equal(p.colors, palettes.color_palette(\"muted\", 2))\n\n        \n        p = cat._CategoricalPlotter()\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(\"blue\", \"deep\", 1)\n        nt.assert_equal(p.colors, palettes.color_palette(\"deep\", 3))\n\n    def test_dict_as_palette(self):\n\n        p = cat._CategoricalPlotter()\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        pal = {\"m\": (0, 0, 1), \"n\": (1, 0, 0)}\n        p.establish_colors(None, pal, 1)\n        nt.assert_equal(p.colors, [(0, 0, 1), (1, 0, 0)])\n\n    def test_palette_desaturation(self):\n\n        p = cat._CategoricalPlotter()\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors((0, 0, 1), None, .5)\n        nt.assert_equal(p.colors, [(.25, .25, .75)] * 3)\n\n        p.establish_colors(None, [(0, 0, 1), (1, 0, 0), \"w\"], .5)\n        nt.assert_equal(p.colors, [(.25, .25, .75),\n                                   (.75, .25, .25),\n                                   (1, 1, 1)])\n\n\nclass TestCategoricalStatPlotter(CategoricalFixture):\n\n    def test_no_bootstrappig(self):\n\n        p = cat._CategoricalStatPlotter()\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.estimate_statistic(np.mean, None, 100)\n        npt.assert_array_equal(p.confint, np.array([]))\n\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        p.estimate_statistic(np.mean, None, 100)\n        npt.assert_array_equal(p.confint, np.array([[], [], []]))\n\n    def test_single_layer_stats(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n\n        p.establish_variables(g, y)\n        p.estimate_statistic(np.mean, 95, 10000)\n\n        nt.assert_equal(p.statistic.shape, (3,))\n        nt.assert_equal(p.confint.shape, (3, 2))\n\n        npt.assert_array_almost_equal(p.statistic,\n                                      y.groupby(g).mean())\n\n        for ci, (_, grp_y) in zip(p.confint, y.groupby(g)):\n            sem = stats.sem(grp_y)\n            mean = grp_y.mean()\n            stats.norm.ppf(.975)\n            half_ci = stats.norm.ppf(.975) * sem\n            ci_want = mean - half_ci, mean + half_ci\n            npt.assert_array_almost_equal(ci_want, ci, 2)\n\n    def test_single_layer_stats_with_units(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 90))\n        y = pd.Series(np.random.RandomState(0).randn(270))\n        u = pd.Series(np.repeat(np.tile(list(\"xyz\"), 30), 3))\n        y[u == \"x\"] -= 3\n        y[u == \"y\"] += 3\n\n        p.establish_variables(g, y)\n        p.estimate_statistic(np.mean, 95, 10000)\n        stat1, ci1 = p.statistic, p.confint\n\n        p.establish_variables(g, y, units=u)\n        p.estimate_statistic(np.mean, 95, 10000)\n        stat2, ci2 = p.statistic, p.confint\n\n        npt.assert_array_equal(stat1, stat2)\n        ci1_size = ci1[:, 1] - ci1[:, 0]\n        ci2_size = ci2[:, 1] - ci2[:, 0]\n        npt.assert_array_less(ci1_size, ci2_size)\n\n    def test_single_layer_stats_with_missing_data(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n\n        p.establish_variables(g, y, order=list(\"abdc\"))\n        p.estimate_statistic(np.mean, 95, 10000)\n\n        nt.assert_equal(p.statistic.shape, (4,))\n        nt.assert_equal(p.confint.shape, (4, 2))\n\n        mean = y[g == \"b\"].mean()\n        sem = stats.sem(y[g == \"b\"])\n        half_ci = stats.norm.ppf(.975) * sem\n        ci = mean - half_ci, mean + half_ci\n        npt.assert_almost_equal(p.statistic[1], mean)\n        npt.assert_array_almost_equal(p.confint[1], ci, 2)\n\n        npt.assert_equal(p.statistic[2], np.nan)\n        npt.assert_array_equal(p.confint[2], (np.nan, np.nan))\n\n    def test_nested_stats(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        h = pd.Series(np.tile(list(\"xy\"), 150))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n\n        p.establish_variables(g, y, h)\n        p.estimate_statistic(np.mean, 95, 50000)\n\n        nt.assert_equal(p.statistic.shape, (3, 2))\n        nt.assert_equal(p.confint.shape, (3, 2, 2))\n\n        npt.assert_array_almost_equal(p.statistic,\n                                      y.groupby([g, h]).mean().unstack())\n\n        for ci_g, (_, grp_y) in zip(p.confint, y.groupby(g)):\n            for ci, hue_y in zip(ci_g, [grp_y[::2], grp_y[1::2]]):\n                sem = stats.sem(hue_y)\n                mean = hue_y.mean()\n                half_ci = stats.norm.ppf(.975) * sem\n                ci_want = mean - half_ci, mean + half_ci\n                npt.assert_array_almost_equal(ci_want, ci, 2)\n\n    def test_nested_stats_with_units(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 90))\n        h = pd.Series(np.tile(list(\"xy\"), 135))\n        u = pd.Series(np.repeat(list(\"ijkijk\"), 45))\n        y = pd.Series(np.random.RandomState(0).randn(270))\n        y[u == \"i\"] -= 3\n        y[u == \"k\"] += 3\n\n        p.establish_variables(g, y, h)\n        p.estimate_statistic(np.mean, 95, 10000)\n        stat1, ci1 = p.statistic, p.confint\n\n        p.establish_variables(g, y, h, units=u)\n        p.estimate_statistic(np.mean, 95, 10000)\n        stat2, ci2 = p.statistic, p.confint\n\n        npt.assert_array_equal(stat1, stat2)\n        ci1_size = ci1[:, 0, 1] - ci1[:, 0, 0]\n        ci2_size = ci2[:, 0, 1] - ci2[:, 0, 0]\n        npt.assert_array_less(ci1_size, ci2_size)\n\n    def test_nested_stats_with_missing_data(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n        h = pd.Series(np.tile(list(\"xy\"), 150))\n\n        p.establish_variables(g, y, h,\n                              order=list(\"abdc\"),\n                              hue_order=list(\"zyx\"))\n        p.estimate_statistic(np.mean, 95, 50000)\n\n        nt.assert_equal(p.statistic.shape, (4, 3))\n        nt.assert_equal(p.confint.shape, (4, 3, 2))\n\n        mean = y[(g == \"b\") & (h == \"x\")].mean()\n        sem = stats.sem(y[(g == \"b\") & (h == \"x\")])\n        half_ci = stats.norm.ppf(.975) * sem\n        ci = mean - half_ci, mean + half_ci\n        npt.assert_almost_equal(p.statistic[1, 2], mean)\n        npt.assert_array_almost_equal(p.confint[1, 2], ci, 2)\n\n        npt.assert_array_equal(p.statistic[:, 0], [np.nan] * 4)\n        npt.assert_array_equal(p.statistic[2], [np.nan] * 3)\n        npt.assert_array_equal(p.confint[:, 0],\n                               np.zeros((4, 2)) * np.nan)\n        npt.assert_array_equal(p.confint[2],\n                               np.zeros((3, 2)) * np.nan)\n\n    def test_sd_error_bars(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n\n        p.establish_variables(g, y)\n        p.estimate_statistic(np.mean, \"sd\", None)\n\n        nt.assert_equal(p.statistic.shape, (3,))\n        nt.assert_equal(p.confint.shape, (3, 2))\n\n        npt.assert_array_almost_equal(p.statistic,\n                                      y.groupby(g).mean())\n\n        for ci, (_, grp_y) in zip(p.confint, y.groupby(g)):\n            mean = grp_y.mean()\n            half_ci = np.std(grp_y)\n            ci_want = mean - half_ci, mean + half_ci\n            npt.assert_array_almost_equal(ci_want, ci, 2)\n\n    def test_nested_sd_error_bars(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        h = pd.Series(np.tile(list(\"xy\"), 150))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n\n        p.establish_variables(g, y, h)\n        p.estimate_statistic(np.mean, \"sd\", None)\n\n        nt.assert_equal(p.statistic.shape, (3, 2))\n        nt.assert_equal(p.confint.shape, (3, 2, 2))\n\n        npt.assert_array_almost_equal(p.statistic,\n                                      y.groupby([g, h]).mean().unstack())\n\n        for ci_g, (_, grp_y) in zip(p.confint, y.groupby(g)):\n            for ci, hue_y in zip(ci_g, [grp_y[::2], grp_y[1::2]]):\n                mean = hue_y.mean()\n                half_ci = np.std(hue_y)\n                ci_want = mean - half_ci, mean + half_ci\n                npt.assert_array_almost_equal(ci_want, ci, 2)\n\n    def test_draw_cis(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        \n        p.orient = \"v\"\n\n        f, ax = plt.subplots()\n        at_group = [0, 1]\n        confints = [(.5, 1.5), (.25, .8)]\n        colors = [\".2\", \".3\"]\n        p.draw_confints(ax, at_group, confints, colors)\n\n        lines = ax.lines\n        for line, at, ci, c in zip(lines, at_group, confints, colors):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, [at, at])\n            npt.assert_array_equal(y, ci)\n            nt.assert_equal(line.get_color(), c)\n\n        plt.close(\"all\")\n\n        \n        p.orient = \"h\"\n\n        f, ax = plt.subplots()\n        p.draw_confints(ax, at_group, confints, colors)\n\n        lines = ax.lines\n        for line, at, ci, c in zip(lines, at_group, confints, colors):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, ci)\n            npt.assert_array_equal(y, [at, at])\n            nt.assert_equal(line.get_color(), c)\n\n        plt.close(\"all\")\n\n         with endcaps\n        p.orient = \"v\"\n\n        f, ax = plt.subplots()\n        p.draw_confints(ax, at_group, confints, colors, capsize=0.3)\n        capline = ax.lines[len(ax.lines) - 1]\n        caplinestart = capline.get_xdata()[0]\n        caplineend = capline.get_xdata()[1]\n        caplinelength = abs(caplineend - caplinestart)\n        nt.assert_almost_equal(caplinelength, 0.3)\n        nt.assert_equal(len(ax.lines), 6)\n\n        plt.close(\"all\")\n\n         with endcaps\n        p.orient = \"h\"\n\n        f, ax = plt.subplots()\n        p.draw_confints(ax, at_group, confints, colors, capsize=0.3)\n        capline = ax.lines[len(ax.lines) - 1]\n        caplinestart = capline.get_ydata()[0]\n        caplineend = capline.get_ydata()[1]\n        caplinelength = abs(caplineend - caplinestart)\n        nt.assert_almost_equal(caplinelength, 0.3)\n        nt.assert_equal(len(ax.lines), 6)\n\n        \n        f, ax = plt.subplots()\n        p.draw_confints(ax, at_group, confints, colors, lw=4)\n        line = ax.lines[0]\n        nt.assert_equal(line.get_linewidth(), 4)\n\n        plt.close(\"all\")\n\n        \n        f, ax = plt.subplots()\n        p.draw_confints(ax, at_group, confints, colors, errwidth=2)\n        capline = ax.lines[len(ax.lines)-1]\n        nt.assert_equal(capline._linewidth, 2)\n        nt.assert_equal(len(ax.lines), 2)\n\n        plt.close(\"all\")\n\n\nclass TestBoxPlotter(CategoricalFixture):\n\n    default_kws = dict(x=None, y=None, hue=None, data=None,\n                       order=None, hue_order=None,\n                       orient=None, color=None, palette=None,\n                       saturation=.75, width=.8, dodge=True,\n                       fliersize=5, linewidth=None)\n\n    def test_nested_width(self):\n\n        kws = self.default_kws.copy()\n        p = cat._BoxPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(p.nested_width, .4 * .98)\n\n        kws = self.default_kws.copy()\n        kws[\"width\"] = .6\n        p = cat._BoxPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(p.nested_width, .3 * .98)\n\n        kws = self.default_kws.copy()\n        kws[\"dodge\"] = False\n        p = cat._BoxPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(p.nested_width, .8)\n\n    def test_hue_offsets(self):\n\n        p = cat._BoxPlotter(**self.default_kws)\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        npt.assert_array_equal(p.hue_offsets, [-.2, .2])\n\n        kws = self.default_kws.copy()\n        kws[\"width\"] = .6\n        p = cat._BoxPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        npt.assert_array_equal(p.hue_offsets, [-.15, .15])\n\n        p = cat._BoxPlotter(**kws)\n        p.establish_variables(\"h\", \"y\", \"g\", data=self.df)\n        npt.assert_array_almost_equal(p.hue_offsets, [-.2, 0, .2])\n\n    def test_axes_data(self):\n\n        ax = cat.boxplot(\"g\", \"y\", data=self.df)\n        nt.assert_equal(len(ax.artists), 3)\n\n        plt.close(\"all\")\n\n        ax = cat.boxplot(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(len(ax.artists), 6)\n\n        plt.close(\"all\")\n\n    def test_box_colors(self):\n\n        ax = cat.boxplot(\"g\", \"y\", data=self.df, saturation=1)\n        pal = palettes.color_palette(n_colors=3)\n        for patch, color in zip(ax.artists, pal):\n            nt.assert_equal(patch.get_facecolor()[:3], color)\n\n        plt.close(\"all\")\n\n        ax = cat.boxplot(\"g\", \"y\", \"h\", data=self.df, saturation=1)\n        pal = palettes.color_palette(n_colors=2)\n        for patch, color in zip(ax.artists, pal * 2):\n            nt.assert_equal(patch.get_facecolor()[:3], color)\n\n        plt.close(\"all\")\n\n    def test_draw_missing_boxes(self):\n\n        ax = cat.boxplot(\"g\", \"y\", data=self.df,\n                         order=[\"a\", \"b\", \"c\", \"d\"])\n        nt.assert_equal(len(ax.artists), 3)\n\n    def test_missing_data(self):\n\n        x = [\"a\", \"a\", \"b\", \"b\", \"c\", \"c\", \"d\", \"d\"]\n        h = [\"x\", \"y\", \"x\", \"y\", \"x\", \"y\", \"x\", \"y\"]\n        y = self.rs.randn(8)\n        y[-2:] = np.nan\n\n        ax = cat.boxplot(x, y)\n        nt.assert_equal(len(ax.artists), 3)\n\n        plt.close(\"all\")\n\n        y[-1] = 0\n        ax = cat.boxplot(x, y, h)\n        nt.assert_equal(len(ax.artists), 7)\n\n        plt.close(\"all\")\n\n    def test_boxplots(self):\n\n        \n\n        cat.boxplot(\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(y=\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(\"g\", \"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(\"y\", \"g\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n        cat.boxplot(\"g\", \"y\", \"h\", data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(\"g\", \"y\", \"h\", order=list(\"nabc\"), data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(\"g\", \"y\", \"h\", hue_order=list(\"omn\"), data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(\"y\", \"g\", \"h\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n    def test_axes_annotation(self):\n\n        ax = cat.boxplot(\"g\", \"y\", data=self.df)\n        nt.assert_equal(ax.get_xlabel(), \"g\")\n        nt.assert_equal(ax.get_ylabel(), \"y\")\n        nt.assert_equal(ax.get_xlim(), (-.5, 2.5))\n        npt.assert_array_equal(ax.get_xticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_xticklabels()],\n                               [\"a\", \"b\", \"c\"])\n\n        plt.close(\"all\")\n\n        ax = cat.boxplot(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(ax.get_xlabel(), \"g\")\n        nt.assert_equal(ax.get_ylabel(), \"y\")\n        npt.assert_array_equal(ax.get_xticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_xticklabels()],\n                               [\"a\", \"b\", \"c\"])\n        npt.assert_array_equal([l.get_text() for l in ax.legend_.get_texts()],\n                               [\"m\", \"n\"])\n\n        plt.close(\"all\")\n\n        ax = cat.boxplot(\"y\", \"g\", data=self.df, orient=\"h\")\n        nt.assert_equal(ax.get_xlabel(), \"y\")\n        nt.assert_equal(ax.get_ylabel(), \"g\")\n        nt.assert_equal(ax.get_ylim(), (2.5, -.5))\n        npt.assert_array_equal(ax.get_yticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_yticklabels()],\n                               [\"a\", \"b\", \"c\"])\n\n        plt.close(\"all\")\n\n\nclass TestViolinPlotter(CategoricalFixture):\n\n    default_kws = dict(x=None, y=None, hue=None, data=None,\n                       order=None, hue_order=None,\n                       bw=\"scott\", cut=2, scale=\"area\", scale_hue=True,\n                       gridsize=100, width=.8, inner=\"box\", split=False,\n                       dodge=True, orient=None, linewidth=None,\n                       color=None, palette=None, saturation=.75)\n\n    def test_split_error(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"h\", y=\"y\", hue=\"g\", data=self.df, split=True))\n\n        with nt.assert_raises(ValueError):\n            cat._ViolinPlotter(**kws)\n\n    def test_no_observations(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n\n        x = [\"a\", \"a\", \"b\"]\n        y = self.rs.randn(3)\n        y[-1] = np.nan\n        p.establish_variables(x, y)\n        p.estimate_densities(\"scott\", 2, \"area\", True, 20)\n\n        nt.assert_equal(len(p.support[0]), 20)\n        nt.assert_equal(len(p.support[1]), 0)\n\n        nt.assert_equal(len(p.density[0]), 20)\n        nt.assert_equal(len(p.density[1]), 1)\n\n        nt.assert_equal(p.density[1].item(), 1)\n\n        p.estimate_densities(\"scott\", 2, \"count\", True, 20)\n        nt.assert_equal(p.density[1].item(), 0)\n\n        x = [\"a\"] * 4 + [\"b\"] * 2\n        y = self.rs.randn(6)\n        h = [\"m\", \"n\"] * 2 + [\"m\"] * 2\n\n        p.establish_variables(x, y, h)\n        p.estimate_densities(\"scott\", 2, \"area\", True, 20)\n\n        nt.assert_equal(len(p.support[1][0]), 20)\n        nt.assert_equal(len(p.support[1][1]), 0)\n\n        nt.assert_equal(len(p.density[1][0]), 20)\n        nt.assert_equal(len(p.density[1][1]), 1)\n\n        nt.assert_equal(p.density[1][1].item(), 1)\n\n        p.estimate_densities(\"scott\", 2, \"count\", False, 20)\n        nt.assert_equal(p.density[1][1].item(), 0)\n\n    def test_single_observation(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n\n        x = [\"a\", \"a\", \"b\"]\n        y = self.rs.randn(3)\n        p.establish_variables(x, y)\n        p.estimate_densities(\"scott\", 2, \"area\", True, 20)\n\n        nt.assert_equal(len(p.support[0]), 20)\n        nt.assert_equal(len(p.support[1]), 1)\n\n        nt.assert_equal(len(p.density[0]), 20)\n        nt.assert_equal(len(p.density[1]), 1)\n\n        nt.assert_equal(p.density[1].item(), 1)\n\n        p.estimate_densities(\"scott\", 2, \"count\", True, 20)\n        nt.assert_equal(p.density[1].item(), .5)\n\n        x = [\"b\"] * 4 + [\"a\"] * 3\n        y = self.rs.randn(7)\n        h = ([\"m\", \"n\"] * 4)[:-1]\n\n        p.establish_variables(x, y, h)\n        p.estimate_densities(\"scott\", 2, \"area\", True, 20)\n\n        nt.assert_equal(len(p.support[1][0]), 20)\n        nt.assert_equal(len(p.support[1][1]), 1)\n\n        nt.assert_equal(len(p.density[1][0]), 20)\n        nt.assert_equal(len(p.density[1][1]), 1)\n\n        nt.assert_equal(p.density[1][1].item(), 1)\n\n        p.estimate_densities(\"scott\", 2, \"count\", False, 20)\n        nt.assert_equal(p.density[1][1].item(), .5)\n\n    def test_dwidth(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"g\", y=\"y\", data=self.df))\n\n        p = cat._ViolinPlotter(**kws)\n        nt.assert_equal(p.dwidth, .4)\n\n        kws.update(dict(width=.4))\n        p = cat._ViolinPlotter(**kws)\n        nt.assert_equal(p.dwidth, .2)\n\n        kws.update(dict(hue=\"h\", width=.8))\n        p = cat._ViolinPlotter(**kws)\n        nt.assert_equal(p.dwidth, .2)\n\n        kws.update(dict(split=True))\n        p = cat._ViolinPlotter(**kws)\n        nt.assert_equal(p.dwidth, .4)\n\n    def test_scale_area(self):\n\n        kws = self.default_kws.copy()\n        kws[\"scale\"] = \"area\"\n        p = cat._ViolinPlotter(**kws)\n\n        \n        p.hue_names = None\n        density = [self.rs.uniform(0, .8, 50), self.rs.uniform(0, .2, 50)]\n        max_before = np.array([d.max() for d in density])\n        p.scale_area(density, max_before, False)\n        max_after = np.array([d.max() for d in density])\n        nt.assert_equal(max_after[0], 1)\n\n        before_ratio = max_before[1] / max_before[0]\n        after_ratio = max_after[1] / max_after[0]\n        nt.assert_equal(before_ratio, after_ratio)\n\n        \n        p.hue_names = [\"foo\", \"bar\"]\n        density = [[self.rs.uniform(0, .8, 50), self.rs.uniform(0, .2, 50)],\n                   [self.rs.uniform(0, .1, 50), self.rs.uniform(0, .02, 50)]]\n\n        max_before = np.array([[r.max() for r in row] for row in density])\n        p.scale_area(density, max_before, False)\n        max_after = np.array([[r.max() for r in row] for row in density])\n        nt.assert_equal(max_after[0, 0], 1)\n\n        before_ratio = max_before[1, 1] / max_before[0, 0]\n        after_ratio = max_after[1, 1] / max_after[0, 0]\n        nt.assert_equal(before_ratio, after_ratio)\n\n        \n        p.hue_names = [\"foo\", \"bar\"]\n        density = [[self.rs.uniform(0, .8, 50), self.rs.uniform(0, .2, 50)],\n                   [self.rs.uniform(0, .1, 50), self.rs.uniform(0, .02, 50)]]\n\n        max_before = np.array([[r.max() for r in row] for row in density])\n        p.scale_area(density, max_before, True)\n        max_after = np.array([[r.max() for r in row] for row in density])\n        nt.assert_equal(max_after[0, 0], 1)\n        nt.assert_equal(max_after[1, 0], 1)\n\n        before_ratio = max_before[1, 1] / max_before[1, 0]\n        after_ratio = max_after[1, 1] / max_after[1, 0]\n        nt.assert_equal(before_ratio, after_ratio)\n\n    def test_scale_width(self):\n\n        kws = self.default_kws.copy()\n        kws[\"scale\"] = \"width\"\n        p = cat._ViolinPlotter(**kws)\n\n        \n        p.hue_names = None\n        density = [self.rs.uniform(0, .8, 50), self.rs.uniform(0, .2, 50)]\n        p.scale_width(density)\n        max_after = np.array([d.max() for d in density])\n        npt.assert_array_equal(max_after, [1, 1])\n\n        \n        p.hue_names = [\"foo\", \"bar\"]\n        density = [[self.rs.uniform(0, .8, 50), self.rs.uniform(0, .2, 50)],\n                   [self.rs.uniform(0, .1, 50), self.rs.uniform(0, .02, 50)]]\n\n        p.scale_width(density)\n        max_after = np.array([[r.max() for r in row] for row in density])\n        npt.assert_array_equal(max_after, [[1, 1], [1, 1]])\n\n    def test_scale_count(self):\n\n        kws = self.default_kws.copy()\n        kws[\"scale\"] = \"count\"\n        p = cat._ViolinPlotter(**kws)\n\n        \n        p.hue_names = None\n        density = [self.rs.uniform(0, .8, 20), self.rs.uniform(0, .2, 40)]\n        counts = np.array([20, 40])\n        p.scale_count(density, counts, False)\n        max_after = np.array([d.max() for d in density])\n        npt.assert_array_equal(max_after, [.5, 1])\n\n        \n        p.hue_names = [\"foo\", \"bar\"]\n        density = [[self.rs.uniform(0, .8, 5), self.rs.uniform(0, .2, 40)],\n                   [self.rs.uniform(0, .1, 100), self.rs.uniform(0, .02, 50)]]\n\n        counts = np.array([[5, 40], [100, 50]])\n        p.scale_count(density, counts, False)\n        max_after = np.array([[r.max() for r in row] for row in density])\n        npt.assert_array_equal(max_after, [[.05, .4], [1, .5]])\n\n        \n        p.hue_names = [\"foo\", \"bar\"]\n        density = [[self.rs.uniform(0, .8, 5), self.rs.uniform(0, .2, 40)],\n                   [self.rs.uniform(0, .1, 100), self.rs.uniform(0, .02, 50)]]\n\n        counts = np.array([[5, 40], [100, 50]])\n        p.scale_count(density, counts, True)\n        max_after = np.array([[r.max() for r in row] for row in density])\n        npt.assert_array_equal(max_after, [[.125, 1], [1, .5]])\n\n    def test_bad_scale(self):\n\n        kws = self.default_kws.copy()\n        kws[\"scale\"] = \"not_a_scale_type\"\n        with nt.assert_raises(ValueError):\n            cat._ViolinPlotter(**kws)\n\n    def test_kde_fit(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n        data = self.y\n        data_std = data.std(ddof=1)\n\n        \n        if LooseVersion(scipy.__version__) < \"0.11\":\n            \n            kde, bw = p.fit_kde(self.y, .2)\n            nt.assert_is_instance(kde, stats.gaussian_kde)\n            nt.assert_equal(kde.factor, kde.scotts_factor())\n\n        else:\n            \n            kde, bw = p.fit_kde(data, \"scott\")\n            nt.assert_is_instance(kde, stats.gaussian_kde)\n            nt.assert_equal(kde.factor, kde.scotts_factor())\n            nt.assert_equal(bw, kde.scotts_factor() * data_std)\n\n            \n            kde, bw = p.fit_kde(self.y, .2)\n            nt.assert_is_instance(kde, stats.gaussian_kde)\n            nt.assert_equal(kde.factor, .2)\n            nt.assert_equal(bw, .2 * data_std)\n\n    def test_draw_to_density(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n        \n        p.width = 2\n\n        \n        support = np.array([.2, .6])\n        density = np.array([.1, .4])\n\n        \n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .5, support, density, False)\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [.99 * -.4, .99 * .4])\n        npt.assert_array_equal(y, [.5, .5])\n        plt.close(\"all\")\n\n        \n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .5, support, density, \"left\")\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [.99 * -.4, 0])\n        npt.assert_array_equal(y, [.5, .5])\n        plt.close(\"all\")\n\n        \n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .5, support, density, \"right\")\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [0, .99 * .4])\n        npt.assert_array_equal(y, [.5, .5])\n        plt.close(\"all\")\n\n        \n        p.orient = \"h\"\n        support = np.array([.2, .5])\n        density = np.array([.3, .7])\n\n        \n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .6, support, density, False)\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [.6, .6])\n        npt.assert_array_equal(y, [.99 * -.7, .99 * .7])\n        plt.close(\"all\")\n\n        \n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .6, support, density, \"left\")\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [.6, .6])\n        npt.assert_array_equal(y, [.99 * -.7, 0])\n        plt.close(\"all\")\n\n        \n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .6, support, density, \"right\")\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [.6, .6])\n        npt.assert_array_equal(y, [0, .99 * .7])\n        plt.close(\"all\")\n\n    def test_draw_single_observations(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n        p.width = 2\n\n        \n        _, ax = plt.subplots()\n        p.draw_single_observation(ax, 1, 1.5, 1)\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [0, 2])\n        npt.assert_array_equal(y, [1.5, 1.5])\n        plt.close(\"all\")\n\n        \n        p.orient = \"h\"\n        _, ax = plt.subplots()\n        p.draw_single_observation(ax, 2, 2.2, .5)\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [2.2, 2.2])\n        npt.assert_array_equal(y, [1.5, 2.5])\n        plt.close(\"all\")\n\n    def test_draw_box_lines(self):\n\n        \n        kws = self.default_kws.copy()\n        kws.update(dict(y=\"y\", data=self.df, inner=None))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_box_lines(ax, self.y, p.support[0], p.density[0], 0)\n        nt.assert_equal(len(ax.lines), 2)\n\n        q25, q50, q75 = np.percentile(self.y, [25, 50, 75])\n        _, y = ax.lines[1].get_xydata().T\n        npt.assert_array_equal(y, [q25, q75])\n\n        _, y = ax.collections[0].get_offsets().T\n        nt.assert_equal(y, q50)\n\n        plt.close(\"all\")\n\n        \n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"y\", data=self.df, inner=None))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_box_lines(ax, self.y, p.support[0], p.density[0], 0)\n        nt.assert_equal(len(ax.lines), 2)\n\n        q25, q50, q75 = np.percentile(self.y, [25, 50, 75])\n        x, _ = ax.lines[1].get_xydata().T\n        npt.assert_array_equal(x, [q25, q75])\n\n        x, _ = ax.collections[0].get_offsets().T\n        nt.assert_equal(x, q50)\n\n        plt.close(\"all\")\n\n    def test_draw_quartiles(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(y=\"y\", data=self.df, inner=None))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_quartiles(ax, self.y, p.support[0], p.density[0], 0)\n        for val, line in zip(np.percentile(self.y, [25, 50, 75]), ax.lines):\n            _, y = line.get_xydata().T\n            npt.assert_array_equal(y, [val, val])\n\n    def test_draw_points(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n\n        \n        _, ax = plt.subplots()\n        p.draw_points(ax, self.y, 0)\n        x, y = ax.collections[0].get_offsets().T\n        npt.assert_array_equal(x, np.zeros_like(self.y))\n        npt.assert_array_equal(y, self.y)\n        plt.close(\"all\")\n\n        \n        p.orient = \"h\"\n        _, ax = plt.subplots()\n        p.draw_points(ax, self.y, 0)\n        x, y = ax.collections[0].get_offsets().T\n        npt.assert_array_equal(x, self.y)\n        npt.assert_array_equal(y, np.zeros_like(self.y))\n        plt.close(\"all\")\n\n    def test_draw_sticks(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(y=\"y\", data=self.df, inner=None))\n        p = cat._ViolinPlotter(**kws)\n\n        \n        _, ax = plt.subplots()\n        p.draw_stick_lines(ax, self.y, p.support[0], p.density[0], 0)\n        for val, line in zip(self.y, ax.lines):\n            _, y = line.get_xydata().T\n            npt.assert_array_equal(y, [val, val])\n        plt.close(\"all\")\n\n        \n        p.orient = \"h\"\n        _, ax = plt.subplots()\n        p.draw_stick_lines(ax, self.y, p.support[0], p.density[0], 0)\n        for val, line in zip(self.y, ax.lines):\n            x, _ = line.get_xydata().T\n            npt.assert_array_equal(x, [val, val])\n        plt.close(\"all\")\n\n    def test_validate_inner(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(inner=\"bad_inner\"))\n        with nt.assert_raises(ValueError):\n            cat._ViolinPlotter(**kws)\n\n    def test_draw_violinplots(self):\n\n        kws = self.default_kws.copy()\n\n        \n        kws.update(dict(y=\"y\", data=self.df, inner=None,\n                        saturation=1, color=(1, 0, 0, 1)))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 1)\n        npt.assert_array_equal(ax.collections[0].get_facecolors(),\n                               [(1, 0, 0, 1)])\n        plt.close(\"all\")\n\n        \n        kws.update(dict(x=\"y\", y=None, color=(0, 1, 0, 1)))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 1)\n        npt.assert_array_equal(ax.collections[0].get_facecolors(),\n                               [(0, 1, 0, 1)])\n        plt.close(\"all\")\n\n        \n        kws.update(dict(x=\"g\", y=\"y\", color=None,))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 3)\n        for violin, color in zip(ax.collections, palettes.color_palette()):\n            npt.assert_array_equal(violin.get_facecolors()[0, :-1], color)\n        plt.close(\"all\")\n\n        \n        kws.update(dict(hue=\"h\"))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 6)\n        for violin, color in zip(ax.collections,\n                                 palettes.color_palette(n_colors=2) * 3):\n            npt.assert_array_equal(violin.get_facecolors()[0, :-1], color)\n        plt.close(\"all\")\n\n        \n        kws.update(dict(split=True, palette=\"muted\"))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 6)\n        for violin, color in zip(ax.collections,\n                                 palettes.color_palette(\"muted\",\n                                                        n_colors=2) * 3):\n            npt.assert_array_equal(violin.get_facecolors()[0, :-1], color)\n        plt.close(\"all\")\n\n    def test_draw_violinplots_no_observations(self):\n\n        kws = self.default_kws.copy()\n        kws[\"inner\"] = None\n\n        \n        x = [\"a\", \"a\", \"b\"]\n        y = self.rs.randn(3)\n        y[-1] = np.nan\n        kws.update(x=x, y=y)\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 1)\n        nt.assert_equal(len(ax.lines), 0)\n        plt.close(\"all\")\n\n        \n        x = [\"a\"] * 4 + [\"b\"] * 2\n        y = self.rs.randn(6)\n        h = [\"m\", \"n\"] * 2 + [\"m\"] * 2\n        kws.update(x=x, y=y, hue=h)\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 3)\n        nt.assert_equal(len(ax.lines), 0)\n        plt.close(\"all\")\n\n    def test_draw_violinplots_single_observations(self):\n\n        kws = self.default_kws.copy()\n        kws[\"inner\"] = None\n\n        \n        x = [\"a\", \"a\", \"b\"]\n        y = self.rs.randn(3)\n        kws.update(x=x, y=y)\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 1)\n        nt.assert_equal(len(ax.lines), 1)\n        plt.close(\"all\")\n\n        \n        x = [\"b\"] * 4 + [\"a\"] * 3\n        y = self.rs.randn(7)\n        h = ([\"m\", \"n\"] * 4)[:-1]\n        kws.update(x=x, y=y, hue=h)\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 3)\n        nt.assert_equal(len(ax.lines), 1)\n        plt.close(\"all\")\n\n         with split\n        kws[\"split\"] = True\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 3)\n        nt.assert_equal(len(ax.lines), 1)\n        plt.close(\"all\")\n\n    def test_violinplots(self):\n\n        \n\n        cat.violinplot(\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.violinplot(y=\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.violinplot(\"g\", \"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.violinplot(\"y\", \"g\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n        cat.violinplot(\"g\", \"y\", \"h\", data=self.df)\n        plt.close(\"all\")\n\n        cat.violinplot(\"g\", \"y\", \"h\", order=list(\"nabc\"), data=self.df)\n        plt.close(\"all\")\n\n        cat.violinplot(\"g\", \"y\", \"h\", hue_order=list(\"omn\"), data=self.df)\n        plt.close(\"all\")\n\n        cat.violinplot(\"y\", \"g\", \"h\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n        for inner in [\"box\", \"quart\", \"point\", \"stick\", None]:\n            cat.violinplot(\"g\", \"y\", data=self.df, inner=inner)\n            plt.close(\"all\")\n\n            cat.violinplot(\"g\", \"y\", \"h\", data=self.df, inner=inner)\n            plt.close(\"all\")\n\n            cat.violinplot(\"g\", \"y\", \"h\", data=self.df,\n                           inner=inner, split=True)\n            plt.close(\"all\")\n\n\nclass TestCategoricalScatterPlotter(CategoricalFixture):\n\n    def test_group_point_colors(self):\n\n        p = cat._CategoricalScatterPlotter()\n\n        p.establish_variables(x=\"g\", y=\"y\", data=self.df)\n        p.establish_colors(None, \"deep\", 1)\n\n        point_colors = p.point_colors\n        nt.assert_equal(len(point_colors), self.g.unique().size)\n        deep_colors = palettes.color_palette(\"deep\", self.g.unique().size)\n\n        for i, group_colors in enumerate(point_colors):\n            nt.assert_equal(tuple(deep_colors[i]), tuple(group_colors[0]))\n            for channel in group_colors.T:\n                nt.assert_equals(np.unique(channel).size, 1)\n\n    def test_hue_point_colors(self):\n\n        p = cat._CategoricalScatterPlotter()\n\n        hue_order = self.h.unique().tolist()\n        p.establish_variables(x=\"g\", y=\"y\", hue=\"h\",\n                              hue_order=hue_order, data=self.df)\n        p.establish_colors(None, \"deep\", 1)\n\n        point_colors = p.point_colors\n        nt.assert_equal(len(point_colors), self.g.unique().size)\n        deep_colors = palettes.color_palette(\"deep\", len(hue_order))\n\n        for i, group_colors in enumerate(point_colors):\n            for j, point_color in enumerate(group_colors):\n                hue_level = p.plot_hues[i][j]\n                nt.assert_equal(tuple(point_color),\n                                deep_colors[hue_order.index(hue_level)])\n\n    def test_scatterplot_legend(self):\n\n        p = cat._CategoricalScatterPlotter()\n\n        hue_order = [\"m\", \"n\"]\n        p.establish_variables(x=\"g\", y=\"y\", hue=\"h\",\n                              hue_order=hue_order, data=self.df)\n        p.establish_colors(None, \"deep\", 1)\n        deep_colors = palettes.color_palette(\"deep\", self.h.unique().size)\n\n        f, ax = plt.subplots()\n        p.add_legend_data(ax)\n        leg = ax.legend()\n\n        for i, t in enumerate(leg.get_texts()):\n            nt.assert_equal(t.get_text(), hue_order[i])\n\n        for i, h in enumerate(leg.legendHandles):\n            rgb = h.get_facecolor()[0, :3]\n            nt.assert_equal(tuple(rgb), tuple(deep_colors[i]))\n\n\nclass TestStripPlotter(CategoricalFixture):\n\n    def test_stripplot_vertical(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.stripplot(\"g\", \"y\", data=self.df)\n        for i, (_, vals) in enumerate(self.y.groupby(self.g)):\n\n            x, y = ax.collections[i].get_offsets().T\n\n            npt.assert_array_equal(x, np.ones(len(x)) * i)\n            npt.assert_array_equal(y, vals)\n\n            npt.assert_equal(ax.collections[i].get_facecolors()[0, :3], pal[i])\n\n    @skipif(not pandas_has_categoricals)\n    def test_stripplot_horiztonal(self):\n\n        df = self.df.copy()\n        df.g = df.g.astype(\"category\")\n\n        ax = cat.stripplot(\"y\", \"g\", data=df)\n        for i, (_, vals) in enumerate(self.y.groupby(self.g)):\n\n            x, y = ax.collections[i].get_offsets().T\n\n            npt.assert_array_equal(x, vals)\n            npt.assert_array_equal(y, np.ones(len(x)) * i)\n\n    def test_stripplot_jitter(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.stripplot(\"g\", \"y\", data=self.df, jitter=True)\n        for i, (_, vals) in enumerate(self.y.groupby(self.g)):\n\n            x, y = ax.collections[i].get_offsets().T\n\n            npt.assert_array_less(np.ones(len(x)) * i - .1, x)\n            npt.assert_array_less(x, np.ones(len(x)) * i + .1)\n            npt.assert_array_equal(y, vals)\n\n            npt.assert_equal(ax.collections[i].get_facecolors()[0, :3], pal[i])\n\n    def test_dodge_nested_stripplot_vertical(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.stripplot(\"g\", \"y\", \"h\", data=self.df, dodge=True)\n        for i, (_, group_vals) in enumerate(self.y.groupby(self.g)):\n            for j, (_, vals) in enumerate(group_vals.groupby(self.h)):\n\n                x, y = ax.collections[i * 2 + j].get_offsets().T\n\n                npt.assert_array_equal(x, np.ones(len(x)) * i + [-.2, .2][j])\n                npt.assert_array_equal(y, vals)\n\n                fc = ax.collections[i * 2 + j].get_facecolors()[0, :3]\n                npt.assert_equal(fc, pal[j])\n\n    @skipif(not pandas_has_categoricals)\n    def test_dodge_nested_stripplot_horizontal(self):\n\n        df = self.df.copy()\n        df.g = df.g.astype(\"category\")\n\n        ax = cat.stripplot(\"y\", \"g\", \"h\", data=df, dodge=True)\n        for i, (_, group_vals) in enumerate(self.y.groupby(self.g)):\n            for j, (_, vals) in enumerate(group_vals.groupby(self.h)):\n\n                x, y = ax.collections[i * 2 + j].get_offsets().T\n\n                npt.assert_array_equal(x, vals)\n                npt.assert_array_equal(y, np.ones(len(x)) * i + [-.2, .2][j])\n\n    def test_nested_stripplot_vertical(self):\n\n        \n        ax = cat.stripplot(\"g\", \"y\", \"h\", data=self.df, dodge=False)\n        for i, (_, group_vals) in enumerate(self.y.groupby(self.g)):\n\n            x, y = ax.collections[i].get_offsets().T\n\n            npt.assert_array_equal(x, np.ones(len(x)) * i)\n            npt.assert_array_equal(y, group_vals)\n\n    @skipif(not pandas_has_categoricals)\n    def test_nested_stripplot_horizontal(self):\n\n        df = self.df.copy()\n        df.g = df.g.astype(\"category\")\n\n        ax = cat.stripplot(\"y\", \"g\", \"h\", data=df, dodge=False)\n        for i, (_, group_vals) in enumerate(self.y.groupby(self.g)):\n\n            x, y = ax.collections[i].get_offsets().T\n\n            npt.assert_array_equal(x, group_vals)\n            npt.assert_array_equal(y, np.ones(len(x)) * i)\n\n    def test_three_strip_points(self):\n\n        x = np.arange(3)\n        ax = cat.stripplot(x=x)\n        facecolors = ax.collections[0].get_facecolor()\n        nt.assert_equal(facecolors.shape, (3, 4))\n        npt.assert_array_equal(facecolors[0], facecolors[1])\n\n\nclass TestSwarmPlotter(CategoricalFixture):\n\n    default_kws = dict(x=None, y=None, hue=None, data=None,\n                       order=None, hue_order=None, dodge=False,\n                       orient=None, color=None, palette=None)\n\n    def test_could_overlap(self):\n\n        p = cat._SwarmPlotter(**self.default_kws)\n        neighbors = p.could_overlap((1, 1), [(0, 0), (1, .5), (.5, .5)], 1)\n        npt.assert_array_equal(neighbors, [(1, .5), (.5, .5)])\n\n    def test_position_candidates(self):\n\n        p = cat._SwarmPlotter(**self.default_kws)\n        xy_i = (0, 1)\n        neighbors = [(0, 1), (0, 1.5)]\n        candidates = p.position_candidates(xy_i, neighbors, 1)\n        dx1 = 1.05\n        dx2 = np.sqrt(1 - .5 ** 2) * 1.05\n        npt.assert_array_equal(candidates,\n                               [(0, 1), (-dx1, 1), (dx1, 1),\n                                (dx2, 1), (-dx2, 1)])\n\n    def test_find_first_non_overlapping_candidate(self):\n\n        p = cat._SwarmPlotter(**self.default_kws)\n        candidates = [(.5, 1), (1, 1), (1.5, 1)]\n        neighbors = np.array([(0, 1)])\n\n        first = p.first_non_overlapping_candidate(candidates, neighbors, 1)\n        npt.assert_array_equal(first, (1, 1))\n\n    def test_beeswarm(self):\n\n        p = cat._SwarmPlotter(**self.default_kws)\n        d = self.y.diff().mean() * 1.5\n        x = np.zeros(self.y.size)\n        y = np.sort(self.y)\n        orig_xy = np.c_[x, y]\n        swarm = p.beeswarm(orig_xy, d)\n        dmat = spatial.distance.cdist(swarm, swarm)\n        triu = dmat[np.triu_indices_from(dmat, 1)]\n        npt.assert_array_less(d, triu)\n        npt.assert_array_equal(y, swarm[:, 1])\n\n    def test_add_gutters(self):\n\n        p = cat._SwarmPlotter(**self.default_kws)\n        points = np.array([0, -1, .4, .8])\n        points = p.add_gutters(points, 0, 1)\n        npt.assert_array_equal(points,\n                               np.array([0, -.5, .4, .5]))\n\n    def test_swarmplot_vertical(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.swarmplot(\"g\", \"y\", data=self.df)\n        for i, (_, vals) in enumerate(self.y.groupby(self.g)):\n\n            x, y = ax.collections[i].get_offsets().T\n            npt.assert_array_almost_equal(y, np.sort(vals))\n\n            fc = ax.collections[i].get_facecolors()[0, :3]\n            npt.assert_equal(fc, pal[i])\n\n    def test_swarmplot_horizontal(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.swarmplot(\"y\", \"g\", data=self.df, orient=\"h\")\n        for i, (_, vals) in enumerate(self.y.groupby(self.g)):\n\n            x, y = ax.collections[i].get_offsets().T\n            npt.assert_array_almost_equal(x, np.sort(vals))\n\n            fc = ax.collections[i].get_facecolors()[0, :3]\n            npt.assert_equal(fc, pal[i])\n\n    def test_dodge_nested_swarmplot_vetical(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.swarmplot(\"g\", \"y\", \"h\", data=self.df, dodge=True)\n        for i, (_, group_vals) in enumerate(self.y.groupby(self.g)):\n            for j, (_, vals) in enumerate(group_vals.groupby(self.h)):\n\n                x, y = ax.collections[i * 2 + j].get_offsets().T\n                npt.assert_array_almost_equal(y, np.sort(vals))\n\n                fc = ax.collections[i * 2 + j].get_facecolors()[0, :3]\n                npt.assert_equal(fc, pal[j])\n\n    def test_dodge_nested_swarmplot_horizontal(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.swarmplot(\"y\", \"g\", \"h\", data=self.df, orient=\"h\", dodge=True)\n        for i, (_, group_vals) in enumerate(self.y.groupby(self.g)):\n            for j, (_, vals) in enumerate(group_vals.groupby(self.h)):\n\n                x, y = ax.collections[i * 2 + j].get_offsets().T\n                npt.assert_array_almost_equal(x, np.sort(vals))\n\n                fc = ax.collections[i * 2 + j].get_facecolors()[0, :3]\n                npt.assert_equal(fc, pal[j])\n\n    def test_nested_swarmplot_vertical(self):\n\n        ax = cat.swarmplot(\"g\", \"y\", \"h\", data=self.df)\n\n        pal = palettes.color_palette()\n        hue_names = self.h.unique().tolist()\n        grouped_hues = list(self.h.groupby(self.g))\n\n        for i, (_, vals) in enumerate(self.y.groupby(self.g)):\n\n            points = ax.collections[i]\n            x, y = points.get_offsets().T\n            sorter = np.argsort(vals)\n            npt.assert_array_almost_equal(y, vals.iloc[sorter])\n\n            _, hue_vals = grouped_hues[i]\n            for hue, fc in zip(hue_vals.values[sorter.values],\n                               points.get_facecolors()):\n\n                npt.assert_equal(fc[:3], pal[hue_names.index(hue)])\n\n    def test_nested_swarmplot_horizontal(self):\n\n        ax = cat.swarmplot(\"y\", \"g\", \"h\", data=self.df, orient=\"h\")\n\n        pal = palettes.color_palette()\n        hue_names = self.h.unique().tolist()\n        grouped_hues = list(self.h.groupby(self.g))\n\n        for i, (_, vals) in enumerate(self.y.groupby(self.g)):\n\n            points = ax.collections[i]\n            x, y = points.get_offsets().T\n            sorter = np.argsort(vals)\n            npt.assert_array_almost_equal(x, vals.iloc[sorter])\n\n            _, hue_vals = grouped_hues[i]\n            for hue, fc in zip(hue_vals.values[sorter.values],\n                               points.get_facecolors()):\n\n                npt.assert_equal(fc[:3], pal[hue_names.index(hue)])\n\n\nclass TestBarPlotter(CategoricalFixture):\n\n    default_kws = dict(x=None, y=None, hue=None, data=None,\n                       estimator=np.mean, ci=95, n_boot=100, units=None,\n                       order=None, hue_order=None,\n                       orient=None, color=None, palette=None,\n                       saturation=.75, errcolor=\".26\", errwidth=None,\n                       capsize=None, dodge=True)\n\n    def test_nested_width(self):\n\n        kws = self.default_kws.copy()\n\n        p = cat._BarPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(p.nested_width, .8 / 2)\n\n        p = cat._BarPlotter(**kws)\n        p.establish_variables(\"h\", \"y\", \"g\", data=self.df)\n        nt.assert_equal(p.nested_width, .8 / 3)\n\n        kws[\"dodge\"] = False\n        p = cat._BarPlotter(**kws)\n        p.establish_variables(\"h\", \"y\", \"g\", data=self.df)\n        nt.assert_equal(p.nested_width, .8)\n\n    def test_draw_vertical_bars(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        nt.assert_equal(len(ax.patches), len(p.plot_data))\n        nt.assert_equal(len(ax.lines), len(p.plot_data))\n\n        for bar, color in zip(ax.patches, p.colors):\n            nt.assert_equal(bar.get_facecolor()[:-1], color)\n\n        positions = np.arange(len(p.plot_data)) - p.width / 2\n        for bar, pos, stat in zip(ax.patches, positions, p.statistic):\n            nt.assert_equal(bar.get_x(), pos)\n            nt.assert_equal(bar.get_width(), p.width)\n            if mpl.__version__ >= mpl_barplot_change:\n                nt.assert_equal(bar.get_y(), 0)\n                nt.assert_equal(bar.get_height(), stat)\n            else:\n                nt.assert_equal(bar.get_y(), min(0, stat))\n                nt.assert_equal(bar.get_height(), abs(stat))\n\n    def test_draw_horizontal_bars(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"y\", y=\"g\", orient=\"h\", data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        nt.assert_equal(len(ax.patches), len(p.plot_data))\n        nt.assert_equal(len(ax.lines), len(p.plot_data))\n\n        for bar, color in zip(ax.patches, p.colors):\n            nt.assert_equal(bar.get_facecolor()[:-1], color)\n\n        positions = np.arange(len(p.plot_data)) - p.width / 2\n        for bar, pos, stat in zip(ax.patches, positions, p.statistic):\n            nt.assert_equal(bar.get_y(), pos)\n            nt.assert_equal(bar.get_height(), p.width)\n            if mpl.__version__ >= mpl_barplot_change:\n                nt.assert_equal(bar.get_x(), 0)\n                nt.assert_equal(bar.get_width(), stat)\n            else:\n                nt.assert_equal(bar.get_x(), min(0, stat))\n                nt.assert_equal(bar.get_width(), abs(stat))\n\n    def test_draw_nested_vertical_bars(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        n_groups, n_hues = len(p.plot_data), len(p.hue_names)\n        nt.assert_equal(len(ax.patches), n_groups * n_hues)\n        nt.assert_equal(len(ax.lines), n_groups * n_hues)\n\n        for bar in ax.patches[:n_groups]:\n            nt.assert_equal(bar.get_facecolor()[:-1], p.colors[0])\n        for bar in ax.patches[n_groups:]:\n            nt.assert_equal(bar.get_facecolor()[:-1], p.colors[1])\n\n        positions = np.arange(len(p.plot_data))\n        for bar, pos in zip(ax.patches[:n_groups], positions):\n            nt.assert_almost_equal(bar.get_x(), pos - p.width / 2)\n            nt.assert_almost_equal(bar.get_width(), p.nested_width)\n\n        for bar, stat in zip(ax.patches, p.statistic.T.flat):\n            if LooseVersion(mpl.__version__) >= mpl_barplot_change:\n                nt.assert_almost_equal(bar.get_y(), 0)\n                nt.assert_almost_equal(bar.get_height(), stat)\n            else:\n                nt.assert_almost_equal(bar.get_y(), min(0, stat))\n                nt.assert_almost_equal(bar.get_height(), abs(stat))\n\n    def test_draw_nested_horizontal_bars(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"y\", y=\"g\", hue=\"h\", orient=\"h\", data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        n_groups, n_hues = len(p.plot_data), len(p.hue_names)\n        nt.assert_equal(len(ax.patches), n_groups * n_hues)\n        nt.assert_equal(len(ax.lines), n_groups * n_hues)\n\n        for bar in ax.patches[:n_groups]:\n            nt.assert_equal(bar.get_facecolor()[:-1], p.colors[0])\n        for bar in ax.patches[n_groups:]:\n            nt.assert_equal(bar.get_facecolor()[:-1], p.colors[1])\n\n        positions = np.arange(len(p.plot_data))\n        for bar, pos in zip(ax.patches[:n_groups], positions):\n            nt.assert_almost_equal(bar.get_y(), pos - p.width / 2)\n            nt.assert_almost_equal(bar.get_height(), p.nested_width)\n\n        for bar, stat in zip(ax.patches, p.statistic.T.flat):\n            if LooseVersion(mpl.__version__) >= mpl_barplot_change:\n                nt.assert_almost_equal(bar.get_x(), 0)\n                nt.assert_almost_equal(bar.get_width(), stat)\n            else:\n                nt.assert_almost_equal(bar.get_x(), min(0, stat))\n                nt.assert_almost_equal(bar.get_width(), abs(stat))\n\n    def test_draw_missing_bars(self):\n\n        kws = self.default_kws.copy()\n\n        order = list(\"abcd\")\n        kws.update(x=\"g\", y=\"y\", order=order, data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        nt.assert_equal(len(ax.patches), len(order))\n        nt.assert_equal(len(ax.lines), len(order))\n\n        plt.close(\"all\")\n\n        hue_order = list(\"mno\")\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", hue_order=hue_order, data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        nt.assert_equal(len(ax.patches), len(p.plot_data) * len(hue_order))\n        nt.assert_equal(len(ax.lines),  len(p.plot_data) * len(hue_order))\n\n        plt.close(\"all\")\n\n    def test_barplot_colors(self):\n\n        \n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", data=self.df,\n                   saturation=1, palette=\"muted\")\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        palette = palettes.color_palette(\"muted\", len(self.g.unique()))\n        for patch, pal_color in zip(ax.patches, palette):\n            nt.assert_equal(patch.get_facecolor()[:-1], pal_color)\n\n        plt.close(\"all\")\n\n        \n        color = (.2, .2, .3, 1)\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", data=self.df,\n                   saturation=1, color=color)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        for patch in ax.patches:\n            nt.assert_equal(patch.get_facecolor(), color)\n\n        plt.close(\"all\")\n\n        \n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", data=self.df,\n                   saturation=1, palette=\"Set2\")\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        palette = palettes.color_palette(\"Set2\", len(self.h.unique()))\n        for patch in ax.patches[:len(self.g.unique())]:\n            nt.assert_equal(patch.get_facecolor()[:-1], palette[0])\n        for patch in ax.patches[len(self.g.unique()):]:\n            nt.assert_equal(patch.get_facecolor()[:-1], palette[1])\n\n        plt.close(\"all\")\n\n    def test_simple_barplots(self):\n\n        ax = cat.barplot(\"g\", \"y\", data=self.df)\n        nt.assert_equal(len(ax.patches), len(self.g.unique()))\n        nt.assert_equal(ax.get_xlabel(), \"g\")\n        nt.assert_equal(ax.get_ylabel(), \"y\")\n        plt.close(\"all\")\n\n        ax = cat.barplot(\"y\", \"g\", orient=\"h\", data=self.df)\n        nt.assert_equal(len(ax.patches), len(self.g.unique()))\n        nt.assert_equal(ax.get_xlabel(), \"y\")\n        nt.assert_equal(ax.get_ylabel(), \"g\")\n        plt.close(\"all\")\n\n        ax = cat.barplot(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(len(ax.patches),\n                        len(self.g.unique()) * len(self.h.unique()))\n        nt.assert_equal(ax.get_xlabel(), \"g\")\n        nt.assert_equal(ax.get_ylabel(), \"y\")\n        plt.close(\"all\")\n\n        ax = cat.barplot(\"y\", \"g\", \"h\", orient=\"h\", data=self.df)\n        nt.assert_equal(len(ax.patches),\n                        len(self.g.unique()) * len(self.h.unique()))\n        nt.assert_equal(ax.get_xlabel(), \"y\")\n        nt.assert_equal(ax.get_ylabel(), \"g\")\n        plt.close(\"all\")\n\n\nclass TestPointPlotter(CategoricalFixture):\n\n    default_kws = dict(x=None, y=None, hue=None, data=None,\n                       estimator=np.mean, ci=95, n_boot=100, units=None,\n                       order=None, hue_order=None,\n                       markers=\"o\", linestyles=\"-\", dodge=0,\n                       join=True, scale=1,\n                       orient=None, color=None, palette=None)\n\n    def test_different_defualt_colors(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"g\", y=\"y\", data=self.df))\n        p = cat._PointPlotter(**kws)\n        color = palettes.color_palette()[0]\n        npt.assert_array_equal(p.colors, [color, color, color])\n\n    def test_hue_offsets(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"g\", y=\"y\", hue=\"h\", data=self.df))\n\n        p = cat._PointPlotter(**kws)\n        npt.assert_array_equal(p.hue_offsets, [0, 0])\n\n        kws.update(dict(dodge=.5))\n\n        p = cat._PointPlotter(**kws)\n        npt.assert_array_equal(p.hue_offsets, [-.25, .25])\n\n        kws.update(dict(x=\"h\", hue=\"g\", dodge=0))\n\n        p = cat._PointPlotter(**kws)\n        npt.assert_array_equal(p.hue_offsets, [0, 0, 0])\n\n        kws.update(dict(dodge=.3))\n\n        p = cat._PointPlotter(**kws)\n        npt.assert_array_equal(p.hue_offsets, [-.15, 0, .15])\n\n    def test_draw_vertical_points(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", data=self.df)\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        nt.assert_equal(len(ax.collections), 1)\n        nt.assert_equal(len(ax.lines), len(p.plot_data) + 1)\n        points = ax.collections[0]\n        nt.assert_equal(len(points.get_offsets()), len(p.plot_data))\n\n        x, y = points.get_offsets().T\n        npt.assert_array_equal(x, np.arange(len(p.plot_data)))\n        npt.assert_array_equal(y, p.statistic)\n\n        for got_color, want_color in zip(points.get_facecolors(),\n                                         p.colors):\n            npt.assert_array_equal(got_color[:-1], want_color)\n\n    def test_draw_horizontal_points(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"y\", y=\"g\", orient=\"h\", data=self.df)\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        nt.assert_equal(len(ax.collections), 1)\n        nt.assert_equal(len(ax.lines), len(p.plot_data) + 1)\n        points = ax.collections[0]\n        nt.assert_equal(len(points.get_offsets()), len(p.plot_data))\n\n        x, y = points.get_offsets().T\n        npt.assert_array_equal(x, p.statistic)\n        npt.assert_array_equal(y, np.arange(len(p.plot_data)))\n\n        for got_color, want_color in zip(points.get_facecolors(),\n                                         p.colors):\n            npt.assert_array_equal(got_color[:-1], want_color)\n\n    def test_draw_vertical_nested_points(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", data=self.df)\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        nt.assert_equal(len(ax.collections), 2)\n        nt.assert_equal(len(ax.lines),\n                        len(p.plot_data) * len(p.hue_names) + len(p.hue_names))\n\n        for points, stats, color in zip(ax.collections,\n                                        p.statistic.T,\n                                        p.colors):\n\n            nt.assert_equal(len(points.get_offsets()), len(p.plot_data))\n\n            x, y = points.get_offsets().T\n            npt.assert_array_equal(x, np.arange(len(p.plot_data)))\n            npt.assert_array_equal(y, stats)\n\n            for got_color in points.get_facecolors():\n                npt.assert_array_equal(got_color[:-1], color)\n\n    def test_draw_horizontal_nested_points(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"y\", y=\"g\", hue=\"h\", orient=\"h\", data=self.df)\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        nt.assert_equal(len(ax.collections), 2)\n        nt.assert_equal(len(ax.lines),\n                        len(p.plot_data) * len(p.hue_names) + len(p.hue_names))\n\n        for points, stats, color in zip(ax.collections,\n                                        p.statistic.T,\n                                        p.colors):\n\n            nt.assert_equal(len(points.get_offsets()), len(p.plot_data))\n\n            x, y = points.get_offsets().T\n            npt.assert_array_equal(x, stats)\n            npt.assert_array_equal(y, np.arange(len(p.plot_data)))\n\n            for got_color in points.get_facecolors():\n                npt.assert_array_equal(got_color[:-1], color)\n\n    def test_pointplot_colors(self):\n\n        \n        color = (.2, .2, .3, 1)\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", data=self.df, color=color)\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        for line in ax.lines:\n            nt.assert_equal(line.get_color(), color[:-1])\n\n        for got_color in ax.collections[0].get_facecolors():\n            npt.assert_array_equal(rgb2hex(got_color), rgb2hex(color))\n\n        plt.close(\"all\")\n\n        \n        palette = palettes.color_palette(\"Set1\", 3)\n        kws.update(x=\"g\", y=\"y\", data=self.df, palette=\"Set1\")\n        p = cat._PointPlotter(**kws)\n\n        nt.assert_true(not p.join)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        for line, pal_color in zip(ax.lines, palette):\n            npt.assert_array_equal(line.get_color(), pal_color)\n\n        for point_color, pal_color in zip(ax.collections[0].get_facecolors(),\n                                          palette):\n            npt.assert_array_equal(rgb2hex(point_color), rgb2hex(pal_color))\n\n        plt.close(\"all\")\n\n        \n        palette = palettes.color_palette(\"dark\", 2)\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", data=self.df, palette=\"dark\")\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        for line in ax.lines[:(len(p.plot_data) + 1)]:\n            nt.assert_equal(line.get_color(), palette[0])\n        for line in ax.lines[(len(p.plot_data) + 1):]:\n            nt.assert_equal(line.get_color(), palette[1])\n\n        for i, pal_color in enumerate(palette):\n            for point_color in ax.collections[i].get_facecolors():\n                npt.assert_array_equal(point_color[:-1], pal_color)\n\n        plt.close(\"all\")\n\n    def test_simple_pointplots(self):\n\n        ax = cat.pointplot(\"g\", \"y\", data=self.df)\n        nt.assert_equal(len(ax.collections), 1)\n        nt.assert_equal(len(ax.lines), len(self.g.unique()) + 1)\n        nt.assert_equal(ax.get_xlabel(), \"g\")\n        nt.assert_equal(ax.get_ylabel(), \"y\")\n        plt.close(\"all\")\n\n        ax = cat.pointplot(\"y\", \"g\", orient=\"h\", data=self.df)\n        nt.assert_equal(len(ax.collections), 1)\n        nt.assert_equal(len(ax.lines), len(self.g.unique()) + 1)\n        nt.assert_equal(ax.get_xlabel(), \"y\")\n        nt.assert_equal(ax.get_ylabel(), \"g\")\n        plt.close(\"all\")\n\n        ax = cat.pointplot(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(len(ax.collections), len(self.h.unique()))\n        nt.assert_equal(len(ax.lines),\n                        (len(self.g.unique()) *\n                         len(self.h.unique()) +\n                         len(self.h.unique())))\n        nt.assert_equal(ax.get_xlabel(), \"g\")\n        nt.assert_equal(ax.get_ylabel(), \"y\")\n        plt.close(\"all\")\n\n        ax = cat.pointplot(\"y\", \"g\", \"h\", orient=\"h\", data=self.df)\n        nt.assert_equal(len(ax.collections), len(self.h.unique()))\n        nt.assert_equal(len(ax.lines),\n                        (len(self.g.unique()) *\n                         len(self.h.unique()) +\n                         len(self.h.unique())))\n        nt.assert_equal(ax.get_xlabel(), \"y\")\n        nt.assert_equal(ax.get_ylabel(), \"g\")\n        plt.close(\"all\")\n\n\nclass TestCountPlot(CategoricalFixture):\n\n    def test_plot_elements(self):\n\n        ax = cat.countplot(\"g\", data=self.df)\n        nt.assert_equal(len(ax.patches), self.g.unique().size)\n        for p in ax.patches:\n            nt.assert_equal(p.get_y(), 0)\n            nt.assert_equal(p.get_height(),\n                            self.g.size / self.g.unique().size)\n        plt.close(\"all\")\n\n        ax = cat.countplot(y=\"g\", data=self.df)\n        nt.assert_equal(len(ax.patches), self.g.unique().size)\n        for p in ax.patches:\n            nt.assert_equal(p.get_x(), 0)\n            nt.assert_equal(p.get_width(),\n                            self.g.size / self.g.unique().size)\n        plt.close(\"all\")\n\n        ax = cat.countplot(\"g\", hue=\"h\", data=self.df)\n        nt.assert_equal(len(ax.patches),\n                        self.g.unique().size * self.h.unique().size)\n        plt.close(\"all\")\n\n        ax = cat.countplot(y=\"g\", hue=\"h\", data=self.df)\n        nt.assert_equal(len(ax.patches),\n                        self.g.unique().size * self.h.unique().size)\n        plt.close(\"all\")\n\n    def test_input_error(self):\n\n        with nt.assert_raises(TypeError):\n            cat.countplot()\n\n        with nt.assert_raises(TypeError):\n            cat.countplot(x=\"g\", y=\"h\", data=self.df)\n\n\nclass TestFactorPlot(CategoricalFixture):\n\n    def test_facet_organization(self):\n\n        g = cat.factorplot(\"g\", \"y\", data=self.df)\n        nt.assert_equal(g.axes.shape, (1, 1))\n\n        g = cat.factorplot(\"g\", \"y\", col=\"h\", data=self.df)\n        nt.assert_equal(g.axes.shape, (1, 2))\n\n        g = cat.factorplot(\"g\", \"y\", row=\"h\", data=self.df)\n        nt.assert_equal(g.axes.shape, (2, 1))\n\n        g = cat.factorplot(\"g\", \"y\", col=\"u\", row=\"h\", data=self.df)\n        nt.assert_equal(g.axes.shape, (2, 3))\n\n    def test_plot_elements(self):\n\n        g = cat.factorplot(\"g\", \"y\", data=self.df)\n        nt.assert_equal(len(g.ax.collections), 1)\n        want_lines = self.g.unique().size + 1\n        nt.assert_equal(len(g.ax.lines), want_lines)\n\n        g = cat.factorplot(\"g\", \"y\", \"h\", data=self.df)\n        want_collections = self.h.unique().size\n        nt.assert_equal(len(g.ax.collections), want_collections)\n        want_lines = (self.g.unique().size + 1) * self.h.unique().size\n        nt.assert_equal(len(g.ax.lines), want_lines)\n\n        g = cat.factorplot(\"g\", \"y\", data=self.df, kind=\"bar\")\n        want_elements = self.g.unique().size\n        nt.assert_equal(len(g.ax.patches), want_elements)\n        nt.assert_equal(len(g.ax.lines), want_elements)\n\n        g = cat.factorplot(\"g\", \"y\", \"h\", data=self.df, kind=\"bar\")\n        want_elements = self.g.unique().size * self.h.unique().size\n        nt.assert_equal(len(g.ax.patches), want_elements)\n        nt.assert_equal(len(g.ax.lines), want_elements)\n\n        g = cat.factorplot(\"g\", data=self.df, kind=\"count\")\n        want_elements = self.g.unique().size\n        nt.assert_equal(len(g.ax.patches), want_elements)\n        nt.assert_equal(len(g.ax.lines), 0)\n\n        g = cat.factorplot(\"g\", hue=\"h\", data=self.df, kind=\"count\")\n        want_elements = self.g.unique().size * self.h.unique().size\n        nt.assert_equal(len(g.ax.patches), want_elements)\n        nt.assert_equal(len(g.ax.lines), 0)\n\n        g = cat.factorplot(\"g\", \"y\", data=self.df, kind=\"box\")\n        want_artists = self.g.unique().size\n        nt.assert_equal(len(g.ax.artists), want_artists)\n\n        g = cat.factorplot(\"g\", \"y\", \"h\", data=self.df, kind=\"box\")\n        want_artists = self.g.unique().size * self.h.unique().size\n        nt.assert_equal(len(g.ax.artists), want_artists)\n\n        g = cat.factorplot(\"g\", \"y\", data=self.df,\n                           kind=\"violin\", inner=None)\n        want_elements = self.g.unique().size\n        nt.assert_equal(len(g.ax.collections), want_elements)\n\n        g = cat.factorplot(\"g\", \"y\", \"h\", data=self.df,\n                           kind=\"violin\", inner=None)\n        want_elements = self.g.unique().size * self.h.unique().size\n        nt.assert_equal(len(g.ax.collections), want_elements)\n\n        g = cat.factorplot(\"g\", \"y\", data=self.df, kind=\"strip\")\n        want_elements = self.g.unique().size\n        nt.assert_equal(len(g.ax.collections), want_elements)\n\n        g = cat.factorplot(\"g\", \"y\", \"h\", data=self.df, kind=\"strip\")\n        want_elements = self.g.unique().size + self.h.unique().size\n        nt.assert_equal(len(g.ax.collections), want_elements)\n\n    def test_bad_plot_kind_error(self):\n\n        with nt.assert_raises(ValueError):\n            cat.factorplot(\"g\", \"y\", data=self.df, kind=\"not_a_kind\")\n\n    def test_count_x_and_y(self):\n\n        with nt.assert_raises(ValueError):\n            cat.factorplot(\"g\", \"y\", data=self.df, kind=\"count\")\n\n    def test_plot_colors(self):\n\n        ax = cat.barplot(\"g\", \"y\", data=self.df)\n        g = cat.factorplot(\"g\", \"y\", data=self.df, kind=\"bar\")\n        for p1, p2 in zip(ax.patches, g.ax.patches):\n            nt.assert_equal(p1.get_facecolor(), p2.get_facecolor())\n        plt.close(\"all\")\n\n        ax = cat.barplot(\"g\", \"y\", data=self.df, color=\"purple\")\n        g = cat.factorplot(\"g\", \"y\", data=self.df,\n                           kind=\"bar\", color=\"purple\")\n        for p1, p2 in zip(ax.patches, g.ax.patches):\n            nt.assert_equal(p1.get_facecolor(), p2.get_facecolor())\n        plt.close(\"all\")\n\n        ax = cat.barplot(\"g\", \"y\", data=self.df, palette=\"Set2\")\n        g = cat.factorplot(\"g\", \"y\", data=self.df,\n                           kind=\"bar\", palette=\"Set2\")\n        for p1, p2 in zip(ax.patches, g.ax.patches):\n            nt.assert_equal(p1.get_facecolor(), p2.get_facecolor())\n        plt.close(\"all\")\n\n        ax = cat.pointplot(\"g\", \"y\", data=self.df)\n        g = cat.factorplot(\"g\", \"y\", data=self.df)\n        for l1, l2 in zip(ax.lines, g.ax.lines):\n            nt.assert_equal(l1.get_color(), l2.get_color())\n        plt.close(\"all\")\n\n        ax = cat.pointplot(\"g\", \"y\", data=self.df, color=\"purple\")\n        g = cat.factorplot(\"g\", \"y\", data=self.df, color=\"purple\")\n        for l1, l2 in zip(ax.lines, g.ax.lines):\n            nt.assert_equal(l1.get_color(), l2.get_color())\n        plt.close(\"all\")\n\n        ax = cat.pointplot(\"g\", \"y\", data=self.df, palette=\"Set2\")\n        g = cat.factorplot(\"g\", \"y\", data=self.df, palette=\"Set2\")\n        for l1, l2 in zip(ax.lines, g.ax.lines):\n            nt.assert_equal(l1.get_color(), l2.get_color())\n        plt.close(\"all\")\n\n\nclass TestLVPlotter(CategoricalFixture):\n\n    default_kws = dict(x=None, y=None, hue=None, data=None,\n                            order=None, hue_order=None,\n                            orient=None, color=None, palette=None,\n                            saturation=.75, width=.8, dodge=True,\n                            k_depth='proportion', linewidth=None,\n                            scale='exponential', outlier_prop=None)\n\n    def ispatch(self, c):\n\n        return isinstance(c, mpl.collections.PatchCollection)\n\n    def edge_calc(self, n, data):\n\n        q = np.asanyarray([0.5 ** n, 1 - 0.5 ** n]) * 100\n        q = list(np.unique(q))\n        return np.percentile(data, q)\n\n    def test_box_ends_finite(self):\n        p = cat._LVPlotter(**self.default_kws)\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        box_k = np.asarray([[b, k]\n                           for b, k in map(p._lv_box_ends, p.plot_data)])\n        box_ends = box_k[:, 0]\n        k_vals = box_k[:, 1]\n\n        \n        \n        b_e = map(lambda a: np.all(np.isfinite(a)), box_ends)\n        npt.assert_equal(np.sum(list(b_e)), len(box_ends))\n\n        def within(t):\n            a, d = t\n            return ((np.ravel(a) <= d.max()) &\n                    (np.ravel(a) >= d.min())).all()\n\n        b_w = map(within, zip(box_ends, p.plot_data))\n        npt.assert_equal(np.sum(list(b_w)), len(box_ends))\n\n        k_f = map(lambda k: (k > 0.) & np.isfinite(k), k_vals)\n        npt.assert_equal(np.sum(list(k_f)), len(k_vals))\n\n    def test_box_ends_correct(self):\n\n        n = 100\n        linear_data = np.arange(n)\n        expected_k = int(np.log2(n)) - int(np.log2(n * 0.007)) + 1\n        expected_edges = [self.edge_calc(i, linear_data)\n                          for i in range(expected_k + 2, 1, -1)]\n\n        p = cat._LVPlotter(**self.default_kws)\n        calc_edges, calc_k = p._lv_box_ends(linear_data)\n\n        npt.assert_equal(list(expected_edges), calc_edges)\n        npt.assert_equal(expected_k, calc_k)\n\n    def test_outliers(self):\n\n        n = 100\n        outlier_data = np.append(np.arange(n - 1), 2 * n)\n        expected_k = int(np.log2(n)) - int(np.log2(n * 0.007)) + 1\n        expected_edges = [self.edge_calc(i, outlier_data)\n                          for i in range(expected_k + 2, 1, -1)]\n\n        p = cat._LVPlotter(**self.default_kws)\n        calc_edges, calc_k = p._lv_box_ends(outlier_data)\n\n        npt.assert_equal(list(expected_edges), calc_edges)\n\n        npt.assert_equal(expected_k, calc_k)\n\n        out_calc = p._lv_outliers(outlier_data, calc_k)\n        out_exp = p._lv_outliers(outlier_data, expected_k)\n\n        npt.assert_equal(out_exp, out_calc)\n\n    def test_hue_offsets(self):\n\n        p = cat._LVPlotter(**self.default_kws)\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        npt.assert_array_equal(p.hue_offsets, [-.2, .2])\n\n        kws = self.default_kws.copy()\n        kws[\"width\"] = .6\n        p = cat._LVPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        npt.assert_array_equal(p.hue_offsets, [-.15, .15])\n\n        p = cat._LVPlotter(**kws)\n        p.establish_variables(\"h\", \"y\", \"g\", data=self.df)\n        npt.assert_array_almost_equal(p.hue_offsets, [-.2, 0, .2])\n\n    def test_axes_data(self):\n\n        ax = cat.lvplot(\"g\", \"y\", data=self.df)\n        patches = filter(self.ispatch, ax.collections)\n        nt.assert_equal(len(list(patches)), 3)\n\n        plt.close(\"all\")\n\n        ax = cat.lvplot(\"g\", \"y\", \"h\", data=self.df)\n        patches = filter(self.ispatch, ax.collections)\n        nt.assert_equal(len(list(patches)), 6)\n\n        plt.close(\"all\")\n\n    def test_box_colors(self):\n\n        ax = cat.lvplot(\"g\", \"y\", data=self.df, saturation=1)\n        pal = palettes.color_palette(n_colors=3)\n        for patch, color in zip(ax.artists, pal):\n            nt.assert_equal(patch.get_facecolor()[:3], color)\n\n        plt.close(\"all\")\n\n        ax = cat.lvplot(\"g\", \"y\", \"h\", data=self.df, saturation=1)\n        pal = palettes.color_palette(n_colors=2)\n        for patch, color in zip(ax.artists, pal * 2):\n            nt.assert_equal(patch.get_facecolor()[:3], color)\n\n        plt.close(\"all\")\n\n    def test_draw_missing_boxes(self):\n\n        ax = cat.lvplot(\"g\", \"y\", data=self.df,\n                        order=[\"a\", \"b\", \"c\", \"d\"])\n\n        patches = filter(self.ispatch, ax.collections)\n        nt.assert_equal(len(list(patches)), 3)\n        plt.close(\"all\")\n\n    def test_missing_data(self):\n\n        x = [\"a\", \"a\", \"b\", \"b\", \"c\", \"c\", \"d\", \"d\"]\n        h = [\"x\", \"y\", \"x\", \"y\", \"x\", \"y\", \"x\", \"y\"]\n        y = self.rs.randn(8)\n        y[-2:] = np.nan\n\n        ax = cat.lvplot(x, y)\n        patches = filter(self.ispatch, ax.collections)\n        nt.assert_equal(len(ax.lines), 3)\n\n        plt.close(\"all\")\n\n        y[-1] = 0\n        ax = cat.lvplot(x, y, h)\n        nt.assert_equal(len(ax.lines), 7)\n\n        plt.close(\"all\")\n\n    def test_lvplots(self):\n\n        \n\n        cat.lvplot(\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.lvplot(y=\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.lvplot(\"g\", \"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.lvplot(\"y\", \"g\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n        cat.lvplot(\"g\", \"y\", \"h\", data=self.df)\n        plt.close(\"all\")\n\n        cat.lvplot(\"g\", \"y\", \"h\", order=list(\"nabc\"), data=self.df)\n        plt.close(\"all\")\n\n        cat.lvplot(\"g\", \"y\", \"h\", hue_order=list(\"omn\"), data=self.df)\n        plt.close(\"all\")\n\n        cat.lvplot(\"y\", \"g\", \"h\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n    def test_axes_annotation(self):\n\n        ax = cat.lvplot(\"g\", \"y\", data=self.df)\n        nt.assert_equal(ax.get_xlabel(), \"g\")\n        nt.assert_equal(ax.get_ylabel(), \"y\")\n        nt.assert_equal(ax.get_xlim(), (-.5, 2.5))\n        npt.assert_array_equal(ax.get_xticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_xticklabels()],\n                               [\"a\", \"b\", \"c\"])\n\n        plt.close(\"all\")\n\n        ax = cat.lvplot(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(ax.get_xlabel(), \"g\")\n        nt.assert_equal(ax.get_ylabel(), \"y\")\n        npt.assert_array_equal(ax.get_xticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_xticklabels()],\n                               [\"a\", \"b\", \"c\"])\n        npt.assert_array_equal([l.get_text() for l in ax.legend_.get_texts()],\n                               [\"m\", \"n\"])\n\n        plt.close(\"all\")\n\n        ax = cat.lvplot(\"y\", \"g\", data=self.df, orient=\"h\")\n        nt.assert_equal(ax.get_xlabel(), \"y\")\n        nt.assert_equal(ax.get_ylabel(), \"g\")\n        nt.assert_equal(ax.get_ylim(), (2.5, -.5))\n        npt.assert_array_equal(ax.get_yticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_yticklabels()],\n                               [\"a\", \"b\", \"c\"])\n\n        plt.close(\"all\")\n", "comments": "   test boxplot (also base class things like violinplots)        test basic wide dataframe    check data attribute    check semantic attributes    test wide dataframe forced horizontal orientation    text exception trying hue group wide dataframe    test basic vector data    test basic vector data list form    test object array looks 1d    test vector data looks 2d really columns    test vector data looks 2d really rows    test passing actually 3d data raises    test 2d input list form    test 2d input array form    test passing series x variable    test passing series variable    test passing array variable    test referencing dataframe series x variable    test referencing dataframe series variable    test vertically oriented grouped nested plot    test grouped nested plot direct array value data    test grouped nested plot direct array hue data    test categorical grouping data    test horizontal orientation automatically detected    test inferred order wide dataframe input    test specified order wide dataframe input    test inferred order grouped longform input    test specified order grouped longform input    test inferred order grouped input categorical groups    test inferred hue order    test specified hue order    test inferred hue order categorical hue input    test palette mapping x position    test palette mapping hue position    test color x position    test color based blend hue mapping    test palette mapping x position    test non none  color   hue  raises error    test specified palette overrides specified color    test vertical cis    test horizontal cis    test vertical cis endcaps    test horizontal cis endcaps    test extra keyword arguments    test errwidth set appropriately    smoke test high level boxplot options    test single layer grouping    test nested grouping scaling across densities    test nested grouping scaling within hue    test single layer grouping    test nested grouping    test single layer grouping    test nested grouping scaling across densities    test nested grouping scaling within hue    bandwidth behavior depends scipy version    test ignoring custom bandwidth old scipy    test reference rule bandwidth    test numeric scale factor    p dwidth 1 easier testing    test verical plots    test full vertical plot    test left vertical plot    test right vertical plot    switch orientation test horizontal plots    test full horizontal plot    test left horizontal plot    test right horizontal plot    test vertical plot    test horizontal plot    test vertical plot    test horizontal plot    test vertical plot    test horizontal plot    test vertical plot    test horizontal plot    test single vertical violin    test single horizontal violin    test multiple vertical violins    test multiple violins hue nesting    test multiple split violins    test single layer grouping    test nested hue grouping    test single layer grouping    test nested hue grouping    test nested hue grouping split    smoke test high level violinplot options    test simple vertical strip plot    test unnested palette colors    test single color    test nested palette colors    test single color unnested plot    test multi color unnested plot    test multi colored nested plot    check box ends finite within    bounds data    smoke test high level lvplot options ", "content": "import numpy as np\nimport pandas as pd\nimport scipy\nfrom scipy import stats, spatial\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import rgb2hex\n\nfrom distutils.version import LooseVersion\n\nimport nose.tools as nt\nimport numpy.testing as npt\nfrom numpy.testing.decorators import skipif\n\nfrom .. import categorical as cat\nfrom .. import palettes\n\n\npandas_has_categoricals = LooseVersion(pd.__version__) >= \"0.15\"\nmpl_barplot_change = LooseVersion(\"2.0.1\")\n\n\nclass CategoricalFixture(object):\n    \"\"\"Test boxplot (also base class for things like violinplots).\"\"\"\n    rs = np.random.RandomState(30)\n    n_total = 60\n    x = rs.randn(int(n_total / 3), 3)\n    x_df = pd.DataFrame(x, columns=pd.Series(list(\"XYZ\"), name=\"big\"))\n    y = pd.Series(rs.randn(n_total), name=\"y_data\")\n    g = pd.Series(np.repeat(list(\"abc\"), int(n_total / 3)), name=\"small\")\n    h = pd.Series(np.tile(list(\"mn\"), int(n_total / 2)), name=\"medium\")\n    u = pd.Series(np.tile(list(\"jkh\"), int(n_total / 3)))\n    df = pd.DataFrame(dict(y=y, g=g, h=h, u=u))\n    x_df[\"W\"] = g\n\n\nclass TestCategoricalPlotter(CategoricalFixture):\n\n    def test_wide_df_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test basic wide DataFrame\n        p.establish_variables(data=self.x_df)\n\n        # Check data attribute\n        for x, y, in zip(p.plot_data, self.x_df[[\"X\", \"Y\", \"Z\"]].values.T):\n            npt.assert_array_equal(x, y)\n\n        # Check semantic attributes\n        nt.assert_equal(p.orient, \"v\")\n        nt.assert_is(p.plot_hues, None)\n        nt.assert_is(p.group_label, \"big\")\n        nt.assert_is(p.value_label, None)\n\n        # Test wide dataframe with forced horizontal orientation\n        p.establish_variables(data=self.x_df, orient=\"horiz\")\n        nt.assert_equal(p.orient, \"h\")\n\n        # Text exception by trying to hue-group with a wide dataframe\n        with nt.assert_raises(ValueError):\n            p.establish_variables(hue=\"d\", data=self.x_df)\n\n    def test_1d_input_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test basic vector data\n        x_1d_array = self.x.ravel()\n        p.establish_variables(data=x_1d_array)\n        nt.assert_equal(len(p.plot_data), 1)\n        nt.assert_equal(len(p.plot_data[0]), self.n_total)\n        nt.assert_is(p.group_label, None)\n        nt.assert_is(p.value_label, None)\n\n        # Test basic vector data in list form\n        x_1d_list = x_1d_array.tolist()\n        p.establish_variables(data=x_1d_list)\n        nt.assert_equal(len(p.plot_data), 1)\n        nt.assert_equal(len(p.plot_data[0]), self.n_total)\n        nt.assert_is(p.group_label, None)\n        nt.assert_is(p.value_label, None)\n\n        # Test an object array that looks 1D but isn't\n        x_notreally_1d = np.array([self.x.ravel(),\n                                   self.x.ravel()[:int(self.n_total / 2)]])\n        p.establish_variables(data=x_notreally_1d)\n        nt.assert_equal(len(p.plot_data), 2)\n        nt.assert_equal(len(p.plot_data[0]), self.n_total)\n        nt.assert_equal(len(p.plot_data[1]), self.n_total / 2)\n        nt.assert_is(p.group_label, None)\n        nt.assert_is(p.value_label, None)\n\n    def test_2d_input_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        x = self.x[:, 0]\n\n        # Test vector data that looks 2D but doesn't really have columns\n        p.establish_variables(data=x[:, np.newaxis])\n        nt.assert_equal(len(p.plot_data), 1)\n        nt.assert_equal(len(p.plot_data[0]), self.x.shape[0])\n        nt.assert_is(p.group_label, None)\n        nt.assert_is(p.value_label, None)\n\n        # Test vector data that looks 2D but doesn't really have rows\n        p.establish_variables(data=x[np.newaxis, :])\n        nt.assert_equal(len(p.plot_data), 1)\n        nt.assert_equal(len(p.plot_data[0]), self.x.shape[0])\n        nt.assert_is(p.group_label, None)\n        nt.assert_is(p.value_label, None)\n\n    def test_3d_input_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test that passing actually 3D data raises\n        x = np.zeros((5, 5, 5))\n        with nt.assert_raises(ValueError):\n            p.establish_variables(data=x)\n\n    def test_list_of_array_input_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test 2D input in list form\n        x_list = self.x.T.tolist()\n        p.establish_variables(data=x_list)\n        nt.assert_equal(len(p.plot_data), 3)\n\n        lengths = [len(v_i) for v_i in p.plot_data]\n        nt.assert_equal(lengths, [self.n_total / 3] * 3)\n\n        nt.assert_is(p.group_label, None)\n        nt.assert_is(p.value_label, None)\n\n    def test_wide_array_input_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test 2D input in array form\n        p.establish_variables(data=self.x)\n        nt.assert_equal(np.shape(p.plot_data), (3, self.n_total / 3))\n        npt.assert_array_equal(p.plot_data, self.x.T)\n\n        nt.assert_is(p.group_label, None)\n        nt.assert_is(p.value_label, None)\n\n    def test_single_long_direct_inputs(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test passing a series to the x variable\n        p.establish_variables(x=self.y)\n        npt.assert_equal(p.plot_data, [self.y])\n        nt.assert_equal(p.orient, \"h\")\n        nt.assert_equal(p.value_label, \"y_data\")\n        nt.assert_is(p.group_label, None)\n\n        # Test passing a series to the y variable\n        p.establish_variables(y=self.y)\n        npt.assert_equal(p.plot_data, [self.y])\n        nt.assert_equal(p.orient, \"v\")\n        nt.assert_equal(p.value_label, \"y_data\")\n        nt.assert_is(p.group_label, None)\n\n        # Test passing an array to the y variable\n        p.establish_variables(y=self.y.values)\n        npt.assert_equal(p.plot_data, [self.y])\n        nt.assert_equal(p.orient, \"v\")\n        nt.assert_is(p.value_label, None)\n        nt.assert_is(p.group_label, None)\n\n    def test_single_long_indirect_inputs(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test referencing a DataFrame series in the x variable\n        p.establish_variables(x=\"y\", data=self.df)\n        npt.assert_equal(p.plot_data, [self.y])\n        nt.assert_equal(p.orient, \"h\")\n        nt.assert_equal(p.value_label, \"y\")\n        nt.assert_is(p.group_label, None)\n\n        # Test referencing a DataFrame series in the y variable\n        p.establish_variables(y=\"y\", data=self.df)\n        npt.assert_equal(p.plot_data, [self.y])\n        nt.assert_equal(p.orient, \"v\")\n        nt.assert_equal(p.value_label, \"y\")\n        nt.assert_is(p.group_label, None)\n\n    def test_longform_groupby(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test a vertically oriented grouped and nested plot\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(len(p.plot_data), 3)\n        nt.assert_equal(len(p.plot_hues), 3)\n        nt.assert_equal(p.orient, \"v\")\n        nt.assert_equal(p.value_label, \"y\")\n        nt.assert_equal(p.group_label, \"g\")\n        nt.assert_equal(p.hue_title, \"h\")\n\n        for group, vals in zip([\"a\", \"b\", \"c\"], p.plot_data):\n            npt.assert_array_equal(vals, self.y[self.g == group])\n\n        for group, hues in zip([\"a\", \"b\", \"c\"], p.plot_hues):\n            npt.assert_array_equal(hues, self.h[self.g == group])\n\n        # Test a grouped and nested plot with direct array value data\n        p.establish_variables(\"g\", self.y.values, \"h\", self.df)\n        nt.assert_is(p.value_label, None)\n        nt.assert_equal(p.group_label, \"g\")\n\n        for group, vals in zip([\"a\", \"b\", \"c\"], p.plot_data):\n            npt.assert_array_equal(vals, self.y[self.g == group])\n\n        # Test a grouped and nested plot with direct array hue data\n        p.establish_variables(\"g\", \"y\", self.h.values, self.df)\n\n        for group, hues in zip([\"a\", \"b\", \"c\"], p.plot_hues):\n            npt.assert_array_equal(hues, self.h[self.g == group])\n\n        # Test categorical grouping data\n        if pandas_has_categoricals:\n            df = self.df.copy()\n            df.g = df.g.astype(\"category\")\n\n            # Test that horizontal orientation is automatically detected\n            p.establish_variables(\"y\", \"g\", \"h\", data=df)\n            nt.assert_equal(len(p.plot_data), 3)\n            nt.assert_equal(len(p.plot_hues), 3)\n            nt.assert_equal(p.orient, \"h\")\n            nt.assert_equal(p.value_label, \"y\")\n            nt.assert_equal(p.group_label, \"g\")\n            nt.assert_equal(p.hue_title, \"h\")\n\n            for group, vals in zip([\"a\", \"b\", \"c\"], p.plot_data):\n                npt.assert_array_equal(vals, self.y[self.g == group])\n\n            for group, hues in zip([\"a\", \"b\", \"c\"], p.plot_hues):\n                npt.assert_array_equal(hues, self.h[self.g == group])\n\n    def test_input_validation(self):\n\n        p = cat._CategoricalPlotter()\n\n        kws = dict(x=\"g\", y=\"y\", hue=\"h\", units=\"u\", data=self.df)\n        for input in [\"x\", \"y\", \"hue\", \"units\"]:\n            input_kws = kws.copy()\n            input_kws[input] = \"bad_input\"\n            with nt.assert_raises(ValueError):\n                p.establish_variables(**input_kws)\n\n    def test_order(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test inferred order from a wide dataframe input\n        p.establish_variables(data=self.x_df)\n        nt.assert_equal(p.group_names, [\"X\", \"Y\", \"Z\"])\n\n        # Test specified order with a wide dataframe input\n        p.establish_variables(data=self.x_df, order=[\"Y\", \"Z\", \"X\"])\n        nt.assert_equal(p.group_names, [\"Y\", \"Z\", \"X\"])\n\n        for group, vals in zip([\"Y\", \"Z\", \"X\"], p.plot_data):\n            npt.assert_array_equal(vals, self.x_df[group])\n\n        with nt.assert_raises(ValueError):\n            p.establish_variables(data=self.x, order=[1, 2, 0])\n\n        # Test inferred order from a grouped longform input\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        nt.assert_equal(p.group_names, [\"a\", \"b\", \"c\"])\n\n        # Test specified order from a grouped longform input\n        p.establish_variables(\"g\", \"y\", data=self.df, order=[\"b\", \"a\", \"c\"])\n        nt.assert_equal(p.group_names, [\"b\", \"a\", \"c\"])\n\n        for group, vals in zip([\"b\", \"a\", \"c\"], p.plot_data):\n            npt.assert_array_equal(vals, self.y[self.g == group])\n\n        # Test inferred order from a grouped input with categorical groups\n        if pandas_has_categoricals:\n            df = self.df.copy()\n            df.g = df.g.astype(\"category\")\n            df.g = df.g.cat.reorder_categories([\"c\", \"b\", \"a\"])\n            p.establish_variables(\"g\", \"y\", data=df)\n            nt.assert_equal(p.group_names, [\"c\", \"b\", \"a\"])\n\n            for group, vals in zip([\"c\", \"b\", \"a\"], p.plot_data):\n                npt.assert_array_equal(vals, self.y[self.g == group])\n\n            df.g = (df.g.cat.add_categories(\"d\")\n                        .cat.reorder_categories([\"c\", \"b\", \"d\", \"a\"]))\n            p.establish_variables(\"g\", \"y\", data=df)\n            nt.assert_equal(p.group_names, [\"c\", \"b\", \"d\", \"a\"])\n\n    def test_hue_order(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test inferred hue order\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(p.hue_names, [\"m\", \"n\"])\n\n        # Test specified hue order\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df,\n                              hue_order=[\"n\", \"m\"])\n        nt.assert_equal(p.hue_names, [\"n\", \"m\"])\n\n        # Test inferred hue order from a categorical hue input\n        if pandas_has_categoricals:\n            df = self.df.copy()\n            df.h = df.h.astype(\"category\")\n            df.h = df.h.cat.reorder_categories([\"n\", \"m\"])\n            p.establish_variables(\"g\", \"y\", \"h\", data=df)\n            nt.assert_equal(p.hue_names, [\"n\", \"m\"])\n\n            df.h = (df.h.cat.add_categories(\"o\")\n                        .cat.reorder_categories([\"o\", \"m\", \"n\"]))\n            p.establish_variables(\"g\", \"y\", \"h\", data=df)\n            nt.assert_equal(p.hue_names, [\"o\", \"m\", \"n\"])\n\n    def test_plot_units(self):\n\n        p = cat._CategoricalPlotter()\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_is(p.plot_units, None)\n\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df, units=\"u\")\n        for group, units in zip([\"a\", \"b\", \"c\"], p.plot_units):\n            npt.assert_array_equal(units, self.u[self.g == group])\n\n    def test_infer_orient(self):\n\n        p = cat._CategoricalPlotter()\n\n        cats = pd.Series([\"a\", \"b\", \"c\"] * 10)\n        nums = pd.Series(self.rs.randn(30))\n\n        nt.assert_equal(p.infer_orient(cats, nums), \"v\")\n        nt.assert_equal(p.infer_orient(nums, cats), \"h\")\n        nt.assert_equal(p.infer_orient(nums, None), \"h\")\n        nt.assert_equal(p.infer_orient(None, nums), \"v\")\n        nt.assert_equal(p.infer_orient(nums, nums, \"vert\"), \"v\")\n        nt.assert_equal(p.infer_orient(nums, nums, \"hori\"), \"h\")\n\n        with nt.assert_raises(ValueError):\n            p.infer_orient(cats, cats)\n\n        if pandas_has_categoricals:\n            cats = pd.Series([0, 1, 2] * 10, dtype=\"category\")\n            nt.assert_equal(p.infer_orient(cats, nums), \"v\")\n            nt.assert_equal(p.infer_orient(nums, cats), \"h\")\n\n            with nt.assert_raises(ValueError):\n                p.infer_orient(cats, cats)\n\n    def test_default_palettes(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test palette mapping the x position\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(None, None, 1)\n        nt.assert_equal(p.colors, palettes.color_palette(n_colors=3))\n\n        # Test palette mapping the hue position\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        p.establish_colors(None, None, 1)\n        nt.assert_equal(p.colors, palettes.color_palette(n_colors=2))\n\n    def test_default_palette_with_many_levels(self):\n\n        with palettes.color_palette([\"blue\", \"red\"], 2):\n            p = cat._CategoricalPlotter()\n            p.establish_variables(\"g\", \"y\", data=self.df)\n            p.establish_colors(None, None, 1)\n            npt.assert_array_equal(p.colors, palettes.husl_palette(3, l=.7))\n\n    def test_specific_color(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test the same color for each x position\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(\"blue\", None, 1)\n        blue_rgb = mpl.colors.colorConverter.to_rgb(\"blue\")\n        nt.assert_equal(p.colors, [blue_rgb] * 3)\n\n        # Test a color-based blend for the hue mapping\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        p.establish_colors(\"#ff0022\", None, 1)\n        rgba_array = np.array(palettes.light_palette(\"#ff0022\", 2))\n        npt.assert_array_almost_equal(p.colors,\n                                      rgba_array[:, :3])\n\n    def test_specific_palette(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test palette mapping the x position\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(None, \"dark\", 1)\n        nt.assert_equal(p.colors, palettes.color_palette(\"dark\", 3))\n\n        # Test that non-None `color` and `hue` raises an error\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        p.establish_colors(None, \"muted\", 1)\n        nt.assert_equal(p.colors, palettes.color_palette(\"muted\", 2))\n\n        # Test that specified palette overrides specified color\n        p = cat._CategoricalPlotter()\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(\"blue\", \"deep\", 1)\n        nt.assert_equal(p.colors, palettes.color_palette(\"deep\", 3))\n\n    def test_dict_as_palette(self):\n\n        p = cat._CategoricalPlotter()\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        pal = {\"m\": (0, 0, 1), \"n\": (1, 0, 0)}\n        p.establish_colors(None, pal, 1)\n        nt.assert_equal(p.colors, [(0, 0, 1), (1, 0, 0)])\n\n    def test_palette_desaturation(self):\n\n        p = cat._CategoricalPlotter()\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors((0, 0, 1), None, .5)\n        nt.assert_equal(p.colors, [(.25, .25, .75)] * 3)\n\n        p.establish_colors(None, [(0, 0, 1), (1, 0, 0), \"w\"], .5)\n        nt.assert_equal(p.colors, [(.25, .25, .75),\n                                   (.75, .25, .25),\n                                   (1, 1, 1)])\n\n\nclass TestCategoricalStatPlotter(CategoricalFixture):\n\n    def test_no_bootstrappig(self):\n\n        p = cat._CategoricalStatPlotter()\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.estimate_statistic(np.mean, None, 100)\n        npt.assert_array_equal(p.confint, np.array([]))\n\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        p.estimate_statistic(np.mean, None, 100)\n        npt.assert_array_equal(p.confint, np.array([[], [], []]))\n\n    def test_single_layer_stats(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n\n        p.establish_variables(g, y)\n        p.estimate_statistic(np.mean, 95, 10000)\n\n        nt.assert_equal(p.statistic.shape, (3,))\n        nt.assert_equal(p.confint.shape, (3, 2))\n\n        npt.assert_array_almost_equal(p.statistic,\n                                      y.groupby(g).mean())\n\n        for ci, (_, grp_y) in zip(p.confint, y.groupby(g)):\n            sem = stats.sem(grp_y)\n            mean = grp_y.mean()\n            stats.norm.ppf(.975)\n            half_ci = stats.norm.ppf(.975) * sem\n            ci_want = mean - half_ci, mean + half_ci\n            npt.assert_array_almost_equal(ci_want, ci, 2)\n\n    def test_single_layer_stats_with_units(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 90))\n        y = pd.Series(np.random.RandomState(0).randn(270))\n        u = pd.Series(np.repeat(np.tile(list(\"xyz\"), 30), 3))\n        y[u == \"x\"] -= 3\n        y[u == \"y\"] += 3\n\n        p.establish_variables(g, y)\n        p.estimate_statistic(np.mean, 95, 10000)\n        stat1, ci1 = p.statistic, p.confint\n\n        p.establish_variables(g, y, units=u)\n        p.estimate_statistic(np.mean, 95, 10000)\n        stat2, ci2 = p.statistic, p.confint\n\n        npt.assert_array_equal(stat1, stat2)\n        ci1_size = ci1[:, 1] - ci1[:, 0]\n        ci2_size = ci2[:, 1] - ci2[:, 0]\n        npt.assert_array_less(ci1_size, ci2_size)\n\n    def test_single_layer_stats_with_missing_data(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n\n        p.establish_variables(g, y, order=list(\"abdc\"))\n        p.estimate_statistic(np.mean, 95, 10000)\n\n        nt.assert_equal(p.statistic.shape, (4,))\n        nt.assert_equal(p.confint.shape, (4, 2))\n\n        mean = y[g == \"b\"].mean()\n        sem = stats.sem(y[g == \"b\"])\n        half_ci = stats.norm.ppf(.975) * sem\n        ci = mean - half_ci, mean + half_ci\n        npt.assert_almost_equal(p.statistic[1], mean)\n        npt.assert_array_almost_equal(p.confint[1], ci, 2)\n\n        npt.assert_equal(p.statistic[2], np.nan)\n        npt.assert_array_equal(p.confint[2], (np.nan, np.nan))\n\n    def test_nested_stats(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        h = pd.Series(np.tile(list(\"xy\"), 150))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n\n        p.establish_variables(g, y, h)\n        p.estimate_statistic(np.mean, 95, 50000)\n\n        nt.assert_equal(p.statistic.shape, (3, 2))\n        nt.assert_equal(p.confint.shape, (3, 2, 2))\n\n        npt.assert_array_almost_equal(p.statistic,\n                                      y.groupby([g, h]).mean().unstack())\n\n        for ci_g, (_, grp_y) in zip(p.confint, y.groupby(g)):\n            for ci, hue_y in zip(ci_g, [grp_y[::2], grp_y[1::2]]):\n                sem = stats.sem(hue_y)\n                mean = hue_y.mean()\n                half_ci = stats.norm.ppf(.975) * sem\n                ci_want = mean - half_ci, mean + half_ci\n                npt.assert_array_almost_equal(ci_want, ci, 2)\n\n    def test_nested_stats_with_units(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 90))\n        h = pd.Series(np.tile(list(\"xy\"), 135))\n        u = pd.Series(np.repeat(list(\"ijkijk\"), 45))\n        y = pd.Series(np.random.RandomState(0).randn(270))\n        y[u == \"i\"] -= 3\n        y[u == \"k\"] += 3\n\n        p.establish_variables(g, y, h)\n        p.estimate_statistic(np.mean, 95, 10000)\n        stat1, ci1 = p.statistic, p.confint\n\n        p.establish_variables(g, y, h, units=u)\n        p.estimate_statistic(np.mean, 95, 10000)\n        stat2, ci2 = p.statistic, p.confint\n\n        npt.assert_array_equal(stat1, stat2)\n        ci1_size = ci1[:, 0, 1] - ci1[:, 0, 0]\n        ci2_size = ci2[:, 0, 1] - ci2[:, 0, 0]\n        npt.assert_array_less(ci1_size, ci2_size)\n\n    def test_nested_stats_with_missing_data(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n        h = pd.Series(np.tile(list(\"xy\"), 150))\n\n        p.establish_variables(g, y, h,\n                              order=list(\"abdc\"),\n                              hue_order=list(\"zyx\"))\n        p.estimate_statistic(np.mean, 95, 50000)\n\n        nt.assert_equal(p.statistic.shape, (4, 3))\n        nt.assert_equal(p.confint.shape, (4, 3, 2))\n\n        mean = y[(g == \"b\") & (h == \"x\")].mean()\n        sem = stats.sem(y[(g == \"b\") & (h == \"x\")])\n        half_ci = stats.norm.ppf(.975) * sem\n        ci = mean - half_ci, mean + half_ci\n        npt.assert_almost_equal(p.statistic[1, 2], mean)\n        npt.assert_array_almost_equal(p.confint[1, 2], ci, 2)\n\n        npt.assert_array_equal(p.statistic[:, 0], [np.nan] * 4)\n        npt.assert_array_equal(p.statistic[2], [np.nan] * 3)\n        npt.assert_array_equal(p.confint[:, 0],\n                               np.zeros((4, 2)) * np.nan)\n        npt.assert_array_equal(p.confint[2],\n                               np.zeros((3, 2)) * np.nan)\n\n    def test_sd_error_bars(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n\n        p.establish_variables(g, y)\n        p.estimate_statistic(np.mean, \"sd\", None)\n\n        nt.assert_equal(p.statistic.shape, (3,))\n        nt.assert_equal(p.confint.shape, (3, 2))\n\n        npt.assert_array_almost_equal(p.statistic,\n                                      y.groupby(g).mean())\n\n        for ci, (_, grp_y) in zip(p.confint, y.groupby(g)):\n            mean = grp_y.mean()\n            half_ci = np.std(grp_y)\n            ci_want = mean - half_ci, mean + half_ci\n            npt.assert_array_almost_equal(ci_want, ci, 2)\n\n    def test_nested_sd_error_bars(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        h = pd.Series(np.tile(list(\"xy\"), 150))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n\n        p.establish_variables(g, y, h)\n        p.estimate_statistic(np.mean, \"sd\", None)\n\n        nt.assert_equal(p.statistic.shape, (3, 2))\n        nt.assert_equal(p.confint.shape, (3, 2, 2))\n\n        npt.assert_array_almost_equal(p.statistic,\n                                      y.groupby([g, h]).mean().unstack())\n\n        for ci_g, (_, grp_y) in zip(p.confint, y.groupby(g)):\n            for ci, hue_y in zip(ci_g, [grp_y[::2], grp_y[1::2]]):\n                mean = hue_y.mean()\n                half_ci = np.std(hue_y)\n                ci_want = mean - half_ci, mean + half_ci\n                npt.assert_array_almost_equal(ci_want, ci, 2)\n\n    def test_draw_cis(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        # Test vertical CIs\n        p.orient = \"v\"\n\n        f, ax = plt.subplots()\n        at_group = [0, 1]\n        confints = [(.5, 1.5), (.25, .8)]\n        colors = [\".2\", \".3\"]\n        p.draw_confints(ax, at_group, confints, colors)\n\n        lines = ax.lines\n        for line, at, ci, c in zip(lines, at_group, confints, colors):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, [at, at])\n            npt.assert_array_equal(y, ci)\n            nt.assert_equal(line.get_color(), c)\n\n        plt.close(\"all\")\n\n        # Test horizontal CIs\n        p.orient = \"h\"\n\n        f, ax = plt.subplots()\n        p.draw_confints(ax, at_group, confints, colors)\n\n        lines = ax.lines\n        for line, at, ci, c in zip(lines, at_group, confints, colors):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, ci)\n            npt.assert_array_equal(y, [at, at])\n            nt.assert_equal(line.get_color(), c)\n\n        plt.close(\"all\")\n\n        # Test vertical CIs with endcaps\n        p.orient = \"v\"\n\n        f, ax = plt.subplots()\n        p.draw_confints(ax, at_group, confints, colors, capsize=0.3)\n        capline = ax.lines[len(ax.lines) - 1]\n        caplinestart = capline.get_xdata()[0]\n        caplineend = capline.get_xdata()[1]\n        caplinelength = abs(caplineend - caplinestart)\n        nt.assert_almost_equal(caplinelength, 0.3)\n        nt.assert_equal(len(ax.lines), 6)\n\n        plt.close(\"all\")\n\n        # Test horizontal CIs with endcaps\n        p.orient = \"h\"\n\n        f, ax = plt.subplots()\n        p.draw_confints(ax, at_group, confints, colors, capsize=0.3)\n        capline = ax.lines[len(ax.lines) - 1]\n        caplinestart = capline.get_ydata()[0]\n        caplineend = capline.get_ydata()[1]\n        caplinelength = abs(caplineend - caplinestart)\n        nt.assert_almost_equal(caplinelength, 0.3)\n        nt.assert_equal(len(ax.lines), 6)\n\n        # Test extra keyword arguments\n        f, ax = plt.subplots()\n        p.draw_confints(ax, at_group, confints, colors, lw=4)\n        line = ax.lines[0]\n        nt.assert_equal(line.get_linewidth(), 4)\n\n        plt.close(\"all\")\n\n        # Test errwidth is set appropriately\n        f, ax = plt.subplots()\n        p.draw_confints(ax, at_group, confints, colors, errwidth=2)\n        capline = ax.lines[len(ax.lines)-1]\n        nt.assert_equal(capline._linewidth, 2)\n        nt.assert_equal(len(ax.lines), 2)\n\n        plt.close(\"all\")\n\n\nclass TestBoxPlotter(CategoricalFixture):\n\n    default_kws = dict(x=None, y=None, hue=None, data=None,\n                       order=None, hue_order=None,\n                       orient=None, color=None, palette=None,\n                       saturation=.75, width=.8, dodge=True,\n                       fliersize=5, linewidth=None)\n\n    def test_nested_width(self):\n\n        kws = self.default_kws.copy()\n        p = cat._BoxPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(p.nested_width, .4 * .98)\n\n        kws = self.default_kws.copy()\n        kws[\"width\"] = .6\n        p = cat._BoxPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(p.nested_width, .3 * .98)\n\n        kws = self.default_kws.copy()\n        kws[\"dodge\"] = False\n        p = cat._BoxPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(p.nested_width, .8)\n\n    def test_hue_offsets(self):\n\n        p = cat._BoxPlotter(**self.default_kws)\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        npt.assert_array_equal(p.hue_offsets, [-.2, .2])\n\n        kws = self.default_kws.copy()\n        kws[\"width\"] = .6\n        p = cat._BoxPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        npt.assert_array_equal(p.hue_offsets, [-.15, .15])\n\n        p = cat._BoxPlotter(**kws)\n        p.establish_variables(\"h\", \"y\", \"g\", data=self.df)\n        npt.assert_array_almost_equal(p.hue_offsets, [-.2, 0, .2])\n\n    def test_axes_data(self):\n\n        ax = cat.boxplot(\"g\", \"y\", data=self.df)\n        nt.assert_equal(len(ax.artists), 3)\n\n        plt.close(\"all\")\n\n        ax = cat.boxplot(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(len(ax.artists), 6)\n\n        plt.close(\"all\")\n\n    def test_box_colors(self):\n\n        ax = cat.boxplot(\"g\", \"y\", data=self.df, saturation=1)\n        pal = palettes.color_palette(n_colors=3)\n        for patch, color in zip(ax.artists, pal):\n            nt.assert_equal(patch.get_facecolor()[:3], color)\n\n        plt.close(\"all\")\n\n        ax = cat.boxplot(\"g\", \"y\", \"h\", data=self.df, saturation=1)\n        pal = palettes.color_palette(n_colors=2)\n        for patch, color in zip(ax.artists, pal * 2):\n            nt.assert_equal(patch.get_facecolor()[:3], color)\n\n        plt.close(\"all\")\n\n    def test_draw_missing_boxes(self):\n\n        ax = cat.boxplot(\"g\", \"y\", data=self.df,\n                         order=[\"a\", \"b\", \"c\", \"d\"])\n        nt.assert_equal(len(ax.artists), 3)\n\n    def test_missing_data(self):\n\n        x = [\"a\", \"a\", \"b\", \"b\", \"c\", \"c\", \"d\", \"d\"]\n        h = [\"x\", \"y\", \"x\", \"y\", \"x\", \"y\", \"x\", \"y\"]\n        y = self.rs.randn(8)\n        y[-2:] = np.nan\n\n        ax = cat.boxplot(x, y)\n        nt.assert_equal(len(ax.artists), 3)\n\n        plt.close(\"all\")\n\n        y[-1] = 0\n        ax = cat.boxplot(x, y, h)\n        nt.assert_equal(len(ax.artists), 7)\n\n        plt.close(\"all\")\n\n    def test_boxplots(self):\n\n        # Smoke test the high level boxplot options\n\n        cat.boxplot(\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(y=\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(\"g\", \"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(\"y\", \"g\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n        cat.boxplot(\"g\", \"y\", \"h\", data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(\"g\", \"y\", \"h\", order=list(\"nabc\"), data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(\"g\", \"y\", \"h\", hue_order=list(\"omn\"), data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(\"y\", \"g\", \"h\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n    def test_axes_annotation(self):\n\n        ax = cat.boxplot(\"g\", \"y\", data=self.df)\n        nt.assert_equal(ax.get_xlabel(), \"g\")\n        nt.assert_equal(ax.get_ylabel(), \"y\")\n        nt.assert_equal(ax.get_xlim(), (-.5, 2.5))\n        npt.assert_array_equal(ax.get_xticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_xticklabels()],\n                               [\"a\", \"b\", \"c\"])\n\n        plt.close(\"all\")\n\n        ax = cat.boxplot(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(ax.get_xlabel(), \"g\")\n        nt.assert_equal(ax.get_ylabel(), \"y\")\n        npt.assert_array_equal(ax.get_xticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_xticklabels()],\n                               [\"a\", \"b\", \"c\"])\n        npt.assert_array_equal([l.get_text() for l in ax.legend_.get_texts()],\n                               [\"m\", \"n\"])\n\n        plt.close(\"all\")\n\n        ax = cat.boxplot(\"y\", \"g\", data=self.df, orient=\"h\")\n        nt.assert_equal(ax.get_xlabel(), \"y\")\n        nt.assert_equal(ax.get_ylabel(), \"g\")\n        nt.assert_equal(ax.get_ylim(), (2.5, -.5))\n        npt.assert_array_equal(ax.get_yticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_yticklabels()],\n                               [\"a\", \"b\", \"c\"])\n\n        plt.close(\"all\")\n\n\nclass TestViolinPlotter(CategoricalFixture):\n\n    default_kws = dict(x=None, y=None, hue=None, data=None,\n                       order=None, hue_order=None,\n                       bw=\"scott\", cut=2, scale=\"area\", scale_hue=True,\n                       gridsize=100, width=.8, inner=\"box\", split=False,\n                       dodge=True, orient=None, linewidth=None,\n                       color=None, palette=None, saturation=.75)\n\n    def test_split_error(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"h\", y=\"y\", hue=\"g\", data=self.df, split=True))\n\n        with nt.assert_raises(ValueError):\n            cat._ViolinPlotter(**kws)\n\n    def test_no_observations(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n\n        x = [\"a\", \"a\", \"b\"]\n        y = self.rs.randn(3)\n        y[-1] = np.nan\n        p.establish_variables(x, y)\n        p.estimate_densities(\"scott\", 2, \"area\", True, 20)\n\n        nt.assert_equal(len(p.support[0]), 20)\n        nt.assert_equal(len(p.support[1]), 0)\n\n        nt.assert_equal(len(p.density[0]), 20)\n        nt.assert_equal(len(p.density[1]), 1)\n\n        nt.assert_equal(p.density[1].item(), 1)\n\n        p.estimate_densities(\"scott\", 2, \"count\", True, 20)\n        nt.assert_equal(p.density[1].item(), 0)\n\n        x = [\"a\"] * 4 + [\"b\"] * 2\n        y = self.rs.randn(6)\n        h = [\"m\", \"n\"] * 2 + [\"m\"] * 2\n\n        p.establish_variables(x, y, h)\n        p.estimate_densities(\"scott\", 2, \"area\", True, 20)\n\n        nt.assert_equal(len(p.support[1][0]), 20)\n        nt.assert_equal(len(p.support[1][1]), 0)\n\n        nt.assert_equal(len(p.density[1][0]), 20)\n        nt.assert_equal(len(p.density[1][1]), 1)\n\n        nt.assert_equal(p.density[1][1].item(), 1)\n\n        p.estimate_densities(\"scott\", 2, \"count\", False, 20)\n        nt.assert_equal(p.density[1][1].item(), 0)\n\n    def test_single_observation(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n\n        x = [\"a\", \"a\", \"b\"]\n        y = self.rs.randn(3)\n        p.establish_variables(x, y)\n        p.estimate_densities(\"scott\", 2, \"area\", True, 20)\n\n        nt.assert_equal(len(p.support[0]), 20)\n        nt.assert_equal(len(p.support[1]), 1)\n\n        nt.assert_equal(len(p.density[0]), 20)\n        nt.assert_equal(len(p.density[1]), 1)\n\n        nt.assert_equal(p.density[1].item(), 1)\n\n        p.estimate_densities(\"scott\", 2, \"count\", True, 20)\n        nt.assert_equal(p.density[1].item(), .5)\n\n        x = [\"b\"] * 4 + [\"a\"] * 3\n        y = self.rs.randn(7)\n        h = ([\"m\", \"n\"] * 4)[:-1]\n\n        p.establish_variables(x, y, h)\n        p.estimate_densities(\"scott\", 2, \"area\", True, 20)\n\n        nt.assert_equal(len(p.support[1][0]), 20)\n        nt.assert_equal(len(p.support[1][1]), 1)\n\n        nt.assert_equal(len(p.density[1][0]), 20)\n        nt.assert_equal(len(p.density[1][1]), 1)\n\n        nt.assert_equal(p.density[1][1].item(), 1)\n\n        p.estimate_densities(\"scott\", 2, \"count\", False, 20)\n        nt.assert_equal(p.density[1][1].item(), .5)\n\n    def test_dwidth(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"g\", y=\"y\", data=self.df))\n\n        p = cat._ViolinPlotter(**kws)\n        nt.assert_equal(p.dwidth, .4)\n\n        kws.update(dict(width=.4))\n        p = cat._ViolinPlotter(**kws)\n        nt.assert_equal(p.dwidth, .2)\n\n        kws.update(dict(hue=\"h\", width=.8))\n        p = cat._ViolinPlotter(**kws)\n        nt.assert_equal(p.dwidth, .2)\n\n        kws.update(dict(split=True))\n        p = cat._ViolinPlotter(**kws)\n        nt.assert_equal(p.dwidth, .4)\n\n    def test_scale_area(self):\n\n        kws = self.default_kws.copy()\n        kws[\"scale\"] = \"area\"\n        p = cat._ViolinPlotter(**kws)\n\n        # Test single layer of grouping\n        p.hue_names = None\n        density = [self.rs.uniform(0, .8, 50), self.rs.uniform(0, .2, 50)]\n        max_before = np.array([d.max() for d in density])\n        p.scale_area(density, max_before, False)\n        max_after = np.array([d.max() for d in density])\n        nt.assert_equal(max_after[0], 1)\n\n        before_ratio = max_before[1] / max_before[0]\n        after_ratio = max_after[1] / max_after[0]\n        nt.assert_equal(before_ratio, after_ratio)\n\n        # Test nested grouping scaling across all densities\n        p.hue_names = [\"foo\", \"bar\"]\n        density = [[self.rs.uniform(0, .8, 50), self.rs.uniform(0, .2, 50)],\n                   [self.rs.uniform(0, .1, 50), self.rs.uniform(0, .02, 50)]]\n\n        max_before = np.array([[r.max() for r in row] for row in density])\n        p.scale_area(density, max_before, False)\n        max_after = np.array([[r.max() for r in row] for row in density])\n        nt.assert_equal(max_after[0, 0], 1)\n\n        before_ratio = max_before[1, 1] / max_before[0, 0]\n        after_ratio = max_after[1, 1] / max_after[0, 0]\n        nt.assert_equal(before_ratio, after_ratio)\n\n        # Test nested grouping scaling within hue\n        p.hue_names = [\"foo\", \"bar\"]\n        density = [[self.rs.uniform(0, .8, 50), self.rs.uniform(0, .2, 50)],\n                   [self.rs.uniform(0, .1, 50), self.rs.uniform(0, .02, 50)]]\n\n        max_before = np.array([[r.max() for r in row] for row in density])\n        p.scale_area(density, max_before, True)\n        max_after = np.array([[r.max() for r in row] for row in density])\n        nt.assert_equal(max_after[0, 0], 1)\n        nt.assert_equal(max_after[1, 0], 1)\n\n        before_ratio = max_before[1, 1] / max_before[1, 0]\n        after_ratio = max_after[1, 1] / max_after[1, 0]\n        nt.assert_equal(before_ratio, after_ratio)\n\n    def test_scale_width(self):\n\n        kws = self.default_kws.copy()\n        kws[\"scale\"] = \"width\"\n        p = cat._ViolinPlotter(**kws)\n\n        # Test single layer of grouping\n        p.hue_names = None\n        density = [self.rs.uniform(0, .8, 50), self.rs.uniform(0, .2, 50)]\n        p.scale_width(density)\n        max_after = np.array([d.max() for d in density])\n        npt.assert_array_equal(max_after, [1, 1])\n\n        # Test nested grouping\n        p.hue_names = [\"foo\", \"bar\"]\n        density = [[self.rs.uniform(0, .8, 50), self.rs.uniform(0, .2, 50)],\n                   [self.rs.uniform(0, .1, 50), self.rs.uniform(0, .02, 50)]]\n\n        p.scale_width(density)\n        max_after = np.array([[r.max() for r in row] for row in density])\n        npt.assert_array_equal(max_after, [[1, 1], [1, 1]])\n\n    def test_scale_count(self):\n\n        kws = self.default_kws.copy()\n        kws[\"scale\"] = \"count\"\n        p = cat._ViolinPlotter(**kws)\n\n        # Test single layer of grouping\n        p.hue_names = None\n        density = [self.rs.uniform(0, .8, 20), self.rs.uniform(0, .2, 40)]\n        counts = np.array([20, 40])\n        p.scale_count(density, counts, False)\n        max_after = np.array([d.max() for d in density])\n        npt.assert_array_equal(max_after, [.5, 1])\n\n        # Test nested grouping scaling across all densities\n        p.hue_names = [\"foo\", \"bar\"]\n        density = [[self.rs.uniform(0, .8, 5), self.rs.uniform(0, .2, 40)],\n                   [self.rs.uniform(0, .1, 100), self.rs.uniform(0, .02, 50)]]\n\n        counts = np.array([[5, 40], [100, 50]])\n        p.scale_count(density, counts, False)\n        max_after = np.array([[r.max() for r in row] for row in density])\n        npt.assert_array_equal(max_after, [[.05, .4], [1, .5]])\n\n        # Test nested grouping scaling within hue\n        p.hue_names = [\"foo\", \"bar\"]\n        density = [[self.rs.uniform(0, .8, 5), self.rs.uniform(0, .2, 40)],\n                   [self.rs.uniform(0, .1, 100), self.rs.uniform(0, .02, 50)]]\n\n        counts = np.array([[5, 40], [100, 50]])\n        p.scale_count(density, counts, True)\n        max_after = np.array([[r.max() for r in row] for row in density])\n        npt.assert_array_equal(max_after, [[.125, 1], [1, .5]])\n\n    def test_bad_scale(self):\n\n        kws = self.default_kws.copy()\n        kws[\"scale\"] = \"not_a_scale_type\"\n        with nt.assert_raises(ValueError):\n            cat._ViolinPlotter(**kws)\n\n    def test_kde_fit(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n        data = self.y\n        data_std = data.std(ddof=1)\n\n        # Bandwidth behavior depends on scipy version\n        if LooseVersion(scipy.__version__) < \"0.11\":\n            # Test ignoring custom bandwidth on old scipy\n            kde, bw = p.fit_kde(self.y, .2)\n            nt.assert_is_instance(kde, stats.gaussian_kde)\n            nt.assert_equal(kde.factor, kde.scotts_factor())\n\n        else:\n            # Test reference rule bandwidth\n            kde, bw = p.fit_kde(data, \"scott\")\n            nt.assert_is_instance(kde, stats.gaussian_kde)\n            nt.assert_equal(kde.factor, kde.scotts_factor())\n            nt.assert_equal(bw, kde.scotts_factor() * data_std)\n\n            # Test numeric scale factor\n            kde, bw = p.fit_kde(self.y, .2)\n            nt.assert_is_instance(kde, stats.gaussian_kde)\n            nt.assert_equal(kde.factor, .2)\n            nt.assert_equal(bw, .2 * data_std)\n\n    def test_draw_to_density(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n        # p.dwidth will be 1 for easier testing\n        p.width = 2\n\n        # Test verical plots\n        support = np.array([.2, .6])\n        density = np.array([.1, .4])\n\n        # Test full vertical plot\n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .5, support, density, False)\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [.99 * -.4, .99 * .4])\n        npt.assert_array_equal(y, [.5, .5])\n        plt.close(\"all\")\n\n        # Test left vertical plot\n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .5, support, density, \"left\")\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [.99 * -.4, 0])\n        npt.assert_array_equal(y, [.5, .5])\n        plt.close(\"all\")\n\n        # Test right vertical plot\n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .5, support, density, \"right\")\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [0, .99 * .4])\n        npt.assert_array_equal(y, [.5, .5])\n        plt.close(\"all\")\n\n        # Switch orientation to test horizontal plots\n        p.orient = \"h\"\n        support = np.array([.2, .5])\n        density = np.array([.3, .7])\n\n        # Test full horizontal plot\n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .6, support, density, False)\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [.6, .6])\n        npt.assert_array_equal(y, [.99 * -.7, .99 * .7])\n        plt.close(\"all\")\n\n        # Test left horizontal plot\n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .6, support, density, \"left\")\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [.6, .6])\n        npt.assert_array_equal(y, [.99 * -.7, 0])\n        plt.close(\"all\")\n\n        # Test right horizontal plot\n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .6, support, density, \"right\")\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [.6, .6])\n        npt.assert_array_equal(y, [0, .99 * .7])\n        plt.close(\"all\")\n\n    def test_draw_single_observations(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n        p.width = 2\n\n        # Test vertical plot\n        _, ax = plt.subplots()\n        p.draw_single_observation(ax, 1, 1.5, 1)\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [0, 2])\n        npt.assert_array_equal(y, [1.5, 1.5])\n        plt.close(\"all\")\n\n        # Test horizontal plot\n        p.orient = \"h\"\n        _, ax = plt.subplots()\n        p.draw_single_observation(ax, 2, 2.2, .5)\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [2.2, 2.2])\n        npt.assert_array_equal(y, [1.5, 2.5])\n        plt.close(\"all\")\n\n    def test_draw_box_lines(self):\n\n        # Test vertical plot\n        kws = self.default_kws.copy()\n        kws.update(dict(y=\"y\", data=self.df, inner=None))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_box_lines(ax, self.y, p.support[0], p.density[0], 0)\n        nt.assert_equal(len(ax.lines), 2)\n\n        q25, q50, q75 = np.percentile(self.y, [25, 50, 75])\n        _, y = ax.lines[1].get_xydata().T\n        npt.assert_array_equal(y, [q25, q75])\n\n        _, y = ax.collections[0].get_offsets().T\n        nt.assert_equal(y, q50)\n\n        plt.close(\"all\")\n\n        # Test horizontal plot\n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"y\", data=self.df, inner=None))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_box_lines(ax, self.y, p.support[0], p.density[0], 0)\n        nt.assert_equal(len(ax.lines), 2)\n\n        q25, q50, q75 = np.percentile(self.y, [25, 50, 75])\n        x, _ = ax.lines[1].get_xydata().T\n        npt.assert_array_equal(x, [q25, q75])\n\n        x, _ = ax.collections[0].get_offsets().T\n        nt.assert_equal(x, q50)\n\n        plt.close(\"all\")\n\n    def test_draw_quartiles(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(y=\"y\", data=self.df, inner=None))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_quartiles(ax, self.y, p.support[0], p.density[0], 0)\n        for val, line in zip(np.percentile(self.y, [25, 50, 75]), ax.lines):\n            _, y = line.get_xydata().T\n            npt.assert_array_equal(y, [val, val])\n\n    def test_draw_points(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n\n        # Test vertical plot\n        _, ax = plt.subplots()\n        p.draw_points(ax, self.y, 0)\n        x, y = ax.collections[0].get_offsets().T\n        npt.assert_array_equal(x, np.zeros_like(self.y))\n        npt.assert_array_equal(y, self.y)\n        plt.close(\"all\")\n\n        # Test horizontal plot\n        p.orient = \"h\"\n        _, ax = plt.subplots()\n        p.draw_points(ax, self.y, 0)\n        x, y = ax.collections[0].get_offsets().T\n        npt.assert_array_equal(x, self.y)\n        npt.assert_array_equal(y, np.zeros_like(self.y))\n        plt.close(\"all\")\n\n    def test_draw_sticks(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(y=\"y\", data=self.df, inner=None))\n        p = cat._ViolinPlotter(**kws)\n\n        # Test vertical plot\n        _, ax = plt.subplots()\n        p.draw_stick_lines(ax, self.y, p.support[0], p.density[0], 0)\n        for val, line in zip(self.y, ax.lines):\n            _, y = line.get_xydata().T\n            npt.assert_array_equal(y, [val, val])\n        plt.close(\"all\")\n\n        # Test horizontal plot\n        p.orient = \"h\"\n        _, ax = plt.subplots()\n        p.draw_stick_lines(ax, self.y, p.support[0], p.density[0], 0)\n        for val, line in zip(self.y, ax.lines):\n            x, _ = line.get_xydata().T\n            npt.assert_array_equal(x, [val, val])\n        plt.close(\"all\")\n\n    def test_validate_inner(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(inner=\"bad_inner\"))\n        with nt.assert_raises(ValueError):\n            cat._ViolinPlotter(**kws)\n\n    def test_draw_violinplots(self):\n\n        kws = self.default_kws.copy()\n\n        # Test single vertical violin\n        kws.update(dict(y=\"y\", data=self.df, inner=None,\n                        saturation=1, color=(1, 0, 0, 1)))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 1)\n        npt.assert_array_equal(ax.collections[0].get_facecolors(),\n                               [(1, 0, 0, 1)])\n        plt.close(\"all\")\n\n        # Test single horizontal violin\n        kws.update(dict(x=\"y\", y=None, color=(0, 1, 0, 1)))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 1)\n        npt.assert_array_equal(ax.collections[0].get_facecolors(),\n                               [(0, 1, 0, 1)])\n        plt.close(\"all\")\n\n        # Test multiple vertical violins\n        kws.update(dict(x=\"g\", y=\"y\", color=None,))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 3)\n        for violin, color in zip(ax.collections, palettes.color_palette()):\n            npt.assert_array_equal(violin.get_facecolors()[0, :-1], color)\n        plt.close(\"all\")\n\n        # Test multiple violins with hue nesting\n        kws.update(dict(hue=\"h\"))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 6)\n        for violin, color in zip(ax.collections,\n                                 palettes.color_palette(n_colors=2) * 3):\n            npt.assert_array_equal(violin.get_facecolors()[0, :-1], color)\n        plt.close(\"all\")\n\n        # Test multiple split violins\n        kws.update(dict(split=True, palette=\"muted\"))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 6)\n        for violin, color in zip(ax.collections,\n                                 palettes.color_palette(\"muted\",\n                                                        n_colors=2) * 3):\n            npt.assert_array_equal(violin.get_facecolors()[0, :-1], color)\n        plt.close(\"all\")\n\n    def test_draw_violinplots_no_observations(self):\n\n        kws = self.default_kws.copy()\n        kws[\"inner\"] = None\n\n        # Test single layer of grouping\n        x = [\"a\", \"a\", \"b\"]\n        y = self.rs.randn(3)\n        y[-1] = np.nan\n        kws.update(x=x, y=y)\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 1)\n        nt.assert_equal(len(ax.lines), 0)\n        plt.close(\"all\")\n\n        # Test nested hue grouping\n        x = [\"a\"] * 4 + [\"b\"] * 2\n        y = self.rs.randn(6)\n        h = [\"m\", \"n\"] * 2 + [\"m\"] * 2\n        kws.update(x=x, y=y, hue=h)\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 3)\n        nt.assert_equal(len(ax.lines), 0)\n        plt.close(\"all\")\n\n    def test_draw_violinplots_single_observations(self):\n\n        kws = self.default_kws.copy()\n        kws[\"inner\"] = None\n\n        # Test single layer of grouping\n        x = [\"a\", \"a\", \"b\"]\n        y = self.rs.randn(3)\n        kws.update(x=x, y=y)\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 1)\n        nt.assert_equal(len(ax.lines), 1)\n        plt.close(\"all\")\n\n        # Test nested hue grouping\n        x = [\"b\"] * 4 + [\"a\"] * 3\n        y = self.rs.randn(7)\n        h = ([\"m\", \"n\"] * 4)[:-1]\n        kws.update(x=x, y=y, hue=h)\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 3)\n        nt.assert_equal(len(ax.lines), 1)\n        plt.close(\"all\")\n\n        # Test nested hue grouping with split\n        kws[\"split\"] = True\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        nt.assert_equal(len(ax.collections), 3)\n        nt.assert_equal(len(ax.lines), 1)\n        plt.close(\"all\")\n\n    def test_violinplots(self):\n\n        # Smoke test the high level violinplot options\n\n        cat.violinplot(\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.violinplot(y=\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.violinplot(\"g\", \"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.violinplot(\"y\", \"g\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n        cat.violinplot(\"g\", \"y\", \"h\", data=self.df)\n        plt.close(\"all\")\n\n        cat.violinplot(\"g\", \"y\", \"h\", order=list(\"nabc\"), data=self.df)\n        plt.close(\"all\")\n\n        cat.violinplot(\"g\", \"y\", \"h\", hue_order=list(\"omn\"), data=self.df)\n        plt.close(\"all\")\n\n        cat.violinplot(\"y\", \"g\", \"h\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n        for inner in [\"box\", \"quart\", \"point\", \"stick\", None]:\n            cat.violinplot(\"g\", \"y\", data=self.df, inner=inner)\n            plt.close(\"all\")\n\n            cat.violinplot(\"g\", \"y\", \"h\", data=self.df, inner=inner)\n            plt.close(\"all\")\n\n            cat.violinplot(\"g\", \"y\", \"h\", data=self.df,\n                           inner=inner, split=True)\n            plt.close(\"all\")\n\n\nclass TestCategoricalScatterPlotter(CategoricalFixture):\n\n    def test_group_point_colors(self):\n\n        p = cat._CategoricalScatterPlotter()\n\n        p.establish_variables(x=\"g\", y=\"y\", data=self.df)\n        p.establish_colors(None, \"deep\", 1)\n\n        point_colors = p.point_colors\n        nt.assert_equal(len(point_colors), self.g.unique().size)\n        deep_colors = palettes.color_palette(\"deep\", self.g.unique().size)\n\n        for i, group_colors in enumerate(point_colors):\n            nt.assert_equal(tuple(deep_colors[i]), tuple(group_colors[0]))\n            for channel in group_colors.T:\n                nt.assert_equals(np.unique(channel).size, 1)\n\n    def test_hue_point_colors(self):\n\n        p = cat._CategoricalScatterPlotter()\n\n        hue_order = self.h.unique().tolist()\n        p.establish_variables(x=\"g\", y=\"y\", hue=\"h\",\n                              hue_order=hue_order, data=self.df)\n        p.establish_colors(None, \"deep\", 1)\n\n        point_colors = p.point_colors\n        nt.assert_equal(len(point_colors), self.g.unique().size)\n        deep_colors = palettes.color_palette(\"deep\", len(hue_order))\n\n        for i, group_colors in enumerate(point_colors):\n            for j, point_color in enumerate(group_colors):\n                hue_level = p.plot_hues[i][j]\n                nt.assert_equal(tuple(point_color),\n                                deep_colors[hue_order.index(hue_level)])\n\n    def test_scatterplot_legend(self):\n\n        p = cat._CategoricalScatterPlotter()\n\n        hue_order = [\"m\", \"n\"]\n        p.establish_variables(x=\"g\", y=\"y\", hue=\"h\",\n                              hue_order=hue_order, data=self.df)\n        p.establish_colors(None, \"deep\", 1)\n        deep_colors = palettes.color_palette(\"deep\", self.h.unique().size)\n\n        f, ax = plt.subplots()\n        p.add_legend_data(ax)\n        leg = ax.legend()\n\n        for i, t in enumerate(leg.get_texts()):\n            nt.assert_equal(t.get_text(), hue_order[i])\n\n        for i, h in enumerate(leg.legendHandles):\n            rgb = h.get_facecolor()[0, :3]\n            nt.assert_equal(tuple(rgb), tuple(deep_colors[i]))\n\n\nclass TestStripPlotter(CategoricalFixture):\n\n    def test_stripplot_vertical(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.stripplot(\"g\", \"y\", data=self.df)\n        for i, (_, vals) in enumerate(self.y.groupby(self.g)):\n\n            x, y = ax.collections[i].get_offsets().T\n\n            npt.assert_array_equal(x, np.ones(len(x)) * i)\n            npt.assert_array_equal(y, vals)\n\n            npt.assert_equal(ax.collections[i].get_facecolors()[0, :3], pal[i])\n\n    @skipif(not pandas_has_categoricals)\n    def test_stripplot_horiztonal(self):\n\n        df = self.df.copy()\n        df.g = df.g.astype(\"category\")\n\n        ax = cat.stripplot(\"y\", \"g\", data=df)\n        for i, (_, vals) in enumerate(self.y.groupby(self.g)):\n\n            x, y = ax.collections[i].get_offsets().T\n\n            npt.assert_array_equal(x, vals)\n            npt.assert_array_equal(y, np.ones(len(x)) * i)\n\n    def test_stripplot_jitter(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.stripplot(\"g\", \"y\", data=self.df, jitter=True)\n        for i, (_, vals) in enumerate(self.y.groupby(self.g)):\n\n            x, y = ax.collections[i].get_offsets().T\n\n            npt.assert_array_less(np.ones(len(x)) * i - .1, x)\n            npt.assert_array_less(x, np.ones(len(x)) * i + .1)\n            npt.assert_array_equal(y, vals)\n\n            npt.assert_equal(ax.collections[i].get_facecolors()[0, :3], pal[i])\n\n    def test_dodge_nested_stripplot_vertical(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.stripplot(\"g\", \"y\", \"h\", data=self.df, dodge=True)\n        for i, (_, group_vals) in enumerate(self.y.groupby(self.g)):\n            for j, (_, vals) in enumerate(group_vals.groupby(self.h)):\n\n                x, y = ax.collections[i * 2 + j].get_offsets().T\n\n                npt.assert_array_equal(x, np.ones(len(x)) * i + [-.2, .2][j])\n                npt.assert_array_equal(y, vals)\n\n                fc = ax.collections[i * 2 + j].get_facecolors()[0, :3]\n                npt.assert_equal(fc, pal[j])\n\n    @skipif(not pandas_has_categoricals)\n    def test_dodge_nested_stripplot_horizontal(self):\n\n        df = self.df.copy()\n        df.g = df.g.astype(\"category\")\n\n        ax = cat.stripplot(\"y\", \"g\", \"h\", data=df, dodge=True)\n        for i, (_, group_vals) in enumerate(self.y.groupby(self.g)):\n            for j, (_, vals) in enumerate(group_vals.groupby(self.h)):\n\n                x, y = ax.collections[i * 2 + j].get_offsets().T\n\n                npt.assert_array_equal(x, vals)\n                npt.assert_array_equal(y, np.ones(len(x)) * i + [-.2, .2][j])\n\n    def test_nested_stripplot_vertical(self):\n\n        # Test a simple vertical strip plot\n        ax = cat.stripplot(\"g\", \"y\", \"h\", data=self.df, dodge=False)\n        for i, (_, group_vals) in enumerate(self.y.groupby(self.g)):\n\n            x, y = ax.collections[i].get_offsets().T\n\n            npt.assert_array_equal(x, np.ones(len(x)) * i)\n            npt.assert_array_equal(y, group_vals)\n\n    @skipif(not pandas_has_categoricals)\n    def test_nested_stripplot_horizontal(self):\n\n        df = self.df.copy()\n        df.g = df.g.astype(\"category\")\n\n        ax = cat.stripplot(\"y\", \"g\", \"h\", data=df, dodge=False)\n        for i, (_, group_vals) in enumerate(self.y.groupby(self.g)):\n\n            x, y = ax.collections[i].get_offsets().T\n\n            npt.assert_array_equal(x, group_vals)\n            npt.assert_array_equal(y, np.ones(len(x)) * i)\n\n    def test_three_strip_points(self):\n\n        x = np.arange(3)\n        ax = cat.stripplot(x=x)\n        facecolors = ax.collections[0].get_facecolor()\n        nt.assert_equal(facecolors.shape, (3, 4))\n        npt.assert_array_equal(facecolors[0], facecolors[1])\n\n\nclass TestSwarmPlotter(CategoricalFixture):\n\n    default_kws = dict(x=None, y=None, hue=None, data=None,\n                       order=None, hue_order=None, dodge=False,\n                       orient=None, color=None, palette=None)\n\n    def test_could_overlap(self):\n\n        p = cat._SwarmPlotter(**self.default_kws)\n        neighbors = p.could_overlap((1, 1), [(0, 0), (1, .5), (.5, .5)], 1)\n        npt.assert_array_equal(neighbors, [(1, .5), (.5, .5)])\n\n    def test_position_candidates(self):\n\n        p = cat._SwarmPlotter(**self.default_kws)\n        xy_i = (0, 1)\n        neighbors = [(0, 1), (0, 1.5)]\n        candidates = p.position_candidates(xy_i, neighbors, 1)\n        dx1 = 1.05\n        dx2 = np.sqrt(1 - .5 ** 2) * 1.05\n        npt.assert_array_equal(candidates,\n                               [(0, 1), (-dx1, 1), (dx1, 1),\n                                (dx2, 1), (-dx2, 1)])\n\n    def test_find_first_non_overlapping_candidate(self):\n\n        p = cat._SwarmPlotter(**self.default_kws)\n        candidates = [(.5, 1), (1, 1), (1.5, 1)]\n        neighbors = np.array([(0, 1)])\n\n        first = p.first_non_overlapping_candidate(candidates, neighbors, 1)\n        npt.assert_array_equal(first, (1, 1))\n\n    def test_beeswarm(self):\n\n        p = cat._SwarmPlotter(**self.default_kws)\n        d = self.y.diff().mean() * 1.5\n        x = np.zeros(self.y.size)\n        y = np.sort(self.y)\n        orig_xy = np.c_[x, y]\n        swarm = p.beeswarm(orig_xy, d)\n        dmat = spatial.distance.cdist(swarm, swarm)\n        triu = dmat[np.triu_indices_from(dmat, 1)]\n        npt.assert_array_less(d, triu)\n        npt.assert_array_equal(y, swarm[:, 1])\n\n    def test_add_gutters(self):\n\n        p = cat._SwarmPlotter(**self.default_kws)\n        points = np.array([0, -1, .4, .8])\n        points = p.add_gutters(points, 0, 1)\n        npt.assert_array_equal(points,\n                               np.array([0, -.5, .4, .5]))\n\n    def test_swarmplot_vertical(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.swarmplot(\"g\", \"y\", data=self.df)\n        for i, (_, vals) in enumerate(self.y.groupby(self.g)):\n\n            x, y = ax.collections[i].get_offsets().T\n            npt.assert_array_almost_equal(y, np.sort(vals))\n\n            fc = ax.collections[i].get_facecolors()[0, :3]\n            npt.assert_equal(fc, pal[i])\n\n    def test_swarmplot_horizontal(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.swarmplot(\"y\", \"g\", data=self.df, orient=\"h\")\n        for i, (_, vals) in enumerate(self.y.groupby(self.g)):\n\n            x, y = ax.collections[i].get_offsets().T\n            npt.assert_array_almost_equal(x, np.sort(vals))\n\n            fc = ax.collections[i].get_facecolors()[0, :3]\n            npt.assert_equal(fc, pal[i])\n\n    def test_dodge_nested_swarmplot_vetical(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.swarmplot(\"g\", \"y\", \"h\", data=self.df, dodge=True)\n        for i, (_, group_vals) in enumerate(self.y.groupby(self.g)):\n            for j, (_, vals) in enumerate(group_vals.groupby(self.h)):\n\n                x, y = ax.collections[i * 2 + j].get_offsets().T\n                npt.assert_array_almost_equal(y, np.sort(vals))\n\n                fc = ax.collections[i * 2 + j].get_facecolors()[0, :3]\n                npt.assert_equal(fc, pal[j])\n\n    def test_dodge_nested_swarmplot_horizontal(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.swarmplot(\"y\", \"g\", \"h\", data=self.df, orient=\"h\", dodge=True)\n        for i, (_, group_vals) in enumerate(self.y.groupby(self.g)):\n            for j, (_, vals) in enumerate(group_vals.groupby(self.h)):\n\n                x, y = ax.collections[i * 2 + j].get_offsets().T\n                npt.assert_array_almost_equal(x, np.sort(vals))\n\n                fc = ax.collections[i * 2 + j].get_facecolors()[0, :3]\n                npt.assert_equal(fc, pal[j])\n\n    def test_nested_swarmplot_vertical(self):\n\n        ax = cat.swarmplot(\"g\", \"y\", \"h\", data=self.df)\n\n        pal = palettes.color_palette()\n        hue_names = self.h.unique().tolist()\n        grouped_hues = list(self.h.groupby(self.g))\n\n        for i, (_, vals) in enumerate(self.y.groupby(self.g)):\n\n            points = ax.collections[i]\n            x, y = points.get_offsets().T\n            sorter = np.argsort(vals)\n            npt.assert_array_almost_equal(y, vals.iloc[sorter])\n\n            _, hue_vals = grouped_hues[i]\n            for hue, fc in zip(hue_vals.values[sorter.values],\n                               points.get_facecolors()):\n\n                npt.assert_equal(fc[:3], pal[hue_names.index(hue)])\n\n    def test_nested_swarmplot_horizontal(self):\n\n        ax = cat.swarmplot(\"y\", \"g\", \"h\", data=self.df, orient=\"h\")\n\n        pal = palettes.color_palette()\n        hue_names = self.h.unique().tolist()\n        grouped_hues = list(self.h.groupby(self.g))\n\n        for i, (_, vals) in enumerate(self.y.groupby(self.g)):\n\n            points = ax.collections[i]\n            x, y = points.get_offsets().T\n            sorter = np.argsort(vals)\n            npt.assert_array_almost_equal(x, vals.iloc[sorter])\n\n            _, hue_vals = grouped_hues[i]\n            for hue, fc in zip(hue_vals.values[sorter.values],\n                               points.get_facecolors()):\n\n                npt.assert_equal(fc[:3], pal[hue_names.index(hue)])\n\n\nclass TestBarPlotter(CategoricalFixture):\n\n    default_kws = dict(x=None, y=None, hue=None, data=None,\n                       estimator=np.mean, ci=95, n_boot=100, units=None,\n                       order=None, hue_order=None,\n                       orient=None, color=None, palette=None,\n                       saturation=.75, errcolor=\".26\", errwidth=None,\n                       capsize=None, dodge=True)\n\n    def test_nested_width(self):\n\n        kws = self.default_kws.copy()\n\n        p = cat._BarPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(p.nested_width, .8 / 2)\n\n        p = cat._BarPlotter(**kws)\n        p.establish_variables(\"h\", \"y\", \"g\", data=self.df)\n        nt.assert_equal(p.nested_width, .8 / 3)\n\n        kws[\"dodge\"] = False\n        p = cat._BarPlotter(**kws)\n        p.establish_variables(\"h\", \"y\", \"g\", data=self.df)\n        nt.assert_equal(p.nested_width, .8)\n\n    def test_draw_vertical_bars(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        nt.assert_equal(len(ax.patches), len(p.plot_data))\n        nt.assert_equal(len(ax.lines), len(p.plot_data))\n\n        for bar, color in zip(ax.patches, p.colors):\n            nt.assert_equal(bar.get_facecolor()[:-1], color)\n\n        positions = np.arange(len(p.plot_data)) - p.width / 2\n        for bar, pos, stat in zip(ax.patches, positions, p.statistic):\n            nt.assert_equal(bar.get_x(), pos)\n            nt.assert_equal(bar.get_width(), p.width)\n            if mpl.__version__ >= mpl_barplot_change:\n                nt.assert_equal(bar.get_y(), 0)\n                nt.assert_equal(bar.get_height(), stat)\n            else:\n                nt.assert_equal(bar.get_y(), min(0, stat))\n                nt.assert_equal(bar.get_height(), abs(stat))\n\n    def test_draw_horizontal_bars(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"y\", y=\"g\", orient=\"h\", data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        nt.assert_equal(len(ax.patches), len(p.plot_data))\n        nt.assert_equal(len(ax.lines), len(p.plot_data))\n\n        for bar, color in zip(ax.patches, p.colors):\n            nt.assert_equal(bar.get_facecolor()[:-1], color)\n\n        positions = np.arange(len(p.plot_data)) - p.width / 2\n        for bar, pos, stat in zip(ax.patches, positions, p.statistic):\n            nt.assert_equal(bar.get_y(), pos)\n            nt.assert_equal(bar.get_height(), p.width)\n            if mpl.__version__ >= mpl_barplot_change:\n                nt.assert_equal(bar.get_x(), 0)\n                nt.assert_equal(bar.get_width(), stat)\n            else:\n                nt.assert_equal(bar.get_x(), min(0, stat))\n                nt.assert_equal(bar.get_width(), abs(stat))\n\n    def test_draw_nested_vertical_bars(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        n_groups, n_hues = len(p.plot_data), len(p.hue_names)\n        nt.assert_equal(len(ax.patches), n_groups * n_hues)\n        nt.assert_equal(len(ax.lines), n_groups * n_hues)\n\n        for bar in ax.patches[:n_groups]:\n            nt.assert_equal(bar.get_facecolor()[:-1], p.colors[0])\n        for bar in ax.patches[n_groups:]:\n            nt.assert_equal(bar.get_facecolor()[:-1], p.colors[1])\n\n        positions = np.arange(len(p.plot_data))\n        for bar, pos in zip(ax.patches[:n_groups], positions):\n            nt.assert_almost_equal(bar.get_x(), pos - p.width / 2)\n            nt.assert_almost_equal(bar.get_width(), p.nested_width)\n\n        for bar, stat in zip(ax.patches, p.statistic.T.flat):\n            if LooseVersion(mpl.__version__) >= mpl_barplot_change:\n                nt.assert_almost_equal(bar.get_y(), 0)\n                nt.assert_almost_equal(bar.get_height(), stat)\n            else:\n                nt.assert_almost_equal(bar.get_y(), min(0, stat))\n                nt.assert_almost_equal(bar.get_height(), abs(stat))\n\n    def test_draw_nested_horizontal_bars(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"y\", y=\"g\", hue=\"h\", orient=\"h\", data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        n_groups, n_hues = len(p.plot_data), len(p.hue_names)\n        nt.assert_equal(len(ax.patches), n_groups * n_hues)\n        nt.assert_equal(len(ax.lines), n_groups * n_hues)\n\n        for bar in ax.patches[:n_groups]:\n            nt.assert_equal(bar.get_facecolor()[:-1], p.colors[0])\n        for bar in ax.patches[n_groups:]:\n            nt.assert_equal(bar.get_facecolor()[:-1], p.colors[1])\n\n        positions = np.arange(len(p.plot_data))\n        for bar, pos in zip(ax.patches[:n_groups], positions):\n            nt.assert_almost_equal(bar.get_y(), pos - p.width / 2)\n            nt.assert_almost_equal(bar.get_height(), p.nested_width)\n\n        for bar, stat in zip(ax.patches, p.statistic.T.flat):\n            if LooseVersion(mpl.__version__) >= mpl_barplot_change:\n                nt.assert_almost_equal(bar.get_x(), 0)\n                nt.assert_almost_equal(bar.get_width(), stat)\n            else:\n                nt.assert_almost_equal(bar.get_x(), min(0, stat))\n                nt.assert_almost_equal(bar.get_width(), abs(stat))\n\n    def test_draw_missing_bars(self):\n\n        kws = self.default_kws.copy()\n\n        order = list(\"abcd\")\n        kws.update(x=\"g\", y=\"y\", order=order, data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        nt.assert_equal(len(ax.patches), len(order))\n        nt.assert_equal(len(ax.lines), len(order))\n\n        plt.close(\"all\")\n\n        hue_order = list(\"mno\")\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", hue_order=hue_order, data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        nt.assert_equal(len(ax.patches), len(p.plot_data) * len(hue_order))\n        nt.assert_equal(len(ax.lines),  len(p.plot_data) * len(hue_order))\n\n        plt.close(\"all\")\n\n    def test_barplot_colors(self):\n\n        # Test unnested palette colors\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", data=self.df,\n                   saturation=1, palette=\"muted\")\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        palette = palettes.color_palette(\"muted\", len(self.g.unique()))\n        for patch, pal_color in zip(ax.patches, palette):\n            nt.assert_equal(patch.get_facecolor()[:-1], pal_color)\n\n        plt.close(\"all\")\n\n        # Test single color\n        color = (.2, .2, .3, 1)\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", data=self.df,\n                   saturation=1, color=color)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        for patch in ax.patches:\n            nt.assert_equal(patch.get_facecolor(), color)\n\n        plt.close(\"all\")\n\n        # Test nested palette colors\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", data=self.df,\n                   saturation=1, palette=\"Set2\")\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        palette = palettes.color_palette(\"Set2\", len(self.h.unique()))\n        for patch in ax.patches[:len(self.g.unique())]:\n            nt.assert_equal(patch.get_facecolor()[:-1], palette[0])\n        for patch in ax.patches[len(self.g.unique()):]:\n            nt.assert_equal(patch.get_facecolor()[:-1], palette[1])\n\n        plt.close(\"all\")\n\n    def test_simple_barplots(self):\n\n        ax = cat.barplot(\"g\", \"y\", data=self.df)\n        nt.assert_equal(len(ax.patches), len(self.g.unique()))\n        nt.assert_equal(ax.get_xlabel(), \"g\")\n        nt.assert_equal(ax.get_ylabel(), \"y\")\n        plt.close(\"all\")\n\n        ax = cat.barplot(\"y\", \"g\", orient=\"h\", data=self.df)\n        nt.assert_equal(len(ax.patches), len(self.g.unique()))\n        nt.assert_equal(ax.get_xlabel(), \"y\")\n        nt.assert_equal(ax.get_ylabel(), \"g\")\n        plt.close(\"all\")\n\n        ax = cat.barplot(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(len(ax.patches),\n                        len(self.g.unique()) * len(self.h.unique()))\n        nt.assert_equal(ax.get_xlabel(), \"g\")\n        nt.assert_equal(ax.get_ylabel(), \"y\")\n        plt.close(\"all\")\n\n        ax = cat.barplot(\"y\", \"g\", \"h\", orient=\"h\", data=self.df)\n        nt.assert_equal(len(ax.patches),\n                        len(self.g.unique()) * len(self.h.unique()))\n        nt.assert_equal(ax.get_xlabel(), \"y\")\n        nt.assert_equal(ax.get_ylabel(), \"g\")\n        plt.close(\"all\")\n\n\nclass TestPointPlotter(CategoricalFixture):\n\n    default_kws = dict(x=None, y=None, hue=None, data=None,\n                       estimator=np.mean, ci=95, n_boot=100, units=None,\n                       order=None, hue_order=None,\n                       markers=\"o\", linestyles=\"-\", dodge=0,\n                       join=True, scale=1,\n                       orient=None, color=None, palette=None)\n\n    def test_different_defualt_colors(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"g\", y=\"y\", data=self.df))\n        p = cat._PointPlotter(**kws)\n        color = palettes.color_palette()[0]\n        npt.assert_array_equal(p.colors, [color, color, color])\n\n    def test_hue_offsets(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"g\", y=\"y\", hue=\"h\", data=self.df))\n\n        p = cat._PointPlotter(**kws)\n        npt.assert_array_equal(p.hue_offsets, [0, 0])\n\n        kws.update(dict(dodge=.5))\n\n        p = cat._PointPlotter(**kws)\n        npt.assert_array_equal(p.hue_offsets, [-.25, .25])\n\n        kws.update(dict(x=\"h\", hue=\"g\", dodge=0))\n\n        p = cat._PointPlotter(**kws)\n        npt.assert_array_equal(p.hue_offsets, [0, 0, 0])\n\n        kws.update(dict(dodge=.3))\n\n        p = cat._PointPlotter(**kws)\n        npt.assert_array_equal(p.hue_offsets, [-.15, 0, .15])\n\n    def test_draw_vertical_points(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", data=self.df)\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        nt.assert_equal(len(ax.collections), 1)\n        nt.assert_equal(len(ax.lines), len(p.plot_data) + 1)\n        points = ax.collections[0]\n        nt.assert_equal(len(points.get_offsets()), len(p.plot_data))\n\n        x, y = points.get_offsets().T\n        npt.assert_array_equal(x, np.arange(len(p.plot_data)))\n        npt.assert_array_equal(y, p.statistic)\n\n        for got_color, want_color in zip(points.get_facecolors(),\n                                         p.colors):\n            npt.assert_array_equal(got_color[:-1], want_color)\n\n    def test_draw_horizontal_points(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"y\", y=\"g\", orient=\"h\", data=self.df)\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        nt.assert_equal(len(ax.collections), 1)\n        nt.assert_equal(len(ax.lines), len(p.plot_data) + 1)\n        points = ax.collections[0]\n        nt.assert_equal(len(points.get_offsets()), len(p.plot_data))\n\n        x, y = points.get_offsets().T\n        npt.assert_array_equal(x, p.statistic)\n        npt.assert_array_equal(y, np.arange(len(p.plot_data)))\n\n        for got_color, want_color in zip(points.get_facecolors(),\n                                         p.colors):\n            npt.assert_array_equal(got_color[:-1], want_color)\n\n    def test_draw_vertical_nested_points(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", data=self.df)\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        nt.assert_equal(len(ax.collections), 2)\n        nt.assert_equal(len(ax.lines),\n                        len(p.plot_data) * len(p.hue_names) + len(p.hue_names))\n\n        for points, stats, color in zip(ax.collections,\n                                        p.statistic.T,\n                                        p.colors):\n\n            nt.assert_equal(len(points.get_offsets()), len(p.plot_data))\n\n            x, y = points.get_offsets().T\n            npt.assert_array_equal(x, np.arange(len(p.plot_data)))\n            npt.assert_array_equal(y, stats)\n\n            for got_color in points.get_facecolors():\n                npt.assert_array_equal(got_color[:-1], color)\n\n    def test_draw_horizontal_nested_points(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"y\", y=\"g\", hue=\"h\", orient=\"h\", data=self.df)\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        nt.assert_equal(len(ax.collections), 2)\n        nt.assert_equal(len(ax.lines),\n                        len(p.plot_data) * len(p.hue_names) + len(p.hue_names))\n\n        for points, stats, color in zip(ax.collections,\n                                        p.statistic.T,\n                                        p.colors):\n\n            nt.assert_equal(len(points.get_offsets()), len(p.plot_data))\n\n            x, y = points.get_offsets().T\n            npt.assert_array_equal(x, stats)\n            npt.assert_array_equal(y, np.arange(len(p.plot_data)))\n\n            for got_color in points.get_facecolors():\n                npt.assert_array_equal(got_color[:-1], color)\n\n    def test_pointplot_colors(self):\n\n        # Test a single-color unnested plot\n        color = (.2, .2, .3, 1)\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", data=self.df, color=color)\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        for line in ax.lines:\n            nt.assert_equal(line.get_color(), color[:-1])\n\n        for got_color in ax.collections[0].get_facecolors():\n            npt.assert_array_equal(rgb2hex(got_color), rgb2hex(color))\n\n        plt.close(\"all\")\n\n        # Test a multi-color unnested plot\n        palette = palettes.color_palette(\"Set1\", 3)\n        kws.update(x=\"g\", y=\"y\", data=self.df, palette=\"Set1\")\n        p = cat._PointPlotter(**kws)\n\n        nt.assert_true(not p.join)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        for line, pal_color in zip(ax.lines, palette):\n            npt.assert_array_equal(line.get_color(), pal_color)\n\n        for point_color, pal_color in zip(ax.collections[0].get_facecolors(),\n                                          palette):\n            npt.assert_array_equal(rgb2hex(point_color), rgb2hex(pal_color))\n\n        plt.close(\"all\")\n\n        # Test a multi-colored nested plot\n        palette = palettes.color_palette(\"dark\", 2)\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", data=self.df, palette=\"dark\")\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        for line in ax.lines[:(len(p.plot_data) + 1)]:\n            nt.assert_equal(line.get_color(), palette[0])\n        for line in ax.lines[(len(p.plot_data) + 1):]:\n            nt.assert_equal(line.get_color(), palette[1])\n\n        for i, pal_color in enumerate(palette):\n            for point_color in ax.collections[i].get_facecolors():\n                npt.assert_array_equal(point_color[:-1], pal_color)\n\n        plt.close(\"all\")\n\n    def test_simple_pointplots(self):\n\n        ax = cat.pointplot(\"g\", \"y\", data=self.df)\n        nt.assert_equal(len(ax.collections), 1)\n        nt.assert_equal(len(ax.lines), len(self.g.unique()) + 1)\n        nt.assert_equal(ax.get_xlabel(), \"g\")\n        nt.assert_equal(ax.get_ylabel(), \"y\")\n        plt.close(\"all\")\n\n        ax = cat.pointplot(\"y\", \"g\", orient=\"h\", data=self.df)\n        nt.assert_equal(len(ax.collections), 1)\n        nt.assert_equal(len(ax.lines), len(self.g.unique()) + 1)\n        nt.assert_equal(ax.get_xlabel(), \"y\")\n        nt.assert_equal(ax.get_ylabel(), \"g\")\n        plt.close(\"all\")\n\n        ax = cat.pointplot(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(len(ax.collections), len(self.h.unique()))\n        nt.assert_equal(len(ax.lines),\n                        (len(self.g.unique()) *\n                         len(self.h.unique()) +\n                         len(self.h.unique())))\n        nt.assert_equal(ax.get_xlabel(), \"g\")\n        nt.assert_equal(ax.get_ylabel(), \"y\")\n        plt.close(\"all\")\n\n        ax = cat.pointplot(\"y\", \"g\", \"h\", orient=\"h\", data=self.df)\n        nt.assert_equal(len(ax.collections), len(self.h.unique()))\n        nt.assert_equal(len(ax.lines),\n                        (len(self.g.unique()) *\n                         len(self.h.unique()) +\n                         len(self.h.unique())))\n        nt.assert_equal(ax.get_xlabel(), \"y\")\n        nt.assert_equal(ax.get_ylabel(), \"g\")\n        plt.close(\"all\")\n\n\nclass TestCountPlot(CategoricalFixture):\n\n    def test_plot_elements(self):\n\n        ax = cat.countplot(\"g\", data=self.df)\n        nt.assert_equal(len(ax.patches), self.g.unique().size)\n        for p in ax.patches:\n            nt.assert_equal(p.get_y(), 0)\n            nt.assert_equal(p.get_height(),\n                            self.g.size / self.g.unique().size)\n        plt.close(\"all\")\n\n        ax = cat.countplot(y=\"g\", data=self.df)\n        nt.assert_equal(len(ax.patches), self.g.unique().size)\n        for p in ax.patches:\n            nt.assert_equal(p.get_x(), 0)\n            nt.assert_equal(p.get_width(),\n                            self.g.size / self.g.unique().size)\n        plt.close(\"all\")\n\n        ax = cat.countplot(\"g\", hue=\"h\", data=self.df)\n        nt.assert_equal(len(ax.patches),\n                        self.g.unique().size * self.h.unique().size)\n        plt.close(\"all\")\n\n        ax = cat.countplot(y=\"g\", hue=\"h\", data=self.df)\n        nt.assert_equal(len(ax.patches),\n                        self.g.unique().size * self.h.unique().size)\n        plt.close(\"all\")\n\n    def test_input_error(self):\n\n        with nt.assert_raises(TypeError):\n            cat.countplot()\n\n        with nt.assert_raises(TypeError):\n            cat.countplot(x=\"g\", y=\"h\", data=self.df)\n\n\nclass TestFactorPlot(CategoricalFixture):\n\n    def test_facet_organization(self):\n\n        g = cat.factorplot(\"g\", \"y\", data=self.df)\n        nt.assert_equal(g.axes.shape, (1, 1))\n\n        g = cat.factorplot(\"g\", \"y\", col=\"h\", data=self.df)\n        nt.assert_equal(g.axes.shape, (1, 2))\n\n        g = cat.factorplot(\"g\", \"y\", row=\"h\", data=self.df)\n        nt.assert_equal(g.axes.shape, (2, 1))\n\n        g = cat.factorplot(\"g\", \"y\", col=\"u\", row=\"h\", data=self.df)\n        nt.assert_equal(g.axes.shape, (2, 3))\n\n    def test_plot_elements(self):\n\n        g = cat.factorplot(\"g\", \"y\", data=self.df)\n        nt.assert_equal(len(g.ax.collections), 1)\n        want_lines = self.g.unique().size + 1\n        nt.assert_equal(len(g.ax.lines), want_lines)\n\n        g = cat.factorplot(\"g\", \"y\", \"h\", data=self.df)\n        want_collections = self.h.unique().size\n        nt.assert_equal(len(g.ax.collections), want_collections)\n        want_lines = (self.g.unique().size + 1) * self.h.unique().size\n        nt.assert_equal(len(g.ax.lines), want_lines)\n\n        g = cat.factorplot(\"g\", \"y\", data=self.df, kind=\"bar\")\n        want_elements = self.g.unique().size\n        nt.assert_equal(len(g.ax.patches), want_elements)\n        nt.assert_equal(len(g.ax.lines), want_elements)\n\n        g = cat.factorplot(\"g\", \"y\", \"h\", data=self.df, kind=\"bar\")\n        want_elements = self.g.unique().size * self.h.unique().size\n        nt.assert_equal(len(g.ax.patches), want_elements)\n        nt.assert_equal(len(g.ax.lines), want_elements)\n\n        g = cat.factorplot(\"g\", data=self.df, kind=\"count\")\n        want_elements = self.g.unique().size\n        nt.assert_equal(len(g.ax.patches), want_elements)\n        nt.assert_equal(len(g.ax.lines), 0)\n\n        g = cat.factorplot(\"g\", hue=\"h\", data=self.df, kind=\"count\")\n        want_elements = self.g.unique().size * self.h.unique().size\n        nt.assert_equal(len(g.ax.patches), want_elements)\n        nt.assert_equal(len(g.ax.lines), 0)\n\n        g = cat.factorplot(\"g\", \"y\", data=self.df, kind=\"box\")\n        want_artists = self.g.unique().size\n        nt.assert_equal(len(g.ax.artists), want_artists)\n\n        g = cat.factorplot(\"g\", \"y\", \"h\", data=self.df, kind=\"box\")\n        want_artists = self.g.unique().size * self.h.unique().size\n        nt.assert_equal(len(g.ax.artists), want_artists)\n\n        g = cat.factorplot(\"g\", \"y\", data=self.df,\n                           kind=\"violin\", inner=None)\n        want_elements = self.g.unique().size\n        nt.assert_equal(len(g.ax.collections), want_elements)\n\n        g = cat.factorplot(\"g\", \"y\", \"h\", data=self.df,\n                           kind=\"violin\", inner=None)\n        want_elements = self.g.unique().size * self.h.unique().size\n        nt.assert_equal(len(g.ax.collections), want_elements)\n\n        g = cat.factorplot(\"g\", \"y\", data=self.df, kind=\"strip\")\n        want_elements = self.g.unique().size\n        nt.assert_equal(len(g.ax.collections), want_elements)\n\n        g = cat.factorplot(\"g\", \"y\", \"h\", data=self.df, kind=\"strip\")\n        want_elements = self.g.unique().size + self.h.unique().size\n        nt.assert_equal(len(g.ax.collections), want_elements)\n\n    def test_bad_plot_kind_error(self):\n\n        with nt.assert_raises(ValueError):\n            cat.factorplot(\"g\", \"y\", data=self.df, kind=\"not_a_kind\")\n\n    def test_count_x_and_y(self):\n\n        with nt.assert_raises(ValueError):\n            cat.factorplot(\"g\", \"y\", data=self.df, kind=\"count\")\n\n    def test_plot_colors(self):\n\n        ax = cat.barplot(\"g\", \"y\", data=self.df)\n        g = cat.factorplot(\"g\", \"y\", data=self.df, kind=\"bar\")\n        for p1, p2 in zip(ax.patches, g.ax.patches):\n            nt.assert_equal(p1.get_facecolor(), p2.get_facecolor())\n        plt.close(\"all\")\n\n        ax = cat.barplot(\"g\", \"y\", data=self.df, color=\"purple\")\n        g = cat.factorplot(\"g\", \"y\", data=self.df,\n                           kind=\"bar\", color=\"purple\")\n        for p1, p2 in zip(ax.patches, g.ax.patches):\n            nt.assert_equal(p1.get_facecolor(), p2.get_facecolor())\n        plt.close(\"all\")\n\n        ax = cat.barplot(\"g\", \"y\", data=self.df, palette=\"Set2\")\n        g = cat.factorplot(\"g\", \"y\", data=self.df,\n                           kind=\"bar\", palette=\"Set2\")\n        for p1, p2 in zip(ax.patches, g.ax.patches):\n            nt.assert_equal(p1.get_facecolor(), p2.get_facecolor())\n        plt.close(\"all\")\n\n        ax = cat.pointplot(\"g\", \"y\", data=self.df)\n        g = cat.factorplot(\"g\", \"y\", data=self.df)\n        for l1, l2 in zip(ax.lines, g.ax.lines):\n            nt.assert_equal(l1.get_color(), l2.get_color())\n        plt.close(\"all\")\n\n        ax = cat.pointplot(\"g\", \"y\", data=self.df, color=\"purple\")\n        g = cat.factorplot(\"g\", \"y\", data=self.df, color=\"purple\")\n        for l1, l2 in zip(ax.lines, g.ax.lines):\n            nt.assert_equal(l1.get_color(), l2.get_color())\n        plt.close(\"all\")\n\n        ax = cat.pointplot(\"g\", \"y\", data=self.df, palette=\"Set2\")\n        g = cat.factorplot(\"g\", \"y\", data=self.df, palette=\"Set2\")\n        for l1, l2 in zip(ax.lines, g.ax.lines):\n            nt.assert_equal(l1.get_color(), l2.get_color())\n        plt.close(\"all\")\n\n\nclass TestLVPlotter(CategoricalFixture):\n\n    default_kws = dict(x=None, y=None, hue=None, data=None,\n                            order=None, hue_order=None,\n                            orient=None, color=None, palette=None,\n                            saturation=.75, width=.8, dodge=True,\n                            k_depth='proportion', linewidth=None,\n                            scale='exponential', outlier_prop=None)\n\n    def ispatch(self, c):\n\n        return isinstance(c, mpl.collections.PatchCollection)\n\n    def edge_calc(self, n, data):\n\n        q = np.asanyarray([0.5 ** n, 1 - 0.5 ** n]) * 100\n        q = list(np.unique(q))\n        return np.percentile(data, q)\n\n    def test_box_ends_finite(self):\n        p = cat._LVPlotter(**self.default_kws)\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        box_k = np.asarray([[b, k]\n                           for b, k in map(p._lv_box_ends, p.plot_data)])\n        box_ends = box_k[:, 0]\n        k_vals = box_k[:, 1]\n\n        # Check that all the box ends are finite and are within\n        # the bounds of the data\n        b_e = map(lambda a: np.all(np.isfinite(a)), box_ends)\n        npt.assert_equal(np.sum(list(b_e)), len(box_ends))\n\n        def within(t):\n            a, d = t\n            return ((np.ravel(a) <= d.max()) &\n                    (np.ravel(a) >= d.min())).all()\n\n        b_w = map(within, zip(box_ends, p.plot_data))\n        npt.assert_equal(np.sum(list(b_w)), len(box_ends))\n\n        k_f = map(lambda k: (k > 0.) & np.isfinite(k), k_vals)\n        npt.assert_equal(np.sum(list(k_f)), len(k_vals))\n\n    def test_box_ends_correct(self):\n\n        n = 100\n        linear_data = np.arange(n)\n        expected_k = int(np.log2(n)) - int(np.log2(n * 0.007)) + 1\n        expected_edges = [self.edge_calc(i, linear_data)\n                          for i in range(expected_k + 2, 1, -1)]\n\n        p = cat._LVPlotter(**self.default_kws)\n        calc_edges, calc_k = p._lv_box_ends(linear_data)\n\n        npt.assert_equal(list(expected_edges), calc_edges)\n        npt.assert_equal(expected_k, calc_k)\n\n    def test_outliers(self):\n\n        n = 100\n        outlier_data = np.append(np.arange(n - 1), 2 * n)\n        expected_k = int(np.log2(n)) - int(np.log2(n * 0.007)) + 1\n        expected_edges = [self.edge_calc(i, outlier_data)\n                          for i in range(expected_k + 2, 1, -1)]\n\n        p = cat._LVPlotter(**self.default_kws)\n        calc_edges, calc_k = p._lv_box_ends(outlier_data)\n\n        npt.assert_equal(list(expected_edges), calc_edges)\n\n        npt.assert_equal(expected_k, calc_k)\n\n        out_calc = p._lv_outliers(outlier_data, calc_k)\n        out_exp = p._lv_outliers(outlier_data, expected_k)\n\n        npt.assert_equal(out_exp, out_calc)\n\n    def test_hue_offsets(self):\n\n        p = cat._LVPlotter(**self.default_kws)\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        npt.assert_array_equal(p.hue_offsets, [-.2, .2])\n\n        kws = self.default_kws.copy()\n        kws[\"width\"] = .6\n        p = cat._LVPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", \"h\", data=self.df)\n        npt.assert_array_equal(p.hue_offsets, [-.15, .15])\n\n        p = cat._LVPlotter(**kws)\n        p.establish_variables(\"h\", \"y\", \"g\", data=self.df)\n        npt.assert_array_almost_equal(p.hue_offsets, [-.2, 0, .2])\n\n    def test_axes_data(self):\n\n        ax = cat.lvplot(\"g\", \"y\", data=self.df)\n        patches = filter(self.ispatch, ax.collections)\n        nt.assert_equal(len(list(patches)), 3)\n\n        plt.close(\"all\")\n\n        ax = cat.lvplot(\"g\", \"y\", \"h\", data=self.df)\n        patches = filter(self.ispatch, ax.collections)\n        nt.assert_equal(len(list(patches)), 6)\n\n        plt.close(\"all\")\n\n    def test_box_colors(self):\n\n        ax = cat.lvplot(\"g\", \"y\", data=self.df, saturation=1)\n        pal = palettes.color_palette(n_colors=3)\n        for patch, color in zip(ax.artists, pal):\n            nt.assert_equal(patch.get_facecolor()[:3], color)\n\n        plt.close(\"all\")\n\n        ax = cat.lvplot(\"g\", \"y\", \"h\", data=self.df, saturation=1)\n        pal = palettes.color_palette(n_colors=2)\n        for patch, color in zip(ax.artists, pal * 2):\n            nt.assert_equal(patch.get_facecolor()[:3], color)\n\n        plt.close(\"all\")\n\n    def test_draw_missing_boxes(self):\n\n        ax = cat.lvplot(\"g\", \"y\", data=self.df,\n                        order=[\"a\", \"b\", \"c\", \"d\"])\n\n        patches = filter(self.ispatch, ax.collections)\n        nt.assert_equal(len(list(patches)), 3)\n        plt.close(\"all\")\n\n    def test_missing_data(self):\n\n        x = [\"a\", \"a\", \"b\", \"b\", \"c\", \"c\", \"d\", \"d\"]\n        h = [\"x\", \"y\", \"x\", \"y\", \"x\", \"y\", \"x\", \"y\"]\n        y = self.rs.randn(8)\n        y[-2:] = np.nan\n\n        ax = cat.lvplot(x, y)\n        patches = filter(self.ispatch, ax.collections)\n        nt.assert_equal(len(ax.lines), 3)\n\n        plt.close(\"all\")\n\n        y[-1] = 0\n        ax = cat.lvplot(x, y, h)\n        nt.assert_equal(len(ax.lines), 7)\n\n        plt.close(\"all\")\n\n    def test_lvplots(self):\n\n        # Smoke test the high level lvplot options\n\n        cat.lvplot(\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.lvplot(y=\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.lvplot(\"g\", \"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.lvplot(\"y\", \"g\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n        cat.lvplot(\"g\", \"y\", \"h\", data=self.df)\n        plt.close(\"all\")\n\n        cat.lvplot(\"g\", \"y\", \"h\", order=list(\"nabc\"), data=self.df)\n        plt.close(\"all\")\n\n        cat.lvplot(\"g\", \"y\", \"h\", hue_order=list(\"omn\"), data=self.df)\n        plt.close(\"all\")\n\n        cat.lvplot(\"y\", \"g\", \"h\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n    def test_axes_annotation(self):\n\n        ax = cat.lvplot(\"g\", \"y\", data=self.df)\n        nt.assert_equal(ax.get_xlabel(), \"g\")\n        nt.assert_equal(ax.get_ylabel(), \"y\")\n        nt.assert_equal(ax.get_xlim(), (-.5, 2.5))\n        npt.assert_array_equal(ax.get_xticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_xticklabels()],\n                               [\"a\", \"b\", \"c\"])\n\n        plt.close(\"all\")\n\n        ax = cat.lvplot(\"g\", \"y\", \"h\", data=self.df)\n        nt.assert_equal(ax.get_xlabel(), \"g\")\n        nt.assert_equal(ax.get_ylabel(), \"y\")\n        npt.assert_array_equal(ax.get_xticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_xticklabels()],\n                               [\"a\", \"b\", \"c\"])\n        npt.assert_array_equal([l.get_text() for l in ax.legend_.get_texts()],\n                               [\"m\", \"n\"])\n\n        plt.close(\"all\")\n\n        ax = cat.lvplot(\"y\", \"g\", data=self.df, orient=\"h\")\n        nt.assert_equal(ax.get_xlabel(), \"y\")\n        nt.assert_equal(ax.get_ylabel(), \"g\")\n        nt.assert_equal(ax.get_ylim(), (2.5, -.5))\n        npt.assert_array_equal(ax.get_yticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_yticklabels()],\n                               [\"a\", \"b\", \"c\"])\n\n        plt.close(\"all\")\n", "description": "Statistical data visualization using matplotlib", "file_name": "test_categorical.py", "id": "864acb1d22211334d2a6e9ec75c60793", "language": "Python", "project_name": "seaborn", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mwaskom-seaborn/mwaskom-seaborn-71a807b/seaborn/tests/test_categorical.py", "save_time": "", "source": "", "update_at": "2018-03-18T02:14:24Z", "url": "https://github.com/mwaskom/seaborn", "wiki": false}