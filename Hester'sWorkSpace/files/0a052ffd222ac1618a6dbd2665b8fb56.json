{"author": "tornadoweb", "code": "\n\"\"\"Benchmark for stack_context functionality.\"\"\"\nimport collections\nimport contextlib\nimport functools\nimport subprocess\nimport sys\n\nfrom tornado import stack_context\n\n\nclass Benchmark(object):\n    def enter_exit(self, count):\n        \"\"\"Measures the overhead of the nested \"with\" statements\n        when using many contexts.\n        \"\"\"\n        if count < 0:\n            return\n        with self.make_context():\n            self.enter_exit(count - 1)\n\n    def call_wrapped(self, count):\n        \"\"\"Wraps and calls a function at each level of stack depth\n        to measure the overhead of the wrapped function.\n        \"\"\"\n        \n        \n        \n        queue = collections.deque()\n        self.call_wrapped_inner(queue, count)\n        while queue:\n            queue.popleft()()\n\n    def call_wrapped_inner(self, queue, count):\n        if count < 0:\n            return\n        with self.make_context():\n            queue.append(stack_context.wrap(\n                functools.partial(self.call_wrapped_inner, queue, count - 1)))\n\n\nclass StackBenchmark(Benchmark):\n    def make_context(self):\n        return stack_context.StackContext(self.__context)\n\n    @contextlib.contextmanager\n    def __context(self):\n        yield\n\n\nclass ExceptionBenchmark(Benchmark):\n    def make_context(self):\n        return stack_context.ExceptionStackContext(self.__handle_exception)\n\n    def __handle_exception(self, typ, value, tb):\n        pass\n\n\ndef main():\n    base_cmd = [\n        sys.executable, '-m', 'timeit', '-s',\n        'from stack_context_benchmark import StackBenchmark, ExceptionBenchmark']\n    cmds = [\n        'StackBenchmark().enter_exit(50)',\n        'StackBenchmark().call_wrapped(50)',\n        'StackBenchmark().enter_exit(500)',\n        'StackBenchmark().call_wrapped(500)',\n\n        'ExceptionBenchmark().enter_exit(50)',\n        'ExceptionBenchmark().call_wrapped(50)',\n        'ExceptionBenchmark().enter_exit(500)',\n        'ExceptionBenchmark().call_wrapped(500)',\n    ]\n    for cmd in cmds:\n        print(cmd)\n        subprocess.check_call(base_cmd + [cmd])\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "   benchmark stack context functionality     import collections import contextlib import functools import subprocess import sys  tornado import stack context   class benchmark(object)      def enter exit(self  count)             measures overhead nested   statements         using many contexts                      count   0              return         self make context()              self enter exit(count   1)      def call wrapped(self  count)             wraps calls function level stack depth         measure overhead wrapped function                  usr bin env python    this queue analogous ioloop add callback  lets us    benchmark stack context isolation without system call    overhead  ", "content": "#!/usr/bin/env python\n\"\"\"Benchmark for stack_context functionality.\"\"\"\nimport collections\nimport contextlib\nimport functools\nimport subprocess\nimport sys\n\nfrom tornado import stack_context\n\n\nclass Benchmark(object):\n    def enter_exit(self, count):\n        \"\"\"Measures the overhead of the nested \"with\" statements\n        when using many contexts.\n        \"\"\"\n        if count < 0:\n            return\n        with self.make_context():\n            self.enter_exit(count - 1)\n\n    def call_wrapped(self, count):\n        \"\"\"Wraps and calls a function at each level of stack depth\n        to measure the overhead of the wrapped function.\n        \"\"\"\n        # This queue is analogous to IOLoop.add_callback, but lets us\n        # benchmark the stack_context in isolation without system call\n        # overhead.\n        queue = collections.deque()\n        self.call_wrapped_inner(queue, count)\n        while queue:\n            queue.popleft()()\n\n    def call_wrapped_inner(self, queue, count):\n        if count < 0:\n            return\n        with self.make_context():\n            queue.append(stack_context.wrap(\n                functools.partial(self.call_wrapped_inner, queue, count - 1)))\n\n\nclass StackBenchmark(Benchmark):\n    def make_context(self):\n        return stack_context.StackContext(self.__context)\n\n    @contextlib.contextmanager\n    def __context(self):\n        yield\n\n\nclass ExceptionBenchmark(Benchmark):\n    def make_context(self):\n        return stack_context.ExceptionStackContext(self.__handle_exception)\n\n    def __handle_exception(self, typ, value, tb):\n        pass\n\n\ndef main():\n    base_cmd = [\n        sys.executable, '-m', 'timeit', '-s',\n        'from stack_context_benchmark import StackBenchmark, ExceptionBenchmark']\n    cmds = [\n        'StackBenchmark().enter_exit(50)',\n        'StackBenchmark().call_wrapped(50)',\n        'StackBenchmark().enter_exit(500)',\n        'StackBenchmark().call_wrapped(500)',\n\n        'ExceptionBenchmark().enter_exit(50)',\n        'ExceptionBenchmark().call_wrapped(50)',\n        'ExceptionBenchmark().enter_exit(500)',\n        'ExceptionBenchmark().call_wrapped(500)',\n    ]\n    for cmd in cmds:\n        print(cmd)\n        subprocess.check_call(base_cmd + [cmd])\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Tornado is a Python web framework and asynchronous networking library, originally developed at FriendFeed.", "file_name": "stack_context_benchmark.py", "id": "0a052ffd222ac1618a6dbd2665b8fb56", "language": "Python", "project_name": "tornado", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tornadoweb-tornado/tornadoweb-tornado-9a97ffb/demos/benchmark/stack_context_benchmark.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:52:45Z", "url": "https://github.com/tornadoweb/tornado", "wiki": true}