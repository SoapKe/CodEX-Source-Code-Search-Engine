{"author": "localstack", "code": "import re\nimport json\nimport random\nimport logging\nimport threading\nfrom binascii import crc32\nfrom requests.models import Response\nfrom localstack import config\nfrom localstack.utils.aws import aws_stack\nfrom localstack.utils.common import to_bytes, to_str, clone\nfrom localstack.utils.analytics import event_publisher\nfrom localstack.constants import DEFAULT_REGION\nfrom localstack.services.awslambda import lambda_api\nfrom localstack.services.dynamodbstreams import dynamodbstreams_api\nfrom localstack.services.generic_proxy import ProxyListener\n\n\nTABLE_DEFINITIONS = {}\n\n\nACTION_PREFIX = 'DynamoDB_20120810'\n\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass ProxyListenerDynamoDB(ProxyListener):\n\n    thread_local = threading.local()\n\n    def __init__(self):\n        self._table_ttl_map = {}\n\n    def forward_request(self, method, path, data, headers):\n        data = json.loads(to_str(data))\n\n        if random.random() < config.DYNAMODB_ERROR_PROBABILITY:\n            return error_response_throughput()\n\n        action = headers.get('X-Amz-Target')\n        if action in ('%s.PutItem' % ACTION_PREFIX, '%s.UpdateItem' % ACTION_PREFIX, '%s.DeleteItem' % ACTION_PREFIX):\n            \n            # in order to determine whether an item already existed (MODIFY) or not (INSERT)\n            ProxyListenerDynamoDB.thread_local.existing_item = find_existing_item(data)\n        elif action == '%s.UpdateTimeToLive' % ACTION_PREFIX:\n            \n            response = Response()\n            response.status_code = 200\n            self._table_ttl_map[data['TableName']] = {\n                'AttributeName': data['TimeToLiveSpecification']['AttributeName'],\n                'Status': data['TimeToLiveSpecification']['Enabled']\n            }\n            response._content = json.dumps({'TimeToLiveSpecification': data['TimeToLiveSpecification']})\n            fix_headers_for_updated_response(response)\n            return response\n        elif action == '%s.DescribeTimeToLive' % ACTION_PREFIX:\n            response = Response()\n            response.status_code = 200\n            if data['TableName'] in self._table_ttl_map:\n                if self._table_ttl_map[data['TableName']]['Status']:\n                    ttl_status = 'ENABLED'\n                else:\n                    ttl_status = 'DISABLED'\n                response._content = json.dumps({\n                    'TimeToLiveDescription': {\n                        'AttributeName': self._table_ttl_map[data['TableName']]['AttributeName'],\n                        'TimeToLiveStatus': ttl_status\n                    }\n                })\n            else:  \n                response._content = json.dumps({'TimeToLiveDescription': {'TimeToLiveStatus': 'DISABLED'}})\n            fix_headers_for_updated_response(response)\n            return response\n        elif action == '%s.TagResource' % ACTION_PREFIX or action == '%s.UntagResource' % ACTION_PREFIX:\n            response = Response()\n            response.status_code = 200\n            response._content = ''  \n            fix_headers_for_updated_response(response)\n            return response\n        elif action == '%s.ListTagsOfResource' % ACTION_PREFIX:\n            response = Response()\n            response.status_code = 200\n            response._content = json.dumps({'Tags': []})  \n            fix_headers_for_updated_response(response)\n            return response\n\n        return True\n\n    def return_response(self, method, path, data, headers, response):\n        data = json.loads(to_str(data))\n\n        \n        if data and 'TableName' in data and 'KeySchema' in data:\n            TABLE_DEFINITIONS[data['TableName']] = data\n\n        if response._content:\n            # fix the table ARN (DynamoDBLocal hardcodes \"ddblocal\" as the region)\n            content_replaced = re.sub(r'\"TableArn\"\\s*:\\s*\"arn:aws:dynamodb:ddblocal:([^\"]+)\"',\n                r'\"TableArn\": \"arn:aws:dynamodb:%s:\\1\"' % aws_stack.get_local_region(), to_str(response._content))\n            if content_replaced != response._content:\n                response._content = content_replaced\n                fix_headers_for_updated_response(response)\n\n        action = headers.get('X-Amz-Target')\n        if not action:\n            return\n\n        record = {\n            'eventID': '1',\n            'eventVersion': '1.0',\n            'dynamodb': {\n                'StreamViewType': 'NEW_AND_OLD_IMAGES',\n                'SizeBytes': -1\n            },\n            'awsRegion': DEFAULT_REGION,\n            'eventSource': 'aws:dynamodb'\n        }\n        records = [record]\n\n        if action == '%s.UpdateItem' % ACTION_PREFIX:\n            updated_item = find_existing_item(data)\n            if not updated_item:\n                return\n            record['eventName'] = 'MODIFY'\n            record['dynamodb']['Keys'] = data['Key']\n            record['dynamodb']['OldImage'] = ProxyListenerDynamoDB.thread_local.existing_item\n            record['dynamodb']['NewImage'] = updated_item\n            record['dynamodb']['SizeBytes'] = len(json.dumps(updated_item))\n        elif action == '%s.BatchWriteItem' % ACTION_PREFIX:\n            records = []\n            for table_name, requests in data['RequestItems'].items():\n                for request in requests:\n                    put_request = request.get('PutRequest')\n                    if put_request:\n                        keys = dynamodb_extract_keys(item=put_request['Item'], table_name=table_name)\n                        if isinstance(keys, Response):\n                            return keys\n                        new_record = clone(record)\n                        new_record['eventName'] = 'INSERT'\n                        new_record['dynamodb']['Keys'] = keys\n                        new_record['dynamodb']['NewImage'] = put_request['Item']\n                        new_record['eventSourceARN'] = aws_stack.dynamodb_table_arn(table_name)\n                        records.append(new_record)\n        elif action == '%s.PutItem' % ACTION_PREFIX:\n            existing_item = ProxyListenerDynamoDB.thread_local.existing_item\n            ProxyListenerDynamoDB.thread_local.existing_item = None\n            record['eventName'] = 'INSERT' if not existing_item else 'MODIFY'\n            keys = dynamodb_extract_keys(item=data['Item'], table_name=data['TableName'])\n            if isinstance(keys, Response):\n                return keys\n            record['dynamodb']['Keys'] = keys\n            record['dynamodb']['NewImage'] = data['Item']\n            record['dynamodb']['SizeBytes'] = len(json.dumps(data['Item']))\n        elif action == '%s.GetItem' % ACTION_PREFIX:\n            if response.status_code == 200:\n                content = json.loads(to_str(response.content))\n                \n                \n                if 'ConsumedCapacity' not in content and data.get('ReturnConsumedCapacity') in ('TOTAL', 'INDEXES'):\n                    content['ConsumedCapacity'] = {\n                        'CapacityUnits': 0.5,  \n                        'TableName': data['TableName']\n                    }\n                    response._content = json.dumps(content)\n                    fix_headers_for_updated_response(response)\n        elif action == '%s.DeleteItem' % ACTION_PREFIX:\n            old_item = ProxyListenerDynamoDB.thread_local.existing_item\n            record['eventName'] = 'REMOVE'\n            record['dynamodb']['Keys'] = data['Key']\n            record['dynamodb']['OldImage'] = old_item\n        elif action == '%s.CreateTable' % ACTION_PREFIX:\n            if 'StreamSpecification' in data:\n                create_dynamodb_stream(data)\n            event_publisher.fire_event(event_publisher.EVENT_DYNAMODB_CREATE_TABLE,\n                payload={'n': event_publisher.get_hash(data['TableName'])})\n            return\n        elif action == '%s.DeleteTable' % ACTION_PREFIX:\n            event_publisher.fire_event(event_publisher.EVENT_DYNAMODB_DELETE_TABLE,\n                payload={'n': event_publisher.get_hash(data['TableName'])})\n            return\n        elif action == '%s.UpdateTable' % ACTION_PREFIX:\n            if 'StreamSpecification' in data:\n                create_dynamodb_stream(data)\n            return\n        else:\n            \n            return\n\n        if len(records) > 0 and 'eventName' in records[0]:\n            if 'TableName' in data:\n                records[0]['eventSourceARN'] = aws_stack.dynamodb_table_arn(data['TableName'])\n            forward_to_lambda(records)\n            forward_to_ddb_stream(records)\n\n\n\nUPDATE_DYNAMODB = ProxyListenerDynamoDB()\n\n\ndef find_existing_item(put_item):\n    table_name = put_item['TableName']\n    ddb_client = aws_stack.connect_to_service('dynamodb')\n\n    search_key = {}\n    if 'Key' in put_item:\n        search_key = put_item['Key']\n    else:\n        schema = ddb_client.describe_table(TableName=table_name)\n        schemas = [schema['Table']['KeySchema']]\n        for index in schema['Table'].get('GlobalSecondaryIndexes', []):\n            # schemas.append(index['KeySchema'])\n            pass\n        for schema in schemas:\n            for key in schema:\n                key_name = key['AttributeName']\n                search_key[key_name] = put_item['Item'][key_name]\n        if not search_key:\n            return\n\n    req = {'TableName': table_name, 'Key': search_key}\n    existing_item = aws_stack.dynamodb_get_item_raw(req)\n    if 'Item' not in existing_item:\n        if 'message' in existing_item:\n            table_names = ddb_client.list_tables()['TableNames']\n            msg = ('Unable to get item from DynamoDB (existing tables: %s): %s' %\n                (table_names, existing_item['message']))\n            LOGGER.warning(msg)\n        return\n    return existing_item.get('Item')\n\n\ndef fix_headers_for_updated_response(response):\n    response.headers['content-length'] = len(to_bytes(response.content))\n    response.headers['x-amz-crc32'] = calculate_crc32(response)\n\n\ndef calculate_crc32(response):\n    return crc32(to_bytes(response.content)) & 0xffffffff\n\n\ndef create_dynamodb_stream(data):\n    stream = data['StreamSpecification']\n    enabled = stream.get('StreamEnabled')\n    if enabled not in [False, 'False']:\n        table_name = data['TableName']\n        view_type = stream['StreamViewType']\n        dynamodbstreams_api.add_dynamodb_stream(table_name=table_name,\n            view_type=view_type, enabled=enabled)\n\n\ndef forward_to_lambda(records):\n    for record in records:\n        sources = lambda_api.get_event_sources(source_arn=record['eventSourceARN'])\n        event = {\n            'Records': [record]\n        }\n        for src in sources:\n            lambda_api.run_lambda(event=event, context={}, func_arn=src['FunctionArn'])\n\n\ndef forward_to_ddb_stream(records):\n    dynamodbstreams_api.forward_events(records)\n\n\ndef dynamodb_extract_keys(item, table_name):\n    result = {}\n    if table_name not in TABLE_DEFINITIONS:\n        LOGGER.warning('Unknown table: %s not found in %s' % (table_name, TABLE_DEFINITIONS))\n        return None\n    for key in TABLE_DEFINITIONS[table_name]['KeySchema']:\n        attr_name = key['AttributeName']\n        if attr_name not in item:\n            return error_response(error_type='ValidationException',\n                message='One of the required keys was not given a value')\n        result[attr_name] = item[attr_name]\n    return result\n\n\ndef error_response(message=None, error_type=None, code=400):\n    if not message:\n        message = 'Unknown error'\n    if not error_type:\n        error_type = 'UnknownError'\n    if 'com.amazonaws.dynamodb' not in error_type:\n        error_type = 'com.amazonaws.dynamodb.v20120810\n    response = Response()\n    response.status_code = code\n    content = {\n        'message': message,\n        '__type': error_type\n    }\n    response._content = json.dumps(content)\n    return response\n\n\ndef error_response_throughput():\n    message = ('The level of configured provisioned throughput for the table was exceeded. ' +\n            'Consider increasing your provisioning level with the UpdateTable API')\n    error_type = 'ProvisionedThroughputExceededException'\n    return error_response(message, error_type)\n", "comments": "  cache table definitions   used testing    action header prefix    set logger    find existing item store thread local  access return response     order determine whether item already existed (modify) (insert)    todo  ttl status maintained mocked real expiry happening items    ttl dynamodb table set    returns empty body success     todo  mocked returns empty list tags     update table definitions    fix table arn (dynamodblocal hardcodes  ddblocal  region)    make sure append  consumedcapacity   properly    returned dynalite  aws dynamodblocal    todo hardcoded    nothing    instantiate listener    schemas append(index  keyschema  )       error type ", "content": "import re\nimport json\nimport random\nimport logging\nimport threading\nfrom binascii import crc32\nfrom requests.models import Response\nfrom localstack import config\nfrom localstack.utils.aws import aws_stack\nfrom localstack.utils.common import to_bytes, to_str, clone\nfrom localstack.utils.analytics import event_publisher\nfrom localstack.constants import DEFAULT_REGION\nfrom localstack.services.awslambda import lambda_api\nfrom localstack.services.dynamodbstreams import dynamodbstreams_api\nfrom localstack.services.generic_proxy import ProxyListener\n\n# cache table definitions - used for testing\nTABLE_DEFINITIONS = {}\n\n# action header prefix\nACTION_PREFIX = 'DynamoDB_20120810'\n\n# set up logger\nLOGGER = logging.getLogger(__name__)\n\n\nclass ProxyListenerDynamoDB(ProxyListener):\n\n    thread_local = threading.local()\n\n    def __init__(self):\n        self._table_ttl_map = {}\n\n    def forward_request(self, method, path, data, headers):\n        data = json.loads(to_str(data))\n\n        if random.random() < config.DYNAMODB_ERROR_PROBABILITY:\n            return error_response_throughput()\n\n        action = headers.get('X-Amz-Target')\n        if action in ('%s.PutItem' % ACTION_PREFIX, '%s.UpdateItem' % ACTION_PREFIX, '%s.DeleteItem' % ACTION_PREFIX):\n            # find an existing item and store it in a thread-local, so we can access it in return_response,\n            # in order to determine whether an item already existed (MODIFY) or not (INSERT)\n            ProxyListenerDynamoDB.thread_local.existing_item = find_existing_item(data)\n        elif action == '%s.UpdateTimeToLive' % ACTION_PREFIX:\n            # TODO: TTL status is maintained/mocked but no real expiry is happening for items\n            response = Response()\n            response.status_code = 200\n            self._table_ttl_map[data['TableName']] = {\n                'AttributeName': data['TimeToLiveSpecification']['AttributeName'],\n                'Status': data['TimeToLiveSpecification']['Enabled']\n            }\n            response._content = json.dumps({'TimeToLiveSpecification': data['TimeToLiveSpecification']})\n            fix_headers_for_updated_response(response)\n            return response\n        elif action == '%s.DescribeTimeToLive' % ACTION_PREFIX:\n            response = Response()\n            response.status_code = 200\n            if data['TableName'] in self._table_ttl_map:\n                if self._table_ttl_map[data['TableName']]['Status']:\n                    ttl_status = 'ENABLED'\n                else:\n                    ttl_status = 'DISABLED'\n                response._content = json.dumps({\n                    'TimeToLiveDescription': {\n                        'AttributeName': self._table_ttl_map[data['TableName']]['AttributeName'],\n                        'TimeToLiveStatus': ttl_status\n                    }\n                })\n            else:  # TTL for dynamodb table not set\n                response._content = json.dumps({'TimeToLiveDescription': {'TimeToLiveStatus': 'DISABLED'}})\n            fix_headers_for_updated_response(response)\n            return response\n        elif action == '%s.TagResource' % ACTION_PREFIX or action == '%s.UntagResource' % ACTION_PREFIX:\n            response = Response()\n            response.status_code = 200\n            response._content = ''  # returns an empty body on success.\n            fix_headers_for_updated_response(response)\n            return response\n        elif action == '%s.ListTagsOfResource' % ACTION_PREFIX:\n            response = Response()\n            response.status_code = 200\n            response._content = json.dumps({'Tags': []})  # TODO: mocked and returns an empty list of tags for now.\n            fix_headers_for_updated_response(response)\n            return response\n\n        return True\n\n    def return_response(self, method, path, data, headers, response):\n        data = json.loads(to_str(data))\n\n        # update table definitions\n        if data and 'TableName' in data and 'KeySchema' in data:\n            TABLE_DEFINITIONS[data['TableName']] = data\n\n        if response._content:\n            # fix the table ARN (DynamoDBLocal hardcodes \"ddblocal\" as the region)\n            content_replaced = re.sub(r'\"TableArn\"\\s*:\\s*\"arn:aws:dynamodb:ddblocal:([^\"]+)\"',\n                r'\"TableArn\": \"arn:aws:dynamodb:%s:\\1\"' % aws_stack.get_local_region(), to_str(response._content))\n            if content_replaced != response._content:\n                response._content = content_replaced\n                fix_headers_for_updated_response(response)\n\n        action = headers.get('X-Amz-Target')\n        if not action:\n            return\n\n        record = {\n            'eventID': '1',\n            'eventVersion': '1.0',\n            'dynamodb': {\n                'StreamViewType': 'NEW_AND_OLD_IMAGES',\n                'SizeBytes': -1\n            },\n            'awsRegion': DEFAULT_REGION,\n            'eventSource': 'aws:dynamodb'\n        }\n        records = [record]\n\n        if action == '%s.UpdateItem' % ACTION_PREFIX:\n            updated_item = find_existing_item(data)\n            if not updated_item:\n                return\n            record['eventName'] = 'MODIFY'\n            record['dynamodb']['Keys'] = data['Key']\n            record['dynamodb']['OldImage'] = ProxyListenerDynamoDB.thread_local.existing_item\n            record['dynamodb']['NewImage'] = updated_item\n            record['dynamodb']['SizeBytes'] = len(json.dumps(updated_item))\n        elif action == '%s.BatchWriteItem' % ACTION_PREFIX:\n            records = []\n            for table_name, requests in data['RequestItems'].items():\n                for request in requests:\n                    put_request = request.get('PutRequest')\n                    if put_request:\n                        keys = dynamodb_extract_keys(item=put_request['Item'], table_name=table_name)\n                        if isinstance(keys, Response):\n                            return keys\n                        new_record = clone(record)\n                        new_record['eventName'] = 'INSERT'\n                        new_record['dynamodb']['Keys'] = keys\n                        new_record['dynamodb']['NewImage'] = put_request['Item']\n                        new_record['eventSourceARN'] = aws_stack.dynamodb_table_arn(table_name)\n                        records.append(new_record)\n        elif action == '%s.PutItem' % ACTION_PREFIX:\n            existing_item = ProxyListenerDynamoDB.thread_local.existing_item\n            ProxyListenerDynamoDB.thread_local.existing_item = None\n            record['eventName'] = 'INSERT' if not existing_item else 'MODIFY'\n            keys = dynamodb_extract_keys(item=data['Item'], table_name=data['TableName'])\n            if isinstance(keys, Response):\n                return keys\n            record['dynamodb']['Keys'] = keys\n            record['dynamodb']['NewImage'] = data['Item']\n            record['dynamodb']['SizeBytes'] = len(json.dumps(data['Item']))\n        elif action == '%s.GetItem' % ACTION_PREFIX:\n            if response.status_code == 200:\n                content = json.loads(to_str(response.content))\n                # make sure we append 'ConsumedCapacity', which is properly\n                # returned by dynalite, but not by AWS's DynamoDBLocal\n                if 'ConsumedCapacity' not in content and data.get('ReturnConsumedCapacity') in ('TOTAL', 'INDEXES'):\n                    content['ConsumedCapacity'] = {\n                        'CapacityUnits': 0.5,  # TODO hardcoded\n                        'TableName': data['TableName']\n                    }\n                    response._content = json.dumps(content)\n                    fix_headers_for_updated_response(response)\n        elif action == '%s.DeleteItem' % ACTION_PREFIX:\n            old_item = ProxyListenerDynamoDB.thread_local.existing_item\n            record['eventName'] = 'REMOVE'\n            record['dynamodb']['Keys'] = data['Key']\n            record['dynamodb']['OldImage'] = old_item\n        elif action == '%s.CreateTable' % ACTION_PREFIX:\n            if 'StreamSpecification' in data:\n                create_dynamodb_stream(data)\n            event_publisher.fire_event(event_publisher.EVENT_DYNAMODB_CREATE_TABLE,\n                payload={'n': event_publisher.get_hash(data['TableName'])})\n            return\n        elif action == '%s.DeleteTable' % ACTION_PREFIX:\n            event_publisher.fire_event(event_publisher.EVENT_DYNAMODB_DELETE_TABLE,\n                payload={'n': event_publisher.get_hash(data['TableName'])})\n            return\n        elif action == '%s.UpdateTable' % ACTION_PREFIX:\n            if 'StreamSpecification' in data:\n                create_dynamodb_stream(data)\n            return\n        else:\n            # nothing to do\n            return\n\n        if len(records) > 0 and 'eventName' in records[0]:\n            if 'TableName' in data:\n                records[0]['eventSourceARN'] = aws_stack.dynamodb_table_arn(data['TableName'])\n            forward_to_lambda(records)\n            forward_to_ddb_stream(records)\n\n\n# instantiate listener\nUPDATE_DYNAMODB = ProxyListenerDynamoDB()\n\n\ndef find_existing_item(put_item):\n    table_name = put_item['TableName']\n    ddb_client = aws_stack.connect_to_service('dynamodb')\n\n    search_key = {}\n    if 'Key' in put_item:\n        search_key = put_item['Key']\n    else:\n        schema = ddb_client.describe_table(TableName=table_name)\n        schemas = [schema['Table']['KeySchema']]\n        for index in schema['Table'].get('GlobalSecondaryIndexes', []):\n            # schemas.append(index['KeySchema'])\n            pass\n        for schema in schemas:\n            for key in schema:\n                key_name = key['AttributeName']\n                search_key[key_name] = put_item['Item'][key_name]\n        if not search_key:\n            return\n\n    req = {'TableName': table_name, 'Key': search_key}\n    existing_item = aws_stack.dynamodb_get_item_raw(req)\n    if 'Item' not in existing_item:\n        if 'message' in existing_item:\n            table_names = ddb_client.list_tables()['TableNames']\n            msg = ('Unable to get item from DynamoDB (existing tables: %s): %s' %\n                (table_names, existing_item['message']))\n            LOGGER.warning(msg)\n        return\n    return existing_item.get('Item')\n\n\ndef fix_headers_for_updated_response(response):\n    response.headers['content-length'] = len(to_bytes(response.content))\n    response.headers['x-amz-crc32'] = calculate_crc32(response)\n\n\ndef calculate_crc32(response):\n    return crc32(to_bytes(response.content)) & 0xffffffff\n\n\ndef create_dynamodb_stream(data):\n    stream = data['StreamSpecification']\n    enabled = stream.get('StreamEnabled')\n    if enabled not in [False, 'False']:\n        table_name = data['TableName']\n        view_type = stream['StreamViewType']\n        dynamodbstreams_api.add_dynamodb_stream(table_name=table_name,\n            view_type=view_type, enabled=enabled)\n\n\ndef forward_to_lambda(records):\n    for record in records:\n        sources = lambda_api.get_event_sources(source_arn=record['eventSourceARN'])\n        event = {\n            'Records': [record]\n        }\n        for src in sources:\n            lambda_api.run_lambda(event=event, context={}, func_arn=src['FunctionArn'])\n\n\ndef forward_to_ddb_stream(records):\n    dynamodbstreams_api.forward_events(records)\n\n\ndef dynamodb_extract_keys(item, table_name):\n    result = {}\n    if table_name not in TABLE_DEFINITIONS:\n        LOGGER.warning('Unknown table: %s not found in %s' % (table_name, TABLE_DEFINITIONS))\n        return None\n    for key in TABLE_DEFINITIONS[table_name]['KeySchema']:\n        attr_name = key['AttributeName']\n        if attr_name not in item:\n            return error_response(error_type='ValidationException',\n                message='One of the required keys was not given a value')\n        result[attr_name] = item[attr_name]\n    return result\n\n\ndef error_response(message=None, error_type=None, code=400):\n    if not message:\n        message = 'Unknown error'\n    if not error_type:\n        error_type = 'UnknownError'\n    if 'com.amazonaws.dynamodb' not in error_type:\n        error_type = 'com.amazonaws.dynamodb.v20120810#%s' % error_type\n    response = Response()\n    response.status_code = code\n    content = {\n        'message': message,\n        '__type': error_type\n    }\n    response._content = json.dumps(content)\n    return response\n\n\ndef error_response_throughput():\n    message = ('The level of configured provisioned throughput for the table was exceeded. ' +\n            'Consider increasing your provisioning level with the UpdateTable API')\n    error_type = 'ProvisionedThroughputExceededException'\n    return error_response(message, error_type)\n", "description": "\ud83d\udcbb  A fully functional local AWS cloud stack. Develop and test your cloud apps offline!", "file_name": "dynamodb_listener.py", "id": "6deafdf00d26d1c805187579bc47e68e", "language": "Python", "project_name": "localstack", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/localstack-localstack/localstack-localstack-fcc848e/localstack/services/dynamodb/dynamodb_listener.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:04:08Z", "url": "https://github.com/localstack/localstack", "wiki": true}