{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\nimport time\nimport itertools\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_urllib_parse_urlencode,\n    compat_str,\n)\nfrom ..utils import (\n    dict_get,\n    ExtractorError,\n    float_or_none,\n    int_or_none,\n    remove_start,\n    try_get,\n    urlencode_postdata,\n)\n\n\nclass VLiveIE(InfoExtractor):\n    IE_NAME = 'vlive'\n    _VALID_URL = r'https?://(?:(?:www|m)\\.)?vlive\\.tv/video/(?P<id>[0-9]+)'\n    _TESTS = [{\n        'url': 'http://www.vlive.tv/video/1326',\n        'md5': 'cc7314812855ce56de70a06a27314983',\n        'info_dict': {\n            'id': '1326',\n            'ext': 'mp4',\n            'title': \"[V LIVE] Girl's Day's Broadcast\",\n            'creator': \"Girl's Day\",\n            'view_count': int,\n        },\n    }, {\n        'url': 'http://www.vlive.tv/video/16937',\n        'info_dict': {\n            'id': '16937',\n            'ext': 'mp4',\n            'title': '[V LIVE] \uccb8\ubc31\uc2dc \uac4d\ubc29',\n            'creator': 'EXO',\n            'view_count': int,\n            'subtitles': 'mincount:12',\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if VLivePlaylistIE.suitable(url) else super(VLiveIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(\n            'http://www.vlive.tv/video/%s' % video_id, video_id)\n\n        VIDEO_PARAMS_RE = r'\\bvlive\\.video\\.init\\(([^)]+)'\n        VIDEO_PARAMS_FIELD = 'video params'\n\n        params = self._parse_json(self._search_regex(\n            VIDEO_PARAMS_RE, webpage, VIDEO_PARAMS_FIELD, default=''), video_id,\n            transform_source=lambda s: '[' + s + ']', fatal=False)\n\n        if not params or len(params) < 7:\n            params = self._search_regex(\n                VIDEO_PARAMS_RE, webpage, VIDEO_PARAMS_FIELD)\n            params = [p.strip(r'\"') for p in re.split(r'\\s*,\\s*', params)]\n\n        status, long_video_id, key = params[2], params[5], params[6]\n        status = remove_start(status, 'PRODUCT_')\n\n        if status in ('LIVE_ON_AIR', 'BIG_EVENT_ON_AIR'):\n            return self._live(video_id, webpage)\n        elif status in ('VOD_ON_AIR', 'BIG_EVENT_INTRO'):\n            if long_video_id and key:\n                return self._replay(video_id, webpage, long_video_id, key)\n            else:\n                status = 'COMING_SOON'\n\n        if status == 'LIVE_END':\n            raise ExtractorError('Uploading for replay. Please wait...',\n                                 expected=True)\n        elif status == 'COMING_SOON':\n            raise ExtractorError('Coming soon!', expected=True)\n        elif status == 'CANCELED':\n            raise ExtractorError('We are sorry, '\n                                 'but the live broadcast has been canceled.',\n                                 expected=True)\n        else:\n            raise ExtractorError('Unknown status %s' % status)\n\n    def _get_common_fields(self, webpage):\n        title = self._og_search_title(webpage)\n        creator = self._html_search_regex(\n            r'<div[^>]+class=\"info_area\"[^>]*>\\s*<a\\s+[^>]*>([^<]+)',\n            webpage, 'creator', fatal=False)\n        thumbnail = self._og_search_thumbnail(webpage)\n        return {\n            'title': title,\n            'creator': creator,\n            'thumbnail': thumbnail,\n        }\n\n    def _live(self, video_id, webpage):\n        init_page = self._download_webpage(\n            'http://www.vlive.tv/video/init/view',\n            video_id, note='Downloading live webpage',\n            data=urlencode_postdata({'videoSeq': video_id}),\n            headers={\n                'Referer': 'http://www.vlive.tv/video/%s' % video_id,\n                'Content-Type': 'application/x-www-form-urlencoded'\n            })\n\n        live_params = self._search_regex(\n            r'\"liveStreamInfo\"\\s*:\\s*(\".*\"),',\n            init_page, 'live stream info')\n        live_params = self._parse_json(live_params, video_id)\n        live_params = self._parse_json(live_params, video_id)\n\n        formats = []\n        for vid in live_params.get('resolutions', []):\n            formats.extend(self._extract_m3u8_formats(\n                vid['cdnUrl'], video_id, 'mp4',\n                m3u8_id=vid.get('name'),\n                fatal=False, live=True))\n        self._sort_formats(formats)\n\n        info = self._get_common_fields(webpage)\n        info.update({\n            'title': self._live_title(info['title']),\n            'id': video_id,\n            'formats': formats,\n            'is_live': True,\n        })\n        return info\n\n    def _replay(self, video_id, webpage, long_video_id, key):\n        playinfo = self._download_json(\n            'http://global.apis.naver.com/rmcnmv/rmcnmv/vod_play_videoInfo.json?%s'\n            % compat_urllib_parse_urlencode({\n                'videoId': long_video_id,\n                'key': key,\n                'ptc': 'http',\n                'doct': 'json',  \n                'cpt': 'vtt',  \n            }), video_id)\n\n        formats = [{\n            'url': vid['source'],\n            'format_id': vid.get('encodingOption', {}).get('name'),\n            'abr': float_or_none(vid.get('bitrate', {}).get('audio')),\n            'vbr': float_or_none(vid.get('bitrate', {}).get('video')),\n            'width': int_or_none(vid.get('encodingOption', {}).get('width')),\n            'height': int_or_none(vid.get('encodingOption', {}).get('height')),\n            'filesize': int_or_none(vid.get('size')),\n        } for vid in playinfo.get('videos', {}).get('list', []) if vid.get('source')]\n        self._sort_formats(formats)\n\n        view_count = int_or_none(playinfo.get('meta', {}).get('count'))\n\n        subtitles = {}\n        for caption in playinfo.get('captions', {}).get('list', []):\n            lang = dict_get(caption, ('locale', 'language', 'country', 'label'))\n            if lang and caption.get('source'):\n                subtitles[lang] = [{\n                    'ext': 'vtt',\n                    'url': caption['source']}]\n\n        info = self._get_common_fields(webpage)\n        info.update({\n            'id': video_id,\n            'formats': formats,\n            'view_count': view_count,\n            'subtitles': subtitles,\n        })\n        return info\n\n\nclass VLiveChannelIE(InfoExtractor):\n    IE_NAME = 'vlive:channel'\n    _VALID_URL = r'https?://channels\\.vlive\\.tv/(?P<id>[0-9A-Z]+)'\n    _TEST = {\n        'url': 'http://channels.vlive.tv/FCD4B',\n        'info_dict': {\n            'id': 'FCD4B',\n            'title': 'MAMAMOO',\n        },\n        'playlist_mincount': 110\n    }\n    _APP_ID = '8c6cc7b45d2568fb668be6e05b6e5a3b'\n\n    def _real_extract(self, url):\n        channel_code = self._match_id(url)\n\n        webpage = self._download_webpage(\n            'http://channels.vlive.tv/%s/video' % channel_code, channel_code)\n\n        app_id = None\n\n        app_js_url = self._search_regex(\n            r'<script[^>]+src=([\"\\'])(?P<url>http.+?/app\\.js.*?)\\1',\n            webpage, 'app js', default=None, group='url')\n\n        if app_js_url:\n            app_js = self._download_webpage(\n                app_js_url, channel_code, 'Downloading app JS', fatal=False)\n            if app_js:\n                app_id = self._search_regex(\n                    r'Global\\.VFAN_APP_ID\\s*=\\s*[\\'\"]([^\\'\"]+)[\\'\"]',\n                    app_js, 'app id', default=None)\n\n        app_id = app_id or self._APP_ID\n\n        channel_info = self._download_json(\n            'http://api.vfan.vlive.tv/vproxy/channelplus/decodeChannelCode',\n            channel_code, note='Downloading decode channel code',\n            query={\n                'app_id': app_id,\n                'channelCode': channel_code,\n                '_': int(time.time())\n            })\n\n        channel_seq = channel_info['result']['channelSeq']\n        channel_name = None\n        entries = []\n\n        for page_num in itertools.count(1):\n            video_list = self._download_json(\n                'http://api.vfan.vlive.tv/vproxy/channelplus/getChannelVideoList',\n                channel_code, note='Downloading channel list page \n                query={\n                    'app_id': app_id,\n                    'channelSeq': channel_seq,\n                    \n                    \n                    \n                    \n                    \n                    'maxNumOfRows': 100,\n                    '_': int(time.time()),\n                    'pageNo': page_num\n                }\n            )\n\n            if not channel_name:\n                channel_name = try_get(\n                    video_list,\n                    lambda x: x['result']['channelInfo']['channelName'],\n                    compat_str)\n\n            videos = try_get(\n                video_list, lambda x: x['result']['videoList'], list)\n            if not videos:\n                break\n\n            for video in videos:\n                video_id = video.get('videoSeq')\n                if not video_id:\n                    continue\n                video_id = compat_str(video_id)\n                entries.append(\n                    self.url_result(\n                        'http://www.vlive.tv/video/%s' % video_id,\n                        ie=VLiveIE.ie_key(), video_id=video_id))\n\n        return self.playlist_result(\n            entries, channel_code, channel_name)\n\n\nclass VLivePlaylistIE(InfoExtractor):\n    IE_NAME = 'vlive:playlist'\n    _VALID_URL = r'https?://(?:(?:www|m)\\.)?vlive\\.tv/video/(?P<video_id>[0-9]+)/playlist/(?P<id>[0-9]+)'\n    _TEST = {\n        'url': 'http://www.vlive.tv/video/22867/playlist/22912',\n        'info_dict': {\n            'id': '22912',\n            'title': 'Valentine Day Message from TWICE'\n        },\n        'playlist_mincount': 9\n    }\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        video_id, playlist_id = mobj.group('video_id', 'id')\n\n        VIDEO_URL_TEMPLATE = 'http://www.vlive.tv/video/%s'\n        if self._downloader.params.get('noplaylist'):\n            self.to_screen(\n                'Downloading just video %s because of --no-playlist' % video_id)\n            return self.url_result(\n                VIDEO_URL_TEMPLATE % video_id,\n                ie=VLiveIE.ie_key(), video_id=video_id)\n\n        self.to_screen(\n            'Downloading playlist %s - add --no-playlist to just download video'\n            % playlist_id)\n\n        webpage = self._download_webpage(\n            'http://www.vlive.tv/video/%s/playlist/%s'\n            % (video_id, playlist_id), playlist_id)\n\n        item_ids = self._parse_json(\n            self._search_regex(\n                r'playlistVideoSeqs\\s*=\\s*(\\[[^]]+\\])', webpage,\n                'playlist video seqs'),\n            playlist_id)\n\n        entries = [\n            self.url_result(\n                VIDEO_URL_TEMPLATE % item_id, ie=VLiveIE.ie_key(),\n                video_id=compat_str(item_id))\n            for item_id in item_ids]\n\n        playlist_name = self._html_search_regex(\n            r'<div[^>]+class=\"[^\"]*multicam_playlist[^>]*>\\s*<h3[^>]+>([^<]+)',\n            webpage, 'playlist title', fatal=False)\n\n        return self.playlist_result(entries, playlist_id, playlist_name)\n", "comments": "# coding: utf-8\n# document type (xml or json)\n# captions type (vtt or ttml)\n#%d' % page_num,\n# Large values of maxNumOfRows (~300 or above) may cause\n# empty responses (see [1]), e.g. this happens for [2] that\n# has more than 300 videos.\n# 1. https://github.com/rg3/youtube-dl/issues/13830\n# 2. http://channels.vlive.tv/EDBF.\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\nimport time\nimport itertools\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_urllib_parse_urlencode,\n    compat_str,\n)\nfrom ..utils import (\n    dict_get,\n    ExtractorError,\n    float_or_none,\n    int_or_none,\n    remove_start,\n    try_get,\n    urlencode_postdata,\n)\n\n\nclass VLiveIE(InfoExtractor):\n    IE_NAME = 'vlive'\n    _VALID_URL = r'https?://(?:(?:www|m)\\.)?vlive\\.tv/video/(?P<id>[0-9]+)'\n    _TESTS = [{\n        'url': 'http://www.vlive.tv/video/1326',\n        'md5': 'cc7314812855ce56de70a06a27314983',\n        'info_dict': {\n            'id': '1326',\n            'ext': 'mp4',\n            'title': \"[V LIVE] Girl's Day's Broadcast\",\n            'creator': \"Girl's Day\",\n            'view_count': int,\n        },\n    }, {\n        'url': 'http://www.vlive.tv/video/16937',\n        'info_dict': {\n            'id': '16937',\n            'ext': 'mp4',\n            'title': '[V LIVE] \uccb8\ubc31\uc2dc \uac4d\ubc29',\n            'creator': 'EXO',\n            'view_count': int,\n            'subtitles': 'mincount:12',\n        },\n        'params': {\n            'skip_download': True,\n        },\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if VLivePlaylistIE.suitable(url) else super(VLiveIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(\n            'http://www.vlive.tv/video/%s' % video_id, video_id)\n\n        VIDEO_PARAMS_RE = r'\\bvlive\\.video\\.init\\(([^)]+)'\n        VIDEO_PARAMS_FIELD = 'video params'\n\n        params = self._parse_json(self._search_regex(\n            VIDEO_PARAMS_RE, webpage, VIDEO_PARAMS_FIELD, default=''), video_id,\n            transform_source=lambda s: '[' + s + ']', fatal=False)\n\n        if not params or len(params) < 7:\n            params = self._search_regex(\n                VIDEO_PARAMS_RE, webpage, VIDEO_PARAMS_FIELD)\n            params = [p.strip(r'\"') for p in re.split(r'\\s*,\\s*', params)]\n\n        status, long_video_id, key = params[2], params[5], params[6]\n        status = remove_start(status, 'PRODUCT_')\n\n        if status in ('LIVE_ON_AIR', 'BIG_EVENT_ON_AIR'):\n            return self._live(video_id, webpage)\n        elif status in ('VOD_ON_AIR', 'BIG_EVENT_INTRO'):\n            if long_video_id and key:\n                return self._replay(video_id, webpage, long_video_id, key)\n            else:\n                status = 'COMING_SOON'\n\n        if status == 'LIVE_END':\n            raise ExtractorError('Uploading for replay. Please wait...',\n                                 expected=True)\n        elif status == 'COMING_SOON':\n            raise ExtractorError('Coming soon!', expected=True)\n        elif status == 'CANCELED':\n            raise ExtractorError('We are sorry, '\n                                 'but the live broadcast has been canceled.',\n                                 expected=True)\n        else:\n            raise ExtractorError('Unknown status %s' % status)\n\n    def _get_common_fields(self, webpage):\n        title = self._og_search_title(webpage)\n        creator = self._html_search_regex(\n            r'<div[^>]+class=\"info_area\"[^>]*>\\s*<a\\s+[^>]*>([^<]+)',\n            webpage, 'creator', fatal=False)\n        thumbnail = self._og_search_thumbnail(webpage)\n        return {\n            'title': title,\n            'creator': creator,\n            'thumbnail': thumbnail,\n        }\n\n    def _live(self, video_id, webpage):\n        init_page = self._download_webpage(\n            'http://www.vlive.tv/video/init/view',\n            video_id, note='Downloading live webpage',\n            data=urlencode_postdata({'videoSeq': video_id}),\n            headers={\n                'Referer': 'http://www.vlive.tv/video/%s' % video_id,\n                'Content-Type': 'application/x-www-form-urlencoded'\n            })\n\n        live_params = self._search_regex(\n            r'\"liveStreamInfo\"\\s*:\\s*(\".*\"),',\n            init_page, 'live stream info')\n        live_params = self._parse_json(live_params, video_id)\n        live_params = self._parse_json(live_params, video_id)\n\n        formats = []\n        for vid in live_params.get('resolutions', []):\n            formats.extend(self._extract_m3u8_formats(\n                vid['cdnUrl'], video_id, 'mp4',\n                m3u8_id=vid.get('name'),\n                fatal=False, live=True))\n        self._sort_formats(formats)\n\n        info = self._get_common_fields(webpage)\n        info.update({\n            'title': self._live_title(info['title']),\n            'id': video_id,\n            'formats': formats,\n            'is_live': True,\n        })\n        return info\n\n    def _replay(self, video_id, webpage, long_video_id, key):\n        playinfo = self._download_json(\n            'http://global.apis.naver.com/rmcnmv/rmcnmv/vod_play_videoInfo.json?%s'\n            % compat_urllib_parse_urlencode({\n                'videoId': long_video_id,\n                'key': key,\n                'ptc': 'http',\n                'doct': 'json',  # document type (xml or json)\n                'cpt': 'vtt',  # captions type (vtt or ttml)\n            }), video_id)\n\n        formats = [{\n            'url': vid['source'],\n            'format_id': vid.get('encodingOption', {}).get('name'),\n            'abr': float_or_none(vid.get('bitrate', {}).get('audio')),\n            'vbr': float_or_none(vid.get('bitrate', {}).get('video')),\n            'width': int_or_none(vid.get('encodingOption', {}).get('width')),\n            'height': int_or_none(vid.get('encodingOption', {}).get('height')),\n            'filesize': int_or_none(vid.get('size')),\n        } for vid in playinfo.get('videos', {}).get('list', []) if vid.get('source')]\n        self._sort_formats(formats)\n\n        view_count = int_or_none(playinfo.get('meta', {}).get('count'))\n\n        subtitles = {}\n        for caption in playinfo.get('captions', {}).get('list', []):\n            lang = dict_get(caption, ('locale', 'language', 'country', 'label'))\n            if lang and caption.get('source'):\n                subtitles[lang] = [{\n                    'ext': 'vtt',\n                    'url': caption['source']}]\n\n        info = self._get_common_fields(webpage)\n        info.update({\n            'id': video_id,\n            'formats': formats,\n            'view_count': view_count,\n            'subtitles': subtitles,\n        })\n        return info\n\n\nclass VLiveChannelIE(InfoExtractor):\n    IE_NAME = 'vlive:channel'\n    _VALID_URL = r'https?://channels\\.vlive\\.tv/(?P<id>[0-9A-Z]+)'\n    _TEST = {\n        'url': 'http://channels.vlive.tv/FCD4B',\n        'info_dict': {\n            'id': 'FCD4B',\n            'title': 'MAMAMOO',\n        },\n        'playlist_mincount': 110\n    }\n    _APP_ID = '8c6cc7b45d2568fb668be6e05b6e5a3b'\n\n    def _real_extract(self, url):\n        channel_code = self._match_id(url)\n\n        webpage = self._download_webpage(\n            'http://channels.vlive.tv/%s/video' % channel_code, channel_code)\n\n        app_id = None\n\n        app_js_url = self._search_regex(\n            r'<script[^>]+src=([\"\\'])(?P<url>http.+?/app\\.js.*?)\\1',\n            webpage, 'app js', default=None, group='url')\n\n        if app_js_url:\n            app_js = self._download_webpage(\n                app_js_url, channel_code, 'Downloading app JS', fatal=False)\n            if app_js:\n                app_id = self._search_regex(\n                    r'Global\\.VFAN_APP_ID\\s*=\\s*[\\'\"]([^\\'\"]+)[\\'\"]',\n                    app_js, 'app id', default=None)\n\n        app_id = app_id or self._APP_ID\n\n        channel_info = self._download_json(\n            'http://api.vfan.vlive.tv/vproxy/channelplus/decodeChannelCode',\n            channel_code, note='Downloading decode channel code',\n            query={\n                'app_id': app_id,\n                'channelCode': channel_code,\n                '_': int(time.time())\n            })\n\n        channel_seq = channel_info['result']['channelSeq']\n        channel_name = None\n        entries = []\n\n        for page_num in itertools.count(1):\n            video_list = self._download_json(\n                'http://api.vfan.vlive.tv/vproxy/channelplus/getChannelVideoList',\n                channel_code, note='Downloading channel list page #%d' % page_num,\n                query={\n                    'app_id': app_id,\n                    'channelSeq': channel_seq,\n                    # Large values of maxNumOfRows (~300 or above) may cause\n                    # empty responses (see [1]), e.g. this happens for [2] that\n                    # has more than 300 videos.\n                    # 1. https://github.com/rg3/youtube-dl/issues/13830\n                    # 2. http://channels.vlive.tv/EDBF.\n                    'maxNumOfRows': 100,\n                    '_': int(time.time()),\n                    'pageNo': page_num\n                }\n            )\n\n            if not channel_name:\n                channel_name = try_get(\n                    video_list,\n                    lambda x: x['result']['channelInfo']['channelName'],\n                    compat_str)\n\n            videos = try_get(\n                video_list, lambda x: x['result']['videoList'], list)\n            if not videos:\n                break\n\n            for video in videos:\n                video_id = video.get('videoSeq')\n                if not video_id:\n                    continue\n                video_id = compat_str(video_id)\n                entries.append(\n                    self.url_result(\n                        'http://www.vlive.tv/video/%s' % video_id,\n                        ie=VLiveIE.ie_key(), video_id=video_id))\n\n        return self.playlist_result(\n            entries, channel_code, channel_name)\n\n\nclass VLivePlaylistIE(InfoExtractor):\n    IE_NAME = 'vlive:playlist'\n    _VALID_URL = r'https?://(?:(?:www|m)\\.)?vlive\\.tv/video/(?P<video_id>[0-9]+)/playlist/(?P<id>[0-9]+)'\n    _TEST = {\n        'url': 'http://www.vlive.tv/video/22867/playlist/22912',\n        'info_dict': {\n            'id': '22912',\n            'title': 'Valentine Day Message from TWICE'\n        },\n        'playlist_mincount': 9\n    }\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        video_id, playlist_id = mobj.group('video_id', 'id')\n\n        VIDEO_URL_TEMPLATE = 'http://www.vlive.tv/video/%s'\n        if self._downloader.params.get('noplaylist'):\n            self.to_screen(\n                'Downloading just video %s because of --no-playlist' % video_id)\n            return self.url_result(\n                VIDEO_URL_TEMPLATE % video_id,\n                ie=VLiveIE.ie_key(), video_id=video_id)\n\n        self.to_screen(\n            'Downloading playlist %s - add --no-playlist to just download video'\n            % playlist_id)\n\n        webpage = self._download_webpage(\n            'http://www.vlive.tv/video/%s/playlist/%s'\n            % (video_id, playlist_id), playlist_id)\n\n        item_ids = self._parse_json(\n            self._search_regex(\n                r'playlistVideoSeqs\\s*=\\s*(\\[[^]]+\\])', webpage,\n                'playlist video seqs'),\n            playlist_id)\n\n        entries = [\n            self.url_result(\n                VIDEO_URL_TEMPLATE % item_id, ie=VLiveIE.ie_key(),\n                video_id=compat_str(item_id))\n            for item_id in item_ids]\n\n        playlist_name = self._html_search_regex(\n            r'<div[^>]+class=\"[^\"]*multicam_playlist[^>]*>\\s*<h3[^>]+>([^<]+)',\n            webpage, 'playlist title', fatal=False)\n\n        return self.playlist_result(entries, playlist_id, playlist_name)\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "vlive.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/vlive.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}