{"author": "localstack", "code": "import re\nimport os\nimport socket\nimport subprocess\nimport tempfile\nimport logging\nfrom os.path import expanduser\nfrom six import iteritems\nfrom localstack.constants import DEFAULT_SERVICE_PORTS, LOCALHOST, PATH_USER_REQUEST, DEFAULT_PORT_WEB_UI\n\n\nKINESIS_ERROR_PROBABILITY = float(os.environ.get('KINESIS_ERROR_PROBABILITY', '').strip() or 0.0)\n\n\nDYNAMODB_ERROR_PROBABILITY = float(os.environ.get('DYNAMODB_ERROR_PROBABILITY', '').strip() or 0.0)\n\n\nHOSTNAME = os.environ.get('HOSTNAME', '').strip() or LOCALHOST\n\n\nHOSTNAME_EXTERNAL = os.environ.get('HOSTNAME_EXTERNAL', '').strip() or LOCALHOST\n\n\nLOCALSTACK_HOSTNAME = os.environ.get('LOCALSTACK_HOSTNAME', '').strip() or HOSTNAME\n\n\nLAMBDA_REMOTE_DOCKER = os.environ.get('LAMBDA_REMOTE_DOCKER', '').lower().strip() in ['true', '1']\n\n\nTMP_FOLDER = os.path.join(tempfile.gettempdir(), 'localstack')\n\nif TMP_FOLDER.startswith('/var/folders/') and os.path.exists('/private%s' % TMP_FOLDER):\n    TMP_FOLDER = '/private%s' % TMP_FOLDER\n\n# temporary folder of the host (required when running in Docker). Fall back to local tmp folder if not set\nHOST_TMP_FOLDER = os.environ.get('HOST_TMP_FOLDER', TMP_FOLDER)\n\n\nDATA_DIR = os.environ.get('DATA_DIR', '').strip()\n\n\nUSE_SSL = os.environ.get('USE_SSL', '').strip() not in ('0', 'false', '')\n\n# default encoding used to convert strings to byte arrays (mainly for Python 3 compatibility)\nDEFAULT_ENCODING = 'utf-8'\n\n\nDOCKER_SOCK = os.environ.get('DOCKER_SOCK', '').strip() or '/var/run/docker.sock'\n\n\nPORT_WEB_UI = int(os.environ.get('PORT_WEB_UI', '').strip() or DEFAULT_PORT_WEB_UI)\n\n\nLAMBDA_EXECUTOR = os.environ.get('LAMBDA_EXECUTOR', '').strip()\nif not LAMBDA_EXECUTOR:\n    LAMBDA_EXECUTOR = 'local'\n    try:\n        if 'Linux' in subprocess.check_output('uname -a'):\n            LAMBDA_EXECUTOR = 'docker'\n    except Exception as e:\n        pass\n\n\n\n# Note: do *not* include DATA_DIR in this list, as it is treated separately\nCONFIG_ENV_VARS = ['SERVICES', 'HOSTNAME', 'HOSTNAME_EXTERNAL', 'LOCALSTACK_HOSTNAME',\n    'LAMBDA_EXECUTOR', 'LAMBDA_REMOTE_DOCKER', 'USE_SSL', 'LICENSE_KEY', 'DEBUG',\n    'KINESIS_ERROR_PROBABILITY', 'DYNAMODB_ERROR_PROBABILITY', 'PORT_WEB_UI']\nfor key, value in iteritems(DEFAULT_SERVICE_PORTS):\n    backend_override_var = '%s_BACKEND' % key.upper().replace('-', '_')\n    if os.environ.get(backend_override_var):\n        CONFIG_ENV_VARS.append(backend_override_var)\n\ndef in_docker():\n    \"\"\" Returns: True if running in a docker container, else False \"\"\"\n    if not os.path.exists('/proc/1/cgroup'):\n        return False\n    with open('/proc/1/cgroup', 'rt') as ifh:\n        return 'docker' in ifh.read()\n\n\nDOCKER_BRIDGE_IP = '172.17.0.1'\ntry:\n    DOCKER_HOST_FROM_CONTAINER = socket.gethostbyname('docker.for.mac.localhost')\n    \n    if in_docker() and LOCALSTACK_HOSTNAME == DOCKER_BRIDGE_IP:\n        LOCALSTACK_HOSTNAME = DOCKER_HOST_FROM_CONTAINER\nexcept socket.error:\n    DOCKER_HOST_FROM_CONTAINER = DOCKER_BRIDGE_IP\n\n\nif in_docker() and not os.environ.get('LAMBDA_REMOTE_DOCKER', '').strip():\n    LAMBDA_REMOTE_DOCKER = True\n\n\nCONFIG_FILE_PATH = os.path.join(expanduser(\"~\"), '.localstack')\n\n\nfor folder in [DATA_DIR, TMP_FOLDER]:\n    if folder and not os.path.exists(folder):\n        try:\n            os.makedirs(folder)\n        except Exception as e:\n            \n            \n            pass\n\n\nno_proxy = ','.join(set((LOCALSTACK_HOSTNAME, HOSTNAME, LOCALHOST, '127.0.0.1', '[::1]')))\nif os.environ.get('no_proxy'):\n    os.environ['no_proxy'] += ',' + no_proxy\nelif os.environ.get('NO_PROXY'):\n    os.environ['NO_PROXY'] += ',' + no_proxy\nelse:\n    os.environ['no_proxy'] = no_proxy\n\n\nCLI_COMMANDS = {}\n\n\ndef parse_service_ports():\n    \"\"\" Parses the environment variable $SERVICE_PORTS with a comma-separated list of services\n        and (optional) ports they should run on: 'service1:port1,service2,service3:port3' \"\"\"\n    service_ports = os.environ.get('SERVICES', '').strip()\n    if not service_ports:\n        return DEFAULT_SERVICE_PORTS\n    result = {}\n    for service_port in re.split(r'\\s*,\\s*', service_ports):\n        parts = re.split(r'[:=]', service_port)\n        service = parts[0]\n        result[service] = int(parts[-1]) if len(parts) > 1 else DEFAULT_SERVICE_PORTS.get(service)\n    # Fix Elasticsearch port - we have 'es' (AWS ES API) and 'elasticsearch' (actual Elasticsearch API)\n    if result.get('es') and not result.get('elasticsearch'):\n        result['elasticsearch'] = DEFAULT_SERVICE_PORTS.get('elasticsearch')\n    return result\n\n\ndef populate_configs():\n    global SERVICE_PORTS\n\n    SERVICE_PORTS = parse_service_ports()\n\n    \n    for key, value in iteritems(DEFAULT_SERVICE_PORTS):\n        key_upper = key.upper().replace('-', '_')\n\n        # define PORT_* variables with actual service ports as per configuration\n        exec('global PORT_%s; PORT_%s = SERVICE_PORTS.get(\"%s\", 0)' % (key_upper, key_upper, key))\n        url = 'http%s://%s:%s' % ('s' if USE_SSL else '', LOCALSTACK_HOSTNAME, SERVICE_PORTS.get(key, 0))\n        # define TEST_*_URL variables with mock service endpoints\n        exec('global TEST_%s_URL; TEST_%s_URL = \"%s\"' % (key_upper, key_upper, url))\n        # expose HOST_*_URL variables as environment variables\n        os.environ['TEST_%s_URL' % key_upper] = url\n\n    \n    os.environ['LOCALSTACK_HOSTNAME'] = LOCALSTACK_HOSTNAME\n\n\ndef service_port(service_key):\n    return SERVICE_PORTS.get(service_key, 0)\n\n\n\npopulate_configs()\n\n\nif os.environ.get('DEBUG', '').lower() in ('1', 'true'):\n    logging.getLogger('').setLevel(logging.DEBUG)\n    logging.getLogger('localstack').setLevel(logging.DEBUG)\n\n\nINBOUND_GATEWAY_URL_PATTERN = ('%s/restapis/{api_id}/{stage_name}/%s{path}' %\n    (TEST_APIGATEWAY_URL, PATH_USER_REQUEST))  \n", "comments": "    returns  true running docker container  else false         os path exists(  proc 1 cgroup )          return false     open(  proc 1 cgroup    rt ) ifh          return  docker  ifh read()    determine route docker host container docker bridge ip    172 17 0 1  try      docker host from container   socket gethostbyname( docker mac localhost )       update localstack hostname docker mac localhost available     docker() localstack hostname    docker bridge ip          localstack hostname   docker host from container except socket error      docker host from container   docker bridge ip    make sure default lambda remote docker true running docker docker() os environ get( lambda remote docker     ) strip()      lambda remote docker   true    local config file path home directory config file path   os path join(expanduser(   )    localstack )    create folders folder  data dir  tmp folder       folder os path exists(folder)          try              os makedirs(folder)         except exception e                happen due race condition starting               multiple processes parallel  should safe ignore             pass    set variables proxy  e   run internal service calls directly proxy       join(set((localstack hostname  hostname  localhost   127 0 0 1       1  ))) os environ get( proxy )      os environ  proxy            proxy elif os environ get( no proxy )      os environ  no proxy            proxy else      os environ  proxy     proxy    additional cli commands  set plugins cli commands        def parse service ports()          parses environment variable  service ports comma separated list services         (optional) ports run   service1 port1 service2 service3 port3         randomly inject faults kinesis    randomly inject faults dynamodb    expose services specific host internally    expose services specific host externally    name host localstack services available    whether remotely copy lambda locally mount volume    folder temporary files data    fix mac os  able mount  var folders docker    temporary folder host (required running docker)  fall back local tmp folder set    directory persisting data    whether use ssl encryption services    default encoding used convert strings byte arrays (mainly python 3 compatibility)    path local docker unix domain socket    port web ui    whether use lambda functions docker container    list environment variable names used configuration     make sure keep sync     note    include data dir list  treated separately    determine route docker host container    update localstack hostname docker mac localhost available    make sure default lambda remote docker true running docker    local config file path home directory    create folders    happen due race condition starting    multiple processes parallel  should safe ignore    set variables proxy  e   run internal service calls directly    additional cli commands  set plugins    fix elasticsearch port    es  (aws es api)  elasticsearch  (actual elasticsearch api)    define service ports urls environment variables    define port   variables actual service ports per configuration    define test   url variables mock service endpoints    expose host   url variables environment variables    expose localstack hostname env  variable    initialize config values    set log level    set url pattern inbound api gateway    flake8  noqa ", "content": "import re\nimport os\nimport socket\nimport subprocess\nimport tempfile\nimport logging\nfrom os.path import expanduser\nfrom six import iteritems\nfrom localstack.constants import DEFAULT_SERVICE_PORTS, LOCALHOST, PATH_USER_REQUEST, DEFAULT_PORT_WEB_UI\n\n# randomly inject faults to Kinesis\nKINESIS_ERROR_PROBABILITY = float(os.environ.get('KINESIS_ERROR_PROBABILITY', '').strip() or 0.0)\n\n# randomly inject faults to DynamoDB\nDYNAMODB_ERROR_PROBABILITY = float(os.environ.get('DYNAMODB_ERROR_PROBABILITY', '').strip() or 0.0)\n\n# expose services on a specific host internally\nHOSTNAME = os.environ.get('HOSTNAME', '').strip() or LOCALHOST\n\n# expose services on a specific host externally\nHOSTNAME_EXTERNAL = os.environ.get('HOSTNAME_EXTERNAL', '').strip() or LOCALHOST\n\n# name of the host under which the LocalStack services are available\nLOCALSTACK_HOSTNAME = os.environ.get('LOCALSTACK_HOSTNAME', '').strip() or HOSTNAME\n\n# whether to remotely copy the lambda or locally mount a volume\nLAMBDA_REMOTE_DOCKER = os.environ.get('LAMBDA_REMOTE_DOCKER', '').lower().strip() in ['true', '1']\n\n# folder for temporary files and data\nTMP_FOLDER = os.path.join(tempfile.gettempdir(), 'localstack')\n# fix for Mac OS, to be able to mount /var/folders in Docker\nif TMP_FOLDER.startswith('/var/folders/') and os.path.exists('/private%s' % TMP_FOLDER):\n    TMP_FOLDER = '/private%s' % TMP_FOLDER\n\n# temporary folder of the host (required when running in Docker). Fall back to local tmp folder if not set\nHOST_TMP_FOLDER = os.environ.get('HOST_TMP_FOLDER', TMP_FOLDER)\n\n# directory for persisting data\nDATA_DIR = os.environ.get('DATA_DIR', '').strip()\n\n# whether to use SSL encryption for the services\nUSE_SSL = os.environ.get('USE_SSL', '').strip() not in ('0', 'false', '')\n\n# default encoding used to convert strings to byte arrays (mainly for Python 3 compatibility)\nDEFAULT_ENCODING = 'utf-8'\n\n# path to local Docker UNIX domain socket\nDOCKER_SOCK = os.environ.get('DOCKER_SOCK', '').strip() or '/var/run/docker.sock'\n\n# port of Web UI\nPORT_WEB_UI = int(os.environ.get('PORT_WEB_UI', '').strip() or DEFAULT_PORT_WEB_UI)\n\n# whether to use Lambda functions in a Docker container\nLAMBDA_EXECUTOR = os.environ.get('LAMBDA_EXECUTOR', '').strip()\nif not LAMBDA_EXECUTOR:\n    LAMBDA_EXECUTOR = 'local'\n    try:\n        if 'Linux' in subprocess.check_output('uname -a'):\n            LAMBDA_EXECUTOR = 'docker'\n    except Exception as e:\n        pass\n\n# list of environment variable names used for configuration.\n# Make sure to keep this in sync with the above!\n# Note: do *not* include DATA_DIR in this list, as it is treated separately\nCONFIG_ENV_VARS = ['SERVICES', 'HOSTNAME', 'HOSTNAME_EXTERNAL', 'LOCALSTACK_HOSTNAME',\n    'LAMBDA_EXECUTOR', 'LAMBDA_REMOTE_DOCKER', 'USE_SSL', 'LICENSE_KEY', 'DEBUG',\n    'KINESIS_ERROR_PROBABILITY', 'DYNAMODB_ERROR_PROBABILITY', 'PORT_WEB_UI']\nfor key, value in iteritems(DEFAULT_SERVICE_PORTS):\n    backend_override_var = '%s_BACKEND' % key.upper().replace('-', '_')\n    if os.environ.get(backend_override_var):\n        CONFIG_ENV_VARS.append(backend_override_var)\n\ndef in_docker():\n    \"\"\" Returns: True if running in a docker container, else False \"\"\"\n    if not os.path.exists('/proc/1/cgroup'):\n        return False\n    with open('/proc/1/cgroup', 'rt') as ifh:\n        return 'docker' in ifh.read()\n\n# determine route to Docker host from container\nDOCKER_BRIDGE_IP = '172.17.0.1'\ntry:\n    DOCKER_HOST_FROM_CONTAINER = socket.gethostbyname('docker.for.mac.localhost')\n    # update LOCALSTACK_HOSTNAME if docker.for.mac.localhost is available\n    if in_docker() and LOCALSTACK_HOSTNAME == DOCKER_BRIDGE_IP:\n        LOCALSTACK_HOSTNAME = DOCKER_HOST_FROM_CONTAINER\nexcept socket.error:\n    DOCKER_HOST_FROM_CONTAINER = DOCKER_BRIDGE_IP\n\n# make sure we default to LAMBDA_REMOTE_DOCKER=true if running in Docker\nif in_docker() and not os.environ.get('LAMBDA_REMOTE_DOCKER', '').strip():\n    LAMBDA_REMOTE_DOCKER = True\n\n# local config file path in home directory\nCONFIG_FILE_PATH = os.path.join(expanduser(\"~\"), '.localstack')\n\n# create folders\nfor folder in [DATA_DIR, TMP_FOLDER]:\n    if folder and not os.path.exists(folder):\n        try:\n            os.makedirs(folder)\n        except Exception as e:\n            # this can happen due to a race condition when starting\n            # multiple processes in parallel. Should be safe to ignore\n            pass\n\n# set variables no_proxy, i.e., run internal service calls directly\nno_proxy = ','.join(set((LOCALSTACK_HOSTNAME, HOSTNAME, LOCALHOST, '127.0.0.1', '[::1]')))\nif os.environ.get('no_proxy'):\n    os.environ['no_proxy'] += ',' + no_proxy\nelif os.environ.get('NO_PROXY'):\n    os.environ['NO_PROXY'] += ',' + no_proxy\nelse:\n    os.environ['no_proxy'] = no_proxy\n\n# additional CLI commands, can be set by plugins\nCLI_COMMANDS = {}\n\n\ndef parse_service_ports():\n    \"\"\" Parses the environment variable $SERVICE_PORTS with a comma-separated list of services\n        and (optional) ports they should run on: 'service1:port1,service2,service3:port3' \"\"\"\n    service_ports = os.environ.get('SERVICES', '').strip()\n    if not service_ports:\n        return DEFAULT_SERVICE_PORTS\n    result = {}\n    for service_port in re.split(r'\\s*,\\s*', service_ports):\n        parts = re.split(r'[:=]', service_port)\n        service = parts[0]\n        result[service] = int(parts[-1]) if len(parts) > 1 else DEFAULT_SERVICE_PORTS.get(service)\n    # Fix Elasticsearch port - we have 'es' (AWS ES API) and 'elasticsearch' (actual Elasticsearch API)\n    if result.get('es') and not result.get('elasticsearch'):\n        result['elasticsearch'] = DEFAULT_SERVICE_PORTS.get('elasticsearch')\n    return result\n\n\ndef populate_configs():\n    global SERVICE_PORTS\n\n    SERVICE_PORTS = parse_service_ports()\n\n    # define service ports and URLs as environment variables\n    for key, value in iteritems(DEFAULT_SERVICE_PORTS):\n        key_upper = key.upper().replace('-', '_')\n\n        # define PORT_* variables with actual service ports as per configuration\n        exec('global PORT_%s; PORT_%s = SERVICE_PORTS.get(\"%s\", 0)' % (key_upper, key_upper, key))\n        url = 'http%s://%s:%s' % ('s' if USE_SSL else '', LOCALSTACK_HOSTNAME, SERVICE_PORTS.get(key, 0))\n        # define TEST_*_URL variables with mock service endpoints\n        exec('global TEST_%s_URL; TEST_%s_URL = \"%s\"' % (key_upper, key_upper, url))\n        # expose HOST_*_URL variables as environment variables\n        os.environ['TEST_%s_URL' % key_upper] = url\n\n    # expose LOCALSTACK_HOSTNAME as env. variable\n    os.environ['LOCALSTACK_HOSTNAME'] = LOCALSTACK_HOSTNAME\n\n\ndef service_port(service_key):\n    return SERVICE_PORTS.get(service_key, 0)\n\n\n# initialize config values\npopulate_configs()\n\n# set log level\nif os.environ.get('DEBUG', '').lower() in ('1', 'true'):\n    logging.getLogger('').setLevel(logging.DEBUG)\n    logging.getLogger('localstack').setLevel(logging.DEBUG)\n\n# set URL pattern of inbound API gateway\nINBOUND_GATEWAY_URL_PATTERN = ('%s/restapis/{api_id}/{stage_name}/%s{path}' %\n    (TEST_APIGATEWAY_URL, PATH_USER_REQUEST))  # flake8: noqa\n", "description": "\ud83d\udcbb  A fully functional local AWS cloud stack. Develop and test your cloud apps offline!", "file_name": "config.py", "id": "e0a81c60bbb0f1369bb7929edd78b9bf", "language": "Python", "project_name": "localstack", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/localstack-localstack/localstack-localstack-865ec3a/localstack/config.py", "save_time": "", "source": "", "update_at": "2018-03-14T00:04:55Z", "url": "https://github.com/localstack/localstack", "wiki": true}