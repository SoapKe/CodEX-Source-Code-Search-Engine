{"author": "jakubroztocil", "code": "\n    headers = []\n    data = []\n    files = []\n    params = []\n    for item in items:\n        value = item.value\n        if item.sep == SEP_HEADERS:\n            if value == '':\n                \n                value = None\n            target = headers\n        elif item.sep == SEP_HEADERS_EMPTY:\n            if item.value:\n                raise ParseError(\n                    'Invalid item \"%s\" '\n                    '(to specify an empty header use `Header;`)'\n                    % item.orig\n                )\n            target = headers\n        elif item.sep == SEP_QUERY:\n            target = params\n        elif item.sep == SEP_FILES:\n            try:\n                with open(os.path.expanduser(value), 'rb') as f:\n                    value = (os.path.basename(value),\n                             BytesIO(f.read()),\n                             get_content_type(value))\n            except IOError as e:\n                raise ParseError('\"%s\": %s' % (item.orig, e))\n            target = files\n\n        elif item.sep in SEP_GROUP_DATA_ITEMS:\n\n            if item.sep in SEP_GROUP_DATA_EMBED_ITEMS:\n                try:\n                    with open(os.path.expanduser(value), 'rb') as f:\n                        value = f.read().decode('utf8')\n                except IOError as e:\n                    raise ParseError('\"%s\": %s' % (item.orig, e))\n                except UnicodeDecodeError:\n                    raise ParseError(\n                        '\"%s\": cannot embed the content of \"%s\",'\n                        ' not a UTF8 or ASCII-encoded text file'\n                        % (item.orig, item.value)\n                    )\n\n            if item.sep in SEP_GROUP_RAW_JSON_ITEMS:\n                try:\n                    value = load_json_preserve_order(value)\n                except ValueError as e:\n                    raise ParseError('\"%s\": %s' % (item.orig, e))\n            target = data\n\n        else:\n            raise TypeError(item)\n\n        target.append((item.key, value))\n\n    return RequestItems(headers_class(headers),\n                        data_class(data),\n                        files_class(files),\n                        params_class(params))\n\n\ndef readable_file_arg(filename):\n    try:\n        open(filename, 'rb')\n    except IOError as ex:\n        raise ArgumentTypeError('%s: %s' % (filename, ex.args[1]))\n    return filename\n", "comments": "Parsing and processing of CLI input (args, auth credentials, files, stdin).\n\n\"\"\"\nimport os\nimport ssl\nimport sys\nimport re\nimport errno\nimport mimetypes\nimport getpass\nfrom io import BytesIO\nfrom collections import namedtuple, Iterable, OrderedDict\n# noinspection PyCompatibility\nfrom argparse import ArgumentParser, ArgumentTypeError, ArgumentError\n\n# TODO: Use MultiDict for headers once added to `requests`.\n# https://github.com/jakubroztocil/httpie/issues/130\nfrom httpie.plugins import plugin_manager\nfrom requests.structures import CaseInsensitiveDict\n\nfrom httpie.compat import urlsplit, str, is_pypy, is_py27\nfrom httpie.sessions import VALID_SESSION_NAME_PATTERN\nfrom httpie.utils import load_json_preserve_order\n\n\n# ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n# <http://tools.ietf.org/html/rfc3986#section-3.1>\nURL_SCHEME_RE = re.compile(r'^[a-z][a-z0-9.+-]*://', re.IGNORECASE)\n\nHTTP_POST = 'POST'\nHTTP_GET = 'GET'\n\n\n# Various separators used in args\nSEP_HEADERS = ':'\nSEP_HEADERS_EMPTY = ';'\nSEP_CREDENTIALS = ':'\nSEP_PROXY = ':'\nSEP_DATA = '='\nSEP_DATA_RAW_JSON = ':='\nSEP_FILES = '@'\nSEP_DATA_EMBED_FILE = '=@'\nSEP_DATA_EMBED_RAW_JSON_FILE = ':=@'\nSEP_QUERY = '=='\n\n# Separators that become request data\nSEP_GROUP_DATA_ITEMS = frozenset([\n    SEP_DATA,\n    SEP_DATA_RAW_JSON,\n    SEP_FILES,\n    SEP_DATA_EMBED_FILE,\n    SEP_DATA_EMBED_RAW_JSON_FILE\n])\n\n# Separators for items whose value is a filename to be embedded\nSEP_GROUP_DATA_EMBED_ITEMS = frozenset([\n    SEP_DATA_EMBED_FILE,\n    SEP_DATA_EMBED_RAW_JSON_FILE,\n])\n\n# Separators for raw JSON items\nSEP_GROUP_RAW_JSON_ITEMS = frozenset([\n    SEP_DATA_RAW_JSON,\n    SEP_DATA_EMBED_RAW_JSON_FILE,\n])\n\n# Separators allowed in ITEM arguments\nSEP_GROUP_ALL_ITEMS = frozenset([\n    SEP_HEADERS,\n    SEP_HEADERS_EMPTY,\n    SEP_QUERY,\n    SEP_DATA,\n    SEP_DATA_RAW_JSON,\n    SEP_FILES,\n    SEP_DATA_EMBED_FILE,\n    SEP_DATA_EMBED_RAW_JSON_FILE,\n])\n\n\n# Output options\nOUT_REQ_HEAD = 'H'\nOUT_REQ_BODY = 'B'\nOUT_RESP_HEAD = 'h'\nOUT_RESP_BODY = 'b'\n\nOUTPUT_OPTIONS = frozenset([\n    OUT_REQ_HEAD,\n    OUT_REQ_BODY,\n    OUT_RESP_HEAD,\n    OUT_RESP_BODY\n])\n\n# Pretty\nPRETTY_MAP = {\n    'all': ['format', 'colors'],\n    'colors': ['colors'],\n    'format': ['format'],\n    'none': []\n}\nPRETTY_STDOUT_TTY_ONLY = object()\n\n\n# Defaults\nOUTPUT_OPTIONS_DEFAULT = OUT_RESP_HEAD + OUT_RESP_BODY\nOUTPUT_OPTIONS_DEFAULT_STDOUT_REDIRECTED = OUT_RESP_BODY\n\n\nSSL_VERSION_ARG_MAPPING = {\n    'ssl2.3': 'PROTOCOL_SSLv23',\n    'ssl3': 'PROTOCOL_SSLv3',\n    'tls1': 'PROTOCOL_TLSv1',\n    'tls1.1': 'PROTOCOL_TLSv1_1',\n    'tls1.2': 'PROTOCOL_TLSv1_2',\n}\nSSL_VERSION_ARG_MAPPING = {\n    cli_arg: getattr(ssl, ssl_constant)\n    for cli_arg, ssl_constant in SSL_VERSION_ARG_MAPPING.items()\n    if hasattr(ssl, ssl_constant)\n}\n\n\nclass HTTPieArgumentParser(ArgumentParser):\n    \"\"\"Adds additional logic to `argparse.ArgumentParser`.\n\n    Handles all input (CLI args, file args, stdin), applies defaults,\n    and performs extra validation.\n\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        kwargs['add_help'] = False\n        super(HTTPieArgumentParser, self).__init__(*args, **kwargs)\n\n    # noinspection PyMethodOverriding\n    def parse_args(self, env, args=None, namespace=None):\n\n        self.env = env\n        self.args, no_options = super(HTTPieArgumentParser, self)\\\n            .parse_known_args(args, namespace)\n\n        if self.args.debug:\n            self.args.traceback = True\n\n        # Arguments processing and environment setup.\n        self._apply_no_options(no_options)\n        self._validate_download_options()\n        self._setup_standard_streams()\n        self._process_output_options()\n        self._process_pretty_options()\n        self._guess_method()\n        self._parse_items()\n        if not self.args.ignore_stdin and not env.stdin_isatty:\n            self._body_from_file(self.env.stdin)\n        if not URL_SCHEME_RE.match(self.args.url):\n            scheme = self.args.default_scheme + \"://\"\n\n            # See if we're using curl style shorthand for localhost (:3000/foo)\n            shorthand = re.match(r'^:(?!:)(\\d*)(/?.*)$', self.args.url)\n            if shorthand:\n                port = shorthand.group(1)\n                rest = shorthand.group(2)\n                self.args.url = scheme + 'localhost'\n                if port:\n                    self.args.url += ':' + port\n                self.args.url += rest\n            else:\n                self.args.url = scheme + self.args.url\n        self._process_auth()\n\n        return self.args\n\n    # noinspection PyShadowingBuiltins\n    def _print_message(self, message, file=None):\n        # Sneak in our stderr/stdout.\n        file = {\n            sys.stdout: self.env.stdout,\n            sys.stderr: self.env.stderr,\n            None: self.env.stderr\n        }.get(file, file)\n        if not hasattr(file, 'buffer') and isinstance(message, str):\n            message = message.encode(self.env.stdout_encoding)\n        super(HTTPieArgumentParser, self)._print_message(message, file)\n\n    def _setup_standard_streams(self):\n        \"\"\"\n        Modify `env.stdout` and `env.stdout_isatty` based on args, if needed.\n\n        \"\"\"\n        self.args.output_file_specified = bool(self.args.output_file)\n        if self.args.download:\n            # FIXME: Come up with a cleaner solution.\n            if not self.args.output_file and not self.env.stdout_isatty:\n                # Use stdout as the download output file.\n                self.args.output_file = self.env.stdout\n            # With `--download`, we write everything that would normally go to\n            # `stdout` to `stderr` instead. Let's replace the stream so that\n            # we don't have to use many `if`s throughout the codebase.\n            # The response body will be treated separately.\n            self.env.stdout = self.env.stderr\n            self.env.stdout_isatty = self.env.stderr_isatty\n        elif self.args.output_file:\n            # When not `--download`ing, then `--output` simply replaces\n            # `stdout`. The file is opened for appending, which isn't what\n            # we want in this case.\n            self.args.output_file.seek(0)\n            try:\n                self.args.output_file.truncate()\n            except IOError as e:\n                if e.errno == errno.EINVAL:\n                    # E.g. /dev/null on Linux.\n                    pass\n                else:\n                    raise\n            self.env.stdout = self.args.output_file\n            self.env.stdout_isatty = False\n\n    def _process_auth(self):\n        # TODO: refactor\n        self.args.auth_plugin = None\n        default_auth_plugin = plugin_manager.get_auth_plugins()[0]\n        auth_type_set = self.args.auth_type is not None\n        url = urlsplit(self.args.url)\n\n        if self.args.auth is None and not auth_type_set:\n            if url.username is not None:\n                # Handle http://username:password@hostname/\n                username = url.username\n                password = url.password or ''\n                self.args.auth = AuthCredentials(\n                    key=username,\n                    value=password,\n                    sep=SEP_CREDENTIALS,\n                    orig=SEP_CREDENTIALS.join([username, password])\n                )\n\n        if self.args.auth is not None or auth_type_set:\n            if not self.args.auth_type:\n                self.args.auth_type = default_auth_plugin.auth_type\n            plugin = plugin_manager.get_auth_plugin(self.args.auth_type)()\n\n            if plugin.auth_require and self.args.auth is None:\n                self.error('--auth required')\n\n            plugin.raw_auth = self.args.auth\n            self.args.auth_plugin = plugin\n            already_parsed = isinstance(self.args.auth, AuthCredentials)\n\n            if self.args.auth is None or not plugin.auth_parse:\n                self.args.auth = plugin.get_auth()\n            else:\n                if already_parsed:\n                    # from the URL\n                    credentials = self.args.auth\n                else:\n                    credentials = parse_auth(self.args.auth)\n\n                if (not credentials.has_password() and\n                        plugin.prompt_password):\n                    if self.args.ignore_stdin:\n                        # Non-tty stdin read by now\n                        self.error(\n                            'Unable to prompt for passwords because'\n                            ' --ignore-stdin is set.'\n                        )\n                    credentials.prompt_password(url.netloc)\n                self.args.auth = plugin.get_auth(\n                    username=credentials.key,\n                    password=credentials.value,\n                )\n\n    def _apply_no_options(self, no_options):\n        \"\"\"For every `--no-OPTION` in `no_options`, set `args.OPTION` to\n        its default value. This allows for un-setting of options, e.g.,\n        specified in config.\n\n        \"\"\"\n        invalid = []\n\n        for option in no_options:\n            if not option.startswith('--no-'):\n                invalid.append(option)\n                continue\n\n            # --no-option => --option\n            inverted = '--' + option[5:]\n            for action in self._actions:\n                if inverted in action.option_strings:\n                    setattr(self.args, action.dest, action.default)\n                    break\n            else:\n                invalid.append(option)\n\n        if invalid:\n            msg = 'unrecognized arguments: %s'\n            self.error(msg % ' '.join(invalid))\n\n    def _body_from_file(self, fd):\n        \"\"\"There can only be one source of request data.\n\n        Bytes are always read.\n\n        \"\"\"\n        if self.args.data:\n            self.error('Request body (from stdin or a file) and request '\n                       'data (key=value) cannot be mixed. Pass '\n                       '--ignore-stdin to let key/value take priority.')\n        self.args.data = getattr(fd, 'buffer', fd).read()\n\n    def _guess_method(self):\n        \"\"\"Set `args.method` if not specified to either POST or GET\n        based on whether the request has data or not.\n\n        \"\"\"\n        if self.args.method is None:\n            # Invoked as `http URL'.\n            assert not self.args.items\n            if not self.args.ignore_stdin and not self.env.stdin_isatty:\n                self.args.method = HTTP_POST\n            else:\n                self.args.method = HTTP_GET\n\n        # FIXME: False positive, e.g., \"localhost\" matches but is a valid URL.\n        elif not re.match('^[a-zA-Z]+$', self.args.method):\n            # Invoked as `http URL item+'. The URL is now in `args.method`\n            # and the first ITEM is now incorrectly in `args.url`.\n            try:\n                # Parse the URL as an ITEM and store it as the first ITEM arg.\n                self.args.items.insert(0, KeyValueArgType(\n                    *SEP_GROUP_ALL_ITEMS).__call__(self.args.url))\n\n            except ArgumentTypeError as e:\n                if self.args.traceback:\n                    raise\n                self.error(e.args[0])\n\n            else:\n                # Set the URL correctly\n                self.args.url = self.args.method\n                # Infer the method\n                has_data = (\n                    (not self.args.ignore_stdin and\n                     not self.env.stdin_isatty) or\n                    any(item.sep in SEP_GROUP_DATA_ITEMS\n                        for item in self.args.items)\n                )\n                self.args.method = HTTP_POST if has_data else HTTP_GET\n\n    def _parse_items(self):\n        \"\"\"Parse `args.items` into `args.headers`, `args.data`, `args.params`,\n         and `args.files`.\n\n        \"\"\"\n        try:\n            items = parse_items(\n                items=self.args.items,\n                data_class=ParamsDict if self.args.form else OrderedDict\n            )\n        except ParseError as e:\n            if self.args.traceback:\n                raise\n            self.error(e.args[0])\n        else:\n            self.args.headers = items.headers\n            self.args.data = items.data\n            self.args.files = items.files\n            self.args.params = items.params\n\n        if self.args.files and not self.args.form:\n            # `http url @/path/to/file`\n            file_fields = list(self.args.files.keys())\n            if file_fields != ['']:\n                self.error(\n                    'Invalid file fields (perhaps you meant --form?): %s'\n                    % ','.join(file_fields))\n\n            fn, fd, ct = self.args.files['']\n            self.args.files = {}\n\n            self._body_from_file(fd)\n\n            if 'Content-Type' not in self.args.headers:\n                content_type = get_content_type(fn)\n                if content_type:\n                    self.args.headers['Content-Type'] = content_type\n\n    def _process_output_options(self):\n        \"\"\"Apply defaults to output options, or validate the provided ones.\n\n        The default output options are stdout-type-sensitive.\n\n        \"\"\"\n        def check_options(value, option):\n            unknown = set(value) - OUTPUT_OPTIONS\n            if unknown:\n                self.error('Unknown output options: {0}={1}'.format(\n                    option,\n                    ','.join(unknown)\n                ))\n\n        if self.args.verbose:\n            self.args.all = True\n\n        if self.args.output_options is None:\n            if self.args.verbose:\n                self.args.output_options = ''.join(OUTPUT_OPTIONS)\n            else:\n                self.args.output_options = (\n                    OUTPUT_OPTIONS_DEFAULT\n                    if self.env.stdout_isatty\n                    else OUTPUT_OPTIONS_DEFAULT_STDOUT_REDIRECTED\n                )\n\n        if self.args.output_options_history is None:\n            self.args.output_options_history = self.args.output_options\n\n        check_options(self.args.output_options, '--print')\n        check_options(self.args.output_options_history, '--history-print')\n\n        if self.args.download and OUT_RESP_BODY in self.args.output_options:\n            # Response body is always downloaded with --download and it goes\n            # through a different routine, so we remove it.\n            self.args.output_options = str(\n                set(self.args.output_options) - set(OUT_RESP_BODY))\n\n    def _process_pretty_options(self):\n        if self.args.prettify == PRETTY_STDOUT_TTY_ONLY:\n            self.args.prettify = PRETTY_MAP[\n                'all' if self.env.stdout_isatty else 'none']\n        elif (self.args.prettify and self.env.is_windows and\n              self.args.output_file):\n            self.error('Only terminal output can be colorized on Windows.')\n        else:\n            # noinspection PyTypeChecker\n            self.args.prettify = PRETTY_MAP[self.args.prettify]\n\n    def _validate_download_options(self):\n        if not self.args.download:\n            if self.args.download_resume:\n                self.error('--continue only works with --download')\n        if self.args.download_resume and not (\n                self.args.download and self.args.output_file):\n            self.error('--continue requires --output to be specified')\n\n\nclass ParseError(Exception):\n    pass\n\n\nclass KeyValue(object):\n    \"\"\"Base key-value pair parsed from CLI.\"\"\"\n\n    def __init__(self, key, value, sep, orig):\n        self.key = key\n        self.value = value\n        self.sep = sep\n        self.orig = orig\n\n    def __eq__(self, other):\n        return self.__dict__ == other.__dict__\n\n    def __repr__(self):\n        return repr(self.__dict__)\n\n\nclass SessionNameValidator(object):\n\n    def __init__(self, error_message):\n        self.error_message = error_message\n\n    def __call__(self, value):\n        # Session name can be a path or just a name.\n        if (os.path.sep not in value and\n                not VALID_SESSION_NAME_PATTERN.search(value)):\n            raise ArgumentError(None, self.error_message)\n        return value\n\n\nclass KeyValueArgType(object):\n    \"\"\"A key-value pair argument type used with `argparse`.\n\n    Parses a key-value arg and constructs a `KeyValue` instance.\n    Used for headers, form data, and other key-value pair types.\n\n    \"\"\"\n\n    key_value_class = KeyValue\n\n    def __init__(self, *separators):\n        self.separators = separators\n        self.special_characters = set('\\\\')\n        for separator in separators:\n            self.special_characters.update(separator)\n\n    def __call__(self, string):\n        \"\"\"Parse `string` and return `self.key_value_class()` instance.\n\n        The best of `self.separators` is determined (first found, longest).\n        Back slash escaped characters aren't considered as separators\n        (or parts thereof). Literal back slash characters have to be escaped\n        as well (r'\\\\').\n\n        \"\"\"\n\n        class Escaped(str):\n            \"\"\"Represents an escaped character.\"\"\"\n\n        def tokenize(string):\n            \"\"\"Tokenize `string`. There are only two token types - strings\n            and escaped characters:\n\n            tokenize(r'foo\\=bar\\\\baz')\n            => ['foo', Escaped('='), 'bar', Escaped('\\\\'), 'baz']\n\n            \"\"\"\n            tokens = ['']\n            characters = iter(string)\n            for char in characters:\n                if char == '\\\\':\n                    char = next(characters, '')\n                    if char not in self.special_characters:\n                        tokens[-1] += '\\\\' + char\n                    else:\n                        tokens.extend([Escaped(char), ''])\n                else:\n                    tokens[-1] += char\n            return tokens\n\n        tokens = tokenize(string)\n\n        # Sorting by length ensures that the longest one will be\n        # chosen as it will overwrite any shorter ones starting\n        # at the same position in the `found` dictionary.\n        separators = sorted(self.separators, key=len)\n\n        for i, token in enumerate(tokens):\n\n            if isinstance(token, Escaped):\n                continue\n\n            found = {}\n            for sep in separators:\n                pos = token.find(sep)\n                if pos != -1:\n                    found[pos] = sep\n\n            if found:\n                # Starting first, longest separator found.\n                sep = found[min(found.keys())]\n\n                key, value = token.split(sep, 1)\n\n                # Any preceding tokens are part of the key.\n                key = ''.join(tokens[:i]) + key\n\n                # Any following tokens are part of the value.\n                value += ''.join(tokens[i + 1:])\n\n                break\n\n        else:\n            raise ArgumentTypeError(\n                u'\"%s\" is not a valid value' % string)\n\n        return self.key_value_class(\n            key=key, value=value, sep=sep, orig=string)\n\n\nclass AuthCredentials(KeyValue):\n    \"\"\"Represents parsed credentials.\"\"\"\n\n    def _getpass(self, prompt):\n        # To allow mocking.\n        return getpass.getpass(str(prompt))\n\n    def has_password(self):\n        return self.value is not None\n\n    def prompt_password(self, host):\n        try:\n            self.value = self._getpass(\n                'http: password for %s@%s: ' % (self.key, host))\n        except (EOFError, KeyboardInterrupt):\n            sys.stderr.write('\\n')\n            sys.exit(0)\n\n\nclass AuthCredentialsArgType(KeyValueArgType):\n    \"\"\"A key-value arg type that parses credentials.\"\"\"\n\n    key_value_class = AuthCredentials\n\n    def __call__(self, string):\n        \"\"\"Parse credentials from `string`.\n\n        (\"username\" or \"username:password\").\n\n        \"\"\"\n        try:\n            return super(AuthCredentialsArgType, self).__call__(string)\n        except ArgumentTypeError:\n            # No password provided, will prompt for it later.\n            return self.key_value_class(\n                key=string,\n                value=None,\n                sep=SEP_CREDENTIALS,\n                orig=string\n            )\n\n\nparse_auth = AuthCredentialsArgType(SEP_CREDENTIALS)\n\n\nclass RequestItemsDict(OrderedDict):\n    \"\"\"Multi-value dict for URL parameters and form data.\"\"\"\n\n    if is_pypy and is_py27:\n        # Manually set keys when initialized with an iterable as PyPy\n        # doesn't call __setitem__ in such case (pypy3 does).\n        def __init__(self, *args, **kwargs):\n            if len(args) == 1 and isinstance(args[0], Iterable):\n                super(RequestItemsDict, self).__init__(**kwargs)\n                for k, v in args[0]:\n                    self[k] = v\n            else:\n                super(RequestItemsDict, self).__init__(*args, **kwargs)\n\n    # noinspection PyMethodOverriding\n    def __setitem__(self, key, value):\n        \"\"\" If `key` is assigned more than once, `self[key]` holds a\n        `list` of all the values.\n\n        This allows having multiple fields with the same name in form\n        data and URL params.\n\n        \"\"\"\n        assert not isinstance(value, list)\n        if key not in self:\n            super(RequestItemsDict, self).__setitem__(key, value)\n        else:\n            if not isinstance(self[key], list):\n                super(RequestItemsDict, self).__setitem__(key, [self[key]])\n            self[key].append(value)\n\n\nclass ParamsDict(RequestItemsDict):\n    pass\n\n\nclass DataDict(RequestItemsDict):\n\n    def items(self):\n        for key, values in super(RequestItemsDict, self).items():\n            if not isinstance(values, list):\n                values = [values]\n            for value in values:\n                yield key, value\n\n\nRequestItems = namedtuple('RequestItems',\n                          ['headers', 'data', 'files', 'params'])\n\n\ndef get_content_type(filename):\n    \"\"\"\n    Return the content type for ``filename`` in format appropriate\n    for Content-Type headers, or ``None`` if the file type is unknown\n    to ``mimetypes``.\n\n    \"\"\"\n    mime, encoding = mimetypes.guess_type(filename, strict=False)\n    if mime:\n        content_type = mime\n        if encoding:\n            content_type = '%s; charset=%s' % (mime, encoding)\n        return content_type\n\n\ndef parse_items(items,\n                headers_class=CaseInsensitiveDict,\n                data_class=OrderedDict,\n                files_class=DataDict,\n                params_class=ParamsDict):\n    \"\"\"Parse `KeyValue` `items` into `data`, `headers`, `files`,\n    and `params`.\n\n    \n \n# No value => unset the header\n", "content": "\"\"\"Parsing and processing of CLI input (args, auth credentials, files, stdin).\n\n\"\"\"\nimport os\nimport ssl\nimport sys\nimport re\nimport errno\nimport mimetypes\nimport getpass\nfrom io import BytesIO\nfrom collections import namedtuple, Iterable, OrderedDict\n# noinspection PyCompatibility\nfrom argparse import ArgumentParser, ArgumentTypeError, ArgumentError\n\n# TODO: Use MultiDict for headers once added to `requests`.\n# https://github.com/jakubroztocil/httpie/issues/130\nfrom httpie.plugins import plugin_manager\nfrom requests.structures import CaseInsensitiveDict\n\nfrom httpie.compat import urlsplit, str, is_pypy, is_py27\nfrom httpie.sessions import VALID_SESSION_NAME_PATTERN\nfrom httpie.utils import load_json_preserve_order\n\n\n# ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n# <http://tools.ietf.org/html/rfc3986#section-3.1>\nURL_SCHEME_RE = re.compile(r'^[a-z][a-z0-9.+-]*://', re.IGNORECASE)\n\nHTTP_POST = 'POST'\nHTTP_GET = 'GET'\n\n\n# Various separators used in args\nSEP_HEADERS = ':'\nSEP_HEADERS_EMPTY = ';'\nSEP_CREDENTIALS = ':'\nSEP_PROXY = ':'\nSEP_DATA = '='\nSEP_DATA_RAW_JSON = ':='\nSEP_FILES = '@'\nSEP_DATA_EMBED_FILE = '=@'\nSEP_DATA_EMBED_RAW_JSON_FILE = ':=@'\nSEP_QUERY = '=='\n\n# Separators that become request data\nSEP_GROUP_DATA_ITEMS = frozenset([\n    SEP_DATA,\n    SEP_DATA_RAW_JSON,\n    SEP_FILES,\n    SEP_DATA_EMBED_FILE,\n    SEP_DATA_EMBED_RAW_JSON_FILE\n])\n\n# Separators for items whose value is a filename to be embedded\nSEP_GROUP_DATA_EMBED_ITEMS = frozenset([\n    SEP_DATA_EMBED_FILE,\n    SEP_DATA_EMBED_RAW_JSON_FILE,\n])\n\n# Separators for raw JSON items\nSEP_GROUP_RAW_JSON_ITEMS = frozenset([\n    SEP_DATA_RAW_JSON,\n    SEP_DATA_EMBED_RAW_JSON_FILE,\n])\n\n# Separators allowed in ITEM arguments\nSEP_GROUP_ALL_ITEMS = frozenset([\n    SEP_HEADERS,\n    SEP_HEADERS_EMPTY,\n    SEP_QUERY,\n    SEP_DATA,\n    SEP_DATA_RAW_JSON,\n    SEP_FILES,\n    SEP_DATA_EMBED_FILE,\n    SEP_DATA_EMBED_RAW_JSON_FILE,\n])\n\n\n# Output options\nOUT_REQ_HEAD = 'H'\nOUT_REQ_BODY = 'B'\nOUT_RESP_HEAD = 'h'\nOUT_RESP_BODY = 'b'\n\nOUTPUT_OPTIONS = frozenset([\n    OUT_REQ_HEAD,\n    OUT_REQ_BODY,\n    OUT_RESP_HEAD,\n    OUT_RESP_BODY\n])\n\n# Pretty\nPRETTY_MAP = {\n    'all': ['format', 'colors'],\n    'colors': ['colors'],\n    'format': ['format'],\n    'none': []\n}\nPRETTY_STDOUT_TTY_ONLY = object()\n\n\n# Defaults\nOUTPUT_OPTIONS_DEFAULT = OUT_RESP_HEAD + OUT_RESP_BODY\nOUTPUT_OPTIONS_DEFAULT_STDOUT_REDIRECTED = OUT_RESP_BODY\n\n\nSSL_VERSION_ARG_MAPPING = {\n    'ssl2.3': 'PROTOCOL_SSLv23',\n    'ssl3': 'PROTOCOL_SSLv3',\n    'tls1': 'PROTOCOL_TLSv1',\n    'tls1.1': 'PROTOCOL_TLSv1_1',\n    'tls1.2': 'PROTOCOL_TLSv1_2',\n}\nSSL_VERSION_ARG_MAPPING = {\n    cli_arg: getattr(ssl, ssl_constant)\n    for cli_arg, ssl_constant in SSL_VERSION_ARG_MAPPING.items()\n    if hasattr(ssl, ssl_constant)\n}\n\n\nclass HTTPieArgumentParser(ArgumentParser):\n    \"\"\"Adds additional logic to `argparse.ArgumentParser`.\n\n    Handles all input (CLI args, file args, stdin), applies defaults,\n    and performs extra validation.\n\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        kwargs['add_help'] = False\n        super(HTTPieArgumentParser, self).__init__(*args, **kwargs)\n\n    # noinspection PyMethodOverriding\n    def parse_args(self, env, args=None, namespace=None):\n\n        self.env = env\n        self.args, no_options = super(HTTPieArgumentParser, self)\\\n            .parse_known_args(args, namespace)\n\n        if self.args.debug:\n            self.args.traceback = True\n\n        # Arguments processing and environment setup.\n        self._apply_no_options(no_options)\n        self._validate_download_options()\n        self._setup_standard_streams()\n        self._process_output_options()\n        self._process_pretty_options()\n        self._guess_method()\n        self._parse_items()\n        if not self.args.ignore_stdin and not env.stdin_isatty:\n            self._body_from_file(self.env.stdin)\n        if not URL_SCHEME_RE.match(self.args.url):\n            scheme = self.args.default_scheme + \"://\"\n\n            # See if we're using curl style shorthand for localhost (:3000/foo)\n            shorthand = re.match(r'^:(?!:)(\\d*)(/?.*)$', self.args.url)\n            if shorthand:\n                port = shorthand.group(1)\n                rest = shorthand.group(2)\n                self.args.url = scheme + 'localhost'\n                if port:\n                    self.args.url += ':' + port\n                self.args.url += rest\n            else:\n                self.args.url = scheme + self.args.url\n        self._process_auth()\n\n        return self.args\n\n    # noinspection PyShadowingBuiltins\n    def _print_message(self, message, file=None):\n        # Sneak in our stderr/stdout.\n        file = {\n            sys.stdout: self.env.stdout,\n            sys.stderr: self.env.stderr,\n            None: self.env.stderr\n        }.get(file, file)\n        if not hasattr(file, 'buffer') and isinstance(message, str):\n            message = message.encode(self.env.stdout_encoding)\n        super(HTTPieArgumentParser, self)._print_message(message, file)\n\n    def _setup_standard_streams(self):\n        \"\"\"\n        Modify `env.stdout` and `env.stdout_isatty` based on args, if needed.\n\n        \"\"\"\n        self.args.output_file_specified = bool(self.args.output_file)\n        if self.args.download:\n            # FIXME: Come up with a cleaner solution.\n            if not self.args.output_file and not self.env.stdout_isatty:\n                # Use stdout as the download output file.\n                self.args.output_file = self.env.stdout\n            # With `--download`, we write everything that would normally go to\n            # `stdout` to `stderr` instead. Let's replace the stream so that\n            # we don't have to use many `if`s throughout the codebase.\n            # The response body will be treated separately.\n            self.env.stdout = self.env.stderr\n            self.env.stdout_isatty = self.env.stderr_isatty\n        elif self.args.output_file:\n            # When not `--download`ing, then `--output` simply replaces\n            # `stdout`. The file is opened for appending, which isn't what\n            # we want in this case.\n            self.args.output_file.seek(0)\n            try:\n                self.args.output_file.truncate()\n            except IOError as e:\n                if e.errno == errno.EINVAL:\n                    # E.g. /dev/null on Linux.\n                    pass\n                else:\n                    raise\n            self.env.stdout = self.args.output_file\n            self.env.stdout_isatty = False\n\n    def _process_auth(self):\n        # TODO: refactor\n        self.args.auth_plugin = None\n        default_auth_plugin = plugin_manager.get_auth_plugins()[0]\n        auth_type_set = self.args.auth_type is not None\n        url = urlsplit(self.args.url)\n\n        if self.args.auth is None and not auth_type_set:\n            if url.username is not None:\n                # Handle http://username:password@hostname/\n                username = url.username\n                password = url.password or ''\n                self.args.auth = AuthCredentials(\n                    key=username,\n                    value=password,\n                    sep=SEP_CREDENTIALS,\n                    orig=SEP_CREDENTIALS.join([username, password])\n                )\n\n        if self.args.auth is not None or auth_type_set:\n            if not self.args.auth_type:\n                self.args.auth_type = default_auth_plugin.auth_type\n            plugin = plugin_manager.get_auth_plugin(self.args.auth_type)()\n\n            if plugin.auth_require and self.args.auth is None:\n                self.error('--auth required')\n\n            plugin.raw_auth = self.args.auth\n            self.args.auth_plugin = plugin\n            already_parsed = isinstance(self.args.auth, AuthCredentials)\n\n            if self.args.auth is None or not plugin.auth_parse:\n                self.args.auth = plugin.get_auth()\n            else:\n                if already_parsed:\n                    # from the URL\n                    credentials = self.args.auth\n                else:\n                    credentials = parse_auth(self.args.auth)\n\n                if (not credentials.has_password() and\n                        plugin.prompt_password):\n                    if self.args.ignore_stdin:\n                        # Non-tty stdin read by now\n                        self.error(\n                            'Unable to prompt for passwords because'\n                            ' --ignore-stdin is set.'\n                        )\n                    credentials.prompt_password(url.netloc)\n                self.args.auth = plugin.get_auth(\n                    username=credentials.key,\n                    password=credentials.value,\n                )\n\n    def _apply_no_options(self, no_options):\n        \"\"\"For every `--no-OPTION` in `no_options`, set `args.OPTION` to\n        its default value. This allows for un-setting of options, e.g.,\n        specified in config.\n\n        \"\"\"\n        invalid = []\n\n        for option in no_options:\n            if not option.startswith('--no-'):\n                invalid.append(option)\n                continue\n\n            # --no-option => --option\n            inverted = '--' + option[5:]\n            for action in self._actions:\n                if inverted in action.option_strings:\n                    setattr(self.args, action.dest, action.default)\n                    break\n            else:\n                invalid.append(option)\n\n        if invalid:\n            msg = 'unrecognized arguments: %s'\n            self.error(msg % ' '.join(invalid))\n\n    def _body_from_file(self, fd):\n        \"\"\"There can only be one source of request data.\n\n        Bytes are always read.\n\n        \"\"\"\n        if self.args.data:\n            self.error('Request body (from stdin or a file) and request '\n                       'data (key=value) cannot be mixed. Pass '\n                       '--ignore-stdin to let key/value take priority.')\n        self.args.data = getattr(fd, 'buffer', fd).read()\n\n    def _guess_method(self):\n        \"\"\"Set `args.method` if not specified to either POST or GET\n        based on whether the request has data or not.\n\n        \"\"\"\n        if self.args.method is None:\n            # Invoked as `http URL'.\n            assert not self.args.items\n            if not self.args.ignore_stdin and not self.env.stdin_isatty:\n                self.args.method = HTTP_POST\n            else:\n                self.args.method = HTTP_GET\n\n        # FIXME: False positive, e.g., \"localhost\" matches but is a valid URL.\n        elif not re.match('^[a-zA-Z]+$', self.args.method):\n            # Invoked as `http URL item+'. The URL is now in `args.method`\n            # and the first ITEM is now incorrectly in `args.url`.\n            try:\n                # Parse the URL as an ITEM and store it as the first ITEM arg.\n                self.args.items.insert(0, KeyValueArgType(\n                    *SEP_GROUP_ALL_ITEMS).__call__(self.args.url))\n\n            except ArgumentTypeError as e:\n                if self.args.traceback:\n                    raise\n                self.error(e.args[0])\n\n            else:\n                # Set the URL correctly\n                self.args.url = self.args.method\n                # Infer the method\n                has_data = (\n                    (not self.args.ignore_stdin and\n                     not self.env.stdin_isatty) or\n                    any(item.sep in SEP_GROUP_DATA_ITEMS\n                        for item in self.args.items)\n                )\n                self.args.method = HTTP_POST if has_data else HTTP_GET\n\n    def _parse_items(self):\n        \"\"\"Parse `args.items` into `args.headers`, `args.data`, `args.params`,\n         and `args.files`.\n\n        \"\"\"\n        try:\n            items = parse_items(\n                items=self.args.items,\n                data_class=ParamsDict if self.args.form else OrderedDict\n            )\n        except ParseError as e:\n            if self.args.traceback:\n                raise\n            self.error(e.args[0])\n        else:\n            self.args.headers = items.headers\n            self.args.data = items.data\n            self.args.files = items.files\n            self.args.params = items.params\n\n        if self.args.files and not self.args.form:\n            # `http url @/path/to/file`\n            file_fields = list(self.args.files.keys())\n            if file_fields != ['']:\n                self.error(\n                    'Invalid file fields (perhaps you meant --form?): %s'\n                    % ','.join(file_fields))\n\n            fn, fd, ct = self.args.files['']\n            self.args.files = {}\n\n            self._body_from_file(fd)\n\n            if 'Content-Type' not in self.args.headers:\n                content_type = get_content_type(fn)\n                if content_type:\n                    self.args.headers['Content-Type'] = content_type\n\n    def _process_output_options(self):\n        \"\"\"Apply defaults to output options, or validate the provided ones.\n\n        The default output options are stdout-type-sensitive.\n\n        \"\"\"\n        def check_options(value, option):\n            unknown = set(value) - OUTPUT_OPTIONS\n            if unknown:\n                self.error('Unknown output options: {0}={1}'.format(\n                    option,\n                    ','.join(unknown)\n                ))\n\n        if self.args.verbose:\n            self.args.all = True\n\n        if self.args.output_options is None:\n            if self.args.verbose:\n                self.args.output_options = ''.join(OUTPUT_OPTIONS)\n            else:\n                self.args.output_options = (\n                    OUTPUT_OPTIONS_DEFAULT\n                    if self.env.stdout_isatty\n                    else OUTPUT_OPTIONS_DEFAULT_STDOUT_REDIRECTED\n                )\n\n        if self.args.output_options_history is None:\n            self.args.output_options_history = self.args.output_options\n\n        check_options(self.args.output_options, '--print')\n        check_options(self.args.output_options_history, '--history-print')\n\n        if self.args.download and OUT_RESP_BODY in self.args.output_options:\n            # Response body is always downloaded with --download and it goes\n            # through a different routine, so we remove it.\n            self.args.output_options = str(\n                set(self.args.output_options) - set(OUT_RESP_BODY))\n\n    def _process_pretty_options(self):\n        if self.args.prettify == PRETTY_STDOUT_TTY_ONLY:\n            self.args.prettify = PRETTY_MAP[\n                'all' if self.env.stdout_isatty else 'none']\n        elif (self.args.prettify and self.env.is_windows and\n              self.args.output_file):\n            self.error('Only terminal output can be colorized on Windows.')\n        else:\n            # noinspection PyTypeChecker\n            self.args.prettify = PRETTY_MAP[self.args.prettify]\n\n    def _validate_download_options(self):\n        if not self.args.download:\n            if self.args.download_resume:\n                self.error('--continue only works with --download')\n        if self.args.download_resume and not (\n                self.args.download and self.args.output_file):\n            self.error('--continue requires --output to be specified')\n\n\nclass ParseError(Exception):\n    pass\n\n\nclass KeyValue(object):\n    \"\"\"Base key-value pair parsed from CLI.\"\"\"\n\n    def __init__(self, key, value, sep, orig):\n        self.key = key\n        self.value = value\n        self.sep = sep\n        self.orig = orig\n\n    def __eq__(self, other):\n        return self.__dict__ == other.__dict__\n\n    def __repr__(self):\n        return repr(self.__dict__)\n\n\nclass SessionNameValidator(object):\n\n    def __init__(self, error_message):\n        self.error_message = error_message\n\n    def __call__(self, value):\n        # Session name can be a path or just a name.\n        if (os.path.sep not in value and\n                not VALID_SESSION_NAME_PATTERN.search(value)):\n            raise ArgumentError(None, self.error_message)\n        return value\n\n\nclass KeyValueArgType(object):\n    \"\"\"A key-value pair argument type used with `argparse`.\n\n    Parses a key-value arg and constructs a `KeyValue` instance.\n    Used for headers, form data, and other key-value pair types.\n\n    \"\"\"\n\n    key_value_class = KeyValue\n\n    def __init__(self, *separators):\n        self.separators = separators\n        self.special_characters = set('\\\\')\n        for separator in separators:\n            self.special_characters.update(separator)\n\n    def __call__(self, string):\n        \"\"\"Parse `string` and return `self.key_value_class()` instance.\n\n        The best of `self.separators` is determined (first found, longest).\n        Back slash escaped characters aren't considered as separators\n        (or parts thereof). Literal back slash characters have to be escaped\n        as well (r'\\\\').\n\n        \"\"\"\n\n        class Escaped(str):\n            \"\"\"Represents an escaped character.\"\"\"\n\n        def tokenize(string):\n            \"\"\"Tokenize `string`. There are only two token types - strings\n            and escaped characters:\n\n            tokenize(r'foo\\=bar\\\\baz')\n            => ['foo', Escaped('='), 'bar', Escaped('\\\\'), 'baz']\n\n            \"\"\"\n            tokens = ['']\n            characters = iter(string)\n            for char in characters:\n                if char == '\\\\':\n                    char = next(characters, '')\n                    if char not in self.special_characters:\n                        tokens[-1] += '\\\\' + char\n                    else:\n                        tokens.extend([Escaped(char), ''])\n                else:\n                    tokens[-1] += char\n            return tokens\n\n        tokens = tokenize(string)\n\n        # Sorting by length ensures that the longest one will be\n        # chosen as it will overwrite any shorter ones starting\n        # at the same position in the `found` dictionary.\n        separators = sorted(self.separators, key=len)\n\n        for i, token in enumerate(tokens):\n\n            if isinstance(token, Escaped):\n                continue\n\n            found = {}\n            for sep in separators:\n                pos = token.find(sep)\n                if pos != -1:\n                    found[pos] = sep\n\n            if found:\n                # Starting first, longest separator found.\n                sep = found[min(found.keys())]\n\n                key, value = token.split(sep, 1)\n\n                # Any preceding tokens are part of the key.\n                key = ''.join(tokens[:i]) + key\n\n                # Any following tokens are part of the value.\n                value += ''.join(tokens[i + 1:])\n\n                break\n\n        else:\n            raise ArgumentTypeError(\n                u'\"%s\" is not a valid value' % string)\n\n        return self.key_value_class(\n            key=key, value=value, sep=sep, orig=string)\n\n\nclass AuthCredentials(KeyValue):\n    \"\"\"Represents parsed credentials.\"\"\"\n\n    def _getpass(self, prompt):\n        # To allow mocking.\n        return getpass.getpass(str(prompt))\n\n    def has_password(self):\n        return self.value is not None\n\n    def prompt_password(self, host):\n        try:\n            self.value = self._getpass(\n                'http: password for %s@%s: ' % (self.key, host))\n        except (EOFError, KeyboardInterrupt):\n            sys.stderr.write('\\n')\n            sys.exit(0)\n\n\nclass AuthCredentialsArgType(KeyValueArgType):\n    \"\"\"A key-value arg type that parses credentials.\"\"\"\n\n    key_value_class = AuthCredentials\n\n    def __call__(self, string):\n        \"\"\"Parse credentials from `string`.\n\n        (\"username\" or \"username:password\").\n\n        \"\"\"\n        try:\n            return super(AuthCredentialsArgType, self).__call__(string)\n        except ArgumentTypeError:\n            # No password provided, will prompt for it later.\n            return self.key_value_class(\n                key=string,\n                value=None,\n                sep=SEP_CREDENTIALS,\n                orig=string\n            )\n\n\nparse_auth = AuthCredentialsArgType(SEP_CREDENTIALS)\n\n\nclass RequestItemsDict(OrderedDict):\n    \"\"\"Multi-value dict for URL parameters and form data.\"\"\"\n\n    if is_pypy and is_py27:\n        # Manually set keys when initialized with an iterable as PyPy\n        # doesn't call __setitem__ in such case (pypy3 does).\n        def __init__(self, *args, **kwargs):\n            if len(args) == 1 and isinstance(args[0], Iterable):\n                super(RequestItemsDict, self).__init__(**kwargs)\n                for k, v in args[0]:\n                    self[k] = v\n            else:\n                super(RequestItemsDict, self).__init__(*args, **kwargs)\n\n    # noinspection PyMethodOverriding\n    def __setitem__(self, key, value):\n        \"\"\" If `key` is assigned more than once, `self[key]` holds a\n        `list` of all the values.\n\n        This allows having multiple fields with the same name in form\n        data and URL params.\n\n        \"\"\"\n        assert not isinstance(value, list)\n        if key not in self:\n            super(RequestItemsDict, self).__setitem__(key, value)\n        else:\n            if not isinstance(self[key], list):\n                super(RequestItemsDict, self).__setitem__(key, [self[key]])\n            self[key].append(value)\n\n\nclass ParamsDict(RequestItemsDict):\n    pass\n\n\nclass DataDict(RequestItemsDict):\n\n    def items(self):\n        for key, values in super(RequestItemsDict, self).items():\n            if not isinstance(values, list):\n                values = [values]\n            for value in values:\n                yield key, value\n\n\nRequestItems = namedtuple('RequestItems',\n                          ['headers', 'data', 'files', 'params'])\n\n\ndef get_content_type(filename):\n    \"\"\"\n    Return the content type for ``filename`` in format appropriate\n    for Content-Type headers, or ``None`` if the file type is unknown\n    to ``mimetypes``.\n\n    \"\"\"\n    mime, encoding = mimetypes.guess_type(filename, strict=False)\n    if mime:\n        content_type = mime\n        if encoding:\n            content_type = '%s; charset=%s' % (mime, encoding)\n        return content_type\n\n\ndef parse_items(items,\n                headers_class=CaseInsensitiveDict,\n                data_class=OrderedDict,\n                files_class=DataDict,\n                params_class=ParamsDict):\n    \"\"\"Parse `KeyValue` `items` into `data`, `headers`, `files`,\n    and `params`.\n\n    \"\"\"\n    headers = []\n    data = []\n    files = []\n    params = []\n    for item in items:\n        value = item.value\n        if item.sep == SEP_HEADERS:\n            if value == '':\n                # No value => unset the header\n                value = None\n            target = headers\n        elif item.sep == SEP_HEADERS_EMPTY:\n            if item.value:\n                raise ParseError(\n                    'Invalid item \"%s\" '\n                    '(to specify an empty header use `Header;`)'\n                    % item.orig\n                )\n            target = headers\n        elif item.sep == SEP_QUERY:\n            target = params\n        elif item.sep == SEP_FILES:\n            try:\n                with open(os.path.expanduser(value), 'rb') as f:\n                    value = (os.path.basename(value),\n                             BytesIO(f.read()),\n                             get_content_type(value))\n            except IOError as e:\n                raise ParseError('\"%s\": %s' % (item.orig, e))\n            target = files\n\n        elif item.sep in SEP_GROUP_DATA_ITEMS:\n\n            if item.sep in SEP_GROUP_DATA_EMBED_ITEMS:\n                try:\n                    with open(os.path.expanduser(value), 'rb') as f:\n                        value = f.read().decode('utf8')\n                except IOError as e:\n                    raise ParseError('\"%s\": %s' % (item.orig, e))\n                except UnicodeDecodeError:\n                    raise ParseError(\n                        '\"%s\": cannot embed the content of \"%s\",'\n                        ' not a UTF8 or ASCII-encoded text file'\n                        % (item.orig, item.value)\n                    )\n\n            if item.sep in SEP_GROUP_RAW_JSON_ITEMS:\n                try:\n                    value = load_json_preserve_order(value)\n                except ValueError as e:\n                    raise ParseError('\"%s\": %s' % (item.orig, e))\n            target = data\n\n        else:\n            raise TypeError(item)\n\n        target.append((item.key, value))\n\n    return RequestItems(headers_class(headers),\n                        data_class(data),\n                        files_class(files),\n                        params_class(params))\n\n\ndef readable_file_arg(filename):\n    try:\n        open(filename, 'rb')\n    except IOError as ex:\n        raise ArgumentTypeError('%s: %s' % (filename, ex.args[1]))\n    return filename\n", "description": "Modern command line HTTP client \u2013 user-friendly curl alternative with intuitive UI, JSON support, syntax highlighting, wget-like downloads, extensions, etc.  https://httpie.org", "file_name": "input.py", "language": "Python", "project_name": "httpie", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/jakubroztocil_httpie/jakubroztocil-httpie-0f4dce9/httpie/input.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:20:06Z", "url": "https://github.com/jakubroztocil/httpie", "wiki": false}