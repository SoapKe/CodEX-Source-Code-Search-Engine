{"author": "python", "code": "\n\"\"\"Generate C code for the jump table of the threaded code interpreter\n(for compilers supporting computed gotos or \"labels-as-values\", such as gcc).\n\"\"\"\n\nimport os\nimport sys\n\n\ntry:\n    from importlib.machinery import SourceFileLoader\nexcept ImportError:\n    import imp\n\n    def find_module(modname):\n        \"\"\"Finds and returns a module in the local dist/checkout.\n        \"\"\"\n        modpath = os.path.join(\n            os.path.dirname(os.path.dirname(__file__)), \"Lib\")\n        return imp.load_module(modname, *imp.find_module(modname, [modpath]))\nelse:\n    def find_module(modname):\n        \"\"\"Finds and returns a module in the local dist/checkout.\n        \"\"\"\n        modpath = os.path.join(\n            os.path.dirname(os.path.dirname(__file__)), \"Lib\", modname + \".py\")\n        return SourceFileLoader(modname, modpath).load_module()\n\n\ndef write_contents(f):\n    \"\"\"Write C code contents to the target file object.\n    \"\"\"\n    opcode = find_module('opcode')\n    targets = ['_unknown_opcode'] * 256\n    for opname, op in opcode.opmap.items():\n        targets[op] = \"TARGET_%s\" % opname\n    f.write(\"static void *opcode_targets[256] = {\\n\")\n    f.write(\",\\n\".join([\"    &&%s\" % s for s in targets]))\n    f.write(\"\\n};\\n\")\n\n\ndef main():\n    if len(sys.argv) >= 3:\n        sys.exit(\"Too many arguments\")\n    if len(sys.argv) == 2:\n        target = sys.argv[1]\n    else:\n        target = \"Python/opcode_targets.h\"\n    with open(target, \"w\") as f:\n        write_contents(f)\n    print(\"Jump table written into %s\" % target)\n\n\nif __name__ == \"__main__\":\n    main()\n", "comments": "   generate c code jump table threaded code interpreter (for compilers supporting computed gotos  labels values   gcc)       import os import sys   try      importlib machinery import sourcefileloader except importerror      import imp      def find module(modname)             finds returns module local dist checkout                      modpath   os path join(             os path dirname(os path dirname(  file  ))   lib )         return imp load module(modname   imp find module(modname   modpath )) else      def find module(modname)             finds returns module local dist checkout                      modpath   os path join(             os path dirname(os path dirname(  file  ))   lib   modname     py )         return sourcefileloader(modname  modpath) load module()   def write contents(f)         write c code contents target file object               usr bin env python ", "content": "#! /usr/bin/env python\n\"\"\"Generate C code for the jump table of the threaded code interpreter\n(for compilers supporting computed gotos or \"labels-as-values\", such as gcc).\n\"\"\"\n\nimport os\nimport sys\n\n\ntry:\n    from importlib.machinery import SourceFileLoader\nexcept ImportError:\n    import imp\n\n    def find_module(modname):\n        \"\"\"Finds and returns a module in the local dist/checkout.\n        \"\"\"\n        modpath = os.path.join(\n            os.path.dirname(os.path.dirname(__file__)), \"Lib\")\n        return imp.load_module(modname, *imp.find_module(modname, [modpath]))\nelse:\n    def find_module(modname):\n        \"\"\"Finds and returns a module in the local dist/checkout.\n        \"\"\"\n        modpath = os.path.join(\n            os.path.dirname(os.path.dirname(__file__)), \"Lib\", modname + \".py\")\n        return SourceFileLoader(modname, modpath).load_module()\n\n\ndef write_contents(f):\n    \"\"\"Write C code contents to the target file object.\n    \"\"\"\n    opcode = find_module('opcode')\n    targets = ['_unknown_opcode'] * 256\n    for opname, op in opcode.opmap.items():\n        targets[op] = \"TARGET_%s\" % opname\n    f.write(\"static void *opcode_targets[256] = {\\n\")\n    f.write(\",\\n\".join([\"    &&%s\" % s for s in targets]))\n    f.write(\"\\n};\\n\")\n\n\ndef main():\n    if len(sys.argv) >= 3:\n        sys.exit(\"Too many arguments\")\n    if len(sys.argv) == 2:\n        target = sys.argv[1]\n    else:\n        target = \"Python/opcode_targets.h\"\n    with open(target, \"w\") as f:\n        write_contents(f)\n    print(\"Jump table written into %s\" % target)\n\n\nif __name__ == \"__main__\":\n    main()\n", "description": "The Python programming language", "file_name": "makeopcodetargets.py", "id": "81acaee1d38efa09993d84df82c3a5a9", "language": "Python", "project_name": "cpython", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/python-cpython/python-cpython-fe2bbb1/Python/makeopcodetargets.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:51:39Z", "url": "https://github.com/python/cpython", "wiki": false}