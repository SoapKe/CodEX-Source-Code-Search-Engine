{"author": "nvbn", "code": "\n\nimport os\nfrom subprocess import PIPE, STDOUT\nfrom mock import Mock\nimport pytest\nfrom tests.utils import CorrectedCommand, Rule\nfrom thefuck import const\nfrom thefuck.exceptions import EmptyCommand\nfrom thefuck.system import Path\nfrom thefuck.types import Command\n\n\nclass TestCorrectedCommand(object):\n\n    def test_equality(self):\n        assert (CorrectedCommand('ls', None, 100) ==\n                CorrectedCommand('ls', None, 200))\n        assert (CorrectedCommand('ls', None, 100) !=\n                CorrectedCommand('ls', lambda *_: _, 100))\n\n    def test_hashable(self):\n        assert {CorrectedCommand('ls', None, 100),\n                CorrectedCommand('ls', None, 200)} == {CorrectedCommand('ls')}\n\n    def test_representable(self):\n        assert '{}'.format(CorrectedCommand('ls', None, 100)) == \\\n               'CorrectedCommand(script=ls, side_effect=None, priority=100)'\n        assert u'{}'.format(CorrectedCommand(u'echo caf\u00e9', None, 100)) == \\\n               u'CorrectedCommand(script=echo caf\u00e9, side_effect=None, priority=100)'\n\n    @pytest.mark.parametrize('script, printed, override_settings', [\n        ('git branch', 'git branch', {'repeat': False, 'debug': False}),\n        ('git brunch',\n         \"git brunch || fuck --repeat --force-command 'git brunch'\",\n         {'repeat': True, 'debug': False}),\n        ('git brunch',\n         \"git brunch || fuck --repeat --debug --force-command 'git brunch'\",\n         {'repeat': True, 'debug': True})])\n    def test_run(self, capsys, settings, script, printed, override_settings):\n        settings.update(override_settings)\n        CorrectedCommand(script, None, 1000).run(Command(script, ''))\n        out, _ = capsys.readouterr()\n        assert out[:-1] == printed\n\n\nclass TestRule(object):\n    def test_from_path(self, mocker):\n        match = object()\n        get_new_command = object()\n        load_source = mocker.patch(\n            'thefuck.types.load_source',\n            return_value=Mock(match=match,\n                              get_new_command=get_new_command,\n                              enabled_by_default=True,\n                              priority=900,\n                              requires_output=True))\n        rule_path = os.path.join(os.sep, 'rules', 'bash.py')\n        assert (Rule.from_path(Path(rule_path))\n                == Rule('bash', match, get_new_command, priority=900))\n        load_source.assert_called_once_with('bash', rule_path)\n\n    @pytest.mark.parametrize('rules, exclude_rules, rule, is_enabled', [\n        (const.DEFAULT_RULES, [], Rule('git', enabled_by_default=True), True),\n        (const.DEFAULT_RULES, [], Rule('git', enabled_by_default=False), False),\n        ([], [], Rule('git', enabled_by_default=False), False),\n        ([], [], Rule('git', enabled_by_default=True), False),\n        (const.DEFAULT_RULES + ['git'], [], Rule('git', enabled_by_default=False), True),\n        (['git'], [], Rule('git', enabled_by_default=False), True),\n        (const.DEFAULT_RULES, ['git'], Rule('git', enabled_by_default=True), False),\n        (const.DEFAULT_RULES, ['git'], Rule('git', enabled_by_default=False), False),\n        ([], ['git'], Rule('git', enabled_by_default=True), False),\n        ([], ['git'], Rule('git', enabled_by_default=False), False)])\n    def test_is_enabled(self, settings, rules, exclude_rules, rule, is_enabled):\n        settings.update(rules=rules,\n                        exclude_rules=exclude_rules)\n        assert rule.is_enabled == is_enabled\n\n    def test_isnt_match(self):\n        assert not Rule('', lambda _: False).is_match(\n            Command('ls', ''))\n\n    def test_is_match(self):\n        rule = Rule('', lambda x: x.script == 'cd ..')\n        assert rule.is_match(Command('cd ..', ''))\n\n    @pytest.mark.usefixtures('no_colors')\n    def test_isnt_match_when_rule_failed(self, capsys):\n        rule = Rule('test', Mock(side_effect=OSError('Denied')),\n                    requires_output=False)\n        assert not rule.is_match(Command('ls', ''))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n    def test_get_corrected_commands_with_rule_returns_list(self):\n        rule = Rule(get_new_command=lambda x: [x.script + '!', x.script + '@'],\n                    priority=100)\n        assert (list(rule.get_corrected_commands(Command('test', '')))\n                == [CorrectedCommand(script='test!', priority=100),\n                    CorrectedCommand(script='test@', priority=200)])\n\n    def test_get_corrected_commands_with_rule_returns_command(self):\n        rule = Rule(get_new_command=lambda x: x.script + '!',\n                    priority=100)\n        assert (list(rule.get_corrected_commands(Command('test', '')))\n                == [CorrectedCommand(script='test!', priority=100)])\n\n\nclass TestCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'output'\n        monkeypatch.setattr('thefuck.output_readers.rerun.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.output_readers.rerun._wait_output',\n                            lambda *_: True)\n\n    def test_from_script_calls(self, Popen, settings, os_environ):\n        settings.env = {}\n        assert Command.from_raw_script(\n            ['apt-get', 'search', 'vim']) == Command(\n            'apt-get search vim', 'output')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdin=PIPE,\n                                      stdout=PIPE,\n                                      stderr=STDOUT,\n                                      env=os_environ)\n\n    @pytest.mark.parametrize('script, result', [\n        ([''], None),\n        (['', ''], None),\n        (['ls', '-la'], 'ls -la'),\n        (['ls'], 'ls')])\n    def test_from_script(self, script, result):\n        if result:\n            assert Command.from_raw_script(script).script == result\n        else:\n            with pytest.raises(EmptyCommand):\n                Command.from_raw_script(script)\n", "comments": "# -*- coding: utf-8 -*-\n", "content": "# -*- coding: utf-8 -*-\n\nimport os\nfrom subprocess import PIPE, STDOUT\nfrom mock import Mock\nimport pytest\nfrom tests.utils import CorrectedCommand, Rule\nfrom thefuck import const\nfrom thefuck.exceptions import EmptyCommand\nfrom thefuck.system import Path\nfrom thefuck.types import Command\n\n\nclass TestCorrectedCommand(object):\n\n    def test_equality(self):\n        assert (CorrectedCommand('ls', None, 100) ==\n                CorrectedCommand('ls', None, 200))\n        assert (CorrectedCommand('ls', None, 100) !=\n                CorrectedCommand('ls', lambda *_: _, 100))\n\n    def test_hashable(self):\n        assert {CorrectedCommand('ls', None, 100),\n                CorrectedCommand('ls', None, 200)} == {CorrectedCommand('ls')}\n\n    def test_representable(self):\n        assert '{}'.format(CorrectedCommand('ls', None, 100)) == \\\n               'CorrectedCommand(script=ls, side_effect=None, priority=100)'\n        assert u'{}'.format(CorrectedCommand(u'echo caf\u00e9', None, 100)) == \\\n               u'CorrectedCommand(script=echo caf\u00e9, side_effect=None, priority=100)'\n\n    @pytest.mark.parametrize('script, printed, override_settings', [\n        ('git branch', 'git branch', {'repeat': False, 'debug': False}),\n        ('git brunch',\n         \"git brunch || fuck --repeat --force-command 'git brunch'\",\n         {'repeat': True, 'debug': False}),\n        ('git brunch',\n         \"git brunch || fuck --repeat --debug --force-command 'git brunch'\",\n         {'repeat': True, 'debug': True})])\n    def test_run(self, capsys, settings, script, printed, override_settings):\n        settings.update(override_settings)\n        CorrectedCommand(script, None, 1000).run(Command(script, ''))\n        out, _ = capsys.readouterr()\n        assert out[:-1] == printed\n\n\nclass TestRule(object):\n    def test_from_path(self, mocker):\n        match = object()\n        get_new_command = object()\n        load_source = mocker.patch(\n            'thefuck.types.load_source',\n            return_value=Mock(match=match,\n                              get_new_command=get_new_command,\n                              enabled_by_default=True,\n                              priority=900,\n                              requires_output=True))\n        rule_path = os.path.join(os.sep, 'rules', 'bash.py')\n        assert (Rule.from_path(Path(rule_path))\n                == Rule('bash', match, get_new_command, priority=900))\n        load_source.assert_called_once_with('bash', rule_path)\n\n    @pytest.mark.parametrize('rules, exclude_rules, rule, is_enabled', [\n        (const.DEFAULT_RULES, [], Rule('git', enabled_by_default=True), True),\n        (const.DEFAULT_RULES, [], Rule('git', enabled_by_default=False), False),\n        ([], [], Rule('git', enabled_by_default=False), False),\n        ([], [], Rule('git', enabled_by_default=True), False),\n        (const.DEFAULT_RULES + ['git'], [], Rule('git', enabled_by_default=False), True),\n        (['git'], [], Rule('git', enabled_by_default=False), True),\n        (const.DEFAULT_RULES, ['git'], Rule('git', enabled_by_default=True), False),\n        (const.DEFAULT_RULES, ['git'], Rule('git', enabled_by_default=False), False),\n        ([], ['git'], Rule('git', enabled_by_default=True), False),\n        ([], ['git'], Rule('git', enabled_by_default=False), False)])\n    def test_is_enabled(self, settings, rules, exclude_rules, rule, is_enabled):\n        settings.update(rules=rules,\n                        exclude_rules=exclude_rules)\n        assert rule.is_enabled == is_enabled\n\n    def test_isnt_match(self):\n        assert not Rule('', lambda _: False).is_match(\n            Command('ls', ''))\n\n    def test_is_match(self):\n        rule = Rule('', lambda x: x.script == 'cd ..')\n        assert rule.is_match(Command('cd ..', ''))\n\n    @pytest.mark.usefixtures('no_colors')\n    def test_isnt_match_when_rule_failed(self, capsys):\n        rule = Rule('test', Mock(side_effect=OSError('Denied')),\n                    requires_output=False)\n        assert not rule.is_match(Command('ls', ''))\n        assert capsys.readouterr()[1].split('\\n')[0] == '[WARN] Rule test:'\n\n    def test_get_corrected_commands_with_rule_returns_list(self):\n        rule = Rule(get_new_command=lambda x: [x.script + '!', x.script + '@'],\n                    priority=100)\n        assert (list(rule.get_corrected_commands(Command('test', '')))\n                == [CorrectedCommand(script='test!', priority=100),\n                    CorrectedCommand(script='test@', priority=200)])\n\n    def test_get_corrected_commands_with_rule_returns_command(self):\n        rule = Rule(get_new_command=lambda x: x.script + '!',\n                    priority=100)\n        assert (list(rule.get_corrected_commands(Command('test', '')))\n                == [CorrectedCommand(script='test!', priority=100)])\n\n\nclass TestCommand(object):\n    @pytest.fixture(autouse=True)\n    def Popen(self, monkeypatch):\n        Popen = Mock()\n        Popen.return_value.stdout.read.return_value = b'output'\n        monkeypatch.setattr('thefuck.output_readers.rerun.Popen', Popen)\n        return Popen\n\n    @pytest.fixture(autouse=True)\n    def prepare(self, monkeypatch):\n        monkeypatch.setattr('thefuck.output_readers.rerun._wait_output',\n                            lambda *_: True)\n\n    def test_from_script_calls(self, Popen, settings, os_environ):\n        settings.env = {}\n        assert Command.from_raw_script(\n            ['apt-get', 'search', 'vim']) == Command(\n            'apt-get search vim', 'output')\n        Popen.assert_called_once_with('apt-get search vim',\n                                      shell=True,\n                                      stdin=PIPE,\n                                      stdout=PIPE,\n                                      stderr=STDOUT,\n                                      env=os_environ)\n\n    @pytest.mark.parametrize('script, result', [\n        ([''], None),\n        (['', ''], None),\n        (['ls', '-la'], 'ls -la'),\n        (['ls'], 'ls')])\n    def test_from_script(self, script, result):\n        if result:\n            assert Command.from_raw_script(script).script == result\n        else:\n            with pytest.raises(EmptyCommand):\n                Command.from_raw_script(script)\n", "description": "Magnificent app which corrects your previous console command.", "file_name": "test_types.py", "language": "Python", "project_name": "thefuck", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/nvbn_thefuck/nvbn-thefuck-284d49d/tests/test_types.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:34:29Z", "url": "https://github.com/nvbn/thefuck", "wiki": true}