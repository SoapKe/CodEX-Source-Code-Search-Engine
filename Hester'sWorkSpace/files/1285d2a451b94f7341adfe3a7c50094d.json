{"author": "mwaskom", "code": "import warnings\nimport colorsys\nimport numpy as np\nimport matplotlib as mpl\n\nimport nose.tools as nt\nimport numpy.testing as npt\n\nfrom .. import palettes, utils, rcmod\nfrom ..external import husl\nfrom ..colors import xkcd_rgb, crayons\n\n\nclass TestColorPalettes(object):\n\n    def test_current_palette(self):\n\n        pal = palettes.color_palette([\"red\", \"blue\", \"green\"], 3)\n        rcmod.set_palette(pal, 3)\n        nt.assert_equal(pal, utils.get_color_cycle())\n        rcmod.set()\n\n    def test_palette_context(self):\n\n        default_pal = palettes.color_palette()\n        context_pal = palettes.color_palette(\"muted\")\n\n        with palettes.color_palette(context_pal):\n            nt.assert_equal(utils.get_color_cycle(), context_pal)\n\n        nt.assert_equal(utils.get_color_cycle(), default_pal)\n\n    def test_big_palette_context(self):\n\n        original_pal = palettes.color_palette(\"deep\", n_colors=8)\n        context_pal = palettes.color_palette(\"husl\", 10)\n\n        rcmod.set_palette(original_pal)\n        with palettes.color_palette(context_pal, 10):\n            nt.assert_equal(utils.get_color_cycle(), context_pal)\n\n        nt.assert_equal(utils.get_color_cycle(), original_pal)\n\n        \n        rcmod.set()\n\n    def test_seaborn_palettes(self):\n\n        pals = \"deep\", \"muted\", \"pastel\", \"bright\", \"dark\", \"colorblind\"\n        for name in pals:\n            pal_out = palettes.color_palette(name)\n            nt.assert_equal(len(pal_out), 6)\n\n    def test_hls_palette(self):\n\n        hls_pal1 = palettes.hls_palette()\n        hls_pal2 = palettes.color_palette(\"hls\")\n        npt.assert_array_equal(hls_pal1, hls_pal2)\n\n    def test_husl_palette(self):\n\n        husl_pal1 = palettes.husl_palette()\n        husl_pal2 = palettes.color_palette(\"husl\")\n        npt.assert_array_equal(husl_pal1, husl_pal2)\n\n    def test_mpl_palette(self):\n\n        mpl_pal1 = palettes.mpl_palette(\"Reds\")\n        mpl_pal2 = palettes.color_palette(\"Reds\")\n        npt.assert_array_equal(mpl_pal1, mpl_pal2)\n\n    def test_mpl_dark_palette(self):\n\n        mpl_pal1 = palettes.mpl_palette(\"Blues_d\")\n        mpl_pal2 = palettes.color_palette(\"Blues_d\")\n        npt.assert_array_equal(mpl_pal1, mpl_pal2)\n\n    def test_bad_palette_name(self):\n\n        with nt.assert_raises(ValueError):\n            palettes.color_palette(\"IAmNotAPalette\")\n\n    def test_terrible_palette_name(self):\n\n        with nt.assert_raises(ValueError):\n            palettes.color_palette(\"jet\")\n\n    def test_bad_palette_colors(self):\n\n        pal = [\"red\", \"blue\", \"iamnotacolor\"]\n        with nt.assert_raises(ValueError):\n            palettes.color_palette(pal)\n\n    def test_palette_desat(self):\n\n        pal1 = palettes.husl_palette(6)\n        pal1 = [utils.desaturate(c, .5) for c in pal1]\n        pal2 = palettes.color_palette(\"husl\", desat=.5)\n        npt.assert_array_equal(pal1, pal2)\n\n    def test_palette_is_list_of_tuples(self):\n\n        pal_in = np.array([\"red\", \"blue\", \"green\"])\n        pal_out = palettes.color_palette(pal_in, 3)\n\n        nt.assert_is_instance(pal_out, list)\n        nt.assert_is_instance(pal_out[0], tuple)\n        nt.assert_is_instance(pal_out[0][0], float)\n        nt.assert_equal(len(pal_out[0]), 3)\n\n    def test_palette_cycles(self):\n\n        deep = palettes.color_palette(\"deep\")\n        double_deep = palettes.color_palette(\"deep\", 12)\n        nt.assert_equal(double_deep, deep + deep)\n\n    def test_hls_values(self):\n\n        pal1 = palettes.hls_palette(6, h=0)\n        pal2 = palettes.hls_palette(6, h=.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n\n        pal_dark = palettes.hls_palette(5, l=.2)\n        pal_bright = palettes.hls_palette(5, l=.8)\n        npt.assert_array_less(list(map(sum, pal_dark)),\n                              list(map(sum, pal_bright)))\n\n        pal_flat = palettes.hls_palette(5, s=.1)\n        pal_bold = palettes.hls_palette(5, s=.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)),\n                              list(map(np.std, pal_bold)))\n\n    def test_husl_values(self):\n\n        pal1 = palettes.husl_palette(6, h=0)\n        pal2 = palettes.husl_palette(6, h=.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n\n        pal_dark = palettes.husl_palette(5, l=.2)\n        pal_bright = palettes.husl_palette(5, l=.8)\n        npt.assert_array_less(list(map(sum, pal_dark)),\n                              list(map(sum, pal_bright)))\n\n        pal_flat = palettes.husl_palette(5, s=.1)\n        pal_bold = palettes.husl_palette(5, s=.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)),\n                              list(map(np.std, pal_bold)))\n\n    def test_cbrewer_qual(self):\n\n        pal_short = palettes.mpl_palette(\"Set1\", 4)\n        pal_long = palettes.mpl_palette(\"Set1\", 6)\n        nt.assert_equal(pal_short, pal_long[:4])\n\n        pal_full = palettes.mpl_palette(\"Set2\", 8)\n        pal_long = palettes.mpl_palette(\"Set2\", 10)\n        nt.assert_equal(pal_full, pal_long[:8])\n\n    def test_mpl_reversal(self):\n\n        pal_forward = palettes.mpl_palette(\"BuPu\", 6)\n        pal_reverse = palettes.mpl_palette(\"BuPu_r\", 6)\n        npt.assert_array_almost_equal(pal_forward, pal_reverse[::-1])\n\n    def test_rgb_from_hls(self):\n\n        color = .5, .8, .4\n        rgb_got = palettes._color_to_rgb(color, \"hls\")\n        rgb_want = colorsys.hls_to_rgb(*color)\n        nt.assert_equal(rgb_got, rgb_want)\n\n    def test_rgb_from_husl(self):\n\n        color = 120, 50, 40\n        rgb_got = palettes._color_to_rgb(color, \"husl\")\n        rgb_want = husl.husl_to_rgb(*color)\n        nt.assert_equal(rgb_got, rgb_want)\n\n    def test_rgb_from_xkcd(self):\n\n        color = \"dull red\"\n        rgb_got = palettes._color_to_rgb(color, \"xkcd\")\n        rgb_want = xkcd_rgb[color]\n        nt.assert_equal(rgb_got, rgb_want)\n\n    def test_light_palette(self):\n\n        pal_forward = palettes.light_palette(\"red\")\n        pal_reverse = palettes.light_palette(\"red\", reverse=True)\n        npt.assert_array_almost_equal(pal_forward, pal_reverse[::-1])\n\n        red = tuple(mpl.colors.colorConverter.to_rgba(\"red\"))\n        nt.assert_equal(tuple(pal_forward[-1]), red)\n\n        pal_cmap = palettes.light_palette(\"blue\", as_cmap=True)\n        nt.assert_is_instance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n\n    def test_dark_palette(self):\n\n        pal_forward = palettes.dark_palette(\"red\")\n        pal_reverse = palettes.dark_palette(\"red\", reverse=True)\n        npt.assert_array_almost_equal(pal_forward, pal_reverse[::-1])\n\n        red = tuple(mpl.colors.colorConverter.to_rgba(\"red\"))\n        nt.assert_equal(tuple(pal_forward[-1]), red)\n\n        pal_cmap = palettes.dark_palette(\"blue\", as_cmap=True)\n        nt.assert_is_instance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n\n    def test_blend_palette(self):\n\n        colors = [\"red\", \"yellow\", \"white\"]\n        pal_cmap = palettes.blend_palette(colors, as_cmap=True)\n        nt.assert_is_instance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n\n    def test_cubehelix_against_matplotlib(self):\n\n        x = np.linspace(0, 1, 8)\n        mpl_pal = mpl.cm.cubehelix(x)[:, :3].tolist()\n\n        sns_pal = palettes.cubehelix_palette(8, start=0.5, rot=-1.5, hue=1,\n                                             dark=0, light=1, reverse=True)\n\n        nt.assert_list_equal(sns_pal, mpl_pal)\n\n    def test_cubehelix_n_colors(self):\n\n        for n in [3, 5, 8]:\n            pal = palettes.cubehelix_palette(n)\n            nt.assert_equal(len(pal), n)\n\n    def test_cubehelix_reverse(self):\n\n        pal_forward = palettes.cubehelix_palette()\n        pal_reverse = palettes.cubehelix_palette(reverse=True)\n        nt.assert_list_equal(pal_forward, pal_reverse[::-1])\n\n    def test_cubehelix_cmap(self):\n\n        cmap = palettes.cubehelix_palette(as_cmap=True)\n        nt.assert_is_instance(cmap, mpl.colors.ListedColormap)\n        pal = palettes.cubehelix_palette()\n        x = np.linspace(0, 1, 6)\n        npt.assert_array_equal(cmap(x)[:, :3], pal)\n\n        cmap_rev = palettes.cubehelix_palette(as_cmap=True, reverse=True)\n        x = np.linspace(0, 1, 6)\n        pal_forward = cmap(x).tolist()\n        pal_reverse = cmap_rev(x[::-1]).tolist()\n        nt.assert_list_equal(pal_forward, pal_reverse)\n\n    def test_xkcd_palette(self):\n\n        names = list(xkcd_rgb.keys())[10:15]\n        colors = palettes.xkcd_palette(names)\n        for name, color in zip(names, colors):\n            as_hex = mpl.colors.rgb2hex(color)\n            nt.assert_equal(as_hex, xkcd_rgb[name])\n\n    def test_crayon_palette(self):\n\n        names = list(crayons.keys())[10:15]\n        colors = palettes.crayon_palette(names)\n        for name, color in zip(names, colors):\n            as_hex = mpl.colors.rgb2hex(color)\n            nt.assert_equal(as_hex, crayons[name].lower())\n\n    def test_color_codes(self):\n\n        palettes.set_color_codes(\"deep\")\n        colors = palettes.color_palette(\"deep\") + [\".1\"]\n        for code, color in zip(\"bgrmyck\", colors):\n            rgb_want = mpl.colors.colorConverter.to_rgb(color)\n            rgb_got = mpl.colors.colorConverter.to_rgb(code)\n            nt.assert_equal(rgb_want, rgb_got)\n        palettes.set_color_codes(\"reset\")\n\n    def test_as_hex(self):\n\n        pal = palettes.color_palette(\"deep\")\n        for rgb, hex in zip(pal, pal.as_hex()):\n            nt.assert_equal(mpl.colors.rgb2hex(rgb), hex)\n\n    def test_preserved_palette_length(self):\n\n        pal_in = palettes.color_palette(\"Set1\", 10)\n        pal_out = palettes.color_palette(pal_in)\n        nt.assert_equal(pal_in, pal_out)\n\n    def test_get_color_cycle(self):\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')\n            result = utils.get_color_cycle()\n            expected = mpl.rcParams['axes.color_cycle']\n        nt.assert_equal(result, expected)\n", "comments": "  reset default ", "content": "import warnings\nimport colorsys\nimport numpy as np\nimport matplotlib as mpl\n\nimport nose.tools as nt\nimport numpy.testing as npt\n\nfrom .. import palettes, utils, rcmod\nfrom ..external import husl\nfrom ..colors import xkcd_rgb, crayons\n\n\nclass TestColorPalettes(object):\n\n    def test_current_palette(self):\n\n        pal = palettes.color_palette([\"red\", \"blue\", \"green\"], 3)\n        rcmod.set_palette(pal, 3)\n        nt.assert_equal(pal, utils.get_color_cycle())\n        rcmod.set()\n\n    def test_palette_context(self):\n\n        default_pal = palettes.color_palette()\n        context_pal = palettes.color_palette(\"muted\")\n\n        with palettes.color_palette(context_pal):\n            nt.assert_equal(utils.get_color_cycle(), context_pal)\n\n        nt.assert_equal(utils.get_color_cycle(), default_pal)\n\n    def test_big_palette_context(self):\n\n        original_pal = palettes.color_palette(\"deep\", n_colors=8)\n        context_pal = palettes.color_palette(\"husl\", 10)\n\n        rcmod.set_palette(original_pal)\n        with palettes.color_palette(context_pal, 10):\n            nt.assert_equal(utils.get_color_cycle(), context_pal)\n\n        nt.assert_equal(utils.get_color_cycle(), original_pal)\n\n        # Reset default\n        rcmod.set()\n\n    def test_seaborn_palettes(self):\n\n        pals = \"deep\", \"muted\", \"pastel\", \"bright\", \"dark\", \"colorblind\"\n        for name in pals:\n            pal_out = palettes.color_palette(name)\n            nt.assert_equal(len(pal_out), 6)\n\n    def test_hls_palette(self):\n\n        hls_pal1 = palettes.hls_palette()\n        hls_pal2 = palettes.color_palette(\"hls\")\n        npt.assert_array_equal(hls_pal1, hls_pal2)\n\n    def test_husl_palette(self):\n\n        husl_pal1 = palettes.husl_palette()\n        husl_pal2 = palettes.color_palette(\"husl\")\n        npt.assert_array_equal(husl_pal1, husl_pal2)\n\n    def test_mpl_palette(self):\n\n        mpl_pal1 = palettes.mpl_palette(\"Reds\")\n        mpl_pal2 = palettes.color_palette(\"Reds\")\n        npt.assert_array_equal(mpl_pal1, mpl_pal2)\n\n    def test_mpl_dark_palette(self):\n\n        mpl_pal1 = palettes.mpl_palette(\"Blues_d\")\n        mpl_pal2 = palettes.color_palette(\"Blues_d\")\n        npt.assert_array_equal(mpl_pal1, mpl_pal2)\n\n    def test_bad_palette_name(self):\n\n        with nt.assert_raises(ValueError):\n            palettes.color_palette(\"IAmNotAPalette\")\n\n    def test_terrible_palette_name(self):\n\n        with nt.assert_raises(ValueError):\n            palettes.color_palette(\"jet\")\n\n    def test_bad_palette_colors(self):\n\n        pal = [\"red\", \"blue\", \"iamnotacolor\"]\n        with nt.assert_raises(ValueError):\n            palettes.color_palette(pal)\n\n    def test_palette_desat(self):\n\n        pal1 = palettes.husl_palette(6)\n        pal1 = [utils.desaturate(c, .5) for c in pal1]\n        pal2 = palettes.color_palette(\"husl\", desat=.5)\n        npt.assert_array_equal(pal1, pal2)\n\n    def test_palette_is_list_of_tuples(self):\n\n        pal_in = np.array([\"red\", \"blue\", \"green\"])\n        pal_out = palettes.color_palette(pal_in, 3)\n\n        nt.assert_is_instance(pal_out, list)\n        nt.assert_is_instance(pal_out[0], tuple)\n        nt.assert_is_instance(pal_out[0][0], float)\n        nt.assert_equal(len(pal_out[0]), 3)\n\n    def test_palette_cycles(self):\n\n        deep = palettes.color_palette(\"deep\")\n        double_deep = palettes.color_palette(\"deep\", 12)\n        nt.assert_equal(double_deep, deep + deep)\n\n    def test_hls_values(self):\n\n        pal1 = palettes.hls_palette(6, h=0)\n        pal2 = palettes.hls_palette(6, h=.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n\n        pal_dark = palettes.hls_palette(5, l=.2)\n        pal_bright = palettes.hls_palette(5, l=.8)\n        npt.assert_array_less(list(map(sum, pal_dark)),\n                              list(map(sum, pal_bright)))\n\n        pal_flat = palettes.hls_palette(5, s=.1)\n        pal_bold = palettes.hls_palette(5, s=.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)),\n                              list(map(np.std, pal_bold)))\n\n    def test_husl_values(self):\n\n        pal1 = palettes.husl_palette(6, h=0)\n        pal2 = palettes.husl_palette(6, h=.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n\n        pal_dark = palettes.husl_palette(5, l=.2)\n        pal_bright = palettes.husl_palette(5, l=.8)\n        npt.assert_array_less(list(map(sum, pal_dark)),\n                              list(map(sum, pal_bright)))\n\n        pal_flat = palettes.husl_palette(5, s=.1)\n        pal_bold = palettes.husl_palette(5, s=.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)),\n                              list(map(np.std, pal_bold)))\n\n    def test_cbrewer_qual(self):\n\n        pal_short = palettes.mpl_palette(\"Set1\", 4)\n        pal_long = palettes.mpl_palette(\"Set1\", 6)\n        nt.assert_equal(pal_short, pal_long[:4])\n\n        pal_full = palettes.mpl_palette(\"Set2\", 8)\n        pal_long = palettes.mpl_palette(\"Set2\", 10)\n        nt.assert_equal(pal_full, pal_long[:8])\n\n    def test_mpl_reversal(self):\n\n        pal_forward = palettes.mpl_palette(\"BuPu\", 6)\n        pal_reverse = palettes.mpl_palette(\"BuPu_r\", 6)\n        npt.assert_array_almost_equal(pal_forward, pal_reverse[::-1])\n\n    def test_rgb_from_hls(self):\n\n        color = .5, .8, .4\n        rgb_got = palettes._color_to_rgb(color, \"hls\")\n        rgb_want = colorsys.hls_to_rgb(*color)\n        nt.assert_equal(rgb_got, rgb_want)\n\n    def test_rgb_from_husl(self):\n\n        color = 120, 50, 40\n        rgb_got = palettes._color_to_rgb(color, \"husl\")\n        rgb_want = husl.husl_to_rgb(*color)\n        nt.assert_equal(rgb_got, rgb_want)\n\n    def test_rgb_from_xkcd(self):\n\n        color = \"dull red\"\n        rgb_got = palettes._color_to_rgb(color, \"xkcd\")\n        rgb_want = xkcd_rgb[color]\n        nt.assert_equal(rgb_got, rgb_want)\n\n    def test_light_palette(self):\n\n        pal_forward = palettes.light_palette(\"red\")\n        pal_reverse = palettes.light_palette(\"red\", reverse=True)\n        npt.assert_array_almost_equal(pal_forward, pal_reverse[::-1])\n\n        red = tuple(mpl.colors.colorConverter.to_rgba(\"red\"))\n        nt.assert_equal(tuple(pal_forward[-1]), red)\n\n        pal_cmap = palettes.light_palette(\"blue\", as_cmap=True)\n        nt.assert_is_instance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n\n    def test_dark_palette(self):\n\n        pal_forward = palettes.dark_palette(\"red\")\n        pal_reverse = palettes.dark_palette(\"red\", reverse=True)\n        npt.assert_array_almost_equal(pal_forward, pal_reverse[::-1])\n\n        red = tuple(mpl.colors.colorConverter.to_rgba(\"red\"))\n        nt.assert_equal(tuple(pal_forward[-1]), red)\n\n        pal_cmap = palettes.dark_palette(\"blue\", as_cmap=True)\n        nt.assert_is_instance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n\n    def test_blend_palette(self):\n\n        colors = [\"red\", \"yellow\", \"white\"]\n        pal_cmap = palettes.blend_palette(colors, as_cmap=True)\n        nt.assert_is_instance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n\n    def test_cubehelix_against_matplotlib(self):\n\n        x = np.linspace(0, 1, 8)\n        mpl_pal = mpl.cm.cubehelix(x)[:, :3].tolist()\n\n        sns_pal = palettes.cubehelix_palette(8, start=0.5, rot=-1.5, hue=1,\n                                             dark=0, light=1, reverse=True)\n\n        nt.assert_list_equal(sns_pal, mpl_pal)\n\n    def test_cubehelix_n_colors(self):\n\n        for n in [3, 5, 8]:\n            pal = palettes.cubehelix_palette(n)\n            nt.assert_equal(len(pal), n)\n\n    def test_cubehelix_reverse(self):\n\n        pal_forward = palettes.cubehelix_palette()\n        pal_reverse = palettes.cubehelix_palette(reverse=True)\n        nt.assert_list_equal(pal_forward, pal_reverse[::-1])\n\n    def test_cubehelix_cmap(self):\n\n        cmap = palettes.cubehelix_palette(as_cmap=True)\n        nt.assert_is_instance(cmap, mpl.colors.ListedColormap)\n        pal = palettes.cubehelix_palette()\n        x = np.linspace(0, 1, 6)\n        npt.assert_array_equal(cmap(x)[:, :3], pal)\n\n        cmap_rev = palettes.cubehelix_palette(as_cmap=True, reverse=True)\n        x = np.linspace(0, 1, 6)\n        pal_forward = cmap(x).tolist()\n        pal_reverse = cmap_rev(x[::-1]).tolist()\n        nt.assert_list_equal(pal_forward, pal_reverse)\n\n    def test_xkcd_palette(self):\n\n        names = list(xkcd_rgb.keys())[10:15]\n        colors = palettes.xkcd_palette(names)\n        for name, color in zip(names, colors):\n            as_hex = mpl.colors.rgb2hex(color)\n            nt.assert_equal(as_hex, xkcd_rgb[name])\n\n    def test_crayon_palette(self):\n\n        names = list(crayons.keys())[10:15]\n        colors = palettes.crayon_palette(names)\n        for name, color in zip(names, colors):\n            as_hex = mpl.colors.rgb2hex(color)\n            nt.assert_equal(as_hex, crayons[name].lower())\n\n    def test_color_codes(self):\n\n        palettes.set_color_codes(\"deep\")\n        colors = palettes.color_palette(\"deep\") + [\".1\"]\n        for code, color in zip(\"bgrmyck\", colors):\n            rgb_want = mpl.colors.colorConverter.to_rgb(color)\n            rgb_got = mpl.colors.colorConverter.to_rgb(code)\n            nt.assert_equal(rgb_want, rgb_got)\n        palettes.set_color_codes(\"reset\")\n\n    def test_as_hex(self):\n\n        pal = palettes.color_palette(\"deep\")\n        for rgb, hex in zip(pal, pal.as_hex()):\n            nt.assert_equal(mpl.colors.rgb2hex(rgb), hex)\n\n    def test_preserved_palette_length(self):\n\n        pal_in = palettes.color_palette(\"Set1\", 10)\n        pal_out = palettes.color_palette(pal_in)\n        nt.assert_equal(pal_in, pal_out)\n\n    def test_get_color_cycle(self):\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')\n            result = utils.get_color_cycle()\n            expected = mpl.rcParams['axes.color_cycle']\n        nt.assert_equal(result, expected)\n", "description": "Statistical data visualization using matplotlib", "file_name": "test_palettes.py", "id": "1285d2a451b94f7341adfe3a7c50094d", "language": "Python", "project_name": "seaborn", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mwaskom-seaborn/mwaskom-seaborn-71a807b/seaborn/tests/test_palettes.py", "save_time": "", "source": "", "update_at": "2018-03-18T02:14:24Z", "url": "https://github.com/mwaskom/seaborn", "wiki": false}