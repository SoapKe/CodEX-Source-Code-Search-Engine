{"author": "facebook", "code": "\n\n Copyright (c) 2014, Facebook, Inc.\n\n\n This source code is licensed under the BSD-style license found in the\n LICENSE file in the root directory of this source tree. An additional grant\n of patent rights can be found in the PATENTS file in the same directory.\n\nimport lldb\n\nimport imp\nimport os\n\nfrom optparse import OptionParser\n\nimport fblldbbase as fb\n\ndef __lldb_init_module(debugger, dict):\n  filePath = os.path.realpath(__file__)\n  lldbHelperDir = os.path.dirname(filePath)\n\n  commandsDirectory = os.path.join(lldbHelperDir, 'commands')\n  loadCommandsInDirectory(commandsDirectory)\n\ndef loadCommandsInDirectory(commandsDirectory):\n  for file in os.listdir(commandsDirectory):\n    fileName, fileExtension = os.path.splitext(file)\n    if fileExtension == '.py':\n      module = imp.load_source(fileName, os.path.join(commandsDirectory, file))\n\n      if hasattr(module, 'lldbinit'):\n        module.lldbinit()\n\n      if hasattr(module, 'lldbcommands'):\n        module._loadedFunctions = {}\n        for command in module.lldbcommands():\n          loadCommand(module, command, commandsDirectory, fileName, fileExtension)\n\ndef loadCommand(module, command, directory, filename, extension):\n  func = makeRunCommand(command, os.path.join(directory, filename + extension))\n  name = command.name()\n  helpText = command.description().strip().splitlines()[0]  first line of description\n\n  key = filename + '_' + name\n\n  module._loadedFunctions[key] = func\n\n  functionName = '__' + key\n\n  lldb.debugger.HandleCommand('script ' + functionName + ' = sys.modules[\\'' + module.__name__ + '\\']._loadedFunctions[\\'' + key + '\\']')\n  lldb.debugger.HandleCommand('command script add --help \"{help}\" --function {function} {name}'.format(\n    help=helpText.replace('\"', '\\\\\"'),  escape quotes\n    function=functionName,\n    name=name))\n\ndef makeRunCommand(command, filename):\n  def runCommand(debugger, input, exe_ctx, result, _):\n    command.result = result\n    command.context = exe_ctx\n    splitInput = command.lex(input)\n\n     OptionParser will throw in the case where you want just one big long argument and no\n     options and you enter something that starts with '-' in the argument. e.g.:\n         somecommand -[SomeClass someSelector:]\n     This solves that problem by prepending a '--' so that OptionParser does the right\n     thing.\n    options = command.options()\n    if len(options) == 0:\n      if '--' not in splitInput:\n        splitInput.insert(0, '--')\n\n    parser = optionParserForCommand(command)\n    (options, args) = parser.parse_args(splitInput)\n\n     When there are more args than the command has declared, assume\n     the initial args form an expression and combine them into a single arg.\n    if len(args) > len(command.args()):\n      overhead = len(args) - len(command.args())\n      head = args[:overhead + 1]  Take N+1 and reduce to 1.\n      args = [' '.join(head)] + args[-overhead:]\n\n    if validateArgsForCommand(args, command):\n      command.run(args, options)\n\n  runCommand.__doc__ = helpForCommand(command, filename)\n  return runCommand\n\ndef validateArgsForCommand(args, command):\n  if len(args) < len(command.args()):\n    defaultArgs = [arg.default for arg in command.args()]\n    defaultArgsToAppend = defaultArgs[len(args):]\n\n    index = len(args)\n    for defaultArg in defaultArgsToAppend:\n      if not defaultArg:\n        arg = command.args()[index]\n        print 'Whoops! You are missing the <' + arg.argName + '> argument.'\n        print '\\nUsage: ' + usageForCommand(command)\n        return\n      index += 1\n\n    args.extend(defaultArgsToAppend)\n  return True\n\ndef optionParserForCommand(command):\n  parser = OptionParser()\n\n  for argument in command.options():\n    if argument.boolean:\n      parser.add_option(argument.shortName, argument.longName, dest=argument.argName,\n                        help=argument.help, action=(\"store_false\" if argument.default else \"store_true\"))\n    else:\n      parser.add_option(argument.shortName, argument.longName, dest=argument.argName,\n                        help=argument.help, default=argument.default)\n\n  return parser\n\ndef helpForCommand(command, filename):\n  help = command.description()\n\n  argSyntax = ''\n  optionSyntax = ''\n\n  if command.args():\n    help += '\\n\\nArguments:'\n    for arg in command.args():\n      help += '\\n  <' + arg.argName + '>; '\n      if arg.argType:\n        help += 'Type: ' + arg.argType + '; '\n      help += arg.help\n      argSyntax += ' <' + arg.argName + '>'\n\n  if command.options():\n    help += '\\n\\nOptions:'\n    for option in command.options():\n\n      if option.longName and option.shortName:\n        optionFlag = option.longName + '/' + option.shortName\n      elif option.longName:\n        optionFlag = option.longName\n      else:\n        optionFlag = option.shortName\n\n      help += '\\n  ' + optionFlag + ' '\n\n      if not option.boolean:\n        help += '<' + option.argName + '>; Type: ' + option.argType\n\n      help += '; ' + option.help\n\n      optionSyntax += ' [{name}{arg}]'.format(\n        name=(option.longName or option.shortName),\n        arg=('' if option.boolean else ('=' + option.argName))\n      )\n\n  help += '\\n\\nSyntax: ' + command.name() + optionSyntax + argSyntax\n\n  help += '\\n\\nThis command is implemented as %s in %s.' % (command.__class__.__name__, filename)\n\n  return help\n\ndef usageForCommand(command):\n  usage = command.name()\n  for arg in command.args():\n    if arg.default:\n      usage += ' [' + arg.argName + ']'\n    else:\n      usage += ' ' + arg.argName\n\n  return usage\n", "comments": "   usr bin python    copyright (c) 2014  facebook  inc     all rights reserved        this source code licensed bsd style license found    license file root directory source tree  an additional grant    patent rights found patents file directory     first line description    escape quotes    optionparser throw case want one big long argument    options enter something starts     argument  e g          somecommand   someclass someselector      this solves problem prepending      optionparser right    thing     when args command declared  assume    initial args form expression combine single arg     take n 1 reduce 1  ", "content": "#!/usr/bin/python\n\n# Copyright (c) 2014, Facebook, Inc.\n# All rights reserved.\n#\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree. An additional grant\n# of patent rights can be found in the PATENTS file in the same directory.\n\nimport lldb\n\nimport imp\nimport os\n\nfrom optparse import OptionParser\n\nimport fblldbbase as fb\n\ndef __lldb_init_module(debugger, dict):\n  filePath = os.path.realpath(__file__)\n  lldbHelperDir = os.path.dirname(filePath)\n\n  commandsDirectory = os.path.join(lldbHelperDir, 'commands')\n  loadCommandsInDirectory(commandsDirectory)\n\ndef loadCommandsInDirectory(commandsDirectory):\n  for file in os.listdir(commandsDirectory):\n    fileName, fileExtension = os.path.splitext(file)\n    if fileExtension == '.py':\n      module = imp.load_source(fileName, os.path.join(commandsDirectory, file))\n\n      if hasattr(module, 'lldbinit'):\n        module.lldbinit()\n\n      if hasattr(module, 'lldbcommands'):\n        module._loadedFunctions = {}\n        for command in module.lldbcommands():\n          loadCommand(module, command, commandsDirectory, fileName, fileExtension)\n\ndef loadCommand(module, command, directory, filename, extension):\n  func = makeRunCommand(command, os.path.join(directory, filename + extension))\n  name = command.name()\n  helpText = command.description().strip().splitlines()[0] # first line of description\n\n  key = filename + '_' + name\n\n  module._loadedFunctions[key] = func\n\n  functionName = '__' + key\n\n  lldb.debugger.HandleCommand('script ' + functionName + ' = sys.modules[\\'' + module.__name__ + '\\']._loadedFunctions[\\'' + key + '\\']')\n  lldb.debugger.HandleCommand('command script add --help \"{help}\" --function {function} {name}'.format(\n    help=helpText.replace('\"', '\\\\\"'), # escape quotes\n    function=functionName,\n    name=name))\n\ndef makeRunCommand(command, filename):\n  def runCommand(debugger, input, exe_ctx, result, _):\n    command.result = result\n    command.context = exe_ctx\n    splitInput = command.lex(input)\n\n    # OptionParser will throw in the case where you want just one big long argument and no\n    # options and you enter something that starts with '-' in the argument. e.g.:\n    #     somecommand -[SomeClass someSelector:]\n    # This solves that problem by prepending a '--' so that OptionParser does the right\n    # thing.\n    options = command.options()\n    if len(options) == 0:\n      if '--' not in splitInput:\n        splitInput.insert(0, '--')\n\n    parser = optionParserForCommand(command)\n    (options, args) = parser.parse_args(splitInput)\n\n    # When there are more args than the command has declared, assume\n    # the initial args form an expression and combine them into a single arg.\n    if len(args) > len(command.args()):\n      overhead = len(args) - len(command.args())\n      head = args[:overhead + 1] # Take N+1 and reduce to 1.\n      args = [' '.join(head)] + args[-overhead:]\n\n    if validateArgsForCommand(args, command):\n      command.run(args, options)\n\n  runCommand.__doc__ = helpForCommand(command, filename)\n  return runCommand\n\ndef validateArgsForCommand(args, command):\n  if len(args) < len(command.args()):\n    defaultArgs = [arg.default for arg in command.args()]\n    defaultArgsToAppend = defaultArgs[len(args):]\n\n    index = len(args)\n    for defaultArg in defaultArgsToAppend:\n      if not defaultArg:\n        arg = command.args()[index]\n        print 'Whoops! You are missing the <' + arg.argName + '> argument.'\n        print '\\nUsage: ' + usageForCommand(command)\n        return\n      index += 1\n\n    args.extend(defaultArgsToAppend)\n  return True\n\ndef optionParserForCommand(command):\n  parser = OptionParser()\n\n  for argument in command.options():\n    if argument.boolean:\n      parser.add_option(argument.shortName, argument.longName, dest=argument.argName,\n                        help=argument.help, action=(\"store_false\" if argument.default else \"store_true\"))\n    else:\n      parser.add_option(argument.shortName, argument.longName, dest=argument.argName,\n                        help=argument.help, default=argument.default)\n\n  return parser\n\ndef helpForCommand(command, filename):\n  help = command.description()\n\n  argSyntax = ''\n  optionSyntax = ''\n\n  if command.args():\n    help += '\\n\\nArguments:'\n    for arg in command.args():\n      help += '\\n  <' + arg.argName + '>; '\n      if arg.argType:\n        help += 'Type: ' + arg.argType + '; '\n      help += arg.help\n      argSyntax += ' <' + arg.argName + '>'\n\n  if command.options():\n    help += '\\n\\nOptions:'\n    for option in command.options():\n\n      if option.longName and option.shortName:\n        optionFlag = option.longName + '/' + option.shortName\n      elif option.longName:\n        optionFlag = option.longName\n      else:\n        optionFlag = option.shortName\n\n      help += '\\n  ' + optionFlag + ' '\n\n      if not option.boolean:\n        help += '<' + option.argName + '>; Type: ' + option.argType\n\n      help += '; ' + option.help\n\n      optionSyntax += ' [{name}{arg}]'.format(\n        name=(option.longName or option.shortName),\n        arg=('' if option.boolean else ('=' + option.argName))\n      )\n\n  help += '\\n\\nSyntax: ' + command.name() + optionSyntax + argSyntax\n\n  help += '\\n\\nThis command is implemented as %s in %s.' % (command.__class__.__name__, filename)\n\n  return help\n\ndef usageForCommand(command):\n  usage = command.name()\n  for arg in command.args():\n    if arg.default:\n      usage += ' [' + arg.argName + ']'\n    else:\n      usage += ' ' + arg.argName\n\n  return usage\n", "description": "Chisel is a collection of LLDB commands to assist debugging iOS apps.", "file_name": "fblldb.py", "id": "1a067e089b576bd217c74f825f580045", "language": "Python", "project_name": "chisel", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/facebook-chisel/facebook-chisel-8312a63/fblldb.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:09:48Z", "url": "https://github.com/facebook/chisel", "wiki": true}