{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    int_or_none,\n    strip_jsonp,\n)\n\n\nclass WashingtonPostIE(InfoExtractor):\n    IE_NAME = 'washingtonpost'\n    _VALID_URL = r'(?:washingtonpost:|https?://(?:www\\.)?washingtonpost\\.com/video/(?:[^/]+/)*)(?P<id>[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12})'\n    _EMBED_URL = r'https?://(?:www\\.)?washingtonpost\\.com/video/c/embed/[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}'\n    _TEST = {\n        'url': 'https://www.washingtonpost.com/video/c/video/480ba4ee-1ec7-11e6-82c2-a7dcb313287d',\n        'md5': '6f537e1334b714eb15f9563bd4b9cdfa',\n        'info_dict': {\n            'id': '480ba4ee-1ec7-11e6-82c2-a7dcb313287d',\n            'ext': 'mp4',\n            'title': 'Egypt finds belongings, debris from plane crash',\n            'description': 'md5:a17ceee432f215a5371388c1f680bd86',\n            'upload_date': '20160520',\n            'uploader': 'Reuters',\n            'timestamp': 1463778452,\n        },\n    }\n\n    @classmethod\n    def _extract_urls(cls, webpage):\n        return re.findall(\n            r'<iframe[^>]+\\bsrc=[\"\\'](%s)' % cls._EMBED_URL, webpage)\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        video_data = self._download_json(\n            'http://www.washingtonpost.com/posttv/c/videojson/%s?resType=jsonp' % video_id,\n            video_id, transform_source=strip_jsonp)[0]['contentConfig']\n        title = video_data['title']\n\n        urls = []\n        formats = []\n        for s in video_data.get('streams', []):\n            s_url = s.get('url')\n            if not s_url or s_url in urls:\n                continue\n            urls.append(s_url)\n            video_type = s.get('type')\n            if video_type == 'smil':\n                continue\n            elif video_type in ('ts', 'hls') and ('_master.m3u8' in s_url or '_mobile.m3u8' in s_url):\n                m3u8_formats = self._extract_m3u8_formats(\n                    s_url, video_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False)\n                for m3u8_format in m3u8_formats:\n                    width = m3u8_format.get('width')\n                    if not width:\n                        continue\n                    vbr = self._search_regex(\n                        r'%d_%d_(\\d+)' % (width, m3u8_format['height']), m3u8_format['url'], 'vbr', default=None)\n                    if vbr:\n                        m3u8_format.update({\n                            'vbr': int_or_none(vbr),\n                        })\n                formats.extend(m3u8_formats)\n            else:\n                width = int_or_none(s.get('width'))\n                vbr = int_or_none(s.get('bitrate'))\n                has_width = width != 0\n                formats.append({\n                    'format_id': (\n                        '%s-%d-%d' % (video_type, width, vbr)\n                        if width\n                        else video_type),\n                    'vbr': vbr if has_width else None,\n                    'width': width,\n                    'height': int_or_none(s.get('height')),\n                    'acodec': s.get('audioCodec'),\n                    'vcodec': s.get('videoCodec') if has_width else 'none',\n                    'filesize': int_or_none(s.get('fileSize')),\n                    'url': s_url,\n                    'ext': 'mp4',\n                    'protocol': 'm3u8_native' if video_type in ('ts', 'hls') else None,\n                })\n        source_media_url = video_data.get('sourceMediaURL')\n        if source_media_url:\n            formats.append({\n                'format_id': 'source_media',\n                'url': source_media_url,\n            })\n        self._sort_formats(\n            formats, ('width', 'height', 'vbr', 'filesize', 'tbr', 'format_id'))\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': video_data.get('blurb'),\n            'uploader': video_data.get('credits', {}).get('source'),\n            'formats': formats,\n            'duration': int_or_none(video_data.get('videoDuration'), 100),\n            'timestamp': int_or_none(\n                video_data.get('dateConfig', {}).get('dateFirstPublished'), 1000),\n        }\n\n\nclass WashingtonPostArticleIE(InfoExtractor):\n    IE_NAME = 'washingtonpost:article'\n    _VALID_URL = r'https?://(?:www\\.)?washingtonpost\\.com/(?:[^/]+/)*(?P<id>[^/?\n    _TESTS = [{\n        'url': 'http://www.washingtonpost.com/sf/national/2014/03/22/sinkhole-of-bureaucracy/',\n        'info_dict': {\n            'id': 'sinkhole-of-bureaucracy',\n            'title': 'Sinkhole of bureaucracy',\n        },\n        'playlist': [{\n            'md5': 'b9be794ceb56c7267d410a13f99d801a',\n            'info_dict': {\n                'id': 'fc433c38-b146-11e3-b8b3-44b1d1cd4c1f',\n                'ext': 'mp4',\n                'title': 'Breaking Points: The Paper Mine',\n                'duration': 1290,\n                'description': 'Overly complicated paper pushing is nothing new to government bureaucracy. But the way federal retirement applications are filed may be the most outdated. David Fahrenthold explains.',\n                'uploader': 'The Washington Post',\n                'timestamp': 1395527908,\n                'upload_date': '20140322',\n            },\n        }, {\n            'md5': '1fff6a689d8770966df78c8cb6c8c17c',\n            'info_dict': {\n                'id': '41255e28-b14a-11e3-b8b3-44b1d1cd4c1f',\n                'ext': 'mp4',\n                'title': 'The town bureaucracy sustains',\n                'description': 'Underneath the friendly town of Boyers is a sea of government paperwork. In a disused limestone mine, hundreds of locals now track, file and process retirement applications for the federal government. We set out to find out what it\\'s like to do paperwork 230 feet underground.',\n                'duration': 2220,\n                'timestamp': 1395528005,\n                'upload_date': '20140322',\n                'uploader': 'The Washington Post',\n            },\n        }],\n    }, {\n        'url': 'http://www.washingtonpost.com/blogs/wonkblog/wp/2014/12/31/one-airline-figured-out-how-to-make-sure-its-airplanes-never-disappear/',\n        'info_dict': {\n            'id': 'one-airline-figured-out-how-to-make-sure-its-airplanes-never-disappear',\n            'title': 'One airline figured out how to make sure its airplanes never disappear',\n        },\n        'playlist': [{\n            'md5': 'a7c1b5634ba5e57a6a82cdffa5b1e0d0',\n            'info_dict': {\n                'id': '0e4bb54c-9065-11e4-a66f-0ca5037a597d',\n                'ext': 'mp4',\n                'description': 'Washington Post transportation reporter Ashley Halsey III explains why a plane\\'s black box needs to be recovered from a crash site instead of having its information streamed in real time throughout the flight.',\n                'upload_date': '20141230',\n                'uploader': 'The Washington Post',\n                'timestamp': 1419974765,\n                'title': 'Why black boxes don\u2019t transmit data in real time',\n            }\n        }]\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if WashingtonPostIE.suitable(url) else super(WashingtonPostArticleIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        page_id = self._match_id(url)\n        webpage = self._download_webpage(url, page_id)\n\n        title = self._og_search_title(webpage)\n\n        uuids = re.findall(r, webpage)\n        entries = [self.url_result('washingtonpost:%s' % uuid, 'WashingtonPost', uuid) for uuid in uuids]\n\n        return {\n            '_type': 'playlist',\n            'entries': entries,\n            'id': page_id,\n            'title': title,\n        }\n", "comments": "(?x)\n            (?:\n                <div\\s+class=\"posttv-video-embed[^>]*?data-uuid=|\n                data-video-uuid=\n            )\"([^\"]+)\"\n\"\n# coding: utf-8\n#]+)'\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    int_or_none,\n    strip_jsonp,\n)\n\n\nclass WashingtonPostIE(InfoExtractor):\n    IE_NAME = 'washingtonpost'\n    _VALID_URL = r'(?:washingtonpost:|https?://(?:www\\.)?washingtonpost\\.com/video/(?:[^/]+/)*)(?P<id>[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12})'\n    _EMBED_URL = r'https?://(?:www\\.)?washingtonpost\\.com/video/c/embed/[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}'\n    _TEST = {\n        'url': 'https://www.washingtonpost.com/video/c/video/480ba4ee-1ec7-11e6-82c2-a7dcb313287d',\n        'md5': '6f537e1334b714eb15f9563bd4b9cdfa',\n        'info_dict': {\n            'id': '480ba4ee-1ec7-11e6-82c2-a7dcb313287d',\n            'ext': 'mp4',\n            'title': 'Egypt finds belongings, debris from plane crash',\n            'description': 'md5:a17ceee432f215a5371388c1f680bd86',\n            'upload_date': '20160520',\n            'uploader': 'Reuters',\n            'timestamp': 1463778452,\n        },\n    }\n\n    @classmethod\n    def _extract_urls(cls, webpage):\n        return re.findall(\n            r'<iframe[^>]+\\bsrc=[\"\\'](%s)' % cls._EMBED_URL, webpage)\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        video_data = self._download_json(\n            'http://www.washingtonpost.com/posttv/c/videojson/%s?resType=jsonp' % video_id,\n            video_id, transform_source=strip_jsonp)[0]['contentConfig']\n        title = video_data['title']\n\n        urls = []\n        formats = []\n        for s in video_data.get('streams', []):\n            s_url = s.get('url')\n            if not s_url or s_url in urls:\n                continue\n            urls.append(s_url)\n            video_type = s.get('type')\n            if video_type == 'smil':\n                continue\n            elif video_type in ('ts', 'hls') and ('_master.m3u8' in s_url or '_mobile.m3u8' in s_url):\n                m3u8_formats = self._extract_m3u8_formats(\n                    s_url, video_id, 'mp4', 'm3u8_native', m3u8_id='hls', fatal=False)\n                for m3u8_format in m3u8_formats:\n                    width = m3u8_format.get('width')\n                    if not width:\n                        continue\n                    vbr = self._search_regex(\n                        r'%d_%d_(\\d+)' % (width, m3u8_format['height']), m3u8_format['url'], 'vbr', default=None)\n                    if vbr:\n                        m3u8_format.update({\n                            'vbr': int_or_none(vbr),\n                        })\n                formats.extend(m3u8_formats)\n            else:\n                width = int_or_none(s.get('width'))\n                vbr = int_or_none(s.get('bitrate'))\n                has_width = width != 0\n                formats.append({\n                    'format_id': (\n                        '%s-%d-%d' % (video_type, width, vbr)\n                        if width\n                        else video_type),\n                    'vbr': vbr if has_width else None,\n                    'width': width,\n                    'height': int_or_none(s.get('height')),\n                    'acodec': s.get('audioCodec'),\n                    'vcodec': s.get('videoCodec') if has_width else 'none',\n                    'filesize': int_or_none(s.get('fileSize')),\n                    'url': s_url,\n                    'ext': 'mp4',\n                    'protocol': 'm3u8_native' if video_type in ('ts', 'hls') else None,\n                })\n        source_media_url = video_data.get('sourceMediaURL')\n        if source_media_url:\n            formats.append({\n                'format_id': 'source_media',\n                'url': source_media_url,\n            })\n        self._sort_formats(\n            formats, ('width', 'height', 'vbr', 'filesize', 'tbr', 'format_id'))\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': video_data.get('blurb'),\n            'uploader': video_data.get('credits', {}).get('source'),\n            'formats': formats,\n            'duration': int_or_none(video_data.get('videoDuration'), 100),\n            'timestamp': int_or_none(\n                video_data.get('dateConfig', {}).get('dateFirstPublished'), 1000),\n        }\n\n\nclass WashingtonPostArticleIE(InfoExtractor):\n    IE_NAME = 'washingtonpost:article'\n    _VALID_URL = r'https?://(?:www\\.)?washingtonpost\\.com/(?:[^/]+/)*(?P<id>[^/?#]+)'\n    _TESTS = [{\n        'url': 'http://www.washingtonpost.com/sf/national/2014/03/22/sinkhole-of-bureaucracy/',\n        'info_dict': {\n            'id': 'sinkhole-of-bureaucracy',\n            'title': 'Sinkhole of bureaucracy',\n        },\n        'playlist': [{\n            'md5': 'b9be794ceb56c7267d410a13f99d801a',\n            'info_dict': {\n                'id': 'fc433c38-b146-11e3-b8b3-44b1d1cd4c1f',\n                'ext': 'mp4',\n                'title': 'Breaking Points: The Paper Mine',\n                'duration': 1290,\n                'description': 'Overly complicated paper pushing is nothing new to government bureaucracy. But the way federal retirement applications are filed may be the most outdated. David Fahrenthold explains.',\n                'uploader': 'The Washington Post',\n                'timestamp': 1395527908,\n                'upload_date': '20140322',\n            },\n        }, {\n            'md5': '1fff6a689d8770966df78c8cb6c8c17c',\n            'info_dict': {\n                'id': '41255e28-b14a-11e3-b8b3-44b1d1cd4c1f',\n                'ext': 'mp4',\n                'title': 'The town bureaucracy sustains',\n                'description': 'Underneath the friendly town of Boyers is a sea of government paperwork. In a disused limestone mine, hundreds of locals now track, file and process retirement applications for the federal government. We set out to find out what it\\'s like to do paperwork 230 feet underground.',\n                'duration': 2220,\n                'timestamp': 1395528005,\n                'upload_date': '20140322',\n                'uploader': 'The Washington Post',\n            },\n        }],\n    }, {\n        'url': 'http://www.washingtonpost.com/blogs/wonkblog/wp/2014/12/31/one-airline-figured-out-how-to-make-sure-its-airplanes-never-disappear/',\n        'info_dict': {\n            'id': 'one-airline-figured-out-how-to-make-sure-its-airplanes-never-disappear',\n            'title': 'One airline figured out how to make sure its airplanes never disappear',\n        },\n        'playlist': [{\n            'md5': 'a7c1b5634ba5e57a6a82cdffa5b1e0d0',\n            'info_dict': {\n                'id': '0e4bb54c-9065-11e4-a66f-0ca5037a597d',\n                'ext': 'mp4',\n                'description': 'Washington Post transportation reporter Ashley Halsey III explains why a plane\\'s black box needs to be recovered from a crash site instead of having its information streamed in real time throughout the flight.',\n                'upload_date': '20141230',\n                'uploader': 'The Washington Post',\n                'timestamp': 1419974765,\n                'title': 'Why black boxes don\u2019t transmit data in real time',\n            }\n        }]\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return False if WashingtonPostIE.suitable(url) else super(WashingtonPostArticleIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        page_id = self._match_id(url)\n        webpage = self._download_webpage(url, page_id)\n\n        title = self._og_search_title(webpage)\n\n        uuids = re.findall(r'''(?x)\n            (?:\n                <div\\s+class=\"posttv-video-embed[^>]*?data-uuid=|\n                data-video-uuid=\n            )\"([^\"]+)\"''', webpage)\n        entries = [self.url_result('washingtonpost:%s' % uuid, 'WashingtonPost', uuid) for uuid in uuids]\n\n        return {\n            '_type': 'playlist',\n            'entries': entries,\n            'id': page_id,\n            'title': title,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "washingtonpost.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/washingtonpost.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}