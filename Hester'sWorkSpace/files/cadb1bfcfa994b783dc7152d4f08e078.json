{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nimport logging\n\nfrom odoo import fields, models, _\nfrom odoo.tools import float_compare\n\n_logger = logging.getLogger(__name__)\n\n\nclass PaymentTransaction(models.Model):\n    _inherit = 'payment.transaction'\n\n    account_invoice_id = fields.Many2one('account.invoice', string='Invoice')\n\n    def form_feedback(self, data, acquirer_name):\n        \"\"\" Override to confirm the invoice, if defined, and if the transaction is done. \"\"\"\n        tx = None\n        res = super(PaymentTransaction, self).form_feedback(data, acquirer_name)\n\n        \n        tx_find_method_name = '_%s_form_get_tx_from_data' % acquirer_name\n        if hasattr(self, tx_find_method_name):\n            tx = getattr(self, tx_find_method_name)(data)\n\n        if tx and tx.account_invoice_id:\n            _logger.info(\n                '<%s> transaction <%s> processing form feedback for invoice <%s>: tx ref:%s, tx amount: %s',\n                acquirer_name, tx.id, tx.account_invoice_id.id, tx.reference, tx.amount)\n            tx._confirm_invoice()\n\n        return res\n\n    def confirm_invoice_token(self):\n        \"\"\" Confirm a transaction token and call SO confirmation if it is a success.\n\n        :return: True if success; error string otherwise \"\"\"\n        self.ensure_one()\n        if self.payment_token_id and self.partner_id == self.account_invoice_id.partner_id:\n            try:\n                s2s_result = self.s2s_do_transaction()\n            except Exception as e:\n                _logger.warning(\n                    _(\"<%s> transaction (%s) failed : <%s>\") %\n                    (self.acquirer_id.provider, self.id, str(e)))\n                return 'pay_invoice_tx_fail'\n\n            valid_state = 'authorized' if self.acquirer_id.capture_manually else 'done'\n            if not s2s_result or self.state != valid_state:\n                _logger.warning(\n                    _(\"<%s> transaction (%s) invalid state : %s\") %\n                    (self.acquirer_id.provider, self.id, self.state_mesage))\n                return 'pay_invoice_tx_state'\n\n            try:\n                \n                return self._confirm_invoice()\n            except Exception as e:\n                _logger.warning(\n                    _(\"<%s>  transaction (%s) invoice confirmation failed : <%s>\") %\n                    (self.acquirer_id.provider, self.id, str(e)))\n                return 'pay_invoice_tx_confirm'\n        return 'pay_invoice_tx_token'\n\n    def _confirm_invoice(self):\n        \"\"\" Check tx state, confirm and pay potential invoice \"\"\"\n        self.ensure_one()\n        \n        if self.account_invoice_id.state != 'open':\n            _logger.warning('<%s> transaction STATE INCORRECT for invoice %s (ID %s, state %s)', self.acquirer_id.provider, self.account_invoice_id.number, self.account_invoice_id.id, self.account_invoice_id.state)\n            return 'pay_invoice_invalid_doc_state'\n        if not float_compare(self.amount, self.account_invoice_id.amount_total, 2) == 0:\n            _logger.warning(\n                '<%s> transaction AMOUNT MISMATCH for invoice %s (ID %s): expected %r, got %r',\n                self.acquirer_id.provider, self.account_invoice_id.number, self.account_invoice_id.id,\n                self.account_invoice_id.amount_total, self.amount,\n            )\n            self.account_invoice_id.message_post(\n                subject=_(\"Amount Mismatch (%s)\") % self.acquirer_id.provider,\n                body=_(\"The invoice was not confirmed despite response from the acquirer (%s): invoice amount is %r but acquirer replied with %r.\") % (\n                    self.acquirer_id.provider,\n                    self.account_invoice_id.amount_total,\n                    self.amount,\n                )\n            )\n            return 'pay_invoice_tx_amount'\n\n        if self.state == 'authorized' and self.acquirer_id.capture_manually:\n            _logger.info('<%s> transaction authorized, nothing to do with invoice %s (ID %s)', self.acquirer_id.provider, self.account_invoice_id.number, self.account_invoice_id.id)\n        elif self.state == 'done':\n            _logger.info('<%s> transaction completed, paying invoice %s (ID %s)', self.acquirer_id.provider, self.account_invoice_id.number, self.account_invoice_id.id)\n            self._pay_invoice()\n        else:\n            _logger.warning('<%s> transaction MISMATCH for invoice %s (ID %s)', self.acquirer_id.provider, self.account_invoice_id.number, self.account_invoice_id.id)\n            return 'pay_invoice_tx_state'\n        return True\n\n    def _pay_invoice(self):\n        self.ensure_one()\n\n        \n        \n        \n        ctx_company = {'company_id': self.account_invoice_id.company_id.id,\n                       'force_company': self.account_invoice_id.company_id.id}\n        invoice = self.account_invoice_id.with_context(**ctx_company)\n\n        if not self.acquirer_id.journal_id:\n            default_journal = self.env['account.journal'].search([('type', '=', 'bank')], limit=1)\n            if not default_journal:\n                _logger.warning('<%s> transaction completed, could not auto-generate payment for invoice %s (ID %s) (no journal set on acquirer)',\n                                self.acquirer_id.provider, self.account_invoice_id.number, self.account_invoice_id.id)\n                return False\n            self.acquirer_id.journal_id = default_journal\n\n        invoice.pay_and_reconcile(self.acquirer_id.journal_id, pay_amount=invoice.amount_total)\n        invoice.payment_ids.write({'payment_transaction_id': self.ids[0]})\n        _logger.info('<%s> transaction <%s> completed, reconciled invoice %s (ID %s))',\n                     self.acquirer_id.provider, self.ids[0], invoice.number, invoice.id)\n\n        return True\n\n    def render_invoice_button(self, invoice, return_url, submit_txt=None, render_values=None):\n        values = {\n            'return_url': return_url,\n            'partner_id': invoice.partner_id.id,\n        }\n        if render_values:\n            values.update(render_values)\n        return self.acquirer_id.with_context(submit_class='btn btn-primary', submit_txt=submit_txt or _('Pay Now')).sudo().render(\n            self.reference,\n            invoice.amount_total,\n            invoice.currency_id.id,\n            values=values,\n        )\n\n    def _check_or_create_invoice_tx(self, invoice, acquirer, payment_token=None, tx_type='form', add_tx_values=None):\n        tx = self\n        if not tx:\n            tx = self.search([('reference', '=', invoice.number)], limit=1)\n\n        if tx and tx.state in ['error', 'cancel']:  \n            tx = False\n        if (tx and acquirer and tx.acquirer_id != acquirer) or (tx and tx.account_invoice_id != invoice):  \n            tx = False\n        if tx and tx.payment_token_id and payment_token and payment_token != tx.payment_token_id:  \n            tx = False\n\n        \n        if tx and tx.state == 'draft':\n            tx = False\n\n        if not tx:\n            tx_values = {\n                'acquirer_id': acquirer.id,\n                'type': tx_type,\n                'amount': invoice.amount_total,\n                'currency_id': invoice.currency_id.id,\n                'partner_id': invoice.partner_id.id,\n                'partner_country_id': invoice.partner_id.country_id.id,\n                'reference': self.get_next_reference(invoice.number),\n                'account_invoice_id': invoice.id,\n            }\n            if add_tx_values:\n                tx_values.update(add_tx_values)\n            if payment_token and payment_token.sudo().partner_id == invoice.partner_id:\n                tx_values['payment_token_id'] = payment_token.id\n\n            tx = self.create(tx_values)\n\n        \n        invoice.write({\n            'payment_tx_id': tx.id,\n        })\n\n        return tx\n", "comments": "    override confirm invoice  defined  transaction done              tx   none         res   super(paymenttransaction  self) form feedback(data  acquirer name)            fetch tx         tx find method name      form get tx data    acquirer name         hasattr(self  tx find method name)              tx   getattr(self  tx find method name)(data)          tx tx account invoice id               logger info(                     transaction    processing form feedback invoice     tx ref   tx amount                     acquirer name  tx id  tx account invoice id id  tx reference  tx amount)             tx  confirm invoice()          return res      def confirm invoice token(self)              confirm transaction token call so confirmation success            return  true success  error string otherwise             self ensure one()         self payment token id self partner id    self account invoice id partner id              try                  s2s result   self s2s transaction()             except exception e                   logger warning(                      (    transaction ( s) failed      )                       (self acquirer id provider  self id  str(e)))                 return  pay invoice tx fail               valid state    authorized  self acquirer id capture manually else  done              s2s result self state    valid state                   logger warning(                      (    transaction ( s) invalid state    )                       (self acquirer id provider  self id  self state mesage))                 return  pay invoice tx state               try                    auto confirm so necessary                 return self  confirm invoice()             except exception e                   logger warning(                      (     transaction ( s) invoice confirmation failed      )                       (self acquirer id provider  self id  str(e)))                 return  pay invoice tx confirm          return  pay invoice tx token       def  confirm invoice(self)              check tx state  confirm pay potential invoice            coding  utf 8        part odoo  see license file full copyright licensing details     fetch tx    auto confirm so necessary    check tx state  confirm potential so    force company ensure journals accounts etc  correct    company id needed default get account journal    force company needed company dependent fields    filter incorrect states    filter unmatching    new distinct token    still draft tx  info    create new one    update invoice ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nimport logging\n\nfrom odoo import fields, models, _\nfrom odoo.tools import float_compare\n\n_logger = logging.getLogger(__name__)\n\n\nclass PaymentTransaction(models.Model):\n    _inherit = 'payment.transaction'\n\n    account_invoice_id = fields.Many2one('account.invoice', string='Invoice')\n\n    def form_feedback(self, data, acquirer_name):\n        \"\"\" Override to confirm the invoice, if defined, and if the transaction is done. \"\"\"\n        tx = None\n        res = super(PaymentTransaction, self).form_feedback(data, acquirer_name)\n\n        # fetch the tx\n        tx_find_method_name = '_%s_form_get_tx_from_data' % acquirer_name\n        if hasattr(self, tx_find_method_name):\n            tx = getattr(self, tx_find_method_name)(data)\n\n        if tx and tx.account_invoice_id:\n            _logger.info(\n                '<%s> transaction <%s> processing form feedback for invoice <%s>: tx ref:%s, tx amount: %s',\n                acquirer_name, tx.id, tx.account_invoice_id.id, tx.reference, tx.amount)\n            tx._confirm_invoice()\n\n        return res\n\n    def confirm_invoice_token(self):\n        \"\"\" Confirm a transaction token and call SO confirmation if it is a success.\n\n        :return: True if success; error string otherwise \"\"\"\n        self.ensure_one()\n        if self.payment_token_id and self.partner_id == self.account_invoice_id.partner_id:\n            try:\n                s2s_result = self.s2s_do_transaction()\n            except Exception as e:\n                _logger.warning(\n                    _(\"<%s> transaction (%s) failed : <%s>\") %\n                    (self.acquirer_id.provider, self.id, str(e)))\n                return 'pay_invoice_tx_fail'\n\n            valid_state = 'authorized' if self.acquirer_id.capture_manually else 'done'\n            if not s2s_result or self.state != valid_state:\n                _logger.warning(\n                    _(\"<%s> transaction (%s) invalid state : %s\") %\n                    (self.acquirer_id.provider, self.id, self.state_mesage))\n                return 'pay_invoice_tx_state'\n\n            try:\n                # Auto-confirm SO if necessary\n                return self._confirm_invoice()\n            except Exception as e:\n                _logger.warning(\n                    _(\"<%s>  transaction (%s) invoice confirmation failed : <%s>\") %\n                    (self.acquirer_id.provider, self.id, str(e)))\n                return 'pay_invoice_tx_confirm'\n        return 'pay_invoice_tx_token'\n\n    def _confirm_invoice(self):\n        \"\"\" Check tx state, confirm and pay potential invoice \"\"\"\n        self.ensure_one()\n        # check tx state, confirm the potential SO\n        if self.account_invoice_id.state != 'open':\n            _logger.warning('<%s> transaction STATE INCORRECT for invoice %s (ID %s, state %s)', self.acquirer_id.provider, self.account_invoice_id.number, self.account_invoice_id.id, self.account_invoice_id.state)\n            return 'pay_invoice_invalid_doc_state'\n        if not float_compare(self.amount, self.account_invoice_id.amount_total, 2) == 0:\n            _logger.warning(\n                '<%s> transaction AMOUNT MISMATCH for invoice %s (ID %s): expected %r, got %r',\n                self.acquirer_id.provider, self.account_invoice_id.number, self.account_invoice_id.id,\n                self.account_invoice_id.amount_total, self.amount,\n            )\n            self.account_invoice_id.message_post(\n                subject=_(\"Amount Mismatch (%s)\") % self.acquirer_id.provider,\n                body=_(\"The invoice was not confirmed despite response from the acquirer (%s): invoice amount is %r but acquirer replied with %r.\") % (\n                    self.acquirer_id.provider,\n                    self.account_invoice_id.amount_total,\n                    self.amount,\n                )\n            )\n            return 'pay_invoice_tx_amount'\n\n        if self.state == 'authorized' and self.acquirer_id.capture_manually:\n            _logger.info('<%s> transaction authorized, nothing to do with invoice %s (ID %s)', self.acquirer_id.provider, self.account_invoice_id.number, self.account_invoice_id.id)\n        elif self.state == 'done':\n            _logger.info('<%s> transaction completed, paying invoice %s (ID %s)', self.acquirer_id.provider, self.account_invoice_id.number, self.account_invoice_id.id)\n            self._pay_invoice()\n        else:\n            _logger.warning('<%s> transaction MISMATCH for invoice %s (ID %s)', self.acquirer_id.provider, self.account_invoice_id.number, self.account_invoice_id.id)\n            return 'pay_invoice_tx_state'\n        return True\n\n    def _pay_invoice(self):\n        self.ensure_one()\n\n        # force company to ensure journals/accounts etc. are correct\n        # company_id needed for default_get on account.journal\n        # force_company needed for company_dependent fields\n        ctx_company = {'company_id': self.account_invoice_id.company_id.id,\n                       'force_company': self.account_invoice_id.company_id.id}\n        invoice = self.account_invoice_id.with_context(**ctx_company)\n\n        if not self.acquirer_id.journal_id:\n            default_journal = self.env['account.journal'].search([('type', '=', 'bank')], limit=1)\n            if not default_journal:\n                _logger.warning('<%s> transaction completed, could not auto-generate payment for invoice %s (ID %s) (no journal set on acquirer)',\n                                self.acquirer_id.provider, self.account_invoice_id.number, self.account_invoice_id.id)\n                return False\n            self.acquirer_id.journal_id = default_journal\n\n        invoice.pay_and_reconcile(self.acquirer_id.journal_id, pay_amount=invoice.amount_total)\n        invoice.payment_ids.write({'payment_transaction_id': self.ids[0]})\n        _logger.info('<%s> transaction <%s> completed, reconciled invoice %s (ID %s))',\n                     self.acquirer_id.provider, self.ids[0], invoice.number, invoice.id)\n\n        return True\n\n    def render_invoice_button(self, invoice, return_url, submit_txt=None, render_values=None):\n        values = {\n            'return_url': return_url,\n            'partner_id': invoice.partner_id.id,\n        }\n        if render_values:\n            values.update(render_values)\n        return self.acquirer_id.with_context(submit_class='btn btn-primary', submit_txt=submit_txt or _('Pay Now')).sudo().render(\n            self.reference,\n            invoice.amount_total,\n            invoice.currency_id.id,\n            values=values,\n        )\n\n    def _check_or_create_invoice_tx(self, invoice, acquirer, payment_token=None, tx_type='form', add_tx_values=None):\n        tx = self\n        if not tx:\n            tx = self.search([('reference', '=', invoice.number)], limit=1)\n\n        if tx and tx.state in ['error', 'cancel']:  # filter incorrect states\n            tx = False\n        if (tx and acquirer and tx.acquirer_id != acquirer) or (tx and tx.account_invoice_id != invoice):  # filter unmatching\n            tx = False\n        if tx and tx.payment_token_id and payment_token and payment_token != tx.payment_token_id:  # new or distinct token\n            tx = False\n\n        # still draft tx, no more info -> create a new one\n        if tx and tx.state == 'draft':\n            tx = False\n\n        if not tx:\n            tx_values = {\n                'acquirer_id': acquirer.id,\n                'type': tx_type,\n                'amount': invoice.amount_total,\n                'currency_id': invoice.currency_id.id,\n                'partner_id': invoice.partner_id.id,\n                'partner_country_id': invoice.partner_id.country_id.id,\n                'reference': self.get_next_reference(invoice.number),\n                'account_invoice_id': invoice.id,\n            }\n            if add_tx_values:\n                tx_values.update(add_tx_values)\n            if payment_token and payment_token.sudo().partner_id == invoice.partner_id:\n                tx_values['payment_token_id'] = payment_token.id\n\n            tx = self.create(tx_values)\n\n        # update invoice\n        invoice.write({\n            'payment_tx_id': tx.id,\n        })\n\n        return tx\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "payment.py", "id": "cadb1bfcfa994b783dc7152d4f08e078", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/account_payment/models/payment.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}