{"author": "mwaskom", "code": "from __future__ import division\nfrom itertools import product\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom .. import basic\nfrom ..palettes import color_palette\nfrom ..utils import categorical_order\n\n\nclass TestBasicPlotter(object):\n\n    @pytest.fixture\n    def wide_df(self):\n\n        columns = list(\"abc\")\n        index = pd.Int64Index(np.arange(10, 50, 2), name=\"wide_index\")\n        values = np.random.randn(len(index), len(columns))\n        return pd.DataFrame(values, index=index, columns=columns)\n\n    @pytest.fixture\n    def wide_array(self):\n\n        return np.random.randn(20, 3)\n\n    @pytest.fixture\n    def flat_array(self):\n\n        return np.random.randn(20)\n\n    @pytest.fixture\n    def flat_series(self):\n\n        index = pd.Int64Index(np.arange(10, 30), name=\"t\")\n        return pd.Series(np.random.randn(20), index, name=\"s\")\n\n    @pytest.fixture\n    def wide_list(self):\n\n        return [np.random.randn(20), np.random.randn(10)]\n\n    @pytest.fixture\n    def wide_list_of_series(self):\n\n        return [pd.Series(np.random.randn(20), np.arange(20), name=\"a\"),\n                pd.Series(np.random.randn(10), np.arange(5, 15), name=\"b\")]\n\n    @pytest.fixture\n    def long_df(self):\n\n        n = 100\n        rs = np.random.RandomState()\n        return pd.DataFrame(dict(\n            x=rs.randint(0, 20, n),\n            y=rs.randn(n),\n            a=np.take(list(\"abc\"), rs.randint(0, 3, n)),\n            b=np.take(list(\"mnop\"), rs.randint(0, 4, n)),\n            s=np.take([2, 4, 8], rs.randint(0, 3, n)),\n        ))\n\n    @pytest.fixture\n    def null_column(self):\n\n        return pd.Series(index=np.arange(20))\n\n    def test_wide_df_variables(self, wide_df):\n\n        p = basic._BasicPlotter()\n        p.establish_variables(data=wide_df)\n        assert p.input_format == \"wide\"\n        assert len(p.plot_data) == np.product(wide_df.shape)\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.tile(wide_df.index, wide_df.shape[1])\n        assert np.array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = wide_df.values.ravel(order=\"f\")\n        assert np.array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        expected_hue = np.repeat(wide_df.columns.values, wide_df.shape[0])\n        assert np.array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert np.array_equal(style, expected_style)\n\n        assert p.plot_data[\"size\"].isnull().all()\n\n        assert p.x_label == wide_df.index.name\n        assert p.y_label is None\n        assert p.hue_label == wide_df.columns.name\n        assert p.size_label is None\n        assert p.style_label == wide_df.columns.name\n\n    def test_wide_df_variables_check(self, wide_df):\n\n        p = basic._BasicPlotter()\n        wide_df = wide_df.copy()\n        wide_df.loc[:, \"not_numeric\"] = \"a\"\n        with pytest.raises(ValueError):\n            p.establish_variables(data=wide_df)\n\n    def test_wide_array_variables(self, wide_array):\n\n        p = basic._BasicPlotter()\n        p.establish_variables(data=wide_array)\n        assert p.input_format == \"wide\"\n        assert len(p.plot_data) == np.product(wide_array.shape)\n\n        nrow, ncol = wide_array.shape\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.tile(np.arange(nrow), ncol)\n        assert np.array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = wide_array.ravel(order=\"f\")\n        assert np.array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        expected_hue = np.repeat(np.arange(ncol), nrow)\n        assert np.array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert np.array_equal(style, expected_style)\n\n        assert p.plot_data[\"size\"].isnull().all()\n\n        assert p.x_label is None\n        assert p.y_label is None\n        assert p.hue_label is None\n        assert p.size_label is None\n        assert p.style_label is None\n\n    def test_flat_array_variables(self, flat_array):\n\n        p = basic._BasicPlotter()\n        p.establish_variables(data=flat_array)\n        assert p.input_format == \"wide\"\n        assert len(p.plot_data) == np.product(flat_array.shape)\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.arange(flat_array.shape[0])\n        assert np.array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = flat_array\n        assert np.array_equal(y, expected_y)\n\n        assert p.plot_data[\"hue\"].isnull().all()\n        assert p.plot_data[\"style\"].isnull().all()\n        assert p.plot_data[\"size\"].isnull().all()\n\n        assert p.x_label is None\n        assert p.y_label is None\n        assert p.hue_label is None\n        assert p.size_label is None\n        assert p.style_label is None\n\n    def test_flat_series_variables(self, flat_series):\n\n        p = basic._BasicPlotter()\n        p.establish_variables(data=flat_series)\n        assert p.input_format == \"wide\"\n        assert len(p.plot_data) == len(flat_series)\n\n        x = p.plot_data[\"x\"]\n        expected_x = flat_series.index\n        assert np.array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = flat_series\n        assert np.array_equal(y, expected_y)\n\n        assert p.x_label is None\n        assert p.y_label is None\n        assert p.hue_label is None\n        assert p.size_label is None\n        assert p.style_label is None\n\n    def test_wide_list_variables(self, wide_list):\n\n        p = basic._BasicPlotter()\n        p.establish_variables(data=wide_list)\n        assert p.input_format == \"wide\"\n        assert len(p.plot_data) == sum(len(l) for l in wide_list)\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.concatenate([np.arange(len(l)) for l in wide_list])\n        assert np.array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = np.concatenate(wide_list)\n        assert np.array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        expected_hue = np.concatenate([\n            np.ones_like(l) * i for i, l in enumerate(wide_list)\n        ])\n        assert np.array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert np.array_equal(style, expected_style)\n\n        assert p.plot_data[\"size\"].isnull().all()\n\n        assert p.x_label is None\n        assert p.y_label is None\n        assert p.hue_label is None\n        assert p.size_label is None\n        assert p.style_label is None\n\n    def test_wide_list_of_series_variables(self, wide_list_of_series):\n\n        p = basic._BasicPlotter()\n        p.establish_variables(data=wide_list_of_series)\n        assert p.input_format == \"wide\"\n        assert len(p.plot_data) == sum(len(l) for l in wide_list_of_series)\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.concatenate([s.index for s in wide_list_of_series])\n        assert np.array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = np.concatenate(wide_list_of_series)\n        assert np.array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        expected_hue = np.concatenate([\n            np.full(len(s), s.name, object) for s in wide_list_of_series\n        ])\n        assert np.array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert np.array_equal(style, expected_style)\n\n        assert p.plot_data[\"size\"].isnull().all()\n\n        assert p.x_label is None\n        assert p.y_label is None\n        assert p.hue_label is None\n        assert p.size_label is None\n        assert p.style_label is None\n\n    def test_long_df(self, long_df):\n\n        p = basic._BasicPlotter()\n        p.establish_variables(x=\"x\", y=\"y\", data=long_df)\n        assert p.input_format == \"long\"\n\n        assert np.array_equal(p.plot_data[\"x\"], long_df[\"x\"])\n        assert np.array_equal(p.plot_data[\"y\"], long_df[\"y\"])\n        for col in [\"hue\", \"style\", \"size\"]:\n            assert p.plot_data[col].isnull().all()\n        assert (p.x_label, p.y_label) == (\"x\", \"y\")\n        assert p.hue_label is None\n        assert p.size_label is None\n        assert p.style_label is None\n\n        p.establish_variables(x=long_df.x, y=\"y\", data=long_df)\n        assert np.array_equal(p.plot_data[\"x\"], long_df[\"x\"])\n        assert np.array_equal(p.plot_data[\"y\"], long_df[\"y\"])\n        assert (p.x_label, p.y_label) == (\"x\", \"y\")\n\n        p.establish_variables(x=\"x\", y=long_df.y, data=long_df)\n        assert np.array_equal(p.plot_data[\"x\"], long_df[\"x\"])\n        assert np.array_equal(p.plot_data[\"y\"], long_df[\"y\"])\n        assert (p.x_label, p.y_label) == (\"x\", \"y\")\n\n        p.establish_variables(x=\"x\", y=\"y\", hue=\"a\", data=long_df)\n        assert np.array_equal(p.plot_data[\"hue\"], long_df[\"a\"])\n        for col in [\"style\", \"size\"]:\n            assert p.plot_data[col].isnull().all()\n        assert p.hue_label == \"a\"\n        assert p.size_label is None and p.style_label is None\n\n        p.establish_variables(x=\"x\", y=\"y\", hue=\"a\", style=\"a\", data=long_df)\n        assert np.array_equal(p.plot_data[\"hue\"], long_df[\"a\"])\n        assert np.array_equal(p.plot_data[\"style\"], long_df[\"a\"])\n        assert p.plot_data[\"size\"].isnull().all()\n        assert p.hue_label == p.style_label == \"a\"\n        assert p.size_label is None\n\n        p.establish_variables(x=\"x\", y=\"y\", hue=\"a\", style=\"b\", data=long_df)\n        assert np.array_equal(p.plot_data[\"hue\"], long_df[\"a\"])\n        assert np.array_equal(p.plot_data[\"style\"], long_df[\"b\"])\n        assert p.plot_data[\"size\"].isnull().all()\n\n        p.establish_variables(x=\"x\", y=\"y\", size=\"y\", data=long_df)\n        assert np.array_equal(p.plot_data[\"size\"], long_df[\"y\"])\n        assert p.size_label == \"y\"\n        assert p.hue_label is None and p.style_label is None\n\n    def test_bad_input(self, long_df):\n\n        p = basic._BasicPlotter()\n\n        with pytest.raises(ValueError):\n            p.establish_variables(x=long_df.x)\n\n        with pytest.raises(ValueError):\n            p.establish_variables(y=long_df.y)\n\n        with pytest.raises(ValueError):\n            p.establish_variables(x=\"not_in_df\", data=long_df)\n\n        with pytest.raises(ValueError):\n            p.establish_variables(x=\"x\", y=\"not_in_df\", data=long_df)\n\n        with pytest.raises(ValueError):\n            p.establish_variables(x=\"x\", y=\"not_in_df\", data=long_df)\n\n    def test_empty_input(self):\n\n        p = basic._BasicPlotter()\n\n        p.establish_variables(data=[])\n        p.establish_variables(data=np.array([]))\n        p.establish_variables(data=pd.DataFrame())\n        p.establish_variables(x=[], y=[])\n\n\nclass TestLinePlotter(TestBasicPlotter):\n\n    def test_parse_hue_null(self, wide_df, null_column):\n\n        p = basic._LinePlotter(data=wide_df)\n        p.parse_hue(null_column, \"Blues\", None, None)\n        assert p.hue_levels == [None]\n        assert p.palette == {}\n        assert p.hue_type is None\n        assert p.cmap is None\n\n    def test_parse_hue_categorical(self, wide_df, long_df):\n\n        p = basic._LinePlotter(data=wide_df)\n        assert p.hue_levels == wide_df.columns.tolist()\n        assert p.hue_type is \"categorical\"\n        assert p.cmap is None\n\n        \n        palette = \"Blues\"\n        expected_colors = color_palette(palette, wide_df.shape[1])\n        expected_palette = dict(zip(wide_df.columns, expected_colors))\n        p.parse_hue(p.plot_data.hue, palette, None, None)\n        assert p.palette == expected_palette\n\n        \n        palette = color_palette(\"Reds\", wide_df.shape[1])\n        p.parse_hue(p.plot_data.hue, palette, None, None)\n        expected_palette = dict(zip(wide_df.columns, palette))\n        assert p.palette == expected_palette\n\n        \n        colors = color_palette(\"Set1\", 8)\n        palette = dict(zip(wide_df.columns, colors))\n        p.parse_hue(p.plot_data.hue, palette, None, None)\n        assert p.palette == palette\n\n        \n        palette = dict(zip(wide_df.columns[:-1], colors))\n        with pytest.raises(ValueError):\n            p.parse_hue(p.plot_data.hue, palette, None, None)\n\n        \n        palette = colors[:-1]\n        with pytest.raises(ValueError):\n            p.parse_hue(p.plot_data.hue, palette, None, None)\n\n        \n        hue_order = [\"a\", \"c\", \"d\"]\n        p.parse_hue(p.plot_data.hue, None, hue_order, None)\n        assert p.hue_levels == hue_order\n\n        \n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", data=long_df)\n        assert p.hue_levels == categorical_order(long_df.a)\n        assert p.hue_type is \"categorical\"\n        assert p.cmap is None\n\n        \n        p.parse_hue(p.plot_data.hue, None, None, None)\n        hue_levels = categorical_order(long_df.a)\n        expected_colors = color_palette(n_colors=len(hue_levels))\n        expected_palette = dict(zip(hue_levels, expected_colors))\n        assert p.palette == expected_palette\n\n         with many levels\n        levels = pd.Series(list(\"abcdefghijklmnopqrstuvwxyz\"))\n        p.parse_hue(levels, None, None, None)\n        expected_colors = color_palette(\"husl\", n_colors=len(levels))\n        expected_palette = dict(zip(levels, expected_colors))\n        assert p.palette == expected_palette\n\n    def test_parse_hue_numeric(self, long_df):\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"s\", data=long_df)\n        hue_levels = list(np.sort(long_df.s.unique()))\n        assert p.hue_levels == hue_levels\n        assert p.hue_type is \"numeric\"\n        assert p.cmap is mpl.cm.get_cmap(mpl.rcParams[\"image.cmap\"])\n\n        \n        palette = \"Purples\"\n        p.parse_hue(p.plot_data.hue, palette, None, None)\n        assert p.cmap is mpl.cm.get_cmap(palette)\n\n        \n        palette = mpl.cm.get_cmap(\"Greens\")\n        p.parse_hue(p.plot_data.hue, palette, None, None)\n        assert p.cmap is palette\n\n        \n        p.parse_hue(p.plot_data.hue, None, None, None)\n        assert p.hue_limits == (p.plot_data.hue.min(), p.plot_data.hue.max())\n\n        \n        hue_limits = 1, 4\n        p.parse_hue(p.plot_data.hue, None, None, hue_limits)\n        assert p.hue_limits == hue_limits\n\n        \n        hmin, hmax = p.plot_data.hue.min(), p.plot_data.hue.max()\n        p.parse_hue(p.plot_data.hue, None, None, None)\n        assert p.palette[hmin] == pytest.approx(p.cmap(0.0))\n        assert p.palette[hmax] == pytest.approx(p.cmap(1.0))\n\n        \n        hue_limits = hmin - 1, hmax - 1\n        p.parse_hue(p.plot_data.hue, None, None, hue_limits)\n        norm_min = (hmin - hue_limits[0]) / (hue_limits[1] - hue_limits[0])\n        assert p.palette[hmin] == pytest.approx(p.cmap(norm_min))\n        assert p.palette[hmax] == pytest.approx(p.cmap(1.0))\n\n        \n        hue_levels = list(np.sort(long_df.s.unique()))\n        palette = color_palette(\"Blues\", len(hue_levels))\n        p.parse_hue(p.plot_data.hue, palette, None, None)\n        assert p.palette == dict(zip(hue_levels, palette))\n\n        palette = color_palette(\"Blues\", len(hue_levels) + 1)\n        with pytest.raises(ValueError):\n            p.parse_hue(p.plot_data.hue, palette, None, None)\n\n        \n        palette = dict(zip(hue_levels, color_palette(\"Reds\")))\n        p.parse_hue(p.plot_data.hue, palette, None, None)\n        assert p.palette == palette\n\n        palette.pop(hue_levels[0])\n        with pytest.raises(ValueError):\n            p.parse_hue(p.plot_data.hue, palette, None, None)\n\n        \n        palette = \"not_a_valid_palette\"\n        with pytest.raises(ValueError):\n            p.parse_hue(p.plot_data.hue, palette, None, None)\n\n    def test_parse_size(self, long_df):\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", size=\"s\", data=long_df)\n\n        \n        default_linewidth = mpl.rcParams[\"lines.linewidth\"]\n        default_limits = p.plot_data[\"size\"].min(), p.plot_data[\"size\"].max()\n        default_range = .5 * default_linewidth, 2 * default_linewidth\n        p.parse_size(p.plot_data[\"size\"], None, None, None)\n        assert p.size_limits == default_limits\n        size_range = min(p.sizes.values()), max(p.sizes.values())\n        assert size_range == default_range\n\n        \n        size_limits = (1, 5)\n        p.parse_size(p.plot_data[\"size\"], None, None, size_limits)\n        assert p.size_limits == size_limits\n\n        \n        sizes = (.1, .5)\n        p.parse_size(p.plot_data[\"size\"], sizes, None, None)\n        assert p.size_limits == default_limits\n\n        \n        sizes = (1, 5)\n        size_limits = (1, 10)\n        p.parse_size(p.plot_data[\"size\"], sizes, None, size_limits)\n        normalize = mpl.colors.Normalize(*size_limits, clip=False)\n        for level, width in p.sizes.items():\n            assert width == sizes[0] + (sizes[1] - sizes[0]) * normalize(level)\n\n        \n        var = \"a\"\n        levels = categorical_order(long_df[var])\n        sizes = list(np.random.rand(len(levels)))\n        p = basic._LinePlotter(x=\"x\", y=\"y\", size=var, data=long_df)\n        p.parse_size(p.plot_data[\"size\"], sizes, None, None)\n        assert p.sizes == dict(zip(levels, sizes))\n\n        \n        var = \"a\"\n        levels = categorical_order(long_df[var])\n        sizes = dict(zip(levels, np.random.rand(len(levels))))\n        p = basic._LinePlotter(x=\"x\", y=\"y\", size=var, data=long_df)\n        p.parse_size(p.plot_data[\"size\"], sizes, None, None)\n        assert p.sizes == sizes\n\n        \n        sizes = list(np.random.rand(len(levels) + 1))\n        with pytest.raises(ValueError):\n            p.parse_size(p.plot_data[\"size\"], sizes, None, None)\n\n        \n        sizes = dict(zip(levels, np.random.rand(len(levels) - 1)))\n        with pytest.raises(ValueError):\n            p.parse_size(p.plot_data[\"size\"], sizes, None, None)\n\n        \n        sizes = \"bad_size\"\n        with pytest.raises(ValueError):\n            p.parse_size(p.plot_data[\"size\"], sizes, None, None)\n\n    def test_parse_style(self, long_df):\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", style=\"a\", data=long_df)\n\n        \n        markers, dashes = True, True\n        p.parse_style(p.plot_data[\"style\"], markers, dashes, None)\n        assert p.markers == dict(zip(p.style_levels, p.default_markers))\n        assert p.dashes == dict(zip(p.style_levels, p.default_dashes))\n\n        \n        markers, dashes = [\"o\", \"s\", \"d\"], [(1, 0), (1, 1), (2, 1, 3, 1)]\n        p.parse_style(p.plot_data[\"style\"], markers, dashes, None)\n        assert p.markers == dict(zip(p.style_levels, markers))\n        assert p.dashes == dict(zip(p.style_levels, dashes))\n\n        \n        markers = dict(zip(p.style_levels, markers))\n        dashes = dict(zip(p.style_levels, dashes))\n        p.parse_style(p.plot_data[\"style\"], markers, dashes, None)\n        assert p.markers == markers\n        assert p.dashes == dashes\n\n        \n        style_order = np.take(p.style_levels, [1, 2, 0])\n        markers = dashes = True\n        p.parse_style(p.plot_data[\"style\"], markers, dashes, style_order)\n        assert p.markers == dict(zip(style_order, p.default_markers))\n        assert p.dashes == dict(zip(style_order, p.default_dashes))\n\n        \n        markers, dashes = [\"o\", \"s\"], False\n        with pytest.raises(ValueError):\n            p.parse_style(p.plot_data[\"style\"], markers, dashes, None)\n\n        markers, dashes = False, [(2, 1)]\n        with pytest.raises(ValueError):\n            p.parse_style(p.plot_data[\"style\"], markers, dashes, None)\n\n        \n        markers, dashes = {\"a\": \"o\", \"b\": \"s\"}, False\n        with pytest.raises(ValueError):\n            p.parse_style(p.plot_data[\"style\"], markers, dashes, None)\n\n        markers, dashes = False, {\"a\": (1, 0), \"b\": (2, 1)}\n        with pytest.raises(ValueError):\n            p.parse_style(p.plot_data[\"style\"], markers, dashes, None)\n\n    def test_subset_data_quantities(self, long_df):\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df)\n        assert len(list(p.subset_data())) == 1\n\n        \n\n        var = \"a\"\n        n_subsets = len(long_df[var].unique())\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=var, data=long_df)\n        assert len(list(p.subset_data())) == n_subsets\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", style=var, data=long_df)\n        assert len(list(p.subset_data())) == n_subsets\n\n        n_subsets = len(long_df[var].unique())\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", size=var, data=long_df)\n        assert len(list(p.subset_data())) == n_subsets\n\n        \n\n        var = \"a\"\n        n_subsets = len(long_df[var].unique())\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=var, style=var, data=long_df)\n        assert len(list(p.subset_data())) == n_subsets\n\n        \n\n        var1, var2 = \"a\", \"s\"\n        n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=var1, style=var2,\n                               data=long_df)\n        assert len(list(p.subset_data())) == n_subsets\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=var1, size=var2, style=var1,\n                               data=long_df)\n        assert len(list(p.subset_data())) == n_subsets\n\n        \n\n        var1, var2, var3 = \"a\", \"s\", \"b\"\n        cols = [var1, var2, var3]\n        n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=var1, size=var2, style=var3,\n                               data=long_df)\n        assert len(list(p.subset_data())) == n_subsets\n\n    def test_subset_data_keys(self, long_df):\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df)\n        for (hue, size, style), _ in p.subset_data():\n            assert hue is None\n            assert size is None\n            assert style is None\n\n        \n\n        var = \"a\"\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=var, data=long_df)\n        for (hue, size, style), _ in p.subset_data():\n            assert hue in long_df[var].values\n            assert size is None\n            assert style is None\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", style=var, data=long_df)\n        for (hue, size, style), _ in p.subset_data():\n            assert hue is None\n            assert size is None\n            assert style in long_df[var].values\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=var, style=var, data=long_df)\n        for (hue, size, style), _ in p.subset_data():\n            assert hue in long_df[var].values\n            assert size is None\n            assert style in long_df[var].values\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", size=var, data=long_df)\n        for (hue, size, style), _ in p.subset_data():\n            assert hue is None\n            assert size in long_df[var].values\n            assert style is None\n\n        \n\n        var1, var2 = \"a\", \"s\"\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=var1, size=var2, data=long_df)\n        for (hue, size, style), _ in p.subset_data():\n            assert hue in long_df[var1].values\n            assert size in long_df[var2].values\n            assert style is None\n\n    def test_subset_data_values(self, long_df):\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df)\n        _, data = next(p.subset_data())\n        expected = basic.sort_df(p.plot_data.loc[:, [\"x\", \"y\"]], [\"x\", \"y\"])\n        assert np.array_equal(data.values, expected)\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df, sort=False)\n        _, data = next(p.subset_data())\n        expected = p.plot_data.loc[:, [\"x\", \"y\"]]\n        assert np.array_equal(data.values, expected)\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", data=long_df)\n        for (hue, _, _), data in p.subset_data():\n            rows = p.plot_data[\"hue\"] == hue\n            cols = [\"x\", \"y\"]\n            expected = basic.sort_df(p.plot_data.loc[rows, cols], cols)\n            assert np.array_equal(data.values, expected.values)\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", data=long_df, sort=False)\n        for (hue, _, _), data in p.subset_data():\n            rows = p.plot_data[\"hue\"] == hue\n            cols = [\"x\", \"y\"]\n            expected = p.plot_data.loc[rows, cols]\n            assert np.array_equal(data.values, expected.values)\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", style=\"a\", data=long_df)\n        for (hue, _, _), data in p.subset_data():\n            rows = p.plot_data[\"hue\"] == hue\n            cols = [\"x\", \"y\"]\n            expected = basic.sort_df(p.plot_data.loc[rows, cols], cols)\n            assert np.array_equal(data.values, expected.values)\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", size=\"s\", data=long_df)\n        for (hue, size, _), data in p.subset_data():\n            rows = (p.plot_data[\"hue\"] == hue) & (p.plot_data[\"size\"] == size)\n            cols = [\"x\", \"y\"]\n            expected = basic.sort_df(p.plot_data.loc[rows, cols], cols)\n            assert np.array_equal(data.values, expected.values)\n\n    def test_aggregate(self, long_df):\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df)\n        p.n_boot = 10000\n        p.sort = False\n\n        x = pd.Series(np.tile([1, 2], 100))\n        y = pd.Series(np.random.randn(200))\n        y_mean = y.groupby(x).mean()\n\n        def sem(x):\n            return np.std(x) / np.sqrt(len(x))\n\n        y_sem = y.groupby(x).apply(sem)\n        y_cis = pd.DataFrame(dict(low=y_mean - y_sem,\n                                  high=y_mean + y_sem),\n                             columns=[\"low\", \"high\"])\n\n        index, est, cis = p.aggregate(y, x, \"mean\", 68)\n        assert np.array_equal(index.values, x.unique())\n        assert est.index.equals(index)\n        assert est.values == pytest.approx(y_mean.values)\n        assert cis.values == pytest.approx(y_cis.values, 4)\n        assert list(cis.columns) == [\"low\", \"high\"]\n\n        index, est, cis = p.aggregate(y, x, np.mean, 68)\n        assert np.array_equal(index.values, x.unique())\n        assert est.index.equals(index)\n        assert est.values == pytest.approx(y_mean.values)\n        assert cis.values == pytest.approx(y_cis.values, 4)\n        assert list(cis.columns) == [\"low\", \"high\"]\n\n        y_std = y.groupby(x).std()\n        y_cis = pd.DataFrame(dict(low=y_mean - y_std,\n                                  high=y_mean + y_std),\n                             columns=[\"low\", \"high\"])\n\n        index, est, cis = p.aggregate(y, x, \"mean\", \"sd\")\n        assert np.array_equal(index.values, x.unique())\n        assert est.index.equals(index)\n        assert est.values == pytest.approx(y_mean.values)\n        assert cis.values == pytest.approx(y_cis.values)\n        assert list(cis.columns) == [\"low\", \"high\"]\n\n        index, est, cis = p.aggregate(y, x, \"mean\", None)\n        assert cis is None\n\n        x, y = pd.Series([1, 2, 3]), pd.Series([4, 3, 2])\n        index, est, cis = p.aggregate(y, x, \"mean\", 68)\n        assert np.array_equal(index.values, x)\n        assert np.array_equal(est.values, y)\n        assert cis is None\n\n        x, y = pd.Series([1, 1, 2]), pd.Series([2, 3, 4])\n        index, est, cis = p.aggregate(y, x, \"mean\", 68)\n        assert cis.loc[2].isnull().all()\n\n    def test_legend_data(self, long_df):\n\n        f, ax = plt.subplots()\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df, legend=\"full\")\n        p.add_legend_data(ax)\n        handles, _ = ax.get_legend_handles_labels()\n        assert handles == []\n\n        \n\n        ax.clear()\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", data=long_df,\n                               legend=\"full\")\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        colors = [h.get_color() for h in handles]\n        assert labels == p.hue_levels\n        assert colors == [p.palette[l] for l in labels]\n\n        \n\n        ax.clear()\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", style=\"a\",\n                               markers=True, legend=\"full\", data=long_df)\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        colors = [h.get_color() for h in handles]\n        markers = [h.get_marker() for h in handles]\n        assert labels == p.hue_levels == p.style_levels\n        assert colors == [p.palette[l] for l in labels]\n        assert markers == [p.markers[l] for l in labels]\n\n        \n\n        ax.clear()\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", style=\"b\",\n                               markers=True, legend=\"full\", data=long_df)\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        colors = [h.get_color() for h in handles]\n        markers = [h.get_marker() for h in handles]\n        expected_colors = ([p.palette[l] for l in p.hue_levels]\n                           + [\".2\" for _ in p.style_levels])\n        expected_markers = ([\"None\" for _ in p.hue_levels]\n                            + [p.markers[l] for l in p.style_levels])\n        assert labels == p.hue_levels + p.style_levels\n        assert colors == expected_colors\n        assert markers == expected_markers\n\n        \n\n        ax.clear()\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", size=\"a\", data=long_df,\n                               legend=\"full\")\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        colors = [h.get_color() for h in handles]\n        widths = [h.get_linewidth() for h in handles]\n        assert labels == p.hue_levels == p.size_levels\n        assert colors == [p.palette[l] for l in labels]\n        assert widths == [p.sizes[l] for l in labels]\n\n        \n\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n\n        p = basic._LinePlotter(x=x, y=y, hue=z)\n\n        ax.clear()\n        p.legend = \"full\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert labels == [str(l) for l in p.hue_levels]\n\n        ax.clear()\n        p.legend = \"brief\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert len(labels) == 4\n\n        p = basic._LinePlotter(x=x, y=y, size=z)\n\n        ax.clear()\n        p.legend = \"full\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert labels == [str(l) for l in p.size_levels]\n\n        ax.clear()\n        p.legend = \"brief\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert len(labels) == 4\n\n        ax.clear()\n        p.legend = \"bad_value\"\n        with pytest.raises(ValueError):\n            p.add_legend_data(ax)\n\n    def test_plot(self, long_df):\n\n        f, ax = plt.subplots()\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df,\n                               sort=False, estimator=None)\n        p.plot(ax, {})\n        line, = ax.lines\n        assert np.array_equal(line.get_xdata(), long_df.x.values)\n        assert np.array_equal(line.get_ydata(), long_df.y.values)\n\n        ax.clear()\n        p.plot(ax, {\"color\": \"k\", \"label\": \"test\"})\n        line, = ax.lines\n        assert line.get_color() == \"k\"\n        assert line.get_label() == \"test\"\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df,\n                               sort=True, estimator=None)\n\n        ax.clear()\n        p.plot(ax, {})\n        line, = ax.lines\n        sorted_data = basic.sort_df(long_df, [\"x\", \"y\"])\n        assert np.array_equal(line.get_xdata(), sorted_data.x.values)\n        assert np.array_equal(line.get_ydata(), sorted_data.y.values)\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", data=long_df)\n\n        ax.clear()\n        p.plot(ax, {})\n        assert len(ax.lines) == len(p.hue_levels)\n        for line, level in zip(ax.lines, p.hue_levels):\n            assert line.get_color() == p.palette[level]\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", size=\"a\", data=long_df)\n\n        ax.clear()\n        p.plot(ax, {})\n        assert len(ax.lines) == len(p.size_levels)\n        for line, level in zip(ax.lines, p.size_levels):\n            assert line.get_linewidth() == p.sizes[level]\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", style=\"a\",\n                               markers=True, data=long_df)\n\n        ax.clear()\n        p.plot(ax, {})\n        assert len(ax.lines) == len(p.hue_levels) == len(p.style_levels)\n        for line, level in zip(ax.lines, p.hue_levels):\n            assert line.get_color() == p.palette[level]\n            assert line.get_marker() == p.markers[level]\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", style=\"b\",\n                               markers=True, data=long_df)\n\n        ax.clear()\n        p.plot(ax, {})\n        levels = product(p.hue_levels, p.style_levels)\n        assert len(ax.lines) == (len(p.hue_levels) * len(p.style_levels))\n        for line, (hue, style) in zip(ax.lines, levels):\n            assert line.get_color() == p.palette[hue]\n            assert line.get_marker() == p.markers[style]\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df,\n                               estimator=\"mean\", errstyle=\"band\", ci=\"sd\",\n                               sort=True)\n\n        ax.clear()\n        p.plot(ax, {})\n        line, = ax.lines\n        expected_data = long_df.groupby(\"x\").y.mean()\n        assert np.array_equal(line.get_xdata(), expected_data.index.values)\n        assert np.allclose(line.get_ydata(), expected_data.values)\n        assert len(ax.collections) == 1\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", data=long_df,\n                               estimator=\"mean\", errstyle=\"band\", ci=\"sd\")\n\n        ax.clear()\n        p.plot(ax, {})\n        assert len(ax.lines) == len(ax.collections) == len(p.hue_levels)\n        for c in ax.collections:\n            assert isinstance(c, mpl.collections.PolyCollection)\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", data=long_df,\n                               estimator=\"mean\", errstyle=\"bars\", ci=\"sd\")\n\n        ax.clear()\n        p.plot(ax, {})\n        assert len(ax.lines) == len(ax.collections) == len(p.hue_levels)\n        for c in ax.collections:\n            assert isinstance(c, mpl.collections.LineCollection)\n\n    def test_axis_labels(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df)\n\n        p.plot(ax1, {})\n        assert ax1.get_xlabel() == \"x\"\n        assert ax1.get_ylabel() == \"y\"\n\n        p.plot(ax2, {})\n        assert ax2.get_xlabel() == \"x\"\n        assert ax2.get_ylabel() == \"y\"\n        assert not ax2.yaxis.label.get_visible()\n\n    def test_lineplot_axes(self, wide_df):\n\n        f1, ax1 = plt.subplots()\n        f2, ax2 = plt.subplots()\n\n        ax = basic.lineplot(data=wide_df)\n        assert ax is ax2\n\n        ax = basic.lineplot(data=wide_df, ax=ax1)\n        assert ax is ax1\n\n    def test_lineplot_smoke(self, flat_array, flat_series,\n                            wide_array, wide_list, wide_list_of_series,\n                            wide_df, long_df):\n\n        f, ax = plt.subplots()\n\n        basic.lineplot(data=flat_array)\n        ax.clear()\n\n        basic.lineplot(data=flat_series)\n        ax.clear()\n\n        basic.lineplot(data=wide_array)\n        ax.clear()\n\n        basic.lineplot(data=wide_list)\n        ax.clear()\n\n        basic.lineplot(data=wide_list_of_series)\n        ax.clear()\n\n        basic.lineplot(data=wide_df)\n        ax.clear()\n\n        basic.lineplot(x=\"x\", y=\"y\", data=long_df)\n        ax.clear()\n\n        basic.lineplot(x=long_df.x, y=long_df.y)\n        ax.clear()\n\n        basic.lineplot(x=long_df.x, y=\"y\", data=long_df)\n        ax.clear()\n\n        basic.lineplot(x=\"x\", y=long_df.y.values, data=long_df)\n        ax.clear()\n\n        basic.lineplot(x=\"x\", y=\"y\", hue=\"a\", data=long_df)\n        ax.clear()\n\n        basic.lineplot(x=\"x\", y=\"y\", hue=\"a\", style=\"a\", data=long_df)\n        ax.clear()\n\n        basic.lineplot(x=\"x\", y=\"y\", hue=\"a\", style=\"b\", data=long_df)\n        ax.clear()\n\n        basic.lineplot(x=\"x\", y=\"y\", hue=\"a\", size=\"a\", data=long_df)\n        ax.clear()\n\n        basic.lineplot(x=\"x\", y=\"y\", hue=\"a\", size=\"s\", data=long_df)\n        ax.clear()\n", "comments": "  test named palette    test list palette    test dict palette    test dict missing keys    test list wrong number colors    test hue order    test long data    test default palette    test default palette many levels    test named colormap    test colormap object    test default hue limits    test specified hue limits    test default colormap values    test specified colormap values    test list colors    test dictionary colors    test invalid palette    test default size limits range    test specified size limits    test specified size range    test size values inferred ranges    test list sizes    test dict sizes    test sizes list wrong length    test sizes dict missing levels    test bad sizes argument    test defaults    test lists    test dicts    test style order defaults    test many levels style lists    test many levels style dicts                                                                   ", "content": "from __future__ import division\nfrom itertools import product\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom .. import basic\nfrom ..palettes import color_palette\nfrom ..utils import categorical_order\n\n\nclass TestBasicPlotter(object):\n\n    @pytest.fixture\n    def wide_df(self):\n\n        columns = list(\"abc\")\n        index = pd.Int64Index(np.arange(10, 50, 2), name=\"wide_index\")\n        values = np.random.randn(len(index), len(columns))\n        return pd.DataFrame(values, index=index, columns=columns)\n\n    @pytest.fixture\n    def wide_array(self):\n\n        return np.random.randn(20, 3)\n\n    @pytest.fixture\n    def flat_array(self):\n\n        return np.random.randn(20)\n\n    @pytest.fixture\n    def flat_series(self):\n\n        index = pd.Int64Index(np.arange(10, 30), name=\"t\")\n        return pd.Series(np.random.randn(20), index, name=\"s\")\n\n    @pytest.fixture\n    def wide_list(self):\n\n        return [np.random.randn(20), np.random.randn(10)]\n\n    @pytest.fixture\n    def wide_list_of_series(self):\n\n        return [pd.Series(np.random.randn(20), np.arange(20), name=\"a\"),\n                pd.Series(np.random.randn(10), np.arange(5, 15), name=\"b\")]\n\n    @pytest.fixture\n    def long_df(self):\n\n        n = 100\n        rs = np.random.RandomState()\n        return pd.DataFrame(dict(\n            x=rs.randint(0, 20, n),\n            y=rs.randn(n),\n            a=np.take(list(\"abc\"), rs.randint(0, 3, n)),\n            b=np.take(list(\"mnop\"), rs.randint(0, 4, n)),\n            s=np.take([2, 4, 8], rs.randint(0, 3, n)),\n        ))\n\n    @pytest.fixture\n    def null_column(self):\n\n        return pd.Series(index=np.arange(20))\n\n    def test_wide_df_variables(self, wide_df):\n\n        p = basic._BasicPlotter()\n        p.establish_variables(data=wide_df)\n        assert p.input_format == \"wide\"\n        assert len(p.plot_data) == np.product(wide_df.shape)\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.tile(wide_df.index, wide_df.shape[1])\n        assert np.array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = wide_df.values.ravel(order=\"f\")\n        assert np.array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        expected_hue = np.repeat(wide_df.columns.values, wide_df.shape[0])\n        assert np.array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert np.array_equal(style, expected_style)\n\n        assert p.plot_data[\"size\"].isnull().all()\n\n        assert p.x_label == wide_df.index.name\n        assert p.y_label is None\n        assert p.hue_label == wide_df.columns.name\n        assert p.size_label is None\n        assert p.style_label == wide_df.columns.name\n\n    def test_wide_df_variables_check(self, wide_df):\n\n        p = basic._BasicPlotter()\n        wide_df = wide_df.copy()\n        wide_df.loc[:, \"not_numeric\"] = \"a\"\n        with pytest.raises(ValueError):\n            p.establish_variables(data=wide_df)\n\n    def test_wide_array_variables(self, wide_array):\n\n        p = basic._BasicPlotter()\n        p.establish_variables(data=wide_array)\n        assert p.input_format == \"wide\"\n        assert len(p.plot_data) == np.product(wide_array.shape)\n\n        nrow, ncol = wide_array.shape\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.tile(np.arange(nrow), ncol)\n        assert np.array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = wide_array.ravel(order=\"f\")\n        assert np.array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        expected_hue = np.repeat(np.arange(ncol), nrow)\n        assert np.array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert np.array_equal(style, expected_style)\n\n        assert p.plot_data[\"size\"].isnull().all()\n\n        assert p.x_label is None\n        assert p.y_label is None\n        assert p.hue_label is None\n        assert p.size_label is None\n        assert p.style_label is None\n\n    def test_flat_array_variables(self, flat_array):\n\n        p = basic._BasicPlotter()\n        p.establish_variables(data=flat_array)\n        assert p.input_format == \"wide\"\n        assert len(p.plot_data) == np.product(flat_array.shape)\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.arange(flat_array.shape[0])\n        assert np.array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = flat_array\n        assert np.array_equal(y, expected_y)\n\n        assert p.plot_data[\"hue\"].isnull().all()\n        assert p.plot_data[\"style\"].isnull().all()\n        assert p.plot_data[\"size\"].isnull().all()\n\n        assert p.x_label is None\n        assert p.y_label is None\n        assert p.hue_label is None\n        assert p.size_label is None\n        assert p.style_label is None\n\n    def test_flat_series_variables(self, flat_series):\n\n        p = basic._BasicPlotter()\n        p.establish_variables(data=flat_series)\n        assert p.input_format == \"wide\"\n        assert len(p.plot_data) == len(flat_series)\n\n        x = p.plot_data[\"x\"]\n        expected_x = flat_series.index\n        assert np.array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = flat_series\n        assert np.array_equal(y, expected_y)\n\n        assert p.x_label is None\n        assert p.y_label is None\n        assert p.hue_label is None\n        assert p.size_label is None\n        assert p.style_label is None\n\n    def test_wide_list_variables(self, wide_list):\n\n        p = basic._BasicPlotter()\n        p.establish_variables(data=wide_list)\n        assert p.input_format == \"wide\"\n        assert len(p.plot_data) == sum(len(l) for l in wide_list)\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.concatenate([np.arange(len(l)) for l in wide_list])\n        assert np.array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = np.concatenate(wide_list)\n        assert np.array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        expected_hue = np.concatenate([\n            np.ones_like(l) * i for i, l in enumerate(wide_list)\n        ])\n        assert np.array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert np.array_equal(style, expected_style)\n\n        assert p.plot_data[\"size\"].isnull().all()\n\n        assert p.x_label is None\n        assert p.y_label is None\n        assert p.hue_label is None\n        assert p.size_label is None\n        assert p.style_label is None\n\n    def test_wide_list_of_series_variables(self, wide_list_of_series):\n\n        p = basic._BasicPlotter()\n        p.establish_variables(data=wide_list_of_series)\n        assert p.input_format == \"wide\"\n        assert len(p.plot_data) == sum(len(l) for l in wide_list_of_series)\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.concatenate([s.index for s in wide_list_of_series])\n        assert np.array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = np.concatenate(wide_list_of_series)\n        assert np.array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        expected_hue = np.concatenate([\n            np.full(len(s), s.name, object) for s in wide_list_of_series\n        ])\n        assert np.array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert np.array_equal(style, expected_style)\n\n        assert p.plot_data[\"size\"].isnull().all()\n\n        assert p.x_label is None\n        assert p.y_label is None\n        assert p.hue_label is None\n        assert p.size_label is None\n        assert p.style_label is None\n\n    def test_long_df(self, long_df):\n\n        p = basic._BasicPlotter()\n        p.establish_variables(x=\"x\", y=\"y\", data=long_df)\n        assert p.input_format == \"long\"\n\n        assert np.array_equal(p.plot_data[\"x\"], long_df[\"x\"])\n        assert np.array_equal(p.plot_data[\"y\"], long_df[\"y\"])\n        for col in [\"hue\", \"style\", \"size\"]:\n            assert p.plot_data[col].isnull().all()\n        assert (p.x_label, p.y_label) == (\"x\", \"y\")\n        assert p.hue_label is None\n        assert p.size_label is None\n        assert p.style_label is None\n\n        p.establish_variables(x=long_df.x, y=\"y\", data=long_df)\n        assert np.array_equal(p.plot_data[\"x\"], long_df[\"x\"])\n        assert np.array_equal(p.plot_data[\"y\"], long_df[\"y\"])\n        assert (p.x_label, p.y_label) == (\"x\", \"y\")\n\n        p.establish_variables(x=\"x\", y=long_df.y, data=long_df)\n        assert np.array_equal(p.plot_data[\"x\"], long_df[\"x\"])\n        assert np.array_equal(p.plot_data[\"y\"], long_df[\"y\"])\n        assert (p.x_label, p.y_label) == (\"x\", \"y\")\n\n        p.establish_variables(x=\"x\", y=\"y\", hue=\"a\", data=long_df)\n        assert np.array_equal(p.plot_data[\"hue\"], long_df[\"a\"])\n        for col in [\"style\", \"size\"]:\n            assert p.plot_data[col].isnull().all()\n        assert p.hue_label == \"a\"\n        assert p.size_label is None and p.style_label is None\n\n        p.establish_variables(x=\"x\", y=\"y\", hue=\"a\", style=\"a\", data=long_df)\n        assert np.array_equal(p.plot_data[\"hue\"], long_df[\"a\"])\n        assert np.array_equal(p.plot_data[\"style\"], long_df[\"a\"])\n        assert p.plot_data[\"size\"].isnull().all()\n        assert p.hue_label == p.style_label == \"a\"\n        assert p.size_label is None\n\n        p.establish_variables(x=\"x\", y=\"y\", hue=\"a\", style=\"b\", data=long_df)\n        assert np.array_equal(p.plot_data[\"hue\"], long_df[\"a\"])\n        assert np.array_equal(p.plot_data[\"style\"], long_df[\"b\"])\n        assert p.plot_data[\"size\"].isnull().all()\n\n        p.establish_variables(x=\"x\", y=\"y\", size=\"y\", data=long_df)\n        assert np.array_equal(p.plot_data[\"size\"], long_df[\"y\"])\n        assert p.size_label == \"y\"\n        assert p.hue_label is None and p.style_label is None\n\n    def test_bad_input(self, long_df):\n\n        p = basic._BasicPlotter()\n\n        with pytest.raises(ValueError):\n            p.establish_variables(x=long_df.x)\n\n        with pytest.raises(ValueError):\n            p.establish_variables(y=long_df.y)\n\n        with pytest.raises(ValueError):\n            p.establish_variables(x=\"not_in_df\", data=long_df)\n\n        with pytest.raises(ValueError):\n            p.establish_variables(x=\"x\", y=\"not_in_df\", data=long_df)\n\n        with pytest.raises(ValueError):\n            p.establish_variables(x=\"x\", y=\"not_in_df\", data=long_df)\n\n    def test_empty_input(self):\n\n        p = basic._BasicPlotter()\n\n        p.establish_variables(data=[])\n        p.establish_variables(data=np.array([]))\n        p.establish_variables(data=pd.DataFrame())\n        p.establish_variables(x=[], y=[])\n\n\nclass TestLinePlotter(TestBasicPlotter):\n\n    def test_parse_hue_null(self, wide_df, null_column):\n\n        p = basic._LinePlotter(data=wide_df)\n        p.parse_hue(null_column, \"Blues\", None, None)\n        assert p.hue_levels == [None]\n        assert p.palette == {}\n        assert p.hue_type is None\n        assert p.cmap is None\n\n    def test_parse_hue_categorical(self, wide_df, long_df):\n\n        p = basic._LinePlotter(data=wide_df)\n        assert p.hue_levels == wide_df.columns.tolist()\n        assert p.hue_type is \"categorical\"\n        assert p.cmap is None\n\n        # Test named palette\n        palette = \"Blues\"\n        expected_colors = color_palette(palette, wide_df.shape[1])\n        expected_palette = dict(zip(wide_df.columns, expected_colors))\n        p.parse_hue(p.plot_data.hue, palette, None, None)\n        assert p.palette == expected_palette\n\n        # Test list palette\n        palette = color_palette(\"Reds\", wide_df.shape[1])\n        p.parse_hue(p.plot_data.hue, palette, None, None)\n        expected_palette = dict(zip(wide_df.columns, palette))\n        assert p.palette == expected_palette\n\n        # Test dict palette\n        colors = color_palette(\"Set1\", 8)\n        palette = dict(zip(wide_df.columns, colors))\n        p.parse_hue(p.plot_data.hue, palette, None, None)\n        assert p.palette == palette\n\n        # Test dict with missing keys\n        palette = dict(zip(wide_df.columns[:-1], colors))\n        with pytest.raises(ValueError):\n            p.parse_hue(p.plot_data.hue, palette, None, None)\n\n        # Test list with wrong number of colors\n        palette = colors[:-1]\n        with pytest.raises(ValueError):\n            p.parse_hue(p.plot_data.hue, palette, None, None)\n\n        # Test hue order\n        hue_order = [\"a\", \"c\", \"d\"]\n        p.parse_hue(p.plot_data.hue, None, hue_order, None)\n        assert p.hue_levels == hue_order\n\n        # Test long data\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", data=long_df)\n        assert p.hue_levels == categorical_order(long_df.a)\n        assert p.hue_type is \"categorical\"\n        assert p.cmap is None\n\n        # Test default palette\n        p.parse_hue(p.plot_data.hue, None, None, None)\n        hue_levels = categorical_order(long_df.a)\n        expected_colors = color_palette(n_colors=len(hue_levels))\n        expected_palette = dict(zip(hue_levels, expected_colors))\n        assert p.palette == expected_palette\n\n        # Test default palette with many levels\n        levels = pd.Series(list(\"abcdefghijklmnopqrstuvwxyz\"))\n        p.parse_hue(levels, None, None, None)\n        expected_colors = color_palette(\"husl\", n_colors=len(levels))\n        expected_palette = dict(zip(levels, expected_colors))\n        assert p.palette == expected_palette\n\n    def test_parse_hue_numeric(self, long_df):\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"s\", data=long_df)\n        hue_levels = list(np.sort(long_df.s.unique()))\n        assert p.hue_levels == hue_levels\n        assert p.hue_type is \"numeric\"\n        assert p.cmap is mpl.cm.get_cmap(mpl.rcParams[\"image.cmap\"])\n\n        # Test named colormap\n        palette = \"Purples\"\n        p.parse_hue(p.plot_data.hue, palette, None, None)\n        assert p.cmap is mpl.cm.get_cmap(palette)\n\n        # Test colormap object\n        palette = mpl.cm.get_cmap(\"Greens\")\n        p.parse_hue(p.plot_data.hue, palette, None, None)\n        assert p.cmap is palette\n\n        # Test default hue limits\n        p.parse_hue(p.plot_data.hue, None, None, None)\n        assert p.hue_limits == (p.plot_data.hue.min(), p.plot_data.hue.max())\n\n        # Test specified hue limits\n        hue_limits = 1, 4\n        p.parse_hue(p.plot_data.hue, None, None, hue_limits)\n        assert p.hue_limits == hue_limits\n\n        # Test default colormap values\n        hmin, hmax = p.plot_data.hue.min(), p.plot_data.hue.max()\n        p.parse_hue(p.plot_data.hue, None, None, None)\n        assert p.palette[hmin] == pytest.approx(p.cmap(0.0))\n        assert p.palette[hmax] == pytest.approx(p.cmap(1.0))\n\n        # Test specified colormap values\n        hue_limits = hmin - 1, hmax - 1\n        p.parse_hue(p.plot_data.hue, None, None, hue_limits)\n        norm_min = (hmin - hue_limits[0]) / (hue_limits[1] - hue_limits[0])\n        assert p.palette[hmin] == pytest.approx(p.cmap(norm_min))\n        assert p.palette[hmax] == pytest.approx(p.cmap(1.0))\n\n        # Test list of colors\n        hue_levels = list(np.sort(long_df.s.unique()))\n        palette = color_palette(\"Blues\", len(hue_levels))\n        p.parse_hue(p.plot_data.hue, palette, None, None)\n        assert p.palette == dict(zip(hue_levels, palette))\n\n        palette = color_palette(\"Blues\", len(hue_levels) + 1)\n        with pytest.raises(ValueError):\n            p.parse_hue(p.plot_data.hue, palette, None, None)\n\n        # Test dictionary of colors\n        palette = dict(zip(hue_levels, color_palette(\"Reds\")))\n        p.parse_hue(p.plot_data.hue, palette, None, None)\n        assert p.palette == palette\n\n        palette.pop(hue_levels[0])\n        with pytest.raises(ValueError):\n            p.parse_hue(p.plot_data.hue, palette, None, None)\n\n        # Test invalid palette\n        palette = \"not_a_valid_palette\"\n        with pytest.raises(ValueError):\n            p.parse_hue(p.plot_data.hue, palette, None, None)\n\n    def test_parse_size(self, long_df):\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", size=\"s\", data=long_df)\n\n        # Test default size limits and range\n        default_linewidth = mpl.rcParams[\"lines.linewidth\"]\n        default_limits = p.plot_data[\"size\"].min(), p.plot_data[\"size\"].max()\n        default_range = .5 * default_linewidth, 2 * default_linewidth\n        p.parse_size(p.plot_data[\"size\"], None, None, None)\n        assert p.size_limits == default_limits\n        size_range = min(p.sizes.values()), max(p.sizes.values())\n        assert size_range == default_range\n\n        # Test specified size limits\n        size_limits = (1, 5)\n        p.parse_size(p.plot_data[\"size\"], None, None, size_limits)\n        assert p.size_limits == size_limits\n\n        # Test specified size range\n        sizes = (.1, .5)\n        p.parse_size(p.plot_data[\"size\"], sizes, None, None)\n        assert p.size_limits == default_limits\n\n        # Test size values inferred from ranges\n        sizes = (1, 5)\n        size_limits = (1, 10)\n        p.parse_size(p.plot_data[\"size\"], sizes, None, size_limits)\n        normalize = mpl.colors.Normalize(*size_limits, clip=False)\n        for level, width in p.sizes.items():\n            assert width == sizes[0] + (sizes[1] - sizes[0]) * normalize(level)\n\n        # Test list of sizes\n        var = \"a\"\n        levels = categorical_order(long_df[var])\n        sizes = list(np.random.rand(len(levels)))\n        p = basic._LinePlotter(x=\"x\", y=\"y\", size=var, data=long_df)\n        p.parse_size(p.plot_data[\"size\"], sizes, None, None)\n        assert p.sizes == dict(zip(levels, sizes))\n\n        # Test dict of sizes\n        var = \"a\"\n        levels = categorical_order(long_df[var])\n        sizes = dict(zip(levels, np.random.rand(len(levels))))\n        p = basic._LinePlotter(x=\"x\", y=\"y\", size=var, data=long_df)\n        p.parse_size(p.plot_data[\"size\"], sizes, None, None)\n        assert p.sizes == sizes\n\n        # Test sizes list with wrong length\n        sizes = list(np.random.rand(len(levels) + 1))\n        with pytest.raises(ValueError):\n            p.parse_size(p.plot_data[\"size\"], sizes, None, None)\n\n        # Test sizes dict with missing levels\n        sizes = dict(zip(levels, np.random.rand(len(levels) - 1)))\n        with pytest.raises(ValueError):\n            p.parse_size(p.plot_data[\"size\"], sizes, None, None)\n\n        # Test bad sizes argument\n        sizes = \"bad_size\"\n        with pytest.raises(ValueError):\n            p.parse_size(p.plot_data[\"size\"], sizes, None, None)\n\n    def test_parse_style(self, long_df):\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", style=\"a\", data=long_df)\n\n        # Test defaults\n        markers, dashes = True, True\n        p.parse_style(p.plot_data[\"style\"], markers, dashes, None)\n        assert p.markers == dict(zip(p.style_levels, p.default_markers))\n        assert p.dashes == dict(zip(p.style_levels, p.default_dashes))\n\n        # Test lists\n        markers, dashes = [\"o\", \"s\", \"d\"], [(1, 0), (1, 1), (2, 1, 3, 1)]\n        p.parse_style(p.plot_data[\"style\"], markers, dashes, None)\n        assert p.markers == dict(zip(p.style_levels, markers))\n        assert p.dashes == dict(zip(p.style_levels, dashes))\n\n        # Test dicts\n        markers = dict(zip(p.style_levels, markers))\n        dashes = dict(zip(p.style_levels, dashes))\n        p.parse_style(p.plot_data[\"style\"], markers, dashes, None)\n        assert p.markers == markers\n        assert p.dashes == dashes\n\n        # Test style order with defaults\n        style_order = np.take(p.style_levels, [1, 2, 0])\n        markers = dashes = True\n        p.parse_style(p.plot_data[\"style\"], markers, dashes, style_order)\n        assert p.markers == dict(zip(style_order, p.default_markers))\n        assert p.dashes == dict(zip(style_order, p.default_dashes))\n\n        # Test too many levels with style lists\n        markers, dashes = [\"o\", \"s\"], False\n        with pytest.raises(ValueError):\n            p.parse_style(p.plot_data[\"style\"], markers, dashes, None)\n\n        markers, dashes = False, [(2, 1)]\n        with pytest.raises(ValueError):\n            p.parse_style(p.plot_data[\"style\"], markers, dashes, None)\n\n        # Test too many levels with style dicts\n        markers, dashes = {\"a\": \"o\", \"b\": \"s\"}, False\n        with pytest.raises(ValueError):\n            p.parse_style(p.plot_data[\"style\"], markers, dashes, None)\n\n        markers, dashes = False, {\"a\": (1, 0), \"b\": (2, 1)}\n        with pytest.raises(ValueError):\n            p.parse_style(p.plot_data[\"style\"], markers, dashes, None)\n\n    def test_subset_data_quantities(self, long_df):\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df)\n        assert len(list(p.subset_data())) == 1\n\n        # --\n\n        var = \"a\"\n        n_subsets = len(long_df[var].unique())\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=var, data=long_df)\n        assert len(list(p.subset_data())) == n_subsets\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", style=var, data=long_df)\n        assert len(list(p.subset_data())) == n_subsets\n\n        n_subsets = len(long_df[var].unique())\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", size=var, data=long_df)\n        assert len(list(p.subset_data())) == n_subsets\n\n        # --\n\n        var = \"a\"\n        n_subsets = len(long_df[var].unique())\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=var, style=var, data=long_df)\n        assert len(list(p.subset_data())) == n_subsets\n\n        # --\n\n        var1, var2 = \"a\", \"s\"\n        n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=var1, style=var2,\n                               data=long_df)\n        assert len(list(p.subset_data())) == n_subsets\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=var1, size=var2, style=var1,\n                               data=long_df)\n        assert len(list(p.subset_data())) == n_subsets\n\n        # --\n\n        var1, var2, var3 = \"a\", \"s\", \"b\"\n        cols = [var1, var2, var3]\n        n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=var1, size=var2, style=var3,\n                               data=long_df)\n        assert len(list(p.subset_data())) == n_subsets\n\n    def test_subset_data_keys(self, long_df):\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df)\n        for (hue, size, style), _ in p.subset_data():\n            assert hue is None\n            assert size is None\n            assert style is None\n\n        # --\n\n        var = \"a\"\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=var, data=long_df)\n        for (hue, size, style), _ in p.subset_data():\n            assert hue in long_df[var].values\n            assert size is None\n            assert style is None\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", style=var, data=long_df)\n        for (hue, size, style), _ in p.subset_data():\n            assert hue is None\n            assert size is None\n            assert style in long_df[var].values\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=var, style=var, data=long_df)\n        for (hue, size, style), _ in p.subset_data():\n            assert hue in long_df[var].values\n            assert size is None\n            assert style in long_df[var].values\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", size=var, data=long_df)\n        for (hue, size, style), _ in p.subset_data():\n            assert hue is None\n            assert size in long_df[var].values\n            assert style is None\n\n        # --\n\n        var1, var2 = \"a\", \"s\"\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=var1, size=var2, data=long_df)\n        for (hue, size, style), _ in p.subset_data():\n            assert hue in long_df[var1].values\n            assert size in long_df[var2].values\n            assert style is None\n\n    def test_subset_data_values(self, long_df):\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df)\n        _, data = next(p.subset_data())\n        expected = basic.sort_df(p.plot_data.loc[:, [\"x\", \"y\"]], [\"x\", \"y\"])\n        assert np.array_equal(data.values, expected)\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df, sort=False)\n        _, data = next(p.subset_data())\n        expected = p.plot_data.loc[:, [\"x\", \"y\"]]\n        assert np.array_equal(data.values, expected)\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", data=long_df)\n        for (hue, _, _), data in p.subset_data():\n            rows = p.plot_data[\"hue\"] == hue\n            cols = [\"x\", \"y\"]\n            expected = basic.sort_df(p.plot_data.loc[rows, cols], cols)\n            assert np.array_equal(data.values, expected.values)\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", data=long_df, sort=False)\n        for (hue, _, _), data in p.subset_data():\n            rows = p.plot_data[\"hue\"] == hue\n            cols = [\"x\", \"y\"]\n            expected = p.plot_data.loc[rows, cols]\n            assert np.array_equal(data.values, expected.values)\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", style=\"a\", data=long_df)\n        for (hue, _, _), data in p.subset_data():\n            rows = p.plot_data[\"hue\"] == hue\n            cols = [\"x\", \"y\"]\n            expected = basic.sort_df(p.plot_data.loc[rows, cols], cols)\n            assert np.array_equal(data.values, expected.values)\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", size=\"s\", data=long_df)\n        for (hue, size, _), data in p.subset_data():\n            rows = (p.plot_data[\"hue\"] == hue) & (p.plot_data[\"size\"] == size)\n            cols = [\"x\", \"y\"]\n            expected = basic.sort_df(p.plot_data.loc[rows, cols], cols)\n            assert np.array_equal(data.values, expected.values)\n\n    def test_aggregate(self, long_df):\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df)\n        p.n_boot = 10000\n        p.sort = False\n\n        x = pd.Series(np.tile([1, 2], 100))\n        y = pd.Series(np.random.randn(200))\n        y_mean = y.groupby(x).mean()\n\n        def sem(x):\n            return np.std(x) / np.sqrt(len(x))\n\n        y_sem = y.groupby(x).apply(sem)\n        y_cis = pd.DataFrame(dict(low=y_mean - y_sem,\n                                  high=y_mean + y_sem),\n                             columns=[\"low\", \"high\"])\n\n        index, est, cis = p.aggregate(y, x, \"mean\", 68)\n        assert np.array_equal(index.values, x.unique())\n        assert est.index.equals(index)\n        assert est.values == pytest.approx(y_mean.values)\n        assert cis.values == pytest.approx(y_cis.values, 4)\n        assert list(cis.columns) == [\"low\", \"high\"]\n\n        index, est, cis = p.aggregate(y, x, np.mean, 68)\n        assert np.array_equal(index.values, x.unique())\n        assert est.index.equals(index)\n        assert est.values == pytest.approx(y_mean.values)\n        assert cis.values == pytest.approx(y_cis.values, 4)\n        assert list(cis.columns) == [\"low\", \"high\"]\n\n        y_std = y.groupby(x).std()\n        y_cis = pd.DataFrame(dict(low=y_mean - y_std,\n                                  high=y_mean + y_std),\n                             columns=[\"low\", \"high\"])\n\n        index, est, cis = p.aggregate(y, x, \"mean\", \"sd\")\n        assert np.array_equal(index.values, x.unique())\n        assert est.index.equals(index)\n        assert est.values == pytest.approx(y_mean.values)\n        assert cis.values == pytest.approx(y_cis.values)\n        assert list(cis.columns) == [\"low\", \"high\"]\n\n        index, est, cis = p.aggregate(y, x, \"mean\", None)\n        assert cis is None\n\n        x, y = pd.Series([1, 2, 3]), pd.Series([4, 3, 2])\n        index, est, cis = p.aggregate(y, x, \"mean\", 68)\n        assert np.array_equal(index.values, x)\n        assert np.array_equal(est.values, y)\n        assert cis is None\n\n        x, y = pd.Series([1, 1, 2]), pd.Series([2, 3, 4])\n        index, est, cis = p.aggregate(y, x, \"mean\", 68)\n        assert cis.loc[2].isnull().all()\n\n    def test_legend_data(self, long_df):\n\n        f, ax = plt.subplots()\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df, legend=\"full\")\n        p.add_legend_data(ax)\n        handles, _ = ax.get_legend_handles_labels()\n        assert handles == []\n\n        # --\n\n        ax.clear()\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", data=long_df,\n                               legend=\"full\")\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        colors = [h.get_color() for h in handles]\n        assert labels == p.hue_levels\n        assert colors == [p.palette[l] for l in labels]\n\n        # --\n\n        ax.clear()\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", style=\"a\",\n                               markers=True, legend=\"full\", data=long_df)\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        colors = [h.get_color() for h in handles]\n        markers = [h.get_marker() for h in handles]\n        assert labels == p.hue_levels == p.style_levels\n        assert colors == [p.palette[l] for l in labels]\n        assert markers == [p.markers[l] for l in labels]\n\n        # --\n\n        ax.clear()\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", style=\"b\",\n                               markers=True, legend=\"full\", data=long_df)\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        colors = [h.get_color() for h in handles]\n        markers = [h.get_marker() for h in handles]\n        expected_colors = ([p.palette[l] for l in p.hue_levels]\n                           + [\".2\" for _ in p.style_levels])\n        expected_markers = ([\"None\" for _ in p.hue_levels]\n                            + [p.markers[l] for l in p.style_levels])\n        assert labels == p.hue_levels + p.style_levels\n        assert colors == expected_colors\n        assert markers == expected_markers\n\n        # --\n\n        ax.clear()\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", size=\"a\", data=long_df,\n                               legend=\"full\")\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        colors = [h.get_color() for h in handles]\n        widths = [h.get_linewidth() for h in handles]\n        assert labels == p.hue_levels == p.size_levels\n        assert colors == [p.palette[l] for l in labels]\n        assert widths == [p.sizes[l] for l in labels]\n\n        # --\n\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n\n        p = basic._LinePlotter(x=x, y=y, hue=z)\n\n        ax.clear()\n        p.legend = \"full\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert labels == [str(l) for l in p.hue_levels]\n\n        ax.clear()\n        p.legend = \"brief\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert len(labels) == 4\n\n        p = basic._LinePlotter(x=x, y=y, size=z)\n\n        ax.clear()\n        p.legend = \"full\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert labels == [str(l) for l in p.size_levels]\n\n        ax.clear()\n        p.legend = \"brief\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert len(labels) == 4\n\n        ax.clear()\n        p.legend = \"bad_value\"\n        with pytest.raises(ValueError):\n            p.add_legend_data(ax)\n\n    def test_plot(self, long_df):\n\n        f, ax = plt.subplots()\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df,\n                               sort=False, estimator=None)\n        p.plot(ax, {})\n        line, = ax.lines\n        assert np.array_equal(line.get_xdata(), long_df.x.values)\n        assert np.array_equal(line.get_ydata(), long_df.y.values)\n\n        ax.clear()\n        p.plot(ax, {\"color\": \"k\", \"label\": \"test\"})\n        line, = ax.lines\n        assert line.get_color() == \"k\"\n        assert line.get_label() == \"test\"\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df,\n                               sort=True, estimator=None)\n\n        ax.clear()\n        p.plot(ax, {})\n        line, = ax.lines\n        sorted_data = basic.sort_df(long_df, [\"x\", \"y\"])\n        assert np.array_equal(line.get_xdata(), sorted_data.x.values)\n        assert np.array_equal(line.get_ydata(), sorted_data.y.values)\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", data=long_df)\n\n        ax.clear()\n        p.plot(ax, {})\n        assert len(ax.lines) == len(p.hue_levels)\n        for line, level in zip(ax.lines, p.hue_levels):\n            assert line.get_color() == p.palette[level]\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", size=\"a\", data=long_df)\n\n        ax.clear()\n        p.plot(ax, {})\n        assert len(ax.lines) == len(p.size_levels)\n        for line, level in zip(ax.lines, p.size_levels):\n            assert line.get_linewidth() == p.sizes[level]\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", style=\"a\",\n                               markers=True, data=long_df)\n\n        ax.clear()\n        p.plot(ax, {})\n        assert len(ax.lines) == len(p.hue_levels) == len(p.style_levels)\n        for line, level in zip(ax.lines, p.hue_levels):\n            assert line.get_color() == p.palette[level]\n            assert line.get_marker() == p.markers[level]\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", style=\"b\",\n                               markers=True, data=long_df)\n\n        ax.clear()\n        p.plot(ax, {})\n        levels = product(p.hue_levels, p.style_levels)\n        assert len(ax.lines) == (len(p.hue_levels) * len(p.style_levels))\n        for line, (hue, style) in zip(ax.lines, levels):\n            assert line.get_color() == p.palette[hue]\n            assert line.get_marker() == p.markers[style]\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df,\n                               estimator=\"mean\", errstyle=\"band\", ci=\"sd\",\n                               sort=True)\n\n        ax.clear()\n        p.plot(ax, {})\n        line, = ax.lines\n        expected_data = long_df.groupby(\"x\").y.mean()\n        assert np.array_equal(line.get_xdata(), expected_data.index.values)\n        assert np.allclose(line.get_ydata(), expected_data.values)\n        assert len(ax.collections) == 1\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", data=long_df,\n                               estimator=\"mean\", errstyle=\"band\", ci=\"sd\")\n\n        ax.clear()\n        p.plot(ax, {})\n        assert len(ax.lines) == len(ax.collections) == len(p.hue_levels)\n        for c in ax.collections:\n            assert isinstance(c, mpl.collections.PolyCollection)\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", hue=\"a\", data=long_df,\n                               estimator=\"mean\", errstyle=\"bars\", ci=\"sd\")\n\n        ax.clear()\n        p.plot(ax, {})\n        assert len(ax.lines) == len(ax.collections) == len(p.hue_levels)\n        for c in ax.collections:\n            assert isinstance(c, mpl.collections.LineCollection)\n\n    def test_axis_labels(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\n\n        p = basic._LinePlotter(x=\"x\", y=\"y\", data=long_df)\n\n        p.plot(ax1, {})\n        assert ax1.get_xlabel() == \"x\"\n        assert ax1.get_ylabel() == \"y\"\n\n        p.plot(ax2, {})\n        assert ax2.get_xlabel() == \"x\"\n        assert ax2.get_ylabel() == \"y\"\n        assert not ax2.yaxis.label.get_visible()\n\n    def test_lineplot_axes(self, wide_df):\n\n        f1, ax1 = plt.subplots()\n        f2, ax2 = plt.subplots()\n\n        ax = basic.lineplot(data=wide_df)\n        assert ax is ax2\n\n        ax = basic.lineplot(data=wide_df, ax=ax1)\n        assert ax is ax1\n\n    def test_lineplot_smoke(self, flat_array, flat_series,\n                            wide_array, wide_list, wide_list_of_series,\n                            wide_df, long_df):\n\n        f, ax = plt.subplots()\n\n        basic.lineplot(data=flat_array)\n        ax.clear()\n\n        basic.lineplot(data=flat_series)\n        ax.clear()\n\n        basic.lineplot(data=wide_array)\n        ax.clear()\n\n        basic.lineplot(data=wide_list)\n        ax.clear()\n\n        basic.lineplot(data=wide_list_of_series)\n        ax.clear()\n\n        basic.lineplot(data=wide_df)\n        ax.clear()\n\n        basic.lineplot(x=\"x\", y=\"y\", data=long_df)\n        ax.clear()\n\n        basic.lineplot(x=long_df.x, y=long_df.y)\n        ax.clear()\n\n        basic.lineplot(x=long_df.x, y=\"y\", data=long_df)\n        ax.clear()\n\n        basic.lineplot(x=\"x\", y=long_df.y.values, data=long_df)\n        ax.clear()\n\n        basic.lineplot(x=\"x\", y=\"y\", hue=\"a\", data=long_df)\n        ax.clear()\n\n        basic.lineplot(x=\"x\", y=\"y\", hue=\"a\", style=\"a\", data=long_df)\n        ax.clear()\n\n        basic.lineplot(x=\"x\", y=\"y\", hue=\"a\", style=\"b\", data=long_df)\n        ax.clear()\n\n        basic.lineplot(x=\"x\", y=\"y\", hue=\"a\", size=\"a\", data=long_df)\n        ax.clear()\n\n        basic.lineplot(x=\"x\", y=\"y\", hue=\"a\", size=\"s\", data=long_df)\n        ax.clear()\n", "description": "Statistical data visualization using matplotlib", "file_name": "test_basic.py", "id": "f7a2f06b7fa328d867e000cffe6aa5a9", "language": "Python", "project_name": "seaborn", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mwaskom-seaborn/mwaskom-seaborn-71a807b/seaborn/tests/test_basic.py", "save_time": "", "source": "", "update_at": "2018-03-18T02:14:24Z", "url": "https://github.com/mwaskom/seaborn", "wiki": false}