{"author": "HelloZeroNet", "code": "\n This file is part of pyasn1 software.\n\n Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>\n License: http://pyasn1.sf.net/license.html\n\nfrom pyasn1.type import base, univ, char, useful, tag\nfrom pyasn1 import debug, error\n\n__all__ = ['decode']\n\n\nclass AbstractScalarDecoder(object):\n    def __call__(self, pyObject, asn1Spec, decoderFunc=None):\n        return asn1Spec.clone(pyObject)\n\n\nclass BitStringDecoder(AbstractScalarDecoder):\n    def __call__(self, pyObject, asn1Spec, decoderFunc=None):\n        return asn1Spec.clone(univ.BitString.fromBinaryString(pyObject))\n\n\nclass SequenceOrSetDecoder(object):\n    def __call__(self, pyObject, asn1Spec, decoderFunc):\n        asn1Value = asn1Spec.clone()\n\n        componentsTypes = asn1Spec.getComponentType()\n\n        for field in asn1Value:\n            if field in pyObject:\n                asn1Value[field] = decoderFunc(pyObject[field], componentsTypes[field].asn1Object)\n\n        return asn1Value\n\n\nclass SequenceOfOrSetOfDecoder(object):\n    def __call__(self, pyObject, asn1Spec, decoderFunc):\n        asn1Value = asn1Spec.clone()\n\n        for pyValue in pyObject:\n            asn1Value.append(decoderFunc(pyValue, asn1Spec.getComponentType()))\n\n        return asn1Value\n\n\nclass ChoiceDecoder(object):\n    def __call__(self, pyObject, asn1Spec, decoderFunc):\n        asn1Value = asn1Spec.clone()\n\n        componentsTypes = asn1Spec.getComponentType()\n\n        for field in pyObject:\n            if field in componentsTypes:\n                asn1Value[field] = decoderFunc(pyObject[field], componentsTypes[field].asn1Object)\n                break\n\n        return asn1Value\n\n\ntagMap = {\n    univ.Integer.tagSet: AbstractScalarDecoder(),\n    univ.Boolean.tagSet: AbstractScalarDecoder(),\n    univ.BitString.tagSet: BitStringDecoder(),\n    univ.OctetString.tagSet: AbstractScalarDecoder(),\n    univ.Null.tagSet: AbstractScalarDecoder(),\n    univ.ObjectIdentifier.tagSet: AbstractScalarDecoder(),\n    univ.Enumerated.tagSet: AbstractScalarDecoder(),\n    univ.Real.tagSet: AbstractScalarDecoder(),\n    univ.Sequence.tagSet: SequenceOrSetDecoder(),   conflicts with SequenceOf\n    univ.Set.tagSet: SequenceOrSetDecoder(),   conflicts with SetOf\n    univ.Choice.tagSet: ChoiceDecoder(),   conflicts with Any\n     character string types\n    char.UTF8String.tagSet: AbstractScalarDecoder(),\n    char.NumericString.tagSet: AbstractScalarDecoder(),\n    char.PrintableString.tagSet: AbstractScalarDecoder(),\n    char.TeletexString.tagSet: AbstractScalarDecoder(),\n    char.VideotexString.tagSet: AbstractScalarDecoder(),\n    char.IA5String.tagSet: AbstractScalarDecoder(),\n    char.GraphicString.tagSet: AbstractScalarDecoder(),\n    char.VisibleString.tagSet: AbstractScalarDecoder(),\n    char.GeneralString.tagSet: AbstractScalarDecoder(),\n    char.UniversalString.tagSet: AbstractScalarDecoder(),\n    char.BMPString.tagSet: AbstractScalarDecoder(),\n     useful types\n    useful.ObjectDescriptor.tagSet: AbstractScalarDecoder(),\n    useful.GeneralizedTime.tagSet: AbstractScalarDecoder(),\n    useful.UTCTime.tagSet: AbstractScalarDecoder()\n}\n\n Put in ambiguous & non-ambiguous types for faster codec lookup\ntypeMap = {\n    univ.Integer.typeId: AbstractScalarDecoder(),\n    univ.Boolean.typeId: AbstractScalarDecoder(),\n    univ.BitString.typeId: BitStringDecoder(),\n    univ.OctetString.typeId: AbstractScalarDecoder(),\n    univ.Null.typeId: AbstractScalarDecoder(),\n    univ.ObjectIdentifier.typeId: AbstractScalarDecoder(),\n    univ.Enumerated.typeId: AbstractScalarDecoder(),\n    univ.Real.typeId: AbstractScalarDecoder(),\n     ambiguous base types\n    univ.Set.typeId: SequenceOrSetDecoder(),\n    univ.SetOf.typeId: SequenceOfOrSetOfDecoder(),\n    univ.Sequence.typeId: SequenceOrSetDecoder(),\n    univ.SequenceOf.typeId: SequenceOfOrSetOfDecoder(),\n    univ.Choice.typeId: ChoiceDecoder(),\n    univ.Any.typeId: AbstractScalarDecoder(),\n     character string types\n    char.UTF8String.typeId: AbstractScalarDecoder(),\n    char.NumericString.typeId: AbstractScalarDecoder(),\n    char.PrintableString.typeId: AbstractScalarDecoder(),\n    char.TeletexString.typeId: AbstractScalarDecoder(),\n    char.VideotexString.typeId: AbstractScalarDecoder(),\n    char.IA5String.typeId: AbstractScalarDecoder(),\n    char.GraphicString.typeId: AbstractScalarDecoder(),\n    char.VisibleString.typeId: AbstractScalarDecoder(),\n    char.GeneralString.typeId: AbstractScalarDecoder(),\n    char.UniversalString.typeId: AbstractScalarDecoder(),\n    char.BMPString.typeId: AbstractScalarDecoder(),\n     useful types\n    useful.ObjectDescriptor.typeId: AbstractScalarDecoder(),\n    useful.GeneralizedTime.typeId: AbstractScalarDecoder(),\n    useful.UTCTime.typeId: AbstractScalarDecoder()\n}\n\n\nclass Decoder(object):\n\n     noinspection PyDefaultArgument\n    def __init__(self, tagMap, typeMap):\n        self.__tagMap = tagMap\n        self.__typeMap = typeMap\n\n    def __call__(self, pyObject, asn1Spec):\n        if debug.logger & debug.flagDecoder:\n            debug.scope.push(type(pyObject).__name__)\n            debug.logger('decoder called at scope %s, working with type %s' % (debug.scope, type(pyObject).__name__))\n\n        if asn1Spec is None or not isinstance(asn1Spec, base.Asn1Item):\n            raise error.PyAsn1Error('asn1Spec is not valid (should be an instance of an ASN.1 Item, not %s)' % asn1Spec.__class__.__name__)\n\n        try:\n            valueDecoder = self.__typeMap[asn1Spec.typeId]\n        except KeyError:\n             use base type for codec lookup to recover untagged types\n            baseTagSet = tag.TagSet(asn1Spec.tagSet.baseTag, asn1Spec.tagSet.baseTag)\n            try:\n                valueDecoder = self.__tagMap[baseTagSet]\n            except KeyError:\n                raise error.PyAsn1Error('Unknown ASN.1 tag %s' % asn1Spec.tagSet)\n\n        if debug.logger & debug.flagDecoder:\n            debug.logger('calling decoder %s on Python type %s <%s>' % (type(valueDecoder).__name__, type(pyObject).__name__, repr(pyObject)))\n\n        value = valueDecoder(pyObject, asn1Spec, self)\n\n        if debug.logger & debug.flagDecoder:\n            debug.logger('decoder %s produced ASN.1 type %s <%s>' % (type(valueDecoder).__name__, type(value).__name__, repr(value)))\n            debug.scope.pop()\n\n        return value\n\n\n: Turns Python objects of built-in types into ASN.1 objects.\n:\n: Takes Python objects of built-in types and turns them into a tree of\n: ASN.1 objects (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which\n: may be a scalar or an arbitrary nested structure.\n:\n: Parameters\n: ----------\n: pyObject: :py:class:`object`\n:     A scalar or nested Python objects\n:\n: asn1Spec: any pyasn1 type object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n:     A pyasn1 type object to act as a template guiding the decoder. It is required\n:     for successful interpretation of Python objects mapping into their ASN.1\n:     representations.\n:\n: Returns\n: -------\n: : :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n:     A scalar or constructed pyasn1 object\n:\n: Raises\n: ------\n: : :py:class:`pyasn1.error.PyAsn1Error`\n:     On decoding errors\ndecode = Decoder(tagMap, typeMap)\n", "comments": "     this file part pyasn1 software        copyright (c) 2005 2017  ilya etingof  etingof gmail com     license  http   pyasn1 sf net license html       conflicts sequenceof    conflicts setof    conflicts any    character string types    useful types    put ambiguous   non ambiguous types faster codec lookup    ambiguous base types    character string types    useful types    noinspection pydefaultargument    use base type codec lookup recover untagged types     turns python objects built types asn 1 objects          takes python objects built types turns tree     asn 1 objects (e g   py class   pyasn1 type base pyasn1item  derivative)     may scalar arbitrary nested structure          parameters                    pyobject   py class  object          a scalar nested python objects         asn1spec  pyasn1 type object e g   py class   pyasn1 type base pyasn1item  derivative         a pyasn1 type object act template guiding decoder  it required         successful interpretation python objects mapping asn 1         representations          returns                    py class   pyasn1 type base pyasn1item  derivative         a scalar constructed pyasn1 object         raises                   py class  pyasn1 error pyasn1error          on decoding errors ", "content": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>\n# License: http://pyasn1.sf.net/license.html\n#\nfrom pyasn1.type import base, univ, char, useful, tag\nfrom pyasn1 import debug, error\n\n__all__ = ['decode']\n\n\nclass AbstractScalarDecoder(object):\n    def __call__(self, pyObject, asn1Spec, decoderFunc=None):\n        return asn1Spec.clone(pyObject)\n\n\nclass BitStringDecoder(AbstractScalarDecoder):\n    def __call__(self, pyObject, asn1Spec, decoderFunc=None):\n        return asn1Spec.clone(univ.BitString.fromBinaryString(pyObject))\n\n\nclass SequenceOrSetDecoder(object):\n    def __call__(self, pyObject, asn1Spec, decoderFunc):\n        asn1Value = asn1Spec.clone()\n\n        componentsTypes = asn1Spec.getComponentType()\n\n        for field in asn1Value:\n            if field in pyObject:\n                asn1Value[field] = decoderFunc(pyObject[field], componentsTypes[field].asn1Object)\n\n        return asn1Value\n\n\nclass SequenceOfOrSetOfDecoder(object):\n    def __call__(self, pyObject, asn1Spec, decoderFunc):\n        asn1Value = asn1Spec.clone()\n\n        for pyValue in pyObject:\n            asn1Value.append(decoderFunc(pyValue, asn1Spec.getComponentType()))\n\n        return asn1Value\n\n\nclass ChoiceDecoder(object):\n    def __call__(self, pyObject, asn1Spec, decoderFunc):\n        asn1Value = asn1Spec.clone()\n\n        componentsTypes = asn1Spec.getComponentType()\n\n        for field in pyObject:\n            if field in componentsTypes:\n                asn1Value[field] = decoderFunc(pyObject[field], componentsTypes[field].asn1Object)\n                break\n\n        return asn1Value\n\n\ntagMap = {\n    univ.Integer.tagSet: AbstractScalarDecoder(),\n    univ.Boolean.tagSet: AbstractScalarDecoder(),\n    univ.BitString.tagSet: BitStringDecoder(),\n    univ.OctetString.tagSet: AbstractScalarDecoder(),\n    univ.Null.tagSet: AbstractScalarDecoder(),\n    univ.ObjectIdentifier.tagSet: AbstractScalarDecoder(),\n    univ.Enumerated.tagSet: AbstractScalarDecoder(),\n    univ.Real.tagSet: AbstractScalarDecoder(),\n    univ.Sequence.tagSet: SequenceOrSetDecoder(),  # conflicts with SequenceOf\n    univ.Set.tagSet: SequenceOrSetDecoder(),  # conflicts with SetOf\n    univ.Choice.tagSet: ChoiceDecoder(),  # conflicts with Any\n    # character string types\n    char.UTF8String.tagSet: AbstractScalarDecoder(),\n    char.NumericString.tagSet: AbstractScalarDecoder(),\n    char.PrintableString.tagSet: AbstractScalarDecoder(),\n    char.TeletexString.tagSet: AbstractScalarDecoder(),\n    char.VideotexString.tagSet: AbstractScalarDecoder(),\n    char.IA5String.tagSet: AbstractScalarDecoder(),\n    char.GraphicString.tagSet: AbstractScalarDecoder(),\n    char.VisibleString.tagSet: AbstractScalarDecoder(),\n    char.GeneralString.tagSet: AbstractScalarDecoder(),\n    char.UniversalString.tagSet: AbstractScalarDecoder(),\n    char.BMPString.tagSet: AbstractScalarDecoder(),\n    # useful types\n    useful.ObjectDescriptor.tagSet: AbstractScalarDecoder(),\n    useful.GeneralizedTime.tagSet: AbstractScalarDecoder(),\n    useful.UTCTime.tagSet: AbstractScalarDecoder()\n}\n\n# Put in ambiguous & non-ambiguous types for faster codec lookup\ntypeMap = {\n    univ.Integer.typeId: AbstractScalarDecoder(),\n    univ.Boolean.typeId: AbstractScalarDecoder(),\n    univ.BitString.typeId: BitStringDecoder(),\n    univ.OctetString.typeId: AbstractScalarDecoder(),\n    univ.Null.typeId: AbstractScalarDecoder(),\n    univ.ObjectIdentifier.typeId: AbstractScalarDecoder(),\n    univ.Enumerated.typeId: AbstractScalarDecoder(),\n    univ.Real.typeId: AbstractScalarDecoder(),\n    # ambiguous base types\n    univ.Set.typeId: SequenceOrSetDecoder(),\n    univ.SetOf.typeId: SequenceOfOrSetOfDecoder(),\n    univ.Sequence.typeId: SequenceOrSetDecoder(),\n    univ.SequenceOf.typeId: SequenceOfOrSetOfDecoder(),\n    univ.Choice.typeId: ChoiceDecoder(),\n    univ.Any.typeId: AbstractScalarDecoder(),\n    # character string types\n    char.UTF8String.typeId: AbstractScalarDecoder(),\n    char.NumericString.typeId: AbstractScalarDecoder(),\n    char.PrintableString.typeId: AbstractScalarDecoder(),\n    char.TeletexString.typeId: AbstractScalarDecoder(),\n    char.VideotexString.typeId: AbstractScalarDecoder(),\n    char.IA5String.typeId: AbstractScalarDecoder(),\n    char.GraphicString.typeId: AbstractScalarDecoder(),\n    char.VisibleString.typeId: AbstractScalarDecoder(),\n    char.GeneralString.typeId: AbstractScalarDecoder(),\n    char.UniversalString.typeId: AbstractScalarDecoder(),\n    char.BMPString.typeId: AbstractScalarDecoder(),\n    # useful types\n    useful.ObjectDescriptor.typeId: AbstractScalarDecoder(),\n    useful.GeneralizedTime.typeId: AbstractScalarDecoder(),\n    useful.UTCTime.typeId: AbstractScalarDecoder()\n}\n\n\nclass Decoder(object):\n\n    # noinspection PyDefaultArgument\n    def __init__(self, tagMap, typeMap):\n        self.__tagMap = tagMap\n        self.__typeMap = typeMap\n\n    def __call__(self, pyObject, asn1Spec):\n        if debug.logger & debug.flagDecoder:\n            debug.scope.push(type(pyObject).__name__)\n            debug.logger('decoder called at scope %s, working with type %s' % (debug.scope, type(pyObject).__name__))\n\n        if asn1Spec is None or not isinstance(asn1Spec, base.Asn1Item):\n            raise error.PyAsn1Error('asn1Spec is not valid (should be an instance of an ASN.1 Item, not %s)' % asn1Spec.__class__.__name__)\n\n        try:\n            valueDecoder = self.__typeMap[asn1Spec.typeId]\n        except KeyError:\n            # use base type for codec lookup to recover untagged types\n            baseTagSet = tag.TagSet(asn1Spec.tagSet.baseTag, asn1Spec.tagSet.baseTag)\n            try:\n                valueDecoder = self.__tagMap[baseTagSet]\n            except KeyError:\n                raise error.PyAsn1Error('Unknown ASN.1 tag %s' % asn1Spec.tagSet)\n\n        if debug.logger & debug.flagDecoder:\n            debug.logger('calling decoder %s on Python type %s <%s>' % (type(valueDecoder).__name__, type(pyObject).__name__, repr(pyObject)))\n\n        value = valueDecoder(pyObject, asn1Spec, self)\n\n        if debug.logger & debug.flagDecoder:\n            debug.logger('decoder %s produced ASN.1 type %s <%s>' % (type(valueDecoder).__name__, type(value).__name__, repr(value)))\n            debug.scope.pop()\n\n        return value\n\n\n#: Turns Python objects of built-in types into ASN.1 objects.\n#:\n#: Takes Python objects of built-in types and turns them into a tree of\n#: ASN.1 objects (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which\n#: may be a scalar or an arbitrary nested structure.\n#:\n#: Parameters\n#: ----------\n#: pyObject: :py:class:`object`\n#:     A scalar or nested Python objects\n#:\n#: asn1Spec: any pyasn1 type object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:     A pyasn1 type object to act as a template guiding the decoder. It is required\n#:     for successful interpretation of Python objects mapping into their ASN.1\n#:     representations.\n#:\n#: Returns\n#: -------\n#: : :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:     A scalar or constructed pyasn1 object\n#:\n#: Raises\n#: ------\n#: : :py:class:`pyasn1.error.PyAsn1Error`\n#:     On decoding errors\ndecode = Decoder(tagMap, typeMap)\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "decoder.py", "id": "fff72e8b8880ef572dd2b82613b68f1d", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/lib/pyasn1/codec/native/decoder.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}