{"author": "sympy", "code": "from sympy.unify.core import Compound, Variable, CondVariable, allcombinations\nfrom sympy.unify import core\n\na,b,c = 'abc'\nw,x,y,z = map(Variable, 'wxyz')\n\nC = Compound\n\ndef is_associative(x):\n    return isinstance(x, Compound) and (x.op in ('Add', 'Mul', 'CAdd', 'CMul'))\ndef is_commutative(x):\n    return isinstance(x, Compound) and (x.op in ('CAdd', 'CMul'))\n\n\ndef unify(a, b, s={}):\n    return core.unify(a, b, s=s, is_associative=is_associative,\n                          is_commutative=is_commutative)\n\ndef test_basic():\n    assert list(unify(a, x, {})) == [{x: a}]\n    assert list(unify(a, x, {x: 10})) == []\n    assert list(unify(1, x, {})) == [{x: 1}]\n    assert list(unify(a, a, {})) == [{}]\n    assert list(unify((w, x), (y, z), {})) == [{w: y, x: z}]\n    assert list(unify(x, (a, b), {})) == [{x: (a, b)}]\n\n    assert list(unify((a, b), (x, x), {})) == []\n    assert list(unify((y, z), (x, x), {}))!= []\n    assert list(unify((a, (b, c)), (a, (x, y)), {})) == [{x: b, y: c}]\n\ndef test_ops():\n    assert list(unify(C('Add', (a,b,c)), C('Add', (a,x,y)), {})) == \\\n            [{x:b, y:c}]\n    assert list(unify(C('Add', (C('Mul', (1,2)), b,c)), C('Add', (x,y,c)), {})) == \\\n            [{x: C('Mul', (1,2)), y:b}]\n\ndef test_associative():\n    c1 = C('Add', (1,2,3))\n    c2 = C('Add', (x,y))\n    result = list(unify(c1, c2, {}))\n    assert tuple(unify(c1, c2, {})) == ({x: 1, y: C('Add', (2, 3))},\n                                         {x: C('Add', (1, 2)), y: 3})\n\ndef test_commutative():\n    c1 = C('CAdd', (1,2,3))\n    c2 = C('CAdd', (x,y))\n    result = list(unify(c1, c2, {}))\n    assert  {x: 1, y: C('CAdd', (2, 3))} in result\n    assert ({x: 2, y: C('CAdd', (1, 3))} in result or\n            {x: 2, y: C('CAdd', (3, 1))} in result)\n\ndef _test_combinations_assoc():\n    assert set(allcombinations((1,2,3), (a,b), True)) == \\\n        set(((((1, 2), (3,)), (a, b)), (((1,), (2, 3)), (a, b))))\n\ndef _test_combinations_comm():\n    assert set(allcombinations((1,2,3), (a,b), None)) == \\\n        set(((((1,), (2, 3)), ('a', 'b')), (((2,), (3, 1)), ('a', 'b')),\n             (((3,), (1, 2)), ('a', 'b')), (((1, 2), (3,)), ('a', 'b')),\n             (((2, 3), (1,)), ('a', 'b')), (((3, 1), (2,)), ('a', 'b'))))\n\ndef test_allcombinations():\n    assert set(allcombinations((1,2), (1,2), 'commutative')) ==\\\n        set(((((1,),(2,)), ((1,),(2,))), (((1,),(2,)), ((2,),(1,)))))\n\n\ndef test_commutativity():\n    c1 = Compound('CAdd', (a, b))\n    c2 = Compound('CAdd', (x, y))\n    assert is_commutative(c1) and is_commutative(c2)\n    assert len(list(unify(c1, c2, {}))) == 2\n\n\ndef test_CondVariable():\n    expr = C('CAdd', (1, 2))\n    x = Variable('x')\n    y = CondVariable('y', lambda a: a % 2 == 0)\n    z = CondVariable('z', lambda a: a > 3)\n    pattern = C('CAdd', (x, y))\n    assert list(unify(expr, pattern, {})) == \\\n            [{x: 1, y: 2}]\n\n    z = CondVariable('z', lambda a: a > 3)\n    pattern = C('CAdd', (z, y))\n\n    assert list(unify(expr, pattern, {})) == []\n\ndef test_defaultdict():\n    assert next(unify(Variable('x'), 'foo')) == {Variable('x'): 'foo'}\n", "comments": "", "content": "from sympy.unify.core import Compound, Variable, CondVariable, allcombinations\nfrom sympy.unify import core\n\na,b,c = 'abc'\nw,x,y,z = map(Variable, 'wxyz')\n\nC = Compound\n\ndef is_associative(x):\n    return isinstance(x, Compound) and (x.op in ('Add', 'Mul', 'CAdd', 'CMul'))\ndef is_commutative(x):\n    return isinstance(x, Compound) and (x.op in ('CAdd', 'CMul'))\n\n\ndef unify(a, b, s={}):\n    return core.unify(a, b, s=s, is_associative=is_associative,\n                          is_commutative=is_commutative)\n\ndef test_basic():\n    assert list(unify(a, x, {})) == [{x: a}]\n    assert list(unify(a, x, {x: 10})) == []\n    assert list(unify(1, x, {})) == [{x: 1}]\n    assert list(unify(a, a, {})) == [{}]\n    assert list(unify((w, x), (y, z), {})) == [{w: y, x: z}]\n    assert list(unify(x, (a, b), {})) == [{x: (a, b)}]\n\n    assert list(unify((a, b), (x, x), {})) == []\n    assert list(unify((y, z), (x, x), {}))!= []\n    assert list(unify((a, (b, c)), (a, (x, y)), {})) == [{x: b, y: c}]\n\ndef test_ops():\n    assert list(unify(C('Add', (a,b,c)), C('Add', (a,x,y)), {})) == \\\n            [{x:b, y:c}]\n    assert list(unify(C('Add', (C('Mul', (1,2)), b,c)), C('Add', (x,y,c)), {})) == \\\n            [{x: C('Mul', (1,2)), y:b}]\n\ndef test_associative():\n    c1 = C('Add', (1,2,3))\n    c2 = C('Add', (x,y))\n    result = list(unify(c1, c2, {}))\n    assert tuple(unify(c1, c2, {})) == ({x: 1, y: C('Add', (2, 3))},\n                                         {x: C('Add', (1, 2)), y: 3})\n\ndef test_commutative():\n    c1 = C('CAdd', (1,2,3))\n    c2 = C('CAdd', (x,y))\n    result = list(unify(c1, c2, {}))\n    assert  {x: 1, y: C('CAdd', (2, 3))} in result\n    assert ({x: 2, y: C('CAdd', (1, 3))} in result or\n            {x: 2, y: C('CAdd', (3, 1))} in result)\n\ndef _test_combinations_assoc():\n    assert set(allcombinations((1,2,3), (a,b), True)) == \\\n        set(((((1, 2), (3,)), (a, b)), (((1,), (2, 3)), (a, b))))\n\ndef _test_combinations_comm():\n    assert set(allcombinations((1,2,3), (a,b), None)) == \\\n        set(((((1,), (2, 3)), ('a', 'b')), (((2,), (3, 1)), ('a', 'b')),\n             (((3,), (1, 2)), ('a', 'b')), (((1, 2), (3,)), ('a', 'b')),\n             (((2, 3), (1,)), ('a', 'b')), (((3, 1), (2,)), ('a', 'b'))))\n\ndef test_allcombinations():\n    assert set(allcombinations((1,2), (1,2), 'commutative')) ==\\\n        set(((((1,),(2,)), ((1,),(2,))), (((1,),(2,)), ((2,),(1,)))))\n\n\ndef test_commutativity():\n    c1 = Compound('CAdd', (a, b))\n    c2 = Compound('CAdd', (x, y))\n    assert is_commutative(c1) and is_commutative(c2)\n    assert len(list(unify(c1, c2, {}))) == 2\n\n\ndef test_CondVariable():\n    expr = C('CAdd', (1, 2))\n    x = Variable('x')\n    y = CondVariable('y', lambda a: a % 2 == 0)\n    z = CondVariable('z', lambda a: a > 3)\n    pattern = C('CAdd', (x, y))\n    assert list(unify(expr, pattern, {})) == \\\n            [{x: 1, y: 2}]\n\n    z = CondVariable('z', lambda a: a > 3)\n    pattern = C('CAdd', (z, y))\n\n    assert list(unify(expr, pattern, {})) == []\n\ndef test_defaultdict():\n    assert next(unify(Variable('x'), 'foo')) == {Variable('x'): 'foo'}\n", "description": "A computer algebra system written in pure Python", "file_name": "test_unify.py", "id": "e1101ff4f9ddab3f19e3d2816b5389b9", "language": "Python", "project_name": "sympy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/sympy-sympy/sympy-sympy-205da79/sympy/unify/tests/test_unify.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:35:56Z", "url": "https://github.com/sympy/sympy", "wiki": true}