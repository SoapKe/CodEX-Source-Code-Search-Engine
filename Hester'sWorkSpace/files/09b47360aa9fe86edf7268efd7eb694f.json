{"author": "mitmproxy", "code": "\n\n Helper tool to enable/disable OS X proxy and wrap mitmproxy\n\n Get usage information with:\n\n mitmproxywrapper.py -h\n\n\nimport subprocess\nimport re\nimport argparse\nimport contextlib\nimport os\nimport sys\n\n\nclass Wrapper:\n    def __init__(self, port, extra_arguments=None):\n        self.port = port\n        self.extra_arguments = extra_arguments\n\n    def run_networksetup_command(self, *arguments):\n        return subprocess.check_output(\n            ['sudo', 'networksetup'] + list(arguments))\n\n    def proxy_state_for_service(self, service):\n        state = self.run_networksetup_command(\n            '-getwebproxy',\n            service).splitlines()\n        return dict([re.findall(r'([^:]+): (.*)', line)[0] for line in state])\n\n    def enable_proxy_for_service(self, service):\n        print('Enabling proxy on {}...'.format(service))\n        for subcommand in ['-setwebproxy', '-setsecurewebproxy']:\n            self.run_networksetup_command(\n                subcommand, service, '127.0.0.1', str(\n                    self.port))\n\n    def disable_proxy_for_service(self, service):\n        print('Disabling proxy on {}...'.format(service))\n        for subcommand in ['-setwebproxystate', '-setsecurewebproxystate']:\n            self.run_networksetup_command(subcommand, service, 'Off')\n\n    def interface_name_to_service_name_map(self):\n        order = self.run_networksetup_command('-listnetworkserviceorder')\n        mapping = re.findall(\n            r'\\(\\d+\\)\\s(.*)$\\n\\(.*Device: (.+)\\)$',\n            order,\n            re.MULTILINE)\n        return dict([(b, a) for (a, b) in mapping])\n\n    def run_command_with_input(self, command, input):\n        popen = subprocess.Popen(\n            command,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE)\n        (stdout, stderr) = popen.communicate(input)\n        return stdout\n\n    def primary_interace_name(self):\n        scutil_script = 'get State:/Network/Global/IPv4\\nd.show\\n'\n        stdout = self.run_command_with_input('/usr/sbin/scutil', scutil_script)\n        interface, = re.findall(r'PrimaryInterface\\s*:\\s*(.+)', stdout)\n        return interface\n\n    def primary_service_name(self):\n        return self.interface_name_to_service_name_map()[\n            self.primary_interace_name()]\n\n    def proxy_enabled_for_service(self, service):\n        return self.proxy_state_for_service(service)['Enabled'] == 'Yes'\n\n    def toggle_proxy(self):\n        new_state = not self.proxy_enabled_for_service(\n            self.primary_service_name())\n        for service_name in self.connected_service_names():\n            if self.proxy_enabled_for_service(service_name) and not new_state:\n                self.disable_proxy_for_service(service_name)\n            elif not self.proxy_enabled_for_service(service_name) and new_state:\n                self.enable_proxy_for_service(service_name)\n\n    def connected_service_names(self):\n        scutil_script = 'list\\n'\n        stdout = self.run_command_with_input('/usr/sbin/scutil', scutil_script)\n        service_ids = re.findall(r'State:/Network/Service/(.+)/IPv4', stdout)\n\n        service_names = []\n        for service_id in service_ids:\n            scutil_script = 'show Setup:/Network/Service/{}\\n'.format(\n                service_id)\n            stdout = self.run_command_with_input(\n                '/usr/sbin/scutil',\n                scutil_script)\n            service_name, = re.findall(r'UserDefinedName\\s*:\\s*(.+)', stdout)\n            service_names.append(service_name)\n\n        return service_names\n\n    def wrap_mitmproxy(self):\n        with self.wrap_proxy():\n            cmd = ['mitmproxy', '-p', str(self.port)]\n            if self.extra_arguments:\n                cmd.extend(self.extra_arguments)\n            subprocess.check_call(cmd)\n\n    def wrap_honeyproxy(self):\n        with self.wrap_proxy():\n            popen = subprocess.Popen('honeyproxy.sh')\n            try:\n                popen.wait()\n            except KeyboardInterrupt:\n                popen.terminate()\n\n    @contextlib.contextmanager\n    def wrap_proxy(self):\n        connected_service_names = self.connected_service_names()\n        for service_name in connected_service_names:\n            if not self.proxy_enabled_for_service(service_name):\n                self.enable_proxy_for_service(service_name)\n\n        yield\n\n        for service_name in connected_service_names:\n            if self.proxy_enabled_for_service(service_name):\n                self.disable_proxy_for_service(service_name)\n\n    @classmethod\n    def ensure_superuser(cls):\n        if os.getuid() != 0:\n            print('Relaunching with sudo...')\n            os.execv('/usr/bin/sudo', ['/usr/bin/sudo'] + sys.argv)\n\n    @classmethod\n    def main(cls):\n        parser = argparse.ArgumentParser(\n            description='Helper tool for OS X proxy configuration and mitmproxy.',\n            epilog='Any additional arguments will be passed on unchanged to mitmproxy.')\n        parser.add_argument(\n            '-t',\n            '--toggle',\n            action='store_true',\n            help='just toggle the proxy configuration')\n         parser.add_argument('--honeyproxy', action='store_true', help='run honeyproxy instead of mitmproxy')\n        parser.add_argument(\n            '-p',\n            '--port',\n            type=int,\n            help='override the default port of 8080',\n            default=8080)\n        args, extra_arguments = parser.parse_known_args()\n\n        wrapper = cls(port=args.port, extra_arguments=extra_arguments)\n\n        if args.toggle:\n            wrapper.toggle_proxy()\n         elif args.honeyproxy:\n             wrapper.wrap_honeyproxy()\n        else:\n            wrapper.wrap_mitmproxy()\n\n\nif __name__ == '__main__':\n    Wrapper.ensure_superuser()\n    Wrapper.main()\n", "comments": "   usr bin env python       helper tool enable disable os x proxy wrap mitmproxy       get usage information        mitmproxywrapper py  h       parser add argument(   honeyproxy   action  store true   help  run honeyproxy instead mitmproxy )    elif args honeyproxy         wrapper wrap honeyproxy() ", "content": "#!/usr/bin/env python\n#\n# Helper tool to enable/disable OS X proxy and wrap mitmproxy\n#\n# Get usage information with:\n#\n# mitmproxywrapper.py -h\n#\n\nimport subprocess\nimport re\nimport argparse\nimport contextlib\nimport os\nimport sys\n\n\nclass Wrapper:\n    def __init__(self, port, extra_arguments=None):\n        self.port = port\n        self.extra_arguments = extra_arguments\n\n    def run_networksetup_command(self, *arguments):\n        return subprocess.check_output(\n            ['sudo', 'networksetup'] + list(arguments))\n\n    def proxy_state_for_service(self, service):\n        state = self.run_networksetup_command(\n            '-getwebproxy',\n            service).splitlines()\n        return dict([re.findall(r'([^:]+): (.*)', line)[0] for line in state])\n\n    def enable_proxy_for_service(self, service):\n        print('Enabling proxy on {}...'.format(service))\n        for subcommand in ['-setwebproxy', '-setsecurewebproxy']:\n            self.run_networksetup_command(\n                subcommand, service, '127.0.0.1', str(\n                    self.port))\n\n    def disable_proxy_for_service(self, service):\n        print('Disabling proxy on {}...'.format(service))\n        for subcommand in ['-setwebproxystate', '-setsecurewebproxystate']:\n            self.run_networksetup_command(subcommand, service, 'Off')\n\n    def interface_name_to_service_name_map(self):\n        order = self.run_networksetup_command('-listnetworkserviceorder')\n        mapping = re.findall(\n            r'\\(\\d+\\)\\s(.*)$\\n\\(.*Device: (.+)\\)$',\n            order,\n            re.MULTILINE)\n        return dict([(b, a) for (a, b) in mapping])\n\n    def run_command_with_input(self, command, input):\n        popen = subprocess.Popen(\n            command,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE)\n        (stdout, stderr) = popen.communicate(input)\n        return stdout\n\n    def primary_interace_name(self):\n        scutil_script = 'get State:/Network/Global/IPv4\\nd.show\\n'\n        stdout = self.run_command_with_input('/usr/sbin/scutil', scutil_script)\n        interface, = re.findall(r'PrimaryInterface\\s*:\\s*(.+)', stdout)\n        return interface\n\n    def primary_service_name(self):\n        return self.interface_name_to_service_name_map()[\n            self.primary_interace_name()]\n\n    def proxy_enabled_for_service(self, service):\n        return self.proxy_state_for_service(service)['Enabled'] == 'Yes'\n\n    def toggle_proxy(self):\n        new_state = not self.proxy_enabled_for_service(\n            self.primary_service_name())\n        for service_name in self.connected_service_names():\n            if self.proxy_enabled_for_service(service_name) and not new_state:\n                self.disable_proxy_for_service(service_name)\n            elif not self.proxy_enabled_for_service(service_name) and new_state:\n                self.enable_proxy_for_service(service_name)\n\n    def connected_service_names(self):\n        scutil_script = 'list\\n'\n        stdout = self.run_command_with_input('/usr/sbin/scutil', scutil_script)\n        service_ids = re.findall(r'State:/Network/Service/(.+)/IPv4', stdout)\n\n        service_names = []\n        for service_id in service_ids:\n            scutil_script = 'show Setup:/Network/Service/{}\\n'.format(\n                service_id)\n            stdout = self.run_command_with_input(\n                '/usr/sbin/scutil',\n                scutil_script)\n            service_name, = re.findall(r'UserDefinedName\\s*:\\s*(.+)', stdout)\n            service_names.append(service_name)\n\n        return service_names\n\n    def wrap_mitmproxy(self):\n        with self.wrap_proxy():\n            cmd = ['mitmproxy', '-p', str(self.port)]\n            if self.extra_arguments:\n                cmd.extend(self.extra_arguments)\n            subprocess.check_call(cmd)\n\n    def wrap_honeyproxy(self):\n        with self.wrap_proxy():\n            popen = subprocess.Popen('honeyproxy.sh')\n            try:\n                popen.wait()\n            except KeyboardInterrupt:\n                popen.terminate()\n\n    @contextlib.contextmanager\n    def wrap_proxy(self):\n        connected_service_names = self.connected_service_names()\n        for service_name in connected_service_names:\n            if not self.proxy_enabled_for_service(service_name):\n                self.enable_proxy_for_service(service_name)\n\n        yield\n\n        for service_name in connected_service_names:\n            if self.proxy_enabled_for_service(service_name):\n                self.disable_proxy_for_service(service_name)\n\n    @classmethod\n    def ensure_superuser(cls):\n        if os.getuid() != 0:\n            print('Relaunching with sudo...')\n            os.execv('/usr/bin/sudo', ['/usr/bin/sudo'] + sys.argv)\n\n    @classmethod\n    def main(cls):\n        parser = argparse.ArgumentParser(\n            description='Helper tool for OS X proxy configuration and mitmproxy.',\n            epilog='Any additional arguments will be passed on unchanged to mitmproxy.')\n        parser.add_argument(\n            '-t',\n            '--toggle',\n            action='store_true',\n            help='just toggle the proxy configuration')\n        # parser.add_argument('--honeyproxy', action='store_true', help='run honeyproxy instead of mitmproxy')\n        parser.add_argument(\n            '-p',\n            '--port',\n            type=int,\n            help='override the default port of 8080',\n            default=8080)\n        args, extra_arguments = parser.parse_known_args()\n\n        wrapper = cls(port=args.port, extra_arguments=extra_arguments)\n\n        if args.toggle:\n            wrapper.toggle_proxy()\n        # elif args.honeyproxy:\n        #     wrapper.wrap_honeyproxy()\n        else:\n            wrapper.wrap_mitmproxy()\n\n\nif __name__ == '__main__':\n    Wrapper.ensure_superuser()\n    Wrapper.main()\n", "description": "An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers.", "file_name": "mitmproxywrapper.py", "id": "09b47360aa9fe86edf7268efd7eb694f", "language": "Python", "project_name": "mitmproxy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mitmproxy-mitmproxy/mitmproxy-mitmproxy-3c7725a/docs/src/examples/complex/mitmproxywrapper.py", "save_time": "", "source": "", "update_at": "2018-03-18T11:30:56Z", "url": "https://github.com/mitmproxy/mitmproxy", "wiki": false}