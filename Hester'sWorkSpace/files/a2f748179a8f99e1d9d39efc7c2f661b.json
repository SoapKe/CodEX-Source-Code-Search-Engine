{"author": "keon", "code": "import collections\n\n\"\"\"\ndo BFS from each building, and decrement all empty place for every building visit\nwhen grid[i][j] == -b_nums, it means that grid[i][j] are already visited from all b_nums\nand use dist to record distances from b_nums\n\"\"\"\n\ndef shortest_distance(grid):\n    if not grid or not grid[0]:\n        return -1\n\n    matrix = [[[0,0] for i in range(len(grid[0]))] for j in range(len(grid))]\n\n    count = 0    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                bfs(grid, matrix, i, j, count)\n                count += 1\n\n    res = float('inf')\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j][1]==count:\n                res = min(res, matrix[i][j][0])\n\n    return res if res!=float('inf') else -1\n\ndef bfs(grid, matrix, i, j, count):\n    q = [(i, j, 0)]\n    while q:\n        i, j, step = q.pop(0)\n        for k, l in [(i-1,j), (i+1,j), (i,j-1), (i,j+1)]:\n            \n            if 0<=k<len(grid) and 0<=l<len(grid[0]) and \\\n                    matrix[k][l][1]==count and grid[k][l]==0:\n                matrix[k][l][0] += step+1\n                matrix[k][l][1] = count+1\n                q.append((k, l, step+1))\n\ngrid = [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]\nprint(shortest_distance(grid))\n", "comments": "    bfs building  decrement empty place every building visit grid  j      b nums  means grid  j  already visited b nums use dist record distances b nums        count many building visited    position visited count times append queue ", "content": "import collections\n\n\"\"\"\ndo BFS from each building, and decrement all empty place for every building visit\nwhen grid[i][j] == -b_nums, it means that grid[i][j] are already visited from all b_nums\nand use dist to record distances from b_nums\n\"\"\"\n\ndef shortest_distance(grid):\n    if not grid or not grid[0]:\n        return -1\n\n    matrix = [[[0,0] for i in range(len(grid[0]))] for j in range(len(grid))]\n\n    count = 0    # count how many building we have visited\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                bfs(grid, matrix, i, j, count)\n                count += 1\n\n    res = float('inf')\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j][1]==count:\n                res = min(res, matrix[i][j][0])\n\n    return res if res!=float('inf') else -1\n\ndef bfs(grid, matrix, i, j, count):\n    q = [(i, j, 0)]\n    while q:\n        i, j, step = q.pop(0)\n        for k, l in [(i-1,j), (i+1,j), (i,j-1), (i,j+1)]:\n            # only the position be visited by count times will append to queue\n            if 0<=k<len(grid) and 0<=l<len(grid[0]) and \\\n                    matrix[k][l][1]==count and grid[k][l]==0:\n                matrix[k][l][0] += step+1\n                matrix[k][l][1] = count+1\n                q.append((k, l, step+1))\n\ngrid = [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]\nprint(shortest_distance(grid))\n", "description": "Minimal examples of data structures and algorithms in Python", "file_name": "shortest_distance_from_all_buildings.py", "id": "a2f748179a8f99e1d9d39efc7c2f661b", "language": "Python", "project_name": "algorithms", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/keon-algorithms/keon-algorithms-ea43887/bfs/shortest_distance_from_all_buildings.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:53:29Z", "url": "https://github.com/keon/algorithms", "wiki": true}