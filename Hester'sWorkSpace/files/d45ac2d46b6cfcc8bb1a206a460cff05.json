{"author": "HelloZeroNet", "code": "\n This file is part of pyasn1 software.\n\n Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>\n License: http://pyasn1.sf.net/license.html\n\nimport sys\nif sys.version_info[0:2] < (3, 2):\n    from binascii import a2b_hex, b2a_hex\nfrom pyasn1.compat.octets import oct2int, null\n\nif sys.version_info[0:2] < (3, 2):\n    def from_bytes(octets, signed=False):\n        value = long(b2a_hex(str(octets)), 16)\n\n        if signed and oct2int(octets[0]) & 0x80:\n            return value - (1 << len(octets) * 8)\n\n        return value\n\n    def to_bytes(value, signed=False, length=0):\n        if value < 0:\n            if signed:\n                bits = bitLength(value)\n\n                 two's complement form\n                maxValue = 1 << bits\n                valueToEncode = (value + maxValue) % maxValue\n\n            else:\n                raise OverflowError('can\\'t convert negative int to unsigned')\n        elif value == 0 and length == 0:\n            return null\n        else:\n            bits = 0\n            valueToEncode = value\n\n        hexValue = hex(valueToEncode)[2:]\n        if hexValue.endswith('L'):\n            hexValue = hexValue[:-1]\n\n        if len(hexValue) & 1:\n            hexValue = '0' + hexValue\n\n         padding may be needed for two's complement encoding\n        if value != valueToEncode or length:\n            hexLength = len(hexValue) * 4\n\n            padLength = max(length, bits)\n\n            if padLength > hexLength:\n                hexValue = '00' * ((padLength - hexLength - 1) // 8 + 1) + hexValue\n            elif length and hexLength - length > 7:\n                raise OverflowError('int too big to convert')\n\n        firstOctet = int(hexValue[:2], 16)\n\n        if signed:\n            if firstOctet & 0x80:\n                if value >= 0:\n                    hexValue = '00' + hexValue\n            elif value < 0:\n                hexValue = 'ff' + hexValue\n\n        octets_value = a2b_hex(hexValue)\n\n        return octets_value\n\n    def bitLength(number):\n         bits in unsigned number\n        hexValue = hex(abs(number))\n        bits = len(hexValue) - 2\n        if hexValue.endswith('L'):\n            bits -= 1\n        if bits & 1:\n            bits += 1\n        bits *= 4\n         TODO: strip lhs zeros\n        return bits\n\nelse:\n\n    def from_bytes(octets, signed=False):\n        return int.from_bytes(bytes(octets), 'big', signed=signed)\n\n    def to_bytes(value, signed=False, length=0):\n        length = max(value.bit_length(), length)\n\n        if signed and length % 8 == 0:\n            length += 1\n\n        return value.to_bytes(length // 8 + (length % 8 and 1 or 0), 'big', signed=signed)\n\n    def bitLength(number):\n        return int(number).bit_length()\n\n", "comments": "     this file part pyasn1 software        copyright (c) 2005 2017  ilya etingof  etingof gmail com     license  http   pyasn1 sf net license html       two complement form    padding may needed two complement encoding    bits unsigned number    todo  strip lhs zeros ", "content": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>\n# License: http://pyasn1.sf.net/license.html\n#\nimport sys\nif sys.version_info[0:2] < (3, 2):\n    from binascii import a2b_hex, b2a_hex\nfrom pyasn1.compat.octets import oct2int, null\n\nif sys.version_info[0:2] < (3, 2):\n    def from_bytes(octets, signed=False):\n        value = long(b2a_hex(str(octets)), 16)\n\n        if signed and oct2int(octets[0]) & 0x80:\n            return value - (1 << len(octets) * 8)\n\n        return value\n\n    def to_bytes(value, signed=False, length=0):\n        if value < 0:\n            if signed:\n                bits = bitLength(value)\n\n                # two's complement form\n                maxValue = 1 << bits\n                valueToEncode = (value + maxValue) % maxValue\n\n            else:\n                raise OverflowError('can\\'t convert negative int to unsigned')\n        elif value == 0 and length == 0:\n            return null\n        else:\n            bits = 0\n            valueToEncode = value\n\n        hexValue = hex(valueToEncode)[2:]\n        if hexValue.endswith('L'):\n            hexValue = hexValue[:-1]\n\n        if len(hexValue) & 1:\n            hexValue = '0' + hexValue\n\n        # padding may be needed for two's complement encoding\n        if value != valueToEncode or length:\n            hexLength = len(hexValue) * 4\n\n            padLength = max(length, bits)\n\n            if padLength > hexLength:\n                hexValue = '00' * ((padLength - hexLength - 1) // 8 + 1) + hexValue\n            elif length and hexLength - length > 7:\n                raise OverflowError('int too big to convert')\n\n        firstOctet = int(hexValue[:2], 16)\n\n        if signed:\n            if firstOctet & 0x80:\n                if value >= 0:\n                    hexValue = '00' + hexValue\n            elif value < 0:\n                hexValue = 'ff' + hexValue\n\n        octets_value = a2b_hex(hexValue)\n\n        return octets_value\n\n    def bitLength(number):\n        # bits in unsigned number\n        hexValue = hex(abs(number))\n        bits = len(hexValue) - 2\n        if hexValue.endswith('L'):\n            bits -= 1\n        if bits & 1:\n            bits += 1\n        bits *= 4\n        # TODO: strip lhs zeros\n        return bits\n\nelse:\n\n    def from_bytes(octets, signed=False):\n        return int.from_bytes(bytes(octets), 'big', signed=signed)\n\n    def to_bytes(value, signed=False, length=0):\n        length = max(value.bit_length(), length)\n\n        if signed and length % 8 == 0:\n            length += 1\n\n        return value.to_bytes(length // 8 + (length % 8 and 1 or 0), 'big', signed=signed)\n\n    def bitLength(number):\n        return int(number).bit_length()\n\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "integer.py", "id": "d45ac2d46b6cfcc8bb1a206a460cff05", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/lib/pyasn1/compat/integer.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}