{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_urllib_parse_unquote,\n    compat_urllib_parse_urlparse,\n)\nfrom ..utils import (\n    ExtractorError,\n    float_or_none,\n    sanitized_Request,\n    unescapeHTML,\n    urlencode_postdata,\n    USER_AGENTS,\n)\n\n\nclass CeskaTelevizeIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?ceskatelevize\\.cz/ivysilani/(?:[^/?\n    _TESTS = [{\n        'url': 'http://www.ceskatelevize.cz/ivysilani/ivysilani/10441294653-hyde-park-civilizace/214411058091220',\n        'info_dict': {\n            'id': '61924494877246241',\n            'ext': 'mp4',\n            'title': 'Hyde Park Civilizace: \u017divot v Gr\u00f3nsku',\n            'description': 'md5:3fec8f6bb497be5cdb0c9e8781076626',\n            'thumbnail': r're:^https?://.*\\.jpg',\n            'duration': 3350,\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }, {\n        'url': 'http://www.ceskatelevize.cz/ivysilani/10441294653-hyde-park-civilizace/215411058090502/bonus/20641-bonus-01-en',\n        'info_dict': {\n            'id': '61924494877028507',\n            'ext': 'mp4',\n            'title': 'Hyde Park Civilizace: Bonus 01 - En',\n            'description': 'English Subtittles',\n            'thumbnail': r're:^https?://.*\\.jpg',\n            'duration': 81.3,\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }, {\n        \n        'url': 'http://www.ceskatelevize.cz/ivysilani/zive/ct4/',\n        'info_dict': {\n            'id': 402,\n            'ext': 'mp4',\n            'title': r're:^\u010cT Sport \\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$',\n            'is_live': True,\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n        'skip': 'Georestricted to Czech Republic',\n    }, {\n        'url': 'http://www.ceskatelevize.cz/ivysilani/embed/iFramePlayer.php?hash=d6a3e1370d2e4fa76296b90bad4dfc19673b641e&IDEC=217 562 22150/0004&channelID=1&width=100%25',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        playlist_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, playlist_id)\n\n        NOT_AVAILABLE_STRING = 'This content is not available at your territory due to limited copyright.'\n        if '%s</p>' % NOT_AVAILABLE_STRING in webpage:\n            raise ExtractorError(NOT_AVAILABLE_STRING, expected=True)\n\n        type_ = None\n        episode_id = None\n\n        playlist = self._parse_json(\n            self._search_regex(\n                r'getPlaylistUrl\\(\\[({.+?})\\]', webpage, 'playlist',\n                default='{}'), playlist_id)\n        if playlist:\n            type_ = playlist.get('type')\n            episode_id = playlist.get('id')\n\n        if not type_:\n            type_ = self._html_search_regex(\n                r'getPlaylistUrl\\(\\[\\{\"type\":\"(.+?)\",\"id\":\".+?\"\\}\\],',\n                webpage, 'type')\n        if not episode_id:\n            episode_id = self._html_search_regex(\n                r'getPlaylistUrl\\(\\[\\{\"type\":\".+?\",\"id\":\"(.+?)\"\\}\\],',\n                webpage, 'episode_id')\n\n        data = {\n            'playlist[0][type]': type_,\n            'playlist[0][id]': episode_id,\n            'requestUrl': compat_urllib_parse_urlparse(url).path,\n            'requestSource': 'iVysilani',\n        }\n\n        entries = []\n\n        for user_agent in (None, USER_AGENTS['Safari']):\n            req = sanitized_Request(\n                'http://www.ceskatelevize.cz/ivysilani/ajax/get-client-playlist',\n                data=urlencode_postdata(data))\n\n            req.add_header('Content-type', 'application/x-www-form-urlencoded')\n            req.add_header('x-addr', '127.0.0.1')\n            req.add_header('X-Requested-With', 'XMLHttpRequest')\n            if user_agent:\n                req.add_header('User-Agent', user_agent)\n            req.add_header('Referer', url)\n\n            playlistpage = self._download_json(req, playlist_id, fatal=False)\n\n            if not playlistpage:\n                continue\n\n            playlist_url = playlistpage['url']\n            if playlist_url == 'error_region':\n                raise ExtractorError(NOT_AVAILABLE_STRING, expected=True)\n\n            req = sanitized_Request(compat_urllib_parse_unquote(playlist_url))\n            req.add_header('Referer', url)\n\n            playlist_title = self._og_search_title(webpage, default=None)\n            playlist_description = self._og_search_description(webpage, default=None)\n\n            playlist = self._download_json(req, playlist_id, fatal=False)\n            if not playlist:\n                continue\n\n            playlist = playlist.get('playlist')\n            if not isinstance(playlist, list):\n                continue\n\n            playlist_len = len(playlist)\n\n            for num, item in enumerate(playlist):\n                is_live = item.get('type') == 'LIVE'\n                formats = []\n                for format_id, stream_url in item.get('streamUrls', {}).items():\n                    if 'playerType=flash' in stream_url:\n                        stream_formats = self._extract_m3u8_formats(\n                            stream_url, playlist_id, 'mp4', 'm3u8_native',\n                            m3u8_id='hls-%s' % format_id, fatal=False)\n                    else:\n                        stream_formats = self._extract_mpd_formats(\n                            stream_url, playlist_id,\n                            mpd_id='dash-%s' % format_id, fatal=False)\n                    \n                    if format_id == 'audioDescription':\n                        for f in stream_formats:\n                            f['source_preference'] = -10\n                    formats.extend(stream_formats)\n\n                if user_agent and len(entries) == playlist_len:\n                    entries[num]['formats'].extend(formats)\n                    continue\n\n                item_id = item.get('id') or item['assetId']\n                title = item['title']\n\n                duration = float_or_none(item.get('duration'))\n                thumbnail = item.get('previewImageUrl')\n\n                subtitles = {}\n                if item.get('type') == 'VOD':\n                    subs = item.get('subtitles')\n                    if subs:\n                        subtitles = self.extract_subtitles(episode_id, subs)\n\n                if playlist_len == 1:\n                    final_title = playlist_title or title\n                    if is_live:\n                        final_title = self._live_title(final_title)\n                else:\n                    final_title = '%s (%s)' % (playlist_title, title)\n\n                entries.append({\n                    'id': item_id,\n                    'title': final_title,\n                    'description': playlist_description if playlist_len == 1 else None,\n                    'thumbnail': thumbnail,\n                    'duration': duration,\n                    'formats': formats,\n                    'subtitles': subtitles,\n                    'is_live': is_live,\n                })\n\n        for e in entries:\n            self._sort_formats(e['formats'])\n\n        return self.playlist_result(entries, playlist_id, playlist_title, playlist_description)\n\n    def _get_subtitles(self, episode_id, subs):\n        original_subtitles = self._download_webpage(\n            subs[0]['url'], episode_id, 'Downloading subtitles')\n        srt_subs = self._fix_subtitles(original_subtitles)\n        return {\n            'cs': [{\n                'ext': 'srt',\n                'data': srt_subs,\n            }]\n        }\n\n    @staticmethod\n    def _fix_subtitles(subtitles):\n        \n            components = []\n            for divider in [1000, 60, 60, 100]:\n                components.append(msec % divider)\n                msec //= divider\n            return '{3:02}:{2:02}:{1:02},{0:03}'.format(*components)\n\n        def _fix_subtitle(subtitle):\n            for line in subtitle.splitlines():\n                m = re.match(r'^\\s*([0-9]+);\\s*([0-9]+)\\s+([0-9]+)\\s*$', line)\n                if m:\n                    yield m.group(1)\n                    start, stop = (_msectotimecode(int(t)) for t in m.groups()[1:])\n                    yield '{0} --> {1}'.format(start, stop)\n                else:\n                    yield line\n\n        return '\\r\\n'.join(_fix_subtitle(subtitles))\n\n\nclass CeskaTelevizePoradyIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?ceskatelevize\\.cz/porady/(?:[^/?\n    _TESTS = [{\n        \n        'url': 'http://www.ceskatelevize.cz/porady/10520528904-queer/215562210900007-bogotart/',\n        'info_dict': {\n            'id': '215562210900007-bogotart',\n            'title': 'Queer: Bogotart',\n            'description': 'Alternativn\u00ed pr\u016fvodce sou\u010dasn\u00fdm queer sv\u011btem',\n        },\n        'playlist': [{\n            'info_dict': {\n                'id': '61924494876844842',\n                'ext': 'mp4',\n                'title': 'Queer: Bogotart (Varov\u00e1n\u00ed 18+)',\n                'duration': 10.2,\n            },\n        }, {\n            'info_dict': {\n                'id': '61924494877068022',\n                'ext': 'mp4',\n                'title': 'Queer: Bogotart (Queer)',\n                'thumbnail': r're:^https?://.*\\.jpg',\n                'duration': 1558.3,\n            },\n        }],\n        'params': {\n            \n            'skip_download': True,\n        },\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id)\n\n        data_url = unescapeHTML(self._search_regex(\n            r'<span[^>]*\\bdata-url=([\"\\'])(?P<url>(?:(?!\\1).)+)\\1',\n            webpage, 'iframe player url', group='url'))\n\n        return self.url_result(data_url, ie=CeskaTelevizeIE.ie_key())\n", "comments": " Convert millisecond-based subtitles to SRT \"\"\"\n\n        def _msectotimecode(msec):\n            \"\"\" Helper utility to convert milliseconds to timecode \n \n# coding: utf-8\n#&]+/)*(?P<id>[^/#?]+)'\n# m3u8 download\n# m3u8 download\n# live stream\n# m3u8 download\n# See https://github.com/rg3/youtube-dl/issues/12119#issuecomment-280037031\n#&]+/)*(?P<id>[^/#?]+)'\n# video with 18+ caution trailer\n# m3u8 download\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_urllib_parse_unquote,\n    compat_urllib_parse_urlparse,\n)\nfrom ..utils import (\n    ExtractorError,\n    float_or_none,\n    sanitized_Request,\n    unescapeHTML,\n    urlencode_postdata,\n    USER_AGENTS,\n)\n\n\nclass CeskaTelevizeIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?ceskatelevize\\.cz/ivysilani/(?:[^/?#&]+/)*(?P<id>[^/#?]+)'\n    _TESTS = [{\n        'url': 'http://www.ceskatelevize.cz/ivysilani/ivysilani/10441294653-hyde-park-civilizace/214411058091220',\n        'info_dict': {\n            'id': '61924494877246241',\n            'ext': 'mp4',\n            'title': 'Hyde Park Civilizace: \u017divot v Gr\u00f3nsku',\n            'description': 'md5:3fec8f6bb497be5cdb0c9e8781076626',\n            'thumbnail': r're:^https?://.*\\.jpg',\n            'duration': 3350,\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n    }, {\n        'url': 'http://www.ceskatelevize.cz/ivysilani/10441294653-hyde-park-civilizace/215411058090502/bonus/20641-bonus-01-en',\n        'info_dict': {\n            'id': '61924494877028507',\n            'ext': 'mp4',\n            'title': 'Hyde Park Civilizace: Bonus 01 - En',\n            'description': 'English Subtittles',\n            'thumbnail': r're:^https?://.*\\.jpg',\n            'duration': 81.3,\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n    }, {\n        # live stream\n        'url': 'http://www.ceskatelevize.cz/ivysilani/zive/ct4/',\n        'info_dict': {\n            'id': 402,\n            'ext': 'mp4',\n            'title': r're:^\u010cT Sport \\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$',\n            'is_live': True,\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n        'skip': 'Georestricted to Czech Republic',\n    }, {\n        'url': 'http://www.ceskatelevize.cz/ivysilani/embed/iFramePlayer.php?hash=d6a3e1370d2e4fa76296b90bad4dfc19673b641e&IDEC=217 562 22150/0004&channelID=1&width=100%25',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        playlist_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, playlist_id)\n\n        NOT_AVAILABLE_STRING = 'This content is not available at your territory due to limited copyright.'\n        if '%s</p>' % NOT_AVAILABLE_STRING in webpage:\n            raise ExtractorError(NOT_AVAILABLE_STRING, expected=True)\n\n        type_ = None\n        episode_id = None\n\n        playlist = self._parse_json(\n            self._search_regex(\n                r'getPlaylistUrl\\(\\[({.+?})\\]', webpage, 'playlist',\n                default='{}'), playlist_id)\n        if playlist:\n            type_ = playlist.get('type')\n            episode_id = playlist.get('id')\n\n        if not type_:\n            type_ = self._html_search_regex(\n                r'getPlaylistUrl\\(\\[\\{\"type\":\"(.+?)\",\"id\":\".+?\"\\}\\],',\n                webpage, 'type')\n        if not episode_id:\n            episode_id = self._html_search_regex(\n                r'getPlaylistUrl\\(\\[\\{\"type\":\".+?\",\"id\":\"(.+?)\"\\}\\],',\n                webpage, 'episode_id')\n\n        data = {\n            'playlist[0][type]': type_,\n            'playlist[0][id]': episode_id,\n            'requestUrl': compat_urllib_parse_urlparse(url).path,\n            'requestSource': 'iVysilani',\n        }\n\n        entries = []\n\n        for user_agent in (None, USER_AGENTS['Safari']):\n            req = sanitized_Request(\n                'http://www.ceskatelevize.cz/ivysilani/ajax/get-client-playlist',\n                data=urlencode_postdata(data))\n\n            req.add_header('Content-type', 'application/x-www-form-urlencoded')\n            req.add_header('x-addr', '127.0.0.1')\n            req.add_header('X-Requested-With', 'XMLHttpRequest')\n            if user_agent:\n                req.add_header('User-Agent', user_agent)\n            req.add_header('Referer', url)\n\n            playlistpage = self._download_json(req, playlist_id, fatal=False)\n\n            if not playlistpage:\n                continue\n\n            playlist_url = playlistpage['url']\n            if playlist_url == 'error_region':\n                raise ExtractorError(NOT_AVAILABLE_STRING, expected=True)\n\n            req = sanitized_Request(compat_urllib_parse_unquote(playlist_url))\n            req.add_header('Referer', url)\n\n            playlist_title = self._og_search_title(webpage, default=None)\n            playlist_description = self._og_search_description(webpage, default=None)\n\n            playlist = self._download_json(req, playlist_id, fatal=False)\n            if not playlist:\n                continue\n\n            playlist = playlist.get('playlist')\n            if not isinstance(playlist, list):\n                continue\n\n            playlist_len = len(playlist)\n\n            for num, item in enumerate(playlist):\n                is_live = item.get('type') == 'LIVE'\n                formats = []\n                for format_id, stream_url in item.get('streamUrls', {}).items():\n                    if 'playerType=flash' in stream_url:\n                        stream_formats = self._extract_m3u8_formats(\n                            stream_url, playlist_id, 'mp4', 'm3u8_native',\n                            m3u8_id='hls-%s' % format_id, fatal=False)\n                    else:\n                        stream_formats = self._extract_mpd_formats(\n                            stream_url, playlist_id,\n                            mpd_id='dash-%s' % format_id, fatal=False)\n                    # See https://github.com/rg3/youtube-dl/issues/12119#issuecomment-280037031\n                    if format_id == 'audioDescription':\n                        for f in stream_formats:\n                            f['source_preference'] = -10\n                    formats.extend(stream_formats)\n\n                if user_agent and len(entries) == playlist_len:\n                    entries[num]['formats'].extend(formats)\n                    continue\n\n                item_id = item.get('id') or item['assetId']\n                title = item['title']\n\n                duration = float_or_none(item.get('duration'))\n                thumbnail = item.get('previewImageUrl')\n\n                subtitles = {}\n                if item.get('type') == 'VOD':\n                    subs = item.get('subtitles')\n                    if subs:\n                        subtitles = self.extract_subtitles(episode_id, subs)\n\n                if playlist_len == 1:\n                    final_title = playlist_title or title\n                    if is_live:\n                        final_title = self._live_title(final_title)\n                else:\n                    final_title = '%s (%s)' % (playlist_title, title)\n\n                entries.append({\n                    'id': item_id,\n                    'title': final_title,\n                    'description': playlist_description if playlist_len == 1 else None,\n                    'thumbnail': thumbnail,\n                    'duration': duration,\n                    'formats': formats,\n                    'subtitles': subtitles,\n                    'is_live': is_live,\n                })\n\n        for e in entries:\n            self._sort_formats(e['formats'])\n\n        return self.playlist_result(entries, playlist_id, playlist_title, playlist_description)\n\n    def _get_subtitles(self, episode_id, subs):\n        original_subtitles = self._download_webpage(\n            subs[0]['url'], episode_id, 'Downloading subtitles')\n        srt_subs = self._fix_subtitles(original_subtitles)\n        return {\n            'cs': [{\n                'ext': 'srt',\n                'data': srt_subs,\n            }]\n        }\n\n    @staticmethod\n    def _fix_subtitles(subtitles):\n        \"\"\" Convert millisecond-based subtitles to SRT \"\"\"\n\n        def _msectotimecode(msec):\n            \"\"\" Helper utility to convert milliseconds to timecode \"\"\"\n            components = []\n            for divider in [1000, 60, 60, 100]:\n                components.append(msec % divider)\n                msec //= divider\n            return '{3:02}:{2:02}:{1:02},{0:03}'.format(*components)\n\n        def _fix_subtitle(subtitle):\n            for line in subtitle.splitlines():\n                m = re.match(r'^\\s*([0-9]+);\\s*([0-9]+)\\s+([0-9]+)\\s*$', line)\n                if m:\n                    yield m.group(1)\n                    start, stop = (_msectotimecode(int(t)) for t in m.groups()[1:])\n                    yield '{0} --> {1}'.format(start, stop)\n                else:\n                    yield line\n\n        return '\\r\\n'.join(_fix_subtitle(subtitles))\n\n\nclass CeskaTelevizePoradyIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?ceskatelevize\\.cz/porady/(?:[^/?#&]+/)*(?P<id>[^/#?]+)'\n    _TESTS = [{\n        # video with 18+ caution trailer\n        'url': 'http://www.ceskatelevize.cz/porady/10520528904-queer/215562210900007-bogotart/',\n        'info_dict': {\n            'id': '215562210900007-bogotart',\n            'title': 'Queer: Bogotart',\n            'description': 'Alternativn\u00ed pr\u016fvodce sou\u010dasn\u00fdm queer sv\u011btem',\n        },\n        'playlist': [{\n            'info_dict': {\n                'id': '61924494876844842',\n                'ext': 'mp4',\n                'title': 'Queer: Bogotart (Varov\u00e1n\u00ed 18+)',\n                'duration': 10.2,\n            },\n        }, {\n            'info_dict': {\n                'id': '61924494877068022',\n                'ext': 'mp4',\n                'title': 'Queer: Bogotart (Queer)',\n                'thumbnail': r're:^https?://.*\\.jpg',\n                'duration': 1558.3,\n            },\n        }],\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id)\n\n        data_url = unescapeHTML(self._search_regex(\n            r'<span[^>]*\\bdata-url=([\"\\'])(?P<url>(?:(?!\\1).)+)\\1',\n            webpage, 'iframe player url', group='url'))\n\n        return self.url_result(data_url, ie=CeskaTelevizeIE.ie_key())\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "ceskatelevize.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/ceskatelevize.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}