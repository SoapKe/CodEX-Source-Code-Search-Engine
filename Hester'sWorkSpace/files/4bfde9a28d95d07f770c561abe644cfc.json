{"author": "ansible", "code": "\n\n This file is part of Ansible\n\n Ansible is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Ansible is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'network'}\n\n\nDOCUMENTATION = '''\n---\nmodule: nxos_vrf_interface\nextends_documentation_fragment: nxos\nversion_added: \"2.1\"\nshort_description: Manages interface specific VRF configuration.\ndescription:\n    - Manages interface specific VRF configuration.\nauthor:\n    - Jason Edelman (@jedelman8)\n    - Gabriele Gerbino (@GGabriele)\nnotes:\n    - Tested against NXOSv 7.3.(0)D1(1) on VIRL\n    - VRF needs to be added globally with M(nxos_vrf) before\n      adding a VRF to an interface.\n    - Remove a VRF from an interface will still remove\n      all L3 attributes just as it does from CLI.\n    - VRF is not read from an interface until IP address is\n      configured on that interface.\noptions:\n    vrf:\n        description:\n            - Name of VRF to be managed.\n        required: true\n    interface:\n        description:\n            - Full name of interface to be managed, i.e. Ethernet1/1.\n        required: true\n    state:\n        description:\n            - Manages desired state of the resource.\n        required: false\n        default: present\n        choices: ['present','absent']\n'''\n\nEXAMPLES = '''\n- name: Ensure vrf ntc exists on Eth1/1\n  nxos_vrf_interface:\n    vrf: ntc\n    interface: Ethernet1/1\n    state: present\n\n- name: Ensure ntc VRF does not exist on Eth1/1\n  nxos_vrf_interface:\n    vrf: ntc\n    interface: Ethernet1/1\n    state: absent\n'''\n\nRETURN = '''\ncommands:\n    description: commands sent to the device\n    returned: always\n    type: list\n    sample: [\"interface loopback16\", \"vrf member ntc\"]\n'''\nimport re\n\nfrom ansible.module_utils.network.nxos.nxos import load_config, run_commands\nfrom ansible.module_utils.network.nxos.nxos import get_capabilities, nxos_argument_spec\nfrom ansible.module_utils.basic import AnsibleModule\n\n\ndef execute_show_command(command, module):\n    if 'show run' not in command:\n        output = 'json'\n    else:\n        output = 'text'\n    cmds = [{\n        'command': command,\n        'output': output,\n    }]\n    return run_commands(module, cmds)[0]\n\n\ndef get_interface_type(interface):\n    if interface.upper().startswith('ET'):\n        return 'ethernet'\n    elif interface.upper().startswith('VL'):\n        return 'svi'\n    elif interface.upper().startswith('LO'):\n        return 'loopback'\n    elif interface.upper().startswith('MG'):\n        return 'management'\n    elif interface.upper().startswith('MA'):\n        return 'management'\n    elif interface.upper().startswith('PO'):\n        return 'portchannel'\n    else:\n        return 'unknown'\n\n\ndef get_interface_mode(interface, intf_type, module):\n    command = 'show interface {0}'.format(interface)\n    interface = {}\n    mode = 'unknown'\n\n    if intf_type in ['ethernet', 'portchannel']:\n        body = execute_show_command(command, module)\n        try:\n            interface_table = body['TABLE_interface']['ROW_interface']\n        except KeyError:\n            return mode\n\n        if interface_table and isinstance(interface_table, dict):\n            mode = str(interface_table.get('eth_mode', 'layer3'))\n            if mode == 'access' or mode == 'trunk':\n                mode = 'layer2'\n        else:\n            return mode\n\n    elif intf_type == 'loopback' or intf_type == 'svi':\n        mode = 'layer3'\n    return mode\n\n\ndef get_vrf_list(module):\n    command = 'show vrf all'\n    vrf_list = []\n    body = execute_show_command(command, module)\n\n    try:\n        vrf_table = body['TABLE_vrf']['ROW_vrf']\n    except (KeyError, AttributeError):\n        return vrf_list\n\n    for each in vrf_table:\n        vrf_list.append(str(each['vrf_name']))\n\n    return vrf_list\n\n\ndef get_interface_info(interface, module):\n    if not interface.startswith('loopback'):\n        interface = interface.capitalize()\n\n    command = 'show run interface {0}'.format(interface)\n    vrf_regex = r\".*vrf\\s+member\\s+(?P<vrf>\\S+).*\"\n\n    try:\n        body = execute_show_command(command, module)\n        match_vrf = re.match(vrf_regex, body, re.DOTALL)\n        group_vrf = match_vrf.groupdict()\n        vrf = group_vrf[\"vrf\"]\n    except (AttributeError, TypeError):\n        return \"\"\n\n    return vrf\n\n\ndef is_default(interface, module):\n    command = 'show run interface {0}'.format(interface)\n\n    try:\n        body = execute_show_command(command, module)\n        raw_list = body.split('\\n')\n        if raw_list[-1].startswith('interface'):\n            return True\n        else:\n            return False\n\n    except (KeyError, IndexError):\n        return 'DNE'\n\n\ndef main():\n    argument_spec = dict(\n        vrf=dict(required=True),\n        interface=dict(type='str', required=True),\n        state=dict(default='present', choices=['present', 'absent'], required=False),\n    )\n\n    argument_spec.update(nxos_argument_spec)\n\n    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)\n\n    warnings = list()\n    results = {'changed': False, 'commands': [], 'warnings': warnings}\n\n    vrf = module.params['vrf']\n    interface = module.params['interface'].lower()\n    state = module.params['state']\n\n    device_info = get_capabilities(module)\n    network_api = device_info.get('network_api', 'nxapi')\n\n    current_vrfs = get_vrf_list(module)\n    if vrf not in current_vrfs:\n        warnings.append(\"The VRF is not present/active on the device. \"\n                        \"Use nxos_vrf to fix this.\")\n\n    intf_type = get_interface_type(interface)\n    if (intf_type != 'ethernet' and network_api == 'cliconf'):\n        if is_default(interface, module) == 'DNE':\n            module.fail_json(msg=\"interface does not exist on switch. Verify \"\n                                 \"switch platform or create it first with \"\n                                 \"nxos_interface if it's a logical interface\")\n\n    mode = get_interface_mode(interface, intf_type, module)\n    if mode == 'layer2':\n        module.fail_json(msg='Ensure interface is a Layer 3 port before '\n                             'configuring a VRF on an interface. You can '\n                             'use nxos_interface')\n\n    proposed = dict(interface=interface, vrf=vrf)\n\n    current_vrf = get_interface_info(interface, module)\n    existing = dict(interface=interface, vrf=current_vrf)\n    changed = False\n    end_state = existing\n\n    if not existing['vrf']:\n        pass\n    elif vrf != existing['vrf'] and state == 'absent':\n        module.fail_json(msg='The VRF you are trying to remove '\n                             'from the interface does not exist '\n                             'on that interface.',\n                         interface=interface, proposed_vrf=vrf,\n                         existing_vrf=existing['vrf'])\n\n    commands = []\n    if existing:\n        if state == 'absent':\n            if existing and vrf == existing['vrf']:\n                command = 'no vrf member {0}'.format(vrf)\n                commands.append(command)\n\n        elif state == 'present':\n            if existing['vrf'] != vrf:\n                command = 'vrf member {0}'.format(vrf)\n                commands.append(command)\n\n    if commands:\n        commands.insert(0, 'interface {0}'.format(interface))\n\n    if commands:\n        if module.check_mode:\n            module.exit_json(changed=True, commands=commands)\n        else:\n            load_config(module, commands)\n            changed = True\n            changed_vrf = get_interface_info(interface, module)\n            end_state = dict(interface=interface, vrf=changed_vrf)\n            if 'configure' in commands:\n                commands.pop(0)\n\n    results['commands'] = commands\n    results['changed'] = changed\n\n    module.exit_json(**results)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  nxos vrf interface extends documentation fragment  nxos version added   2 1  short description  manages interface specific vrf configuration  description        manages interface specific vrf configuration  author        jason edelman ( jedelman8)       gabriele gerbino ( ggabriele) notes        tested nxosv 7 3 (0)d1(1) virl       vrf needs added globally m(nxos vrf)       adding vrf interface        remove vrf interface still remove       l3 attributes cli        vrf read interface ip address       configured interface  options      vrf          description                name vrf managed          required  true     interface          description                full name interface managed  e  ethernet1 1          required  true     state          description                manages desired state resource          required  false         default  present         choices    present   absent        examples         name  ensure vrf ntc exists eth1 1   nxos vrf interface      vrf  ntc     interface  ethernet1 1     state  present    name  ensure ntc vrf exist eth1 1   nxos vrf interface      vrf  ntc     interface  ethernet1 1     state  absent      return       commands      description  commands sent device     returned  always     type  list     sample    interface loopback16    vrf member ntc           usr bin python       this file part ansible       ansible free software  redistribute modify    terms gnu general public license published    free software foundation  either version 3 license     (at option) later version        ansible distributed hope useful     without any warranty  without even implied warranty    merchantability fitness for a particular purpose   see    gnu general public license details        you received copy gnu general public license    along ansible   if  see  http   www gnu org licenses       ", "content": "#!/usr/bin/python\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'network'}\n\n\nDOCUMENTATION = '''\n---\nmodule: nxos_vrf_interface\nextends_documentation_fragment: nxos\nversion_added: \"2.1\"\nshort_description: Manages interface specific VRF configuration.\ndescription:\n    - Manages interface specific VRF configuration.\nauthor:\n    - Jason Edelman (@jedelman8)\n    - Gabriele Gerbino (@GGabriele)\nnotes:\n    - Tested against NXOSv 7.3.(0)D1(1) on VIRL\n    - VRF needs to be added globally with M(nxos_vrf) before\n      adding a VRF to an interface.\n    - Remove a VRF from an interface will still remove\n      all L3 attributes just as it does from CLI.\n    - VRF is not read from an interface until IP address is\n      configured on that interface.\noptions:\n    vrf:\n        description:\n            - Name of VRF to be managed.\n        required: true\n    interface:\n        description:\n            - Full name of interface to be managed, i.e. Ethernet1/1.\n        required: true\n    state:\n        description:\n            - Manages desired state of the resource.\n        required: false\n        default: present\n        choices: ['present','absent']\n'''\n\nEXAMPLES = '''\n- name: Ensure vrf ntc exists on Eth1/1\n  nxos_vrf_interface:\n    vrf: ntc\n    interface: Ethernet1/1\n    state: present\n\n- name: Ensure ntc VRF does not exist on Eth1/1\n  nxos_vrf_interface:\n    vrf: ntc\n    interface: Ethernet1/1\n    state: absent\n'''\n\nRETURN = '''\ncommands:\n    description: commands sent to the device\n    returned: always\n    type: list\n    sample: [\"interface loopback16\", \"vrf member ntc\"]\n'''\nimport re\n\nfrom ansible.module_utils.network.nxos.nxos import load_config, run_commands\nfrom ansible.module_utils.network.nxos.nxos import get_capabilities, nxos_argument_spec\nfrom ansible.module_utils.basic import AnsibleModule\n\n\ndef execute_show_command(command, module):\n    if 'show run' not in command:\n        output = 'json'\n    else:\n        output = 'text'\n    cmds = [{\n        'command': command,\n        'output': output,\n    }]\n    return run_commands(module, cmds)[0]\n\n\ndef get_interface_type(interface):\n    if interface.upper().startswith('ET'):\n        return 'ethernet'\n    elif interface.upper().startswith('VL'):\n        return 'svi'\n    elif interface.upper().startswith('LO'):\n        return 'loopback'\n    elif interface.upper().startswith('MG'):\n        return 'management'\n    elif interface.upper().startswith('MA'):\n        return 'management'\n    elif interface.upper().startswith('PO'):\n        return 'portchannel'\n    else:\n        return 'unknown'\n\n\ndef get_interface_mode(interface, intf_type, module):\n    command = 'show interface {0}'.format(interface)\n    interface = {}\n    mode = 'unknown'\n\n    if intf_type in ['ethernet', 'portchannel']:\n        body = execute_show_command(command, module)\n        try:\n            interface_table = body['TABLE_interface']['ROW_interface']\n        except KeyError:\n            return mode\n\n        if interface_table and isinstance(interface_table, dict):\n            mode = str(interface_table.get('eth_mode', 'layer3'))\n            if mode == 'access' or mode == 'trunk':\n                mode = 'layer2'\n        else:\n            return mode\n\n    elif intf_type == 'loopback' or intf_type == 'svi':\n        mode = 'layer3'\n    return mode\n\n\ndef get_vrf_list(module):\n    command = 'show vrf all'\n    vrf_list = []\n    body = execute_show_command(command, module)\n\n    try:\n        vrf_table = body['TABLE_vrf']['ROW_vrf']\n    except (KeyError, AttributeError):\n        return vrf_list\n\n    for each in vrf_table:\n        vrf_list.append(str(each['vrf_name']))\n\n    return vrf_list\n\n\ndef get_interface_info(interface, module):\n    if not interface.startswith('loopback'):\n        interface = interface.capitalize()\n\n    command = 'show run interface {0}'.format(interface)\n    vrf_regex = r\".*vrf\\s+member\\s+(?P<vrf>\\S+).*\"\n\n    try:\n        body = execute_show_command(command, module)\n        match_vrf = re.match(vrf_regex, body, re.DOTALL)\n        group_vrf = match_vrf.groupdict()\n        vrf = group_vrf[\"vrf\"]\n    except (AttributeError, TypeError):\n        return \"\"\n\n    return vrf\n\n\ndef is_default(interface, module):\n    command = 'show run interface {0}'.format(interface)\n\n    try:\n        body = execute_show_command(command, module)\n        raw_list = body.split('\\n')\n        if raw_list[-1].startswith('interface'):\n            return True\n        else:\n            return False\n\n    except (KeyError, IndexError):\n        return 'DNE'\n\n\ndef main():\n    argument_spec = dict(\n        vrf=dict(required=True),\n        interface=dict(type='str', required=True),\n        state=dict(default='present', choices=['present', 'absent'], required=False),\n    )\n\n    argument_spec.update(nxos_argument_spec)\n\n    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)\n\n    warnings = list()\n    results = {'changed': False, 'commands': [], 'warnings': warnings}\n\n    vrf = module.params['vrf']\n    interface = module.params['interface'].lower()\n    state = module.params['state']\n\n    device_info = get_capabilities(module)\n    network_api = device_info.get('network_api', 'nxapi')\n\n    current_vrfs = get_vrf_list(module)\n    if vrf not in current_vrfs:\n        warnings.append(\"The VRF is not present/active on the device. \"\n                        \"Use nxos_vrf to fix this.\")\n\n    intf_type = get_interface_type(interface)\n    if (intf_type != 'ethernet' and network_api == 'cliconf'):\n        if is_default(interface, module) == 'DNE':\n            module.fail_json(msg=\"interface does not exist on switch. Verify \"\n                                 \"switch platform or create it first with \"\n                                 \"nxos_interface if it's a logical interface\")\n\n    mode = get_interface_mode(interface, intf_type, module)\n    if mode == 'layer2':\n        module.fail_json(msg='Ensure interface is a Layer 3 port before '\n                             'configuring a VRF on an interface. You can '\n                             'use nxos_interface')\n\n    proposed = dict(interface=interface, vrf=vrf)\n\n    current_vrf = get_interface_info(interface, module)\n    existing = dict(interface=interface, vrf=current_vrf)\n    changed = False\n    end_state = existing\n\n    if not existing['vrf']:\n        pass\n    elif vrf != existing['vrf'] and state == 'absent':\n        module.fail_json(msg='The VRF you are trying to remove '\n                             'from the interface does not exist '\n                             'on that interface.',\n                         interface=interface, proposed_vrf=vrf,\n                         existing_vrf=existing['vrf'])\n\n    commands = []\n    if existing:\n        if state == 'absent':\n            if existing and vrf == existing['vrf']:\n                command = 'no vrf member {0}'.format(vrf)\n                commands.append(command)\n\n        elif state == 'present':\n            if existing['vrf'] != vrf:\n                command = 'vrf member {0}'.format(vrf)\n                commands.append(command)\n\n    if commands:\n        commands.insert(0, 'interface {0}'.format(interface))\n\n    if commands:\n        if module.check_mode:\n            module.exit_json(changed=True, commands=commands)\n        else:\n            load_config(module, commands)\n            changed = True\n            changed_vrf = get_interface_info(interface, module)\n            end_state = dict(interface=interface, vrf=changed_vrf)\n            if 'configure' in commands:\n                commands.pop(0)\n\n    results['commands'] = commands\n    results['changed'] = changed\n\n    module.exit_json(**results)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "nxos_vrf_interface.py", "id": "4bfde9a28d95d07f770c561abe644cfc", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/network/nxos/nxos_vrf_interface.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}