{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    int_or_none,\n    parse_duration,\n    remove_end,\n    xpath_element,\n    xpath_text,\n)\n\n\nclass DigitallySpeakingIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:s?evt\\.dispeak|events\\.digitallyspeaking)\\.com/(?:[^/]+/)+xml/(?P<id>[^.]+)\\.xml'\n\n    _TESTS = [{\n        \n        'url': 'http://evt.dispeak.com/ubm/gdc/sf16/xml/840376_BQRC.xml',\n        'md5': 'a8efb6c31ed06ca8739294960b2dbabd',\n        'info_dict': {\n            'id': '840376_BQRC',\n            'ext': 'mp4',\n            'title': 'Tenacious Design and The Interface of \\'Destiny\\'',\n        },\n    }, {\n        \n        'url': 'http://events.digitallyspeaking.com/gdc/sf11/xml/12396_1299111843500GMPX.xml',\n        'only_matching': True,\n    }, {\n        \n        'url': 'http://sevt.dispeak.com/ubm/gdc/eur10/xml/11256_1282118587281VNIT.xml',\n        'only_matching': True,\n    }]\n\n    def _parse_mp4(self, metadata):\n        video_formats = []\n        video_root = None\n\n        mp4_video = xpath_text(metadata, './mp4video', default=None)\n        if mp4_video is not None:\n            mobj = re.match(r'(?P<root>https?://.*?/).*', mp4_video)\n            video_root = mobj.group('root')\n        if video_root is None:\n            http_host = xpath_text(metadata, 'httpHost', default=None)\n            if http_host:\n                video_root = 'http://%s/' % http_host\n        if video_root is None:\n            \n            \n            video_root = 'http://s3-2u.digitallyspeaking.com/'\n\n        formats = metadata.findall('./MBRVideos/MBRVideo')\n        if not formats:\n            return None\n        for a_format in formats:\n            stream_name = xpath_text(a_format, 'streamName', fatal=True)\n            video_path = re.match(r'mp4\\:(?P<path>.*)', stream_name).group('path')\n            url = video_root + video_path\n            vbr = xpath_text(a_format, 'bitrate')\n            video_formats.append({\n                'url': url,\n                'vbr': int_or_none(vbr),\n            })\n        return video_formats\n\n    def _parse_flv(self, metadata):\n        formats = []\n        akamai_url = xpath_text(metadata, './akamaiHost', fatal=True)\n        audios = metadata.findall('./audios/audio')\n        for audio in audios:\n            formats.append({\n                'url': 'rtmp://%s/ondemand?ovpfv=1.1' % akamai_url,\n                'play_path': remove_end(audio.get('url'), '.flv'),\n                'ext': 'flv',\n                'vcodec': 'none',\n                'format_id': audio.get('code'),\n            })\n        slide_video_path = xpath_text(metadata, './slideVideo', fatal=True)\n        formats.append({\n            'url': 'rtmp://%s/ondemand?ovpfv=1.1' % akamai_url,\n            'play_path': remove_end(slide_video_path, '.flv'),\n            'ext': 'flv',\n            'format_note': 'slide deck video',\n            'quality': -2,\n            'preference': -2,\n            'format_id': 'slides',\n        })\n        speaker_video_path = xpath_text(metadata, './speakerVideo', fatal=True)\n        formats.append({\n            'url': 'rtmp://%s/ondemand?ovpfv=1.1' % akamai_url,\n            'play_path': remove_end(speaker_video_path, '.flv'),\n            'ext': 'flv',\n            'format_note': 'speaker video',\n            'quality': -1,\n            'preference': -1,\n            'format_id': 'speaker',\n        })\n        return formats\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        xml_description = self._download_xml(url, video_id)\n        metadata = xpath_element(xml_description, 'metadata')\n\n        video_formats = self._parse_mp4(metadata)\n        if video_formats is None:\n            video_formats = self._parse_flv(metadata)\n\n        return {\n            'id': video_id,\n            'formats': video_formats,\n            'title': xpath_text(metadata, 'title', fatal=True),\n            'duration': parse_duration(xpath_text(metadata, 'endTime')),\n            'creator': xpath_text(metadata, 'speaker'),\n        }\n", "comments": "# From http://gdcvault.com/play/1023460/Tenacious-Design-and-The-Interface\n# From http://www.gdcvault.com/play/1014631/Classic-Game-Postmortem-PAC\n# From http://www.gdcvault.com/play/1013700/Advanced-Material\n# Hard-coded in http://evt.dispeak.com/ubm/gdc/sf16/custom/player2.js\n# Works for GPUTechConf, too\n", "content": "from __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    int_or_none,\n    parse_duration,\n    remove_end,\n    xpath_element,\n    xpath_text,\n)\n\n\nclass DigitallySpeakingIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:s?evt\\.dispeak|events\\.digitallyspeaking)\\.com/(?:[^/]+/)+xml/(?P<id>[^.]+)\\.xml'\n\n    _TESTS = [{\n        # From http://gdcvault.com/play/1023460/Tenacious-Design-and-The-Interface\n        'url': 'http://evt.dispeak.com/ubm/gdc/sf16/xml/840376_BQRC.xml',\n        'md5': 'a8efb6c31ed06ca8739294960b2dbabd',\n        'info_dict': {\n            'id': '840376_BQRC',\n            'ext': 'mp4',\n            'title': 'Tenacious Design and The Interface of \\'Destiny\\'',\n        },\n    }, {\n        # From http://www.gdcvault.com/play/1014631/Classic-Game-Postmortem-PAC\n        'url': 'http://events.digitallyspeaking.com/gdc/sf11/xml/12396_1299111843500GMPX.xml',\n        'only_matching': True,\n    }, {\n        # From http://www.gdcvault.com/play/1013700/Advanced-Material\n        'url': 'http://sevt.dispeak.com/ubm/gdc/eur10/xml/11256_1282118587281VNIT.xml',\n        'only_matching': True,\n    }]\n\n    def _parse_mp4(self, metadata):\n        video_formats = []\n        video_root = None\n\n        mp4_video = xpath_text(metadata, './mp4video', default=None)\n        if mp4_video is not None:\n            mobj = re.match(r'(?P<root>https?://.*?/).*', mp4_video)\n            video_root = mobj.group('root')\n        if video_root is None:\n            http_host = xpath_text(metadata, 'httpHost', default=None)\n            if http_host:\n                video_root = 'http://%s/' % http_host\n        if video_root is None:\n            # Hard-coded in http://evt.dispeak.com/ubm/gdc/sf16/custom/player2.js\n            # Works for GPUTechConf, too\n            video_root = 'http://s3-2u.digitallyspeaking.com/'\n\n        formats = metadata.findall('./MBRVideos/MBRVideo')\n        if not formats:\n            return None\n        for a_format in formats:\n            stream_name = xpath_text(a_format, 'streamName', fatal=True)\n            video_path = re.match(r'mp4\\:(?P<path>.*)', stream_name).group('path')\n            url = video_root + video_path\n            vbr = xpath_text(a_format, 'bitrate')\n            video_formats.append({\n                'url': url,\n                'vbr': int_or_none(vbr),\n            })\n        return video_formats\n\n    def _parse_flv(self, metadata):\n        formats = []\n        akamai_url = xpath_text(metadata, './akamaiHost', fatal=True)\n        audios = metadata.findall('./audios/audio')\n        for audio in audios:\n            formats.append({\n                'url': 'rtmp://%s/ondemand?ovpfv=1.1' % akamai_url,\n                'play_path': remove_end(audio.get('url'), '.flv'),\n                'ext': 'flv',\n                'vcodec': 'none',\n                'format_id': audio.get('code'),\n            })\n        slide_video_path = xpath_text(metadata, './slideVideo', fatal=True)\n        formats.append({\n            'url': 'rtmp://%s/ondemand?ovpfv=1.1' % akamai_url,\n            'play_path': remove_end(slide_video_path, '.flv'),\n            'ext': 'flv',\n            'format_note': 'slide deck video',\n            'quality': -2,\n            'preference': -2,\n            'format_id': 'slides',\n        })\n        speaker_video_path = xpath_text(metadata, './speakerVideo', fatal=True)\n        formats.append({\n            'url': 'rtmp://%s/ondemand?ovpfv=1.1' % akamai_url,\n            'play_path': remove_end(speaker_video_path, '.flv'),\n            'ext': 'flv',\n            'format_note': 'speaker video',\n            'quality': -1,\n            'preference': -1,\n            'format_id': 'speaker',\n        })\n        return formats\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        xml_description = self._download_xml(url, video_id)\n        metadata = xpath_element(xml_description, 'metadata')\n\n        video_formats = self._parse_mp4(metadata)\n        if video_formats is None:\n            video_formats = self._parse_flv(metadata)\n\n        return {\n            'id': video_id,\n            'formats': video_formats,\n            'title': xpath_text(metadata, 'title', fatal=True),\n            'duration': parse_duration(xpath_text(metadata, 'endTime')),\n            'creator': xpath_text(metadata, 'speaker'),\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "dispeak.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/dispeak.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}