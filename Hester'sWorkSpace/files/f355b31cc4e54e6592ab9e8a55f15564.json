{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_HTTPError,\n    compat_kwargs,\n    compat_str,\n    compat_urllib_request,\n    compat_urlparse,\n)\nfrom ..utils import (\n    determine_ext,\n    extract_attributes,\n    ExtractorError,\n    float_or_none,\n    int_or_none,\n    js_to_json,\n    sanitized_Request,\n    unescapeHTML,\n    urlencode_postdata,\n)\n\n\nclass UdemyIE(InfoExtractor):\n    IE_NAME = 'udemy'\n    _VALID_URL = r\n    _LOGIN_URL = 'https://www.udemy.com/join/login-popup/?displayType=ajax&showSkipButton=1'\n    _ORIGIN_URL = 'https://www.udemy.com'\n    _NETRC_MACHINE = 'udemy'\n\n    _TESTS = [{\n        'url': 'https://www.udemy.com/java-tutorial/\n        'md5': '98eda5b657e752cf945d8445e261b5c5',\n        'info_dict': {\n            'id': '160614',\n            'ext': 'mp4',\n            'title': 'Introduction and Installation',\n            'description': 'md5:c0d51f6f21ef4ec65f091055a5eef876',\n            'duration': 579.29,\n        },\n        'skip': 'Requires udemy account credentials',\n    }, {\n        \n        'url': 'https://www.udemy.com/electric-bass-right-from-the-start/learn/v4/t/lecture/4580906',\n        'only_matching': True,\n    }, {\n        \n        'url': 'https://www.udemy.com/learn-web-development-complete-step-by-step-guide-to-success/learn/v4/t/lecture/4125812',\n        'only_matching': True,\n    }]\n\n    def _extract_course_info(self, webpage, video_id):\n        course = self._parse_json(\n            unescapeHTML(self._search_regex(\n                r'ng-init=[\"\\'].*\\bcourse=({.+?})[;\"\\']',\n                webpage, 'course', default='{}')),\n            video_id, fatal=False) or {}\n        course_id = course.get('id') or self._search_regex(\n            r'data-course-id=[\"\\'](\\d+)', webpage, 'course id')\n        return course_id, course.get('title')\n\n    def _enroll_course(self, base_url, webpage, course_id):\n        def combine_url(base_url, url):\n            return compat_urlparse.urljoin(base_url, url) if not url.startswith('http') else url\n\n        checkout_url = unescapeHTML(self._search_regex(\n            r'href=([\"\\'])(?P<url>(?:https?://(?:www\\.)?udemy\\.com)?/(?:payment|cart)/checkout/.+?)\\1',\n            webpage, 'checkout url', group='url', default=None))\n        if checkout_url:\n            raise ExtractorError(\n                'Course %s is not free. You have to pay for it before you can download. '\n                'Use this URL to confirm purchase: %s'\n                % (course_id, combine_url(base_url, checkout_url)),\n                expected=True)\n\n        enroll_url = unescapeHTML(self._search_regex(\n            r'href=([\"\\'])(?P<url>(?:https?://(?:www\\.)?udemy\\.com)?/course/subscribe/.+?)\\1',\n            webpage, 'enroll url', group='url', default=None))\n        if enroll_url:\n            webpage = self._download_webpage(\n                combine_url(base_url, enroll_url),\n                course_id, 'Enrolling in the course',\n                headers={'Referer': base_url})\n            if '>You have enrolled in' in webpage:\n                self.to_screen('%s: Successfully enrolled in the course' % course_id)\n\n    def _download_lecture(self, course_id, lecture_id):\n        return self._download_json(\n            'https://www.udemy.com/api-2.0/users/me/subscribed-courses/%s/lectures/%s?'\n            % (course_id, lecture_id),\n            lecture_id, 'Downloading lecture JSON', query={\n                'fields[lecture]': 'title,description,view_html,asset',\n                'fields[asset]': 'asset_type,stream_url,thumbnail_url,download_urls,data',\n            })\n\n    def _handle_error(self, response):\n        if not isinstance(response, dict):\n            return\n        error = response.get('error')\n        if error:\n            error_str = 'Udemy returned error \n            error_data = error.get('data')\n            if error_data:\n                error_str += ' - %s' % error_data.get('formErrors')\n            raise ExtractorError(error_str, expected=True)\n\n    def _download_webpage(self, *args, **kwargs):\n        kwargs.setdefault('headers', {})['User-Agent'] = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/603.2.4 (KHTML, like Gecko) Version/10.1.1 Safari/603.2.4'\n        return super(UdemyIE, self)._download_webpage(\n            *args, **compat_kwargs(kwargs))\n\n    def _download_json(self, url_or_request, *args, **kwargs):\n        headers = {\n            'X-Udemy-Snail-Case': 'true',\n            'X-Requested-With': 'XMLHttpRequest',\n        }\n        for cookie in self._downloader.cookiejar:\n            if cookie.name == 'client_id':\n                headers['X-Udemy-Client-Id'] = cookie.value\n            elif cookie.name == 'access_token':\n                headers['X-Udemy-Bearer-Token'] = cookie.value\n                headers['X-Udemy-Authorization'] = 'Bearer %s' % cookie.value\n\n        if isinstance(url_or_request, compat_urllib_request.Request):\n            for header, value in headers.items():\n                url_or_request.add_header(header, value)\n        else:\n            url_or_request = sanitized_Request(url_or_request, headers=headers)\n\n        response = super(UdemyIE, self)._download_json(url_or_request, *args, **kwargs)\n        self._handle_error(response)\n        return response\n\n    def _real_initialize(self):\n        self._login()\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n\n        login_popup = self._download_webpage(\n            self._LOGIN_URL, None, 'Downloading login popup')\n\n        def is_logged(webpage):\n            return any(re.search(p, webpage) for p in (\n                r'href=[\"\\'](?:https://www\\.udemy\\.com)?/user/logout/',\n                r'>Logout<'))\n\n        \n        if is_logged(login_popup):\n            return\n\n        login_form = self._form_hidden_inputs('login-form', login_popup)\n\n        login_form.update({\n            'email': username,\n            'password': password,\n        })\n\n        response = self._download_webpage(\n            self._LOGIN_URL, None, 'Logging in',\n            data=urlencode_postdata(login_form),\n            headers={\n                'Referer': self._ORIGIN_URL,\n                'Origin': self._ORIGIN_URL,\n            })\n\n        if not is_logged(response):\n            error = self._html_search_regex(\n                r'(?s)<div[^>]+class=\"form-errors[^\"]*\">(.+?)</div>',\n                response, 'error message', default=None)\n            if error:\n                raise ExtractorError('Unable to login: %s' % error, expected=True)\n            raise ExtractorError('Unable to log in')\n\n    def _real_extract(self, url):\n        lecture_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, lecture_id)\n\n        course_id, _ = self._extract_course_info(webpage, lecture_id)\n\n        try:\n            lecture = self._download_lecture(course_id, lecture_id)\n        except ExtractorError as e:\n            \n            if isinstance(e.cause, compat_HTTPError) and e.cause.code == 403:\n                self._enroll_course(url, webpage, course_id)\n                lecture = self._download_lecture(course_id, lecture_id)\n            else:\n                raise\n\n        title = lecture['title']\n        description = lecture.get('description')\n\n        asset = lecture['asset']\n\n        asset_type = asset.get('asset_type') or asset.get('assetType')\n        if asset_type != 'Video':\n            raise ExtractorError(\n                'Lecture %s is not a video' % lecture_id, expected=True)\n\n        stream_url = asset.get('stream_url') or asset.get('streamUrl')\n        if stream_url:\n            youtube_url = self._search_regex(\n                r'(https?://www\\.youtube\\.com/watch\\?v=.*)', stream_url, 'youtube URL', default=None)\n            if youtube_url:\n                return self.url_result(youtube_url, 'Youtube')\n\n        video_id = compat_str(asset['id'])\n        thumbnail = asset.get('thumbnail_url') or asset.get('thumbnailUrl')\n        duration = float_or_none(asset.get('data', {}).get('duration'))\n\n        subtitles = {}\n        automatic_captions = {}\n\n        formats = []\n\n        def extract_output_format(src, f_id):\n            return {\n                'url': src.get('url'),\n                'format_id': '%sp' % (src.get('height') or f_id),\n                'width': int_or_none(src.get('width')),\n                'height': int_or_none(src.get('height')),\n                'vbr': int_or_none(src.get('video_bitrate_in_kbps')),\n                'vcodec': src.get('video_codec'),\n                'fps': int_or_none(src.get('frame_rate')),\n                'abr': int_or_none(src.get('audio_bitrate_in_kbps')),\n                'acodec': src.get('audio_codec'),\n                'asr': int_or_none(src.get('audio_sample_rate')),\n                'tbr': int_or_none(src.get('total_bitrate_in_kbps')),\n                'filesize': int_or_none(src.get('file_size_in_bytes')),\n            }\n\n        outputs = asset.get('data', {}).get('outputs')\n        if not isinstance(outputs, dict):\n            outputs = {}\n\n        def add_output_format_meta(f, key):\n            output = outputs.get(key)\n            if isinstance(output, dict):\n                output_format = extract_output_format(output, key)\n                output_format.update(f)\n                return output_format\n            return f\n\n        def extract_formats(source_list):\n            if not isinstance(source_list, list):\n                return\n            for source in source_list:\n                video_url = source.get('file') or source.get('src')\n                if not video_url or not isinstance(video_url, compat_str):\n                    continue\n                if source.get('type') == 'application/x-mpegURL' or determine_ext(video_url) == 'm3u8':\n                    formats.extend(self._extract_m3u8_formats(\n                        video_url, video_id, 'mp4', entry_protocol='m3u8_native',\n                        m3u8_id='hls', fatal=False))\n                    continue\n                format_id = source.get('label')\n                f = {\n                    'url': video_url,\n                    'format_id': '%sp' % format_id,\n                    'height': int_or_none(format_id),\n                }\n                if format_id:\n                    \n                    \n                    f = add_output_format_meta(f, format_id)\n                formats.append(f)\n\n        def extract_subtitles(track_list):\n            if not isinstance(track_list, list):\n                return\n            for track in track_list:\n                if not isinstance(track, dict):\n                    continue\n                if track.get('kind') != 'captions':\n                    continue\n                src = track.get('src')\n                if not src or not isinstance(src, compat_str):\n                    continue\n                lang = track.get('language') or track.get(\n                    'srclang') or track.get('label')\n                sub_dict = automatic_captions if track.get(\n                    'autogenerated') is True else subtitles\n                sub_dict.setdefault(lang, []).append({\n                    'url': src,\n                })\n\n        download_urls = asset.get('download_urls')\n        if isinstance(download_urls, dict):\n            extract_formats(download_urls.get('Video'))\n\n        view_html = lecture.get('view_html')\n        if view_html:\n            view_html_urls = set()\n            for source in re.findall(r'<source[^>]+>', view_html):\n                attributes = extract_attributes(source)\n                src = attributes.get('src')\n                if not src:\n                    continue\n                res = attributes.get('data-res')\n                height = int_or_none(res)\n                if src in view_html_urls:\n                    continue\n                view_html_urls.add(src)\n                if attributes.get('type') == 'application/x-mpegURL' or determine_ext(src) == 'm3u8':\n                    m3u8_formats = self._extract_m3u8_formats(\n                        src, video_id, 'mp4', entry_protocol='m3u8_native',\n                        m3u8_id='hls', fatal=False)\n                    for f in m3u8_formats:\n                        m = re.search(r'/hls_(?P<height>\\d{3,4})_(?P<tbr>\\d{2,})/', f['url'])\n                        if m:\n                            if not f.get('height'):\n                                f['height'] = int(m.group('height'))\n                            if not f.get('tbr'):\n                                f['tbr'] = int(m.group('tbr'))\n                    formats.extend(m3u8_formats)\n                else:\n                    formats.append(add_output_format_meta({\n                        'url': src,\n                        'format_id': '%dp' % height if height else None,\n                        'height': height,\n                    }, res))\n\n            \n            \n            data = self._parse_json(\n                self._search_regex(\n                    r'videojs-setup-data=([\"\\'])(?P<data>{.+?})\\1', view_html,\n                    'setup data', default='{}', group='data'), video_id,\n                transform_source=unescapeHTML, fatal=False)\n            if data and isinstance(data, dict):\n                extract_formats(data.get('sources'))\n                if not duration:\n                    duration = int_or_none(data.get('duration'))\n                extract_subtitles(data.get('tracks'))\n\n            if not subtitles and not automatic_captions:\n                text_tracks = self._parse_json(\n                    self._search_regex(\n                        r'text-tracks=([\"\\'])(?P<data>\\[.+?\\])\\1', view_html,\n                        'text tracks', default='{}', group='data'), video_id,\n                    transform_source=lambda s: js_to_json(unescapeHTML(s)),\n                    fatal=False)\n                extract_subtitles(text_tracks)\n\n        self._sort_formats(formats, field_preference=('height', 'width', 'tbr', 'format_id'))\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'thumbnail': thumbnail,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': subtitles,\n            'automatic_captions': automatic_captions,\n        }\n\n\nclass UdemyCourseIE(UdemyIE):\n    IE_NAME = 'udemy:course'\n    _VALID_URL = r'https?://(?:www\\.)?udemy\\.com/(?P<id>[^/?\n    _TESTS = []\n\n    @classmethod\n    def suitable(cls, url):\n        return False if UdemyIE.suitable(url) else super(UdemyCourseIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        course_path = self._match_id(url)\n\n        webpage = self._download_webpage(url, course_path)\n\n        course_id, title = self._extract_course_info(webpage, course_path)\n\n        self._enroll_course(url, webpage, course_id)\n\n        response = self._download_json(\n            'https://www.udemy.com/api-2.0/courses/%s/cached-subscriber-curriculum-items' % course_id,\n            course_id, 'Downloading course curriculum', query={\n                'fields[chapter]': 'title,object_index',\n                'fields[lecture]': 'title,asset',\n                'page_size': '1000',\n            })\n\n        entries = []\n        chapter, chapter_number = [None] * 2\n        for entry in response['results']:\n            clazz = entry.get('_class')\n            if clazz == 'lecture':\n                asset = entry.get('asset')\n                if isinstance(asset, dict):\n                    asset_type = asset.get('asset_type') or asset.get('assetType')\n                    if asset_type != 'Video':\n                        continue\n                lecture_id = entry.get('id')\n                if lecture_id:\n                    entry = {\n                        '_type': 'url_transparent',\n                        'url': 'https://www.udemy.com/%s/learn/v4/t/lecture/%s' % (course_path, entry['id']),\n                        'title': entry.get('title'),\n                        'ie_key': UdemyIE.ie_key(),\n                    }\n                    if chapter_number:\n                        entry['chapter_number'] = chapter_number\n                    if chapter:\n                        entry['chapter'] = chapter\n                    entries.append(entry)\n            elif clazz == 'chapter':\n                chapter_number = entry.get('object_index')\n                chapter = entry.get('title')\n\n        return self.playlist_result(entries, course_id, title)\n", "comments": "(?x)\n                    https?://\n                        www\\.udemy\\.com/\n                        (?:\n                            [^#]+\\#/lecture/|\n                            lecture/view/?\\?lectureId=|\n                            [^/]+/learn/v4/t/lecture/\n                        )\n                        (?P<id>\\d+)\n                    \n \n#/lecture/172757',\n# new URL schema\n# no url in outputs format entry\n#%s: %s' % (error.get('code'), error.get('message'))\n# already logged in\n# Error could possibly mean we are not enrolled in the course\n# Some videos contain additional metadata (e.g.\n# https://www.udemy.com/ios9-swift/learn/#/lecture/3383208)\n# react rendition since 2017.04.15 (see\n# https://github.com/rg3/youtube-dl/issues/12744)\n#&]+)'\n", "content": "from __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_HTTPError,\n    compat_kwargs,\n    compat_str,\n    compat_urllib_request,\n    compat_urlparse,\n)\nfrom ..utils import (\n    determine_ext,\n    extract_attributes,\n    ExtractorError,\n    float_or_none,\n    int_or_none,\n    js_to_json,\n    sanitized_Request,\n    unescapeHTML,\n    urlencode_postdata,\n)\n\n\nclass UdemyIE(InfoExtractor):\n    IE_NAME = 'udemy'\n    _VALID_URL = r'''(?x)\n                    https?://\n                        www\\.udemy\\.com/\n                        (?:\n                            [^#]+\\#/lecture/|\n                            lecture/view/?\\?lectureId=|\n                            [^/]+/learn/v4/t/lecture/\n                        )\n                        (?P<id>\\d+)\n                    '''\n    _LOGIN_URL = 'https://www.udemy.com/join/login-popup/?displayType=ajax&showSkipButton=1'\n    _ORIGIN_URL = 'https://www.udemy.com'\n    _NETRC_MACHINE = 'udemy'\n\n    _TESTS = [{\n        'url': 'https://www.udemy.com/java-tutorial/#/lecture/172757',\n        'md5': '98eda5b657e752cf945d8445e261b5c5',\n        'info_dict': {\n            'id': '160614',\n            'ext': 'mp4',\n            'title': 'Introduction and Installation',\n            'description': 'md5:c0d51f6f21ef4ec65f091055a5eef876',\n            'duration': 579.29,\n        },\n        'skip': 'Requires udemy account credentials',\n    }, {\n        # new URL schema\n        'url': 'https://www.udemy.com/electric-bass-right-from-the-start/learn/v4/t/lecture/4580906',\n        'only_matching': True,\n    }, {\n        # no url in outputs format entry\n        'url': 'https://www.udemy.com/learn-web-development-complete-step-by-step-guide-to-success/learn/v4/t/lecture/4125812',\n        'only_matching': True,\n    }]\n\n    def _extract_course_info(self, webpage, video_id):\n        course = self._parse_json(\n            unescapeHTML(self._search_regex(\n                r'ng-init=[\"\\'].*\\bcourse=({.+?})[;\"\\']',\n                webpage, 'course', default='{}')),\n            video_id, fatal=False) or {}\n        course_id = course.get('id') or self._search_regex(\n            r'data-course-id=[\"\\'](\\d+)', webpage, 'course id')\n        return course_id, course.get('title')\n\n    def _enroll_course(self, base_url, webpage, course_id):\n        def combine_url(base_url, url):\n            return compat_urlparse.urljoin(base_url, url) if not url.startswith('http') else url\n\n        checkout_url = unescapeHTML(self._search_regex(\n            r'href=([\"\\'])(?P<url>(?:https?://(?:www\\.)?udemy\\.com)?/(?:payment|cart)/checkout/.+?)\\1',\n            webpage, 'checkout url', group='url', default=None))\n        if checkout_url:\n            raise ExtractorError(\n                'Course %s is not free. You have to pay for it before you can download. '\n                'Use this URL to confirm purchase: %s'\n                % (course_id, combine_url(base_url, checkout_url)),\n                expected=True)\n\n        enroll_url = unescapeHTML(self._search_regex(\n            r'href=([\"\\'])(?P<url>(?:https?://(?:www\\.)?udemy\\.com)?/course/subscribe/.+?)\\1',\n            webpage, 'enroll url', group='url', default=None))\n        if enroll_url:\n            webpage = self._download_webpage(\n                combine_url(base_url, enroll_url),\n                course_id, 'Enrolling in the course',\n                headers={'Referer': base_url})\n            if '>You have enrolled in' in webpage:\n                self.to_screen('%s: Successfully enrolled in the course' % course_id)\n\n    def _download_lecture(self, course_id, lecture_id):\n        return self._download_json(\n            'https://www.udemy.com/api-2.0/users/me/subscribed-courses/%s/lectures/%s?'\n            % (course_id, lecture_id),\n            lecture_id, 'Downloading lecture JSON', query={\n                'fields[lecture]': 'title,description,view_html,asset',\n                'fields[asset]': 'asset_type,stream_url,thumbnail_url,download_urls,data',\n            })\n\n    def _handle_error(self, response):\n        if not isinstance(response, dict):\n            return\n        error = response.get('error')\n        if error:\n            error_str = 'Udemy returned error #%s: %s' % (error.get('code'), error.get('message'))\n            error_data = error.get('data')\n            if error_data:\n                error_str += ' - %s' % error_data.get('formErrors')\n            raise ExtractorError(error_str, expected=True)\n\n    def _download_webpage(self, *args, **kwargs):\n        kwargs.setdefault('headers', {})['User-Agent'] = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/603.2.4 (KHTML, like Gecko) Version/10.1.1 Safari/603.2.4'\n        return super(UdemyIE, self)._download_webpage(\n            *args, **compat_kwargs(kwargs))\n\n    def _download_json(self, url_or_request, *args, **kwargs):\n        headers = {\n            'X-Udemy-Snail-Case': 'true',\n            'X-Requested-With': 'XMLHttpRequest',\n        }\n        for cookie in self._downloader.cookiejar:\n            if cookie.name == 'client_id':\n                headers['X-Udemy-Client-Id'] = cookie.value\n            elif cookie.name == 'access_token':\n                headers['X-Udemy-Bearer-Token'] = cookie.value\n                headers['X-Udemy-Authorization'] = 'Bearer %s' % cookie.value\n\n        if isinstance(url_or_request, compat_urllib_request.Request):\n            for header, value in headers.items():\n                url_or_request.add_header(header, value)\n        else:\n            url_or_request = sanitized_Request(url_or_request, headers=headers)\n\n        response = super(UdemyIE, self)._download_json(url_or_request, *args, **kwargs)\n        self._handle_error(response)\n        return response\n\n    def _real_initialize(self):\n        self._login()\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n\n        login_popup = self._download_webpage(\n            self._LOGIN_URL, None, 'Downloading login popup')\n\n        def is_logged(webpage):\n            return any(re.search(p, webpage) for p in (\n                r'href=[\"\\'](?:https://www\\.udemy\\.com)?/user/logout/',\n                r'>Logout<'))\n\n        # already logged in\n        if is_logged(login_popup):\n            return\n\n        login_form = self._form_hidden_inputs('login-form', login_popup)\n\n        login_form.update({\n            'email': username,\n            'password': password,\n        })\n\n        response = self._download_webpage(\n            self._LOGIN_URL, None, 'Logging in',\n            data=urlencode_postdata(login_form),\n            headers={\n                'Referer': self._ORIGIN_URL,\n                'Origin': self._ORIGIN_URL,\n            })\n\n        if not is_logged(response):\n            error = self._html_search_regex(\n                r'(?s)<div[^>]+class=\"form-errors[^\"]*\">(.+?)</div>',\n                response, 'error message', default=None)\n            if error:\n                raise ExtractorError('Unable to login: %s' % error, expected=True)\n            raise ExtractorError('Unable to log in')\n\n    def _real_extract(self, url):\n        lecture_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, lecture_id)\n\n        course_id, _ = self._extract_course_info(webpage, lecture_id)\n\n        try:\n            lecture = self._download_lecture(course_id, lecture_id)\n        except ExtractorError as e:\n            # Error could possibly mean we are not enrolled in the course\n            if isinstance(e.cause, compat_HTTPError) and e.cause.code == 403:\n                self._enroll_course(url, webpage, course_id)\n                lecture = self._download_lecture(course_id, lecture_id)\n            else:\n                raise\n\n        title = lecture['title']\n        description = lecture.get('description')\n\n        asset = lecture['asset']\n\n        asset_type = asset.get('asset_type') or asset.get('assetType')\n        if asset_type != 'Video':\n            raise ExtractorError(\n                'Lecture %s is not a video' % lecture_id, expected=True)\n\n        stream_url = asset.get('stream_url') or asset.get('streamUrl')\n        if stream_url:\n            youtube_url = self._search_regex(\n                r'(https?://www\\.youtube\\.com/watch\\?v=.*)', stream_url, 'youtube URL', default=None)\n            if youtube_url:\n                return self.url_result(youtube_url, 'Youtube')\n\n        video_id = compat_str(asset['id'])\n        thumbnail = asset.get('thumbnail_url') or asset.get('thumbnailUrl')\n        duration = float_or_none(asset.get('data', {}).get('duration'))\n\n        subtitles = {}\n        automatic_captions = {}\n\n        formats = []\n\n        def extract_output_format(src, f_id):\n            return {\n                'url': src.get('url'),\n                'format_id': '%sp' % (src.get('height') or f_id),\n                'width': int_or_none(src.get('width')),\n                'height': int_or_none(src.get('height')),\n                'vbr': int_or_none(src.get('video_bitrate_in_kbps')),\n                'vcodec': src.get('video_codec'),\n                'fps': int_or_none(src.get('frame_rate')),\n                'abr': int_or_none(src.get('audio_bitrate_in_kbps')),\n                'acodec': src.get('audio_codec'),\n                'asr': int_or_none(src.get('audio_sample_rate')),\n                'tbr': int_or_none(src.get('total_bitrate_in_kbps')),\n                'filesize': int_or_none(src.get('file_size_in_bytes')),\n            }\n\n        outputs = asset.get('data', {}).get('outputs')\n        if not isinstance(outputs, dict):\n            outputs = {}\n\n        def add_output_format_meta(f, key):\n            output = outputs.get(key)\n            if isinstance(output, dict):\n                output_format = extract_output_format(output, key)\n                output_format.update(f)\n                return output_format\n            return f\n\n        def extract_formats(source_list):\n            if not isinstance(source_list, list):\n                return\n            for source in source_list:\n                video_url = source.get('file') or source.get('src')\n                if not video_url or not isinstance(video_url, compat_str):\n                    continue\n                if source.get('type') == 'application/x-mpegURL' or determine_ext(video_url) == 'm3u8':\n                    formats.extend(self._extract_m3u8_formats(\n                        video_url, video_id, 'mp4', entry_protocol='m3u8_native',\n                        m3u8_id='hls', fatal=False))\n                    continue\n                format_id = source.get('label')\n                f = {\n                    'url': video_url,\n                    'format_id': '%sp' % format_id,\n                    'height': int_or_none(format_id),\n                }\n                if format_id:\n                    # Some videos contain additional metadata (e.g.\n                    # https://www.udemy.com/ios9-swift/learn/#/lecture/3383208)\n                    f = add_output_format_meta(f, format_id)\n                formats.append(f)\n\n        def extract_subtitles(track_list):\n            if not isinstance(track_list, list):\n                return\n            for track in track_list:\n                if not isinstance(track, dict):\n                    continue\n                if track.get('kind') != 'captions':\n                    continue\n                src = track.get('src')\n                if not src or not isinstance(src, compat_str):\n                    continue\n                lang = track.get('language') or track.get(\n                    'srclang') or track.get('label')\n                sub_dict = automatic_captions if track.get(\n                    'autogenerated') is True else subtitles\n                sub_dict.setdefault(lang, []).append({\n                    'url': src,\n                })\n\n        download_urls = asset.get('download_urls')\n        if isinstance(download_urls, dict):\n            extract_formats(download_urls.get('Video'))\n\n        view_html = lecture.get('view_html')\n        if view_html:\n            view_html_urls = set()\n            for source in re.findall(r'<source[^>]+>', view_html):\n                attributes = extract_attributes(source)\n                src = attributes.get('src')\n                if not src:\n                    continue\n                res = attributes.get('data-res')\n                height = int_or_none(res)\n                if src in view_html_urls:\n                    continue\n                view_html_urls.add(src)\n                if attributes.get('type') == 'application/x-mpegURL' or determine_ext(src) == 'm3u8':\n                    m3u8_formats = self._extract_m3u8_formats(\n                        src, video_id, 'mp4', entry_protocol='m3u8_native',\n                        m3u8_id='hls', fatal=False)\n                    for f in m3u8_formats:\n                        m = re.search(r'/hls_(?P<height>\\d{3,4})_(?P<tbr>\\d{2,})/', f['url'])\n                        if m:\n                            if not f.get('height'):\n                                f['height'] = int(m.group('height'))\n                            if not f.get('tbr'):\n                                f['tbr'] = int(m.group('tbr'))\n                    formats.extend(m3u8_formats)\n                else:\n                    formats.append(add_output_format_meta({\n                        'url': src,\n                        'format_id': '%dp' % height if height else None,\n                        'height': height,\n                    }, res))\n\n            # react rendition since 2017.04.15 (see\n            # https://github.com/rg3/youtube-dl/issues/12744)\n            data = self._parse_json(\n                self._search_regex(\n                    r'videojs-setup-data=([\"\\'])(?P<data>{.+?})\\1', view_html,\n                    'setup data', default='{}', group='data'), video_id,\n                transform_source=unescapeHTML, fatal=False)\n            if data and isinstance(data, dict):\n                extract_formats(data.get('sources'))\n                if not duration:\n                    duration = int_or_none(data.get('duration'))\n                extract_subtitles(data.get('tracks'))\n\n            if not subtitles and not automatic_captions:\n                text_tracks = self._parse_json(\n                    self._search_regex(\n                        r'text-tracks=([\"\\'])(?P<data>\\[.+?\\])\\1', view_html,\n                        'text tracks', default='{}', group='data'), video_id,\n                    transform_source=lambda s: js_to_json(unescapeHTML(s)),\n                    fatal=False)\n                extract_subtitles(text_tracks)\n\n        self._sort_formats(formats, field_preference=('height', 'width', 'tbr', 'format_id'))\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'thumbnail': thumbnail,\n            'duration': duration,\n            'formats': formats,\n            'subtitles': subtitles,\n            'automatic_captions': automatic_captions,\n        }\n\n\nclass UdemyCourseIE(UdemyIE):\n    IE_NAME = 'udemy:course'\n    _VALID_URL = r'https?://(?:www\\.)?udemy\\.com/(?P<id>[^/?#&]+)'\n    _TESTS = []\n\n    @classmethod\n    def suitable(cls, url):\n        return False if UdemyIE.suitable(url) else super(UdemyCourseIE, cls).suitable(url)\n\n    def _real_extract(self, url):\n        course_path = self._match_id(url)\n\n        webpage = self._download_webpage(url, course_path)\n\n        course_id, title = self._extract_course_info(webpage, course_path)\n\n        self._enroll_course(url, webpage, course_id)\n\n        response = self._download_json(\n            'https://www.udemy.com/api-2.0/courses/%s/cached-subscriber-curriculum-items' % course_id,\n            course_id, 'Downloading course curriculum', query={\n                'fields[chapter]': 'title,object_index',\n                'fields[lecture]': 'title,asset',\n                'page_size': '1000',\n            })\n\n        entries = []\n        chapter, chapter_number = [None] * 2\n        for entry in response['results']:\n            clazz = entry.get('_class')\n            if clazz == 'lecture':\n                asset = entry.get('asset')\n                if isinstance(asset, dict):\n                    asset_type = asset.get('asset_type') or asset.get('assetType')\n                    if asset_type != 'Video':\n                        continue\n                lecture_id = entry.get('id')\n                if lecture_id:\n                    entry = {\n                        '_type': 'url_transparent',\n                        'url': 'https://www.udemy.com/%s/learn/v4/t/lecture/%s' % (course_path, entry['id']),\n                        'title': entry.get('title'),\n                        'ie_key': UdemyIE.ie_key(),\n                    }\n                    if chapter_number:\n                        entry['chapter_number'] = chapter_number\n                    if chapter:\n                        entry['chapter'] = chapter\n                    entries.append(entry)\n            elif clazz == 'chapter':\n                chapter_number = entry.get('object_index')\n                chapter = entry.get('title')\n\n        return self.playlist_result(entries, course_id, title)\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "udemy.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/udemy.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}