{"author": "pallets", "code": "\n.format(\n    cmd='export' if os.name == 'posix' else 'set',\n    prefix='$ ' if os.name == 'posix' else '> '\n))\n\n\ndef main(as_module=False):\n    args = sys.argv[1:]\n\n    if as_module:\n        this_module = 'flask'\n\n        if sys.version_info < (2, 7):\n            this_module += '.cli'\n\n        name = 'python -m ' + this_module\n\n        \n        \n        sys.argv = ['-m', this_module] + args\n    else:\n        name = None\n\n    cli.main(args=args, prog_name=name)\n\n\nif __name__ == '__main__':\n    main(as_module=True)\n", "comments": "\n    flask.cli\n    ~~~~~~~~~\n\n    A simple command line application to run flask apps.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom __future__ import print_function\n\nimport ast\nimport inspect\nimport os\nimport re\nimport ssl\nimport sys\nimport traceback\nfrom functools import update_wrapper\nfrom operator import attrgetter\nfrom threading import Lock, Thread\n\nimport click\nfrom werkzeug.utils import import_string\n\nfrom . import __version__\nfrom ._compat import getargspec, iteritems, reraise, text_type\nfrom .globals import current_app\nfrom .helpers import get_debug_flag, get_env\n\ntry:\n    import dotenv\nexcept ImportError:\n    dotenv = None\n\n\nclass NoAppException(click.UsageError):\n    \"\"\"Raised if an application cannot be found or loaded.\"\"\"\n\n\ndef find_best_app(script_info, module):\n    \"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"\n    from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in ('app', 'application'):\n        app = getattr(module, attr_name, None)\n\n        if isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [\n        v for k, v in iteritems(module.__dict__) if isinstance(v, Flask)\n    ]\n\n    if len(matches) == 1:\n        return matches[0]\n    elif len(matches) > 1:\n        raise NoAppException(\n            'Detected multiple Flask applications in module \"{module}\". Use '\n            '\"FLASK_APP={module}:name\" to specify the correct '\n            'one.'.format(module=module.__name__)\n        )\n\n    # Search for app factory functions.\n    for attr_name in ('create_app', 'make_app'):\n        app_factory = getattr(module, attr_name, None)\n\n        if inspect.isfunction(app_factory):\n            try:\n                app = call_factory(script_info, app_factory)\n\n                if isinstance(app, Flask):\n                    return app\n            except TypeError:\n                if not _called_with_wrong_args(app_factory):\n                    raise\n                raise NoAppException(\n                    'Detected factory \"{factory}\" in module \"{module}\", but '\n                    'could not call it without arguments. Use '\n                    '\"FLASK_APP=\\'{module}:{factory}(args)\\'\" to specify '\n                    'arguments.'.format(\n                        factory=attr_name, module=module.__name__\n                    )\n                )\n\n    raise NoAppException(\n        'Failed to find Flask application or factory in module \"{module}\". '\n        'Use \"FLASK_APP={module}:name to specify one.'.format(\n            module=module.__name__\n        )\n    )\n\n\ndef call_factory(script_info, app_factory, arguments=()):\n    \"\"\"Takes an app factory, a ``script_info` object and  optionally a tuple\n    of arguments. Checks for the existence of a script_info argument and calls\n    the app_factory depending on that and the arguments provided.\n    \"\"\"\n    args_spec = getargspec(app_factory)\n    arg_names = args_spec.args\n    arg_defaults = args_spec.defaults\n\n    if 'script_info' in arg_names:\n        return app_factory(*arguments, script_info=script_info)\n    elif arguments:\n        return app_factory(*arguments)\n    elif not arguments and len(arg_names) == 1 and arg_defaults is None:\n        return app_factory(script_info)\n\n    return app_factory()\n\n\ndef _called_with_wrong_args(factory):\n    \"\"\"Check whether calling a function raised a ``TypeError`` because\n    the call failed or because something in the factory raised the\n    error.\n\n    :param factory: the factory function that was called\n    :return: true if the call failed\n    \"\"\"\n    tb = sys.exc_info()[2]\n\n    try:\n        while tb is not None:\n            if tb.tb_frame.f_code is factory.__code__:\n                # in the factory, it was called successfully\n                return False\n\n            tb = tb.tb_next\n\n        # didn't reach the factory\n        return True\n    finally:\n        del tb\n\n\ndef find_app_by_string(script_info, module, app_name):\n    \"\"\"Checks if the given string is a variable name or a function. If it is a\n    function, it checks for specified arguments and whether it takes a\n    ``script_info`` argument and calls the function with the appropriate\n    arguments.\n    \"\"\"\n    from flask import Flask\n    match = re.match(r'^ *([^ ()]+) *(?:\\((.*?) *,? *\\))? *$', app_name)\n\n    if not match:\n        raise NoAppException(\n            '\"{name}\" is not a valid variable name or function '\n            'expression.'.format(name=app_name)\n        )\n\n    name, args = match.groups()\n\n    try:\n        attr = getattr(module, name)\n    except AttributeError as e:\n        raise NoAppException(e.args[0])\n\n    if inspect.isfunction(attr):\n        if args:\n            try:\n                args = ast.literal_eval('({args},)'.format(args=args))\n            except (ValueError, SyntaxError)as e:\n                raise NoAppException(\n                    'Could not parse the arguments in '\n                    '\"{app_name}\".'.format(e=e, app_name=app_name)\n                )\n        else:\n            args = ()\n\n        try:\n            app = call_factory(script_info, attr, args)\n        except TypeError as e:\n            if not _called_with_wrong_args(attr):\n                raise\n\n            raise NoAppException(\n                '{e}\\nThe factory \"{app_name}\" in module \"{module}\" could not '\n                'be called with the specified arguments.'.format(\n                    e=e, app_name=app_name, module=module.__name__\n                )\n            )\n    else:\n        app = attr\n\n    if isinstance(app, Flask):\n        return app\n\n    raise NoAppException(\n        'A valid Flask application was not obtained from '\n        '\"{module}:{app_name}\".'.format(\n            module=module.__name__, app_name=app_name\n        )\n    )\n\n\ndef prepare_import(path):\n    \"\"\"Given a filename this will try to calculate the python path, add it\n    to the search path and return the actual module name that is expected.\n    \"\"\"\n    path = os.path.realpath(path)\n\n    if os.path.splitext(path)[1] == '.py':\n        path = os.path.splitext(path)[0]\n\n    if os.path.basename(path) == '__init__':\n        path = os.path.dirname(path)\n\n    module_name = []\n\n    # move up until outside package structure (no __init__.py)\n    while True:\n        path, name = os.path.split(path)\n        module_name.append(name)\n\n        if not os.path.exists(os.path.join(path, '__init__.py')):\n            break\n\n    if sys.path[0] != path:\n        sys.path.insert(0, path)\n\n    return '.'.join(module_name[::-1])\n\n\ndef locate_app(script_info, module_name, app_name, raise_if_not_found=True):\n    __traceback_hide__ = True\n\n    try:\n        __import__(module_name)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[-1].tb_next:\n            raise NoAppException(\n                'While importing \"{name}\", an ImportError was raised:'\n                '\\n\\n{tb}'.format(name=module_name, tb=traceback.format_exc())\n            )\n        elif raise_if_not_found:\n            raise NoAppException(\n                'Could not import \"{name}\".\"'.format(name=module_name)\n            )\n        else:\n            return\n\n    module = sys.modules[module_name]\n\n    if app_name is None:\n        return find_best_app(script_info, module)\n    else:\n        return find_app_by_string(script_info, module, app_name)\n\n\ndef get_version(ctx, param, value):\n    if not value or ctx.resilient_parsing:\n        return\n    message = 'Flask %(version)s\\nPython %(python_version)s'\n    click.echo(message % {\n        'version': __version__,\n        'python_version': sys.version,\n    }, color=ctx.color)\n    ctx.exit()\n\n\nversion_option = click.Option(\n    ['--version'],\n    help='Show the flask version',\n    expose_value=False,\n    callback=get_version,\n    is_flag=True,\n    is_eager=True\n)\n\n\nclass DispatchingApp(object):\n    \"\"\"Special application that dispatches to a Flask application which\n    is imported by name in a background thread.  If an error happens\n    it is recorded and shown as part of the WSGI handling which in case\n    of the Werkzeug debugger means that it shows up in the browser.\n    \"\"\"\n\n    def __init__(self, loader, use_eager_loading=False):\n        self.loader = loader\n        self._app = None\n        self._lock = Lock()\n        self._bg_loading_exc_info = None\n        if use_eager_loading:\n            self._load_unlocked()\n        else:\n            self._load_in_background()\n\n    def _load_in_background(self):\n        def _load_app():\n            __traceback_hide__ = True\n            with self._lock:\n                try:\n                    self._load_unlocked()\n                except Exception:\n                    self._bg_loading_exc_info = sys.exc_info()\n        t = Thread(target=_load_app, args=())\n        t.start()\n\n    def _flush_bg_loading_exception(self):\n        __traceback_hide__ = True\n        exc_info = self._bg_loading_exc_info\n        if exc_info is not None:\n            self._bg_loading_exc_info = None\n            reraise(*exc_info)\n\n    def _load_unlocked(self):\n        __traceback_hide__ = True\n        self._app = rv = self.loader()\n        self._bg_loading_exc_info = None\n        return rv\n\n    def __call__(self, environ, start_response):\n        __traceback_hide__ = True\n        if self._app is not None:\n            return self._app(environ, start_response)\n        self._flush_bg_loading_exception()\n        with self._lock:\n            if self._app is not None:\n                rv = self._app\n            else:\n                rv = self._load_unlocked()\n            return rv(environ, start_response)\n\n\nclass ScriptInfo(object):\n    \"\"\"Help object to deal with Flask applications.  This is usually not\n    necessary to interface with as it's used internally in the dispatching\n    to click.  In future versions of Flask this object will most likely play\n    a bigger role.  Typically it's created automatically by the\n    :class:`FlaskGroup` but you can also manually create it and pass it\n    onwards as click object.\n    \"\"\"\n\n    def __init__(self, app_import_path=None, create_app=None):\n        #: Optionally the import path for the Flask application.\n        self.app_import_path = app_import_path or os.environ.get('FLASK_APP')\n        #: Optionally a function that is passed the script info to create\n        #: the instance of the application.\n        self.create_app = create_app\n        #: A dictionary with arbitrary data that can be associated with\n        #: this script info.\n        self.data = {}\n        self._loaded_app = None\n\n    def load_app(self):\n        \"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n        this multiple times will just result in the already loaded app to\n        be returned.\n        \"\"\"\n        __traceback_hide__ = True\n\n        if self._loaded_app is not None:\n            return self._loaded_app\n\n        app = None\n\n        if self.create_app is not None:\n            app = call_factory(self, self.create_app)\n        else:\n            if self.app_import_path:\n                path, name = (self.app_import_path.split(':', 1) + [None])[:2]\n                import_name = prepare_import(path)\n                app = locate_app(self, import_name, name)\n            else:\n                for path in ('wsgi.py', 'app.py'):\n                    import_name = prepare_import(path)\n                    app = locate_app(self, import_name, None,\n                                     raise_if_not_found=False)\n\n                    if app:\n                        break\n\n        if not app:\n            raise NoAppException(\n                'Could not locate a Flask application. You did not provide '\n                'the \"FLASK_APP\" environment variable, and a \"wsgi.py\" or '\n                '\"app.py\" module was not found in the current directory.'\n            )\n\n        debug = get_debug_flag()\n\n        # Update the app's debug flag through the descriptor so that other\n        # values repopulate as well.\n        if debug is not None:\n            app.debug = debug\n\n        self._loaded_app = app\n        return app\n\n\npass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)\n\n\ndef with_appcontext(f):\n    \"\"\"Wraps a callback so that it's guaranteed to be executed with the\n    script's application context.  If callbacks are registered directly\n    to the ``app.cli`` object then they are wrapped with this function\n    by default unless it's disabled.\n    \"\"\"\n    @click.pass_context\n    def decorator(__ctx, *args, **kwargs):\n        with __ctx.ensure_object(ScriptInfo).load_app().app_context():\n            return __ctx.invoke(f, *args, **kwargs)\n    return update_wrapper(decorator, f)\n\n\nclass AppGroup(click.Group):\n    \"\"\"This works similar to a regular click :class:`~click.Group` but it\n    changes the behavior of the :meth:`command` decorator so that it\n    automatically wraps the functions in :func:`with_appcontext`.\n\n    Not to be confused with :class:`FlaskGroup`.\n    \"\"\"\n\n    def command(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\n        unless it's disabled by passing ``with_appcontext=False``.\n        \"\"\"\n        wrap_for_ctx = kwargs.pop('with_appcontext', True)\n        def decorator(f):\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return click.Group.command(self, *args, **kwargs)(f)\n        return decorator\n\n    def group(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it defaults the group class to\n        :class:`AppGroup`.\n        \"\"\"\n        kwargs.setdefault('cls', AppGroup)\n        return click.Group.group(self, *args, **kwargs)\n\n\nclass FlaskGroup(AppGroup):\n    \"\"\"Special subclass of the :class:`AppGroup` group that supports\n    loading more commands from the configured Flask app.  Normally a\n    developer does not have to interface with this class but there are\n    some very advanced use cases for which it makes sense to create an\n    instance of this.\n\n    For information as of why this is useful see :ref:`custom-scripts`.\n\n    :param add_default_commands: if this is True then the default run and\n        shell commands wil be added.\n    :param add_version_option: adds the ``--version`` option.\n    :param create_app: an optional callback that is passed the script info and\n        returns the loaded app.\n    :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n        files to set environment variables. Will also change the working\n        directory to the directory containing the first file found.\n\n    .. versionchanged:: 1.0\n        If installed, python-dotenv will be used to load environment variables\n        from :file:`.env` and :file:`.flaskenv` files.\n    \"\"\"\n\n    def __init__(self, add_default_commands=True, create_app=None,\n                 add_version_option=True, load_dotenv=True, **extra):\n        params = list(extra.pop('params', None) or ())\n\n        if add_version_option:\n            params.append(version_option)\n\n        AppGroup.__init__(self, params=params, **extra)\n        self.create_app = create_app\n        self.load_dotenv = load_dotenv\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False\n\n    def _load_plugin_commands(self):\n        if self._loaded_plugin_commands:\n            return\n        try:\n            import pkg_resources\n        except ImportError:\n            self._loaded_plugin_commands = True\n            return\n\n        for ep in pkg_resources.iter_entry_points('flask.commands'):\n            self.add_command(ep.load(), ep.name)\n        self._loaded_plugin_commands = True\n\n    def get_command(self, ctx, name):\n        self._load_plugin_commands()\n\n        # We load built-in commands first as these should always be the\n        # same no matter what the app does.  If the app does want to\n        # override this it needs to make a custom instance of this group\n        # and not attach the default commands.\n        #\n        # This also means that the script stays functional in case the\n        # application completely fails.\n        rv = AppGroup.get_command(self, ctx, name)\n        if rv is not None:\n            return rv\n\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv = info.load_app().cli.get_command(ctx, name)\n            if rv is not None:\n                return rv\n        except NoAppException:\n            pass\n\n    def list_commands(self, ctx):\n        self._load_plugin_commands()\n\n        # The commands available is the list of both the application (if\n        # available) plus the builtin commands.\n        rv = set(click.Group.list_commands(self, ctx))\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv.update(info.load_app().cli.list_commands(ctx))\n        except Exception:\n            # Here we intentionally swallow all exceptions as we don't\n            # want the help page to break if the app does not exist.\n            # If someone attempts to use the command we try to create\n            # the app again and this will give us the error.\n            # However, we will not do so silently because that would confuse\n            # users.\n            traceback.print_exc()\n        return sorted(rv)\n\n    def main(self, *args, **kwargs):\n        # Set a global flag that indicates that we were invoked from the\n        # command line interface. This is detected by Flask.run to make the\n        # call into a no-op. This is necessary to avoid ugly errors when the\n        # script that is loaded here also attempts to start a server.\n        os.environ['FLASK_RUN_FROM_CLI'] = 'true'\n\n        if self.load_dotenv:\n            load_dotenv()\n\n        obj = kwargs.get('obj')\n\n        if obj is None:\n            obj = ScriptInfo(create_app=self.create_app)\n\n        kwargs['obj'] = obj\n        kwargs.setdefault('auto_envvar_prefix', 'FLASK')\n        return super(FlaskGroup, self).main(*args, **kwargs)\n\n\ndef _path_is_ancestor(path, other):\n    \"\"\"Take ``other`` and remove the length of ``path`` from it. Then join it\n    to ``path``. If it is the original value, ``path`` is an ancestor of\n    ``other``.\"\"\"\n    return os.path.join(path, other[len(path):].lstrip(os.sep)) == other\n\n\ndef load_dotenv(path=None):\n    \"\"\"Load \"dotenv\" files in order of precedence to set environment variables.\n\n    If an env var is already set it is not overwritten, so earlier files in the\n    list are preferred over later files.\n\n    Changes the current working directory to the location of the first file\n    found, with the assumption that it is in the top level project directory\n    and will be where the Python path should import local packages from.\n\n    This is a no-op if `python-dotenv`_ is not installed.\n\n    .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme\n\n    :param path: Load the file at this location instead of searching.\n    :return: ``True`` if a file was loaded.\n\n    .. versionadded:: 1.0\n    \"\"\"\n\n    if dotenv is None:\n        return\n\n    if path is not None:\n        return dotenv.load_dotenv(path)\n\n    new_dir = None\n\n    for name in ('.env', '.flaskenv'):\n        path = dotenv.find_dotenv(name, usecwd=True)\n\n        if not path:\n            continue\n\n        if new_dir is None:\n            new_dir = os.path.dirname(path)\n\n        dotenv.load_dotenv(path)\n\n    if new_dir and os.getcwd() != new_dir:\n        os.chdir(new_dir)\n\n    return new_dir is not None  # at least one file was located and loaded\n\n\ndef show_server_banner(env, debug, app_import_path):\n    \"\"\"Show extra startup messages the first time the server is run,\n    ignoring the reloader.\n    \"\"\"\n    if os.environ.get('WERKZEUG_RUN_MAIN') == 'true':\n        return\n\n    if app_import_path is not None:\n        print(' * Serving Flask app \"{0}\"'.format(app_import_path))\n\n    print(' * Environment: {0}'.format(env))\n\n    if env == 'production':\n        click.secho(\n            '   WARNING: Do not use the development server in a production'\n            ' environment.', fg='red')\n        click.secho('   Use a production WSGI server instead.', dim=True)\n\n    if debug is not None:\n        print(' * Debug mode: {0}'.format('on' if debug else 'off'))\n\n\nclass CertParamType(click.ParamType):\n    \"\"\"Click option type for the ``--cert`` option. Allows either an\n    existing file, the string ``'adhoc'``, or an import for a\n    :class:`~ssl.SSLContext` object.\n    \"\"\"\n\n    name = 'path'\n\n    def __init__(self):\n        self.path_type = click.Path(\n            exists=True, dir_okay=False, resolve_path=True)\n\n    def convert(self, value, param, ctx):\n        try:\n            return self.path_type(value, param, ctx)\n        except click.BadParameter:\n            value = click.STRING(value, param, ctx).lower()\n\n            if value == 'adhoc':\n                try:\n                    import OpenSSL\n                except ImportError:\n                    raise click.BadParameter(\n                        'Using ad-hoc certificates requires pyOpenSSL.',\n                        ctx, param)\n\n                return value\n\n            obj = import_string(value, silent=True)\n\n            if sys.version_info < (2, 7):\n                if obj:\n                    return obj\n            else:\n                if isinstance(obj, ssl.SSLContext):\n                    return obj\n\n            raise\n\n\ndef _validate_key(ctx, param, value):\n    \"\"\"The ``--key`` option must be specified when ``--cert`` is a file.\n    Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.\n    \"\"\"\n    cert = ctx.params.get('cert')\n    is_adhoc = cert == 'adhoc'\n\n    if sys.version_info < (2, 7):\n        is_context = cert and not isinstance(cert, (text_type, bytes))\n    else:\n        is_context = isinstance(cert, ssl.SSLContext)\n\n    if value is not None:\n        if is_adhoc:\n            raise click.BadParameter(\n                'When \"--cert\" is \"adhoc\", \"--key\" is not used.',\n                ctx, param)\n\n        if is_context:\n            raise click.BadParameter(\n                'When \"--cert\" is an SSLContext object, \"--key is not used.',\n                ctx, param)\n\n        if not cert:\n            raise click.BadParameter(\n                '\"--cert\" must also be specified.',\n                ctx, param)\n\n        ctx.params['cert'] = cert, value\n\n    else:\n        if cert and not (is_adhoc or is_context):\n            raise click.BadParameter(\n                'Required when using \"--cert\".',\n                ctx, param)\n\n    return value\n\n\n@click.command('run', short_help='Runs a development server.')\n@click.option('--host', '-h', default='127.0.0.1',\n              help='The interface to bind to.')\n@click.option('--port', '-p', default=5000,\n              help='The port to bind to.')\n@click.option('--cert', type=CertParamType(),\n              help='Specify a certificate file to use HTTPS.')\n@click.option('--key',\n              type=click.Path(exists=True, dir_okay=False, resolve_path=True),\n              callback=_validate_key, expose_value=False,\n              help='The key file to use when specifying a certificate.')\n@click.option('--reload/--no-reload', default=None,\n              help='Enable or disable the reloader. By default the reloader '\n              'is active if debug is enabled.')\n@click.option('--debugger/--no-debugger', default=None,\n              help='Enable or disable the debugger. By default the debugger '\n              'is active if debug is enabled.')\n@click.option('--eager-loading/--lazy-loader', default=None,\n              help='Enable or disable eager loading. By default eager '\n              'loading is enabled if the reloader is disabled.')\n@click.option('--with-threads/--without-threads', default=True,\n              help='Enable or disable multithreading.')\n@pass_script_info\ndef run_command(info, host, port, reload, debugger, eager_loading,\n                with_threads, cert):\n    \"\"\"Run a local development server.\n\n    This server is for development purposes only. It does not provide\n    the stability, security, or performance of production WSGI servers.\n\n    The reloader and debugger are enabled by default if\n    FLASK_ENV=development or FLASK_DEBUG=1.\n    \"\"\"\n    debug = get_debug_flag()\n\n    if reload is None:\n        reload = debug\n\n    if debugger is None:\n        debugger = debug\n\n    if eager_loading is None:\n        eager_loading = not reload\n\n    show_server_banner(get_env(), debug, info.app_import_path)\n    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)\n\n    from werkzeug.serving import run_simple\n    run_simple(host, port, app, use_reloader=reload, use_debugger=debugger,\n               threaded=with_threads, ssl_context=cert)\n\n\n@click.command('shell', short_help='Runs a shell in the app context.')\n@with_appcontext\ndef shell_command():\n    \"\"\"Runs an interactive Python shell in the context of a given\n    Flask application.  The application will populate the default\n    namespace of this shell according to it's configuration.\n\n    This is useful for executing small snippets of management code\n    without having to manually configure the application.\n    \"\"\"\n    import code\n    from flask.globals import _app_ctx_stack\n    app = _app_ctx_stack.top.app\n    banner = 'Python %s on %s\\nApp: %s [%s]\\nInstance: %s' % (\n        sys.version,\n        sys.platform,\n        app.import_name,\n        app.env,\n        app.instance_path,\n    )\n    ctx = {}\n\n    # Support the regular Python interpreter startup script if someone\n    # is using it.\n    startup = os.environ.get('PYTHONSTARTUP')\n    if startup and os.path.isfile(startup):\n        with open(startup, 'r') as f:\n            eval(compile(f.read(), startup, 'exec'), ctx)\n\n    ctx.update(app.make_shell_context())\n\n    code.interact(banner=banner, local=ctx)\n\n\n@click.command('routes', short_help='Show the routes for the app.')\n@click.option(\n    '--sort', '-s',\n    type=click.Choice(('endpoint', 'methods', 'rule', 'match')),\n    default='endpoint',\n    help=(\n        'Method to sort routes by. \"match\" is the order that Flask will match '\n        'routes when dispatching a request.'\n    )\n)\n@click.option(\n    '--all-methods',\n    is_flag=True,\n    help=\"Show HEAD and OPTIONS methods.\"\n)\n@with_appcontext\ndef routes_command(sort, all_methods):\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    ignored_methods = set(() if all_methods else ('HEAD', 'OPTIONS'))\n\n    if sort in ('endpoint', 'rule'):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == 'methods':\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))\n\n    rule_methods = [\n        ', '.join(sorted(rule.methods - ignored_methods)) for rule in rules\n    ]\n\n    headers = ('Endpoint', 'Methods', 'Rule')\n    widths = (\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = '{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}'.format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*('-' * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n\n\ncli = FlaskGroup(help=\"\"\"\\\nA general utility script for Flask applications.\n\nProvides commands from Flask, extensions, and the application. Loads the\napplication defined in the FLASK_APP environment variable, or from a wsgi.py\nfile. Setting the FLASK_ENV environment variable to 'development' will enable\ndebug mode.\n\n\\b\n  {prefix}{cmd} FLASK_APP=hello.py\n  {prefix}{cmd} FLASK_ENV=development\n  {prefix}flask run\n\n\n\n# -*- coding: utf-8 -*-\n# Python rewrites \"python -m flask\" to the path to the file in argv.\n# Restore the original command so that the reloader works.\n", "content": "# -*- coding: utf-8 -*-\n\"\"\"\n    flask.cli\n    ~~~~~~~~~\n\n    A simple command line application to run flask apps.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom __future__ import print_function\n\nimport ast\nimport inspect\nimport os\nimport re\nimport ssl\nimport sys\nimport traceback\nfrom functools import update_wrapper\nfrom operator import attrgetter\nfrom threading import Lock, Thread\n\nimport click\nfrom werkzeug.utils import import_string\n\nfrom . import __version__\nfrom ._compat import getargspec, iteritems, reraise, text_type\nfrom .globals import current_app\nfrom .helpers import get_debug_flag, get_env\n\ntry:\n    import dotenv\nexcept ImportError:\n    dotenv = None\n\n\nclass NoAppException(click.UsageError):\n    \"\"\"Raised if an application cannot be found or loaded.\"\"\"\n\n\ndef find_best_app(script_info, module):\n    \"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"\n    from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in ('app', 'application'):\n        app = getattr(module, attr_name, None)\n\n        if isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [\n        v for k, v in iteritems(module.__dict__) if isinstance(v, Flask)\n    ]\n\n    if len(matches) == 1:\n        return matches[0]\n    elif len(matches) > 1:\n        raise NoAppException(\n            'Detected multiple Flask applications in module \"{module}\". Use '\n            '\"FLASK_APP={module}:name\" to specify the correct '\n            'one.'.format(module=module.__name__)\n        )\n\n    # Search for app factory functions.\n    for attr_name in ('create_app', 'make_app'):\n        app_factory = getattr(module, attr_name, None)\n\n        if inspect.isfunction(app_factory):\n            try:\n                app = call_factory(script_info, app_factory)\n\n                if isinstance(app, Flask):\n                    return app\n            except TypeError:\n                if not _called_with_wrong_args(app_factory):\n                    raise\n                raise NoAppException(\n                    'Detected factory \"{factory}\" in module \"{module}\", but '\n                    'could not call it without arguments. Use '\n                    '\"FLASK_APP=\\'{module}:{factory}(args)\\'\" to specify '\n                    'arguments.'.format(\n                        factory=attr_name, module=module.__name__\n                    )\n                )\n\n    raise NoAppException(\n        'Failed to find Flask application or factory in module \"{module}\". '\n        'Use \"FLASK_APP={module}:name to specify one.'.format(\n            module=module.__name__\n        )\n    )\n\n\ndef call_factory(script_info, app_factory, arguments=()):\n    \"\"\"Takes an app factory, a ``script_info` object and  optionally a tuple\n    of arguments. Checks for the existence of a script_info argument and calls\n    the app_factory depending on that and the arguments provided.\n    \"\"\"\n    args_spec = getargspec(app_factory)\n    arg_names = args_spec.args\n    arg_defaults = args_spec.defaults\n\n    if 'script_info' in arg_names:\n        return app_factory(*arguments, script_info=script_info)\n    elif arguments:\n        return app_factory(*arguments)\n    elif not arguments and len(arg_names) == 1 and arg_defaults is None:\n        return app_factory(script_info)\n\n    return app_factory()\n\n\ndef _called_with_wrong_args(factory):\n    \"\"\"Check whether calling a function raised a ``TypeError`` because\n    the call failed or because something in the factory raised the\n    error.\n\n    :param factory: the factory function that was called\n    :return: true if the call failed\n    \"\"\"\n    tb = sys.exc_info()[2]\n\n    try:\n        while tb is not None:\n            if tb.tb_frame.f_code is factory.__code__:\n                # in the factory, it was called successfully\n                return False\n\n            tb = tb.tb_next\n\n        # didn't reach the factory\n        return True\n    finally:\n        del tb\n\n\ndef find_app_by_string(script_info, module, app_name):\n    \"\"\"Checks if the given string is a variable name or a function. If it is a\n    function, it checks for specified arguments and whether it takes a\n    ``script_info`` argument and calls the function with the appropriate\n    arguments.\n    \"\"\"\n    from flask import Flask\n    match = re.match(r'^ *([^ ()]+) *(?:\\((.*?) *,? *\\))? *$', app_name)\n\n    if not match:\n        raise NoAppException(\n            '\"{name}\" is not a valid variable name or function '\n            'expression.'.format(name=app_name)\n        )\n\n    name, args = match.groups()\n\n    try:\n        attr = getattr(module, name)\n    except AttributeError as e:\n        raise NoAppException(e.args[0])\n\n    if inspect.isfunction(attr):\n        if args:\n            try:\n                args = ast.literal_eval('({args},)'.format(args=args))\n            except (ValueError, SyntaxError)as e:\n                raise NoAppException(\n                    'Could not parse the arguments in '\n                    '\"{app_name}\".'.format(e=e, app_name=app_name)\n                )\n        else:\n            args = ()\n\n        try:\n            app = call_factory(script_info, attr, args)\n        except TypeError as e:\n            if not _called_with_wrong_args(attr):\n                raise\n\n            raise NoAppException(\n                '{e}\\nThe factory \"{app_name}\" in module \"{module}\" could not '\n                'be called with the specified arguments.'.format(\n                    e=e, app_name=app_name, module=module.__name__\n                )\n            )\n    else:\n        app = attr\n\n    if isinstance(app, Flask):\n        return app\n\n    raise NoAppException(\n        'A valid Flask application was not obtained from '\n        '\"{module}:{app_name}\".'.format(\n            module=module.__name__, app_name=app_name\n        )\n    )\n\n\ndef prepare_import(path):\n    \"\"\"Given a filename this will try to calculate the python path, add it\n    to the search path and return the actual module name that is expected.\n    \"\"\"\n    path = os.path.realpath(path)\n\n    if os.path.splitext(path)[1] == '.py':\n        path = os.path.splitext(path)[0]\n\n    if os.path.basename(path) == '__init__':\n        path = os.path.dirname(path)\n\n    module_name = []\n\n    # move up until outside package structure (no __init__.py)\n    while True:\n        path, name = os.path.split(path)\n        module_name.append(name)\n\n        if not os.path.exists(os.path.join(path, '__init__.py')):\n            break\n\n    if sys.path[0] != path:\n        sys.path.insert(0, path)\n\n    return '.'.join(module_name[::-1])\n\n\ndef locate_app(script_info, module_name, app_name, raise_if_not_found=True):\n    __traceback_hide__ = True\n\n    try:\n        __import__(module_name)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[-1].tb_next:\n            raise NoAppException(\n                'While importing \"{name}\", an ImportError was raised:'\n                '\\n\\n{tb}'.format(name=module_name, tb=traceback.format_exc())\n            )\n        elif raise_if_not_found:\n            raise NoAppException(\n                'Could not import \"{name}\".\"'.format(name=module_name)\n            )\n        else:\n            return\n\n    module = sys.modules[module_name]\n\n    if app_name is None:\n        return find_best_app(script_info, module)\n    else:\n        return find_app_by_string(script_info, module, app_name)\n\n\ndef get_version(ctx, param, value):\n    if not value or ctx.resilient_parsing:\n        return\n    message = 'Flask %(version)s\\nPython %(python_version)s'\n    click.echo(message % {\n        'version': __version__,\n        'python_version': sys.version,\n    }, color=ctx.color)\n    ctx.exit()\n\n\nversion_option = click.Option(\n    ['--version'],\n    help='Show the flask version',\n    expose_value=False,\n    callback=get_version,\n    is_flag=True,\n    is_eager=True\n)\n\n\nclass DispatchingApp(object):\n    \"\"\"Special application that dispatches to a Flask application which\n    is imported by name in a background thread.  If an error happens\n    it is recorded and shown as part of the WSGI handling which in case\n    of the Werkzeug debugger means that it shows up in the browser.\n    \"\"\"\n\n    def __init__(self, loader, use_eager_loading=False):\n        self.loader = loader\n        self._app = None\n        self._lock = Lock()\n        self._bg_loading_exc_info = None\n        if use_eager_loading:\n            self._load_unlocked()\n        else:\n            self._load_in_background()\n\n    def _load_in_background(self):\n        def _load_app():\n            __traceback_hide__ = True\n            with self._lock:\n                try:\n                    self._load_unlocked()\n                except Exception:\n                    self._bg_loading_exc_info = sys.exc_info()\n        t = Thread(target=_load_app, args=())\n        t.start()\n\n    def _flush_bg_loading_exception(self):\n        __traceback_hide__ = True\n        exc_info = self._bg_loading_exc_info\n        if exc_info is not None:\n            self._bg_loading_exc_info = None\n            reraise(*exc_info)\n\n    def _load_unlocked(self):\n        __traceback_hide__ = True\n        self._app = rv = self.loader()\n        self._bg_loading_exc_info = None\n        return rv\n\n    def __call__(self, environ, start_response):\n        __traceback_hide__ = True\n        if self._app is not None:\n            return self._app(environ, start_response)\n        self._flush_bg_loading_exception()\n        with self._lock:\n            if self._app is not None:\n                rv = self._app\n            else:\n                rv = self._load_unlocked()\n            return rv(environ, start_response)\n\n\nclass ScriptInfo(object):\n    \"\"\"Help object to deal with Flask applications.  This is usually not\n    necessary to interface with as it's used internally in the dispatching\n    to click.  In future versions of Flask this object will most likely play\n    a bigger role.  Typically it's created automatically by the\n    :class:`FlaskGroup` but you can also manually create it and pass it\n    onwards as click object.\n    \"\"\"\n\n    def __init__(self, app_import_path=None, create_app=None):\n        #: Optionally the import path for the Flask application.\n        self.app_import_path = app_import_path or os.environ.get('FLASK_APP')\n        #: Optionally a function that is passed the script info to create\n        #: the instance of the application.\n        self.create_app = create_app\n        #: A dictionary with arbitrary data that can be associated with\n        #: this script info.\n        self.data = {}\n        self._loaded_app = None\n\n    def load_app(self):\n        \"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n        this multiple times will just result in the already loaded app to\n        be returned.\n        \"\"\"\n        __traceback_hide__ = True\n\n        if self._loaded_app is not None:\n            return self._loaded_app\n\n        app = None\n\n        if self.create_app is not None:\n            app = call_factory(self, self.create_app)\n        else:\n            if self.app_import_path:\n                path, name = (self.app_import_path.split(':', 1) + [None])[:2]\n                import_name = prepare_import(path)\n                app = locate_app(self, import_name, name)\n            else:\n                for path in ('wsgi.py', 'app.py'):\n                    import_name = prepare_import(path)\n                    app = locate_app(self, import_name, None,\n                                     raise_if_not_found=False)\n\n                    if app:\n                        break\n\n        if not app:\n            raise NoAppException(\n                'Could not locate a Flask application. You did not provide '\n                'the \"FLASK_APP\" environment variable, and a \"wsgi.py\" or '\n                '\"app.py\" module was not found in the current directory.'\n            )\n\n        debug = get_debug_flag()\n\n        # Update the app's debug flag through the descriptor so that other\n        # values repopulate as well.\n        if debug is not None:\n            app.debug = debug\n\n        self._loaded_app = app\n        return app\n\n\npass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)\n\n\ndef with_appcontext(f):\n    \"\"\"Wraps a callback so that it's guaranteed to be executed with the\n    script's application context.  If callbacks are registered directly\n    to the ``app.cli`` object then they are wrapped with this function\n    by default unless it's disabled.\n    \"\"\"\n    @click.pass_context\n    def decorator(__ctx, *args, **kwargs):\n        with __ctx.ensure_object(ScriptInfo).load_app().app_context():\n            return __ctx.invoke(f, *args, **kwargs)\n    return update_wrapper(decorator, f)\n\n\nclass AppGroup(click.Group):\n    \"\"\"This works similar to a regular click :class:`~click.Group` but it\n    changes the behavior of the :meth:`command` decorator so that it\n    automatically wraps the functions in :func:`with_appcontext`.\n\n    Not to be confused with :class:`FlaskGroup`.\n    \"\"\"\n\n    def command(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\n        unless it's disabled by passing ``with_appcontext=False``.\n        \"\"\"\n        wrap_for_ctx = kwargs.pop('with_appcontext', True)\n        def decorator(f):\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return click.Group.command(self, *args, **kwargs)(f)\n        return decorator\n\n    def group(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it defaults the group class to\n        :class:`AppGroup`.\n        \"\"\"\n        kwargs.setdefault('cls', AppGroup)\n        return click.Group.group(self, *args, **kwargs)\n\n\nclass FlaskGroup(AppGroup):\n    \"\"\"Special subclass of the :class:`AppGroup` group that supports\n    loading more commands from the configured Flask app.  Normally a\n    developer does not have to interface with this class but there are\n    some very advanced use cases for which it makes sense to create an\n    instance of this.\n\n    For information as of why this is useful see :ref:`custom-scripts`.\n\n    :param add_default_commands: if this is True then the default run and\n        shell commands wil be added.\n    :param add_version_option: adds the ``--version`` option.\n    :param create_app: an optional callback that is passed the script info and\n        returns the loaded app.\n    :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n        files to set environment variables. Will also change the working\n        directory to the directory containing the first file found.\n\n    .. versionchanged:: 1.0\n        If installed, python-dotenv will be used to load environment variables\n        from :file:`.env` and :file:`.flaskenv` files.\n    \"\"\"\n\n    def __init__(self, add_default_commands=True, create_app=None,\n                 add_version_option=True, load_dotenv=True, **extra):\n        params = list(extra.pop('params', None) or ())\n\n        if add_version_option:\n            params.append(version_option)\n\n        AppGroup.__init__(self, params=params, **extra)\n        self.create_app = create_app\n        self.load_dotenv = load_dotenv\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False\n\n    def _load_plugin_commands(self):\n        if self._loaded_plugin_commands:\n            return\n        try:\n            import pkg_resources\n        except ImportError:\n            self._loaded_plugin_commands = True\n            return\n\n        for ep in pkg_resources.iter_entry_points('flask.commands'):\n            self.add_command(ep.load(), ep.name)\n        self._loaded_plugin_commands = True\n\n    def get_command(self, ctx, name):\n        self._load_plugin_commands()\n\n        # We load built-in commands first as these should always be the\n        # same no matter what the app does.  If the app does want to\n        # override this it needs to make a custom instance of this group\n        # and not attach the default commands.\n        #\n        # This also means that the script stays functional in case the\n        # application completely fails.\n        rv = AppGroup.get_command(self, ctx, name)\n        if rv is not None:\n            return rv\n\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv = info.load_app().cli.get_command(ctx, name)\n            if rv is not None:\n                return rv\n        except NoAppException:\n            pass\n\n    def list_commands(self, ctx):\n        self._load_plugin_commands()\n\n        # The commands available is the list of both the application (if\n        # available) plus the builtin commands.\n        rv = set(click.Group.list_commands(self, ctx))\n        info = ctx.ensure_object(ScriptInfo)\n        try:\n            rv.update(info.load_app().cli.list_commands(ctx))\n        except Exception:\n            # Here we intentionally swallow all exceptions as we don't\n            # want the help page to break if the app does not exist.\n            # If someone attempts to use the command we try to create\n            # the app again and this will give us the error.\n            # However, we will not do so silently because that would confuse\n            # users.\n            traceback.print_exc()\n        return sorted(rv)\n\n    def main(self, *args, **kwargs):\n        # Set a global flag that indicates that we were invoked from the\n        # command line interface. This is detected by Flask.run to make the\n        # call into a no-op. This is necessary to avoid ugly errors when the\n        # script that is loaded here also attempts to start a server.\n        os.environ['FLASK_RUN_FROM_CLI'] = 'true'\n\n        if self.load_dotenv:\n            load_dotenv()\n\n        obj = kwargs.get('obj')\n\n        if obj is None:\n            obj = ScriptInfo(create_app=self.create_app)\n\n        kwargs['obj'] = obj\n        kwargs.setdefault('auto_envvar_prefix', 'FLASK')\n        return super(FlaskGroup, self).main(*args, **kwargs)\n\n\ndef _path_is_ancestor(path, other):\n    \"\"\"Take ``other`` and remove the length of ``path`` from it. Then join it\n    to ``path``. If it is the original value, ``path`` is an ancestor of\n    ``other``.\"\"\"\n    return os.path.join(path, other[len(path):].lstrip(os.sep)) == other\n\n\ndef load_dotenv(path=None):\n    \"\"\"Load \"dotenv\" files in order of precedence to set environment variables.\n\n    If an env var is already set it is not overwritten, so earlier files in the\n    list are preferred over later files.\n\n    Changes the current working directory to the location of the first file\n    found, with the assumption that it is in the top level project directory\n    and will be where the Python path should import local packages from.\n\n    This is a no-op if `python-dotenv`_ is not installed.\n\n    .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme\n\n    :param path: Load the file at this location instead of searching.\n    :return: ``True`` if a file was loaded.\n\n    .. versionadded:: 1.0\n    \"\"\"\n\n    if dotenv is None:\n        return\n\n    if path is not None:\n        return dotenv.load_dotenv(path)\n\n    new_dir = None\n\n    for name in ('.env', '.flaskenv'):\n        path = dotenv.find_dotenv(name, usecwd=True)\n\n        if not path:\n            continue\n\n        if new_dir is None:\n            new_dir = os.path.dirname(path)\n\n        dotenv.load_dotenv(path)\n\n    if new_dir and os.getcwd() != new_dir:\n        os.chdir(new_dir)\n\n    return new_dir is not None  # at least one file was located and loaded\n\n\ndef show_server_banner(env, debug, app_import_path):\n    \"\"\"Show extra startup messages the first time the server is run,\n    ignoring the reloader.\n    \"\"\"\n    if os.environ.get('WERKZEUG_RUN_MAIN') == 'true':\n        return\n\n    if app_import_path is not None:\n        print(' * Serving Flask app \"{0}\"'.format(app_import_path))\n\n    print(' * Environment: {0}'.format(env))\n\n    if env == 'production':\n        click.secho(\n            '   WARNING: Do not use the development server in a production'\n            ' environment.', fg='red')\n        click.secho('   Use a production WSGI server instead.', dim=True)\n\n    if debug is not None:\n        print(' * Debug mode: {0}'.format('on' if debug else 'off'))\n\n\nclass CertParamType(click.ParamType):\n    \"\"\"Click option type for the ``--cert`` option. Allows either an\n    existing file, the string ``'adhoc'``, or an import for a\n    :class:`~ssl.SSLContext` object.\n    \"\"\"\n\n    name = 'path'\n\n    def __init__(self):\n        self.path_type = click.Path(\n            exists=True, dir_okay=False, resolve_path=True)\n\n    def convert(self, value, param, ctx):\n        try:\n            return self.path_type(value, param, ctx)\n        except click.BadParameter:\n            value = click.STRING(value, param, ctx).lower()\n\n            if value == 'adhoc':\n                try:\n                    import OpenSSL\n                except ImportError:\n                    raise click.BadParameter(\n                        'Using ad-hoc certificates requires pyOpenSSL.',\n                        ctx, param)\n\n                return value\n\n            obj = import_string(value, silent=True)\n\n            if sys.version_info < (2, 7):\n                if obj:\n                    return obj\n            else:\n                if isinstance(obj, ssl.SSLContext):\n                    return obj\n\n            raise\n\n\ndef _validate_key(ctx, param, value):\n    \"\"\"The ``--key`` option must be specified when ``--cert`` is a file.\n    Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.\n    \"\"\"\n    cert = ctx.params.get('cert')\n    is_adhoc = cert == 'adhoc'\n\n    if sys.version_info < (2, 7):\n        is_context = cert and not isinstance(cert, (text_type, bytes))\n    else:\n        is_context = isinstance(cert, ssl.SSLContext)\n\n    if value is not None:\n        if is_adhoc:\n            raise click.BadParameter(\n                'When \"--cert\" is \"adhoc\", \"--key\" is not used.',\n                ctx, param)\n\n        if is_context:\n            raise click.BadParameter(\n                'When \"--cert\" is an SSLContext object, \"--key is not used.',\n                ctx, param)\n\n        if not cert:\n            raise click.BadParameter(\n                '\"--cert\" must also be specified.',\n                ctx, param)\n\n        ctx.params['cert'] = cert, value\n\n    else:\n        if cert and not (is_adhoc or is_context):\n            raise click.BadParameter(\n                'Required when using \"--cert\".',\n                ctx, param)\n\n    return value\n\n\n@click.command('run', short_help='Runs a development server.')\n@click.option('--host', '-h', default='127.0.0.1',\n              help='The interface to bind to.')\n@click.option('--port', '-p', default=5000,\n              help='The port to bind to.')\n@click.option('--cert', type=CertParamType(),\n              help='Specify a certificate file to use HTTPS.')\n@click.option('--key',\n              type=click.Path(exists=True, dir_okay=False, resolve_path=True),\n              callback=_validate_key, expose_value=False,\n              help='The key file to use when specifying a certificate.')\n@click.option('--reload/--no-reload', default=None,\n              help='Enable or disable the reloader. By default the reloader '\n              'is active if debug is enabled.')\n@click.option('--debugger/--no-debugger', default=None,\n              help='Enable or disable the debugger. By default the debugger '\n              'is active if debug is enabled.')\n@click.option('--eager-loading/--lazy-loader', default=None,\n              help='Enable or disable eager loading. By default eager '\n              'loading is enabled if the reloader is disabled.')\n@click.option('--with-threads/--without-threads', default=True,\n              help='Enable or disable multithreading.')\n@pass_script_info\ndef run_command(info, host, port, reload, debugger, eager_loading,\n                with_threads, cert):\n    \"\"\"Run a local development server.\n\n    This server is for development purposes only. It does not provide\n    the stability, security, or performance of production WSGI servers.\n\n    The reloader and debugger are enabled by default if\n    FLASK_ENV=development or FLASK_DEBUG=1.\n    \"\"\"\n    debug = get_debug_flag()\n\n    if reload is None:\n        reload = debug\n\n    if debugger is None:\n        debugger = debug\n\n    if eager_loading is None:\n        eager_loading = not reload\n\n    show_server_banner(get_env(), debug, info.app_import_path)\n    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)\n\n    from werkzeug.serving import run_simple\n    run_simple(host, port, app, use_reloader=reload, use_debugger=debugger,\n               threaded=with_threads, ssl_context=cert)\n\n\n@click.command('shell', short_help='Runs a shell in the app context.')\n@with_appcontext\ndef shell_command():\n    \"\"\"Runs an interactive Python shell in the context of a given\n    Flask application.  The application will populate the default\n    namespace of this shell according to it's configuration.\n\n    This is useful for executing small snippets of management code\n    without having to manually configure the application.\n    \"\"\"\n    import code\n    from flask.globals import _app_ctx_stack\n    app = _app_ctx_stack.top.app\n    banner = 'Python %s on %s\\nApp: %s [%s]\\nInstance: %s' % (\n        sys.version,\n        sys.platform,\n        app.import_name,\n        app.env,\n        app.instance_path,\n    )\n    ctx = {}\n\n    # Support the regular Python interpreter startup script if someone\n    # is using it.\n    startup = os.environ.get('PYTHONSTARTUP')\n    if startup and os.path.isfile(startup):\n        with open(startup, 'r') as f:\n            eval(compile(f.read(), startup, 'exec'), ctx)\n\n    ctx.update(app.make_shell_context())\n\n    code.interact(banner=banner, local=ctx)\n\n\n@click.command('routes', short_help='Show the routes for the app.')\n@click.option(\n    '--sort', '-s',\n    type=click.Choice(('endpoint', 'methods', 'rule', 'match')),\n    default='endpoint',\n    help=(\n        'Method to sort routes by. \"match\" is the order that Flask will match '\n        'routes when dispatching a request.'\n    )\n)\n@click.option(\n    '--all-methods',\n    is_flag=True,\n    help=\"Show HEAD and OPTIONS methods.\"\n)\n@with_appcontext\ndef routes_command(sort, all_methods):\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    ignored_methods = set(() if all_methods else ('HEAD', 'OPTIONS'))\n\n    if sort in ('endpoint', 'rule'):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == 'methods':\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))\n\n    rule_methods = [\n        ', '.join(sorted(rule.methods - ignored_methods)) for rule in rules\n    ]\n\n    headers = ('Endpoint', 'Methods', 'Rule')\n    widths = (\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = '{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}'.format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*('-' * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n\n\ncli = FlaskGroup(help=\"\"\"\\\nA general utility script for Flask applications.\n\nProvides commands from Flask, extensions, and the application. Loads the\napplication defined in the FLASK_APP environment variable, or from a wsgi.py\nfile. Setting the FLASK_ENV environment variable to 'development' will enable\ndebug mode.\n\n\\b\n  {prefix}{cmd} FLASK_APP=hello.py\n  {prefix}{cmd} FLASK_ENV=development\n  {prefix}flask run\n\"\"\".format(\n    cmd='export' if os.name == 'posix' else 'set',\n    prefix='$ ' if os.name == 'posix' else '> '\n))\n\n\ndef main(as_module=False):\n    args = sys.argv[1:]\n\n    if as_module:\n        this_module = 'flask'\n\n        if sys.version_info < (2, 7):\n            this_module += '.cli'\n\n        name = 'python -m ' + this_module\n\n        # Python rewrites \"python -m flask\" to the path to the file in argv.\n        # Restore the original command so that the reloader works.\n        sys.argv = ['-m', this_module] + args\n    else:\n        name = None\n\n    cli.main(args=args, prog_name=name)\n\n\nif __name__ == '__main__':\n    main(as_module=True)\n", "description": "The Python micro framework for building web applications.", "file_name": "cli.py", "language": "Python", "project_name": "flask", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/pallets_flask/pallets-flask-a2ea186/flask/cli.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:52:03Z", "url": "https://github.com/pallets/flask", "wiki": false}