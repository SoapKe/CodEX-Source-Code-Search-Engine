{"author": "faif", "code": "\n# -*- coding: utf-8 -*-\n\n\"\"\"\n*What is this pattern about?\nThis pattern is used when creating an object is costly (and they are\ncreated frequently) but only a few are used at a time. With a Pool we\ncan manage those instances we have as of now by caching them. Now it\nis possible to skip the costly creation of an object if one is\navailable in the pool.\nA pool allows to 'check out' an inactive object and then to return it.\nIf none are available the pool creates one to provide without wait.\n\n*What does this example do?\nIn this example queue.Queue is used to create the pool (wrapped in a\ncustom ObjectPool object to use with the with statement), and it is\npopulated with strings.\nAs we can see, the first string object put in \"yam\" is USED by the\nwith statement. But because it is released back into the pool\naftwerwards it is reused by the explicit call to sample_queue.get().\nSame thing happens with \"sam\", when the ObjectPool created insided the\nfunction is deleted (by the GC) and the object is returned.\n\n*Where is the pattern used practically?\n\n*References:\nhttp://stackoverflow.com/questions/1514120/python-implementation-of-the-object-pool-design-pattern\nhttps://sourcemaking.com/design_patterns/object_pool\n\n*TL;DR80\nStores a set of initialized objects kept ready to use.\n\"\"\"\n\n\nclass ObjectPool(object):\n\n    def __init__(self, queue, auto_get=False):\n        self._queue = queue\n        self.item = self._queue.get() if auto_get else None\n\n    def __enter__(self):\n        if self.item is None:\n            self.item = self._queue.get()\n        return self.item\n\n    def __exit__(self, Type, value, traceback):\n        if self.item is not None:\n            self._queue.put(self.item)\n            self.item = None\n\n    def __del__(self):\n        if self.item is not None:\n            self._queue.put(self.item)\n            self.item = None\n\n\ndef main():\n    try:\n        import queue\n    except ImportError:  \n        import Queue as queue\n\n    def test_object(queue):\n        pool = ObjectPool(queue, True)\n        print('Inside func: {}'.format(pool.item))\n\n    sample_queue = queue.Queue()\n\n    sample_queue.put('yam')\n    with ObjectPool(sample_queue) as obj:\n        print('Inside with: {}'.format(obj))\n    print('Outside with: {}'.format(sample_queue.get()))\n\n    sample_queue.put('sam')\n    test_object(sample_queue)\n    print('Outside func: {}'.format(sample_queue.get()))\n\n    if not sample_queue.empty():\n        print(sample_queue.get())\n\n\nif __name__ == '__main__':\n    main()\n\n\n\n\n\n\n", "comments": "     what pattern  this pattern used creating object costly (and created frequently) used time  with pool manage instances caching  now possible skip costly creation object one available pool  a pool allows  check  inactive object return  if none available pool creates one provide without wait    what example  in example queue queue used create pool (wrapped custom objectpool object use statement)  populated strings  as see  first string object put  yam  used statement  but released back pool aftwerwards reused explicit call sample queue get()  same thing happens  sam   objectpool created insided function deleted (by gc) object returned    where pattern used practically    references  http   stackoverflow com questions 1514120 python implementation object pool design pattern https   sourcemaking com design patterns object pool   tl dr80 stores set initialized objects kept ready use          usr bin env python        coding  utf 8        python 2 x compatibility      output        inside  yam    outside  yam    inside func  sam    outside func  sam ", "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\n*What is this pattern about?\nThis pattern is used when creating an object is costly (and they are\ncreated frequently) but only a few are used at a time. With a Pool we\ncan manage those instances we have as of now by caching them. Now it\nis possible to skip the costly creation of an object if one is\navailable in the pool.\nA pool allows to 'check out' an inactive object and then to return it.\nIf none are available the pool creates one to provide without wait.\n\n*What does this example do?\nIn this example queue.Queue is used to create the pool (wrapped in a\ncustom ObjectPool object to use with the with statement), and it is\npopulated with strings.\nAs we can see, the first string object put in \"yam\" is USED by the\nwith statement. But because it is released back into the pool\naftwerwards it is reused by the explicit call to sample_queue.get().\nSame thing happens with \"sam\", when the ObjectPool created insided the\nfunction is deleted (by the GC) and the object is returned.\n\n*Where is the pattern used practically?\n\n*References:\nhttp://stackoverflow.com/questions/1514120/python-implementation-of-the-object-pool-design-pattern\nhttps://sourcemaking.com/design_patterns/object_pool\n\n*TL;DR80\nStores a set of initialized objects kept ready to use.\n\"\"\"\n\n\nclass ObjectPool(object):\n\n    def __init__(self, queue, auto_get=False):\n        self._queue = queue\n        self.item = self._queue.get() if auto_get else None\n\n    def __enter__(self):\n        if self.item is None:\n            self.item = self._queue.get()\n        return self.item\n\n    def __exit__(self, Type, value, traceback):\n        if self.item is not None:\n            self._queue.put(self.item)\n            self.item = None\n\n    def __del__(self):\n        if self.item is not None:\n            self._queue.put(self.item)\n            self.item = None\n\n\ndef main():\n    try:\n        import queue\n    except ImportError:  # python 2.x compatibility\n        import Queue as queue\n\n    def test_object(queue):\n        pool = ObjectPool(queue, True)\n        print('Inside func: {}'.format(pool.item))\n\n    sample_queue = queue.Queue()\n\n    sample_queue.put('yam')\n    with ObjectPool(sample_queue) as obj:\n        print('Inside with: {}'.format(obj))\n    print('Outside with: {}'.format(sample_queue.get()))\n\n    sample_queue.put('sam')\n    test_object(sample_queue)\n    print('Outside func: {}'.format(sample_queue.get()))\n\n    if not sample_queue.empty():\n        print(sample_queue.get())\n\n\nif __name__ == '__main__':\n    main()\n\n### OUTPUT ###\n# Inside with: yam\n# Outside with: yam\n# Inside func: sam\n# Outside func: sam\n", "description": "A collection of design patterns/idioms in Python", "file_name": "pool.py", "id": "552d2e75a11dd103d768600c0650baa9", "language": "Python", "project_name": "python-patterns", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/faif-python-patterns/faif-python-patterns-20bd570/creational/pool.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:52:50Z", "url": "https://github.com/faif/python-patterns", "wiki": true}