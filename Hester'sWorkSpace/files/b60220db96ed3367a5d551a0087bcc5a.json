{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\nimport time\nimport hashlib\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_urlparse,\n)\nfrom ..utils import (\n    clean_html,\n    ExtractorError,\n    int_or_none,\n    float_or_none,\n    parse_iso8601,\n    sanitized_Request,\n    urlencode_postdata,\n)\n\n\nclass NocoIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:(?:www\\.)?noco\\.tv/emission/|player\\.noco\\.tv/\\?idvideo=)(?P<id>\\d+)'\n    _LOGIN_URL = 'https://noco.tv/do.php'\n    _API_URL_TEMPLATE = 'https://api.noco.tv/1.1/%s?ts=%s&tk=%s'\n    _SUB_LANG_TEMPLATE = '&sub_lang=%s'\n    _NETRC_MACHINE = 'noco'\n\n    _TESTS = [\n        {\n            'url': 'http://noco.tv/emission/11538/nolife/ami-ami-idol-hello-france/',\n            'md5': '0a993f0058ddbcd902630b2047ef710e',\n            'info_dict': {\n                'id': '11538',\n                'ext': 'mp4',\n                'title': 'Ami Ami Idol - Hello! France',\n                'description': 'md5:4eaab46ab68fa4197a317a88a53d3b86',\n                'upload_date': '20140412',\n                'uploader': 'Nolife',\n                'uploader_id': 'NOL',\n                'duration': 2851.2,\n            },\n            'skip': 'Requires noco account',\n        },\n        {\n            'url': 'http://noco.tv/emission/12610/lbl42/the-guild/s01e01-wake-up-call',\n            'md5': 'c190f1f48e313c55838f1f412225934d',\n            'info_dict': {\n                'id': '12610',\n                'ext': 'mp4',\n                'title': 'The Guild \n                'timestamp': 1403863200,\n                'upload_date': '20140627',\n                'uploader': 'LBL42',\n                'uploader_id': 'LBL',\n                'duration': 233.023,\n            },\n            'skip': 'Requires noco account',\n        }\n    ]\n\n    def _real_initialize(self):\n        self._login()\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n\n        login = self._download_json(\n            self._LOGIN_URL, None, 'Logging in',\n            data=urlencode_postdata({\n                'a': 'login',\n                'cookie': '1',\n                'username': username,\n                'password': password,\n            }),\n            headers={\n                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\n            })\n\n        if 'erreur' in login:\n            raise ExtractorError('Unable to login: %s' % clean_html(login['erreur']), expected=True)\n\n    @staticmethod\n    def _ts():\n        return int(time.time() * 1000)\n\n    def _call_api(self, path, video_id, note, sub_lang=None):\n        ts = compat_str(self._ts() + self._ts_offset)\n        tk = hashlib.md5((hashlib.md5(ts.encode('ascii')).hexdigest() + '\n        url = self._API_URL_TEMPLATE % (path, ts, tk)\n        if sub_lang:\n            url += self._SUB_LANG_TEMPLATE % sub_lang\n\n        request = sanitized_Request(url)\n        request.add_header('Referer', self._referer)\n\n        resp = self._download_json(request, video_id, note)\n\n        if isinstance(resp, dict) and resp.get('error'):\n            self._raise_error(resp['error'], resp['description'])\n\n        return resp\n\n    def _raise_error(self, error, description):\n        raise ExtractorError(\n            '%s returned error: %s - %s' % (self.IE_NAME, error, description),\n            expected=True)\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        \n        \n        \n        webpage = self._download_webpage(url, video_id)\n\n        player_url = self._search_regex(\n            r'([\"\\'])(?P<player>https?://noco\\.tv/(?:[^/]+/)+NocoPlayer.+?\\.swf.*?)\\1',\n            webpage, 'noco player', group='player',\n            default='http://noco.tv/cdata/js/player/NocoPlayer-v1.2.40.swf')\n\n        qs = compat_urlparse.parse_qs(compat_urlparse.urlparse(player_url).query)\n        ts = int_or_none(qs.get('ts', [None])[0])\n        self._ts_offset = ts - self._ts() if ts else 0\n        self._referer = player_url\n\n        medias = self._call_api(\n            'shows/%s/medias' % video_id,\n            video_id, 'Downloading video JSON')\n\n        show = self._call_api(\n            'shows/by_id/%s' % video_id,\n            video_id, 'Downloading show JSON')[0]\n\n        options = self._call_api(\n            'users/init', video_id,\n            'Downloading user options JSON')['options']\n        audio_lang_pref = options.get('audio_language') or options.get('language', 'fr')\n\n        if audio_lang_pref == 'original':\n            audio_lang_pref = show['original_lang']\n        if len(medias) == 1:\n            audio_lang_pref = list(medias.keys())[0]\n        elif audio_lang_pref not in medias:\n            audio_lang_pref = 'fr'\n\n        qualities = self._call_api(\n            'qualities',\n            video_id, 'Downloading qualities JSON')\n\n        formats = []\n\n        for audio_lang, audio_lang_dict in medias.items():\n            preference = 1 if audio_lang == audio_lang_pref else 0\n            for sub_lang, lang_dict in audio_lang_dict['video_list'].items():\n                for format_id, fmt in lang_dict['quality_list'].items():\n                    format_id_extended = 'audio-%s_sub-%s_%s' % (audio_lang, sub_lang, format_id)\n\n                    video = self._call_api(\n                        'shows/%s/video/%s/%s' % (video_id, format_id.lower(), audio_lang),\n                        video_id, 'Downloading %s video JSON' % format_id_extended,\n                        sub_lang if sub_lang != 'none' else None)\n\n                    file_url = video['file']\n                    if not file_url:\n                        continue\n\n                    if file_url in ['forbidden', 'not found']:\n                        popmessage = video['popmessage']\n                        self._raise_error(popmessage['title'], popmessage['message'])\n\n                    formats.append({\n                        'url': file_url,\n                        'format_id': format_id_extended,\n                        'width': int_or_none(fmt.get('res_width')),\n                        'height': int_or_none(fmt.get('res_lines')),\n                        'abr': int_or_none(fmt.get('audiobitrate'), 1000),\n                        'vbr': int_or_none(fmt.get('videobitrate'), 1000),\n                        'filesize': int_or_none(fmt.get('filesize')),\n                        'format_note': qualities[format_id].get('quality_name'),\n                        'quality': qualities[format_id].get('priority'),\n                        'preference': preference,\n                    })\n\n        self._sort_formats(formats)\n\n        timestamp = parse_iso8601(show.get('online_date_start_utc'), ' ')\n\n        if timestamp is not None and timestamp < 0:\n            timestamp = None\n\n        uploader = show.get('partner_name')\n        uploader_id = show.get('partner_key')\n        duration = float_or_none(show.get('duration_ms'), 1000)\n\n        thumbnails = []\n        for thumbnail_key, thumbnail_url in show.items():\n            m = re.search(r'^screenshot_(?P<width>\\d+)x(?P<height>\\d+)$', thumbnail_key)\n            if not m:\n                continue\n            thumbnails.append({\n                'url': thumbnail_url,\n                'width': int(m.group('width')),\n                'height': int(m.group('height')),\n            })\n\n        episode = show.get('show_TT') or show.get('show_OT')\n        family = show.get('family_TT') or show.get('family_OT')\n        episode_number = show.get('episode_number')\n\n        title = ''\n        if family:\n            title += family\n        if episode_number:\n            title += ' \n        if episode:\n            title += ' - ' + compat_str(episode)\n\n        description = show.get('show_resume') or show.get('family_resume')\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'thumbnails': thumbnails,\n            'timestamp': timestamp,\n            'uploader': uploader,\n            'uploader_id': uploader_id,\n            'duration': duration,\n            'formats': formats,\n        }\n", "comments": "# coding: utf-8\n#1 - Wake-Up Call',\n#8S?uCraTedap6a').encode('ascii')).hexdigest()\n# Timestamp adjustment offset between server time and local time\n# must be calculated in order to use timestamps closest to server's\n# in all API requests (see https://github.com/rg3/youtube-dl/issues/7864)\n#' + compat_str(episode_number)\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\nimport time\nimport hashlib\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_urlparse,\n)\nfrom ..utils import (\n    clean_html,\n    ExtractorError,\n    int_or_none,\n    float_or_none,\n    parse_iso8601,\n    sanitized_Request,\n    urlencode_postdata,\n)\n\n\nclass NocoIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:(?:www\\.)?noco\\.tv/emission/|player\\.noco\\.tv/\\?idvideo=)(?P<id>\\d+)'\n    _LOGIN_URL = 'https://noco.tv/do.php'\n    _API_URL_TEMPLATE = 'https://api.noco.tv/1.1/%s?ts=%s&tk=%s'\n    _SUB_LANG_TEMPLATE = '&sub_lang=%s'\n    _NETRC_MACHINE = 'noco'\n\n    _TESTS = [\n        {\n            'url': 'http://noco.tv/emission/11538/nolife/ami-ami-idol-hello-france/',\n            'md5': '0a993f0058ddbcd902630b2047ef710e',\n            'info_dict': {\n                'id': '11538',\n                'ext': 'mp4',\n                'title': 'Ami Ami Idol - Hello! France',\n                'description': 'md5:4eaab46ab68fa4197a317a88a53d3b86',\n                'upload_date': '20140412',\n                'uploader': 'Nolife',\n                'uploader_id': 'NOL',\n                'duration': 2851.2,\n            },\n            'skip': 'Requires noco account',\n        },\n        {\n            'url': 'http://noco.tv/emission/12610/lbl42/the-guild/s01e01-wake-up-call',\n            'md5': 'c190f1f48e313c55838f1f412225934d',\n            'info_dict': {\n                'id': '12610',\n                'ext': 'mp4',\n                'title': 'The Guild #1 - Wake-Up Call',\n                'timestamp': 1403863200,\n                'upload_date': '20140627',\n                'uploader': 'LBL42',\n                'uploader_id': 'LBL',\n                'duration': 233.023,\n            },\n            'skip': 'Requires noco account',\n        }\n    ]\n\n    def _real_initialize(self):\n        self._login()\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n\n        login = self._download_json(\n            self._LOGIN_URL, None, 'Logging in',\n            data=urlencode_postdata({\n                'a': 'login',\n                'cookie': '1',\n                'username': username,\n                'password': password,\n            }),\n            headers={\n                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\n            })\n\n        if 'erreur' in login:\n            raise ExtractorError('Unable to login: %s' % clean_html(login['erreur']), expected=True)\n\n    @staticmethod\n    def _ts():\n        return int(time.time() * 1000)\n\n    def _call_api(self, path, video_id, note, sub_lang=None):\n        ts = compat_str(self._ts() + self._ts_offset)\n        tk = hashlib.md5((hashlib.md5(ts.encode('ascii')).hexdigest() + '#8S?uCraTedap6a').encode('ascii')).hexdigest()\n        url = self._API_URL_TEMPLATE % (path, ts, tk)\n        if sub_lang:\n            url += self._SUB_LANG_TEMPLATE % sub_lang\n\n        request = sanitized_Request(url)\n        request.add_header('Referer', self._referer)\n\n        resp = self._download_json(request, video_id, note)\n\n        if isinstance(resp, dict) and resp.get('error'):\n            self._raise_error(resp['error'], resp['description'])\n\n        return resp\n\n    def _raise_error(self, error, description):\n        raise ExtractorError(\n            '%s returned error: %s - %s' % (self.IE_NAME, error, description),\n            expected=True)\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        # Timestamp adjustment offset between server time and local time\n        # must be calculated in order to use timestamps closest to server's\n        # in all API requests (see https://github.com/rg3/youtube-dl/issues/7864)\n        webpage = self._download_webpage(url, video_id)\n\n        player_url = self._search_regex(\n            r'([\"\\'])(?P<player>https?://noco\\.tv/(?:[^/]+/)+NocoPlayer.+?\\.swf.*?)\\1',\n            webpage, 'noco player', group='player',\n            default='http://noco.tv/cdata/js/player/NocoPlayer-v1.2.40.swf')\n\n        qs = compat_urlparse.parse_qs(compat_urlparse.urlparse(player_url).query)\n        ts = int_or_none(qs.get('ts', [None])[0])\n        self._ts_offset = ts - self._ts() if ts else 0\n        self._referer = player_url\n\n        medias = self._call_api(\n            'shows/%s/medias' % video_id,\n            video_id, 'Downloading video JSON')\n\n        show = self._call_api(\n            'shows/by_id/%s' % video_id,\n            video_id, 'Downloading show JSON')[0]\n\n        options = self._call_api(\n            'users/init', video_id,\n            'Downloading user options JSON')['options']\n        audio_lang_pref = options.get('audio_language') or options.get('language', 'fr')\n\n        if audio_lang_pref == 'original':\n            audio_lang_pref = show['original_lang']\n        if len(medias) == 1:\n            audio_lang_pref = list(medias.keys())[0]\n        elif audio_lang_pref not in medias:\n            audio_lang_pref = 'fr'\n\n        qualities = self._call_api(\n            'qualities',\n            video_id, 'Downloading qualities JSON')\n\n        formats = []\n\n        for audio_lang, audio_lang_dict in medias.items():\n            preference = 1 if audio_lang == audio_lang_pref else 0\n            for sub_lang, lang_dict in audio_lang_dict['video_list'].items():\n                for format_id, fmt in lang_dict['quality_list'].items():\n                    format_id_extended = 'audio-%s_sub-%s_%s' % (audio_lang, sub_lang, format_id)\n\n                    video = self._call_api(\n                        'shows/%s/video/%s/%s' % (video_id, format_id.lower(), audio_lang),\n                        video_id, 'Downloading %s video JSON' % format_id_extended,\n                        sub_lang if sub_lang != 'none' else None)\n\n                    file_url = video['file']\n                    if not file_url:\n                        continue\n\n                    if file_url in ['forbidden', 'not found']:\n                        popmessage = video['popmessage']\n                        self._raise_error(popmessage['title'], popmessage['message'])\n\n                    formats.append({\n                        'url': file_url,\n                        'format_id': format_id_extended,\n                        'width': int_or_none(fmt.get('res_width')),\n                        'height': int_or_none(fmt.get('res_lines')),\n                        'abr': int_or_none(fmt.get('audiobitrate'), 1000),\n                        'vbr': int_or_none(fmt.get('videobitrate'), 1000),\n                        'filesize': int_or_none(fmt.get('filesize')),\n                        'format_note': qualities[format_id].get('quality_name'),\n                        'quality': qualities[format_id].get('priority'),\n                        'preference': preference,\n                    })\n\n        self._sort_formats(formats)\n\n        timestamp = parse_iso8601(show.get('online_date_start_utc'), ' ')\n\n        if timestamp is not None and timestamp < 0:\n            timestamp = None\n\n        uploader = show.get('partner_name')\n        uploader_id = show.get('partner_key')\n        duration = float_or_none(show.get('duration_ms'), 1000)\n\n        thumbnails = []\n        for thumbnail_key, thumbnail_url in show.items():\n            m = re.search(r'^screenshot_(?P<width>\\d+)x(?P<height>\\d+)$', thumbnail_key)\n            if not m:\n                continue\n            thumbnails.append({\n                'url': thumbnail_url,\n                'width': int(m.group('width')),\n                'height': int(m.group('height')),\n            })\n\n        episode = show.get('show_TT') or show.get('show_OT')\n        family = show.get('family_TT') or show.get('family_OT')\n        episode_number = show.get('episode_number')\n\n        title = ''\n        if family:\n            title += family\n        if episode_number:\n            title += ' #' + compat_str(episode_number)\n        if episode:\n            title += ' - ' + compat_str(episode)\n\n        description = show.get('show_resume') or show.get('family_resume')\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'thumbnails': thumbnails,\n            'timestamp': timestamp,\n            'uploader': uploader,\n            'uploader_id': uploader_id,\n            'duration': duration,\n            'formats': formats,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "noco.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/noco.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}