{"author": "HelloZeroNet", "code": "\n\n# Modified: random number generator in def GeneratePrivateKey(self):\n\nimport random\nimport hashlib\nimport os\n\nclass GaussInt:\n    #A class for the Gauss integers of the form a + b sqrt(n) where a,b are integers.\n    \n    def __init__(self,x,y,n,p=0):\n        if p:\n            self.x=x%p\n            self.y=y%p\n            self.n=n%p\n        else:\n            self.x=x\n            self.y=y\n            self.n=n\n\n        self.p=p\n        \n    def __add__(self,b):\n        return GaussInt(self.x+b.x,self.y+b.y,self.n,self.p)\n        \n    def __sub__(self,b):\n        return GaussInt(self.x-b.x,self.y-b.y,self.n,self.p)\n    \n    def __mul__(self,b):\n        return GaussInt(self.x*b.x+self.n*self.y*b.y,self.x*b.y+self.y*b.x,self.n,self.p)\n    \n    def __div__(self,b):\n        return GaussInt((self.x*b.x-self.n*self.y*b.y)/(b.x*b.x-self.n*b.y*b.y),(-self.x*b.y+self.y*b.x)/(b.x*b.x-self.n*b.y*b.y),self.n,self.p)\n    \n    def __eq__(self,b):\n        return self.x==b.x and self.y==b.y\n    \n    def __repr__(self):\n        if self.p:\n            return \"%s+%s (%d,%d)\"%(self.x,self.y,self.n,self.p)\n        else:\n            return \"%s+%s (%d)\"%(self.x,self.y,self.n)\n        \n    def __pow__(self,n):\n        b=Base(n,2)\n        t=GaussInt(1,0,self.n)\n        while b:\n            t=t*t\n            if b.pop():\n                t=self*t\n            \n        return t\n\n    def Inv(self):\n        return GaussInt(self.x/(self.x*self.x-self.n*self.y*self.y),-self.y/(self.x*self.x-self.n*self.y*self.y),self.n,self.p)\n\ndef Cipolla(a,p):\n    \n    b=0\n    while pow((b*b-a)%p,(p-1)/2,p)==1:\n        b+=1\n\n    return (GaussInt(b,1,b**2-a,p)**((p+1)/2)).x\n    \ndef Base(n,b):\n    \n    l=[]\n    while n:\n        l.append(n%b)\n        n/=b\n\n    return l\n    \ndef InvMod(a,n):\n    \n    \n    m=[]\n\n    s=n\n    while n:\n        m.append(a/n)\n        (a,n)=(n,a%n)\n\n    u=1\n    v=0\n    while m:\n        (u,v)=(v,u-m.pop()*v)\n\n    return u%s\n\ndef b58encode(v):\n    \n    digit=\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n    base=len(digit)\n    val=0    \n    for c in v:\n        val*=256\n        val+=ord(c)\n\n    result=\"\"\n    while val:\n        (val,mod)=divmod(val,base)\n        result=digit[mod]+result\n\n    pad=0\n    for c in v:\n        if c==\"\\0\":\n            pad+=1\n        else:\n            break\n\n    return (digit[0]*pad)+result\n\ndef b58decode(v):\n    \n    digit=\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n    base=len(digit)\n    val=0    \n    for c in v:\n        val*=base\n        val+=digit.find(c)\n\n    result=\"\"\n    while val:\n        (val,mod)=divmod(val,256)\n        result=chr(mod)+result\n\n    pad=0\n    for c in v:\n        if c==digit[0]:\n            pad+=1\n        else:\n            break\n\n    result=\"\\0\"*pad+result\n\n    return result\n\ndef Byte2Hex(b):\n    \n    out=\"\"\n    for x in b:\n        y=hex(ord(x))[2:]\n        if len(y)==1:\n            y=\"0\"+y\n        out+=\"%2s\"%y\n    \n    return out\n\ndef Int2Byte(n,b):\n    \n    out=\"\"\n    \n    for i in range(b):\n        (n,m)=divmod(n,256)\n        out=chr(m)+out\n    \n    return out\n\nclass EllipticCurvePoint:\n    \n    \n    \n    def __init__(self,x,a,b,p,n=0):\n        \n        \n        self.x=x[:]\n        self.a=a\n        self.b=b\n        self.p=p\n        self.n=n\n\n    def EqualProj(self,y):\n        ?\n        \n        return self.x[0]*y.x[1]==self.x[1]*y.x[0] and self.x[1]*y.x[2]==self.x[2]*y.x[1] and self.x[2]*y.x[0]==self.x[0]*y.x[2]\n\n    def __add__(self,y):\n        \n        \n        #Projectives coordinates are more performant than the usual (x,y) coordinates\n        \n        z=EllipticCurvePoint([0,0,0],self.a,self.b,self.p)\n\n        if self.EqualProj(y):\n            d=(2*self.x[1]*self.x[2])%self.p\n            d3=pow(d,3,self.p)\n            n=(3*pow(self.x[0],2,self.p)+self.a*pow(self.x[2],2,self.p))%self.p\n            \n            z.x[0]=(pow(n,2,self.p)*d*self.x[2]-2*d3*self.x[0])%self.p\n            z.x[1]=(3*self.x[0]*n*pow(d,2,self.p)-pow(n,3,self.p)*self.x[2]-self.x[1]*d3)%self.p\n            z.x[2]=(self.x[2]*d3)%self.p\n        else:\n            d=(y.x[0]*self.x[2]-y.x[2]*self.x[0])%self.p\n            d3=pow(d,3,self.p)\n            n=(y.x[1]*self.x[2]-self.x[1]*y.x[2])%self.p\n\n            z.x[0]=(y.x[2]*self.x[2]*pow(n,2,self.p)*d-d3*(y.x[2]*self.x[0]+y.x[0]*self.x[2]))%self.p\n            z.x[1]=(pow(d,2,self.p)*n*(2*self.x[0]*y.x[2]+y.x[0]*self.x[2])-pow(n,3,self.p)*self.x[2]*y.x[2]-self.x[1]*d3*y.x[2])%self.p\n            z.x[2]=(self.x[2]*d3*y.x[2])%self.p\n        \n        return z\n\n    def __mul__(self,n):\n        \n        b=Base(n,2)\n        t=EllipticCurvePoint(self.x,self.a,self.b,self.p)\n        b.pop()\n        while b:\n            t+=t\n            if b.pop():\n                t+=self\n                \n        return t\n\n    def __repr__(self):\n        #print a point in (x,y) coordinate.\n        return \"x=%d\\ny=%d\\n\"%((self.x[0]*InvMod(self.x[2],self.p))%self.p,(self.x[1]*InvMod(self.x[2],self.p))%self.p)\n    \n    def __eq__(self,x):\n        ?\n        return self.x==x.x and self.a==x.a and self.b==x.b and self.p==x.p\n    \n    def __ne__(self,x):\n        ?\n        return self.x!=x.x or self.a!=x.a or self.b!=x.b or self.p!=x.p\n    \n    def Check(self):\n        ?\n        return (self.x[0]**3+self.a*self.x[0]*self.x[2]**2+self.b*self.x[2]**3-self.x[1]**2*self.x[2])%self.p==0\n\n    def GeneratePrivateKey(self):\n        \n        \n        \n        #self.d = random.randint(1,self.n-1)\n        self.d = random.SystemRandom().randint(1,self.n-1) \n    \n    def SignECDSA(self,m):\n        \n        h=hashlib.new(\"SHA256\")\n        h.update(m)\n        z=int(h.hexdigest(),16)\n        \n        r=0\n        s=0\n        while not r or not s:\n            #k=random.randint(1,self.n-1)\n            k=random.SystemRandom().randint(1,self.n-1) \n            R=self*k\n            R.Normalize()\n            r=R.x[0]%self.n\n            s=(InvMod(k,self.n)*(z+r*self.d))%self.n\n\n        return (r,s)\n        \n    def CheckECDSA(self,sig,m):\n        #Check a signature (r,s) of the message m using the public key self.Q\n        \n        \n        \n        (r,s)=sig        \n        \n        h=hashlib.new(\"SHA256\")\n        h.update(m)\n        z=int(h.hexdigest(),16)\n        \n        if self.Q.x[2]==0:\n            return False\n        if not self.Q.Check():\n            return False\n        if (self.Q*self.n).x[2]!=0:\n            return False\n        if r<1 or r>self.n-1 or s<1 or s>self.n-1:\n            return False\n\n        w=InvMod(s,self.n)\n        u1=(z*w)%self.n\n        u2=(r*w)%self.n\n        R=self*u1+self.Q*u2\n        R.Normalize()\n\n        return (R.x[0]-r)%self.n==0\n\n    def VerifyMessageFromBitcoinAddress(self,adresse,m,sig):\n        #Check a signature (r,s) for the message m signed by the Bitcoin \n        \n        h=hashlib.new(\"SHA256\")\n        h.update(m)\n        z=int(h.hexdigest(),16)\n        \n        (r,s)=sig\n        x=r\n        y2=(pow(x,3,self.p)+self.a*x+self.b)%self.p\n        y=Cipolla(y2,self.p)\n\n        for i in range(2):\n            kG=EllipticCurvePoint([x,y,1],self.a,self.b,self.p,self.n)  \n            mzG=self*((-z)%self.n)\n            self.Q=(kG*s+mzG)*InvMod(r,self.n)\n\n            adr=self.BitcoinAddresFromPublicKey()\n            if adr==adresse:\n                break\n            y=(-y)%self.p\n\n        if adr!=adresse:\n            return False\n\n        return True\n\n    def BitcoinAddressFromPrivate(self,pri=None):\n        \n        \n        if not pri:\n            print \"Private Key :\",\n            pri=raw_input()\n\n        normal=(len(pri)==51)\n        pri=b58decode(pri)\n        \n        if normal:\n            pri=pri[1:-4]\n        else:\n            pri=pri[1:-5]\n        \n        self.d=int(Byte2Hex(pri),16)\n        \n        return self.BitcoinAddress(normal)\n\n    def PrivateEncoding(self,normal=True):\n        \n        p=Int2Byte(self.d,32)\n        p=\"\\80\"+p\n        \n        if not normal:\n            p+=chr(1)\n\n        h=hashlib.new(\"SHA256\")\n        h.update(p)\n        s=h.digest()\n        \n        h=hashlib.new(\"SHA256\")\n        h.update(s)\n        s=h.digest()\n        \n        cs=s[:4]\n\n        p+=cs\n        p=b58encode(p)\n\n        return p\n\n    def BitcoinAddresFromPublicKey(self,normal=True):\n        \n        \n        # (x,y) coordinates.\n        self.Q.Normalize()\n        if normal:\n            pk=chr(4)+Int2Byte(self.Q.x[0],32)+Int2Byte((self.Q.x[1])%self.p,32)\n        else:\n            if self.Q.x[1]%2==0:\n                pk=chr(2)+Int2Byte(self.Q.x[0],32)\n            else:\n                pk=chr(3)+Int2Byte(self.Q.x[0],32)\n        \n        version=chr(0)\n        \n        h=hashlib.new(\"SHA256\")\n        h.update(pk)\n        s=h.digest()\n\n        h=hashlib.new(\"RIPEMD160\")\n        h.update(s)\n        kh=version+h.digest()\n\n        h=hashlib.new(\"SHA256\")\n        h.update(kh)\n        cs=h.digest()\n\n        h=hashlib.new(\"SHA256\")\n        h.update(cs)\n        cs=h.digest()[:4]\n\n        adr=b58encode(kh+cs)\n\n        return adr\n\n    def BitcoinAddress(self,normal=True):\n        \n        self.Q=self*self.d\n        \n        return self.BitcoinAddresFromPublicKey(normal)\n    \n    def BitcoinAddressGenerator(self,k,filename):\n        \n        \n        f=open(filename,\"w\")\n        for i in range(k):\n            self.GeneratePrivateKey()\n            adr=self.BitcoinAddress()\n            p=self.PrivateEncoding()\n            f.write(\"#%s\\n%s 2014-01-30T12:00:00Z\\n\"%(adr,p))\n\n            #print hex(self.d)\n            print adr,p\n        \n        f.close()\n\n    def TestSign(self):\n        \n        self.GeneratePrivateKey()\n        self.Q=self*self.d\n        m=\"Hello World\"\n        adresse=self.BitcoinAddresFromPublicKey()\n        (r,s)=self.SignECDSA(m)\n        \n        m=\"Hello World\"\n        print self.VerifyMessageFromBitcoinAddress(adresse,m,r,s)\n\n    def Normalize(self):\n        #Transform projective coordinates of self to the usual (x,y) coordinates.\n        if self.x[2]:\n            self.x[0]=(self.x[0]*InvMod(self.x[2],self.p))%self.p\n            self.x[1]=(self.x[1]*InvMod(self.x[2],self.p))%self.p\n            self.x[2]=1\n        elif self.x[1]:\n            self.x[0]=(self.x[0]*InvMod(self.x[1],self.p))%self.p\n            self.x[1]=1\n        elif self.x[0]:\n            self.x[0]=1\n        else:\n            raise Exception\n\ndef Bitcoin():\n    \n    a=0\n    b=7\n    p=2**256-2**32-2**9-2**8-2**7-2**6-2**4-1\n    \n    \n    Gx=int(\"79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\",16)\n    Gy=int(\"483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\",16)\n    n =int(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\",16)\n    \n    \n    return EllipticCurvePoint([Gx,Gy,1],a,b,p,n)\n\n\nif __name__ == \"__main__\":\n    bitcoin=Bitcoin()\n\n    \n    print bitcoin.BitcoinAddressFromPrivate(\"23DKRBLkeDbcSaddsMYLAHXhanPmGwkWAhSPVGbspAkc72Hw9BdrDF\")\n    print bitcoin.BitcoinAddress()\n\n    \n    adr=bitcoin.BitcoinAddresFromPublicKey()\n    print adr\n\n    \n    m=\"Hello World\"\n    sig=bitcoin.SignECDSA(\"Hello World\")\n    \n    \n    print bitcoin.VerifyMessageFromBitcoinAddress(adr,m,sig)\n", "comments": "  by  hurlsly    source  https   github com hurlsly python blob master bitcoinecc py    modified  random number generator def generateprivatekey(self)    a class gauss integers form   b sqrt(n) b integers    n positive negative    find square root modulo p using algorithm cipolla   decompose n base b   find inverse mod n    use extended euclides algorithm    encode byte string base58   decode base58 string byte string   convert byte string hex number   convert integer byte string length b   main class   it point elliptic curve   we store coordinate x elliptic curbe parameter    x length 3  this 3 projective coordinates point    does equals self     it computes self cross product check result 0    the main function add self   it uses formulas i derived projective coordinates    projectives coordinates performant usual (x y) coordinates   need compute inverse mod p  faster    the fast multiplication point n times    print point (x y) coordinate    does self  x     does self  x     is self curve     generate private key  it random number 1 n 1    of course  function cryptographically secure    don use generate key  use cryptographically secure source randomness instead    self   random randint(1 self n 1)    better random fix   sign message  the private key self     k random randint(1 self n 1)    better random fix   check signature (r s) message using public key self q    generator self    this one used bitcoin public key known     hash public key known  see next function    check signature (r s) message signed bitcoin     address  addresse     transform private key base58 encoding bitcoin address    normal means  uncompressed     encode private key self base58 encoding    find bitcoin address public key self q   we normalization go projective coordinates usual    (x y) coordinates    computes bitcoin address given private key self    generate bitcoin address write filename multibit format    change date like    print hex(self d)   test signature   transform projective coordinates self usual (x y) coordinates    create bitcoin elliptiv curve   create generator g bitcoin elliptic curve  order n    create generator       generate public key private one   print bitcoin address public key generated previous line   sign message current address   verify message using bitcoin adress  signature message    not using public key needed  ", "content": "# By: HurlSly\n# Source: https://github.com/HurlSly/Python/blob/master/BitcoinECC.py\n# Modified: random number generator in def GeneratePrivateKey(self):\n\nimport random\nimport hashlib\nimport os\n\nclass GaussInt:\n    #A class for the Gauss integers of the form a + b sqrt(n) where a,b are integers.\n    #n can be positive or negative.\n    def __init__(self,x,y,n,p=0):\n        if p:\n            self.x=x%p\n            self.y=y%p\n            self.n=n%p\n        else:\n            self.x=x\n            self.y=y\n            self.n=n\n\n        self.p=p\n        \n    def __add__(self,b):\n        return GaussInt(self.x+b.x,self.y+b.y,self.n,self.p)\n        \n    def __sub__(self,b):\n        return GaussInt(self.x-b.x,self.y-b.y,self.n,self.p)\n    \n    def __mul__(self,b):\n        return GaussInt(self.x*b.x+self.n*self.y*b.y,self.x*b.y+self.y*b.x,self.n,self.p)\n    \n    def __div__(self,b):\n        return GaussInt((self.x*b.x-self.n*self.y*b.y)/(b.x*b.x-self.n*b.y*b.y),(-self.x*b.y+self.y*b.x)/(b.x*b.x-self.n*b.y*b.y),self.n,self.p)\n    \n    def __eq__(self,b):\n        return self.x==b.x and self.y==b.y\n    \n    def __repr__(self):\n        if self.p:\n            return \"%s+%s (%d,%d)\"%(self.x,self.y,self.n,self.p)\n        else:\n            return \"%s+%s (%d)\"%(self.x,self.y,self.n)\n        \n    def __pow__(self,n):\n        b=Base(n,2)\n        t=GaussInt(1,0,self.n)\n        while b:\n            t=t*t\n            if b.pop():\n                t=self*t\n            \n        return t\n\n    def Inv(self):\n        return GaussInt(self.x/(self.x*self.x-self.n*self.y*self.y),-self.y/(self.x*self.x-self.n*self.y*self.y),self.n,self.p)\n\ndef Cipolla(a,p):\n    #Find a square root of a modulo p using the algorithm of Cipolla\n    b=0\n    while pow((b*b-a)%p,(p-1)/2,p)==1:\n        b+=1\n\n    return (GaussInt(b,1,b**2-a,p)**((p+1)/2)).x\n    \ndef Base(n,b):\n    #Decompose n in base b\n    l=[]\n    while n:\n        l.append(n%b)\n        n/=b\n\n    return l\n    \ndef InvMod(a,n):\n    #Find the inverse mod n of a.\n    #Use the Extended Euclides Algorithm.\n    m=[]\n\n    s=n\n    while n:\n        m.append(a/n)\n        (a,n)=(n,a%n)\n\n    u=1\n    v=0\n    while m:\n        (u,v)=(v,u-m.pop()*v)\n\n    return u%s\n\ndef b58encode(v):\n    #Encode a byte string to the Base58\n    digit=\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n    base=len(digit)\n    val=0    \n    for c in v:\n        val*=256\n        val+=ord(c)\n\n    result=\"\"\n    while val:\n        (val,mod)=divmod(val,base)\n        result=digit[mod]+result\n\n    pad=0\n    for c in v:\n        if c==\"\\0\":\n            pad+=1\n        else:\n            break\n\n    return (digit[0]*pad)+result\n\ndef b58decode(v):\n    #Decode a Base58 string to byte string\n    digit=\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n    base=len(digit)\n    val=0    \n    for c in v:\n        val*=base\n        val+=digit.find(c)\n\n    result=\"\"\n    while val:\n        (val,mod)=divmod(val,256)\n        result=chr(mod)+result\n\n    pad=0\n    for c in v:\n        if c==digit[0]:\n            pad+=1\n        else:\n            break\n\n    result=\"\\0\"*pad+result\n\n    return result\n\ndef Byte2Hex(b):\n    #Convert a byte string to hex number\n    out=\"\"\n    for x in b:\n        y=hex(ord(x))[2:]\n        if len(y)==1:\n            y=\"0\"+y\n        out+=\"%2s\"%y\n    \n    return out\n\ndef Int2Byte(n,b):\n    #Convert a integer to a byte string of length b\n    out=\"\"\n    \n    for i in range(b):\n        (n,m)=divmod(n,256)\n        out=chr(m)+out\n    \n    return out\n\nclass EllipticCurvePoint:\n    #Main class\n    #It is an point on an Elliptic Curve\n    \n    def __init__(self,x,a,b,p,n=0):\n        #We store the coordinate in x and the elliptic curbe parameter.\n        #x is of length 3. This is the 3 projective coordinates of the point.\n        self.x=x[:]\n        self.a=a\n        self.b=b\n        self.p=p\n        self.n=n\n\n    def EqualProj(self,y):\n        #Does y equals self ?\n        #It computes self cross product with y and check if the result is 0.\n        return self.x[0]*y.x[1]==self.x[1]*y.x[0] and self.x[1]*y.x[2]==self.x[2]*y.x[1] and self.x[2]*y.x[0]==self.x[0]*y.x[2]\n\n    def __add__(self,y):\n        #The main function to add self and y\n        #It uses the formulas I derived in projective coordinates.\n        #Projectives coordinates are more performant than the usual (x,y) coordinates\n        #because it we don't need to compute inverse mod p, which is faster.\n        z=EllipticCurvePoint([0,0,0],self.a,self.b,self.p)\n\n        if self.EqualProj(y):\n            d=(2*self.x[1]*self.x[2])%self.p\n            d3=pow(d,3,self.p)\n            n=(3*pow(self.x[0],2,self.p)+self.a*pow(self.x[2],2,self.p))%self.p\n            \n            z.x[0]=(pow(n,2,self.p)*d*self.x[2]-2*d3*self.x[0])%self.p\n            z.x[1]=(3*self.x[0]*n*pow(d,2,self.p)-pow(n,3,self.p)*self.x[2]-self.x[1]*d3)%self.p\n            z.x[2]=(self.x[2]*d3)%self.p\n        else:\n            d=(y.x[0]*self.x[2]-y.x[2]*self.x[0])%self.p\n            d3=pow(d,3,self.p)\n            n=(y.x[1]*self.x[2]-self.x[1]*y.x[2])%self.p\n\n            z.x[0]=(y.x[2]*self.x[2]*pow(n,2,self.p)*d-d3*(y.x[2]*self.x[0]+y.x[0]*self.x[2]))%self.p\n            z.x[1]=(pow(d,2,self.p)*n*(2*self.x[0]*y.x[2]+y.x[0]*self.x[2])-pow(n,3,self.p)*self.x[2]*y.x[2]-self.x[1]*d3*y.x[2])%self.p\n            z.x[2]=(self.x[2]*d3*y.x[2])%self.p\n        \n        return z\n\n    def __mul__(self,n):\n        #The fast multiplication of point n times by itself.\n        b=Base(n,2)\n        t=EllipticCurvePoint(self.x,self.a,self.b,self.p)\n        b.pop()\n        while b:\n            t+=t\n            if b.pop():\n                t+=self\n                \n        return t\n\n    def __repr__(self):\n        #print a point in (x,y) coordinate.\n        return \"x=%d\\ny=%d\\n\"%((self.x[0]*InvMod(self.x[2],self.p))%self.p,(self.x[1]*InvMod(self.x[2],self.p))%self.p)\n    \n    def __eq__(self,x):\n        #Does self==x ?\n        return self.x==x.x and self.a==x.a and self.b==x.b and self.p==x.p\n    \n    def __ne__(self,x):\n        #Does self!=x ?\n        return self.x!=x.x or self.a!=x.a or self.b!=x.b or self.p!=x.p\n    \n    def Check(self):\n        #Is self on the curve ?\n        return (self.x[0]**3+self.a*self.x[0]*self.x[2]**2+self.b*self.x[2]**3-self.x[1]**2*self.x[2])%self.p==0\n\n    def GeneratePrivateKey(self):\n        #Generate a private key. It's just a random number between 1 and n-1.\n        #Of course, this function isn't cryptographically secure.\n        #Don't use it to generate your key. Use a cryptographically secure source of randomness instead.\n        #self.d = random.randint(1,self.n-1)\n        self.d = random.SystemRandom().randint(1,self.n-1) # Better random fix\n    \n    def SignECDSA(self,m):\n        #Sign a message. The private key is self.d .\n        h=hashlib.new(\"SHA256\")\n        h.update(m)\n        z=int(h.hexdigest(),16)\n        \n        r=0\n        s=0\n        while not r or not s:\n            #k=random.randint(1,self.n-1)\n            k=random.SystemRandom().randint(1,self.n-1) # Better random fix\n            R=self*k\n            R.Normalize()\n            r=R.x[0]%self.n\n            s=(InvMod(k,self.n)*(z+r*self.d))%self.n\n\n        return (r,s)\n        \n    def CheckECDSA(self,sig,m):\n        #Check a signature (r,s) of the message m using the public key self.Q\n        # and the generator which is self.\n        #This is not the one used by Bitcoin because the public key isn't known;\n        # only a hash of the public key is known. See the next function.\n        (r,s)=sig        \n        \n        h=hashlib.new(\"SHA256\")\n        h.update(m)\n        z=int(h.hexdigest(),16)\n        \n        if self.Q.x[2]==0:\n            return False\n        if not self.Q.Check():\n            return False\n        if (self.Q*self.n).x[2]!=0:\n            return False\n        if r<1 or r>self.n-1 or s<1 or s>self.n-1:\n            return False\n\n        w=InvMod(s,self.n)\n        u1=(z*w)%self.n\n        u2=(r*w)%self.n\n        R=self*u1+self.Q*u2\n        R.Normalize()\n\n        return (R.x[0]-r)%self.n==0\n\n    def VerifyMessageFromBitcoinAddress(self,adresse,m,sig):\n        #Check a signature (r,s) for the message m signed by the Bitcoin \n        # address \"addresse\".\n        h=hashlib.new(\"SHA256\")\n        h.update(m)\n        z=int(h.hexdigest(),16)\n        \n        (r,s)=sig\n        x=r\n        y2=(pow(x,3,self.p)+self.a*x+self.b)%self.p\n        y=Cipolla(y2,self.p)\n\n        for i in range(2):\n            kG=EllipticCurvePoint([x,y,1],self.a,self.b,self.p,self.n)  \n            mzG=self*((-z)%self.n)\n            self.Q=(kG*s+mzG)*InvMod(r,self.n)\n\n            adr=self.BitcoinAddresFromPublicKey()\n            if adr==adresse:\n                break\n            y=(-y)%self.p\n\n        if adr!=adresse:\n            return False\n\n        return True\n\n    def BitcoinAddressFromPrivate(self,pri=None):\n        #Transform a private key in base58 encoding to a bitcoin address.\n        #normal means \"uncompressed\".\n        if not pri:\n            print \"Private Key :\",\n            pri=raw_input()\n\n        normal=(len(pri)==51)\n        pri=b58decode(pri)\n        \n        if normal:\n            pri=pri[1:-4]\n        else:\n            pri=pri[1:-5]\n        \n        self.d=int(Byte2Hex(pri),16)\n        \n        return self.BitcoinAddress(normal)\n\n    def PrivateEncoding(self,normal=True):\n        #Encode a private key self.d to base58 encoding.\n        p=Int2Byte(self.d,32)\n        p=\"\\80\"+p\n        \n        if not normal:\n            p+=chr(1)\n\n        h=hashlib.new(\"SHA256\")\n        h.update(p)\n        s=h.digest()\n        \n        h=hashlib.new(\"SHA256\")\n        h.update(s)\n        s=h.digest()\n        \n        cs=s[:4]\n\n        p+=cs\n        p=b58encode(p)\n\n        return p\n\n    def BitcoinAddresFromPublicKey(self,normal=True):\n        #Find the bitcoin address from the public key self.Q\n        #We do normalization to go from the projective coordinates to the usual\n        # (x,y) coordinates.\n        self.Q.Normalize()\n        if normal:\n            pk=chr(4)+Int2Byte(self.Q.x[0],32)+Int2Byte((self.Q.x[1])%self.p,32)\n        else:\n            if self.Q.x[1]%2==0:\n                pk=chr(2)+Int2Byte(self.Q.x[0],32)\n            else:\n                pk=chr(3)+Int2Byte(self.Q.x[0],32)\n        \n        version=chr(0)\n        \n        h=hashlib.new(\"SHA256\")\n        h.update(pk)\n        s=h.digest()\n\n        h=hashlib.new(\"RIPEMD160\")\n        h.update(s)\n        kh=version+h.digest()\n\n        h=hashlib.new(\"SHA256\")\n        h.update(kh)\n        cs=h.digest()\n\n        h=hashlib.new(\"SHA256\")\n        h.update(cs)\n        cs=h.digest()[:4]\n\n        adr=b58encode(kh+cs)\n\n        return adr\n\n    def BitcoinAddress(self,normal=True):\n        #Computes a bitcoin address given the private key self.d.\n        self.Q=self*self.d\n        \n        return self.BitcoinAddresFromPublicKey(normal)\n    \n    def BitcoinAddressGenerator(self,k,filename):\n        #Generate Bitcoin address and write them in the filename in the multibit format.\n        #Change the date as you like.\n        f=open(filename,\"w\")\n        for i in range(k):\n            self.GeneratePrivateKey()\n            adr=self.BitcoinAddress()\n            p=self.PrivateEncoding()\n            f.write(\"#%s\\n%s 2014-01-30T12:00:00Z\\n\"%(adr,p))\n\n            #print hex(self.d)\n            print adr,p\n        \n        f.close()\n\n    def TestSign(self):\n        #Test signature\n        self.GeneratePrivateKey()\n        self.Q=self*self.d\n        m=\"Hello World\"\n        adresse=self.BitcoinAddresFromPublicKey()\n        (r,s)=self.SignECDSA(m)\n        \n        m=\"Hello World\"\n        print self.VerifyMessageFromBitcoinAddress(adresse,m,r,s)\n\n    def Normalize(self):\n        #Transform projective coordinates of self to the usual (x,y) coordinates.\n        if self.x[2]:\n            self.x[0]=(self.x[0]*InvMod(self.x[2],self.p))%self.p\n            self.x[1]=(self.x[1]*InvMod(self.x[2],self.p))%self.p\n            self.x[2]=1\n        elif self.x[1]:\n            self.x[0]=(self.x[0]*InvMod(self.x[1],self.p))%self.p\n            self.x[1]=1\n        elif self.x[0]:\n            self.x[0]=1\n        else:\n            raise Exception\n\ndef Bitcoin():\n    #Create the Bitcoin elliptiv curve\n    a=0\n    b=7\n    p=2**256-2**32-2**9-2**8-2**7-2**6-2**4-1\n    \n    #Create the generator G of the Bitcoin elliptic curve, with is order n.\n    Gx=int(\"79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\",16)\n    Gy=int(\"483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\",16)\n    n =int(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\",16)\n    \n    #Create the generator    \n    return EllipticCurvePoint([Gx,Gy,1],a,b,p,n)\n\n\nif __name__ == \"__main__\":\n    bitcoin=Bitcoin()\n\n    #Generate the public key from the private one\n    print bitcoin.BitcoinAddressFromPrivate(\"23DKRBLkeDbcSaddsMYLAHXhanPmGwkWAhSPVGbspAkc72Hw9BdrDF\")\n    print bitcoin.BitcoinAddress()\n\n    #Print the bitcoin address of the public key generated at the previous line\n    adr=bitcoin.BitcoinAddresFromPublicKey()\n    print adr\n\n    #Sign a message with the current address\n    m=\"Hello World\"\n    sig=bitcoin.SignECDSA(\"Hello World\")\n    #Verify the message using only the bitcoin adress, the signature and the message.\n    #Not using the public key as it is not needed.\n    print bitcoin.VerifyMessageFromBitcoinAddress(adr,m,sig)\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "BitcoinECC.py", "id": "84f04ae4e28960f1c623b33f50e692b5", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/lib/BitcoinECC/BitcoinECC.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}