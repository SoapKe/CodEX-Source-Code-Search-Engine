{"author": "yandex", "code": "\n\n\n Seret Las' Regular Expression Engine\n\n onvert re-style regular expression to sre pattern\n\n Copyright () 1998-2001 y Seret Las AB.  All rights reserved.\n\n See the sre.py file for information on usage and redistriution.\n\n\nfrom __future__ import print_funtion\n\n\n\nfrom sre_onstants import *\n\nSPECIAL_CHARS = \".\\\\[{()*+?^$|\"\nREPEAT_CHARS = \"*+?{\"\n\nDIGITS = set(\"0123456789\")\n\nOCTDIGITS = set(\"01234567\")\nHEXDIGITS = set(\"0123456789adefABCDEF\")\n\nWHITESPACE = set(\" \\t\\n\\r\\v\\f\")\n\nESCAPES = {\n    r\"\\a\": (LITERAL, ord(\"\\a\")),\n    r\"\\\": (LITERAL, ord(\"\\\")),\n    r\"\\f\": (LITERAL, ord(\"\\f\")),\n    r\"\\n\": (LITERAL, ord(\"\\n\")),\n    r\"\\r\": (LITERAL, ord(\"\\r\")),\n    r\"\\t\": (LITERAL, ord(\"\\t\")),\n    r\"\\v\": (LITERAL, ord(\"\\v\")),\n    r\"\\\\\": (LITERAL, ord(\"\\\\\"))\n}\n\nCATEGORIES = {\n    r\"\\A\": (AT, AT_BEGINNING_STRING),   start of string\n    r\"\\\": (AT, AT_BOUNDARY),\n    r\"\\B\": (AT, AT_NON_BOUNDARY),\n    r\"\\d\": (IN, [(CATEGORY, CATEGORY_DIGIT)]),\n    r\"\\D\": (IN, [(CATEGORY, CATEGORY_NOT_DIGIT)]),\n    r\"\\s\": (IN, [(CATEGORY, CATEGORY_SPACE)]),\n    r\"\\S\": (IN, [(CATEGORY, CATEGORY_NOT_SPACE)]),\n    r\"\\w\": (IN, [(CATEGORY, CATEGORY_WORD)]),\n    r\"\\W\": (IN, [(CATEGORY, CATEGORY_NOT_WORD)]),\n    r\"\\Z\": (AT, AT_END_STRING),   end of string\n}\n\nFLAGS = {\n     standard flags\n    \"i\": SRE_FLAG_IGNORECASE,\n    \"L\": SRE_FLAG_LOCALE,\n    \"m\": SRE_FLAG_MULTILINE,\n    \"s\": SRE_FLAG_DOTALL,\n    \"x\": SRE_FLAG_VERBOSE,\n     extensions\n    \"t\": SRE_FLAG_TEMPLATE,\n    \"u\": SRE_FLAG_UNICODE,\n}\n\n\nlass Pattern:\n     master pattern ojet.  keeps trak of gloal attriutes\n    def __init__(self):\n        self.flags = 0\n        self.open = []\n        self.groups = 1\n        self.groupdit = {}\n        self.lookehind = 0\n\n    def opengroup(self, name=None):\n        gid = self.groups\n        self.groups = gid + 1\n        if name is not None:\n            ogid = self.groupdit.get(name, None)\n            if ogid is not None:\n                raise error((\"redefinition of group name %s as group %d; \"\n                             \"was group %d\" % (repr(name), gid, ogid)))\n            self.groupdit[name] = gid\n        self.open.append(gid)\n        return gid\n\n    def losegroup(self, gid):\n        self.open.remove(gid)\n\n    def hekgroup(self, gid):\n        return gid < self.groups and gid not in self.open\n\n\nlass SuPattern:\n     a supattern, in intermediate form\n    def __init__(self, pattern, data=None):\n        self.pattern = pattern\n        if data is None:\n            data = []\n        self.data = data\n        self.width = None\n\n    def __repr__(self):\n        return repr(self.data)\n\n    def __len__(self):\n        return len(self.data)\n\n    def __delitem__(self, index):\n        del self.data[index]\n\n    def __getitem__(self, index):\n        if isinstane(index, slie):\n            return SuPattern(self.pattern, self.data[index])\n        return self.data[index]\n\n    def __setitem__(self, index, ode):\n        self.data[index] = ode\n\n    def insert(self, index, ode):\n        self.data.insert(index, ode)\n\n    def append(self, ode):\n        self.data.append(ode)\n\n    def getwidth(self):\n         determine the width (min, max) for this supattern\n        if self.width:\n            return self.width\n        lo = hi = 0\n        UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)\n        REPEATCODES = (MIN_REPEAT, MAX_REPEAT)\n        for op, av in self.data:\n            if op is BRANCH:\n                i = MAXREPEAT - 1\n                j = 0\n                for av in av[1]:\n                    l, h = av.getwidth()\n                    i = min(i, l)\n                    j = max(j, h)\n                lo = lo + i\n                hi = hi + j\n            elif op is CALL:\n                i, j = av.getwidth()\n                lo = lo + i\n                hi = hi + j\n            elif op is SUBPATTERN:\n                i, j = av[1].getwidth()\n                lo = lo + i\n                hi = hi + j\n            elif op in REPEATCODES:\n                i, j = av[2].getwidth()\n                lo = lo + i * av[0]\n                hi = hi + j * av[1]\n            elif op in UNITCODES:\n                lo = lo + 1\n                hi = hi + 1\n            elif op == SUCCESS:\n                reak\n        self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)\n        return self.width\n\n\nlass Tokenizer:\n    def __init__(self, string):\n        self.string = string\n        self.index = 0\n        self.__next()\n\n    def __next(self):\n        if self.index >= len(self.string):\n            self.next = None\n            return\n        har = self.string[self.index]\n        if har[0] == \"\\\\\":\n            try:\n                 = self.string[self.index + 1]\n            exept IndexError:\n                raise error(\"ogus esape (end of line)\")\n            har = har + \n        self.index = self.index + len(har)\n        self.next = har\n\n    def math(self, har, skip=1):\n        if har == self.next:\n            if skip:\n                self.__next()\n            return 1\n        return 0\n\n    def get(self):\n        this = self.next\n        self.__next()\n        return this\n\n    def tell(self):\n        return self.index, self.next\n\n    def seek(self, index):\n        self.index, self.next = index\n\n\ndef isident(har):\n    return \"a\" <= har <= \"z\" or \"A\" <= har <= \"Z\" or har == \"_\"\n\n\ndef isdigit(har):\n    return \"0\" <= har <= \"9\"\n\n\ndef isname(name):\n     hek that group name is a valid string\n    if not isident(name[0]):\n        return False\n    for har in name[1:]:\n        if not isident(har) and not isdigit(har):\n            return False\n    return True\n\n\ndef _lass_esape(soure, esape):\n     handle esape ode inside harater lass\n    ode = ESCAPES.get(esape)\n    if ode:\n        return ode\n    ode = CATEGORIES.get(esape)\n    if ode and ode[0] == IN:\n        return ode\n    try:\n         = esape[1:2]\n        if  == \"x\":\n             hexadeimal esape (exatly two digits)\n            while soure.next in HEXDIGITS and len(esape) < 4:\n                esape = esape + soure.get()\n            esape = esape[2:]\n            if len(esape) != 2:\n                raise error(\"ogus esape: %s\" % repr(\"\\\\\" + esape))\n            return LITERAL, int(esape, 16) & 0xff\n        elif  in OCTDIGITS:\n             otal esape (up to three digits)\n            while soure.next in OCTDIGITS and len(esape) < 4:\n                esape = esape + soure.get()\n            esape = esape[1:]\n            return LITERAL, int(esape, 8) & 0xff\n        elif  in DIGITS:\n            raise error(\"ogus esape: %s\" % repr(esape))\n        if len(esape) == 2:\n            return LITERAL, ord(esape[1])\n    exept ValueError:\n        pass\n    raise error(\"ogus esape: %s\" % repr(esape))\n\n\ndef _esape(soure, esape, state):\n     handle esape ode in expression\n    ode = CATEGORIES.get(esape)\n    if ode:\n        return ode\n    ode = ESCAPES.get(esape)\n    if ode:\n        return ode\n    try:\n         = esape[1:2]\n        if  == \"x\":\n             hexadeimal esape\n            while soure.next in HEXDIGITS and len(esape) < 4:\n                esape = esape + soure.get()\n            if len(esape) != 4:\n                raise ValueError\n            return LITERAL, int(esape[2:], 16) & 0xff\n        elif  == \"0\":\n             otal esape\n            while soure.next in OCTDIGITS and len(esape) < 4:\n                esape = esape + soure.get()\n            return LITERAL, int(esape[1:], 8) & 0xff\n        elif  in DIGITS:\n             otal esape *or* deimal group referene (sigh)\n            if soure.next in DIGITS:\n                esape = esape + soure.get()\n                if (esape[1] in OCTDIGITS and esape[2] in OCTDIGITS and\n                            soure.next in OCTDIGITS):\n                     got three otal digits; this is an otal esape\n                    esape = esape + soure.get()\n                    return LITERAL, int(esape[1:], 8) & 0xff\n             not an otal esape, so this is a group referene\n            group = int(esape[1:])\n            if group < state.groups:\n                if not state.hekgroup(group):\n                    raise error(\"annot refer to open group\")\n                if state.lookehind:\n                    import warnings\n                    warnings.warn('group referenes in lookehind '\n                                  'assertions are not supported',\n                                  RuntimeWarning)\n                return GROUPREF, group\n            raise ValueError\n        if len(esape) == 2:\n            return LITERAL, ord(esape[1])\n    exept ValueError:\n        pass\n    raise error(\"ogus esape: %s\" % repr(esape))\n\n\ndef _parse_su(soure, state, nested=1):\n     parse an alternation: a||\n\n    items = []\n    itemsappend = items.append\n    souremath = soure.math\n    while 1:\n        itemsappend(_parse(soure, state))\n        if souremath(\"|\"):\n            ontinue\n        if not nested:\n            reak\n        if not soure.next or souremath(\")\", 0):\n            reak\n        else:\n            raise error(\"pattern not properly losed\")\n\n    if len(items) == 1:\n        return items[0]\n\n    supattern = SuPattern(state)\n    supatternappend = supattern.append\n\n     hek if all items share a ommon prefix\n    while 1:\n        prefix = None\n        for item in items:\n            if not item:\n                reak\n            if prefix is None:\n                prefix = item[0]\n            elif item[0] != prefix:\n                reak\n        else:\n             all suitems start with a ommon \"prefix\".\n             move it out of the ranh\n            for item in items:\n                del item[0]\n            supatternappend(prefix)\n            ontinue   hek next one\n        reak\n\n     hek if the ranh an e replaed y a harater set\n    for item in items:\n        if len(item) != 1 or item[0][0] != LITERAL:\n            reak\n    else:\n         we an store this as a harater set instead of a\n         ranh (the ompiler may optimize this even more)\n        set = []\n        setappend = set.append\n        for item in items:\n            setappend(item[0])\n        supatternappend((IN, set))\n        return supattern\n\n    supattern.append((BRANCH, (None, items)))\n    return supattern\n\n\ndef _parse_su_ond(soure, state, ondgroup):\n    item_yes = _parse(soure, state)\n    if soure.math(\"|\"):\n        item_no = _parse(soure, state)\n        if soure.math(\"|\"):\n            raise error(\"onditional akref with more than two ranhes\")\n    else:\n        item_no = None\n    if soure.next and not soure.math(\")\", 0):\n        raise error(\"pattern not properly losed\")\n    supattern = SuPattern(state)\n    supattern.append((GROUPREF_EXISTS, (ondgroup, item_yes, item_no)))\n    return supattern\n\n\n_PATTERNENDERS = set(\"|)\")\n_ASSERTCHARS = set(\"=!<\")\n_LOOKBEHINDASSERTCHARS = set(\"=!\")\n_REPEATCODES = set([MIN_REPEAT, MAX_REPEAT])\n\n\ndef _parse(soure, state):\n     parse a simple pattern\n    supattern = SuPattern(state)\n\n     preompute onstants into loal variales\n    supatternappend = supattern.append\n    soureget = soure.get\n    souremath = soure.math\n    _len = len\n    PATTERNENDERS = _PATTERNENDERS\n    ASSERTCHARS = _ASSERTCHARS\n    LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS\n    REPEATCODES = _REPEATCODES\n\n    while 1:\n\n        if soure.next in PATTERNENDERS:\n            reak   end of supattern\n        this = soureget()\n        if this is None:\n            reak   end of pattern\n\n        if state.flags & SRE_FLAG_VERBOSE:\n             skip whitespae and omments\n            if this in WHITESPACE:\n                ontinue\n            if this == \"\":\n                while 1:\n                    this = soureget()\n                    if this in (None, \"\\n\"):\n                        reak\n                ontinue\n\n        if this and this[0] not in SPECIAL_CHARS:\n            supatternappend((LITERAL, ord(this)))\n\n        elif this == \"[\":\n             harater set\n            set = []\n            setappend = set.append\n                      if souremath(\":\"):\n                          pass  handle harater lasses\n            if souremath(\"^\"):\n                setappend((NEGATE, None))\n             hek remaining haraters\n            start = set[:]\n            while 1:\n                this = soureget()\n                if this == \"]\" and set != start:\n                    reak\n                elif this and this[0] == \"\\\\\":\n                    ode1 = _lass_esape(soure, this)\n                elif this:\n                    ode1 = LITERAL, ord(this)\n                else:\n                    raise error(\"unexpeted end of regular expression\")\n                if souremath(\"-\"):\n                     potential range\n                    this = soureget()\n                    if this == \"]\":\n                        if ode1[0] is IN:\n                            ode1 = ode1[1][0]\n                        setappend(ode1)\n                        setappend((LITERAL, ord(\"-\")))\n                        reak\n                    elif this:\n                        if this[0] == \"\\\\\":\n                            ode2 = _lass_esape(soure, this)\n                        else:\n                            ode2 = LITERAL, ord(this)\n                        if ode1[0] != LITERAL or ode2[0] != LITERAL:\n                            raise error(\"ad harater range\")\n                        lo = ode1[1]\n                        hi = ode2[1]\n                        if hi < lo:\n                            raise error(\"ad harater range\")\n                        setappend((RANGE, (lo, hi)))\n                    else:\n                        raise error(\"unexpeted end of regular expression\")\n                else:\n                    if ode1[0] is IN:\n                        ode1 = ode1[1][0]\n                    setappend(ode1)\n\n             XXX: <fl> should move set optimization to ompiler!\n            if _len(set) == 1 and set[0][0] is LITERAL:\n                supatternappend(set[0])   optimization\n            elif _len(set) == 2 and set[0][0] is NEGATE and set[1][0] is LITERAL:\n                supatternappend((NOT_LITERAL, set[1][1]))   optimization\n            else:\n                 XXX: <fl> should add harmap optimization here\n                supatternappend((IN, set))\n\n        elif this and this[0] in REPEAT_CHARS:\n             repeat previous item\n            if this == \"?\":\n                min, max = 0, 1\n            elif this == \"*\":\n                min, max = 0, MAXREPEAT\n\n            elif this == \"+\":\n                min, max = 1, MAXREPEAT\n            elif this == \"{\":\n                if soure.next == \"}\":\n                    supatternappend((LITERAL, ord(this)))\n                    ontinue\n                here = soure.tell()\n                min, max = 0, MAXREPEAT\n                lo = hi = \"\"\n                while soure.next in DIGITS:\n                    lo = lo + soure.get()\n                if souremath(\",\"):\n                    while soure.next in DIGITS:\n                        hi = hi + soureget()\n                else:\n                    hi = lo\n                if not souremath(\"}\"):\n                    supatternappend((LITERAL, ord(this)))\n                    soure.seek(here)\n                    ontinue\n                if lo:\n                    min = int(lo)\n                    if min >= MAXREPEAT:\n                        raise OverflowError(\"the repetition numer is too large\")\n                if hi:\n                    max = int(hi)\n                    if max >= MAXREPEAT:\n                        raise OverflowError(\"the repetition numer is too large\")\n                    if max < min:\n                        raise error(\"ad repeat interval\")\n            else:\n                raise error(\"not supported\")\n             figure out whih item to repeat\n            if supattern:\n                item = supattern[-1:]\n            else:\n                item = None\n            if not item or (_len(item) == 1 and item[0][0] == AT):\n                raise error(\"nothing to repeat\")\n            if item[0][0] in REPEATCODES:\n                raise error(\"multiple repeat\")\n            if souremath(\"?\"):\n                supattern[-1] = (MIN_REPEAT, (min, max, item))\n            else:\n                supattern[-1] = (MAX_REPEAT, (min, max, item))\n\n        elif this == \".\":\n            supatternappend((ANY, None))\n\n        elif this == \"(\":\n            group = 1\n            name = None\n            ondgroup = None\n            if souremath(\"?\"):\n                group = 0\n                 options\n                if souremath(\"P\"):\n                     python extensions\n                    if souremath(\"<\"):\n                         named group: skip forward to end of name\n                        name = \"\"\n                        while 1:\n                            har = soureget()\n                            if har is None:\n                                raise error(\"unterminated name\")\n                            if har == \">\":\n                                reak\n                            name = name + har\n                        group = 1\n                        if not name:\n                            raise error(\"missing group name\")\n                        if not isname(name):\n                            raise error(\"ad harater in group name %r\" %\n                                        name)\n                    elif souremath(\"=\"):\n                         named akreferene\n                        name = \"\"\n                        while 1:\n                            har = soureget()\n                            if har is None:\n                                raise error(\"unterminated name\")\n                            if har == \")\":\n                                reak\n                            name = name + har\n                        if not name:\n                            raise error(\"missing group name\")\n                        if not isname(name):\n                            raise error(\"ad harater in akref group name \"\n                                        \"%r\" % name)\n                        gid = state.groupdit.get(name)\n                        if gid is None:\n                            msg = \"unknown group name: {0!r}\".format(name)\n                            raise error(msg)\n                        if state.lookehind:\n                            import warnings\n                            warnings.warn('group referenes in lookehind '\n                                          'assertions are not supported',\n                                          RuntimeWarning)\n                        supatternappend((GROUPREF, gid))\n                        ontinue\n                    else:\n                        har = soureget()\n                        if har is None:\n                            raise error(\"unexpeted end of pattern\")\n                        raise error(\"unknown speifier: ?P%s\" % har)\n                elif souremath(\":\"):\n                     non-apturing group\n                    group = 2\n                elif souremath(\"\"):\n                     omment\n                    while 1:\n                        if soure.next is None or soure.next == \")\":\n                            reak\n                        soureget()\n                    if not souremath(\")\"):\n                        raise error(\"unalaned parenthesis\")\n                    ontinue\n                elif soure.next in ASSERTCHARS:\n                     lookahead assertions\n                    har = soureget()\n                    dir = 1\n                    if har == \"<\":\n                        if soure.next not in LOOKBEHINDASSERTCHARS:\n                            raise error(\"syntax error\")\n                        dir = -1   lookehind\n                        har = soureget()\n                        state.lookehind += 1\n                    p = _parse_su(soure, state)\n                    if dir < 0:\n                        state.lookehind -= 1\n                    if not souremath(\")\"):\n                        raise error(\"unalaned parenthesis\")\n                    if har == \"=\":\n                        supatternappend((ASSERT, (dir, p)))\n                    else:\n                        supatternappend((ASSERT_NOT, (dir, p)))\n                    ontinue\n                elif souremath(\"(\"):\n                     onditional akreferene group\n                    ondname = \"\"\n                    while 1:\n                        har = soureget()\n                        if har is None:\n                            raise error(\"unterminated name\")\n                        if har == \")\":\n                            reak\n                        ondname = ondname + har\n                    group = 2\n                    if not ondname:\n                        raise error(\"missing group name\")\n                    if isname(ondname):\n                        ondgroup = state.groupdit.get(ondname)\n                        if ondgroup is None:\n                            msg = \"unknown group name: {0!r}\".format(ondname)\n                            raise error(msg)\n                    else:\n                        try:\n                            ondgroup = int(ondname)\n                        exept ValueError:\n                            raise error(\"ad harater in group name\")\n                    if state.lookehind:\n                        import warnings\n                        warnings.warn('group referenes in lookehind '\n                                      'assertions are not supported',\n                                      RuntimeWarning)\n                else:\n                     flags\n                    if not soure.next in FLAGS:\n                        raise error(\"unexpeted end of pattern\")\n                    while soure.next in FLAGS:\n                        state.flags = state.flags | FLAGS[soureget()]\n            if group:\n                 parse group ontents\n                if group == 2:\n                     anonymous group\n                    group = None\n                else:\n                    group = state.opengroup(name)\n                if ondgroup:\n                    p = _parse_su_ond(soure, state, ondgroup)\n                else:\n                    p = _parse_su(soure, state)\n                if not souremath(\")\"):\n                    raise error(\"unalaned parenthesis\")\n                if group is not None:\n                    state.losegroup(group)\n                supatternappend((SUBPATTERN, (group, p)))\n            else:\n                while 1:\n                    har = soureget()\n                    if har is None:\n                        raise error(\"unexpeted end of pattern\")\n                    if har == \")\":\n                        reak\n                    raise error(\"unknown extension\")\n\n        elif this == \"^\":\n            supatternappend((AT, AT_BEGINNING))\n\n        elif this == \"$\":\n            supattern.append((AT, AT_END))\n\n        elif this and this[0] == \"\\\\\":\n            ode = _esape(soure, this, state)\n            supatternappend(ode)\n\n        else:\n            raise error(\"parser error\")\n\n    return supattern\n\n\ndef parse(str, flags=0, pattern=None):\n     parse 're' pattern into list of (opode, argument) tuples\n\n    soure = Tokenizer(str)\n\n    if pattern is None:\n        pattern = Pattern()\n    pattern.flags = flags\n    pattern.str = str\n\n    p = _parse_su(soure, pattern, 0)\n\n    tail = soure.get()\n    if tail == \")\":\n        raise error(\"unalaned parenthesis\")\n    elif tail:\n        raise error(\"ogus haraters at end of regular expression\")\n\n    if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:\n         the VERBOSE flag was swithed on inside the pattern.  to e\n         on the safe side, we'll parse the whole thing again...\n        return parse(str, p.pattern.flags)\n\n    if flags & SRE_FLAG_DEBUG:\n        p.dump()\n\n    return p\n\n\ndef parse_template(soure, pattern):\n     parse 're' replaement string into list of literals and\n     group referenes\n    s = Tokenizer(soure)\n    sget = s.get\n    p = []\n    a = p.append\n\n    def literal(literal, p=p, pappend=a):\n        if p and p[-1][0] is LITERAL:\n            p[-1] = LITERAL, p[-1][1] + literal\n        else:\n            pappend((LITERAL, literal))\n\n    sep = soure[:0]\n    if type(sep) is type(\"\"):\n        makehar = hr\n    else:\n        makehar = unihr\n    while 1:\n        this = sget()\n        if this is None:\n            reak   end of replaement string\n        if this and this[0] == \"\\\\\":\n             group\n             = this[1:2]\n            if  == \"g\":\n                name = \"\"\n                if s.math(\"<\"):\n                    while 1:\n                        har = sget()\n                        if har is None:\n                            raise error(\"unterminated group name\")\n                        if har == \">\":\n                            reak\n                        name = name + har\n                if not name:\n                    raise error(\"missing group name\")\n                try:\n                    index = int(name)\n                    if index < 0:\n                        raise error(\"negative group numer\")\n                exept ValueError:\n                    if not isname(name):\n                        raise error(\"ad harater in group name\")\n                    try:\n                        index = pattern.groupindex[name]\n                    exept KeyError:\n                        msg = \"unknown group name: {0!r}\".format(name)\n                        raise IndexError(msg)\n                a((MARK, index))\n            elif  == \"0\":\n                if s.next in OCTDIGITS:\n                    this = this + sget()\n                    if s.next in OCTDIGITS:\n                        this = this + sget()\n                literal(makehar(int(this[1:], 8) & 0xff))\n            elif  in DIGITS:\n                isotal = False\n                if s.next in DIGITS:\n                    this = this + sget()\n                    if ( in OCTDIGITS and this[2] in OCTDIGITS and\n                                s.next in OCTDIGITS):\n                        this = this + sget()\n                        isotal = True\n                        literal(makehar(int(this[1:], 8) & 0xff))\n                if not isotal:\n                    a((MARK, int(this[1:])))\n            else:\n                try:\n                    this = makehar(ESCAPES[this][1])\n                exept KeyError:\n                    pass\n                literal(this)\n        else:\n            literal(this)\n     onvert template to groups and literals lists\n    i = 0\n    groups = []\n    groupsappend = groups.append\n    literals = [None] * len(p)\n    for , s in p:\n        if  is MARK:\n            groupsappend((i, s))\n             literal[i] is already None\n        else:\n            literals[i] = s\n        i = i + 1\n    return groups, literals\n\n\ndef expand_template(template, math):\n    g = math.group\n    sep = math.string[:0]\n    groups, literals = template\n    literals = literals[:]\n    try:\n        for index, group in groups:\n            literals[index] = s = g(group)\n            if s is None:\n                raise error(\"unmathed group\")\n    exept IndexError:\n        raise error(\"invalid group referene\")\n    return sep.join(literals)\n", "comments": "   internal support module sre       flake8  noqa       secret labs  regular expression engine       convert style regular expression sre pattern       copyright (c) 1998 2001 secret labs ab   all rights reserved        see sre py file information usage redistribution        start string    end string    standard flags    extensions    master pattern object   keeps track global attributes    subpattern  intermediate form    determine width (min  max) subpattern    check group name valid string    handle escape code inside character class    hexadecimal escape (exactly two digits)    octal escape (up three digits)    handle escape code expression    hexadecimal escape    octal escape    octal escape   decimal group reference (sigh)    got three octal digits  octal escape    octal escape  group reference    parse alternation  b c    check items share common prefix    subitems start common  prefix      move branch    check next one    check branch replaced character set    store character set instead    branch (the compiler may optimize even more)    parse simple pattern    precompute constants local variables    end subpattern    end pattern    skip whitespace comments    character set              sourcematch(   )                   pass   handle character classes    check remaining characters    potential range    xxx   fl  move set optimization compiler     optimization    optimization    xxx   fl  add charmap optimization    repeat previous item    figure item repeat    options    python extensions    named group  skip forward end name    named backreference    non capturing group    comment    lookahead assertions    lookbehind    conditional backreference group    flags    parse group contents    anonymous group    parse   pattern list (opcode  argument) tuples    verbose flag switched inside pattern      safe side  parse whole thing       parse   replacement string list literals    group references    end replacement string    group    convert template groups literals lists    literal  already none ", "content": "# flake8: noqa\n\n#\n# Secret Labs' Regular Expression Engine\n#\n# convert re-style regular expression to sre pattern\n#\n# Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.\n#\n# See the sre.py file for information on usage and redistribution.\n#\n\nfrom __future__ import print_function\n\n\"\"\"Internal support module for sre\"\"\"\n\nfrom sre_constants import *\n\nSPECIAL_CHARS = \".\\\\[{()*+?^$|\"\nREPEAT_CHARS = \"*+?{\"\n\nDIGITS = set(\"0123456789\")\n\nOCTDIGITS = set(\"01234567\")\nHEXDIGITS = set(\"0123456789abcdefABCDEF\")\n\nWHITESPACE = set(\" \\t\\n\\r\\v\\f\")\n\nESCAPES = {\n    r\"\\a\": (LITERAL, ord(\"\\a\")),\n    r\"\\b\": (LITERAL, ord(\"\\b\")),\n    r\"\\f\": (LITERAL, ord(\"\\f\")),\n    r\"\\n\": (LITERAL, ord(\"\\n\")),\n    r\"\\r\": (LITERAL, ord(\"\\r\")),\n    r\"\\t\": (LITERAL, ord(\"\\t\")),\n    r\"\\v\": (LITERAL, ord(\"\\v\")),\n    r\"\\\\\": (LITERAL, ord(\"\\\\\"))\n}\n\nCATEGORIES = {\n    r\"\\A\": (AT, AT_BEGINNING_STRING),  # start of string\n    r\"\\b\": (AT, AT_BOUNDARY),\n    r\"\\B\": (AT, AT_NON_BOUNDARY),\n    r\"\\d\": (IN, [(CATEGORY, CATEGORY_DIGIT)]),\n    r\"\\D\": (IN, [(CATEGORY, CATEGORY_NOT_DIGIT)]),\n    r\"\\s\": (IN, [(CATEGORY, CATEGORY_SPACE)]),\n    r\"\\S\": (IN, [(CATEGORY, CATEGORY_NOT_SPACE)]),\n    r\"\\w\": (IN, [(CATEGORY, CATEGORY_WORD)]),\n    r\"\\W\": (IN, [(CATEGORY, CATEGORY_NOT_WORD)]),\n    r\"\\Z\": (AT, AT_END_STRING),  # end of string\n}\n\nFLAGS = {\n    # standard flags\n    \"i\": SRE_FLAG_IGNORECASE,\n    \"L\": SRE_FLAG_LOCALE,\n    \"m\": SRE_FLAG_MULTILINE,\n    \"s\": SRE_FLAG_DOTALL,\n    \"x\": SRE_FLAG_VERBOSE,\n    # extensions\n    \"t\": SRE_FLAG_TEMPLATE,\n    \"u\": SRE_FLAG_UNICODE,\n}\n\n\nclass Pattern:\n    # master pattern object.  keeps track of global attributes\n    def __init__(self):\n        self.flags = 0\n        self.open = []\n        self.groups = 1\n        self.groupdict = {}\n        self.lookbehind = 0\n\n    def opengroup(self, name=None):\n        gid = self.groups\n        self.groups = gid + 1\n        if name is not None:\n            ogid = self.groupdict.get(name, None)\n            if ogid is not None:\n                raise error((\"redefinition of group name %s as group %d; \"\n                             \"was group %d\" % (repr(name), gid, ogid)))\n            self.groupdict[name] = gid\n        self.open.append(gid)\n        return gid\n\n    def closegroup(self, gid):\n        self.open.remove(gid)\n\n    def checkgroup(self, gid):\n        return gid < self.groups and gid not in self.open\n\n\nclass SubPattern:\n    # a subpattern, in intermediate form\n    def __init__(self, pattern, data=None):\n        self.pattern = pattern\n        if data is None:\n            data = []\n        self.data = data\n        self.width = None\n\n    def __repr__(self):\n        return repr(self.data)\n\n    def __len__(self):\n        return len(self.data)\n\n    def __delitem__(self, index):\n        del self.data[index]\n\n    def __getitem__(self, index):\n        if isinstance(index, slice):\n            return SubPattern(self.pattern, self.data[index])\n        return self.data[index]\n\n    def __setitem__(self, index, code):\n        self.data[index] = code\n\n    def insert(self, index, code):\n        self.data.insert(index, code)\n\n    def append(self, code):\n        self.data.append(code)\n\n    def getwidth(self):\n        # determine the width (min, max) for this subpattern\n        if self.width:\n            return self.width\n        lo = hi = 0\n        UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)\n        REPEATCODES = (MIN_REPEAT, MAX_REPEAT)\n        for op, av in self.data:\n            if op is BRANCH:\n                i = MAXREPEAT - 1\n                j = 0\n                for av in av[1]:\n                    l, h = av.getwidth()\n                    i = min(i, l)\n                    j = max(j, h)\n                lo = lo + i\n                hi = hi + j\n            elif op is CALL:\n                i, j = av.getwidth()\n                lo = lo + i\n                hi = hi + j\n            elif op is SUBPATTERN:\n                i, j = av[1].getwidth()\n                lo = lo + i\n                hi = hi + j\n            elif op in REPEATCODES:\n                i, j = av[2].getwidth()\n                lo = lo + i * av[0]\n                hi = hi + j * av[1]\n            elif op in UNITCODES:\n                lo = lo + 1\n                hi = hi + 1\n            elif op == SUCCESS:\n                break\n        self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)\n        return self.width\n\n\nclass Tokenizer:\n    def __init__(self, string):\n        self.string = string\n        self.index = 0\n        self.__next()\n\n    def __next(self):\n        if self.index >= len(self.string):\n            self.next = None\n            return\n        char = self.string[self.index]\n        if char[0] == \"\\\\\":\n            try:\n                c = self.string[self.index + 1]\n            except IndexError:\n                raise error(\"bogus escape (end of line)\")\n            char = char + c\n        self.index = self.index + len(char)\n        self.next = char\n\n    def match(self, char, skip=1):\n        if char == self.next:\n            if skip:\n                self.__next()\n            return 1\n        return 0\n\n    def get(self):\n        this = self.next\n        self.__next()\n        return this\n\n    def tell(self):\n        return self.index, self.next\n\n    def seek(self, index):\n        self.index, self.next = index\n\n\ndef isident(char):\n    return \"a\" <= char <= \"z\" or \"A\" <= char <= \"Z\" or char == \"_\"\n\n\ndef isdigit(char):\n    return \"0\" <= char <= \"9\"\n\n\ndef isname(name):\n    # check that group name is a valid string\n    if not isident(name[0]):\n        return False\n    for char in name[1:]:\n        if not isident(char) and not isdigit(char):\n            return False\n    return True\n\n\ndef _class_escape(source, escape):\n    # handle escape code inside character class\n    code = ESCAPES.get(escape)\n    if code:\n        return code\n    code = CATEGORIES.get(escape)\n    if code and code[0] == IN:\n        return code\n    try:\n        c = escape[1:2]\n        if c == \"x\":\n            # hexadecimal escape (exactly two digits)\n            while source.next in HEXDIGITS and len(escape) < 4:\n                escape = escape + source.get()\n            escape = escape[2:]\n            if len(escape) != 2:\n                raise error(\"bogus escape: %s\" % repr(\"\\\\\" + escape))\n            return LITERAL, int(escape, 16) & 0xff\n        elif c in OCTDIGITS:\n            # octal escape (up to three digits)\n            while source.next in OCTDIGITS and len(escape) < 4:\n                escape = escape + source.get()\n            escape = escape[1:]\n            return LITERAL, int(escape, 8) & 0xff\n        elif c in DIGITS:\n            raise error(\"bogus escape: %s\" % repr(escape))\n        if len(escape) == 2:\n            return LITERAL, ord(escape[1])\n    except ValueError:\n        pass\n    raise error(\"bogus escape: %s\" % repr(escape))\n\n\ndef _escape(source, escape, state):\n    # handle escape code in expression\n    code = CATEGORIES.get(escape)\n    if code:\n        return code\n    code = ESCAPES.get(escape)\n    if code:\n        return code\n    try:\n        c = escape[1:2]\n        if c == \"x\":\n            # hexadecimal escape\n            while source.next in HEXDIGITS and len(escape) < 4:\n                escape = escape + source.get()\n            if len(escape) != 4:\n                raise ValueError\n            return LITERAL, int(escape[2:], 16) & 0xff\n        elif c == \"0\":\n            # octal escape\n            while source.next in OCTDIGITS and len(escape) < 4:\n                escape = escape + source.get()\n            return LITERAL, int(escape[1:], 8) & 0xff\n        elif c in DIGITS:\n            # octal escape *or* decimal group reference (sigh)\n            if source.next in DIGITS:\n                escape = escape + source.get()\n                if (escape[1] in OCTDIGITS and escape[2] in OCTDIGITS and\n                            source.next in OCTDIGITS):\n                    # got three octal digits; this is an octal escape\n                    escape = escape + source.get()\n                    return LITERAL, int(escape[1:], 8) & 0xff\n            # not an octal escape, so this is a group reference\n            group = int(escape[1:])\n            if group < state.groups:\n                if not state.checkgroup(group):\n                    raise error(\"cannot refer to open group\")\n                if state.lookbehind:\n                    import warnings\n                    warnings.warn('group references in lookbehind '\n                                  'assertions are not supported',\n                                  RuntimeWarning)\n                return GROUPREF, group\n            raise ValueError\n        if len(escape) == 2:\n            return LITERAL, ord(escape[1])\n    except ValueError:\n        pass\n    raise error(\"bogus escape: %s\" % repr(escape))\n\n\ndef _parse_sub(source, state, nested=1):\n    # parse an alternation: a|b|c\n\n    items = []\n    itemsappend = items.append\n    sourcematch = source.match\n    while 1:\n        itemsappend(_parse(source, state))\n        if sourcematch(\"|\"):\n            continue\n        if not nested:\n            break\n        if not source.next or sourcematch(\")\", 0):\n            break\n        else:\n            raise error(\"pattern not properly closed\")\n\n    if len(items) == 1:\n        return items[0]\n\n    subpattern = SubPattern(state)\n    subpatternappend = subpattern.append\n\n    # check if all items share a common prefix\n    while 1:\n        prefix = None\n        for item in items:\n            if not item:\n                break\n            if prefix is None:\n                prefix = item[0]\n            elif item[0] != prefix:\n                break\n        else:\n            # all subitems start with a common \"prefix\".\n            # move it out of the branch\n            for item in items:\n                del item[0]\n            subpatternappend(prefix)\n            continue  # check next one\n        break\n\n    # check if the branch can be replaced by a character set\n    for item in items:\n        if len(item) != 1 or item[0][0] != LITERAL:\n            break\n    else:\n        # we can store this as a character set instead of a\n        # branch (the compiler may optimize this even more)\n        set = []\n        setappend = set.append\n        for item in items:\n            setappend(item[0])\n        subpatternappend((IN, set))\n        return subpattern\n\n    subpattern.append((BRANCH, (None, items)))\n    return subpattern\n\n\ndef _parse_sub_cond(source, state, condgroup):\n    item_yes = _parse(source, state)\n    if source.match(\"|\"):\n        item_no = _parse(source, state)\n        if source.match(\"|\"):\n            raise error(\"conditional backref with more than two branches\")\n    else:\n        item_no = None\n    if source.next and not source.match(\")\", 0):\n        raise error(\"pattern not properly closed\")\n    subpattern = SubPattern(state)\n    subpattern.append((GROUPREF_EXISTS, (condgroup, item_yes, item_no)))\n    return subpattern\n\n\n_PATTERNENDERS = set(\"|)\")\n_ASSERTCHARS = set(\"=!<\")\n_LOOKBEHINDASSERTCHARS = set(\"=!\")\n_REPEATCODES = set([MIN_REPEAT, MAX_REPEAT])\n\n\ndef _parse(source, state):\n    # parse a simple pattern\n    subpattern = SubPattern(state)\n\n    # precompute constants into local variables\n    subpatternappend = subpattern.append\n    sourceget = source.get\n    sourcematch = source.match\n    _len = len\n    PATTERNENDERS = _PATTERNENDERS\n    ASSERTCHARS = _ASSERTCHARS\n    LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS\n    REPEATCODES = _REPEATCODES\n\n    while 1:\n\n        if source.next in PATTERNENDERS:\n            break  # end of subpattern\n        this = sourceget()\n        if this is None:\n            break  # end of pattern\n\n        if state.flags & SRE_FLAG_VERBOSE:\n            # skip whitespace and comments\n            if this in WHITESPACE:\n                continue\n            if this == \"#\":\n                while 1:\n                    this = sourceget()\n                    if this in (None, \"\\n\"):\n                        break\n                continue\n\n        if this and this[0] not in SPECIAL_CHARS:\n            subpatternappend((LITERAL, ord(this)))\n\n        elif this == \"[\":\n            # character set\n            set = []\n            setappend = set.append\n            ##          if sourcematch(\":\"):\n            ##              pass # handle character classes\n            if sourcematch(\"^\"):\n                setappend((NEGATE, None))\n            # check remaining characters\n            start = set[:]\n            while 1:\n                this = sourceget()\n                if this == \"]\" and set != start:\n                    break\n                elif this and this[0] == \"\\\\\":\n                    code1 = _class_escape(source, this)\n                elif this:\n                    code1 = LITERAL, ord(this)\n                else:\n                    raise error(\"unexpected end of regular expression\")\n                if sourcematch(\"-\"):\n                    # potential range\n                    this = sourceget()\n                    if this == \"]\":\n                        if code1[0] is IN:\n                            code1 = code1[1][0]\n                        setappend(code1)\n                        setappend((LITERAL, ord(\"-\")))\n                        break\n                    elif this:\n                        if this[0] == \"\\\\\":\n                            code2 = _class_escape(source, this)\n                        else:\n                            code2 = LITERAL, ord(this)\n                        if code1[0] != LITERAL or code2[0] != LITERAL:\n                            raise error(\"bad character range\")\n                        lo = code1[1]\n                        hi = code2[1]\n                        if hi < lo:\n                            raise error(\"bad character range\")\n                        setappend((RANGE, (lo, hi)))\n                    else:\n                        raise error(\"unexpected end of regular expression\")\n                else:\n                    if code1[0] is IN:\n                        code1 = code1[1][0]\n                    setappend(code1)\n\n            # XXX: <fl> should move set optimization to compiler!\n            if _len(set) == 1 and set[0][0] is LITERAL:\n                subpatternappend(set[0])  # optimization\n            elif _len(set) == 2 and set[0][0] is NEGATE and set[1][0] is LITERAL:\n                subpatternappend((NOT_LITERAL, set[1][1]))  # optimization\n            else:\n                # XXX: <fl> should add charmap optimization here\n                subpatternappend((IN, set))\n\n        elif this and this[0] in REPEAT_CHARS:\n            # repeat previous item\n            if this == \"?\":\n                min, max = 0, 1\n            elif this == \"*\":\n                min, max = 0, MAXREPEAT\n\n            elif this == \"+\":\n                min, max = 1, MAXREPEAT\n            elif this == \"{\":\n                if source.next == \"}\":\n                    subpatternappend((LITERAL, ord(this)))\n                    continue\n                here = source.tell()\n                min, max = 0, MAXREPEAT\n                lo = hi = \"\"\n                while source.next in DIGITS:\n                    lo = lo + source.get()\n                if sourcematch(\",\"):\n                    while source.next in DIGITS:\n                        hi = hi + sourceget()\n                else:\n                    hi = lo\n                if not sourcematch(\"}\"):\n                    subpatternappend((LITERAL, ord(this)))\n                    source.seek(here)\n                    continue\n                if lo:\n                    min = int(lo)\n                    if min >= MAXREPEAT:\n                        raise OverflowError(\"the repetition number is too large\")\n                if hi:\n                    max = int(hi)\n                    if max >= MAXREPEAT:\n                        raise OverflowError(\"the repetition number is too large\")\n                    if max < min:\n                        raise error(\"bad repeat interval\")\n            else:\n                raise error(\"not supported\")\n            # figure out which item to repeat\n            if subpattern:\n                item = subpattern[-1:]\n            else:\n                item = None\n            if not item or (_len(item) == 1 and item[0][0] == AT):\n                raise error(\"nothing to repeat\")\n            if item[0][0] in REPEATCODES:\n                raise error(\"multiple repeat\")\n            if sourcematch(\"?\"):\n                subpattern[-1] = (MIN_REPEAT, (min, max, item))\n            else:\n                subpattern[-1] = (MAX_REPEAT, (min, max, item))\n\n        elif this == \".\":\n            subpatternappend((ANY, None))\n\n        elif this == \"(\":\n            group = 1\n            name = None\n            condgroup = None\n            if sourcematch(\"?\"):\n                group = 0\n                # options\n                if sourcematch(\"P\"):\n                    # python extensions\n                    if sourcematch(\"<\"):\n                        # named group: skip forward to end of name\n                        name = \"\"\n                        while 1:\n                            char = sourceget()\n                            if char is None:\n                                raise error(\"unterminated name\")\n                            if char == \">\":\n                                break\n                            name = name + char\n                        group = 1\n                        if not name:\n                            raise error(\"missing group name\")\n                        if not isname(name):\n                            raise error(\"bad character in group name %r\" %\n                                        name)\n                    elif sourcematch(\"=\"):\n                        # named backreference\n                        name = \"\"\n                        while 1:\n                            char = sourceget()\n                            if char is None:\n                                raise error(\"unterminated name\")\n                            if char == \")\":\n                                break\n                            name = name + char\n                        if not name:\n                            raise error(\"missing group name\")\n                        if not isname(name):\n                            raise error(\"bad character in backref group name \"\n                                        \"%r\" % name)\n                        gid = state.groupdict.get(name)\n                        if gid is None:\n                            msg = \"unknown group name: {0!r}\".format(name)\n                            raise error(msg)\n                        if state.lookbehind:\n                            import warnings\n                            warnings.warn('group references in lookbehind '\n                                          'assertions are not supported',\n                                          RuntimeWarning)\n                        subpatternappend((GROUPREF, gid))\n                        continue\n                    else:\n                        char = sourceget()\n                        if char is None:\n                            raise error(\"unexpected end of pattern\")\n                        raise error(\"unknown specifier: ?P%s\" % char)\n                elif sourcematch(\":\"):\n                    # non-capturing group\n                    group = 2\n                elif sourcematch(\"#\"):\n                    # comment\n                    while 1:\n                        if source.next is None or source.next == \")\":\n                            break\n                        sourceget()\n                    if not sourcematch(\")\"):\n                        raise error(\"unbalanced parenthesis\")\n                    continue\n                elif source.next in ASSERTCHARS:\n                    # lookahead assertions\n                    char = sourceget()\n                    dir = 1\n                    if char == \"<\":\n                        if source.next not in LOOKBEHINDASSERTCHARS:\n                            raise error(\"syntax error\")\n                        dir = -1  # lookbehind\n                        char = sourceget()\n                        state.lookbehind += 1\n                    p = _parse_sub(source, state)\n                    if dir < 0:\n                        state.lookbehind -= 1\n                    if not sourcematch(\")\"):\n                        raise error(\"unbalanced parenthesis\")\n                    if char == \"=\":\n                        subpatternappend((ASSERT, (dir, p)))\n                    else:\n                        subpatternappend((ASSERT_NOT, (dir, p)))\n                    continue\n                elif sourcematch(\"(\"):\n                    # conditional backreference group\n                    condname = \"\"\n                    while 1:\n                        char = sourceget()\n                        if char is None:\n                            raise error(\"unterminated name\")\n                        if char == \")\":\n                            break\n                        condname = condname + char\n                    group = 2\n                    if not condname:\n                        raise error(\"missing group name\")\n                    if isname(condname):\n                        condgroup = state.groupdict.get(condname)\n                        if condgroup is None:\n                            msg = \"unknown group name: {0!r}\".format(condname)\n                            raise error(msg)\n                    else:\n                        try:\n                            condgroup = int(condname)\n                        except ValueError:\n                            raise error(\"bad character in group name\")\n                    if state.lookbehind:\n                        import warnings\n                        warnings.warn('group references in lookbehind '\n                                      'assertions are not supported',\n                                      RuntimeWarning)\n                else:\n                    # flags\n                    if not source.next in FLAGS:\n                        raise error(\"unexpected end of pattern\")\n                    while source.next in FLAGS:\n                        state.flags = state.flags | FLAGS[sourceget()]\n            if group:\n                # parse group contents\n                if group == 2:\n                    # anonymous group\n                    group = None\n                else:\n                    group = state.opengroup(name)\n                if condgroup:\n                    p = _parse_sub_cond(source, state, condgroup)\n                else:\n                    p = _parse_sub(source, state)\n                if not sourcematch(\")\"):\n                    raise error(\"unbalanced parenthesis\")\n                if group is not None:\n                    state.closegroup(group)\n                subpatternappend((SUBPATTERN, (group, p)))\n            else:\n                while 1:\n                    char = sourceget()\n                    if char is None:\n                        raise error(\"unexpected end of pattern\")\n                    if char == \")\":\n                        break\n                    raise error(\"unknown extension\")\n\n        elif this == \"^\":\n            subpatternappend((AT, AT_BEGINNING))\n\n        elif this == \"$\":\n            subpattern.append((AT, AT_END))\n\n        elif this and this[0] == \"\\\\\":\n            code = _escape(source, this, state)\n            subpatternappend(code)\n\n        else:\n            raise error(\"parser error\")\n\n    return subpattern\n\n\ndef parse(str, flags=0, pattern=None):\n    # parse 're' pattern into list of (opcode, argument) tuples\n\n    source = Tokenizer(str)\n\n    if pattern is None:\n        pattern = Pattern()\n    pattern.flags = flags\n    pattern.str = str\n\n    p = _parse_sub(source, pattern, 0)\n\n    tail = source.get()\n    if tail == \")\":\n        raise error(\"unbalanced parenthesis\")\n    elif tail:\n        raise error(\"bogus characters at end of regular expression\")\n\n    if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:\n        # the VERBOSE flag was switched on inside the pattern.  to be\n        # on the safe side, we'll parse the whole thing again...\n        return parse(str, p.pattern.flags)\n\n    if flags & SRE_FLAG_DEBUG:\n        p.dump()\n\n    return p\n\n\ndef parse_template(source, pattern):\n    # parse 're' replacement string into list of literals and\n    # group references\n    s = Tokenizer(source)\n    sget = s.get\n    p = []\n    a = p.append\n\n    def literal(literal, p=p, pappend=a):\n        if p and p[-1][0] is LITERAL:\n            p[-1] = LITERAL, p[-1][1] + literal\n        else:\n            pappend((LITERAL, literal))\n\n    sep = source[:0]\n    if type(sep) is type(\"\"):\n        makechar = chr\n    else:\n        makechar = unichr\n    while 1:\n        this = sget()\n        if this is None:\n            break  # end of replacement string\n        if this and this[0] == \"\\\\\":\n            # group\n            c = this[1:2]\n            if c == \"g\":\n                name = \"\"\n                if s.match(\"<\"):\n                    while 1:\n                        char = sget()\n                        if char is None:\n                            raise error(\"unterminated group name\")\n                        if char == \">\":\n                            break\n                        name = name + char\n                if not name:\n                    raise error(\"missing group name\")\n                try:\n                    index = int(name)\n                    if index < 0:\n                        raise error(\"negative group number\")\n                except ValueError:\n                    if not isname(name):\n                        raise error(\"bad character in group name\")\n                    try:\n                        index = pattern.groupindex[name]\n                    except KeyError:\n                        msg = \"unknown group name: {0!r}\".format(name)\n                        raise IndexError(msg)\n                a((MARK, index))\n            elif c == \"0\":\n                if s.next in OCTDIGITS:\n                    this = this + sget()\n                    if s.next in OCTDIGITS:\n                        this = this + sget()\n                literal(makechar(int(this[1:], 8) & 0xff))\n            elif c in DIGITS:\n                isoctal = False\n                if s.next in DIGITS:\n                    this = this + sget()\n                    if (c in OCTDIGITS and this[2] in OCTDIGITS and\n                                s.next in OCTDIGITS):\n                        this = this + sget()\n                        isoctal = True\n                        literal(makechar(int(this[1:], 8) & 0xff))\n                if not isoctal:\n                    a((MARK, int(this[1:])))\n            else:\n                try:\n                    this = makechar(ESCAPES[this][1])\n                except KeyError:\n                    pass\n                literal(this)\n        else:\n            literal(this)\n    # convert template to groups and literals lists\n    i = 0\n    groups = []\n    groupsappend = groups.append\n    literals = [None] * len(p)\n    for c, s in p:\n        if c is MARK:\n            groupsappend((i, s))\n            # literal[i] is already None\n        else:\n            literals[i] = s\n        i = i + 1\n    return groups, literals\n\n\ndef expand_template(template, match):\n    g = match.group\n    sep = match.string[:0]\n    groups, literals = template\n    literals = literals[:]\n    try:\n        for index, group in groups:\n            literals[index] = s = g(group)\n            if s is None:\n                raise error(\"unmatched group\")\n    except IndexError:\n        raise error(\"invalid group reference\")\n    return sep.join(literals)\n", "description": "Nginx configuration static analyzer", "file_name": "sre_parse.py", "id": "ae9936db3704973436f02e135cb7db33", "language": "Python", "project_name": "gixy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/yandex-gixy/yandex-gixy-86b5e60/gixy/core/sre_parse/sre_parse.py", "save_time": "", "source": "", "update_at": "2018-03-17T23:01:42Z", "url": "https://github.com/yandex/gixy", "wiki": true}