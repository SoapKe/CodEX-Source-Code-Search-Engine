{"author": "HelloZeroNet", "code": "\n This file is part of pyasn1 software.\n\n Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>\n License: http://pyasn1.sf.net/license.html\n\nfrom pyasn1.type import univ\nfrom pyasn1.codec.cer import encoder\nfrom pyasn1 import error\n\n__all__ = ['encode']\n\n\nclass SetOfEncoder(encoder.SetOfEncoder):\n    @staticmethod\n    def _cmpSetComponents(c1, c2):\n        tagSet1 = isinstance(c1, univ.Choice) and c1.effectiveTagSet or c1.tagSet\n        tagSet2 = isinstance(c2, univ.Choice) and c2.effectiveTagSet or c2.tagSet\n        return cmp(tagSet1, tagSet2)\n\n\ntagMap = encoder.tagMap.copy()\ntagMap.update({\n     Overload CER encoders with BER ones (a bit hackerish XXX)\n    univ.BitString.tagSet: encoder.encoder.BitStringEncoder(),\n    univ.OctetString.tagSet: encoder.encoder.OctetStringEncoder(),\n     Set & SetOf have same tags\n    univ.SetOf().tagSet: SetOfEncoder()\n})\n\ntypeMap = encoder.typeMap.copy()\n\n\nclass Encoder(encoder.Encoder):\n    supportIndefLength = False\n\n    def __call__(self, client, defMode=True, maxChunkSize=0):\n        if not defMode or maxChunkSize:\n            raise error.PyAsn1Error('DER forbids indefinite length mode')\n        return encoder.Encoder.__call__(self, client, defMode, maxChunkSize)\n\n: Turns ASN.1 object into DER octet stream.\n:\n: Takes any ASN.1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n: walks all its components recursively and produces a DER octet stream.\n:\n: Parameters\n: ----------\n  value: any pyasn1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n:     A pyasn1 object to encode\n:\n: defMode: :py:class:`bool`\n:     If `False`, produces indefinite length encoding\n:\n: maxChunkSize: :py:class:`int`\n:     Maximum chunk size in chunked encoding mode (0 denotes unlimited chunk size)\n:\n: Returns\n: -------\n: : :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n:     Given ASN.1 object encoded into BER octetstream\n:\n: Raises\n: ------\n: : :py:class:`pyasn1.error.PyAsn1Error`\n:     On encoding errors\nencode = Encoder(tagMap, typeMap)\n", "comments": "     this file part pyasn1 software        copyright (c) 2005 2017  ilya etingof  etingof gmail com     license  http   pyasn1 sf net license html       overload cer encoders ber ones (a bit hackerish xxx)    set   setof tags     turns asn 1 object der octet stream          takes asn 1 object (e g   py class   pyasn1 type base pyasn1item  derivative)     walks components recursively produces der octet stream          parameters                    value  pyasn1 object (e g   py class   pyasn1 type base pyasn1item  derivative)         a pyasn1 object encode         defmode   py class  bool          if  false   produces indefinite length encoding         maxchunksize   py class  int          maximum chunk size chunked encoding mode (0 denotes unlimited chunk size)         returns                    py class  bytes  (python 3)  py class  str  (python 2)         given asn 1 object encoded ber octetstream         raises                   py class  pyasn1 error pyasn1error          on encoding errors ", "content": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>\n# License: http://pyasn1.sf.net/license.html\n#\nfrom pyasn1.type import univ\nfrom pyasn1.codec.cer import encoder\nfrom pyasn1 import error\n\n__all__ = ['encode']\n\n\nclass SetOfEncoder(encoder.SetOfEncoder):\n    @staticmethod\n    def _cmpSetComponents(c1, c2):\n        tagSet1 = isinstance(c1, univ.Choice) and c1.effectiveTagSet or c1.tagSet\n        tagSet2 = isinstance(c2, univ.Choice) and c2.effectiveTagSet or c2.tagSet\n        return cmp(tagSet1, tagSet2)\n\n\ntagMap = encoder.tagMap.copy()\ntagMap.update({\n    # Overload CER encoders with BER ones (a bit hackerish XXX)\n    univ.BitString.tagSet: encoder.encoder.BitStringEncoder(),\n    univ.OctetString.tagSet: encoder.encoder.OctetStringEncoder(),\n    # Set & SetOf have same tags\n    univ.SetOf().tagSet: SetOfEncoder()\n})\n\ntypeMap = encoder.typeMap.copy()\n\n\nclass Encoder(encoder.Encoder):\n    supportIndefLength = False\n\n    def __call__(self, client, defMode=True, maxChunkSize=0):\n        if not defMode or maxChunkSize:\n            raise error.PyAsn1Error('DER forbids indefinite length mode')\n        return encoder.Encoder.__call__(self, client, defMode, maxChunkSize)\n\n#: Turns ASN.1 object into DER octet stream.\n#:\n#: Takes any ASN.1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#: walks all its components recursively and produces a DER octet stream.\n#:\n#: Parameters\n#: ----------\n#  value: any pyasn1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     A pyasn1 object to encode\n#:\n#: defMode: :py:class:`bool`\n#:     If `False`, produces indefinite length encoding\n#:\n#: maxChunkSize: :py:class:`int`\n#:     Maximum chunk size in chunked encoding mode (0 denotes unlimited chunk size)\n#:\n#: Returns\n#: -------\n#: : :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n#:     Given ASN.1 object encoded into BER octetstream\n#:\n#: Raises\n#: ------\n#: : :py:class:`pyasn1.error.PyAsn1Error`\n#:     On encoding errors\nencode = Encoder(tagMap, typeMap)\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "encoder.py", "id": "0440745b9f3ba57d91aec5013a36d177", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/lib/pyasn1/codec/der/encoder.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}