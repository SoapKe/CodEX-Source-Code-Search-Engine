{"author": "HelloZeroNet", "code": "import sys\nimport logging\nimport os\nimport ssl\nimport hashlib\n\nfrom Config import config\nfrom util import SslPatch\nfrom util import helper\n\n\nclass CryptConnectionManager:\n    def __init__(self):\n        \n        if sys.platform.startswith(\"win\"):\n            self.openssl_bin = \"src\\\\lib\\\\opensslVerify\\\\openssl.exe\"\n        else:\n            self.openssl_bin = \"openssl\"\n        self.openssl_env = {\"OPENSSL_CONF\": \"src/lib/opensslVerify/openssl.cnf\"}\n\n        self.crypt_supported = []  \n\n    \n    \n    def selectCrypt(self, client_supported):\n        for crypt in self.crypt_supported:\n            if crypt in client_supported:\n                return crypt\n        return False\n\n    \n    \n    def wrapSocket(self, sock, crypt, server=False, cert_pin=None):\n        if crypt == \"tls-rsa\":\n            ciphers = \"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:AES128-GCM-SHA256:AES128-SHA256:HIGH:\"\n            ciphers += \"!aNULL:!eNULL:!EXPORT:!DSS:!DES:!RC4:!3DES:!MD5:!PSK\"\n            if server:\n                sock_wrapped = ssl.wrap_socket(\n                    sock, server_side=server, keyfile='%s/key-rsa.pem' % config.data_dir,\n                    certfile='%s/cert-rsa.pem' % config.data_dir, ciphers=ciphers)\n            else:\n                sock_wrapped = ssl.wrap_socket(sock, ciphers=ciphers)\n            if cert_pin:\n                cert_hash = hashlib.sha256(sock_wrapped.getpeercert(True)).hexdigest()\n                assert cert_hash == cert_pin, \"Socket certificate does not match (%s != %s)\" % (cert_hash, cert_pin)\n            return sock_wrapped\n        else:\n            return sock\n\n    def removeCerts(self):\n        if config.keep_ssl_cert:\n            return False\n        for file_name in [\"cert-rsa.pem\", \"key-rsa.pem\"]:\n            file_path = \"%s/%s\" % (config.data_dir, file_name)\n            if os.path.isfile(file_path):\n                os.unlink(file_path)\n\n    \n    def loadCerts(self):\n        if config.disable_encryption:\n            return False\n\n        if self.createSslRsaCert():\n            self.crypt_supported.append(\"tls-rsa\")\n\n    # Try to create RSA server cert + sign for connection encryption\n    \n    def createSslRsaCert(self):\n        if os.path.isfile(\"%s/cert-rsa.pem\" % config.data_dir) and os.path.isfile(\"%s/key-rsa.pem\" % config.data_dir):\n            return True  \n\n        import subprocess\n        cmd = \"%s req -x509 -newkey rsa:2048 -sha256 -batch -keyout %s -out %s -nodes -config %s\" % helper.shellquote(\n            self.openssl_bin,\n            config.data_dir+\"/key-rsa.pem\",\n            config.data_dir+\"/cert-rsa.pem\",\n            self.openssl_env[\"OPENSSL_CONF\"]\n        )\n        proc = subprocess.Popen(\n            cmd.encode(sys.getfilesystemencoding()),\n            shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=self.openssl_env\n        )\n        back = proc.stdout.read().strip()\n        proc.wait()\n        logging.debug(\"Generating RSA cert and key PEM files...%s\" % back)\n\n        if os.path.isfile(\"%s/cert-rsa.pem\" % config.data_dir) and os.path.isfile(\"%s/key-rsa.pem\" % config.data_dir):\n            return True\n        else:\n            logging.error(\"RSA ECC SSL cert generation failed, cert or key files not exist.\")\n            return False\n\n    \n    \"\"\"def createSslEccCert(self):\n        return False\n        import subprocess\n\n        \n        proc = subprocess.Popen(\n            \"%s ecparam -name prime256v1 -genkey -out %s/key-ecc.pem\" % (self.openssl_bin, config.data_dir),\n            shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=self.openssl_env\n        )\n        back = proc.stdout.read().strip()\n        proc.wait()\n        self.log.debug(\"Generating ECC privatekey PEM file...%s\" % back)\n\n        \n        proc = subprocess.Popen(\n            \"%s req -new -key %s -x509 -nodes -out %s -config %s\" % helper.shellquote(\n                self.openssl_bin,\n                config.data_dir+\"/key-ecc.pem\",\n                config.data_dir+\"/cert-ecc.pem\",\n                self.openssl_env[\"OPENSSL_CONF\"]\n            ),\n            shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=self.openssl_env\n        )\n        back = proc.stdout.read().strip()\n        proc.wait()\n        self.log.debug(\"Generating ECC cert PEM file...%s\" % back)\n\n        if os.path.isfile(\"%s/cert-ecc.pem\" % config.data_dir) and os.path.isfile(\"%s/key-ecc.pem\" % config.data_dir):\n            return True\n        else:\n            self.logging.error(\"ECC SSL cert generation failed, cert or key files not exits.\")\n            return False\n    \"\"\"\n\nmanager = CryptConnectionManager()\n", "comments": "   def createsslecccert(self)          return false         import subprocess            create ecc privatekey         proc   subprocess popen(               ecparam  name prime256v1  genkey   key ecc pem    (self openssl bin  config data dir)              shell true  stderr subprocess stdout  stdout subprocess pipe  env self openssl env         )         back   proc stdout read() strip()         proc wait()         self log debug( generating ecc privatekey pem file       back)            create ecc cert         proc   subprocess popen(               req  new  key   x509  nodes    config     helper shellquote(                 self openssl bin                  config data dir   key ecc pem                   config data dir   cert ecc pem                   self openssl env  openssl conf               )              shell true  stderr subprocess stdout  stdout subprocess pipe  env self openssl env         )         back   proc stdout read() strip()         proc wait()         self log debug( generating ecc cert pem file       back)          os path isfile(  cert ecc pem    config data dir) os path isfile(  key ecc pem    config data dir)              return true         else              self logging error( ecc ssl cert generation failed  cert key files exits  )             return false            openssl params    supported cryptos    select crypt supported sides    return  name crypto    wrap socket crypt    return  wrapped socket    load create cert files necessary    try create rsa server cert   sign connection encryption    return  true success    files already exits    not used yet  missing platform    create ecc privatekey    create ecc cert ", "content": "import sys\nimport logging\nimport os\nimport ssl\nimport hashlib\n\nfrom Config import config\nfrom util import SslPatch\nfrom util import helper\n\n\nclass CryptConnectionManager:\n    def __init__(self):\n        # OpenSSL params\n        if sys.platform.startswith(\"win\"):\n            self.openssl_bin = \"src\\\\lib\\\\opensslVerify\\\\openssl.exe\"\n        else:\n            self.openssl_bin = \"openssl\"\n        self.openssl_env = {\"OPENSSL_CONF\": \"src/lib/opensslVerify/openssl.cnf\"}\n\n        self.crypt_supported = []  # Supported cryptos\n\n    # Select crypt that supported by both sides\n    # Return: Name of the crypto\n    def selectCrypt(self, client_supported):\n        for crypt in self.crypt_supported:\n            if crypt in client_supported:\n                return crypt\n        return False\n\n    # Wrap socket for crypt\n    # Return: wrapped socket\n    def wrapSocket(self, sock, crypt, server=False, cert_pin=None):\n        if crypt == \"tls-rsa\":\n            ciphers = \"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:AES128-GCM-SHA256:AES128-SHA256:HIGH:\"\n            ciphers += \"!aNULL:!eNULL:!EXPORT:!DSS:!DES:!RC4:!3DES:!MD5:!PSK\"\n            if server:\n                sock_wrapped = ssl.wrap_socket(\n                    sock, server_side=server, keyfile='%s/key-rsa.pem' % config.data_dir,\n                    certfile='%s/cert-rsa.pem' % config.data_dir, ciphers=ciphers)\n            else:\n                sock_wrapped = ssl.wrap_socket(sock, ciphers=ciphers)\n            if cert_pin:\n                cert_hash = hashlib.sha256(sock_wrapped.getpeercert(True)).hexdigest()\n                assert cert_hash == cert_pin, \"Socket certificate does not match (%s != %s)\" % (cert_hash, cert_pin)\n            return sock_wrapped\n        else:\n            return sock\n\n    def removeCerts(self):\n        if config.keep_ssl_cert:\n            return False\n        for file_name in [\"cert-rsa.pem\", \"key-rsa.pem\"]:\n            file_path = \"%s/%s\" % (config.data_dir, file_name)\n            if os.path.isfile(file_path):\n                os.unlink(file_path)\n\n    # Load and create cert files is necessary\n    def loadCerts(self):\n        if config.disable_encryption:\n            return False\n\n        if self.createSslRsaCert():\n            self.crypt_supported.append(\"tls-rsa\")\n\n    # Try to create RSA server cert + sign for connection encryption\n    # Return: True on success\n    def createSslRsaCert(self):\n        if os.path.isfile(\"%s/cert-rsa.pem\" % config.data_dir) and os.path.isfile(\"%s/key-rsa.pem\" % config.data_dir):\n            return True  # Files already exits\n\n        import subprocess\n        cmd = \"%s req -x509 -newkey rsa:2048 -sha256 -batch -keyout %s -out %s -nodes -config %s\" % helper.shellquote(\n            self.openssl_bin,\n            config.data_dir+\"/key-rsa.pem\",\n            config.data_dir+\"/cert-rsa.pem\",\n            self.openssl_env[\"OPENSSL_CONF\"]\n        )\n        proc = subprocess.Popen(\n            cmd.encode(sys.getfilesystemencoding()),\n            shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=self.openssl_env\n        )\n        back = proc.stdout.read().strip()\n        proc.wait()\n        logging.debug(\"Generating RSA cert and key PEM files...%s\" % back)\n\n        if os.path.isfile(\"%s/cert-rsa.pem\" % config.data_dir) and os.path.isfile(\"%s/key-rsa.pem\" % config.data_dir):\n            return True\n        else:\n            logging.error(\"RSA ECC SSL cert generation failed, cert or key files not exist.\")\n            return False\n\n    # Not used yet: Missing on some platform\n    \"\"\"def createSslEccCert(self):\n        return False\n        import subprocess\n\n        # Create ECC privatekey\n        proc = subprocess.Popen(\n            \"%s ecparam -name prime256v1 -genkey -out %s/key-ecc.pem\" % (self.openssl_bin, config.data_dir),\n            shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=self.openssl_env\n        )\n        back = proc.stdout.read().strip()\n        proc.wait()\n        self.log.debug(\"Generating ECC privatekey PEM file...%s\" % back)\n\n        # Create ECC cert\n        proc = subprocess.Popen(\n            \"%s req -new -key %s -x509 -nodes -out %s -config %s\" % helper.shellquote(\n                self.openssl_bin,\n                config.data_dir+\"/key-ecc.pem\",\n                config.data_dir+\"/cert-ecc.pem\",\n                self.openssl_env[\"OPENSSL_CONF\"]\n            ),\n            shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=self.openssl_env\n        )\n        back = proc.stdout.read().strip()\n        proc.wait()\n        self.log.debug(\"Generating ECC cert PEM file...%s\" % back)\n\n        if os.path.isfile(\"%s/cert-ecc.pem\" % config.data_dir) and os.path.isfile(\"%s/key-ecc.pem\" % config.data_dir):\n            return True\n        else:\n            self.logging.error(\"ECC SSL cert generation failed, cert or key files not exits.\")\n            return False\n    \"\"\"\n\nmanager = CryptConnectionManager()\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "CryptConnection.py", "id": "3e3378d6fce97606e1373d3b17f49085", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/Crypt/CryptConnection.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}