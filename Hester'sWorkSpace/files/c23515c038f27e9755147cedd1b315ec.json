{"author": "jakubroztocil", "code": "import json\nimport sys\n\nimport requests\nfrom requests.adapters import HTTPAdapter\nfrom requests.structures import CaseInsensitiveDict\n\nfrom httpie import sessions\nfrom httpie import __version__\nfrom httpie.compat import str\nfrom httpie.input import SSL_VERSION_ARG_MAPPING\nfrom httpie.plugins import plugin_manager\nfrom httpie.utils import repr_dict_nice\n\ntry:\n    \n    \n    import urllib3\n    urllib3.disable_warnings()\nexcept (ImportError, AttributeError):\n    \n    \n    \n    \n    pass\n\n\nFORM_CONTENT_TYPE = 'application/x-www-form-urlencoded; charset=utf-8'\nJSON_CONTENT_TYPE = 'application/json'\nJSON_ACCEPT = '{0}, */*'.format(JSON_CONTENT_TYPE)\nDEFAULT_UA = 'HTTPie/%s' % __version__\n\n\nclass HTTPieHTTPAdapter(HTTPAdapter):\n\n    def __init__(self, ssl_version=None, **kwargs):\n        self._ssl_version = ssl_version\n        super(HTTPieHTTPAdapter, self).__init__(**kwargs)\n\n    def init_poolmanager(self, *args, **kwargs):\n        kwargs['ssl_version'] = self._ssl_version\n        super(HTTPieHTTPAdapter, self).init_poolmanager(*args, **kwargs)\n\n\ndef get_requests_session(ssl_version):\n    requests_session = requests.Session()\n    requests_session.mount(\n        'https://',\n        HTTPieHTTPAdapter(ssl_version=ssl_version)\n    )\n    for cls in plugin_manager.get_transport_plugins():\n        transport_plugin = cls()\n        requests_session.mount(prefix=transport_plugin.prefix,\n                               adapter=transport_plugin.get_adapter())\n    return requests_session\n\n\ndef get_response(args, config_dir):\n    \n    \n    data = args.data\n    auto_json = data and not args.form\n    if (args.json or auto_json) and isinstance(data, dict):\n        if data:\n            data = json.dumps(data)\n        else:\n            \n            \n            data = ''\n\n    \n    headers = get_default_headers(args)\n    if base_headers:\n        headers.update(base_headers)\n    headers.update(args.headers)\n    headers = finalize_headers(headers)\n\n    cert = None\n    if args.cert:\n        cert = args.cert\n        if args.cert_key:\n            cert = cert, args.cert_key\n\n    kwargs = {\n        'stream': True,\n        'method': args.method.lower(),\n        'url': args.url,\n        'headers': headers,\n        'data': data,\n        'verify': {\n            'yes': True,\n            'true': True,\n            'no': False,\n            'false': False,\n        }.get(args.verify.lower(), args.verify),\n        'cert': cert,\n        'timeout': args.timeout,\n        'auth': args.auth,\n        'proxies': {p.key: p.value for p in args.proxy},\n        'files': args.files,\n        'allow_redirects': args.follow,\n        'params': args.params,\n    }\n\n    return kwargs\n", "comments": "Send the request and return a `request.Response`.\"\"\"\n\n    ssl_version = None\n    if args.ssl_version:\n        ssl_version = SSL_VERSION_ARG_MAPPING[args.ssl_version]\n\n    requests_session = get_requests_session(ssl_version)\n    requests_session.max_redirects = args.max_redirects\n\n    if not args.session and not args.session_read_only:\n        kwargs = get_requests_kwargs(args)\n        if args.debug:\n            dump_request(kwargs)\n        response = requests_session.request(**kwargs)\n    else:\n        response = sessions.get_response(\n            requests_session=requests_session,\n            args=args,\n            config_dir=config_dir,\n            session_name=args.session or args.session_read_only,\n            read_only=bool(args.session_read_only),\n        )\n\n    return response\n\n\ndef dump_request(kwargs):\n    sys.stderr.write('\\n>>> requests.request(**%s)\\n\\n'\n                     % repr_dict_nice(kwargs))\n\n\ndef finalize_headers(headers):\n    final_headers = {}\n    for name, value in headers.items():\n        if value is not None:\n\n            # >leading or trailing LWS MAY be removed without\n            # >changing the semantics of the field value\"\n            # -https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html\n            # Also, requests raises `InvalidHeader` for leading spaces.\n            value = value.strip()\n\n            if isinstance(value, str):\n                # See: https://github.com/jakubroztocil/httpie/issues/212\n                value = value.encode('utf8')\n\n        final_headers[name] = value\n    return final_headers\n\n\ndef get_default_headers(args):\n    default_headers = CaseInsensitiveDict({\n        'User-Agent': DEFAULT_UA\n    })\n\n    auto_json = args.data and not args.form\n    if args.json or auto_json:\n        default_headers['Accept'] = JSON_ACCEPT\n        if args.json or (auto_json and args.data):\n            default_headers['Content-Type'] = JSON_CONTENT_TYPE\n\n    elif args.form and not args.files:\n        # If sending files, `requests` will set\n        # the `Content-Type` for us.\n        default_headers['Content-Type'] = FORM_CONTENT_TYPE\n    return default_headers\n\n\ndef get_requests_kwargs(args, base_headers=None):\n    \"\"\"\n    Translate our `args` into `requests.request` keyword arguments.\n\n    \n \n# https://urllib3.readthedocs.io/en/latest/security.html\n# noinspection PyPackageRequirements\n# In some rare cases, the user may have an old version of the requests\n# or urllib3, and there is no method called \"disable_warnings.\" In these\n# cases, we don't need to call the method.\n# They may get some noisy output but execution shouldn't die. Move on.\n# Serialize JSON data, if needed.\n# We need to set data to an empty string to prevent requests\n# from assigning an empty list to `response.request.data`.\n# Finalize headers.\n", "content": "import json\nimport sys\n\nimport requests\nfrom requests.adapters import HTTPAdapter\nfrom requests.structures import CaseInsensitiveDict\n\nfrom httpie import sessions\nfrom httpie import __version__\nfrom httpie.compat import str\nfrom httpie.input import SSL_VERSION_ARG_MAPPING\nfrom httpie.plugins import plugin_manager\nfrom httpie.utils import repr_dict_nice\n\ntry:\n    # https://urllib3.readthedocs.io/en/latest/security.html\n    # noinspection PyPackageRequirements\n    import urllib3\n    urllib3.disable_warnings()\nexcept (ImportError, AttributeError):\n    # In some rare cases, the user may have an old version of the requests\n    # or urllib3, and there is no method called \"disable_warnings.\" In these\n    # cases, we don't need to call the method.\n    # They may get some noisy output but execution shouldn't die. Move on.\n    pass\n\n\nFORM_CONTENT_TYPE = 'application/x-www-form-urlencoded; charset=utf-8'\nJSON_CONTENT_TYPE = 'application/json'\nJSON_ACCEPT = '{0}, */*'.format(JSON_CONTENT_TYPE)\nDEFAULT_UA = 'HTTPie/%s' % __version__\n\n\nclass HTTPieHTTPAdapter(HTTPAdapter):\n\n    def __init__(self, ssl_version=None, **kwargs):\n        self._ssl_version = ssl_version\n        super(HTTPieHTTPAdapter, self).__init__(**kwargs)\n\n    def init_poolmanager(self, *args, **kwargs):\n        kwargs['ssl_version'] = self._ssl_version\n        super(HTTPieHTTPAdapter, self).init_poolmanager(*args, **kwargs)\n\n\ndef get_requests_session(ssl_version):\n    requests_session = requests.Session()\n    requests_session.mount(\n        'https://',\n        HTTPieHTTPAdapter(ssl_version=ssl_version)\n    )\n    for cls in plugin_manager.get_transport_plugins():\n        transport_plugin = cls()\n        requests_session.mount(prefix=transport_plugin.prefix,\n                               adapter=transport_plugin.get_adapter())\n    return requests_session\n\n\ndef get_response(args, config_dir):\n    \"\"\"Send the request and return a `request.Response`.\"\"\"\n\n    ssl_version = None\n    if args.ssl_version:\n        ssl_version = SSL_VERSION_ARG_MAPPING[args.ssl_version]\n\n    requests_session = get_requests_session(ssl_version)\n    requests_session.max_redirects = args.max_redirects\n\n    if not args.session and not args.session_read_only:\n        kwargs = get_requests_kwargs(args)\n        if args.debug:\n            dump_request(kwargs)\n        response = requests_session.request(**kwargs)\n    else:\n        response = sessions.get_response(\n            requests_session=requests_session,\n            args=args,\n            config_dir=config_dir,\n            session_name=args.session or args.session_read_only,\n            read_only=bool(args.session_read_only),\n        )\n\n    return response\n\n\ndef dump_request(kwargs):\n    sys.stderr.write('\\n>>> requests.request(**%s)\\n\\n'\n                     % repr_dict_nice(kwargs))\n\n\ndef finalize_headers(headers):\n    final_headers = {}\n    for name, value in headers.items():\n        if value is not None:\n\n            # >leading or trailing LWS MAY be removed without\n            # >changing the semantics of the field value\"\n            # -https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html\n            # Also, requests raises `InvalidHeader` for leading spaces.\n            value = value.strip()\n\n            if isinstance(value, str):\n                # See: https://github.com/jakubroztocil/httpie/issues/212\n                value = value.encode('utf8')\n\n        final_headers[name] = value\n    return final_headers\n\n\ndef get_default_headers(args):\n    default_headers = CaseInsensitiveDict({\n        'User-Agent': DEFAULT_UA\n    })\n\n    auto_json = args.data and not args.form\n    if args.json or auto_json:\n        default_headers['Accept'] = JSON_ACCEPT\n        if args.json or (auto_json and args.data):\n            default_headers['Content-Type'] = JSON_CONTENT_TYPE\n\n    elif args.form and not args.files:\n        # If sending files, `requests` will set\n        # the `Content-Type` for us.\n        default_headers['Content-Type'] = FORM_CONTENT_TYPE\n    return default_headers\n\n\ndef get_requests_kwargs(args, base_headers=None):\n    \"\"\"\n    Translate our `args` into `requests.request` keyword arguments.\n\n    \"\"\"\n    # Serialize JSON data, if needed.\n    data = args.data\n    auto_json = data and not args.form\n    if (args.json or auto_json) and isinstance(data, dict):\n        if data:\n            data = json.dumps(data)\n        else:\n            # We need to set data to an empty string to prevent requests\n            # from assigning an empty list to `response.request.data`.\n            data = ''\n\n    # Finalize headers.\n    headers = get_default_headers(args)\n    if base_headers:\n        headers.update(base_headers)\n    headers.update(args.headers)\n    headers = finalize_headers(headers)\n\n    cert = None\n    if args.cert:\n        cert = args.cert\n        if args.cert_key:\n            cert = cert, args.cert_key\n\n    kwargs = {\n        'stream': True,\n        'method': args.method.lower(),\n        'url': args.url,\n        'headers': headers,\n        'data': data,\n        'verify': {\n            'yes': True,\n            'true': True,\n            'no': False,\n            'false': False,\n        }.get(args.verify.lower(), args.verify),\n        'cert': cert,\n        'timeout': args.timeout,\n        'auth': args.auth,\n        'proxies': {p.key: p.value for p in args.proxy},\n        'files': args.files,\n        'allow_redirects': args.follow,\n        'params': args.params,\n    }\n\n    return kwargs\n", "description": "Modern command line HTTP client \u2013 user-friendly curl alternative with intuitive UI, JSON support, syntax highlighting, wget-like downloads, extensions, etc.  https://httpie.org", "file_name": "client.py", "language": "Python", "project_name": "httpie", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/jakubroztocil_httpie/jakubroztocil-httpie-0f4dce9/httpie/client.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:20:06Z", "url": "https://github.com/jakubroztocil/httpie", "wiki": false}