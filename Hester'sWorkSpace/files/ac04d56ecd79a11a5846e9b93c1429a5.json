{"author": "ansible", "code": "\n -*- coding: utf-8 -*-\n\n Copyright (c) 2017 F5 Networks Inc.\n GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = r'''\n---\nmodule: bigip_monitor_https\nshort_description: Manages F5 BIG-IP LTM https monitors\ndescription: Manages F5 BIG-IP LTM https monitors.\nversion_added: \"2.5\"\noptions:\n  name:\n    description:\n      - Monitor name.\n    required: True\n  parent:\n    description:\n      - The parent template of this monitor template. Once this value has\n        been set, it cannot be changed. By default, this value is the C(https)\n        parent on the C(Common) partition.\n    default: \"/Common/https\"\n  send:\n    description:\n      - The send string for the monitor call. When creating a new monitor, if\n        this value is not provided, the default C(GET /\\\\r\\\\n) will be used.\n  receive:\n    description:\n      - The receive string for the monitor call.\n  receive_disable:\n    description:\n      - This setting works like C(receive), except that the system marks the node\n        or pool member disabled when its response matches the C(receive_disable)\n        string but not C(receive). To use this setting, you must specify both\n        C(receive_disable) and C(receive).\n  ip:\n    description:\n      - IP address part of the IP/port definition. If this parameter is not\n        provided when creating a new monitor, then the default value will be\n        '*'.\n  port:\n    description:\n      - Port address part of the IP/port definition. If this parameter is not\n        provided when creating a new monitor, then the default value will be\n        '*'. Note that if specifying an IP address, a value between 1 and 65535\n        must be specified\n  interval:\n    description:\n      - The interval specifying how frequently the monitor instance of this\n        template will run. If this parameter is not provided when creating\n        a new monitor, then the default value will be 5. This value B(must)\n        be less than the C(timeout) value.\n  timeout:\n    description:\n      - The number of seconds in which the node or service must respond to\n        the monitor request. If the target responds within the set time\n        period, it is considered up. If the target does not respond within\n        the set time period, it is considered down. You can change this\n        number to any number you want, however, it should be 3 times the\n        interval number of seconds plus 1 second. If this parameter is not\n        provided when creating a new monitor, then the default value will be 16.\n  time_until_up:\n    description:\n      - Specifies the amount of time in seconds after the first successful\n        response before a node will be marked up. A value of 0 will cause a\n        node to be marked up immediately after a valid response is received\n        from the node. If this parameter is not provided when creating\n        a new monitor, then the default value will be 0.\n  target_username:\n    description:\n      - Specifies the user name, if the monitored target requires authentication.\n  target_password:\n    description:\n      - Specifies the password, if the monitored target requires authentication.\n  partition:\n    description:\n      - Device partition to manage resources on.\n    default: Common\n  state:\n    description:\n      - When C(present), ensures that the monitor exists.\n      - When C(absent), ensures the monitor is removed.\n    default: present\n    choices:\n      - present\n      - absent\n    version_added: 2.5\nnotes:\n  - Requires BIG-IP software version >= 12\nextends_documentation_fragment: f5\nauthor:\n  - Tim Rupp (@caphrim007)\n'''\n\nEXAMPLES = r'''\n- name: Create HTTPS Monitor\n  bigip_monitor_https:\n    state: present\n    ip: 10.10.10.10\n    server: lb.mydomain.com\n    user: admin\n    password: secret\n    name: my_http_monitor\n  delegate_to: localhost\n\n- name: Remove HTTPS Monitor\n  bigip_monitor_https:\n    state: absent\n    server: lb.mydomain.com\n    user: admin\n    password: secret\n    name: my_http_monitor\n  delegate_to: localhost\n'''\n\nRETURN = r'''\nparent:\n  description: New parent template of the monitor.\n  returned: changed\n  type: string\n  sample: https\nip:\n  description: The new IP of IP/port definition.\n  returned: changed\n  type: string\n  sample: 10.12.13.14\ninterval:\n  description: The new interval in which to run the monitor check.\n  returned: changed\n  type: int\n  sample: 2\ntimeout:\n  description: The new timeout in which the remote system must respond to the monitor.\n  returned: changed\n  type: int\n  sample: 10\ntime_until_up:\n  description: The new time in which to mark a system as up after first successful response.\n  returned: changed\n  type: int\n  sample: 2\n'''\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.basic import env_fallback\n\nHAS_DEVEL_IMPORTS = False\n\ntry:\n     Sideband repository used for dev\n    from library.module_utils.network.f5.bigip import HAS_F5SDK\n    from library.module_utils.network.f5.bigip import F5Client\n    from library.module_utils.network.f5.common import F5ModuleError\n    from library.module_utils.network.f5.common import AnsibleF5Parameters\n    from library.module_utils.network.f5.common import cleanup_tokens\n    from library.module_utils.network.f5.common import fqdn_name\n    from library.module_utils.network.f5.common import f5_argument_spec\n    try:\n        from library.module_utils.network.f5.common import iControlUnexpectedHTTPError\n    except ImportError:\n        HAS_F5SDK = False\n    HAS_DEVEL_IMPORTS = True\nexcept ImportError:\n     Upstream Ansible\n    from ansible.module_utils.network.f5.bigip import HAS_F5SDK\n    from ansible.module_utils.network.f5.bigip import F5Client\n    from ansible.module_utils.network.f5.common import F5ModuleError\n    from ansible.module_utils.network.f5.common import AnsibleF5Parameters\n    from ansible.module_utils.network.f5.common import cleanup_tokens\n    from ansible.module_utils.network.f5.common import fqdn_name\n    from ansible.module_utils.network.f5.common import f5_argument_spec\n    try:\n        from ansible.module_utils.network.f5.common import iControlUnexpectedHTTPError\n    except ImportError:\n        HAS_F5SDK = False\n\ntry:\n    import netaddr\n    HAS_NETADDR = True\nexcept ImportError:\n    HAS_NETADDR = False\n\n\nclass Parameters(AnsibleF5Parameters):\n    api_map = {\n        'timeUntilUp': 'time_until_up',\n        'defaultsFrom': 'parent',\n        'recv': 'receive'\n    }\n\n    api_attributes = [\n        'timeUntilUp', 'defaultsFrom', 'interval', 'timeout', 'recv', 'send',\n        'destination', 'username', 'password'\n    ]\n\n    returnables = [\n        'parent', 'send', 'receive', 'ip', 'port', 'interval', 'timeout',\n        'time_until_up'\n    ]\n\n    updatables = [\n        'destination', 'send', 'receive', 'interval', 'timeout', 'time_until_up',\n        'target_username', 'target_password'\n    ]\n\n    def _fqdn_name(self, value):\n        if value is not None and not value.startswith('/'):\n            return '/{0}/{1}'.format(self.partition, value)\n        return value\n\n    def to_return(self):\n        result = {}\n        try:\n            for returnable in self.returnables:\n                result[returnable] = getattr(self, returnable)\n            result = self._filter_params(result)\n            return result\n        except Exception:\n            return result\n\n    @property\n    def username(self):\n        return self._values['target_username']\n\n    @property\n    def password(self):\n        return self._values['target_password']\n\n    @property\n    def destination(self):\n        if self.ip is None and self.port is None:\n            return None\n        destination = '{0}:{1}'.format(self.ip, self.port)\n        return destination\n\n    @destination.setter\n    def destination(self, value):\n        ip, port = value.split(':')\n        self._values['ip'] = ip\n        self._values['port'] = port\n\n    @property\n    def interval(self):\n        if self._values['interval'] is None:\n            return None\n\n         Per BZ617284, the BIG-IP UI does not raise a warning about this.\n         So I do\n        if 1 > int(self._values['interval']) > 86400:\n            raise F5ModuleError(\n                \"Interval value must be between 1 and 86400\"\n            )\n        return int(self._values['interval'])\n\n    @property\n    def timeout(self):\n        if self._values['timeout'] is None:\n            return None\n        return int(self._values['timeout'])\n\n    @property\n    def ip(self):\n        if self._values['ip'] is None:\n            return None\n        try:\n            if self._values['ip'] in ['*', '0.0.0.0']:\n                return '*'\n            result = str(netaddr.IPAddress(self._values['ip']))\n            return result\n        except netaddr.core.AddrFormatError:\n            raise F5ModuleError(\n                \"The provided 'ip' parameter is not an IP address.\"\n            )\n\n    @property\n    def port(self):\n        if self._values['port'] is None:\n            return None\n        elif self._values['port'] == '*':\n            return '*'\n        return int(self._values['port'])\n\n    @property\n    def time_until_up(self):\n        if self._values['time_until_up'] is None:\n            return None\n        return int(self._values['time_until_up'])\n\n    @property\n    def parent(self):\n        if self._values['parent'] is None:\n            return None\n        result = self._fqdn_name(self._values['parent'])\n        return result\n\n    @property\n    def type(self):\n        return 'https'\n\n\nclass Changes(Parameters):\n    pass\n\n\nclass Difference(object):\n    def __init__(self, want, have=None):\n        self.want = want\n        self.have = have\n\n    def compare(self, param):\n        try:\n            result = getattr(self, param)\n            return result\n        except AttributeError:\n            result = self.__default(param)\n            return result\n\n    @property\n    def parent(self):\n        if self.want.parent != self.have.parent:\n            raise F5ModuleError(\n                \"The parent monitor cannot be changed\"\n            )\n\n    @property\n    def destination(self):\n        if self.want.ip is None and self.want.port is None:\n            return None\n        if self.want.port is None:\n            self.want.update({'port': self.have.port})\n        if self.want.ip is None:\n            self.want.update({'ip': self.have.ip})\n\n        if self.want.port in [None, '*'] and self.want.ip != '*':\n            raise F5ModuleError(\n                \"Specifying an IP address requires that a port number be specified\"\n            )\n\n        if self.want.destination != self.have.destination:\n            return self.want.destination\n\n    @property\n    def interval(self):\n        if self.want.timeout is not None and self.want.interval is not None:\n            if self.want.interval >= self.want.timeout:\n                raise F5ModuleError(\n                    \"Parameter 'interval' must be less than 'timeout'.\"\n                )\n        elif self.want.timeout is not None:\n            if self.have.interval >= self.want.timeout:\n                raise F5ModuleError(\n                    \"Parameter 'interval' must be less than 'timeout'.\"\n                )\n        elif self.want.interval is not None:\n            if self.want.interval >= self.have.timeout:\n                raise F5ModuleError(\n                    \"Parameter 'interval' must be less than 'timeout'.\"\n                )\n        if self.want.interval != self.have.interval:\n            return self.want.interval\n\n    def __default(self, param):\n        attr1 = getattr(self.want, param)\n        try:\n            attr2 = getattr(self.have, param)\n            if attr1 != attr2:\n                return attr1\n        except AttributeError:\n            return attr1\n\n\nclass ModuleManager(object):\n    def __init__(self, *args, **kwargs):\n        self.module = kwargs.get('module', None)\n        self.client = kwargs.get('client', None)\n        self.have = None\n        self.want = Parameters(params=self.module.params)\n        self.changes = Changes()\n\n    def _set_changed_options(self):\n        changed = {}\n        for key in Parameters.returnables:\n            if getattr(self.want, key) is not None:\n                changed[key] = getattr(self.want, key)\n        if changed:\n            self.changes = Changes(params=changed)\n\n    def _update_changed_options(self):\n        diff = Difference(self.want, self.have)\n        updatables = Parameters.updatables\n        changed = dict()\n        for k in updatables:\n            change = diff.compare(k)\n            if change is None:\n                continue\n            else:\n                changed[k] = change\n        if changed:\n            self.changes = Changes(params=changed)\n            return True\n        return False\n\n    def _announce_deprecations(self):\n        warnings = []\n        if self.want:\n            warnings += self.want._values.get('__warnings', [])\n        if self.have:\n            warnings += self.have._values.get('__warnings', [])\n        for warning in warnings:\n            self.module.deprecate(\n                msg=warning['msg'],\n                version=warning['version']\n            )\n\n    def exec_module(self):\n        changed = False\n        result = dict()\n        state = self.want.state\n\n        try:\n            if state == \"present\":\n                changed = self.present()\n            elif state == \"absent\":\n                changed = self.absent()\n        except iControlUnexpectedHTTPError as e:\n            raise F5ModuleError(str(e))\n\n        changes = self.changes.to_return()\n        result.update(**changes)\n        result.update(dict(changed=changed))\n        self._announce_deprecations()\n        return result\n\n    def present(self):\n        if self.exists():\n            return self.update()\n        else:\n            return self.create()\n\n    def create(self):\n        self._set_changed_options()\n        if self.want.timeout is None:\n            self.want.update({'timeout': 16})\n        if self.want.interval is None:\n            self.want.update({'interval': 5})\n        if self.want.time_until_up is None:\n            self.want.update({'time_until_up': 0})\n        if self.want.ip is None:\n            self.want.update({'ip': '*'})\n        if self.want.port is None:\n            self.want.update({'port': '*'})\n        if self.want.send is None:\n            self.want.update({'send': 'GET /\\r\\n'})\n        if self.module.check_mode:\n            return True\n        self.create_on_device()\n        return True\n\n    def should_update(self):\n        result = self._update_changed_options()\n        if result:\n            return True\n        return False\n\n    def update(self):\n        self.have = self.read_current_from_device()\n        if not self.should_update():\n            return False\n        if self.module.check_mode:\n            return True\n        self.update_on_device()\n        return True\n\n    def absent(self):\n        if self.exists():\n            return self.remove()\n        return False\n\n    def remove(self):\n        if self.module.check_mode:\n            return True\n        self.remove_from_device()\n        if self.exists():\n            raise F5ModuleError(\"Failed to delete the monitor.\")\n        return True\n\n    def read_current_from_device(self):\n        resource = self.client.api.tm.ltm.monitor.https_s.https.load(\n            name=self.want.name,\n            partition=self.want.partition\n        )\n        result = resource.attrs\n        return Parameters(params=result)\n\n    def exists(self):\n        result = self.client.api.tm.ltm.monitor.https_s.https.exists(\n            name=self.want.name,\n            partition=self.want.partition\n        )\n        return result\n\n    def update_on_device(self):\n        params = self.want.api_params()\n        result = self.client.api.tm.ltm.monitor.https_s.https.load(\n            name=self.want.name,\n            partition=self.want.partition\n        )\n        result.modify(**params)\n\n    def create_on_device(self):\n        params = self.want.api_params()\n        self.client.api.tm.ltm.monitor.https_s.https.create(\n            name=self.want.name,\n            partition=self.want.partition,\n            **params\n        )\n\n    def remove_from_device(self):\n        result = self.client.api.tm.ltm.monitor.https_s.https.load(\n            name=self.want.name,\n            partition=self.want.partition\n        )\n        if result:\n            result.delete()\n\n\nclass ArgumentSpec(object):\n    def __init__(self):\n        self.supports_check_mode = True\n        argument_spec = dict(\n            name=dict(required=True),\n            parent=dict(default='/Common/https'),\n            send=dict(),\n            receive=dict(),\n            receive_disable=dict(required=False),\n            ip=dict(),\n            port=dict(type='int'),\n            interval=dict(type='int'),\n            timeout=dict(type='int'),\n            time_until_up=dict(type='int'),\n            target_username=dict(),\n            target_password=dict(no_log=True),\n            state=dict(\n                default='present',\n                choices=['present', 'absent']\n            ),\n            partition=dict(\n                default='Common',\n                fallback=(env_fallback, ['F5_PARTITION'])\n            )\n        )\n        self.argument_spec = {}\n        self.argument_spec.update(f5_argument_spec)\n        self.argument_spec.update(argument_spec)\n\n\ndef main():\n    spec = ArgumentSpec()\n\n    module = AnsibleModule(\n        argument_spec=spec.argument_spec,\n        supports_check_mode=spec.supports_check_mode\n    )\n    if not HAS_F5SDK:\n        module.fail_json(msg=\"The python f5-sdk module is required\")\n    if not HAS_NETADDR:\n        module.fail_json(msg=\"The python netaddr module is required\")\n\n    try:\n        client = F5Client(**module.params)\n        mm = ModuleManager(module=module, client=client)\n        results = mm.exec_module()\n        cleanup_tokens(client)\n        module.exit_json(**results)\n    except F5ModuleError as ex:\n        cleanup_tokens(client)\n        module.fail_json(msg=str(ex))\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  bigip monitor https short description  manages f5 big ip ltm https monitors description  manages f5 big ip ltm https monitors  version added   2 5  options    name      description          monitor name      required  true   parent      description          the parent template monitor template  once value         set  cannot changed  by default  value c(https)         parent c(common) partition      default    common https    send      description          the send string monitor call  when creating new monitor          value provided  default c(get    r  n) used    receive      description          the receive string monitor call    receive disable      description          this setting works like c(receive)  except system marks node         pool member disabled response matches c(receive disable)         string c(receive)  to use setting  must specify         c(receive disable) c(receive)    ip      description          ip address part ip port definition  if parameter         provided creating new monitor  default value                port      description          port address part ip port definition  if parameter         provided creating new monitor  default value              note specifying ip address  value 1 65535         must specified   interval      description          the interval specifying frequently monitor instance         template run  if parameter provided creating         new monitor  default value 5  this value b(must)         less c(timeout) value    timeout      description          the number seconds node service must respond         monitor request  if target responds within set time         period  considered  if target respond within         set time period  considered  you change         number number want  however  3 times         interval number seconds plus 1 second  if parameter         provided creating new monitor  default value 16    time      description          specifies amount time seconds first successful         response node marked  a value 0 cause         node marked immediately valid response received         node  if parameter provided creating         new monitor  default value 0    target username      description          specifies user name  monitored target requires authentication    target password      description          specifies password  monitored target requires authentication    partition      description          device partition manage resources      default  common   state      description          when c(present)  ensures monitor exists          when c(absent)  ensures monitor removed      default  present     choices          present         absent     version added  2 5 notes      requires big ip software version    12 extends documentation fragment  f5 author      tim rupp ( caphrim007)      examples   r      name  create https monitor   bigip monitor https      state  present     ip  10 10 10 10     server  lb mydomain com     user  admin     password  secret     name  http monitor   delegate  localhost    name  remove https monitor   bigip monitor https      state  absent     server  lb mydomain com     user  admin     password  secret     name  http monitor   delegate  localhost      return   r    parent    description  new parent template monitor    returned  changed   type  string   sample  https ip    description  the new ip ip port definition    returned  changed   type  string   sample  10 12 13 14 interval    description  the new interval run monitor check    returned  changed   type  int   sample  2 timeout    description  the new timeout remote system must respond monitor    returned  changed   type  int   sample  10 time    description  the new time mark system first successful response    returned  changed   type  int   sample  2         usr bin python        coding  utf 8           copyright (c) 2017 f5 networks inc     gnu general public license v3 0 (see copying https   www gnu org licenses gpl 3 0 txt)    sideband repository used dev    upstream ansible    per bz617284  big ip ui raise warning     so i ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n#\n# Copyright (c) 2017 F5 Networks Inc.\n# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = r'''\n---\nmodule: bigip_monitor_https\nshort_description: Manages F5 BIG-IP LTM https monitors\ndescription: Manages F5 BIG-IP LTM https monitors.\nversion_added: \"2.5\"\noptions:\n  name:\n    description:\n      - Monitor name.\n    required: True\n  parent:\n    description:\n      - The parent template of this monitor template. Once this value has\n        been set, it cannot be changed. By default, this value is the C(https)\n        parent on the C(Common) partition.\n    default: \"/Common/https\"\n  send:\n    description:\n      - The send string for the monitor call. When creating a new monitor, if\n        this value is not provided, the default C(GET /\\\\r\\\\n) will be used.\n  receive:\n    description:\n      - The receive string for the monitor call.\n  receive_disable:\n    description:\n      - This setting works like C(receive), except that the system marks the node\n        or pool member disabled when its response matches the C(receive_disable)\n        string but not C(receive). To use this setting, you must specify both\n        C(receive_disable) and C(receive).\n  ip:\n    description:\n      - IP address part of the IP/port definition. If this parameter is not\n        provided when creating a new monitor, then the default value will be\n        '*'.\n  port:\n    description:\n      - Port address part of the IP/port definition. If this parameter is not\n        provided when creating a new monitor, then the default value will be\n        '*'. Note that if specifying an IP address, a value between 1 and 65535\n        must be specified\n  interval:\n    description:\n      - The interval specifying how frequently the monitor instance of this\n        template will run. If this parameter is not provided when creating\n        a new monitor, then the default value will be 5. This value B(must)\n        be less than the C(timeout) value.\n  timeout:\n    description:\n      - The number of seconds in which the node or service must respond to\n        the monitor request. If the target responds within the set time\n        period, it is considered up. If the target does not respond within\n        the set time period, it is considered down. You can change this\n        number to any number you want, however, it should be 3 times the\n        interval number of seconds plus 1 second. If this parameter is not\n        provided when creating a new monitor, then the default value will be 16.\n  time_until_up:\n    description:\n      - Specifies the amount of time in seconds after the first successful\n        response before a node will be marked up. A value of 0 will cause a\n        node to be marked up immediately after a valid response is received\n        from the node. If this parameter is not provided when creating\n        a new monitor, then the default value will be 0.\n  target_username:\n    description:\n      - Specifies the user name, if the monitored target requires authentication.\n  target_password:\n    description:\n      - Specifies the password, if the monitored target requires authentication.\n  partition:\n    description:\n      - Device partition to manage resources on.\n    default: Common\n  state:\n    description:\n      - When C(present), ensures that the monitor exists.\n      - When C(absent), ensures the monitor is removed.\n    default: present\n    choices:\n      - present\n      - absent\n    version_added: 2.5\nnotes:\n  - Requires BIG-IP software version >= 12\nextends_documentation_fragment: f5\nauthor:\n  - Tim Rupp (@caphrim007)\n'''\n\nEXAMPLES = r'''\n- name: Create HTTPS Monitor\n  bigip_monitor_https:\n    state: present\n    ip: 10.10.10.10\n    server: lb.mydomain.com\n    user: admin\n    password: secret\n    name: my_http_monitor\n  delegate_to: localhost\n\n- name: Remove HTTPS Monitor\n  bigip_monitor_https:\n    state: absent\n    server: lb.mydomain.com\n    user: admin\n    password: secret\n    name: my_http_monitor\n  delegate_to: localhost\n'''\n\nRETURN = r'''\nparent:\n  description: New parent template of the monitor.\n  returned: changed\n  type: string\n  sample: https\nip:\n  description: The new IP of IP/port definition.\n  returned: changed\n  type: string\n  sample: 10.12.13.14\ninterval:\n  description: The new interval in which to run the monitor check.\n  returned: changed\n  type: int\n  sample: 2\ntimeout:\n  description: The new timeout in which the remote system must respond to the monitor.\n  returned: changed\n  type: int\n  sample: 10\ntime_until_up:\n  description: The new time in which to mark a system as up after first successful response.\n  returned: changed\n  type: int\n  sample: 2\n'''\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.basic import env_fallback\n\nHAS_DEVEL_IMPORTS = False\n\ntry:\n    # Sideband repository used for dev\n    from library.module_utils.network.f5.bigip import HAS_F5SDK\n    from library.module_utils.network.f5.bigip import F5Client\n    from library.module_utils.network.f5.common import F5ModuleError\n    from library.module_utils.network.f5.common import AnsibleF5Parameters\n    from library.module_utils.network.f5.common import cleanup_tokens\n    from library.module_utils.network.f5.common import fqdn_name\n    from library.module_utils.network.f5.common import f5_argument_spec\n    try:\n        from library.module_utils.network.f5.common import iControlUnexpectedHTTPError\n    except ImportError:\n        HAS_F5SDK = False\n    HAS_DEVEL_IMPORTS = True\nexcept ImportError:\n    # Upstream Ansible\n    from ansible.module_utils.network.f5.bigip import HAS_F5SDK\n    from ansible.module_utils.network.f5.bigip import F5Client\n    from ansible.module_utils.network.f5.common import F5ModuleError\n    from ansible.module_utils.network.f5.common import AnsibleF5Parameters\n    from ansible.module_utils.network.f5.common import cleanup_tokens\n    from ansible.module_utils.network.f5.common import fqdn_name\n    from ansible.module_utils.network.f5.common import f5_argument_spec\n    try:\n        from ansible.module_utils.network.f5.common import iControlUnexpectedHTTPError\n    except ImportError:\n        HAS_F5SDK = False\n\ntry:\n    import netaddr\n    HAS_NETADDR = True\nexcept ImportError:\n    HAS_NETADDR = False\n\n\nclass Parameters(AnsibleF5Parameters):\n    api_map = {\n        'timeUntilUp': 'time_until_up',\n        'defaultsFrom': 'parent',\n        'recv': 'receive'\n    }\n\n    api_attributes = [\n        'timeUntilUp', 'defaultsFrom', 'interval', 'timeout', 'recv', 'send',\n        'destination', 'username', 'password'\n    ]\n\n    returnables = [\n        'parent', 'send', 'receive', 'ip', 'port', 'interval', 'timeout',\n        'time_until_up'\n    ]\n\n    updatables = [\n        'destination', 'send', 'receive', 'interval', 'timeout', 'time_until_up',\n        'target_username', 'target_password'\n    ]\n\n    def _fqdn_name(self, value):\n        if value is not None and not value.startswith('/'):\n            return '/{0}/{1}'.format(self.partition, value)\n        return value\n\n    def to_return(self):\n        result = {}\n        try:\n            for returnable in self.returnables:\n                result[returnable] = getattr(self, returnable)\n            result = self._filter_params(result)\n            return result\n        except Exception:\n            return result\n\n    @property\n    def username(self):\n        return self._values['target_username']\n\n    @property\n    def password(self):\n        return self._values['target_password']\n\n    @property\n    def destination(self):\n        if self.ip is None and self.port is None:\n            return None\n        destination = '{0}:{1}'.format(self.ip, self.port)\n        return destination\n\n    @destination.setter\n    def destination(self, value):\n        ip, port = value.split(':')\n        self._values['ip'] = ip\n        self._values['port'] = port\n\n    @property\n    def interval(self):\n        if self._values['interval'] is None:\n            return None\n\n        # Per BZ617284, the BIG-IP UI does not raise a warning about this.\n        # So I do\n        if 1 > int(self._values['interval']) > 86400:\n            raise F5ModuleError(\n                \"Interval value must be between 1 and 86400\"\n            )\n        return int(self._values['interval'])\n\n    @property\n    def timeout(self):\n        if self._values['timeout'] is None:\n            return None\n        return int(self._values['timeout'])\n\n    @property\n    def ip(self):\n        if self._values['ip'] is None:\n            return None\n        try:\n            if self._values['ip'] in ['*', '0.0.0.0']:\n                return '*'\n            result = str(netaddr.IPAddress(self._values['ip']))\n            return result\n        except netaddr.core.AddrFormatError:\n            raise F5ModuleError(\n                \"The provided 'ip' parameter is not an IP address.\"\n            )\n\n    @property\n    def port(self):\n        if self._values['port'] is None:\n            return None\n        elif self._values['port'] == '*':\n            return '*'\n        return int(self._values['port'])\n\n    @property\n    def time_until_up(self):\n        if self._values['time_until_up'] is None:\n            return None\n        return int(self._values['time_until_up'])\n\n    @property\n    def parent(self):\n        if self._values['parent'] is None:\n            return None\n        result = self._fqdn_name(self._values['parent'])\n        return result\n\n    @property\n    def type(self):\n        return 'https'\n\n\nclass Changes(Parameters):\n    pass\n\n\nclass Difference(object):\n    def __init__(self, want, have=None):\n        self.want = want\n        self.have = have\n\n    def compare(self, param):\n        try:\n            result = getattr(self, param)\n            return result\n        except AttributeError:\n            result = self.__default(param)\n            return result\n\n    @property\n    def parent(self):\n        if self.want.parent != self.have.parent:\n            raise F5ModuleError(\n                \"The parent monitor cannot be changed\"\n            )\n\n    @property\n    def destination(self):\n        if self.want.ip is None and self.want.port is None:\n            return None\n        if self.want.port is None:\n            self.want.update({'port': self.have.port})\n        if self.want.ip is None:\n            self.want.update({'ip': self.have.ip})\n\n        if self.want.port in [None, '*'] and self.want.ip != '*':\n            raise F5ModuleError(\n                \"Specifying an IP address requires that a port number be specified\"\n            )\n\n        if self.want.destination != self.have.destination:\n            return self.want.destination\n\n    @property\n    def interval(self):\n        if self.want.timeout is not None and self.want.interval is not None:\n            if self.want.interval >= self.want.timeout:\n                raise F5ModuleError(\n                    \"Parameter 'interval' must be less than 'timeout'.\"\n                )\n        elif self.want.timeout is not None:\n            if self.have.interval >= self.want.timeout:\n                raise F5ModuleError(\n                    \"Parameter 'interval' must be less than 'timeout'.\"\n                )\n        elif self.want.interval is not None:\n            if self.want.interval >= self.have.timeout:\n                raise F5ModuleError(\n                    \"Parameter 'interval' must be less than 'timeout'.\"\n                )\n        if self.want.interval != self.have.interval:\n            return self.want.interval\n\n    def __default(self, param):\n        attr1 = getattr(self.want, param)\n        try:\n            attr2 = getattr(self.have, param)\n            if attr1 != attr2:\n                return attr1\n        except AttributeError:\n            return attr1\n\n\nclass ModuleManager(object):\n    def __init__(self, *args, **kwargs):\n        self.module = kwargs.get('module', None)\n        self.client = kwargs.get('client', None)\n        self.have = None\n        self.want = Parameters(params=self.module.params)\n        self.changes = Changes()\n\n    def _set_changed_options(self):\n        changed = {}\n        for key in Parameters.returnables:\n            if getattr(self.want, key) is not None:\n                changed[key] = getattr(self.want, key)\n        if changed:\n            self.changes = Changes(params=changed)\n\n    def _update_changed_options(self):\n        diff = Difference(self.want, self.have)\n        updatables = Parameters.updatables\n        changed = dict()\n        for k in updatables:\n            change = diff.compare(k)\n            if change is None:\n                continue\n            else:\n                changed[k] = change\n        if changed:\n            self.changes = Changes(params=changed)\n            return True\n        return False\n\n    def _announce_deprecations(self):\n        warnings = []\n        if self.want:\n            warnings += self.want._values.get('__warnings', [])\n        if self.have:\n            warnings += self.have._values.get('__warnings', [])\n        for warning in warnings:\n            self.module.deprecate(\n                msg=warning['msg'],\n                version=warning['version']\n            )\n\n    def exec_module(self):\n        changed = False\n        result = dict()\n        state = self.want.state\n\n        try:\n            if state == \"present\":\n                changed = self.present()\n            elif state == \"absent\":\n                changed = self.absent()\n        except iControlUnexpectedHTTPError as e:\n            raise F5ModuleError(str(e))\n\n        changes = self.changes.to_return()\n        result.update(**changes)\n        result.update(dict(changed=changed))\n        self._announce_deprecations()\n        return result\n\n    def present(self):\n        if self.exists():\n            return self.update()\n        else:\n            return self.create()\n\n    def create(self):\n        self._set_changed_options()\n        if self.want.timeout is None:\n            self.want.update({'timeout': 16})\n        if self.want.interval is None:\n            self.want.update({'interval': 5})\n        if self.want.time_until_up is None:\n            self.want.update({'time_until_up': 0})\n        if self.want.ip is None:\n            self.want.update({'ip': '*'})\n        if self.want.port is None:\n            self.want.update({'port': '*'})\n        if self.want.send is None:\n            self.want.update({'send': 'GET /\\r\\n'})\n        if self.module.check_mode:\n            return True\n        self.create_on_device()\n        return True\n\n    def should_update(self):\n        result = self._update_changed_options()\n        if result:\n            return True\n        return False\n\n    def update(self):\n        self.have = self.read_current_from_device()\n        if not self.should_update():\n            return False\n        if self.module.check_mode:\n            return True\n        self.update_on_device()\n        return True\n\n    def absent(self):\n        if self.exists():\n            return self.remove()\n        return False\n\n    def remove(self):\n        if self.module.check_mode:\n            return True\n        self.remove_from_device()\n        if self.exists():\n            raise F5ModuleError(\"Failed to delete the monitor.\")\n        return True\n\n    def read_current_from_device(self):\n        resource = self.client.api.tm.ltm.monitor.https_s.https.load(\n            name=self.want.name,\n            partition=self.want.partition\n        )\n        result = resource.attrs\n        return Parameters(params=result)\n\n    def exists(self):\n        result = self.client.api.tm.ltm.monitor.https_s.https.exists(\n            name=self.want.name,\n            partition=self.want.partition\n        )\n        return result\n\n    def update_on_device(self):\n        params = self.want.api_params()\n        result = self.client.api.tm.ltm.monitor.https_s.https.load(\n            name=self.want.name,\n            partition=self.want.partition\n        )\n        result.modify(**params)\n\n    def create_on_device(self):\n        params = self.want.api_params()\n        self.client.api.tm.ltm.monitor.https_s.https.create(\n            name=self.want.name,\n            partition=self.want.partition,\n            **params\n        )\n\n    def remove_from_device(self):\n        result = self.client.api.tm.ltm.monitor.https_s.https.load(\n            name=self.want.name,\n            partition=self.want.partition\n        )\n        if result:\n            result.delete()\n\n\nclass ArgumentSpec(object):\n    def __init__(self):\n        self.supports_check_mode = True\n        argument_spec = dict(\n            name=dict(required=True),\n            parent=dict(default='/Common/https'),\n            send=dict(),\n            receive=dict(),\n            receive_disable=dict(required=False),\n            ip=dict(),\n            port=dict(type='int'),\n            interval=dict(type='int'),\n            timeout=dict(type='int'),\n            time_until_up=dict(type='int'),\n            target_username=dict(),\n            target_password=dict(no_log=True),\n            state=dict(\n                default='present',\n                choices=['present', 'absent']\n            ),\n            partition=dict(\n                default='Common',\n                fallback=(env_fallback, ['F5_PARTITION'])\n            )\n        )\n        self.argument_spec = {}\n        self.argument_spec.update(f5_argument_spec)\n        self.argument_spec.update(argument_spec)\n\n\ndef main():\n    spec = ArgumentSpec()\n\n    module = AnsibleModule(\n        argument_spec=spec.argument_spec,\n        supports_check_mode=spec.supports_check_mode\n    )\n    if not HAS_F5SDK:\n        module.fail_json(msg=\"The python f5-sdk module is required\")\n    if not HAS_NETADDR:\n        module.fail_json(msg=\"The python netaddr module is required\")\n\n    try:\n        client = F5Client(**module.params)\n        mm = ModuleManager(module=module, client=client)\n        results = mm.exec_module()\n        cleanup_tokens(client)\n        module.exit_json(**results)\n    except F5ModuleError as ex:\n        cleanup_tokens(client)\n        module.fail_json(msg=str(ex))\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "bigip_monitor_https.py", "id": "ac04d56ecd79a11a5846e9b93c1429a5", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/network/f5/bigip_monitor_https.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}