{"author": "HelloZeroNet", "code": "import time\nimport collections\n\nfrom util import helper\nfrom Plugin import PluginManager\nimport ContentDbPlugin\n\n\n\n@PluginManager.afterLoad\ndef importPluginnedClasses():\n    global config\n    from Config import config\n\n\ndef processAccessLog():\n    if access_log:\n        content_db = ContentDbPlugin.content_db\n        now = int(time.time())\n        num = 0\n        for site_id in access_log:\n            content_db.execute(\n                \"UPDATE file_optional SET time_accessed = %s WHERE ?\" % now,\n                {\"site_id\": site_id, \"inner_path\": access_log[site_id].keys()}\n            )\n            num += len(access_log[site_id])\n        access_log.clear()\n\n\ndef processRequestLog():\n    if request_log:\n        content_db = ContentDbPlugin.content_db\n        cur = content_db.getCursor()\n        num = 0\n        cur.execute(\"BEGIN\")\n        for site_id in request_log:\n            for inner_path, uploaded in request_log[site_id].iteritems():\n                content_db.execute(\n                    \"UPDATE file_optional SET uploaded = uploaded + %s WHERE ?\" % uploaded,\n                    {\"site_id\": site_id, \"inner_path\": inner_path}\n                )\n                num += 1\n        cur.execute(\"END\")\n        request_log.clear()\n\n\nif \"access_log\" not in locals().keys():  \n    access_log = collections.defaultdict(dict)  \n    request_log = collections.defaultdict(lambda: collections.defaultdict(int))  \n    helper.timer(61, processAccessLog)\n    helper.timer(60, processRequestLog)\n\n\n@PluginManager.registerTo(\"WorkerManager\")\nclass WorkerManagerPlugin(object):\n    def doneTask(self, task):\n        content_db = self.site.content_manager.contents.db\n        if task[\"optional_hash_id\"] and task[\"optional_hash_id\"] not in self.site.content_manager.hashfield:\n\n            inner_path = task[\"inner_path\"]\n            is_pinned = 0\n            if \"|\" in inner_path:  \n                inner_path, file_range = inner_path.split(\"|\")\n                file_info = self.site.content_manager.getFileInfo(inner_path)\n                \n                if config.pin_bigfile and file_info[\"size\"] > 1024 * 1024 * config.pin_bigfile:\n                    is_pinned = 1\n\n\n            content_db.executeDelayed(\n                \"UPDATE file_optional SET time_downloaded = :now, is_downloaded = 1, peer = peer + 1, is_pinned = :is_pinned WHERE site_id = :site_id AND inner_path = :inner_path\",\n                {\"now\": int(time.time()), \"site_id\": content_db.site_ids[self.site.address], \"inner_path\": inner_path, \"is_pinned\": is_pinned}\n            )\n\n        super(WorkerManagerPlugin, self).doneTask(task)\n\n        if task[\"optional_hash_id\"] and not self.tasks:\n            content_db.processDelayed()\n\n\n@PluginManager.registerTo(\"UiRequest\")\nclass UiRequestPlugin(object):\n    def parsePath(self, path):\n        global access_log\n        path_parts = super(UiRequestPlugin, self).parsePath(path)\n        if path_parts:\n            site_id = ContentDbPlugin.content_db.site_ids.get(path_parts[\"request_address\"])\n            if site_id:\n                if ContentDbPlugin.content_db.isOptionalFile(site_id, path_parts[\"inner_path\"]):\n                    access_log[site_id][path_parts[\"inner_path\"]] = 1\n        return path_parts\n\n\n@PluginManager.registerTo(\"FileRequest\")\nclass FileRequestPlugin(object):\n    def actionGetFile(self, params):\n        stats = super(FileRequestPlugin, self).actionGetFile(params)\n        self.recordFileRequest(params[\"site\"], params[\"inner_path\"], stats)\n        return stats\n\n    def actionStreamFile(self, params):\n        stats = super(FileRequestPlugin, self).actionStreamFile(params)\n        self.recordFileRequest(params[\"site\"], params[\"inner_path\"], stats)\n        return stats\n\n    def recordFileRequest(self, site_address, inner_path, stats):\n        if not stats:\n            \n            return False\n        site_id = ContentDbPlugin.content_db.site_ids[site_address]\n        if site_id and ContentDbPlugin.content_db.isOptionalFile(site_id, inner_path):\n            request_log[site_id][inner_path] += stats[\"bytes_sent\"]\n\n\n@PluginManager.registerTo(\"Site\")\nclass SitePlugin(object):\n    def isDownloadable(self, inner_path):\n        is_downloadable = super(SitePlugin, self).isDownloadable(inner_path)\n        if is_downloadable:\n            return is_downloadable\n\n        for path in self.settings.get(\"optional_help\", {}).iterkeys():\n            if inner_path.startswith(path):\n                return True\n\n        return False\n\n\n@PluginManager.registerTo(\"ConfigPlugin\")\nclass ConfigPlugin(object):\n    def createArguments(self):\n        group = self.parser.add_argument_group(\"OptionalManager plugin\")\n        group.add_argument('--optional_limit', help='Limit total size of optional files', default=\"10%\", metavar=\"GB or free space %\")\n        group.add_argument('--pin_bigfile', help='Automatically pin files larger than this limit', default=20, metavar=\"MB\", type=int)\n\n        return super(ConfigPlugin, self).createArguments()\n", "comments": "  we import plugin host clases plugins loaded    to keep module reloads     site id   inner path1  1  inner path2  1          site id   inner path1  1  inner path2  1         big file piece    auto pin bigfiles    only track last request files ", "content": "import time\nimport collections\n\nfrom util import helper\nfrom Plugin import PluginManager\nimport ContentDbPlugin\n\n\n# We can only import plugin host clases after the plugins are loaded\n@PluginManager.afterLoad\ndef importPluginnedClasses():\n    global config\n    from Config import config\n\n\ndef processAccessLog():\n    if access_log:\n        content_db = ContentDbPlugin.content_db\n        now = int(time.time())\n        num = 0\n        for site_id in access_log:\n            content_db.execute(\n                \"UPDATE file_optional SET time_accessed = %s WHERE ?\" % now,\n                {\"site_id\": site_id, \"inner_path\": access_log[site_id].keys()}\n            )\n            num += len(access_log[site_id])\n        access_log.clear()\n\n\ndef processRequestLog():\n    if request_log:\n        content_db = ContentDbPlugin.content_db\n        cur = content_db.getCursor()\n        num = 0\n        cur.execute(\"BEGIN\")\n        for site_id in request_log:\n            for inner_path, uploaded in request_log[site_id].iteritems():\n                content_db.execute(\n                    \"UPDATE file_optional SET uploaded = uploaded + %s WHERE ?\" % uploaded,\n                    {\"site_id\": site_id, \"inner_path\": inner_path}\n                )\n                num += 1\n        cur.execute(\"END\")\n        request_log.clear()\n\n\nif \"access_log\" not in locals().keys():  # To keep between module reloads\n    access_log = collections.defaultdict(dict)  # {site_id: {inner_path1: 1, inner_path2: 1...}}\n    request_log = collections.defaultdict(lambda: collections.defaultdict(int))  # {site_id: {inner_path1: 1, inner_path2: 1...}}\n    helper.timer(61, processAccessLog)\n    helper.timer(60, processRequestLog)\n\n\n@PluginManager.registerTo(\"WorkerManager\")\nclass WorkerManagerPlugin(object):\n    def doneTask(self, task):\n        content_db = self.site.content_manager.contents.db\n        if task[\"optional_hash_id\"] and task[\"optional_hash_id\"] not in self.site.content_manager.hashfield:\n\n            inner_path = task[\"inner_path\"]\n            is_pinned = 0\n            if \"|\" in inner_path:  # Big file piece\n                inner_path, file_range = inner_path.split(\"|\")\n                file_info = self.site.content_manager.getFileInfo(inner_path)\n                # Auto-pin bigfiles\n                if config.pin_bigfile and file_info[\"size\"] > 1024 * 1024 * config.pin_bigfile:\n                    is_pinned = 1\n\n\n            content_db.executeDelayed(\n                \"UPDATE file_optional SET time_downloaded = :now, is_downloaded = 1, peer = peer + 1, is_pinned = :is_pinned WHERE site_id = :site_id AND inner_path = :inner_path\",\n                {\"now\": int(time.time()), \"site_id\": content_db.site_ids[self.site.address], \"inner_path\": inner_path, \"is_pinned\": is_pinned}\n            )\n\n        super(WorkerManagerPlugin, self).doneTask(task)\n\n        if task[\"optional_hash_id\"] and not self.tasks:\n            content_db.processDelayed()\n\n\n@PluginManager.registerTo(\"UiRequest\")\nclass UiRequestPlugin(object):\n    def parsePath(self, path):\n        global access_log\n        path_parts = super(UiRequestPlugin, self).parsePath(path)\n        if path_parts:\n            site_id = ContentDbPlugin.content_db.site_ids.get(path_parts[\"request_address\"])\n            if site_id:\n                if ContentDbPlugin.content_db.isOptionalFile(site_id, path_parts[\"inner_path\"]):\n                    access_log[site_id][path_parts[\"inner_path\"]] = 1\n        return path_parts\n\n\n@PluginManager.registerTo(\"FileRequest\")\nclass FileRequestPlugin(object):\n    def actionGetFile(self, params):\n        stats = super(FileRequestPlugin, self).actionGetFile(params)\n        self.recordFileRequest(params[\"site\"], params[\"inner_path\"], stats)\n        return stats\n\n    def actionStreamFile(self, params):\n        stats = super(FileRequestPlugin, self).actionStreamFile(params)\n        self.recordFileRequest(params[\"site\"], params[\"inner_path\"], stats)\n        return stats\n\n    def recordFileRequest(self, site_address, inner_path, stats):\n        if not stats:\n            # Only track the last request of files\n            return False\n        site_id = ContentDbPlugin.content_db.site_ids[site_address]\n        if site_id and ContentDbPlugin.content_db.isOptionalFile(site_id, inner_path):\n            request_log[site_id][inner_path] += stats[\"bytes_sent\"]\n\n\n@PluginManager.registerTo(\"Site\")\nclass SitePlugin(object):\n    def isDownloadable(self, inner_path):\n        is_downloadable = super(SitePlugin, self).isDownloadable(inner_path)\n        if is_downloadable:\n            return is_downloadable\n\n        for path in self.settings.get(\"optional_help\", {}).iterkeys():\n            if inner_path.startswith(path):\n                return True\n\n        return False\n\n\n@PluginManager.registerTo(\"ConfigPlugin\")\nclass ConfigPlugin(object):\n    def createArguments(self):\n        group = self.parser.add_argument_group(\"OptionalManager plugin\")\n        group.add_argument('--optional_limit', help='Limit total size of optional files', default=\"10%\", metavar=\"GB or free space %\")\n        group.add_argument('--pin_bigfile', help='Automatically pin files larger than this limit', default=20, metavar=\"MB\", type=int)\n\n        return super(ConfigPlugin, self).createArguments()\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "OptionalManagerPlugin.py", "id": "10695b72f9c43711a63fd0d30260da55", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/plugins/OptionalManager/OptionalManagerPlugin.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}