{"author": "openai", "code": "import numpy as np\n\nfrom gym import utils, error\nfrom gym.envs.robotics import rotations, hand_env\nfrom gym.envs.robotics.utils import robot_get_obs\n\ntry:\n    import mujoco_py\nexcept ImportError as e:\n    raise error.DependencyNotInstalled(\"{}. (HINT: you need to install mujoco_py, and also perform the setup instructions here: https://github.com/openai/mujoco-py/.)\".format(e))\n\n\ndef quat_from_angle_and_axis(angle, axis):\n    assert axis.shape == (3,)\n    axis /= np.linalg.norm(axis)\n    quat = np.concatenate([[np.cos(angle / 2.)], np.sin(angle / 2.) * axis])\n    quat /= np.linalg.norm(quat)\n    return quat\n\n\nclass ManipulateEnv(hand_env.HandEnv, utils.EzPickle):\n    def __init__(\n        self, model_path, target_position, target_rotation,\n        target_position_range, reward_type, initial_qpos={},\n        randomize_initial_position=True, randomize_initial_rotation=True,\n        distance_threshold=0.01, rotation_threshold=0.1, n_substeps=20, relative_control=False,\n        ignore_z_target_rotation=False,\n    ):\n        \"\"\"Initializes a new Hand manipulation environment.\n\n        Args:\n            model_path (string): path to the environments XML file\n            target_position (string): the type of target position:\n                - ignore: target position is fully ignored, i.e. the object can be positioned arbitrarily\n                - fixed: target position is set to the initial position of the object\n                - random: target position is fully randomized according to target_position_range\n            target_rotation (string): the type of target rotation:\n                - ignore: target rotation is fully ignored, i.e. the object can be rotated arbitrarily\n                - fixed: target rotation is set to the initial rotation of the object\n                - xyz: fully randomized target rotation around the X, Y and Z axis\n                - z: fully randomized target rotation around the Z axis\n                - parallel: fully randomized target rotation around Z and axis-aligned rotation around X, Y\n            ignore_z_target_rotation (boolean): whether or not the Z axis of the target rotation is ignored\n            target_position_range (np.array of shape (3, 2)): range of the target_position randomization\n            reward_type ('sparse' or 'dense'): the reward type, i.e. sparse or dense\n            initial_qpos (dict): a dictionary of joint names and values that define the initial configuration\n            randomize_initial_position (boolean): whether or not to randomize the initial position of the object\n            randomize_initial_rotation (boolean): whether or not to randomize the initial rotation of the object\n            distance_threshold (float, in meters): the threshold after which the position of a goal is considered achieved\n            rotation_threshold (float, in radians): the threshold after which the rotation of a goal is considered achieved\n            n_substeps (int): number of substeps the simulation runs on every call to step\n            relative_control (boolean): whether or not the hand is actuated in absolute joint positions or relative to the current state\n        \"\"\"\n        self.target_position = target_position\n        self.target_rotation = target_rotation\n        self.target_position_range = target_position_range\n        self.parallel_quats = [rotations.euler2quat(r) for r in rotations.get_parallel_rotations()]\n        self.randomize_initial_rotation = randomize_initial_rotation\n        self.randomize_initial_position = randomize_initial_position\n        self.distance_threshold = distance_threshold\n        self.rotation_threshold = rotation_threshold\n        self.reward_type = reward_type\n        self.ignore_z_target_rotation = ignore_z_target_rotation\n\n        assert self.target_position in ['ignore', 'fixed', 'random']\n        assert self.target_rotation in ['ignore', 'fixed', 'xyz', 'z', 'parallel']\n\n        hand_env.HandEnv.__init__(\n            self, model_path, n_substeps=n_substeps, initial_qpos=initial_qpos,\n            relative_control=relative_control)\n        utils.EzPickle.__init__(self)\n\n    def _get_achieved_goal(self):\n        \n        object_qpos = self.sim.data.get_joint_qpos('object:joint')\n        assert object_qpos.shape == (7,)\n        return object_qpos\n\n    def _goal_distance(self, goal_a, goal_b):\n        assert goal_a.shape == goal_b.shape\n        assert goal_a.shape[-1] == 7\n\n        d_pos = np.zeros_like(goal_a[..., 0])\n        d_rot = np.zeros_like(goal_b[..., 0])\n        if self.target_position != 'ignore':\n            delta_pos = goal_a[..., :3] - goal_b[..., :3]\n            d_pos = np.linalg.norm(delta_pos, axis=-1)\n\n        if self.target_rotation != 'ignore':\n            quat_a, quat_b = goal_a[..., 3:], goal_b[..., 3:]\n\n            if self.ignore_z_target_rotation:\n                \n                \n                \n                \n                euler_a = rotations.quat2euler(quat_a)\n                euler_b = rotations.quat2euler(quat_b)\n                euler_a[2] = euler_b[2]\n                quat_a = rotations.euler2quat(euler_a)\n\n            \n            quat_diff = rotations.quat_mul(quat_a, rotations.quat_conjugate(quat_b))\n            angle_diff = 2 * np.arccos(np.clip(quat_diff[..., 0], -1., 1.))\n            d_rot = angle_diff\n        assert d_pos.shape == d_rot.shape\n        return d_pos, d_rot\n\n    \n    \n\n    def compute_reward(self, achieved_goal, goal, info):\n        if self.reward_type == 'sparse':\n            success = self._is_success(achieved_goal, goal).astype(np.float32)\n            return (success - 1.)\n        else:\n            d_pos, d_rot = self._goal_distance(achieved_goal, goal)\n            # We weigh the difference in position to avoid that `d_pos` (in meters) is completely\n            # dominated by `d_rot` (in radians).\n            return -(10. * d_pos + d_rot)\n\n    \n    \n\n    def _is_success(self, achieved_goal, desired_goal):\n        d_pos, d_rot = self._goal_distance(achieved_goal, desired_goal)\n        achieved_pos = (d_pos < self.distance_threshold).astype(np.float32)\n        achieved_rot = (d_rot < self.rotation_threshold).astype(np.float32)\n        achieved_both = achieved_pos * achieved_rot\n        return achieved_both\n\n    def _env_setup(self, initial_qpos):\n        for name, value in initial_qpos.items():\n            self.sim.data.set_joint_qpos(name, value)\n        self.sim.forward()\n\n    def _reset_sim(self):\n        self.sim.set_state(self.initial_state)\n        self.sim.forward()\n\n        initial_qpos = self.sim.data.get_joint_qpos('object:joint').copy()\n        initial_pos, initial_quat = initial_qpos[:3], initial_qpos[3:]\n        assert initial_qpos.shape == (7,)\n        assert initial_pos.shape == (3,)\n        assert initial_quat.shape == (4,)\n        initial_qpos = None\n\n        \n        if self.randomize_initial_rotation:\n            if self.target_rotation == 'z':\n                angle = self.np_random.uniform(-np.pi, np.pi)\n                axis = np.array([0., 0., 1.])\n                offset_quat = quat_from_angle_and_axis(angle, axis)\n                initial_quat = rotations.quat_mul(initial_quat, offset_quat)\n            elif self.target_rotation == 'parallel':\n                angle = self.np_random.uniform(-np.pi, np.pi)\n                axis = np.array([0., 0., 1.])\n                z_quat = quat_from_angle_and_axis(angle, axis)\n                parallel_quat = self.parallel_quats[self.np_random.randint(len(self.parallel_quats))]\n                offset_quat = rotations.quat_mul(z_quat, parallel_quat)\n                initial_quat = rotations.quat_mul(initial_quat, offset_quat)\n            elif self.target_rotation in ['xyz', 'ignore']:\n                angle = self.np_random.uniform(-np.pi, np.pi)\n                axis = np.random.uniform(-1., 1., size=3)\n                offset_quat = quat_from_angle_and_axis(angle, axis)\n                initial_quat = rotations.quat_mul(initial_quat, offset_quat)\n            elif self.target_rotation == 'fixed':\n                pass\n            else:\n                raise error.Error('Unknown target_rotation option \"{}\".'.format(self.target_rotation))\n\n        \n        if self.randomize_initial_position:\n            if self.target_position != 'fixed':\n                initial_pos += self.np_random.normal(size=3, scale=0.005)\n\n        initial_quat /= np.linalg.norm(initial_quat)\n        initial_qpos = np.concatenate([initial_pos, initial_quat])\n        self.sim.data.set_joint_qpos('object:joint', initial_qpos)\n\n        def is_on_palm():\n            self.sim.forward()\n            cube_middle_idx = self.sim.model.site_name2id('object:center')\n            cube_middle_pos = self.sim.data.site_xpos[cube_middle_idx]\n            is_on_palm = (cube_middle_pos[2] > 0.04)\n            return is_on_palm\n\n        \n        for _ in range(10):\n            self._set_action(np.zeros(20))\n            try:\n                self.sim.step()\n            except mujoco_py.MujocoException:\n                return False\n        return is_on_palm()\n\n    def _sample_goal(self):\n        \n        target_pos = None\n        if self.target_position == 'random':\n            assert self.target_position_range.shape == (3, 2)\n            offset = self.np_random.uniform(self.target_position_range[:, 0], self.target_position_range[:, 1])\n            assert offset.shape == (3,)\n            target_pos = self.sim.data.get_joint_qpos('object:joint')[:3] + offset\n        elif self.target_position in ['ignore', 'fixed']:\n            target_pos = self.sim.data.get_joint_qpos('object:joint')[:3]\n        else:\n            raise error.Error('Unknown target_position option \"{}\".'.format(self.target_position))\n        assert target_pos is not None\n        assert target_pos.shape == (3,)\n\n        \n        target_quat = None\n        if self.target_rotation == 'z':\n            angle = self.np_random.uniform(-np.pi, np.pi)\n            axis = np.array([0., 0., 1.])\n            target_quat = quat_from_angle_and_axis(angle, axis)\n        elif self.target_rotation == 'parallel':\n            angle = self.np_random.uniform(-np.pi, np.pi)\n            axis = np.array([0., 0., 1.])\n            target_quat = quat_from_angle_and_axis(angle, axis)\n            parallel_quat = self.parallel_quats[self.np_random.randint(len(self.parallel_quats))]\n            target_quat = rotations.quat_mul(target_quat, parallel_quat)\n        elif self.target_rotation == 'xyz':\n            angle = self.np_random.uniform(-np.pi, np.pi)\n            axis = np.random.uniform(-1., 1., size=3)\n            target_quat = quat_from_angle_and_axis(angle, axis)\n        elif self.target_rotation in ['ignore', 'fixed']:\n            target_quat = self.sim.data.get_joint_qpos('object:joint')\n        else:\n            raise error.Error('Unknown target_rotation option \"{}\".'.format(self.target_rotation))\n        assert target_quat is not None\n        assert target_quat.shape == (4,)\n\n        target_quat /= np.linalg.norm(target_quat)  \n        goal = np.concatenate([target_pos, target_quat])\n        return goal\n\n    def _render_callback(self):\n        \n        \n        goal = self.goal.copy()\n        assert goal.shape == (7,)\n        if self.target_position == 'ignore':\n            \n            goal[0] += 0.15\n        self.sim.data.set_joint_qpos('target:joint', goal)\n        self.sim.data.set_joint_qvel('target:joint', np.zeros(6))\n\n        if 'object_hidden' in self.sim.model.geom_names:\n            hidden_id = self.sim.model.geom_name2id('object_hidden')\n            self.sim.model.geom_rgba[hidden_id, 3] = 1.\n        self.sim.forward()\n\n    def _get_obs(self):\n        robot_qpos, robot_qvel = robot_get_obs(self.sim)\n        object_qvel = self.sim.data.get_joint_qvel('object:joint')\n        achieved_goal = self._get_achieved_goal().ravel()  # this contains the object position + rotation\n        observation = np.concatenate([robot_qpos, robot_qvel, object_qvel, achieved_goal])\n        return {\n            'observation': observation.copy(),\n            'achieved_goal': achieved_goal.copy(),\n            'desired_goal': self.goal.ravel().copy(),\n        }\n\n\nclass HandBlockEnv(ManipulateEnv):\n    def __init__(self, target_position='random', target_rotation='xyz', reward_type='sparse'):\n        super(HandBlockEnv, self).__init__(\n            model_path='hand/manipulate_block.xml', target_position=target_position,\n            target_rotation=target_rotation,\n            target_position_range=np.array([(-0.04, 0.04), (-0.06, 0.02), (0.0, 0.06)]),\n            reward_type=reward_type)\n\n\nclass HandEggEnv(ManipulateEnv):\n    def __init__(self, target_position='random', target_rotation='xyz', reward_type='sparse'):\n        super(HandEggEnv, self).__init__(\n            model_path='hand/manipulate_egg.xml', target_position=target_position,\n            target_rotation=target_rotation,\n            target_position_range=np.array([(-0.04, 0.04), (-0.06, 0.02), (0.0, 0.06)]),\n            reward_type=reward_type)\n\n\nclass HandPenEnv(ManipulateEnv):\n    def __init__(self, target_position='random', target_rotation='xyz', reward_type='sparse'):\n        super(HandPenEnv, self).__init__(\n            model_path='hand/manipulate_pen.xml', target_position=target_position,\n            target_rotation=target_rotation,\n            target_position_range=np.array([(-0.04, 0.04), (-0.06, 0.02), (0.0, 0.06)]),\n            randomize_initial_rotation=False, reward_type=reward_type,\n            ignore_z_target_rotation=True, distance_threshold=0.05)\n", "comments": "   initializes new hand manipulation environment           args              model path (string)  path environments xml file             target position (string)  type target position                    ignore  target position fully ignored  e  object positioned arbitrarily                   fixed  target position set initial position object                   random  target position fully randomized according target position range             target rotation (string)  type target rotation                    ignore  target rotation fully ignored  e  object rotated arbitrarily                   fixed  target rotation set initial rotation object                   xyz  fully randomized target rotation around x  y z axis                   z  fully randomized target rotation around z axis                   parallel  fully randomized target rotation around z axis aligned rotation around x  y             ignore z target rotation (boolean)  whether z axis target rotation ignored             target position range (np array shape (3  2))  range target position randomization             reward type ( sparse   dense )  reward type  e  sparse dense             initial qpos (dict)  dictionary joint names values define initial configuration             randomize initial position (boolean)  whether randomize initial position object             randomize initial rotation (boolean)  whether randomize initial rotation object             distance threshold (float  meters)  threshold position goal considered achieved             rotation threshold (float  radians)  threshold rotation goal considered achieved             n substeps (int)  number substeps simulation runs every call step             relative control (boolean)  whether hand actuated absolute joint positions relative current state                object position rotation     special case  we want ignore z component rotation     this code assumes euler angles xyz convention  we first transform    euler  set z component equal two  finally    transform back quaternions     subtract quaternions extract angle     goalenv methods                                    we weigh difference position avoid  pos  (in meters) completely    dominated  rot  (in radians)     robotenv methods                                    randomization initial rotation     randomize initial position     run simulation bunch timesteps let everything settle     select goal object position     select goal object rotation     normalized quaternion    assign current state target object offset bit actual object    obscured     move object side since care position     contains object position   rotation ", "content": "import numpy as np\n\nfrom gym import utils, error\nfrom gym.envs.robotics import rotations, hand_env\nfrom gym.envs.robotics.utils import robot_get_obs\n\ntry:\n    import mujoco_py\nexcept ImportError as e:\n    raise error.DependencyNotInstalled(\"{}. (HINT: you need to install mujoco_py, and also perform the setup instructions here: https://github.com/openai/mujoco-py/.)\".format(e))\n\n\ndef quat_from_angle_and_axis(angle, axis):\n    assert axis.shape == (3,)\n    axis /= np.linalg.norm(axis)\n    quat = np.concatenate([[np.cos(angle / 2.)], np.sin(angle / 2.) * axis])\n    quat /= np.linalg.norm(quat)\n    return quat\n\n\nclass ManipulateEnv(hand_env.HandEnv, utils.EzPickle):\n    def __init__(\n        self, model_path, target_position, target_rotation,\n        target_position_range, reward_type, initial_qpos={},\n        randomize_initial_position=True, randomize_initial_rotation=True,\n        distance_threshold=0.01, rotation_threshold=0.1, n_substeps=20, relative_control=False,\n        ignore_z_target_rotation=False,\n    ):\n        \"\"\"Initializes a new Hand manipulation environment.\n\n        Args:\n            model_path (string): path to the environments XML file\n            target_position (string): the type of target position:\n                - ignore: target position is fully ignored, i.e. the object can be positioned arbitrarily\n                - fixed: target position is set to the initial position of the object\n                - random: target position is fully randomized according to target_position_range\n            target_rotation (string): the type of target rotation:\n                - ignore: target rotation is fully ignored, i.e. the object can be rotated arbitrarily\n                - fixed: target rotation is set to the initial rotation of the object\n                - xyz: fully randomized target rotation around the X, Y and Z axis\n                - z: fully randomized target rotation around the Z axis\n                - parallel: fully randomized target rotation around Z and axis-aligned rotation around X, Y\n            ignore_z_target_rotation (boolean): whether or not the Z axis of the target rotation is ignored\n            target_position_range (np.array of shape (3, 2)): range of the target_position randomization\n            reward_type ('sparse' or 'dense'): the reward type, i.e. sparse or dense\n            initial_qpos (dict): a dictionary of joint names and values that define the initial configuration\n            randomize_initial_position (boolean): whether or not to randomize the initial position of the object\n            randomize_initial_rotation (boolean): whether or not to randomize the initial rotation of the object\n            distance_threshold (float, in meters): the threshold after which the position of a goal is considered achieved\n            rotation_threshold (float, in radians): the threshold after which the rotation of a goal is considered achieved\n            n_substeps (int): number of substeps the simulation runs on every call to step\n            relative_control (boolean): whether or not the hand is actuated in absolute joint positions or relative to the current state\n        \"\"\"\n        self.target_position = target_position\n        self.target_rotation = target_rotation\n        self.target_position_range = target_position_range\n        self.parallel_quats = [rotations.euler2quat(r) for r in rotations.get_parallel_rotations()]\n        self.randomize_initial_rotation = randomize_initial_rotation\n        self.randomize_initial_position = randomize_initial_position\n        self.distance_threshold = distance_threshold\n        self.rotation_threshold = rotation_threshold\n        self.reward_type = reward_type\n        self.ignore_z_target_rotation = ignore_z_target_rotation\n\n        assert self.target_position in ['ignore', 'fixed', 'random']\n        assert self.target_rotation in ['ignore', 'fixed', 'xyz', 'z', 'parallel']\n\n        hand_env.HandEnv.__init__(\n            self, model_path, n_substeps=n_substeps, initial_qpos=initial_qpos,\n            relative_control=relative_control)\n        utils.EzPickle.__init__(self)\n\n    def _get_achieved_goal(self):\n        # Object position and rotation.\n        object_qpos = self.sim.data.get_joint_qpos('object:joint')\n        assert object_qpos.shape == (7,)\n        return object_qpos\n\n    def _goal_distance(self, goal_a, goal_b):\n        assert goal_a.shape == goal_b.shape\n        assert goal_a.shape[-1] == 7\n\n        d_pos = np.zeros_like(goal_a[..., 0])\n        d_rot = np.zeros_like(goal_b[..., 0])\n        if self.target_position != 'ignore':\n            delta_pos = goal_a[..., :3] - goal_b[..., :3]\n            d_pos = np.linalg.norm(delta_pos, axis=-1)\n\n        if self.target_rotation != 'ignore':\n            quat_a, quat_b = goal_a[..., 3:], goal_b[..., 3:]\n\n            if self.ignore_z_target_rotation:\n                # Special case: We want to ignore the Z component of the rotation.\n                # This code here assumes Euler angles with xyz convention. We first transform\n                # to euler, then set the Z component to be equal between the two, and finally\n                # transform back into quaternions.\n                euler_a = rotations.quat2euler(quat_a)\n                euler_b = rotations.quat2euler(quat_b)\n                euler_a[2] = euler_b[2]\n                quat_a = rotations.euler2quat(euler_a)\n\n            # Subtract quaternions and extract angle between them.\n            quat_diff = rotations.quat_mul(quat_a, rotations.quat_conjugate(quat_b))\n            angle_diff = 2 * np.arccos(np.clip(quat_diff[..., 0], -1., 1.))\n            d_rot = angle_diff\n        assert d_pos.shape == d_rot.shape\n        return d_pos, d_rot\n\n    # GoalEnv methods\n    # ----------------------------\n\n    def compute_reward(self, achieved_goal, goal, info):\n        if self.reward_type == 'sparse':\n            success = self._is_success(achieved_goal, goal).astype(np.float32)\n            return (success - 1.)\n        else:\n            d_pos, d_rot = self._goal_distance(achieved_goal, goal)\n            # We weigh the difference in position to avoid that `d_pos` (in meters) is completely\n            # dominated by `d_rot` (in radians).\n            return -(10. * d_pos + d_rot)\n\n    # RobotEnv methods\n    # ----------------------------\n\n    def _is_success(self, achieved_goal, desired_goal):\n        d_pos, d_rot = self._goal_distance(achieved_goal, desired_goal)\n        achieved_pos = (d_pos < self.distance_threshold).astype(np.float32)\n        achieved_rot = (d_rot < self.rotation_threshold).astype(np.float32)\n        achieved_both = achieved_pos * achieved_rot\n        return achieved_both\n\n    def _env_setup(self, initial_qpos):\n        for name, value in initial_qpos.items():\n            self.sim.data.set_joint_qpos(name, value)\n        self.sim.forward()\n\n    def _reset_sim(self):\n        self.sim.set_state(self.initial_state)\n        self.sim.forward()\n\n        initial_qpos = self.sim.data.get_joint_qpos('object:joint').copy()\n        initial_pos, initial_quat = initial_qpos[:3], initial_qpos[3:]\n        assert initial_qpos.shape == (7,)\n        assert initial_pos.shape == (3,)\n        assert initial_quat.shape == (4,)\n        initial_qpos = None\n\n        # Randomization initial rotation.\n        if self.randomize_initial_rotation:\n            if self.target_rotation == 'z':\n                angle = self.np_random.uniform(-np.pi, np.pi)\n                axis = np.array([0., 0., 1.])\n                offset_quat = quat_from_angle_and_axis(angle, axis)\n                initial_quat = rotations.quat_mul(initial_quat, offset_quat)\n            elif self.target_rotation == 'parallel':\n                angle = self.np_random.uniform(-np.pi, np.pi)\n                axis = np.array([0., 0., 1.])\n                z_quat = quat_from_angle_and_axis(angle, axis)\n                parallel_quat = self.parallel_quats[self.np_random.randint(len(self.parallel_quats))]\n                offset_quat = rotations.quat_mul(z_quat, parallel_quat)\n                initial_quat = rotations.quat_mul(initial_quat, offset_quat)\n            elif self.target_rotation in ['xyz', 'ignore']:\n                angle = self.np_random.uniform(-np.pi, np.pi)\n                axis = np.random.uniform(-1., 1., size=3)\n                offset_quat = quat_from_angle_and_axis(angle, axis)\n                initial_quat = rotations.quat_mul(initial_quat, offset_quat)\n            elif self.target_rotation == 'fixed':\n                pass\n            else:\n                raise error.Error('Unknown target_rotation option \"{}\".'.format(self.target_rotation))\n\n        # Randomize initial position.\n        if self.randomize_initial_position:\n            if self.target_position != 'fixed':\n                initial_pos += self.np_random.normal(size=3, scale=0.005)\n\n        initial_quat /= np.linalg.norm(initial_quat)\n        initial_qpos = np.concatenate([initial_pos, initial_quat])\n        self.sim.data.set_joint_qpos('object:joint', initial_qpos)\n\n        def is_on_palm():\n            self.sim.forward()\n            cube_middle_idx = self.sim.model.site_name2id('object:center')\n            cube_middle_pos = self.sim.data.site_xpos[cube_middle_idx]\n            is_on_palm = (cube_middle_pos[2] > 0.04)\n            return is_on_palm\n\n        # Run the simulation for a bunch of timesteps to let everything settle in.\n        for _ in range(10):\n            self._set_action(np.zeros(20))\n            try:\n                self.sim.step()\n            except mujoco_py.MujocoException:\n                return False\n        return is_on_palm()\n\n    def _sample_goal(self):\n        # Select a goal for the object position.\n        target_pos = None\n        if self.target_position == 'random':\n            assert self.target_position_range.shape == (3, 2)\n            offset = self.np_random.uniform(self.target_position_range[:, 0], self.target_position_range[:, 1])\n            assert offset.shape == (3,)\n            target_pos = self.sim.data.get_joint_qpos('object:joint')[:3] + offset\n        elif self.target_position in ['ignore', 'fixed']:\n            target_pos = self.sim.data.get_joint_qpos('object:joint')[:3]\n        else:\n            raise error.Error('Unknown target_position option \"{}\".'.format(self.target_position))\n        assert target_pos is not None\n        assert target_pos.shape == (3,)\n\n        # Select a goal for the object rotation.\n        target_quat = None\n        if self.target_rotation == 'z':\n            angle = self.np_random.uniform(-np.pi, np.pi)\n            axis = np.array([0., 0., 1.])\n            target_quat = quat_from_angle_and_axis(angle, axis)\n        elif self.target_rotation == 'parallel':\n            angle = self.np_random.uniform(-np.pi, np.pi)\n            axis = np.array([0., 0., 1.])\n            target_quat = quat_from_angle_and_axis(angle, axis)\n            parallel_quat = self.parallel_quats[self.np_random.randint(len(self.parallel_quats))]\n            target_quat = rotations.quat_mul(target_quat, parallel_quat)\n        elif self.target_rotation == 'xyz':\n            angle = self.np_random.uniform(-np.pi, np.pi)\n            axis = np.random.uniform(-1., 1., size=3)\n            target_quat = quat_from_angle_and_axis(angle, axis)\n        elif self.target_rotation in ['ignore', 'fixed']:\n            target_quat = self.sim.data.get_joint_qpos('object:joint')\n        else:\n            raise error.Error('Unknown target_rotation option \"{}\".'.format(self.target_rotation))\n        assert target_quat is not None\n        assert target_quat.shape == (4,)\n\n        target_quat /= np.linalg.norm(target_quat)  # normalized quaternion\n        goal = np.concatenate([target_pos, target_quat])\n        return goal\n\n    def _render_callback(self):\n        # Assign current state to target object but offset a bit so that the actual object\n        # is not obscured.\n        goal = self.goal.copy()\n        assert goal.shape == (7,)\n        if self.target_position == 'ignore':\n            # Move the object to the side since we do not care about it's position.\n            goal[0] += 0.15\n        self.sim.data.set_joint_qpos('target:joint', goal)\n        self.sim.data.set_joint_qvel('target:joint', np.zeros(6))\n\n        if 'object_hidden' in self.sim.model.geom_names:\n            hidden_id = self.sim.model.geom_name2id('object_hidden')\n            self.sim.model.geom_rgba[hidden_id, 3] = 1.\n        self.sim.forward()\n\n    def _get_obs(self):\n        robot_qpos, robot_qvel = robot_get_obs(self.sim)\n        object_qvel = self.sim.data.get_joint_qvel('object:joint')\n        achieved_goal = self._get_achieved_goal().ravel()  # this contains the object position + rotation\n        observation = np.concatenate([robot_qpos, robot_qvel, object_qvel, achieved_goal])\n        return {\n            'observation': observation.copy(),\n            'achieved_goal': achieved_goal.copy(),\n            'desired_goal': self.goal.ravel().copy(),\n        }\n\n\nclass HandBlockEnv(ManipulateEnv):\n    def __init__(self, target_position='random', target_rotation='xyz', reward_type='sparse'):\n        super(HandBlockEnv, self).__init__(\n            model_path='hand/manipulate_block.xml', target_position=target_position,\n            target_rotation=target_rotation,\n            target_position_range=np.array([(-0.04, 0.04), (-0.06, 0.02), (0.0, 0.06)]),\n            reward_type=reward_type)\n\n\nclass HandEggEnv(ManipulateEnv):\n    def __init__(self, target_position='random', target_rotation='xyz', reward_type='sparse'):\n        super(HandEggEnv, self).__init__(\n            model_path='hand/manipulate_egg.xml', target_position=target_position,\n            target_rotation=target_rotation,\n            target_position_range=np.array([(-0.04, 0.04), (-0.06, 0.02), (0.0, 0.06)]),\n            reward_type=reward_type)\n\n\nclass HandPenEnv(ManipulateEnv):\n    def __init__(self, target_position='random', target_rotation='xyz', reward_type='sparse'):\n        super(HandPenEnv, self).__init__(\n            model_path='hand/manipulate_pen.xml', target_position=target_position,\n            target_rotation=target_rotation,\n            target_position_range=np.array([(-0.04, 0.04), (-0.06, 0.02), (0.0, 0.06)]),\n            randomize_initial_rotation=False, reward_type=reward_type,\n            ignore_z_target_rotation=True, distance_threshold=0.05)\n", "description": "A toolkit for developing and comparing reinforcement learning algorithms.", "file_name": "manipulate.py", "id": "c232785f33bb707d7adf42bdf8e68135", "language": "Python", "project_name": "gym", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/openai-gym/openai-gym-6160181/gym/envs/robotics/hand/manipulate.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:30:35Z", "url": "https://github.com/openai/gym", "wiki": true}