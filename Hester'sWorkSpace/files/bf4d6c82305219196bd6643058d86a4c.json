{"author": "kennethreitz", "code": "# -*- coding: utf-8 -*-\n\n\"\"\"\nlegit.cli\n~~~~~~~~~\n\nThis module provides the CLI interface to legit.\n\"\"\"\nimport os\n\nimport click\nfrom clint import resources\nfrom clint.textui import columns\nimport crayons\n\nfrom .core import __version__\nfrom .scm import SCMRepo\nfrom .settings import legit_settings\nfrom .utils import black, format_help, order_manually, output_aliases, status_log, verbose_echo\n\n\nCONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])\npass_scm = click.make_pass_decorator(SCMRepo)\n\n\nclass LegitGroup(click.Group):\n    \"\"\"Custom Group class with specially sorted command list\"\"\"\n\n    command_aliases = {\n        'pub': 'publish',\n        'sw': 'switch',\n        'sy': 'sync',\n        'unp': 'unpublish',\n        'un': 'undo',\n    }\n\n    def list_commands(self, ctx):\n        \"\"\"Override for showing commands in particular order\"\"\"\n        commands = super(LegitGroup, self).list_commands(ctx)\n        return [cmd for cmd in order_manually(commands)]\n\n    def get_command(self, ctx, cmd_name):\n        \"\"\"Override to handle command aliases\"\"\"\n        rv = click.Group.get_command(self, ctx, cmd_name)\n        if rv is not None:\n            return rv\n        cmd_name = self.command_aliases.get(cmd_name, \"\")\n        return click.Group.get_command(self, ctx, cmd_name)\n\n    def get_help_option(self, ctx):\n        \"\"\"Override for showing formatted main help via --help and -h options\"\"\"\n        help_options = self.get_help_option_names(ctx)\n        if not help_options or not self.add_help_option:\n            return\n\n        def show_help(ctx, param, value):\n            if value and not ctx.resilient_parsing:\n                if not ctx.obj:\n                    \n                    click.echo(format_help(ctx.get_help()))\n                else:\n                    \n                    click.echo(ctx.get_help(), color=ctx.color)\n                ctx.exit()\n        return click.Option(\n            help_options,\n            is_flag=True,\n            is_eager=True,\n            expose_value=False,\n            callback=show_help,\n            help='Show this message and exit.')\n\n\n@click.group(cls=LegitGroup, invoke_without_command=True, context_settings=CONTEXT_SETTINGS)\n@click.version_option(prog_name=black('legit', bold=True), version=__version__)\n@click.option('--verbose', is_flag=True, help='Enables verbose mode.')\n@click.option('--fake', is_flag=True, help='Show but do not invoke git commands.')\n@click.option('--install', is_flag=True, help='Install legit git aliases.')\n@click.option('--uninstall', is_flag=True, help='Uninstall legit git aliases.')\n@click.option('--config', is_flag=True, help='Edit legit configuration file.')\n@click.pass_context\ndef cli(ctx, verbose, fake, install, uninstall, config):\n    \"\"\"legit command line interface\"\"\"\n    \n    \n    \n    ctx.obj = SCMRepo()\n    ctx.obj.fake = fake\n    ctx.obj.verbose = fake or verbose\n\n    if install:\n        do_install(ctx, verbose, fake)\n        ctx.exit()\n    elif uninstall:\n        do_uninstall(ctx, verbose, fake)\n        ctx.exit()\n    elif config:\n        do_edit_settings(fake)\n        ctx.exit()\n    else:\n        if ctx.invoked_subcommand is None:\n            \n            click.echo(format_help(ctx.get_help()))\n\n\n@cli.command(short_help='Switches to specified branch.')\n@click.argument('to_branch', required=False)\n@click.option('--verbose', is_flag=True, help='Enables verbose mode.')\n@click.option('--fake', is_flag=True, help='Show but do not invoke git commands.')\n@pass_scm\ndef switch(scm, to_branch, verbose, fake):\n    \"\"\"Switches from one branch to another, safely stashing and restoring local changes.\n    \"\"\"\n    scm.fake = fake\n    scm.verbose = fake or verbose\n\n    scm.repo_check()\n\n    if to_branch is None:\n        scm.display_available_branches()\n        raise click.BadArgumentUsage('Please specify a branch to switch to')\n\n    scm.stash_log()\n    status_log(scm.checkout_branch, 'Switching to {0}.'.format(\n        crayons.yellow(to_branch)), to_branch)\n    scm.unstash_log()\n\n\n@cli.command(short_help='Synchronizes the given branch with remote.')\n@click.argument('to_branch', required=False)\n@click.option('--verbose', is_flag=True, help='Enables verbose mode.')\n@click.option('--fake', is_flag=True, help='Show but do not invoke git commands.')\n@pass_scm\n@click.pass_context\ndef sync(ctx, scm, to_branch, verbose, fake):\n    \"\"\"Stashes unstaged changes, Fetches remote data, Performs smart\n    pull+merge, Pushes local commits up, and Unstashes changes.\n\n    Defaults to current branch.\n    \"\"\"\n    scm.fake = fake\n    scm.verbose = fake or verbose\n\n    scm.repo_check(require_remote=True)\n\n    if to_branch:\n        \n        branch = scm.fuzzy_match_branch(to_branch)\n        if branch:\n            is_external = True\n            original_branch = scm.get_current_branch_name()\n        else:\n            raise click.BadArgumentUsage(\n                \"Branch {0} does not exist. Use an existing branch.\"\n                .format(crayons.yellow(branch)))\n    else:\n        \n        branch = scm.get_current_branch_name()\n        is_external = False\n\n    if branch in scm.get_branch_names(local=False):\n        if is_external:\n            ctx.invoke(switch, to_branch=branch, verbose=verbose, fake=fake)\n        scm.stash_log(sync=True)\n        status_log(scm.smart_pull, 'Pulling commits from the server.')\n        status_log(scm.push, 'Pushing commits to the server.', branch)\n        scm.unstash_log(sync=True)\n        if is_external:\n            ctx.invoke(switch, to_branch=original_branch, verbose=verbose, fake=fake)\n    else:\n        raise click.BadArgumentUsage(\n            \"Branch {0} is not published. Publish before syncing.\"\n            .format(crayons.yellow(branch)))\n\n\n@cli.command(short_help='Publishes specified branch to the remote.')\n@click.argument('to_branch', required=False)\n@click.option('--verbose', is_flag=True, help='Enables verbose mode.')\n@click.option('--fake', is_flag=True, help='Show but do not invoke git commands.')\n@pass_scm\ndef publish(scm, to_branch, verbose, fake):\n    \"\"\"Pushes an unpublished branch to a remote repository.\"\"\"\n    scm.fake = fake\n    scm.verbose = fake or verbose\n\n    scm.repo_check(require_remote=True)\n    branch = scm.fuzzy_match_branch(to_branch)\n\n    if not branch:\n        branch = scm.get_current_branch_name()\n        scm.display_available_branches()\n        if to_branch is None:\n            click.echo(\"Using current branch {0}\".format(crayons.yellow(branch)))\n        else:\n            click.echo(\n                \"Branch {0} not found, using current branch {1}\"\n                .format(crayons.red(to_branch), crayons.yellow(branch)))\n\n    branch_names = scm.get_branch_names(local=False)\n\n    if branch in branch_names:\n        raise click.BadArgumentUsage(\n            \"Branch {0} is already published. Use a branch that is not published.\"\n            .format(crayons.yellow(branch)))\n\n    status_log(scm.publish_branch, 'Publishing {0}.'.format(\n        crayons.yellow(branch)), branch)\n\n\n@cli.command(short_help='Removes specified branch from the remote.')\n@click.argument('published_branch', required=False)\n@click.option('--verbose', is_flag=True, help='Enables verbose mode.')\n@click.option('--fake', is_flag=True, help='Show but do not invoke git commands.')\n@pass_scm\ndef unpublish(scm, published_branch, verbose, fake):\n    \"\"\"Removes a published branch from the remote repository.\"\"\"\n    scm.fake = fake\n    scm.verbose = fake or verbose\n\n    scm.repo_check(require_remote=True)\n    branch = scm.fuzzy_match_branch(published_branch)\n\n    if not branch:\n        scm.display_available_branches()\n        raise click.BadArgumentUsage('Please specify a branch to unpublish')\n\n    branch_names = scm.get_branch_names(local=False)\n\n    if branch not in branch_names:\n        raise click.BadArgumentUsage(\n            \"Branch {0} is not published. Use a branch that is published.\"\n            .format(crayons.yellow(branch)))\n\n    status_log(scm.unpublish_branch, 'Unpublishing {0}.'.format(\n        crayons.yellow(branch)), branch)\n\n\n@cli.command()\n@click.option('--verbose', is_flag=True, help='Enables verbose mode.')\n@click.option('--fake', is_flag=True, help='Show but do not invoke git commands.')\n@click.option('--hard', is_flag=True, help='Discard local changes.')\n@pass_scm\ndef undo(scm, verbose, fake, hard):\n    \"\"\"Removes the last commit from history.\"\"\"\n    scm.fake = fake\n    scm.verbose = fake or verbose\n\n    scm.repo_check()\n\n    status_log(scm.undo, 'Last commit removed from history.', hard)\n\n\n@cli.command()\n@pass_scm\ndef branches(scm):\n    \"\"\"Displays a list of branches.\"\"\"\n    scm.repo_check()\n\n    scm.display_available_branches()\n\n\ndef do_install(ctx, verbose, fake):\n    \"\"\"Installs legit git aliases.\"\"\"\n    click.echo('The following git aliases will be installed:\\n')\n    aliases = cli.list_commands(ctx)\n    output_aliases(aliases)\n\n    if click.confirm('\\n{}Install aliases above?'.format('FAKE ' if fake else ''), default=fake):\n        for alias in aliases:\n            cmd = '!legit ' + alias\n            system_command = 'git config --global --replace-all alias.{0} \"{1}\"'.format(alias, cmd)\n            verbose_echo(system_command, verbose, fake)\n            if not fake:\n                os.system(system_command)\n        if not fake:\n            click.echo(\"\\nAliases installed.\")\n    else:\n        click.echo(\"\\nAliases will not be installed.\")\n\n\ndef do_uninstall(ctx, verbose, fake):\n    \"\"\"Uninstalls legit git aliases, including deprecated legit sub-commands.\"\"\"\n    aliases = cli.list_commands(ctx)\n    \n    aliases.extend(['graft', 'harvest', 'sprout', 'resync', 'settings', 'install', 'uninstall'])\n    for alias in aliases:\n        system_command = 'git config --global --unset-all alias.{0}'.format(alias)\n        verbose_echo(system_command, verbose, fake)\n        if not fake:\n            os.system(system_command)\n    if not fake:\n        click.echo('\\nThe following git aliases are uninstalled:\\n')\n        output_aliases(aliases)\n\n\ndef do_edit_settings(fake):\n    \"\"\"Opens legit settings in editor.\"\"\"\n\n    path = resources.user.open('config.ini').name\n\n    click.echo('Legit Settings:\\n')\n\n    for (option, _, description) in legit_settings.config_defaults:\n        click.echo(columns([crayons.yellow(option), 25], [description, None]))\n    click.echo(\"\")  \n\n    if fake:\n        click.echo(crayons.red('Faked! >>> edit {}'.format(path)))\n    else:\n        click.edit(path)\n\n\ndef handle_abort(aborted, type=None):\n    click.echo('{0} {1}'.format(crayons.red('Error:'), aborted.message))\n    click.echo(str(aborted.log))\n    if type == 'merge':\n        click.echo('Unfortunately, there was a merge conflict.'\n                   ' It has to be merged manually.')\n    elif type == 'unpublish':\n        click.echo(\n            )\n    raise click.Abort\n\n\nlegit_settings.abort_handler = handle_abort\n", "comments": "    legit cli            this module provides cli interface legit      import os  import click clint import resources clint textui import columns import crayons   core import   version    scm import scmrepo  settings import legit settings  utils import black  format help  order manually  output aliases  status log  verbose echo   context settings   dict(help option names    h      help  ) pass scm   click make pass decorator(scmrepo)   class legitgroup(click group)         custom group class specially sorted command list         command aliases              pub    publish            sw    switch            sy    sync            unp    unpublish            un    undo              def list commands(self  ctx)             override showing commands particular order            commands   super(legitgroup  self) list commands(ctx)         return  cmd cmd order manually(commands)       def get command(self  ctx  cmd name)             override handle command aliases            rv   click group get command(self  ctx  cmd name)         rv none              return rv         cmd name   self command aliases get(cmd name    )         return click group get command(self  ctx  cmd name)      def get help option(self  ctx)             override showing formatted main help via   help  h options            help options   self get help option names(ctx)         help options self add help option              return          def show help(ctx  param  value)              value ctx resilient parsing                  ctx obj                        legit main help                     click echo(format help(ctx get help()))                 else                        legit sub command help                     click echo(ctx get help()  color ctx color)                 ctx exit()         return click option(             help options              flag true              eager true              expose value false              callback show help              help  show message exit  )    click group(cls legitgroup  invoke without command true  context settings context settings)  click version option(prog name black( legit   bold true)  version   version  )  click option(   verbose   flag true  help  enables verbose mode  )  click option(   fake   flag true  help  show invoke git commands  )  click option(   install   flag true  help  install legit git aliases  )  click option(   uninstall   flag true  help  uninstall legit git aliases  )  click option(   config   flag true  help  edit legit configuration file  )  click pass context def cli(ctx  verbose  fake  install  uninstall  config)         legit command line interface          create repo object remember context object   from       point onwards commands refer using        pass scm decorator      ctx obj   scmrepo()     ctx obj fake   fake     ctx obj verbose   fake verbose      install          install(ctx  verbose  fake)         ctx exit()     elif uninstall          uninstall(ctx  verbose  fake)         ctx exit()     elif config          edit settings(fake)         ctx exit()     else          ctx invoked subcommand none                display help user commands passed              click echo(format help(ctx get help()))    cli command(short help  switches specified branch  )  click argument( branch   required false)  click option(   verbose   flag true  help  enables verbose mode  )  click option(   fake   flag true  help  show invoke git commands  )  pass scm def switch(scm  branch  verbose  fake)         switches one branch another  safely stashing restoring local changes              scm fake   fake     scm verbose   fake verbose      scm repo check()      branch none          scm display available branches()         raise click badargumentusage( please specify branch switch )      scm stash log()     status log(scm checkout branch   switching  0    format(         crayons yellow(to branch))  branch)     scm unstash log()    cli command(short help  synchronizes given branch remote  )  click argument( branch   required false)  click option(   verbose   flag true  help  enables verbose mode  )  click option(   fake   flag true  help  show invoke git commands  )  pass scm  click pass context def sync(ctx  scm  branch  verbose  fake)         stashes unstaged changes  fetches remote data  performs smart     pull merge  pushes local commits  unstashes changes       defaults current branch              scm fake   fake     scm verbose   fake verbose      scm repo check(require remote true)      branch            optional branch specifier          branch   scm fuzzy match branch(to branch)         branch              external   true             original branch   scm get current branch name()         else              raise click badargumentusage(                  branch  0  exist  use existing branch                    format(crayons yellow(branch)))     else            sync current branch          branch   scm get current branch name()         external   false      branch scm get branch names(local false)          external              ctx invoke(switch  branch branch  verbose verbose  fake fake)         scm stash log(sync true)         status log(scm smart pull   pulling commits server  )         status log(scm push   pushing commits server    branch)         scm unstash log(sync true)         external              ctx invoke(switch  branch original branch  verbose verbose  fake fake)     else          raise click badargumentusage(              branch  0  published  publish syncing                format(crayons yellow(branch)))    cli command(short help  publishes specified branch remote  )  click argument( branch   required false)  click option(   verbose   flag true  help  enables verbose mode  )  click option(   fake   flag true  help  show invoke git commands  )  pass scm def publish(scm  branch  verbose  fake)         pushes unpublished branch remote repository         scm fake   fake     scm verbose   fake verbose      scm repo check(require remote true)     branch   scm fuzzy match branch(to branch)      branch          branch   scm get current branch name()         scm display available branches()         branch none              click echo( using current branch  0   format(crayons yellow(branch)))         else              click echo(                  branch  0  found  using current branch  1                    format(crayons red(to branch)  crayons yellow(branch)))      branch names   scm get branch names(local false)      branch branch names          raise click badargumentusage(              branch  0  already published  use branch published                format(crayons yellow(branch)))      status log(scm publish branch   publishing  0    format(         crayons yellow(branch))  branch)    cli command(short help  removes specified branch remote  )  click argument( published branch   required false)  click option(   verbose   flag true  help  enables verbose mode  )  click option(   fake   flag true  help  show invoke git commands  )  pass scm def unpublish(scm  published branch  verbose  fake)         removes published branch remote repository         scm fake   fake     scm verbose   fake verbose      scm repo check(require remote true)     branch   scm fuzzy match branch(published branch)      branch          scm display available branches()         raise click badargumentusage( please specify branch unpublish )      branch names   scm get branch names(local false)      branch branch names          raise click badargumentusage(              branch  0  published  use branch published                format(crayons yellow(branch)))      status log(scm unpublish branch   unpublishing  0    format(         crayons yellow(branch))  branch)    cli command()  click option(   verbose   flag true  help  enables verbose mode  )  click option(   fake   flag true  help  show invoke git commands  )  click option(   hard   flag true  help  discard local changes  )  pass scm def undo(scm  verbose  fake  hard)         removes last commit history         scm fake   fake     scm verbose   fake verbose      scm repo check()      status log(scm undo   last commit removed history    hard)    cli command()  pass scm def branches(scm)         displays list branches         scm repo check()      scm display available branches()   def install(ctx  verbose  fake)         installs legit git aliases         click echo( the following git aliases installed  n )     aliases   cli list commands(ctx)     output aliases(aliases)      click confirm(  n  install aliases   format( fake   fake else   )  default fake)          alias aliases              cmd     legit     alias             system command    git config   global   replace alias  0    1    format(alias  cmd)             verbose echo(system command  verbose  fake)             fake                  os system(system command)         fake              click echo(  naliases installed  )     else          click echo(  naliases installed  )   def uninstall(ctx  verbose  fake)         uninstalls legit git aliases  including deprecated legit sub commands         aliases   cli list commands(ctx)       add deprecated aliases     aliases extend(  graft    harvest    sprout    resync    settings    install    uninstall  )     alias aliases          system command    git config   global   unset alias  0   format(alias)         verbose echo(system command  verbose  fake)         fake              os system(system command)     fake          click echo(  nthe following git aliases uninstalled  n )         output aliases(aliases)   def edit settings(fake)         opens legit settings editor         it seems remote branch deleted              if  legit branches  still shows published              probably branch deleted remote someone else              you run  git fetch   prune  update remote information                         coding  utf 8        legit main help    legit sub command help    create repo object remember context object   from    point onwards commands refer using     pass scm decorator     display help user commands passed     optional branch specifier     sync current branch     add deprecated aliases    separate settings info os output ", "content": "# -*- coding: utf-8 -*-\n\n\"\"\"\nlegit.cli\n~~~~~~~~~\n\nThis module provides the CLI interface to legit.\n\"\"\"\nimport os\n\nimport click\nfrom clint import resources\nfrom clint.textui import columns\nimport crayons\n\nfrom .core import __version__\nfrom .scm import SCMRepo\nfrom .settings import legit_settings\nfrom .utils import black, format_help, order_manually, output_aliases, status_log, verbose_echo\n\n\nCONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])\npass_scm = click.make_pass_decorator(SCMRepo)\n\n\nclass LegitGroup(click.Group):\n    \"\"\"Custom Group class with specially sorted command list\"\"\"\n\n    command_aliases = {\n        'pub': 'publish',\n        'sw': 'switch',\n        'sy': 'sync',\n        'unp': 'unpublish',\n        'un': 'undo',\n    }\n\n    def list_commands(self, ctx):\n        \"\"\"Override for showing commands in particular order\"\"\"\n        commands = super(LegitGroup, self).list_commands(ctx)\n        return [cmd for cmd in order_manually(commands)]\n\n    def get_command(self, ctx, cmd_name):\n        \"\"\"Override to handle command aliases\"\"\"\n        rv = click.Group.get_command(self, ctx, cmd_name)\n        if rv is not None:\n            return rv\n        cmd_name = self.command_aliases.get(cmd_name, \"\")\n        return click.Group.get_command(self, ctx, cmd_name)\n\n    def get_help_option(self, ctx):\n        \"\"\"Override for showing formatted main help via --help and -h options\"\"\"\n        help_options = self.get_help_option_names(ctx)\n        if not help_options or not self.add_help_option:\n            return\n\n        def show_help(ctx, param, value):\n            if value and not ctx.resilient_parsing:\n                if not ctx.obj:\n                    # legit main help\n                    click.echo(format_help(ctx.get_help()))\n                else:\n                    # legit sub-command help\n                    click.echo(ctx.get_help(), color=ctx.color)\n                ctx.exit()\n        return click.Option(\n            help_options,\n            is_flag=True,\n            is_eager=True,\n            expose_value=False,\n            callback=show_help,\n            help='Show this message and exit.')\n\n\n@click.group(cls=LegitGroup, invoke_without_command=True, context_settings=CONTEXT_SETTINGS)\n@click.version_option(prog_name=black('legit', bold=True), version=__version__)\n@click.option('--verbose', is_flag=True, help='Enables verbose mode.')\n@click.option('--fake', is_flag=True, help='Show but do not invoke git commands.')\n@click.option('--install', is_flag=True, help='Install legit git aliases.')\n@click.option('--uninstall', is_flag=True, help='Uninstall legit git aliases.')\n@click.option('--config', is_flag=True, help='Edit legit configuration file.')\n@click.pass_context\ndef cli(ctx, verbose, fake, install, uninstall, config):\n    \"\"\"legit command line interface\"\"\"\n    # Create a repo object and remember it as as the context object.  From\n    # this point onwards other commands can refer to it by using the\n    # @pass_scm decorator.\n    ctx.obj = SCMRepo()\n    ctx.obj.fake = fake\n    ctx.obj.verbose = fake or verbose\n\n    if install:\n        do_install(ctx, verbose, fake)\n        ctx.exit()\n    elif uninstall:\n        do_uninstall(ctx, verbose, fake)\n        ctx.exit()\n    elif config:\n        do_edit_settings(fake)\n        ctx.exit()\n    else:\n        if ctx.invoked_subcommand is None:\n            # Display help to user if no commands were passed.\n            click.echo(format_help(ctx.get_help()))\n\n\n@cli.command(short_help='Switches to specified branch.')\n@click.argument('to_branch', required=False)\n@click.option('--verbose', is_flag=True, help='Enables verbose mode.')\n@click.option('--fake', is_flag=True, help='Show but do not invoke git commands.')\n@pass_scm\ndef switch(scm, to_branch, verbose, fake):\n    \"\"\"Switches from one branch to another, safely stashing and restoring local changes.\n    \"\"\"\n    scm.fake = fake\n    scm.verbose = fake or verbose\n\n    scm.repo_check()\n\n    if to_branch is None:\n        scm.display_available_branches()\n        raise click.BadArgumentUsage('Please specify a branch to switch to')\n\n    scm.stash_log()\n    status_log(scm.checkout_branch, 'Switching to {0}.'.format(\n        crayons.yellow(to_branch)), to_branch)\n    scm.unstash_log()\n\n\n@cli.command(short_help='Synchronizes the given branch with remote.')\n@click.argument('to_branch', required=False)\n@click.option('--verbose', is_flag=True, help='Enables verbose mode.')\n@click.option('--fake', is_flag=True, help='Show but do not invoke git commands.')\n@pass_scm\n@click.pass_context\ndef sync(ctx, scm, to_branch, verbose, fake):\n    \"\"\"Stashes unstaged changes, Fetches remote data, Performs smart\n    pull+merge, Pushes local commits up, and Unstashes changes.\n\n    Defaults to current branch.\n    \"\"\"\n    scm.fake = fake\n    scm.verbose = fake or verbose\n\n    scm.repo_check(require_remote=True)\n\n    if to_branch:\n        # Optional branch specifier.\n        branch = scm.fuzzy_match_branch(to_branch)\n        if branch:\n            is_external = True\n            original_branch = scm.get_current_branch_name()\n        else:\n            raise click.BadArgumentUsage(\n                \"Branch {0} does not exist. Use an existing branch.\"\n                .format(crayons.yellow(branch)))\n    else:\n        # Sync current branch.\n        branch = scm.get_current_branch_name()\n        is_external = False\n\n    if branch in scm.get_branch_names(local=False):\n        if is_external:\n            ctx.invoke(switch, to_branch=branch, verbose=verbose, fake=fake)\n        scm.stash_log(sync=True)\n        status_log(scm.smart_pull, 'Pulling commits from the server.')\n        status_log(scm.push, 'Pushing commits to the server.', branch)\n        scm.unstash_log(sync=True)\n        if is_external:\n            ctx.invoke(switch, to_branch=original_branch, verbose=verbose, fake=fake)\n    else:\n        raise click.BadArgumentUsage(\n            \"Branch {0} is not published. Publish before syncing.\"\n            .format(crayons.yellow(branch)))\n\n\n@cli.command(short_help='Publishes specified branch to the remote.')\n@click.argument('to_branch', required=False)\n@click.option('--verbose', is_flag=True, help='Enables verbose mode.')\n@click.option('--fake', is_flag=True, help='Show but do not invoke git commands.')\n@pass_scm\ndef publish(scm, to_branch, verbose, fake):\n    \"\"\"Pushes an unpublished branch to a remote repository.\"\"\"\n    scm.fake = fake\n    scm.verbose = fake or verbose\n\n    scm.repo_check(require_remote=True)\n    branch = scm.fuzzy_match_branch(to_branch)\n\n    if not branch:\n        branch = scm.get_current_branch_name()\n        scm.display_available_branches()\n        if to_branch is None:\n            click.echo(\"Using current branch {0}\".format(crayons.yellow(branch)))\n        else:\n            click.echo(\n                \"Branch {0} not found, using current branch {1}\"\n                .format(crayons.red(to_branch), crayons.yellow(branch)))\n\n    branch_names = scm.get_branch_names(local=False)\n\n    if branch in branch_names:\n        raise click.BadArgumentUsage(\n            \"Branch {0} is already published. Use a branch that is not published.\"\n            .format(crayons.yellow(branch)))\n\n    status_log(scm.publish_branch, 'Publishing {0}.'.format(\n        crayons.yellow(branch)), branch)\n\n\n@cli.command(short_help='Removes specified branch from the remote.')\n@click.argument('published_branch', required=False)\n@click.option('--verbose', is_flag=True, help='Enables verbose mode.')\n@click.option('--fake', is_flag=True, help='Show but do not invoke git commands.')\n@pass_scm\ndef unpublish(scm, published_branch, verbose, fake):\n    \"\"\"Removes a published branch from the remote repository.\"\"\"\n    scm.fake = fake\n    scm.verbose = fake or verbose\n\n    scm.repo_check(require_remote=True)\n    branch = scm.fuzzy_match_branch(published_branch)\n\n    if not branch:\n        scm.display_available_branches()\n        raise click.BadArgumentUsage('Please specify a branch to unpublish')\n\n    branch_names = scm.get_branch_names(local=False)\n\n    if branch not in branch_names:\n        raise click.BadArgumentUsage(\n            \"Branch {0} is not published. Use a branch that is published.\"\n            .format(crayons.yellow(branch)))\n\n    status_log(scm.unpublish_branch, 'Unpublishing {0}.'.format(\n        crayons.yellow(branch)), branch)\n\n\n@cli.command()\n@click.option('--verbose', is_flag=True, help='Enables verbose mode.')\n@click.option('--fake', is_flag=True, help='Show but do not invoke git commands.')\n@click.option('--hard', is_flag=True, help='Discard local changes.')\n@pass_scm\ndef undo(scm, verbose, fake, hard):\n    \"\"\"Removes the last commit from history.\"\"\"\n    scm.fake = fake\n    scm.verbose = fake or verbose\n\n    scm.repo_check()\n\n    status_log(scm.undo, 'Last commit removed from history.', hard)\n\n\n@cli.command()\n@pass_scm\ndef branches(scm):\n    \"\"\"Displays a list of branches.\"\"\"\n    scm.repo_check()\n\n    scm.display_available_branches()\n\n\ndef do_install(ctx, verbose, fake):\n    \"\"\"Installs legit git aliases.\"\"\"\n    click.echo('The following git aliases will be installed:\\n')\n    aliases = cli.list_commands(ctx)\n    output_aliases(aliases)\n\n    if click.confirm('\\n{}Install aliases above?'.format('FAKE ' if fake else ''), default=fake):\n        for alias in aliases:\n            cmd = '!legit ' + alias\n            system_command = 'git config --global --replace-all alias.{0} \"{1}\"'.format(alias, cmd)\n            verbose_echo(system_command, verbose, fake)\n            if not fake:\n                os.system(system_command)\n        if not fake:\n            click.echo(\"\\nAliases installed.\")\n    else:\n        click.echo(\"\\nAliases will not be installed.\")\n\n\ndef do_uninstall(ctx, verbose, fake):\n    \"\"\"Uninstalls legit git aliases, including deprecated legit sub-commands.\"\"\"\n    aliases = cli.list_commands(ctx)\n    # Add deprecated aliases\n    aliases.extend(['graft', 'harvest', 'sprout', 'resync', 'settings', 'install', 'uninstall'])\n    for alias in aliases:\n        system_command = 'git config --global --unset-all alias.{0}'.format(alias)\n        verbose_echo(system_command, verbose, fake)\n        if not fake:\n            os.system(system_command)\n    if not fake:\n        click.echo('\\nThe following git aliases are uninstalled:\\n')\n        output_aliases(aliases)\n\n\ndef do_edit_settings(fake):\n    \"\"\"Opens legit settings in editor.\"\"\"\n\n    path = resources.user.open('config.ini').name\n\n    click.echo('Legit Settings:\\n')\n\n    for (option, _, description) in legit_settings.config_defaults:\n        click.echo(columns([crayons.yellow(option), 25], [description, None]))\n    click.echo(\"\")  # separate settings info from os output\n\n    if fake:\n        click.echo(crayons.red('Faked! >>> edit {}'.format(path)))\n    else:\n        click.edit(path)\n\n\ndef handle_abort(aborted, type=None):\n    click.echo('{0} {1}'.format(crayons.red('Error:'), aborted.message))\n    click.echo(str(aborted.log))\n    if type == 'merge':\n        click.echo('Unfortunately, there was a merge conflict.'\n                   ' It has to be merged manually.')\n    elif type == 'unpublish':\n        click.echo(\n            '''It seems that the remote branch is deleted.\n            If `legit branches` still shows it as published,\n            then probably the branch has been deleted at the remote by someone else.\n            You can run `git fetch --prune` to update remote information.\n            ''')\n    raise click.Abort\n\n\nlegit_settings.abort_handler = handle_abort\n", "description": "Git for Humans, Inspired by GitHub for Mac\u2122.", "file_name": "cli.py", "id": "bf4d6c82305219196bd6643058d86a4c", "language": "Python", "project_name": "legit", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/kennethreitz-legit/kennethreitz-legit-7345d70/legit/cli.py", "save_time": "", "source": "", "update_at": "2018-03-18T10:23:57Z", "url": "https://github.com/kennethreitz/legit", "wiki": true}