{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    parse_iso8601,\n    float_or_none,\n    ExtractorError,\n    int_or_none,\n)\n\n\nclass NineCNineMediaBaseIE(InfoExtractor):\n    _API_BASE_TEMPLATE = 'http://capi.9c9media.com/destinations/%s/platforms/desktop/contents/%s/'\n\n\nclass NineCNineMediaStackIE(NineCNineMediaBaseIE):\n    IE_NAME = '9c9media:stack'\n    _GEO_COUNTRIES = ['CA']\n    _VALID_URL = r'9c9media:stack:(?P<destination_code>[^:]+):(?P<content_id>\\d+):(?P<content_package>\\d+):(?P<id>\\d+)'\n\n    def _real_extract(self, url):\n        destination_code, content_id, package_id, stack_id = re.match(self._VALID_URL, url).groups()\n        stack_base_url_template = self._API_BASE_TEMPLATE + 'contentpackages/%s/stacks/%s/manifest.'\n        stack_base_url = stack_base_url_template % (destination_code, content_id, package_id, stack_id)\n\n        formats = []\n        formats.extend(self._extract_m3u8_formats(\n            stack_base_url + 'm3u8', stack_id, 'mp4',\n            'm3u8_native', m3u8_id='hls', fatal=False))\n        formats.extend(self._extract_f4m_formats(\n            stack_base_url + 'f4m', stack_id,\n            f4m_id='hds', fatal=False))\n        self._sort_formats(formats)\n\n        return {\n            'id': stack_id,\n            'formats': formats,\n        }\n\n\nclass NineCNineMediaIE(NineCNineMediaBaseIE):\n    IE_NAME = '9c9media'\n    _VALID_URL = r'9c9media:(?P<destination_code>[^:]+):(?P<id>\\d+)'\n\n    def _real_extract(self, url):\n        destination_code, content_id = re.match(self._VALID_URL, url).groups()\n        api_base_url = self._API_BASE_TEMPLATE % (destination_code, content_id)\n        content = self._download_json(api_base_url, content_id, query={\n            '$include': '[Media,Season,ContentPackages]',\n        })\n        title = content['Name']\n        if len(content['ContentPackages']) > 1:\n            raise ExtractorError('multiple content packages')\n        content_package = content['ContentPackages'][0]\n        package_id = content_package['Id']\n        content_package_url = api_base_url + 'contentpackages/%s/' % package_id\n        content_package = self._download_json(content_package_url, content_id)\n\n        if content_package.get('Constraints', {}).get('Security', {}).get('Type') == 'adobe-drm':\n            raise ExtractorError('This video is DRM protected.', expected=True)\n\n        stacks = self._download_json(content_package_url + 'stacks/', package_id)['Items']\n        multistacks = len(stacks) > 1\n\n        thumbnails = []\n        for image in content.get('Images', []):\n            image_url = image.get('Url')\n            if not image_url:\n                continue\n            thumbnails.append({\n                'url': image_url,\n                'width': int_or_none(image.get('Width')),\n                'height': int_or_none(image.get('Height')),\n            })\n\n        tags, categories = [], []\n        for source_name, container in (('Tags', tags), ('Genres', categories)):\n            for e in content.get(source_name, []):\n                e_name = e.get('Name')\n                if not e_name:\n                    continue\n                container.append(e_name)\n\n        description = content.get('Desc') or content.get('ShortDesc')\n        season = content.get('Season', {})\n        base_info = {\n            'description': description,\n            'timestamp': parse_iso8601(content.get('BroadcastDateTime')),\n            'episode_number': int_or_none(content.get('Episode')),\n            'season': season.get('Name'),\n            'season_number': season.get('Number'),\n            'season_id': season.get('Id'),\n            'series': content.get('Media', {}).get('Name'),\n            'tags': tags,\n            'categories': categories,\n        }\n\n        entries = []\n        for stack in stacks:\n            stack_id = compat_str(stack['Id'])\n            entry = {\n                '_type': 'url_transparent',\n                'url': '9c9media:stack:%s:%s:%s:%s' % (destination_code, content_id, package_id, stack_id),\n                'id': stack_id,\n                'title': '%s_part%s' % (title, stack['Name']) if multistacks else title,\n                'duration': float_or_none(stack.get('Duration')),\n                'ie_key': 'NineCNineMediaStack',\n            }\n            entry.update(base_info)\n            entries.append(entry)\n\n        return {\n            '_type': 'multi_video',\n            'id': content_id,\n            'title': title,\n            'description': description,\n            'entries': entries,\n        }\n", "comments": "# coding: utf-8\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    parse_iso8601,\n    float_or_none,\n    ExtractorError,\n    int_or_none,\n)\n\n\nclass NineCNineMediaBaseIE(InfoExtractor):\n    _API_BASE_TEMPLATE = 'http://capi.9c9media.com/destinations/%s/platforms/desktop/contents/%s/'\n\n\nclass NineCNineMediaStackIE(NineCNineMediaBaseIE):\n    IE_NAME = '9c9media:stack'\n    _GEO_COUNTRIES = ['CA']\n    _VALID_URL = r'9c9media:stack:(?P<destination_code>[^:]+):(?P<content_id>\\d+):(?P<content_package>\\d+):(?P<id>\\d+)'\n\n    def _real_extract(self, url):\n        destination_code, content_id, package_id, stack_id = re.match(self._VALID_URL, url).groups()\n        stack_base_url_template = self._API_BASE_TEMPLATE + 'contentpackages/%s/stacks/%s/manifest.'\n        stack_base_url = stack_base_url_template % (destination_code, content_id, package_id, stack_id)\n\n        formats = []\n        formats.extend(self._extract_m3u8_formats(\n            stack_base_url + 'm3u8', stack_id, 'mp4',\n            'm3u8_native', m3u8_id='hls', fatal=False))\n        formats.extend(self._extract_f4m_formats(\n            stack_base_url + 'f4m', stack_id,\n            f4m_id='hds', fatal=False))\n        self._sort_formats(formats)\n\n        return {\n            'id': stack_id,\n            'formats': formats,\n        }\n\n\nclass NineCNineMediaIE(NineCNineMediaBaseIE):\n    IE_NAME = '9c9media'\n    _VALID_URL = r'9c9media:(?P<destination_code>[^:]+):(?P<id>\\d+)'\n\n    def _real_extract(self, url):\n        destination_code, content_id = re.match(self._VALID_URL, url).groups()\n        api_base_url = self._API_BASE_TEMPLATE % (destination_code, content_id)\n        content = self._download_json(api_base_url, content_id, query={\n            '$include': '[Media,Season,ContentPackages]',\n        })\n        title = content['Name']\n        if len(content['ContentPackages']) > 1:\n            raise ExtractorError('multiple content packages')\n        content_package = content['ContentPackages'][0]\n        package_id = content_package['Id']\n        content_package_url = api_base_url + 'contentpackages/%s/' % package_id\n        content_package = self._download_json(content_package_url, content_id)\n\n        if content_package.get('Constraints', {}).get('Security', {}).get('Type') == 'adobe-drm':\n            raise ExtractorError('This video is DRM protected.', expected=True)\n\n        stacks = self._download_json(content_package_url + 'stacks/', package_id)['Items']\n        multistacks = len(stacks) > 1\n\n        thumbnails = []\n        for image in content.get('Images', []):\n            image_url = image.get('Url')\n            if not image_url:\n                continue\n            thumbnails.append({\n                'url': image_url,\n                'width': int_or_none(image.get('Width')),\n                'height': int_or_none(image.get('Height')),\n            })\n\n        tags, categories = [], []\n        for source_name, container in (('Tags', tags), ('Genres', categories)):\n            for e in content.get(source_name, []):\n                e_name = e.get('Name')\n                if not e_name:\n                    continue\n                container.append(e_name)\n\n        description = content.get('Desc') or content.get('ShortDesc')\n        season = content.get('Season', {})\n        base_info = {\n            'description': description,\n            'timestamp': parse_iso8601(content.get('BroadcastDateTime')),\n            'episode_number': int_or_none(content.get('Episode')),\n            'season': season.get('Name'),\n            'season_number': season.get('Number'),\n            'season_id': season.get('Id'),\n            'series': content.get('Media', {}).get('Name'),\n            'tags': tags,\n            'categories': categories,\n        }\n\n        entries = []\n        for stack in stacks:\n            stack_id = compat_str(stack['Id'])\n            entry = {\n                '_type': 'url_transparent',\n                'url': '9c9media:stack:%s:%s:%s:%s' % (destination_code, content_id, package_id, stack_id),\n                'id': stack_id,\n                'title': '%s_part%s' % (title, stack['Name']) if multistacks else title,\n                'duration': float_or_none(stack.get('Duration')),\n                'ie_key': 'NineCNineMediaStack',\n            }\n            entry.update(base_info)\n            entries.append(entry)\n\n        return {\n            '_type': 'multi_video',\n            'id': content_id,\n            'title': title,\n            'description': description,\n            'entries': entries,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "ninecninemedia.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/ninecninemedia.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}