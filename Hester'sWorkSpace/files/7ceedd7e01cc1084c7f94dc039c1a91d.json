{"author": "localstack", "code": "import json\nimport logging\nimport requests\nimport uuid\nimport xmltodict\nfrom requests.models import Response\nfrom six.moves.urllib import parse as urlparse\nfrom localstack.utils.aws import aws_stack\nfrom localstack.utils.common import short_uid, to_str\nfrom localstack.services.awslambda import lambda_api\nfrom localstack.services.generic_proxy import ProxyListener\n\n\nSNS_SUBSCRIPTIONS = {}\n\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass ProxyListenerSNS(ProxyListener):\n\n    def forward_request(self, method, path, data, headers):\n\n        if method == 'POST' and path == '/':\n            req_data = urlparse.parse_qs(to_str(data))\n            req_action = req_data['Action'][0]\n            topic_arn = req_data.get('TargetArn') or req_data.get('TopicArn')\n\n            if topic_arn:\n                topic_arn = topic_arn[0]\n                do_create_topic(topic_arn)\n\n            if req_action == 'SetSubscriptionAttributes':\n                sub = get_subscription_by_arn(req_data['SubscriptionArn'][0])\n                if not sub:\n                    return make_error(message='Unable to find subscription for given ARN', code=400)\n                attr_name = req_data['AttributeName'][0]\n                attr_value = req_data['AttributeValue'][0]\n                sub[attr_name] = attr_value\n                return make_response(req_action)\n            elif req_action == 'GetSubscriptionAttributes':\n                sub = get_subscription_by_arn(req_data['SubscriptionArn'][0])\n                if not sub:\n                    return make_error(message='Unable to find subscription for given ARN', code=400)\n                content = '<Attributes>'\n                for key, value in sub.items():\n                    content += '<entry><key>%s</key><value>%s</value></entry>\\n' % (key, value)\n                content += '</Attributes>'\n                return make_response(req_action, content=content)\n            elif req_action == 'Subscribe':\n                if 'Endpoint' not in req_data:\n                    return make_error(message='Endpoint not specified in subscription', code=400)\n            elif req_action == 'Unsubscribe':\n                if 'SubscriptionArn' not in req_data:\n                    return make_error(message='SubscriptionArn not specified in unsubscribe request', code=400)\n                do_unsubscribe(req_data.get('SubscriptionArn')[0])\n\n            elif req_action == 'Publish':\n                message = req_data['Message'][0]\n                sqs_client = aws_stack.connect_to_service('sqs')\n                for subscriber in SNS_SUBSCRIPTIONS[topic_arn]:\n                    if subscriber['Protocol'] == 'sqs':\n                        endpoint = subscriber['Endpoint']\n                        if 'sqs_queue_url' in subscriber:\n                            queue_url = subscriber.get('sqs_queue_url')\n                        elif '://' in endpoint:\n                            queue_url = endpoint\n                        else:\n                            queue_name = endpoint.split(':')[5]\n                            queue_url = aws_stack.get_sqs_queue_url(queue_name)\n                            subscriber['sqs_queue_url'] = queue_url\n                        sqs_client.send_message(QueueUrl=queue_url,\n                            MessageBody=create_sns_message_body(subscriber, req_data))\n                    elif subscriber['Protocol'] == 'lambda':\n                        lambda_api.process_sns_notification(\n                            subscriber['Endpoint'],\n                            topic_arn, message, subject=req_data.get('Subject', [None])[0]\n                        )\n                    elif subscriber['Protocol'] in ['http', 'https']:\n                        requests.post(\n                            subscriber['Endpoint'],\n                            headers={\n                                'Content-Type': 'text/plain',\n                                'x-amz-sns-message-type': 'Notification'\n                            },\n                            data=create_sns_message_body(subscriber, req_data))\n                    else:\n                        LOGGER.warning('Unexpected protocol \"%s\" for SNS subscription' % subscriber['Protocol'])\n                \n                return make_response(req_action)\n\n        return True\n\n    def return_response(self, method, path, data, headers, response):\n        \n        \n        if method == 'POST' and path == '/':\n            req_data = urlparse.parse_qs(to_str(data))\n            req_action = req_data['Action'][0]\n            if req_action == 'Subscribe' and response.status_code < 400:\n                response_data = xmltodict.parse(response.content)\n                topic_arn = (req_data.get('TargetArn') or req_data.get('TopicArn'))[0]\n                sub_arn = response_data['SubscribeResponse']['SubscribeResult']['SubscriptionArn']\n                do_subscribe(topic_arn, req_data['Endpoint'][0], req_data['Protocol'][0], sub_arn)\n\n\n\nUPDATE_SNS = ProxyListenerSNS()\n\n\ndef do_create_topic(topic_arn):\n    if topic_arn not in SNS_SUBSCRIPTIONS:\n        SNS_SUBSCRIPTIONS[topic_arn] = []\n\n\ndef do_subscribe(topic_arn, endpoint, protocol, subscription_arn):\n    subscription = {\n        \n        'TopicArn': topic_arn,\n        'Endpoint': endpoint,\n        'Protocol': protocol,\n        'SubscriptionArn': subscription_arn,\n        'RawMessageDelivery': 'false'\n    }\n    SNS_SUBSCRIPTIONS[topic_arn].append(subscription)\n\n\ndef do_unsubscribe(subscription_arn):\n    for topic_arn in SNS_SUBSCRIPTIONS:\n        SNS_SUBSCRIPTIONS[topic_arn] = [\n            sub for sub in SNS_SUBSCRIPTIONS[topic_arn]\n            if sub['SubscriptionArn'] != subscription_arn\n        ]\n\n\n\n\n\n\ndef get_topic_by_arn(topic_arn):\n    if topic_arn in SNS_SUBSCRIPTIONS:\n        return SNS_SUBSCRIPTIONS[topic_arn]\n    else:\n        return None\n\n\ndef get_subscription_by_arn(sub_arn):\n    \n    for key, subscriptions in SNS_SUBSCRIPTIONS.items():\n        for sub in subscriptions:\n            if sub['SubscriptionArn'] == sub_arn:\n                return sub\n\n\ndef make_response(op_name, content=''):\n    response = Response()\n    if not content:\n        content = '<MessageId>%s</MessageId>' % short_uid()\n    response._content = \"\"\"<{op_name}Response xmlns=\"http://sns.amazonaws.com/doc/2010-03-31/\">\n        <{op_name}Result>\n            {content}\n        </{op_name}Result>\n        <ResponseMetadata><RequestId>{req_id}</RequestId></ResponseMetadata>\n        </{op_name}Response>\"\"\".format(op_name=op_name, content=content, req_id=short_uid())\n    response.status_code = 200\n    return response\n\n\ndef make_error(message, code=400, code_string='InvalidParameter'):\n    response = Response()\n    response._content = \"\"\"<ErrorResponse xmlns=\"http://sns.amazonaws.com/doc/2010-03-31/\"><Error>\n        <Type>Sender</Type>\n        <Code>{code_string}</Code>\n        <Message>{message}</Message>\n        </Error><RequestId>{req_id}</RequestId>\n        </ErrorResponse>\"\"\".format(message=message, code_string=code_string, req_id=short_uid())\n    response.status_code = code\n    return response\n\n\ndef create_sns_message_body(subscriber, req_data):\n    message = req_data['Message'][0]\n    subject = req_data.get('Subject', [None])[0]\n\n    if subscriber['RawMessageDelivery'] == 'true':\n        return message\n\n    data = {}\n    data['MessageId'] = str(uuid.uuid4())\n    data['Type'] = 'Notification'\n    data['Message'] = message\n    data['TopicArn'] = subscriber['TopicArn']\n    if subject is not None:\n        data['Subject'] = subject\n    attributes = get_message_attributes(req_data)\n    if attributes:\n        data['MessageAttributes'] = attributes\n    return json.dumps(data)\n\n\ndef get_message_attributes(req_data):\n    attributes = {}\n    x = 1\n    while True:\n        name = req_data.get('MessageAttributes.entry.' + str(x) + '.Name', [None])[0]\n        if name is not None:\n            attribute = {}\n            attribute['Type'] = req_data.get('MessageAttributes.entry.' + str(x) + '.Value.DataType', [None])[0]\n            string_value = req_data.get('MessageAttributes.entry.' + str(x) + '.Value.StringValue', [None])[0]\n            binary_value = req_data.get('MessageAttributes.entry.' + str(x) + '.Value.BinaryValue', [None])[0]\n            if string_value is not None:\n                attribute['Value'] = string_value\n            elif binary_value is not None:\n                attribute['Value'] = binary_value\n\n            attributes[name] = attribute\n            x += 1\n        else:\n            break\n\n    return attributes\n", "comments": "     op name response xmlns  http   sns amazonaws com doc 2010 03 31              op name result               content             op name result           responsemetadata  requestid  req id   requestid   responsemetadata             op name response     format(op name op name  content content  req id short uid())     response status code   200     return response   def make error(message  code 400  code string  invalidparameter )      response   response()     response  content       errorresponse xmlns  http   sns amazonaws com doc 2010 03 31    error           type sender  type           code  code string   code           message  message   message            error  requestid  req id   requestid            errorresponse        mappings sns topic subscriptions    set logger    return response want request forwarded sns    this method executed proxy already received    response backend  hence utilize  response  variable    instantiate listener    http   docs aws amazon com cli latest reference sns get subscription attributes html                       helper methods                       todo maintain separate map instead traversing items ", "content": "import json\nimport logging\nimport requests\nimport uuid\nimport xmltodict\nfrom requests.models import Response\nfrom six.moves.urllib import parse as urlparse\nfrom localstack.utils.aws import aws_stack\nfrom localstack.utils.common import short_uid, to_str\nfrom localstack.services.awslambda import lambda_api\nfrom localstack.services.generic_proxy import ProxyListener\n\n# mappings for SNS topic subscriptions\nSNS_SUBSCRIPTIONS = {}\n\n# set up logger\nLOGGER = logging.getLogger(__name__)\n\n\nclass ProxyListenerSNS(ProxyListener):\n\n    def forward_request(self, method, path, data, headers):\n\n        if method == 'POST' and path == '/':\n            req_data = urlparse.parse_qs(to_str(data))\n            req_action = req_data['Action'][0]\n            topic_arn = req_data.get('TargetArn') or req_data.get('TopicArn')\n\n            if topic_arn:\n                topic_arn = topic_arn[0]\n                do_create_topic(topic_arn)\n\n            if req_action == 'SetSubscriptionAttributes':\n                sub = get_subscription_by_arn(req_data['SubscriptionArn'][0])\n                if not sub:\n                    return make_error(message='Unable to find subscription for given ARN', code=400)\n                attr_name = req_data['AttributeName'][0]\n                attr_value = req_data['AttributeValue'][0]\n                sub[attr_name] = attr_value\n                return make_response(req_action)\n            elif req_action == 'GetSubscriptionAttributes':\n                sub = get_subscription_by_arn(req_data['SubscriptionArn'][0])\n                if not sub:\n                    return make_error(message='Unable to find subscription for given ARN', code=400)\n                content = '<Attributes>'\n                for key, value in sub.items():\n                    content += '<entry><key>%s</key><value>%s</value></entry>\\n' % (key, value)\n                content += '</Attributes>'\n                return make_response(req_action, content=content)\n            elif req_action == 'Subscribe':\n                if 'Endpoint' not in req_data:\n                    return make_error(message='Endpoint not specified in subscription', code=400)\n            elif req_action == 'Unsubscribe':\n                if 'SubscriptionArn' not in req_data:\n                    return make_error(message='SubscriptionArn not specified in unsubscribe request', code=400)\n                do_unsubscribe(req_data.get('SubscriptionArn')[0])\n\n            elif req_action == 'Publish':\n                message = req_data['Message'][0]\n                sqs_client = aws_stack.connect_to_service('sqs')\n                for subscriber in SNS_SUBSCRIPTIONS[topic_arn]:\n                    if subscriber['Protocol'] == 'sqs':\n                        endpoint = subscriber['Endpoint']\n                        if 'sqs_queue_url' in subscriber:\n                            queue_url = subscriber.get('sqs_queue_url')\n                        elif '://' in endpoint:\n                            queue_url = endpoint\n                        else:\n                            queue_name = endpoint.split(':')[5]\n                            queue_url = aws_stack.get_sqs_queue_url(queue_name)\n                            subscriber['sqs_queue_url'] = queue_url\n                        sqs_client.send_message(QueueUrl=queue_url,\n                            MessageBody=create_sns_message_body(subscriber, req_data))\n                    elif subscriber['Protocol'] == 'lambda':\n                        lambda_api.process_sns_notification(\n                            subscriber['Endpoint'],\n                            topic_arn, message, subject=req_data.get('Subject', [None])[0]\n                        )\n                    elif subscriber['Protocol'] in ['http', 'https']:\n                        requests.post(\n                            subscriber['Endpoint'],\n                            headers={\n                                'Content-Type': 'text/plain',\n                                'x-amz-sns-message-type': 'Notification'\n                            },\n                            data=create_sns_message_body(subscriber, req_data))\n                    else:\n                        LOGGER.warning('Unexpected protocol \"%s\" for SNS subscription' % subscriber['Protocol'])\n                # return response here because we do not want the request to be forwarded to SNS\n                return make_response(req_action)\n\n        return True\n\n    def return_response(self, method, path, data, headers, response):\n        # This method is executed by the proxy after we've already received a\n        # response from the backend, hence we can utilize the \"response\" variable here\n        if method == 'POST' and path == '/':\n            req_data = urlparse.parse_qs(to_str(data))\n            req_action = req_data['Action'][0]\n            if req_action == 'Subscribe' and response.status_code < 400:\n                response_data = xmltodict.parse(response.content)\n                topic_arn = (req_data.get('TargetArn') or req_data.get('TopicArn'))[0]\n                sub_arn = response_data['SubscribeResponse']['SubscribeResult']['SubscriptionArn']\n                do_subscribe(topic_arn, req_data['Endpoint'][0], req_data['Protocol'][0], sub_arn)\n\n\n# instantiate listener\nUPDATE_SNS = ProxyListenerSNS()\n\n\ndef do_create_topic(topic_arn):\n    if topic_arn not in SNS_SUBSCRIPTIONS:\n        SNS_SUBSCRIPTIONS[topic_arn] = []\n\n\ndef do_subscribe(topic_arn, endpoint, protocol, subscription_arn):\n    subscription = {\n        # http://docs.aws.amazon.com/cli/latest/reference/sns/get-subscription-attributes.html\n        'TopicArn': topic_arn,\n        'Endpoint': endpoint,\n        'Protocol': protocol,\n        'SubscriptionArn': subscription_arn,\n        'RawMessageDelivery': 'false'\n    }\n    SNS_SUBSCRIPTIONS[topic_arn].append(subscription)\n\n\ndef do_unsubscribe(subscription_arn):\n    for topic_arn in SNS_SUBSCRIPTIONS:\n        SNS_SUBSCRIPTIONS[topic_arn] = [\n            sub for sub in SNS_SUBSCRIPTIONS[topic_arn]\n            if sub['SubscriptionArn'] != subscription_arn\n        ]\n\n\n# ---------------\n# HELPER METHODS\n# ---------------\n\ndef get_topic_by_arn(topic_arn):\n    if topic_arn in SNS_SUBSCRIPTIONS:\n        return SNS_SUBSCRIPTIONS[topic_arn]\n    else:\n        return None\n\n\ndef get_subscription_by_arn(sub_arn):\n    # TODO maintain separate map instead of traversing all items\n    for key, subscriptions in SNS_SUBSCRIPTIONS.items():\n        for sub in subscriptions:\n            if sub['SubscriptionArn'] == sub_arn:\n                return sub\n\n\ndef make_response(op_name, content=''):\n    response = Response()\n    if not content:\n        content = '<MessageId>%s</MessageId>' % short_uid()\n    response._content = \"\"\"<{op_name}Response xmlns=\"http://sns.amazonaws.com/doc/2010-03-31/\">\n        <{op_name}Result>\n            {content}\n        </{op_name}Result>\n        <ResponseMetadata><RequestId>{req_id}</RequestId></ResponseMetadata>\n        </{op_name}Response>\"\"\".format(op_name=op_name, content=content, req_id=short_uid())\n    response.status_code = 200\n    return response\n\n\ndef make_error(message, code=400, code_string='InvalidParameter'):\n    response = Response()\n    response._content = \"\"\"<ErrorResponse xmlns=\"http://sns.amazonaws.com/doc/2010-03-31/\"><Error>\n        <Type>Sender</Type>\n        <Code>{code_string}</Code>\n        <Message>{message}</Message>\n        </Error><RequestId>{req_id}</RequestId>\n        </ErrorResponse>\"\"\".format(message=message, code_string=code_string, req_id=short_uid())\n    response.status_code = code\n    return response\n\n\ndef create_sns_message_body(subscriber, req_data):\n    message = req_data['Message'][0]\n    subject = req_data.get('Subject', [None])[0]\n\n    if subscriber['RawMessageDelivery'] == 'true':\n        return message\n\n    data = {}\n    data['MessageId'] = str(uuid.uuid4())\n    data['Type'] = 'Notification'\n    data['Message'] = message\n    data['TopicArn'] = subscriber['TopicArn']\n    if subject is not None:\n        data['Subject'] = subject\n    attributes = get_message_attributes(req_data)\n    if attributes:\n        data['MessageAttributes'] = attributes\n    return json.dumps(data)\n\n\ndef get_message_attributes(req_data):\n    attributes = {}\n    x = 1\n    while True:\n        name = req_data.get('MessageAttributes.entry.' + str(x) + '.Name', [None])[0]\n        if name is not None:\n            attribute = {}\n            attribute['Type'] = req_data.get('MessageAttributes.entry.' + str(x) + '.Value.DataType', [None])[0]\n            string_value = req_data.get('MessageAttributes.entry.' + str(x) + '.Value.StringValue', [None])[0]\n            binary_value = req_data.get('MessageAttributes.entry.' + str(x) + '.Value.BinaryValue', [None])[0]\n            if string_value is not None:\n                attribute['Value'] = string_value\n            elif binary_value is not None:\n                attribute['Value'] = binary_value\n\n            attributes[name] = attribute\n            x += 1\n        else:\n            break\n\n    return attributes\n", "description": "\ud83d\udcbb  A fully functional local AWS cloud stack. Develop and test your cloud apps offline!", "file_name": "sns_listener.py", "id": "7ceedd7e01cc1084c7f94dc039c1a91d", "language": "Python", "project_name": "localstack", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/localstack-localstack/localstack-localstack-fcc848e/localstack/services/sns/sns_listener.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:04:08Z", "url": "https://github.com/localstack/localstack", "wiki": true}