{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport os.path\nimport subprocess\nimport sys\nimport re\n\nfrom .common import FileDownloader\nfrom ..compat import (\n    compat_setenv,\n    compat_str,\n)\nfrom ..postprocessor.ffmpeg import FFmpegPostProcessor, EXT_TO_OUT_FORMATS\nfrom ..utils import (\n    cli_option,\n    cli_valueless_option,\n    cli_bool_option,\n    cli_configuration_args,\n    encodeFilename,\n    encodeArgument,\n    handle_youtubedl_headers,\n    check_executable,\n    is_outdated_version,\n)\n\n\nclass ExternalFD(FileDownloader):\n    def real_download(self, filename, info_dict):\n        self.report_destination(filename)\n        tmpfilename = self.temp_name(filename)\n\n        try:\n            retval = self._call_downloader(tmpfilename, info_dict)\n        except KeyboardInterrupt:\n            if not info_dict.get('is_live'):\n                raise\n            \n            \n            \n            retval = 0\n            self.to_screen('[%s] Interrupted by user' % self.get_basename())\n\n        if retval == 0:\n            fsize = os.path.getsize(encodeFilename(tmpfilename))\n            self.to_screen('\\r[%s] Downloaded %s bytes' % (self.get_basename(), fsize))\n            self.try_rename(tmpfilename, filename)\n            self._hook_progress({\n                'downloaded_bytes': fsize,\n                'total_bytes': fsize,\n                'filename': filename,\n                'status': 'finished',\n            })\n            return True\n        else:\n            self.to_stderr('\\n')\n            self.report_error('%s exited with code %d' % (\n                self.get_basename(), retval))\n            return False\n\n    @classmethod\n    def get_basename(cls):\n        return cls.__name__[:-2].lower()\n\n    @property\n    def exe(self):\n        return self.params.get('external_downloader')\n\n    @classmethod\n    def available(cls):\n        return check_executable(cls.get_basename(), [cls.AVAILABLE_OPT])\n\n    @classmethod\n    def supports(cls, info_dict):\n        return info_dict['protocol'] in ('http', 'https', 'ftp', 'ftps')\n\n    @classmethod\n    def can_download(cls, info_dict):\n        return cls.available() and cls.supports(info_dict)\n\n    def _option(self, command_option, param):\n        return cli_option(self.params, command_option, param)\n\n    def _bool_option(self, command_option, param, true_value='true', false_value='false', separator=None):\n        return cli_bool_option(self.params, command_option, param, true_value, false_value, separator)\n\n    def _valueless_option(self, command_option, param, expected_value=True):\n        return cli_valueless_option(self.params, command_option, param, expected_value)\n\n    def _configuration_args(self, default=[]):\n        return cli_configuration_args(self.params, 'external_downloader_args', default)\n\n    def _call_downloader(self, tmpfilename, info_dict):\n        \n    \n    bn = os.path.splitext(os.path.basename(external_downloader))[0]\n    return _BY_NAME[bn]\n", "comments": " Either overwrite this or implement _make_cmd \"\"\"\n        cmd = [encodeArgument(a) for a in self._make_cmd(tmpfilename, info_dict)]\n\n        self._debug_cmd(cmd)\n\n        p = subprocess.Popen(\n            cmd, stderr=subprocess.PIPE)\n        _, stderr = p.communicate()\n        if p.returncode != 0:\n            self.to_stderr(stderr.decode('utf-8', 'replace'))\n        return p.returncode\n\n\nclass CurlFD(ExternalFD):\n    AVAILABLE_OPT = '-V'\n\n    def _make_cmd(self, tmpfilename, info_dict):\n        cmd = [self.exe, '--location', '-o', tmpfilename]\n        for key, val in info_dict['http_headers'].items():\n            cmd += ['--header', '%s: %s' % (key, val)]\n        cmd += self._bool_option('--continue-at', 'continuedl', '-', '0')\n        cmd += self._valueless_option('--silent', 'noprogress')\n        cmd += self._valueless_option('--verbose', 'verbose')\n        cmd += self._option('--limit-rate', 'ratelimit')\n        cmd += self._option('--retry', 'retries')\n        cmd += self._option('--max-filesize', 'max_filesize')\n        cmd += self._option('--interface', 'source_address')\n        cmd += self._option('--proxy', 'proxy')\n        cmd += self._valueless_option('--insecure', 'nocheckcertificate')\n        cmd += self._configuration_args()\n        cmd += ['--', info_dict['url']]\n        return cmd\n\n    def _call_downloader(self, tmpfilename, info_dict):\n        cmd = [encodeArgument(a) for a in self._make_cmd(tmpfilename, info_dict)]\n\n        self._debug_cmd(cmd)\n\n        # curl writes the progress to stderr so don't capture it.\n        p = subprocess.Popen(cmd)\n        p.communicate()\n        return p.returncode\n\n\nclass AxelFD(ExternalFD):\n    AVAILABLE_OPT = '-V'\n\n    def _make_cmd(self, tmpfilename, info_dict):\n        cmd = [self.exe, '-o', tmpfilename]\n        for key, val in info_dict['http_headers'].items():\n            cmd += ['-H', '%s: %s' % (key, val)]\n        cmd += self._configuration_args()\n        cmd += ['--', info_dict['url']]\n        return cmd\n\n\nclass WgetFD(ExternalFD):\n    AVAILABLE_OPT = '--version'\n\n    def _make_cmd(self, tmpfilename, info_dict):\n        cmd = [self.exe, '-O', tmpfilename, '-nv', '--no-cookies']\n        for key, val in info_dict['http_headers'].items():\n            cmd += ['--header', '%s: %s' % (key, val)]\n        cmd += self._option('--bind-address', 'source_address')\n        cmd += self._option('--proxy', 'proxy')\n        cmd += self._valueless_option('--no-check-certificate', 'nocheckcertificate')\n        cmd += self._configuration_args()\n        cmd += ['--', info_dict['url']]\n        return cmd\n\n\nclass Aria2cFD(ExternalFD):\n    AVAILABLE_OPT = '-v'\n\n    def _make_cmd(self, tmpfilename, info_dict):\n        cmd = [self.exe, '-c']\n        cmd += self._configuration_args([\n            '--min-split-size', '1M', '--max-connection-per-server', '4'])\n        dn = os.path.dirname(tmpfilename)\n        if dn:\n            cmd += ['--dir', dn]\n        cmd += ['--out', os.path.basename(tmpfilename)]\n        for key, val in info_dict['http_headers'].items():\n            cmd += ['--header', '%s: %s' % (key, val)]\n        cmd += self._option('--interface', 'source_address')\n        cmd += self._option('--all-proxy', 'proxy')\n        cmd += self._bool_option('--check-certificate', 'nocheckcertificate', 'false', 'true', '=')\n        cmd += ['--', info_dict['url']]\n        return cmd\n\n\nclass HttpieFD(ExternalFD):\n    @classmethod\n    def available(cls):\n        return check_executable('http', ['--version'])\n\n    def _make_cmd(self, tmpfilename, info_dict):\n        cmd = ['http', '--download', '--output', tmpfilename, info_dict['url']]\n        for key, val in info_dict['http_headers'].items():\n            cmd += ['%s:%s' % (key, val)]\n        return cmd\n\n\nclass FFmpegFD(ExternalFD):\n    @classmethod\n    def supports(cls, info_dict):\n        return info_dict['protocol'] in ('http', 'https', 'ftp', 'ftps', 'm3u8', 'rtsp', 'rtmp', 'mms')\n\n    @classmethod\n    def available(cls):\n        return FFmpegPostProcessor().available\n\n    def _call_downloader(self, tmpfilename, info_dict):\n        url = info_dict['url']\n        ffpp = FFmpegPostProcessor(downloader=self)\n        if not ffpp.available:\n            self.report_error('m3u8 download detected but ffmpeg or avconv could not be found. Please install one.')\n            return False\n        ffpp.check_version()\n\n        args = [ffpp.executable, '-y']\n\n        for log_level in ('quiet', 'verbose'):\n            if self.params.get(log_level, False):\n                args += ['-loglevel', log_level]\n                break\n\n        seekable = info_dict.get('_seekable')\n        if seekable is not None:\n            # setting -seekable prevents ffmpeg from guessing if the server\n            # supports seeking(by adding the header `Range: bytes=0-`), which\n            # can cause problems in some cases\n            # https://github.com/rg3/youtube-dl/issues/11800#issuecomment-275037127\n            # http://trac.ffmpeg.org/ticket/6125#comment:10\n            args += ['-seekable', '1' if seekable else '0']\n\n        args += self._configuration_args()\n\n        # start_time = info_dict.get('start_time') or 0\n        # if start_time:\n        #     args += ['-ss', compat_str(start_time)]\n        # end_time = info_dict.get('end_time')\n        # if end_time:\n        #     args += ['-t', compat_str(end_time - start_time)]\n\n        if info_dict['http_headers'] and re.match(r'^https?://', url):\n            # Trailing \\r\\n after each HTTP header is important to prevent warning from ffmpeg/avconv:\n            # [http @ 00000000003d2fa0] No trailing CRLF found in HTTP header.\n            headers = handle_youtubedl_headers(info_dict['http_headers'])\n            args += [\n                '-headers',\n                ''.join('%s: %s\\r\\n' % (key, val) for key, val in headers.items())]\n\n        env = None\n        proxy = self.params.get('proxy')\n        if proxy:\n            if not re.match(r'^[\\da-zA-Z]+://', proxy):\n                proxy = 'http://%s' % proxy\n\n            if proxy.startswith('socks'):\n                self.report_warning(\n                    '%s does not support SOCKS proxies. Downloading is likely to fail. '\n                    'Consider adding --hls-prefer-native to your command.' % self.get_basename())\n\n            # Since December 2015 ffmpeg supports -http_proxy option (see\n            # http://git.videolan.org/?p=ffmpeg.git;a=commit;h=b4eb1f29ebddd60c41a2eb39f5af701e38e0d3fd)\n            # We could switch to the following code if we are able to detect version properly\n            # args += ['-http_proxy', proxy]\n            env = os.environ.copy()\n            compat_setenv('HTTP_PROXY', proxy, env=env)\n            compat_setenv('http_proxy', proxy, env=env)\n\n        protocol = info_dict.get('protocol')\n\n        if protocol == 'rtmp':\n            player_url = info_dict.get('player_url')\n            page_url = info_dict.get('page_url')\n            app = info_dict.get('app')\n            play_path = info_dict.get('play_path')\n            tc_url = info_dict.get('tc_url')\n            flash_version = info_dict.get('flash_version')\n            live = info_dict.get('rtmp_live', False)\n            if player_url is not None:\n                args += ['-rtmp_swfverify', player_url]\n            if page_url is not None:\n                args += ['-rtmp_pageurl', page_url]\n            if app is not None:\n                args += ['-rtmp_app', app]\n            if play_path is not None:\n                args += ['-rtmp_playpath', play_path]\n            if tc_url is not None:\n                args += ['-rtmp_tcurl', tc_url]\n            if flash_version is not None:\n                args += ['-rtmp_flashver', flash_version]\n            if live:\n                args += ['-rtmp_live', 'live']\n\n        args += ['-i', url, '-c', 'copy']\n\n        if self.params.get('test', False):\n            args += ['-fs', compat_str(self._TEST_FILE_SIZE)]\n\n        if protocol in ('m3u8', 'm3u8_native'):\n            if self.params.get('hls_use_mpegts', False) or tmpfilename == '-':\n                args += ['-f', 'mpegts']\n            else:\n                args += ['-f', 'mp4']\n                if (ffpp.basename == 'ffmpeg' and is_outdated_version(ffpp._versions['ffmpeg'], '3.2', False)) and (not info_dict.get('acodec') or info_dict['acodec'].split('.')[0] in ('aac', 'mp4a')):\n                    args += ['-bsf:a', 'aac_adtstoasc']\n        elif protocol == 'rtmp':\n            args += ['-f', 'flv']\n        else:\n            args += ['-f', EXT_TO_OUT_FORMATS.get(info_dict['ext'], info_dict['ext'])]\n\n        args = [encodeArgument(opt) for opt in args]\n        args.append(encodeFilename(ffpp._ffmpeg_filename_argument(tmpfilename), True))\n\n        self._debug_cmd(args)\n\n        proc = subprocess.Popen(args, stdin=subprocess.PIPE, env=env)\n        try:\n            retval = proc.wait()\n        except KeyboardInterrupt:\n            # subprocces.run would send the SIGKILL signal to ffmpeg and the\n            # mp4 file couldn't be played, but if we ask ffmpeg to quit it\n            # produces a file that is playable (this is mostly useful for live\n            # streams). Note that Windows is not affected and produces playable\n            # files (see https://github.com/rg3/youtube-dl/issues/8300).\n            if sys.platform != 'win32':\n                proc.communicate(b'q')\n            raise\n        return retval\n\n\nclass AVconvFD(FFmpegFD):\n    pass\n\n\n_BY_NAME = dict(\n    (klass.get_basename(), klass)\n    for name, klass in globals().items()\n    if name.endswith('FD') and name != 'ExternalFD'\n)\n\n\ndef list_external_downloaders():\n    return sorted(_BY_NAME.keys())\n\n\ndef get_external_downloader(external_downloader):\n    \"\"\" Given the name of the executable, see whether we support the given\n        downloader . \n \n# Live stream downloading cancellation should be considered as\n# correct and expected termination thus all postprocessing\n# should take place\n# Drop .exe extension on Windows\n", "content": "from __future__ import unicode_literals\n\nimport os.path\nimport subprocess\nimport sys\nimport re\n\nfrom .common import FileDownloader\nfrom ..compat import (\n    compat_setenv,\n    compat_str,\n)\nfrom ..postprocessor.ffmpeg import FFmpegPostProcessor, EXT_TO_OUT_FORMATS\nfrom ..utils import (\n    cli_option,\n    cli_valueless_option,\n    cli_bool_option,\n    cli_configuration_args,\n    encodeFilename,\n    encodeArgument,\n    handle_youtubedl_headers,\n    check_executable,\n    is_outdated_version,\n)\n\n\nclass ExternalFD(FileDownloader):\n    def real_download(self, filename, info_dict):\n        self.report_destination(filename)\n        tmpfilename = self.temp_name(filename)\n\n        try:\n            retval = self._call_downloader(tmpfilename, info_dict)\n        except KeyboardInterrupt:\n            if not info_dict.get('is_live'):\n                raise\n            # Live stream downloading cancellation should be considered as\n            # correct and expected termination thus all postprocessing\n            # should take place\n            retval = 0\n            self.to_screen('[%s] Interrupted by user' % self.get_basename())\n\n        if retval == 0:\n            fsize = os.path.getsize(encodeFilename(tmpfilename))\n            self.to_screen('\\r[%s] Downloaded %s bytes' % (self.get_basename(), fsize))\n            self.try_rename(tmpfilename, filename)\n            self._hook_progress({\n                'downloaded_bytes': fsize,\n                'total_bytes': fsize,\n                'filename': filename,\n                'status': 'finished',\n            })\n            return True\n        else:\n            self.to_stderr('\\n')\n            self.report_error('%s exited with code %d' % (\n                self.get_basename(), retval))\n            return False\n\n    @classmethod\n    def get_basename(cls):\n        return cls.__name__[:-2].lower()\n\n    @property\n    def exe(self):\n        return self.params.get('external_downloader')\n\n    @classmethod\n    def available(cls):\n        return check_executable(cls.get_basename(), [cls.AVAILABLE_OPT])\n\n    @classmethod\n    def supports(cls, info_dict):\n        return info_dict['protocol'] in ('http', 'https', 'ftp', 'ftps')\n\n    @classmethod\n    def can_download(cls, info_dict):\n        return cls.available() and cls.supports(info_dict)\n\n    def _option(self, command_option, param):\n        return cli_option(self.params, command_option, param)\n\n    def _bool_option(self, command_option, param, true_value='true', false_value='false', separator=None):\n        return cli_bool_option(self.params, command_option, param, true_value, false_value, separator)\n\n    def _valueless_option(self, command_option, param, expected_value=True):\n        return cli_valueless_option(self.params, command_option, param, expected_value)\n\n    def _configuration_args(self, default=[]):\n        return cli_configuration_args(self.params, 'external_downloader_args', default)\n\n    def _call_downloader(self, tmpfilename, info_dict):\n        \"\"\" Either overwrite this or implement _make_cmd \"\"\"\n        cmd = [encodeArgument(a) for a in self._make_cmd(tmpfilename, info_dict)]\n\n        self._debug_cmd(cmd)\n\n        p = subprocess.Popen(\n            cmd, stderr=subprocess.PIPE)\n        _, stderr = p.communicate()\n        if p.returncode != 0:\n            self.to_stderr(stderr.decode('utf-8', 'replace'))\n        return p.returncode\n\n\nclass CurlFD(ExternalFD):\n    AVAILABLE_OPT = '-V'\n\n    def _make_cmd(self, tmpfilename, info_dict):\n        cmd = [self.exe, '--location', '-o', tmpfilename]\n        for key, val in info_dict['http_headers'].items():\n            cmd += ['--header', '%s: %s' % (key, val)]\n        cmd += self._bool_option('--continue-at', 'continuedl', '-', '0')\n        cmd += self._valueless_option('--silent', 'noprogress')\n        cmd += self._valueless_option('--verbose', 'verbose')\n        cmd += self._option('--limit-rate', 'ratelimit')\n        cmd += self._option('--retry', 'retries')\n        cmd += self._option('--max-filesize', 'max_filesize')\n        cmd += self._option('--interface', 'source_address')\n        cmd += self._option('--proxy', 'proxy')\n        cmd += self._valueless_option('--insecure', 'nocheckcertificate')\n        cmd += self._configuration_args()\n        cmd += ['--', info_dict['url']]\n        return cmd\n\n    def _call_downloader(self, tmpfilename, info_dict):\n        cmd = [encodeArgument(a) for a in self._make_cmd(tmpfilename, info_dict)]\n\n        self._debug_cmd(cmd)\n\n        # curl writes the progress to stderr so don't capture it.\n        p = subprocess.Popen(cmd)\n        p.communicate()\n        return p.returncode\n\n\nclass AxelFD(ExternalFD):\n    AVAILABLE_OPT = '-V'\n\n    def _make_cmd(self, tmpfilename, info_dict):\n        cmd = [self.exe, '-o', tmpfilename]\n        for key, val in info_dict['http_headers'].items():\n            cmd += ['-H', '%s: %s' % (key, val)]\n        cmd += self._configuration_args()\n        cmd += ['--', info_dict['url']]\n        return cmd\n\n\nclass WgetFD(ExternalFD):\n    AVAILABLE_OPT = '--version'\n\n    def _make_cmd(self, tmpfilename, info_dict):\n        cmd = [self.exe, '-O', tmpfilename, '-nv', '--no-cookies']\n        for key, val in info_dict['http_headers'].items():\n            cmd += ['--header', '%s: %s' % (key, val)]\n        cmd += self._option('--bind-address', 'source_address')\n        cmd += self._option('--proxy', 'proxy')\n        cmd += self._valueless_option('--no-check-certificate', 'nocheckcertificate')\n        cmd += self._configuration_args()\n        cmd += ['--', info_dict['url']]\n        return cmd\n\n\nclass Aria2cFD(ExternalFD):\n    AVAILABLE_OPT = '-v'\n\n    def _make_cmd(self, tmpfilename, info_dict):\n        cmd = [self.exe, '-c']\n        cmd += self._configuration_args([\n            '--min-split-size', '1M', '--max-connection-per-server', '4'])\n        dn = os.path.dirname(tmpfilename)\n        if dn:\n            cmd += ['--dir', dn]\n        cmd += ['--out', os.path.basename(tmpfilename)]\n        for key, val in info_dict['http_headers'].items():\n            cmd += ['--header', '%s: %s' % (key, val)]\n        cmd += self._option('--interface', 'source_address')\n        cmd += self._option('--all-proxy', 'proxy')\n        cmd += self._bool_option('--check-certificate', 'nocheckcertificate', 'false', 'true', '=')\n        cmd += ['--', info_dict['url']]\n        return cmd\n\n\nclass HttpieFD(ExternalFD):\n    @classmethod\n    def available(cls):\n        return check_executable('http', ['--version'])\n\n    def _make_cmd(self, tmpfilename, info_dict):\n        cmd = ['http', '--download', '--output', tmpfilename, info_dict['url']]\n        for key, val in info_dict['http_headers'].items():\n            cmd += ['%s:%s' % (key, val)]\n        return cmd\n\n\nclass FFmpegFD(ExternalFD):\n    @classmethod\n    def supports(cls, info_dict):\n        return info_dict['protocol'] in ('http', 'https', 'ftp', 'ftps', 'm3u8', 'rtsp', 'rtmp', 'mms')\n\n    @classmethod\n    def available(cls):\n        return FFmpegPostProcessor().available\n\n    def _call_downloader(self, tmpfilename, info_dict):\n        url = info_dict['url']\n        ffpp = FFmpegPostProcessor(downloader=self)\n        if not ffpp.available:\n            self.report_error('m3u8 download detected but ffmpeg or avconv could not be found. Please install one.')\n            return False\n        ffpp.check_version()\n\n        args = [ffpp.executable, '-y']\n\n        for log_level in ('quiet', 'verbose'):\n            if self.params.get(log_level, False):\n                args += ['-loglevel', log_level]\n                break\n\n        seekable = info_dict.get('_seekable')\n        if seekable is not None:\n            # setting -seekable prevents ffmpeg from guessing if the server\n            # supports seeking(by adding the header `Range: bytes=0-`), which\n            # can cause problems in some cases\n            # https://github.com/rg3/youtube-dl/issues/11800#issuecomment-275037127\n            # http://trac.ffmpeg.org/ticket/6125#comment:10\n            args += ['-seekable', '1' if seekable else '0']\n\n        args += self._configuration_args()\n\n        # start_time = info_dict.get('start_time') or 0\n        # if start_time:\n        #     args += ['-ss', compat_str(start_time)]\n        # end_time = info_dict.get('end_time')\n        # if end_time:\n        #     args += ['-t', compat_str(end_time - start_time)]\n\n        if info_dict['http_headers'] and re.match(r'^https?://', url):\n            # Trailing \\r\\n after each HTTP header is important to prevent warning from ffmpeg/avconv:\n            # [http @ 00000000003d2fa0] No trailing CRLF found in HTTP header.\n            headers = handle_youtubedl_headers(info_dict['http_headers'])\n            args += [\n                '-headers',\n                ''.join('%s: %s\\r\\n' % (key, val) for key, val in headers.items())]\n\n        env = None\n        proxy = self.params.get('proxy')\n        if proxy:\n            if not re.match(r'^[\\da-zA-Z]+://', proxy):\n                proxy = 'http://%s' % proxy\n\n            if proxy.startswith('socks'):\n                self.report_warning(\n                    '%s does not support SOCKS proxies. Downloading is likely to fail. '\n                    'Consider adding --hls-prefer-native to your command.' % self.get_basename())\n\n            # Since December 2015 ffmpeg supports -http_proxy option (see\n            # http://git.videolan.org/?p=ffmpeg.git;a=commit;h=b4eb1f29ebddd60c41a2eb39f5af701e38e0d3fd)\n            # We could switch to the following code if we are able to detect version properly\n            # args += ['-http_proxy', proxy]\n            env = os.environ.copy()\n            compat_setenv('HTTP_PROXY', proxy, env=env)\n            compat_setenv('http_proxy', proxy, env=env)\n\n        protocol = info_dict.get('protocol')\n\n        if protocol == 'rtmp':\n            player_url = info_dict.get('player_url')\n            page_url = info_dict.get('page_url')\n            app = info_dict.get('app')\n            play_path = info_dict.get('play_path')\n            tc_url = info_dict.get('tc_url')\n            flash_version = info_dict.get('flash_version')\n            live = info_dict.get('rtmp_live', False)\n            if player_url is not None:\n                args += ['-rtmp_swfverify', player_url]\n            if page_url is not None:\n                args += ['-rtmp_pageurl', page_url]\n            if app is not None:\n                args += ['-rtmp_app', app]\n            if play_path is not None:\n                args += ['-rtmp_playpath', play_path]\n            if tc_url is not None:\n                args += ['-rtmp_tcurl', tc_url]\n            if flash_version is not None:\n                args += ['-rtmp_flashver', flash_version]\n            if live:\n                args += ['-rtmp_live', 'live']\n\n        args += ['-i', url, '-c', 'copy']\n\n        if self.params.get('test', False):\n            args += ['-fs', compat_str(self._TEST_FILE_SIZE)]\n\n        if protocol in ('m3u8', 'm3u8_native'):\n            if self.params.get('hls_use_mpegts', False) or tmpfilename == '-':\n                args += ['-f', 'mpegts']\n            else:\n                args += ['-f', 'mp4']\n                if (ffpp.basename == 'ffmpeg' and is_outdated_version(ffpp._versions['ffmpeg'], '3.2', False)) and (not info_dict.get('acodec') or info_dict['acodec'].split('.')[0] in ('aac', 'mp4a')):\n                    args += ['-bsf:a', 'aac_adtstoasc']\n        elif protocol == 'rtmp':\n            args += ['-f', 'flv']\n        else:\n            args += ['-f', EXT_TO_OUT_FORMATS.get(info_dict['ext'], info_dict['ext'])]\n\n        args = [encodeArgument(opt) for opt in args]\n        args.append(encodeFilename(ffpp._ffmpeg_filename_argument(tmpfilename), True))\n\n        self._debug_cmd(args)\n\n        proc = subprocess.Popen(args, stdin=subprocess.PIPE, env=env)\n        try:\n            retval = proc.wait()\n        except KeyboardInterrupt:\n            # subprocces.run would send the SIGKILL signal to ffmpeg and the\n            # mp4 file couldn't be played, but if we ask ffmpeg to quit it\n            # produces a file that is playable (this is mostly useful for live\n            # streams). Note that Windows is not affected and produces playable\n            # files (see https://github.com/rg3/youtube-dl/issues/8300).\n            if sys.platform != 'win32':\n                proc.communicate(b'q')\n            raise\n        return retval\n\n\nclass AVconvFD(FFmpegFD):\n    pass\n\n\n_BY_NAME = dict(\n    (klass.get_basename(), klass)\n    for name, klass in globals().items()\n    if name.endswith('FD') and name != 'ExternalFD'\n)\n\n\ndef list_external_downloaders():\n    return sorted(_BY_NAME.keys())\n\n\ndef get_external_downloader(external_downloader):\n    \"\"\" Given the name of the executable, see whether we support the given\n        downloader . \"\"\"\n    # Drop .exe extension on Windows\n    bn = os.path.splitext(os.path.basename(external_downloader))[0]\n    return _BY_NAME[bn]\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "external.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/downloader/external.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}