{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\nimport logging\nimport werkzeug\n\nfrom odoo import http, _\nfrom odoo.addons.auth_signup.models.res_users import SignupError\nfrom odoo.addons.web.controllers.main import ensure_db, Home\nfrom odoo.exceptions import UserError\nfrom odoo.http import request\n\n_logger = logging.getLogger(__name__)\n\n\nclass AuthSignupHome(Home):\n\n    @http.route()\n    def web_login(self, *args, **kw):\n        ensure_db()\n        response = super(AuthSignupHome, self).web_login(*args, **kw)\n        response.qcontext.update(self.get_auth_signup_config())\n        if request.httprequest.method == 'GET' and request.session.uid and request.params.get('redirect'):\n            \n            return http.redirect_with_hash(request.params.get('redirect'))\n        return response\n\n    @http.route('/web/signup', type='http', auth='public', website=True, sitemap=False)\n    def web_auth_signup(self, *args, **kw):\n        qcontext = self.get_auth_signup_qcontext()\n\n        if not qcontext.get('token') and not qcontext.get('signup_enabled'):\n            raise werkzeug.exceptions.NotFound()\n\n        if 'error' not in qcontext and request.httprequest.method == 'POST':\n            try:\n                self.do_signup(qcontext)\n                \n                if qcontext.get('token'):\n                    user_sudo = request.env['res.users'].sudo().search([('login', '=', qcontext.get('login'))])\n                    template = request.env.ref('auth_signup.mail_template_user_signup_account_created', raise_if_not_found=False)\n                    if user_sudo and template:\n                        template.sudo().with_context(\n                            lang=user_sudo.lang,\n                            auth_login=werkzeug.url_encode({'auth_login': user_sudo.email}),\n                            password=request.params.get('password')\n                        ).send_mail(user_sudo.id, force_send=True)\n                return super(AuthSignupHome, self).web_login(*args, **kw)\n            except UserError as e:\n                qcontext['error'] = e.name or e.value\n            except (SignupError, AssertionError) as e:\n                if request.env[\"res.users\"].sudo().search([(\"login\", \"=\", qcontext.get(\"login\"))]):\n                    qcontext[\"error\"] = _(\"Another user is already registered using this email address.\")\n                else:\n                    _logger.error(\"%s\", e)\n                    qcontext['error'] = _(\"Could not create a new account.\")\n\n        response = request.render('auth_signup.signup', qcontext)\n        response.headers['X-Frame-Options'] = 'DENY'\n        return response\n\n    @http.route('/web/reset_password', type='http', auth='public', website=True, sitemap=False)\n    def web_auth_reset_password(self, *args, **kw):\n        qcontext = self.get_auth_signup_qcontext()\n\n        if not qcontext.get('token') and not qcontext.get('reset_password_enabled'):\n            raise werkzeug.exceptions.NotFound()\n\n        if 'error' not in qcontext and request.httprequest.method == 'POST':\n            try:\n                if qcontext.get('token'):\n                    self.do_signup(qcontext)\n                    return super(AuthSignupHome, self).web_login(*args, **kw)\n                else:\n                    login = qcontext.get('login')\n                    assert login, _(\"No login provided.\")\n                    _logger.info(\n                        \"Password reset attempt for <%s> by user <%s> from %s\",\n                        login, request.env.user.login, request.httprequest.remote_addr)\n                    request.env['res.users'].sudo().reset_password(login)\n                    qcontext['message'] = _(\"An email has been sent with credentials to reset your password\")\n            except SignupError:\n                qcontext['error'] = _(\"Could not reset your password\")\n                _logger.exception('error when resetting password')\n            except Exception as e:\n                qcontext['error'] = str(e)\n\n        response = request.render('auth_signup.reset_password', qcontext)\n        response.headers['X-Frame-Options'] = 'DENY'\n        return response\n\n    def get_auth_signup_config(self):\n        \"\"\"retrieve the module config (which features are enabled) for the login page\"\"\"\n\n        get_param = request.env['ir.config_parameter'].sudo().get_param\n        return {\n            'signup_enabled': get_param('auth_signup.allow_uninvited') == 'True',\n            'reset_password_enabled': get_param('auth_signup.reset_password') == 'True',\n        }\n\n    def get_auth_signup_qcontext(self):\n        \"\"\" Shared helper returning the rendering context for signup and reset password \"\"\"\n        qcontext = request.params.copy()\n        qcontext.update(self.get_auth_signup_config())\n        if not qcontext.get('token') and request.session.get('auth_signup_token'):\n            qcontext['token'] = request.session.get('auth_signup_token')\n        if qcontext.get('token'):\n            try:\n                # retrieve the user info (name, login or email) corresponding to a signup token\n                token_infos = request.env['res.partner'].sudo().signup_retrieve_info(qcontext.get('token'))\n                for k, v in token_infos.items():\n                    qcontext.setdefault(k, v)\n            except:\n                qcontext['error'] = _(\"Invalid signup token\")\n                qcontext['invalid_token'] = True\n        return qcontext\n\n    def do_signup(self, qcontext):\n        \"\"\" Shared helper that creates a res.partner out of a token \"\"\"\n        values = { key: qcontext.get(key) for key in ('login', 'name', 'password') }\n        if not values:\n            raise UserError(_(\"The form was not properly filled in.\"))\n        if values.get('password') != qcontext.get('confirm_password'):\n            raise UserError(_(\"Passwords do not match; please retype them.\"))\n        supported_langs = [lang['code'] for lang in request.env['res.lang'].sudo().search_read([], ['code'])]\n        if request.lang in supported_langs:\n            values['lang'] = request.lang\n        self._signup_with_values(qcontext.get('token'), values)\n        request.env.cr.commit()\n\n    def _signup_with_values(self, token, values):\n        db, login, password = request.env['res.users'].sudo().signup(values, token)\n        request.env.cr.commit()     \n        uid = request.session.authenticate(db, login, password)\n        if not uid:\n            raise SignupError(_('Authentication Failed.'))\n", "comments": "   retrieve module config (which features enabled) login page             get param   request env  ir config parameter   sudo() get param         return                signup enabled   get param( auth signup allow uninvited )     true                reset password enabled   get param( auth signup reset password )     true                  def get auth signup qcontext(self)              shared helper returning rendering context signup reset password             qcontext   request params copy()         qcontext update(self get auth signup config())         qcontext get( token ) request session get( auth signup token )              qcontext  token     request session get( auth signup token )         qcontext get( token )              try                    retrieve user info (name  login email) corresponding signup token                 token infos   request env  res partner   sudo() signup retrieve info(qcontext get( token ))                 k  v token infos items()                      qcontext setdefault(k  v)             except                  qcontext  error      ( invalid signup token )                 qcontext  invalid token     true         return qcontext      def signup(self  qcontext)              shared helper creates res partner token            coding  utf 8        part odoo  see license file full copyright licensing details     redirect already logged redirect param present    send account creation confirmation email    retrieve user info (name  login email) corresponding signup token    authenticate use cursor need commit current transaction ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\nimport logging\nimport werkzeug\n\nfrom odoo import http, _\nfrom odoo.addons.auth_signup.models.res_users import SignupError\nfrom odoo.addons.web.controllers.main import ensure_db, Home\nfrom odoo.exceptions import UserError\nfrom odoo.http import request\n\n_logger = logging.getLogger(__name__)\n\n\nclass AuthSignupHome(Home):\n\n    @http.route()\n    def web_login(self, *args, **kw):\n        ensure_db()\n        response = super(AuthSignupHome, self).web_login(*args, **kw)\n        response.qcontext.update(self.get_auth_signup_config())\n        if request.httprequest.method == 'GET' and request.session.uid and request.params.get('redirect'):\n            # Redirect if already logged in and redirect param is present\n            return http.redirect_with_hash(request.params.get('redirect'))\n        return response\n\n    @http.route('/web/signup', type='http', auth='public', website=True, sitemap=False)\n    def web_auth_signup(self, *args, **kw):\n        qcontext = self.get_auth_signup_qcontext()\n\n        if not qcontext.get('token') and not qcontext.get('signup_enabled'):\n            raise werkzeug.exceptions.NotFound()\n\n        if 'error' not in qcontext and request.httprequest.method == 'POST':\n            try:\n                self.do_signup(qcontext)\n                # Send an account creation confirmation email\n                if qcontext.get('token'):\n                    user_sudo = request.env['res.users'].sudo().search([('login', '=', qcontext.get('login'))])\n                    template = request.env.ref('auth_signup.mail_template_user_signup_account_created', raise_if_not_found=False)\n                    if user_sudo and template:\n                        template.sudo().with_context(\n                            lang=user_sudo.lang,\n                            auth_login=werkzeug.url_encode({'auth_login': user_sudo.email}),\n                            password=request.params.get('password')\n                        ).send_mail(user_sudo.id, force_send=True)\n                return super(AuthSignupHome, self).web_login(*args, **kw)\n            except UserError as e:\n                qcontext['error'] = e.name or e.value\n            except (SignupError, AssertionError) as e:\n                if request.env[\"res.users\"].sudo().search([(\"login\", \"=\", qcontext.get(\"login\"))]):\n                    qcontext[\"error\"] = _(\"Another user is already registered using this email address.\")\n                else:\n                    _logger.error(\"%s\", e)\n                    qcontext['error'] = _(\"Could not create a new account.\")\n\n        response = request.render('auth_signup.signup', qcontext)\n        response.headers['X-Frame-Options'] = 'DENY'\n        return response\n\n    @http.route('/web/reset_password', type='http', auth='public', website=True, sitemap=False)\n    def web_auth_reset_password(self, *args, **kw):\n        qcontext = self.get_auth_signup_qcontext()\n\n        if not qcontext.get('token') and not qcontext.get('reset_password_enabled'):\n            raise werkzeug.exceptions.NotFound()\n\n        if 'error' not in qcontext and request.httprequest.method == 'POST':\n            try:\n                if qcontext.get('token'):\n                    self.do_signup(qcontext)\n                    return super(AuthSignupHome, self).web_login(*args, **kw)\n                else:\n                    login = qcontext.get('login')\n                    assert login, _(\"No login provided.\")\n                    _logger.info(\n                        \"Password reset attempt for <%s> by user <%s> from %s\",\n                        login, request.env.user.login, request.httprequest.remote_addr)\n                    request.env['res.users'].sudo().reset_password(login)\n                    qcontext['message'] = _(\"An email has been sent with credentials to reset your password\")\n            except SignupError:\n                qcontext['error'] = _(\"Could not reset your password\")\n                _logger.exception('error when resetting password')\n            except Exception as e:\n                qcontext['error'] = str(e)\n\n        response = request.render('auth_signup.reset_password', qcontext)\n        response.headers['X-Frame-Options'] = 'DENY'\n        return response\n\n    def get_auth_signup_config(self):\n        \"\"\"retrieve the module config (which features are enabled) for the login page\"\"\"\n\n        get_param = request.env['ir.config_parameter'].sudo().get_param\n        return {\n            'signup_enabled': get_param('auth_signup.allow_uninvited') == 'True',\n            'reset_password_enabled': get_param('auth_signup.reset_password') == 'True',\n        }\n\n    def get_auth_signup_qcontext(self):\n        \"\"\" Shared helper returning the rendering context for signup and reset password \"\"\"\n        qcontext = request.params.copy()\n        qcontext.update(self.get_auth_signup_config())\n        if not qcontext.get('token') and request.session.get('auth_signup_token'):\n            qcontext['token'] = request.session.get('auth_signup_token')\n        if qcontext.get('token'):\n            try:\n                # retrieve the user info (name, login or email) corresponding to a signup token\n                token_infos = request.env['res.partner'].sudo().signup_retrieve_info(qcontext.get('token'))\n                for k, v in token_infos.items():\n                    qcontext.setdefault(k, v)\n            except:\n                qcontext['error'] = _(\"Invalid signup token\")\n                qcontext['invalid_token'] = True\n        return qcontext\n\n    def do_signup(self, qcontext):\n        \"\"\" Shared helper that creates a res.partner out of a token \"\"\"\n        values = { key: qcontext.get(key) for key in ('login', 'name', 'password') }\n        if not values:\n            raise UserError(_(\"The form was not properly filled in.\"))\n        if values.get('password') != qcontext.get('confirm_password'):\n            raise UserError(_(\"Passwords do not match; please retype them.\"))\n        supported_langs = [lang['code'] for lang in request.env['res.lang'].sudo().search_read([], ['code'])]\n        if request.lang in supported_langs:\n            values['lang'] = request.lang\n        self._signup_with_values(qcontext.get('token'), values)\n        request.env.cr.commit()\n\n    def _signup_with_values(self, token, values):\n        db, login, password = request.env['res.users'].sudo().signup(values, token)\n        request.env.cr.commit()     # as authenticate will use its own cursor we need to commit the current transaction\n        uid = request.session.authenticate(db, login, password)\n        if not uid:\n            raise SignupError(_('Authentication Failed.'))\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "main.py", "id": "960e8c76332f0e2207fa5b396ef28189", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/auth_signup/controllers/main.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}