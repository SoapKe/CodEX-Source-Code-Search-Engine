{"author": "pallets", "code": "\n\n        app_ctx = self._implicit_app_ctx_stack.pop()\n\n        try:\n            clear_request = False\n            if not self._implicit_app_ctx_stack:\n                self.preserved = False\n                self._preserved_exc = None\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_request(exc)\n\n                \n                \n                \n                \n                if hasattr(sys, 'exc_clear'):\n                    sys.exc_clear()\n\n                request_close = getattr(self.request, 'close', None)\n                if request_close is not None:\n                    request_close()\n                clear_request = True\n        finally:\n            rv = _request_ctx_stack.pop()\n\n            \n            \n            if clear_request:\n                rv.request.environ['werkzeug.request'] = None\n\n            \n            if app_ctx is not None:\n                app_ctx.pop(exc)\n\n            assert rv is self, 'Popped wrong request context.  ' \\\n                '(%r instead of %r)' % (rv, self)\n\n    def auto_pop(self, exc):\n        if self.request.environ.get('flask._preserve_context') or \\\n           (exc is not None and self.app.preserve_context_on_exception):\n            self.preserved = True\n            self._preserved_exc = exc\n        else:\n            self.pop(exc)\n\n    def __enter__(self):\n        self.push()\n        return self\n\n    def __exit__(self, exc_type, exc_value, tb):\n        \n        \n        \n        \n        \n        self.auto_pop(exc_value)\n\n        if BROKEN_PYPY_CTXMGR_EXIT and exc_type is not None:\n            reraise(exc_type, exc_value, tb)\n\n    def __repr__(self):\n        return '<%s \\'%s\\' [%s] of %s>' % (\n            self.__class__.__name__,\n            self.request.url,\n            self.request.method,\n            self.app.name,\n        )\n", "comments": "\n    flask.ctx\n    ~~~~~~~~~\n\n    Implements the objects required to keep the context.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport sys\nfrom functools import update_wrapper\n\nfrom werkzeug.exceptions import HTTPException\n\nfrom .globals import _request_ctx_stack, _app_ctx_stack\nfrom .signals import appcontext_pushed, appcontext_popped\nfrom ._compat import BROKEN_PYPY_CTXMGR_EXIT, reraise\n\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\nclass _AppCtxGlobals(object):\n    \"\"\"A plain object.\"\"\"\n\n    def get(self, name, default=None):\n        return self.__dict__.get(name, default)\n\n    def pop(self, name, default=_sentinel):\n        if default is _sentinel:\n            return self.__dict__.pop(name)\n        else:\n            return self.__dict__.pop(name, default)\n\n    def setdefault(self, name, default=None):\n        return self.__dict__.setdefault(name, default)\n\n    def __contains__(self, item):\n        return item in self.__dict__\n\n    def __iter__(self):\n        return iter(self.__dict__)\n\n    def __repr__(self):\n        top = _app_ctx_stack.top\n        if top is not None:\n            return '<flask.g of %r>' % top.app.name\n        return object.__repr__(self)\n\n\ndef after_this_request(f):\n    \"\"\"Executes a function after this request.  This is useful to modify\n    response objects.  The function is passed the response object and has\n    to return the same or a new one.\n\n    Example::\n\n        @app.route('/')\n        def index():\n            @after_this_request\n            def add_header(response):\n                response.headers['X-Foo'] = 'Parachute'\n                return response\n            return 'Hello World!'\n\n    This is more useful if a function other than the view function wants to\n    modify a response.  For instance think of a decorator that wants to add\n    some headers without converting the return value into a response object.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    _request_ctx_stack.top._after_request_functions.append(f)\n    return f\n\n\ndef copy_current_request_context(f):\n    \"\"\"A helper function that decorates a function to retain the current\n    request context.  This is useful when working with greenlets.  The moment\n    the function is decorated a copy of the request context is created and\n    then pushed when the function is called.\n\n    Example::\n\n        import gevent\n        from flask import copy_current_request_context\n\n        @app.route('/')\n        def index():\n            @copy_current_request_context\n            def do_some_work():\n                # do some work here, it can access flask.request like you\n                # would otherwise in the view function.\n                ...\n            gevent.spawn(do_some_work)\n            return 'Regular response'\n\n    .. versionadded:: 0.10\n    \"\"\"\n    top = _request_ctx_stack.top\n    if top is None:\n        raise RuntimeError('This decorator can only be used at local scopes '\n            'when a request context is on the stack.  For instance within '\n            'view functions.')\n    reqctx = top.copy()\n    def wrapper(*args, **kwargs):\n        with reqctx:\n            return f(*args, **kwargs)\n    return update_wrapper(wrapper, f)\n\n\ndef has_request_context():\n    \"\"\"If you have code that wants to test if a request context is there or\n    not this function can be used.  For instance, you may want to take advantage\n    of request information if the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g` for truthness)::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _request_ctx_stack.top is not None\n\n\ndef has_app_context():\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _app_ctx_stack.top is not None\n\n\nclass AppContext(object):\n    \"\"\"The application context binds an application object implicitly\n    to the current thread or greenlet, similar to how the\n    :class:`RequestContext` binds request information.  The application\n    context is also implicitly created if a request context is created\n    but the application is not on top of the individual application\n    context.\n    \"\"\"\n\n    def __init__(self, app):\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g = app.app_ctx_globals_class()\n\n        # Like request context, app contexts can be pushed multiple times\n        # but there a basic \"refcount\" is enough to track them.\n        self._refcnt = 0\n\n    def push(self):\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._refcnt += 1\n        if hasattr(sys, 'exc_clear'):\n            sys.exc_clear()\n        _app_ctx_stack.push(self)\n        appcontext_pushed.send(self.app)\n\n    def pop(self, exc=_sentinel):\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            self._refcnt -= 1\n            if self._refcnt <= 0:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            rv = _app_ctx_stack.pop()\n        assert rv is self, 'Popped wrong app context.  (%r instead of %r)' \\\n            % (rv, self)\n        appcontext_popped.send(self.app)\n\n    def __enter__(self):\n        self.push()\n        return self\n\n    def __exit__(self, exc_type, exc_value, tb):\n        self.pop(exc_value)\n\n        if BROKEN_PYPY_CTXMGR_EXIT and exc_type is not None:\n            reraise(exc_type, exc_value, tb)\n\n\nclass RequestContext(object):\n    \"\"\"The request context contains all request relevant information.  It is\n    created at the beginning of the request and pushed to the\n    `_request_ctx_stack` and removed at the end of it.  It will create the\n    URL adapter and request object for the WSGI environment provided.\n\n    Do not attempt to use this class directly, instead use\n    :meth:`~flask.Flask.test_request_context` and\n    :meth:`~flask.Flask.request_context` to create this object.\n\n    When the request context is popped, it will evaluate all the\n    functions registered on the application for teardown execution\n    (:meth:`~flask.Flask.teardown_request`).\n\n    The request context is automatically popped at the end of the request\n    for you.  In debug mode the request context is kept around if\n    exceptions happen so that interactive debuggers have a chance to\n    introspect the data.  With 0.4 this can also be forced for requests\n    that did not fail and outside of ``DEBUG`` mode.  By setting\n    ``'flask._preserve_context'`` to ``True`` on the WSGI environment the\n    context will not pop itself at the end of the request.  This is used by\n    the :meth:`~flask.Flask.test_client` for example to implement the\n    deferred cleanup functionality.\n\n    You might find this helpful for unittests where you need the\n    information from the context local around for a little longer.  Make\n    sure to properly :meth:`~werkzeug.LocalStack.pop` the stack yourself in\n    that situation, otherwise your unittests will leak memory.\n    \"\"\"\n\n    def __init__(self, app, environ, request=None):\n        self.app = app\n        if request is None:\n            request = app.request_class(environ)\n        self.request = request\n        self.url_adapter = app.create_url_adapter(self.request)\n        self.flashes = None\n        self.session = None\n\n        # Request contexts can be pushed multiple times and interleaved with\n        # other request contexts.  Now only if the last level is popped we\n        # get rid of them.  Additionally if an application context is missing\n        # one is created implicitly so for each level we add this information\n        self._implicit_app_ctx_stack = []\n\n        # indicator if the context was preserved.  Next time another context\n        # is pushed the preserved context is popped.\n        self.preserved = False\n\n        # remembers the exception for pop if there is one in case the context\n        # preservation kicks in.\n        self._preserved_exc = None\n\n        # Functions that should be executed after the request on the response\n        # object.  These will be called before the regular \"after_request\"\n        # functions.\n        self._after_request_functions = []\n\n        self.match_request()\n\n    def _get_g(self):\n        return _app_ctx_stack.top.g\n    def _set_g(self, value):\n        _app_ctx_stack.top.g = value\n    g = property(_get_g, _set_g)\n    del _get_g, _set_g\n\n    def copy(self):\n        \"\"\"Creates a copy of this request context with the same request object.\n        This can be used to move a request context to a different greenlet.\n        Because the actual request object is the same this cannot be used to\n        move a request context to a different thread unless access to the\n        request object is locked.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__class__(self.app,\n            environ=self.request.environ,\n            request=self.request\n        )\n\n    def match_request(self):\n        \"\"\"Can be overridden by a subclass to hook into the matching\n        of the request.\n        \"\"\"\n        try:\n            url_rule, self.request.view_args = \\\n                self.url_adapter.match(return_rule=True)\n            self.request.url_rule = url_rule\n        except HTTPException as e:\n            self.request.routing_exception = e\n\n    def push(self):\n        \"\"\"Binds the request context to the current context.\"\"\"\n        # If an exception occurs in debug mode or if context preservation is\n        # activated under exception situations exactly one context stays\n        # on the stack.  The rationale is that you want to access that\n        # information under debug situations.  However if someone forgets to\n        # pop that context again we want to make sure that on the next push\n        # it's invalidated, otherwise we run at risk that something leaks\n        # memory.  This is usually only a problem in test suite since this\n        # functionality is not active in production environments.\n        top = _request_ctx_stack.top\n        if top is not None and top.preserved:\n            top.pop(top._preserved_exc)\n\n        # Before we push the request context we have to ensure that there\n        # is an application context.\n        app_ctx = _app_ctx_stack.top\n        if app_ctx is None or app_ctx.app != self.app:\n            app_ctx = self.app.app_context()\n            app_ctx.push()\n            self._implicit_app_ctx_stack.append(app_ctx)\n        else:\n            self._implicit_app_ctx_stack.append(None)\n\n        if hasattr(sys, 'exc_clear'):\n            sys.exc_clear()\n\n        _request_ctx_stack.push(self)\n\n        # Open the session at the moment that the request context is available.\n        # This allows a custom open_session method to use the request context.\n        # Only open a new session if this is the first time the request was\n        # pushed, otherwise stream_with_context loses the session.\n        if self.session is None:\n            session_interface = self.app.session_interface\n            self.session = session_interface.open_session(\n                self.app, self.request\n            )\n\n            if self.session is None:\n                self.session = session_interface.make_null_session(self.app)\n\n    def pop(self, exc=_sentinel):\n        \"\"\"Pops the request context and unbinds it by doing that.  This will\n        also trigger the execution of functions registered by the\n        :meth:`~flask.Flask.teardown_request` decorator.\n\n        .. versionchanged:: 0.9\n           Added the `exc` argument.\n        \n \n# -*- coding: utf-8 -*-\n# If this interpreter supports clearing the exception information\n# we do that now.  This will only go into effect on Python 2.x,\n# on 3.x it disappears automatically at the end of the exception\n# stack.\n# get rid of circular dependencies at the end of the request\n# so that we don't require the GC to be active.\n# Get rid of the app as well if necessary.\n# do not pop the request stack if we are in debug mode and an\n# exception happened.  This will allow the debugger to still\n# access the request object in the interactive shell.  Furthermore\n# the context can be force kept alive for the test client.\n# See flask.testing for how this works.\n", "content": "# -*- coding: utf-8 -*-\n\"\"\"\n    flask.ctx\n    ~~~~~~~~~\n\n    Implements the objects required to keep the context.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport sys\nfrom functools import update_wrapper\n\nfrom werkzeug.exceptions import HTTPException\n\nfrom .globals import _request_ctx_stack, _app_ctx_stack\nfrom .signals import appcontext_pushed, appcontext_popped\nfrom ._compat import BROKEN_PYPY_CTXMGR_EXIT, reraise\n\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\nclass _AppCtxGlobals(object):\n    \"\"\"A plain object.\"\"\"\n\n    def get(self, name, default=None):\n        return self.__dict__.get(name, default)\n\n    def pop(self, name, default=_sentinel):\n        if default is _sentinel:\n            return self.__dict__.pop(name)\n        else:\n            return self.__dict__.pop(name, default)\n\n    def setdefault(self, name, default=None):\n        return self.__dict__.setdefault(name, default)\n\n    def __contains__(self, item):\n        return item in self.__dict__\n\n    def __iter__(self):\n        return iter(self.__dict__)\n\n    def __repr__(self):\n        top = _app_ctx_stack.top\n        if top is not None:\n            return '<flask.g of %r>' % top.app.name\n        return object.__repr__(self)\n\n\ndef after_this_request(f):\n    \"\"\"Executes a function after this request.  This is useful to modify\n    response objects.  The function is passed the response object and has\n    to return the same or a new one.\n\n    Example::\n\n        @app.route('/')\n        def index():\n            @after_this_request\n            def add_header(response):\n                response.headers['X-Foo'] = 'Parachute'\n                return response\n            return 'Hello World!'\n\n    This is more useful if a function other than the view function wants to\n    modify a response.  For instance think of a decorator that wants to add\n    some headers without converting the return value into a response object.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    _request_ctx_stack.top._after_request_functions.append(f)\n    return f\n\n\ndef copy_current_request_context(f):\n    \"\"\"A helper function that decorates a function to retain the current\n    request context.  This is useful when working with greenlets.  The moment\n    the function is decorated a copy of the request context is created and\n    then pushed when the function is called.\n\n    Example::\n\n        import gevent\n        from flask import copy_current_request_context\n\n        @app.route('/')\n        def index():\n            @copy_current_request_context\n            def do_some_work():\n                # do some work here, it can access flask.request like you\n                # would otherwise in the view function.\n                ...\n            gevent.spawn(do_some_work)\n            return 'Regular response'\n\n    .. versionadded:: 0.10\n    \"\"\"\n    top = _request_ctx_stack.top\n    if top is None:\n        raise RuntimeError('This decorator can only be used at local scopes '\n            'when a request context is on the stack.  For instance within '\n            'view functions.')\n    reqctx = top.copy()\n    def wrapper(*args, **kwargs):\n        with reqctx:\n            return f(*args, **kwargs)\n    return update_wrapper(wrapper, f)\n\n\ndef has_request_context():\n    \"\"\"If you have code that wants to test if a request context is there or\n    not this function can be used.  For instance, you may want to take advantage\n    of request information if the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g` for truthness)::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _request_ctx_stack.top is not None\n\n\ndef has_app_context():\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _app_ctx_stack.top is not None\n\n\nclass AppContext(object):\n    \"\"\"The application context binds an application object implicitly\n    to the current thread or greenlet, similar to how the\n    :class:`RequestContext` binds request information.  The application\n    context is also implicitly created if a request context is created\n    but the application is not on top of the individual application\n    context.\n    \"\"\"\n\n    def __init__(self, app):\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g = app.app_ctx_globals_class()\n\n        # Like request context, app contexts can be pushed multiple times\n        # but there a basic \"refcount\" is enough to track them.\n        self._refcnt = 0\n\n    def push(self):\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._refcnt += 1\n        if hasattr(sys, 'exc_clear'):\n            sys.exc_clear()\n        _app_ctx_stack.push(self)\n        appcontext_pushed.send(self.app)\n\n    def pop(self, exc=_sentinel):\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            self._refcnt -= 1\n            if self._refcnt <= 0:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            rv = _app_ctx_stack.pop()\n        assert rv is self, 'Popped wrong app context.  (%r instead of %r)' \\\n            % (rv, self)\n        appcontext_popped.send(self.app)\n\n    def __enter__(self):\n        self.push()\n        return self\n\n    def __exit__(self, exc_type, exc_value, tb):\n        self.pop(exc_value)\n\n        if BROKEN_PYPY_CTXMGR_EXIT and exc_type is not None:\n            reraise(exc_type, exc_value, tb)\n\n\nclass RequestContext(object):\n    \"\"\"The request context contains all request relevant information.  It is\n    created at the beginning of the request and pushed to the\n    `_request_ctx_stack` and removed at the end of it.  It will create the\n    URL adapter and request object for the WSGI environment provided.\n\n    Do not attempt to use this class directly, instead use\n    :meth:`~flask.Flask.test_request_context` and\n    :meth:`~flask.Flask.request_context` to create this object.\n\n    When the request context is popped, it will evaluate all the\n    functions registered on the application for teardown execution\n    (:meth:`~flask.Flask.teardown_request`).\n\n    The request context is automatically popped at the end of the request\n    for you.  In debug mode the request context is kept around if\n    exceptions happen so that interactive debuggers have a chance to\n    introspect the data.  With 0.4 this can also be forced for requests\n    that did not fail and outside of ``DEBUG`` mode.  By setting\n    ``'flask._preserve_context'`` to ``True`` on the WSGI environment the\n    context will not pop itself at the end of the request.  This is used by\n    the :meth:`~flask.Flask.test_client` for example to implement the\n    deferred cleanup functionality.\n\n    You might find this helpful for unittests where you need the\n    information from the context local around for a little longer.  Make\n    sure to properly :meth:`~werkzeug.LocalStack.pop` the stack yourself in\n    that situation, otherwise your unittests will leak memory.\n    \"\"\"\n\n    def __init__(self, app, environ, request=None):\n        self.app = app\n        if request is None:\n            request = app.request_class(environ)\n        self.request = request\n        self.url_adapter = app.create_url_adapter(self.request)\n        self.flashes = None\n        self.session = None\n\n        # Request contexts can be pushed multiple times and interleaved with\n        # other request contexts.  Now only if the last level is popped we\n        # get rid of them.  Additionally if an application context is missing\n        # one is created implicitly so for each level we add this information\n        self._implicit_app_ctx_stack = []\n\n        # indicator if the context was preserved.  Next time another context\n        # is pushed the preserved context is popped.\n        self.preserved = False\n\n        # remembers the exception for pop if there is one in case the context\n        # preservation kicks in.\n        self._preserved_exc = None\n\n        # Functions that should be executed after the request on the response\n        # object.  These will be called before the regular \"after_request\"\n        # functions.\n        self._after_request_functions = []\n\n        self.match_request()\n\n    def _get_g(self):\n        return _app_ctx_stack.top.g\n    def _set_g(self, value):\n        _app_ctx_stack.top.g = value\n    g = property(_get_g, _set_g)\n    del _get_g, _set_g\n\n    def copy(self):\n        \"\"\"Creates a copy of this request context with the same request object.\n        This can be used to move a request context to a different greenlet.\n        Because the actual request object is the same this cannot be used to\n        move a request context to a different thread unless access to the\n        request object is locked.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__class__(self.app,\n            environ=self.request.environ,\n            request=self.request\n        )\n\n    def match_request(self):\n        \"\"\"Can be overridden by a subclass to hook into the matching\n        of the request.\n        \"\"\"\n        try:\n            url_rule, self.request.view_args = \\\n                self.url_adapter.match(return_rule=True)\n            self.request.url_rule = url_rule\n        except HTTPException as e:\n            self.request.routing_exception = e\n\n    def push(self):\n        \"\"\"Binds the request context to the current context.\"\"\"\n        # If an exception occurs in debug mode or if context preservation is\n        # activated under exception situations exactly one context stays\n        # on the stack.  The rationale is that you want to access that\n        # information under debug situations.  However if someone forgets to\n        # pop that context again we want to make sure that on the next push\n        # it's invalidated, otherwise we run at risk that something leaks\n        # memory.  This is usually only a problem in test suite since this\n        # functionality is not active in production environments.\n        top = _request_ctx_stack.top\n        if top is not None and top.preserved:\n            top.pop(top._preserved_exc)\n\n        # Before we push the request context we have to ensure that there\n        # is an application context.\n        app_ctx = _app_ctx_stack.top\n        if app_ctx is None or app_ctx.app != self.app:\n            app_ctx = self.app.app_context()\n            app_ctx.push()\n            self._implicit_app_ctx_stack.append(app_ctx)\n        else:\n            self._implicit_app_ctx_stack.append(None)\n\n        if hasattr(sys, 'exc_clear'):\n            sys.exc_clear()\n\n        _request_ctx_stack.push(self)\n\n        # Open the session at the moment that the request context is available.\n        # This allows a custom open_session method to use the request context.\n        # Only open a new session if this is the first time the request was\n        # pushed, otherwise stream_with_context loses the session.\n        if self.session is None:\n            session_interface = self.app.session_interface\n            self.session = session_interface.open_session(\n                self.app, self.request\n            )\n\n            if self.session is None:\n                self.session = session_interface.make_null_session(self.app)\n\n    def pop(self, exc=_sentinel):\n        \"\"\"Pops the request context and unbinds it by doing that.  This will\n        also trigger the execution of functions registered by the\n        :meth:`~flask.Flask.teardown_request` decorator.\n\n        .. versionchanged:: 0.9\n           Added the `exc` argument.\n        \"\"\"\n        app_ctx = self._implicit_app_ctx_stack.pop()\n\n        try:\n            clear_request = False\n            if not self._implicit_app_ctx_stack:\n                self.preserved = False\n                self._preserved_exc = None\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_request(exc)\n\n                # If this interpreter supports clearing the exception information\n                # we do that now.  This will only go into effect on Python 2.x,\n                # on 3.x it disappears automatically at the end of the exception\n                # stack.\n                if hasattr(sys, 'exc_clear'):\n                    sys.exc_clear()\n\n                request_close = getattr(self.request, 'close', None)\n                if request_close is not None:\n                    request_close()\n                clear_request = True\n        finally:\n            rv = _request_ctx_stack.pop()\n\n            # get rid of circular dependencies at the end of the request\n            # so that we don't require the GC to be active.\n            if clear_request:\n                rv.request.environ['werkzeug.request'] = None\n\n            # Get rid of the app as well if necessary.\n            if app_ctx is not None:\n                app_ctx.pop(exc)\n\n            assert rv is self, 'Popped wrong request context.  ' \\\n                '(%r instead of %r)' % (rv, self)\n\n    def auto_pop(self, exc):\n        if self.request.environ.get('flask._preserve_context') or \\\n           (exc is not None and self.app.preserve_context_on_exception):\n            self.preserved = True\n            self._preserved_exc = exc\n        else:\n            self.pop(exc)\n\n    def __enter__(self):\n        self.push()\n        return self\n\n    def __exit__(self, exc_type, exc_value, tb):\n        # do not pop the request stack if we are in debug mode and an\n        # exception happened.  This will allow the debugger to still\n        # access the request object in the interactive shell.  Furthermore\n        # the context can be force kept alive for the test client.\n        # See flask.testing for how this works.\n        self.auto_pop(exc_value)\n\n        if BROKEN_PYPY_CTXMGR_EXIT and exc_type is not None:\n            reraise(exc_type, exc_value, tb)\n\n    def __repr__(self):\n        return '<%s \\'%s\\' [%s] of %s>' % (\n            self.__class__.__name__,\n            self.request.url,\n            self.request.method,\n            self.app.name,\n        )\n", "description": "The Python micro framework for building web applications.", "file_name": "ctx.py", "language": "Python", "project_name": "flask", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/pallets_flask/pallets-flask-a2ea186/flask/ctx.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:52:03Z", "url": "https://github.com/pallets/flask", "wiki": false}