{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport base64\nimport json\nimport hashlib\nimport hmac\nimport random\nimport string\nimport time\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_urllib_parse_urlencode,\n    compat_urlparse,\n)\nfrom ..utils import (\n    float_or_none,\n    int_or_none,\n)\n\n\nclass VRVBaseIE(InfoExtractor):\n    _API_DOMAIN = None\n    _API_PARAMS = {}\n    _CMS_SIGNING = {}\n\n    def _call_api(self, path, video_id, note, data=None):\n        base_url = self._API_DOMAIN + '/core/' + path\n        encoded_query = compat_urllib_parse_urlencode({\n            'oauth_consumer_key': self._API_PARAMS['oAuthKey'],\n            'oauth_nonce': ''.join([random.choice(string.ascii_letters) for _ in range(32)]),\n            'oauth_signature_method': 'HMAC-SHA1',\n            'oauth_timestamp': int(time.time()),\n            'oauth_version': '1.0',\n        })\n        headers = self.geo_verification_headers()\n        if data:\n            data = json.dumps(data).encode()\n            headers['Content-Type'] = 'application/json'\n        method = 'POST' if data else 'GET'\n        base_string = '&'.join([method, compat_urlparse.quote(base_url, ''), compat_urlparse.quote(encoded_query, '')])\n        oauth_signature = base64.b64encode(hmac.new(\n            (self._API_PARAMS['oAuthSecret'] + '&').encode('ascii'),\n            base_string.encode(), hashlib.sha1).digest()).decode()\n        encoded_query += '&oauth_signature=' + compat_urlparse.quote(oauth_signature, '')\n        return self._download_json(\n            '?'.join([base_url, encoded_query]), video_id,\n            note='Downloading %s JSON metadata' % note, headers=headers, data=data)\n\n    def _call_cms(self, path, video_id, note):\n        if not self._CMS_SIGNING:\n            self._CMS_SIGNING = self._call_api('index', video_id, 'CMS Signing')['cms_signing']\n        return self._download_json(\n            self._API_DOMAIN + path, video_id, query=self._CMS_SIGNING,\n            note='Downloading %s JSON metadata' % note, headers=self.geo_verification_headers())\n\n    def _set_api_params(self, webpage, video_id):\n        if not self._API_PARAMS:\n            self._API_PARAMS = self._parse_json(self._search_regex(\n                r'window\\.__APP_CONFIG__\\s*=\\s*({.+?})</script>',\n                webpage, 'api config'), video_id)['cxApiParams']\n            self._API_DOMAIN = self._API_PARAMS.get('apiDomain', 'https://api.vrv.co')\n\n    def _get_cms_resource(self, resource_key, video_id):\n        return self._call_api(\n            'cms_resource', video_id, 'resource path', data={\n                'resource_key': resource_key,\n            })['__links__']['cms_resource']['href']\n\n\nclass VRVIE(VRVBaseIE):\n    IE_NAME = 'vrv'\n    _VALID_URL = r'https?://(?:www\\.)?vrv\\.co/watch/(?P<id>[A-Z0-9]+)'\n    _TEST = {\n        'url': 'https://vrv.co/watch/GR9PNZ396/Hidden-America-with-Jonah-Ray:BOSTON-WHERE-THE-PAST-IS-THE-PRESENT',\n        'info_dict': {\n            'id': 'GR9PNZ396',\n            'ext': 'mp4',\n            'title': 'BOSTON: WHERE THE PAST IS THE PRESENT',\n            'description': 'md5:4ec8844ac262ca2df9e67c0983c6b83f',\n            'uploader_id': 'seeso',\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        webpage = self._download_webpage(\n            url, video_id,\n            headers=self.geo_verification_headers())\n        media_resource = self._parse_json(self._search_regex(\n            r'window\\.__INITIAL_STATE__\\s*=\\s*({.+?})</script>',\n            webpage, 'inital state'), video_id).get('watch', {}).get('mediaResource') or {}\n\n        video_data = media_resource.get('json')\n        if not video_data:\n            self._set_api_params(webpage, video_id)\n            episode_path = self._get_cms_resource(\n                'cms:/episodes/' + video_id, video_id)\n            video_data = self._call_cms(episode_path, video_id, 'video')\n        title = video_data['title']\n\n        streams_json = media_resource.get('streams', {}).get('json', {})\n        if not streams_json:\n            self._set_api_params(webpage, video_id)\n            streams_path = video_data['__links__']['streams']['href']\n            streams_json = self._call_cms(streams_path, video_id, 'streams')\n\n        audio_locale = streams_json.get('audio_locale')\n        formats = []\n        for stream_type, streams in streams_json.get('streams', {}).items():\n            if stream_type in ('adaptive_hls', 'adaptive_dash'):\n                for stream in streams.values():\n                    stream_url = stream.get('url')\n                    if not stream_url:\n                        continue\n                    stream_id = stream.get('hardsub_locale') or audio_locale\n                    format_id = '%s-%s' % (stream_type.split('_')[1], stream_id)\n                    if stream_type == 'adaptive_hls':\n                        adaptive_formats = self._extract_m3u8_formats(\n                            stream_url, video_id, 'mp4', m3u8_id=format_id,\n                            note='Downloading %s m3u8 information' % stream_id,\n                            fatal=False)\n                    else:\n                        adaptive_formats = self._extract_mpd_formats(\n                            stream_url, video_id, mpd_id=format_id,\n                            note='Downloading %s MPD information' % stream_id,\n                            fatal=False)\n                    if audio_locale:\n                        for f in adaptive_formats:\n                            if f.get('acodec') != 'none':\n                                f['language'] = audio_locale\n                    formats.extend(adaptive_formats)\n        self._sort_formats(formats)\n\n        subtitles = {}\n        for subtitle in streams_json.get('subtitles', {}).values():\n            subtitle_url = subtitle.get('url')\n            if not subtitle_url:\n                continue\n            subtitles.setdefault(subtitle.get('locale', 'en-US'), []).append({\n                'url': subtitle_url,\n                'ext': subtitle.get('format', 'ass'),\n            })\n\n        thumbnails = []\n        for thumbnail in video_data.get('images', {}).get('thumbnails', []):\n            thumbnail_url = thumbnail.get('source')\n            if not thumbnail_url:\n                continue\n            thumbnails.append({\n                'url': thumbnail_url,\n                'width': int_or_none(thumbnail.get('width')),\n                'height': int_or_none(thumbnail.get('height')),\n            })\n\n        return {\n            'id': video_id,\n            'title': title,\n            'formats': formats,\n            'subtitles': subtitles,\n            'thumbnails': thumbnails,\n            'description': video_data.get('description'),\n            'duration': float_or_none(video_data.get('duration_ms'), 1000),\n            'uploader_id': video_data.get('channel_id'),\n            'series': video_data.get('series_title'),\n            'season': video_data.get('season_title'),\n            'season_number': int_or_none(video_data.get('season_number')),\n            'season_id': video_data.get('season_id'),\n            'episode': title,\n            'episode_number': int_or_none(video_data.get('episode_number')),\n            'episode_id': video_data.get('production_episode_id'),\n        }\n\n\nclass VRVSeriesIE(VRVBaseIE):\n    IE_NAME = 'vrv:series'\n    _VALID_URL = r'https?://(?:www\\.)?vrv\\.co/series/(?P<id>[A-Z0-9]+)'\n    _TEST = {\n        'url': 'https://vrv.co/series/G68VXG3G6/The-Perfect-Insider',\n        'info_dict': {\n            'id': 'G68VXG3G6',\n        },\n        'playlist_mincount': 11,\n    }\n\n    def _real_extract(self, url):\n        series_id = self._match_id(url)\n        webpage = self._download_webpage(\n            url, series_id,\n            headers=self.geo_verification_headers())\n\n        self._set_api_params(webpage, series_id)\n        seasons_path = self._get_cms_resource(\n            'cms:/seasons?series_id=' + series_id, series_id)\n        seasons_data = self._call_cms(seasons_path, series_id, 'seasons')\n\n        entries = []\n        for season in seasons_data.get('items', []):\n            episodes_path = season['__links__']['season/episodes']['href']\n            episodes = self._call_cms(episodes_path, series_id, 'episodes')\n            for episode in episodes.get('items', []):\n                episode_id = episode['id']\n                entries.append(self.url_result(\n                    'https://vrv.co/watch/' + episode_id,\n                    'VRV', episode_id, episode.get('title')))\n\n        return self.playlist_result(entries, series_id)\n", "comments": "# coding: utf-8\n# m3u8 download\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport base64\nimport json\nimport hashlib\nimport hmac\nimport random\nimport string\nimport time\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_urllib_parse_urlencode,\n    compat_urlparse,\n)\nfrom ..utils import (\n    float_or_none,\n    int_or_none,\n)\n\n\nclass VRVBaseIE(InfoExtractor):\n    _API_DOMAIN = None\n    _API_PARAMS = {}\n    _CMS_SIGNING = {}\n\n    def _call_api(self, path, video_id, note, data=None):\n        base_url = self._API_DOMAIN + '/core/' + path\n        encoded_query = compat_urllib_parse_urlencode({\n            'oauth_consumer_key': self._API_PARAMS['oAuthKey'],\n            'oauth_nonce': ''.join([random.choice(string.ascii_letters) for _ in range(32)]),\n            'oauth_signature_method': 'HMAC-SHA1',\n            'oauth_timestamp': int(time.time()),\n            'oauth_version': '1.0',\n        })\n        headers = self.geo_verification_headers()\n        if data:\n            data = json.dumps(data).encode()\n            headers['Content-Type'] = 'application/json'\n        method = 'POST' if data else 'GET'\n        base_string = '&'.join([method, compat_urlparse.quote(base_url, ''), compat_urlparse.quote(encoded_query, '')])\n        oauth_signature = base64.b64encode(hmac.new(\n            (self._API_PARAMS['oAuthSecret'] + '&').encode('ascii'),\n            base_string.encode(), hashlib.sha1).digest()).decode()\n        encoded_query += '&oauth_signature=' + compat_urlparse.quote(oauth_signature, '')\n        return self._download_json(\n            '?'.join([base_url, encoded_query]), video_id,\n            note='Downloading %s JSON metadata' % note, headers=headers, data=data)\n\n    def _call_cms(self, path, video_id, note):\n        if not self._CMS_SIGNING:\n            self._CMS_SIGNING = self._call_api('index', video_id, 'CMS Signing')['cms_signing']\n        return self._download_json(\n            self._API_DOMAIN + path, video_id, query=self._CMS_SIGNING,\n            note='Downloading %s JSON metadata' % note, headers=self.geo_verification_headers())\n\n    def _set_api_params(self, webpage, video_id):\n        if not self._API_PARAMS:\n            self._API_PARAMS = self._parse_json(self._search_regex(\n                r'window\\.__APP_CONFIG__\\s*=\\s*({.+?})</script>',\n                webpage, 'api config'), video_id)['cxApiParams']\n            self._API_DOMAIN = self._API_PARAMS.get('apiDomain', 'https://api.vrv.co')\n\n    def _get_cms_resource(self, resource_key, video_id):\n        return self._call_api(\n            'cms_resource', video_id, 'resource path', data={\n                'resource_key': resource_key,\n            })['__links__']['cms_resource']['href']\n\n\nclass VRVIE(VRVBaseIE):\n    IE_NAME = 'vrv'\n    _VALID_URL = r'https?://(?:www\\.)?vrv\\.co/watch/(?P<id>[A-Z0-9]+)'\n    _TEST = {\n        'url': 'https://vrv.co/watch/GR9PNZ396/Hidden-America-with-Jonah-Ray:BOSTON-WHERE-THE-PAST-IS-THE-PRESENT',\n        'info_dict': {\n            'id': 'GR9PNZ396',\n            'ext': 'mp4',\n            'title': 'BOSTON: WHERE THE PAST IS THE PRESENT',\n            'description': 'md5:4ec8844ac262ca2df9e67c0983c6b83f',\n            'uploader_id': 'seeso',\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n    }\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n        webpage = self._download_webpage(\n            url, video_id,\n            headers=self.geo_verification_headers())\n        media_resource = self._parse_json(self._search_regex(\n            r'window\\.__INITIAL_STATE__\\s*=\\s*({.+?})</script>',\n            webpage, 'inital state'), video_id).get('watch', {}).get('mediaResource') or {}\n\n        video_data = media_resource.get('json')\n        if not video_data:\n            self._set_api_params(webpage, video_id)\n            episode_path = self._get_cms_resource(\n                'cms:/episodes/' + video_id, video_id)\n            video_data = self._call_cms(episode_path, video_id, 'video')\n        title = video_data['title']\n\n        streams_json = media_resource.get('streams', {}).get('json', {})\n        if not streams_json:\n            self._set_api_params(webpage, video_id)\n            streams_path = video_data['__links__']['streams']['href']\n            streams_json = self._call_cms(streams_path, video_id, 'streams')\n\n        audio_locale = streams_json.get('audio_locale')\n        formats = []\n        for stream_type, streams in streams_json.get('streams', {}).items():\n            if stream_type in ('adaptive_hls', 'adaptive_dash'):\n                for stream in streams.values():\n                    stream_url = stream.get('url')\n                    if not stream_url:\n                        continue\n                    stream_id = stream.get('hardsub_locale') or audio_locale\n                    format_id = '%s-%s' % (stream_type.split('_')[1], stream_id)\n                    if stream_type == 'adaptive_hls':\n                        adaptive_formats = self._extract_m3u8_formats(\n                            stream_url, video_id, 'mp4', m3u8_id=format_id,\n                            note='Downloading %s m3u8 information' % stream_id,\n                            fatal=False)\n                    else:\n                        adaptive_formats = self._extract_mpd_formats(\n                            stream_url, video_id, mpd_id=format_id,\n                            note='Downloading %s MPD information' % stream_id,\n                            fatal=False)\n                    if audio_locale:\n                        for f in adaptive_formats:\n                            if f.get('acodec') != 'none':\n                                f['language'] = audio_locale\n                    formats.extend(adaptive_formats)\n        self._sort_formats(formats)\n\n        subtitles = {}\n        for subtitle in streams_json.get('subtitles', {}).values():\n            subtitle_url = subtitle.get('url')\n            if not subtitle_url:\n                continue\n            subtitles.setdefault(subtitle.get('locale', 'en-US'), []).append({\n                'url': subtitle_url,\n                'ext': subtitle.get('format', 'ass'),\n            })\n\n        thumbnails = []\n        for thumbnail in video_data.get('images', {}).get('thumbnails', []):\n            thumbnail_url = thumbnail.get('source')\n            if not thumbnail_url:\n                continue\n            thumbnails.append({\n                'url': thumbnail_url,\n                'width': int_or_none(thumbnail.get('width')),\n                'height': int_or_none(thumbnail.get('height')),\n            })\n\n        return {\n            'id': video_id,\n            'title': title,\n            'formats': formats,\n            'subtitles': subtitles,\n            'thumbnails': thumbnails,\n            'description': video_data.get('description'),\n            'duration': float_or_none(video_data.get('duration_ms'), 1000),\n            'uploader_id': video_data.get('channel_id'),\n            'series': video_data.get('series_title'),\n            'season': video_data.get('season_title'),\n            'season_number': int_or_none(video_data.get('season_number')),\n            'season_id': video_data.get('season_id'),\n            'episode': title,\n            'episode_number': int_or_none(video_data.get('episode_number')),\n            'episode_id': video_data.get('production_episode_id'),\n        }\n\n\nclass VRVSeriesIE(VRVBaseIE):\n    IE_NAME = 'vrv:series'\n    _VALID_URL = r'https?://(?:www\\.)?vrv\\.co/series/(?P<id>[A-Z0-9]+)'\n    _TEST = {\n        'url': 'https://vrv.co/series/G68VXG3G6/The-Perfect-Insider',\n        'info_dict': {\n            'id': 'G68VXG3G6',\n        },\n        'playlist_mincount': 11,\n    }\n\n    def _real_extract(self, url):\n        series_id = self._match_id(url)\n        webpage = self._download_webpage(\n            url, series_id,\n            headers=self.geo_verification_headers())\n\n        self._set_api_params(webpage, series_id)\n        seasons_path = self._get_cms_resource(\n            'cms:/seasons?series_id=' + series_id, series_id)\n        seasons_data = self._call_cms(seasons_path, series_id, 'seasons')\n\n        entries = []\n        for season in seasons_data.get('items', []):\n            episodes_path = season['__links__']['season/episodes']['href']\n            episodes = self._call_cms(episodes_path, series_id, 'episodes')\n            for episode in episodes.get('items', []):\n                episode_id = episode['id']\n                entries.append(self.url_result(\n                    'https://vrv.co/watch/' + episode_id,\n                    'VRV', episode_id, episode.get('title')))\n\n        return self.playlist_result(entries, series_id)\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "vrv.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/vrv.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}