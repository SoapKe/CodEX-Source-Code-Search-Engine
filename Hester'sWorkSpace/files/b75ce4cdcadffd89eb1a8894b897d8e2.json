{"author": "HelloZeroNet", "code": "import re\nimport time\nimport copy\n\nfrom Plugin import PluginManager\nfrom Translate import Translate\nfrom util import RateLimit\nfrom util import helper\nfrom Debug import Debug\ntry:\n    import OptionalManager.UiWebsocketPlugin  \nexcept Exception:\n    pass\n\nif \"merger_db\" not in locals().keys():  \n    merger_db = {}  # Sites that allowed to list other sites {address: [type1, type2...]}\n    merged_db = {}  \n    merged_to_merger = {}  # {address: [site1, site2, ...]} cache\n    site_manager = None  \n\nif \"_\" not in locals():\n    _ = Translate(\"plugins/MergerSite/languages/\")\n\n\n\ndef checkMergerPath(address, inner_path):\n    merged_match = re.match(\"^merged-(.*?)/([A-Za-z0-9]{26,35})/\", inner_path)\n    if merged_match:\n        merger_type = merged_match.group(1)\n        \n        if merger_type in merger_db.get(address, []):\n            \n            merged_address = merged_match.group(2)\n            if merged_db.get(merged_address) == merger_type:\n                inner_path = re.sub(\"^merged-(.*?)/([A-Za-z0-9]{26,35})/\", \"\", inner_path)\n                return merged_address, inner_path\n            else:\n                raise Exception(\n                    \"Merger site (%s) does not have permission for merged site: %s (%s)\" %\n                    (merger_type, merged_address, merged_db.get(merged_address))\n                )\n        else:\n            raise Exception(\"No merger (%s) permission to load: <br>%s (%s not in %s)\" % (\n                address, inner_path, merger_type, merger_db.get(address, []))\n            )\n    else:\n        raise Exception(\"Invalid merger path: %s\" % inner_path)\n\n\n@PluginManager.registerTo(\"UiWebsocket\")\nclass UiWebsocketPlugin(object):\n    \n    def actionMergerSiteAdd(self, to, addresses):\n        if type(addresses) != list:\n            \n            addresses = [addresses]\n        \n        merger_types = merger_db.get(self.site.address)\n        if not merger_types:\n            return self.response(to, {\"error\": \"Not a merger site\"})\n\n        if RateLimit.isAllowed(self.site.address + \"-MergerSiteAdd\", 10) and len(addresses) == 1:\n            \n            self.cbMergerSiteAdd(to, addresses)\n        else:\n            self.cmd(\n                \"confirm\",\n                [_[\"Add <b>%s</b> new site?\"] % len(addresses), \"Add\"],\n                lambda (res): self.cbMergerSiteAdd(to, addresses)\n            )\n        self.response(to, \"ok\")\n\n    \n    def cbMergerSiteAdd(self, to, addresses):\n        added = 0\n        for address in addresses:\n            added += 1\n            site_manager.need(address)\n        if added:\n            self.cmd(\"notification\", [\"done\", _[\"Added <b>%s</b> new site\"] % added, 5000])\n        RateLimit.called(self.site.address + \"-MergerSiteAdd\")\n        site_manager.updateMergerSites()\n\n    \n    def actionMergerSiteDelete(self, to, address):\n        site = self.server.sites.get(address)\n        if not site:\n            return self.response(to, {\"error\": \"No site found: %s\" % address})\n\n        merger_types = merger_db.get(self.site.address)\n        if not merger_types:\n            return self.response(to, {\"error\": \"Not a merger site\"})\n        if merged_db.get(address) not in merger_types:\n            return self.response(to, {\"error\": \"Merged type (%s) not in %s\" % (merged_db.get(address), merger_types)})\n\n        self.cmd(\"notification\", [\"done\", _[\"Site deleted: <b>%s</b>\"] % address, 5000])\n        self.response(to, \"ok\")\n\n    \n    def actionMergerSiteList(self, to, query_site_info=False):\n        merger_types = merger_db.get(self.site.address)\n        ret = {}\n        if not merger_types:\n            return self.response(to, {\"error\": \"Not a merger site\"})\n        for address, merged_type in merged_db.iteritems():\n            if merged_type not in merger_types:\n                continue  \n            if query_site_info:\n                site = self.server.sites.get(address)\n                ret[address] = self.formatSiteInfo(site, create_user=False)\n            else:\n                ret[address] = merged_type\n        self.response(to, ret)\n\n    def hasSitePermission(self, address, *args, **kwargs):\n        if super(UiWebsocketPlugin, self).hasSitePermission(address, *args, **kwargs):\n            return True\n        else:\n            if self.site.address in [merger_site.address for merger_site in merged_to_merger.get(address, [])]:\n                return True\n            else:\n                return False\n\n    \n    def mergerFuncWrapper(self, func_name, to, inner_path, *args, **kwargs):\n        if inner_path.startswith(\"merged-\"):\n            merged_address, merged_inner_path = checkMergerPath(self.site.address, inner_path)\n\n            \n            merger_cert = self.user.getSiteData(self.site.address).get(\"cert\")\n            if merger_cert and self.user.getSiteData(merged_address).get(\"cert\") != merger_cert:\n                self.user.setCert(merged_address, merger_cert)\n\n            req_self = copy.copy(self)\n            req_self.site = self.server.sites.get(merged_address)  \n\n            func = getattr(super(UiWebsocketPlugin, req_self), func_name)\n            return func(to, merged_inner_path, *args, **kwargs)\n        else:\n            func = getattr(super(UiWebsocketPlugin, self), func_name)\n            return func(to, inner_path, *args, **kwargs)\n\n    def actionFileList(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionFileList\", to, inner_path, *args, **kwargs)\n\n    def actionDirList(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionDirList\", to, inner_path, *args, **kwargs)\n\n    def actionFileGet(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionFileGet\", to, inner_path, *args, **kwargs)\n\n    def actionFileWrite(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionFileWrite\", to, inner_path, *args, **kwargs)\n\n    def actionFileDelete(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionFileDelete\", to, inner_path, *args, **kwargs)\n\n    def actionFileRules(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionFileRules\", to, inner_path, *args, **kwargs)\n\n    def actionFileNeed(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionFileNeed\", to, inner_path, *args, **kwargs)\n\n    def actionOptionalFileInfo(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionOptionalFileInfo\", to, inner_path, *args, **kwargs)\n\n    def actionOptionalFileDelete(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionOptionalFileDelete\", to, inner_path, *args, **kwargs)\n\n    def actionBigfileUploadInit(self, to, inner_path, *args, **kwargs):\n        back = self.mergerFuncWrapper(\"actionBigfileUploadInit\", to, inner_path, *args, **kwargs)\n        if inner_path.startswith(\"merged-\"):\n            merged_address, merged_inner_path = checkMergerPath(self.site.address, inner_path)\n            back[\"inner_path\"] = \"merged-%s/%s/%s\" % (merged_db[merged_address], merged_address, back[\"inner_path\"])\n        return back\n\n     with privatekey parameter\n    def mergerFuncWrapperWithPrivatekey(self, func_name, to, privatekey, inner_path, *args, **kwargs):\n        func = getattr(super(UiWebsocketPlugin, self), func_name)\n        if inner_path.startswith(\"merged-\"):\n            merged_address, merged_inner_path = checkMergerPath(self.site.address, inner_path)\n            merged_site = self.server.sites.get(merged_address)\n\n            \n            merger_cert = self.user.getSiteData(self.site.address).get(\"cert\")\n            if merger_cert:\n                self.user.setCert(merged_address, merger_cert)\n\n            site_before = self.site  \n            self.site = merged_site  \n            try:\n                back = func(to, privatekey, merged_inner_path, *args, **kwargs)\n            finally:\n                self.site = site_before  \n            return back\n        else:\n            return func(to, privatekey, inner_path, *args, **kwargs)\n\n    def actionSiteSign(self, to, privatekey=None, inner_path=\"content.json\", *args, **kwargs):\n        return self.mergerFuncWrapperWithPrivatekey(\"actionSiteSign\", to, privatekey, inner_path, *args, **kwargs)\n\n    def actionSitePublish(self, to, privatekey=None, inner_path=\"content.json\", *args, **kwargs):\n        return self.mergerFuncWrapperWithPrivatekey(\"actionSitePublish\", to, privatekey, inner_path, *args, **kwargs)\n\n    def actionPermissionAdd(self, to, permission):\n        super(UiWebsocketPlugin, self).actionPermissionAdd(to, permission)\n        if permission.startswith(\"Merger\"):\n            self.site.storage.rebuildDb()\n\n    def actionPermissionDetails(self, to, permission):\n        if not permission.startswith(\"Merger\"):\n            return super(UiWebsocketPlugin, self).actionPermissionDetails(to, permission)\n\n        merger_type = permission.replace(\"Merger:\", \"\")\n        merged_sites = []\n        for address, merged_type in merged_db.iteritems():\n            if merged_type != merger_type:\n                continue\n            site = self.server.sites.get(address)\n            try:\n                merged_sites.append(site.content_manager.contents.get(\"content.json\").get(\"title\", address))\n            except Exception as err:\n                merged_sites.append(address)\n\n        details = _[\"Read and write permissions to sites with merged type of <b>%s</b> \"] % merger_type\n        details += _[\"(%s sites)\"] % len(merged_sites)\n        details += \"<div style='white-space: normal; max-width: 400px'>%s</div>\" % \", \".join(merged_sites)\n        self.response(to, details)\n\n\n@PluginManager.registerTo(\"UiRequest\")\nclass UiRequestPlugin(object):\n    \n    def parsePath(self, path):\n        path_parts = super(UiRequestPlugin, self).parsePath(path)\n        if \"merged-\" not in path:  \n            return path_parts\n        path_parts[\"address\"], path_parts[\"inner_path\"] = checkMergerPath(path_parts[\"address\"], path_parts[\"inner_path\"])\n        return path_parts\n\n\n@PluginManager.registerTo(\"SiteStorage\")\nclass SiteStoragePlugin(object):\n    \n    def getDbFiles(self):\n        merger_types = merger_db.get(self.site.address)\n\n        \n        for item in super(SiteStoragePlugin, self).getDbFiles():\n            yield item\n\n        \n        if not merger_types:\n            raise StopIteration\n\n        merged_sites = [\n            site_manager.sites[address]\n            for address, merged_type in merged_db.iteritems()\n            if merged_type in merger_types\n        ]\n        found = 0\n        for merged_site in merged_sites:\n            self.log.debug(\"Loading merged site: %s\" % merged_site)\n            merged_type = merged_db[merged_site.address]\n            for content_inner_path, content in merged_site.content_manager.contents.iteritems():\n                \n                if merged_site.storage.isFile(content_inner_path):  \n                    merged_inner_path = \"merged-%s/%s/%s\" % (merged_type, merged_site.address, content_inner_path)\n                    yield merged_inner_path, merged_site.storage.getPath(content_inner_path)\n                else:\n                    merged_site.log.error(\"[MISSING] %s\" % content_inner_path)\n                \n                content_inner_path_dir = helper.getDirname(content_inner_path)  \n                for file_relative_path in content.get(\"files\", {}).keys() + content.get(\"files_optional\", {}).keys():\n                    if not file_relative_path.endswith(\".json\"):\n                        continue  \n                    file_inner_path = content_inner_path_dir + file_relative_path  \n                    file_inner_path = file_inner_path.strip(\"/\")  \n                    if merged_site.storage.isFile(file_inner_path):\n                        merged_inner_path = \"merged-%s/%s/%s\" % (merged_type, merged_site.address, file_inner_path)\n                        yield merged_inner_path, merged_site.storage.getPath(file_inner_path)\n                    else:\n                        merged_site.log.error(\"[MISSING] %s\" % file_inner_path)\n                    found += 1\n                    if found % 100 == 0:\n                        time.sleep(0.000001)  \n\n    \n    def onUpdated(self, inner_path, file=None):\n        super(SiteStoragePlugin, self).onUpdated(inner_path, file)\n\n        merged_type = merged_db.get(self.site.address)\n\n        for merger_site in merged_to_merger.get(self.site.address, []):\n            if merger_site.address == self.site.address:  \n                continue\n            virtual_path = \"merged-%s/%s/%s\" % (merged_type, self.site.address, inner_path)\n            if inner_path.endswith(\".json\"):\n                if file is not None:\n                    merger_site.storage.onUpdated(virtual_path, file=file)\n                else:\n                    merger_site.storage.onUpdated(virtual_path, file=self.open(inner_path))\n            else:\n                merger_site.storage.onUpdated(virtual_path)\n\n\n@PluginManager.registerTo(\"Site\")\nclass SitePlugin(object):\n    def fileDone(self, inner_path):\n        super(SitePlugin, self).fileDone(inner_path)\n\n        for merger_site in merged_to_merger.get(self.address, []):\n            if merger_site.address == self.address:\n                continue\n            for ws in merger_site.websockets:\n                ws.event(\"siteChanged\", self, {\"event\": [\"file_done\", inner_path]})\n\n    def fileFailed(self, inner_path):\n        super(SitePlugin, self).fileFailed(inner_path)\n\n        for merger_site in merged_to_merger.get(self.address, []):\n            if merger_site.address == self.address:\n                continue\n            for ws in merger_site.websockets:\n                ws.event(\"siteChanged\", self, {\"event\": [\"file_failed\", inner_path]})\n\n\n@PluginManager.registerTo(\"SiteManager\")\nclass SiteManagerPlugin(object):\n    \n    def updateMergerSites(self):\n        global merger_db, merged_db, merged_to_merger, site_manager\n        s = time.time()\n        merger_db = {}\n        merged_db = {}\n        merged_to_merger = {}\n        site_manager = self\n        if not self.sites:\n            return\n        for site in self.sites.itervalues():\n            \n            try:\n                merged_type = site.content_manager.contents.get(\"content.json\", {}).get(\"merged_type\")\n            except Exception, err:\n                self.log.error(\"Error loading site %s: %s\" % (site.address, Debug.formatException(err)))\n                continue\n            if merged_type:\n                merged_db[site.address] = merged_type\n\n            \n            for permission in site.settings[\"permissions\"]:\n                if not permission.startswith(\"Merger:\"):\n                    continue\n                if merged_type:\n                    self.log.error(\n                        \"Removing permission %s from %s: Merger and merged at the same time.\" %\n                        (permission, site.address)\n                    )\n                    site.settings[\"permissions\"].remove(permission)\n                    continue\n                merger_type = permission.replace(\"Merger:\", \"\")\n                if site.address not in merger_db:\n                    merger_db[site.address] = []\n                merger_db[site.address].append(merger_type)\n                site_manager.sites[site.address] = site\n\n            \n            if merged_type:\n                for merger_site in self.sites.itervalues():\n                    if \"Merger:\" + merged_type in merger_site.settings[\"permissions\"]:\n                        if site.address not in merged_to_merger:\n                            merged_to_merger[site.address] = []\n                        merged_to_merger[site.address].append(merger_site)\n        self.log.debug(\"Updated merger sites in %.3fs\" % (time.time() - s))\n\n    def load(self, *args, **kwags):\n        super(SiteManagerPlugin, self).load(*args, **kwags)\n        self.updateMergerSites()\n\n    def save(self, *args, **kwags):\n        super(SiteManagerPlugin, self).save(*args, **kwags)\n        self.updateMergerSites()\n", "comments": "  to make optioanlfileinfo merger sites compatible    to keep merger sites module reloads    sites allowed list sites  address   type1  type2         sites allowed merged sites  address  type           address   site1  site2        cache    site manager merger sites    check site permission merger site    check merged site allowed include sites    check included site allows include    download new site    single site add    check site merger permission    without confirmation one site address called last 10 sec    callback adding new site confirmation    delete merged site    lists merged sites    site us    add support merger sites file commands    set cert merged site    change site merged one    add support merger sites file commands privatekey parameter    set cert merged site    save able change back ran command    change site merged one    change back original site    allow load merged site files using  merged zerome address file jpg    optimization    also rebuild merged sites    first return site db files    not merger site     content json file    missing content json file    data files content json    content json dir relative site    we interesed json files    file relative site dir    strip leading      context switch avoid ui block    also notice merger sites merged site file change    avoid infinite loop    update merger site site types    update merged sites    update merger sites    update merged merger ", "content": "import re\nimport time\nimport copy\n\nfrom Plugin import PluginManager\nfrom Translate import Translate\nfrom util import RateLimit\nfrom util import helper\nfrom Debug import Debug\ntry:\n    import OptionalManager.UiWebsocketPlugin  # To make optioanlFileInfo merger sites compatible\nexcept Exception:\n    pass\n\nif \"merger_db\" not in locals().keys():  # To keep merger_sites between module reloads\n    merger_db = {}  # Sites that allowed to list other sites {address: [type1, type2...]}\n    merged_db = {}  # Sites that allowed to be merged to other sites {address: type, ...}\n    merged_to_merger = {}  # {address: [site1, site2, ...]} cache\n    site_manager = None  # Site manager for merger sites\n\nif \"_\" not in locals():\n    _ = Translate(\"plugins/MergerSite/languages/\")\n\n\n# Check if the site has permission to this merger site\ndef checkMergerPath(address, inner_path):\n    merged_match = re.match(\"^merged-(.*?)/([A-Za-z0-9]{26,35})/\", inner_path)\n    if merged_match:\n        merger_type = merged_match.group(1)\n        # Check if merged site is allowed to include other sites\n        if merger_type in merger_db.get(address, []):\n            # Check if included site allows to include\n            merged_address = merged_match.group(2)\n            if merged_db.get(merged_address) == merger_type:\n                inner_path = re.sub(\"^merged-(.*?)/([A-Za-z0-9]{26,35})/\", \"\", inner_path)\n                return merged_address, inner_path\n            else:\n                raise Exception(\n                    \"Merger site (%s) does not have permission for merged site: %s (%s)\" %\n                    (merger_type, merged_address, merged_db.get(merged_address))\n                )\n        else:\n            raise Exception(\"No merger (%s) permission to load: <br>%s (%s not in %s)\" % (\n                address, inner_path, merger_type, merger_db.get(address, []))\n            )\n    else:\n        raise Exception(\"Invalid merger path: %s\" % inner_path)\n\n\n@PluginManager.registerTo(\"UiWebsocket\")\nclass UiWebsocketPlugin(object):\n    # Download new site\n    def actionMergerSiteAdd(self, to, addresses):\n        if type(addresses) != list:\n            # Single site add\n            addresses = [addresses]\n        # Check if the site has merger permission\n        merger_types = merger_db.get(self.site.address)\n        if not merger_types:\n            return self.response(to, {\"error\": \"Not a merger site\"})\n\n        if RateLimit.isAllowed(self.site.address + \"-MergerSiteAdd\", 10) and len(addresses) == 1:\n            # Without confirmation if only one site address and not called in last 10 sec\n            self.cbMergerSiteAdd(to, addresses)\n        else:\n            self.cmd(\n                \"confirm\",\n                [_[\"Add <b>%s</b> new site?\"] % len(addresses), \"Add\"],\n                lambda (res): self.cbMergerSiteAdd(to, addresses)\n            )\n        self.response(to, \"ok\")\n\n    # Callback of adding new site confirmation\n    def cbMergerSiteAdd(self, to, addresses):\n        added = 0\n        for address in addresses:\n            added += 1\n            site_manager.need(address)\n        if added:\n            self.cmd(\"notification\", [\"done\", _[\"Added <b>%s</b> new site\"] % added, 5000])\n        RateLimit.called(self.site.address + \"-MergerSiteAdd\")\n        site_manager.updateMergerSites()\n\n    # Delete a merged site\n    def actionMergerSiteDelete(self, to, address):\n        site = self.server.sites.get(address)\n        if not site:\n            return self.response(to, {\"error\": \"No site found: %s\" % address})\n\n        merger_types = merger_db.get(self.site.address)\n        if not merger_types:\n            return self.response(to, {\"error\": \"Not a merger site\"})\n        if merged_db.get(address) not in merger_types:\n            return self.response(to, {\"error\": \"Merged type (%s) not in %s\" % (merged_db.get(address), merger_types)})\n\n        self.cmd(\"notification\", [\"done\", _[\"Site deleted: <b>%s</b>\"] % address, 5000])\n        self.response(to, \"ok\")\n\n    # Lists merged sites\n    def actionMergerSiteList(self, to, query_site_info=False):\n        merger_types = merger_db.get(self.site.address)\n        ret = {}\n        if not merger_types:\n            return self.response(to, {\"error\": \"Not a merger site\"})\n        for address, merged_type in merged_db.iteritems():\n            if merged_type not in merger_types:\n                continue  # Site not for us\n            if query_site_info:\n                site = self.server.sites.get(address)\n                ret[address] = self.formatSiteInfo(site, create_user=False)\n            else:\n                ret[address] = merged_type\n        self.response(to, ret)\n\n    def hasSitePermission(self, address, *args, **kwargs):\n        if super(UiWebsocketPlugin, self).hasSitePermission(address, *args, **kwargs):\n            return True\n        else:\n            if self.site.address in [merger_site.address for merger_site in merged_to_merger.get(address, [])]:\n                return True\n            else:\n                return False\n\n    # Add support merger sites for file commands\n    def mergerFuncWrapper(self, func_name, to, inner_path, *args, **kwargs):\n        if inner_path.startswith(\"merged-\"):\n            merged_address, merged_inner_path = checkMergerPath(self.site.address, inner_path)\n\n            # Set the same cert for merged site\n            merger_cert = self.user.getSiteData(self.site.address).get(\"cert\")\n            if merger_cert and self.user.getSiteData(merged_address).get(\"cert\") != merger_cert:\n                self.user.setCert(merged_address, merger_cert)\n\n            req_self = copy.copy(self)\n            req_self.site = self.server.sites.get(merged_address)  # Change the site to the merged one\n\n            func = getattr(super(UiWebsocketPlugin, req_self), func_name)\n            return func(to, merged_inner_path, *args, **kwargs)\n        else:\n            func = getattr(super(UiWebsocketPlugin, self), func_name)\n            return func(to, inner_path, *args, **kwargs)\n\n    def actionFileList(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionFileList\", to, inner_path, *args, **kwargs)\n\n    def actionDirList(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionDirList\", to, inner_path, *args, **kwargs)\n\n    def actionFileGet(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionFileGet\", to, inner_path, *args, **kwargs)\n\n    def actionFileWrite(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionFileWrite\", to, inner_path, *args, **kwargs)\n\n    def actionFileDelete(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionFileDelete\", to, inner_path, *args, **kwargs)\n\n    def actionFileRules(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionFileRules\", to, inner_path, *args, **kwargs)\n\n    def actionFileNeed(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionFileNeed\", to, inner_path, *args, **kwargs)\n\n    def actionOptionalFileInfo(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionOptionalFileInfo\", to, inner_path, *args, **kwargs)\n\n    def actionOptionalFileDelete(self, to, inner_path, *args, **kwargs):\n        return self.mergerFuncWrapper(\"actionOptionalFileDelete\", to, inner_path, *args, **kwargs)\n\n    def actionBigfileUploadInit(self, to, inner_path, *args, **kwargs):\n        back = self.mergerFuncWrapper(\"actionBigfileUploadInit\", to, inner_path, *args, **kwargs)\n        if inner_path.startswith(\"merged-\"):\n            merged_address, merged_inner_path = checkMergerPath(self.site.address, inner_path)\n            back[\"inner_path\"] = \"merged-%s/%s/%s\" % (merged_db[merged_address], merged_address, back[\"inner_path\"])\n        return back\n\n    # Add support merger sites for file commands with privatekey parameter\n    def mergerFuncWrapperWithPrivatekey(self, func_name, to, privatekey, inner_path, *args, **kwargs):\n        func = getattr(super(UiWebsocketPlugin, self), func_name)\n        if inner_path.startswith(\"merged-\"):\n            merged_address, merged_inner_path = checkMergerPath(self.site.address, inner_path)\n            merged_site = self.server.sites.get(merged_address)\n\n            # Set the same cert for merged site\n            merger_cert = self.user.getSiteData(self.site.address).get(\"cert\")\n            if merger_cert:\n                self.user.setCert(merged_address, merger_cert)\n\n            site_before = self.site  # Save to be able to change it back after we ran the command\n            self.site = merged_site  # Change the site to the merged one\n            try:\n                back = func(to, privatekey, merged_inner_path, *args, **kwargs)\n            finally:\n                self.site = site_before  # Change back to original site\n            return back\n        else:\n            return func(to, privatekey, inner_path, *args, **kwargs)\n\n    def actionSiteSign(self, to, privatekey=None, inner_path=\"content.json\", *args, **kwargs):\n        return self.mergerFuncWrapperWithPrivatekey(\"actionSiteSign\", to, privatekey, inner_path, *args, **kwargs)\n\n    def actionSitePublish(self, to, privatekey=None, inner_path=\"content.json\", *args, **kwargs):\n        return self.mergerFuncWrapperWithPrivatekey(\"actionSitePublish\", to, privatekey, inner_path, *args, **kwargs)\n\n    def actionPermissionAdd(self, to, permission):\n        super(UiWebsocketPlugin, self).actionPermissionAdd(to, permission)\n        if permission.startswith(\"Merger\"):\n            self.site.storage.rebuildDb()\n\n    def actionPermissionDetails(self, to, permission):\n        if not permission.startswith(\"Merger\"):\n            return super(UiWebsocketPlugin, self).actionPermissionDetails(to, permission)\n\n        merger_type = permission.replace(\"Merger:\", \"\")\n        merged_sites = []\n        for address, merged_type in merged_db.iteritems():\n            if merged_type != merger_type:\n                continue\n            site = self.server.sites.get(address)\n            try:\n                merged_sites.append(site.content_manager.contents.get(\"content.json\").get(\"title\", address))\n            except Exception as err:\n                merged_sites.append(address)\n\n        details = _[\"Read and write permissions to sites with merged type of <b>%s</b> \"] % merger_type\n        details += _[\"(%s sites)\"] % len(merged_sites)\n        details += \"<div style='white-space: normal; max-width: 400px'>%s</div>\" % \", \".join(merged_sites)\n        self.response(to, details)\n\n\n@PluginManager.registerTo(\"UiRequest\")\nclass UiRequestPlugin(object):\n    # Allow to load merged site files using /merged-ZeroMe/address/file.jpg\n    def parsePath(self, path):\n        path_parts = super(UiRequestPlugin, self).parsePath(path)\n        if \"merged-\" not in path:  # Optimization\n            return path_parts\n        path_parts[\"address\"], path_parts[\"inner_path\"] = checkMergerPath(path_parts[\"address\"], path_parts[\"inner_path\"])\n        return path_parts\n\n\n@PluginManager.registerTo(\"SiteStorage\")\nclass SiteStoragePlugin(object):\n    # Also rebuild from merged sites\n    def getDbFiles(self):\n        merger_types = merger_db.get(self.site.address)\n\n        # First return the site's own db files\n        for item in super(SiteStoragePlugin, self).getDbFiles():\n            yield item\n\n        # Not a merger site, that's all\n        if not merger_types:\n            raise StopIteration\n\n        merged_sites = [\n            site_manager.sites[address]\n            for address, merged_type in merged_db.iteritems()\n            if merged_type in merger_types\n        ]\n        found = 0\n        for merged_site in merged_sites:\n            self.log.debug(\"Loading merged site: %s\" % merged_site)\n            merged_type = merged_db[merged_site.address]\n            for content_inner_path, content in merged_site.content_manager.contents.iteritems():\n                # content.json file itself\n                if merged_site.storage.isFile(content_inner_path):  # Missing content.json file\n                    merged_inner_path = \"merged-%s/%s/%s\" % (merged_type, merged_site.address, content_inner_path)\n                    yield merged_inner_path, merged_site.storage.getPath(content_inner_path)\n                else:\n                    merged_site.log.error(\"[MISSING] %s\" % content_inner_path)\n                # Data files in content.json\n                content_inner_path_dir = helper.getDirname(content_inner_path)  # Content.json dir relative to site\n                for file_relative_path in content.get(\"files\", {}).keys() + content.get(\"files_optional\", {}).keys():\n                    if not file_relative_path.endswith(\".json\"):\n                        continue  # We only interesed in json files\n                    file_inner_path = content_inner_path_dir + file_relative_path  # File Relative to site dir\n                    file_inner_path = file_inner_path.strip(\"/\")  # Strip leading /\n                    if merged_site.storage.isFile(file_inner_path):\n                        merged_inner_path = \"merged-%s/%s/%s\" % (merged_type, merged_site.address, file_inner_path)\n                        yield merged_inner_path, merged_site.storage.getPath(file_inner_path)\n                    else:\n                        merged_site.log.error(\"[MISSING] %s\" % file_inner_path)\n                    found += 1\n                    if found % 100 == 0:\n                        time.sleep(0.000001)  # Context switch to avoid UI block\n\n    # Also notice merger sites on a merged site file change\n    def onUpdated(self, inner_path, file=None):\n        super(SiteStoragePlugin, self).onUpdated(inner_path, file)\n\n        merged_type = merged_db.get(self.site.address)\n\n        for merger_site in merged_to_merger.get(self.site.address, []):\n            if merger_site.address == self.site.address:  # Avoid infinite loop\n                continue\n            virtual_path = \"merged-%s/%s/%s\" % (merged_type, self.site.address, inner_path)\n            if inner_path.endswith(\".json\"):\n                if file is not None:\n                    merger_site.storage.onUpdated(virtual_path, file=file)\n                else:\n                    merger_site.storage.onUpdated(virtual_path, file=self.open(inner_path))\n            else:\n                merger_site.storage.onUpdated(virtual_path)\n\n\n@PluginManager.registerTo(\"Site\")\nclass SitePlugin(object):\n    def fileDone(self, inner_path):\n        super(SitePlugin, self).fileDone(inner_path)\n\n        for merger_site in merged_to_merger.get(self.address, []):\n            if merger_site.address == self.address:\n                continue\n            for ws in merger_site.websockets:\n                ws.event(\"siteChanged\", self, {\"event\": [\"file_done\", inner_path]})\n\n    def fileFailed(self, inner_path):\n        super(SitePlugin, self).fileFailed(inner_path)\n\n        for merger_site in merged_to_merger.get(self.address, []):\n            if merger_site.address == self.address:\n                continue\n            for ws in merger_site.websockets:\n                ws.event(\"siteChanged\", self, {\"event\": [\"file_failed\", inner_path]})\n\n\n@PluginManager.registerTo(\"SiteManager\")\nclass SiteManagerPlugin(object):\n    # Update merger site for site types\n    def updateMergerSites(self):\n        global merger_db, merged_db, merged_to_merger, site_manager\n        s = time.time()\n        merger_db = {}\n        merged_db = {}\n        merged_to_merger = {}\n        site_manager = self\n        if not self.sites:\n            return\n        for site in self.sites.itervalues():\n            # Update merged sites\n            try:\n                merged_type = site.content_manager.contents.get(\"content.json\", {}).get(\"merged_type\")\n            except Exception, err:\n                self.log.error(\"Error loading site %s: %s\" % (site.address, Debug.formatException(err)))\n                continue\n            if merged_type:\n                merged_db[site.address] = merged_type\n\n            # Update merger sites\n            for permission in site.settings[\"permissions\"]:\n                if not permission.startswith(\"Merger:\"):\n                    continue\n                if merged_type:\n                    self.log.error(\n                        \"Removing permission %s from %s: Merger and merged at the same time.\" %\n                        (permission, site.address)\n                    )\n                    site.settings[\"permissions\"].remove(permission)\n                    continue\n                merger_type = permission.replace(\"Merger:\", \"\")\n                if site.address not in merger_db:\n                    merger_db[site.address] = []\n                merger_db[site.address].append(merger_type)\n                site_manager.sites[site.address] = site\n\n            # Update merged to merger\n            if merged_type:\n                for merger_site in self.sites.itervalues():\n                    if \"Merger:\" + merged_type in merger_site.settings[\"permissions\"]:\n                        if site.address not in merged_to_merger:\n                            merged_to_merger[site.address] = []\n                        merged_to_merger[site.address].append(merger_site)\n        self.log.debug(\"Updated merger sites in %.3fs\" % (time.time() - s))\n\n    def load(self, *args, **kwags):\n        super(SiteManagerPlugin, self).load(*args, **kwags)\n        self.updateMergerSites()\n\n    def save(self, *args, **kwags):\n        super(SiteManagerPlugin, self).save(*args, **kwags)\n        self.updateMergerSites()\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "MergerSitePlugin.py", "id": "b75ce4cdcadffd89eb1a8894b897d8e2", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/plugins/MergerSite/MergerSitePlugin.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}