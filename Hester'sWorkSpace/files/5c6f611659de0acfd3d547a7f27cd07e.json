{"author": "odoo", "code": "import logging\nimport re\n\nfrom odoo import tools, models, fields, api, _\nfrom odoo.exceptions import ValidationError\n\n_logger = logging.getLogger(__name__)\n\n\nUPC_EAN_CONVERSIONS = [\n    ('none','Never'),\n    ('ean2upc','EAN-13 to UPC-A'),\n    ('upc2ean','UPC-A to EAN-13'),\n    ('always','Always'),\n]\n\nclass BarcodeNomenclature(models.Model):\n    _name = 'barcode.nomenclature'\n\n    name = fields.Char(string='Nomenclature Name', size=32, required=True, help='An internal identification of the barcode nomenclature')\n    rule_ids = fields.One2many('barcode.rule', 'barcode_nomenclature_id', string='Rules', help='The list of barcode rules')\n    upc_ean_conv = fields.Selection(UPC_EAN_CONVERSIONS, string='UPC/EAN Conversion', required=True, default='always',\n        help=\"UPC Codes can be converted to EAN by prefixing them with a zero. This setting determines if a UPC/EAN barcode should be automatically converted in one way or another when trying to match a rule with the other encoding.\")\n\n    \n    def ean_checksum(self, ean):\n        code = list(ean)\n        if len(code) != 13:\n            return -1\n\n        oddsum = evensum = total = 0\n        code = code[:-1] \n        for i in range(len(code)):\n            if i % 2 == 0:\n                evensum += int(code[i])\n            else:\n                oddsum += int(code[i])\n        total = oddsum * 3 + evensum\n        return int((10 - total % 10) % 10)\n\n    \n    def ean8_checksum(self,ean):\n        code = list(ean)\n        if len(code) != 8:\n            return -1\n\n        sum1  = int(ean[1]) + int(ean[3]) + int(ean[5])\n        sum2  = int(ean[0]) + int(ean[2]) + int(ean[4]) + int(ean[6])\n        total = sum1 + 3 * sum2\n        return int((10 - total % 10) % 10)\n\n    \n    def check_ean(self, ean):\n       return re.match(\"^\\d+$\", ean) and self.ean_checksum(ean) == int(ean[-1])\n\n    \n    def check_encoding(self, barcode, encoding):\n        if encoding == 'ean13':\n            return len(barcode) == 13 and re.match(\"^\\d+$\", barcode) and self.ean_checksum(barcode) == int(barcode[-1]) \n        elif encoding == 'ean8':\n            return len(barcode) == 8 and re.match(\"^\\d+$\", barcode) and self.ean8_checksum(barcode) == int(barcode[-1])\n        elif encoding == 'upca':\n            return len(barcode) == 12 and re.match(\"^\\d+$\", barcode) and self.ean_checksum(\"0\"+barcode) == int(barcode[-1])\n        elif encoding == 'any':\n            return True\n        else:\n            return False\n\n\n    \n    def sanitize_ean(self, ean):\n        ean = ean[0:13]\n        ean = ean + (13-len(ean))*'0'\n        return ean[0:12] + str(self.ean_checksum(ean))\n\n    \n    def sanitize_upc(self, upc):\n        return self.sanitize_ean('0'+upc)[1:]\n\n    \n    \n    \n    # - value: the numerical value encoded in the barcode (0 if no value encoded)\n    \n    \n    def match_pattern(self, barcode, pattern):\n        match = {\n            \"value\": 0,\n            \"base_code\": barcode,\n            \"match\": False,\n        }\n\n        barcode = barcode.replace(\"\\\\\", \"\\\\\\\\\").replace(\"{\", '\\{').replace(\"}\", \"\\}\").replace(\".\", \"\\.\")\n        numerical_content = re.search(\"[{][N]*[D]*[}]\", pattern) \n\n        if numerical_content: \n            num_start = numerical_content.start() \n            num_end = numerical_content.end() \n            value_string = barcode[num_start:num_end-2] \n\n            whole_part_match = re.search(\"[{][N]*[D}]\", numerical_content.group()) \n            decimal_part_match = re.search(\"[{N][D]*[}]\", numerical_content.group()) \n            whole_part = value_string[:whole_part_match.end()-2] \n            decimal_part = \"0.\" + value_string[decimal_part_match.start():decimal_part_match.end()-1] \n            if whole_part == '':\n                whole_part = '0'\n            match['value'] = int(whole_part) + float(decimal_part)\n\n            match['base_code'] = barcode[:num_start] + (num_end-num_start-2)*\"0\" + barcode[num_end-2:] \n            match['base_code'] = match['base_code'].replace(\"\\\\\\\\\", \"\\\\\").replace(\"\\{\", \"{\").replace(\"\\}\",\"}\").replace(\"\\.\",\".\")\n            pattern = pattern[:num_start] + (num_end-num_start-2)*\"0\" + pattern[num_end:] \n\n        match['match'] = re.match(pattern, match['base_code'][:len(pattern)])\n\n        return match\n\n    # Attempts to interpret an barcode (string encoding a barcode)\n    \n    \n    \n    \n    \n    \n    \n    def parse_barcode(self, barcode):\n        parsed_result = {\n            'encoding': '', \n            'type': 'error', \n            'code': barcode, \n            'base_code': barcode, \n            'value': 0,\n        }\n\n        rules = []\n        for rule in self.rule_ids:\n            rules.append({'type': rule.type, 'encoding': rule.encoding, 'sequence': rule.sequence, 'pattern': rule.pattern, 'alias': rule.alias})\n\n        for rule in rules:\n            cur_barcode = barcode\n            if rule['encoding'] == 'ean13' and self.check_encoding(barcode,'upca') and self.upc_ean_conv in ['upc2ean','always']:\n                cur_barcode = '0'+cur_barcode\n            elif rule['encoding'] == 'upca' and self.check_encoding(barcode,'ean13') and barcode[0] == '0' and self.upc_ean_conv in ['ean2upc','always']:\n                cur_barcode = cur_barcode[1:]\n\n            if not self.check_encoding(barcode,rule['encoding']):\n                continue\n\n            match = self.match_pattern(cur_barcode, rule['pattern'])\n            if match['match']:\n                if rule['type'] == 'alias':\n                    barcode = rule['alias']\n                    parsed_result['code'] = barcode\n                else:\n                    parsed_result['encoding'] = rule['encoding']\n                    parsed_result['type'] = rule['type']\n                    parsed_result['value'] = match['value']\n                    parsed_result['code'] = cur_barcode\n                    if rule['encoding'] == \"ean13\":\n                        parsed_result['base_code'] = self.sanitize_ean(match['base_code'])\n                    elif rule['encoding'] == \"upca\":\n                        parsed_result['base_code'] = self.sanitize_upc(match['base_code'])\n                    else:\n                        parsed_result['base_code'] = match['base_code']\n                    return parsed_result\n\n        return parsed_result\n\nclass BarcodeRule(models.Model):\n    _name = 'barcode.rule'\n    _order = 'sequence asc'\n\n\n    name = fields.Char(string='Rule Name', size=32, required=True, help='An internal identification for this barcode nomenclature rule')\n    barcode_nomenclature_id = fields.Many2one('barcode.nomenclature', string='Barcode Nomenclature')\n    sequence = fields.Integer(string='Sequence', help='Used to order rules such that rules with a smaller sequence match first')\n    encoding = fields.Selection([\n                ('any', _('Any')),\n                ('ean13', 'EAN-13'),\n                ('ean8', 'EAN-8'),\n                ('upca', 'UPC-A'),\n        ], string='Encoding', required=True, default='any', help='This rule will apply only if the barcode is encoded with the specified encoding')\n    type = fields.Selection([\n            ('alias', _('Alias')),\n            ('product', _('Unit Product'))\n        ], string='Type', required=True, default='product')\n    pattern = fields.Char(string='Barcode Pattern', size=32, help=\"The barcode matching pattern\", required=True, default='.*')\n    alias = fields.Char(string='Alias', size=32, default='0', help='The matched pattern will alias to this barcode', required=True)\n\n    @api.one\n    @api.constrains('pattern')\n    def _check_pattern(self):\n        p = self.pattern.replace(\"\\\\\\\\\", \"X\").replace(\"\\{\", \"X\").replace(\"\\}\", \"X\")\n        findall = re.findall(\"[{]|[}]\", p) \n        if len(findall) == 2: \n            if not re.search(\"[{][N]*[D]*[}]\", p):\n                raise ValidationError(_(\"There is a syntax error in the barcode pattern \") + self.pattern + _(\": braces can only contain N's followed by D's.\"))\n            elif re.search(\"[{][}]\", p):\n                raise ValidationError(_(\"There is a syntax error in the barcode pattern \") + self.pattern + _(\": empty braces.\"))\n        elif len(findall) != 0:\n            raise ValidationError(_(\"There is a syntax error in the barcode pattern \") + self.pattern + _(\": a rule can only contain one pair of braces.\"))\n        elif p == '*':\n            raise ValidationError(_(\" '*' is not a valid Regex Barcode Pattern. Did you mean '.*' ?\"))\n", "comments": "  returns checksum ean13   1 ean correct length  ean must string    remove checksum    returns checksum ean8   1 ean correct length  ean must string    returns true barcode valid ean barcode    returns true barcode string encoded provided encoding     returns valid zero padded ean13 ean prefix  ean prefix must string     returns valid zero padded upc a upc a prefix  upc a prefix must string     checks barcode matches pattern    additionaly retrieves optional numerical content barcode    returns object containing       value  numerical value encoded barcode (0 value encoded)      base code  barcode numerical content replaced 0      match  boolean    look numerical content pattern    pattern encodes numerical content    start index numerical content    end index numerical content    numerical content barcode    looks whole part numerical content    looks decimal part    retrieve whole part numerical content barcode    retrieve decimal part    replace numerical content 0 barcode    replace numerical content 0 pattern match    attempts interpret barcode (string encoding barcode)    it return object containing various information barcode     importantly          code      barcode       type     type barcode         value    id encodes numerical value  put       base code   barcode code encoding parts set zero  one put                   product backend    p contain escaped     ", "content": "import logging\nimport re\n\nfrom odoo import tools, models, fields, api, _\nfrom odoo.exceptions import ValidationError\n\n_logger = logging.getLogger(__name__)\n\n\nUPC_EAN_CONVERSIONS = [\n    ('none','Never'),\n    ('ean2upc','EAN-13 to UPC-A'),\n    ('upc2ean','UPC-A to EAN-13'),\n    ('always','Always'),\n]\n\nclass BarcodeNomenclature(models.Model):\n    _name = 'barcode.nomenclature'\n\n    name = fields.Char(string='Nomenclature Name', size=32, required=True, help='An internal identification of the barcode nomenclature')\n    rule_ids = fields.One2many('barcode.rule', 'barcode_nomenclature_id', string='Rules', help='The list of barcode rules')\n    upc_ean_conv = fields.Selection(UPC_EAN_CONVERSIONS, string='UPC/EAN Conversion', required=True, default='always',\n        help=\"UPC Codes can be converted to EAN by prefixing them with a zero. This setting determines if a UPC/EAN barcode should be automatically converted in one way or another when trying to match a rule with the other encoding.\")\n\n    # returns the checksum of the ean13, or -1 if the ean has not the correct length, ean must be a string\n    def ean_checksum(self, ean):\n        code = list(ean)\n        if len(code) != 13:\n            return -1\n\n        oddsum = evensum = total = 0\n        code = code[:-1] # Remove checksum\n        for i in range(len(code)):\n            if i % 2 == 0:\n                evensum += int(code[i])\n            else:\n                oddsum += int(code[i])\n        total = oddsum * 3 + evensum\n        return int((10 - total % 10) % 10)\n\n    # returns the checksum of the ean8, or -1 if the ean has not the correct length, ean must be a string\n    def ean8_checksum(self,ean):\n        code = list(ean)\n        if len(code) != 8:\n            return -1\n\n        sum1  = int(ean[1]) + int(ean[3]) + int(ean[5])\n        sum2  = int(ean[0]) + int(ean[2]) + int(ean[4]) + int(ean[6])\n        total = sum1 + 3 * sum2\n        return int((10 - total % 10) % 10)\n\n    # returns true if the barcode is a valid EAN barcode\n    def check_ean(self, ean):\n       return re.match(\"^\\d+$\", ean) and self.ean_checksum(ean) == int(ean[-1])\n\n    # returns true if the barcode string is encoded with the provided encoding.\n    def check_encoding(self, barcode, encoding):\n        if encoding == 'ean13':\n            return len(barcode) == 13 and re.match(\"^\\d+$\", barcode) and self.ean_checksum(barcode) == int(barcode[-1]) \n        elif encoding == 'ean8':\n            return len(barcode) == 8 and re.match(\"^\\d+$\", barcode) and self.ean8_checksum(barcode) == int(barcode[-1])\n        elif encoding == 'upca':\n            return len(barcode) == 12 and re.match(\"^\\d+$\", barcode) and self.ean_checksum(\"0\"+barcode) == int(barcode[-1])\n        elif encoding == 'any':\n            return True\n        else:\n            return False\n\n\n    # Returns a valid zero padded ean13 from an ean prefix. the ean prefix must be a string.\n    def sanitize_ean(self, ean):\n        ean = ean[0:13]\n        ean = ean + (13-len(ean))*'0'\n        return ean[0:12] + str(self.ean_checksum(ean))\n\n    # Returns a valid zero padded UPC-A from a UPC-A prefix. the UPC-A prefix must be a string.\n    def sanitize_upc(self, upc):\n        return self.sanitize_ean('0'+upc)[1:]\n\n    # Checks if barcode matches the pattern\n    # Additionaly retrieves the optional numerical content in barcode\n    # Returns an object containing:\n    # - value: the numerical value encoded in the barcode (0 if no value encoded)\n    # - base_code: the barcode in which numerical content is replaced by 0's\n    # - match: boolean\n    def match_pattern(self, barcode, pattern):\n        match = {\n            \"value\": 0,\n            \"base_code\": barcode,\n            \"match\": False,\n        }\n\n        barcode = barcode.replace(\"\\\\\", \"\\\\\\\\\").replace(\"{\", '\\{').replace(\"}\", \"\\}\").replace(\".\", \"\\.\")\n        numerical_content = re.search(\"[{][N]*[D]*[}]\", pattern) # look for numerical content in pattern\n\n        if numerical_content: # the pattern encodes a numerical content\n            num_start = numerical_content.start() # start index of numerical content\n            num_end = numerical_content.end() # end index of numerical content\n            value_string = barcode[num_start:num_end-2] # numerical content in barcode\n\n            whole_part_match = re.search(\"[{][N]*[D}]\", numerical_content.group()) # looks for whole part of numerical content\n            decimal_part_match = re.search(\"[{N][D]*[}]\", numerical_content.group()) # looks for decimal part\n            whole_part = value_string[:whole_part_match.end()-2] # retrieve whole part of numerical content in barcode\n            decimal_part = \"0.\" + value_string[decimal_part_match.start():decimal_part_match.end()-1] # retrieve decimal part\n            if whole_part == '':\n                whole_part = '0'\n            match['value'] = int(whole_part) + float(decimal_part)\n\n            match['base_code'] = barcode[:num_start] + (num_end-num_start-2)*\"0\" + barcode[num_end-2:] # replace numerical content by 0's in barcode\n            match['base_code'] = match['base_code'].replace(\"\\\\\\\\\", \"\\\\\").replace(\"\\{\", \"{\").replace(\"\\}\",\"}\").replace(\"\\.\",\".\")\n            pattern = pattern[:num_start] + (num_end-num_start-2)*\"0\" + pattern[num_end:] # replace numerical content by 0's in pattern to match\n\n        match['match'] = re.match(pattern, match['base_code'][:len(pattern)])\n\n        return match\n\n    # Attempts to interpret an barcode (string encoding a barcode)\n    # It will return an object containing various information about the barcode.\n    # most importantly : \n    #  - code    : the barcode\n    #  - type   : the type of the barcode: \n    #  - value  : if the id encodes a numerical value, it will be put there\n    #  - base_code : the barcode code with all the encoding parts set to zero; the one put on\n    #                the product in the backend\n    def parse_barcode(self, barcode):\n        parsed_result = {\n            'encoding': '', \n            'type': 'error', \n            'code': barcode, \n            'base_code': barcode, \n            'value': 0,\n        }\n\n        rules = []\n        for rule in self.rule_ids:\n            rules.append({'type': rule.type, 'encoding': rule.encoding, 'sequence': rule.sequence, 'pattern': rule.pattern, 'alias': rule.alias})\n\n        for rule in rules:\n            cur_barcode = barcode\n            if rule['encoding'] == 'ean13' and self.check_encoding(barcode,'upca') and self.upc_ean_conv in ['upc2ean','always']:\n                cur_barcode = '0'+cur_barcode\n            elif rule['encoding'] == 'upca' and self.check_encoding(barcode,'ean13') and barcode[0] == '0' and self.upc_ean_conv in ['ean2upc','always']:\n                cur_barcode = cur_barcode[1:]\n\n            if not self.check_encoding(barcode,rule['encoding']):\n                continue\n\n            match = self.match_pattern(cur_barcode, rule['pattern'])\n            if match['match']:\n                if rule['type'] == 'alias':\n                    barcode = rule['alias']\n                    parsed_result['code'] = barcode\n                else:\n                    parsed_result['encoding'] = rule['encoding']\n                    parsed_result['type'] = rule['type']\n                    parsed_result['value'] = match['value']\n                    parsed_result['code'] = cur_barcode\n                    if rule['encoding'] == \"ean13\":\n                        parsed_result['base_code'] = self.sanitize_ean(match['base_code'])\n                    elif rule['encoding'] == \"upca\":\n                        parsed_result['base_code'] = self.sanitize_upc(match['base_code'])\n                    else:\n                        parsed_result['base_code'] = match['base_code']\n                    return parsed_result\n\n        return parsed_result\n\nclass BarcodeRule(models.Model):\n    _name = 'barcode.rule'\n    _order = 'sequence asc'\n\n\n    name = fields.Char(string='Rule Name', size=32, required=True, help='An internal identification for this barcode nomenclature rule')\n    barcode_nomenclature_id = fields.Many2one('barcode.nomenclature', string='Barcode Nomenclature')\n    sequence = fields.Integer(string='Sequence', help='Used to order rules such that rules with a smaller sequence match first')\n    encoding = fields.Selection([\n                ('any', _('Any')),\n                ('ean13', 'EAN-13'),\n                ('ean8', 'EAN-8'),\n                ('upca', 'UPC-A'),\n        ], string='Encoding', required=True, default='any', help='This rule will apply only if the barcode is encoded with the specified encoding')\n    type = fields.Selection([\n            ('alias', _('Alias')),\n            ('product', _('Unit Product'))\n        ], string='Type', required=True, default='product')\n    pattern = fields.Char(string='Barcode Pattern', size=32, help=\"The barcode matching pattern\", required=True, default='.*')\n    alias = fields.Char(string='Alias', size=32, default='0', help='The matched pattern will alias to this barcode', required=True)\n\n    @api.one\n    @api.constrains('pattern')\n    def _check_pattern(self):\n        p = self.pattern.replace(\"\\\\\\\\\", \"X\").replace(\"\\{\", \"X\").replace(\"\\}\", \"X\")\n        findall = re.findall(\"[{]|[}]\", p) # p does not contain escaped { or }\n        if len(findall) == 2: \n            if not re.search(\"[{][N]*[D]*[}]\", p):\n                raise ValidationError(_(\"There is a syntax error in the barcode pattern \") + self.pattern + _(\": braces can only contain N's followed by D's.\"))\n            elif re.search(\"[{][}]\", p):\n                raise ValidationError(_(\"There is a syntax error in the barcode pattern \") + self.pattern + _(\": empty braces.\"))\n        elif len(findall) != 0:\n            raise ValidationError(_(\"There is a syntax error in the barcode pattern \") + self.pattern + _(\": a rule can only contain one pair of braces.\"))\n        elif p == '*':\n            raise ValidationError(_(\" '*' is not a valid Regex Barcode Pattern. Did you mean '.*' ?\"))\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "barcodes.py", "id": "5c6f611659de0acfd3d547a7f27cd07e", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/barcodes/models/barcodes.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}