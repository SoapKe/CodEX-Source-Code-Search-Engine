{"author": "mwaskom", "code": "import itertools\nimport tempfile\n\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom scipy.spatial import distance\nfrom scipy.cluster import hierarchy\n\nimport nose.tools as nt\nimport numpy.testing as npt\ntry:\n    import pandas.testing as pdt\nexcept ImportError:\n    import pandas.util.testing as pdt\nfrom numpy.testing.decorators import skipif\n\nfrom .. import matrix as mat\nfrom .. import color_palette\nfrom ..external.six.moves import range\n\ntry:\n    import fastcluster\n\n    assert fastcluster\n    _no_fastcluster = False\nexcept ImportError:\n    _no_fastcluster = True\n\n\nclass TestHeatmap(object):\n    rs = np.random.RandomState(sum(map(ord, \"heatmap\")))\n\n    x_norm = rs.randn(4, 8)\n    letters = pd.Series([\"A\", \"B\", \"C\", \"D\"], name=\"letters\")\n    df_norm = pd.DataFrame(x_norm, index=letters)\n\n    x_unif = rs.rand(20, 13)\n    df_unif = pd.DataFrame(x_unif)\n\n    default_kws = dict(vmin=None, vmax=None, cmap=None, center=None,\n                       robust=False, annot=False, fmt=\".2f\", annot_kws=None,\n                       cbar=True, cbar_kws=None, mask=None)\n\n    def test_ndarray_input(self):\n\n        p = mat._HeatMapper(self.x_norm, **self.default_kws)\n        npt.assert_array_equal(p.plot_data, self.x_norm)\n        pdt.assert_frame_equal(p.data, pd.DataFrame(self.x_norm))\n\n        npt.assert_array_equal(p.xticklabels, np.arange(8))\n        npt.assert_array_equal(p.yticklabels, np.arange(4))\n\n        nt.assert_equal(p.xlabel, \"\")\n        nt.assert_equal(p.ylabel, \"\")\n\n    def test_df_input(self):\n\n        p = mat._HeatMapper(self.df_norm, **self.default_kws)\n        npt.assert_array_equal(p.plot_data, self.x_norm)\n        pdt.assert_frame_equal(p.data, self.df_norm)\n\n        npt.assert_array_equal(p.xticklabels, np.arange(8))\n        npt.assert_array_equal(p.yticklabels, self.letters.values)\n\n        nt.assert_equal(p.xlabel, \"\")\n        nt.assert_equal(p.ylabel, \"letters\")\n\n    def test_df_multindex_input(self):\n\n        df = self.df_norm.copy()\n        index = pd.MultiIndex.from_tuples([(\"A\", 1), (\"B\", 2),\n                                           (\"C\", 3), (\"D\", 4)],\n                                          names=[\"letter\", \"number\"])\n        index.name = \"letter-number\"\n        df.index = index\n\n        p = mat._HeatMapper(df, **self.default_kws)\n\n        combined_tick_labels = [\"A-1\", \"B-2\", \"C-3\", \"D-4\"]\n        npt.assert_array_equal(p.yticklabels, combined_tick_labels)\n        nt.assert_equal(p.ylabel, \"letter-number\")\n\n        p = mat._HeatMapper(df.T, **self.default_kws)\n\n        npt.assert_array_equal(p.xticklabels, combined_tick_labels)\n        nt.assert_equal(p.xlabel, \"letter-number\")\n\n    def test_mask_input(self):\n        kws = self.default_kws.copy()\n\n        mask = self.x_norm > 0\n        kws['mask'] = mask\n        p = mat._HeatMapper(self.x_norm, **kws)\n        plot_data = np.ma.masked_where(mask, self.x_norm)\n\n        npt.assert_array_equal(p.plot_data, plot_data)\n\n    def test_default_vlims(self):\n\n        p = mat._HeatMapper(self.df_unif, **self.default_kws)\n        nt.assert_equal(p.vmin, self.x_unif.min())\n        nt.assert_equal(p.vmax, self.x_unif.max())\n\n    def test_robust_vlims(self):\n\n        kws = self.default_kws.copy()\n        kws[\"robust\"] = True\n        p = mat._HeatMapper(self.df_unif, **kws)\n\n        nt.assert_equal(p.vmin, np.percentile(self.x_unif, 2))\n        nt.assert_equal(p.vmax, np.percentile(self.x_unif, 98))\n\n    def test_custom_sequential_vlims(self):\n\n        kws = self.default_kws.copy()\n        kws[\"vmin\"] = 0\n        kws[\"vmax\"] = 1\n        p = mat._HeatMapper(self.df_unif, **kws)\n\n        nt.assert_equal(p.vmin, 0)\n        nt.assert_equal(p.vmax, 1)\n\n    def test_custom_diverging_vlims(self):\n\n        kws = self.default_kws.copy()\n        kws[\"vmin\"] = -4\n        kws[\"vmax\"] = 5\n        kws[\"center\"] = 0\n        p = mat._HeatMapper(self.df_norm, **kws)\n\n        nt.assert_equal(p.vmin, -4)\n        nt.assert_equal(p.vmax, 5)\n\n    def test_array_with_nans(self):\n\n        x1 = self.rs.rand(10, 10)\n        nulls = np.zeros(10) * np.nan\n        x2 = np.c_[x1, nulls]\n\n        m1 = mat._HeatMapper(x1, **self.default_kws)\n        m2 = mat._HeatMapper(x2, **self.default_kws)\n\n        nt.assert_equal(m1.vmin, m2.vmin)\n        nt.assert_equal(m1.vmax, m2.vmax)\n\n    def test_mask(self):\n\n        df = pd.DataFrame(data={'a': [1, 1, 1],\n                                'b': [2, np.nan, 2],\n                                'c': [3, 3, np.nan]})\n\n        kws = self.default_kws.copy()\n        kws[\"mask\"] = np.isnan(df.values)\n\n        m = mat._HeatMapper(df, **kws)\n\n        npt.assert_array_equal(np.isnan(m.plot_data.data),\n                               m.plot_data.mask)\n\n    def test_custom_cmap(self):\n\n        kws = self.default_kws.copy()\n        kws[\"cmap\"] = \"BuGn\"\n        p = mat._HeatMapper(self.df_unif, **kws)\n        nt.assert_equal(p.cmap, mpl.cm.BuGn)\n\n    def test_centered_vlims(self):\n\n        kws = self.default_kws.copy()\n        kws[\"center\"] = .5\n\n        p = mat._HeatMapper(self.df_unif, **kws)\n\n        nt.assert_equal(p.vmin, self.df_unif.values.min())\n        nt.assert_equal(p.vmax, self.df_unif.values.max())\n\n    def test_default_colors(self):\n\n        vals = np.linspace(.2, 1, 9)\n        cmap = mpl.cm.binary\n        ax = mat.heatmap([vals], cmap=cmap)\n        fc = ax.collections[0].get_facecolors()\n        cvals = np.linspace(0, 1, 9)\n        npt.assert_array_almost_equal(fc, cmap(cvals), 2)\n\n    def test_custom_vlim_colors(self):\n\n        vals = np.linspace(.2, 1, 9)\n        cmap = mpl.cm.binary\n        ax = mat.heatmap([vals], vmin=0, cmap=cmap)\n        fc = ax.collections[0].get_facecolors()\n        npt.assert_array_almost_equal(fc, cmap(vals), 2)\n\n    def test_custom_center_colors(self):\n\n        vals = np.linspace(.2, 1, 9)\n        cmap = mpl.cm.binary\n        ax = mat.heatmap([vals], center=.5, cmap=cmap)\n        fc = ax.collections[0].get_facecolors()\n        npt.assert_array_almost_equal(fc, cmap(vals), 2)\n\n    def test_tickabels_off(self):\n        kws = self.default_kws.copy()\n        kws['xticklabels'] = False\n        kws['yticklabels'] = False\n        p = mat._HeatMapper(self.df_norm, **kws)\n        nt.assert_equal(p.xticklabels, [])\n        nt.assert_equal(p.yticklabels, [])\n\n    def test_custom_ticklabels(self):\n        kws = self.default_kws.copy()\n        xticklabels = list('iheartheatmaps'[:self.df_norm.shape[1]])\n        yticklabels = list('heatmapsarecool'[:self.df_norm.shape[0]])\n        kws['xticklabels'] = xticklabels\n        kws['yticklabels'] = yticklabels\n        p = mat._HeatMapper(self.df_norm, **kws)\n        nt.assert_equal(p.xticklabels, xticklabels)\n        nt.assert_equal(p.yticklabels, yticklabels)\n\n    def test_custom_ticklabel_interval(self):\n\n        kws = self.default_kws.copy()\n        xstep, ystep = 2, 3\n        kws['xticklabels'] = xstep\n        kws['yticklabels'] = ystep\n        p = mat._HeatMapper(self.df_norm, **kws)\n\n        nx, ny = self.df_norm.T.shape\n        npt.assert_array_equal(p.xticks, np.arange(0, nx, xstep) + .5)\n        npt.assert_array_equal(p.yticks, np.arange(0, ny, ystep) + .5)\n        npt.assert_array_equal(p.xticklabels,\n                               self.df_norm.columns[0:nx:xstep])\n        npt.assert_array_equal(p.yticklabels,\n                               self.df_norm.index[0:ny:ystep])\n\n    def test_heatmap_annotation(self):\n\n        ax = mat.heatmap(self.df_norm, annot=True, fmt=\".1f\",\n                         annot_kws={\"fontsize\": 14})\n        for val, text in zip(self.x_norm.flat, ax.texts):\n            nt.assert_equal(text.get_text(), \"{:.1f}\".format(val))\n            nt.assert_equal(text.get_fontsize(), 14)\n\n    def test_heatmap_annotation_overwrite_kws(self):\n\n        annot_kws = dict(color=\"0.3\", va=\"bottom\", ha=\"left\")\n        ax = mat.heatmap(self.df_norm, annot=True, fmt=\".1f\",\n                         annot_kws=annot_kws)\n        for text in ax.texts:\n            nt.assert_equal(text.get_color(), \"0.3\")\n            nt.assert_equal(text.get_ha(), \"left\")\n            nt.assert_equal(text.get_va(), \"bottom\")\n\n    def test_heatmap_annotation_with_mask(self):\n\n        df = pd.DataFrame(data={'a': [1, 1, 1],\n                                'b': [2, np.nan, 2],\n                                'c': [3, 3, np.nan]})\n        mask = np.isnan(df.values)\n        df_masked = np.ma.masked_where(mask, df)\n        ax = mat.heatmap(df, annot=True, fmt='.1f', mask=mask)\n        nt.assert_equal(len(df_masked.compressed()), len(ax.texts))\n        for val, text in zip(df_masked.compressed(), ax.texts):\n            nt.assert_equal(\"{:.1f}\".format(val), text.get_text())\n\n    def test_heatmap_annotation_mesh_colors(self):\n\n        ax = mat.heatmap(self.df_norm, annot=True)\n        mesh = ax.collections[0]\n        nt.assert_equal(len(mesh.get_facecolors()), self.df_norm.values.size)\n\n        plt.close(\"all\")\n\n    def test_heatmap_annotation_other_data(self):\n        annot_data = self.df_norm + 10\n\n        ax = mat.heatmap(self.df_norm, annot=annot_data, fmt=\".1f\",\n                         annot_kws={\"fontsize\": 14})\n\n        for val, text in zip(annot_data.values.flat, ax.texts):\n            nt.assert_equal(text.get_text(), \"{:.1f}\".format(val))\n            nt.assert_equal(text.get_fontsize(), 14)\n\n    def test_heatmap_annotation_with_limited_ticklabels(self):\n        ax = mat.heatmap(self.df_norm, fmt=\".2f\", annot=True,\n                         xticklabels=False, yticklabels=False)\n        for val, text in zip(self.x_norm.flat, ax.texts):\n            nt.assert_equal(text.get_text(), \"{:.2f}\".format(val))\n\n    def test_heatmap_cbar(self):\n\n        f = plt.figure()\n        mat.heatmap(self.df_norm)\n        nt.assert_equal(len(f.axes), 2)\n        plt.close(f)\n\n        f = plt.figure()\n        mat.heatmap(self.df_norm, cbar=False)\n        nt.assert_equal(len(f.axes), 1)\n        plt.close(f)\n\n        f, (ax1, ax2) = plt.subplots(2)\n        mat.heatmap(self.df_norm, ax=ax1, cbar_ax=ax2)\n        nt.assert_equal(len(f.axes), 2)\n        plt.close(f)\n\n    def test_heatmap_axes(self):\n\n        ax = mat.heatmap(self.df_norm)\n\n        xtl = [int(l.get_text()) for l in ax.get_xticklabels()]\n        nt.assert_equal(xtl, list(self.df_norm.columns))\n        ytl = [l.get_text() for l in ax.get_yticklabels()]\n        nt.assert_equal(ytl, list(self.df_norm.index))\n\n        nt.assert_equal(ax.get_xlabel(), \"\")\n        nt.assert_equal(ax.get_ylabel(), \"letters\")\n\n        nt.assert_equal(ax.get_xlim(), (0, 8))\n        nt.assert_equal(ax.get_ylim(), (4, 0))\n\n    def test_heatmap_ticklabel_rotation(self):\n\n        f, ax = plt.subplots(figsize=(2, 2))\n        mat.heatmap(self.df_norm, xticklabels=1, yticklabels=1, ax=ax)\n\n        for t in ax.get_xticklabels():\n            nt.assert_equal(t.get_rotation(), 0)\n\n        for t in ax.get_yticklabels():\n            nt.assert_equal(t.get_rotation(), 90)\n\n        plt.close(f)\n\n        df = self.df_norm.copy()\n        df.columns = [str(c) * 10 for c in df.columns]\n        df.index = [i * 10 for i in df.index]\n\n        f, ax = plt.subplots(figsize=(2, 2))\n        mat.heatmap(df, xticklabels=1, yticklabels=1, ax=ax)\n\n        for t in ax.get_xticklabels():\n            nt.assert_equal(t.get_rotation(), 90)\n\n        for t in ax.get_yticklabels():\n            nt.assert_equal(t.get_rotation(), 0)\n\n        plt.close(f)\n\n    def test_heatmap_inner_lines(self):\n\n        c = (0, 0, 1, 1)\n        ax = mat.heatmap(self.df_norm, linewidths=2, linecolor=c)\n        mesh = ax.collections[0]\n        nt.assert_equal(mesh.get_linewidths()[0], 2)\n        nt.assert_equal(tuple(mesh.get_edgecolor()[0]), c)\n\n    def test_square_aspect(self):\n\n        ax = mat.heatmap(self.df_norm, square=True)\n        nt.assert_equal(ax.get_aspect(), \"equal\")\n\n    def test_mask_validation(self):\n\n        mask = mat._matrix_mask(self.df_norm, None)\n        nt.assert_equal(mask.shape, self.df_norm.shape)\n        nt.assert_equal(mask.values.sum(), 0)\n\n        with nt.assert_raises(ValueError):\n            bad_array_mask = self.rs.randn(3, 6) > 0\n            mat._matrix_mask(self.df_norm, bad_array_mask)\n\n        with nt.assert_raises(ValueError):\n            bad_df_mask = pd.DataFrame(self.rs.randn(4, 8) > 0)\n            mat._matrix_mask(self.df_norm, bad_df_mask)\n\n    def test_missing_data_mask(self):\n\n        data = pd.DataFrame(np.arange(4, dtype=np.float).reshape(2, 2))\n        data.loc[0, 0] = np.nan\n        mask = mat._matrix_mask(data, None)\n        npt.assert_array_equal(mask, [[True, False], [False, False]])\n\n        mask_in = np.array([[False, True], [False, False]])\n        mask_out = mat._matrix_mask(data, mask_in)\n        npt.assert_array_equal(mask_out, [[True, True], [False, False]])\n\n    def test_cbar_ticks(self):\n        max_n_ticks = 3\n\n        locator = mpl.ticker.MaxNLocator(max_n_ticks)\n        f, (ax1, ax2) = plt.subplots(2)\n        mat.heatmap(self.df_norm, ax=ax1, cbar_ax=ax2,\n                    cbar_kws=dict(ticks=locator))\n        nt.assert_equal(len(ax2.yaxis.get_ticklabels()), max_n_ticks)\n        plt.close(f)\n\n\nclass TestDendrogram(object):\n    rs = np.random.RandomState(sum(map(ord, \"dendrogram\")))\n\n    x_norm = rs.randn(4, 8) + np.arange(8)\n    x_norm = (x_norm.T + np.arange(4)).T\n    letters = pd.Series([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"],\n                        name=\"letters\")\n\n    df_norm = pd.DataFrame(x_norm, columns=letters)\n    try:\n        import fastcluster\n\n        x_norm_linkage = fastcluster.linkage_vector(x_norm.T,\n                                                    metric='euclidean',\n                                                    method='single')\n    except ImportError:\n        x_norm_distances = distance.pdist(x_norm.T, metric='euclidean')\n        x_norm_linkage = hierarchy.linkage(x_norm_distances, method='single')\n    x_norm_dendrogram = hierarchy.dendrogram(x_norm_linkage, no_plot=True,\n                                             color_threshold=-np.inf)\n    x_norm_leaves = x_norm_dendrogram['leaves']\n    df_norm_leaves = np.asarray(df_norm.columns[x_norm_leaves])\n\n    default_kws = dict(linkage=None, metric='euclidean', method='single',\n                       axis=1, label=True, rotate=False)\n\n    def test_ndarray_input(self):\n        p = mat._DendrogramPlotter(self.x_norm, **self.default_kws)\n        npt.assert_array_equal(p.array.T, self.x_norm)\n        pdt.assert_frame_equal(p.data.T, pd.DataFrame(self.x_norm))\n\n        npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n        nt.assert_dict_equal(p.dendrogram, self.x_norm_dendrogram)\n\n        npt.assert_array_equal(p.reordered_ind, self.x_norm_leaves)\n\n        npt.assert_array_equal(p.xticklabels, self.x_norm_leaves)\n        npt.assert_array_equal(p.yticklabels, [])\n\n        nt.assert_equal(p.xlabel, None)\n        nt.assert_equal(p.ylabel, '')\n\n    def test_df_input(self):\n        p = mat._DendrogramPlotter(self.df_norm, **self.default_kws)\n        npt.assert_array_equal(p.array.T, np.asarray(self.df_norm))\n        pdt.assert_frame_equal(p.data.T, self.df_norm)\n\n        npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n        nt.assert_dict_equal(p.dendrogram, self.x_norm_dendrogram)\n\n        npt.assert_array_equal(p.xticklabels,\n                               np.asarray(self.df_norm.columns)[\n                                   self.x_norm_leaves])\n        npt.assert_array_equal(p.yticklabels, [])\n\n        nt.assert_equal(p.xlabel, 'letters')\n        nt.assert_equal(p.ylabel, '')\n\n    def test_df_multindex_input(self):\n\n        df = self.df_norm.copy()\n        index = pd.MultiIndex.from_tuples([(\"A\", 1), (\"B\", 2),\n                                           (\"C\", 3), (\"D\", 4)],\n                                          names=[\"letter\", \"number\"])\n        index.name = \"letter-number\"\n        df.index = index\n        kws = self.default_kws.copy()\n        kws['label'] = True\n\n        p = mat._DendrogramPlotter(df.T, **kws)\n\n        xticklabels = [\"A-1\", \"B-2\", \"C-3\", \"D-4\"]\n        xticklabels = [xticklabels[i] for i in p.reordered_ind]\n        npt.assert_array_equal(p.xticklabels, xticklabels)\n        npt.assert_array_equal(p.yticklabels, [])\n        nt.assert_equal(p.xlabel, \"letter-number\")\n\n    def test_axis0_input(self):\n        kws = self.default_kws.copy()\n        kws['axis'] = 0\n        p = mat._DendrogramPlotter(self.df_norm.T, **kws)\n\n        npt.assert_array_equal(p.array, np.asarray(self.df_norm.T))\n        pdt.assert_frame_equal(p.data, self.df_norm.T)\n\n        npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n        nt.assert_dict_equal(p.dendrogram, self.x_norm_dendrogram)\n\n        npt.assert_array_equal(p.xticklabels, self.df_norm_leaves)\n        npt.assert_array_equal(p.yticklabels, [])\n\n        nt.assert_equal(p.xlabel, 'letters')\n        nt.assert_equal(p.ylabel, '')\n\n    def test_rotate_input(self):\n        kws = self.default_kws.copy()\n        kws['rotate'] = True\n        p = mat._DendrogramPlotter(self.df_norm, **kws)\n        npt.assert_array_equal(p.array.T, np.asarray(self.df_norm))\n        pdt.assert_frame_equal(p.data.T, self.df_norm)\n\n        npt.assert_array_equal(p.xticklabels, [])\n        npt.assert_array_equal(p.yticklabels, self.df_norm_leaves)\n\n        nt.assert_equal(p.xlabel, '')\n        nt.assert_equal(p.ylabel, 'letters')\n\n    def test_rotate_axis0_input(self):\n        kws = self.default_kws.copy()\n        kws['rotate'] = True\n        kws['axis'] = 0\n        p = mat._DendrogramPlotter(self.df_norm.T, **kws)\n\n        npt.assert_array_equal(p.reordered_ind, self.x_norm_leaves)\n\n    def test_custom_linkage(self):\n        kws = self.default_kws.copy()\n\n        try:\n            import fastcluster\n\n            linkage = fastcluster.linkage_vector(self.x_norm, method='single',\n                                                 metric='euclidean')\n        except ImportError:\n            d = distance.pdist(self.x_norm, metric='euclidean')\n            linkage = hierarchy.linkage(d, method='single')\n        dendrogram = hierarchy.dendrogram(linkage, no_plot=True,\n                                          color_threshold=-np.inf)\n        kws['linkage'] = linkage\n        p = mat._DendrogramPlotter(self.df_norm, **kws)\n\n        npt.assert_array_equal(p.linkage, linkage)\n        nt.assert_dict_equal(p.dendrogram, dendrogram)\n\n    def test_label_false(self):\n        kws = self.default_kws.copy()\n        kws['label'] = False\n        p = mat._DendrogramPlotter(self.df_norm, **kws)\n        nt.assert_equal(p.xticks, [])\n        nt.assert_equal(p.yticks, [])\n        nt.assert_equal(p.xticklabels, [])\n        nt.assert_equal(p.yticklabels, [])\n        nt.assert_equal(p.xlabel, \"\")\n        nt.assert_equal(p.ylabel, \"\")\n\n    def test_linkage_scipy(self):\n        p = mat._DendrogramPlotter(self.x_norm, **self.default_kws)\n\n        scipy_linkage = p._calculate_linkage_scipy()\n\n        from scipy.spatial import distance\n        from scipy.cluster import hierarchy\n\n        dists = distance.pdist(self.x_norm.T,\n                               metric=self.default_kws['metric'])\n        linkage = hierarchy.linkage(dists, method=self.default_kws['method'])\n\n        npt.assert_array_equal(scipy_linkage, linkage)\n\n    @skipif(_no_fastcluster)\n    def test_fastcluster_other_method(self):\n        import fastcluster\n\n        kws = self.default_kws.copy()\n        kws['method'] = 'average'\n        linkage = fastcluster.linkage(self.x_norm.T, method='average',\n                                      metric='euclidean')\n        p = mat._DendrogramPlotter(self.x_norm, **kws)\n        npt.assert_array_equal(p.linkage, linkage)\n\n    @skipif(_no_fastcluster)\n    def test_fastcluster_non_euclidean(self):\n        import fastcluster\n\n        kws = self.default_kws.copy()\n        kws['metric'] = 'cosine'\n        kws['method'] = 'average'\n        linkage = fastcluster.linkage(self.x_norm.T, method=kws['method'],\n                                      metric=kws['metric'])\n        p = mat._DendrogramPlotter(self.x_norm, **kws)\n        npt.assert_array_equal(p.linkage, linkage)\n\n    def test_dendrogram_plot(self):\n        d = mat.dendrogram(self.x_norm, **self.default_kws)\n\n        ax = plt.gca()\n        xlim = ax.get_xlim()\n        \n        xmax = len(d.reordered_ind) * 10\n\n        nt.assert_equal(xlim[0], 0)\n        nt.assert_equal(xlim[1], xmax)\n\n        nt.assert_equal(len(ax.collections[0].get_paths()),\n                        len(d.dependent_coord))\n\n    def test_dendrogram_rotate(self):\n        kws = self.default_kws.copy()\n        kws['rotate'] = True\n\n        d = mat.dendrogram(self.x_norm, **kws)\n\n        ax = plt.gca()\n        ylim = ax.get_ylim()\n\n        \n        ymax = len(d.reordered_ind) * 10\n\n        # Since y axis is inverted, ylim is (80, 0)\n        # and therefore not (0, 80) as usual:\n        nt.assert_equal(ylim[1], 0)\n        nt.assert_equal(ylim[0], ymax)\n\n    def test_dendrogram_ticklabel_rotation(self):\n        f, ax = plt.subplots(figsize=(2, 2))\n        mat.dendrogram(self.df_norm, ax=ax)\n\n        for t in ax.get_xticklabels():\n            nt.assert_equal(t.get_rotation(), 0)\n\n        plt.close(f)\n\n        df = self.df_norm.copy()\n        df.columns = [str(c) * 10 for c in df.columns]\n        df.index = [i * 10 for i in df.index]\n\n        f, ax = plt.subplots(figsize=(2, 2))\n        mat.dendrogram(df, ax=ax)\n\n        for t in ax.get_xticklabels():\n            nt.assert_equal(t.get_rotation(), 90)\n\n        plt.close(f)\n\n        f, ax = plt.subplots(figsize=(2, 2))\n        mat.dendrogram(df.T, axis=0, rotate=True)\n        for t in ax.get_yticklabels():\n            nt.assert_equal(t.get_rotation(), 0)\n        plt.close(f)\n\n\nclass TestClustermap(object):\n    rs = np.random.RandomState(sum(map(ord, \"clustermap\")))\n\n    x_norm = rs.randn(4, 8) + np.arange(8)\n    x_norm = (x_norm.T + np.arange(4)).T\n    letters = pd.Series([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"],\n                        name=\"letters\")\n\n    df_norm = pd.DataFrame(x_norm, columns=letters)\n    try:\n        import fastcluster\n\n        x_norm_linkage = fastcluster.linkage_vector(x_norm.T,\n                                                    metric='euclidean',\n                                                    method='single')\n    except ImportError:\n        x_norm_distances = distance.pdist(x_norm.T, metric='euclidean')\n        x_norm_linkage = hierarchy.linkage(x_norm_distances, method='single')\n    x_norm_dendrogram = hierarchy.dendrogram(x_norm_linkage, no_plot=True,\n                                             color_threshold=-np.inf)\n    x_norm_leaves = x_norm_dendrogram['leaves']\n    df_norm_leaves = np.asarray(df_norm.columns[x_norm_leaves])\n\n    default_kws = dict(pivot_kws=None, z_score=None, standard_scale=None,\n                       figsize=None, row_colors=None, col_colors=None)\n\n    default_plot_kws = dict(metric='euclidean', method='average',\n                            colorbar_kws=None,\n                            row_cluster=True, col_cluster=True,\n                            row_linkage=None, col_linkage=None)\n\n    row_colors = color_palette('Set2', df_norm.shape[0])\n    col_colors = color_palette('Dark2', df_norm.shape[1])\n\n    def test_ndarray_input(self):\n        cm = mat.ClusterGrid(self.x_norm, **self.default_kws)\n        pdt.assert_frame_equal(cm.data, pd.DataFrame(self.x_norm))\n        nt.assert_equal(len(cm.fig.axes), 4)\n        nt.assert_equal(cm.ax_row_colors, None)\n        nt.assert_equal(cm.ax_col_colors, None)\n\n    def test_df_input(self):\n        cm = mat.ClusterGrid(self.df_norm, **self.default_kws)\n        pdt.assert_frame_equal(cm.data, self.df_norm)\n\n    def test_corr_df_input(self):\n        df = self.df_norm.corr()\n        cg = mat.ClusterGrid(df, **self.default_kws)\n        cg.plot(**self.default_plot_kws)\n        diag = cg.data2d.values[np.diag_indices_from(cg.data2d)]\n        npt.assert_array_equal(diag, np.ones(cg.data2d.shape[0]))\n\n    def test_pivot_input(self):\n        df_norm = self.df_norm.copy()\n        df_norm.index.name = 'numbers'\n        df_long = pd.melt(df_norm.reset_index(), var_name='letters',\n                          id_vars='numbers')\n        kws = self.default_kws.copy()\n        kws['pivot_kws'] = dict(index='numbers', columns='letters',\n                                values='value')\n        cm = mat.ClusterGrid(df_long, **kws)\n\n        pdt.assert_frame_equal(cm.data2d, df_norm)\n\n    def test_colors_input(self):\n        kws = self.default_kws.copy()\n\n        kws['row_colors'] = self.row_colors\n        kws['col_colors'] = self.col_colors\n\n        cm = mat.ClusterGrid(self.df_norm, **kws)\n        npt.assert_array_equal(cm.row_colors, self.row_colors)\n        npt.assert_array_equal(cm.col_colors, self.col_colors)\n\n        nt.assert_equal(len(cm.fig.axes), 6)\n\n    def test_nested_colors_input(self):\n        kws = self.default_kws.copy()\n\n        row_colors = [self.row_colors, self.row_colors]\n        col_colors = [self.col_colors, self.col_colors]\n        kws['row_colors'] = row_colors\n        kws['col_colors'] = col_colors\n\n        cm = mat.ClusterGrid(self.df_norm, **kws)\n        npt.assert_array_equal(cm.row_colors, row_colors)\n        npt.assert_array_equal(cm.col_colors, col_colors)\n\n        nt.assert_equal(len(cm.fig.axes), 6)\n\n    def test_colors_input_custom_cmap(self):\n        kws = self.default_kws.copy()\n\n        kws['cmap'] = mpl.cm.PRGn\n        kws['row_colors'] = self.row_colors\n        kws['col_colors'] = self.col_colors\n\n        cm = mat.clustermap(self.df_norm, **kws)\n        npt.assert_array_equal(cm.row_colors, self.row_colors)\n        npt.assert_array_equal(cm.col_colors, self.col_colors)\n\n        nt.assert_equal(len(cm.fig.axes), 6)\n\n    def test_z_score(self):\n        df = self.df_norm.copy()\n        df = (df - df.mean()) / df.std()\n        kws = self.default_kws.copy()\n        kws['z_score'] = 1\n\n        cm = mat.ClusterGrid(self.df_norm, **kws)\n        pdt.assert_frame_equal(cm.data2d, df)\n\n    def test_z_score_axis0(self):\n        df = self.df_norm.copy()\n        df = df.T\n        df = (df - df.mean()) / df.std()\n        df = df.T\n        kws = self.default_kws.copy()\n        kws['z_score'] = 0\n\n        cm = mat.ClusterGrid(self.df_norm, **kws)\n        pdt.assert_frame_equal(cm.data2d, df)\n\n    def test_standard_scale(self):\n        df = self.df_norm.copy()\n        df = (df - df.min()) / (df.max() - df.min())\n        kws = self.default_kws.copy()\n        kws['standard_scale'] = 1\n\n        cm = mat.ClusterGrid(self.df_norm, **kws)\n        pdt.assert_frame_equal(cm.data2d, df)\n\n    def test_standard_scale_axis0(self):\n        df = self.df_norm.copy()\n        df = df.T\n        df = (df - df.min()) / (df.max() - df.min())\n        df = df.T\n        kws = self.default_kws.copy()\n        kws['standard_scale'] = 0\n\n        cm = mat.ClusterGrid(self.df_norm, **kws)\n        pdt.assert_frame_equal(cm.data2d, df)\n\n    def test_z_score_standard_scale(self):\n        kws = self.default_kws.copy()\n        kws['z_score'] = True\n        kws['standard_scale'] = True\n        with nt.assert_raises(ValueError):\n            cm = mat.ClusterGrid(self.df_norm, **kws)\n\n    def test_color_list_to_matrix_and_cmap(self):\n        matrix, cmap = mat.ClusterGrid.color_list_to_matrix_and_cmap(\n            self.col_colors, self.x_norm_leaves)\n\n        colors_set = set(self.col_colors)\n        col_to_value = dict((col, i) for i, col in enumerate(colors_set))\n        matrix_test = np.array([col_to_value[col] for col in\n                                self.col_colors])[self.x_norm_leaves]\n        shape = len(self.col_colors), 1\n        matrix_test = matrix_test.reshape(shape)\n        cmap_test = mpl.colors.ListedColormap(colors_set)\n        npt.assert_array_equal(matrix, matrix_test)\n        npt.assert_array_equal(cmap.colors, cmap_test.colors)\n\n    def test_nested_color_list_to_matrix_and_cmap(self):\n        colors = [self.col_colors, self.col_colors]\n        matrix, cmap = mat.ClusterGrid.color_list_to_matrix_and_cmap(\n            colors, self.x_norm_leaves)\n\n        all_colors = set(itertools.chain(*colors))\n        color_to_value = dict((col, i) for i, col in enumerate(all_colors))\n        matrix_test = np.array(\n            [color_to_value[c] for color in colors for c in color])\n        shape = len(colors), len(colors[0])\n        matrix_test = matrix_test.reshape(shape)\n        matrix_test = matrix_test[:, self.x_norm_leaves]\n        matrix_test = matrix_test.T\n\n        cmap_test = mpl.colors.ListedColormap(all_colors)\n        npt.assert_array_equal(matrix, matrix_test)\n        npt.assert_array_equal(cmap.colors, cmap_test.colors)\n\n    def test_color_list_to_matrix_and_cmap_axis1(self):\n        matrix, cmap = mat.ClusterGrid.color_list_to_matrix_and_cmap(\n            self.col_colors, self.x_norm_leaves, axis=1)\n\n        colors_set = set(self.col_colors)\n        col_to_value = dict((col, i) for i, col in enumerate(colors_set))\n        matrix_test = np.array([col_to_value[col] for col in\n                                self.col_colors])[self.x_norm_leaves]\n        shape = 1, len(self.col_colors)\n        matrix_test = matrix_test.reshape(shape)\n        cmap_test = mpl.colors.ListedColormap(colors_set)\n        npt.assert_array_equal(matrix, matrix_test)\n        npt.assert_array_equal(cmap.colors, cmap_test.colors)\n\n    def test_savefig(self):\n        \n        cm = mat.ClusterGrid(self.df_norm, **self.default_kws)\n        cm.plot(**self.default_plot_kws)\n        cm.savefig(tempfile.NamedTemporaryFile(), format='png')\n\n    def test_plot_dendrograms(self):\n        cm = mat.clustermap(self.df_norm, **self.default_kws)\n\n        nt.assert_equal(len(cm.ax_row_dendrogram.collections[0].get_paths()),\n                        len(cm.dendrogram_row.independent_coord))\n        nt.assert_equal(len(cm.ax_col_dendrogram.collections[0].get_paths()),\n                        len(cm.dendrogram_col.independent_coord))\n        data2d = self.df_norm.iloc[cm.dendrogram_row.reordered_ind,\n                                   cm.dendrogram_col.reordered_ind]\n        pdt.assert_frame_equal(cm.data2d, data2d)\n\n    def test_cluster_false(self):\n        kws = self.default_kws.copy()\n        kws['row_cluster'] = False\n        kws['col_cluster'] = False\n\n        cm = mat.clustermap(self.df_norm, **kws)\n        nt.assert_equal(len(cm.ax_row_dendrogram.lines), 0)\n        nt.assert_equal(len(cm.ax_col_dendrogram.lines), 0)\n\n        nt.assert_equal(len(cm.ax_row_dendrogram.get_xticks()), 0)\n        nt.assert_equal(len(cm.ax_row_dendrogram.get_yticks()), 0)\n        nt.assert_equal(len(cm.ax_col_dendrogram.get_xticks()), 0)\n        nt.assert_equal(len(cm.ax_col_dendrogram.get_yticks()), 0)\n\n        pdt.assert_frame_equal(cm.data2d, self.df_norm)\n\n    def test_row_col_colors(self):\n        kws = self.default_kws.copy()\n        kws['row_colors'] = self.row_colors\n        kws['col_colors'] = self.col_colors\n\n        cm = mat.clustermap(self.df_norm, **kws)\n\n        nt.assert_equal(len(cm.ax_row_colors.collections), 1)\n        nt.assert_equal(len(cm.ax_col_colors.collections), 1)\n\n    def test_cluster_false_row_col_colors(self):\n        kws = self.default_kws.copy()\n        kws['row_cluster'] = False\n        kws['col_cluster'] = False\n        kws['row_colors'] = self.row_colors\n        kws['col_colors'] = self.col_colors\n\n        cm = mat.clustermap(self.df_norm, **kws)\n        nt.assert_equal(len(cm.ax_row_dendrogram.lines), 0)\n        nt.assert_equal(len(cm.ax_col_dendrogram.lines), 0)\n\n        nt.assert_equal(len(cm.ax_row_dendrogram.get_xticks()), 0)\n        nt.assert_equal(len(cm.ax_row_dendrogram.get_yticks()), 0)\n        nt.assert_equal(len(cm.ax_col_dendrogram.get_xticks()), 0)\n        nt.assert_equal(len(cm.ax_col_dendrogram.get_yticks()), 0)\n        nt.assert_equal(len(cm.ax_row_colors.collections), 1)\n        nt.assert_equal(len(cm.ax_col_colors.collections), 1)\n\n        pdt.assert_frame_equal(cm.data2d, self.df_norm)\n\n    def test_row_col_colors_df(self):\n        kws = self.default_kws.copy()\n        kws['row_colors'] = pd.DataFrame({'row_1': list(self.row_colors),\n                                          'row_2': list(self.row_colors)},\n                                         index=self.df_norm.index,\n                                         columns=['row_1', 'row_2'])\n        kws['col_colors'] = pd.DataFrame({'col_1': list(self.col_colors),\n                                          'col_2': list(self.col_colors)},\n                                         index=self.df_norm.columns,\n                                         columns=['col_1', 'col_2'])\n\n        cm = mat.clustermap(self.df_norm, **kws)\n\n        row_labels = [l.get_text() for l in\n                      cm.ax_row_colors.get_xticklabels()]\n        nt.assert_equal(cm.row_color_labels, ['row_1', 'row_2'])\n        nt.assert_equal(row_labels, cm.row_color_labels)\n\n        col_labels = [l.get_text() for l in\n                      cm.ax_col_colors.get_yticklabels()]\n        nt.assert_equal(cm.col_color_labels, ['col_1', 'col_2'])\n        nt.assert_equal(col_labels, cm.col_color_labels)\n\n    def test_row_col_colors_df_shuffled(self):\n        \n\n        m, n = self.df_norm.shape\n        shuffled_inds = [self.df_norm.index[i] for i in\n                         list(range(0, m, 2)) + list(range(1, m, 2))]\n        shuffled_cols = [self.df_norm.columns[i] for i in\n                         list(range(0, n, 2)) + list(range(1, n, 2))]\n\n        kws = self.default_kws.copy()\n\n        row_colors = pd.DataFrame({'row_annot': list(self.row_colors)},\n                                  index=self.df_norm.index)\n        kws['row_colors'] = row_colors.ix[shuffled_inds]\n\n        col_colors = pd.DataFrame({'col_annot': list(self.col_colors)},\n                                  index=self.df_norm.columns)\n        kws['col_colors'] = col_colors.ix[shuffled_cols]\n\n        cm = mat.clustermap(self.df_norm, **kws)\n        nt.assert_equal(list(cm.col_colors)[0], list(self.col_colors))\n        nt.assert_equal(list(cm.row_colors)[0], list(self.row_colors))\n\n    def test_row_col_colors_df_missing(self):\n        kws = self.default_kws.copy()\n        row_colors = pd.DataFrame({'row_annot': list(self.row_colors)},\n                                  index=self.df_norm.index)\n        kws['row_colors'] = row_colors.drop(self.df_norm.index[0])\n\n        col_colors = pd.DataFrame({'col_annot': list(self.col_colors)},\n                                  index=self.df_norm.columns)\n        kws['col_colors'] = col_colors.drop(self.df_norm.columns[0])\n\n        cm = mat.clustermap(self.df_norm, **kws)\n\n        nt.assert_equal(list(cm.col_colors)[0],\n                        [(1.0, 1.0, 1.0)] + list(self.col_colors[1:]))\n        nt.assert_equal(list(cm.row_colors)[0],\n                        [(1.0, 1.0, 1.0)] + list(self.row_colors[1:]))\n\n    def test_row_col_colors_df_one_axis(self):\n        \n        kws1 = self.default_kws.copy()\n        kws1['row_colors'] = pd.DataFrame({'row_1': list(self.row_colors),\n                                           'row_2': list(self.row_colors)},\n                                          index=self.df_norm.index,\n                                          columns=['row_1', 'row_2'])\n\n        cm1 = mat.clustermap(self.df_norm, **kws1)\n\n        row_labels = [l.get_text() for l in\n                      cm1.ax_row_colors.get_xticklabels()]\n        nt.assert_equal(cm1.row_color_labels, ['row_1', 'row_2'])\n        nt.assert_equal(row_labels, cm1.row_color_labels)\n\n        \n        kws2 = self.default_kws.copy()\n        kws2['col_colors'] = pd.DataFrame({'col_1': list(self.col_colors),\n                                           'col_2': list(self.col_colors)},\n                                          index=self.df_norm.columns,\n                                          columns=['col_1', 'col_2'])\n\n        cm2 = mat.clustermap(self.df_norm, **kws2)\n\n        col_labels = [l.get_text() for l in\n                      cm2.ax_col_colors.get_yticklabels()]\n        nt.assert_equal(cm2.col_color_labels, ['col_1', 'col_2'])\n        nt.assert_equal(col_labels, cm2.col_color_labels)\n\n    def test_row_col_colors_series(self):\n        kws = self.default_kws.copy()\n        kws['row_colors'] = pd.Series(list(self.row_colors), name='row_annot',\n                                      index=self.df_norm.index)\n        kws['col_colors'] = pd.Series(list(self.col_colors), name='col_annot',\n                                      index=self.df_norm.columns)\n\n        cm = mat.clustermap(self.df_norm, **kws)\n\n        row_labels = [l.get_text() for l in\n                      cm.ax_row_colors.get_xticklabels()]\n        nt.assert_equal(cm.row_color_labels, ['row_annot'])\n        nt.assert_equal(row_labels, cm.row_color_labels)\n\n        col_labels = [l.get_text() for l in\n                      cm.ax_col_colors.get_yticklabels()]\n        nt.assert_equal(cm.col_color_labels, ['col_annot'])\n        nt.assert_equal(col_labels, cm.col_color_labels)\n\n    def test_row_col_colors_series_shuffled(self):\n        \n\n        m, n = self.df_norm.shape\n        shuffled_inds = [self.df_norm.index[i] for i in\n                         list(range(0, m, 2)) + list(range(1, m, 2))]\n        shuffled_cols = [self.df_norm.columns[i] for i in\n                         list(range(0, n, 2)) + list(range(1, n, 2))]\n\n        kws = self.default_kws.copy()\n\n        row_colors = pd.Series(list(self.row_colors), name='row_annot',\n                               index=self.df_norm.index)\n        kws['row_colors'] = row_colors.ix[shuffled_inds]\n\n        col_colors = pd.Series(list(self.col_colors), name='col_annot',\n                               index=self.df_norm.columns)\n        kws['col_colors'] = col_colors.ix[shuffled_cols]\n\n        cm = mat.clustermap(self.df_norm, **kws)\n\n        nt.assert_equal(list(cm.col_colors), list(self.col_colors))\n        nt.assert_equal(list(cm.row_colors), list(self.row_colors))\n\n    def test_row_col_colors_series_missing(self):\n        kws = self.default_kws.copy()\n        row_colors = pd.Series(list(self.row_colors), name='row_annot',\n                               index=self.df_norm.index)\n        kws['row_colors'] = row_colors.drop(self.df_norm.index[0])\n\n        col_colors = pd.Series(list(self.col_colors), name='col_annot',\n                               index=self.df_norm.columns)\n        kws['col_colors'] = col_colors.drop(self.df_norm.columns[0])\n\n        cm = mat.clustermap(self.df_norm, **kws)\n        nt.assert_equal(list(cm.col_colors),\n                        [(1.0, 1.0, 1.0)] + list(self.col_colors[1:]))\n        nt.assert_equal(list(cm.row_colors),\n                        [(1.0, 1.0, 1.0)] + list(self.row_colors[1:]))\n\n    def test_mask_reorganization(self):\n\n        kws = self.default_kws.copy()\n        kws[\"mask\"] = self.df_norm > 0\n\n        g = mat.clustermap(self.df_norm, **kws)\n        npt.assert_array_equal(g.data2d.index, g.mask.index)\n        npt.assert_array_equal(g.data2d.columns, g.mask.columns)\n\n        npt.assert_array_equal(g.mask.index,\n                               self.df_norm.index[\n                                   g.dendrogram_row.reordered_ind])\n        npt.assert_array_equal(g.mask.columns,\n                               self.df_norm.columns[\n                                   g.dendrogram_col.reordered_ind])\n\n    def test_ticklabel_reorganization(self):\n\n        kws = self.default_kws.copy()\n        xtl = np.arange(self.df_norm.shape[1])\n        kws[\"xticklabels\"] = list(xtl)\n        ytl = self.letters.ix[:self.df_norm.shape[0]]\n        kws[\"yticklabels\"] = ytl\n\n        g = mat.clustermap(self.df_norm, **kws)\n\n        xtl_actual = [t.get_text() for t in g.ax_heatmap.get_xticklabels()]\n        ytl_actual = [t.get_text() for t in g.ax_heatmap.get_yticklabels()]\n\n        xtl_want = xtl[g.dendrogram_col.reordered_ind].astype(\"<U1\")\n        ytl_want = ytl[g.dendrogram_row.reordered_ind].astype(\"<U1\")\n\n        npt.assert_array_equal(xtl_actual, xtl_want)\n        npt.assert_array_equal(ytl_actual, ytl_want)\n\n    def test_noticklabels(self):\n\n        kws = self.default_kws.copy()\n        kws[\"xticklabels\"] = False\n        kws[\"yticklabels\"] = False\n\n        g = mat.clustermap(self.df_norm, **kws)\n\n        xtl_actual = [t.get_text() for t in g.ax_heatmap.get_xticklabels()]\n        ytl_actual = [t.get_text() for t in g.ax_heatmap.get_yticklabels()]\n        nt.assert_equal(xtl_actual, [])\n        nt.assert_equal(ytl_actual, [])\n", "comments": "  10 comes  plot dendrogram scipy cluster hierarchy    10 comes  plot dendrogram scipy cluster hierarchy    since axis inverted  ylim (80  0)    therefore (0  80) usual     not sure right way test        tests colors properly matched  even given wrong order    test case row annotation     test case onl col annotation     tests colors properly matched  even given wrong order ", "content": "import itertools\nimport tempfile\n\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom scipy.spatial import distance\nfrom scipy.cluster import hierarchy\n\nimport nose.tools as nt\nimport numpy.testing as npt\ntry:\n    import pandas.testing as pdt\nexcept ImportError:\n    import pandas.util.testing as pdt\nfrom numpy.testing.decorators import skipif\n\nfrom .. import matrix as mat\nfrom .. import color_palette\nfrom ..external.six.moves import range\n\ntry:\n    import fastcluster\n\n    assert fastcluster\n    _no_fastcluster = False\nexcept ImportError:\n    _no_fastcluster = True\n\n\nclass TestHeatmap(object):\n    rs = np.random.RandomState(sum(map(ord, \"heatmap\")))\n\n    x_norm = rs.randn(4, 8)\n    letters = pd.Series([\"A\", \"B\", \"C\", \"D\"], name=\"letters\")\n    df_norm = pd.DataFrame(x_norm, index=letters)\n\n    x_unif = rs.rand(20, 13)\n    df_unif = pd.DataFrame(x_unif)\n\n    default_kws = dict(vmin=None, vmax=None, cmap=None, center=None,\n                       robust=False, annot=False, fmt=\".2f\", annot_kws=None,\n                       cbar=True, cbar_kws=None, mask=None)\n\n    def test_ndarray_input(self):\n\n        p = mat._HeatMapper(self.x_norm, **self.default_kws)\n        npt.assert_array_equal(p.plot_data, self.x_norm)\n        pdt.assert_frame_equal(p.data, pd.DataFrame(self.x_norm))\n\n        npt.assert_array_equal(p.xticklabels, np.arange(8))\n        npt.assert_array_equal(p.yticklabels, np.arange(4))\n\n        nt.assert_equal(p.xlabel, \"\")\n        nt.assert_equal(p.ylabel, \"\")\n\n    def test_df_input(self):\n\n        p = mat._HeatMapper(self.df_norm, **self.default_kws)\n        npt.assert_array_equal(p.plot_data, self.x_norm)\n        pdt.assert_frame_equal(p.data, self.df_norm)\n\n        npt.assert_array_equal(p.xticklabels, np.arange(8))\n        npt.assert_array_equal(p.yticklabels, self.letters.values)\n\n        nt.assert_equal(p.xlabel, \"\")\n        nt.assert_equal(p.ylabel, \"letters\")\n\n    def test_df_multindex_input(self):\n\n        df = self.df_norm.copy()\n        index = pd.MultiIndex.from_tuples([(\"A\", 1), (\"B\", 2),\n                                           (\"C\", 3), (\"D\", 4)],\n                                          names=[\"letter\", \"number\"])\n        index.name = \"letter-number\"\n        df.index = index\n\n        p = mat._HeatMapper(df, **self.default_kws)\n\n        combined_tick_labels = [\"A-1\", \"B-2\", \"C-3\", \"D-4\"]\n        npt.assert_array_equal(p.yticklabels, combined_tick_labels)\n        nt.assert_equal(p.ylabel, \"letter-number\")\n\n        p = mat._HeatMapper(df.T, **self.default_kws)\n\n        npt.assert_array_equal(p.xticklabels, combined_tick_labels)\n        nt.assert_equal(p.xlabel, \"letter-number\")\n\n    def test_mask_input(self):\n        kws = self.default_kws.copy()\n\n        mask = self.x_norm > 0\n        kws['mask'] = mask\n        p = mat._HeatMapper(self.x_norm, **kws)\n        plot_data = np.ma.masked_where(mask, self.x_norm)\n\n        npt.assert_array_equal(p.plot_data, plot_data)\n\n    def test_default_vlims(self):\n\n        p = mat._HeatMapper(self.df_unif, **self.default_kws)\n        nt.assert_equal(p.vmin, self.x_unif.min())\n        nt.assert_equal(p.vmax, self.x_unif.max())\n\n    def test_robust_vlims(self):\n\n        kws = self.default_kws.copy()\n        kws[\"robust\"] = True\n        p = mat._HeatMapper(self.df_unif, **kws)\n\n        nt.assert_equal(p.vmin, np.percentile(self.x_unif, 2))\n        nt.assert_equal(p.vmax, np.percentile(self.x_unif, 98))\n\n    def test_custom_sequential_vlims(self):\n\n        kws = self.default_kws.copy()\n        kws[\"vmin\"] = 0\n        kws[\"vmax\"] = 1\n        p = mat._HeatMapper(self.df_unif, **kws)\n\n        nt.assert_equal(p.vmin, 0)\n        nt.assert_equal(p.vmax, 1)\n\n    def test_custom_diverging_vlims(self):\n\n        kws = self.default_kws.copy()\n        kws[\"vmin\"] = -4\n        kws[\"vmax\"] = 5\n        kws[\"center\"] = 0\n        p = mat._HeatMapper(self.df_norm, **kws)\n\n        nt.assert_equal(p.vmin, -4)\n        nt.assert_equal(p.vmax, 5)\n\n    def test_array_with_nans(self):\n\n        x1 = self.rs.rand(10, 10)\n        nulls = np.zeros(10) * np.nan\n        x2 = np.c_[x1, nulls]\n\n        m1 = mat._HeatMapper(x1, **self.default_kws)\n        m2 = mat._HeatMapper(x2, **self.default_kws)\n\n        nt.assert_equal(m1.vmin, m2.vmin)\n        nt.assert_equal(m1.vmax, m2.vmax)\n\n    def test_mask(self):\n\n        df = pd.DataFrame(data={'a': [1, 1, 1],\n                                'b': [2, np.nan, 2],\n                                'c': [3, 3, np.nan]})\n\n        kws = self.default_kws.copy()\n        kws[\"mask\"] = np.isnan(df.values)\n\n        m = mat._HeatMapper(df, **kws)\n\n        npt.assert_array_equal(np.isnan(m.plot_data.data),\n                               m.plot_data.mask)\n\n    def test_custom_cmap(self):\n\n        kws = self.default_kws.copy()\n        kws[\"cmap\"] = \"BuGn\"\n        p = mat._HeatMapper(self.df_unif, **kws)\n        nt.assert_equal(p.cmap, mpl.cm.BuGn)\n\n    def test_centered_vlims(self):\n\n        kws = self.default_kws.copy()\n        kws[\"center\"] = .5\n\n        p = mat._HeatMapper(self.df_unif, **kws)\n\n        nt.assert_equal(p.vmin, self.df_unif.values.min())\n        nt.assert_equal(p.vmax, self.df_unif.values.max())\n\n    def test_default_colors(self):\n\n        vals = np.linspace(.2, 1, 9)\n        cmap = mpl.cm.binary\n        ax = mat.heatmap([vals], cmap=cmap)\n        fc = ax.collections[0].get_facecolors()\n        cvals = np.linspace(0, 1, 9)\n        npt.assert_array_almost_equal(fc, cmap(cvals), 2)\n\n    def test_custom_vlim_colors(self):\n\n        vals = np.linspace(.2, 1, 9)\n        cmap = mpl.cm.binary\n        ax = mat.heatmap([vals], vmin=0, cmap=cmap)\n        fc = ax.collections[0].get_facecolors()\n        npt.assert_array_almost_equal(fc, cmap(vals), 2)\n\n    def test_custom_center_colors(self):\n\n        vals = np.linspace(.2, 1, 9)\n        cmap = mpl.cm.binary\n        ax = mat.heatmap([vals], center=.5, cmap=cmap)\n        fc = ax.collections[0].get_facecolors()\n        npt.assert_array_almost_equal(fc, cmap(vals), 2)\n\n    def test_tickabels_off(self):\n        kws = self.default_kws.copy()\n        kws['xticklabels'] = False\n        kws['yticklabels'] = False\n        p = mat._HeatMapper(self.df_norm, **kws)\n        nt.assert_equal(p.xticklabels, [])\n        nt.assert_equal(p.yticklabels, [])\n\n    def test_custom_ticklabels(self):\n        kws = self.default_kws.copy()\n        xticklabels = list('iheartheatmaps'[:self.df_norm.shape[1]])\n        yticklabels = list('heatmapsarecool'[:self.df_norm.shape[0]])\n        kws['xticklabels'] = xticklabels\n        kws['yticklabels'] = yticklabels\n        p = mat._HeatMapper(self.df_norm, **kws)\n        nt.assert_equal(p.xticklabels, xticklabels)\n        nt.assert_equal(p.yticklabels, yticklabels)\n\n    def test_custom_ticklabel_interval(self):\n\n        kws = self.default_kws.copy()\n        xstep, ystep = 2, 3\n        kws['xticklabels'] = xstep\n        kws['yticklabels'] = ystep\n        p = mat._HeatMapper(self.df_norm, **kws)\n\n        nx, ny = self.df_norm.T.shape\n        npt.assert_array_equal(p.xticks, np.arange(0, nx, xstep) + .5)\n        npt.assert_array_equal(p.yticks, np.arange(0, ny, ystep) + .5)\n        npt.assert_array_equal(p.xticklabels,\n                               self.df_norm.columns[0:nx:xstep])\n        npt.assert_array_equal(p.yticklabels,\n                               self.df_norm.index[0:ny:ystep])\n\n    def test_heatmap_annotation(self):\n\n        ax = mat.heatmap(self.df_norm, annot=True, fmt=\".1f\",\n                         annot_kws={\"fontsize\": 14})\n        for val, text in zip(self.x_norm.flat, ax.texts):\n            nt.assert_equal(text.get_text(), \"{:.1f}\".format(val))\n            nt.assert_equal(text.get_fontsize(), 14)\n\n    def test_heatmap_annotation_overwrite_kws(self):\n\n        annot_kws = dict(color=\"0.3\", va=\"bottom\", ha=\"left\")\n        ax = mat.heatmap(self.df_norm, annot=True, fmt=\".1f\",\n                         annot_kws=annot_kws)\n        for text in ax.texts:\n            nt.assert_equal(text.get_color(), \"0.3\")\n            nt.assert_equal(text.get_ha(), \"left\")\n            nt.assert_equal(text.get_va(), \"bottom\")\n\n    def test_heatmap_annotation_with_mask(self):\n\n        df = pd.DataFrame(data={'a': [1, 1, 1],\n                                'b': [2, np.nan, 2],\n                                'c': [3, 3, np.nan]})\n        mask = np.isnan(df.values)\n        df_masked = np.ma.masked_where(mask, df)\n        ax = mat.heatmap(df, annot=True, fmt='.1f', mask=mask)\n        nt.assert_equal(len(df_masked.compressed()), len(ax.texts))\n        for val, text in zip(df_masked.compressed(), ax.texts):\n            nt.assert_equal(\"{:.1f}\".format(val), text.get_text())\n\n    def test_heatmap_annotation_mesh_colors(self):\n\n        ax = mat.heatmap(self.df_norm, annot=True)\n        mesh = ax.collections[0]\n        nt.assert_equal(len(mesh.get_facecolors()), self.df_norm.values.size)\n\n        plt.close(\"all\")\n\n    def test_heatmap_annotation_other_data(self):\n        annot_data = self.df_norm + 10\n\n        ax = mat.heatmap(self.df_norm, annot=annot_data, fmt=\".1f\",\n                         annot_kws={\"fontsize\": 14})\n\n        for val, text in zip(annot_data.values.flat, ax.texts):\n            nt.assert_equal(text.get_text(), \"{:.1f}\".format(val))\n            nt.assert_equal(text.get_fontsize(), 14)\n\n    def test_heatmap_annotation_with_limited_ticklabels(self):\n        ax = mat.heatmap(self.df_norm, fmt=\".2f\", annot=True,\n                         xticklabels=False, yticklabels=False)\n        for val, text in zip(self.x_norm.flat, ax.texts):\n            nt.assert_equal(text.get_text(), \"{:.2f}\".format(val))\n\n    def test_heatmap_cbar(self):\n\n        f = plt.figure()\n        mat.heatmap(self.df_norm)\n        nt.assert_equal(len(f.axes), 2)\n        plt.close(f)\n\n        f = plt.figure()\n        mat.heatmap(self.df_norm, cbar=False)\n        nt.assert_equal(len(f.axes), 1)\n        plt.close(f)\n\n        f, (ax1, ax2) = plt.subplots(2)\n        mat.heatmap(self.df_norm, ax=ax1, cbar_ax=ax2)\n        nt.assert_equal(len(f.axes), 2)\n        plt.close(f)\n\n    def test_heatmap_axes(self):\n\n        ax = mat.heatmap(self.df_norm)\n\n        xtl = [int(l.get_text()) for l in ax.get_xticklabels()]\n        nt.assert_equal(xtl, list(self.df_norm.columns))\n        ytl = [l.get_text() for l in ax.get_yticklabels()]\n        nt.assert_equal(ytl, list(self.df_norm.index))\n\n        nt.assert_equal(ax.get_xlabel(), \"\")\n        nt.assert_equal(ax.get_ylabel(), \"letters\")\n\n        nt.assert_equal(ax.get_xlim(), (0, 8))\n        nt.assert_equal(ax.get_ylim(), (4, 0))\n\n    def test_heatmap_ticklabel_rotation(self):\n\n        f, ax = plt.subplots(figsize=(2, 2))\n        mat.heatmap(self.df_norm, xticklabels=1, yticklabels=1, ax=ax)\n\n        for t in ax.get_xticklabels():\n            nt.assert_equal(t.get_rotation(), 0)\n\n        for t in ax.get_yticklabels():\n            nt.assert_equal(t.get_rotation(), 90)\n\n        plt.close(f)\n\n        df = self.df_norm.copy()\n        df.columns = [str(c) * 10 for c in df.columns]\n        df.index = [i * 10 for i in df.index]\n\n        f, ax = plt.subplots(figsize=(2, 2))\n        mat.heatmap(df, xticklabels=1, yticklabels=1, ax=ax)\n\n        for t in ax.get_xticklabels():\n            nt.assert_equal(t.get_rotation(), 90)\n\n        for t in ax.get_yticklabels():\n            nt.assert_equal(t.get_rotation(), 0)\n\n        plt.close(f)\n\n    def test_heatmap_inner_lines(self):\n\n        c = (0, 0, 1, 1)\n        ax = mat.heatmap(self.df_norm, linewidths=2, linecolor=c)\n        mesh = ax.collections[0]\n        nt.assert_equal(mesh.get_linewidths()[0], 2)\n        nt.assert_equal(tuple(mesh.get_edgecolor()[0]), c)\n\n    def test_square_aspect(self):\n\n        ax = mat.heatmap(self.df_norm, square=True)\n        nt.assert_equal(ax.get_aspect(), \"equal\")\n\n    def test_mask_validation(self):\n\n        mask = mat._matrix_mask(self.df_norm, None)\n        nt.assert_equal(mask.shape, self.df_norm.shape)\n        nt.assert_equal(mask.values.sum(), 0)\n\n        with nt.assert_raises(ValueError):\n            bad_array_mask = self.rs.randn(3, 6) > 0\n            mat._matrix_mask(self.df_norm, bad_array_mask)\n\n        with nt.assert_raises(ValueError):\n            bad_df_mask = pd.DataFrame(self.rs.randn(4, 8) > 0)\n            mat._matrix_mask(self.df_norm, bad_df_mask)\n\n    def test_missing_data_mask(self):\n\n        data = pd.DataFrame(np.arange(4, dtype=np.float).reshape(2, 2))\n        data.loc[0, 0] = np.nan\n        mask = mat._matrix_mask(data, None)\n        npt.assert_array_equal(mask, [[True, False], [False, False]])\n\n        mask_in = np.array([[False, True], [False, False]])\n        mask_out = mat._matrix_mask(data, mask_in)\n        npt.assert_array_equal(mask_out, [[True, True], [False, False]])\n\n    def test_cbar_ticks(self):\n        max_n_ticks = 3\n\n        locator = mpl.ticker.MaxNLocator(max_n_ticks)\n        f, (ax1, ax2) = plt.subplots(2)\n        mat.heatmap(self.df_norm, ax=ax1, cbar_ax=ax2,\n                    cbar_kws=dict(ticks=locator))\n        nt.assert_equal(len(ax2.yaxis.get_ticklabels()), max_n_ticks)\n        plt.close(f)\n\n\nclass TestDendrogram(object):\n    rs = np.random.RandomState(sum(map(ord, \"dendrogram\")))\n\n    x_norm = rs.randn(4, 8) + np.arange(8)\n    x_norm = (x_norm.T + np.arange(4)).T\n    letters = pd.Series([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"],\n                        name=\"letters\")\n\n    df_norm = pd.DataFrame(x_norm, columns=letters)\n    try:\n        import fastcluster\n\n        x_norm_linkage = fastcluster.linkage_vector(x_norm.T,\n                                                    metric='euclidean',\n                                                    method='single')\n    except ImportError:\n        x_norm_distances = distance.pdist(x_norm.T, metric='euclidean')\n        x_norm_linkage = hierarchy.linkage(x_norm_distances, method='single')\n    x_norm_dendrogram = hierarchy.dendrogram(x_norm_linkage, no_plot=True,\n                                             color_threshold=-np.inf)\n    x_norm_leaves = x_norm_dendrogram['leaves']\n    df_norm_leaves = np.asarray(df_norm.columns[x_norm_leaves])\n\n    default_kws = dict(linkage=None, metric='euclidean', method='single',\n                       axis=1, label=True, rotate=False)\n\n    def test_ndarray_input(self):\n        p = mat._DendrogramPlotter(self.x_norm, **self.default_kws)\n        npt.assert_array_equal(p.array.T, self.x_norm)\n        pdt.assert_frame_equal(p.data.T, pd.DataFrame(self.x_norm))\n\n        npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n        nt.assert_dict_equal(p.dendrogram, self.x_norm_dendrogram)\n\n        npt.assert_array_equal(p.reordered_ind, self.x_norm_leaves)\n\n        npt.assert_array_equal(p.xticklabels, self.x_norm_leaves)\n        npt.assert_array_equal(p.yticklabels, [])\n\n        nt.assert_equal(p.xlabel, None)\n        nt.assert_equal(p.ylabel, '')\n\n    def test_df_input(self):\n        p = mat._DendrogramPlotter(self.df_norm, **self.default_kws)\n        npt.assert_array_equal(p.array.T, np.asarray(self.df_norm))\n        pdt.assert_frame_equal(p.data.T, self.df_norm)\n\n        npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n        nt.assert_dict_equal(p.dendrogram, self.x_norm_dendrogram)\n\n        npt.assert_array_equal(p.xticklabels,\n                               np.asarray(self.df_norm.columns)[\n                                   self.x_norm_leaves])\n        npt.assert_array_equal(p.yticklabels, [])\n\n        nt.assert_equal(p.xlabel, 'letters')\n        nt.assert_equal(p.ylabel, '')\n\n    def test_df_multindex_input(self):\n\n        df = self.df_norm.copy()\n        index = pd.MultiIndex.from_tuples([(\"A\", 1), (\"B\", 2),\n                                           (\"C\", 3), (\"D\", 4)],\n                                          names=[\"letter\", \"number\"])\n        index.name = \"letter-number\"\n        df.index = index\n        kws = self.default_kws.copy()\n        kws['label'] = True\n\n        p = mat._DendrogramPlotter(df.T, **kws)\n\n        xticklabels = [\"A-1\", \"B-2\", \"C-3\", \"D-4\"]\n        xticklabels = [xticklabels[i] for i in p.reordered_ind]\n        npt.assert_array_equal(p.xticklabels, xticklabels)\n        npt.assert_array_equal(p.yticklabels, [])\n        nt.assert_equal(p.xlabel, \"letter-number\")\n\n    def test_axis0_input(self):\n        kws = self.default_kws.copy()\n        kws['axis'] = 0\n        p = mat._DendrogramPlotter(self.df_norm.T, **kws)\n\n        npt.assert_array_equal(p.array, np.asarray(self.df_norm.T))\n        pdt.assert_frame_equal(p.data, self.df_norm.T)\n\n        npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n        nt.assert_dict_equal(p.dendrogram, self.x_norm_dendrogram)\n\n        npt.assert_array_equal(p.xticklabels, self.df_norm_leaves)\n        npt.assert_array_equal(p.yticklabels, [])\n\n        nt.assert_equal(p.xlabel, 'letters')\n        nt.assert_equal(p.ylabel, '')\n\n    def test_rotate_input(self):\n        kws = self.default_kws.copy()\n        kws['rotate'] = True\n        p = mat._DendrogramPlotter(self.df_norm, **kws)\n        npt.assert_array_equal(p.array.T, np.asarray(self.df_norm))\n        pdt.assert_frame_equal(p.data.T, self.df_norm)\n\n        npt.assert_array_equal(p.xticklabels, [])\n        npt.assert_array_equal(p.yticklabels, self.df_norm_leaves)\n\n        nt.assert_equal(p.xlabel, '')\n        nt.assert_equal(p.ylabel, 'letters')\n\n    def test_rotate_axis0_input(self):\n        kws = self.default_kws.copy()\n        kws['rotate'] = True\n        kws['axis'] = 0\n        p = mat._DendrogramPlotter(self.df_norm.T, **kws)\n\n        npt.assert_array_equal(p.reordered_ind, self.x_norm_leaves)\n\n    def test_custom_linkage(self):\n        kws = self.default_kws.copy()\n\n        try:\n            import fastcluster\n\n            linkage = fastcluster.linkage_vector(self.x_norm, method='single',\n                                                 metric='euclidean')\n        except ImportError:\n            d = distance.pdist(self.x_norm, metric='euclidean')\n            linkage = hierarchy.linkage(d, method='single')\n        dendrogram = hierarchy.dendrogram(linkage, no_plot=True,\n                                          color_threshold=-np.inf)\n        kws['linkage'] = linkage\n        p = mat._DendrogramPlotter(self.df_norm, **kws)\n\n        npt.assert_array_equal(p.linkage, linkage)\n        nt.assert_dict_equal(p.dendrogram, dendrogram)\n\n    def test_label_false(self):\n        kws = self.default_kws.copy()\n        kws['label'] = False\n        p = mat._DendrogramPlotter(self.df_norm, **kws)\n        nt.assert_equal(p.xticks, [])\n        nt.assert_equal(p.yticks, [])\n        nt.assert_equal(p.xticklabels, [])\n        nt.assert_equal(p.yticklabels, [])\n        nt.assert_equal(p.xlabel, \"\")\n        nt.assert_equal(p.ylabel, \"\")\n\n    def test_linkage_scipy(self):\n        p = mat._DendrogramPlotter(self.x_norm, **self.default_kws)\n\n        scipy_linkage = p._calculate_linkage_scipy()\n\n        from scipy.spatial import distance\n        from scipy.cluster import hierarchy\n\n        dists = distance.pdist(self.x_norm.T,\n                               metric=self.default_kws['metric'])\n        linkage = hierarchy.linkage(dists, method=self.default_kws['method'])\n\n        npt.assert_array_equal(scipy_linkage, linkage)\n\n    @skipif(_no_fastcluster)\n    def test_fastcluster_other_method(self):\n        import fastcluster\n\n        kws = self.default_kws.copy()\n        kws['method'] = 'average'\n        linkage = fastcluster.linkage(self.x_norm.T, method='average',\n                                      metric='euclidean')\n        p = mat._DendrogramPlotter(self.x_norm, **kws)\n        npt.assert_array_equal(p.linkage, linkage)\n\n    @skipif(_no_fastcluster)\n    def test_fastcluster_non_euclidean(self):\n        import fastcluster\n\n        kws = self.default_kws.copy()\n        kws['metric'] = 'cosine'\n        kws['method'] = 'average'\n        linkage = fastcluster.linkage(self.x_norm.T, method=kws['method'],\n                                      metric=kws['metric'])\n        p = mat._DendrogramPlotter(self.x_norm, **kws)\n        npt.assert_array_equal(p.linkage, linkage)\n\n    def test_dendrogram_plot(self):\n        d = mat.dendrogram(self.x_norm, **self.default_kws)\n\n        ax = plt.gca()\n        xlim = ax.get_xlim()\n        # 10 comes from _plot_dendrogram in scipy.cluster.hierarchy\n        xmax = len(d.reordered_ind) * 10\n\n        nt.assert_equal(xlim[0], 0)\n        nt.assert_equal(xlim[1], xmax)\n\n        nt.assert_equal(len(ax.collections[0].get_paths()),\n                        len(d.dependent_coord))\n\n    def test_dendrogram_rotate(self):\n        kws = self.default_kws.copy()\n        kws['rotate'] = True\n\n        d = mat.dendrogram(self.x_norm, **kws)\n\n        ax = plt.gca()\n        ylim = ax.get_ylim()\n\n        # 10 comes from _plot_dendrogram in scipy.cluster.hierarchy\n        ymax = len(d.reordered_ind) * 10\n\n        # Since y axis is inverted, ylim is (80, 0)\n        # and therefore not (0, 80) as usual:\n        nt.assert_equal(ylim[1], 0)\n        nt.assert_equal(ylim[0], ymax)\n\n    def test_dendrogram_ticklabel_rotation(self):\n        f, ax = plt.subplots(figsize=(2, 2))\n        mat.dendrogram(self.df_norm, ax=ax)\n\n        for t in ax.get_xticklabels():\n            nt.assert_equal(t.get_rotation(), 0)\n\n        plt.close(f)\n\n        df = self.df_norm.copy()\n        df.columns = [str(c) * 10 for c in df.columns]\n        df.index = [i * 10 for i in df.index]\n\n        f, ax = plt.subplots(figsize=(2, 2))\n        mat.dendrogram(df, ax=ax)\n\n        for t in ax.get_xticklabels():\n            nt.assert_equal(t.get_rotation(), 90)\n\n        plt.close(f)\n\n        f, ax = plt.subplots(figsize=(2, 2))\n        mat.dendrogram(df.T, axis=0, rotate=True)\n        for t in ax.get_yticklabels():\n            nt.assert_equal(t.get_rotation(), 0)\n        plt.close(f)\n\n\nclass TestClustermap(object):\n    rs = np.random.RandomState(sum(map(ord, \"clustermap\")))\n\n    x_norm = rs.randn(4, 8) + np.arange(8)\n    x_norm = (x_norm.T + np.arange(4)).T\n    letters = pd.Series([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"],\n                        name=\"letters\")\n\n    df_norm = pd.DataFrame(x_norm, columns=letters)\n    try:\n        import fastcluster\n\n        x_norm_linkage = fastcluster.linkage_vector(x_norm.T,\n                                                    metric='euclidean',\n                                                    method='single')\n    except ImportError:\n        x_norm_distances = distance.pdist(x_norm.T, metric='euclidean')\n        x_norm_linkage = hierarchy.linkage(x_norm_distances, method='single')\n    x_norm_dendrogram = hierarchy.dendrogram(x_norm_linkage, no_plot=True,\n                                             color_threshold=-np.inf)\n    x_norm_leaves = x_norm_dendrogram['leaves']\n    df_norm_leaves = np.asarray(df_norm.columns[x_norm_leaves])\n\n    default_kws = dict(pivot_kws=None, z_score=None, standard_scale=None,\n                       figsize=None, row_colors=None, col_colors=None)\n\n    default_plot_kws = dict(metric='euclidean', method='average',\n                            colorbar_kws=None,\n                            row_cluster=True, col_cluster=True,\n                            row_linkage=None, col_linkage=None)\n\n    row_colors = color_palette('Set2', df_norm.shape[0])\n    col_colors = color_palette('Dark2', df_norm.shape[1])\n\n    def test_ndarray_input(self):\n        cm = mat.ClusterGrid(self.x_norm, **self.default_kws)\n        pdt.assert_frame_equal(cm.data, pd.DataFrame(self.x_norm))\n        nt.assert_equal(len(cm.fig.axes), 4)\n        nt.assert_equal(cm.ax_row_colors, None)\n        nt.assert_equal(cm.ax_col_colors, None)\n\n    def test_df_input(self):\n        cm = mat.ClusterGrid(self.df_norm, **self.default_kws)\n        pdt.assert_frame_equal(cm.data, self.df_norm)\n\n    def test_corr_df_input(self):\n        df = self.df_norm.corr()\n        cg = mat.ClusterGrid(df, **self.default_kws)\n        cg.plot(**self.default_plot_kws)\n        diag = cg.data2d.values[np.diag_indices_from(cg.data2d)]\n        npt.assert_array_equal(diag, np.ones(cg.data2d.shape[0]))\n\n    def test_pivot_input(self):\n        df_norm = self.df_norm.copy()\n        df_norm.index.name = 'numbers'\n        df_long = pd.melt(df_norm.reset_index(), var_name='letters',\n                          id_vars='numbers')\n        kws = self.default_kws.copy()\n        kws['pivot_kws'] = dict(index='numbers', columns='letters',\n                                values='value')\n        cm = mat.ClusterGrid(df_long, **kws)\n\n        pdt.assert_frame_equal(cm.data2d, df_norm)\n\n    def test_colors_input(self):\n        kws = self.default_kws.copy()\n\n        kws['row_colors'] = self.row_colors\n        kws['col_colors'] = self.col_colors\n\n        cm = mat.ClusterGrid(self.df_norm, **kws)\n        npt.assert_array_equal(cm.row_colors, self.row_colors)\n        npt.assert_array_equal(cm.col_colors, self.col_colors)\n\n        nt.assert_equal(len(cm.fig.axes), 6)\n\n    def test_nested_colors_input(self):\n        kws = self.default_kws.copy()\n\n        row_colors = [self.row_colors, self.row_colors]\n        col_colors = [self.col_colors, self.col_colors]\n        kws['row_colors'] = row_colors\n        kws['col_colors'] = col_colors\n\n        cm = mat.ClusterGrid(self.df_norm, **kws)\n        npt.assert_array_equal(cm.row_colors, row_colors)\n        npt.assert_array_equal(cm.col_colors, col_colors)\n\n        nt.assert_equal(len(cm.fig.axes), 6)\n\n    def test_colors_input_custom_cmap(self):\n        kws = self.default_kws.copy()\n\n        kws['cmap'] = mpl.cm.PRGn\n        kws['row_colors'] = self.row_colors\n        kws['col_colors'] = self.col_colors\n\n        cm = mat.clustermap(self.df_norm, **kws)\n        npt.assert_array_equal(cm.row_colors, self.row_colors)\n        npt.assert_array_equal(cm.col_colors, self.col_colors)\n\n        nt.assert_equal(len(cm.fig.axes), 6)\n\n    def test_z_score(self):\n        df = self.df_norm.copy()\n        df = (df - df.mean()) / df.std()\n        kws = self.default_kws.copy()\n        kws['z_score'] = 1\n\n        cm = mat.ClusterGrid(self.df_norm, **kws)\n        pdt.assert_frame_equal(cm.data2d, df)\n\n    def test_z_score_axis0(self):\n        df = self.df_norm.copy()\n        df = df.T\n        df = (df - df.mean()) / df.std()\n        df = df.T\n        kws = self.default_kws.copy()\n        kws['z_score'] = 0\n\n        cm = mat.ClusterGrid(self.df_norm, **kws)\n        pdt.assert_frame_equal(cm.data2d, df)\n\n    def test_standard_scale(self):\n        df = self.df_norm.copy()\n        df = (df - df.min()) / (df.max() - df.min())\n        kws = self.default_kws.copy()\n        kws['standard_scale'] = 1\n\n        cm = mat.ClusterGrid(self.df_norm, **kws)\n        pdt.assert_frame_equal(cm.data2d, df)\n\n    def test_standard_scale_axis0(self):\n        df = self.df_norm.copy()\n        df = df.T\n        df = (df - df.min()) / (df.max() - df.min())\n        df = df.T\n        kws = self.default_kws.copy()\n        kws['standard_scale'] = 0\n\n        cm = mat.ClusterGrid(self.df_norm, **kws)\n        pdt.assert_frame_equal(cm.data2d, df)\n\n    def test_z_score_standard_scale(self):\n        kws = self.default_kws.copy()\n        kws['z_score'] = True\n        kws['standard_scale'] = True\n        with nt.assert_raises(ValueError):\n            cm = mat.ClusterGrid(self.df_norm, **kws)\n\n    def test_color_list_to_matrix_and_cmap(self):\n        matrix, cmap = mat.ClusterGrid.color_list_to_matrix_and_cmap(\n            self.col_colors, self.x_norm_leaves)\n\n        colors_set = set(self.col_colors)\n        col_to_value = dict((col, i) for i, col in enumerate(colors_set))\n        matrix_test = np.array([col_to_value[col] for col in\n                                self.col_colors])[self.x_norm_leaves]\n        shape = len(self.col_colors), 1\n        matrix_test = matrix_test.reshape(shape)\n        cmap_test = mpl.colors.ListedColormap(colors_set)\n        npt.assert_array_equal(matrix, matrix_test)\n        npt.assert_array_equal(cmap.colors, cmap_test.colors)\n\n    def test_nested_color_list_to_matrix_and_cmap(self):\n        colors = [self.col_colors, self.col_colors]\n        matrix, cmap = mat.ClusterGrid.color_list_to_matrix_and_cmap(\n            colors, self.x_norm_leaves)\n\n        all_colors = set(itertools.chain(*colors))\n        color_to_value = dict((col, i) for i, col in enumerate(all_colors))\n        matrix_test = np.array(\n            [color_to_value[c] for color in colors for c in color])\n        shape = len(colors), len(colors[0])\n        matrix_test = matrix_test.reshape(shape)\n        matrix_test = matrix_test[:, self.x_norm_leaves]\n        matrix_test = matrix_test.T\n\n        cmap_test = mpl.colors.ListedColormap(all_colors)\n        npt.assert_array_equal(matrix, matrix_test)\n        npt.assert_array_equal(cmap.colors, cmap_test.colors)\n\n    def test_color_list_to_matrix_and_cmap_axis1(self):\n        matrix, cmap = mat.ClusterGrid.color_list_to_matrix_and_cmap(\n            self.col_colors, self.x_norm_leaves, axis=1)\n\n        colors_set = set(self.col_colors)\n        col_to_value = dict((col, i) for i, col in enumerate(colors_set))\n        matrix_test = np.array([col_to_value[col] for col in\n                                self.col_colors])[self.x_norm_leaves]\n        shape = 1, len(self.col_colors)\n        matrix_test = matrix_test.reshape(shape)\n        cmap_test = mpl.colors.ListedColormap(colors_set)\n        npt.assert_array_equal(matrix, matrix_test)\n        npt.assert_array_equal(cmap.colors, cmap_test.colors)\n\n    def test_savefig(self):\n        # Not sure if this is the right way to test....\n        cm = mat.ClusterGrid(self.df_norm, **self.default_kws)\n        cm.plot(**self.default_plot_kws)\n        cm.savefig(tempfile.NamedTemporaryFile(), format='png')\n\n    def test_plot_dendrograms(self):\n        cm = mat.clustermap(self.df_norm, **self.default_kws)\n\n        nt.assert_equal(len(cm.ax_row_dendrogram.collections[0].get_paths()),\n                        len(cm.dendrogram_row.independent_coord))\n        nt.assert_equal(len(cm.ax_col_dendrogram.collections[0].get_paths()),\n                        len(cm.dendrogram_col.independent_coord))\n        data2d = self.df_norm.iloc[cm.dendrogram_row.reordered_ind,\n                                   cm.dendrogram_col.reordered_ind]\n        pdt.assert_frame_equal(cm.data2d, data2d)\n\n    def test_cluster_false(self):\n        kws = self.default_kws.copy()\n        kws['row_cluster'] = False\n        kws['col_cluster'] = False\n\n        cm = mat.clustermap(self.df_norm, **kws)\n        nt.assert_equal(len(cm.ax_row_dendrogram.lines), 0)\n        nt.assert_equal(len(cm.ax_col_dendrogram.lines), 0)\n\n        nt.assert_equal(len(cm.ax_row_dendrogram.get_xticks()), 0)\n        nt.assert_equal(len(cm.ax_row_dendrogram.get_yticks()), 0)\n        nt.assert_equal(len(cm.ax_col_dendrogram.get_xticks()), 0)\n        nt.assert_equal(len(cm.ax_col_dendrogram.get_yticks()), 0)\n\n        pdt.assert_frame_equal(cm.data2d, self.df_norm)\n\n    def test_row_col_colors(self):\n        kws = self.default_kws.copy()\n        kws['row_colors'] = self.row_colors\n        kws['col_colors'] = self.col_colors\n\n        cm = mat.clustermap(self.df_norm, **kws)\n\n        nt.assert_equal(len(cm.ax_row_colors.collections), 1)\n        nt.assert_equal(len(cm.ax_col_colors.collections), 1)\n\n    def test_cluster_false_row_col_colors(self):\n        kws = self.default_kws.copy()\n        kws['row_cluster'] = False\n        kws['col_cluster'] = False\n        kws['row_colors'] = self.row_colors\n        kws['col_colors'] = self.col_colors\n\n        cm = mat.clustermap(self.df_norm, **kws)\n        nt.assert_equal(len(cm.ax_row_dendrogram.lines), 0)\n        nt.assert_equal(len(cm.ax_col_dendrogram.lines), 0)\n\n        nt.assert_equal(len(cm.ax_row_dendrogram.get_xticks()), 0)\n        nt.assert_equal(len(cm.ax_row_dendrogram.get_yticks()), 0)\n        nt.assert_equal(len(cm.ax_col_dendrogram.get_xticks()), 0)\n        nt.assert_equal(len(cm.ax_col_dendrogram.get_yticks()), 0)\n        nt.assert_equal(len(cm.ax_row_colors.collections), 1)\n        nt.assert_equal(len(cm.ax_col_colors.collections), 1)\n\n        pdt.assert_frame_equal(cm.data2d, self.df_norm)\n\n    def test_row_col_colors_df(self):\n        kws = self.default_kws.copy()\n        kws['row_colors'] = pd.DataFrame({'row_1': list(self.row_colors),\n                                          'row_2': list(self.row_colors)},\n                                         index=self.df_norm.index,\n                                         columns=['row_1', 'row_2'])\n        kws['col_colors'] = pd.DataFrame({'col_1': list(self.col_colors),\n                                          'col_2': list(self.col_colors)},\n                                         index=self.df_norm.columns,\n                                         columns=['col_1', 'col_2'])\n\n        cm = mat.clustermap(self.df_norm, **kws)\n\n        row_labels = [l.get_text() for l in\n                      cm.ax_row_colors.get_xticklabels()]\n        nt.assert_equal(cm.row_color_labels, ['row_1', 'row_2'])\n        nt.assert_equal(row_labels, cm.row_color_labels)\n\n        col_labels = [l.get_text() for l in\n                      cm.ax_col_colors.get_yticklabels()]\n        nt.assert_equal(cm.col_color_labels, ['col_1', 'col_2'])\n        nt.assert_equal(col_labels, cm.col_color_labels)\n\n    def test_row_col_colors_df_shuffled(self):\n        # Tests if colors are properly matched, even if given in wrong order\n\n        m, n = self.df_norm.shape\n        shuffled_inds = [self.df_norm.index[i] for i in\n                         list(range(0, m, 2)) + list(range(1, m, 2))]\n        shuffled_cols = [self.df_norm.columns[i] for i in\n                         list(range(0, n, 2)) + list(range(1, n, 2))]\n\n        kws = self.default_kws.copy()\n\n        row_colors = pd.DataFrame({'row_annot': list(self.row_colors)},\n                                  index=self.df_norm.index)\n        kws['row_colors'] = row_colors.ix[shuffled_inds]\n\n        col_colors = pd.DataFrame({'col_annot': list(self.col_colors)},\n                                  index=self.df_norm.columns)\n        kws['col_colors'] = col_colors.ix[shuffled_cols]\n\n        cm = mat.clustermap(self.df_norm, **kws)\n        nt.assert_equal(list(cm.col_colors)[0], list(self.col_colors))\n        nt.assert_equal(list(cm.row_colors)[0], list(self.row_colors))\n\n    def test_row_col_colors_df_missing(self):\n        kws = self.default_kws.copy()\n        row_colors = pd.DataFrame({'row_annot': list(self.row_colors)},\n                                  index=self.df_norm.index)\n        kws['row_colors'] = row_colors.drop(self.df_norm.index[0])\n\n        col_colors = pd.DataFrame({'col_annot': list(self.col_colors)},\n                                  index=self.df_norm.columns)\n        kws['col_colors'] = col_colors.drop(self.df_norm.columns[0])\n\n        cm = mat.clustermap(self.df_norm, **kws)\n\n        nt.assert_equal(list(cm.col_colors)[0],\n                        [(1.0, 1.0, 1.0)] + list(self.col_colors[1:]))\n        nt.assert_equal(list(cm.row_colors)[0],\n                        [(1.0, 1.0, 1.0)] + list(self.row_colors[1:]))\n\n    def test_row_col_colors_df_one_axis(self):\n        # Test case with only row annotation.\n        kws1 = self.default_kws.copy()\n        kws1['row_colors'] = pd.DataFrame({'row_1': list(self.row_colors),\n                                           'row_2': list(self.row_colors)},\n                                          index=self.df_norm.index,\n                                          columns=['row_1', 'row_2'])\n\n        cm1 = mat.clustermap(self.df_norm, **kws1)\n\n        row_labels = [l.get_text() for l in\n                      cm1.ax_row_colors.get_xticklabels()]\n        nt.assert_equal(cm1.row_color_labels, ['row_1', 'row_2'])\n        nt.assert_equal(row_labels, cm1.row_color_labels)\n\n        # Test case with onl col annotation.\n        kws2 = self.default_kws.copy()\n        kws2['col_colors'] = pd.DataFrame({'col_1': list(self.col_colors),\n                                           'col_2': list(self.col_colors)},\n                                          index=self.df_norm.columns,\n                                          columns=['col_1', 'col_2'])\n\n        cm2 = mat.clustermap(self.df_norm, **kws2)\n\n        col_labels = [l.get_text() for l in\n                      cm2.ax_col_colors.get_yticklabels()]\n        nt.assert_equal(cm2.col_color_labels, ['col_1', 'col_2'])\n        nt.assert_equal(col_labels, cm2.col_color_labels)\n\n    def test_row_col_colors_series(self):\n        kws = self.default_kws.copy()\n        kws['row_colors'] = pd.Series(list(self.row_colors), name='row_annot',\n                                      index=self.df_norm.index)\n        kws['col_colors'] = pd.Series(list(self.col_colors), name='col_annot',\n                                      index=self.df_norm.columns)\n\n        cm = mat.clustermap(self.df_norm, **kws)\n\n        row_labels = [l.get_text() for l in\n                      cm.ax_row_colors.get_xticklabels()]\n        nt.assert_equal(cm.row_color_labels, ['row_annot'])\n        nt.assert_equal(row_labels, cm.row_color_labels)\n\n        col_labels = [l.get_text() for l in\n                      cm.ax_col_colors.get_yticklabels()]\n        nt.assert_equal(cm.col_color_labels, ['col_annot'])\n        nt.assert_equal(col_labels, cm.col_color_labels)\n\n    def test_row_col_colors_series_shuffled(self):\n        # Tests if colors are properly matched, even if given in wrong order\n\n        m, n = self.df_norm.shape\n        shuffled_inds = [self.df_norm.index[i] for i in\n                         list(range(0, m, 2)) + list(range(1, m, 2))]\n        shuffled_cols = [self.df_norm.columns[i] for i in\n                         list(range(0, n, 2)) + list(range(1, n, 2))]\n\n        kws = self.default_kws.copy()\n\n        row_colors = pd.Series(list(self.row_colors), name='row_annot',\n                               index=self.df_norm.index)\n        kws['row_colors'] = row_colors.ix[shuffled_inds]\n\n        col_colors = pd.Series(list(self.col_colors), name='col_annot',\n                               index=self.df_norm.columns)\n        kws['col_colors'] = col_colors.ix[shuffled_cols]\n\n        cm = mat.clustermap(self.df_norm, **kws)\n\n        nt.assert_equal(list(cm.col_colors), list(self.col_colors))\n        nt.assert_equal(list(cm.row_colors), list(self.row_colors))\n\n    def test_row_col_colors_series_missing(self):\n        kws = self.default_kws.copy()\n        row_colors = pd.Series(list(self.row_colors), name='row_annot',\n                               index=self.df_norm.index)\n        kws['row_colors'] = row_colors.drop(self.df_norm.index[0])\n\n        col_colors = pd.Series(list(self.col_colors), name='col_annot',\n                               index=self.df_norm.columns)\n        kws['col_colors'] = col_colors.drop(self.df_norm.columns[0])\n\n        cm = mat.clustermap(self.df_norm, **kws)\n        nt.assert_equal(list(cm.col_colors),\n                        [(1.0, 1.0, 1.0)] + list(self.col_colors[1:]))\n        nt.assert_equal(list(cm.row_colors),\n                        [(1.0, 1.0, 1.0)] + list(self.row_colors[1:]))\n\n    def test_mask_reorganization(self):\n\n        kws = self.default_kws.copy()\n        kws[\"mask\"] = self.df_norm > 0\n\n        g = mat.clustermap(self.df_norm, **kws)\n        npt.assert_array_equal(g.data2d.index, g.mask.index)\n        npt.assert_array_equal(g.data2d.columns, g.mask.columns)\n\n        npt.assert_array_equal(g.mask.index,\n                               self.df_norm.index[\n                                   g.dendrogram_row.reordered_ind])\n        npt.assert_array_equal(g.mask.columns,\n                               self.df_norm.columns[\n                                   g.dendrogram_col.reordered_ind])\n\n    def test_ticklabel_reorganization(self):\n\n        kws = self.default_kws.copy()\n        xtl = np.arange(self.df_norm.shape[1])\n        kws[\"xticklabels\"] = list(xtl)\n        ytl = self.letters.ix[:self.df_norm.shape[0]]\n        kws[\"yticklabels\"] = ytl\n\n        g = mat.clustermap(self.df_norm, **kws)\n\n        xtl_actual = [t.get_text() for t in g.ax_heatmap.get_xticklabels()]\n        ytl_actual = [t.get_text() for t in g.ax_heatmap.get_yticklabels()]\n\n        xtl_want = xtl[g.dendrogram_col.reordered_ind].astype(\"<U1\")\n        ytl_want = ytl[g.dendrogram_row.reordered_ind].astype(\"<U1\")\n\n        npt.assert_array_equal(xtl_actual, xtl_want)\n        npt.assert_array_equal(ytl_actual, ytl_want)\n\n    def test_noticklabels(self):\n\n        kws = self.default_kws.copy()\n        kws[\"xticklabels\"] = False\n        kws[\"yticklabels\"] = False\n\n        g = mat.clustermap(self.df_norm, **kws)\n\n        xtl_actual = [t.get_text() for t in g.ax_heatmap.get_xticklabels()]\n        ytl_actual = [t.get_text() for t in g.ax_heatmap.get_yticklabels()]\n        nt.assert_equal(xtl_actual, [])\n        nt.assert_equal(ytl_actual, [])\n", "description": "Statistical data visualization using matplotlib", "file_name": "test_matrix.py", "id": "62a5a3f2fc32c171982924c0ccfe29ea", "language": "Python", "project_name": "seaborn", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mwaskom-seaborn/mwaskom-seaborn-71a807b/seaborn/tests/test_matrix.py", "save_time": "", "source": "", "update_at": "2018-03-18T02:14:24Z", "url": "https://github.com/mwaskom/seaborn", "wiki": false}