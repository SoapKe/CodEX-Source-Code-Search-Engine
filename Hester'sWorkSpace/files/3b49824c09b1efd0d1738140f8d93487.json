{"author": "pandas-dev", "code": "import numpy as np\nimport pandas.util.testing as tm\nfrom pandas import DataFrame, Series, read_csv, factorize, date_range\nfrom pandas.core.algorithms import take_1d\ntry:\n    from pandas import (rolling_median, rolling_mean, rolling_min, rolling_max,\n                        rolling_var, rolling_skew, rolling_kurt, rolling_std)\n    have_rolling_methods = True\nexcept ImportError:\n    have_rolling_methods = False\ntry:\n    from pandas._libs import algos\nexcept ImportError:\n    from pandas import algos\ntry:\n    from pandas.util.testing import test_parallel\n    have_real_test_parallel = True\nexcept ImportError:\n    have_real_test_parallel = False\n\n    def test_parallel(num_threads=1):\n        def wrapper(fname):\n            return fname\n        return wrapper\n\nfrom .pandas_vb_common import BaseIO, setup  \n\n\nclass ParallelGroupbyMethods(object):\n\n    goal_time = 0.2\n    params = ([2, 4, 8], ['count', 'last', 'max', 'mean', 'min', 'prod',\n                          'sum', 'var'])\n    param_names = ['threads', 'method']\n\n    def setup(self, threads, method):\n        if not have_real_test_parallel:\n            raise NotImplementedError\n        N = 10**6\n        ngroups = 10**3\n        df = DataFrame({'key': np.random.randint(0, ngroups, size=N),\n                        'data': np.random.randn(N)})\n\n        @test_parallel(num_threads=threads)\n        def parallel():\n            getattr(df.groupby('key')['data'], method)()\n        self.parallel = parallel\n\n        def loop():\n            getattr(df.groupby('key')['data'], method)()\n        self.loop = loop\n\n    def time_parallel(self, threads, method):\n        self.parallel()\n\n    def time_loop(self, threads, method):\n        for i in range(threads):\n            self.loop()\n\n\nclass ParallelGroups(object):\n\n    goal_time = 0.2\n    params = [2, 4, 8]\n    param_names = ['threads']\n\n    def setup(self, threads):\n        if not have_real_test_parallel:\n            raise NotImplementedError\n        size = 2**22\n        ngroups = 10**3\n        data = Series(np.random.randint(0, ngroups, size=size))\n\n        @test_parallel(num_threads=threads)\n        def get_groups():\n            data.groupby(data).groups\n        self.get_groups = get_groups\n\n    def time_get_groups(self, threads):\n        self.get_groups()\n\n\nclass ParallelTake1D(object):\n\n    goal_time = 0.2\n    params = ['int64', 'float64']\n    param_names = ['dtype']\n\n    def setup(self, dtype):\n        if not have_real_test_parallel:\n            raise NotImplementedError\n        N = 10**6\n        df = DataFrame({'col': np.arange(N, dtype=dtype)})\n        indexer = np.arange(100, len(df) - 100)\n\n        @test_parallel(num_threads=2)\n        def parallel_take1d():\n            take_1d(df['col'].values, indexer)\n        self.parallel_take1d = parallel_take1d\n\n    def time_take1d(self, dtype):\n        self.parallel_take1d()\n\n\nclass ParallelKth(object):\n\n    number = 1\n    repeat = 5\n\n    def setup(self):\n        if not have_real_test_parallel:\n            raise NotImplementedError\n        N = 10**7\n        k = 5 * 10**5\n        kwargs_list = [{'arr': np.random.randn(N)},\n                       {'arr': np.random.randn(N)}]\n\n        @test_parallel(num_threads=2, kwargs_list=kwargs_list)\n        def parallel_kth_smallest(arr):\n            algos.kth_smallest(arr, k)\n        self.parallel_kth_smallest = parallel_kth_smallest\n\n    def time_kth_smallest(self):\n        self.parallel_kth_smallest()\n\n\nclass ParallelDatetimeFields(object):\n\n    goal_time = 0.2\n\n    def setup(self):\n        if not have_real_test_parallel:\n            raise NotImplementedError\n        N = 10**6\n        self.dti = date_range('1900-01-01', periods=N, freq='T')\n        self.period = self.dti.to_period('D')\n\n    def time_datetime_field_year(self):\n        @test_parallel(num_threads=2)\n        def run(dti):\n            dti.year\n        run(self.dti)\n\n    def time_datetime_field_day(self):\n        @test_parallel(num_threads=2)\n        def run(dti):\n            dti.day\n        run(self.dti)\n\n    def time_datetime_field_daysinmonth(self):\n        @test_parallel(num_threads=2)\n        def run(dti):\n            dti.days_in_month\n        run(self.dti)\n\n    def time_datetime_field_normalize(self):\n        @test_parallel(num_threads=2)\n        def run(dti):\n            dti.normalize()\n        run(self.dti)\n\n    def time_datetime_to_period(self):\n        @test_parallel(num_threads=2)\n        def run(dti):\n            dti.to_period('S')\n        run(self.dti)\n\n    def time_period_to_datetime(self):\n        @test_parallel(num_threads=2)\n        def run(period):\n            period.to_timestamp()\n        run(self.period)\n\n\nclass ParallelRolling(object):\n\n    goal_time = 0.2\n    params = ['median', 'mean', 'min', 'max', 'var', 'skew', 'kurt', 'std']\n    param_names = ['method']\n\n    def setup(self, method):\n        if not have_real_test_parallel:\n            raise NotImplementedError\n        win = 100\n        arr = np.random.rand(100000)\n        if hasattr(DataFrame, 'rolling'):\n            df = DataFrame(arr).rolling(win)\n\n            @test_parallel(num_threads=2)\n            def parallel_rolling():\n                getattr(df, method)()\n            self.parallel_rolling = parallel_rolling\n        elif have_rolling_methods:\n            rolling = {'median': rolling_median,\n                       'mean': rolling_mean,\n                       'min': rolling_min,\n                       'max': rolling_max,\n                       'var': rolling_var,\n                       'skew': rolling_skew,\n                       'kurt': rolling_kurt,\n                       'std': rolling_std}\n\n            @test_parallel(num_threads=2)\n            def parallel_rolling():\n                rolling[method](arr, win)\n            self.parallel_rolling = parallel_rolling\n        else:\n            raise NotImplementedError\n\n    def time_rolling(self, method):\n        self.parallel_rolling()\n\n\nclass ParallelReadCSV(BaseIO):\n\n    number = 1\n    repeat = 5\n    params = ['float', 'object', 'datetime']\n    param_names = ['dtype']\n\n    def setup(self, dtype):\n        if not have_real_test_parallel:\n            raise NotImplementedError\n        rows = 10000\n        cols = 50\n        data = {'float': DataFrame(np.random.randn(rows, cols)),\n                'datetime': DataFrame(np.random.randn(rows, cols),\n                                      index=date_range('1/1/2000',\n                                                       periods=rows)),\n                'object': DataFrame('foo',\n                                    index=range(rows),\n                                    columns=['object%03d'.format(i)\n                                             for i in range(5)])}\n\n        self.fname = '__test_{}__.csv'.format(dtype)\n        df = data[dtype]\n        df.to_csv(self.fname)\n\n        @test_parallel(num_threads=2)\n        def parallel_read_csv():\n            read_csv(self.fname)\n        self.parallel_read_csv = parallel_read_csv\n\n    def time_read_csv(self, dtype):\n        self.parallel_read_csv()\n\n\nclass ParallelFactorize(object):\n\n    number = 1\n    repeat = 5\n    params = [2, 4, 8]\n    param_names = ['threads']\n\n    def setup(self, threads):\n        if not have_real_test_parallel:\n            raise NotImplementedError\n\n        strings = tm.makeStringIndex(100000)\n\n        @test_parallel(num_threads=threads)\n        def parallel():\n            factorize(strings)\n        self.parallel = parallel\n\n        def loop():\n            factorize(strings)\n        self.loop = loop\n\n    def time_parallel(self, threads):\n        self.parallel()\n\n    def time_loop(self, threads):\n        for i in range(threads):\n            self.loop()\n", "comments": "noqa", "content": "import numpy as np\nimport pandas.util.testing as tm\nfrom pandas import DataFrame, Series, read_csv, factorize, date_range\nfrom pandas.core.algorithms import take_1d\ntry:\n    from pandas import (rolling_median, rolling_mean, rolling_min, rolling_max,\n                        rolling_var, rolling_skew, rolling_kurt, rolling_std)\n    have_rolling_methods = True\nexcept ImportError:\n    have_rolling_methods = False\ntry:\n    from pandas._libs import algos\nexcept ImportError:\n    from pandas import algos\ntry:\n    from pandas.util.testing import test_parallel\n    have_real_test_parallel = True\nexcept ImportError:\n    have_real_test_parallel = False\n\n    def test_parallel(num_threads=1):\n        def wrapper(fname):\n            return fname\n        return wrapper\n\nfrom .pandas_vb_common import BaseIO, setup  # noqa\n\n\nclass ParallelGroupbyMethods(object):\n\n    goal_time = 0.2\n    params = ([2, 4, 8], ['count', 'last', 'max', 'mean', 'min', 'prod',\n                          'sum', 'var'])\n    param_names = ['threads', 'method']\n\n    def setup(self, threads, method):\n        if not have_real_test_parallel:\n            raise NotImplementedError\n        N = 10**6\n        ngroups = 10**3\n        df = DataFrame({'key': np.random.randint(0, ngroups, size=N),\n                        'data': np.random.randn(N)})\n\n        @test_parallel(num_threads=threads)\n        def parallel():\n            getattr(df.groupby('key')['data'], method)()\n        self.parallel = parallel\n\n        def loop():\n            getattr(df.groupby('key')['data'], method)()\n        self.loop = loop\n\n    def time_parallel(self, threads, method):\n        self.parallel()\n\n    def time_loop(self, threads, method):\n        for i in range(threads):\n            self.loop()\n\n\nclass ParallelGroups(object):\n\n    goal_time = 0.2\n    params = [2, 4, 8]\n    param_names = ['threads']\n\n    def setup(self, threads):\n        if not have_real_test_parallel:\n            raise NotImplementedError\n        size = 2**22\n        ngroups = 10**3\n        data = Series(np.random.randint(0, ngroups, size=size))\n\n        @test_parallel(num_threads=threads)\n        def get_groups():\n            data.groupby(data).groups\n        self.get_groups = get_groups\n\n    def time_get_groups(self, threads):\n        self.get_groups()\n\n\nclass ParallelTake1D(object):\n\n    goal_time = 0.2\n    params = ['int64', 'float64']\n    param_names = ['dtype']\n\n    def setup(self, dtype):\n        if not have_real_test_parallel:\n            raise NotImplementedError\n        N = 10**6\n        df = DataFrame({'col': np.arange(N, dtype=dtype)})\n        indexer = np.arange(100, len(df) - 100)\n\n        @test_parallel(num_threads=2)\n        def parallel_take1d():\n            take_1d(df['col'].values, indexer)\n        self.parallel_take1d = parallel_take1d\n\n    def time_take1d(self, dtype):\n        self.parallel_take1d()\n\n\nclass ParallelKth(object):\n\n    number = 1\n    repeat = 5\n\n    def setup(self):\n        if not have_real_test_parallel:\n            raise NotImplementedError\n        N = 10**7\n        k = 5 * 10**5\n        kwargs_list = [{'arr': np.random.randn(N)},\n                       {'arr': np.random.randn(N)}]\n\n        @test_parallel(num_threads=2, kwargs_list=kwargs_list)\n        def parallel_kth_smallest(arr):\n            algos.kth_smallest(arr, k)\n        self.parallel_kth_smallest = parallel_kth_smallest\n\n    def time_kth_smallest(self):\n        self.parallel_kth_smallest()\n\n\nclass ParallelDatetimeFields(object):\n\n    goal_time = 0.2\n\n    def setup(self):\n        if not have_real_test_parallel:\n            raise NotImplementedError\n        N = 10**6\n        self.dti = date_range('1900-01-01', periods=N, freq='T')\n        self.period = self.dti.to_period('D')\n\n    def time_datetime_field_year(self):\n        @test_parallel(num_threads=2)\n        def run(dti):\n            dti.year\n        run(self.dti)\n\n    def time_datetime_field_day(self):\n        @test_parallel(num_threads=2)\n        def run(dti):\n            dti.day\n        run(self.dti)\n\n    def time_datetime_field_daysinmonth(self):\n        @test_parallel(num_threads=2)\n        def run(dti):\n            dti.days_in_month\n        run(self.dti)\n\n    def time_datetime_field_normalize(self):\n        @test_parallel(num_threads=2)\n        def run(dti):\n            dti.normalize()\n        run(self.dti)\n\n    def time_datetime_to_period(self):\n        @test_parallel(num_threads=2)\n        def run(dti):\n            dti.to_period('S')\n        run(self.dti)\n\n    def time_period_to_datetime(self):\n        @test_parallel(num_threads=2)\n        def run(period):\n            period.to_timestamp()\n        run(self.period)\n\n\nclass ParallelRolling(object):\n\n    goal_time = 0.2\n    params = ['median', 'mean', 'min', 'max', 'var', 'skew', 'kurt', 'std']\n    param_names = ['method']\n\n    def setup(self, method):\n        if not have_real_test_parallel:\n            raise NotImplementedError\n        win = 100\n        arr = np.random.rand(100000)\n        if hasattr(DataFrame, 'rolling'):\n            df = DataFrame(arr).rolling(win)\n\n            @test_parallel(num_threads=2)\n            def parallel_rolling():\n                getattr(df, method)()\n            self.parallel_rolling = parallel_rolling\n        elif have_rolling_methods:\n            rolling = {'median': rolling_median,\n                       'mean': rolling_mean,\n                       'min': rolling_min,\n                       'max': rolling_max,\n                       'var': rolling_var,\n                       'skew': rolling_skew,\n                       'kurt': rolling_kurt,\n                       'std': rolling_std}\n\n            @test_parallel(num_threads=2)\n            def parallel_rolling():\n                rolling[method](arr, win)\n            self.parallel_rolling = parallel_rolling\n        else:\n            raise NotImplementedError\n\n    def time_rolling(self, method):\n        self.parallel_rolling()\n\n\nclass ParallelReadCSV(BaseIO):\n\n    number = 1\n    repeat = 5\n    params = ['float', 'object', 'datetime']\n    param_names = ['dtype']\n\n    def setup(self, dtype):\n        if not have_real_test_parallel:\n            raise NotImplementedError\n        rows = 10000\n        cols = 50\n        data = {'float': DataFrame(np.random.randn(rows, cols)),\n                'datetime': DataFrame(np.random.randn(rows, cols),\n                                      index=date_range('1/1/2000',\n                                                       periods=rows)),\n                'object': DataFrame('foo',\n                                    index=range(rows),\n                                    columns=['object%03d'.format(i)\n                                             for i in range(5)])}\n\n        self.fname = '__test_{}__.csv'.format(dtype)\n        df = data[dtype]\n        df.to_csv(self.fname)\n\n        @test_parallel(num_threads=2)\n        def parallel_read_csv():\n            read_csv(self.fname)\n        self.parallel_read_csv = parallel_read_csv\n\n    def time_read_csv(self, dtype):\n        self.parallel_read_csv()\n\n\nclass ParallelFactorize(object):\n\n    number = 1\n    repeat = 5\n    params = [2, 4, 8]\n    param_names = ['threads']\n\n    def setup(self, threads):\n        if not have_real_test_parallel:\n            raise NotImplementedError\n\n        strings = tm.makeStringIndex(100000)\n\n        @test_parallel(num_threads=threads)\n        def parallel():\n            factorize(strings)\n        self.parallel = parallel\n\n        def loop():\n            factorize(strings)\n        self.loop = loop\n\n    def time_parallel(self, threads):\n        self.parallel()\n\n    def time_loop(self, threads):\n        for i in range(threads):\n            self.loop()\n", "description": "Flexible and powerful data analysis / manipulation library for Python, providing labeled data structures similar to R data.frame objects, statistical functions, and much more", "file_name": "gil.py", "id": "3b49824c09b1efd0d1738140f8d93487", "language": "Python", "project_name": "pandas", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/pandas-dev-pandas/pandas-dev-pandas-3783ccc/asv_bench/benchmarks/gil.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:47:21Z", "url": "https://github.com/pandas-dev/pandas", "wiki": true}