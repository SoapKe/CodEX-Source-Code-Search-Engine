{"author": "ansible", "code": "\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: rax_scaling_policy\nshort_description: Manipulate Rackspace Cloud Autoscale Scaling Policy\ndescription:\n    - Manipulate Rackspace Cloud Autoscale Scaling Policy\nversion_added: 1.7\noptions:\n  at:\n    description:\n      - The UTC time when this policy will be executed. The time must be\n        formatted according to C(yyyy-MM-dd'T'HH:mm:ss.SSS) such as\n        C(2013-05-19T08:07:08Z)\n  change:\n    description:\n      - The change, either as a number of servers or as a percentage, to make\n        in the scaling group. If this is a percentage, you must set\n        I(is_percent) to C(true) also.\n  cron:\n    description:\n      - The time when the policy will be executed, as a cron entry. For\n        example, if this is parameter is set to C(1 0 * * *)\n  cooldown:\n    description:\n      - The period of time, in seconds, that must pass before any scaling can\n        occur after the previous scaling. Must be an integer between 0 and\n        86400 (24 hrs).\n  desired_capacity:\n    description:\n      - The desired server capacity of the scaling the group; that is, how\n        many servers should be in the scaling group.\n  is_percent:\n    description:\n      - Whether the value in I(change) is a percent value\n    default: false\n  name:\n    description:\n      - Name to give the policy\n    required: true\n  policy_type:\n    description:\n      - The type of policy that will be executed for the current release.\n    choices:\n      - webhook\n      - schedule\n    required: true\n  scaling_group:\n    description:\n      - Name of the scaling group that this policy will be added to\n    required: true\n  state:\n    description:\n      - Indicate desired state of the resource\n    choices:\n      - present\n      - absent\n    default: present\nauthor: \"Matt Martz (@sivel)\"\nextends_documentation_fragment:\n  - rackspace\n  - rackspace.openstack\n'''\n\nEXAMPLES = '''\n---\n- hosts: localhost\n  gather_facts: false\n  connection: local\n  tasks:\n    - rax_scaling_policy:\n        credentials: ~/.raxpub\n        region: ORD\n        at: '2013-05-19T08:07:08Z'\n        change: 25\n        cooldown: 300\n        is_percent: true\n        name: ASG Test Policy - at\n        policy_type: schedule\n        scaling_group: ASG Test\n      register: asps_at\n\n    - rax_scaling_policy:\n        credentials: ~/.raxpub\n        region: ORD\n        cron: '1 0 * * *'\n        change: 25\n        cooldown: 300\n        is_percent: true\n        name: ASG Test Policy - cron\n        policy_type: schedule\n        scaling_group: ASG Test\n      register: asp_cron\n\n    - rax_scaling_policy:\n        credentials: ~/.raxpub\n        region: ORD\n        cooldown: 300\n        desired_capacity: 5\n        name: ASG Test Policy - webhook\n        policy_type: webhook\n        scaling_group: ASG Test\n      register: asp_webhook\n'''\n\ntry:\n    import pyrax\n    HAS_PYRAX = True\nexcept ImportError:\n    HAS_PYRAX = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.rax import (UUID, rax_argument_spec, rax_required_together, rax_to_dict,\n                                      setup_rax_module)\n\n\ndef rax_asp(module, at=None, change=0, cron=None, cooldown=300,\n            desired_capacity=0, is_percent=False, name=None,\n            policy_type=None, scaling_group=None, state='present'):\n    changed = False\n\n    au = pyrax.autoscale\n    if not au:\n        module.fail_json(msg='Failed to instantiate client. This '\n                             'typically indicates an invalid region or an '\n                             'incorrectly capitalized region name.')\n\n    try:\n        UUID(scaling_group)\n    except ValueError:\n        try:\n            sg = au.find(name=scaling_group)\n        except Exception as e:\n            module.fail_json(msg='%s' % e.message)\n    else:\n        try:\n            sg = au.get(scaling_group)\n        except Exception as e:\n            module.fail_json(msg='%s' % e.message)\n\n    if state == 'present':\n        policies = filter(lambda p: name == p.name, sg.list_policies())\n        if len(policies) > 1:\n            module.fail_json(msg='No unique policy match found by name')\n        if at:\n            args = dict(at=at)\n        elif cron:\n            args = dict(cron=cron)\n        else:\n            args = None\n\n        if not policies:\n            try:\n                policy = sg.add_policy(name, policy_type=policy_type,\n                                       cooldown=cooldown, change=change,\n                                       is_percent=is_percent,\n                                       desired_capacity=desired_capacity,\n                                       args=args)\n                changed = True\n            except Exception as e:\n                module.fail_json(msg='%s' % e.message)\n\n        else:\n            policy = policies[0]\n            kwargs = {}\n            if policy_type != policy.type:\n                kwargs['policy_type'] = policy_type\n\n            if cooldown != policy.cooldown:\n                kwargs['cooldown'] = cooldown\n\n            if hasattr(policy, 'change') and change != policy.change:\n                kwargs['change'] = change\n\n            if hasattr(policy, 'changePercent') and is_percent is False:\n                kwargs['change'] = change\n                kwargs['is_percent'] = False\n            elif hasattr(policy, 'change') and is_percent is True:\n                kwargs['change'] = change\n                kwargs['is_percent'] = True\n\n            if hasattr(policy, 'desiredCapacity') and change:\n                kwargs['change'] = change\n            elif ((hasattr(policy, 'change') or\n                    hasattr(policy, 'changePercent')) and desired_capacity):\n                kwargs['desired_capacity'] = desired_capacity\n\n            if hasattr(policy, 'args') and args != policy.args:\n                kwargs['args'] = args\n\n            if kwargs:\n                policy.update(**kwargs)\n                changed = True\n\n        policy.get()\n\n        module.exit_json(changed=changed, autoscale_policy=rax_to_dict(policy))\n\n    else:\n        try:\n            policies = filter(lambda p: name == p.name, sg.list_policies())\n            if len(policies) > 1:\n                module.fail_json(msg='No unique policy match found by name')\n            elif not policies:\n                policy = {}\n            else:\n                policy.delete()\n                changed = True\n        except Exception as e:\n            module.fail_json(msg='%s' % e.message)\n\n        module.exit_json(changed=changed, autoscale_policy=rax_to_dict(policy))\n\n\ndef main():\n    argument_spec = rax_argument_spec()\n    argument_spec.update(\n        dict(\n            at=dict(),\n            change=dict(type='int'),\n            cron=dict(),\n            cooldown=dict(type='int', default=300),\n            desired_capacity=dict(type='int'),\n            is_percent=dict(type='bool', default=False),\n            name=dict(required=True),\n            policy_type=dict(required=True, choices=['webhook', 'schedule']),\n            scaling_group=dict(required=True),\n            state=dict(default='present', choices=['present', 'absent']),\n        )\n    )\n\n    module = AnsibleModule(\n        argument_spec=argument_spec,\n        required_together=rax_required_together(),\n        mutually_exclusive=[\n            ['cron', 'at'],\n            ['change', 'desired_capacity'],\n        ]\n    )\n\n    if not HAS_PYRAX:\n        module.fail_json(msg='pyrax is required for this module')\n\n    at = module.params.get('at')\n    change = module.params.get('change')\n    cron = module.params.get('cron')\n    cooldown = module.params.get('cooldown')\n    desired_capacity = module.params.get('desired_capacity')\n    is_percent = module.params.get('is_percent')\n    name = module.params.get('name')\n    policy_type = module.params.get('policy_type')\n    scaling_group = module.params.get('scaling_group')\n    state = module.params.get('state')\n\n    if (at or cron) and policy_type == 'webhook':\n        module.fail_json(msg='policy_type=schedule is required for a time '\n                             'based policy')\n\n    setup_rax_module(module, pyrax)\n\n    rax_asp(module, at=at, change=change, cron=cron, cooldown=cooldown,\n            desired_capacity=desired_capacity, is_percent=is_percent,\n            name=name, policy_type=policy_type, scaling_group=scaling_group,\n            state=state)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  rax scaling policy short description  manipulate rackspace cloud autoscale scaling policy description        manipulate rackspace cloud autoscale scaling policy version added  1 7 options         description          the utc time policy executed  the time must         formatted according c(yyyy mm dd t hh mm ss sss)         c(2013 05 19t08 07 08z)   change      description          the change  either number servers percentage  make         scaling group  if percentage  must set         i(is percent) c(true) also    cron      description          the time policy executed  cron entry  for         example  parameter set c(1 0      )   cooldown      description          the period time  seconds  must pass scaling         occur previous scaling  must integer 0         86400 (24 hrs)    desired capacity      description          the desired server capacity scaling group           many servers scaling group    percent      description          whether value i(change) percent value     default  false   name      description          name give policy     required  true   policy type      description          the type policy executed current release      choices          webhook         schedule     required  true   scaling group      description          name scaling group policy added     required  true   state      description          indicate desired state resource     choices          present         absent     default  present author   matt martz ( sivel)  extends documentation fragment      rackspace     rackspace openstack      examples             hosts  localhost   gather facts  false   connection  local   tasks        rax scaling policy          credentials     raxpub         region  ord           2013 05 19t08 07 08z          change  25         cooldown  300         percent  true         name  asg test policy           policy type  schedule         scaling group  asg test       register  asps        rax scaling policy          credentials     raxpub         region  ord         cron   1 0                change  25         cooldown  300         percent  true         name  asg test policy   cron         policy type  schedule         scaling group  asg test       register  asp cron        rax scaling policy          credentials     raxpub         region  ord         cooldown  300         desired capacity  5         name  asg test policy   webhook         policy type  webhook         scaling group  asg test       register  asp webhook         usr bin python    copyright  ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt) ", "content": "#!/usr/bin/python\n# Copyright: Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: rax_scaling_policy\nshort_description: Manipulate Rackspace Cloud Autoscale Scaling Policy\ndescription:\n    - Manipulate Rackspace Cloud Autoscale Scaling Policy\nversion_added: 1.7\noptions:\n  at:\n    description:\n      - The UTC time when this policy will be executed. The time must be\n        formatted according to C(yyyy-MM-dd'T'HH:mm:ss.SSS) such as\n        C(2013-05-19T08:07:08Z)\n  change:\n    description:\n      - The change, either as a number of servers or as a percentage, to make\n        in the scaling group. If this is a percentage, you must set\n        I(is_percent) to C(true) also.\n  cron:\n    description:\n      - The time when the policy will be executed, as a cron entry. For\n        example, if this is parameter is set to C(1 0 * * *)\n  cooldown:\n    description:\n      - The period of time, in seconds, that must pass before any scaling can\n        occur after the previous scaling. Must be an integer between 0 and\n        86400 (24 hrs).\n  desired_capacity:\n    description:\n      - The desired server capacity of the scaling the group; that is, how\n        many servers should be in the scaling group.\n  is_percent:\n    description:\n      - Whether the value in I(change) is a percent value\n    default: false\n  name:\n    description:\n      - Name to give the policy\n    required: true\n  policy_type:\n    description:\n      - The type of policy that will be executed for the current release.\n    choices:\n      - webhook\n      - schedule\n    required: true\n  scaling_group:\n    description:\n      - Name of the scaling group that this policy will be added to\n    required: true\n  state:\n    description:\n      - Indicate desired state of the resource\n    choices:\n      - present\n      - absent\n    default: present\nauthor: \"Matt Martz (@sivel)\"\nextends_documentation_fragment:\n  - rackspace\n  - rackspace.openstack\n'''\n\nEXAMPLES = '''\n---\n- hosts: localhost\n  gather_facts: false\n  connection: local\n  tasks:\n    - rax_scaling_policy:\n        credentials: ~/.raxpub\n        region: ORD\n        at: '2013-05-19T08:07:08Z'\n        change: 25\n        cooldown: 300\n        is_percent: true\n        name: ASG Test Policy - at\n        policy_type: schedule\n        scaling_group: ASG Test\n      register: asps_at\n\n    - rax_scaling_policy:\n        credentials: ~/.raxpub\n        region: ORD\n        cron: '1 0 * * *'\n        change: 25\n        cooldown: 300\n        is_percent: true\n        name: ASG Test Policy - cron\n        policy_type: schedule\n        scaling_group: ASG Test\n      register: asp_cron\n\n    - rax_scaling_policy:\n        credentials: ~/.raxpub\n        region: ORD\n        cooldown: 300\n        desired_capacity: 5\n        name: ASG Test Policy - webhook\n        policy_type: webhook\n        scaling_group: ASG Test\n      register: asp_webhook\n'''\n\ntry:\n    import pyrax\n    HAS_PYRAX = True\nexcept ImportError:\n    HAS_PYRAX = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.rax import (UUID, rax_argument_spec, rax_required_together, rax_to_dict,\n                                      setup_rax_module)\n\n\ndef rax_asp(module, at=None, change=0, cron=None, cooldown=300,\n            desired_capacity=0, is_percent=False, name=None,\n            policy_type=None, scaling_group=None, state='present'):\n    changed = False\n\n    au = pyrax.autoscale\n    if not au:\n        module.fail_json(msg='Failed to instantiate client. This '\n                             'typically indicates an invalid region or an '\n                             'incorrectly capitalized region name.')\n\n    try:\n        UUID(scaling_group)\n    except ValueError:\n        try:\n            sg = au.find(name=scaling_group)\n        except Exception as e:\n            module.fail_json(msg='%s' % e.message)\n    else:\n        try:\n            sg = au.get(scaling_group)\n        except Exception as e:\n            module.fail_json(msg='%s' % e.message)\n\n    if state == 'present':\n        policies = filter(lambda p: name == p.name, sg.list_policies())\n        if len(policies) > 1:\n            module.fail_json(msg='No unique policy match found by name')\n        if at:\n            args = dict(at=at)\n        elif cron:\n            args = dict(cron=cron)\n        else:\n            args = None\n\n        if not policies:\n            try:\n                policy = sg.add_policy(name, policy_type=policy_type,\n                                       cooldown=cooldown, change=change,\n                                       is_percent=is_percent,\n                                       desired_capacity=desired_capacity,\n                                       args=args)\n                changed = True\n            except Exception as e:\n                module.fail_json(msg='%s' % e.message)\n\n        else:\n            policy = policies[0]\n            kwargs = {}\n            if policy_type != policy.type:\n                kwargs['policy_type'] = policy_type\n\n            if cooldown != policy.cooldown:\n                kwargs['cooldown'] = cooldown\n\n            if hasattr(policy, 'change') and change != policy.change:\n                kwargs['change'] = change\n\n            if hasattr(policy, 'changePercent') and is_percent is False:\n                kwargs['change'] = change\n                kwargs['is_percent'] = False\n            elif hasattr(policy, 'change') and is_percent is True:\n                kwargs['change'] = change\n                kwargs['is_percent'] = True\n\n            if hasattr(policy, 'desiredCapacity') and change:\n                kwargs['change'] = change\n            elif ((hasattr(policy, 'change') or\n                    hasattr(policy, 'changePercent')) and desired_capacity):\n                kwargs['desired_capacity'] = desired_capacity\n\n            if hasattr(policy, 'args') and args != policy.args:\n                kwargs['args'] = args\n\n            if kwargs:\n                policy.update(**kwargs)\n                changed = True\n\n        policy.get()\n\n        module.exit_json(changed=changed, autoscale_policy=rax_to_dict(policy))\n\n    else:\n        try:\n            policies = filter(lambda p: name == p.name, sg.list_policies())\n            if len(policies) > 1:\n                module.fail_json(msg='No unique policy match found by name')\n            elif not policies:\n                policy = {}\n            else:\n                policy.delete()\n                changed = True\n        except Exception as e:\n            module.fail_json(msg='%s' % e.message)\n\n        module.exit_json(changed=changed, autoscale_policy=rax_to_dict(policy))\n\n\ndef main():\n    argument_spec = rax_argument_spec()\n    argument_spec.update(\n        dict(\n            at=dict(),\n            change=dict(type='int'),\n            cron=dict(),\n            cooldown=dict(type='int', default=300),\n            desired_capacity=dict(type='int'),\n            is_percent=dict(type='bool', default=False),\n            name=dict(required=True),\n            policy_type=dict(required=True, choices=['webhook', 'schedule']),\n            scaling_group=dict(required=True),\n            state=dict(default='present', choices=['present', 'absent']),\n        )\n    )\n\n    module = AnsibleModule(\n        argument_spec=argument_spec,\n        required_together=rax_required_together(),\n        mutually_exclusive=[\n            ['cron', 'at'],\n            ['change', 'desired_capacity'],\n        ]\n    )\n\n    if not HAS_PYRAX:\n        module.fail_json(msg='pyrax is required for this module')\n\n    at = module.params.get('at')\n    change = module.params.get('change')\n    cron = module.params.get('cron')\n    cooldown = module.params.get('cooldown')\n    desired_capacity = module.params.get('desired_capacity')\n    is_percent = module.params.get('is_percent')\n    name = module.params.get('name')\n    policy_type = module.params.get('policy_type')\n    scaling_group = module.params.get('scaling_group')\n    state = module.params.get('state')\n\n    if (at or cron) and policy_type == 'webhook':\n        module.fail_json(msg='policy_type=schedule is required for a time '\n                             'based policy')\n\n    setup_rax_module(module, pyrax)\n\n    rax_asp(module, at=at, change=change, cron=cron, cooldown=cooldown,\n            desired_capacity=desired_capacity, is_percent=is_percent,\n            name=name, policy_type=policy_type, scaling_group=scaling_group,\n            state=state)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "rax_scaling_policy.py", "id": "bd0de1c31cf19539f5b6b3a433da86db", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/cloud/rackspace/rax_scaling_policy.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}