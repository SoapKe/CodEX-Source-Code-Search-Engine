{"author": "fxsjy", "code": "from __future__ import absolute_import, unicode_literals\nimport re\nimport os\nimport sys\nimport pickle\nfrom .._compat import *\n\nMIN_FLOAT = -3.14e100\n\nPROB_START_P = \"prob_start.p\"\nPROB_TRANS_P = \"prob_trans.p\"\nPROB_EMIT_P = \"prob_emit.p\"\n\n\nPrevStatus = {\n    'B': 'ES',\n    'M': 'MB',\n    'S': 'SE',\n    'E': 'BM'\n}\n\nForce_Split_Words = set([])\ndef load_model():\n    start_p = pickle.load(get_module_res(\"finalseg\", PROB_START_P))\n    trans_p = pickle.load(get_module_res(\"finalseg\", PROB_TRANS_P))\n    emit_p = pickle.load(get_module_res(\"finalseg\", PROB_EMIT_P))\n    return start_p, trans_p, emit_p\n\nif sys.platform.startswith(\"java\"):\n    start_P, trans_P, emit_P = load_model()\nelse:\n    from .prob_start import P as start_P\n    from .prob_trans import P as trans_P\n    from .prob_emit import P as emit_P\n\n\ndef viterbi(obs, states, start_p, trans_p, emit_p):\n    V = [{}]  \n    path = {}\n    for y in states:  \n        V[0][y] = start_p[y] + emit_p[y].get(obs[0], MIN_FLOAT)\n        path[y] = [y]\n    for t in xrange(1, len(obs)):\n        V.append({})\n        newpath = {}\n        for y in states:\n            em_p = emit_p[y].get(obs[t], MIN_FLOAT)\n            (prob, state) = max(\n                [(V[t - 1][y0] + trans_p[y0].get(y, MIN_FLOAT) + em_p, y0) for y0 in PrevStatus[y]])\n            V[t][y] = prob\n            newpath[y] = path[state] + [y]\n        path = newpath\n\n    (prob, state) = max((V[len(obs) - 1][y], y) for y in 'ES')\n\n    return (prob, path[state])\n\n\ndef __cut(sentence):\n    global emit_P\n    prob, pos_list = viterbi(sentence, 'BMES', start_P, trans_P, emit_P)\n    begin, nexti = 0, 0\n    \n    for i, char in enumerate(sentence):\n        pos = pos_list[i]\n        if pos == 'B':\n            begin = i\n        elif pos == 'E':\n            yield sentence[begin:i + 1]\n            nexti = i + 1\n        elif pos == 'S':\n            yield char\n            nexti = i + 1\n    if nexti < len(sentence):\n        yield sentence[nexti:]\n\nre_han = re.compile(\"([\\u4E00-\\u9FD5]+)\")\nre_skip = re.compile(\"([a-zA-Z0-9]+(?:\\.\\d+)?%?)\")\n\n\ndef add_force_split(word):\n    global Force_Split_Words\n    Force_Split_Words.add(word)\n\ndef cut(sentence):\n    sentence = strdecode(sentence)\n    blocks = re_han.split(sentence)\n    for blk in blocks:\n        if re_han.match(blk):\n            for word in __cut(blk):\n                if word not in Force_Split_Words:\n                    yield word\n                else:\n                    for c in word:\n                        yield c\n        else:\n            tmp = re_skip.split(blk)\n            for x in tmp:\n                if x:\n                    yield x\n", "comments": "  tabular    init    print pos list  sentence ", "content": "from __future__ import absolute_import, unicode_literals\nimport re\nimport os\nimport sys\nimport pickle\nfrom .._compat import *\n\nMIN_FLOAT = -3.14e100\n\nPROB_START_P = \"prob_start.p\"\nPROB_TRANS_P = \"prob_trans.p\"\nPROB_EMIT_P = \"prob_emit.p\"\n\n\nPrevStatus = {\n    'B': 'ES',\n    'M': 'MB',\n    'S': 'SE',\n    'E': 'BM'\n}\n\nForce_Split_Words = set([])\ndef load_model():\n    start_p = pickle.load(get_module_res(\"finalseg\", PROB_START_P))\n    trans_p = pickle.load(get_module_res(\"finalseg\", PROB_TRANS_P))\n    emit_p = pickle.load(get_module_res(\"finalseg\", PROB_EMIT_P))\n    return start_p, trans_p, emit_p\n\nif sys.platform.startswith(\"java\"):\n    start_P, trans_P, emit_P = load_model()\nelse:\n    from .prob_start import P as start_P\n    from .prob_trans import P as trans_P\n    from .prob_emit import P as emit_P\n\n\ndef viterbi(obs, states, start_p, trans_p, emit_p):\n    V = [{}]  # tabular\n    path = {}\n    for y in states:  # init\n        V[0][y] = start_p[y] + emit_p[y].get(obs[0], MIN_FLOAT)\n        path[y] = [y]\n    for t in xrange(1, len(obs)):\n        V.append({})\n        newpath = {}\n        for y in states:\n            em_p = emit_p[y].get(obs[t], MIN_FLOAT)\n            (prob, state) = max(\n                [(V[t - 1][y0] + trans_p[y0].get(y, MIN_FLOAT) + em_p, y0) for y0 in PrevStatus[y]])\n            V[t][y] = prob\n            newpath[y] = path[state] + [y]\n        path = newpath\n\n    (prob, state) = max((V[len(obs) - 1][y], y) for y in 'ES')\n\n    return (prob, path[state])\n\n\ndef __cut(sentence):\n    global emit_P\n    prob, pos_list = viterbi(sentence, 'BMES', start_P, trans_P, emit_P)\n    begin, nexti = 0, 0\n    # print pos_list, sentence\n    for i, char in enumerate(sentence):\n        pos = pos_list[i]\n        if pos == 'B':\n            begin = i\n        elif pos == 'E':\n            yield sentence[begin:i + 1]\n            nexti = i + 1\n        elif pos == 'S':\n            yield char\n            nexti = i + 1\n    if nexti < len(sentence):\n        yield sentence[nexti:]\n\nre_han = re.compile(\"([\\u4E00-\\u9FD5]+)\")\nre_skip = re.compile(\"([a-zA-Z0-9]+(?:\\.\\d+)?%?)\")\n\n\ndef add_force_split(word):\n    global Force_Split_Words\n    Force_Split_Words.add(word)\n\ndef cut(sentence):\n    sentence = strdecode(sentence)\n    blocks = re_han.split(sentence)\n    for blk in blocks:\n        if re_han.match(blk):\n            for word in __cut(blk):\n                if word not in Force_Split_Words:\n                    yield word\n                else:\n                    for c in word:\n                        yield c\n        else:\n            tmp = re_skip.split(blk)\n            for x in tmp:\n                if x:\n                    yield x\n", "description": "\u7ed3\u5df4\u4e2d\u6587\u5206\u8bcd", "file_name": "__init__.py", "id": "d33748874f6b53e03442690b91546d59", "language": "Python", "project_name": "jieba", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/fxsjy-jieba/fxsjy-jieba-cb0de29/jieba/finalseg/__init__.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:12:20Z", "url": "https://github.com/fxsjy/jieba", "wiki": true}