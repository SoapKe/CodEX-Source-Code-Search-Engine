{"author": "mitmproxy", "code": "import pytest\nfrom unittest import mock\n\nfrom mitmproxy import log\nfrom mitmproxy import controller\nfrom mitmproxy import options\nfrom mitmproxy.tools import dump\n\nfrom .. import tservers\n\n\nclass TestDumpMaster(tservers.MasterTest):\n    def mkmaster(self, **opts):\n        o = options.Options(**opts)\n        m = dump.DumpMaster(o, with_termlog=False, with_dumper=False)\n        return m\n\n    def test_has_error(self):\n        m = self.mkmaster()\n        ent = log.LogEntry(\"foo\", \"error\")\n        ent.reply = controller.DummyReply()\n        m.addons.trigger(\"log\", ent)\n        assert m.errorcheck.has_errored\n\n    @pytest.mark.parametrize(\"termlog\", [False, True])\n    def test_addons_termlog(self, termlog):\n        with mock.patch('sys.stdout'):\n            o = options.Options()\n            m = dump.DumpMaster(o, with_termlog=termlog)\n            assert (m.addons.get('termlog') is not None) == termlog\n\n    @pytest.mark.parametrize(\"dumper\", [False, True])\n    def test_addons_dumper(self, dumper):\n        with mock.patch('sys.stdout'):\n            o = options.Options()\n            m = dump.DumpMaster(o, with_dumper=dumper)\n            assert (m.addons.get('dumper') is not None) == dumper\n", "comments": "", "content": "import pytest\nfrom unittest import mock\n\nfrom mitmproxy import log\nfrom mitmproxy import controller\nfrom mitmproxy import options\nfrom mitmproxy.tools import dump\n\nfrom .. import tservers\n\n\nclass TestDumpMaster(tservers.MasterTest):\n    def mkmaster(self, **opts):\n        o = options.Options(**opts)\n        m = dump.DumpMaster(o, with_termlog=False, with_dumper=False)\n        return m\n\n    def test_has_error(self):\n        m = self.mkmaster()\n        ent = log.LogEntry(\"foo\", \"error\")\n        ent.reply = controller.DummyReply()\n        m.addons.trigger(\"log\", ent)\n        assert m.errorcheck.has_errored\n\n    @pytest.mark.parametrize(\"termlog\", [False, True])\n    def test_addons_termlog(self, termlog):\n        with mock.patch('sys.stdout'):\n            o = options.Options()\n            m = dump.DumpMaster(o, with_termlog=termlog)\n            assert (m.addons.get('termlog') is not None) == termlog\n\n    @pytest.mark.parametrize(\"dumper\", [False, True])\n    def test_addons_dumper(self, dumper):\n        with mock.patch('sys.stdout'):\n            o = options.Options()\n            m = dump.DumpMaster(o, with_dumper=dumper)\n            assert (m.addons.get('dumper') is not None) == dumper\n", "description": "An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers.", "file_name": "test_dump.py", "id": "964046bfc40ee5586121a958f9bd40f2", "language": "Python", "project_name": "mitmproxy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mitmproxy-mitmproxy/mitmproxy-mitmproxy-3c7725a/test/mitmproxy/tools/test_dump.py", "save_time": "", "source": "", "update_at": "2018-03-18T11:30:56Z", "url": "https://github.com/mitmproxy/mitmproxy", "wiki": false}