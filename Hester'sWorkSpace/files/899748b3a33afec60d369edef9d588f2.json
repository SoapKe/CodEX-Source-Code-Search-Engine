{"author": "python-telegram-bot", "code": "\n# -*- coding: utf-8 -*-\n\n\n\"\"\"Simple Bot to send timed Telegram messages.\n\n\n\nThis Bot uses the Updater class to handle the bot and the JobQueue to send\ntimed messages.\n\nFirst, a few handler functions are defined. Then, those functions are passed to\nthe Dispatcher and registered at their respective places.\nThen, the bot is started and runs until we press Ctrl-C on the command line.\n\nUsage:\nBasic Alarm Bot example, sends a message after a set time.\nPress Ctrl-C on the command line or send a signal to the process to stop the\nbot.\n\"\"\"\n\nfrom telegram.ext import Updater, CommandHandler\nimport logging\n\n\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n                    level=logging.INFO)\n\nlogger = logging.getLogger(__name__)\n\n\n\n\ndef start(bot, update):\n    update.message.reply_text('Hi! Use /set <seconds> to set a timer')\n\n\ndef alarm(bot, job):\n    \"\"\"Send the alarm message.\"\"\"\n    bot.send_message(job.context, text='Beep!')\n\n\ndef set_timer(bot, update, args, job_queue, chat_data):\n    \"\"\"Add a job to the queue.\"\"\"\n    chat_id = update.message.chat_id\n    try:\n        # args[0] should contain the time for the timer in seconds\n        due = int(args[0])\n        if due < 0:\n            update.message.reply_text('Sorry we can not go back to future!')\n            return\n\n        \n        job = job_queue.run_once(alarm, due, context=chat_id)\n        chat_data['job'] = job\n\n        update.message.reply_text('Timer successfully set!')\n\n    except (IndexError, ValueError):\n        update.message.reply_text('Usage: /set <seconds>')\n\n\ndef unset(bot, update, chat_data):\n    \"\"\"Remove the job if the user changed their mind.\"\"\"\n    if 'job' not in chat_data:\n        update.message.reply_text('You have no active timer')\n        return\n\n    job = chat_data['job']\n    job.schedule_removal()\n    del chat_data['job']\n\n    update.message.reply_text('Timer successfully unset!')\n\n\ndef error(bot, update, error):\n    \"\"\"Log Errors caused by Updates.\"\"\"\n    logger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\n\ndef main():\n    \"\"\"Run bot.\"\"\"\n    updater = Updater(\"TOKEN\")\n\n    \n    dp = updater.dispatcher\n\n    \n    dp.add_handler(CommandHandler(\"start\", start))\n    dp.add_handler(CommandHandler(\"help\", start))\n    dp.add_handler(CommandHandler(\"set\", set_timer,\n                                  pass_args=True,\n                                  pass_job_queue=True,\n                                  pass_chat_data=True))\n    dp.add_handler(CommandHandler(\"unset\", unset, pass_chat_data=True))\n\n    \n    dp.add_error_handler(error)\n\n    \n    updater.start_polling()\n\n    \n    # SIGABRT. This should be used most of the time, since start_polling() is\n    \n    updater.idle()\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "   simple bot send timed telegram messages     this program dedicated public domain cc0 license   this bot uses updater class handle bot jobqueue send timed messages   first  handler functions defined  then  functions passed dispatcher registered respective places  then  bot started runs press ctrl c command line   usage  basic alarm bot example  sends message set time  press ctrl c command line send signal process stop bot       telegram ext import updater  commandhandler import logging    enable logging logging basicconfig(format   (asctime)s    (name)s    (levelname)s    (message)s                       level logging info)  logger   logging getlogger(  name  )     define command handlers  these usually take two arguments bot   update  error handlers also receive raised telegramerror object error  def start(bot  update)      update message reply text( hi  use  set  seconds  set timer )   def alarm(bot  job)         send alarm message         bot send message(job context  text  beep  )   def set timer(bot  update  args  job queue  chat data)         add job queue         chat id   update message chat id     try            args 0  contain time timer seconds         due   int(args 0 )         due   0              update message reply text( sorry go back future  )             return            add job queue         job   job queue run once(alarm  due  context chat id)         chat data  job     job          update message reply text( timer successfully set  )      except (indexerror  valueerror)          update message reply text( usage   set  seconds  )   def unset(bot  update  chat data)         remove job user changed mind          job  chat data          update message reply text( you active timer )         return      job   chat data  job       job schedule removal()     del chat data  job        update message reply text( timer successfully unset  )   def error(bot  update  error)         log errors caused updates         logger warning( update    caused error      update  error)   def main()         run bot         usr bin env python        coding  utf 8        this program dedicated public domain cc0 license     enable logging    define command handlers  these usually take two arguments bot    update  error handlers also receive raised telegramerror object error     args 0  contain time timer seconds    add job queue    get dispatcher register handlers    different commands   answer telegram    log errors    start bot    block press ctrl c process receives sigint  sigterm    sigabrt  this used time  since start polling()    non blocking stop bot gracefully  ", "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\n\"\"\"Simple Bot to send timed Telegram messages.\n\n# This program is dedicated to the public domain under the CC0 license.\n\nThis Bot uses the Updater class to handle the bot and the JobQueue to send\ntimed messages.\n\nFirst, a few handler functions are defined. Then, those functions are passed to\nthe Dispatcher and registered at their respective places.\nThen, the bot is started and runs until we press Ctrl-C on the command line.\n\nUsage:\nBasic Alarm Bot example, sends a message after a set time.\nPress Ctrl-C on the command line or send a signal to the process to stop the\nbot.\n\"\"\"\n\nfrom telegram.ext import Updater, CommandHandler\nimport logging\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n                    level=logging.INFO)\n\nlogger = logging.getLogger(__name__)\n\n\n# Define a few command handlers. These usually take the two arguments bot and\n# update. Error handlers also receive the raised TelegramError object in error.\ndef start(bot, update):\n    update.message.reply_text('Hi! Use /set <seconds> to set a timer')\n\n\ndef alarm(bot, job):\n    \"\"\"Send the alarm message.\"\"\"\n    bot.send_message(job.context, text='Beep!')\n\n\ndef set_timer(bot, update, args, job_queue, chat_data):\n    \"\"\"Add a job to the queue.\"\"\"\n    chat_id = update.message.chat_id\n    try:\n        # args[0] should contain the time for the timer in seconds\n        due = int(args[0])\n        if due < 0:\n            update.message.reply_text('Sorry we can not go back to future!')\n            return\n\n        # Add job to queue\n        job = job_queue.run_once(alarm, due, context=chat_id)\n        chat_data['job'] = job\n\n        update.message.reply_text('Timer successfully set!')\n\n    except (IndexError, ValueError):\n        update.message.reply_text('Usage: /set <seconds>')\n\n\ndef unset(bot, update, chat_data):\n    \"\"\"Remove the job if the user changed their mind.\"\"\"\n    if 'job' not in chat_data:\n        update.message.reply_text('You have no active timer')\n        return\n\n    job = chat_data['job']\n    job.schedule_removal()\n    del chat_data['job']\n\n    update.message.reply_text('Timer successfully unset!')\n\n\ndef error(bot, update, error):\n    \"\"\"Log Errors caused by Updates.\"\"\"\n    logger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\n\ndef main():\n    \"\"\"Run bot.\"\"\"\n    updater = Updater(\"TOKEN\")\n\n    # Get the dispatcher to register handlers\n    dp = updater.dispatcher\n\n    # on different commands - answer in Telegram\n    dp.add_handler(CommandHandler(\"start\", start))\n    dp.add_handler(CommandHandler(\"help\", start))\n    dp.add_handler(CommandHandler(\"set\", set_timer,\n                                  pass_args=True,\n                                  pass_job_queue=True,\n                                  pass_chat_data=True))\n    dp.add_handler(CommandHandler(\"unset\", unset, pass_chat_data=True))\n\n    # log all errors\n    dp.add_error_handler(error)\n\n    # Start the Bot\n    updater.start_polling()\n\n    # Block until you press Ctrl-C or the process receives SIGINT, SIGTERM or\n    # SIGABRT. This should be used most of the time, since start_polling() is\n    # non-blocking and will stop the bot gracefully.\n    updater.idle()\n\n\nif __name__ == '__main__':\n    main()\n", "description": "We have made you a wrapper you can't refuse", "file_name": "timerbot.py", "id": "899748b3a33afec60d369edef9d588f2", "language": "Python", "project_name": "python-telegram-bot", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/python-telegram-bot-python-telegram-bot/python-telegram-bot-python-telegram-bot-3ccf40e/examples/timerbot.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:32:55Z", "url": "https://github.com/python-telegram-bot/python-telegram-bot", "wiki": true}