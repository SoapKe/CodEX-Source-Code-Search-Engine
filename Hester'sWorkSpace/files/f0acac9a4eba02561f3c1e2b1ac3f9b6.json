{"author": "ansible", "code": "\n# -*- coding: utf-8 -*-\n# Copyright (c) 2018 Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'network'}\n\n\nDOCUMENTATION = \"\"\"\n---\nmodule: edgeos_facts\nversion_added: \"2.5\"\nauthor:\n    - Nathaniel Case (@qalthos)\n    - Sam Doran (@samdoran)\nshort_description: Collect facts from remote devices running EdgeOS\ndescription:\n  - Collects a base set of device facts from a remote device that\n    is running EdgeOS. This module prepends all of the\n    base network fact keys with U(ansible_net_<fact>). The facts\n    module will always collect a base set of facts from the device\n    and can enable or disable collection of additional facts.\nnotes:\n  - Tested against EdgeOS 1.9.7\noptions:\n  gather_subset:\n    description:\n      - When supplied, this argument will restrict the facts collected\n        to a given subset. Possible values for this argument include\n        all, default, config, and neighbors. Can specify a list of\n        values to include a larger subset. Values can also be used\n        with an initial C(M(!)) to specify that a specific subset should\n        not be collected.\n    required: false\n    default: \"!config\"\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: collect all facts from the device\n  edgeos_facts:\n    gather_subset: all\n\n- name: collect only the config and default facts\n  edgeos_facts:\n    gather_subset: config\n\n- name: collect everything exception the config\n  edgeos_facts:\n    gather_subset: \"!config\"\n\"\"\"\n\nRETURN = \"\"\"\nansible_net_config:\n  description: The running-config from the device\n  returned: when config is configured\n  type: str\nansible_net_commits:\n  description: The set of available configuration revisions\n  returned: when present\n  type: list\nansible_net_hostname:\n  description: The configured system hostname\n  returned: always\n  type: str\nansible_net_model:\n  description: The device model string\n  returned: always\n  type: str\nansible_net_serialnum:\n  description: The serial number of the device\n  returned: always\n  type: str\nansible_net_version:\n  description: The version of the software running\n  returned: always\n  type: str\nansible_net_neighbors:\n  description: The set of LLDP neighbors\n  returned: when interface is configured\n  type: list\nansible_net_gather_subset:\n  description: The list of subsets gathered by the module\n  returned: always\n  type: list\n\"\"\"\n\nimport re\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.six import iteritems\nfrom ansible.module_utils.network.edgeos.edgeos import run_commands\n\n\nclass FactsBase(object):\n\n    COMMANDS = frozenset()\n\n    def __init__(self, module):\n        self.module = module\n        self.facts = dict()\n        self.responses = None\n\n    def populate(self):\n        self.responses = run_commands(self.module, list(self.COMMANDS))\n\n\nclass Default(FactsBase):\n\n    COMMANDS = [\n        'show version',\n        'show host name',\n    ]\n\n    def populate(self):\n        super(Default, self).populate()\n        data = self.responses[0]\n\n        self.facts['version'] = self.parse_version(data)\n        self.facts['serialnum'] = self.parse_serialnum(data)\n        self.facts['model'] = self.parse_model(data)\n\n        self.facts['hostname'] = self.responses[1]\n\n    def parse_version(self, data):\n        match = re.search(r'Version:\\s*v(\\S+)', data)\n        if match:\n            return match.group(1)\n\n    def parse_model(self, data):\n        match = re.search(r'HW model:\\s*([A-Za-z0-9- ]+)', data)\n        if match:\n            return match.group(1)\n\n    def parse_serialnum(self, data):\n        match = re.search(r'HW S/N:\\s+(\\S+)', data)\n        if match:\n            return match.group(1)\n\n\nclass Config(FactsBase):\n\n    COMMANDS = [\n        'show configuration commands',\n        'show system commit',\n    ]\n\n    def populate(self):\n        super(Config, self).populate()\n\n        self.facts['config'] = self.responses\n\n        commits = self.responses[1]\n        entries = list()\n        entry = None\n\n        for line in commits.split('\\n'):\n            match = re.match(r'(\\d+)\\s+(.+)by(.+)via(.+)', line)\n            if match:\n                if entry:\n                    entries.append(entry)\n\n                entry = dict(revision=match.group(1),\n                             datetime=match.group(2),\n                             by=str(match.group(3)).strip(),\n                             via=str(match.group(4)).strip(),\n                             comment=None)\n            elif entry:\n                entry['comment'] = line.strip()\n\n        self.facts['commits'] = entries\n\n\nclass Neighbors(FactsBase):\n\n    COMMANDS = [\n        'show lldp neighbors',\n        'show lldp neighbors detail',\n    ]\n\n    def populate(self):\n        super(Neighbors, self).populate()\n\n        all_neighbors = self.responses[0]\n        if 'LLDP not configured' not in all_neighbors:\n            neighbors = self.parse(\n                self.responses[1]\n            )\n            self.facts['neighbors'] = self.parse_neighbors(neighbors)\n\n    def parse(self, data):\n        parsed = list()\n        values = None\n        for line in data.split('\\n'):\n            if not line:\n                continue\n            elif line[0] == ' ':\n                values += '\\n%s' % line\n            elif line.startswith('Interface'):\n                if values:\n                    parsed.append(values)\n                values = line\n        if values:\n            parsed.append(values)\n        return parsed\n\n    def parse_neighbors(self, data):\n        facts = dict()\n        for item in data:\n            interface = self.parse_interface(item)\n            host = self.parse_host(item)\n            port = self.parse_port(item)\n            if interface not in facts:\n                facts[interface] = list()\n            facts[interface].append(dict(host=host, port=port))\n        return facts\n\n    def parse_interface(self, data):\n        match = re.search(r'^Interface:\\s+(\\S+),', data)\n        return match.group(1)\n\n    def parse_host(self, data):\n        match = re.search(r'SysName:\\s+(.+)$', data, re.M)\n        if match:\n            return match.group(1)\n\n    def parse_port(self, data):\n        match = re.search(r'PortDescr:\\s+(.+)$', data, re.M)\n        if match:\n            return match.group(1)\n\n\nFACT_SUBSETS = dict(\n    default=Default,\n    neighbors=Neighbors,\n    config=Config\n)\n\nVALID_SUBSETS = frozenset(FACT_SUBSETS.keys())\n\n\ndef main():\n    spec = dict(\n        gather_subset=dict(default=['!config'], type='list')\n    )\n\n    module = AnsibleModule(argument_spec=spec,\n                           supports_check_mode=True)\n\n    warnings = list()\n\n    gather_subset = module.params['gather_subset']\n\n    runable_subsets = set()\n    exclude_subsets = set()\n\n    for subset in gather_subset:\n        if subset == 'all':\n            runable_subsets.update(VALID_SUBSETS)\n            continue\n\n        if subset.startswith('!'):\n            subset = subset[1:]\n            if subset == 'all':\n                exclude_subsets.update(VALID_SUBSETS)\n                continue\n            exclude = True\n        else:\n            exclude = False\n\n        if subset not in VALID_SUBSETS:\n            module.fail_json(msg='Subset must be one of [%s], got %s' %\n                             (', '.join(VALID_SUBSETS), subset))\n\n        if exclude:\n            exclude_subsets.add(subset)\n        else:\n            runable_subsets.add(subset)\n\n    if not runable_subsets:\n        runable_subsets.update(VALID_SUBSETS)\n\n    runable_subsets.difference_update(exclude_subsets)\n    runable_subsets.add('default')\n\n    facts = dict()\n    facts['gather_subset'] = list(runable_subsets)\n\n    instances = list()\n    for key in runable_subsets:\n        instances.append(FACT_SUBSETS[key](module))\n\n    for inst in instances:\n        inst.populate()\n        facts.update(inst.facts)\n\n    ansible_facts = dict()\n    for key, value in iteritems(facts):\n        key = 'ansible_net_%s' % key\n        ansible_facts[key] = value\n\n    module.exit_json(ansible_facts=ansible_facts, warnings=warnings)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  edgeos facts version added   2 5  author        nathaniel case ( qalthos)       sam doran ( samdoran) short description  collect facts remote devices running edgeos description      collects base set device facts remote device     running edgeos  this module prepends     base network fact keys u(ansible net  fact )  the facts     module always collect base set facts device     enable disable collection additional facts  notes      tested edgeos 1 9 7 options    gather subset      description          when supplied  argument restrict facts collected         given subset  possible values argument include          default  config  neighbors  can specify list         values include larger subset  values also used         initial c(m( )) specify specific subset         collected      required  false     default    config       examples         name  collect facts device   edgeos facts      gather subset     name  collect config default facts   edgeos facts      gather subset  config    name  collect everything exception config   edgeos facts      gather subset    config       return       ansible net config    description  the running config device   returned  config configured   type  str ansible net commits    description  the set available configuration revisions   returned  present   type  list ansible net hostname    description  the configured system hostname   returned  always   type  str ansible net model    description  the device model string   returned  always   type  str ansible net serialnum    description  the serial number device   returned  always   type  str ansible net version    description  the version software running   returned  always   type  str ansible net neighbors    description  the set lldp neighbors   returned  interface configured   type  list ansible net gather subset    description  the list subsets gathered module   returned  always   type  list         usr bin python        coding  utf 8        copyright (c) 2018 ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt) ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n# Copyright (c) 2018 Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'network'}\n\n\nDOCUMENTATION = \"\"\"\n---\nmodule: edgeos_facts\nversion_added: \"2.5\"\nauthor:\n    - Nathaniel Case (@qalthos)\n    - Sam Doran (@samdoran)\nshort_description: Collect facts from remote devices running EdgeOS\ndescription:\n  - Collects a base set of device facts from a remote device that\n    is running EdgeOS. This module prepends all of the\n    base network fact keys with U(ansible_net_<fact>). The facts\n    module will always collect a base set of facts from the device\n    and can enable or disable collection of additional facts.\nnotes:\n  - Tested against EdgeOS 1.9.7\noptions:\n  gather_subset:\n    description:\n      - When supplied, this argument will restrict the facts collected\n        to a given subset. Possible values for this argument include\n        all, default, config, and neighbors. Can specify a list of\n        values to include a larger subset. Values can also be used\n        with an initial C(M(!)) to specify that a specific subset should\n        not be collected.\n    required: false\n    default: \"!config\"\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: collect all facts from the device\n  edgeos_facts:\n    gather_subset: all\n\n- name: collect only the config and default facts\n  edgeos_facts:\n    gather_subset: config\n\n- name: collect everything exception the config\n  edgeos_facts:\n    gather_subset: \"!config\"\n\"\"\"\n\nRETURN = \"\"\"\nansible_net_config:\n  description: The running-config from the device\n  returned: when config is configured\n  type: str\nansible_net_commits:\n  description: The set of available configuration revisions\n  returned: when present\n  type: list\nansible_net_hostname:\n  description: The configured system hostname\n  returned: always\n  type: str\nansible_net_model:\n  description: The device model string\n  returned: always\n  type: str\nansible_net_serialnum:\n  description: The serial number of the device\n  returned: always\n  type: str\nansible_net_version:\n  description: The version of the software running\n  returned: always\n  type: str\nansible_net_neighbors:\n  description: The set of LLDP neighbors\n  returned: when interface is configured\n  type: list\nansible_net_gather_subset:\n  description: The list of subsets gathered by the module\n  returned: always\n  type: list\n\"\"\"\n\nimport re\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.six import iteritems\nfrom ansible.module_utils.network.edgeos.edgeos import run_commands\n\n\nclass FactsBase(object):\n\n    COMMANDS = frozenset()\n\n    def __init__(self, module):\n        self.module = module\n        self.facts = dict()\n        self.responses = None\n\n    def populate(self):\n        self.responses = run_commands(self.module, list(self.COMMANDS))\n\n\nclass Default(FactsBase):\n\n    COMMANDS = [\n        'show version',\n        'show host name',\n    ]\n\n    def populate(self):\n        super(Default, self).populate()\n        data = self.responses[0]\n\n        self.facts['version'] = self.parse_version(data)\n        self.facts['serialnum'] = self.parse_serialnum(data)\n        self.facts['model'] = self.parse_model(data)\n\n        self.facts['hostname'] = self.responses[1]\n\n    def parse_version(self, data):\n        match = re.search(r'Version:\\s*v(\\S+)', data)\n        if match:\n            return match.group(1)\n\n    def parse_model(self, data):\n        match = re.search(r'HW model:\\s*([A-Za-z0-9- ]+)', data)\n        if match:\n            return match.group(1)\n\n    def parse_serialnum(self, data):\n        match = re.search(r'HW S/N:\\s+(\\S+)', data)\n        if match:\n            return match.group(1)\n\n\nclass Config(FactsBase):\n\n    COMMANDS = [\n        'show configuration commands',\n        'show system commit',\n    ]\n\n    def populate(self):\n        super(Config, self).populate()\n\n        self.facts['config'] = self.responses\n\n        commits = self.responses[1]\n        entries = list()\n        entry = None\n\n        for line in commits.split('\\n'):\n            match = re.match(r'(\\d+)\\s+(.+)by(.+)via(.+)', line)\n            if match:\n                if entry:\n                    entries.append(entry)\n\n                entry = dict(revision=match.group(1),\n                             datetime=match.group(2),\n                             by=str(match.group(3)).strip(),\n                             via=str(match.group(4)).strip(),\n                             comment=None)\n            elif entry:\n                entry['comment'] = line.strip()\n\n        self.facts['commits'] = entries\n\n\nclass Neighbors(FactsBase):\n\n    COMMANDS = [\n        'show lldp neighbors',\n        'show lldp neighbors detail',\n    ]\n\n    def populate(self):\n        super(Neighbors, self).populate()\n\n        all_neighbors = self.responses[0]\n        if 'LLDP not configured' not in all_neighbors:\n            neighbors = self.parse(\n                self.responses[1]\n            )\n            self.facts['neighbors'] = self.parse_neighbors(neighbors)\n\n    def parse(self, data):\n        parsed = list()\n        values = None\n        for line in data.split('\\n'):\n            if not line:\n                continue\n            elif line[0] == ' ':\n                values += '\\n%s' % line\n            elif line.startswith('Interface'):\n                if values:\n                    parsed.append(values)\n                values = line\n        if values:\n            parsed.append(values)\n        return parsed\n\n    def parse_neighbors(self, data):\n        facts = dict()\n        for item in data:\n            interface = self.parse_interface(item)\n            host = self.parse_host(item)\n            port = self.parse_port(item)\n            if interface not in facts:\n                facts[interface] = list()\n            facts[interface].append(dict(host=host, port=port))\n        return facts\n\n    def parse_interface(self, data):\n        match = re.search(r'^Interface:\\s+(\\S+),', data)\n        return match.group(1)\n\n    def parse_host(self, data):\n        match = re.search(r'SysName:\\s+(.+)$', data, re.M)\n        if match:\n            return match.group(1)\n\n    def parse_port(self, data):\n        match = re.search(r'PortDescr:\\s+(.+)$', data, re.M)\n        if match:\n            return match.group(1)\n\n\nFACT_SUBSETS = dict(\n    default=Default,\n    neighbors=Neighbors,\n    config=Config\n)\n\nVALID_SUBSETS = frozenset(FACT_SUBSETS.keys())\n\n\ndef main():\n    spec = dict(\n        gather_subset=dict(default=['!config'], type='list')\n    )\n\n    module = AnsibleModule(argument_spec=spec,\n                           supports_check_mode=True)\n\n    warnings = list()\n\n    gather_subset = module.params['gather_subset']\n\n    runable_subsets = set()\n    exclude_subsets = set()\n\n    for subset in gather_subset:\n        if subset == 'all':\n            runable_subsets.update(VALID_SUBSETS)\n            continue\n\n        if subset.startswith('!'):\n            subset = subset[1:]\n            if subset == 'all':\n                exclude_subsets.update(VALID_SUBSETS)\n                continue\n            exclude = True\n        else:\n            exclude = False\n\n        if subset not in VALID_SUBSETS:\n            module.fail_json(msg='Subset must be one of [%s], got %s' %\n                             (', '.join(VALID_SUBSETS), subset))\n\n        if exclude:\n            exclude_subsets.add(subset)\n        else:\n            runable_subsets.add(subset)\n\n    if not runable_subsets:\n        runable_subsets.update(VALID_SUBSETS)\n\n    runable_subsets.difference_update(exclude_subsets)\n    runable_subsets.add('default')\n\n    facts = dict()\n    facts['gather_subset'] = list(runable_subsets)\n\n    instances = list()\n    for key in runable_subsets:\n        instances.append(FACT_SUBSETS[key](module))\n\n    for inst in instances:\n        inst.populate()\n        facts.update(inst.facts)\n\n    ansible_facts = dict()\n    for key, value in iteritems(facts):\n        key = 'ansible_net_%s' % key\n        ansible_facts[key] = value\n\n    module.exit_json(ansible_facts=ansible_facts, warnings=warnings)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "edgeos_facts.py", "id": "f0acac9a4eba02561f3c1e2b1ac3f9b6", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/network/edgeos/edgeos_facts.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}