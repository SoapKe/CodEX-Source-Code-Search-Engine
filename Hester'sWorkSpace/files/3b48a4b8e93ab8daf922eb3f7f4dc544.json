{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom odoo import api, fields, models, _\nfrom datetime import datetime\n\n\nclass CrmTeam(models.Model):\n    _inherit = 'crm.team'\n\n    team_type = fields.Selection(selection_add=[('pos', 'Point of Sale')])\n    pos_config_ids = fields.One2many('pos.config', 'crm_team_id', string=\"Point of Sales\")\n    pos_sessions_open_count = fields.Integer(string='Open POS Sessions', compute='_compute_pos_sessions_open_count')\n    pos_order_amount_total = fields.Float(string=\"Session Sale Amount\", compute='_compute_pos_order_amount_total')\n    dashboard_graph_group_pos = fields.Selection([\n        ('day', 'Day'),\n        ('week', 'Week'),\n        ('month', 'Month'),\n        ('user', 'Salesperson'),\n        ('pos', 'Point of Sale'),\n    ], string='Group by', default='day', help=\"How this channel's dashboard graph will group the results.\")\n\n    @api.onchange('dashboard_graph_group_pos')\n    def _onchange_dashboard_graph_group_pos(self):\n        if self.dashboard_graph_group_pos == 'pos':\n            self.dashboard_graph_group = False\n        else:\n            self.dashboard_graph_group = self.dashboard_graph_group_pos\n\n    def _compute_pos_sessions_open_count(self):\n        for team in self.filtered(lambda t: t.team_type == 'pos'):\n            team.pos_sessions_open_count = self.env['pos.session'].search_count([('config_id.crm_team_id', '=', team.id), ('state', '=', 'opened')])\n\n    def _compute_pos_order_amount_total(self):\n        for team in self.filtered(lambda t: t.team_type == 'pos'):\n            team.pos_order_amount_total = sum(self.env['report.pos.order'].search(\n                [('session_id', 'in', team.pos_config_ids.mapped('session_ids').filtered(lambda s: s.state == 'opened').ids)]\n            ).mapped('price_total'))\n\n    def _graph_data(self, start_date, end_date):\n        \"\"\" If the type of the sales team is point of sale ('pos'), the graph will display the sales data.\n            The override here is to get data from pos.order instead of sale.order.\n        \"\"\"\n        if self.team_type == 'pos':\n            result = []\n            if self.dashboard_graph_group_pos == 'pos':\n                order_data = self.env['report.pos.order'].read_group(\n                    domain=[\n                        ('date', '>=', fields.Date.to_string(start_date)),\n                        ('date', '<=', fields.Datetime.to_string(datetime.combine(end_date, datetime.max.time()))),\n                        ('config_id', 'in', self.pos_config_ids.ids),\n                        ('state', 'in', ['paid', 'done', 'invoiced'])],\n                    fields=['config_id', 'price_total'],\n                    groupby=['config_id']\n                )\n                appended_config_ids = set()\n                for data_point in order_data:\n                    result.append({'x_value': self.env['pos.config'].browse(data_point.get('config_id')[0]).name, 'y_value': data_point.get('price_total')})\n                    appended_config_ids.add(data_point.get('config_id'))\n                for config_id in set(self.pos_config_ids.ids) - appended_config_ids:\n                    result.append({'x_value': self.env['pos.config'].browse(config_id).name, 'y_value': 0})\n\n            elif self.dashboard_graph_group_pos == 'user':\n                order_data = self.env['report.pos.order'].read_group(\n                    domain=[\n                        ('date', '>=', fields.Date.to_string(start_date)),\n                        ('date', '<=', fields.Datetime.to_string(datetime.combine(end_date, datetime.max.time()))),\n                        ('config_id', 'in', self.pos_config_ids.ids),\n                        ('state', 'in', ['paid', 'done', 'invoiced'])],\n                    fields=['user_id', 'price_total'],\n                    groupby=['user_id']\n                )\n                for data_point in order_data:\n                    result.append({'x_value': data_point.get('user_id')[0], 'y_value': data_point.get('price_total')})\n\n            else:\n                \n                # /!\\ do not use en_US as it's not ISO-standard and does not match datetime's library\n                order_data = self.env['report.pos.order'].with_context(lang='en_GB').read_group(\n                    domain=[\n                        ('date', '>=', fields.Date.to_string(start_date)),\n                        ('date', '<=', fields.Datetime.to_string(datetime.combine(end_date, datetime.max.time()))),\n                        ('config_id', 'in', self.pos_config_ids.ids),\n                        ('state', 'in', ['paid', 'done', 'invoiced'])],\n                    fields=['date', 'price_total'],\n                    groupby=['date:' + self.dashboard_graph_group_pos]\n                )\n                if self.dashboard_graph_group_pos == 'day':\n                    for data_point in order_data:\n                        result.append({'x_value': fields.Date.to_string((fields.datetime.strptime(data_point.get('date:day'), \"%d %b %Y\"))), 'y_value': data_point.get('price_total')})\n                elif self.dashboard_graph_group_pos == 'week':\n                    for data_point in order_data:\n                        result.append({'x_value': int(data_point.get('date:week')[1:3]), 'y_value': data_point.get('price_total')})\n                elif self.dashboard_graph_group_pos == 'month':\n                    for data_point in order_data:\n                        result.append({'x_value': fields.datetime.strptime(data_point.get('date:month'), \"%B %Y\").month, 'y_value': data_point.get('price_total')})\n            return result\n\n        return super(CrmTeam, self)._graph_data(start_date, end_date)\n\n    def _compute_dashboard_button_name(self):\n        pos_teams = self.filtered(lambda team: team.team_type == 'pos')\n        pos_teams.update({'dashboard_button_name': _(\"Dashboard\")})\n        super(CrmTeam, self - pos_teams)._compute_dashboard_button_name()\n\n    def action_primary_channel_button(self):\n        if self.team_type == 'pos':\n            action = self.env.ref('point_of_sale.action_pos_config_kanban').read()[0]\n            action['context'] = {'search_default_crm_team_id': self.id}\n            return action\n        return super(CrmTeam, self).action_primary_channel_button()\n\n    def _graph_title_and_key(self):\n        if self.team_type == 'pos':\n            return ['', _('Sales: Untaxed Amount')] \n        return super(CrmTeam, self)._graph_title_and_key()\n", "comments": "    if type sales team point sale ( pos )  graph display sales data              the override get data pos order instead sale order                     coding  utf 8        part odoo  see license file full copyright licensing details     locale en gb used able obtain datetime string returned read group        use en us iso standard match datetime library    title ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom odoo import api, fields, models, _\nfrom datetime import datetime\n\n\nclass CrmTeam(models.Model):\n    _inherit = 'crm.team'\n\n    team_type = fields.Selection(selection_add=[('pos', 'Point of Sale')])\n    pos_config_ids = fields.One2many('pos.config', 'crm_team_id', string=\"Point of Sales\")\n    pos_sessions_open_count = fields.Integer(string='Open POS Sessions', compute='_compute_pos_sessions_open_count')\n    pos_order_amount_total = fields.Float(string=\"Session Sale Amount\", compute='_compute_pos_order_amount_total')\n    dashboard_graph_group_pos = fields.Selection([\n        ('day', 'Day'),\n        ('week', 'Week'),\n        ('month', 'Month'),\n        ('user', 'Salesperson'),\n        ('pos', 'Point of Sale'),\n    ], string='Group by', default='day', help=\"How this channel's dashboard graph will group the results.\")\n\n    @api.onchange('dashboard_graph_group_pos')\n    def _onchange_dashboard_graph_group_pos(self):\n        if self.dashboard_graph_group_pos == 'pos':\n            self.dashboard_graph_group = False\n        else:\n            self.dashboard_graph_group = self.dashboard_graph_group_pos\n\n    def _compute_pos_sessions_open_count(self):\n        for team in self.filtered(lambda t: t.team_type == 'pos'):\n            team.pos_sessions_open_count = self.env['pos.session'].search_count([('config_id.crm_team_id', '=', team.id), ('state', '=', 'opened')])\n\n    def _compute_pos_order_amount_total(self):\n        for team in self.filtered(lambda t: t.team_type == 'pos'):\n            team.pos_order_amount_total = sum(self.env['report.pos.order'].search(\n                [('session_id', 'in', team.pos_config_ids.mapped('session_ids').filtered(lambda s: s.state == 'opened').ids)]\n            ).mapped('price_total'))\n\n    def _graph_data(self, start_date, end_date):\n        \"\"\" If the type of the sales team is point of sale ('pos'), the graph will display the sales data.\n            The override here is to get data from pos.order instead of sale.order.\n        \"\"\"\n        if self.team_type == 'pos':\n            result = []\n            if self.dashboard_graph_group_pos == 'pos':\n                order_data = self.env['report.pos.order'].read_group(\n                    domain=[\n                        ('date', '>=', fields.Date.to_string(start_date)),\n                        ('date', '<=', fields.Datetime.to_string(datetime.combine(end_date, datetime.max.time()))),\n                        ('config_id', 'in', self.pos_config_ids.ids),\n                        ('state', 'in', ['paid', 'done', 'invoiced'])],\n                    fields=['config_id', 'price_total'],\n                    groupby=['config_id']\n                )\n                appended_config_ids = set()\n                for data_point in order_data:\n                    result.append({'x_value': self.env['pos.config'].browse(data_point.get('config_id')[0]).name, 'y_value': data_point.get('price_total')})\n                    appended_config_ids.add(data_point.get('config_id'))\n                for config_id in set(self.pos_config_ids.ids) - appended_config_ids:\n                    result.append({'x_value': self.env['pos.config'].browse(config_id).name, 'y_value': 0})\n\n            elif self.dashboard_graph_group_pos == 'user':\n                order_data = self.env['report.pos.order'].read_group(\n                    domain=[\n                        ('date', '>=', fields.Date.to_string(start_date)),\n                        ('date', '<=', fields.Datetime.to_string(datetime.combine(end_date, datetime.max.time()))),\n                        ('config_id', 'in', self.pos_config_ids.ids),\n                        ('state', 'in', ['paid', 'done', 'invoiced'])],\n                    fields=['user_id', 'price_total'],\n                    groupby=['user_id']\n                )\n                for data_point in order_data:\n                    result.append({'x_value': data_point.get('user_id')[0], 'y_value': data_point.get('price_total')})\n\n            else:\n                # locale en_GB is used to be able to obtain the datetime from the string returned by read_group\n                # /!\\ do not use en_US as it's not ISO-standard and does not match datetime's library\n                order_data = self.env['report.pos.order'].with_context(lang='en_GB').read_group(\n                    domain=[\n                        ('date', '>=', fields.Date.to_string(start_date)),\n                        ('date', '<=', fields.Datetime.to_string(datetime.combine(end_date, datetime.max.time()))),\n                        ('config_id', 'in', self.pos_config_ids.ids),\n                        ('state', 'in', ['paid', 'done', 'invoiced'])],\n                    fields=['date', 'price_total'],\n                    groupby=['date:' + self.dashboard_graph_group_pos]\n                )\n                if self.dashboard_graph_group_pos == 'day':\n                    for data_point in order_data:\n                        result.append({'x_value': fields.Date.to_string((fields.datetime.strptime(data_point.get('date:day'), \"%d %b %Y\"))), 'y_value': data_point.get('price_total')})\n                elif self.dashboard_graph_group_pos == 'week':\n                    for data_point in order_data:\n                        result.append({'x_value': int(data_point.get('date:week')[1:3]), 'y_value': data_point.get('price_total')})\n                elif self.dashboard_graph_group_pos == 'month':\n                    for data_point in order_data:\n                        result.append({'x_value': fields.datetime.strptime(data_point.get('date:month'), \"%B %Y\").month, 'y_value': data_point.get('price_total')})\n            return result\n\n        return super(CrmTeam, self)._graph_data(start_date, end_date)\n\n    def _compute_dashboard_button_name(self):\n        pos_teams = self.filtered(lambda team: team.team_type == 'pos')\n        pos_teams.update({'dashboard_button_name': _(\"Dashboard\")})\n        super(CrmTeam, self - pos_teams)._compute_dashboard_button_name()\n\n    def action_primary_channel_button(self):\n        if self.team_type == 'pos':\n            action = self.env.ref('point_of_sale.action_pos_config_kanban').read()[0]\n            action['context'] = {'search_default_crm_team_id': self.id}\n            return action\n        return super(CrmTeam, self).action_primary_channel_button()\n\n    def _graph_title_and_key(self):\n        if self.team_type == 'pos':\n            return ['', _('Sales: Untaxed Amount')] # no more title\n        return super(CrmTeam, self)._graph_title_and_key()\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "crm_team.py", "id": "3b48a4b8e93ab8daf922eb3f7f4dc544", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/pos_sale/models/crm_team.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}