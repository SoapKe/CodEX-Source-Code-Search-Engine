{"author": "localstack", "code": "import unittest\nimport json\nfrom localstack.services.awslambda import lambda_api, lambda_executors\nfrom localstack.utils.aws.aws_models import LambdaFunction\n\n\nclass TestLambdaAPI(unittest.TestCase):\n    CODE_SIZE = 50\n    HANDLER = 'index.handler'\n    RUNTIME = 'node.js4.3'\n    TIMEOUT = 60  \n    FUNCTION_NAME = 'test1'\n    ALIAS_NAME = 'alias1'\n    ALIAS2_NAME = 'alias2'\n    RESOURCENOTFOUND_EXCEPTION = 'ResourceNotFoundException'\n    RESOURCENOTFOUND_MESSAGE = 'Function not found: %s'\n    ALIASEXISTS_EXCEPTION = 'ResourceConflictException'\n    ALIASEXISTS_MESSAGE = 'Alias already exists: %s'\n    ALIASNOTFOUND_EXCEPTION = 'ResourceNotFoundException'\n    ALIASNOTFOUND_MESSAGE = 'Alias not found: %s'\n    TEST_UUID = 'Test'\n\n    def setUp(self):\n        lambda_api.cleanup()\n        self.maxDiff = None\n        self.app = lambda_api.app\n        self.app.testing = True\n        self.client = self.app.test_client()\n\n    def test_get_event_source_mapping(self):\n        with self.app.test_request_context():\n            lambda_api.event_source_mappings.append({'UUID': self.TEST_UUID})\n            result = lambda_api.get_event_source_mapping(self.TEST_UUID)\n            self.assertEqual(json.loads(result.get_data()).get('UUID'), self.TEST_UUID)\n\n    def test_delete_event_source_mapping(self):\n        with self.app.test_request_context():\n            lambda_api.event_source_mappings.append({'UUID': self.TEST_UUID})\n            result = lambda_api.delete_event_source_mapping(self.TEST_UUID)\n            self.assertEqual(json.loads(result.get_data()).get('UUID'), self.TEST_UUID)\n            self.assertEqual(0, len(lambda_api.event_source_mappings))\n\n    def test_publish_function_version(self):\n        with self.app.test_request_context():\n            self._create_function(self.FUNCTION_NAME)\n\n            result = json.loads(lambda_api.publish_version(self.FUNCTION_NAME).get_data())\n            result2 = json.loads(lambda_api.publish_version(self.FUNCTION_NAME).get_data())\n\n            expected_result = dict()\n            expected_result['CodeSize'] = self.CODE_SIZE\n            expected_result['FunctionArn'] = str(lambda_api.func_arn(self.FUNCTION_NAME)) + ':1'\n            expected_result['FunctionName'] = str(self.FUNCTION_NAME)\n            expected_result['Handler'] = str(self.HANDLER)\n            expected_result['Runtime'] = str(self.RUNTIME)\n            expected_result['Timeout'] = self.TIMEOUT\n            expected_result['Version'] = '1'\n            expected_result['Environment'] = {}\n            expected_result2 = dict(expected_result)\n            expected_result2['FunctionArn'] = str(lambda_api.func_arn(self.FUNCTION_NAME)) + ':2'\n            expected_result2['Version'] = '2'\n            expected_result2['Environment'] = {}\n            self.assertDictEqual(expected_result, result)\n            self.assertDictEqual(expected_result2, result2)\n\n    def test_publish_non_existant_function_version_returns_error(self):\n        with self.app.test_request_context():\n            result = json.loads(lambda_api.publish_version(self.FUNCTION_NAME).get_data())\n            self.assertEqual(self.RESOURCENOTFOUND_EXCEPTION, result['__type'])\n            self.assertEqual(self.RESOURCENOTFOUND_MESSAGE % lambda_api.func_arn(self.FUNCTION_NAME),\n                             result['message'])\n\n    def test_list_function_versions(self):\n        with self.app.test_request_context():\n            self._create_function(self.FUNCTION_NAME)\n            lambda_api.publish_version(self.FUNCTION_NAME)\n            lambda_api.publish_version(self.FUNCTION_NAME)\n\n            result = json.loads(lambda_api.list_versions(self.FUNCTION_NAME).get_data())\n\n            latest_version = dict()\n            latest_version['CodeSize'] = self.CODE_SIZE\n            latest_version['FunctionArn'] = str(lambda_api.func_arn(self.FUNCTION_NAME)) + ':$LATEST'\n            latest_version['FunctionName'] = str(self.FUNCTION_NAME)\n            latest_version['Handler'] = str(self.HANDLER)\n            latest_version['Runtime'] = str(self.RUNTIME)\n            latest_version['Timeout'] = self.TIMEOUT\n            latest_version['Version'] = '$LATEST'\n            latest_version['Environment'] = {}\n            version1 = dict(latest_version)\n            version1['FunctionArn'] = str(lambda_api.func_arn(self.FUNCTION_NAME)) + ':1'\n            version1['Version'] = '1'\n            version1['Environment'] = {}\n            version2 = dict(latest_version)\n            version2['FunctionArn'] = str(lambda_api.func_arn(self.FUNCTION_NAME)) + ':2'\n            version2['Version'] = '2'\n            version2['Environment'] = {}\n            expected_result = {'Versions': sorted([latest_version, version1, version2],\n                                                  key=lambda k: str(k.get('Version')))}\n            self.assertDictEqual(expected_result, result)\n\n    def test_list_non_existant_function_versions_returns_error(self):\n        with self.app.test_request_context():\n            result = json.loads(lambda_api.list_versions(self.FUNCTION_NAME).get_data())\n            self.assertEqual(self.RESOURCENOTFOUND_EXCEPTION, result['__type'])\n            self.assertEqual(self.RESOURCENOTFOUND_MESSAGE % lambda_api.func_arn(self.FUNCTION_NAME),\n                             result['message'])\n\n    def test_create_alias(self):\n        self._create_function(self.FUNCTION_NAME)\n        self.client.post('{0}/functions/{1}/versions'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME))\n\n        response = self.client.post('{0}/functions/{1}/aliases'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME),\n                         data=json.dumps({'Name': self.ALIAS_NAME, 'FunctionVersion': '1',\n                             'Description': ''}))\n        result = json.loads(response.get_data())\n\n        expected_result = {'AliasArn': lambda_api.func_arn(self.FUNCTION_NAME) + ':' + self.ALIAS_NAME,\n                           'FunctionVersion': '1', 'Description': '', 'Name': self.ALIAS_NAME}\n        self.assertDictEqual(expected_result, result)\n\n    def test_create_alias_on_non_existant_function_returns_error(self):\n        with self.app.test_request_context():\n            result = json.loads(lambda_api.create_alias(self.FUNCTION_NAME).get_data())\n            self.assertEqual(self.RESOURCENOTFOUND_EXCEPTION, result['__type'])\n            self.assertEqual(self.RESOURCENOTFOUND_MESSAGE % lambda_api.func_arn(self.FUNCTION_NAME),\n                             result['message'])\n\n    def test_create_alias_returns_error_if_already_exists(self):\n        self._create_function(self.FUNCTION_NAME)\n        self.client.post('{0}/functions/{1}/versions'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME))\n        data = json.dumps({'Name': self.ALIAS_NAME, 'FunctionVersion': '1', 'Description': ''})\n        self.client.post('{0}/functions/{1}/aliases'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME), data=data)\n\n        response = self.client.post('{0}/functions/{1}/aliases'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME),\n                                    data=data)\n        result = json.loads(response.get_data())\n\n        alias_arn = lambda_api.func_arn(self.FUNCTION_NAME) + ':' + self.ALIAS_NAME\n        self.assertEqual(self.ALIASEXISTS_EXCEPTION, result['__type'])\n        self.assertEqual(self.ALIASEXISTS_MESSAGE % alias_arn,\n                         result['message'])\n\n    def test_update_alias(self):\n        self._create_function(self.FUNCTION_NAME)\n        self.client.post('{0}/functions/{1}/versions'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME))\n        self.client.post('{0}/functions/{1}/aliases'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME),\n                         data=json.dumps({\n                             'Name': self.ALIAS_NAME, 'FunctionVersion': '1', 'Description': ''}))\n\n        response = self.client.put('{0}/functions/{1}/aliases/{2}'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME,\n                                                                          self.ALIAS_NAME),\n                                   data=json.dumps({'FunctionVersion': '$LATEST', 'Description': 'Test-Description'}))\n        result = json.loads(response.get_data())\n\n        expected_result = {'AliasArn': lambda_api.func_arn(self.FUNCTION_NAME) + ':' + self.ALIAS_NAME,\n                           'FunctionVersion': '$LATEST', 'Description': 'Test-Description',\n                           'Name': self.ALIAS_NAME}\n        self.assertDictEqual(expected_result, result)\n\n    def test_update_alias_on_non_existant_function_returns_error(self):\n        with self.app.test_request_context():\n            result = json.loads(lambda_api.update_alias(self.FUNCTION_NAME, self.ALIAS_NAME).get_data())\n            self.assertEqual(self.RESOURCENOTFOUND_EXCEPTION, result['__type'])\n            self.assertEqual(self.RESOURCENOTFOUND_MESSAGE % lambda_api.func_arn(self.FUNCTION_NAME),\n                             result['message'])\n\n    def test_update_alias_on_non_existant_alias_returns_error(self):\n        with self.app.test_request_context():\n            self._create_function(self.FUNCTION_NAME)\n            result = json.loads(lambda_api.update_alias(self.FUNCTION_NAME, self.ALIAS_NAME).get_data())\n            alias_arn = lambda_api.func_arn(self.FUNCTION_NAME) + ':' + self.ALIAS_NAME\n            self.assertEqual(self.ALIASNOTFOUND_EXCEPTION, result['__type'])\n            self.assertEqual(self.ALIASNOTFOUND_MESSAGE % alias_arn, result['message'])\n\n    def test_list_aliases(self):\n        self._create_function(self.FUNCTION_NAME)\n        self.client.post('{0}/functions/{1}/versions'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME))\n\n        self.client.post('{0}/functions/{1}/aliases'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME),\n                         data=json.dumps({'Name': self.ALIAS2_NAME, 'FunctionVersion': '$LATEST'}))\n        self.client.post('{0}/functions/{1}/aliases'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME),\n                         data=json.dumps({'Name': self.ALIAS_NAME, 'FunctionVersion': '1',\n                                          'Description': self.ALIAS_NAME}))\n\n        response = self.client.get('{0}/functions/{1}/aliases'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME))\n        result = json.loads(response.get_data())\n        expected_result = {'Aliases': [\n            {\n                'AliasArn': lambda_api.func_arn(self.FUNCTION_NAME) + ':' + self.ALIAS_NAME,\n                'FunctionVersion': '1',\n                'Name': self.ALIAS_NAME,\n                'Description': self.ALIAS_NAME\n            },\n            {\n                'AliasArn': lambda_api.func_arn(self.FUNCTION_NAME) + ':' + self.ALIAS2_NAME,\n                'FunctionVersion': '$LATEST',\n                'Name': self.ALIAS2_NAME,\n                'Description': ''\n            }\n        ]}\n        self.assertDictEqual(expected_result, result)\n\n    def test_list_non_existant_function_aliases_returns_error(self):\n        with self.app.test_request_context():\n            result = json.loads(lambda_api.list_aliases(self.FUNCTION_NAME).get_data())\n            self.assertEqual(self.RESOURCENOTFOUND_EXCEPTION, result['__type'])\n            self.assertEqual(self.RESOURCENOTFOUND_MESSAGE % lambda_api.func_arn(self.FUNCTION_NAME),\n                             result['message'])\n\n    def test_get_container_name(self):\n        executor = lambda_executors.EXECUTOR_CONTAINERS_REUSE\n        name = executor.get_container_name('arn:aws:lambda:us-east-1:00000000:function:my_function_name')\n        self.assertEqual(name, 'localstack_lambda_arn_aws_lambda_us-east-1_00000000_function_my_function_name')\n\n    def test_put_concurrency(self):\n        with self.app.test_request_context():\n            self._create_function(self.FUNCTION_NAME)\n            \n            \n            \n            concurrency_data = {'ReservedConcurrentExecutions': 10}\n            response = self.client.put('/2017-10-31/functions/{0}/concurrency'.format(self.FUNCTION_NAME),\n                                       data=json.dumps(concurrency_data))\n\n            result = json.loads(response.get_data())\n            self.assertDictEqual(concurrency_data, result)\n\n    def test_concurrency_get_function(self):\n        with self.app.test_request_context():\n            self._create_function(self.FUNCTION_NAME)\n            \n            \n            \n            concurrency_data = {'ReservedConcurrentExecutions': 10}\n            self.client.put('/2017-10-31/functions/{0}/concurrency'.format(self.FUNCTION_NAME),\n                            data=json.dumps(concurrency_data))\n\n            response = self.client.get('{0}/functions/{1}'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME))\n\n            result = json.loads(response.get_data())\n            self.assertTrue('Concurrency' in result)\n            self.assertDictEqual(concurrency_data, result['Concurrency'])\n\n    def _create_function(self, function_name):\n        arn = lambda_api.func_arn(function_name)\n        lambda_api.arn_to_lambda[arn] = LambdaFunction(arn)\n        lambda_api.arn_to_lambda[arn].versions = {'$LATEST': {'CodeSize': self.CODE_SIZE}}\n        lambda_api.arn_to_lambda[arn].handler = self.HANDLER\n        lambda_api.arn_to_lambda[arn].runtime = self.RUNTIME\n        lambda_api.arn_to_lambda[arn].timeout = self.TIMEOUT\n        lambda_api.arn_to_lambda[arn].envvars = {}\n", "comments": "  default value  hardcoded    note  putfunctionconcurrency mounted   2017 10 31    not lambda api path root    https   docs aws amazon com lambda latest dg api putfunctionconcurrency html    note  putfunctionconcurrency mounted   2017 10 31    not lambda api path root    https   docs aws amazon com lambda latest dg api putfunctionconcurrency html ", "content": "import unittest\nimport json\nfrom localstack.services.awslambda import lambda_api, lambda_executors\nfrom localstack.utils.aws.aws_models import LambdaFunction\n\n\nclass TestLambdaAPI(unittest.TestCase):\n    CODE_SIZE = 50\n    HANDLER = 'index.handler'\n    RUNTIME = 'node.js4.3'\n    TIMEOUT = 60  # Default value, hardcoded\n    FUNCTION_NAME = 'test1'\n    ALIAS_NAME = 'alias1'\n    ALIAS2_NAME = 'alias2'\n    RESOURCENOTFOUND_EXCEPTION = 'ResourceNotFoundException'\n    RESOURCENOTFOUND_MESSAGE = 'Function not found: %s'\n    ALIASEXISTS_EXCEPTION = 'ResourceConflictException'\n    ALIASEXISTS_MESSAGE = 'Alias already exists: %s'\n    ALIASNOTFOUND_EXCEPTION = 'ResourceNotFoundException'\n    ALIASNOTFOUND_MESSAGE = 'Alias not found: %s'\n    TEST_UUID = 'Test'\n\n    def setUp(self):\n        lambda_api.cleanup()\n        self.maxDiff = None\n        self.app = lambda_api.app\n        self.app.testing = True\n        self.client = self.app.test_client()\n\n    def test_get_event_source_mapping(self):\n        with self.app.test_request_context():\n            lambda_api.event_source_mappings.append({'UUID': self.TEST_UUID})\n            result = lambda_api.get_event_source_mapping(self.TEST_UUID)\n            self.assertEqual(json.loads(result.get_data()).get('UUID'), self.TEST_UUID)\n\n    def test_delete_event_source_mapping(self):\n        with self.app.test_request_context():\n            lambda_api.event_source_mappings.append({'UUID': self.TEST_UUID})\n            result = lambda_api.delete_event_source_mapping(self.TEST_UUID)\n            self.assertEqual(json.loads(result.get_data()).get('UUID'), self.TEST_UUID)\n            self.assertEqual(0, len(lambda_api.event_source_mappings))\n\n    def test_publish_function_version(self):\n        with self.app.test_request_context():\n            self._create_function(self.FUNCTION_NAME)\n\n            result = json.loads(lambda_api.publish_version(self.FUNCTION_NAME).get_data())\n            result2 = json.loads(lambda_api.publish_version(self.FUNCTION_NAME).get_data())\n\n            expected_result = dict()\n            expected_result['CodeSize'] = self.CODE_SIZE\n            expected_result['FunctionArn'] = str(lambda_api.func_arn(self.FUNCTION_NAME)) + ':1'\n            expected_result['FunctionName'] = str(self.FUNCTION_NAME)\n            expected_result['Handler'] = str(self.HANDLER)\n            expected_result['Runtime'] = str(self.RUNTIME)\n            expected_result['Timeout'] = self.TIMEOUT\n            expected_result['Version'] = '1'\n            expected_result['Environment'] = {}\n            expected_result2 = dict(expected_result)\n            expected_result2['FunctionArn'] = str(lambda_api.func_arn(self.FUNCTION_NAME)) + ':2'\n            expected_result2['Version'] = '2'\n            expected_result2['Environment'] = {}\n            self.assertDictEqual(expected_result, result)\n            self.assertDictEqual(expected_result2, result2)\n\n    def test_publish_non_existant_function_version_returns_error(self):\n        with self.app.test_request_context():\n            result = json.loads(lambda_api.publish_version(self.FUNCTION_NAME).get_data())\n            self.assertEqual(self.RESOURCENOTFOUND_EXCEPTION, result['__type'])\n            self.assertEqual(self.RESOURCENOTFOUND_MESSAGE % lambda_api.func_arn(self.FUNCTION_NAME),\n                             result['message'])\n\n    def test_list_function_versions(self):\n        with self.app.test_request_context():\n            self._create_function(self.FUNCTION_NAME)\n            lambda_api.publish_version(self.FUNCTION_NAME)\n            lambda_api.publish_version(self.FUNCTION_NAME)\n\n            result = json.loads(lambda_api.list_versions(self.FUNCTION_NAME).get_data())\n\n            latest_version = dict()\n            latest_version['CodeSize'] = self.CODE_SIZE\n            latest_version['FunctionArn'] = str(lambda_api.func_arn(self.FUNCTION_NAME)) + ':$LATEST'\n            latest_version['FunctionName'] = str(self.FUNCTION_NAME)\n            latest_version['Handler'] = str(self.HANDLER)\n            latest_version['Runtime'] = str(self.RUNTIME)\n            latest_version['Timeout'] = self.TIMEOUT\n            latest_version['Version'] = '$LATEST'\n            latest_version['Environment'] = {}\n            version1 = dict(latest_version)\n            version1['FunctionArn'] = str(lambda_api.func_arn(self.FUNCTION_NAME)) + ':1'\n            version1['Version'] = '1'\n            version1['Environment'] = {}\n            version2 = dict(latest_version)\n            version2['FunctionArn'] = str(lambda_api.func_arn(self.FUNCTION_NAME)) + ':2'\n            version2['Version'] = '2'\n            version2['Environment'] = {}\n            expected_result = {'Versions': sorted([latest_version, version1, version2],\n                                                  key=lambda k: str(k.get('Version')))}\n            self.assertDictEqual(expected_result, result)\n\n    def test_list_non_existant_function_versions_returns_error(self):\n        with self.app.test_request_context():\n            result = json.loads(lambda_api.list_versions(self.FUNCTION_NAME).get_data())\n            self.assertEqual(self.RESOURCENOTFOUND_EXCEPTION, result['__type'])\n            self.assertEqual(self.RESOURCENOTFOUND_MESSAGE % lambda_api.func_arn(self.FUNCTION_NAME),\n                             result['message'])\n\n    def test_create_alias(self):\n        self._create_function(self.FUNCTION_NAME)\n        self.client.post('{0}/functions/{1}/versions'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME))\n\n        response = self.client.post('{0}/functions/{1}/aliases'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME),\n                         data=json.dumps({'Name': self.ALIAS_NAME, 'FunctionVersion': '1',\n                             'Description': ''}))\n        result = json.loads(response.get_data())\n\n        expected_result = {'AliasArn': lambda_api.func_arn(self.FUNCTION_NAME) + ':' + self.ALIAS_NAME,\n                           'FunctionVersion': '1', 'Description': '', 'Name': self.ALIAS_NAME}\n        self.assertDictEqual(expected_result, result)\n\n    def test_create_alias_on_non_existant_function_returns_error(self):\n        with self.app.test_request_context():\n            result = json.loads(lambda_api.create_alias(self.FUNCTION_NAME).get_data())\n            self.assertEqual(self.RESOURCENOTFOUND_EXCEPTION, result['__type'])\n            self.assertEqual(self.RESOURCENOTFOUND_MESSAGE % lambda_api.func_arn(self.FUNCTION_NAME),\n                             result['message'])\n\n    def test_create_alias_returns_error_if_already_exists(self):\n        self._create_function(self.FUNCTION_NAME)\n        self.client.post('{0}/functions/{1}/versions'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME))\n        data = json.dumps({'Name': self.ALIAS_NAME, 'FunctionVersion': '1', 'Description': ''})\n        self.client.post('{0}/functions/{1}/aliases'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME), data=data)\n\n        response = self.client.post('{0}/functions/{1}/aliases'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME),\n                                    data=data)\n        result = json.loads(response.get_data())\n\n        alias_arn = lambda_api.func_arn(self.FUNCTION_NAME) + ':' + self.ALIAS_NAME\n        self.assertEqual(self.ALIASEXISTS_EXCEPTION, result['__type'])\n        self.assertEqual(self.ALIASEXISTS_MESSAGE % alias_arn,\n                         result['message'])\n\n    def test_update_alias(self):\n        self._create_function(self.FUNCTION_NAME)\n        self.client.post('{0}/functions/{1}/versions'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME))\n        self.client.post('{0}/functions/{1}/aliases'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME),\n                         data=json.dumps({\n                             'Name': self.ALIAS_NAME, 'FunctionVersion': '1', 'Description': ''}))\n\n        response = self.client.put('{0}/functions/{1}/aliases/{2}'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME,\n                                                                          self.ALIAS_NAME),\n                                   data=json.dumps({'FunctionVersion': '$LATEST', 'Description': 'Test-Description'}))\n        result = json.loads(response.get_data())\n\n        expected_result = {'AliasArn': lambda_api.func_arn(self.FUNCTION_NAME) + ':' + self.ALIAS_NAME,\n                           'FunctionVersion': '$LATEST', 'Description': 'Test-Description',\n                           'Name': self.ALIAS_NAME}\n        self.assertDictEqual(expected_result, result)\n\n    def test_update_alias_on_non_existant_function_returns_error(self):\n        with self.app.test_request_context():\n            result = json.loads(lambda_api.update_alias(self.FUNCTION_NAME, self.ALIAS_NAME).get_data())\n            self.assertEqual(self.RESOURCENOTFOUND_EXCEPTION, result['__type'])\n            self.assertEqual(self.RESOURCENOTFOUND_MESSAGE % lambda_api.func_arn(self.FUNCTION_NAME),\n                             result['message'])\n\n    def test_update_alias_on_non_existant_alias_returns_error(self):\n        with self.app.test_request_context():\n            self._create_function(self.FUNCTION_NAME)\n            result = json.loads(lambda_api.update_alias(self.FUNCTION_NAME, self.ALIAS_NAME).get_data())\n            alias_arn = lambda_api.func_arn(self.FUNCTION_NAME) + ':' + self.ALIAS_NAME\n            self.assertEqual(self.ALIASNOTFOUND_EXCEPTION, result['__type'])\n            self.assertEqual(self.ALIASNOTFOUND_MESSAGE % alias_arn, result['message'])\n\n    def test_list_aliases(self):\n        self._create_function(self.FUNCTION_NAME)\n        self.client.post('{0}/functions/{1}/versions'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME))\n\n        self.client.post('{0}/functions/{1}/aliases'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME),\n                         data=json.dumps({'Name': self.ALIAS2_NAME, 'FunctionVersion': '$LATEST'}))\n        self.client.post('{0}/functions/{1}/aliases'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME),\n                         data=json.dumps({'Name': self.ALIAS_NAME, 'FunctionVersion': '1',\n                                          'Description': self.ALIAS_NAME}))\n\n        response = self.client.get('{0}/functions/{1}/aliases'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME))\n        result = json.loads(response.get_data())\n        expected_result = {'Aliases': [\n            {\n                'AliasArn': lambda_api.func_arn(self.FUNCTION_NAME) + ':' + self.ALIAS_NAME,\n                'FunctionVersion': '1',\n                'Name': self.ALIAS_NAME,\n                'Description': self.ALIAS_NAME\n            },\n            {\n                'AliasArn': lambda_api.func_arn(self.FUNCTION_NAME) + ':' + self.ALIAS2_NAME,\n                'FunctionVersion': '$LATEST',\n                'Name': self.ALIAS2_NAME,\n                'Description': ''\n            }\n        ]}\n        self.assertDictEqual(expected_result, result)\n\n    def test_list_non_existant_function_aliases_returns_error(self):\n        with self.app.test_request_context():\n            result = json.loads(lambda_api.list_aliases(self.FUNCTION_NAME).get_data())\n            self.assertEqual(self.RESOURCENOTFOUND_EXCEPTION, result['__type'])\n            self.assertEqual(self.RESOURCENOTFOUND_MESSAGE % lambda_api.func_arn(self.FUNCTION_NAME),\n                             result['message'])\n\n    def test_get_container_name(self):\n        executor = lambda_executors.EXECUTOR_CONTAINERS_REUSE\n        name = executor.get_container_name('arn:aws:lambda:us-east-1:00000000:function:my_function_name')\n        self.assertEqual(name, 'localstack_lambda_arn_aws_lambda_us-east-1_00000000_function_my_function_name')\n\n    def test_put_concurrency(self):\n        with self.app.test_request_context():\n            self._create_function(self.FUNCTION_NAME)\n            # note: PutFunctionConcurrency is mounted at: /2017-10-31\n            # NOT lambda_api.PATH_ROOT\n            # https://docs.aws.amazon.com/lambda/latest/dg/API_PutFunctionConcurrency.html\n            concurrency_data = {'ReservedConcurrentExecutions': 10}\n            response = self.client.put('/2017-10-31/functions/{0}/concurrency'.format(self.FUNCTION_NAME),\n                                       data=json.dumps(concurrency_data))\n\n            result = json.loads(response.get_data())\n            self.assertDictEqual(concurrency_data, result)\n\n    def test_concurrency_get_function(self):\n        with self.app.test_request_context():\n            self._create_function(self.FUNCTION_NAME)\n            # note: PutFunctionConcurrency is mounted at: /2017-10-31\n            # NOT lambda_api.PATH_ROOT\n            # https://docs.aws.amazon.com/lambda/latest/dg/API_PutFunctionConcurrency.html\n            concurrency_data = {'ReservedConcurrentExecutions': 10}\n            self.client.put('/2017-10-31/functions/{0}/concurrency'.format(self.FUNCTION_NAME),\n                            data=json.dumps(concurrency_data))\n\n            response = self.client.get('{0}/functions/{1}'.format(lambda_api.PATH_ROOT, self.FUNCTION_NAME))\n\n            result = json.loads(response.get_data())\n            self.assertTrue('Concurrency' in result)\n            self.assertDictEqual(concurrency_data, result['Concurrency'])\n\n    def _create_function(self, function_name):\n        arn = lambda_api.func_arn(function_name)\n        lambda_api.arn_to_lambda[arn] = LambdaFunction(arn)\n        lambda_api.arn_to_lambda[arn].versions = {'$LATEST': {'CodeSize': self.CODE_SIZE}}\n        lambda_api.arn_to_lambda[arn].handler = self.HANDLER\n        lambda_api.arn_to_lambda[arn].runtime = self.RUNTIME\n        lambda_api.arn_to_lambda[arn].timeout = self.TIMEOUT\n        lambda_api.arn_to_lambda[arn].envvars = {}\n", "description": "\ud83d\udcbb  A fully functional local AWS cloud stack. Develop and test your cloud apps offline!", "file_name": "test_lambda.py", "id": "b2638b5d4550549031211c830eaf4464", "language": "Python", "project_name": "localstack", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/localstack-localstack/localstack-localstack-865ec3a/tests/unit/test_lambda.py", "save_time": "", "source": "", "update_at": "2018-03-14T00:04:55Z", "url": "https://github.com/localstack/localstack", "wiki": true}