{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom odoo import api, fields, models\nfrom odoo.tools import float_compare\n\n\nclass SaleOrderLine(models.Model):\n    _inherit = 'sale.order.line'\n\n    @api.multi\n    def _get_delivered_qty(self):\n        self.ensure_one()\n\n        \n        \n        bom = self.env['mrp.bom']._bom_find(product=self.product_id)\n        if bom and bom.type == 'phantom':\n            bom_delivered = all([move.state == 'done' for move in self.move_ids])\n            if bom_delivered:\n                return self.product_uom_qty\n            else:\n                return 0.0\n        return super(SaleOrderLine, self)._get_delivered_qty()\n\n    @api.multi\n    def _get_bom_component_qty(self, bom):\n        bom_quantity = self.product_uom._compute_quantity(self.product_uom_qty, bom.product_uom_id)\n        boms, lines = bom.explode(self.product_id, bom_quantity)\n        components = {}\n        for line, line_data in lines:\n            product = line.product_id.id\n            uom = line.product_uom_id\n            qty = line.product_qty\n            if components.get(product, False):\n                if uom.id != components[product]['uom']:\n                    from_uom = uom\n                    to_uom = self.env['product.uom'].browse(components[product]['uom'])\n                    qty = from_uom._compute_quantity(qty, to_uom)\n                components[product]['qty'] += qty\n            else:\n                \n                to_uom = self.env['product.product'].browse(product).uom_id\n                if uom.id != to_uom.id:\n                    from_uom = uom\n                    qty = from_uom._compute_quantity(qty, to_uom)\n                components[product] = {'qty': qty, 'uom': to_uom.id}\n        return components\n\n\nclass AccountInvoiceLine(models.Model):\n     ??\n    _inherit = \"account.invoice.line\"\n\n    def _get_anglo_saxon_price_unit(self):\n        price_unit = super(AccountInvoiceLine, self)._get_anglo_saxon_price_unit()\n        \n        \n        if self.product_id.invoice_policy == \"delivery\":\n            for s_line in self.sale_line_ids:\n                \n                qty_done = sum([x.uom_id._compute_quantity(x.quantity, x.product_id.uom_id) for x in s_line.invoice_lines if x.invoice_id.state in ('open', 'paid')])\n                quantity = self.uom_id._compute_quantity(self.quantity, self.product_id.uom_id)\n                \n                moves = s_line.move_ids\n                moves.sorted(lambda x: x.date)\n                \n                \n                \n                bom = s_line.product_id.product_tmpl_id.bom_ids and s_line.product_id.product_tmpl_id.bom_ids[0]\n                if bom.type == 'phantom':\n                    average_price_unit = 0\n                    components = s_line._get_bom_component_qty(bom)\n                    for product_id in components:\n                        factor = components[product_id]['qty']\n                        prod_moves = [m for m in moves if m.product_id.id == product_id]\n                        prod_qty_done = factor * qty_done\n                        prod_quantity = factor * quantity\n                        average_price_unit += factor * self._compute_average_price(prod_qty_done, prod_quantity, prod_moves)\n                    price_unit = average_price_unit or price_unit\n                    price_unit = self.product_id.uom_id._compute_price(price_unit, self.uom_id)\n        return price_unit\n", "comments": "      coding  utf 8        part odoo  see license file full copyright licensing details     in case kit  need check components shipped  since bom might    changed  compute quantities verify move state     to uom reference product    tde fixme  code       case anglo saxon product configured invoiced based delivery  perpetual    valuation real price costing method  must find real price cost good sold    qtys already invoiced    put moves fixed order date executed    go moves nothing get qty done    beyond qty done need calculate average price unit    moves encounter  ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom odoo import api, fields, models\nfrom odoo.tools import float_compare\n\n\nclass SaleOrderLine(models.Model):\n    _inherit = 'sale.order.line'\n\n    @api.multi\n    def _get_delivered_qty(self):\n        self.ensure_one()\n\n        # In the case of a kit, we need to check if all components are shipped. Since the BOM might\n        # have changed, we don't compute the quantities but verify the move state.\n        bom = self.env['mrp.bom']._bom_find(product=self.product_id)\n        if bom and bom.type == 'phantom':\n            bom_delivered = all([move.state == 'done' for move in self.move_ids])\n            if bom_delivered:\n                return self.product_uom_qty\n            else:\n                return 0.0\n        return super(SaleOrderLine, self)._get_delivered_qty()\n\n    @api.multi\n    def _get_bom_component_qty(self, bom):\n        bom_quantity = self.product_uom._compute_quantity(self.product_uom_qty, bom.product_uom_id)\n        boms, lines = bom.explode(self.product_id, bom_quantity)\n        components = {}\n        for line, line_data in lines:\n            product = line.product_id.id\n            uom = line.product_uom_id\n            qty = line.product_qty\n            if components.get(product, False):\n                if uom.id != components[product]['uom']:\n                    from_uom = uom\n                    to_uom = self.env['product.uom'].browse(components[product]['uom'])\n                    qty = from_uom._compute_quantity(qty, to_uom)\n                components[product]['qty'] += qty\n            else:\n                # To be in the uom reference of the product\n                to_uom = self.env['product.product'].browse(product).uom_id\n                if uom.id != to_uom.id:\n                    from_uom = uom\n                    qty = from_uom._compute_quantity(qty, to_uom)\n                components[product] = {'qty': qty, 'uom': to_uom.id}\n        return components\n\n\nclass AccountInvoiceLine(models.Model):\n    # TDE FIXME: what is this code ??\n    _inherit = \"account.invoice.line\"\n\n    def _get_anglo_saxon_price_unit(self):\n        price_unit = super(AccountInvoiceLine, self)._get_anglo_saxon_price_unit()\n        # in case of anglo saxon with a product configured as invoiced based on delivery, with perpetual\n        # valuation and real price costing method, we must find the real price for the cost of good sold\n        if self.product_id.invoice_policy == \"delivery\":\n            for s_line in self.sale_line_ids:\n                # qtys already invoiced\n                qty_done = sum([x.uom_id._compute_quantity(x.quantity, x.product_id.uom_id) for x in s_line.invoice_lines if x.invoice_id.state in ('open', 'paid')])\n                quantity = self.uom_id._compute_quantity(self.quantity, self.product_id.uom_id)\n                # Put moves in fixed order by date executed\n                moves = s_line.move_ids\n                moves.sorted(lambda x: x.date)\n                # Go through all the moves and do nothing until you get to qty_done\n                # Beyond qty_done we need to calculate the average of the price_unit\n                # on the moves we encounter.\n                bom = s_line.product_id.product_tmpl_id.bom_ids and s_line.product_id.product_tmpl_id.bom_ids[0]\n                if bom.type == 'phantom':\n                    average_price_unit = 0\n                    components = s_line._get_bom_component_qty(bom)\n                    for product_id in components:\n                        factor = components[product_id]['qty']\n                        prod_moves = [m for m in moves if m.product_id.id == product_id]\n                        prod_qty_done = factor * qty_done\n                        prod_quantity = factor * quantity\n                        average_price_unit += factor * self._compute_average_price(prod_qty_done, prod_quantity, prod_moves)\n                    price_unit = average_price_unit or price_unit\n                    price_unit = self.product_id.uom_id._compute_price(price_unit, self.uom_id)\n        return price_unit\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "sale_mrp.py", "id": "9052270501da289135d2c765fe659214", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/sale_mrp/models/sale_mrp.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}