{"author": "tflearn", "code": "import tensorflow as tf\nimport numpy as np\nimport tflearn\nimport unittest\nimport os\n\nclass TestModels(unittest.TestCase):\n    \n\n    def test_dnn(self):\n\n        with tf.Graph().as_default():\n            X = [3.3,4.4,5.5,6.71,6.93,4.168,9.779,6.182,7.59,2.167,7.042,10.791,5.313,7.997,5.654,9.27,3.1]\n            Y = [1.7,2.76,2.09,3.19,1.694,1.573,3.366,2.596,2.53,1.221,2.827,3.465,1.65,2.904,2.42,2.94,1.3]\n            input = tflearn.input_data(shape=[None])\n            linear = tflearn.single_unit(input)\n            regression = tflearn.regression(linear, optimizer='sgd', loss='mean_square',\n                                            metric='R2', learning_rate=0.01)\n            m = tflearn.DNN(regression)\n            \n            m.fit(X, Y, n_epoch=1000, show_metric=True, snapshot_epoch=False)\n            res = m.predict([3.2])[0]\n            self.assertGreater(res, 1.3, \"DNN test (linear regression) failed! with score: \" + str(res) + \" expected > 1.3\")\n            self.assertLess(res, 1.8, \"DNN test (linear regression) failed! with score: \" + str(res) + \" expected < 1.8\")\n\n            \n            m.save(\"test_dnn.tflearn\")\n            self.assertTrue(os.path.exists(\"test_dnn.tflearn.index\"))\n\n        with tf.Graph().as_default():\n            input = tflearn.input_data(shape=[None])\n            linear = tflearn.single_unit(input)\n            regression = tflearn.regression(linear, optimizer='sgd', loss='mean_square',\n                                            metric='R2', learning_rate=0.01)\n            m = tflearn.DNN(regression)\n\n            \n            m.load(\"test_dnn.tflearn\")\n            res = m.predict([3.2])[0]\n            self.assertGreater(res, 1.3, \"DNN test (linear regression) failed after loading model! score: \" + str(res) + \" expected > 1.3\")\n            self.assertLess(res, 1.8, \"DNN test (linear regression) failed after loading model! score: \" + str(res) + \" expected < 1.8\")\n\n    def test_sequencegenerator(self):\n\n        with tf.Graph().as_default():\n            text = \"123456789101234567891012345678910123456789101234567891012345678910\"\n            maxlen = 5\n\n            X, Y, char_idx = \\\n                tflearn.data_utils.string_to_semi_redundant_sequences(text, seq_maxlen=maxlen, redun_step=3)\n\n            g = tflearn.input_data(shape=[None, maxlen, len(char_idx)])\n            g = tflearn.lstm(g, 32)\n            g = tflearn.dropout(g, 0.5)\n            g = tflearn.fully_connected(g, len(char_idx), activation='softmax')\n            g = tflearn.regression(g, optimizer='adam', loss='categorical_crossentropy',\n                                   learning_rate=0.1)\n\n            m = tflearn.SequenceGenerator(g, dictionary=char_idx,\n                                          seq_maxlen=maxlen,\n                                          clip_gradients=5.0)\n            m.fit(X, Y, validation_set=0.1, n_epoch=100, snapshot_epoch=False)\n            res = m.generate(10, temperature=.5, seq_seed=\"12345\")\n            #self.assertEqual(res, \"123456789101234\", \"SequenceGenerator test failed! Generated sequence: \" + res + \" expected '123456789101234'\")\n\n            \n            m.save(\"test_seqgen.tflearn\")\n            self.assertTrue(os.path.exists(\"test_seqgen.tflearn.index\"))\n\n            \n            m.load(\"test_seqgen.tflearn\")\n            res = m.generate(10, temperature=.5, seq_seed=\"12345\")\n            \n            #self.assertEqual(res, \"123456789101234\", \"SequenceGenerator test failed after loading model! Generated sequence: \" + res + \" expected '123456789101234'\")\n\n    def test_sequencegenerator_words(self):\n\n        with tf.Graph().as_default():\n            text = [\"hello\",\"world\"]*100\n            word_idx = {\"hello\": 0, \"world\": 1}\n            maxlen = 2\n\n            vec = [x for x in map(word_idx.get, text) if x is not None]\n\n            sequences = []\n            next_words = []\n            for i in range(0, len(vec) - maxlen, 3):\n                sequences.append(vec[i: i + maxlen])\n                next_words.append(vec[i + maxlen])\n\n            X = np.zeros((len(sequences), maxlen, len(word_idx)), dtype=np.bool)\n            Y = np.zeros((len(sequences), len(word_idx)), dtype=np.bool)\n            for i, seq in enumerate(sequences):\n                for t, idx in enumerate(seq):\n                    X[i, t, idx] = True\n                    Y[i, next_words[i]] = True\n\n            g = tflearn.input_data(shape=[None, maxlen, len(word_idx)])\n            g = tflearn.lstm(g, 32)\n            g = tflearn.dropout(g, 0.5)\n            g = tflearn.fully_connected(g, len(word_idx), activation='softmax')\n            g = tflearn.regression(g, optimizer='adam', loss='categorical_crossentropy',\n                                   learning_rate=0.1)\n\n            m = tflearn.SequenceGenerator(g, dictionary=word_idx,\n                                          seq_maxlen=maxlen,\n                                          clip_gradients=5.0)\n            m.fit(X, Y, validation_set=0.1, n_epoch=100, snapshot_epoch=False)\n            res = m.generate(4, temperature=.5, seq_seed=[\"hello\",\"world\"])\n            res_str = \" \".join(res[-2:])\n            self.assertEqual(res_str, \"hello world\", \"SequenceGenerator (word level) test failed! Generated sequence: \" + res_str + \" expected 'hello world'\")\n\n            \n            m.save(\"test_seqgen_word.tflearn\")\n            self.assertTrue(os.path.exists(\"test_seqgen_word.tflearn.index\"))\n\n            \n            m.load(\"test_seqgen_word.tflearn\")\n            res = m.generate(4, temperature=.5, seq_seed=[\"hello\",\"world\"])\n            res_str = \" \".join(res[-2:])\n            self.assertEqual(res_str, \"hello world\", \"Reloaded SequenceGenerator (word level) test failed! Generated sequence: \" + res_str + \" expected 'hello world'\")\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "comments": "        testing dnn model tflearn models dnn py            testing fit predict    testing save method    testing load method   self assertequal(res   123456789101234    sequencegenerator test failed  generated sequence      res     expected  123456789101234  )    testing save method    testing load method    todo  fix test   self assertequal(res   123456789101234    sequencegenerator test failed loading model  generated sequence      res     expected  123456789101234  )    testing save method    testing load method ", "content": "import tensorflow as tf\nimport numpy as np\nimport tflearn\nimport unittest\nimport os\n\nclass TestModels(unittest.TestCase):\n    \"\"\"\n    Testing DNN model from tflearn/models/dnn.py\n    \"\"\"\n\n    def test_dnn(self):\n\n        with tf.Graph().as_default():\n            X = [3.3,4.4,5.5,6.71,6.93,4.168,9.779,6.182,7.59,2.167,7.042,10.791,5.313,7.997,5.654,9.27,3.1]\n            Y = [1.7,2.76,2.09,3.19,1.694,1.573,3.366,2.596,2.53,1.221,2.827,3.465,1.65,2.904,2.42,2.94,1.3]\n            input = tflearn.input_data(shape=[None])\n            linear = tflearn.single_unit(input)\n            regression = tflearn.regression(linear, optimizer='sgd', loss='mean_square',\n                                            metric='R2', learning_rate=0.01)\n            m = tflearn.DNN(regression)\n            # Testing fit and predict\n            m.fit(X, Y, n_epoch=1000, show_metric=True, snapshot_epoch=False)\n            res = m.predict([3.2])[0]\n            self.assertGreater(res, 1.3, \"DNN test (linear regression) failed! with score: \" + str(res) + \" expected > 1.3\")\n            self.assertLess(res, 1.8, \"DNN test (linear regression) failed! with score: \" + str(res) + \" expected < 1.8\")\n\n            # Testing save method\n            m.save(\"test_dnn.tflearn\")\n            self.assertTrue(os.path.exists(\"test_dnn.tflearn.index\"))\n\n        with tf.Graph().as_default():\n            input = tflearn.input_data(shape=[None])\n            linear = tflearn.single_unit(input)\n            regression = tflearn.regression(linear, optimizer='sgd', loss='mean_square',\n                                            metric='R2', learning_rate=0.01)\n            m = tflearn.DNN(regression)\n\n            # Testing load method\n            m.load(\"test_dnn.tflearn\")\n            res = m.predict([3.2])[0]\n            self.assertGreater(res, 1.3, \"DNN test (linear regression) failed after loading model! score: \" + str(res) + \" expected > 1.3\")\n            self.assertLess(res, 1.8, \"DNN test (linear regression) failed after loading model! score: \" + str(res) + \" expected < 1.8\")\n\n    def test_sequencegenerator(self):\n\n        with tf.Graph().as_default():\n            text = \"123456789101234567891012345678910123456789101234567891012345678910\"\n            maxlen = 5\n\n            X, Y, char_idx = \\\n                tflearn.data_utils.string_to_semi_redundant_sequences(text, seq_maxlen=maxlen, redun_step=3)\n\n            g = tflearn.input_data(shape=[None, maxlen, len(char_idx)])\n            g = tflearn.lstm(g, 32)\n            g = tflearn.dropout(g, 0.5)\n            g = tflearn.fully_connected(g, len(char_idx), activation='softmax')\n            g = tflearn.regression(g, optimizer='adam', loss='categorical_crossentropy',\n                                   learning_rate=0.1)\n\n            m = tflearn.SequenceGenerator(g, dictionary=char_idx,\n                                          seq_maxlen=maxlen,\n                                          clip_gradients=5.0)\n            m.fit(X, Y, validation_set=0.1, n_epoch=100, snapshot_epoch=False)\n            res = m.generate(10, temperature=.5, seq_seed=\"12345\")\n            #self.assertEqual(res, \"123456789101234\", \"SequenceGenerator test failed! Generated sequence: \" + res + \" expected '123456789101234'\")\n\n            # Testing save method\n            m.save(\"test_seqgen.tflearn\")\n            self.assertTrue(os.path.exists(\"test_seqgen.tflearn.index\"))\n\n            # Testing load method\n            m.load(\"test_seqgen.tflearn\")\n            res = m.generate(10, temperature=.5, seq_seed=\"12345\")\n            # TODO: Fix test\n            #self.assertEqual(res, \"123456789101234\", \"SequenceGenerator test failed after loading model! Generated sequence: \" + res + \" expected '123456789101234'\")\n\n    def test_sequencegenerator_words(self):\n\n        with tf.Graph().as_default():\n            text = [\"hello\",\"world\"]*100\n            word_idx = {\"hello\": 0, \"world\": 1}\n            maxlen = 2\n\n            vec = [x for x in map(word_idx.get, text) if x is not None]\n\n            sequences = []\n            next_words = []\n            for i in range(0, len(vec) - maxlen, 3):\n                sequences.append(vec[i: i + maxlen])\n                next_words.append(vec[i + maxlen])\n\n            X = np.zeros((len(sequences), maxlen, len(word_idx)), dtype=np.bool)\n            Y = np.zeros((len(sequences), len(word_idx)), dtype=np.bool)\n            for i, seq in enumerate(sequences):\n                for t, idx in enumerate(seq):\n                    X[i, t, idx] = True\n                    Y[i, next_words[i]] = True\n\n            g = tflearn.input_data(shape=[None, maxlen, len(word_idx)])\n            g = tflearn.lstm(g, 32)\n            g = tflearn.dropout(g, 0.5)\n            g = tflearn.fully_connected(g, len(word_idx), activation='softmax')\n            g = tflearn.regression(g, optimizer='adam', loss='categorical_crossentropy',\n                                   learning_rate=0.1)\n\n            m = tflearn.SequenceGenerator(g, dictionary=word_idx,\n                                          seq_maxlen=maxlen,\n                                          clip_gradients=5.0)\n            m.fit(X, Y, validation_set=0.1, n_epoch=100, snapshot_epoch=False)\n            res = m.generate(4, temperature=.5, seq_seed=[\"hello\",\"world\"])\n            res_str = \" \".join(res[-2:])\n            self.assertEqual(res_str, \"hello world\", \"SequenceGenerator (word level) test failed! Generated sequence: \" + res_str + \" expected 'hello world'\")\n\n            # Testing save method\n            m.save(\"test_seqgen_word.tflearn\")\n            self.assertTrue(os.path.exists(\"test_seqgen_word.tflearn.index\"))\n\n            # Testing load method\n            m.load(\"test_seqgen_word.tflearn\")\n            res = m.generate(4, temperature=.5, seq_seed=[\"hello\",\"world\"])\n            res_str = \" \".join(res[-2:])\n            self.assertEqual(res_str, \"hello world\", \"Reloaded SequenceGenerator (word level) test failed! Generated sequence: \" + res_str + \" expected 'hello world'\")\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "description": "Deep learning library featuring a higher-level API for TensorFlow.", "file_name": "test_models.py", "id": "c9cbc7b97e94c9388a973af54388eb99", "language": "Python", "project_name": "tflearn", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tflearn-tflearn/tflearn-tflearn-70fb38a/tests/test_models.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:15:41Z", "url": "https://github.com/tflearn/tflearn", "wiki": true}