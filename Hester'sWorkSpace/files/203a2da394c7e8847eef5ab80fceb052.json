{"author": "keon", "code": "\"\"\"\nA 2d grid map of m rows and n columns is initially filled with water.\nWe may perform an addLand operation which turns the water at position\n(row, col) into a land. Given a list of positions to operate,\ncount the number of islands after each addLand operation.\nAn island is surrounded by water and is formed by connecting adjacent\nlands horizontally or vertically.\nYou may assume all four edges of the grid are all surrounded by water.\n\nGiven m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]].\nInitially, the 2d grid grid is filled with water.\n(Assume 0 represents water and 1 represents land).\n\n0 0 0\n0 0 0\n0 0 0\nOperation #1: addLand(0, 0) turns the water at grid[0][0] into a land.\n\n1 0 0\n0 0 0   Number of islands = 1\n0 0 0\nOperation #2: addLand(0, 1) turns the water at grid[0][1] into a land.\n\n1 1 0\n0 0 0   Number of islands = 1\n0 0 0\nOperation #3: addLand(1, 2) turns the water at grid[1][2] into a land.\n\n1 1 0\n0 0 1   Number of islands = 2\n0 0 0\nOperation #4: addLand(2, 1) turns the water at grid[2][1] into a land.\n\n1 1 0\n0 0 1   Number of islands = 3\n0 1 0\n\"\"\"\n\n\nclass Solution(object):\n    def numIslands2(self, m, n, positions):\n        ans = []\n        islands = Union()\n        for p in map(tuple, positions):\n            islands.add(p)\n            for dp in (0, 1), (0, -1), (1, 0), (-1, 0):\n                q = (p[0] + dp[0], p[1] + dp[1])\n                if q in islands.id:\n                    islands.unite(p, q)\n            ans += [islands.count]\n        return ans\n\nclass Union(object):\n    def __init__(self):\n        self.id = {}\n        self.sz = {}\n        self.count = 0\n\n    def add(self, p):\n        self.id[p] = p\n        self.sz[p] = 1\n        self.count += 1\n\n    def root(self, i):\n        while i != self.id[i]:\n            self.id[i] = self.id[self.id[i]]\n            i = self.id[i]\n        return i\n\n    def unite(self, p, q):\n        i, j = self.root(p), self.root(q)\n        if i == j:\n            return\n        if self.sz[i] > self.sz[j]:\n            i, j = j, i\n        self.id[i] = j\n        self.sz[j] += self.sz[i]\n        self.count -= 1\n", "comments": "    a 2d grid map rows n columns initially filled water  we may perform addland operation turns water position (row  col) land  given list positions operate  count number islands addland operation  an island surrounded water formed connecting adjacent lands horizontally vertically  you may assume four edges grid surrounded water   given   3  n   3  positions     0 0    0 1    1 2    2 1    initially  2d grid grid filled water  (assume 0 represents water 1 represents land)   0 0 0 0 0 0 0 0 0 operation  1  addland(0  0) turns water grid 0  0  land   1 0 0 0 0 0   number islands   1 0 0 0 operation  2  addland(0  1) turns water grid 0  1  land   1 1 0 0 0 0   number islands   1 0 0 0 operation  3  addland(1  2) turns water grid 1  2  land   1 1 0 0 0 1   number islands   2 0 0 0 operation  4  addland(2  1) turns water grid 2  1  land   1 1 0 0 0 1   number islands   3 0 1 0       1  addland(0  0) turns water grid 0  0  land    2  addland(0  1) turns water grid 0  1  land    3  addland(1  2) turns water grid 1  2  land    4  addland(2  1) turns water grid 2  1  land  ", "content": "\"\"\"\nA 2d grid map of m rows and n columns is initially filled with water.\nWe may perform an addLand operation which turns the water at position\n(row, col) into a land. Given a list of positions to operate,\ncount the number of islands after each addLand operation.\nAn island is surrounded by water and is formed by connecting adjacent\nlands horizontally or vertically.\nYou may assume all four edges of the grid are all surrounded by water.\n\nGiven m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]].\nInitially, the 2d grid grid is filled with water.\n(Assume 0 represents water and 1 represents land).\n\n0 0 0\n0 0 0\n0 0 0\nOperation #1: addLand(0, 0) turns the water at grid[0][0] into a land.\n\n1 0 0\n0 0 0   Number of islands = 1\n0 0 0\nOperation #2: addLand(0, 1) turns the water at grid[0][1] into a land.\n\n1 1 0\n0 0 0   Number of islands = 1\n0 0 0\nOperation #3: addLand(1, 2) turns the water at grid[1][2] into a land.\n\n1 1 0\n0 0 1   Number of islands = 2\n0 0 0\nOperation #4: addLand(2, 1) turns the water at grid[2][1] into a land.\n\n1 1 0\n0 0 1   Number of islands = 3\n0 1 0\n\"\"\"\n\n\nclass Solution(object):\n    def numIslands2(self, m, n, positions):\n        ans = []\n        islands = Union()\n        for p in map(tuple, positions):\n            islands.add(p)\n            for dp in (0, 1), (0, -1), (1, 0), (-1, 0):\n                q = (p[0] + dp[0], p[1] + dp[1])\n                if q in islands.id:\n                    islands.unite(p, q)\n            ans += [islands.count]\n        return ans\n\nclass Union(object):\n    def __init__(self):\n        self.id = {}\n        self.sz = {}\n        self.count = 0\n\n    def add(self, p):\n        self.id[p] = p\n        self.sz[p] = 1\n        self.count += 1\n\n    def root(self, i):\n        while i != self.id[i]:\n            self.id[i] = self.id[self.id[i]]\n            i = self.id[i]\n        return i\n\n    def unite(self, p, q):\n        i, j = self.root(p), self.root(q)\n        if i == j:\n            return\n        if self.sz[i] > self.sz[j]:\n            i, j = j, i\n        self.id[i] = j\n        self.sz[j] += self.sz[i]\n        self.count -= 1\n", "description": "Minimal examples of data structures and algorithms in Python", "file_name": "count_islands.py", "id": "203a2da394c7e8847eef5ab80fceb052", "language": "Python", "project_name": "algorithms", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/keon-algorithms/keon-algorithms-ea43887/union-find/count_islands.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:53:29Z", "url": "https://github.com/keon/algorithms", "wiki": true}