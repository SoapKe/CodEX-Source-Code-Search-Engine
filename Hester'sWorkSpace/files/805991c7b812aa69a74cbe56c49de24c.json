{"author": "USArmyResearchLab", "code": "import dpkt\nimport socket\nfrom dnsdecoder import DNSDecoder\n\n\nclass DshellDecoder(DNSDecoder):\n\n    def __init__(self):\n        DNSDecoder.__init__(self,\n                            name='dns',\n                            description='extract and summarize DNS queries/responses (defaults: A,AAAA,CNAME,PTR records)',\n                            filter='(udp and port 53)',\n                            author='bg/twp',\n                            optiondict={'show_noanswer': {'action': 'store_true', 'help': 'report unanswered queries alongside other queries'},\n                                        'show_norequest': {'action': 'store_true', 'help': 'report unsolicited responses alongside other responses'},\n                                        'only_noanswer': {'action': 'store_true', 'help': 'report only unanswered queries'},\n                                        'only_norequest': {'action': 'store_true', 'help': 'report only unsolicited responses'},\n                                        'showall': {'action': 'store_true', 'help': 'show all answered queries/responses'}}\n                            )\n\n    def decode_q(self, dns):\n        queried = \"\"\n        if dns.qd[0].type == dpkt.dns.DNS_A:\n            queried = queried + \"A? %s\" % (dns.qd[0].name)\n        if dns.qd[0].type == dpkt.dns.DNS_CNAME:\n            queried = queried + \"CNAME? %s\" % (dns.qd[0].name)\n        if dns.qd[0].type == dpkt.dns.DNS_AAAA:\n            queried = queried + \"AAAA? %s\" % (dns.qd[0].name)\n        if dns.qd[0].type == dpkt.dns.DNS_PTR:\n            if dns.qd[0].name.endswith('.in-addr.arpa'):\n                query_name = '.'.join(\n                    reversed(dns.qd[0].name.split('.in-addr.arpa')[0].split('.')))\n            else:\n                query_name = dns.qd[0].name\n            queried = queried + \"PTR? %s\" % (query_name)\n\n        if not self.showall:\n            return queried\n\n        if dns.qd[0].type == dpkt.dns.DNS_NS:\n            queried = queried + \"NS? %s\" % (dns.qd[0].name)\n        if dns.qd[0].type == dpkt.dns.DNS_MX:\n            queried = queried + \"MX? %s\" % (dns.qd[0].name)\n        if dns.qd[0].type == dpkt.dns.DNS_TXT:\n            queried = queried + \"TXT? %s\" % (dns.qd[0].name)\n        if dns.qd[0].type == dpkt.dns.DNS_SRV:\n            queried = queried + \"SRV? %s\" % (dns.qd[0].name)\n\n        return queried\n\n    def DNSHandler(self, conn, request, response, **kwargs):\n        if self.only_norequest and request is not None:\n            return\n        if not self.show_norequest and request is None:\n            return\n        anstext = ''\n        queried = ''\n        id = None\n        for dns in request, response:\n            if dns is None:\n                continue\n            id = dns.id\n            \n            if dns.qr == dpkt.dns.DNS_Q:\n                conn.info(query=self.decode_q(dns))\n\n            \n            elif (dns.qr == dpkt.dns.DNS_A and dns.rcode == dpkt.dns.DNS_RCODE_NOERR and len(dns.an) > 0):\n\n                queried = self.decode_q(dns)\n\n                answers = []\n                for an in dns.an:\n                    if an.type == dpkt.dns.DNS_A:\n                        try:\n                            answers.append(\n                                'A: %s (ttl %ss)' % (socket.inet_ntoa(an.ip), str(an.ttl)))\n                        except:\n                            continue\n                    elif an.type == dpkt.dns.DNS_AAAA:\n                        try:\n                            answers.append('AAAA: %s (ttl %ss)' % (\n                                socket.inet_ntop(socket.AF_INET6, an.ip6), str(an.ttl)))\n                        except:\n                            continue\n                    elif an.type == dpkt.dns.DNS_CNAME:\n                        answers.append('CNAME: ' + an.cname)\n                    elif an.type == dpkt.dns.DNS_PTR:\n                        answers.append('PTR: ' + an.ptrname)\n                    elif an.type == dpkt.dns.DNS_NS:\n                        answers.append('NS: ' + an.nsname)\n                    elif an.type == dpkt.dns.DNS_MX:\n                        answers.append('MX: ' + an.mxname)\n                    elif an.type == dpkt.dns.DNS_TXT:\n                        answers.append('TXT: ' + ' '.join(an.text))\n                    elif an.type == dpkt.dns.DNS_SRV:\n                        answers.append('SRV: ' + an.srvname)\n                    else:\n                        \n                        continue\n                if queried != '':\n                    anstext = \", \".join(answers)\n\n            \n            elif dns.qr == dpkt.dns.DNS_A and dns.rcode == dpkt.dns.DNS_RCODE_NXDOMAIN:\n                queried = self.decode_q(dns)  \n\n                if queried != '':\n                    anstext = 'NXDOMAIN'\n\n        ?\n        if anstext and not self.only_noanswer and not self.only_norequest:\n            self.alert(\n                str(id) + ' ' + queried + ' / ' + anstext, **conn.info(response=anstext))\n        elif not anstext and (self.show_noanswer or self.only_noanswer):\n            self.alert(\n                str(id) + ' ' + conn.query + ' / (no answer)', **conn.info())\n\nif __name__ == '__main__':\n    dObj = DshellDecoder()\n    print dObj\nelse:\n    dObj = DshellDecoder()\n", "comments": "  dns question  update connection info query    dns answer data errors    un handled type   nxdomain response    decode query part    get answer  ", "content": "import dpkt\nimport socket\nfrom dnsdecoder import DNSDecoder\n\n\nclass DshellDecoder(DNSDecoder):\n\n    def __init__(self):\n        DNSDecoder.__init__(self,\n                            name='dns',\n                            description='extract and summarize DNS queries/responses (defaults: A,AAAA,CNAME,PTR records)',\n                            filter='(udp and port 53)',\n                            author='bg/twp',\n                            optiondict={'show_noanswer': {'action': 'store_true', 'help': 'report unanswered queries alongside other queries'},\n                                        'show_norequest': {'action': 'store_true', 'help': 'report unsolicited responses alongside other responses'},\n                                        'only_noanswer': {'action': 'store_true', 'help': 'report only unanswered queries'},\n                                        'only_norequest': {'action': 'store_true', 'help': 'report only unsolicited responses'},\n                                        'showall': {'action': 'store_true', 'help': 'show all answered queries/responses'}}\n                            )\n\n    def decode_q(self, dns):\n        queried = \"\"\n        if dns.qd[0].type == dpkt.dns.DNS_A:\n            queried = queried + \"A? %s\" % (dns.qd[0].name)\n        if dns.qd[0].type == dpkt.dns.DNS_CNAME:\n            queried = queried + \"CNAME? %s\" % (dns.qd[0].name)\n        if dns.qd[0].type == dpkt.dns.DNS_AAAA:\n            queried = queried + \"AAAA? %s\" % (dns.qd[0].name)\n        if dns.qd[0].type == dpkt.dns.DNS_PTR:\n            if dns.qd[0].name.endswith('.in-addr.arpa'):\n                query_name = '.'.join(\n                    reversed(dns.qd[0].name.split('.in-addr.arpa')[0].split('.')))\n            else:\n                query_name = dns.qd[0].name\n            queried = queried + \"PTR? %s\" % (query_name)\n\n        if not self.showall:\n            return queried\n\n        if dns.qd[0].type == dpkt.dns.DNS_NS:\n            queried = queried + \"NS? %s\" % (dns.qd[0].name)\n        if dns.qd[0].type == dpkt.dns.DNS_MX:\n            queried = queried + \"MX? %s\" % (dns.qd[0].name)\n        if dns.qd[0].type == dpkt.dns.DNS_TXT:\n            queried = queried + \"TXT? %s\" % (dns.qd[0].name)\n        if dns.qd[0].type == dpkt.dns.DNS_SRV:\n            queried = queried + \"SRV? %s\" % (dns.qd[0].name)\n\n        return queried\n\n    def DNSHandler(self, conn, request, response, **kwargs):\n        if self.only_norequest and request is not None:\n            return\n        if not self.show_norequest and request is None:\n            return\n        anstext = ''\n        queried = ''\n        id = None\n        for dns in request, response:\n            if dns is None:\n                continue\n            id = dns.id\n            # DNS Question, update connection info with query\n            if dns.qr == dpkt.dns.DNS_Q:\n                conn.info(query=self.decode_q(dns))\n\n            # DNS Answer with data and no errors\n            elif (dns.qr == dpkt.dns.DNS_A and dns.rcode == dpkt.dns.DNS_RCODE_NOERR and len(dns.an) > 0):\n\n                queried = self.decode_q(dns)\n\n                answers = []\n                for an in dns.an:\n                    if an.type == dpkt.dns.DNS_A:\n                        try:\n                            answers.append(\n                                'A: %s (ttl %ss)' % (socket.inet_ntoa(an.ip), str(an.ttl)))\n                        except:\n                            continue\n                    elif an.type == dpkt.dns.DNS_AAAA:\n                        try:\n                            answers.append('AAAA: %s (ttl %ss)' % (\n                                socket.inet_ntop(socket.AF_INET6, an.ip6), str(an.ttl)))\n                        except:\n                            continue\n                    elif an.type == dpkt.dns.DNS_CNAME:\n                        answers.append('CNAME: ' + an.cname)\n                    elif an.type == dpkt.dns.DNS_PTR:\n                        answers.append('PTR: ' + an.ptrname)\n                    elif an.type == dpkt.dns.DNS_NS:\n                        answers.append('NS: ' + an.nsname)\n                    elif an.type == dpkt.dns.DNS_MX:\n                        answers.append('MX: ' + an.mxname)\n                    elif an.type == dpkt.dns.DNS_TXT:\n                        answers.append('TXT: ' + ' '.join(an.text))\n                    elif an.type == dpkt.dns.DNS_SRV:\n                        answers.append('SRV: ' + an.srvname)\n                    else:\n                        # un-handled type\n                        continue\n                if queried != '':\n                    anstext = \", \".join(answers)\n\n            #NXDOMAIN in response\n            elif dns.qr == dpkt.dns.DNS_A and dns.rcode == dpkt.dns.DNS_RCODE_NXDOMAIN:\n                queried = self.decode_q(dns)  # decode query part\n\n                if queried != '':\n                    anstext = 'NXDOMAIN'\n\n        # did we get an answer?\n        if anstext and not self.only_noanswer and not self.only_norequest:\n            self.alert(\n                str(id) + ' ' + queried + ' / ' + anstext, **conn.info(response=anstext))\n        elif not anstext and (self.show_noanswer or self.only_noanswer):\n            self.alert(\n                str(id) + ' ' + conn.query + ' / (no answer)', **conn.info())\n\nif __name__ == '__main__':\n    dObj = DshellDecoder()\n    print dObj\nelse:\n    dObj = DshellDecoder()\n", "description": "Dshell is a network forensic analysis framework.", "file_name": "dns.py", "id": "805991c7b812aa69a74cbe56c49de24c", "language": "Python", "project_name": "Dshell", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/USArmyResearchLab-Dshell/USArmyResearchLab-Dshell-5850adf/decoders/dns/dns.py", "save_time": "", "source": "", "update_at": "2018-03-18T10:01:29Z", "url": "https://github.com/USArmyResearchLab/Dshell", "wiki": true}