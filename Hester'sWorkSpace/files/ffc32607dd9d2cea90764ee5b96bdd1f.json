{"author": "tensorflow", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================\n\"\"\"Functions for constructing vocabulary, converting the examples to integer format and building the required masks for batch computation Author: aneelakantan (Arvind Neelakantan)\n\"\"\"\n\nfrom __future__ import print_function\n\nimport copy\nimport numbers\nimport numpy as np\nimport wiki_data\n\n\ndef return_index(a):\n  for i in range(len(a)):\n    if (a[i] == 1.0):\n      return i\n\n\ndef construct_vocab(data, utility, add_word=False):\n  ans = []\n  for example in data:\n    sent = \"\"\n    for word in example.question:\n      if (not (isinstance(word, numbers.Number))):\n        sent += word + \" \"\n    example.original_nc = copy.deepcopy(example.number_columns)\n    example.original_wc = copy.deepcopy(example.word_columns)\n    example.original_nc_names = copy.deepcopy(example.number_column_names)\n    example.original_wc_names = copy.deepcopy(example.word_column_names)\n    if (add_word):\n      continue\n    number_found = 0\n    if (not (example.is_bad_example)):\n      for word in example.question:\n        if (isinstance(word, numbers.Number)):\n          number_found += 1\n        else:\n          if (not (utility.word_ids.has_key(word))):\n            utility.words.append(word)\n            utility.word_count[word] = 1\n            utility.word_ids[word] = len(utility.word_ids)\n            utility.reverse_word_ids[utility.word_ids[word]] = word\n          else:\n            utility.word_count[word] += 1\n      for col_name in example.word_column_names:\n        for word in col_name:\n          if (isinstance(word, numbers.Number)):\n            number_found += 1\n          else:\n            if (not (utility.word_ids.has_key(word))):\n              utility.words.append(word)\n              utility.word_count[word] = 1\n              utility.word_ids[word] = len(utility.word_ids)\n              utility.reverse_word_ids[utility.word_ids[word]] = word\n            else:\n              utility.word_count[word] += 1\n      for col_name in example.number_column_names:\n        for word in col_name:\n          if (isinstance(word, numbers.Number)):\n            number_found += 1\n          else:\n            if (not (utility.word_ids.has_key(word))):\n              utility.words.append(word)\n              utility.word_count[word] = 1\n              utility.word_ids[word] = len(utility.word_ids)\n              utility.reverse_word_ids[utility.word_ids[word]] = word\n            else:\n              utility.word_count[word] += 1\n\n\ndef word_lookup(word, utility):\n  if (utility.word_ids.has_key(word)):\n    return word\n  else:\n    return utility.unk_token\n\n\ndef convert_to_int_2d_and_pad(a, utility):\n  ans = []\n  print a\n  for b in a:\n    temp = []\n    if (len(b) > utility.FLAGS.max_entry_length):\n      b = b[0:utility.FLAGS.max_entry_length]\n    for remaining in range(len(b), utility.FLAGS.max_entry_length):\n      b.append(utility.dummy_token)\n    assert len(b) == utility.FLAGS.max_entry_length\n    for word in b:\n      temp.append(utility.word_ids[word_lookup(word, utility)])\n    ans.append(temp)\n  print ans\n  return ans\n\n\ndef convert_to_bool_and_pad(a, utility):\n  a = a.tolist()\n  for i in range(len(a)):\n    for j in range(len(a[i])):\n      if (a[i][j] < 1):\n        a[i][j] = False\n      else:\n        a[i][j] = True\n    a[i] = a[i] + [False] * (utility.FLAGS.max_elements - len(a[i]))\n  return a\n\n\nseen_tables = {}\n\n\ndef partial_match(question, table, number):\n  answer = []\n  match = {}\n  for i in range(len(table)):\n    temp = []\n    for j in range(len(table[i])):\n      temp.append(0)\n    answer.append(temp)\n  for i in range(len(table)):\n    for j in range(len(table[i])):\n      for word in question:\n        if (number):\n          if (word == table[i][j]):\n            answer[i][j] = 1.0\n            match[i] = 1.0\n        else:\n          if (word in table[i][j]):\n            answer[i][j] = 1.0\n            match[i] = 1.0\n  return answer, match\n\n\ndef exact_match(question, table, number):\n  performs exact match operation\n  answer = []\n  match = {}\n  matched_indices = []\n  for i in range(len(table)):\n    temp = []\n    for j in range(len(table[i])):\n      temp.append(0)\n    answer.append(temp)\n  for i in range(len(table)):\n    for j in range(len(table[i])):\n      if (number):\n        for word in question:\n          if (word == table[i][j]):\n            match[i] = 1.0\n            answer[i][j] = 1.0\n      else:\n        table_entry = table[i][j]\n        for k in range(len(question)):\n          if (k + len(table_entry) <= len(question)):\n            if (table_entry == question[k:(k + len(table_entry))]):\n              if(len(table_entry) == 1):\n              print \"match: \", table_entry, question\n              match[i] = 1.0\n              answer[i][j] = 1.0\n              matched_indices.append((k, len(table_entry)))\n  return answer, match, matched_indices\n\n\ndef partial_column_match(question, table, number):\n  answer = []\n  for i in range(len(table)):\n    answer.append(0)\n  for i in range(len(table)):\n    for word in question:\n      if (word in table[i]):\n        answer[i] = 1.0\n  return answer\n\n\ndef exact_column_match(question, table, number):\n  performs exact match on column names\n  answer = []\n  matched_indices = []\n  for i in range(len(table)):\n    answer.append(0)\n  for i in range(len(table)):\n    table_entry = table[i]\n    for k in range(len(question)):\n      if (k + len(table_entry) <= len(question)):\n        if (table_entry == question[k:(k + len(table_entry))]):\n          answer[i] = 1.0\n          matched_indices.append((k, len(table_entry)))\n  return answer, matched_indices\n\n\ndef get_max_entry(a):\n  e = {}\n  for w in a:\n    if (w != \"UNK, \"):\n      if (e.has_key(w)):\n        e[w] += 1\n      else:\n        e[w] = 1\n  if (len(e) > 0):\n    (key, val) = sorted(e.items(), key=lambda x: -1 * x[1])[0]\n    if (val > 1):\n      return key\n    else:\n      return -1.0\n  else:\n    return -1.0\n\n\ndef list_join(a):\n  ans = \"\"\n  for w in a:\n    ans += str(w) + \", \"\n  return ans\n\n\ndef group_by_max(table, number):\n  computes the most frequently occurring entry in a column\n  answer = []\n  for i in range(len(table)):\n    temp = []\n    for j in range(len(table[i])):\n      temp.append(0)\n    answer.append(temp)\n  for i in range(len(table)):\n    if (number):\n      curr = table[i]\n    else:\n      curr = [list_join(w) for w in table[i]]\n    max_entry = get_max_entry(curr)\n    print i, max_entry\n    for j in range(len(curr)):\n      if (max_entry == curr[j]):\n        answer[i][j] = 1.0\n      else:\n        answer[i][j] = 0.0\n  return answer\n\n\ndef pick_one(a):\n  for i in range(len(a)):\n    if (1.0 in a[i]):\n      return True\n  return False\n\n\ndef check_processed_cols(col, utility):\n  return True in [\n      True for y in col\n      if (y != utility.FLAGS.pad_int and y !=\n          utility.FLAGS.bad_number_pre_process)\n  ]\n\n\ndef complete_wiki_processing(data, utility, train=True):\n  convert to integers and padding\n  processed_data = []\n  num_bad_examples = 0\n  for example in data:\n    number_found = 0\n    if (example.is_bad_example):\n      num_bad_examples += 1\n    if (not (example.is_bad_example)):\n      example.string_question = example.question[:]\n      entry match\n      example.processed_number_columns = example.processed_number_columns[:]\n      example.processed_word_columns = example.processed_word_columns[:]\n      example.word_exact_match, word_match, matched_indices = exact_match(\n          example.string_question, example.original_wc, number=False)\n      example.number_exact_match, number_match, _ = exact_match(\n          example.string_question, example.original_nc, number=True)\n      if (not (pick_one(example.word_exact_match)) and not (\n          pick_one(example.number_exact_match))):\n        assert len(word_match) == 0\n        assert len(number_match) == 0\n        example.word_exact_match, word_match = partial_match(\n            example.string_question, example.original_wc, number=False)\n      group by max\n      example.word_group_by_max = group_by_max(example.original_wc, False)\n      example.number_group_by_max = group_by_max(example.original_nc, True)\n      column name match\n      example.word_column_exact_match, wcol_matched_indices = exact_column_match(\n          example.string_question, example.original_wc_names, number=False)\n      example.number_column_exact_match, ncol_matched_indices = exact_column_match(\n          example.string_question, example.original_nc_names, number=False)\n      if (not (1.0 in example.word_column_exact_match) and not (\n          1.0 in example.number_column_exact_match)):\n        example.word_column_exact_match = partial_column_match(\n            example.string_question, example.original_wc_names, number=False)\n        example.number_column_exact_match = partial_column_match(\n            example.string_question, example.original_nc_names, number=False)\n      if (len(word_match) > 0 or len(number_match) > 0):\n        example.question.append(utility.entry_match_token)\n      if (1.0 in example.word_column_exact_match or\n          1.0 in example.number_column_exact_match):\n        example.question.append(utility.column_match_token)\n      example.string_question = example.question[:]\n      example.number_lookup_matrix = np.transpose(\n          example.number_lookup_matrix)[:]\n      example.word_lookup_matrix = np.transpose(example.word_lookup_matrix)[:]\n      example.columns = example.number_columns[:]\n      example.word_columns = example.word_columns[:]\n      example.len_total_cols = len(example.word_column_names) + len(\n          example.number_column_names)\n      example.column_names = example.number_column_names[:]\n      example.word_column_names = example.word_column_names[:]\n      example.string_column_names = example.number_column_names[:]\n      example.string_word_column_names = example.word_column_names[:]\n      example.sorted_number_index = []\n      example.sorted_word_index = []\n      example.column_mask = []\n      example.word_column_mask = []\n      example.processed_column_mask = []\n      example.processed_word_column_mask = []\n      example.word_column_entry_mask = []\n      example.question_attention_mask = []\n      example.question_number = example.question_number_1 = -1\n      example.question_attention_mask = []\n      example.ordinal_question = []\n      example.ordinal_question_one = []\n      new_question = []\n      if (len(example.number_columns) > 0):\n        example.len_col = len(example.number_columns[0])\n      else:\n        example.len_col = len(example.word_columns[0])\n      for (start, length) in matched_indices:\n        for j in range(length):\n          example.question[start + j] = utility.unk_token\n      print example.question\n      for word in example.question:\n        if (isinstance(word, numbers.Number) or wiki_data.is_date(word)):\n          if (not (isinstance(word, numbers.Number)) and\n              wiki_data.is_date(word)):\n            word = word.replace(\"X\", \"\").replace(\"-\", \"\")\n          number_found += 1\n          if (number_found == 1):\n            example.question_number = word\n            if (len(example.ordinal_question) > 0):\n              example.ordinal_question[len(example.ordinal_question) - 1] = 1.0\n            else:\n              example.ordinal_question.append(1.0)\n          elif (number_found == 2):\n            example.question_number_1 = word\n            if (len(example.ordinal_question_one) > 0):\n              example.ordinal_question_one[len(example.ordinal_question_one) -\n                                           1] = 1.0\n            else:\n              example.ordinal_question_one.append(1.0)\n        else:\n          new_question.append(word)\n          example.ordinal_question.append(0.0)\n          example.ordinal_question_one.append(0.0)\n      example.question = [\n          utility.word_ids[word_lookup(w, utility)] for w in new_question\n      ]\n      example.question_attention_mask = [0.0] * len(example.question)\n      when the first question number occurs before a word\n      example.ordinal_question = example.ordinal_question[0:len(\n          example.question)]\n      example.ordinal_question_one = example.ordinal_question_one[0:len(\n          example.question)]\n      question-padding\n      example.question = [utility.word_ids[utility.dummy_token]] * (\n          utility.FLAGS.question_length - len(example.question)\n      ) + example.question\n      example.question_attention_mask = [-10000.0] * (\n          utility.FLAGS.question_length - len(example.question_attention_mask)\n      ) + example.question_attention_mask\n      example.ordinal_question = [0.0] * (utility.FLAGS.question_length -\n                                          len(example.ordinal_question)\n                                         ) + example.ordinal_question\n      example.ordinal_question_one = [0.0] * (utility.FLAGS.question_length -\n                                              len(example.ordinal_question_one)\n                                             ) + example.ordinal_question_one\n      if (True):\n        number columns and related-padding\n        num_cols = len(example.columns)\n        start = 0\n        for column in example.number_columns:\n          if (check_processed_cols(example.processed_number_columns[start],\n                                   utility)):\n            example.processed_column_mask.append(0.0)\n          sorted_index = sorted(\n              range(len(example.processed_number_columns[start])),\n              key=lambda k: example.processed_number_columns[start][k],\n              reverse=True)\n          sorted_index = sorted_index + [utility.FLAGS.pad_int] * (\n              utility.FLAGS.max_elements - len(sorted_index))\n          example.sorted_number_index.append(sorted_index)\n          example.columns[start] = column + [utility.FLAGS.pad_int] * (\n              utility.FLAGS.max_elements - len(column))\n          example.processed_number_columns[start] += [utility.FLAGS.pad_int] * (\n              utility.FLAGS.max_elements -\n              len(example.processed_number_columns[start]))\n          start += 1\n          example.column_mask.append(0.0)\n        for remaining in range(num_cols, utility.FLAGS.max_number_cols):\n          example.sorted_number_index.append([utility.FLAGS.pad_int] *\n                                             (utility.FLAGS.max_elements))\n          example.columns.append([utility.FLAGS.pad_int] *\n                                 (utility.FLAGS.max_elements))\n          example.processed_number_columns.append([utility.FLAGS.pad_int] *\n                                                  (utility.FLAGS.max_elements))\n          example.number_exact_match.append([0.0] *\n                                            (utility.FLAGS.max_elements))\n          example.number_group_by_max.append([0.0] *\n                                             (utility.FLAGS.max_elements))\n          example.column_mask.append(-100000000.0)\n          example.processed_column_mask.append(-100000000.0)\n          example.number_column_exact_match.append(0.0)\n          example.column_names.append([utility.dummy_token])\n        word column  and related-padding\n        start = 0\n        word_num_cols = len(example.word_columns)\n        for column in example.word_columns:\n          if (check_processed_cols(example.processed_word_columns[start],\n                                   utility)):\n            example.processed_word_column_mask.append(0.0)\n          sorted_index = sorted(\n              range(len(example.processed_word_columns[start])),\n              key=lambda k: example.processed_word_columns[start][k],\n              reverse=True)\n          sorted_index = sorted_index + [utility.FLAGS.pad_int] * (\n              utility.FLAGS.max_elements - len(sorted_index))\n          example.sorted_word_index.append(sorted_index)\n          column = convert_to_int_2d_and_pad(column, utility)\n          example.word_columns[start] = column + [[\n              utility.word_ids[utility.dummy_token]\n          ] * utility.FLAGS.max_entry_length] * (utility.FLAGS.max_elements -\n                                                 len(column))\n          example.processed_word_columns[start] += [utility.FLAGS.pad_int] * (\n              utility.FLAGS.max_elements -\n              len(example.processed_word_columns[start]))\n          example.word_column_entry_mask.append([0] * len(column) + [\n              utility.word_ids[utility.dummy_token]\n          ] * (utility.FLAGS.max_elements - len(column)))\n          start += 1\n          example.word_column_mask.append(0.0)\n        for remaining in range(word_num_cols, utility.FLAGS.max_word_cols):\n          example.sorted_word_index.append([utility.FLAGS.pad_int] *\n                                           (utility.FLAGS.max_elements))\n          example.word_columns.append([[utility.word_ids[utility.dummy_token]] *\n                                       utility.FLAGS.max_entry_length] *\n                                      (utility.FLAGS.max_elements))\n          example.word_column_entry_mask.append(\n              [utility.word_ids[utility.dummy_token]] *\n              (utility.FLAGS.max_elements))\n          example.word_exact_match.append([0.0] * (utility.FLAGS.max_elements))\n          example.word_group_by_max.append([0.0] * (utility.FLAGS.max_elements))\n          example.processed_word_columns.append([utility.FLAGS.pad_int] *\n                                                (utility.FLAGS.max_elements))\n          example.word_column_mask.append(-100000000.0)\n          example.processed_word_column_mask.append(-100000000.0)\n          example.word_column_exact_match.append(0.0)\n          example.word_column_names.append([utility.dummy_token] *\n                                           utility.FLAGS.max_entry_length)\n        seen_tables[example.table_key] = 1\n      convert column and word column names to integers\n      example.column_ids = convert_to_int_2d_and_pad(example.column_names,\n                                                     utility)\n      example.word_column_ids = convert_to_int_2d_and_pad(\n          example.word_column_names, utility)\n      for i_em in range(len(example.number_exact_match)):\n        example.number_exact_match[i_em] = example.number_exact_match[\n            i_em] + [0.0] * (utility.FLAGS.max_elements -\n                             len(example.number_exact_match[i_em]))\n        example.number_group_by_max[i_em] = example.number_group_by_max[\n            i_em] + [0.0] * (utility.FLAGS.max_elements -\n                             len(example.number_group_by_max[i_em]))\n      for i_em in range(len(example.word_exact_match)):\n        example.word_exact_match[i_em] = example.word_exact_match[\n            i_em] + [0.0] * (utility.FLAGS.max_elements -\n                             len(example.word_exact_match[i_em]))\n        example.word_group_by_max[i_em] = example.word_group_by_max[\n            i_em] + [0.0] * (utility.FLAGS.max_elements -\n                             len(example.word_group_by_max[i_em]))\n      example.exact_match = example.number_exact_match + example.word_exact_match\n      example.group_by_max = example.number_group_by_max + example.word_group_by_max\n      example.exact_column_match = example.number_column_exact_match + example.word_column_exact_match\n      answer and related mask, padding\n      if (example.is_lookup):\n        example.answer = example.calc_answer\n        example.number_print_answer = example.number_lookup_matrix.tolist()\n        example.word_print_answer = example.word_lookup_matrix.tolist()\n        for i_answer in range(len(example.number_print_answer)):\n          example.number_print_answer[i_answer] = example.number_print_answer[\n              i_answer] + [0.0] * (utility.FLAGS.max_elements -\n                                   len(example.number_print_answer[i_answer]))\n        for i_answer in range(len(example.word_print_answer)):\n          example.word_print_answer[i_answer] = example.word_print_answer[\n              i_answer] + [0.0] * (utility.FLAGS.max_elements -\n                                   len(example.word_print_answer[i_answer]))\n        example.number_lookup_matrix = convert_to_bool_and_pad(\n            example.number_lookup_matrix, utility)\n        example.word_lookup_matrix = convert_to_bool_and_pad(\n            example.word_lookup_matrix, utility)\n        for remaining in range(num_cols, utility.FLAGS.max_number_cols):\n          example.number_lookup_matrix.append([False] *\n                                              utility.FLAGS.max_elements)\n          example.number_print_answer.append([0.0] * utility.FLAGS.max_elements)\n        for remaining in range(word_num_cols, utility.FLAGS.max_word_cols):\n          example.word_lookup_matrix.append([False] *\n                                            utility.FLAGS.max_elements)\n          example.word_print_answer.append([0.0] * utility.FLAGS.max_elements)\n        example.print_answer = example.number_print_answer + example.word_print_answer\n      else:\n        example.answer = example.calc_answer\n        example.print_answer = [[0.0] * (utility.FLAGS.max_elements)] * (\n            utility.FLAGS.max_number_cols + utility.FLAGS.max_word_cols)\n      question_number masks\n      if (example.question_number == -1):\n        example.question_number_mask = np.zeros([utility.FLAGS.max_elements])\n      else:\n        example.question_number_mask = np.ones([utility.FLAGS.max_elements])\n      if (example.question_number_1 == -1):\n        example.question_number_one_mask = -10000.0\n      else:\n        example.question_number_one_mask = np.float64(0.0)\n      if (example.len_col > utility.FLAGS.max_elements):\n        continue\n      processed_data.append(example)\n  return processed_data\n\n\ndef add_special_words(utility):\n  utility.words.append(utility.entry_match_token)\n  utility.word_ids[utility.entry_match_token] = len(utility.word_ids)\n  utility.reverse_word_ids[utility.word_ids[\n      utility.entry_match_token]] = utility.entry_match_token\n  utility.entry_match_token_id = utility.word_ids[utility.entry_match_token]\n  print(\"entry match token: \", utility.word_ids[\n      utility.entry_match_token], utility.entry_match_token_id)\n  utility.words.append(utility.column_match_token)\n  utility.word_ids[utility.column_match_token] = len(utility.word_ids)\n  utility.reverse_word_ids[utility.word_ids[\n      utility.column_match_token]] = utility.column_match_token\n  utility.column_match_token_id = utility.word_ids[utility.column_match_token]\n  print(\"entry match token: \", utility.word_ids[\n      utility.column_match_token], utility.column_match_token_id)\n  utility.words.append(utility.dummy_token)\n  utility.word_ids[utility.dummy_token] = len(utility.word_ids)\n  utility.reverse_word_ids[utility.word_ids[\n      utility.dummy_token]] = utility.dummy_token\n  utility.dummy_token_id = utility.word_ids[utility.dummy_token]\n  utility.words.append(utility.unk_token)\n  utility.word_ids[utility.unk_token] = len(utility.word_ids)\n  utility.reverse_word_ids[utility.word_ids[\n      utility.unk_token]] = utility.unk_token\n\n\ndef perform_word_cutoff(utility):\n  if (utility.FLAGS.word_cutoff > 0):\n    for word in utility.word_ids.keys():\n      if (utility.word_count.has_key(word) and utility.word_count[word] <\n          utility.FLAGS.word_cutoff and word != utility.unk_token and\n          word != utility.dummy_token and word != utility.entry_match_token and\n          word != utility.column_match_token):\n        utility.word_ids.pop(word)\n        utility.words.remove(word)\n\n\ndef word_dropout(question, utility):\n  if (utility.FLAGS.word_dropout_prob > 0.0):\n    new_question = []\n    for i in range(len(question)):\n      if (question[i] != utility.dummy_token_id and\n          utility.random.random() > utility.FLAGS.word_dropout_prob):\n        new_question.append(utility.word_ids[utility.unk_token])\n      else:\n        new_question.append(question[i])\n    return new_question\n  else:\n    return question\n\n\ndef generate_feed_dict(data, curr, batch_size, gr, train=False, utility=None):\n  prepare feed dict dictionary\n  feed_dict = {}\n  feed_examples = []\n  for j in range(batch_size):\n    feed_examples.append(data[curr + j])\n  if (train):\n    feed_dict[gr.batch_question] = [\n        word_dropout(feed_examples[j].question, utility)\n        for j in range(batch_size)\n    ]\n  else:\n    feed_dict[gr.batch_question] = [\n        feed_examples[j].question for j in range(batch_size)\n    ]\n  feed_dict[gr.batch_question_attention_mask] = [\n      feed_examples[j].question_attention_mask for j in range(batch_size)\n  ]\n  feed_dict[\n      gr.batch_answer] = [feed_examples[j].answer for j in range(batch_size)]\n  feed_dict[gr.batch_number_column] = [\n      feed_examples[j].columns for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_processed_number_column] = [\n      feed_examples[j].processed_number_columns for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_processed_sorted_index_number_column] = [\n      feed_examples[j].sorted_number_index for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_processed_sorted_index_word_column] = [\n      feed_examples[j].sorted_word_index for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_question_number] = np.array(\n      [feed_examples[j].question_number for j in range(batch_size)]).reshape(\n          (batch_size, 1))\n  feed_dict[gr.batch_question_number_one] = np.array(\n      [feed_examples[j].question_number_1 for j in range(batch_size)]).reshape(\n          (batch_size, 1))\n  feed_dict[gr.batch_question_number_mask] = [\n      feed_examples[j].question_number_mask for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_question_number_one_mask] = np.array(\n      [feed_examples[j].question_number_one_mask for j in range(batch_size)\n      ]).reshape((batch_size, 1))\n  feed_dict[gr.batch_print_answer] = [\n      feed_examples[j].print_answer for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_exact_match] = [\n      feed_examples[j].exact_match for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_group_by_max] = [\n      feed_examples[j].group_by_max for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_column_exact_match] = [\n      feed_examples[j].exact_column_match for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_ordinal_question] = [\n      feed_examples[j].ordinal_question for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_ordinal_question_one] = [\n      feed_examples[j].ordinal_question_one for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_number_column_mask] = [\n      feed_examples[j].column_mask for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_number_column_names] = [\n      feed_examples[j].column_ids for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_processed_word_column] = [\n      feed_examples[j].processed_word_columns for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_word_column_mask] = [\n      feed_examples[j].word_column_mask for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_word_column_names] = [\n      feed_examples[j].word_column_ids for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_word_column_entry_mask] = [\n      feed_examples[j].word_column_entry_mask for j in range(batch_size)\n  ]\n  return feed_dict\n", "comments": "   functions constructing vocabulary  converting examples integer format building required masks batch computation author  aneelakantan (arvind neelakantan)        copyright 2016 google inc  all rights reserved        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license       http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license                                                                                      print   print ans   performs exact match operation   if(len(table entry)    1)    print  match     table entry  question   performs exact match column names   computes frequently occurring entry column   print  max entry   convert integers padding   entry match   group max   column name match   print example question   first question number occurs word   question padding   number columns related padding   word column  related padding   convert column word column names integers   answer related mask  padding   question number masks   prepare feed dict dictionary ", "content": "# Copyright 2016 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Functions for constructing vocabulary, converting the examples to integer format and building the required masks for batch computation Author: aneelakantan (Arvind Neelakantan)\n\"\"\"\n\nfrom __future__ import print_function\n\nimport copy\nimport numbers\nimport numpy as np\nimport wiki_data\n\n\ndef return_index(a):\n  for i in range(len(a)):\n    if (a[i] == 1.0):\n      return i\n\n\ndef construct_vocab(data, utility, add_word=False):\n  ans = []\n  for example in data:\n    sent = \"\"\n    for word in example.question:\n      if (not (isinstance(word, numbers.Number))):\n        sent += word + \" \"\n    example.original_nc = copy.deepcopy(example.number_columns)\n    example.original_wc = copy.deepcopy(example.word_columns)\n    example.original_nc_names = copy.deepcopy(example.number_column_names)\n    example.original_wc_names = copy.deepcopy(example.word_column_names)\n    if (add_word):\n      continue\n    number_found = 0\n    if (not (example.is_bad_example)):\n      for word in example.question:\n        if (isinstance(word, numbers.Number)):\n          number_found += 1\n        else:\n          if (not (utility.word_ids.has_key(word))):\n            utility.words.append(word)\n            utility.word_count[word] = 1\n            utility.word_ids[word] = len(utility.word_ids)\n            utility.reverse_word_ids[utility.word_ids[word]] = word\n          else:\n            utility.word_count[word] += 1\n      for col_name in example.word_column_names:\n        for word in col_name:\n          if (isinstance(word, numbers.Number)):\n            number_found += 1\n          else:\n            if (not (utility.word_ids.has_key(word))):\n              utility.words.append(word)\n              utility.word_count[word] = 1\n              utility.word_ids[word] = len(utility.word_ids)\n              utility.reverse_word_ids[utility.word_ids[word]] = word\n            else:\n              utility.word_count[word] += 1\n      for col_name in example.number_column_names:\n        for word in col_name:\n          if (isinstance(word, numbers.Number)):\n            number_found += 1\n          else:\n            if (not (utility.word_ids.has_key(word))):\n              utility.words.append(word)\n              utility.word_count[word] = 1\n              utility.word_ids[word] = len(utility.word_ids)\n              utility.reverse_word_ids[utility.word_ids[word]] = word\n            else:\n              utility.word_count[word] += 1\n\n\ndef word_lookup(word, utility):\n  if (utility.word_ids.has_key(word)):\n    return word\n  else:\n    return utility.unk_token\n\n\ndef convert_to_int_2d_and_pad(a, utility):\n  ans = []\n  #print a\n  for b in a:\n    temp = []\n    if (len(b) > utility.FLAGS.max_entry_length):\n      b = b[0:utility.FLAGS.max_entry_length]\n    for remaining in range(len(b), utility.FLAGS.max_entry_length):\n      b.append(utility.dummy_token)\n    assert len(b) == utility.FLAGS.max_entry_length\n    for word in b:\n      temp.append(utility.word_ids[word_lookup(word, utility)])\n    ans.append(temp)\n  #print ans\n  return ans\n\n\ndef convert_to_bool_and_pad(a, utility):\n  a = a.tolist()\n  for i in range(len(a)):\n    for j in range(len(a[i])):\n      if (a[i][j] < 1):\n        a[i][j] = False\n      else:\n        a[i][j] = True\n    a[i] = a[i] + [False] * (utility.FLAGS.max_elements - len(a[i]))\n  return a\n\n\nseen_tables = {}\n\n\ndef partial_match(question, table, number):\n  answer = []\n  match = {}\n  for i in range(len(table)):\n    temp = []\n    for j in range(len(table[i])):\n      temp.append(0)\n    answer.append(temp)\n  for i in range(len(table)):\n    for j in range(len(table[i])):\n      for word in question:\n        if (number):\n          if (word == table[i][j]):\n            answer[i][j] = 1.0\n            match[i] = 1.0\n        else:\n          if (word in table[i][j]):\n            answer[i][j] = 1.0\n            match[i] = 1.0\n  return answer, match\n\n\ndef exact_match(question, table, number):\n  #performs exact match operation\n  answer = []\n  match = {}\n  matched_indices = []\n  for i in range(len(table)):\n    temp = []\n    for j in range(len(table[i])):\n      temp.append(0)\n    answer.append(temp)\n  for i in range(len(table)):\n    for j in range(len(table[i])):\n      if (number):\n        for word in question:\n          if (word == table[i][j]):\n            match[i] = 1.0\n            answer[i][j] = 1.0\n      else:\n        table_entry = table[i][j]\n        for k in range(len(question)):\n          if (k + len(table_entry) <= len(question)):\n            if (table_entry == question[k:(k + len(table_entry))]):\n              #if(len(table_entry) == 1):\n              #print \"match: \", table_entry, question\n              match[i] = 1.0\n              answer[i][j] = 1.0\n              matched_indices.append((k, len(table_entry)))\n  return answer, match, matched_indices\n\n\ndef partial_column_match(question, table, number):\n  answer = []\n  for i in range(len(table)):\n    answer.append(0)\n  for i in range(len(table)):\n    for word in question:\n      if (word in table[i]):\n        answer[i] = 1.0\n  return answer\n\n\ndef exact_column_match(question, table, number):\n  #performs exact match on column names\n  answer = []\n  matched_indices = []\n  for i in range(len(table)):\n    answer.append(0)\n  for i in range(len(table)):\n    table_entry = table[i]\n    for k in range(len(question)):\n      if (k + len(table_entry) <= len(question)):\n        if (table_entry == question[k:(k + len(table_entry))]):\n          answer[i] = 1.0\n          matched_indices.append((k, len(table_entry)))\n  return answer, matched_indices\n\n\ndef get_max_entry(a):\n  e = {}\n  for w in a:\n    if (w != \"UNK, \"):\n      if (e.has_key(w)):\n        e[w] += 1\n      else:\n        e[w] = 1\n  if (len(e) > 0):\n    (key, val) = sorted(e.items(), key=lambda x: -1 * x[1])[0]\n    if (val > 1):\n      return key\n    else:\n      return -1.0\n  else:\n    return -1.0\n\n\ndef list_join(a):\n  ans = \"\"\n  for w in a:\n    ans += str(w) + \", \"\n  return ans\n\n\ndef group_by_max(table, number):\n  #computes the most frequently occurring entry in a column\n  answer = []\n  for i in range(len(table)):\n    temp = []\n    for j in range(len(table[i])):\n      temp.append(0)\n    answer.append(temp)\n  for i in range(len(table)):\n    if (number):\n      curr = table[i]\n    else:\n      curr = [list_join(w) for w in table[i]]\n    max_entry = get_max_entry(curr)\n    #print i, max_entry\n    for j in range(len(curr)):\n      if (max_entry == curr[j]):\n        answer[i][j] = 1.0\n      else:\n        answer[i][j] = 0.0\n  return answer\n\n\ndef pick_one(a):\n  for i in range(len(a)):\n    if (1.0 in a[i]):\n      return True\n  return False\n\n\ndef check_processed_cols(col, utility):\n  return True in [\n      True for y in col\n      if (y != utility.FLAGS.pad_int and y !=\n          utility.FLAGS.bad_number_pre_process)\n  ]\n\n\ndef complete_wiki_processing(data, utility, train=True):\n  #convert to integers and padding\n  processed_data = []\n  num_bad_examples = 0\n  for example in data:\n    number_found = 0\n    if (example.is_bad_example):\n      num_bad_examples += 1\n    if (not (example.is_bad_example)):\n      example.string_question = example.question[:]\n      #entry match\n      example.processed_number_columns = example.processed_number_columns[:]\n      example.processed_word_columns = example.processed_word_columns[:]\n      example.word_exact_match, word_match, matched_indices = exact_match(\n          example.string_question, example.original_wc, number=False)\n      example.number_exact_match, number_match, _ = exact_match(\n          example.string_question, example.original_nc, number=True)\n      if (not (pick_one(example.word_exact_match)) and not (\n          pick_one(example.number_exact_match))):\n        assert len(word_match) == 0\n        assert len(number_match) == 0\n        example.word_exact_match, word_match = partial_match(\n            example.string_question, example.original_wc, number=False)\n      #group by max\n      example.word_group_by_max = group_by_max(example.original_wc, False)\n      example.number_group_by_max = group_by_max(example.original_nc, True)\n      #column name match\n      example.word_column_exact_match, wcol_matched_indices = exact_column_match(\n          example.string_question, example.original_wc_names, number=False)\n      example.number_column_exact_match, ncol_matched_indices = exact_column_match(\n          example.string_question, example.original_nc_names, number=False)\n      if (not (1.0 in example.word_column_exact_match) and not (\n          1.0 in example.number_column_exact_match)):\n        example.word_column_exact_match = partial_column_match(\n            example.string_question, example.original_wc_names, number=False)\n        example.number_column_exact_match = partial_column_match(\n            example.string_question, example.original_nc_names, number=False)\n      if (len(word_match) > 0 or len(number_match) > 0):\n        example.question.append(utility.entry_match_token)\n      if (1.0 in example.word_column_exact_match or\n          1.0 in example.number_column_exact_match):\n        example.question.append(utility.column_match_token)\n      example.string_question = example.question[:]\n      example.number_lookup_matrix = np.transpose(\n          example.number_lookup_matrix)[:]\n      example.word_lookup_matrix = np.transpose(example.word_lookup_matrix)[:]\n      example.columns = example.number_columns[:]\n      example.word_columns = example.word_columns[:]\n      example.len_total_cols = len(example.word_column_names) + len(\n          example.number_column_names)\n      example.column_names = example.number_column_names[:]\n      example.word_column_names = example.word_column_names[:]\n      example.string_column_names = example.number_column_names[:]\n      example.string_word_column_names = example.word_column_names[:]\n      example.sorted_number_index = []\n      example.sorted_word_index = []\n      example.column_mask = []\n      example.word_column_mask = []\n      example.processed_column_mask = []\n      example.processed_word_column_mask = []\n      example.word_column_entry_mask = []\n      example.question_attention_mask = []\n      example.question_number = example.question_number_1 = -1\n      example.question_attention_mask = []\n      example.ordinal_question = []\n      example.ordinal_question_one = []\n      new_question = []\n      if (len(example.number_columns) > 0):\n        example.len_col = len(example.number_columns[0])\n      else:\n        example.len_col = len(example.word_columns[0])\n      for (start, length) in matched_indices:\n        for j in range(length):\n          example.question[start + j] = utility.unk_token\n      #print example.question\n      for word in example.question:\n        if (isinstance(word, numbers.Number) or wiki_data.is_date(word)):\n          if (not (isinstance(word, numbers.Number)) and\n              wiki_data.is_date(word)):\n            word = word.replace(\"X\", \"\").replace(\"-\", \"\")\n          number_found += 1\n          if (number_found == 1):\n            example.question_number = word\n            if (len(example.ordinal_question) > 0):\n              example.ordinal_question[len(example.ordinal_question) - 1] = 1.0\n            else:\n              example.ordinal_question.append(1.0)\n          elif (number_found == 2):\n            example.question_number_1 = word\n            if (len(example.ordinal_question_one) > 0):\n              example.ordinal_question_one[len(example.ordinal_question_one) -\n                                           1] = 1.0\n            else:\n              example.ordinal_question_one.append(1.0)\n        else:\n          new_question.append(word)\n          example.ordinal_question.append(0.0)\n          example.ordinal_question_one.append(0.0)\n      example.question = [\n          utility.word_ids[word_lookup(w, utility)] for w in new_question\n      ]\n      example.question_attention_mask = [0.0] * len(example.question)\n      #when the first question number occurs before a word\n      example.ordinal_question = example.ordinal_question[0:len(\n          example.question)]\n      example.ordinal_question_one = example.ordinal_question_one[0:len(\n          example.question)]\n      #question-padding\n      example.question = [utility.word_ids[utility.dummy_token]] * (\n          utility.FLAGS.question_length - len(example.question)\n      ) + example.question\n      example.question_attention_mask = [-10000.0] * (\n          utility.FLAGS.question_length - len(example.question_attention_mask)\n      ) + example.question_attention_mask\n      example.ordinal_question = [0.0] * (utility.FLAGS.question_length -\n                                          len(example.ordinal_question)\n                                         ) + example.ordinal_question\n      example.ordinal_question_one = [0.0] * (utility.FLAGS.question_length -\n                                              len(example.ordinal_question_one)\n                                             ) + example.ordinal_question_one\n      if (True):\n        #number columns and related-padding\n        num_cols = len(example.columns)\n        start = 0\n        for column in example.number_columns:\n          if (check_processed_cols(example.processed_number_columns[start],\n                                   utility)):\n            example.processed_column_mask.append(0.0)\n          sorted_index = sorted(\n              range(len(example.processed_number_columns[start])),\n              key=lambda k: example.processed_number_columns[start][k],\n              reverse=True)\n          sorted_index = sorted_index + [utility.FLAGS.pad_int] * (\n              utility.FLAGS.max_elements - len(sorted_index))\n          example.sorted_number_index.append(sorted_index)\n          example.columns[start] = column + [utility.FLAGS.pad_int] * (\n              utility.FLAGS.max_elements - len(column))\n          example.processed_number_columns[start] += [utility.FLAGS.pad_int] * (\n              utility.FLAGS.max_elements -\n              len(example.processed_number_columns[start]))\n          start += 1\n          example.column_mask.append(0.0)\n        for remaining in range(num_cols, utility.FLAGS.max_number_cols):\n          example.sorted_number_index.append([utility.FLAGS.pad_int] *\n                                             (utility.FLAGS.max_elements))\n          example.columns.append([utility.FLAGS.pad_int] *\n                                 (utility.FLAGS.max_elements))\n          example.processed_number_columns.append([utility.FLAGS.pad_int] *\n                                                  (utility.FLAGS.max_elements))\n          example.number_exact_match.append([0.0] *\n                                            (utility.FLAGS.max_elements))\n          example.number_group_by_max.append([0.0] *\n                                             (utility.FLAGS.max_elements))\n          example.column_mask.append(-100000000.0)\n          example.processed_column_mask.append(-100000000.0)\n          example.number_column_exact_match.append(0.0)\n          example.column_names.append([utility.dummy_token])\n        #word column  and related-padding\n        start = 0\n        word_num_cols = len(example.word_columns)\n        for column in example.word_columns:\n          if (check_processed_cols(example.processed_word_columns[start],\n                                   utility)):\n            example.processed_word_column_mask.append(0.0)\n          sorted_index = sorted(\n              range(len(example.processed_word_columns[start])),\n              key=lambda k: example.processed_word_columns[start][k],\n              reverse=True)\n          sorted_index = sorted_index + [utility.FLAGS.pad_int] * (\n              utility.FLAGS.max_elements - len(sorted_index))\n          example.sorted_word_index.append(sorted_index)\n          column = convert_to_int_2d_and_pad(column, utility)\n          example.word_columns[start] = column + [[\n              utility.word_ids[utility.dummy_token]\n          ] * utility.FLAGS.max_entry_length] * (utility.FLAGS.max_elements -\n                                                 len(column))\n          example.processed_word_columns[start] += [utility.FLAGS.pad_int] * (\n              utility.FLAGS.max_elements -\n              len(example.processed_word_columns[start]))\n          example.word_column_entry_mask.append([0] * len(column) + [\n              utility.word_ids[utility.dummy_token]\n          ] * (utility.FLAGS.max_elements - len(column)))\n          start += 1\n          example.word_column_mask.append(0.0)\n        for remaining in range(word_num_cols, utility.FLAGS.max_word_cols):\n          example.sorted_word_index.append([utility.FLAGS.pad_int] *\n                                           (utility.FLAGS.max_elements))\n          example.word_columns.append([[utility.word_ids[utility.dummy_token]] *\n                                       utility.FLAGS.max_entry_length] *\n                                      (utility.FLAGS.max_elements))\n          example.word_column_entry_mask.append(\n              [utility.word_ids[utility.dummy_token]] *\n              (utility.FLAGS.max_elements))\n          example.word_exact_match.append([0.0] * (utility.FLAGS.max_elements))\n          example.word_group_by_max.append([0.0] * (utility.FLAGS.max_elements))\n          example.processed_word_columns.append([utility.FLAGS.pad_int] *\n                                                (utility.FLAGS.max_elements))\n          example.word_column_mask.append(-100000000.0)\n          example.processed_word_column_mask.append(-100000000.0)\n          example.word_column_exact_match.append(0.0)\n          example.word_column_names.append([utility.dummy_token] *\n                                           utility.FLAGS.max_entry_length)\n        seen_tables[example.table_key] = 1\n      #convert column and word column names to integers\n      example.column_ids = convert_to_int_2d_and_pad(example.column_names,\n                                                     utility)\n      example.word_column_ids = convert_to_int_2d_and_pad(\n          example.word_column_names, utility)\n      for i_em in range(len(example.number_exact_match)):\n        example.number_exact_match[i_em] = example.number_exact_match[\n            i_em] + [0.0] * (utility.FLAGS.max_elements -\n                             len(example.number_exact_match[i_em]))\n        example.number_group_by_max[i_em] = example.number_group_by_max[\n            i_em] + [0.0] * (utility.FLAGS.max_elements -\n                             len(example.number_group_by_max[i_em]))\n      for i_em in range(len(example.word_exact_match)):\n        example.word_exact_match[i_em] = example.word_exact_match[\n            i_em] + [0.0] * (utility.FLAGS.max_elements -\n                             len(example.word_exact_match[i_em]))\n        example.word_group_by_max[i_em] = example.word_group_by_max[\n            i_em] + [0.0] * (utility.FLAGS.max_elements -\n                             len(example.word_group_by_max[i_em]))\n      example.exact_match = example.number_exact_match + example.word_exact_match\n      example.group_by_max = example.number_group_by_max + example.word_group_by_max\n      example.exact_column_match = example.number_column_exact_match + example.word_column_exact_match\n      #answer and related mask, padding\n      if (example.is_lookup):\n        example.answer = example.calc_answer\n        example.number_print_answer = example.number_lookup_matrix.tolist()\n        example.word_print_answer = example.word_lookup_matrix.tolist()\n        for i_answer in range(len(example.number_print_answer)):\n          example.number_print_answer[i_answer] = example.number_print_answer[\n              i_answer] + [0.0] * (utility.FLAGS.max_elements -\n                                   len(example.number_print_answer[i_answer]))\n        for i_answer in range(len(example.word_print_answer)):\n          example.word_print_answer[i_answer] = example.word_print_answer[\n              i_answer] + [0.0] * (utility.FLAGS.max_elements -\n                                   len(example.word_print_answer[i_answer]))\n        example.number_lookup_matrix = convert_to_bool_and_pad(\n            example.number_lookup_matrix, utility)\n        example.word_lookup_matrix = convert_to_bool_and_pad(\n            example.word_lookup_matrix, utility)\n        for remaining in range(num_cols, utility.FLAGS.max_number_cols):\n          example.number_lookup_matrix.append([False] *\n                                              utility.FLAGS.max_elements)\n          example.number_print_answer.append([0.0] * utility.FLAGS.max_elements)\n        for remaining in range(word_num_cols, utility.FLAGS.max_word_cols):\n          example.word_lookup_matrix.append([False] *\n                                            utility.FLAGS.max_elements)\n          example.word_print_answer.append([0.0] * utility.FLAGS.max_elements)\n        example.print_answer = example.number_print_answer + example.word_print_answer\n      else:\n        example.answer = example.calc_answer\n        example.print_answer = [[0.0] * (utility.FLAGS.max_elements)] * (\n            utility.FLAGS.max_number_cols + utility.FLAGS.max_word_cols)\n      #question_number masks\n      if (example.question_number == -1):\n        example.question_number_mask = np.zeros([utility.FLAGS.max_elements])\n      else:\n        example.question_number_mask = np.ones([utility.FLAGS.max_elements])\n      if (example.question_number_1 == -1):\n        example.question_number_one_mask = -10000.0\n      else:\n        example.question_number_one_mask = np.float64(0.0)\n      if (example.len_col > utility.FLAGS.max_elements):\n        continue\n      processed_data.append(example)\n  return processed_data\n\n\ndef add_special_words(utility):\n  utility.words.append(utility.entry_match_token)\n  utility.word_ids[utility.entry_match_token] = len(utility.word_ids)\n  utility.reverse_word_ids[utility.word_ids[\n      utility.entry_match_token]] = utility.entry_match_token\n  utility.entry_match_token_id = utility.word_ids[utility.entry_match_token]\n  print(\"entry match token: \", utility.word_ids[\n      utility.entry_match_token], utility.entry_match_token_id)\n  utility.words.append(utility.column_match_token)\n  utility.word_ids[utility.column_match_token] = len(utility.word_ids)\n  utility.reverse_word_ids[utility.word_ids[\n      utility.column_match_token]] = utility.column_match_token\n  utility.column_match_token_id = utility.word_ids[utility.column_match_token]\n  print(\"entry match token: \", utility.word_ids[\n      utility.column_match_token], utility.column_match_token_id)\n  utility.words.append(utility.dummy_token)\n  utility.word_ids[utility.dummy_token] = len(utility.word_ids)\n  utility.reverse_word_ids[utility.word_ids[\n      utility.dummy_token]] = utility.dummy_token\n  utility.dummy_token_id = utility.word_ids[utility.dummy_token]\n  utility.words.append(utility.unk_token)\n  utility.word_ids[utility.unk_token] = len(utility.word_ids)\n  utility.reverse_word_ids[utility.word_ids[\n      utility.unk_token]] = utility.unk_token\n\n\ndef perform_word_cutoff(utility):\n  if (utility.FLAGS.word_cutoff > 0):\n    for word in utility.word_ids.keys():\n      if (utility.word_count.has_key(word) and utility.word_count[word] <\n          utility.FLAGS.word_cutoff and word != utility.unk_token and\n          word != utility.dummy_token and word != utility.entry_match_token and\n          word != utility.column_match_token):\n        utility.word_ids.pop(word)\n        utility.words.remove(word)\n\n\ndef word_dropout(question, utility):\n  if (utility.FLAGS.word_dropout_prob > 0.0):\n    new_question = []\n    for i in range(len(question)):\n      if (question[i] != utility.dummy_token_id and\n          utility.random.random() > utility.FLAGS.word_dropout_prob):\n        new_question.append(utility.word_ids[utility.unk_token])\n      else:\n        new_question.append(question[i])\n    return new_question\n  else:\n    return question\n\n\ndef generate_feed_dict(data, curr, batch_size, gr, train=False, utility=None):\n  #prepare feed dict dictionary\n  feed_dict = {}\n  feed_examples = []\n  for j in range(batch_size):\n    feed_examples.append(data[curr + j])\n  if (train):\n    feed_dict[gr.batch_question] = [\n        word_dropout(feed_examples[j].question, utility)\n        for j in range(batch_size)\n    ]\n  else:\n    feed_dict[gr.batch_question] = [\n        feed_examples[j].question for j in range(batch_size)\n    ]\n  feed_dict[gr.batch_question_attention_mask] = [\n      feed_examples[j].question_attention_mask for j in range(batch_size)\n  ]\n  feed_dict[\n      gr.batch_answer] = [feed_examples[j].answer for j in range(batch_size)]\n  feed_dict[gr.batch_number_column] = [\n      feed_examples[j].columns for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_processed_number_column] = [\n      feed_examples[j].processed_number_columns for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_processed_sorted_index_number_column] = [\n      feed_examples[j].sorted_number_index for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_processed_sorted_index_word_column] = [\n      feed_examples[j].sorted_word_index for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_question_number] = np.array(\n      [feed_examples[j].question_number for j in range(batch_size)]).reshape(\n          (batch_size, 1))\n  feed_dict[gr.batch_question_number_one] = np.array(\n      [feed_examples[j].question_number_1 for j in range(batch_size)]).reshape(\n          (batch_size, 1))\n  feed_dict[gr.batch_question_number_mask] = [\n      feed_examples[j].question_number_mask for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_question_number_one_mask] = np.array(\n      [feed_examples[j].question_number_one_mask for j in range(batch_size)\n      ]).reshape((batch_size, 1))\n  feed_dict[gr.batch_print_answer] = [\n      feed_examples[j].print_answer for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_exact_match] = [\n      feed_examples[j].exact_match for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_group_by_max] = [\n      feed_examples[j].group_by_max for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_column_exact_match] = [\n      feed_examples[j].exact_column_match for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_ordinal_question] = [\n      feed_examples[j].ordinal_question for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_ordinal_question_one] = [\n      feed_examples[j].ordinal_question_one for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_number_column_mask] = [\n      feed_examples[j].column_mask for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_number_column_names] = [\n      feed_examples[j].column_ids for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_processed_word_column] = [\n      feed_examples[j].processed_word_columns for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_word_column_mask] = [\n      feed_examples[j].word_column_mask for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_word_column_names] = [\n      feed_examples[j].word_column_ids for j in range(batch_size)\n  ]\n  feed_dict[gr.batch_word_column_entry_mask] = [\n      feed_examples[j].word_column_entry_mask for j in range(batch_size)\n  ]\n  return feed_dict\n", "description": "Models and examples built with TensorFlow", "file_name": "data_utils.py", "id": "ffc32607dd9d2cea90764ee5b96bdd1f", "language": "Python", "project_name": "models", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/tensorflow-models/tensorflow-models-086d914/research/neural_programmer/data_utils.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:59:19Z", "url": "https://github.com/tensorflow/models", "wiki": true}