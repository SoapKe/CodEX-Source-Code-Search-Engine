{"author": "ansible", "code": "\n\n Copyright: Ansible Team\n GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = \"\"\"\n---\nmodule: aireos_config\nversion_added: \"2.4\"\nauthor: \"James Mighion (@jmighion)\"\nshort_description: Manage Cisco WLC configurations\ndescription:\n  - AireOS does not use a block indent file syntax, so there are no sections or parents.\n    This module provides an implementation for working with AireOS configurations in\n    a deterministic way.\nextends_documentation_fragment: aireos\noptions:\n  lines:\n    description:\n      - The ordered set of commands that should be configured.\n        The commands must be the exact same commands as found\n        in the device run-config.  Be sure to note the configuration\n        command syntax as some commands are automatically modified by the\n        device config parser.\n    aliases: ['commands']\n  src:\n    description:\n      - Specifies the source path to the file that contains the configuration\n        or configuration template to load.  The path to the source file can\n        either be the full path on the Ansible control host or a relative\n        path from the playbook or role root directory.  This argument is mutually\n        exclusive with I(lines).\n  before:\n    description:\n      - The ordered set of commands to push on to the command stack if\n        a change needs to be made.  This allows the playbook designer\n        the opportunity to perform configuration commands prior to pushing\n        any changes without affecting how the set of commands are matched\n        against the system.\n  after:\n    description:\n      - The ordered set of commands to append to the end of the command\n        stack if a change needs to be made.  Just like with I(before) this\n        allows the playbook designer to append a set of commands to be\n        executed after the command set.\n  match:\n    description:\n      - Instructs the module on the way to perform the matching of\n        the set of commands against the current device config.  If\n        match is set to I(line), commands are matched line by line.\n        If match is set to I(none), the module will not attempt to\n        compare the source configuration with the running\n        configuration on the remote device.\n    default: line\n    choices: ['line', 'none']\n  backup:\n    description:\n      - This argument will cause the module to create a full backup of\n        the current C(running-config) from the remote device before any\n        changes are made.  The backup file is written to the C(backup)\n        folder in the playbook root directory.  If the directory does not\n        exist, it is created.\n    type: bool\n    default: 'no'\n  running_config:\n    description:\n      - The module, by default, will connect to the remote device and\n        retrieve the current running-config to use as a base for comparing\n        against the contents of source.  There are times when it is not\n        desirable to have the task get the current running-config for\n        every task in a playbook.  The I(running_config) argument allows the\n        implementer to pass in the configuration to use as the base\n        config for comparison.\n    aliases: ['config']\n  save:\n    description:\n      - The C(save) argument instructs the module to save the running-\n        config to the startup-config at the conclusion of the module\n        running.  If check mode is specified, this argument is ignored.\n    type: bool\n    default: 'no'\n  diff_against:\n    description:\n      - When using the C(ansible-playbook --diff) command line argument\n        the module can generate diffs against different sources.\n      - When this option is configured as I(intended), the module will\n        return the diff of the running-config against the configuration\n        provided in the C(intended_config) argument.\n      - When this option is configured as I(running), the module will\n        return the before and after diff of the running-config with respect\n        to any changes made to the device configuration.\n    choices: ['intended', 'running']\n  diff_ignore_lines:\n    description:\n      - Use this argument to specify one or more lines that should be\n        ignored during the diff.  This is used for lines in the configuration\n        that are automatically updated by the system.  This argument takes\n        a list of regular expressions or exact line matches.\n  intended_config:\n    description:\n      - The C(intended_config) provides the master configuration that\n        the node should conform to and is used to check the final\n        running-config against.   This argument will not modify any settings\n        on the remote device and is strictly used to check the compliance\n        of the current device's configuration against.  When specifying this\n        argument, the task should also modify the C(diff_against) value and\n        set it to I(intended).\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: configure configuration\n  aireos_config:\n    lines: sysname testDevice\n\n- name: diff the running-config against a provided config\n  aireos_config:\n    diff_against: intended\n    intended: \"{{ lookup('file', 'master.cfg') }}\"\n\n- name: load new acl into device\n  aireos_config:\n    lines:\n      - acl create testACL\n      - acl rule protocol testACL 1 any\n      - acl rule direction testACL 3 in\n    before: acl delete testACL\n\"\"\"\n\nRETURN = \"\"\"\ncommands:\n  description: The set of commands that will be pushed to the remote device\n  returned: always\n  type: list\n  sample: ['hostname foo', 'vlan 1', 'name default']\nupdates:\n  description: The set of commands that will be pushed to the remote device\n  returned: always\n  type: list\n  sample: ['hostname foo', 'vlan 1', 'name default']\nbackup_path:\n  description: The full path to the backup file\n  returned: when backup is yes\n  type: string\n  sample: /playbooks/ansible/backup/aireos_config.2016-07-16@22:28:34\n\"\"\"\nfrom ansible.module_utils.network.aireos.aireos import run_commands, get_config, load_config\nfrom ansible.module_utils.network.aireos.aireos import aireos_argument_spec\nfrom ansible.module_utils.network.aireos.aireos import check_args as aireos_check_args\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.network.common.config import NetworkConfig, dumps\n\n\ndef get_running_config(module, config=None):\n    contents = module.params['running_config']\n    if not contents:\n        if config:\n            contents = config\n        else:\n            contents = get_config(module)\n    return NetworkConfig(indent=1, contents=contents)\n\n\ndef get_candidate(module):\n    candidate = NetworkConfig(indent=1)\n\n    if module.params['src']:\n        candidate.load(module.params['src'])\n    elif module.params['lines']:\n        candidate.add(module.params['lines'])\n    return candidate\n\n\ndef main():\n    \"\"\" main entry point for module execution\n    \"\"\"\n    argument_spec = dict(\n        src=dict(type='path'),\n\n        lines=dict(aliases=['commands'], type='list'),\n\n        before=dict(type='list'),\n        after=dict(type='list'),\n\n        match=dict(default='line', choices=['line', 'none']),\n\n        running_config=dict(aliases=['config']),\n        intended_config=dict(),\n\n        backup=dict(type='bool', default=False),\n\n        save=dict(type='bool', default=False),\n\n        diff_against=dict(choices=['running', 'intended']),\n        diff_ignore_lines=dict(type='list')\n    )\n\n    argument_spec.update(aireos_argument_spec)\n\n    mutually_exclusive = [('lines', 'src')]\n\n    required_if = [('diff_against', 'intended', ['intended_config'])]\n\n    module = AnsibleModule(argument_spec=argument_spec,\n                           mutually_exclusive=mutually_exclusive,\n                           required_if=required_if,\n                           supports_check_mode=True)\n\n    warnings = list()\n    aireos_check_args(module, warnings)\n    result = {'changed': False, 'warnings': warnings}\n\n    config = None\n\n    if module.params['backup'] or (module._diff and module.params['diff_against'] == 'running'):\n        contents = get_config(module)\n        config = NetworkConfig(indent=1, contents=contents)\n        if module.params['backup']:\n            result['__backup__'] = contents\n\n    if any((module.params['src'], module.params['lines'])):\n        match = module.params['match']\n\n        candidate = get_candidate(module)\n\n        if match != 'none':\n            config = get_running_config(module, config)\n            configobjs = candidate.difference(config, match=match)\n        else:\n            configobjs = candidate.items\n\n        if configobjs:\n            commands = dumps(configobjs, 'commands').split('\\n')\n\n            if module.params['before']:\n                commands[:0] = module.params['before']\n\n            if module.params['after']:\n                commands.extend(module.params['after'])\n\n            result['commands'] = commands\n            result['updates'] = commands\n\n            if not module.check_mode:\n                load_config(module, commands)\n\n            result['changed'] = True\n\n    diff_ignore_lines = module.params['diff_ignore_lines']\n\n    if module.params['save']:\n        result['changed'] = True\n        if not module.check_mode:\n            command = {\"command\": \"save config\", \"prompt\": \"Are you sure you want to save\", \"answer\": \"y\"}\n            run_commands(module, command)\n        else:\n            module.warn('Skipping command `save config` due to check_mode.  Configuration not copied to non-volatile storage')\n\n    if module._diff:\n        output = run_commands(module, 'show run-config commands')\n        contents = output[0]\n\n         recreate the object in order to process diff_ignore_lines\n        running_config = NetworkConfig(indent=1, contents=contents, ignore_lines=diff_ignore_lines)\n\n        if module.params['diff_against'] == 'running':\n            if module.check_mode:\n                module.warn(\"unable to perform diff against running-config due to check mode\")\n                contents = None\n            else:\n                contents = config.config_text\n        elif module.params['diff_against'] == 'intended':\n            contents = module.params['intended_config']\n\n        if contents is not None:\n            base_config = NetworkConfig(indent=1, contents=contents, ignore_lines=diff_ignore_lines)\n\n            if running_config.sha1 != base_config.sha1:\n                result.update({\n                    'changed': True,\n                    'diff': {'before': str(base_config), 'after': str(running_config)}\n                })\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  aireos config version added   2 4  author   james mighion ( jmighion)  short description  manage cisco wlc configurations description      aireos use block indent file syntax  sections parents      this module provides implementation working aireos configurations     deterministic way  extends documentation fragment  aireos options    lines      description          the ordered set commands configured          the commands must exact commands found         device run config   be sure note configuration         command syntax commands automatically modified         device config parser      aliases    commands     src      description          specifies source path file contains configuration         configuration template load   the path source file         either full path ansible control host relative         path playbook role root directory   this argument mutually         exclusive i(lines)         description          the ordered set commands push command stack         change needs made   this allows playbook designer         opportunity perform configuration commands prior pushing         changes without affecting set commands matched         system         description          the ordered set commands append end command         stack change needs made   just like i(before)         allows playbook designer append set commands         executed command set    match      description          instructs module way perform matching         set commands current device config   if         match set i(line)  commands matched line line          if match set i(none)  module attempt         compare source configuration running         configuration remote device      default  line     choices    line    none     backup      description          this argument cause module create full backup         current c(running config) remote device         changes made   the backup file written c(backup)         folder playbook root directory   if directory         exist  created      type  bool     default      running config      description          the module  default  connect remote device         retrieve current running config use base comparing         contents source   there times         desirable task get current running config         every task playbook   the i(running config) argument allows         implementer pass configuration use base         config comparison      aliases    config     save      description          the c(save) argument instructs module save running          config startup config conclusion module         running   if check mode specified  argument ignored      type  bool     default      diff      description          when using c(ansible playbook   diff) command line argument         module generate diffs different sources          when option configured i(intended)  module         return diff running config configuration         provided c(intended config) argument          when option configured i(running)  module         return diff running config respect         changes made device configuration      choices    intended    running     diff ignore lines      description          use argument specify one lines         ignored diff   this used lines configuration         automatically updated system   this argument takes         list regular expressions exact line matches    intended config      description          the c(intended config) provides master configuration         node conform used check final         running config    this argument modify settings         remote device strictly used check compliance         current device configuration   when specifying         argument  task also modify c(diff against) value         set i(intended)       examples         name  configure configuration   aireos config      lines  sysname testdevice    name  diff running config provided config   aireos config      diff  intended     intended      lookup( file    master cfg )        name  load new acl device   aireos config      lines          acl create testacl         acl rule protocol testacl 1         acl rule direction testacl 3      acl delete testacl      return       commands    description  the set commands pushed remote device   returned  always   type  list   sample    hostname foo    vlan 1    name default   updates    description  the set commands pushed remote device   returned  always   type  list   sample    hostname foo    vlan 1    name default   backup path    description  the full path backup file   returned  backup yes   type  string   sample   playbooks ansible backup aireos config 2016 07 16 22 28 34     ansible module utils network aireos aireos import run commands  get config  load config ansible module utils network aireos aireos import aireos argument spec ansible module utils network aireos aireos import check args aireos check args ansible module utils basic import ansiblemodule ansible module utils network common config import networkconfig  dumps   def get running config(module  config none)      contents   module params  running config       contents          config              contents   config         else              contents   get config(module)     return networkconfig(indent 1  contents contents)   def get candidate(module)      candidate   networkconfig(indent 1)      module params  src            candidate load(module params  src  )     elif module params  lines            candidate add(module params  lines  )     return candidate   def main()          main entry point module execution             usr bin python       copyright  ansible team    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    recreate object order process diff ignore lines ", "content": "#!/usr/bin/python\n#\n# Copyright: Ansible Team\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = \"\"\"\n---\nmodule: aireos_config\nversion_added: \"2.4\"\nauthor: \"James Mighion (@jmighion)\"\nshort_description: Manage Cisco WLC configurations\ndescription:\n  - AireOS does not use a block indent file syntax, so there are no sections or parents.\n    This module provides an implementation for working with AireOS configurations in\n    a deterministic way.\nextends_documentation_fragment: aireos\noptions:\n  lines:\n    description:\n      - The ordered set of commands that should be configured.\n        The commands must be the exact same commands as found\n        in the device run-config.  Be sure to note the configuration\n        command syntax as some commands are automatically modified by the\n        device config parser.\n    aliases: ['commands']\n  src:\n    description:\n      - Specifies the source path to the file that contains the configuration\n        or configuration template to load.  The path to the source file can\n        either be the full path on the Ansible control host or a relative\n        path from the playbook or role root directory.  This argument is mutually\n        exclusive with I(lines).\n  before:\n    description:\n      - The ordered set of commands to push on to the command stack if\n        a change needs to be made.  This allows the playbook designer\n        the opportunity to perform configuration commands prior to pushing\n        any changes without affecting how the set of commands are matched\n        against the system.\n  after:\n    description:\n      - The ordered set of commands to append to the end of the command\n        stack if a change needs to be made.  Just like with I(before) this\n        allows the playbook designer to append a set of commands to be\n        executed after the command set.\n  match:\n    description:\n      - Instructs the module on the way to perform the matching of\n        the set of commands against the current device config.  If\n        match is set to I(line), commands are matched line by line.\n        If match is set to I(none), the module will not attempt to\n        compare the source configuration with the running\n        configuration on the remote device.\n    default: line\n    choices: ['line', 'none']\n  backup:\n    description:\n      - This argument will cause the module to create a full backup of\n        the current C(running-config) from the remote device before any\n        changes are made.  The backup file is written to the C(backup)\n        folder in the playbook root directory.  If the directory does not\n        exist, it is created.\n    type: bool\n    default: 'no'\n  running_config:\n    description:\n      - The module, by default, will connect to the remote device and\n        retrieve the current running-config to use as a base for comparing\n        against the contents of source.  There are times when it is not\n        desirable to have the task get the current running-config for\n        every task in a playbook.  The I(running_config) argument allows the\n        implementer to pass in the configuration to use as the base\n        config for comparison.\n    aliases: ['config']\n  save:\n    description:\n      - The C(save) argument instructs the module to save the running-\n        config to the startup-config at the conclusion of the module\n        running.  If check mode is specified, this argument is ignored.\n    type: bool\n    default: 'no'\n  diff_against:\n    description:\n      - When using the C(ansible-playbook --diff) command line argument\n        the module can generate diffs against different sources.\n      - When this option is configured as I(intended), the module will\n        return the diff of the running-config against the configuration\n        provided in the C(intended_config) argument.\n      - When this option is configured as I(running), the module will\n        return the before and after diff of the running-config with respect\n        to any changes made to the device configuration.\n    choices: ['intended', 'running']\n  diff_ignore_lines:\n    description:\n      - Use this argument to specify one or more lines that should be\n        ignored during the diff.  This is used for lines in the configuration\n        that are automatically updated by the system.  This argument takes\n        a list of regular expressions or exact line matches.\n  intended_config:\n    description:\n      - The C(intended_config) provides the master configuration that\n        the node should conform to and is used to check the final\n        running-config against.   This argument will not modify any settings\n        on the remote device and is strictly used to check the compliance\n        of the current device's configuration against.  When specifying this\n        argument, the task should also modify the C(diff_against) value and\n        set it to I(intended).\n\"\"\"\n\nEXAMPLES = \"\"\"\n- name: configure configuration\n  aireos_config:\n    lines: sysname testDevice\n\n- name: diff the running-config against a provided config\n  aireos_config:\n    diff_against: intended\n    intended: \"{{ lookup('file', 'master.cfg') }}\"\n\n- name: load new acl into device\n  aireos_config:\n    lines:\n      - acl create testACL\n      - acl rule protocol testACL 1 any\n      - acl rule direction testACL 3 in\n    before: acl delete testACL\n\"\"\"\n\nRETURN = \"\"\"\ncommands:\n  description: The set of commands that will be pushed to the remote device\n  returned: always\n  type: list\n  sample: ['hostname foo', 'vlan 1', 'name default']\nupdates:\n  description: The set of commands that will be pushed to the remote device\n  returned: always\n  type: list\n  sample: ['hostname foo', 'vlan 1', 'name default']\nbackup_path:\n  description: The full path to the backup file\n  returned: when backup is yes\n  type: string\n  sample: /playbooks/ansible/backup/aireos_config.2016-07-16@22:28:34\n\"\"\"\nfrom ansible.module_utils.network.aireos.aireos import run_commands, get_config, load_config\nfrom ansible.module_utils.network.aireos.aireos import aireos_argument_spec\nfrom ansible.module_utils.network.aireos.aireos import check_args as aireos_check_args\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.network.common.config import NetworkConfig, dumps\n\n\ndef get_running_config(module, config=None):\n    contents = module.params['running_config']\n    if not contents:\n        if config:\n            contents = config\n        else:\n            contents = get_config(module)\n    return NetworkConfig(indent=1, contents=contents)\n\n\ndef get_candidate(module):\n    candidate = NetworkConfig(indent=1)\n\n    if module.params['src']:\n        candidate.load(module.params['src'])\n    elif module.params['lines']:\n        candidate.add(module.params['lines'])\n    return candidate\n\n\ndef main():\n    \"\"\" main entry point for module execution\n    \"\"\"\n    argument_spec = dict(\n        src=dict(type='path'),\n\n        lines=dict(aliases=['commands'], type='list'),\n\n        before=dict(type='list'),\n        after=dict(type='list'),\n\n        match=dict(default='line', choices=['line', 'none']),\n\n        running_config=dict(aliases=['config']),\n        intended_config=dict(),\n\n        backup=dict(type='bool', default=False),\n\n        save=dict(type='bool', default=False),\n\n        diff_against=dict(choices=['running', 'intended']),\n        diff_ignore_lines=dict(type='list')\n    )\n\n    argument_spec.update(aireos_argument_spec)\n\n    mutually_exclusive = [('lines', 'src')]\n\n    required_if = [('diff_against', 'intended', ['intended_config'])]\n\n    module = AnsibleModule(argument_spec=argument_spec,\n                           mutually_exclusive=mutually_exclusive,\n                           required_if=required_if,\n                           supports_check_mode=True)\n\n    warnings = list()\n    aireos_check_args(module, warnings)\n    result = {'changed': False, 'warnings': warnings}\n\n    config = None\n\n    if module.params['backup'] or (module._diff and module.params['diff_against'] == 'running'):\n        contents = get_config(module)\n        config = NetworkConfig(indent=1, contents=contents)\n        if module.params['backup']:\n            result['__backup__'] = contents\n\n    if any((module.params['src'], module.params['lines'])):\n        match = module.params['match']\n\n        candidate = get_candidate(module)\n\n        if match != 'none':\n            config = get_running_config(module, config)\n            configobjs = candidate.difference(config, match=match)\n        else:\n            configobjs = candidate.items\n\n        if configobjs:\n            commands = dumps(configobjs, 'commands').split('\\n')\n\n            if module.params['before']:\n                commands[:0] = module.params['before']\n\n            if module.params['after']:\n                commands.extend(module.params['after'])\n\n            result['commands'] = commands\n            result['updates'] = commands\n\n            if not module.check_mode:\n                load_config(module, commands)\n\n            result['changed'] = True\n\n    diff_ignore_lines = module.params['diff_ignore_lines']\n\n    if module.params['save']:\n        result['changed'] = True\n        if not module.check_mode:\n            command = {\"command\": \"save config\", \"prompt\": \"Are you sure you want to save\", \"answer\": \"y\"}\n            run_commands(module, command)\n        else:\n            module.warn('Skipping command `save config` due to check_mode.  Configuration not copied to non-volatile storage')\n\n    if module._diff:\n        output = run_commands(module, 'show run-config commands')\n        contents = output[0]\n\n        # recreate the object in order to process diff_ignore_lines\n        running_config = NetworkConfig(indent=1, contents=contents, ignore_lines=diff_ignore_lines)\n\n        if module.params['diff_against'] == 'running':\n            if module.check_mode:\n                module.warn(\"unable to perform diff against running-config due to check mode\")\n                contents = None\n            else:\n                contents = config.config_text\n        elif module.params['diff_against'] == 'intended':\n            contents = module.params['intended_config']\n\n        if contents is not None:\n            base_config = NetworkConfig(indent=1, contents=contents, ignore_lines=diff_ignore_lines)\n\n            if running_config.sha1 != base_config.sha1:\n                result.update({\n                    'changed': True,\n                    'diff': {'before': str(base_config), 'after': str(running_config)}\n                })\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "aireos_config.py", "id": "6803bf376832be4f634f6d5a2bc06812", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/network/aireos/aireos_config.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}