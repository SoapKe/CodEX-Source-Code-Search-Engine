{"author": "django", "code": "from django.db import connection, transaction\nfrom django.db.models import Case, Count, F, FilteredRelation, Q, When\nfrom django.test import TestCase\nfrom django.test.testcases import skipUnlessDBFeature\n\nfrom .models import Author, Book, Borrower, Editor, RentalSession, Reservation\n\n\nclass FilteredRelationTests(TestCase):\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.author1 = Author.objects.create(name='Alice')\n        cls.author2 = Author.objects.create(name='Jane')\n        cls.editor_a = Editor.objects.create(name='a')\n        cls.editor_b = Editor.objects.create(name='b')\n        cls.book1 = Book.objects.create(\n            title='Poem by Alice',\n            editor=cls.editor_a,\n            author=cls.author1,\n        )\n        cls.book1.generic_author.set([cls.author2])\n        cls.book2 = Book.objects.create(\n            title='The book by Jane A',\n            editor=cls.editor_b,\n            author=cls.author2,\n        )\n        cls.book3 = Book.objects.create(\n            title='The book by Jane B',\n            editor=cls.editor_b,\n            author=cls.author2,\n        )\n        cls.book4 = Book.objects.create(\n            title='The book by Alice',\n            editor=cls.editor_a,\n            author=cls.author1,\n        )\n        cls.author1.favorite_books.add(cls.book2)\n        cls.author1.favorite_books.add(cls.book3)\n\n    def test_select_related(self):\n        qs = Author.objects.annotate(\n            book_join=FilteredRelation('book'),\n        ).select_related('book_join__editor').order_by('pk', 'book_join__pk')\n        with self.assertNumQueries(1):\n            self.assertQuerysetEqual(qs, [\n                (self.author1, self.book1, self.editor_a, self.author1),\n                (self.author1, self.book4, self.editor_a, self.author1),\n                (self.author2, self.book2, self.editor_b, self.author2),\n                (self.author2, self.book3, self.editor_b, self.author2),\n            ], lambda x: (x, x.book_join, x.book_join.editor, x.book_join.author))\n\n    def test_select_related_foreign_key(self):\n        qs = Book.objects.annotate(\n            author_join=FilteredRelation('author'),\n        ).select_related('author_join').order_by('pk')\n        with self.assertNumQueries(1):\n            self.assertQuerysetEqual(qs, [\n                (self.book1, self.author1),\n                (self.book2, self.author2),\n                (self.book3, self.author2),\n                (self.book4, self.author1),\n            ], lambda x: (x, x.author_join))\n\n    @skipUnlessDBFeature('has_select_for_update', 'has_select_for_update_of')\n    def test_select_related_foreign_key_for_update_of(self):\n        with transaction.atomic():\n            qs = Book.objects.annotate(\n                author_join=FilteredRelation('author'),\n            ).select_related('author_join').select_for_update(of=('self',)).order_by('pk')\n            with self.assertNumQueries(1):\n                self.assertQuerysetEqual(qs, [\n                    (self.book1, self.author1),\n                    (self.book2, self.author2),\n                    (self.book3, self.author2),\n                    (self.book4, self.author1),\n                ], lambda x: (x, x.author_join))\n\n    def test_without_join(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n            ),\n            [self.author1, self.author2]\n        )\n\n    def test_with_join(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n            ).filter(book_alice__isnull=False),\n            [self.author1]\n        )\n\n    def test_with_join_and_complex_condition(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_alice=FilteredRelation(\n                    'book', condition=Q(\n                        Q(book__title__iexact='poem by alice') |\n                        Q(book__state=Book.RENTED)\n                    ),\n                ),\n            ).filter(book_alice__isnull=False),\n            [self.author1]\n        )\n\n    def test_internal_queryset_alias_mapping(self):\n        queryset = Author.objects.annotate(\n            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n        ).filter(book_alice__isnull=False)\n        self.assertIn(\n            'INNER JOIN {} book_alice ON'.format(connection.ops.quote_name('filtered_relation_book')),\n            str(queryset.query)\n        )\n\n    def test_with_multiple_filter(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_editor_a=FilteredRelation(\n                    'book',\n                    condition=Q(book__title__icontains='book', book__editor_id=self.editor_a.pk),\n                ),\n            ).filter(book_editor_a__isnull=False),\n            [self.author1]\n        )\n\n    def test_multiple_times(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_title_alice=FilteredRelation('book', condition=Q(book__title__icontains='alice')),\n            ).filter(book_title_alice__isnull=False).filter(book_title_alice__isnull=False).distinct(),\n            [self.author1]\n        )\n\n    def test_exclude_relation_with_join(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_alice=FilteredRelation('book', condition=~Q(book__title__icontains='alice')),\n            ).filter(book_alice__isnull=False).distinct(),\n            [self.author2]\n        )\n\n    def test_with_m2m(self):\n        qs = Author.objects.annotate(\n            favorite_books_written_by_jane=FilteredRelation(\n                'favorite_books', condition=Q(favorite_books__in=[self.book2]),\n            ),\n        ).filter(favorite_books_written_by_jane__isnull=False)\n        self.assertSequenceEqual(qs, [self.author1])\n\n    def test_with_m2m_deep(self):\n        qs = Author.objects.annotate(\n            favorite_books_written_by_jane=FilteredRelation(\n                'favorite_books', condition=Q(favorite_books__author=self.author2),\n            ),\n        ).filter(favorite_books_written_by_jane__title='The book by Jane B')\n        self.assertSequenceEqual(qs, [self.author1])\n\n    def test_with_m2m_multijoin(self):\n        qs = Author.objects.annotate(\n            favorite_books_written_by_jane=FilteredRelation(\n                'favorite_books', condition=Q(favorite_books__author=self.author2),\n            )\n        ).filter(favorite_books_written_by_jane__editor__name='b').distinct()\n        self.assertSequenceEqual(qs, [self.author1])\n\n    def test_values_list(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n            ).filter(book_alice__isnull=False).values_list('book_alice__title', flat=True),\n            ['Poem by Alice']\n        )\n\n    def test_values(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n            ).filter(book_alice__isnull=False).values(),\n            [{'id': self.author1.pk, 'name': 'Alice', 'content_type_id': None, 'object_id': None}]\n        )\n\n    def test_extra(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n            ).filter(book_alice__isnull=False).extra(where=['1 = 1']),\n            [self.author1]\n        )\n\n    @skipUnlessDBFeature('supports_select_union')\n    def test_union(self):\n        qs1 = Author.objects.annotate(\n            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n        ).filter(book_alice__isnull=False)\n        qs2 = Author.objects.annotate(\n            book_jane=FilteredRelation('book', condition=Q(book__title__iexact='the book by jane a')),\n        ).filter(book_jane__isnull=False)\n        self.assertSequenceEqual(qs1.union(qs2), [self.author1, self.author2])\n\n    @skipUnlessDBFeature('supports_select_intersection')\n    def test_intersection(self):\n        qs1 = Author.objects.annotate(\n            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n        ).filter(book_alice__isnull=False)\n        qs2 = Author.objects.annotate(\n            book_jane=FilteredRelation('book', condition=Q(book__title__iexact='the book by jane a')),\n        ).filter(book_jane__isnull=False)\n        self.assertSequenceEqual(qs1.intersection(qs2), [])\n\n    @skipUnlessDBFeature('supports_select_difference')\n    def test_difference(self):\n        qs1 = Author.objects.annotate(\n            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n        ).filter(book_alice__isnull=False)\n        qs2 = Author.objects.annotate(\n            book_jane=FilteredRelation('book', condition=Q(book__title__iexact='the book by jane a')),\n        ).filter(book_jane__isnull=False)\n        self.assertSequenceEqual(qs1.difference(qs2), [self.author1])\n\n    def test_select_for_update(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_jane=FilteredRelation('book', condition=Q(book__title__iexact='the book by jane a')),\n            ).filter(book_jane__isnull=False).select_for_update(),\n            [self.author2]\n        )\n\n    def test_defer(self):\n        \n        with self.assertNumQueries(2):\n            self.assertQuerysetEqual(\n                Author.objects.annotate(\n                    book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n                ).filter(book_alice__isnull=False).select_related('book_alice').defer('book_alice__title'),\n                ['Poem by Alice'], lambda author: author.book_alice.title\n            )\n\n    def test_only_not_supported(self):\n        msg = 'only() is not supported with FilteredRelation.'\n        with self.assertRaisesMessage(ValueError, msg):\n            Author.objects.annotate(\n                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n            ).filter(book_alice__isnull=False).select_related('book_alice').only('book_alice__state')\n\n    def test_as_subquery(self):\n        inner_qs = Author.objects.annotate(\n            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n        ).filter(book_alice__isnull=False)\n        qs = Author.objects.filter(id__in=inner_qs)\n        self.assertSequenceEqual(qs, [self.author1])\n\n    def test_with_foreign_key_error(self):\n        msg = (\n            \"FilteredRelation's condition doesn't support nested relations \"\n            \"(got 'author__favorite_books__author').\"\n        )\n        with self.assertRaisesMessage(ValueError, msg):\n            list(Book.objects.annotate(\n                alice_favorite_books=FilteredRelation(\n                    'author__favorite_books',\n                    condition=Q(author__favorite_books__author=self.author1),\n                )\n            ))\n\n    def test_with_foreign_key_on_condition_error(self):\n        msg = (\n            \"FilteredRelation's condition doesn't support nested relations \"\n            \"(got 'book__editor__name__icontains').\"\n        )\n        with self.assertRaisesMessage(ValueError, msg):\n            list(Author.objects.annotate(\n                book_edited_by_b=FilteredRelation('book', condition=Q(book__editor__name__icontains='b')),\n            ))\n\n    def test_with_empty_relation_name_error(self):\n        with self.assertRaisesMessage(ValueError, 'relation_name cannot be empty.'):\n            FilteredRelation('', condition=Q(blank=''))\n\n    def test_with_condition_as_expression_error(self):\n        msg = 'condition argument must be a Q() instance.'\n        expression = Case(\n            When(book__title__iexact='poem by alice', then=True), default=False,\n        )\n        with self.assertRaisesMessage(ValueError, msg):\n            FilteredRelation('book', condition=expression)\n\n    def test_with_prefetch_related(self):\n        msg = 'prefetch_related() is not supported with FilteredRelation.'\n        qs = Author.objects.annotate(\n            book_title_contains_b=FilteredRelation('book', condition=Q(book__title__icontains='b')),\n        ).filter(\n            book_title_contains_b__isnull=False,\n        )\n        with self.assertRaisesMessage(ValueError, msg):\n            qs.prefetch_related('book_title_contains_b')\n        with self.assertRaisesMessage(ValueError, msg):\n            qs.prefetch_related('book_title_contains_b__editor')\n\n    def test_with_generic_foreign_key(self):\n        self.assertSequenceEqual(\n            Book.objects.annotate(\n                generic_authored_book=FilteredRelation(\n                    'generic_author',\n                    condition=Q(generic_author__isnull=False)\n                ),\n            ).filter(generic_authored_book__isnull=False),\n            [self.book1]\n        )\n\n\nclass FilteredRelationAggregationTests(TestCase):\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.author1 = Author.objects.create(name='Alice')\n        cls.editor_a = Editor.objects.create(name='a')\n        cls.book1 = Book.objects.create(\n            title='Poem by Alice',\n            editor=cls.editor_a,\n            author=cls.author1,\n        )\n        cls.borrower1 = Borrower.objects.create(name='Jenny')\n        cls.borrower2 = Borrower.objects.create(name='Kevin')\n        \n        Reservation.objects.create(\n            borrower=cls.borrower1,\n            book=cls.book1,\n            state=Reservation.STOPPED,\n        )\n        RentalSession.objects.create(\n            borrower=cls.borrower1,\n            book=cls.book1,\n            state=RentalSession.STOPPED,\n        )\n        \n        Reservation.objects.create(\n            borrower=cls.borrower2,\n            book=cls.book1,\n            state=Reservation.STOPPED,\n        )\n        RentalSession.objects.create(\n            borrower=cls.borrower2,\n            book=cls.book1,\n            state=RentalSession.STOPPED,\n        )\n\n    def test_aggregate(self):\n        \"\"\"\n        filtered_relation() not only improves performance but also creates\n        correct results when aggregating with multiple LEFT JOINs.\n\n        Books can be reserved then rented by a borrower. Each reservation and\n        rental session are recorded with Reservation and RentalSession models.\n        Every time a reservation or a rental session is over, their state is\n        changed to 'stopped'.\n\n        Goal: Count number of books that are either currently reserved or\n        rented by borrower1 or available.\n        \"\"\"\n        qs = Book.objects.annotate(\n            is_reserved_or_rented_by=Case(\n                When(reservation__state=Reservation.NEW, then=F('reservation__borrower__pk')),\n                When(rental_session__state=RentalSession.NEW, then=F('rental_session__borrower__pk')),\n                default=None,\n            )\n        ).filter(\n            Q(is_reserved_or_rented_by=self.borrower1.pk) | Q(state=Book.AVAILABLE)\n        ).distinct()\n        self.assertEqual(qs.count(), 1)\n        \n        \n        self.assertSequenceEqual(qs.annotate(total=Count('pk')).values('total'), [{'total': 4}])\n        # With FilteredRelation, the result is as expected (1).\n        qs = Book.objects.annotate(\n            active_reservations=FilteredRelation(\n                'reservation', condition=Q(\n                    reservation__state=Reservation.NEW,\n                    reservation__borrower=self.borrower1,\n                )\n            ),\n        ).annotate(\n            active_rental_sessions=FilteredRelation(\n                'rental_session', condition=Q(\n                    rental_session__state=RentalSession.NEW,\n                    rental_session__borrower=self.borrower1,\n                )\n            ),\n        ).filter(\n            (Q(active_reservations__isnull=False) | Q(active_rental_sessions__isnull=False)) |\n            Q(state=Book.AVAILABLE)\n        ).distinct()\n        self.assertEqual(qs.count(), 1)\n        self.assertSequenceEqual(qs.annotate(total=Count('pk')).values('total'), [{'total': 1}])\n", "comments": "            filtered relation() improves performance also creates         correct results aggregating multiple left joins           books reserved rented borrower  each reservation         rental session recorded reservation rentalsession models          every time reservation rental session  state         changed  stopped            goal  count number books either currently reserved         rented borrower1 available                 one query list one query deferred title     borrower 1 reserves  rents  returns book1     borrower2 reserves  rents  returns book1     if count equal 1  aggregation return    result returns 4     with filteredrelation  result expected (1)  ", "content": "from django.db import connection, transaction\nfrom django.db.models import Case, Count, F, FilteredRelation, Q, When\nfrom django.test import TestCase\nfrom django.test.testcases import skipUnlessDBFeature\n\nfrom .models import Author, Book, Borrower, Editor, RentalSession, Reservation\n\n\nclass FilteredRelationTests(TestCase):\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.author1 = Author.objects.create(name='Alice')\n        cls.author2 = Author.objects.create(name='Jane')\n        cls.editor_a = Editor.objects.create(name='a')\n        cls.editor_b = Editor.objects.create(name='b')\n        cls.book1 = Book.objects.create(\n            title='Poem by Alice',\n            editor=cls.editor_a,\n            author=cls.author1,\n        )\n        cls.book1.generic_author.set([cls.author2])\n        cls.book2 = Book.objects.create(\n            title='The book by Jane A',\n            editor=cls.editor_b,\n            author=cls.author2,\n        )\n        cls.book3 = Book.objects.create(\n            title='The book by Jane B',\n            editor=cls.editor_b,\n            author=cls.author2,\n        )\n        cls.book4 = Book.objects.create(\n            title='The book by Alice',\n            editor=cls.editor_a,\n            author=cls.author1,\n        )\n        cls.author1.favorite_books.add(cls.book2)\n        cls.author1.favorite_books.add(cls.book3)\n\n    def test_select_related(self):\n        qs = Author.objects.annotate(\n            book_join=FilteredRelation('book'),\n        ).select_related('book_join__editor').order_by('pk', 'book_join__pk')\n        with self.assertNumQueries(1):\n            self.assertQuerysetEqual(qs, [\n                (self.author1, self.book1, self.editor_a, self.author1),\n                (self.author1, self.book4, self.editor_a, self.author1),\n                (self.author2, self.book2, self.editor_b, self.author2),\n                (self.author2, self.book3, self.editor_b, self.author2),\n            ], lambda x: (x, x.book_join, x.book_join.editor, x.book_join.author))\n\n    def test_select_related_foreign_key(self):\n        qs = Book.objects.annotate(\n            author_join=FilteredRelation('author'),\n        ).select_related('author_join').order_by('pk')\n        with self.assertNumQueries(1):\n            self.assertQuerysetEqual(qs, [\n                (self.book1, self.author1),\n                (self.book2, self.author2),\n                (self.book3, self.author2),\n                (self.book4, self.author1),\n            ], lambda x: (x, x.author_join))\n\n    @skipUnlessDBFeature('has_select_for_update', 'has_select_for_update_of')\n    def test_select_related_foreign_key_for_update_of(self):\n        with transaction.atomic():\n            qs = Book.objects.annotate(\n                author_join=FilteredRelation('author'),\n            ).select_related('author_join').select_for_update(of=('self',)).order_by('pk')\n            with self.assertNumQueries(1):\n                self.assertQuerysetEqual(qs, [\n                    (self.book1, self.author1),\n                    (self.book2, self.author2),\n                    (self.book3, self.author2),\n                    (self.book4, self.author1),\n                ], lambda x: (x, x.author_join))\n\n    def test_without_join(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n            ),\n            [self.author1, self.author2]\n        )\n\n    def test_with_join(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n            ).filter(book_alice__isnull=False),\n            [self.author1]\n        )\n\n    def test_with_join_and_complex_condition(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_alice=FilteredRelation(\n                    'book', condition=Q(\n                        Q(book__title__iexact='poem by alice') |\n                        Q(book__state=Book.RENTED)\n                    ),\n                ),\n            ).filter(book_alice__isnull=False),\n            [self.author1]\n        )\n\n    def test_internal_queryset_alias_mapping(self):\n        queryset = Author.objects.annotate(\n            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n        ).filter(book_alice__isnull=False)\n        self.assertIn(\n            'INNER JOIN {} book_alice ON'.format(connection.ops.quote_name('filtered_relation_book')),\n            str(queryset.query)\n        )\n\n    def test_with_multiple_filter(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_editor_a=FilteredRelation(\n                    'book',\n                    condition=Q(book__title__icontains='book', book__editor_id=self.editor_a.pk),\n                ),\n            ).filter(book_editor_a__isnull=False),\n            [self.author1]\n        )\n\n    def test_multiple_times(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_title_alice=FilteredRelation('book', condition=Q(book__title__icontains='alice')),\n            ).filter(book_title_alice__isnull=False).filter(book_title_alice__isnull=False).distinct(),\n            [self.author1]\n        )\n\n    def test_exclude_relation_with_join(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_alice=FilteredRelation('book', condition=~Q(book__title__icontains='alice')),\n            ).filter(book_alice__isnull=False).distinct(),\n            [self.author2]\n        )\n\n    def test_with_m2m(self):\n        qs = Author.objects.annotate(\n            favorite_books_written_by_jane=FilteredRelation(\n                'favorite_books', condition=Q(favorite_books__in=[self.book2]),\n            ),\n        ).filter(favorite_books_written_by_jane__isnull=False)\n        self.assertSequenceEqual(qs, [self.author1])\n\n    def test_with_m2m_deep(self):\n        qs = Author.objects.annotate(\n            favorite_books_written_by_jane=FilteredRelation(\n                'favorite_books', condition=Q(favorite_books__author=self.author2),\n            ),\n        ).filter(favorite_books_written_by_jane__title='The book by Jane B')\n        self.assertSequenceEqual(qs, [self.author1])\n\n    def test_with_m2m_multijoin(self):\n        qs = Author.objects.annotate(\n            favorite_books_written_by_jane=FilteredRelation(\n                'favorite_books', condition=Q(favorite_books__author=self.author2),\n            )\n        ).filter(favorite_books_written_by_jane__editor__name='b').distinct()\n        self.assertSequenceEqual(qs, [self.author1])\n\n    def test_values_list(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n            ).filter(book_alice__isnull=False).values_list('book_alice__title', flat=True),\n            ['Poem by Alice']\n        )\n\n    def test_values(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n            ).filter(book_alice__isnull=False).values(),\n            [{'id': self.author1.pk, 'name': 'Alice', 'content_type_id': None, 'object_id': None}]\n        )\n\n    def test_extra(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n            ).filter(book_alice__isnull=False).extra(where=['1 = 1']),\n            [self.author1]\n        )\n\n    @skipUnlessDBFeature('supports_select_union')\n    def test_union(self):\n        qs1 = Author.objects.annotate(\n            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n        ).filter(book_alice__isnull=False)\n        qs2 = Author.objects.annotate(\n            book_jane=FilteredRelation('book', condition=Q(book__title__iexact='the book by jane a')),\n        ).filter(book_jane__isnull=False)\n        self.assertSequenceEqual(qs1.union(qs2), [self.author1, self.author2])\n\n    @skipUnlessDBFeature('supports_select_intersection')\n    def test_intersection(self):\n        qs1 = Author.objects.annotate(\n            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n        ).filter(book_alice__isnull=False)\n        qs2 = Author.objects.annotate(\n            book_jane=FilteredRelation('book', condition=Q(book__title__iexact='the book by jane a')),\n        ).filter(book_jane__isnull=False)\n        self.assertSequenceEqual(qs1.intersection(qs2), [])\n\n    @skipUnlessDBFeature('supports_select_difference')\n    def test_difference(self):\n        qs1 = Author.objects.annotate(\n            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n        ).filter(book_alice__isnull=False)\n        qs2 = Author.objects.annotate(\n            book_jane=FilteredRelation('book', condition=Q(book__title__iexact='the book by jane a')),\n        ).filter(book_jane__isnull=False)\n        self.assertSequenceEqual(qs1.difference(qs2), [self.author1])\n\n    def test_select_for_update(self):\n        self.assertSequenceEqual(\n            Author.objects.annotate(\n                book_jane=FilteredRelation('book', condition=Q(book__title__iexact='the book by jane a')),\n            ).filter(book_jane__isnull=False).select_for_update(),\n            [self.author2]\n        )\n\n    def test_defer(self):\n        # One query for the list and one query for the deferred title.\n        with self.assertNumQueries(2):\n            self.assertQuerysetEqual(\n                Author.objects.annotate(\n                    book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n                ).filter(book_alice__isnull=False).select_related('book_alice').defer('book_alice__title'),\n                ['Poem by Alice'], lambda author: author.book_alice.title\n            )\n\n    def test_only_not_supported(self):\n        msg = 'only() is not supported with FilteredRelation.'\n        with self.assertRaisesMessage(ValueError, msg):\n            Author.objects.annotate(\n                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n            ).filter(book_alice__isnull=False).select_related('book_alice').only('book_alice__state')\n\n    def test_as_subquery(self):\n        inner_qs = Author.objects.annotate(\n            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n        ).filter(book_alice__isnull=False)\n        qs = Author.objects.filter(id__in=inner_qs)\n        self.assertSequenceEqual(qs, [self.author1])\n\n    def test_with_foreign_key_error(self):\n        msg = (\n            \"FilteredRelation's condition doesn't support nested relations \"\n            \"(got 'author__favorite_books__author').\"\n        )\n        with self.assertRaisesMessage(ValueError, msg):\n            list(Book.objects.annotate(\n                alice_favorite_books=FilteredRelation(\n                    'author__favorite_books',\n                    condition=Q(author__favorite_books__author=self.author1),\n                )\n            ))\n\n    def test_with_foreign_key_on_condition_error(self):\n        msg = (\n            \"FilteredRelation's condition doesn't support nested relations \"\n            \"(got 'book__editor__name__icontains').\"\n        )\n        with self.assertRaisesMessage(ValueError, msg):\n            list(Author.objects.annotate(\n                book_edited_by_b=FilteredRelation('book', condition=Q(book__editor__name__icontains='b')),\n            ))\n\n    def test_with_empty_relation_name_error(self):\n        with self.assertRaisesMessage(ValueError, 'relation_name cannot be empty.'):\n            FilteredRelation('', condition=Q(blank=''))\n\n    def test_with_condition_as_expression_error(self):\n        msg = 'condition argument must be a Q() instance.'\n        expression = Case(\n            When(book__title__iexact='poem by alice', then=True), default=False,\n        )\n        with self.assertRaisesMessage(ValueError, msg):\n            FilteredRelation('book', condition=expression)\n\n    def test_with_prefetch_related(self):\n        msg = 'prefetch_related() is not supported with FilteredRelation.'\n        qs = Author.objects.annotate(\n            book_title_contains_b=FilteredRelation('book', condition=Q(book__title__icontains='b')),\n        ).filter(\n            book_title_contains_b__isnull=False,\n        )\n        with self.assertRaisesMessage(ValueError, msg):\n            qs.prefetch_related('book_title_contains_b')\n        with self.assertRaisesMessage(ValueError, msg):\n            qs.prefetch_related('book_title_contains_b__editor')\n\n    def test_with_generic_foreign_key(self):\n        self.assertSequenceEqual(\n            Book.objects.annotate(\n                generic_authored_book=FilteredRelation(\n                    'generic_author',\n                    condition=Q(generic_author__isnull=False)\n                ),\n            ).filter(generic_authored_book__isnull=False),\n            [self.book1]\n        )\n\n\nclass FilteredRelationAggregationTests(TestCase):\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.author1 = Author.objects.create(name='Alice')\n        cls.editor_a = Editor.objects.create(name='a')\n        cls.book1 = Book.objects.create(\n            title='Poem by Alice',\n            editor=cls.editor_a,\n            author=cls.author1,\n        )\n        cls.borrower1 = Borrower.objects.create(name='Jenny')\n        cls.borrower2 = Borrower.objects.create(name='Kevin')\n        # borrower 1 reserves, rents, and returns book1.\n        Reservation.objects.create(\n            borrower=cls.borrower1,\n            book=cls.book1,\n            state=Reservation.STOPPED,\n        )\n        RentalSession.objects.create(\n            borrower=cls.borrower1,\n            book=cls.book1,\n            state=RentalSession.STOPPED,\n        )\n        # borrower2 reserves, rents, and returns book1.\n        Reservation.objects.create(\n            borrower=cls.borrower2,\n            book=cls.book1,\n            state=Reservation.STOPPED,\n        )\n        RentalSession.objects.create(\n            borrower=cls.borrower2,\n            book=cls.book1,\n            state=RentalSession.STOPPED,\n        )\n\n    def test_aggregate(self):\n        \"\"\"\n        filtered_relation() not only improves performance but also creates\n        correct results when aggregating with multiple LEFT JOINs.\n\n        Books can be reserved then rented by a borrower. Each reservation and\n        rental session are recorded with Reservation and RentalSession models.\n        Every time a reservation or a rental session is over, their state is\n        changed to 'stopped'.\n\n        Goal: Count number of books that are either currently reserved or\n        rented by borrower1 or available.\n        \"\"\"\n        qs = Book.objects.annotate(\n            is_reserved_or_rented_by=Case(\n                When(reservation__state=Reservation.NEW, then=F('reservation__borrower__pk')),\n                When(rental_session__state=RentalSession.NEW, then=F('rental_session__borrower__pk')),\n                default=None,\n            )\n        ).filter(\n            Q(is_reserved_or_rented_by=self.borrower1.pk) | Q(state=Book.AVAILABLE)\n        ).distinct()\n        self.assertEqual(qs.count(), 1)\n        # If count is equal to 1, the same aggregation should return in the\n        # same result but it returns 4.\n        self.assertSequenceEqual(qs.annotate(total=Count('pk')).values('total'), [{'total': 4}])\n        # With FilteredRelation, the result is as expected (1).\n        qs = Book.objects.annotate(\n            active_reservations=FilteredRelation(\n                'reservation', condition=Q(\n                    reservation__state=Reservation.NEW,\n                    reservation__borrower=self.borrower1,\n                )\n            ),\n        ).annotate(\n            active_rental_sessions=FilteredRelation(\n                'rental_session', condition=Q(\n                    rental_session__state=RentalSession.NEW,\n                    rental_session__borrower=self.borrower1,\n                )\n            ),\n        ).filter(\n            (Q(active_reservations__isnull=False) | Q(active_rental_sessions__isnull=False)) |\n            Q(state=Book.AVAILABLE)\n        ).distinct()\n        self.assertEqual(qs.count(), 1)\n        self.assertSequenceEqual(qs.annotate(total=Count('pk')).values('total'), [{'total': 1}])\n", "description": "The Web framework for perfectionists with deadlines.", "file_name": "tests.py", "id": "415ca51f9e2423eb6df31124cd8a1556", "language": "Python", "project_name": "django", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/django-django/django-django-acfc650/tests/filtered_relation/tests.py", "save_time": "", "source": "", "update_at": "2018-03-14T02:00:36Z", "url": "https://github.com/django/django", "wiki": false}