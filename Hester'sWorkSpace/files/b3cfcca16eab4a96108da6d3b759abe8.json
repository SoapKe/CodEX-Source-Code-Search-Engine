{"author": "sympy", "code": "from sympy.multipledispatch import dispatch, Dispatcher\nfrom sympy.core import Basic, Expr, Function, Add, Mul, Pow, Dummy, Integer\nfrom sympy import Min, Max, Set, sympify, symbols, exp, log, S, Wild\nfrom sympy.sets import (imageset, Interval, FiniteSet, Union, ImageSet,\n    ProductSet, EmptySet, Intersection, Range)\nfrom sympy.core.function import Lambda, _coeff_isneg\nfrom sympy.sets.fancysets import Integers\nfrom sympy.core.function import FunctionClass\nfrom sympy.logic.boolalg import And, Or, Not, true, false\n\n\n_x, _y = symbols(\"x y\")\n\nFunctionUnion = (FunctionClass, Lambda)\n\n\n@dispatch(FunctionClass, Set)\ndef _set_function(f, x):\n    return None\n\n@dispatch(FunctionUnion, FiniteSet)\ndef _set_function(f, x):\n    return FiniteSet(*map(f, x))\n\n@dispatch(Lambda, Interval)\ndef _set_function(f, x):\n    from sympy.functions.elementary.miscellaneous import Min, Max\n    from sympy.solvers.solveset import solveset\n    from sympy.core.function import diff, Lambda\n    from sympy.series import limit\n    from sympy.calculus.singularities import singularities\n    from sympy.sets import Complement\n    # TODO: handle functions with infinitely many solutions (eg, sin, tan)\n    \n\n    expr = f.expr\n    if len(expr.free_symbols) > 1 or len(f.variables) != 1:\n        return\n    var = f.variables[0]\n\n    if expr.is_Piecewise:\n        result = S.EmptySet\n        domain_set = x\n        for (p_expr, p_cond) in expr.args:\n            if p_cond is true:\n                intrvl = domain_set\n            else:\n                intrvl = p_cond.as_set()\n                intrvl = Intersection(domain_set, intrvl)\n\n            if p_expr.is_Number:\n                image = FiniteSet(p_expr)\n            else:\n                image = imageset(Lambda(var, p_expr), intrvl)\n            result = Union(result, image)\n\n            \n            domain_set = Complement(domain_set, intrvl)\n            if domain_set.is_EmptySet:\n                break\n        return result\n\n    if not x.start.is_comparable or not x.end.is_comparable:\n        return\n\n    try:\n        sing = [i for i in singularities(expr, var)\n            if i.is_real and i in x]\n    except NotImplementedError:\n        return\n\n    if x.left_open:\n        _start = limit(expr, var, x.start, dir=\"+\")\n    elif x.start not in sing:\n        _start = f(x.start)\n    if x.right_open:\n        _end = limit(expr, var, x.end, dir=\"-\")\n    elif x.end not in sing:\n        _end = f(x.end)\n\n    if len(sing) == 0:\n        solns = list(solveset(diff(expr, var), var))\n\n        extr = [_start, _end] + [f(i) for i in solns\n                                 if i.is_real and i in x]\n        start, end = Min(*extr), Max(*extr)\n\n        left_open, right_open = False, False\n        if _start <= _end:\n            \n            \n            \n            if start == _start and start not in solns:\n                left_open = x.left_open\n            if end == _end and end not in solns:\n                right_open = x.right_open\n        else:\n            if start == _end and start not in solns:\n                left_open = x.right_open\n            if end == _start and end not in solns:\n                right_open = x.left_open\n\n        return Interval(start, end, left_open, right_open)\n    else:\n        return imageset(f, Interval(x.start, sing[0],\n                                    x.left_open, True)) + \\\n            Union(*[imageset(f, Interval(sing[i], sing[i + 1], True, True))\n                    for i in range(0, len(sing) - 1)]) + \\\n            imageset(f, Interval(sing[-1], x.end, True, x.right_open))\n\n@dispatch(FunctionClass, Interval)\ndef _set_function(f, x):\n    if f == exp:\n        return Interval(exp(x.start), exp(x.end), x.left_open, x.right_open)\n    elif f == log:\n        return Interval(log(x.start), log(x.end), x.left_open, x.right_open)\n    return ImageSet(Lambda(_x, f(_x)), x)\n\n@dispatch(FunctionUnion, Union)\ndef _set_function(f, x):\n    return Union(imageset(f, arg) for arg in x.args)\n\n@dispatch(FunctionUnion, Intersection)\ndef _set_function(f, x):\n    from sympy.sets.sets import is_function_invertible_in_set\n    \n    if is_function_invertible_in_set(f, x):\n        return Intersection(imageset(f, arg) for arg in x.args)\n    else:\n        return ImageSet(Lambda(_x, f(_x)), x)\n\n@dispatch(FunctionUnion, EmptySet)\ndef _set_function(f, x):\n    return x\n\n@dispatch(FunctionUnion, Set)\ndef _set_function(f, x):\n    return ImageSet(Lambda(_x, f(_x)), x)\n\n@dispatch(FunctionUnion, Range)\ndef _set_function(f, self):\n    from sympy.core.function import expand_mul\n    if not self:\n        return S.EmptySet\n    if not isinstance(f.expr, Expr):\n        return\n    if self.size == 1:\n        return FiniteSet(f(self[0]))\n    if f is S.IdentityFunction:\n        return self\n\n    x = f.variables[0]\n    expr = f.expr\n    \n    if x not in expr.free_symbols or x in expr.diff(x).free_symbols:\n        return\n    if self.start.is_finite:\n        F = f(self.step*x + self.start)  # for i in range(len(self))\n    else:\n        F = f(-self.step*x + self[-1])\n    F = expand_mul(F)\n    if F != expr:\n        return imageset(x, F, Range(self.size))\n\n@dispatch(FunctionUnion, Integers)\ndef _set_function(f, self):\n    expr = f.expr\n    if not isinstance(expr, Expr):\n        return\n\n    if len(f.variables) > 1:\n        return\n\n    n = f.variables[0]\n\n    # f(x) + c and f(-x) + c cover the same integers\n    \n    c = f(0)\n    fx = f(n) - c\n    f_x = f(-n) - c\n    neg_count = lambda e: sum(_coeff_isneg(_) for _ in Add.make_args(e))\n    if neg_count(f_x) < neg_count(fx):\n        expr = f_x + c\n\n    a = Wild('a', exclude=[n])\n    b = Wild('b', exclude=[n])\n    match = expr.match(a*n + b)\n    if match and match[a]:\n        \n        expr = match[a]*n + match[b] % match[a]\n\n    if expr != f.expr:\n        return ImageSet(Lambda(n, expr), S.Integers)\n", "comments": "  todo  handle functions infinitely many solutions (eg  sin  tan)    todo  handle multivariate functions    remove part  imaged     minimum maximum value occur simultaneously    edge interval interior    point    if function invertible  intersect maps sets     handle f linear f variable    range(len(self))    f(x)   c f( x)   c cover integers    choose form fewest negatives    canonical shift ", "content": "from sympy.multipledispatch import dispatch, Dispatcher\nfrom sympy.core import Basic, Expr, Function, Add, Mul, Pow, Dummy, Integer\nfrom sympy import Min, Max, Set, sympify, symbols, exp, log, S, Wild\nfrom sympy.sets import (imageset, Interval, FiniteSet, Union, ImageSet,\n    ProductSet, EmptySet, Intersection, Range)\nfrom sympy.core.function import Lambda, _coeff_isneg\nfrom sympy.sets.fancysets import Integers\nfrom sympy.core.function import FunctionClass\nfrom sympy.logic.boolalg import And, Or, Not, true, false\n\n\n_x, _y = symbols(\"x y\")\n\nFunctionUnion = (FunctionClass, Lambda)\n\n\n@dispatch(FunctionClass, Set)\ndef _set_function(f, x):\n    return None\n\n@dispatch(FunctionUnion, FiniteSet)\ndef _set_function(f, x):\n    return FiniteSet(*map(f, x))\n\n@dispatch(Lambda, Interval)\ndef _set_function(f, x):\n    from sympy.functions.elementary.miscellaneous import Min, Max\n    from sympy.solvers.solveset import solveset\n    from sympy.core.function import diff, Lambda\n    from sympy.series import limit\n    from sympy.calculus.singularities import singularities\n    from sympy.sets import Complement\n    # TODO: handle functions with infinitely many solutions (eg, sin, tan)\n    # TODO: handle multivariate functions\n\n    expr = f.expr\n    if len(expr.free_symbols) > 1 or len(f.variables) != 1:\n        return\n    var = f.variables[0]\n\n    if expr.is_Piecewise:\n        result = S.EmptySet\n        domain_set = x\n        for (p_expr, p_cond) in expr.args:\n            if p_cond is true:\n                intrvl = domain_set\n            else:\n                intrvl = p_cond.as_set()\n                intrvl = Intersection(domain_set, intrvl)\n\n            if p_expr.is_Number:\n                image = FiniteSet(p_expr)\n            else:\n                image = imageset(Lambda(var, p_expr), intrvl)\n            result = Union(result, image)\n\n            # remove the part which has been `imaged`\n            domain_set = Complement(domain_set, intrvl)\n            if domain_set.is_EmptySet:\n                break\n        return result\n\n    if not x.start.is_comparable or not x.end.is_comparable:\n        return\n\n    try:\n        sing = [i for i in singularities(expr, var)\n            if i.is_real and i in x]\n    except NotImplementedError:\n        return\n\n    if x.left_open:\n        _start = limit(expr, var, x.start, dir=\"+\")\n    elif x.start not in sing:\n        _start = f(x.start)\n    if x.right_open:\n        _end = limit(expr, var, x.end, dir=\"-\")\n    elif x.end not in sing:\n        _end = f(x.end)\n\n    if len(sing) == 0:\n        solns = list(solveset(diff(expr, var), var))\n\n        extr = [_start, _end] + [f(i) for i in solns\n                                 if i.is_real and i in x]\n        start, end = Min(*extr), Max(*extr)\n\n        left_open, right_open = False, False\n        if _start <= _end:\n            # the minimum or maximum value can occur simultaneously\n            # on both the edge of the interval and in some interior\n            # point\n            if start == _start and start not in solns:\n                left_open = x.left_open\n            if end == _end and end not in solns:\n                right_open = x.right_open\n        else:\n            if start == _end and start not in solns:\n                left_open = x.right_open\n            if end == _start and end not in solns:\n                right_open = x.left_open\n\n        return Interval(start, end, left_open, right_open)\n    else:\n        return imageset(f, Interval(x.start, sing[0],\n                                    x.left_open, True)) + \\\n            Union(*[imageset(f, Interval(sing[i], sing[i + 1], True, True))\n                    for i in range(0, len(sing) - 1)]) + \\\n            imageset(f, Interval(sing[-1], x.end, True, x.right_open))\n\n@dispatch(FunctionClass, Interval)\ndef _set_function(f, x):\n    if f == exp:\n        return Interval(exp(x.start), exp(x.end), x.left_open, x.right_open)\n    elif f == log:\n        return Interval(log(x.start), log(x.end), x.left_open, x.right_open)\n    return ImageSet(Lambda(_x, f(_x)), x)\n\n@dispatch(FunctionUnion, Union)\ndef _set_function(f, x):\n    return Union(imageset(f, arg) for arg in x.args)\n\n@dispatch(FunctionUnion, Intersection)\ndef _set_function(f, x):\n    from sympy.sets.sets import is_function_invertible_in_set\n    # If the function is invertible, intersect the maps of the sets.\n    if is_function_invertible_in_set(f, x):\n        return Intersection(imageset(f, arg) for arg in x.args)\n    else:\n        return ImageSet(Lambda(_x, f(_x)), x)\n\n@dispatch(FunctionUnion, EmptySet)\ndef _set_function(f, x):\n    return x\n\n@dispatch(FunctionUnion, Set)\ndef _set_function(f, x):\n    return ImageSet(Lambda(_x, f(_x)), x)\n\n@dispatch(FunctionUnion, Range)\ndef _set_function(f, self):\n    from sympy.core.function import expand_mul\n    if not self:\n        return S.EmptySet\n    if not isinstance(f.expr, Expr):\n        return\n    if self.size == 1:\n        return FiniteSet(f(self[0]))\n    if f is S.IdentityFunction:\n        return self\n\n    x = f.variables[0]\n    expr = f.expr\n    # handle f that is linear in f's variable\n    if x not in expr.free_symbols or x in expr.diff(x).free_symbols:\n        return\n    if self.start.is_finite:\n        F = f(self.step*x + self.start)  # for i in range(len(self))\n    else:\n        F = f(-self.step*x + self[-1])\n    F = expand_mul(F)\n    if F != expr:\n        return imageset(x, F, Range(self.size))\n\n@dispatch(FunctionUnion, Integers)\ndef _set_function(f, self):\n    expr = f.expr\n    if not isinstance(expr, Expr):\n        return\n\n    if len(f.variables) > 1:\n        return\n\n    n = f.variables[0]\n\n    # f(x) + c and f(-x) + c cover the same integers\n    # so choose the form that has the fewest negatives\n    c = f(0)\n    fx = f(n) - c\n    f_x = f(-n) - c\n    neg_count = lambda e: sum(_coeff_isneg(_) for _ in Add.make_args(e))\n    if neg_count(f_x) < neg_count(fx):\n        expr = f_x + c\n\n    a = Wild('a', exclude=[n])\n    b = Wild('b', exclude=[n])\n    match = expr.match(a*n + b)\n    if match and match[a]:\n        # canonical shift\n        expr = match[a]*n + match[b] % match[a]\n\n    if expr != f.expr:\n        return ImageSet(Lambda(n, expr), S.Integers)\n", "description": "A computer algebra system written in pure Python", "file_name": "functions.py", "id": "b3cfcca16eab4a96108da6d3b759abe8", "language": "Python", "project_name": "sympy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/sympy-sympy/sympy-sympy-205da79/sympy/sets/handlers/functions.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:35:56Z", "url": "https://github.com/sympy/sympy", "wiki": true}