{"author": "Rochester-NRT", "code": "import sys\nimport multiprocessing\nimport gtp\nfrom AlphaGo import go\nfrom AlphaGo.util import save_gamestate_to_sgf\nfrom builtins import input\n\n\ndef run_gnugo(sgf_file_name, command):\n    from distutils import spawn\n    if spawn.find_executable('gnugo'):\n        from subprocess import Popen, PIPE\n        p = Popen(['gnugo', '--chinese-rules', '--mode', 'gtp', '-l', sgf_file_name],\n                  stdout=PIPE, stdin=PIPE, stderr=PIPE)\n        out_bytes = p.communicate(input=command)[0]\n        return out_bytes.decode('utf-8')[2:]\n    else:\n        return ''\n\n\nclass ExtendedGtpEngine(gtp.Engine):\n\n    recommended_handicaps = {\n        2: \"D4 Q16\",\n        3: \"D4 Q16 D16\",\n        4: \"D4 Q16 D16 Q4\",\n        5: \"D4 Q16 D16 Q4 K10\",\n        6: \"D4 Q16 D16 Q4 D10 Q10\",\n        7: \"D4 Q16 D16 Q4 D10 Q10 K10\",\n        8: \"D4 Q16 D16 Q4 D10 Q10 K4 K16\",\n        9: \"D4 Q16 D16 Q4 D10 Q10 K4 K16 K10\"\n    }\n\n    def call_gnugo(self, sgf_file_name, command):\n        try:\n            pool = multiprocessing.Pool(processes=1)\n            result = pool.apply_async(run_gnugo, (sgf_file_name, command))\n            output = result.get(timeout=10)\n            pool.close()\n            return output\n        except multiprocessing.TimeoutError:\n            pool.terminate()\n            \n            return ''\n\n    def cmd_time_left(self, arguments):\n        pass\n\n    def cmd_place_free_handicap(self, arguments):\n        try:\n            number_of_stones = int(arguments)\n        except Exception:\n            raise ValueError('Number of handicaps could not be parsed: {}'.format(arguments))\n        if number_of_stones < 2 or number_of_stones > 9:\n            raise ValueError('Invalid number of handicap stones: {}'.format(number_of_stones))\n        vertex_string = ExtendedGtpEngine.recommended_handicaps[number_of_stones]\n        self.cmd_set_free_handicap(vertex_string)\n        return vertex_string\n\n    def cmd_set_free_handicap(self, arguments):\n        vertices = arguments.strip().split()\n        moves = [gtp.parse_vertex(vertex) for vertex in vertices]\n        self._game.place_handicaps(moves)\n\n    def cmd_final_score(self, arguments):\n        sgf_file_name = self._game.get_current_state_as_sgf()\n        return self.call_gnugo(sgf_file_name, 'final_score\\n')\n\n    def cmd_final_status_list(self, arguments):\n        sgf_file_name = self._game.get_current_state_as_sgf()\n        return self.call_gnugo(sgf_file_name, 'final_status_list {}\\n'.format(arguments))\n\n    def cmd_load_sgf(self, arguments):\n        pass\n\n    def cmd_save_sgf(self, arguments):\n        pass\n\n    # def cmd_kgs_genmove_cleanup(self, arguments):\n    #     return self.cmd_genmove(arguments)\n\n\nclass GTPGameConnector(object):\n    \n\n    def __init__(self, player):\n        self._state = go.GameState(enforce_superko=True)\n        self._player = player\n\n    def clear(self):\n        self._state = go.GameState(self._state.size, enforce_superko=True)\n\n    def make_move(self, color, vertex):\n        \n        try:\n            if vertex == gtp.PASS:\n                self._state.do_move(go.PASS_MOVE)\n            else:\n                (x, y) = vertex\n                self._state.do_move((x - 1, y - 1), color)\n            return True\n        except go.IllegalMove:\n            return False\n\n    def set_size(self, n):\n        self._state = go.GameState(n, enforce_superko=True)\n\n    def set_komi(self, k):\n        self._state.komi = k\n\n    def get_move(self, color):\n        self._state.current_player = color\n        move = self._player.get_move(self._state)\n        if move == go.PASS_MOVE:\n            return gtp.PASS\n        else:\n            (x, y) = move\n            return (x + 1, y + 1)\n\n    def get_current_state_as_sgf(self):\n        from tempfile import NamedTemporaryFile\n        temp_file = NamedTemporaryFile(delete=False)\n        save_gamestate_to_sgf(self._state, '', temp_file.name)\n        return temp_file.name\n\n    def place_handicaps(self, vertices):\n        actions = []\n        for vertex in vertices:\n            (x, y) = vertex\n            actions.append((x - 1, y - 1))\n        self._state.place_handicaps(actions)\n\n\ndef run_gtp(player_obj, inpt_fn=None, name=\"Gtp Player\", version=\"0.0\"):\n    gtp_game = GTPGameConnector(player_obj)\n    gtp_engine = ExtendedGtpEngine(gtp_game, name, version)\n    if inpt_fn is None:\n        inpt_fn = input\n\n    sys.stderr.write(\"GTP engine ready\\n\")\n    sys.stderr.flush()\n    while not gtp_engine.disconnect:\n        inpt = inpt_fn()\n        \n        # or multiple commands separated by '\\n'\n        cmd_list = inpt.split(\"\\n\")\n        for cmd in cmd_list:\n            engine_reply = gtp_engine.send(cmd)\n            sys.stdout.write(engine_reply)\n            sys.stdout.flush()\n", "comments": "   a class implementing functions  game  object required gtp     engine wrapping gamestate player instance            get answer gnugo  return result    def cmd kgs genmove cleanup(self  arguments)         return self cmd genmove(arguments)    vertex gtp language 1 indexed  whereas gamestate zero indexed    handle either single lines time    multiple commands separated   n  ", "content": "import sys\nimport multiprocessing\nimport gtp\nfrom AlphaGo import go\nfrom AlphaGo.util import save_gamestate_to_sgf\nfrom builtins import input\n\n\ndef run_gnugo(sgf_file_name, command):\n    from distutils import spawn\n    if spawn.find_executable('gnugo'):\n        from subprocess import Popen, PIPE\n        p = Popen(['gnugo', '--chinese-rules', '--mode', 'gtp', '-l', sgf_file_name],\n                  stdout=PIPE, stdin=PIPE, stderr=PIPE)\n        out_bytes = p.communicate(input=command)[0]\n        return out_bytes.decode('utf-8')[2:]\n    else:\n        return ''\n\n\nclass ExtendedGtpEngine(gtp.Engine):\n\n    recommended_handicaps = {\n        2: \"D4 Q16\",\n        3: \"D4 Q16 D16\",\n        4: \"D4 Q16 D16 Q4\",\n        5: \"D4 Q16 D16 Q4 K10\",\n        6: \"D4 Q16 D16 Q4 D10 Q10\",\n        7: \"D4 Q16 D16 Q4 D10 Q10 K10\",\n        8: \"D4 Q16 D16 Q4 D10 Q10 K4 K16\",\n        9: \"D4 Q16 D16 Q4 D10 Q10 K4 K16 K10\"\n    }\n\n    def call_gnugo(self, sgf_file_name, command):\n        try:\n            pool = multiprocessing.Pool(processes=1)\n            result = pool.apply_async(run_gnugo, (sgf_file_name, command))\n            output = result.get(timeout=10)\n            pool.close()\n            return output\n        except multiprocessing.TimeoutError:\n            pool.terminate()\n            # if can't get answer from GnuGo, return no result\n            return ''\n\n    def cmd_time_left(self, arguments):\n        pass\n\n    def cmd_place_free_handicap(self, arguments):\n        try:\n            number_of_stones = int(arguments)\n        except Exception:\n            raise ValueError('Number of handicaps could not be parsed: {}'.format(arguments))\n        if number_of_stones < 2 or number_of_stones > 9:\n            raise ValueError('Invalid number of handicap stones: {}'.format(number_of_stones))\n        vertex_string = ExtendedGtpEngine.recommended_handicaps[number_of_stones]\n        self.cmd_set_free_handicap(vertex_string)\n        return vertex_string\n\n    def cmd_set_free_handicap(self, arguments):\n        vertices = arguments.strip().split()\n        moves = [gtp.parse_vertex(vertex) for vertex in vertices]\n        self._game.place_handicaps(moves)\n\n    def cmd_final_score(self, arguments):\n        sgf_file_name = self._game.get_current_state_as_sgf()\n        return self.call_gnugo(sgf_file_name, 'final_score\\n')\n\n    def cmd_final_status_list(self, arguments):\n        sgf_file_name = self._game.get_current_state_as_sgf()\n        return self.call_gnugo(sgf_file_name, 'final_status_list {}\\n'.format(arguments))\n\n    def cmd_load_sgf(self, arguments):\n        pass\n\n    def cmd_save_sgf(self, arguments):\n        pass\n\n    # def cmd_kgs_genmove_cleanup(self, arguments):\n    #     return self.cmd_genmove(arguments)\n\n\nclass GTPGameConnector(object):\n    \"\"\"A class implementing the functions of a 'game' object required by the GTP\n    Engine by wrapping a GameState and Player instance\n    \"\"\"\n\n    def __init__(self, player):\n        self._state = go.GameState(enforce_superko=True)\n        self._player = player\n\n    def clear(self):\n        self._state = go.GameState(self._state.size, enforce_superko=True)\n\n    def make_move(self, color, vertex):\n        # vertex in GTP language is 1-indexed, whereas GameState's are zero-indexed\n        try:\n            if vertex == gtp.PASS:\n                self._state.do_move(go.PASS_MOVE)\n            else:\n                (x, y) = vertex\n                self._state.do_move((x - 1, y - 1), color)\n            return True\n        except go.IllegalMove:\n            return False\n\n    def set_size(self, n):\n        self._state = go.GameState(n, enforce_superko=True)\n\n    def set_komi(self, k):\n        self._state.komi = k\n\n    def get_move(self, color):\n        self._state.current_player = color\n        move = self._player.get_move(self._state)\n        if move == go.PASS_MOVE:\n            return gtp.PASS\n        else:\n            (x, y) = move\n            return (x + 1, y + 1)\n\n    def get_current_state_as_sgf(self):\n        from tempfile import NamedTemporaryFile\n        temp_file = NamedTemporaryFile(delete=False)\n        save_gamestate_to_sgf(self._state, '', temp_file.name)\n        return temp_file.name\n\n    def place_handicaps(self, vertices):\n        actions = []\n        for vertex in vertices:\n            (x, y) = vertex\n            actions.append((x - 1, y - 1))\n        self._state.place_handicaps(actions)\n\n\ndef run_gtp(player_obj, inpt_fn=None, name=\"Gtp Player\", version=\"0.0\"):\n    gtp_game = GTPGameConnector(player_obj)\n    gtp_engine = ExtendedGtpEngine(gtp_game, name, version)\n    if inpt_fn is None:\n        inpt_fn = input\n\n    sys.stderr.write(\"GTP engine ready\\n\")\n    sys.stderr.flush()\n    while not gtp_engine.disconnect:\n        inpt = inpt_fn()\n        # handle either single lines at a time\n        # or multiple commands separated by '\\n'\n        cmd_list = inpt.split(\"\\n\")\n        for cmd in cmd_list:\n            engine_reply = gtp_engine.send(cmd)\n            sys.stdout.write(engine_reply)\n            sys.stdout.flush()\n", "description": "An independent, student-led replication of DeepMind's 2016 Nature publication, \"Mastering the game of Go with deep neural networks and tree search\" (Nature 529, 484-489, 28 Jan 2016), details of which can be found on their website https://deepmind.com/publications.html.", "file_name": "gtp_wrapper.py", "id": "e57ac27a301ced144ce6b0e185175ddc", "language": "Python", "project_name": "RocAlphaGo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/Rochester-NRT-RocAlphaGo/Rochester-NRT-RocAlphaGo-a39cac2/interface/gtp_wrapper.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:14:30Z", "url": "https://github.com/Rochester-NRT/RocAlphaGo", "wiki": true}