{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport json\nimport re\nimport time\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_HTTPError,\n    compat_str,\n    compat_urlparse,\n)\nfrom ..utils import (\n    determine_ext,\n    ExtractorError,\n    float_or_none,\n    int_or_none,\n    remove_end,\n    try_get,\n    unified_strdate,\n    unified_timestamp,\n    update_url_query,\n    USER_AGENTS,\n)\n\n\nclass DPlayIE(InfoExtractor):\n    _VALID_URL = r'https?://(?P<domain>www\\.(?P<host>dplay\\.(?P<country>dk|se|no)))/(?:video(?:er|s)/)?(?P<id>[^/]+/[^/?\n\n    _TESTS = [{\n        \n        'url': 'http://www.dplay.se/nugammalt-77-handelser-som-format-sverige/season-1-svensken-lar-sig-njuta-av-livet/',\n        'info_dict': {\n            'id': '3172',\n            'display_id': 'nugammalt-77-handelser-som-format-sverige/season-1-svensken-lar-sig-njuta-av-livet',\n            'ext': 'mp4',\n            'title': 'Svensken l\u00e4r sig njuta av livet',\n            'description': 'md5:d3819c9bccffd0fe458ca42451dd50d8',\n            'duration': 2650,\n            'timestamp': 1365454320,\n            'upload_date': '20130408',\n            'creator': 'Kanal 5 (Home)',\n            'series': 'Nugammalt - 77 h\u00e4ndelser som format Sverige',\n            'season_number': 1,\n            'episode_number': 1,\n            'age_limit': 0,\n        },\n    }, {\n        \n        'url': 'http://www.dplay.dk/mig-og-min-mor/season-6-episode-12/',\n        'info_dict': {\n            'id': '70816',\n            'display_id': 'mig-og-min-mor/season-6-episode-12',\n            'ext': 'mp4',\n            'title': 'Episode 12',\n            'description': 'md5:9c86e51a93f8a4401fc9641ef9894c90',\n            'duration': 2563,\n            'timestamp': 1429696800,\n            'upload_date': '20150422',\n            'creator': 'Kanal 4 (Home)',\n            'series': 'Mig og min mor',\n            'season_number': 6,\n            'episode_number': 12,\n            'age_limit': 0,\n        },\n    }, {\n        \n        'url': 'http://www.dplay.no/pga-tour/season-1-hoydepunkter-18-21-februar/',\n        'only_matching': True,\n    }, {\n        \n        'url': 'https://www.dplay.no/videoer/i-kongens-klr/sesong-1-episode-7',\n        'info_dict': {\n            'id': '40206',\n            'display_id': 'i-kongens-klr/sesong-1-episode-7',\n            'ext': 'mp4',\n            'title': 'Episode 7',\n            'description': 'md5:e3e1411b2b9aebeea36a6ec5d50c60cf',\n            'duration': 2611.16,\n            'timestamp': 1516726800,\n            'upload_date': '20180123',\n            'series': 'I kongens kl\u00e6r',\n            'season_number': 1,\n            'episode_number': 7,\n        },\n        'params': {\n            'format': 'bestvideo',\n            'skip_download': True,\n        },\n    }, {\n\n        'url': 'https://www.dplay.dk/videoer/singleliv/season-5-episode-3',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.dplay.se/videos/sofias-anglar/sofias-anglar-1001',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        display_id = mobj.group('id')\n        domain = mobj.group('domain')\n\n        self._initialize_geo_bypass([mobj.group('country').upper()])\n\n        webpage = self._download_webpage(url, display_id)\n\n        video_id = self._search_regex(\n            r'data-video-id=[\"\\'](\\d+)', webpage, 'video id', default=None)\n\n        if not video_id:\n            host = mobj.group('host')\n            disco_base = 'https://disco-api.%s' % host\n            self._download_json(\n                '%s/token' % disco_base, display_id, 'Downloading token',\n                query={\n                    'realm': host.replace('.', ''),\n                })\n            video = self._download_json(\n                '%s/content/videos/%s' % (disco_base, display_id), display_id,\n                headers={\n                    'Referer': url,\n                    'x-disco-client': 'WEB:UNKNOWN:dplay-client:0.0.1',\n                }, query={\n                    'include': 'show'\n                })\n            video_id = video['data']['id']\n            info = video['data']['attributes']\n            title = info['name']\n            formats = []\n            for format_id, format_dict in self._download_json(\n                    '%s/playback/videoPlaybackInfo/%s' % (disco_base, video_id),\n                    display_id)['data']['attributes']['streaming'].items():\n                if not isinstance(format_dict, dict):\n                    continue\n                format_url = format_dict.get('url')\n                if not format_url:\n                    continue\n                ext = determine_ext(format_url)\n                if format_id == 'dash' or ext == 'mpd':\n                    formats.extend(self._extract_mpd_formats(\n                        format_url, display_id, mpd_id='dash', fatal=False))\n                elif format_id == 'hls' or ext == 'm3u8':\n                    formats.extend(self._extract_m3u8_formats(\n                        format_url, display_id, 'mp4',\n                        entry_protocol='m3u8_native', m3u8_id='hls',\n                        fatal=False))\n                else:\n                    formats.append({\n                        'url': format_url,\n                        'format_id': format_id,\n                    })\n            self._sort_formats(formats)\n\n            series = None\n            try:\n                included = video.get('included')\n                if isinstance(included, list):\n                    show = next(e for e in included if e.get('type') == 'show')\n                    series = try_get(\n                        show, lambda x: x['attributes']['name'], compat_str)\n            except StopIteration:\n                pass\n\n            return {\n                'id': video_id,\n                'display_id': display_id,\n                'title': title,\n                'description': info.get('description'),\n                'duration': float_or_none(\n                    info.get('videoDuration'), scale=1000),\n                'timestamp': unified_timestamp(info.get('publishStart')),\n                'series': series,\n                'season_number': int_or_none(info.get('seasonNumber')),\n                'episode_number': int_or_none(info.get('episodeNumber')),\n                'age_limit': int_or_none(info.get('minimum_age')),\n                'formats': formats,\n            }\n\n        info = self._download_json(\n            'http://%s/api/v2/ajax/videos?video_id=%s' % (domain, video_id),\n            video_id)['data'][0]\n\n        title = info['title']\n\n        PROTOCOLS = ('hls', 'hds')\n        formats = []\n\n        def extract_formats(protocol, manifest_url):\n            if protocol == 'hls':\n                m3u8_formats = self._extract_m3u8_formats(\n                    manifest_url, video_id, ext='mp4',\n                    entry_protocol='m3u8_native', m3u8_id=protocol, fatal=False)\n                \n                \n                \n                query = compat_urlparse.parse_qs(compat_urlparse.urlparse(manifest_url).query)\n                for m3u8_format in m3u8_formats:\n                    m3u8_format.update({\n                        'url': update_url_query(m3u8_format['url'], query),\n                        'http_headers': {\n                            'User-Agent': USER_AGENTS['Safari'],\n                        },\n                    })\n                formats.extend(m3u8_formats)\n            elif protocol == 'hds':\n                formats.extend(self._extract_f4m_formats(\n                    manifest_url + '&hdcore=3.8.0&plugin=flowplayer-3.8.0.0',\n                    video_id, f4m_id=protocol, fatal=False))\n\n        domain_tld = domain.split('.')[-1]\n        if domain_tld in ('se', 'dk', 'no'):\n            for protocol in PROTOCOLS:\n                \n                self._set_cookie(\n                    'secure.dplay.%s' % domain_tld, 'dsc-geo',\n                    json.dumps({\n                        'countryCode': domain_tld.upper(),\n                        'expiry': (time.time() + 20 * 60) * 1000,\n                    }))\n                stream = self._download_json(\n                    'https://secure.dplay.%s/secure/api/v2/user/authorization/stream/%s?stream_type=%s'\n                    % (domain_tld, video_id, protocol), video_id,\n                    'Downloading %s stream JSON' % protocol, fatal=False)\n                if stream and stream.get(protocol):\n                    extract_formats(protocol, stream[protocol])\n\n        \n        \n        \n        if not formats:\n            for protocol in PROTOCOLS:\n                if info.get(protocol):\n                    extract_formats(protocol, info[protocol])\n\n        self._sort_formats(formats)\n\n        subtitles = {}\n        for lang in ('se', 'sv', 'da', 'nl', 'no'):\n            for format_id in ('web_vtt', 'vtt', 'srt'):\n                subtitle_url = info.get('subtitles_%s_%s' % (lang, format_id))\n                if subtitle_url:\n                    subtitles.setdefault(lang, []).append({'url': subtitle_url})\n\n        return {\n            'id': video_id,\n            'display_id': display_id,\n            'title': title,\n            'description': info.get('video_metadata_longDescription'),\n            'duration': int_or_none(info.get('video_metadata_length'), scale=1000),\n            'timestamp': int_or_none(info.get('video_publish_date')),\n            'creator': info.get('video_metadata_homeChannel'),\n            'series': info.get('video_metadata_show'),\n            'season_number': int_or_none(info.get('season')),\n            'episode_number': int_or_none(info.get('episode')),\n            'age_limit': int_or_none(info.get('minimum_age')),\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n\n\nclass DPlayItIE(InfoExtractor):\n    _VALID_URL = r'https?://it\\.dplay\\.com/[^/]+/[^/]+/(?P<id>[^/?\n    _GEO_COUNTRIES = ['IT']\n    _TEST = {\n        'url': 'http://it.dplay.com/nove/biografie-imbarazzanti/luigi-di-maio-la-psicosi-di-stanislawskij/',\n        'md5': '2b808ffb00fc47b884a172ca5d13053c',\n        'info_dict': {\n            'id': '6918',\n            'display_id': 'luigi-di-maio-la-psicosi-di-stanislawskij',\n            'ext': 'mp4',\n            'title': 'Biografie imbarazzanti: Luigi Di Maio: la psicosi di Stanislawskij',\n            'description': 'md5:3c7a4303aef85868f867a26f5cc14813',\n            'thumbnail': r're:^https?://.*\\.jpe?g',\n            'upload_date': '20160524',\n            'series': 'Biografie imbarazzanti',\n            'season_number': 1,\n            'episode': 'Luigi Di Maio: la psicosi di Stanislawskij',\n            'episode_number': 1,\n        },\n    }\n\n    def _real_extract(self, url):\n        display_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, display_id)\n\n        title = remove_end(self._og_search_title(webpage), ' | Dplay')\n\n        video_id = None\n\n        info = self._search_regex(\n            r'playback_json\\s*:\\s*JSON\\.parse\\s*\\(\\s*(\"(?:\\\\.|[^\"\\\\])+?\")',\n            webpage, 'playback JSON', default=None)\n        if info:\n            for _ in range(2):\n                info = self._parse_json(info, display_id, fatal=False)\n                if not info:\n                    break\n            else:\n                video_id = try_get(info, lambda x: x['data']['id'])\n\n        if not info:\n            info_url = self._search_regex(\n                r'url\\s*[:=]\\s*[\"\\']((?:https?:)?//[^/]+/playback/videoPlaybackInfo/\\d+)',\n                webpage, 'info url')\n\n            video_id = info_url.rpartition('/')[-1]\n\n            try:\n                info = self._download_json(\n                    info_url, display_id, headers={\n                        'Authorization': 'Bearer %s' % self._get_cookies(url).get(\n                            'dplayit_token').value,\n                        'Referer': url,\n                    })\n            except ExtractorError as e:\n                if isinstance(e.cause, compat_HTTPError) and e.cause.code in (400, 403):\n                    info = self._parse_json(e.cause.read().decode('utf-8'), display_id)\n                    error = info['errors'][0]\n                    if error.get('code') == 'access.denied.geoblocked':\n                        self.raise_geo_restricted(\n                            msg=error.get('detail'), countries=self._GEO_COUNTRIES)\n                    raise ExtractorError(info['errors'][0]['detail'], expected=True)\n                raise\n\n        hls_url = info['data']['attributes']['streaming']['hls']['url']\n\n        formats = self._extract_m3u8_formats(\n            hls_url, display_id, ext='mp4', entry_protocol='m3u8_native',\n            m3u8_id='hls')\n\n        series = self._html_search_regex(\n            r'(?s)<h1[^>]+class=[\"\\'].*?\\bshow_title\\b.*?[\"\\'][^>]*>(.+?)</h1>',\n            webpage, 'series', fatal=False)\n        episode = self._search_regex(\n            r'<p[^>]+class=[\"\\'].*?\\bdesc_ep\\b.*?[\"\\'][^>]*>\\s*<br/>\\s*<b>([^<]+)',\n            webpage, 'episode', fatal=False)\n\n        mobj = re.search(\n            r'(?s)<span[^>]+class=[\"\\']dates[\"\\'][^>]*>.+?\\bS\\.(?P<season_number>\\d+)\\s+E\\.(?P<episode_number>\\d+)\\s*-\\s*(?P<upload_date>\\d{2}/\\d{2}/\\d{4})',\n            webpage)\n        if mobj:\n            season_number = int(mobj.group('season_number'))\n            episode_number = int(mobj.group('episode_number'))\n            upload_date = unified_strdate(mobj.group('upload_date'))\n        else:\n            season_number = episode_number = upload_date = None\n\n        return {\n            'id': compat_str(video_id or display_id),\n            'display_id': display_id,\n            'title': title,\n            'description': self._og_search_description(webpage),\n            'thumbnail': self._og_search_thumbnail(webpage),\n            'series': series,\n            'season_number': season_number,\n            'episode': episode,\n            'episode_number': episode_number,\n            'upload_date': upload_date,\n            'formats': formats,\n        }\n", "comments": "# coding: utf-8\n#]+)'\n# non geo restricted, via secure api, unsigned download hls URL\n# geo restricted, via secure api, unsigned download hls URL\n# geo restricted, via direct unsigned hls URL\n# disco-api\n# Sometimes final URLs inside m3u8 are unsigned, let's fix this\n# ourselves. Also fragments' URLs are only served signed for\n# Safari user agent.\n# Providing dsc-geo allows to bypass geo restriction in some cases\n# The last resort is to try direct unsigned hls/hds URLs from info dictionary.\n# Sometimes this does work even when secure API with dsc-geo has failed (e.g.\n# http://www.dplay.no/pga-tour/season-1-hoydepunkter-18-21-februar/).\n#]+)'\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport json\nimport re\nimport time\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_HTTPError,\n    compat_str,\n    compat_urlparse,\n)\nfrom ..utils import (\n    determine_ext,\n    ExtractorError,\n    float_or_none,\n    int_or_none,\n    remove_end,\n    try_get,\n    unified_strdate,\n    unified_timestamp,\n    update_url_query,\n    USER_AGENTS,\n)\n\n\nclass DPlayIE(InfoExtractor):\n    _VALID_URL = r'https?://(?P<domain>www\\.(?P<host>dplay\\.(?P<country>dk|se|no)))/(?:video(?:er|s)/)?(?P<id>[^/]+/[^/?#]+)'\n\n    _TESTS = [{\n        # non geo restricted, via secure api, unsigned download hls URL\n        'url': 'http://www.dplay.se/nugammalt-77-handelser-som-format-sverige/season-1-svensken-lar-sig-njuta-av-livet/',\n        'info_dict': {\n            'id': '3172',\n            'display_id': 'nugammalt-77-handelser-som-format-sverige/season-1-svensken-lar-sig-njuta-av-livet',\n            'ext': 'mp4',\n            'title': 'Svensken l\u00e4r sig njuta av livet',\n            'description': 'md5:d3819c9bccffd0fe458ca42451dd50d8',\n            'duration': 2650,\n            'timestamp': 1365454320,\n            'upload_date': '20130408',\n            'creator': 'Kanal 5 (Home)',\n            'series': 'Nugammalt - 77 h\u00e4ndelser som format Sverige',\n            'season_number': 1,\n            'episode_number': 1,\n            'age_limit': 0,\n        },\n    }, {\n        # geo restricted, via secure api, unsigned download hls URL\n        'url': 'http://www.dplay.dk/mig-og-min-mor/season-6-episode-12/',\n        'info_dict': {\n            'id': '70816',\n            'display_id': 'mig-og-min-mor/season-6-episode-12',\n            'ext': 'mp4',\n            'title': 'Episode 12',\n            'description': 'md5:9c86e51a93f8a4401fc9641ef9894c90',\n            'duration': 2563,\n            'timestamp': 1429696800,\n            'upload_date': '20150422',\n            'creator': 'Kanal 4 (Home)',\n            'series': 'Mig og min mor',\n            'season_number': 6,\n            'episode_number': 12,\n            'age_limit': 0,\n        },\n    }, {\n        # geo restricted, via direct unsigned hls URL\n        'url': 'http://www.dplay.no/pga-tour/season-1-hoydepunkter-18-21-februar/',\n        'only_matching': True,\n    }, {\n        # disco-api\n        'url': 'https://www.dplay.no/videoer/i-kongens-klr/sesong-1-episode-7',\n        'info_dict': {\n            'id': '40206',\n            'display_id': 'i-kongens-klr/sesong-1-episode-7',\n            'ext': 'mp4',\n            'title': 'Episode 7',\n            'description': 'md5:e3e1411b2b9aebeea36a6ec5d50c60cf',\n            'duration': 2611.16,\n            'timestamp': 1516726800,\n            'upload_date': '20180123',\n            'series': 'I kongens kl\u00e6r',\n            'season_number': 1,\n            'episode_number': 7,\n        },\n        'params': {\n            'format': 'bestvideo',\n            'skip_download': True,\n        },\n    }, {\n\n        'url': 'https://www.dplay.dk/videoer/singleliv/season-5-episode-3',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.dplay.se/videos/sofias-anglar/sofias-anglar-1001',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        display_id = mobj.group('id')\n        domain = mobj.group('domain')\n\n        self._initialize_geo_bypass([mobj.group('country').upper()])\n\n        webpage = self._download_webpage(url, display_id)\n\n        video_id = self._search_regex(\n            r'data-video-id=[\"\\'](\\d+)', webpage, 'video id', default=None)\n\n        if not video_id:\n            host = mobj.group('host')\n            disco_base = 'https://disco-api.%s' % host\n            self._download_json(\n                '%s/token' % disco_base, display_id, 'Downloading token',\n                query={\n                    'realm': host.replace('.', ''),\n                })\n            video = self._download_json(\n                '%s/content/videos/%s' % (disco_base, display_id), display_id,\n                headers={\n                    'Referer': url,\n                    'x-disco-client': 'WEB:UNKNOWN:dplay-client:0.0.1',\n                }, query={\n                    'include': 'show'\n                })\n            video_id = video['data']['id']\n            info = video['data']['attributes']\n            title = info['name']\n            formats = []\n            for format_id, format_dict in self._download_json(\n                    '%s/playback/videoPlaybackInfo/%s' % (disco_base, video_id),\n                    display_id)['data']['attributes']['streaming'].items():\n                if not isinstance(format_dict, dict):\n                    continue\n                format_url = format_dict.get('url')\n                if not format_url:\n                    continue\n                ext = determine_ext(format_url)\n                if format_id == 'dash' or ext == 'mpd':\n                    formats.extend(self._extract_mpd_formats(\n                        format_url, display_id, mpd_id='dash', fatal=False))\n                elif format_id == 'hls' or ext == 'm3u8':\n                    formats.extend(self._extract_m3u8_formats(\n                        format_url, display_id, 'mp4',\n                        entry_protocol='m3u8_native', m3u8_id='hls',\n                        fatal=False))\n                else:\n                    formats.append({\n                        'url': format_url,\n                        'format_id': format_id,\n                    })\n            self._sort_formats(formats)\n\n            series = None\n            try:\n                included = video.get('included')\n                if isinstance(included, list):\n                    show = next(e for e in included if e.get('type') == 'show')\n                    series = try_get(\n                        show, lambda x: x['attributes']['name'], compat_str)\n            except StopIteration:\n                pass\n\n            return {\n                'id': video_id,\n                'display_id': display_id,\n                'title': title,\n                'description': info.get('description'),\n                'duration': float_or_none(\n                    info.get('videoDuration'), scale=1000),\n                'timestamp': unified_timestamp(info.get('publishStart')),\n                'series': series,\n                'season_number': int_or_none(info.get('seasonNumber')),\n                'episode_number': int_or_none(info.get('episodeNumber')),\n                'age_limit': int_or_none(info.get('minimum_age')),\n                'formats': formats,\n            }\n\n        info = self._download_json(\n            'http://%s/api/v2/ajax/videos?video_id=%s' % (domain, video_id),\n            video_id)['data'][0]\n\n        title = info['title']\n\n        PROTOCOLS = ('hls', 'hds')\n        formats = []\n\n        def extract_formats(protocol, manifest_url):\n            if protocol == 'hls':\n                m3u8_formats = self._extract_m3u8_formats(\n                    manifest_url, video_id, ext='mp4',\n                    entry_protocol='m3u8_native', m3u8_id=protocol, fatal=False)\n                # Sometimes final URLs inside m3u8 are unsigned, let's fix this\n                # ourselves. Also fragments' URLs are only served signed for\n                # Safari user agent.\n                query = compat_urlparse.parse_qs(compat_urlparse.urlparse(manifest_url).query)\n                for m3u8_format in m3u8_formats:\n                    m3u8_format.update({\n                        'url': update_url_query(m3u8_format['url'], query),\n                        'http_headers': {\n                            'User-Agent': USER_AGENTS['Safari'],\n                        },\n                    })\n                formats.extend(m3u8_formats)\n            elif protocol == 'hds':\n                formats.extend(self._extract_f4m_formats(\n                    manifest_url + '&hdcore=3.8.0&plugin=flowplayer-3.8.0.0',\n                    video_id, f4m_id=protocol, fatal=False))\n\n        domain_tld = domain.split('.')[-1]\n        if domain_tld in ('se', 'dk', 'no'):\n            for protocol in PROTOCOLS:\n                # Providing dsc-geo allows to bypass geo restriction in some cases\n                self._set_cookie(\n                    'secure.dplay.%s' % domain_tld, 'dsc-geo',\n                    json.dumps({\n                        'countryCode': domain_tld.upper(),\n                        'expiry': (time.time() + 20 * 60) * 1000,\n                    }))\n                stream = self._download_json(\n                    'https://secure.dplay.%s/secure/api/v2/user/authorization/stream/%s?stream_type=%s'\n                    % (domain_tld, video_id, protocol), video_id,\n                    'Downloading %s stream JSON' % protocol, fatal=False)\n                if stream and stream.get(protocol):\n                    extract_formats(protocol, stream[protocol])\n\n        # The last resort is to try direct unsigned hls/hds URLs from info dictionary.\n        # Sometimes this does work even when secure API with dsc-geo has failed (e.g.\n        # http://www.dplay.no/pga-tour/season-1-hoydepunkter-18-21-februar/).\n        if not formats:\n            for protocol in PROTOCOLS:\n                if info.get(protocol):\n                    extract_formats(protocol, info[protocol])\n\n        self._sort_formats(formats)\n\n        subtitles = {}\n        for lang in ('se', 'sv', 'da', 'nl', 'no'):\n            for format_id in ('web_vtt', 'vtt', 'srt'):\n                subtitle_url = info.get('subtitles_%s_%s' % (lang, format_id))\n                if subtitle_url:\n                    subtitles.setdefault(lang, []).append({'url': subtitle_url})\n\n        return {\n            'id': video_id,\n            'display_id': display_id,\n            'title': title,\n            'description': info.get('video_metadata_longDescription'),\n            'duration': int_or_none(info.get('video_metadata_length'), scale=1000),\n            'timestamp': int_or_none(info.get('video_publish_date')),\n            'creator': info.get('video_metadata_homeChannel'),\n            'series': info.get('video_metadata_show'),\n            'season_number': int_or_none(info.get('season')),\n            'episode_number': int_or_none(info.get('episode')),\n            'age_limit': int_or_none(info.get('minimum_age')),\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n\n\nclass DPlayItIE(InfoExtractor):\n    _VALID_URL = r'https?://it\\.dplay\\.com/[^/]+/[^/]+/(?P<id>[^/?#]+)'\n    _GEO_COUNTRIES = ['IT']\n    _TEST = {\n        'url': 'http://it.dplay.com/nove/biografie-imbarazzanti/luigi-di-maio-la-psicosi-di-stanislawskij/',\n        'md5': '2b808ffb00fc47b884a172ca5d13053c',\n        'info_dict': {\n            'id': '6918',\n            'display_id': 'luigi-di-maio-la-psicosi-di-stanislawskij',\n            'ext': 'mp4',\n            'title': 'Biografie imbarazzanti: Luigi Di Maio: la psicosi di Stanislawskij',\n            'description': 'md5:3c7a4303aef85868f867a26f5cc14813',\n            'thumbnail': r're:^https?://.*\\.jpe?g',\n            'upload_date': '20160524',\n            'series': 'Biografie imbarazzanti',\n            'season_number': 1,\n            'episode': 'Luigi Di Maio: la psicosi di Stanislawskij',\n            'episode_number': 1,\n        },\n    }\n\n    def _real_extract(self, url):\n        display_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, display_id)\n\n        title = remove_end(self._og_search_title(webpage), ' | Dplay')\n\n        video_id = None\n\n        info = self._search_regex(\n            r'playback_json\\s*:\\s*JSON\\.parse\\s*\\(\\s*(\"(?:\\\\.|[^\"\\\\])+?\")',\n            webpage, 'playback JSON', default=None)\n        if info:\n            for _ in range(2):\n                info = self._parse_json(info, display_id, fatal=False)\n                if not info:\n                    break\n            else:\n                video_id = try_get(info, lambda x: x['data']['id'])\n\n        if not info:\n            info_url = self._search_regex(\n                r'url\\s*[:=]\\s*[\"\\']((?:https?:)?//[^/]+/playback/videoPlaybackInfo/\\d+)',\n                webpage, 'info url')\n\n            video_id = info_url.rpartition('/')[-1]\n\n            try:\n                info = self._download_json(\n                    info_url, display_id, headers={\n                        'Authorization': 'Bearer %s' % self._get_cookies(url).get(\n                            'dplayit_token').value,\n                        'Referer': url,\n                    })\n            except ExtractorError as e:\n                if isinstance(e.cause, compat_HTTPError) and e.cause.code in (400, 403):\n                    info = self._parse_json(e.cause.read().decode('utf-8'), display_id)\n                    error = info['errors'][0]\n                    if error.get('code') == 'access.denied.geoblocked':\n                        self.raise_geo_restricted(\n                            msg=error.get('detail'), countries=self._GEO_COUNTRIES)\n                    raise ExtractorError(info['errors'][0]['detail'], expected=True)\n                raise\n\n        hls_url = info['data']['attributes']['streaming']['hls']['url']\n\n        formats = self._extract_m3u8_formats(\n            hls_url, display_id, ext='mp4', entry_protocol='m3u8_native',\n            m3u8_id='hls')\n\n        series = self._html_search_regex(\n            r'(?s)<h1[^>]+class=[\"\\'].*?\\bshow_title\\b.*?[\"\\'][^>]*>(.+?)</h1>',\n            webpage, 'series', fatal=False)\n        episode = self._search_regex(\n            r'<p[^>]+class=[\"\\'].*?\\bdesc_ep\\b.*?[\"\\'][^>]*>\\s*<br/>\\s*<b>([^<]+)',\n            webpage, 'episode', fatal=False)\n\n        mobj = re.search(\n            r'(?s)<span[^>]+class=[\"\\']dates[\"\\'][^>]*>.+?\\bS\\.(?P<season_number>\\d+)\\s+E\\.(?P<episode_number>\\d+)\\s*-\\s*(?P<upload_date>\\d{2}/\\d{2}/\\d{4})',\n            webpage)\n        if mobj:\n            season_number = int(mobj.group('season_number'))\n            episode_number = int(mobj.group('episode_number'))\n            upload_date = unified_strdate(mobj.group('upload_date'))\n        else:\n            season_number = episode_number = upload_date = None\n\n        return {\n            'id': compat_str(video_id or display_id),\n            'display_id': display_id,\n            'title': title,\n            'description': self._og_search_description(webpage),\n            'thumbnail': self._og_search_thumbnail(webpage),\n            'series': series,\n            'season_number': season_number,\n            'episode': episode,\n            'episode_number': episode_number,\n            'upload_date': upload_date,\n            'formats': formats,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "dplay.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/dplay.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}