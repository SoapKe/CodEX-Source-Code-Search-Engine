{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_HTTPError\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    smuggle_url,\n    try_get,\n    unsmuggle_url,\n    ExtractorError,\n)\n\n\nclass LimelightBaseIE(InfoExtractor):\n    _PLAYLIST_SERVICE_URL = 'http://production-ps.lvp.llnw.net/r/PlaylistService/%s/%s/%s'\n    _API_URL = 'http://api.video.limelight.com/rest/organizations/%s/%s/%s/%s.json'\n\n    @classmethod\n    def _extract_urls(cls, webpage, source_url):\n        lm = {\n            'Media': 'media',\n            'Channel': 'channel',\n            'ChannelList': 'channel_list',\n        }\n\n        def smuggle(url):\n            return smuggle_url(url, {'source_url': source_url})\n\n        entries = []\n        for kind, video_id in re.findall(\n                r'LimelightPlayer\\.doLoad(Media|Channel|ChannelList)\\([\"\\'](?P<id>[a-z0-9]{32})',\n                webpage):\n            entries.append(cls.url_result(\n                smuggle('limelight:%s:%s' % (lm[kind], video_id)),\n                'Limelight%s' % kind, video_id))\n        for mobj in re.finditer(\n                \n                \n                \n                \n                \n                r\n    _TESTS = [{\n        'url': 'http://link.videoplatform.limelight.com/media/?channelListId=301b117890c4465c8179ede21fd92e2b',\n        'info_dict': {\n            'id': '301b117890c4465c8179ede21fd92e2b',\n            'title': 'Website - Hero Player',\n        },\n        'playlist_mincount': 2,\n    }, {\n        'url': 'https://assets.delvenetworks.com/player/loader.swf?channelListId=301b117890c4465c8179ede21fd92e2b',\n        'only_matching': True,\n    }]\n    _PLAYLIST_SERVICE_PATH = 'channel_list'\n\n    def _real_extract(self, url):\n        channel_list_id = self._match_id(url)\n\n        channel_list = self._call_playlist_service(channel_list_id, 'getMobileChannelListById')\n\n        entries = [\n            self.url_result('limelight:channel:%s' % channel['id'], 'LimelightChannel')\n            for channel in channel_list['channelList']]\n\n        return self.playlist_result(entries, channel_list_id, channel_list['title'])\n", "comments": "(?sx)\n                    <object[^>]+class=([\"\\'])(?:(?!\\1).)*\\bLimelightEmbeddedPlayerFlash\\b(?:(?!\\1).)*\\1[^>]*>.*?\n                        <param[^>]+\n                            name=([\"\\'])flashVars\\2[^>]+\n                            value=([\"\\'])(?:(?!\\3).)*(?P<kind>media|channel(?:List)?)Id=(?P<id>[a-z0-9]{32})\n                ''', webpage):\n            kind, video_id = mobj.group('kind'), mobj.group('id')\n            entries.append(cls.url_result(\n                smuggle('limelight:%s:%s' % (kind, video_id)),\n                'Limelight%s' % kind.capitalize(), video_id))\n        # http://support.3playmedia.com/hc/en-us/articles/115009517327-Limelight-Embedding-the-Audio-Description-Plugin-with-the-Limelight-Player-on-Your-Web-Page)\n        for video_id in re.findall(\n                r'(?s)LimelightPlayerUtil\\.embed\\s*\\(\\s*{.*?\\bmediaId[\"\\']\\s*:\\s*[\"\\'](?P<id>[a-z0-9]{32})',\n                webpage):\n            entries.append(cls.url_result(\n                smuggle('limelight:media:%s' % video_id),\n                LimelightMediaIE.ie_key(), video_id))\n        return entries\n\n    def _call_playlist_service(self, item_id, method, fatal=True, referer=None):\n        headers = {}\n        if referer:\n            headers['Referer'] = referer\n        try:\n            return self._download_json(\n                self._PLAYLIST_SERVICE_URL % (self._PLAYLIST_SERVICE_PATH, item_id, method),\n                item_id, 'Downloading PlaylistService %s JSON' % method, fatal=fatal, headers=headers)\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError) and e.cause.code == 403:\n                error = self._parse_json(e.cause.read().decode(), item_id)['detail']['contentAccessPermission']\n                if error == 'CountryDisabled':\n                    self.raise_geo_restricted()\n                raise ExtractorError(error, expected=True)\n            raise\n\n    def _call_api(self, organization_id, item_id, method):\n        return self._download_json(\n            self._API_URL % (organization_id, self._API_PATH, item_id, method),\n            item_id, 'Downloading API %s JSON' % method)\n\n    def _extract(self, item_id, pc_method, mobile_method, meta_method, referer=None):\n        pc = self._call_playlist_service(item_id, pc_method, referer=referer)\n        metadata = self._call_api(pc['orgId'], item_id, meta_method)\n        mobile = self._call_playlist_service(item_id, mobile_method, fatal=False, referer=referer)\n        return pc, mobile, metadata\n\n    def _extract_info(self, streams, mobile_urls, properties):\n        video_id = properties['media_id']\n        formats = []\n        urls = []\n        for stream in streams:\n            stream_url = stream.get('url')\n            if not stream_url or stream.get('drmProtected') or stream_url in urls:\n                continue\n            urls.append(stream_url)\n            ext = determine_ext(stream_url)\n            if ext == 'f4m':\n                formats.extend(self._extract_f4m_formats(\n                    stream_url, video_id, f4m_id='hds', fatal=False))\n            else:\n                fmt = {\n                    'url': stream_url,\n                    'abr': float_or_none(stream.get('audioBitRate')),\n                    'fps': float_or_none(stream.get('videoFrameRate')),\n                    'ext': ext,\n                }\n                width = int_or_none(stream.get('videoWidthInPixels'))\n                height = int_or_none(stream.get('videoHeightInPixels'))\n                vbr = float_or_none(stream.get('videoBitRate'))\n                if width or height or vbr:\n                    fmt.update({\n                        'width': width,\n                        'height': height,\n                        'vbr': vbr,\n                    })\n                else:\n                    fmt['vcodec'] = 'none'\n                rtmp = re.search(r'^(?P<url>rtmpe?://(?P<host>[^/]+)/(?P<app>.+))/(?P<playpath>mp[34]:.+)$', stream_url)\n                if rtmp:\n                    format_id = 'rtmp'\n                    if stream.get('videoBitRate'):\n                        format_id += '-%d' % int_or_none(stream['videoBitRate'])\n                    http_format_id = format_id.replace('rtmp', 'http')\n\n                    CDN_HOSTS = (\n                        ('delvenetworks.com', 'cpl.delvenetworks.com'),\n                        ('video.llnw.net', 's2.content.video.llnw.net'),\n                    )\n                    for cdn_host, http_host in CDN_HOSTS:\n                        if cdn_host not in rtmp.group('host').lower():\n                            continue\n                        http_url = 'http://%s/%s' % (http_host, rtmp.group('playpath')[4:])\n                        urls.append(http_url)\n                        if self._is_valid_url(http_url, video_id, http_format_id):\n                            http_fmt = fmt.copy()\n                            http_fmt.update({\n                                'url': http_url,\n                                'format_id': http_format_id,\n                            })\n                            formats.append(http_fmt)\n                            break\n\n                    fmt.update({\n                        'url': rtmp.group('url'),\n                        'play_path': rtmp.group('playpath'),\n                        'app': rtmp.group('app'),\n                        'ext': 'flv',\n                        'format_id': format_id,\n                    })\n                formats.append(fmt)\n\n        for mobile_url in mobile_urls:\n            media_url = mobile_url.get('mobileUrl')\n            format_id = mobile_url.get('targetMediaPlatform')\n            if not media_url or format_id in ('Widevine', 'SmoothStreaming') or media_url in urls:\n                continue\n            urls.append(media_url)\n            ext = determine_ext(media_url)\n            if ext == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    media_url, video_id, 'mp4', 'm3u8_native',\n                    m3u8_id=format_id, fatal=False))\n            elif ext == 'f4m':\n                formats.extend(self._extract_f4m_formats(\n                    stream_url, video_id, f4m_id=format_id, fatal=False))\n            else:\n                formats.append({\n                    'url': media_url,\n                    'format_id': format_id,\n                    'preference': -1,\n                    'ext': ext,\n                })\n\n        self._sort_formats(formats)\n\n        title = properties['title']\n        description = properties.get('description')\n        timestamp = int_or_none(properties.get('publish_date') or properties.get('create_date'))\n        duration = float_or_none(properties.get('duration_in_milliseconds'), 1000)\n        filesize = int_or_none(properties.get('total_storage_in_bytes'))\n        categories = [properties.get('category')]\n        tags = properties.get('tags', [])\n        thumbnails = [{\n            'url': thumbnail['url'],\n            'width': int_or_none(thumbnail.get('width')),\n            'height': int_or_none(thumbnail.get('height')),\n        } for thumbnail in properties.get('thumbnails', []) if thumbnail.get('url')]\n\n        subtitles = {}\n        for caption in properties.get('captions', []):\n            lang = caption.get('language_code')\n            subtitles_url = caption.get('url')\n            if lang and subtitles_url:\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitles_url,\n                })\n        closed_captions_url = properties.get('closed_captions_url')\n        if closed_captions_url:\n            subtitles.setdefault('en', []).append({\n                'url': closed_captions_url,\n                'ext': 'ttml',\n            })\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'formats': formats,\n            'timestamp': timestamp,\n            'duration': duration,\n            'filesize': filesize,\n            'categories': categories,\n            'tags': tags,\n            'thumbnails': thumbnails,\n            'subtitles': subtitles,\n        }\n\n    def _extract_info_helper(self, pc, mobile, i, metadata):\n        return self._extract_info(\n            try_get(pc, lambda x: x['playlistItems'][i]['streams'], list) or [],\n            try_get(mobile, lambda x: x['mediaList'][i]['mobileUrls'], list) or [],\n            metadata)\n\n\nclass LimelightMediaIE(LimelightBaseIE):\n    IE_NAME = 'limelight'\n    _VALID_URL = r'''(?x)\n                        (?:\n                            limelight:media:|\n                            https?://\n                                (?:\n                                    link\\.videoplatform\\.limelight\\.com/media/|\n                                    assets\\.delvenetworks\\.com/player/loader\\.swf\n                                )\n                                \\?.*?\\bmediaId=\n                        )\n                        (?P<id>[a-z0-9]{32})\n                    '''\n    _TESTS = [{\n        'url': 'http://link.videoplatform.limelight.com/media/?mediaId=3ffd040b522b4485b6d84effc750cd86',\n        'info_dict': {\n            'id': '3ffd040b522b4485b6d84effc750cd86',\n            'ext': 'mp4',\n            'title': 'HaP and the HB Prince Trailer',\n            'description': 'md5:8005b944181778e313d95c1237ddb640',\n            'thumbnail': r're:^https?://.*\\.jpeg$',\n            'duration': 144.23,\n            'timestamp': 1244136834,\n            'upload_date': '20090604',\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n    }, {\n        # video with subtitles\n        'url': 'limelight:media:a3e00274d4564ec4a9b29b9466432335',\n        'md5': '2fa3bad9ac321e23860ca23bc2c69e3d',\n        'info_dict': {\n            'id': 'a3e00274d4564ec4a9b29b9466432335',\n            'ext': 'mp4',\n            'title': '3Play Media Overview Video',\n            'thumbnail': r're:^https?://.*\\.jpeg$',\n            'duration': 78.101,\n            'timestamp': 1338929955,\n            'upload_date': '20120605',\n            'subtitles': 'mincount:9',\n        },\n    }, {\n        'url': 'https://assets.delvenetworks.com/player/loader.swf?mediaId=8018a574f08d416e95ceaccae4ba0452',\n        'only_matching': True,\n    }]\n    _PLAYLIST_SERVICE_PATH = 'media'\n    _API_PATH = 'media'\n\n    def _real_extract(self, url):\n        url, smuggled_data = unsmuggle_url(url, {})\n        video_id = self._match_id(url)\n        self._initialize_geo_bypass(smuggled_data.get('geo_countries'))\n\n        pc, mobile, metadata = self._extract(\n            video_id, 'getPlaylistByMediaId',\n            'getMobilePlaylistByMediaId', 'properties',\n            smuggled_data.get('source_url'))\n\n        return self._extract_info_helper(pc, mobile, 0, metadata)\n\n\nclass LimelightChannelIE(LimelightBaseIE):\n    IE_NAME = 'limelight:channel'\n    _VALID_URL = r'''(?x)\n                        (?:\n                            limelight:channel:|\n                            https?://\n                                (?:\n                                    link\\.videoplatform\\.limelight\\.com/media/|\n                                    assets\\.delvenetworks\\.com/player/loader\\.swf\n                                )\n                                \\?.*?\\bchannelId=\n                        )\n                        (?P<id>[a-z0-9]{32})\n                    '''\n    _TESTS = [{\n        'url': 'http://link.videoplatform.limelight.com/media/?channelId=ab6a524c379342f9b23642917020c082',\n        'info_dict': {\n            'id': 'ab6a524c379342f9b23642917020c082',\n            'title': 'Javascript Sample Code',\n        },\n        'playlist_mincount': 3,\n    }, {\n        'url': 'http://assets.delvenetworks.com/player/loader.swf?channelId=ab6a524c379342f9b23642917020c082',\n        'only_matching': True,\n    }]\n    _PLAYLIST_SERVICE_PATH = 'channel'\n    _API_PATH = 'channels'\n\n    def _real_extract(self, url):\n        url, smuggled_data = unsmuggle_url(url, {})\n        channel_id = self._match_id(url)\n\n        pc, mobile, medias = self._extract(\n            channel_id, 'getPlaylistByChannelId',\n            'getMobilePlaylistWithNItemsByChannelId?begin=0&count=-1',\n            'media', smuggled_data.get('source_url'))\n\n        entries = [\n            self._extract_info_helper(pc, mobile, i, medias['media_list'][i])\n            for i in range(len(medias['media_list']))]\n\n        return self.playlist_result(entries, channel_id, pc['title'])\n\n\nclass LimelightChannelListIE(LimelightBaseIE):\n    IE_NAME = 'limelight:channel_list'\n    _VALID_URL = r'''(?x)\n                        (?:\n                            limelight:channel_list:|\n                            https?://\n                                (?:\n                                    link\\.videoplatform\\.limelight\\.com/media/|\n                                    assets\\.delvenetworks\\.com/player/loader\\.swf\n                                )\n                                \\?.*?\\bchannelListId=\n                        )\n                        (?P<id>[a-z0-9]{32})\n                    \n \n# coding: utf-8\n# As per [1] class attribute should be exactly equal to\n# LimelightEmbeddedPlayerFlash but numerous examples seen\n# that don't exactly match it (e.g. [2]).\n# 1. http://support.3playmedia.com/hc/en-us/articles/227732408-Limelight-Embedding-the-Captions-Plugin-with-the-Limelight-Player-on-Your-Webpage\n# 2. http://www.sedona.com/FacilitatorTraining2017\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_HTTPError\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    smuggle_url,\n    try_get,\n    unsmuggle_url,\n    ExtractorError,\n)\n\n\nclass LimelightBaseIE(InfoExtractor):\n    _PLAYLIST_SERVICE_URL = 'http://production-ps.lvp.llnw.net/r/PlaylistService/%s/%s/%s'\n    _API_URL = 'http://api.video.limelight.com/rest/organizations/%s/%s/%s/%s.json'\n\n    @classmethod\n    def _extract_urls(cls, webpage, source_url):\n        lm = {\n            'Media': 'media',\n            'Channel': 'channel',\n            'ChannelList': 'channel_list',\n        }\n\n        def smuggle(url):\n            return smuggle_url(url, {'source_url': source_url})\n\n        entries = []\n        for kind, video_id in re.findall(\n                r'LimelightPlayer\\.doLoad(Media|Channel|ChannelList)\\([\"\\'](?P<id>[a-z0-9]{32})',\n                webpage):\n            entries.append(cls.url_result(\n                smuggle('limelight:%s:%s' % (lm[kind], video_id)),\n                'Limelight%s' % kind, video_id))\n        for mobj in re.finditer(\n                # As per [1] class attribute should be exactly equal to\n                # LimelightEmbeddedPlayerFlash but numerous examples seen\n                # that don't exactly match it (e.g. [2]).\n                # 1. http://support.3playmedia.com/hc/en-us/articles/227732408-Limelight-Embedding-the-Captions-Plugin-with-the-Limelight-Player-on-Your-Webpage\n                # 2. http://www.sedona.com/FacilitatorTraining2017\n                r'''(?sx)\n                    <object[^>]+class=([\"\\'])(?:(?!\\1).)*\\bLimelightEmbeddedPlayerFlash\\b(?:(?!\\1).)*\\1[^>]*>.*?\n                        <param[^>]+\n                            name=([\"\\'])flashVars\\2[^>]+\n                            value=([\"\\'])(?:(?!\\3).)*(?P<kind>media|channel(?:List)?)Id=(?P<id>[a-z0-9]{32})\n                ''', webpage):\n            kind, video_id = mobj.group('kind'), mobj.group('id')\n            entries.append(cls.url_result(\n                smuggle('limelight:%s:%s' % (kind, video_id)),\n                'Limelight%s' % kind.capitalize(), video_id))\n        # http://support.3playmedia.com/hc/en-us/articles/115009517327-Limelight-Embedding-the-Audio-Description-Plugin-with-the-Limelight-Player-on-Your-Web-Page)\n        for video_id in re.findall(\n                r'(?s)LimelightPlayerUtil\\.embed\\s*\\(\\s*{.*?\\bmediaId[\"\\']\\s*:\\s*[\"\\'](?P<id>[a-z0-9]{32})',\n                webpage):\n            entries.append(cls.url_result(\n                smuggle('limelight:media:%s' % video_id),\n                LimelightMediaIE.ie_key(), video_id))\n        return entries\n\n    def _call_playlist_service(self, item_id, method, fatal=True, referer=None):\n        headers = {}\n        if referer:\n            headers['Referer'] = referer\n        try:\n            return self._download_json(\n                self._PLAYLIST_SERVICE_URL % (self._PLAYLIST_SERVICE_PATH, item_id, method),\n                item_id, 'Downloading PlaylistService %s JSON' % method, fatal=fatal, headers=headers)\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError) and e.cause.code == 403:\n                error = self._parse_json(e.cause.read().decode(), item_id)['detail']['contentAccessPermission']\n                if error == 'CountryDisabled':\n                    self.raise_geo_restricted()\n                raise ExtractorError(error, expected=True)\n            raise\n\n    def _call_api(self, organization_id, item_id, method):\n        return self._download_json(\n            self._API_URL % (organization_id, self._API_PATH, item_id, method),\n            item_id, 'Downloading API %s JSON' % method)\n\n    def _extract(self, item_id, pc_method, mobile_method, meta_method, referer=None):\n        pc = self._call_playlist_service(item_id, pc_method, referer=referer)\n        metadata = self._call_api(pc['orgId'], item_id, meta_method)\n        mobile = self._call_playlist_service(item_id, mobile_method, fatal=False, referer=referer)\n        return pc, mobile, metadata\n\n    def _extract_info(self, streams, mobile_urls, properties):\n        video_id = properties['media_id']\n        formats = []\n        urls = []\n        for stream in streams:\n            stream_url = stream.get('url')\n            if not stream_url or stream.get('drmProtected') or stream_url in urls:\n                continue\n            urls.append(stream_url)\n            ext = determine_ext(stream_url)\n            if ext == 'f4m':\n                formats.extend(self._extract_f4m_formats(\n                    stream_url, video_id, f4m_id='hds', fatal=False))\n            else:\n                fmt = {\n                    'url': stream_url,\n                    'abr': float_or_none(stream.get('audioBitRate')),\n                    'fps': float_or_none(stream.get('videoFrameRate')),\n                    'ext': ext,\n                }\n                width = int_or_none(stream.get('videoWidthInPixels'))\n                height = int_or_none(stream.get('videoHeightInPixels'))\n                vbr = float_or_none(stream.get('videoBitRate'))\n                if width or height or vbr:\n                    fmt.update({\n                        'width': width,\n                        'height': height,\n                        'vbr': vbr,\n                    })\n                else:\n                    fmt['vcodec'] = 'none'\n                rtmp = re.search(r'^(?P<url>rtmpe?://(?P<host>[^/]+)/(?P<app>.+))/(?P<playpath>mp[34]:.+)$', stream_url)\n                if rtmp:\n                    format_id = 'rtmp'\n                    if stream.get('videoBitRate'):\n                        format_id += '-%d' % int_or_none(stream['videoBitRate'])\n                    http_format_id = format_id.replace('rtmp', 'http')\n\n                    CDN_HOSTS = (\n                        ('delvenetworks.com', 'cpl.delvenetworks.com'),\n                        ('video.llnw.net', 's2.content.video.llnw.net'),\n                    )\n                    for cdn_host, http_host in CDN_HOSTS:\n                        if cdn_host not in rtmp.group('host').lower():\n                            continue\n                        http_url = 'http://%s/%s' % (http_host, rtmp.group('playpath')[4:])\n                        urls.append(http_url)\n                        if self._is_valid_url(http_url, video_id, http_format_id):\n                            http_fmt = fmt.copy()\n                            http_fmt.update({\n                                'url': http_url,\n                                'format_id': http_format_id,\n                            })\n                            formats.append(http_fmt)\n                            break\n\n                    fmt.update({\n                        'url': rtmp.group('url'),\n                        'play_path': rtmp.group('playpath'),\n                        'app': rtmp.group('app'),\n                        'ext': 'flv',\n                        'format_id': format_id,\n                    })\n                formats.append(fmt)\n\n        for mobile_url in mobile_urls:\n            media_url = mobile_url.get('mobileUrl')\n            format_id = mobile_url.get('targetMediaPlatform')\n            if not media_url or format_id in ('Widevine', 'SmoothStreaming') or media_url in urls:\n                continue\n            urls.append(media_url)\n            ext = determine_ext(media_url)\n            if ext == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    media_url, video_id, 'mp4', 'm3u8_native',\n                    m3u8_id=format_id, fatal=False))\n            elif ext == 'f4m':\n                formats.extend(self._extract_f4m_formats(\n                    stream_url, video_id, f4m_id=format_id, fatal=False))\n            else:\n                formats.append({\n                    'url': media_url,\n                    'format_id': format_id,\n                    'preference': -1,\n                    'ext': ext,\n                })\n\n        self._sort_formats(formats)\n\n        title = properties['title']\n        description = properties.get('description')\n        timestamp = int_or_none(properties.get('publish_date') or properties.get('create_date'))\n        duration = float_or_none(properties.get('duration_in_milliseconds'), 1000)\n        filesize = int_or_none(properties.get('total_storage_in_bytes'))\n        categories = [properties.get('category')]\n        tags = properties.get('tags', [])\n        thumbnails = [{\n            'url': thumbnail['url'],\n            'width': int_or_none(thumbnail.get('width')),\n            'height': int_or_none(thumbnail.get('height')),\n        } for thumbnail in properties.get('thumbnails', []) if thumbnail.get('url')]\n\n        subtitles = {}\n        for caption in properties.get('captions', []):\n            lang = caption.get('language_code')\n            subtitles_url = caption.get('url')\n            if lang and subtitles_url:\n                subtitles.setdefault(lang, []).append({\n                    'url': subtitles_url,\n                })\n        closed_captions_url = properties.get('closed_captions_url')\n        if closed_captions_url:\n            subtitles.setdefault('en', []).append({\n                'url': closed_captions_url,\n                'ext': 'ttml',\n            })\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'formats': formats,\n            'timestamp': timestamp,\n            'duration': duration,\n            'filesize': filesize,\n            'categories': categories,\n            'tags': tags,\n            'thumbnails': thumbnails,\n            'subtitles': subtitles,\n        }\n\n    def _extract_info_helper(self, pc, mobile, i, metadata):\n        return self._extract_info(\n            try_get(pc, lambda x: x['playlistItems'][i]['streams'], list) or [],\n            try_get(mobile, lambda x: x['mediaList'][i]['mobileUrls'], list) or [],\n            metadata)\n\n\nclass LimelightMediaIE(LimelightBaseIE):\n    IE_NAME = 'limelight'\n    _VALID_URL = r'''(?x)\n                        (?:\n                            limelight:media:|\n                            https?://\n                                (?:\n                                    link\\.videoplatform\\.limelight\\.com/media/|\n                                    assets\\.delvenetworks\\.com/player/loader\\.swf\n                                )\n                                \\?.*?\\bmediaId=\n                        )\n                        (?P<id>[a-z0-9]{32})\n                    '''\n    _TESTS = [{\n        'url': 'http://link.videoplatform.limelight.com/media/?mediaId=3ffd040b522b4485b6d84effc750cd86',\n        'info_dict': {\n            'id': '3ffd040b522b4485b6d84effc750cd86',\n            'ext': 'mp4',\n            'title': 'HaP and the HB Prince Trailer',\n            'description': 'md5:8005b944181778e313d95c1237ddb640',\n            'thumbnail': r're:^https?://.*\\.jpeg$',\n            'duration': 144.23,\n            'timestamp': 1244136834,\n            'upload_date': '20090604',\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n    }, {\n        # video with subtitles\n        'url': 'limelight:media:a3e00274d4564ec4a9b29b9466432335',\n        'md5': '2fa3bad9ac321e23860ca23bc2c69e3d',\n        'info_dict': {\n            'id': 'a3e00274d4564ec4a9b29b9466432335',\n            'ext': 'mp4',\n            'title': '3Play Media Overview Video',\n            'thumbnail': r're:^https?://.*\\.jpeg$',\n            'duration': 78.101,\n            'timestamp': 1338929955,\n            'upload_date': '20120605',\n            'subtitles': 'mincount:9',\n        },\n    }, {\n        'url': 'https://assets.delvenetworks.com/player/loader.swf?mediaId=8018a574f08d416e95ceaccae4ba0452',\n        'only_matching': True,\n    }]\n    _PLAYLIST_SERVICE_PATH = 'media'\n    _API_PATH = 'media'\n\n    def _real_extract(self, url):\n        url, smuggled_data = unsmuggle_url(url, {})\n        video_id = self._match_id(url)\n        self._initialize_geo_bypass(smuggled_data.get('geo_countries'))\n\n        pc, mobile, metadata = self._extract(\n            video_id, 'getPlaylistByMediaId',\n            'getMobilePlaylistByMediaId', 'properties',\n            smuggled_data.get('source_url'))\n\n        return self._extract_info_helper(pc, mobile, 0, metadata)\n\n\nclass LimelightChannelIE(LimelightBaseIE):\n    IE_NAME = 'limelight:channel'\n    _VALID_URL = r'''(?x)\n                        (?:\n                            limelight:channel:|\n                            https?://\n                                (?:\n                                    link\\.videoplatform\\.limelight\\.com/media/|\n                                    assets\\.delvenetworks\\.com/player/loader\\.swf\n                                )\n                                \\?.*?\\bchannelId=\n                        )\n                        (?P<id>[a-z0-9]{32})\n                    '''\n    _TESTS = [{\n        'url': 'http://link.videoplatform.limelight.com/media/?channelId=ab6a524c379342f9b23642917020c082',\n        'info_dict': {\n            'id': 'ab6a524c379342f9b23642917020c082',\n            'title': 'Javascript Sample Code',\n        },\n        'playlist_mincount': 3,\n    }, {\n        'url': 'http://assets.delvenetworks.com/player/loader.swf?channelId=ab6a524c379342f9b23642917020c082',\n        'only_matching': True,\n    }]\n    _PLAYLIST_SERVICE_PATH = 'channel'\n    _API_PATH = 'channels'\n\n    def _real_extract(self, url):\n        url, smuggled_data = unsmuggle_url(url, {})\n        channel_id = self._match_id(url)\n\n        pc, mobile, medias = self._extract(\n            channel_id, 'getPlaylistByChannelId',\n            'getMobilePlaylistWithNItemsByChannelId?begin=0&count=-1',\n            'media', smuggled_data.get('source_url'))\n\n        entries = [\n            self._extract_info_helper(pc, mobile, i, medias['media_list'][i])\n            for i in range(len(medias['media_list']))]\n\n        return self.playlist_result(entries, channel_id, pc['title'])\n\n\nclass LimelightChannelListIE(LimelightBaseIE):\n    IE_NAME = 'limelight:channel_list'\n    _VALID_URL = r'''(?x)\n                        (?:\n                            limelight:channel_list:|\n                            https?://\n                                (?:\n                                    link\\.videoplatform\\.limelight\\.com/media/|\n                                    assets\\.delvenetworks\\.com/player/loader\\.swf\n                                )\n                                \\?.*?\\bchannelListId=\n                        )\n                        (?P<id>[a-z0-9]{32})\n                    '''\n    _TESTS = [{\n        'url': 'http://link.videoplatform.limelight.com/media/?channelListId=301b117890c4465c8179ede21fd92e2b',\n        'info_dict': {\n            'id': '301b117890c4465c8179ede21fd92e2b',\n            'title': 'Website - Hero Player',\n        },\n        'playlist_mincount': 2,\n    }, {\n        'url': 'https://assets.delvenetworks.com/player/loader.swf?channelListId=301b117890c4465c8179ede21fd92e2b',\n        'only_matching': True,\n    }]\n    _PLAYLIST_SERVICE_PATH = 'channel_list'\n\n    def _real_extract(self, url):\n        channel_list_id = self._match_id(url)\n\n        channel_list = self._call_playlist_service(channel_list_id, 'getMobileChannelListById')\n\n        entries = [\n            self.url_result('limelight:channel:%s' % channel['id'], 'LimelightChannel')\n            for channel in channel_list['channelList']]\n\n        return self.playlist_result(entries, channel_list_id, channel_list['title'])\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "limelight.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/limelight.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}