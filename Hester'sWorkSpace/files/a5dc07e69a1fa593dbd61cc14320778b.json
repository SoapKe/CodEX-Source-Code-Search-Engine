{"author": "keon", "code": " Minimum spanning tree (MST) is going to use an undirected graph\n\n The disjoint set is represented with an list <n> of integers where \n <n[i]> is the parent of the node at position <i>.\n If <n[i]> = <i>, <i> it's a root, or a head, of a set\n\n\nclass Edge:\n    def __init__(self, u, v, weight):\n        self.u = u\n        self.v = v\n        self.weight = weight\n\n\nclass DisjointSet:\n    def __init__(self, n):\n         Args:\n           n (int): Number of vertices in the graph\n\n        self.parent = [None] * n  Contains wich node is the parent of the node at poisition <i>\n        self.size = [1] * n  Contains size of node at index <i>, used to optimize merge\n        for i in range(n):\n            self.parent[i] = i  Make all nodes his own parent, creating n sets.\n\n    def mergeSet(self, a, b):\n         Args:\n           a, b (int): Indexes of nodes whose sets will be merged.\n\n         Get the set of nodes at position <a> and <b>\n         If <a> and <b> are the roots, this will be constant O(1)\n        a = self.findSet(a)\n        b = self.findSet(b)\n\n         Join the shortest node to the longest, minimizing tree size (faster find)\n        if self.size[a] < self.size[b]:\n            self.parent[a] = b  Merge set(a) and set(b)\n            self.size[b] += self.size[a]  Add size of old set(a) to set(b)\n        else:\n            self.parent[b] = a  Merge set(b) and set(a)\n            self.size[a] += self.size[b]  Add size of old set(b) to set(a)\n\n    def findSet(self, a):\n        if self.parent[a] != a: \n             Very important, memoize result of the \n             recursion in the list to optimize next\n             calls and make this operation practically constant, O(1)\n            self.parent[a] = self.findSet(self.parent[a])\n\n         node <a> it's the set root, so we can return that index\n        return self.parent[a]\n\n\ndef kruskal(n, edges, ds):\n     Args:\n       n (int): Number of vertices in the graph\n       edges (list of Edge): Edges of the graph\n       ds (DisjointSet): DisjointSet of the vertices\n     Returns:\n       int: sum of weights of the minnimum spanning tree \n    \n     Kruskal algorithm:\n       This algorithm will find the optimal graph with less edges and less\n       total weight to connect all vertices (MST), the MST will always contain\n       n-1 edges because it's the minimum required to connect n vertices.\n    \n     Procedure:\n       Sort the edges (criteria: less weight).\n       Only take edges of nodes in different sets.\n       If we take a edge, we need to merge the sets to discard these.\n       After repeat this until select n-1 edges, we will have the complete MST.\n    edges.sort(key=lambda edge: edge.weight)\n\n    mst = []  List of edges taken, minimum spanning tree\n\n    for edge in edges:\n        set_u = ds.findSet(edge.u)  Set of the node <u>\n        set_v = ds.findSet(edge.v)  Set of the node <v>\n        if set_u != set_v:\n            ds.mergeSet(set_u, set_v)\n            mst.append(edge)\n            if len(mst) == n-1: \n                 If we have selected n-1 edges, all the other \n                 edges will be discarted, so, we can stop here\n                break\n\n    return sum([edge.weight for edge in mst])\n\n\n\n\nif __name__ == \"__main__\":\n     Test. How input works:\n     Input consists of different weighted, connected, undirected graphs. \n     line 1: \n       integers n, m\n     lines 2..m+2:\n       edge with the format -> node index u, node index v, integer weight\n    \n     Samples of input:\n    \n     5 6\n     1 2 3\n     1 3 8\n     2 4 5\n     3 4 2\n     3 5 4\n     4 5 6\n     \n     3 3\n     2 1 20\n     3 1 20\n     2 3 100\n    \n     Sum of weights of the optimal paths:\n     14, 40\n    import sys\n    for n_m in sys.stdin:\n        n, m = map(int, n_m.split())\n        ds = DisjointSet(m)\n        edges = [None] * m  Create list of size <m>\n\n         Read <m> edges from input\n        for i in range(m):\n            u, v, weight = map(int, input().split())\n            u -= 1  Convert from 1-indexed to 0-indexed\n            v -= 1  Convert from 1-indexed to 0-indexed\n            edges[i] = Edge(u, v, weight)\n\n         After finish input and graph creation, use Kruskal algorithm for MST:\n        print(\"MST weights sum:\", kruskal(n, edges, ds))", "comments": "  minimum spanning tree (mst) going use undirected graph       the disjoint set represented list  n  integers      n   parent node position       if  n          root  head  set    args       n (int)  number vertices graph    contains wich node parent node poisition      contains size node index    used optimize merge    make nodes parent  creating n sets     args        b (int)  indexes nodes whose sets merged     get set nodes position    b     if    b  roots  constant o(1)    join shortest node longest  minimizing tree size (faster find)    merge set(a) set(b)    add size old set(a) set(b)    merge set(b) set(a)    add size old set(b) set(a)    very important  memoize result     recursion list optimize next    calls make operation practically constant  o(1)    node   set root  return index    args       n (int)  number vertices graph      edges (list edge)  edges graph      ds (disjointset)  disjointset vertices    returns       int  sum weights minnimum spanning tree        kruskal algorithm       this algorithm find optimal graph less edges less      total weight connect vertices (mst)  mst always contain      n 1 edges minimum required connect n vertices        procedure       sort edges (criteria  less weight)       only take edges nodes different sets       if take edge  need merge sets discard       after repeat select n 1 edges  complete mst     list edges taken  minimum spanning tree    set node  u     set node  v     if selected n 1 edges      edges discarted   stop    test  how input works     input consists different weighted  connected  undirected graphs      line 1        integers n     lines 2  2       edge format    node index u  node index v  integer weight       samples input        5 6    1 2 3    1 3 8    2 4 5    3 4 2    3 5 4    4 5 6        3 3    2 1 20    3 1 20    2 3 100       sum weights optimal paths     14  40    create list size      read   edges input    convert 1 indexed 0 indexed    convert 1 indexed 0 indexed    after finish input graph creation  use kruskal algorithm mst  ", "content": "# Minimum spanning tree (MST) is going to use an undirected graph\n#\n# The disjoint set is represented with an list <n> of integers where \n# <n[i]> is the parent of the node at position <i>.\n# If <n[i]> = <i>, <i> it's a root, or a head, of a set\n\n\nclass Edge:\n    def __init__(self, u, v, weight):\n        self.u = u\n        self.v = v\n        self.weight = weight\n\n\nclass DisjointSet:\n    def __init__(self, n):\n        # Args:\n        #   n (int): Number of vertices in the graph\n\n        self.parent = [None] * n # Contains wich node is the parent of the node at poisition <i>\n        self.size = [1] * n # Contains size of node at index <i>, used to optimize merge\n        for i in range(n):\n            self.parent[i] = i # Make all nodes his own parent, creating n sets.\n\n    def mergeSet(self, a, b):\n        # Args:\n        #   a, b (int): Indexes of nodes whose sets will be merged.\n\n        # Get the set of nodes at position <a> and <b>\n        # If <a> and <b> are the roots, this will be constant O(1)\n        a = self.findSet(a)\n        b = self.findSet(b)\n\n        # Join the shortest node to the longest, minimizing tree size (faster find)\n        if self.size[a] < self.size[b]:\n            self.parent[a] = b # Merge set(a) and set(b)\n            self.size[b] += self.size[a] # Add size of old set(a) to set(b)\n        else:\n            self.parent[b] = a # Merge set(b) and set(a)\n            self.size[a] += self.size[b] # Add size of old set(b) to set(a)\n\n    def findSet(self, a):\n        if self.parent[a] != a: \n            # Very important, memoize result of the \n            # recursion in the list to optimize next\n            # calls and make this operation practically constant, O(1)\n            self.parent[a] = self.findSet(self.parent[a])\n\n        # node <a> it's the set root, so we can return that index\n        return self.parent[a]\n\n\ndef kruskal(n, edges, ds):\n    # Args:\n    #   n (int): Number of vertices in the graph\n    #   edges (list of Edge): Edges of the graph\n    #   ds (DisjointSet): DisjointSet of the vertices\n    # Returns:\n    #   int: sum of weights of the minnimum spanning tree \n    #\n    # Kruskal algorithm:\n    #   This algorithm will find the optimal graph with less edges and less\n    #   total weight to connect all vertices (MST), the MST will always contain\n    #   n-1 edges because it's the minimum required to connect n vertices.\n    #\n    # Procedure:\n    #   Sort the edges (criteria: less weight).\n    #   Only take edges of nodes in different sets.\n    #   If we take a edge, we need to merge the sets to discard these.\n    #   After repeat this until select n-1 edges, we will have the complete MST.\n    edges.sort(key=lambda edge: edge.weight)\n\n    mst = [] # List of edges taken, minimum spanning tree\n\n    for edge in edges:\n        set_u = ds.findSet(edge.u) # Set of the node <u>\n        set_v = ds.findSet(edge.v) # Set of the node <v>\n        if set_u != set_v:\n            ds.mergeSet(set_u, set_v)\n            mst.append(edge)\n            if len(mst) == n-1: \n                # If we have selected n-1 edges, all the other \n                # edges will be discarted, so, we can stop here\n                break\n\n    return sum([edge.weight for edge in mst])\n\n\n\n\nif __name__ == \"__main__\":\n    # Test. How input works:\n    # Input consists of different weighted, connected, undirected graphs. \n    # line 1: \n    #   integers n, m\n    # lines 2..m+2:\n    #   edge with the format -> node index u, node index v, integer weight\n    #\n    # Samples of input:\n    #\n    # 5 6\n    # 1 2 3\n    # 1 3 8\n    # 2 4 5\n    # 3 4 2\n    # 3 5 4\n    # 4 5 6\n    # \n    # 3 3\n    # 2 1 20\n    # 3 1 20\n    # 2 3 100\n    #\n    # Sum of weights of the optimal paths:\n    # 14, 40\n    import sys\n    for n_m in sys.stdin:\n        n, m = map(int, n_m.split())\n        ds = DisjointSet(m)\n        edges = [None] * m # Create list of size <m>\n\n        # Read <m> edges from input\n        for i in range(m):\n            u, v, weight = map(int, input().split())\n            u -= 1 # Convert from 1-indexed to 0-indexed\n            v -= 1 # Convert from 1-indexed to 0-indexed\n            edges[i] = Edge(u, v, weight)\n\n        # After finish input and graph creation, use Kruskal algorithm for MST:\n        print(\"MST weights sum:\", kruskal(n, edges, ds))", "description": "Minimal examples of data structures and algorithms in Python", "file_name": "minimum_spanning_tree.py", "id": "a5dc07e69a1fa593dbd61cc14320778b", "language": "Python", "project_name": "algorithms", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/keon-algorithms/keon-algorithms-ea43887/graph/minimum_spanning_tree.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:53:29Z", "url": "https://github.com/keon/algorithms", "wiki": true}