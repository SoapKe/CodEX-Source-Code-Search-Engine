{"author": "USArmyResearchLab", "code": "import dshell\nimport dpkt\nimport socket\nfrom dnsdecoder import DNSDecoder\nimport IPy\n\n\nclass DshellDecoder(DNSDecoder):\n\n    def __init__(self):\n        DNSDecoder.__init__(self,\n                            name='reservedips',\n                            description='identify DNS resolutions that fall into reserved ip space',\n                            filter='(port 53)',\n                            author='bg',\n                            cleanupinterval=10,\n                            maxblobs=2,\n                            )\n\n        \n        nets = ['0.0.0.0/8',  # Used for broadcast messages to the current (\"this\") network as specified by RFC 1700, page 4.\n                \n                \n                '10.0.0.0/8',\n                \n                \n                \n                '100.64.0.0/10',\n                \n                \n                '127.0.0.0/8',\n                \n                \n                '169.254.0.0/16',\n                \n                \n                '172.16.0.0/12',\n                \n                \n                '192.0.0.0/29',\n                \n                \n                \n                '192.0.2.0/24',\n                \n                '192.88.99.0/24',\n                \n                \n                '192.168.0.0/16',\n                \n                \n                '198.18.0.0/15',\n                \n                \n                \n                '198.51.100.0/24',\n                \n                \n                \n                '203.0.113.0/24',\n                \n                '224.0.0.0/4',\n                \n                '240.0.0.0/4',\n                \n                \n                '255.255.255.255/32',\n\n                '::/128',  \n                '::1/128',  \n                '::ffff:0:0/96',  \n                '100::/64',  \n                '64:ff9b::/96',  # IPv4/IPv6 translation (RFC 6052)\n                '2001::/32',  \n                # Overlay Routable Cryptographic Hash Identifiers (ORCHID)\n                '2001:10::/28',\n                '2001:db8::/32',  \n                '2002::/16',  \n                'fc00::/7',  \n                'fe80::/10',  \n                'ff00::/8',  \n                ]\n\n        self.reservednets = []\n        for net in nets:\n            self.reservednets.append(IPy.IP(net))\n        self.domains = []       \n\n    def inReservedSpace(self, ipaddress):\n        for net in self.reservednets:\n            if ipaddress in net:\n                return True\n        return False\n\n    def decode_q(self, dns):\n        queried = \"\"\n        if dns.qd[0].type == dpkt.dns.DNS_A:\n            queried = queried + \"A? %s\" % (dns.qd[0].name)\n        if dns.qd[0].type == dpkt.dns.DNS_AAAA:\n            queried = queried + \"AAAA? %s\" % (dns.qd[0].name)\n        return queried\n\n    def DNSHandler(self, conn, request, response, **kwargs):\n        anstext = ''\n        queried = ''\n        id = None\n        for dns in request, response:\n            if dns is None:\n                continue\n            id = dns.id\n            \n            if dns.qr == dpkt.dns.DNS_Q:\n                conn.info(query=self.decode_q(dns))\n\n            \n            elif (dns.qr == dpkt.dns.DNS_A and dns.rcode == dpkt.dns.DNS_RCODE_NOERR and len(dns.an) > 0):\n\n                queried = self.decode_q(dns)\n\n                answers = []\n                for an in dns.an:\n                    if an.type == dpkt.dns.DNS_A:\n                        try:\n                            if self.inReservedSpace(socket.inet_ntoa(an.ip)):\n                                answers.append(\n                                    'A: ' + socket.inet_ntoa(an.ip) + ' (ttl ' + str(an.ttl) + 's)')\n                        except:\n                            continue\n                    elif an.type == dpkt.dns.DNS_AAAA:\n                        try:\n                            if self.inReservedSpace(socket.inet_ntop(socket.AF_INET6, an.ip6)):\n                                answers.append(\n                                    'AAAA: ' + socket.inet_ntop(socket.AF_INET6, an.ip6) + ' (ttl ' + str(an.ttl) + 's)')\n                        except:\n                            continue\n                    else:\n                        \n                        continue\n                if queried != '':\n                    anstext = \", \".join(answers)\n\n        if anstext:  ?\n            self.alert(\n                str(id) + ' ' + queried + ' / ' + anstext, **conn.info(response=anstext))\n\n\nif __name__ == '__main__':\n    dObj = DshellDecoder()\n    print dObj\nelse:\n    dObj = DshellDecoder()\n", "comments": "  source  https   en wikipedia org wiki reserved ip addresses    used broadcast messages current ( ) network specified rfc 1700  page 4     used local communications within private network    specified rfc 1918     used communications service provider    subscribers using carrier grade nat  specified    rfc 6598     used loopback addresses local host  specified    rfc 990     used autoconfiguration two hosts single    link ip address otherwise specified    used local communications within private network    specified rfc 1918    used ds lite transition mechanism specified    rfc 6333    assigned  test net  rfc 5737 use solely    documentation example source code used    publicly    used 6to4 anycast relays specified rfc 3068    used local communications within private network    specified rfc 1918    used testing inter network communications two    separate subnets specified rfc 2544    assigned  test net 2  rfc 5737 use solely    documentation example source code used    publicly    assigned  test net 3  rfc 5737 use solely    documentation example source code used    publicly    reserved multicast assignments specified rfc 5771    reserved future use  specified rfc 6890    reserved  limited broadcast  destination address     specified rfc 6890    unspecified address    loopback address local host     ipv4 mapped addresses    discard prefix rfc 6666    ipv4 ipv6 translation (rfc 6052)    teredo tunneling    overlay routable cryptographic hash identifiers (orchid)    addresses used documentation    6to4    unique local address    link local address    multicast    list known domains    dns question  update connection info query    dns answer data errors    un handled type    get answer  ", "content": "import dshell\nimport dpkt\nimport socket\nfrom dnsdecoder import DNSDecoder\nimport IPy\n\n\nclass DshellDecoder(DNSDecoder):\n\n    def __init__(self):\n        DNSDecoder.__init__(self,\n                            name='reservedips',\n                            description='identify DNS resolutions that fall into reserved ip space',\n                            filter='(port 53)',\n                            author='bg',\n                            cleanupinterval=10,\n                            maxblobs=2,\n                            )\n\n        # source: https://en.wikipedia.org/wiki/Reserved_IP_addresses\n        nets = ['0.0.0.0/8',  # Used for broadcast messages to the current (\"this\") network as specified by RFC 1700, page 4.\n                # Used for local communications within a private network as\n                # specified by RFC 1918.\n                '10.0.0.0/8',\n                # Used for communications between a service provider and its\n                # subscribers when using a Carrier-grade NAT, as specified by\n                # RFC 6598.\n                '100.64.0.0/10',\n                # Used for loopback addresses to the local host, as specified\n                # by RFC 990.\n                '127.0.0.0/8',\n                # Used for autoconfiguration between two hosts on a single\n                # link when no IP address is otherwise specified\n                '169.254.0.0/16',\n                # Used for local communications within a private network as\n                # specified by RFC 1918\n                '172.16.0.0/12',\n                # Used for the DS-Lite transition mechanism as specified by\n                # RFC 6333\n                '192.0.0.0/29',\n                # Assigned as \"TEST-NET\" in RFC 5737 for use solely in\n                # documentation and example source code and should not be used\n                # publicly\n                '192.0.2.0/24',\n                # Used by 6to4 anycast relays as specified by RFC 3068\n                '192.88.99.0/24',\n                # Used for local communications within a private network as\n                # specified by RFC 1918\n                '192.168.0.0/16',\n                # Used for testing of inter-network communications between two\n                # separate subnets as specified in RFC 2544\n                '198.18.0.0/15',\n                # Assigned as \"TEST-NET-2\" in RFC 5737 for use solely in\n                # documentation and example source code and should not be used\n                # publicly\n                '198.51.100.0/24',\n                # Assigned as \"TEST-NET-3\" in RFC 5737 for use solely in\n                # documentation and example source code and should not be used\n                # publicly\n                '203.0.113.0/24',\n                # Reserved for multicast assignments as specified in RFC 5771\n                '224.0.0.0/4',\n                # Reserved for future use, as specified by RFC 6890\n                '240.0.0.0/4',\n                # Reserved for the \"limited broadcast\" destination address, as\n                # specified by RFC 6890\n                '255.255.255.255/32',\n\n                '::/128',  # Unspecified address\n                '::1/128',  # loopback address to the local host.\n                '::ffff:0:0/96',  # IPv4 mapped addresses\n                '100::/64',  # Discard Prefix RFC 6666\n                '64:ff9b::/96',  # IPv4/IPv6 translation (RFC 6052)\n                '2001::/32',  # Teredo tunneling\n                # Overlay Routable Cryptographic Hash Identifiers (ORCHID)\n                '2001:10::/28',\n                '2001:db8::/32',  # Addresses used in documentation\n                '2002::/16',  # 6to4\n                'fc00::/7',  # Unique local address\n                'fe80::/10',  # Link-local address\n                'ff00::/8',  # Multicast\n                ]\n\n        self.reservednets = []\n        for net in nets:\n            self.reservednets.append(IPy.IP(net))\n        self.domains = []       # list for known domains\n\n    def inReservedSpace(self, ipaddress):\n        for net in self.reservednets:\n            if ipaddress in net:\n                return True\n        return False\n\n    def decode_q(self, dns):\n        queried = \"\"\n        if dns.qd[0].type == dpkt.dns.DNS_A:\n            queried = queried + \"A? %s\" % (dns.qd[0].name)\n        if dns.qd[0].type == dpkt.dns.DNS_AAAA:\n            queried = queried + \"AAAA? %s\" % (dns.qd[0].name)\n        return queried\n\n    def DNSHandler(self, conn, request, response, **kwargs):\n        anstext = ''\n        queried = ''\n        id = None\n        for dns in request, response:\n            if dns is None:\n                continue\n            id = dns.id\n            # DNS Question, update connection info with query\n            if dns.qr == dpkt.dns.DNS_Q:\n                conn.info(query=self.decode_q(dns))\n\n            # DNS Answer with data and no errors\n            elif (dns.qr == dpkt.dns.DNS_A and dns.rcode == dpkt.dns.DNS_RCODE_NOERR and len(dns.an) > 0):\n\n                queried = self.decode_q(dns)\n\n                answers = []\n                for an in dns.an:\n                    if an.type == dpkt.dns.DNS_A:\n                        try:\n                            if self.inReservedSpace(socket.inet_ntoa(an.ip)):\n                                answers.append(\n                                    'A: ' + socket.inet_ntoa(an.ip) + ' (ttl ' + str(an.ttl) + 's)')\n                        except:\n                            continue\n                    elif an.type == dpkt.dns.DNS_AAAA:\n                        try:\n                            if self.inReservedSpace(socket.inet_ntop(socket.AF_INET6, an.ip6)):\n                                answers.append(\n                                    'AAAA: ' + socket.inet_ntop(socket.AF_INET6, an.ip6) + ' (ttl ' + str(an.ttl) + 's)')\n                        except:\n                            continue\n                    else:\n                        # un-handled type\n                        continue\n                if queried != '':\n                    anstext = \", \".join(answers)\n\n        if anstext:  # did we get an answer?\n            self.alert(\n                str(id) + ' ' + queried + ' / ' + anstext, **conn.info(response=anstext))\n\n\nif __name__ == '__main__':\n    dObj = DshellDecoder()\n    print dObj\nelse:\n    dObj = DshellDecoder()\n", "description": "Dshell is a network forensic analysis framework.", "file_name": "reservedips.py", "id": "5898a1c75af7d32b1530ea6a0888aa9d", "language": "Python", "project_name": "Dshell", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/USArmyResearchLab-Dshell/USArmyResearchLab-Dshell-5850adf/decoders/dns/reservedips.py", "save_time": "", "source": "", "update_at": "2018-03-18T10:01:29Z", "url": "https://github.com/USArmyResearchLab/Dshell", "wiki": true}