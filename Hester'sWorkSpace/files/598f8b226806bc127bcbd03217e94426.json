{"author": "powerline", "code": "\n\n\n\n\nfrom __future__ import (unicode_literals, division, absolute_import, print_function)\n\nimport sys\nimport json\nimport argparse\n\nfrom itertools import groupby\n\nfrom colormath.color_objects import sRGBColor, LabColor\nfrom colormath.color_conversions import convert_color\nfrom colormath.color_diff import delta_e_cie2000\n\nfrom powerline.colorscheme import cterm_to_hex\n\n\ndef num2(s):\n\ttry:\n\t\treturn (True, [int(v) for v in s.partition(' ')[::2]])\n\texcept TypeError:\n\t\treturn (False, [float(v) for v in s.partition(' ')[::2]])\n\n\ndef rgbint_to_lab(rgbint):\n\trgb = sRGBColor(\n\t\t(rgbint >> 16) & 0xFF, (rgbint >> 8) & 0xFF, rgbint & 0xFF,\n\t\tis_upscaled=True\n\t)\n\treturn convert_color(rgb, LabColor)\n\n\ncterm_to_lab = tuple((rgbint_to_lab(v) for v in cterm_to_hex))\n\n\ndef color(s):\n\tif len(s) <= 3:\n\t\treturn cterm_to_lab[int(s)]\n\telse:\n\t\treturn rgbint_to_lab(int(s, 16))\n\n\ndef nums(s):\n\treturn [int(i) for i in s.split()]\n\n\ndef linear_gradient(start_value, stop_value, start_offset, stop_offset, offset):\n\treturn start_value + ((offset - start_offset) * (stop_value - start_value) / (stop_offset - start_offset))\n\n\ndef lab_gradient(slab, elab, soff, eoff, off):\n\tsvals = slab.get_value_tuple()\n\tevals = elab.get_value_tuple()\n\treturn LabColor(*[\n\t\tlinear_gradient(start_value, end_value, soff, eoff, off)\n\t\tfor start_value, end_value in zip(svals, evals)\n\t])\n\n\ndef generate_gradient_function(DATA):\n\tdef gradient_function(y):\n\t\tinitial_offset = 0\n\t\tfor offset, start, end in DATA:\n\t\t\tif y <= offset:\n\t\t\t\treturn lab_gradient(start, end, initial_offset, offset, y)\n\t\t\tinitial_offset = offset\n\treturn gradient_function\n\n\ndef get_upscaled_values(rgb):\n\treturn [min(max(0, i), 255) for i in rgb.get_upscaled_value_tuple()]\n\n\ndef get_rgb(lab):\n\trgb = convert_color(lab, sRGBColor)\n\trgb = sRGBColor(*get_upscaled_values(rgb), is_upscaled=True)\n\treturn rgb.get_rgb_hex()[1:]\n\n\ndef find_color(ulab, colors, ctrans):\n\tcur_distance = float('inf')\n\tcur_color = None\n\ti = 0\n\tfor clab in colors:\n\t\tdist = delta_e_cie2000(ulab, clab)\n\t\tif dist < cur_distance:\n\t\t\tcur_distance = dist\n\t\t\tcur_color = (ctrans(i), clab)\n\t\ti += 1\n\treturn cur_color\n\n\ndef print_color(color):\n\tif type(color) is int:\n\t\tcolstr = '5;' + str(color)\n\telse:\n\t\trgb = convert_color(color, sRGBColor)\n\t\tcolstr = '2;' + ';'.join((str(i) for i in get_upscaled_values(rgb)))\n\tsys.stdout.write('\\033[48;' + colstr + 'm ')\n\n\ndef print_colors(colors, num):\n\tfor i in range(num):\n\t\tcolor = colors[int(round(i * (len(colors) - 1) / num))]\n\t\tprint_color(color)\n\tsys.stdout.write('\\033[0m\\n')\n\n\ndef dec_scale_generator(num):\n\tj = 0\n\tr = ''\n\twhile num:\n\t\tr += '\\033[{0}m'.format(j % 2)\n\t\tfor i in range(10):\n\t\t\tr += str(i)\n\t\t\tnum -= 1\n\t\t\tif not num:\n\t\t\t\tbreak\n\t\tj += 1\n\tr += '\\033[0m\\n'\n\treturn r\n\n\ndef compute_steps(gradient, weights):\n\tmaxweight = len(gradient) - 1\n\tif weights:\n\t\tweight_sum = sum(weights)\n\t\tnorm_weights = [100.0 * weight / weight_sum for weight in weights]\n\t\tsteps = [0]\n\t\tfor weight in norm_weights:\n\t\t\tsteps.append(steps[-1] + weight)\n\t\tsteps.pop(0)\n\t\tsteps.pop(0)\n\telse:\n\t\tstep = m / maxweight\n\t\tsteps = [i * step for i in range(1, maxweight + 1)]\n\treturn steps\n\n\npalettes = {\n\t'16': (cterm_to_lab[:16], lambda c: c),\n\t'256': (cterm_to_lab, lambda c: c),\n\tNone: (cterm_to_lab[16:], lambda c: c + 16),\n}\n\n\ndef show_scale(rng, num_output):\n\tif not rng and num_output >= 32 and (num_output - 1) // 10 >= 4 and (num_output - 1) % 10 == 0:\n\t\tsys.stdout.write('0')\n\t\tsys.stdout.write(''.join(('%*u' % (num_output // 10, i) for i in range(10, 101, 10))))\n\t\tsys.stdout.write('\\n')\n\telse:\n\t\tif rng:\n\t\t\tvmin, vmax = rng[1]\n\t\t\tisint = rng[0]\n\t\telse:\n\t\t\tisint = True\n\t\t\tvmin = 0\n\t\t\tvmax = 100\n\t\ts = ''\n\t\tlasts = ' ' + str(vmax)\n\t\twhile len(s) + len(lasts) < num_output:\n\t\t\tcurpc = len(s) + 1 if s else 0\n\t\t\tcurval = vmin + curpc * (vmax - vmin) / num_output\n\t\t\tif isint:\n\t\t\t\tcurval = int(round(curval))\n\t\t\ts += str(curval) + ' '\n\t\tsys.stdout.write(s[:-1] + lasts + '\\n')\n\tsys.stdout.write(dec_scale_generator(num_output) + '\\n')\n\n\nif __name__ == '__main__':\n\tp = argparse.ArgumentParser(description=__doc__)\n\tp.add_argument('gradient', nargs='*', metavar='COLOR', type=color, help='List of colors (either indexes from 8-bit palette or 24-bit RGB in hexadecimal notation)')\n\tp.add_argument('-n', '--num_items', metavar='INT', type=int, help='Number of items in resulting list', default=101)\n\tp.add_argument('-N', '--num_output', metavar='INT', type=int, help='Number of characters in sample', default=101)\n\tp.add_argument('-r', '--range', metavar='V1 V2', type=num2, help='Use this range when outputting scale')\n\tp.add_argument('-s', '--show', action='store_true', help='If present output gradient sample')\n\tp.add_argument('-p', '--palette', choices=('16', '256'), help='Use this palette. Defaults to 240-color palette (256 colors without first 16)')\n\tp.add_argument('-w', '--weights', metavar='INT INT ...', type=nums, help='Adjust weights of colors. Number of weights must be equal to number of colors')\n\tp.add_argument('-C', '--omit-terminal', action='store_true', help='If present do not compute values for terminal')\n\n\targs = p.parse_args()\n\n\tm = args.num_items\n\n\tsteps = compute_steps(args.gradient, args.weights)\n\n\tdata = [\n\t\t(weight, args.gradient[i - 1], args.gradient[i])\n\t\tfor weight, i in zip(steps, range(1, len(args.gradient)))\n\t]\n\tgr_func = generate_gradient_function(data)\n\tgradient = [gr_func(y) for y in range(0, m)]\n\n\tr = [get_rgb(lab) for lab in gradient]\n\tif not args.omit_terminal:\n\t\tr2 = [find_color(lab, *palettes[args.palette])[0] for lab in gradient]\n\t\tr3 = [i[0] for i in groupby(r2)]\n\n\tif not args.omit_terminal:\n\t\tprint(json.dumps(r3) + ',')\n\t\tprint(json.dumps(r2) + ',')\n\tprint(json.dumps(r))\n\n\tif args.show:\n\t\tprint_colors(args.gradient, args.num_output)\n\t\tif not args.omit_terminal:\n\t\t\tprint_colors(r3, args.num_output)\n\t\t\tprint_colors(r2, args.num_output)\n\t\tprint_colors(gradient, args.num_output)\n\n\t\tshow_scale(args.range, args.num_output)\n", "comments": "   gradients generator         usr bin env python    vim fileencoding utf 8 noet ", "content": "#!/usr/bin/env python\n# vim:fileencoding=utf-8:noet\n\n'''Gradients generator\n'''\n\nfrom __future__ import (unicode_literals, division, absolute_import, print_function)\n\nimport sys\nimport json\nimport argparse\n\nfrom itertools import groupby\n\nfrom colormath.color_objects import sRGBColor, LabColor\nfrom colormath.color_conversions import convert_color\nfrom colormath.color_diff import delta_e_cie2000\n\nfrom powerline.colorscheme import cterm_to_hex\n\n\ndef num2(s):\n\ttry:\n\t\treturn (True, [int(v) for v in s.partition(' ')[::2]])\n\texcept TypeError:\n\t\treturn (False, [float(v) for v in s.partition(' ')[::2]])\n\n\ndef rgbint_to_lab(rgbint):\n\trgb = sRGBColor(\n\t\t(rgbint >> 16) & 0xFF, (rgbint >> 8) & 0xFF, rgbint & 0xFF,\n\t\tis_upscaled=True\n\t)\n\treturn convert_color(rgb, LabColor)\n\n\ncterm_to_lab = tuple((rgbint_to_lab(v) for v in cterm_to_hex))\n\n\ndef color(s):\n\tif len(s) <= 3:\n\t\treturn cterm_to_lab[int(s)]\n\telse:\n\t\treturn rgbint_to_lab(int(s, 16))\n\n\ndef nums(s):\n\treturn [int(i) for i in s.split()]\n\n\ndef linear_gradient(start_value, stop_value, start_offset, stop_offset, offset):\n\treturn start_value + ((offset - start_offset) * (stop_value - start_value) / (stop_offset - start_offset))\n\n\ndef lab_gradient(slab, elab, soff, eoff, off):\n\tsvals = slab.get_value_tuple()\n\tevals = elab.get_value_tuple()\n\treturn LabColor(*[\n\t\tlinear_gradient(start_value, end_value, soff, eoff, off)\n\t\tfor start_value, end_value in zip(svals, evals)\n\t])\n\n\ndef generate_gradient_function(DATA):\n\tdef gradient_function(y):\n\t\tinitial_offset = 0\n\t\tfor offset, start, end in DATA:\n\t\t\tif y <= offset:\n\t\t\t\treturn lab_gradient(start, end, initial_offset, offset, y)\n\t\t\tinitial_offset = offset\n\treturn gradient_function\n\n\ndef get_upscaled_values(rgb):\n\treturn [min(max(0, i), 255) for i in rgb.get_upscaled_value_tuple()]\n\n\ndef get_rgb(lab):\n\trgb = convert_color(lab, sRGBColor)\n\trgb = sRGBColor(*get_upscaled_values(rgb), is_upscaled=True)\n\treturn rgb.get_rgb_hex()[1:]\n\n\ndef find_color(ulab, colors, ctrans):\n\tcur_distance = float('inf')\n\tcur_color = None\n\ti = 0\n\tfor clab in colors:\n\t\tdist = delta_e_cie2000(ulab, clab)\n\t\tif dist < cur_distance:\n\t\t\tcur_distance = dist\n\t\t\tcur_color = (ctrans(i), clab)\n\t\ti += 1\n\treturn cur_color\n\n\ndef print_color(color):\n\tif type(color) is int:\n\t\tcolstr = '5;' + str(color)\n\telse:\n\t\trgb = convert_color(color, sRGBColor)\n\t\tcolstr = '2;' + ';'.join((str(i) for i in get_upscaled_values(rgb)))\n\tsys.stdout.write('\\033[48;' + colstr + 'm ')\n\n\ndef print_colors(colors, num):\n\tfor i in range(num):\n\t\tcolor = colors[int(round(i * (len(colors) - 1) / num))]\n\t\tprint_color(color)\n\tsys.stdout.write('\\033[0m\\n')\n\n\ndef dec_scale_generator(num):\n\tj = 0\n\tr = ''\n\twhile num:\n\t\tr += '\\033[{0}m'.format(j % 2)\n\t\tfor i in range(10):\n\t\t\tr += str(i)\n\t\t\tnum -= 1\n\t\t\tif not num:\n\t\t\t\tbreak\n\t\tj += 1\n\tr += '\\033[0m\\n'\n\treturn r\n\n\ndef compute_steps(gradient, weights):\n\tmaxweight = len(gradient) - 1\n\tif weights:\n\t\tweight_sum = sum(weights)\n\t\tnorm_weights = [100.0 * weight / weight_sum for weight in weights]\n\t\tsteps = [0]\n\t\tfor weight in norm_weights:\n\t\t\tsteps.append(steps[-1] + weight)\n\t\tsteps.pop(0)\n\t\tsteps.pop(0)\n\telse:\n\t\tstep = m / maxweight\n\t\tsteps = [i * step for i in range(1, maxweight + 1)]\n\treturn steps\n\n\npalettes = {\n\t'16': (cterm_to_lab[:16], lambda c: c),\n\t'256': (cterm_to_lab, lambda c: c),\n\tNone: (cterm_to_lab[16:], lambda c: c + 16),\n}\n\n\ndef show_scale(rng, num_output):\n\tif not rng and num_output >= 32 and (num_output - 1) // 10 >= 4 and (num_output - 1) % 10 == 0:\n\t\tsys.stdout.write('0')\n\t\tsys.stdout.write(''.join(('%*u' % (num_output // 10, i) for i in range(10, 101, 10))))\n\t\tsys.stdout.write('\\n')\n\telse:\n\t\tif rng:\n\t\t\tvmin, vmax = rng[1]\n\t\t\tisint = rng[0]\n\t\telse:\n\t\t\tisint = True\n\t\t\tvmin = 0\n\t\t\tvmax = 100\n\t\ts = ''\n\t\tlasts = ' ' + str(vmax)\n\t\twhile len(s) + len(lasts) < num_output:\n\t\t\tcurpc = len(s) + 1 if s else 0\n\t\t\tcurval = vmin + curpc * (vmax - vmin) / num_output\n\t\t\tif isint:\n\t\t\t\tcurval = int(round(curval))\n\t\t\ts += str(curval) + ' '\n\t\tsys.stdout.write(s[:-1] + lasts + '\\n')\n\tsys.stdout.write(dec_scale_generator(num_output) + '\\n')\n\n\nif __name__ == '__main__':\n\tp = argparse.ArgumentParser(description=__doc__)\n\tp.add_argument('gradient', nargs='*', metavar='COLOR', type=color, help='List of colors (either indexes from 8-bit palette or 24-bit RGB in hexadecimal notation)')\n\tp.add_argument('-n', '--num_items', metavar='INT', type=int, help='Number of items in resulting list', default=101)\n\tp.add_argument('-N', '--num_output', metavar='INT', type=int, help='Number of characters in sample', default=101)\n\tp.add_argument('-r', '--range', metavar='V1 V2', type=num2, help='Use this range when outputting scale')\n\tp.add_argument('-s', '--show', action='store_true', help='If present output gradient sample')\n\tp.add_argument('-p', '--palette', choices=('16', '256'), help='Use this palette. Defaults to 240-color palette (256 colors without first 16)')\n\tp.add_argument('-w', '--weights', metavar='INT INT ...', type=nums, help='Adjust weights of colors. Number of weights must be equal to number of colors')\n\tp.add_argument('-C', '--omit-terminal', action='store_true', help='If present do not compute values for terminal')\n\n\targs = p.parse_args()\n\n\tm = args.num_items\n\n\tsteps = compute_steps(args.gradient, args.weights)\n\n\tdata = [\n\t\t(weight, args.gradient[i - 1], args.gradient[i])\n\t\tfor weight, i in zip(steps, range(1, len(args.gradient)))\n\t]\n\tgr_func = generate_gradient_function(data)\n\tgradient = [gr_func(y) for y in range(0, m)]\n\n\tr = [get_rgb(lab) for lab in gradient]\n\tif not args.omit_terminal:\n\t\tr2 = [find_color(lab, *palettes[args.palette])[0] for lab in gradient]\n\t\tr3 = [i[0] for i in groupby(r2)]\n\n\tif not args.omit_terminal:\n\t\tprint(json.dumps(r3) + ',')\n\t\tprint(json.dumps(r2) + ',')\n\tprint(json.dumps(r))\n\n\tif args.show:\n\t\tprint_colors(args.gradient, args.num_output)\n\t\tif not args.omit_terminal:\n\t\t\tprint_colors(r3, args.num_output)\n\t\t\tprint_colors(r2, args.num_output)\n\t\tprint_colors(gradient, args.num_output)\n\n\t\tshow_scale(args.range, args.num_output)\n", "description": "Powerline is a statusline plugin for vim, and provides statuslines and prompts for several other applications, including zsh, bash, tmux, IPython, Awesome and Qtile.", "file_name": "generate_gradients.py", "id": "598f8b226806bc127bcbd03217e94426", "language": "Python", "project_name": "powerline", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/powerline-powerline/powerline-powerline-d36850f/tools/generate_gradients.py", "save_time": "", "source": "", "update_at": "2018-03-18T09:00:33Z", "url": "https://github.com/powerline/powerline", "wiki": false}