{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport json\nimport re\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    determine_ext,\n    ExtractorError,\n    int_or_none,\n    parse_duration,\n    parse_iso8601,\n    xpath_element,\n    xpath_text,\n)\n\n\nclass BRIE(InfoExtractor):\n    IE_DESC = 'Bayerischer Rundfunk'\n    _VALID_URL = r'(?P<base_url>https?://(?:www\\.)?br(?:-klassik)?\\.de)/(?:[a-z0-9\\-_]+/)+(?P<id>[a-z0-9\\-_]+)\\.html'\n\n    _TESTS = [\n        {\n            'url': 'http://www.br.de/mediathek/video/sendungen/abendschau/betriebliche-altersvorsorge-104.html',\n            'md5': '83a0477cf0b8451027eb566d88b51106',\n            'info_dict': {\n                'id': '48f656ef-287e-486f-be86-459122db22cc',\n                'ext': 'mp4',\n                'title': 'Die b\u00f6se \u00dcberraschung',\n                'description': 'md5:ce9ac81b466ce775b8018f6801b48ac9',\n                'duration': 180,\n                'uploader': 'Reinhard Weber',\n                'upload_date': '20150422',\n            },\n            'skip': '404 not found',\n        },\n        {\n            'url': 'http://www.br.de/nachrichten/oberbayern/inhalt/muenchner-polizeipraesident-schreiber-gestorben-100.html',\n            'md5': 'af3a3a4aa43ff0ce6a89504c67f427ef',\n            'info_dict': {\n                'id': 'a4b83e34-123d-4b81-9f4e-c0d3121a4e05',\n                'ext': 'flv',\n                'title': 'Manfred Schreiber ist tot',\n                'description': 'md5:b454d867f2a9fc524ebe88c3f5092d97',\n                'duration': 26,\n            },\n            'skip': '404 not found',\n        },\n        {\n            'url': 'https://www.br-klassik.de/audio/peeping-tom-premierenkritik-dance-festival-muenchen-100.html',\n            'md5': '8b5b27c0b090f3b35eac4ab3f7a73d3d',\n            'info_dict': {\n                'id': '74c603c9-26d3-48bb-b85b-079aeed66e0b',\n                'ext': 'aac',\n                'title': 'Kurzweilig und sehr bewegend',\n                'description': 'md5:0351996e3283d64adeb38ede91fac54e',\n                'duration': 296,\n            },\n            'skip': '404 not found',\n        },\n        {\n            'url': 'http://www.br.de/radio/bayern1/service/team/videos/team-video-erdelt100.html',\n            'md5': 'dbab0aef2e047060ea7a21fc1ce1078a',\n            'info_dict': {\n                'id': '6ba73750-d405-45d3-861d-1ce8c524e059',\n                'ext': 'mp4',\n                'title': 'Umweltbewusster H\u00e4uslebauer',\n                'description': 'md5:d52dae9792d00226348c1dbb13c9bae2',\n                'duration': 116,\n            }\n        },\n        {\n            'url': 'http://www.br.de/fernsehen/br-alpha/sendungen/kant-fuer-anfaenger/kritik-der-reinen-vernunft/kant-kritik-01-metaphysik100.html',\n            'md5': '23bca295f1650d698f94fc570977dae3',\n            'info_dict': {\n                'id': 'd982c9ce-8648-4753-b358-98abb8aec43d',\n                'ext': 'mp4',\n                'title': 'Folge 1 - Metaphysik',\n                'description': 'md5:bb659990e9e59905c3d41e369db1fbe3',\n                'duration': 893,\n                'uploader': 'Eva Maria Steimle',\n                'upload_date': '20170208',\n            }\n        },\n    ]\n\n    def _real_extract(self, url):\n        base_url, display_id = re.search(self._VALID_URL, url).groups()\n        page = self._download_webpage(url, display_id)\n        xml_url = self._search_regex(\n            r\"return BRavFramework\\.register\\(BRavFramework\\('avPlayer_(?:[a-f0-9-]{36})'\\)\\.setup\\({dataURL:'(/(?:[a-z0-9\\-]+/)+[a-z0-9/~_.-]+)'}\\)\\);\", page, 'XMLURL')\n        xml = self._download_xml(base_url + xml_url, display_id)\n\n        medias = []\n\n        for xml_media in xml.findall('video') + xml.findall('audio'):\n            media_id = xml_media.get('externalId')\n            media = {\n                'id': media_id,\n                'title': xpath_text(xml_media, 'title', 'title', True),\n                'duration': parse_duration(xpath_text(xml_media, 'duration')),\n                'formats': self._extract_formats(xpath_element(\n                    xml_media, 'assets'), media_id),\n                'thumbnails': self._extract_thumbnails(xpath_element(\n                    xml_media, 'teaserImage/variants'), base_url),\n                'description': xpath_text(xml_media, 'desc'),\n                'webpage_url': xpath_text(xml_media, 'permalink'),\n                'uploader': xpath_text(xml_media, 'author'),\n            }\n            broadcast_date = xpath_text(xml_media, 'broadcastDate')\n            if broadcast_date:\n                media['upload_date'] = ''.join(reversed(broadcast_date.split('.')))\n            medias.append(media)\n\n        if len(medias) > 1:\n            self._downloader.report_warning(\n                'found multiple medias; please '\n                'report this with the video URL to http://yt-dl.org/bug')\n        if not medias:\n            raise ExtractorError('No media entries found')\n        return medias[0]\n\n    def _extract_formats(self, assets, media_id):\n        formats = []\n        for asset in assets.findall('asset'):\n            format_url = xpath_text(asset, ['downloadUrl', 'url'])\n            asset_type = asset.get('type')\n            if asset_type.startswith('HDS'):\n                formats.extend(self._extract_f4m_formats(\n                    format_url + '?hdcore=3.2.0', media_id, f4m_id='hds', fatal=False))\n            elif asset_type.startswith('HLS'):\n                formats.extend(self._extract_m3u8_formats(\n                    format_url, media_id, 'mp4', 'm3u8_native', m3u8_id='hds', fatal=False))\n            else:\n                format_info = {\n                    'ext': xpath_text(asset, 'mediaType'),\n                    'width': int_or_none(xpath_text(asset, 'frameWidth')),\n                    'height': int_or_none(xpath_text(asset, 'frameHeight')),\n                    'tbr': int_or_none(xpath_text(asset, 'bitrateVideo')),\n                    'abr': int_or_none(xpath_text(asset, 'bitrateAudio')),\n                    'vcodec': xpath_text(asset, 'codecVideo'),\n                    'acodec': xpath_text(asset, 'codecAudio'),\n                    'container': xpath_text(asset, 'mediaType'),\n                    'filesize': int_or_none(xpath_text(asset, 'size')),\n                }\n                format_url = self._proto_relative_url(format_url)\n                if format_url:\n                    http_format_info = format_info.copy()\n                    http_format_info.update({\n                        'url': format_url,\n                        'format_id': 'http-%s' % asset_type,\n                    })\n                    formats.append(http_format_info)\n                server_prefix = xpath_text(asset, 'serverPrefix')\n                if server_prefix:\n                    rtmp_format_info = format_info.copy()\n                    rtmp_format_info.update({\n                        'url': server_prefix,\n                        'play_path': xpath_text(asset, 'fileName'),\n                        'format_id': 'rtmp-%s' % asset_type,\n                    })\n                    formats.append(rtmp_format_info)\n        self._sort_formats(formats)\n        return formats\n\n    def _extract_thumbnails(self, variants, base_url):\n        thumbnails = [{\n            'url': base_url + xpath_text(variant, 'url'),\n            'width': int_or_none(xpath_text(variant, 'width')),\n            'height': int_or_none(xpath_text(variant, 'height')),\n        } for variant in variants.findall('variant') if xpath_text(variant, 'url')]\n        thumbnails.sort(key=lambda x: x['width'] * x['height'], reverse=True)\n        return thumbnails\n\n\nclass BRMediathekIE(InfoExtractor):\n    IE_DESC = 'Bayerischer Rundfunk Mediathek'\n    _VALID_URL = r'https?://(?:www\\.)?br\\.de/mediathek/video/[^/?&\n\n    _TESTS = [{\n        'url': 'https://www.br.de/mediathek/video/gesundheit-die-sendung-vom-28112017-av:5a1e6a6e8fce6d001871cc8e',\n        'md5': 'fdc3d485835966d1622587d08ba632ec',\n        'info_dict': {\n            'id': 'av:5a1e6a6e8fce6d001871cc8e',\n            'ext': 'mp4',\n            'title': 'Die Sendung vom 28.11.2017',\n            'description': 'md5:6000cdca5912ab2277e5b7339f201ccc',\n            'timestamp': 1511942766,\n            'upload_date': '20171129',\n        }\n    }]\n\n    def _real_extract(self, url):\n        clip_id = self._match_id(url)\n\n        clip = self._download_json(\n            'https://proxy-base.master.mango.express/graphql',\n            clip_id, data=json.dumps({\n                \"query\":  % clip_id}).encode(), headers={\n                'Content-Type': 'application/json',\n            })['data']['viewer']['clip']\n        title = clip['title']\n\n        formats = []\n        for edge in clip.get('videoFiles', {}).get('edges', []):\n            node = edge.get('node', {})\n            n_url = node.get('publicLocation')\n            if not n_url:\n                continue\n            ext = determine_ext(n_url)\n            if ext == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    n_url, clip_id, 'mp4', 'm3u8_native',\n                    m3u8_id='hls', fatal=False))\n            else:\n                video_profile = node.get('videoProfile', {})\n                tbr = int_or_none(video_profile.get('bitrate'))\n                format_id = 'http'\n                if tbr:\n                    format_id += '-%d' % tbr\n                formats.append({\n                    'format_id': format_id,\n                    'url': n_url,\n                    'width': int_or_none(video_profile.get('width')),\n                    'height': int_or_none(video_profile.get('height')),\n                    'tbr': tbr,\n                    'filesize': int_or_none(node.get('fileSize')),\n                })\n        self._sort_formats(formats)\n\n        subtitles = {}\n        for edge in clip.get('captionFiles', {}).get('edges', []):\n            node = edge.get('node', {})\n            n_url = node.get('publicLocation')\n            if not n_url:\n                continue\n            subtitles.setdefault('de', []).append({\n                'url': n_url,\n            })\n\n        thumbnails = []\n        for edge in clip.get('teaserImages', {}).get('edges', []):\n            for image_edge in edge.get('node', {}).get('imageFiles', {}).get('edges', []):\n                node = image_edge.get('node', {})\n                n_url = node.get('publicLocation')\n                if not n_url:\n                    continue\n                thumbnails.append({\n                    'url': n_url,\n                    'width': int_or_none(node.get('width')),\n                    'height': int_or_none(node.get('height')),\n                })\n\n        return {\n            'id': clip_id,\n            'title': title,\n            'description': clip.get('description'),\n            'duration': int_or_none(clip.get('duration')),\n            'timestamp': parse_iso8601(clip.get('createdAt')),\n            'age_limit': int_or_none(clip.get('ageRestriction')),\n            'formats': formats,\n            'subtitles': subtitles,\n            'thumbnails': thumbnails,\n        }\n", "comments": "{\n  viewer {\n    clip(id: \"%s\") {\n      title\n      description\n      duration\n      createdAt\n      ageRestriction\n      videoFiles {\n        edges {\n          node {\n            publicLocation\n            fileSize\n            videoProfile {\n              width\n              height\n              bitrate\n              encoding\n            }\n          }\n        }\n      }\n      captionFiles {\n        edges {\n          node {\n            publicLocation\n          }\n        }\n      }\n      teaserImages {\n        edges {\n          node {\n            imageFiles {\n              edges {\n                node {\n                  publicLocation\n                  width\n                  height\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n}\n# coding: utf-8\n#]*?-(?P<id>av:[0-9a-f]{24})'\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport json\nimport re\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    determine_ext,\n    ExtractorError,\n    int_or_none,\n    parse_duration,\n    parse_iso8601,\n    xpath_element,\n    xpath_text,\n)\n\n\nclass BRIE(InfoExtractor):\n    IE_DESC = 'Bayerischer Rundfunk'\n    _VALID_URL = r'(?P<base_url>https?://(?:www\\.)?br(?:-klassik)?\\.de)/(?:[a-z0-9\\-_]+/)+(?P<id>[a-z0-9\\-_]+)\\.html'\n\n    _TESTS = [\n        {\n            'url': 'http://www.br.de/mediathek/video/sendungen/abendschau/betriebliche-altersvorsorge-104.html',\n            'md5': '83a0477cf0b8451027eb566d88b51106',\n            'info_dict': {\n                'id': '48f656ef-287e-486f-be86-459122db22cc',\n                'ext': 'mp4',\n                'title': 'Die b\u00f6se \u00dcberraschung',\n                'description': 'md5:ce9ac81b466ce775b8018f6801b48ac9',\n                'duration': 180,\n                'uploader': 'Reinhard Weber',\n                'upload_date': '20150422',\n            },\n            'skip': '404 not found',\n        },\n        {\n            'url': 'http://www.br.de/nachrichten/oberbayern/inhalt/muenchner-polizeipraesident-schreiber-gestorben-100.html',\n            'md5': 'af3a3a4aa43ff0ce6a89504c67f427ef',\n            'info_dict': {\n                'id': 'a4b83e34-123d-4b81-9f4e-c0d3121a4e05',\n                'ext': 'flv',\n                'title': 'Manfred Schreiber ist tot',\n                'description': 'md5:b454d867f2a9fc524ebe88c3f5092d97',\n                'duration': 26,\n            },\n            'skip': '404 not found',\n        },\n        {\n            'url': 'https://www.br-klassik.de/audio/peeping-tom-premierenkritik-dance-festival-muenchen-100.html',\n            'md5': '8b5b27c0b090f3b35eac4ab3f7a73d3d',\n            'info_dict': {\n                'id': '74c603c9-26d3-48bb-b85b-079aeed66e0b',\n                'ext': 'aac',\n                'title': 'Kurzweilig und sehr bewegend',\n                'description': 'md5:0351996e3283d64adeb38ede91fac54e',\n                'duration': 296,\n            },\n            'skip': '404 not found',\n        },\n        {\n            'url': 'http://www.br.de/radio/bayern1/service/team/videos/team-video-erdelt100.html',\n            'md5': 'dbab0aef2e047060ea7a21fc1ce1078a',\n            'info_dict': {\n                'id': '6ba73750-d405-45d3-861d-1ce8c524e059',\n                'ext': 'mp4',\n                'title': 'Umweltbewusster H\u00e4uslebauer',\n                'description': 'md5:d52dae9792d00226348c1dbb13c9bae2',\n                'duration': 116,\n            }\n        },\n        {\n            'url': 'http://www.br.de/fernsehen/br-alpha/sendungen/kant-fuer-anfaenger/kritik-der-reinen-vernunft/kant-kritik-01-metaphysik100.html',\n            'md5': '23bca295f1650d698f94fc570977dae3',\n            'info_dict': {\n                'id': 'd982c9ce-8648-4753-b358-98abb8aec43d',\n                'ext': 'mp4',\n                'title': 'Folge 1 - Metaphysik',\n                'description': 'md5:bb659990e9e59905c3d41e369db1fbe3',\n                'duration': 893,\n                'uploader': 'Eva Maria Steimle',\n                'upload_date': '20170208',\n            }\n        },\n    ]\n\n    def _real_extract(self, url):\n        base_url, display_id = re.search(self._VALID_URL, url).groups()\n        page = self._download_webpage(url, display_id)\n        xml_url = self._search_regex(\n            r\"return BRavFramework\\.register\\(BRavFramework\\('avPlayer_(?:[a-f0-9-]{36})'\\)\\.setup\\({dataURL:'(/(?:[a-z0-9\\-]+/)+[a-z0-9/~_.-]+)'}\\)\\);\", page, 'XMLURL')\n        xml = self._download_xml(base_url + xml_url, display_id)\n\n        medias = []\n\n        for xml_media in xml.findall('video') + xml.findall('audio'):\n            media_id = xml_media.get('externalId')\n            media = {\n                'id': media_id,\n                'title': xpath_text(xml_media, 'title', 'title', True),\n                'duration': parse_duration(xpath_text(xml_media, 'duration')),\n                'formats': self._extract_formats(xpath_element(\n                    xml_media, 'assets'), media_id),\n                'thumbnails': self._extract_thumbnails(xpath_element(\n                    xml_media, 'teaserImage/variants'), base_url),\n                'description': xpath_text(xml_media, 'desc'),\n                'webpage_url': xpath_text(xml_media, 'permalink'),\n                'uploader': xpath_text(xml_media, 'author'),\n            }\n            broadcast_date = xpath_text(xml_media, 'broadcastDate')\n            if broadcast_date:\n                media['upload_date'] = ''.join(reversed(broadcast_date.split('.')))\n            medias.append(media)\n\n        if len(medias) > 1:\n            self._downloader.report_warning(\n                'found multiple medias; please '\n                'report this with the video URL to http://yt-dl.org/bug')\n        if not medias:\n            raise ExtractorError('No media entries found')\n        return medias[0]\n\n    def _extract_formats(self, assets, media_id):\n        formats = []\n        for asset in assets.findall('asset'):\n            format_url = xpath_text(asset, ['downloadUrl', 'url'])\n            asset_type = asset.get('type')\n            if asset_type.startswith('HDS'):\n                formats.extend(self._extract_f4m_formats(\n                    format_url + '?hdcore=3.2.0', media_id, f4m_id='hds', fatal=False))\n            elif asset_type.startswith('HLS'):\n                formats.extend(self._extract_m3u8_formats(\n                    format_url, media_id, 'mp4', 'm3u8_native', m3u8_id='hds', fatal=False))\n            else:\n                format_info = {\n                    'ext': xpath_text(asset, 'mediaType'),\n                    'width': int_or_none(xpath_text(asset, 'frameWidth')),\n                    'height': int_or_none(xpath_text(asset, 'frameHeight')),\n                    'tbr': int_or_none(xpath_text(asset, 'bitrateVideo')),\n                    'abr': int_or_none(xpath_text(asset, 'bitrateAudio')),\n                    'vcodec': xpath_text(asset, 'codecVideo'),\n                    'acodec': xpath_text(asset, 'codecAudio'),\n                    'container': xpath_text(asset, 'mediaType'),\n                    'filesize': int_or_none(xpath_text(asset, 'size')),\n                }\n                format_url = self._proto_relative_url(format_url)\n                if format_url:\n                    http_format_info = format_info.copy()\n                    http_format_info.update({\n                        'url': format_url,\n                        'format_id': 'http-%s' % asset_type,\n                    })\n                    formats.append(http_format_info)\n                server_prefix = xpath_text(asset, 'serverPrefix')\n                if server_prefix:\n                    rtmp_format_info = format_info.copy()\n                    rtmp_format_info.update({\n                        'url': server_prefix,\n                        'play_path': xpath_text(asset, 'fileName'),\n                        'format_id': 'rtmp-%s' % asset_type,\n                    })\n                    formats.append(rtmp_format_info)\n        self._sort_formats(formats)\n        return formats\n\n    def _extract_thumbnails(self, variants, base_url):\n        thumbnails = [{\n            'url': base_url + xpath_text(variant, 'url'),\n            'width': int_or_none(xpath_text(variant, 'width')),\n            'height': int_or_none(xpath_text(variant, 'height')),\n        } for variant in variants.findall('variant') if xpath_text(variant, 'url')]\n        thumbnails.sort(key=lambda x: x['width'] * x['height'], reverse=True)\n        return thumbnails\n\n\nclass BRMediathekIE(InfoExtractor):\n    IE_DESC = 'Bayerischer Rundfunk Mediathek'\n    _VALID_URL = r'https?://(?:www\\.)?br\\.de/mediathek/video/[^/?&#]*?-(?P<id>av:[0-9a-f]{24})'\n\n    _TESTS = [{\n        'url': 'https://www.br.de/mediathek/video/gesundheit-die-sendung-vom-28112017-av:5a1e6a6e8fce6d001871cc8e',\n        'md5': 'fdc3d485835966d1622587d08ba632ec',\n        'info_dict': {\n            'id': 'av:5a1e6a6e8fce6d001871cc8e',\n            'ext': 'mp4',\n            'title': 'Die Sendung vom 28.11.2017',\n            'description': 'md5:6000cdca5912ab2277e5b7339f201ccc',\n            'timestamp': 1511942766,\n            'upload_date': '20171129',\n        }\n    }]\n\n    def _real_extract(self, url):\n        clip_id = self._match_id(url)\n\n        clip = self._download_json(\n            'https://proxy-base.master.mango.express/graphql',\n            clip_id, data=json.dumps({\n                \"query\": \"\"\"{\n  viewer {\n    clip(id: \"%s\") {\n      title\n      description\n      duration\n      createdAt\n      ageRestriction\n      videoFiles {\n        edges {\n          node {\n            publicLocation\n            fileSize\n            videoProfile {\n              width\n              height\n              bitrate\n              encoding\n            }\n          }\n        }\n      }\n      captionFiles {\n        edges {\n          node {\n            publicLocation\n          }\n        }\n      }\n      teaserImages {\n        edges {\n          node {\n            imageFiles {\n              edges {\n                node {\n                  publicLocation\n                  width\n                  height\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\"\"\" % clip_id}).encode(), headers={\n                'Content-Type': 'application/json',\n            })['data']['viewer']['clip']\n        title = clip['title']\n\n        formats = []\n        for edge in clip.get('videoFiles', {}).get('edges', []):\n            node = edge.get('node', {})\n            n_url = node.get('publicLocation')\n            if not n_url:\n                continue\n            ext = determine_ext(n_url)\n            if ext == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    n_url, clip_id, 'mp4', 'm3u8_native',\n                    m3u8_id='hls', fatal=False))\n            else:\n                video_profile = node.get('videoProfile', {})\n                tbr = int_or_none(video_profile.get('bitrate'))\n                format_id = 'http'\n                if tbr:\n                    format_id += '-%d' % tbr\n                formats.append({\n                    'format_id': format_id,\n                    'url': n_url,\n                    'width': int_or_none(video_profile.get('width')),\n                    'height': int_or_none(video_profile.get('height')),\n                    'tbr': tbr,\n                    'filesize': int_or_none(node.get('fileSize')),\n                })\n        self._sort_formats(formats)\n\n        subtitles = {}\n        for edge in clip.get('captionFiles', {}).get('edges', []):\n            node = edge.get('node', {})\n            n_url = node.get('publicLocation')\n            if not n_url:\n                continue\n            subtitles.setdefault('de', []).append({\n                'url': n_url,\n            })\n\n        thumbnails = []\n        for edge in clip.get('teaserImages', {}).get('edges', []):\n            for image_edge in edge.get('node', {}).get('imageFiles', {}).get('edges', []):\n                node = image_edge.get('node', {})\n                n_url = node.get('publicLocation')\n                if not n_url:\n                    continue\n                thumbnails.append({\n                    'url': n_url,\n                    'width': int_or_none(node.get('width')),\n                    'height': int_or_none(node.get('height')),\n                })\n\n        return {\n            'id': clip_id,\n            'title': title,\n            'description': clip.get('description'),\n            'duration': int_or_none(clip.get('duration')),\n            'timestamp': parse_iso8601(clip.get('createdAt')),\n            'age_limit': int_or_none(clip.get('ageRestriction')),\n            'formats': formats,\n            'subtitles': subtitles,\n            'thumbnails': thumbnails,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "br.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/br.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}