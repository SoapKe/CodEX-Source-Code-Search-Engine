{"author": "chiphuyen", "code": "\"\"\" Load VGGNet weights needed for the implementation of the paper \n\"A Neural Algorithm of Artistic Style\" by Gatys et al. in TensorFlow.\n\nAuthor: Chip Huyen (huyenn@stanford.edu)\nPrepared for the class CS 20SI: \"TensorFlow for Deep Learning Research\"\nFor more details, please read the assignment handout:\nhttp://web.stanford.edu/class/cs20si/assignments/a2.pdf\n\"\"\"\n\nimport numpy as np\nimport tensorflow as tf\nimport scipy.io\n\ndef _weights(vgg_layers, layer, expected_layer_name):\n    \"\"\" Return the weights and biases already trained by VGG\n    \"\"\"\n    W = vgg_layers[0][layer][0][0][2][0][0]\n    b = vgg_layers[0][layer][0][0][2][0][1]\n    layer_name = vgg_layers[0][layer][0][0][0][0]\n    assert layer_name == expected_layer_name\n    return W, b.reshape(b.size)\n\ndef _conv2d_relu(vgg_layers, prev_layer, layer, layer_name):\n    \"\"\" Return the Conv2D layer with RELU using the weights, biases from the VGG\n    model at 'layer'.\n    Inputs:\n        vgg_layers: holding all the layers of VGGNet\n        prev_layer: the output tensor from the previous layer\n        layer: the index to current layer in vgg_layers\n        layer_name: the string that is the name of the current layer.\n                    It's used to specify variable_scope.\n\n    Output:\n        relu applied on the convolution.\n\n    Note that you first need to obtain W and b from vgg-layers using the function\n    _weights() defined above.\n    W and b returned from _weights() are numpy arrays, so you have\n    to convert them to TF tensors using tf.constant.\n    Note that you'll have to do apply relu on the convolution.\n    Hint for choosing strides size: \n        for small images, you probably don't want to skip any pixel\n    \"\"\"\n    pass\n\ndef _avgpool(prev_layer):\n    \"\"\" Return the average pooling layer. The paper suggests that average pooling\n    actually works better than max pooling.\n    Input:\n        prev_layer: the output tensor from the previous layer\n\n    Output:\n        the output of the tf.nn.avg_pool() function.\n    Hint for choosing strides and kszie: choose what you feel appropriate\n    \"\"\"\n    pass\n\ndef load_vgg(path, input_image):\n    \"\"\" Load VGG into a TensorFlow model.\n    Use a dictionary to hold the model instead of using a Python class\n    \"\"\"\n    vgg = scipy.io.loadmat(path)\n    vgg_layers = vgg['layers']\n\n    graph = {} \n    graph['conv1_1']  = _conv2d_relu(vgg_layers, input_image, 0, 'conv1_1')\n    graph['conv1_2']  = _conv2d_relu(vgg_layers, graph['conv1_1'], 2, 'conv1_2')\n    graph['avgpool1'] = _avgpool(graph['conv1_2'])\n    graph['conv2_1']  = _conv2d_relu(vgg_layers, graph['avgpool1'], 5, 'conv2_1')\n    graph['conv2_2']  = _conv2d_relu(vgg_layers, graph['conv2_1'], 7, 'conv2_2')\n    graph['avgpool2'] = _avgpool(graph['conv2_2'])\n    graph['conv3_1']  = _conv2d_relu(vgg_layers, graph['avgpool2'], 10, 'conv3_1')\n    graph['conv3_2']  = _conv2d_relu(vgg_layers, graph['conv3_1'], 12, 'conv3_2')\n    graph['conv3_3']  = _conv2d_relu(vgg_layers, graph['conv3_2'], 14, 'conv3_3')\n    graph['conv3_4']  = _conv2d_relu(vgg_layers, graph['conv3_3'], 16, 'conv3_4')\n    graph['avgpool3'] = _avgpool(graph['conv3_4'])\n    graph['conv4_1']  = _conv2d_relu(vgg_layers, graph['avgpool3'], 19, 'conv4_1')\n    graph['conv4_2']  = _conv2d_relu(vgg_layers, graph['conv4_1'], 21, 'conv4_2')\n    graph['conv4_3']  = _conv2d_relu(vgg_layers, graph['conv4_2'], 23, 'conv4_3')\n    graph['conv4_4']  = _conv2d_relu(vgg_layers, graph['conv4_3'], 25, 'conv4_4')\n    graph['avgpool4'] = _avgpool(graph['conv4_4'])\n    graph['conv5_1']  = _conv2d_relu(vgg_layers, graph['avgpool4'], 28, 'conv5_1')\n    graph['conv5_2']  = _conv2d_relu(vgg_layers, graph['conv5_1'], 30, 'conv5_2')\n    graph['conv5_3']  = _conv2d_relu(vgg_layers, graph['conv5_2'], 32, 'conv5_3')\n    graph['conv5_4']  = _conv2d_relu(vgg_layers, graph['conv5_3'], 34, 'conv5_4')\n    graph['avgpool5'] = _avgpool(graph['conv5_4'])\n    \n    return graph", "comments": "    load vggnet weights needed implementation paper   a neural algorithm artistic style  gatys et al  tensorflow   author  chip huyen (huyenn stanford edu) prepared class cs 20si   tensorflow deep learning research  for details  please read assignment handout  http   web stanford edu class cs20si assignments a2 pdf      import numpy np import tensorflow tf import scipy io  def  weights(vgg layers  layer  expected layer name)          return weights biases already trained vgg             w   vgg layers 0  layer  0  0  2  0  0      b   vgg layers 0  layer  0  0  2  0  1      layer name   vgg layers 0  layer  0  0  0  0      assert layer name    expected layer name     return w  b reshape(b size)  def  conv2d relu(vgg layers  prev layer  layer  layer name)          return conv2d layer relu using weights  biases vgg     model  layer       inputs          vgg layers  holding layers vggnet         prev layer  output tensor previous layer         layer  index current layer vgg layers         layer name  string name current layer                      it used specify variable scope       output          relu applied convolution       note first need obtain w b vgg layers using function      weights() defined      w b returned  weights() numpy arrays      convert tf tensors using tf constant      note apply relu convolution      hint choosing strides size           small images  probably want skip pixel             pass  def  avgpool(prev layer)          return average pooling layer  the paper suggests average pooling     actually works better max pooling      input          prev layer  output tensor previous layer      output          output tf nn avg pool() function      hint choosing strides kszie  choose feel appropriate             pass  def load vgg(path  input image)          load vgg tensorflow model      use dictionary hold model instead using python class         ", "content": "\"\"\" Load VGGNet weights needed for the implementation of the paper \n\"A Neural Algorithm of Artistic Style\" by Gatys et al. in TensorFlow.\n\nAuthor: Chip Huyen (huyenn@stanford.edu)\nPrepared for the class CS 20SI: \"TensorFlow for Deep Learning Research\"\nFor more details, please read the assignment handout:\nhttp://web.stanford.edu/class/cs20si/assignments/a2.pdf\n\"\"\"\n\nimport numpy as np\nimport tensorflow as tf\nimport scipy.io\n\ndef _weights(vgg_layers, layer, expected_layer_name):\n    \"\"\" Return the weights and biases already trained by VGG\n    \"\"\"\n    W = vgg_layers[0][layer][0][0][2][0][0]\n    b = vgg_layers[0][layer][0][0][2][0][1]\n    layer_name = vgg_layers[0][layer][0][0][0][0]\n    assert layer_name == expected_layer_name\n    return W, b.reshape(b.size)\n\ndef _conv2d_relu(vgg_layers, prev_layer, layer, layer_name):\n    \"\"\" Return the Conv2D layer with RELU using the weights, biases from the VGG\n    model at 'layer'.\n    Inputs:\n        vgg_layers: holding all the layers of VGGNet\n        prev_layer: the output tensor from the previous layer\n        layer: the index to current layer in vgg_layers\n        layer_name: the string that is the name of the current layer.\n                    It's used to specify variable_scope.\n\n    Output:\n        relu applied on the convolution.\n\n    Note that you first need to obtain W and b from vgg-layers using the function\n    _weights() defined above.\n    W and b returned from _weights() are numpy arrays, so you have\n    to convert them to TF tensors using tf.constant.\n    Note that you'll have to do apply relu on the convolution.\n    Hint for choosing strides size: \n        for small images, you probably don't want to skip any pixel\n    \"\"\"\n    pass\n\ndef _avgpool(prev_layer):\n    \"\"\" Return the average pooling layer. The paper suggests that average pooling\n    actually works better than max pooling.\n    Input:\n        prev_layer: the output tensor from the previous layer\n\n    Output:\n        the output of the tf.nn.avg_pool() function.\n    Hint for choosing strides and kszie: choose what you feel appropriate\n    \"\"\"\n    pass\n\ndef load_vgg(path, input_image):\n    \"\"\" Load VGG into a TensorFlow model.\n    Use a dictionary to hold the model instead of using a Python class\n    \"\"\"\n    vgg = scipy.io.loadmat(path)\n    vgg_layers = vgg['layers']\n\n    graph = {} \n    graph['conv1_1']  = _conv2d_relu(vgg_layers, input_image, 0, 'conv1_1')\n    graph['conv1_2']  = _conv2d_relu(vgg_layers, graph['conv1_1'], 2, 'conv1_2')\n    graph['avgpool1'] = _avgpool(graph['conv1_2'])\n    graph['conv2_1']  = _conv2d_relu(vgg_layers, graph['avgpool1'], 5, 'conv2_1')\n    graph['conv2_2']  = _conv2d_relu(vgg_layers, graph['conv2_1'], 7, 'conv2_2')\n    graph['avgpool2'] = _avgpool(graph['conv2_2'])\n    graph['conv3_1']  = _conv2d_relu(vgg_layers, graph['avgpool2'], 10, 'conv3_1')\n    graph['conv3_2']  = _conv2d_relu(vgg_layers, graph['conv3_1'], 12, 'conv3_2')\n    graph['conv3_3']  = _conv2d_relu(vgg_layers, graph['conv3_2'], 14, 'conv3_3')\n    graph['conv3_4']  = _conv2d_relu(vgg_layers, graph['conv3_3'], 16, 'conv3_4')\n    graph['avgpool3'] = _avgpool(graph['conv3_4'])\n    graph['conv4_1']  = _conv2d_relu(vgg_layers, graph['avgpool3'], 19, 'conv4_1')\n    graph['conv4_2']  = _conv2d_relu(vgg_layers, graph['conv4_1'], 21, 'conv4_2')\n    graph['conv4_3']  = _conv2d_relu(vgg_layers, graph['conv4_2'], 23, 'conv4_3')\n    graph['conv4_4']  = _conv2d_relu(vgg_layers, graph['conv4_3'], 25, 'conv4_4')\n    graph['avgpool4'] = _avgpool(graph['conv4_4'])\n    graph['conv5_1']  = _conv2d_relu(vgg_layers, graph['avgpool4'], 28, 'conv5_1')\n    graph['conv5_2']  = _conv2d_relu(vgg_layers, graph['conv5_1'], 30, 'conv5_2')\n    graph['conv5_3']  = _conv2d_relu(vgg_layers, graph['conv5_2'], 32, 'conv5_3')\n    graph['conv5_4']  = _conv2d_relu(vgg_layers, graph['conv5_3'], 34, 'conv5_4')\n    graph['avgpool5'] = _avgpool(graph['conv5_4'])\n    \n    return graph", "description": "This repository contains code examples for the Stanford's course: TensorFlow for Deep Learning Research. ", "file_name": "vgg_model.py", "id": "657e56e6e9a79b0196c4fb772de1a485", "language": "Python", "project_name": "stanford-tensorflow-tutorials", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/chiphuyen-stanford-tensorflow-tutorials/chiphuyen-stanford-tensorflow-tutorials-54c48f5/2017/assignments/style_transfer_starter/vgg_model.py", "save_time": "", "source": "", "update_at": "2018-03-18T15:38:24Z", "url": "https://github.com/chiphuyen/stanford-tensorflow-tutorials", "wiki": true}