{"author": "localstack", "code": "import os\nimport json\nimport base64\nimport traceback\nimport requests\nimport logging\nfrom localstack.config import DATA_DIR\nfrom localstack.utils.aws import aws_stack\nfrom localstack.utils.common import to_bytes, to_str\n\nAPI_FILE_PATTERN = '{data_dir}/{api}_api_calls.json'\n\n\n# (We should not be re-playing and recording at the same time)\nCURRENTLY_REPLAYING = []\n\n\nAPI_FILE_PATHS = {}\n\n\nLOGGER = logging.getLogger(__name__)\n\n\ndef should_record(api, method, path, data, headers):\n    \"\"\" Decide whether or not a given API call should be recorded (persisted to disk) \"\"\"\n    if api == 's3':\n        if method not in ['PUT', 'POST', 'DELETE']:\n            return False\n        return True\n    return False\n\n\ndef record(api, method, path, data, headers):\n    \"\"\" Record a given API call to a persistent file on disk \"\"\"\n    file_path = get_file_path(api, create=True)\n    if CURRENTLY_REPLAYING or not file_path or not should_record(api, method, path, data, headers):\n        return\n    entry = None\n    try:\n        if isinstance(data, dict):\n            data = json.dumps(data)\n        if data:\n            try:\n                data = to_bytes(data)\n            except Exception as e:\n                LOGGER.warning('Unable to call to_bytes: %s' % e)\n            data = to_str(base64.b64encode(data))\n        entry = {\n            'a': api,\n            'm': method,\n            'p': path,\n            'd': data,\n            'h': dict(headers)\n        }\n        with open(file_path, 'a') as dumpfile:\n            dumpfile.write('%s\\n' % json.dumps(entry))\n    except Exception as e:\n        print('Error recording API call to persistent file: %s %s' % (e, traceback.format_exc()))\n\n\ndef replay_command(command):\n    function = getattr(requests, command['m'].lower())\n    data = command['d']\n    if data:\n        data = base64.b64decode(data)\n    endpoint = aws_stack.get_local_service_url(command['a'])\n    full_url = (endpoint[:-1] if endpoint.endswith('/') else endpoint) + command['p']\n    result = function(full_url, data=data, headers=command['h'])\n    return result\n\n\ndef replay(api):\n    file_path = get_file_path(api)\n    if not file_path:\n        return\n    CURRENTLY_REPLAYING.append(True)\n    count = 0\n    try:\n        with open(file_path, 'r') as reader:\n            for line in reader:\n                if line.strip():\n                    count += 1\n                    command = json.loads(line)\n                    replay_command(command)\n    finally:\n        CURRENTLY_REPLAYING.pop(0)\n    if count:\n        LOGGER.info('Restored %s API calls from persistent file: %s' % (count, file_path))\n\n\ndef restore_persisted_data(api):\n    return replay(api)\n\n\n\n\n\n\ndef get_file_path(api, create=False):\n    if api not in API_FILE_PATHS:\n        API_FILE_PATHS[api] = False\n        if not DATA_DIR:\n            return False\n        file_path = API_FILE_PATTERN.format(data_dir=DATA_DIR, api=api)\n        if create and not os.path.exists(file_path):\n            with open(file_path, 'a'):\n                os.utime(file_path, None)\n        if os.path.exists(file_path):\n            API_FILE_PATHS[api] = file_path\n    return API_FILE_PATHS.get(api)\n", "comments": "    decide whether given api call recorded (persisted disk)         api     s3           method   put    post    delete                return false         return true     return false   def record(api  method  path  data  headers)          record given api call persistent file disk        stack flags indicate whether currently playing api calls     (we playing recording time)    file paths api    set logger                       helper methods                    ", "content": "import os\nimport json\nimport base64\nimport traceback\nimport requests\nimport logging\nfrom localstack.config import DATA_DIR\nfrom localstack.utils.aws import aws_stack\nfrom localstack.utils.common import to_bytes, to_str\n\nAPI_FILE_PATTERN = '{data_dir}/{api}_api_calls.json'\n\n# Stack with flags to indicate whether we are currently re-playing API calls.\n# (We should not be re-playing and recording at the same time)\nCURRENTLY_REPLAYING = []\n\n# file paths by API\nAPI_FILE_PATHS = {}\n\n# set up logger\nLOGGER = logging.getLogger(__name__)\n\n\ndef should_record(api, method, path, data, headers):\n    \"\"\" Decide whether or not a given API call should be recorded (persisted to disk) \"\"\"\n    if api == 's3':\n        if method not in ['PUT', 'POST', 'DELETE']:\n            return False\n        return True\n    return False\n\n\ndef record(api, method, path, data, headers):\n    \"\"\" Record a given API call to a persistent file on disk \"\"\"\n    file_path = get_file_path(api, create=True)\n    if CURRENTLY_REPLAYING or not file_path or not should_record(api, method, path, data, headers):\n        return\n    entry = None\n    try:\n        if isinstance(data, dict):\n            data = json.dumps(data)\n        if data:\n            try:\n                data = to_bytes(data)\n            except Exception as e:\n                LOGGER.warning('Unable to call to_bytes: %s' % e)\n            data = to_str(base64.b64encode(data))\n        entry = {\n            'a': api,\n            'm': method,\n            'p': path,\n            'd': data,\n            'h': dict(headers)\n        }\n        with open(file_path, 'a') as dumpfile:\n            dumpfile.write('%s\\n' % json.dumps(entry))\n    except Exception as e:\n        print('Error recording API call to persistent file: %s %s' % (e, traceback.format_exc()))\n\n\ndef replay_command(command):\n    function = getattr(requests, command['m'].lower())\n    data = command['d']\n    if data:\n        data = base64.b64decode(data)\n    endpoint = aws_stack.get_local_service_url(command['a'])\n    full_url = (endpoint[:-1] if endpoint.endswith('/') else endpoint) + command['p']\n    result = function(full_url, data=data, headers=command['h'])\n    return result\n\n\ndef replay(api):\n    file_path = get_file_path(api)\n    if not file_path:\n        return\n    CURRENTLY_REPLAYING.append(True)\n    count = 0\n    try:\n        with open(file_path, 'r') as reader:\n            for line in reader:\n                if line.strip():\n                    count += 1\n                    command = json.loads(line)\n                    replay_command(command)\n    finally:\n        CURRENTLY_REPLAYING.pop(0)\n    if count:\n        LOGGER.info('Restored %s API calls from persistent file: %s' % (count, file_path))\n\n\ndef restore_persisted_data(api):\n    return replay(api)\n\n\n# ---------------\n# HELPER METHODS\n# ---------------\n\ndef get_file_path(api, create=False):\n    if api not in API_FILE_PATHS:\n        API_FILE_PATHS[api] = False\n        if not DATA_DIR:\n            return False\n        file_path = API_FILE_PATTERN.format(data_dir=DATA_DIR, api=api)\n        if create and not os.path.exists(file_path):\n            with open(file_path, 'a'):\n                os.utime(file_path, None)\n        if os.path.exists(file_path):\n            API_FILE_PATHS[api] = file_path\n    return API_FILE_PATHS.get(api)\n", "description": "\ud83d\udcbb  A fully functional local AWS cloud stack. Develop and test your cloud apps offline!", "file_name": "persistence.py", "id": "4fda060c5ff4ae1ae3171257c8ee6cd0", "language": "Python", "project_name": "localstack", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/localstack-localstack/localstack-localstack-fcc848e/localstack/utils/persistence.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:04:08Z", "url": "https://github.com/localstack/localstack", "wiki": true}