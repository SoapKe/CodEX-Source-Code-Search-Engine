{"author": "python", "code": "\"\"\"Benchmark some basic import use-cases.\n\nThe assumption is made that this benchmark is run in a fresh interpreter and\nthus has no external changes made to import-related attributes in sys.\n\n\"\"\"\nfrom test.test_importlib import util\nimport decimal\nimport imp\nimport importlib\nimport importlib.machinery\nimport json\nimport os\nimport py_compile\nimport sys\nimport tabnanny\nimport timeit\n\n\ndef bench(name, cleanup=lambda: None, *, seconds=1, repeat=3):\n    \"\"\"Bench the given statement as many times as necessary until total\n    executions take one second.\"\"\"\n    stmt = \"__import__({!r})\".format(name)\n    timer = timeit.Timer(stmt)\n    for x in range(repeat):\n        total_time = 0\n        count = 0\n        while total_time < seconds:\n            try:\n                total_time += timer.timeit(1)\n            finally:\n                cleanup()\n            count += 1\n        else:\n            \n            if total_time > seconds:\n                count -= 1\n        yield count // seconds\n\ndef from_cache(seconds, repeat):\n    \"\"\"sys.modules\"\"\"\n    name = '<benchmark import>'\n    module = imp.new_module(name)\n    module.__file__ = '<test>'\n    module.__package__ = ''\n    with util.uncache(name):\n        sys.modules[name] = module\n        yield from bench(name, repeat=repeat, seconds=seconds)\n\n\ndef builtin_mod(seconds, repeat):\n    \"\"\"Built-in module\"\"\"\n    name = 'errno'\n    if name in sys.modules:\n        del sys.modules[name]\n    \n    yield from bench(name, lambda: sys.modules.pop(name), repeat=repeat,\n                     seconds=seconds)\n\n\ndef source_wo_bytecode(seconds, repeat):\n    \"\"\"Source w/o bytecode: small\"\"\"\n    sys.dont_write_bytecode = True\n    try:\n        name = '__importlib_test_benchmark__'\n        \n        with util.create_modules(name) as mapping:\n            assert not os.path.exists(imp.cache_from_source(mapping[name]))\n            sys.meta_path.append(importlib.machinery.PathFinder)\n            loader = (importlib.machinery.SourceFileLoader,\n                      importlib.machinery.SOURCE_SUFFIXES)\n            sys.path_hooks.append(importlib.machinery.FileFinder.path_hook(loader))\n            yield from bench(name, lambda: sys.modules.pop(name), repeat=repeat,\n                             seconds=seconds)\n    finally:\n        sys.dont_write_bytecode = False\n\n\ndef _wo_bytecode(module):\n    name = module.__name__\n    def benchmark_wo_bytecode(seconds, repeat):\n        \"\"\"Source w/o bytecode: {}\"\"\"\n        bytecode_path = imp.cache_from_source(module.__file__)\n        if os.path.exists(bytecode_path):\n            os.unlink(bytecode_path)\n        sys.dont_write_bytecode = True\n        try:\n            yield from bench(name, lambda: sys.modules.pop(name),\n                             repeat=repeat, seconds=seconds)\n        finally:\n            sys.dont_write_bytecode = False\n\n    benchmark_wo_bytecode.__doc__ = benchmark_wo_bytecode.__doc__.format(name)\n    return benchmark_wo_bytecode\n\ntabnanny_wo_bytecode = _wo_bytecode(tabnanny)\ndecimal_wo_bytecode = _wo_bytecode(decimal)\n\n\ndef source_writing_bytecode(seconds, repeat):\n    \"\"\"Source writing bytecode: small\"\"\"\n    assert not sys.dont_write_bytecode\n    name = '__importlib_test_benchmark__'\n    with util.create_modules(name) as mapping:\n        sys.meta_path.append(importlib.machinery.PathFinder)\n        loader = (importlib.machinery.SourceFileLoader,\n                  importlib.machinery.SOURCE_SUFFIXES)\n        sys.path_hooks.append(importlib.machinery.FileFinder.path_hook(loader))\n        def cleanup():\n            sys.modules.pop(name)\n            os.unlink(imp.cache_from_source(mapping[name]))\n        for result in bench(name, cleanup, repeat=repeat, seconds=seconds):\n            assert not os.path.exists(imp.cache_from_source(mapping[name]))\n            yield result\n\n\ndef _writing_bytecode(module):\n    name = module.__name__\n    def writing_bytecode_benchmark(seconds, repeat):\n        \"\"\"Source writing bytecode: {}\"\"\"\n        assert not sys.dont_write_bytecode\n        def cleanup():\n            sys.modules.pop(name)\n            os.unlink(imp.cache_from_source(module.__file__))\n        yield from bench(name, cleanup, repeat=repeat, seconds=seconds)\n\n    writing_bytecode_benchmark.__doc__ = (\n                                writing_bytecode_benchmark.__doc__.format(name))\n    return writing_bytecode_benchmark\n\ntabnanny_writing_bytecode = _writing_bytecode(tabnanny)\ndecimal_writing_bytecode = _writing_bytecode(decimal)\n\n\ndef source_using_bytecode(seconds, repeat):\n    \"\"\"Source w/ bytecode: small\"\"\"\n    name = '__importlib_test_benchmark__'\n    with util.create_modules(name) as mapping:\n        sys.meta_path.append(importlib.machinery.PathFinder)\n        loader = (importlib.machinery.SourceFileLoader,\n                  importlib.machinery.SOURCE_SUFFIXES)\n        sys.path_hooks.append(importlib.machinery.FileFinder.path_hook(loader))\n        py_compile.compile(mapping[name])\n        assert os.path.exists(imp.cache_from_source(mapping[name]))\n        yield from bench(name, lambda: sys.modules.pop(name), repeat=repeat,\n                         seconds=seconds)\n\n\ndef _using_bytecode(module):\n    name = module.__name__\n    def using_bytecode_benchmark(seconds, repeat):\n        \"\"\"Source w/ bytecode: {}\"\"\"\n        py_compile.compile(module.__file__)\n        yield from bench(name, lambda: sys.modules.pop(name), repeat=repeat,\n                         seconds=seconds)\n\n    using_bytecode_benchmark.__doc__ = (\n                                using_bytecode_benchmark.__doc__.format(name))\n    return using_bytecode_benchmark\n\ntabnanny_using_bytecode = _using_bytecode(tabnanny)\ndecimal_using_bytecode = _using_bytecode(decimal)\n\n\ndef main(import_, options):\n    if options.source_file:\n        with options.source_file:\n            prev_results = json.load(options.source_file)\n    else:\n        prev_results = {}\n    __builtins__.__import__ = import_\n    benchmarks = (from_cache, builtin_mod,\n                  source_writing_bytecode,\n                  source_wo_bytecode, source_using_bytecode,\n                  tabnanny_writing_bytecode,\n                  tabnanny_wo_bytecode, tabnanny_using_bytecode,\n                  decimal_writing_bytecode,\n                  decimal_wo_bytecode, decimal_using_bytecode,\n                )\n    if options.benchmark:\n        for b in benchmarks:\n            if b.__doc__ == options.benchmark:\n                benchmarks = [b]\n                break\n        else:\n            print('Unknown benchmark: {!r}'.format(options.benchmark,\n                  file=sys.stderr))\n            sys.exit(1)\n    seconds = 1\n    seconds_plural = 's' if seconds > 1 else ''\n    repeat = 3\n    header = ('Measuring imports/second over {} second{}, best out of {}\\n'\n              'Entire benchmark run should take about {} seconds\\n'\n              'Using {!r} as __import__\\n')\n    print(header.format(seconds, seconds_plural, repeat,\n                        len(benchmarks) * seconds * repeat, __import__))\n    new_results = {}\n    for benchmark in benchmarks:\n        print(benchmark.__doc__, \"[\", end=' ')\n        sys.stdout.flush()\n        results = []\n        for result in benchmark(seconds=seconds, repeat=repeat):\n            results.append(result)\n            print(result, end=' ')\n            sys.stdout.flush()\n        assert not sys.dont_write_bytecode\n        print(\"]\", \"best is\", format(max(results), ',d'))\n        new_results[benchmark.__doc__] = results\n    if prev_results:\n        print('\\n\\nComparing new vs. old\\n')\n        for benchmark in benchmarks:\n            benchmark_name = benchmark.__doc__\n            old_result = max(prev_results[benchmark_name])\n            new_result = max(new_results[benchmark_name])\n            result = '{:,d} vs. {:,d} ({:%})'.format(new_result,\n                                                     old_result,\n                                              new_result/old_result)\n            print(benchmark_name, ':', result)\n    if options.dest_file:\n        with options.dest_file:\n            json.dump(new_results, options.dest_file, indent=2)\n\n\nif __name__ == '__main__':\n    import argparse\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-b', '--builtin', dest='builtin', action='store_true',\n                        default=False, help=\"use the built-in __import__\")\n    parser.add_argument('-r', '--read', dest='source_file',\n                        type=argparse.FileType('r'),\n                        help='file to read benchmark data from to compare '\n                             'against')\n    parser.add_argument('-w', '--write', dest='dest_file',\n                        type=argparse.FileType('w'),\n                        help='file to write benchmark data to')\n    parser.add_argument('--benchmark', dest='benchmark',\n                        help='specific benchmark to run')\n    options = parser.parse_args()\n    import_ = __import__\n    if not options.builtin:\n        import_ = importlib.__import__\n\n    main(import_, options)\n", "comments": "   benchmark basic import use cases   the assumption made benchmark run fresh interpreter thus external changes made import related attributes sys       test test importlib import util import decimal import imp import importlib import importlib machinery import json import os import py compile import sys import tabnanny import timeit   def bench(name  cleanup lambda  none     seconds 1  repeat 3)         bench given statement many times necessary total     executions take one second         stmt      import  (  r )  format(name)     timer   timeit timer(stmt)     x range(repeat)          total time   0         count   0         total time   seconds              try                  total time    timer timeit(1)             finally                  cleanup()             count    1         else                one execution far             total time   seconds                  count    1         yield count    seconds  def cache(seconds  repeat)         sys modules        name     benchmark import       module   imp new module(name)     module   file       test       module   package            util uncache(name)          sys modules name    module         yield bench(name  repeat repeat  seconds seconds)   def builtin mod(seconds  repeat)         built module        name    errno      name sys modules          del sys modules name        relying built importer implicit      yield bench(name  lambda  sys modules pop(name)  repeat repeat                       seconds seconds)   def source wo bytecode(seconds  repeat)         source w bytecode  small        sys dont write bytecode   true     try          name      importlib test benchmark              clears sys modules puts entry front sys path          util create modules(name) mapping              assert os path exists(imp cache source(mapping name ))             sys meta path append(importlib machinery pathfinder)             loader   (importlib machinery sourcefileloader                        importlib machinery source suffixes)             sys path hooks append(importlib machinery filefinder path hook(loader))             yield bench(name  lambda  sys modules pop(name)  repeat repeat                               seconds seconds)     finally          sys dont write bytecode   false   def  wo bytecode(module)      name   module   name       def benchmark wo bytecode(seconds  repeat)             source w bytecode                bytecode path   imp cache source(module   file  )         os path exists(bytecode path)              os unlink(bytecode path)         sys dont write bytecode   true         try              yield bench(name  lambda  sys modules pop(name)                               repeat repeat  seconds seconds)         finally              sys dont write bytecode   false      benchmark wo bytecode   doc     benchmark wo bytecode   doc   format(name)     return benchmark wo bytecode  tabnanny wo bytecode    wo bytecode(tabnanny) decimal wo bytecode    wo bytecode(decimal)   def source writing bytecode(seconds  repeat)         source writing bytecode  small        assert sys dont write bytecode     name      importlib test benchmark        util create modules(name) mapping          sys meta path append(importlib machinery pathfinder)         loader   (importlib machinery sourcefileloader                    importlib machinery source suffixes)         sys path hooks append(importlib machinery filefinder path hook(loader))         def cleanup()              sys modules pop(name)             os unlink(imp cache source(mapping name ))         result bench(name  cleanup  repeat repeat  seconds seconds)              assert os path exists(imp cache source(mapping name ))             yield result   def  writing bytecode(module)      name   module   name       def writing bytecode benchmark(seconds  repeat)             source writing bytecode                assert sys dont write bytecode         def cleanup()              sys modules pop(name)             os unlink(imp cache source(module   file  ))         yield bench(name  cleanup  repeat repeat  seconds seconds)      writing bytecode benchmark   doc     (                                 writing bytecode benchmark   doc   format(name))     return writing bytecode benchmark  tabnanny writing bytecode    writing bytecode(tabnanny) decimal writing bytecode    writing bytecode(decimal)   def source using bytecode(seconds  repeat)         source w  bytecode  small        name      importlib test benchmark        util create modules(name) mapping          sys meta path append(importlib machinery pathfinder)         loader   (importlib machinery sourcefileloader                    importlib machinery source suffixes)         sys path hooks append(importlib machinery filefinder path hook(loader))         py compile compile(mapping name )         assert os path exists(imp cache source(mapping name ))         yield bench(name  lambda  sys modules pop(name)  repeat repeat                           seconds seconds)   def  using bytecode(module)      name   module   name       def using bytecode benchmark(seconds  repeat)             source w  bytecode           one execution far    relying built importer implicit     clears sys modules puts entry front sys path  ", "content": "\"\"\"Benchmark some basic import use-cases.\n\nThe assumption is made that this benchmark is run in a fresh interpreter and\nthus has no external changes made to import-related attributes in sys.\n\n\"\"\"\nfrom test.test_importlib import util\nimport decimal\nimport imp\nimport importlib\nimport importlib.machinery\nimport json\nimport os\nimport py_compile\nimport sys\nimport tabnanny\nimport timeit\n\n\ndef bench(name, cleanup=lambda: None, *, seconds=1, repeat=3):\n    \"\"\"Bench the given statement as many times as necessary until total\n    executions take one second.\"\"\"\n    stmt = \"__import__({!r})\".format(name)\n    timer = timeit.Timer(stmt)\n    for x in range(repeat):\n        total_time = 0\n        count = 0\n        while total_time < seconds:\n            try:\n                total_time += timer.timeit(1)\n            finally:\n                cleanup()\n            count += 1\n        else:\n            # One execution too far\n            if total_time > seconds:\n                count -= 1\n        yield count // seconds\n\ndef from_cache(seconds, repeat):\n    \"\"\"sys.modules\"\"\"\n    name = '<benchmark import>'\n    module = imp.new_module(name)\n    module.__file__ = '<test>'\n    module.__package__ = ''\n    with util.uncache(name):\n        sys.modules[name] = module\n        yield from bench(name, repeat=repeat, seconds=seconds)\n\n\ndef builtin_mod(seconds, repeat):\n    \"\"\"Built-in module\"\"\"\n    name = 'errno'\n    if name in sys.modules:\n        del sys.modules[name]\n    # Relying on built-in importer being implicit.\n    yield from bench(name, lambda: sys.modules.pop(name), repeat=repeat,\n                     seconds=seconds)\n\n\ndef source_wo_bytecode(seconds, repeat):\n    \"\"\"Source w/o bytecode: small\"\"\"\n    sys.dont_write_bytecode = True\n    try:\n        name = '__importlib_test_benchmark__'\n        # Clears out sys.modules and puts an entry at the front of sys.path.\n        with util.create_modules(name) as mapping:\n            assert not os.path.exists(imp.cache_from_source(mapping[name]))\n            sys.meta_path.append(importlib.machinery.PathFinder)\n            loader = (importlib.machinery.SourceFileLoader,\n                      importlib.machinery.SOURCE_SUFFIXES)\n            sys.path_hooks.append(importlib.machinery.FileFinder.path_hook(loader))\n            yield from bench(name, lambda: sys.modules.pop(name), repeat=repeat,\n                             seconds=seconds)\n    finally:\n        sys.dont_write_bytecode = False\n\n\ndef _wo_bytecode(module):\n    name = module.__name__\n    def benchmark_wo_bytecode(seconds, repeat):\n        \"\"\"Source w/o bytecode: {}\"\"\"\n        bytecode_path = imp.cache_from_source(module.__file__)\n        if os.path.exists(bytecode_path):\n            os.unlink(bytecode_path)\n        sys.dont_write_bytecode = True\n        try:\n            yield from bench(name, lambda: sys.modules.pop(name),\n                             repeat=repeat, seconds=seconds)\n        finally:\n            sys.dont_write_bytecode = False\n\n    benchmark_wo_bytecode.__doc__ = benchmark_wo_bytecode.__doc__.format(name)\n    return benchmark_wo_bytecode\n\ntabnanny_wo_bytecode = _wo_bytecode(tabnanny)\ndecimal_wo_bytecode = _wo_bytecode(decimal)\n\n\ndef source_writing_bytecode(seconds, repeat):\n    \"\"\"Source writing bytecode: small\"\"\"\n    assert not sys.dont_write_bytecode\n    name = '__importlib_test_benchmark__'\n    with util.create_modules(name) as mapping:\n        sys.meta_path.append(importlib.machinery.PathFinder)\n        loader = (importlib.machinery.SourceFileLoader,\n                  importlib.machinery.SOURCE_SUFFIXES)\n        sys.path_hooks.append(importlib.machinery.FileFinder.path_hook(loader))\n        def cleanup():\n            sys.modules.pop(name)\n            os.unlink(imp.cache_from_source(mapping[name]))\n        for result in bench(name, cleanup, repeat=repeat, seconds=seconds):\n            assert not os.path.exists(imp.cache_from_source(mapping[name]))\n            yield result\n\n\ndef _writing_bytecode(module):\n    name = module.__name__\n    def writing_bytecode_benchmark(seconds, repeat):\n        \"\"\"Source writing bytecode: {}\"\"\"\n        assert not sys.dont_write_bytecode\n        def cleanup():\n            sys.modules.pop(name)\n            os.unlink(imp.cache_from_source(module.__file__))\n        yield from bench(name, cleanup, repeat=repeat, seconds=seconds)\n\n    writing_bytecode_benchmark.__doc__ = (\n                                writing_bytecode_benchmark.__doc__.format(name))\n    return writing_bytecode_benchmark\n\ntabnanny_writing_bytecode = _writing_bytecode(tabnanny)\ndecimal_writing_bytecode = _writing_bytecode(decimal)\n\n\ndef source_using_bytecode(seconds, repeat):\n    \"\"\"Source w/ bytecode: small\"\"\"\n    name = '__importlib_test_benchmark__'\n    with util.create_modules(name) as mapping:\n        sys.meta_path.append(importlib.machinery.PathFinder)\n        loader = (importlib.machinery.SourceFileLoader,\n                  importlib.machinery.SOURCE_SUFFIXES)\n        sys.path_hooks.append(importlib.machinery.FileFinder.path_hook(loader))\n        py_compile.compile(mapping[name])\n        assert os.path.exists(imp.cache_from_source(mapping[name]))\n        yield from bench(name, lambda: sys.modules.pop(name), repeat=repeat,\n                         seconds=seconds)\n\n\ndef _using_bytecode(module):\n    name = module.__name__\n    def using_bytecode_benchmark(seconds, repeat):\n        \"\"\"Source w/ bytecode: {}\"\"\"\n        py_compile.compile(module.__file__)\n        yield from bench(name, lambda: sys.modules.pop(name), repeat=repeat,\n                         seconds=seconds)\n\n    using_bytecode_benchmark.__doc__ = (\n                                using_bytecode_benchmark.__doc__.format(name))\n    return using_bytecode_benchmark\n\ntabnanny_using_bytecode = _using_bytecode(tabnanny)\ndecimal_using_bytecode = _using_bytecode(decimal)\n\n\ndef main(import_, options):\n    if options.source_file:\n        with options.source_file:\n            prev_results = json.load(options.source_file)\n    else:\n        prev_results = {}\n    __builtins__.__import__ = import_\n    benchmarks = (from_cache, builtin_mod,\n                  source_writing_bytecode,\n                  source_wo_bytecode, source_using_bytecode,\n                  tabnanny_writing_bytecode,\n                  tabnanny_wo_bytecode, tabnanny_using_bytecode,\n                  decimal_writing_bytecode,\n                  decimal_wo_bytecode, decimal_using_bytecode,\n                )\n    if options.benchmark:\n        for b in benchmarks:\n            if b.__doc__ == options.benchmark:\n                benchmarks = [b]\n                break\n        else:\n            print('Unknown benchmark: {!r}'.format(options.benchmark,\n                  file=sys.stderr))\n            sys.exit(1)\n    seconds = 1\n    seconds_plural = 's' if seconds > 1 else ''\n    repeat = 3\n    header = ('Measuring imports/second over {} second{}, best out of {}\\n'\n              'Entire benchmark run should take about {} seconds\\n'\n              'Using {!r} as __import__\\n')\n    print(header.format(seconds, seconds_plural, repeat,\n                        len(benchmarks) * seconds * repeat, __import__))\n    new_results = {}\n    for benchmark in benchmarks:\n        print(benchmark.__doc__, \"[\", end=' ')\n        sys.stdout.flush()\n        results = []\n        for result in benchmark(seconds=seconds, repeat=repeat):\n            results.append(result)\n            print(result, end=' ')\n            sys.stdout.flush()\n        assert not sys.dont_write_bytecode\n        print(\"]\", \"best is\", format(max(results), ',d'))\n        new_results[benchmark.__doc__] = results\n    if prev_results:\n        print('\\n\\nComparing new vs. old\\n')\n        for benchmark in benchmarks:\n            benchmark_name = benchmark.__doc__\n            old_result = max(prev_results[benchmark_name])\n            new_result = max(new_results[benchmark_name])\n            result = '{:,d} vs. {:,d} ({:%})'.format(new_result,\n                                                     old_result,\n                                              new_result/old_result)\n            print(benchmark_name, ':', result)\n    if options.dest_file:\n        with options.dest_file:\n            json.dump(new_results, options.dest_file, indent=2)\n\n\nif __name__ == '__main__':\n    import argparse\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-b', '--builtin', dest='builtin', action='store_true',\n                        default=False, help=\"use the built-in __import__\")\n    parser.add_argument('-r', '--read', dest='source_file',\n                        type=argparse.FileType('r'),\n                        help='file to read benchmark data from to compare '\n                             'against')\n    parser.add_argument('-w', '--write', dest='dest_file',\n                        type=argparse.FileType('w'),\n                        help='file to write benchmark data to')\n    parser.add_argument('--benchmark', dest='benchmark',\n                        help='specific benchmark to run')\n    options = parser.parse_args()\n    import_ = __import__\n    if not options.builtin:\n        import_ = importlib.__import__\n\n    main(import_, options)\n", "description": "The Python programming language", "file_name": "importbench.py", "id": "cbce8c87f6dcc0266adb13b87277ca9d", "language": "Python", "project_name": "cpython", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/python-cpython/python-cpython-fe2bbb1/Tools/importbench/importbench.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:51:39Z", "url": "https://github.com/python/cpython", "wiki": false}