{"author": "idank", "code": "import logging, itertools, urllib\nimport markupsafe\n\nfrom flask import render_template, request, redirect\n\nimport bashlex.errors\n\nfrom explainshell import matcher, errors, util, store, config\nfrom explainshell.web import app, helpers\n\nlogger = logging.getLogger(__name__)\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/about')\ndef about():\n    return render_template('about.html')\n\n@app.route('/explain')\ndef explain():\n    if 'cmd' not in request.args or not request.args['cmd'].strip():\n        return redirect('/')\n    command = request.args['cmd'].strip()\n    command = command[:1000] \n    if '\\n' in command:\n        return render_template('errors/error.html', title='parsing error!',\n                               message='no newlines please')\n\n    s = store.store('explainshell', config.MONGO_URI)\n    try:\n        matches, helptext = explaincommand(command, s)\n        return render_template('explain.html',\n                               matches=matches,\n                               helptext=helptext,\n                               getargs=command)\n\n    except errors.ProgramDoesNotExist, e:\n        return render_template('errors/missingmanpage.html', title='missing man page', e=e)\n    except bashlex.errors.ParsingError, e:\n        logger.warn('%r parsing error: %s', command, e.message)\n        return render_template('errors/parsingerror.html', title='parsing error!', e=e)\n    except NotImplementedError, e:\n        logger.warn('not implemented error trying to explain %r', command)\n        msg = (\"the parser doesn't support %r constructs in the command you tried. you may \"\n               \"<a href='https://github.com/idank/explainshell/issues'>report a \"\n               \"bug</a> to have this added, if one doesn't already exist.\") % e.args[0]\n\n        return render_template('errors/error.html', title='error!', message=msg)\n    except:\n        logger.error('uncaught exception trying to explain %r', command, exc_info=True)\n        msg = 'something went wrong... this was logged and will be checked'\n        return render_template('errors/error.html', title='error!', message=msg)\n\n@app.route('/explain/<program>', defaults={'section' : None})\n@app.route('/explain/<section>/<program>')\ndef explainold(section, program):\n    logger.info('/explain section=%r program=%r', section, program)\n\n    s = store.store('explainshell', config.MONGO_URI)\n    if section is not None:\n        program = '%s.%s' % (program, section)\n\n    \n    if 'args' in request.args:\n        args = request.args['args']\n        command = '%s %s' % (program, args)\n        return redirect('/explain?cmd=%s' % urllib.quote_plus(command), 301)\n    else:\n        try:\n            mp, suggestions = explainprogram(program, s)\n            return render_template('options.html', mp=mp, suggestions=suggestions)\n        except errors.ProgramDoesNotExist, e:\n            return render_template('errors/missingmanpage.html', title='missing man page', e=e)\n\ndef explainprogram(program, store):\n    mps = store.findmanpage(program)\n    mp = mps.pop(0)\n    program = mp.namesection\n\n    synopsis = mp.synopsis\n    if synopsis:\n        synopsis = synopsis.decode('utf-8')\n\n    mp = {'source' : mp.source[:-3],\n          'section' : mp.section,\n          'program' : program,\n          'synopsis' : synopsis,\n          'options' : [o.text.decode('utf-8') for o in mp.options]}\n\n    suggestions = []\n    for othermp in mps:\n        d = {'text' : othermp.namesection,\n             'link' : '%s/%s' % (othermp.section, othermp.name)}\n        suggestions.append(d)\n    logger.info('suggestions: %s', suggestions)\n    return mp, suggestions\n\ndef _makematch(start, end, match, commandclass, helpclass):\n    return {'match' : match, 'start' : start, 'end' : end, 'spaces' : '',\n            'commandclass' : commandclass, 'helpclass' : helpclass}\n\ndef explaincommand(command, store):\n    matcher_ = matcher.matcher(command, store)\n    groups = matcher_.match()\n    expansions = matcher_.expansions\n\n    shellgroup = groups[0]\n    commandgroups = groups[1:]\n    matches = []\n\n    \n    \n    texttoid = {}\n\n    \n    \n    \n    idstartpos = {}\n\n    l = []\n    for m in shellgroup.results:\n        commandclass = shellgroup.name\n        helpclass = 'help-%d' % len(texttoid)\n        text = m.text\n        if text:\n            text = text.decode('utf-8')\n            helpclass = texttoid.setdefault(text, helpclass)\n        else:\n            \n            \n            commandclass += ' unknown'\n            helpclass = ''\n        if helpclass:\n            idstartpos.setdefault(helpclass, m.start)\n\n        d = _makematch(m.start, m.end, m.match, commandclass, helpclass)\n        formatmatch(d, m, expansions)\n\n        l.append(d)\n    matches.append(l)\n\n    for commandgroup in commandgroups:\n        l = []\n        for m in commandgroup.results:\n            commandclass = commandgroup.name\n            helpclass = 'help-%d' % len(texttoid)\n            text = m.text\n            if text:\n                text = text.decode('utf-8')\n                helpclass = texttoid.setdefault(text, helpclass)\n            else:\n                commandclass += ' unknown'\n                helpclass = ''\n            if helpclass:\n                idstartpos.setdefault(helpclass, m.start)\n\n            d = _makematch(m.start, m.end, m.match, commandclass, helpclass)\n            formatmatch(d, m, expansions)\n\n            l.append(d)\n\n        d = l[0]\n        d['commandclass'] += ' simplecommandstart'\n        if commandgroup.manpage:\n            d['name'] = commandgroup.manpage.name\n            d['section'] = commandgroup.manpage.section\n            if '.' not in d['match']:\n                d['match'] = '%s(%s)' % (d['match'], d['section'])\n            d['suggestions'] = commandgroup.suggestions\n            d['source'] = commandgroup.manpage.source[:-5]\n        matches.append(l)\n\n    matches = list(itertools.chain.from_iterable(matches))\n    helpers.suggestions(matches, command)\n\n    # _checkoverlaps(matcher_.s, matches)\n    matches.sort(key=lambda d: d['start'])\n\n    it = util.peekable(iter(matches))\n    while it.hasnext():\n        m = it.next()\n        spaces = 0\n        if it.hasnext():\n            spaces = it.peek()['start'] - m['end']\n        m['spaces'] = ' ' * spaces\n\n    helptext = sorted(texttoid.iteritems(), key=lambda (k, v): idstartpos[v])\n\n    return matches, helptext\n\ndef formatmatch(d, m, expansions):\n    '''populate the match field in d by escaping m.match and generating\n    links to any command/process substitutions'''\n\n    \n    ?\n    hassubsinmatch = False\n\n    for start, end, kind in expansions:\n        if m.start <= start and end <= m.end:\n            hassubsinmatch = True\n            break\n\n    \n    if not hassubsinmatch:\n        d['match'] = markupsafe.escape(m.match)\n        return\n\n    \n    d['commandclass'] += ' hasexpansion'\n\n    \n    \n    expandedmatch = ''\n    i = 0\n    for start, end, kind in expansions:\n        if start >= m.end:\n            break\n        relativestart = start - m.start\n        relativeend = end - m.start\n\n        if i < relativestart:\n            for j in range(i, relativestart):\n                if m.match[j].isspace():\n                    expandedmatch += markupsafe.Markup('&nbsp;')\n                else:\n                    expandedmatch += markupsafe.escape(m.match[j])\n            i = relativestart + 1\n        if m.start <= start and end <= m.end:\n            s = m.match[relativestart:relativeend]\n\n            if kind == 'substitution':\n                content = markupsafe.Markup(_substitutionmarkup(s))\n            else:\n                content = s\n\n            expandedmatch += markupsafe.Markup(\n                    '<span class=\"expansion-{0}\">{1}</span>').format(kind, content)\n            i = relativeend\n\n    if i < len(m.match):\n        expandedmatch += markupsafe.escape(m.match[i:])\n\n    assert expandedmatch\n    d['match'] = expandedmatch\n\ndef _substitutionmarkup(cmd):\n    '''\n    >>> _substitutionmarkup('foo')\n    '<a href=\"/explain?cmd=foo\" title=\"Zoom in to nested command\">foo</a>'\n    >>> _substitutionmarkup('cat <&3')\n    '<a href=\"/explain?cmd=cat+%3C%263\" title=\"Zoom in to nested command\">cat <&3</a>'\n    '''\n    encoded = urllib.urlencode({'cmd': cmd})\n    return ('<a href=\"/explain?{query}\" title=\"Zoom in to nested command\">{cmd}'\n            '</a>').format(cmd=cmd, query=encoded)\n\ndef _checkoverlaps(s, matches):\n    explained = [None]*len(s)\n    for d in matches:\n        for i in range(d['start'], d['end']):\n            if explained[i]:\n                raise RuntimeError(\"explained overlap for group %s at %d with %s\" % (d, i, explained[i]))\n            explained[i] = d\n", "comments": "   populate match field escaping match generating     links command process substitutions           save us work later  expansions overlap       current match      hassubsinmatch   false      start  end  kind expansions          start    start end    end              hassubsinmatch   true             break         escape current match     hassubsinmatch           match     markupsafe escape(m match)         return        used es js      commandclass        hasexpansion         go expansions  wrapping link  leave everything else       untouched     expandedmatch            0     start  end  kind expansions          start    end              break         relativestart   start   start         relativeend   end   start            relativestart              j range(i  relativestart)                  match j  isspace()                      expandedmatch    markupsafe markup(  nbsp  )                 else                      expandedmatch    markupsafe escape(m match j )               relativestart   1         start    start end    end                match relativestart relativeend               kind     substitution                   content   markupsafe markup( substitutionmarkup(s))             else                  content                expandedmatch    markupsafe markup(                       span class  expansion  0    1   span  ) format(kind  content)               relativeend        len(m match)          expandedmatch    markupsafe escape(m match  )      assert expandedmatch      match     expandedmatch  def  substitutionmarkup(cmd)                   substitutionmarkup( foo )       href   explain cmd foo  title  zoom nested command  foo             substitutionmarkup( cat   3 )       href   explain cmd cat  3c 263  title  zoom nested command  cat   3               trim commands longer 1000 characters    keep links old urls alive    save mapping help text assigned id     going reuse ids text    remember assigned id started source     going use later sort help text start    position    unknowns shell group possible parser left    unparsed remainder  see matcher  markunparsedunknown     checkoverlaps(matcher   matches)    save us work later  expansions overlap    current match      escape current match    used es js    go expansions  wrapping link  leave everything else    untouched ", "content": "import logging, itertools, urllib\nimport markupsafe\n\nfrom flask import render_template, request, redirect\n\nimport bashlex.errors\n\nfrom explainshell import matcher, errors, util, store, config\nfrom explainshell.web import app, helpers\n\nlogger = logging.getLogger(__name__)\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/about')\ndef about():\n    return render_template('about.html')\n\n@app.route('/explain')\ndef explain():\n    if 'cmd' not in request.args or not request.args['cmd'].strip():\n        return redirect('/')\n    command = request.args['cmd'].strip()\n    command = command[:1000] # trim commands longer than 1000 characters\n    if '\\n' in command:\n        return render_template('errors/error.html', title='parsing error!',\n                               message='no newlines please')\n\n    s = store.store('explainshell', config.MONGO_URI)\n    try:\n        matches, helptext = explaincommand(command, s)\n        return render_template('explain.html',\n                               matches=matches,\n                               helptext=helptext,\n                               getargs=command)\n\n    except errors.ProgramDoesNotExist, e:\n        return render_template('errors/missingmanpage.html', title='missing man page', e=e)\n    except bashlex.errors.ParsingError, e:\n        logger.warn('%r parsing error: %s', command, e.message)\n        return render_template('errors/parsingerror.html', title='parsing error!', e=e)\n    except NotImplementedError, e:\n        logger.warn('not implemented error trying to explain %r', command)\n        msg = (\"the parser doesn't support %r constructs in the command you tried. you may \"\n               \"<a href='https://github.com/idank/explainshell/issues'>report a \"\n               \"bug</a> to have this added, if one doesn't already exist.\") % e.args[0]\n\n        return render_template('errors/error.html', title='error!', message=msg)\n    except:\n        logger.error('uncaught exception trying to explain %r', command, exc_info=True)\n        msg = 'something went wrong... this was logged and will be checked'\n        return render_template('errors/error.html', title='error!', message=msg)\n\n@app.route('/explain/<program>', defaults={'section' : None})\n@app.route('/explain/<section>/<program>')\ndef explainold(section, program):\n    logger.info('/explain section=%r program=%r', section, program)\n\n    s = store.store('explainshell', config.MONGO_URI)\n    if section is not None:\n        program = '%s.%s' % (program, section)\n\n    # keep links to old urls alive\n    if 'args' in request.args:\n        args = request.args['args']\n        command = '%s %s' % (program, args)\n        return redirect('/explain?cmd=%s' % urllib.quote_plus(command), 301)\n    else:\n        try:\n            mp, suggestions = explainprogram(program, s)\n            return render_template('options.html', mp=mp, suggestions=suggestions)\n        except errors.ProgramDoesNotExist, e:\n            return render_template('errors/missingmanpage.html', title='missing man page', e=e)\n\ndef explainprogram(program, store):\n    mps = store.findmanpage(program)\n    mp = mps.pop(0)\n    program = mp.namesection\n\n    synopsis = mp.synopsis\n    if synopsis:\n        synopsis = synopsis.decode('utf-8')\n\n    mp = {'source' : mp.source[:-3],\n          'section' : mp.section,\n          'program' : program,\n          'synopsis' : synopsis,\n          'options' : [o.text.decode('utf-8') for o in mp.options]}\n\n    suggestions = []\n    for othermp in mps:\n        d = {'text' : othermp.namesection,\n             'link' : '%s/%s' % (othermp.section, othermp.name)}\n        suggestions.append(d)\n    logger.info('suggestions: %s', suggestions)\n    return mp, suggestions\n\ndef _makematch(start, end, match, commandclass, helpclass):\n    return {'match' : match, 'start' : start, 'end' : end, 'spaces' : '',\n            'commandclass' : commandclass, 'helpclass' : helpclass}\n\ndef explaincommand(command, store):\n    matcher_ = matcher.matcher(command, store)\n    groups = matcher_.match()\n    expansions = matcher_.expansions\n\n    shellgroup = groups[0]\n    commandgroups = groups[1:]\n    matches = []\n\n    # save a mapping between the help text to its assigned id,\n    # we're going to reuse ids that have the same text\n    texttoid = {}\n\n    # remember where each assigned id has started in the source,\n    # we're going to use it later on to sort the help text by start\n    # position\n    idstartpos = {}\n\n    l = []\n    for m in shellgroup.results:\n        commandclass = shellgroup.name\n        helpclass = 'help-%d' % len(texttoid)\n        text = m.text\n        if text:\n            text = text.decode('utf-8')\n            helpclass = texttoid.setdefault(text, helpclass)\n        else:\n            # unknowns in the shell group are possible when our parser left\n            # an unparsed remainder, see matcher._markunparsedunknown\n            commandclass += ' unknown'\n            helpclass = ''\n        if helpclass:\n            idstartpos.setdefault(helpclass, m.start)\n\n        d = _makematch(m.start, m.end, m.match, commandclass, helpclass)\n        formatmatch(d, m, expansions)\n\n        l.append(d)\n    matches.append(l)\n\n    for commandgroup in commandgroups:\n        l = []\n        for m in commandgroup.results:\n            commandclass = commandgroup.name\n            helpclass = 'help-%d' % len(texttoid)\n            text = m.text\n            if text:\n                text = text.decode('utf-8')\n                helpclass = texttoid.setdefault(text, helpclass)\n            else:\n                commandclass += ' unknown'\n                helpclass = ''\n            if helpclass:\n                idstartpos.setdefault(helpclass, m.start)\n\n            d = _makematch(m.start, m.end, m.match, commandclass, helpclass)\n            formatmatch(d, m, expansions)\n\n            l.append(d)\n\n        d = l[0]\n        d['commandclass'] += ' simplecommandstart'\n        if commandgroup.manpage:\n            d['name'] = commandgroup.manpage.name\n            d['section'] = commandgroup.manpage.section\n            if '.' not in d['match']:\n                d['match'] = '%s(%s)' % (d['match'], d['section'])\n            d['suggestions'] = commandgroup.suggestions\n            d['source'] = commandgroup.manpage.source[:-5]\n        matches.append(l)\n\n    matches = list(itertools.chain.from_iterable(matches))\n    helpers.suggestions(matches, command)\n\n    # _checkoverlaps(matcher_.s, matches)\n    matches.sort(key=lambda d: d['start'])\n\n    it = util.peekable(iter(matches))\n    while it.hasnext():\n        m = it.next()\n        spaces = 0\n        if it.hasnext():\n            spaces = it.peek()['start'] - m['end']\n        m['spaces'] = ' ' * spaces\n\n    helptext = sorted(texttoid.iteritems(), key=lambda (k, v): idstartpos[v])\n\n    return matches, helptext\n\ndef formatmatch(d, m, expansions):\n    '''populate the match field in d by escaping m.match and generating\n    links to any command/process substitutions'''\n\n    # save us some work later: do any expansions overlap\n    # the current match?\n    hassubsinmatch = False\n\n    for start, end, kind in expansions:\n        if m.start <= start and end <= m.end:\n            hassubsinmatch = True\n            break\n\n    # if not, just escape the current match\n    if not hassubsinmatch:\n        d['match'] = markupsafe.escape(m.match)\n        return\n\n    # used in es.js\n    d['commandclass'] += ' hasexpansion'\n\n    # go over the expansions, wrapping them with a link; leave everything else\n    # untouched\n    expandedmatch = ''\n    i = 0\n    for start, end, kind in expansions:\n        if start >= m.end:\n            break\n        relativestart = start - m.start\n        relativeend = end - m.start\n\n        if i < relativestart:\n            for j in range(i, relativestart):\n                if m.match[j].isspace():\n                    expandedmatch += markupsafe.Markup('&nbsp;')\n                else:\n                    expandedmatch += markupsafe.escape(m.match[j])\n            i = relativestart + 1\n        if m.start <= start and end <= m.end:\n            s = m.match[relativestart:relativeend]\n\n            if kind == 'substitution':\n                content = markupsafe.Markup(_substitutionmarkup(s))\n            else:\n                content = s\n\n            expandedmatch += markupsafe.Markup(\n                    '<span class=\"expansion-{0}\">{1}</span>').format(kind, content)\n            i = relativeend\n\n    if i < len(m.match):\n        expandedmatch += markupsafe.escape(m.match[i:])\n\n    assert expandedmatch\n    d['match'] = expandedmatch\n\ndef _substitutionmarkup(cmd):\n    '''\n    >>> _substitutionmarkup('foo')\n    '<a href=\"/explain?cmd=foo\" title=\"Zoom in to nested command\">foo</a>'\n    >>> _substitutionmarkup('cat <&3')\n    '<a href=\"/explain?cmd=cat+%3C%263\" title=\"Zoom in to nested command\">cat <&3</a>'\n    '''\n    encoded = urllib.urlencode({'cmd': cmd})\n    return ('<a href=\"/explain?{query}\" title=\"Zoom in to nested command\">{cmd}'\n            '</a>').format(cmd=cmd, query=encoded)\n\ndef _checkoverlaps(s, matches):\n    explained = [None]*len(s)\n    for d in matches:\n        for i in range(d['start'], d['end']):\n            if explained[i]:\n                raise RuntimeError(\"explained overlap for group %s at %d with %s\" % (d, i, explained[i]))\n            explained[i] = d\n", "description": "match command-line arguments to their help text", "file_name": "views.py", "id": "fee5b5993ae1a3cacf7a99e1c98d7e5f", "language": "Python", "project_name": "explainshell", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/idank-explainshell/idank-explainshell-697e1d1/explainshell/web/views.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:42:42Z", "url": "https://github.com/idank/explainshell", "wiki": true}