{"author": "idank", "code": "import textwrap, logging\n\nfrom explainshell import util\n\nclass basefixer(object):\n    '''The base fixer class which other fixers inherit from.\n\n    Subclasses override the base methods in order to fix manpage content during\n    different parts of the parsing/classifying/saving process.'''\n    runbefore = []\n    runlast = False\n\n    def __init__(self, mctx):\n        self.mctx = mctx\n        self.run = True\n        self.logger = logging.getLogger(self.__class__.__name__)\n\n    def pre_get_raw_manpage(self):\n        pass\n\n    def pre_parse_manpage(self):\n        pass\n\n    def post_parse_manpage(self):\n        pass\n\n    def pre_classify(self):\n        pass\n\n    def post_classify(self):\n        pass\n\n    def post_option_extraction(self):\n        pass\n\n    def pre_add_manpage(self):\n        pass\n\nfixerscls = []\nfixerspriority = {}\n\nclass runner(object):\n    '''The runner coordinates the fixers.'''\n    def __init__(self, mctx):\n        self.mctx = mctx\n        self.fixers = [f(mctx) for f in fixerscls]\n\n    def disable(self, name):\n        before = len(self.fixers)\n        self.fixers = [f for f in self.fixers if f.__class__.__name__ != name]\n        if before == len(self.fixers):\n            raise ValueError('fixer %r not found' % name)\n\n    def _fixers(self):\n        return (f for f in self.fixers if f.run)\n\n    def pre_get_raw_manpage(self):\n        for f in self._fixers():\n            f.pre_get_raw_manpage()\n\n    def pre_parse_manpage(self):\n        for f in self._fixers():\n            f.pre_parse_manpage()\n\n    def post_parse_manpage(self):\n        for f in self._fixers():\n            f.post_parse_manpage()\n\n    def pre_classify(self):\n        for f in self._fixers():\n            f.pre_classify()\n\n    def post_classify(self):\n        for f in self._fixers():\n            f.post_classify()\n\n    def post_option_extraction(self):\n        for f in self._fixers():\n            f.post_option_extraction()\n\n    def pre_add_manpage(self):\n        for f in self._fixers():\n            f.pre_add_manpage()\n\ndef register(fixercls):\n    fixerscls.append(fixercls)\n    for f in fixercls.runbefore:\n        if not hasattr(f, '_parents'):\n            f._parents = []\n        f._parents.append(fixercls)\n    return fixercls\n\n@register\nclass bulletremover(basefixer):\n    '''remove list bullets from paragraph start, see mysqlslap.1'''\n    def post_parse_manpage(self):\n        toremove = []\n        for i, p in enumerate(self.mctx.manpage.paragraphs):\n            try:\n                idx = p.text.index('\\xc2\\xb7')\n                p.text = p.text[:idx] + p.text[idx+2:]\n                if not p.text.strip():\n                    toremove.append(i)\n            except ValueError:\n                pass\n        for i in reversed(toremove):\n            del self.mctx.manpage.paragraphs[i]\n\n@register\nclass leadingspaceremover(basefixer):\n    '''go over all known option paragraphs and remove their leading spaces\n    by the amount of spaces in the first line'''\n\n    def post_option_extraction(self):\n        for i, p in enumerate(self.mctx.manpage.options):\n            text = self._removewhitespace(p.text)\n            p.text = text\n\n    def _removewhitespace(self, text):\n        '''\n        >>> f = leadingspaceremover(None)\n        >>> f._removewhitespace(' a\\\\n  b ')\n        'a\\\\n b'\n        >>> f._removewhitespace('\\\\t a\\\\n\\\\t \\\\tb')\n        'a\\\\n\\\\tb'\n        '''\n        return textwrap.dedent(text).rstrip()\n\n@register\nclass tarfixer(basefixer):\n    def __init__(self, *args):\n        super(tarfixer, self).__init__(*args)\n        self.run = self.mctx.name == 'tar'\n\n    def pre_add_manpage(self):\n        self.mctx.manpage.partialmatch = True\n\n@register\nclass paragraphjoiner(basefixer):\n    runbefore = [leadingspaceremover]\n    maxdistance = 5\n\n    def post_option_extraction(self):\n        options = [p for p in self.mctx.manpage.paragraphs if p.is_option]\n        self._join(self.mctx.manpage.paragraphs, options)\n\n    def _join(self, paragraphs, options):\n        def _paragraphsbetween(op1, op2):\n            assert op1.idx < op2.idx\n            r = []\n            start = None\n            for i, p in enumerate(paragraphs):\n                if op1.idx < p.idx < op2.idx:\n                    if not r:\n                        start = i\n                    r.append(p)\n            return r, start\n\n        totalmerged = 0\n        for curr, next in util.pairwise(options):\n            between, start = _paragraphsbetween(curr, next)\n            if curr.section == next.section and 1 <= len(between) < self.maxdistance:\n                self.logger.info('merging paragraphs %d through %d (inclusive)', curr.idx, next.idx-1)\n                newdesc = [curr.text.rstrip()]\n                newdesc.extend([p.text.rstrip() for p in between])\n                curr.text = '\\n\\n'.join(newdesc)\n                del paragraphs[start:start+len(between)]\n                totalmerged += len(between)\n        return totalmerged\n\n@register\nclass optiontrimmer(basefixer):\n    runbefore = [paragraphjoiner]\n\n    d = {'git-rebase' : (50, -1)}\n\n    def __init__(self, mctx):\n        super(optiontrimmer, self).__init__(mctx)\n        self.run = self.mctx.name in self.d\n\n    def post_classify(self):\n        start, end = self.d[self.mctx.name]\n        classifiedoptions = [p for p in self.mctx.manpage.paragraphs if p.is_option]\n        assert classifiedoptions\n        if end == -1:\n            end = classifiedoptions[-1].idx\n        else:\n            assert start > end\n\n        for p in classifiedoptions:\n            if not (start <= p.idx <= end):\n                p.is_option = False\n                self.logger.info('removing option %r', p)\n\ndef _parents(fixercls):\n    p = getattr(fixercls, '_parents', [])\n    last = fixercls.runlast\n\n    if last and p:\n        raise ValueError(\"%s can't be last and also run before someone else\" % fixercls.__name__)\n\n    if last:\n        return [f for f in fixerscls if f is not fixercls]\n    return p\n\nfixerscls = util.toposorted(fixerscls, _parents)\n", "comments": "   the base fixer class fixers inherit       subclasses override base methods order fix manpage content     different parts parsing classifying saving process         runbefore          runlast   false      def   init  (self  mctx)          self mctx   mctx         self run   true         self logger   logging getlogger(self   class     name  )      def pre get raw manpage(self)          pass      def pre parse manpage(self)          pass      def post parse manpage(self)          pass      def pre classify(self)          pass      def post classify(self)          pass      def post option extraction(self)          pass      def pre add manpage(self)          pass  fixerscls      fixerspriority       class runner(object)         the runner coordinates fixers         def   init  (self  mctx)          self mctx   mctx         self fixers    f(mctx) f fixerscls       def disable(self  name)            len(self fixers)         self fixers    f f self fixers f   class     name      name             len(self fixers)              raise valueerror( fixer  r found    name)      def  fixers(self)          return (f f self fixers f run)      def pre get raw manpage(self)          f self  fixers()              f pre get raw manpage()      def pre parse manpage(self)          f self  fixers()              f pre parse manpage()      def post parse manpage(self)          f self  fixers()              f post parse manpage()      def pre classify(self)          f self  fixers()              f pre classify()      def post classify(self)          f self  fixers()              f post classify()      def post option extraction(self)          f self  fixers()              f post option extraction()      def pre add manpage(self)          f self  fixers()              f pre add manpage()  def register(fixercls)      fixerscls append(fixercls)     f fixercls runbefore          hasattr(f    parents )              f  parents              f  parents append(fixercls)     return fixercls   register class bulletremover(basefixer)         remove list bullets paragraph start  see mysqlslap 1        def post parse manpage(self)          toremove               p enumerate(self mctx manpage paragraphs)              try                  idx   p text index(  xc2 xb7 )                 p text   p text  idx    p text idx 2                   p text strip()                      toremove append(i)             except valueerror                  pass         reversed(toremove)              del self mctx manpage paragraphs    register class leadingspaceremover(basefixer)         go known option paragraphs remove leading spaces     amount spaces first line         def post option extraction(self)           p enumerate(self mctx manpage options)              text   self  removewhitespace(p text)             p text   text      def  removewhitespace(self  text)                          f   leadingspaceremover(none)             f  removewhitespace(   n  b  )           n b              f  removewhitespace(    n    tb )           n  tb              ", "content": "import textwrap, logging\n\nfrom explainshell import util\n\nclass basefixer(object):\n    '''The base fixer class which other fixers inherit from.\n\n    Subclasses override the base methods in order to fix manpage content during\n    different parts of the parsing/classifying/saving process.'''\n    runbefore = []\n    runlast = False\n\n    def __init__(self, mctx):\n        self.mctx = mctx\n        self.run = True\n        self.logger = logging.getLogger(self.__class__.__name__)\n\n    def pre_get_raw_manpage(self):\n        pass\n\n    def pre_parse_manpage(self):\n        pass\n\n    def post_parse_manpage(self):\n        pass\n\n    def pre_classify(self):\n        pass\n\n    def post_classify(self):\n        pass\n\n    def post_option_extraction(self):\n        pass\n\n    def pre_add_manpage(self):\n        pass\n\nfixerscls = []\nfixerspriority = {}\n\nclass runner(object):\n    '''The runner coordinates the fixers.'''\n    def __init__(self, mctx):\n        self.mctx = mctx\n        self.fixers = [f(mctx) for f in fixerscls]\n\n    def disable(self, name):\n        before = len(self.fixers)\n        self.fixers = [f for f in self.fixers if f.__class__.__name__ != name]\n        if before == len(self.fixers):\n            raise ValueError('fixer %r not found' % name)\n\n    def _fixers(self):\n        return (f for f in self.fixers if f.run)\n\n    def pre_get_raw_manpage(self):\n        for f in self._fixers():\n            f.pre_get_raw_manpage()\n\n    def pre_parse_manpage(self):\n        for f in self._fixers():\n            f.pre_parse_manpage()\n\n    def post_parse_manpage(self):\n        for f in self._fixers():\n            f.post_parse_manpage()\n\n    def pre_classify(self):\n        for f in self._fixers():\n            f.pre_classify()\n\n    def post_classify(self):\n        for f in self._fixers():\n            f.post_classify()\n\n    def post_option_extraction(self):\n        for f in self._fixers():\n            f.post_option_extraction()\n\n    def pre_add_manpage(self):\n        for f in self._fixers():\n            f.pre_add_manpage()\n\ndef register(fixercls):\n    fixerscls.append(fixercls)\n    for f in fixercls.runbefore:\n        if not hasattr(f, '_parents'):\n            f._parents = []\n        f._parents.append(fixercls)\n    return fixercls\n\n@register\nclass bulletremover(basefixer):\n    '''remove list bullets from paragraph start, see mysqlslap.1'''\n    def post_parse_manpage(self):\n        toremove = []\n        for i, p in enumerate(self.mctx.manpage.paragraphs):\n            try:\n                idx = p.text.index('\\xc2\\xb7')\n                p.text = p.text[:idx] + p.text[idx+2:]\n                if not p.text.strip():\n                    toremove.append(i)\n            except ValueError:\n                pass\n        for i in reversed(toremove):\n            del self.mctx.manpage.paragraphs[i]\n\n@register\nclass leadingspaceremover(basefixer):\n    '''go over all known option paragraphs and remove their leading spaces\n    by the amount of spaces in the first line'''\n\n    def post_option_extraction(self):\n        for i, p in enumerate(self.mctx.manpage.options):\n            text = self._removewhitespace(p.text)\n            p.text = text\n\n    def _removewhitespace(self, text):\n        '''\n        >>> f = leadingspaceremover(None)\n        >>> f._removewhitespace(' a\\\\n  b ')\n        'a\\\\n b'\n        >>> f._removewhitespace('\\\\t a\\\\n\\\\t \\\\tb')\n        'a\\\\n\\\\tb'\n        '''\n        return textwrap.dedent(text).rstrip()\n\n@register\nclass tarfixer(basefixer):\n    def __init__(self, *args):\n        super(tarfixer, self).__init__(*args)\n        self.run = self.mctx.name == 'tar'\n\n    def pre_add_manpage(self):\n        self.mctx.manpage.partialmatch = True\n\n@register\nclass paragraphjoiner(basefixer):\n    runbefore = [leadingspaceremover]\n    maxdistance = 5\n\n    def post_option_extraction(self):\n        options = [p for p in self.mctx.manpage.paragraphs if p.is_option]\n        self._join(self.mctx.manpage.paragraphs, options)\n\n    def _join(self, paragraphs, options):\n        def _paragraphsbetween(op1, op2):\n            assert op1.idx < op2.idx\n            r = []\n            start = None\n            for i, p in enumerate(paragraphs):\n                if op1.idx < p.idx < op2.idx:\n                    if not r:\n                        start = i\n                    r.append(p)\n            return r, start\n\n        totalmerged = 0\n        for curr, next in util.pairwise(options):\n            between, start = _paragraphsbetween(curr, next)\n            if curr.section == next.section and 1 <= len(between) < self.maxdistance:\n                self.logger.info('merging paragraphs %d through %d (inclusive)', curr.idx, next.idx-1)\n                newdesc = [curr.text.rstrip()]\n                newdesc.extend([p.text.rstrip() for p in between])\n                curr.text = '\\n\\n'.join(newdesc)\n                del paragraphs[start:start+len(between)]\n                totalmerged += len(between)\n        return totalmerged\n\n@register\nclass optiontrimmer(basefixer):\n    runbefore = [paragraphjoiner]\n\n    d = {'git-rebase' : (50, -1)}\n\n    def __init__(self, mctx):\n        super(optiontrimmer, self).__init__(mctx)\n        self.run = self.mctx.name in self.d\n\n    def post_classify(self):\n        start, end = self.d[self.mctx.name]\n        classifiedoptions = [p for p in self.mctx.manpage.paragraphs if p.is_option]\n        assert classifiedoptions\n        if end == -1:\n            end = classifiedoptions[-1].idx\n        else:\n            assert start > end\n\n        for p in classifiedoptions:\n            if not (start <= p.idx <= end):\n                p.is_option = False\n                self.logger.info('removing option %r', p)\n\ndef _parents(fixercls):\n    p = getattr(fixercls, '_parents', [])\n    last = fixercls.runlast\n\n    if last and p:\n        raise ValueError(\"%s can't be last and also run before someone else\" % fixercls.__name__)\n\n    if last:\n        return [f for f in fixerscls if f is not fixercls]\n    return p\n\nfixerscls = util.toposorted(fixerscls, _parents)\n", "description": "match command-line arguments to their help text", "file_name": "fixer.py", "id": "b5bfda46862122430d8933203e4a07bb", "language": "Python", "project_name": "explainshell", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/idank-explainshell/idank-explainshell-697e1d1/explainshell/fixer.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:42:42Z", "url": "https://github.com/idank/explainshell", "wiki": true}