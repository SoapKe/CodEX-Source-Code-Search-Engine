{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nimport json\n\nimport requests\n\nfrom odoo import api, fields, models\nfrom odoo.exceptions import AccessDenied, UserError\nfrom odoo.addons.auth_signup.models.res_users import SignupError\n\nfrom odoo.addons import base\nbase.res.res_users.USER_PRIVATE_FIELDS.append('oauth_access_token')\n\nclass ResUsers(models.Model):\n    _inherit = 'res.users'\n\n    oauth_provider_id = fields.Many2one('auth.oauth.provider', string='OAuth Provider')\n    oauth_uid = fields.Char(string='OAuth User ID', help=\"Oauth Provider user_id\", copy=False)\n    oauth_access_token = fields.Char(string='OAuth Access Token', readonly=True, copy=False)\n\n    _sql_constraints = [\n        ('uniq_users_oauth_provider_oauth_uid', 'unique(oauth_provider_id, oauth_uid)', 'OAuth UID must be unique per provider'),\n    ]\n\n    @api.model\n    def _auth_oauth_rpc(self, endpoint, access_token):\n        return requests.get(endpoint, params={'access_token': access_token}).json()\n\n    @api.model\n    def _auth_oauth_validate(self, provider, access_token):\n        \"\"\" return the validation data corresponding to the access token \"\"\"\n        oauth_provider = self.env['auth.oauth.provider'].browse(provider)\n        validation = self._auth_oauth_rpc(oauth_provider.validation_endpoint, access_token)\n        if validation.get(\"error\"):\n            raise Exception(validation['error'])\n        if oauth_provider.data_endpoint:\n            data = self._auth_oauth_rpc(oauth_provider.data_endpoint, access_token)\n            validation.update(data)\n        return validation\n\n    @api.model\n    def _generate_signup_values(self, provider, validation, params):\n        oauth_uid = validation['user_id']\n        email = validation.get('email', 'provider_%s_user_%s' % (provider, oauth_uid))\n        name = validation.get('name', email)\n        return {\n            'name': name,\n            'login': email,\n            'email': email,\n            'oauth_provider_id': provider,\n            'oauth_uid': oauth_uid,\n            'oauth_access_token': params['access_token'],\n            'active': True,\n        }\n\n    @api.model\n    def _auth_oauth_signin(self, provider, validation, params):\n        \"\"\" retrieve and sign in the user corresponding to provider and validated access token\n            :param provider: oauth provider id (int)\n            :param validation: result of validation of access token (dict)\n            :param params: oauth parameters (dict)\n            :return: user login (str)\n            :raise: AccessDenied if signin failed\n\n            This method can be overridden to add alternative signin methods.\n        \"\"\"\n        oauth_uid = validation['user_id']\n        try:\n            oauth_user = self.search([(\"oauth_uid\", \"=\", oauth_uid), ('oauth_provider_id', '=', provider)])\n            if not oauth_user:\n                raise AccessDenied()\n            assert len(oauth_user) == 1\n            oauth_user.write({'oauth_access_token': params['access_token']})\n            return oauth_user.login\n        except AccessDenied as access_denied_exception:\n            if self.env.context.get('no_user_creation'):\n                return None\n            state = json.loads(params['state'])\n            token = state.get('t')\n            values = self._generate_signup_values(provider, validation, params)\n            try:\n                _, login, _ = self.signup(values, token)\n                return login\n            except (SignupError, UserError):\n                raise access_denied_exception\n\n    @api.model\n    def auth_oauth(self, provider, params):\n        # Advice by Google (to avoid Confused Deputy Problem)\n        \n        ()\n        \n        \n        access_token = params.get('access_token')\n        validation = self._auth_oauth_validate(provider, access_token)\n        \n        if not validation.get('user_id'):\n            \n            if validation.get('id'):\n                validation['user_id'] = validation['id']\n            else:\n                raise AccessDenied()\n\n        \n        login = self._auth_oauth_signin(provider, validation, params)\n        if not login:\n            raise AccessDenied()\n        \n        return (self.env.cr.dbname, login, access_token)\n\n    @api.model\n    def check_credentials(self, password):\n        try:\n            return super(ResUsers, self).check_credentials(password)\n        except AccessDenied:\n            res = self.sudo().search([('id', '=', self.env.uid), ('oauth_access_token', '=', password)])\n            if not res:\n                raise\n", "comments": "    return validation data corresponding access token             oauth provider   self env  auth oauth provider   browse(provider)         validation   self  auth oauth rpc(oauth provider validation endpoint  access token)         validation get( error )              raise exception(validation  error  )         oauth provider data endpoint              data   self  auth oauth rpc(oauth provider data endpoint  access token)             validation update(data)         return validation       api model     def  generate signup values(self  provider  validation  params)          oauth uid   validation  user id           email   validation get( email    provider  user     (provider  oauth uid))         name   validation get( name   email)         return                name   name               login   email               email   email               oauth provider id   provider               oauth uid   oauth uid               oauth access token   params  access token                 active   true                  api model     def  auth oauth signin(self  provider  validation  params)              retrieve sign user corresponding provider validated access token              param provider  oauth provider id (int)              param validation  result validation access token (dict)              param params  oauth parameters (dict)              return  user login (str)              raise  accessdenied signin failed              this method overridden add alternative signin methods                     coding  utf 8        part odoo  see license file full copyright licensing details     advice google (to avoid confused deputy problem)    validation audience    our client id       abort()    else       continue process    required check    workaround  facebook send  user id  open graph api    retrieve sign user    return user credentials ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nimport json\n\nimport requests\n\nfrom odoo import api, fields, models\nfrom odoo.exceptions import AccessDenied, UserError\nfrom odoo.addons.auth_signup.models.res_users import SignupError\n\nfrom odoo.addons import base\nbase.res.res_users.USER_PRIVATE_FIELDS.append('oauth_access_token')\n\nclass ResUsers(models.Model):\n    _inherit = 'res.users'\n\n    oauth_provider_id = fields.Many2one('auth.oauth.provider', string='OAuth Provider')\n    oauth_uid = fields.Char(string='OAuth User ID', help=\"Oauth Provider user_id\", copy=False)\n    oauth_access_token = fields.Char(string='OAuth Access Token', readonly=True, copy=False)\n\n    _sql_constraints = [\n        ('uniq_users_oauth_provider_oauth_uid', 'unique(oauth_provider_id, oauth_uid)', 'OAuth UID must be unique per provider'),\n    ]\n\n    @api.model\n    def _auth_oauth_rpc(self, endpoint, access_token):\n        return requests.get(endpoint, params={'access_token': access_token}).json()\n\n    @api.model\n    def _auth_oauth_validate(self, provider, access_token):\n        \"\"\" return the validation data corresponding to the access token \"\"\"\n        oauth_provider = self.env['auth.oauth.provider'].browse(provider)\n        validation = self._auth_oauth_rpc(oauth_provider.validation_endpoint, access_token)\n        if validation.get(\"error\"):\n            raise Exception(validation['error'])\n        if oauth_provider.data_endpoint:\n            data = self._auth_oauth_rpc(oauth_provider.data_endpoint, access_token)\n            validation.update(data)\n        return validation\n\n    @api.model\n    def _generate_signup_values(self, provider, validation, params):\n        oauth_uid = validation['user_id']\n        email = validation.get('email', 'provider_%s_user_%s' % (provider, oauth_uid))\n        name = validation.get('name', email)\n        return {\n            'name': name,\n            'login': email,\n            'email': email,\n            'oauth_provider_id': provider,\n            'oauth_uid': oauth_uid,\n            'oauth_access_token': params['access_token'],\n            'active': True,\n        }\n\n    @api.model\n    def _auth_oauth_signin(self, provider, validation, params):\n        \"\"\" retrieve and sign in the user corresponding to provider and validated access token\n            :param provider: oauth provider id (int)\n            :param validation: result of validation of access token (dict)\n            :param params: oauth parameters (dict)\n            :return: user login (str)\n            :raise: AccessDenied if signin failed\n\n            This method can be overridden to add alternative signin methods.\n        \"\"\"\n        oauth_uid = validation['user_id']\n        try:\n            oauth_user = self.search([(\"oauth_uid\", \"=\", oauth_uid), ('oauth_provider_id', '=', provider)])\n            if not oauth_user:\n                raise AccessDenied()\n            assert len(oauth_user) == 1\n            oauth_user.write({'oauth_access_token': params['access_token']})\n            return oauth_user.login\n        except AccessDenied as access_denied_exception:\n            if self.env.context.get('no_user_creation'):\n                return None\n            state = json.loads(params['state'])\n            token = state.get('t')\n            values = self._generate_signup_values(provider, validation, params)\n            try:\n                _, login, _ = self.signup(values, token)\n                return login\n            except (SignupError, UserError):\n                raise access_denied_exception\n\n    @api.model\n    def auth_oauth(self, provider, params):\n        # Advice by Google (to avoid Confused Deputy Problem)\n        # if validation.audience != OUR_CLIENT_ID:\n        #   abort()\n        # else:\n        #   continue with the process\n        access_token = params.get('access_token')\n        validation = self._auth_oauth_validate(provider, access_token)\n        # required check\n        if not validation.get('user_id'):\n            # Workaround: facebook does not send 'user_id' in Open Graph Api\n            if validation.get('id'):\n                validation['user_id'] = validation['id']\n            else:\n                raise AccessDenied()\n\n        # retrieve and sign in user\n        login = self._auth_oauth_signin(provider, validation, params)\n        if not login:\n            raise AccessDenied()\n        # return user credentials\n        return (self.env.cr.dbname, login, access_token)\n\n    @api.model\n    def check_credentials(self, password):\n        try:\n            return super(ResUsers, self).check_credentials(password)\n        except AccessDenied:\n            res = self.sudo().search([('id', '=', self.env.uid), ('oauth_access_token', '=', password)])\n            if not res:\n                raise\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "res_users.py", "id": "946fdb666b815944f4c8580188947a61", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/auth_oauth/models/res_users.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}