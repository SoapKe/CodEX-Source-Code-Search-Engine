{"author": "tensorflow", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n\nimport os\nimport tensorflow as tf\n\nfrom magenta.models.nsynth import utils\nfrom magenta.models.nsynth.wavenet import fastgen\n\nFLAGS = tf.app.flags.FLAGS\n\ntf.app.flags.DEFINE_string(\"source_path\", \"\", \"Path to directory with either \"\n                           \".wav files or precomputed encodings in .npy files.\"\n                           \"If .wav files are present, use wav files. If no \"\n                           \".wav files are present, use .npy files\")\ntf.app.flags.DEFINE_boolean(\"npy_only\", False, \"If True, use only .npy files.\")\ntf.app.flags.DEFINE_string(\"save_path\", \"\", \"Path to output file dir.\")\ntf.app.flags.DEFINE_string(\"checkpoint_path\", \"model.ckpt-200000\",\n                           \"Path to checkpoint.\")\ntf.app.flags.DEFINE_integer(\"sample_length\", 100000000,\n                            \"Max output file size in samples.\")\ntf.app.flags.DEFINE_integer(\"batch_size\", 1, \"Number of samples per a batch.\")\ntf.app.flags.DEFINE_string(\"log\", \"INFO\",\n                           \"The threshold for what messages will be logged.\"\n                           \"DEBUG, INFO, WARN, ERROR, or FATAL.\")\ntf.app.flags.DEFINE_integer(\"gpu_number\", 0,\n                            \"Number of the gpu to use for multigpu generation.\")\n\n\ndef main(unused_argv=None):\n  os.environ[\"CUDA_VISIBLE_DEVICES\"] = str(FLAGS.gpu_number)\n  source_path = utils.shell_path(FLAGS.source_path)\n  checkpoint_path = utils.shell_path(FLAGS.checkpoint_path)\n  save_path = utils.shell_path(FLAGS.save_path)\n  if not save_path:\n    raise RuntimeError(\"Must specify a save_path.\")\n  tf.logging.set_verbosity(FLAGS.log)\n\n   Generate from wav files\n  if tf.gfile.IsDirectory(source_path):\n    files = tf.gfile.ListDirectory(source_path)\n    exts = [os.path.splitext(f)[1] for f in files]\n    if \".wav\" in exts:\n      postfix = \".wav\"\n    elif \".npy\" in exts:\n      postfix = \".npy\"\n    else:\n      raise RuntimeError(\"Folder must contain .wav or .npy files.\")\n    postfix = \".npy\" if FLAGS.npy_only else postfix\n    files = sorted([\n        os.path.join(source_path, fname)\n        for fname in files\n        if fname.lower().endswith(postfix)\n    ])\n\n  elif source_path.lower().endswith((\".wav\", \".npy\")):\n    files = [source_path]\n  else:\n    files = []\n\n   Now synthesize from files one batch at a time\n  batch_size = FLAGS.batch_size\n  sample_length = FLAGS.sample_length\n  n = len(files)\n  for start in range(0, n, batch_size):\n    end = start + batch_size\n    batch_files = files[start:end]\n    save_names = [\n        os.path.join(save_path,\n                     \"gen_\" + os.path.splitext(os.path.basename(f))[0] + \".wav\")\n        for f in batch_files\n    ]\n    batch_data = fastgen.load_batch(batch_files, sample_length=sample_length)\n     Encode waveforms\n    encodings = batch_data if postfix == \".npy\" else fastgen.encode(\n        batch_data, checkpoint_path, sample_length=sample_length)\n    if FLAGS.gpu_number != 0:\n      with tf.device(\"/device:GPU:%d\" % FLAGS.gpu_number):\n        fastgen.synthesize(\n            encodings, save_names, checkpoint_path=checkpoint_path)\n    else:\n      fastgen.synthesize(encodings, save_names, checkpoint_path=checkpoint_path)\n\n\ndef console_entry_point():\n  tf.app.run(main)\n\n\nif __name__ == \"__main__\":\n  console_entry_point()\n", "comments": "   a binary generating samples given folder  wav files encodings        copyright 2017 google inc  all rights reserved        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license          http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license     generate wav files    now synthesize files one batch time    encode waveforms ", "content": "# Copyright 2017 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"A binary for generating samples given a folder of .wav files or encodings.\"\"\"\n\nimport os\nimport tensorflow as tf\n\nfrom magenta.models.nsynth import utils\nfrom magenta.models.nsynth.wavenet import fastgen\n\nFLAGS = tf.app.flags.FLAGS\n\ntf.app.flags.DEFINE_string(\"source_path\", \"\", \"Path to directory with either \"\n                           \".wav files or precomputed encodings in .npy files.\"\n                           \"If .wav files are present, use wav files. If no \"\n                           \".wav files are present, use .npy files\")\ntf.app.flags.DEFINE_boolean(\"npy_only\", False, \"If True, use only .npy files.\")\ntf.app.flags.DEFINE_string(\"save_path\", \"\", \"Path to output file dir.\")\ntf.app.flags.DEFINE_string(\"checkpoint_path\", \"model.ckpt-200000\",\n                           \"Path to checkpoint.\")\ntf.app.flags.DEFINE_integer(\"sample_length\", 100000000,\n                            \"Max output file size in samples.\")\ntf.app.flags.DEFINE_integer(\"batch_size\", 1, \"Number of samples per a batch.\")\ntf.app.flags.DEFINE_string(\"log\", \"INFO\",\n                           \"The threshold for what messages will be logged.\"\n                           \"DEBUG, INFO, WARN, ERROR, or FATAL.\")\ntf.app.flags.DEFINE_integer(\"gpu_number\", 0,\n                            \"Number of the gpu to use for multigpu generation.\")\n\n\ndef main(unused_argv=None):\n  os.environ[\"CUDA_VISIBLE_DEVICES\"] = str(FLAGS.gpu_number)\n  source_path = utils.shell_path(FLAGS.source_path)\n  checkpoint_path = utils.shell_path(FLAGS.checkpoint_path)\n  save_path = utils.shell_path(FLAGS.save_path)\n  if not save_path:\n    raise RuntimeError(\"Must specify a save_path.\")\n  tf.logging.set_verbosity(FLAGS.log)\n\n  # Generate from wav files\n  if tf.gfile.IsDirectory(source_path):\n    files = tf.gfile.ListDirectory(source_path)\n    exts = [os.path.splitext(f)[1] for f in files]\n    if \".wav\" in exts:\n      postfix = \".wav\"\n    elif \".npy\" in exts:\n      postfix = \".npy\"\n    else:\n      raise RuntimeError(\"Folder must contain .wav or .npy files.\")\n    postfix = \".npy\" if FLAGS.npy_only else postfix\n    files = sorted([\n        os.path.join(source_path, fname)\n        for fname in files\n        if fname.lower().endswith(postfix)\n    ])\n\n  elif source_path.lower().endswith((\".wav\", \".npy\")):\n    files = [source_path]\n  else:\n    files = []\n\n  # Now synthesize from files one batch at a time\n  batch_size = FLAGS.batch_size\n  sample_length = FLAGS.sample_length\n  n = len(files)\n  for start in range(0, n, batch_size):\n    end = start + batch_size\n    batch_files = files[start:end]\n    save_names = [\n        os.path.join(save_path,\n                     \"gen_\" + os.path.splitext(os.path.basename(f))[0] + \".wav\")\n        for f in batch_files\n    ]\n    batch_data = fastgen.load_batch(batch_files, sample_length=sample_length)\n    # Encode waveforms\n    encodings = batch_data if postfix == \".npy\" else fastgen.encode(\n        batch_data, checkpoint_path, sample_length=sample_length)\n    if FLAGS.gpu_number != 0:\n      with tf.device(\"/device:GPU:%d\" % FLAGS.gpu_number):\n        fastgen.synthesize(\n            encodings, save_names, checkpoint_path=checkpoint_path)\n    else:\n      fastgen.synthesize(encodings, save_names, checkpoint_path=checkpoint_path)\n\n\ndef console_entry_point():\n  tf.app.run(main)\n\n\nif __name__ == \"__main__\":\n  console_entry_point()\n", "description": "Magenta: Music and Art Generation with Machine Intelligence", "file_name": "nsynth_generate.py", "id": "918217490688754f872a6980a496ab09", "language": "Python", "project_name": "magenta", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tensorflow-magenta/tensorflow-magenta-ca73164/magenta/models/nsynth/wavenet/nsynth_generate.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:00:14Z", "url": "https://github.com/tensorflow/magenta", "wiki": false}