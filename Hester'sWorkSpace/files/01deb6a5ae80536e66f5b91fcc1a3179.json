{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport io\nimport os\nimport subprocess\nimport time\nimport re\n\n\nfrom .common import AudioConversionError, PostProcessor\n\nfrom ..compat import (\n    compat_subprocess_get_DEVNULL,\n)\nfrom ..utils import (\n    encodeArgument,\n    encodeFilename,\n    get_exe_version,\n    is_outdated_version,\n    PostProcessingError,\n    prepend_extension,\n    shell_quote,\n    subtitles_filename,\n    dfxp2srt,\n    ISO639Utils,\n    replace_extension,\n)\n\n\nEXT_TO_OUT_FORMATS = {\n    'aac': 'adts',\n    'flac': 'flac',\n    'm4a': 'ipod',\n    'mka': 'matroska',\n    'mkv': 'matroska',\n    'mpg': 'mpeg',\n    'ogv': 'ogg',\n    'ts': 'mpegts',\n    'wma': 'asf',\n    'wmv': 'asf',\n}\nACODECS = {\n    'mp3': 'libmp3lame',\n    'aac': 'aac',\n    'flac': 'flac',\n    'm4a': 'aac',\n    'opus': 'libopus',\n    'vorbis': 'libvorbis',\n    'wav': None,\n}\n\n\nclass FFmpegPostProcessorError(PostProcessingError):\n    pass\n\n\nclass FFmpegPostProcessor(PostProcessor):\n    def __init__(self, downloader=None):\n        PostProcessor.__init__(self, downloader)\n        self._determine_executables()\n\n    def check_version(self):\n        if not self.available:\n            raise FFmpegPostProcessorError('ffmpeg or avconv not found. Please install one.')\n\n        required_version = '10-0' if self.basename == 'avconv' else '1.0'\n        if is_outdated_version(\n                self._versions[self.basename], required_version):\n            warning = 'Your copy of %s is outdated, update %s to version %s or newer if you encounter any errors.' % (\n                self.basename, self.basename, required_version)\n            if self._downloader:\n                self._downloader.report_warning(warning)\n\n    @staticmethod\n    def get_versions(downloader=None):\n        return FFmpegPostProcessor(downloader)._versions\n\n    def _determine_executables(self):\n        programs = ['avprobe', 'avconv', 'ffmpeg', 'ffprobe']\n        prefer_ffmpeg = False\n\n        self.basename = None\n        self.probe_basename = None\n\n        self._paths = None\n        self._versions = None\n        if self._downloader:\n            prefer_ffmpeg = self._downloader.params.get('prefer_ffmpeg', False)\n            location = self._downloader.params.get('ffmpeg_location')\n            if location is not None:\n                if not os.path.exists(location):\n                    self._downloader.report_warning(\n                        'ffmpeg-location %s does not exist! '\n                        'Continuing without avconv/ffmpeg.' % (location))\n                    self._versions = {}\n                    return\n                elif not os.path.isdir(location):\n                    basename = os.path.splitext(os.path.basename(location))[0]\n                    if basename not in programs:\n                        self._downloader.report_warning(\n                            'Cannot identify executable %s, its basename should be one of %s. '\n                            'Continuing without avconv/ffmpeg.' %\n                            (location, ', '.join(programs)))\n                        self._versions = {}\n                        return None\n                    location = os.path.dirname(os.path.abspath(location))\n                    if basename in ('ffmpeg', 'ffprobe'):\n                        prefer_ffmpeg = True\n\n                self._paths = dict(\n                    (p, os.path.join(location, p)) for p in programs)\n                self._versions = dict(\n                    (p, get_exe_version(self._paths[p], args=['-version']))\n                    for p in programs)\n        if self._versions is None:\n            self._versions = dict(\n                (p, get_exe_version(p, args=['-version'])) for p in programs)\n            self._paths = dict((p, p) for p in programs)\n\n        if prefer_ffmpeg:\n            prefs = ('ffmpeg', 'avconv')\n        else:\n            prefs = ('avconv', 'ffmpeg')\n        for p in prefs:\n            if self._versions[p]:\n                self.basename = p\n                break\n\n        if prefer_ffmpeg:\n            prefs = ('ffprobe', 'avprobe')\n        else:\n            prefs = ('avprobe', 'ffprobe')\n        for p in prefs:\n            if self._versions[p]:\n                self.probe_basename = p\n                break\n\n    @property\n    def available(self):\n        return self.basename is not None\n\n    @property\n    def executable(self):\n        return self._paths[self.basename]\n\n    @property\n    def probe_available(self):\n        return self.probe_basename is not None\n\n    @property\n    def probe_executable(self):\n        return self._paths[self.probe_basename]\n\n    def get_audio_codec(self, path):\n        if not self.probe_available:\n            raise PostProcessingError('ffprobe or avprobe not found. Please install one.')\n        try:\n            cmd = [\n                encodeFilename(self.probe_executable, True),\n                encodeArgument('-show_streams'),\n                encodeFilename(self._ffmpeg_filename_argument(path), True)]\n            if self._downloader.params.get('verbose', False):\n                self._downloader.to_screen('[debug] %s command line: %s' % (self.basename, shell_quote(cmd)))\n            handle = subprocess.Popen(cmd, stderr=compat_subprocess_get_DEVNULL(), stdout=subprocess.PIPE, stdin=subprocess.PIPE)\n            output = handle.communicate()[0]\n            if handle.wait() != 0:\n                return None\n        except (IOError, OSError):\n            return None\n        audio_codec = None\n        for line in output.decode('ascii', 'ignore').split('\\n'):\n            if line.startswith('codec_name='):\n                audio_codec = line.split('=')[1].strip()\n            elif line.strip() == 'codec_type=audio' and audio_codec is not None:\n                return audio_codec\n        return None\n\n    def run_ffmpeg_multiple_files(self, input_paths, out_path, opts):\n        self.check_version()\n\n        oldest_mtime = min(\n            os.stat(encodeFilename(path)).st_mtime for path in input_paths)\n\n        opts += self._configuration_args()\n\n        files_cmd = []\n        for path in input_paths:\n            files_cmd.extend([\n                encodeArgument('-i'),\n                encodeFilename(self._ffmpeg_filename_argument(path), True)\n            ])\n        cmd = ([encodeFilename(self.executable, True), encodeArgument('-y')] +\n               files_cmd +\n               [encodeArgument(o) for o in opts] +\n               [encodeFilename(self._ffmpeg_filename_argument(out_path), True)])\n\n        if self._downloader.params.get('verbose', False):\n            self._downloader.to_screen('[debug] ffmpeg command line: %s' % shell_quote(cmd))\n        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n        stdout, stderr = p.communicate()\n        if p.returncode != 0:\n            stderr = stderr.decode('utf-8', 'replace')\n            msg = stderr.strip().split('\\n')[-1]\n            raise FFmpegPostProcessorError(msg)\n        self.try_utime(out_path, oldest_mtime, oldest_mtime)\n\n    def run_ffmpeg(self, path, out_path, opts):\n        self.run_ffmpeg_multiple_files([path], out_path, opts)\n\n    def _ffmpeg_filename_argument(self, fn):\n        \n        \n        \n        \n        return 'file:' + fn if fn != '-' else fn\n\n\nclass FFmpegExtractAudioPP(FFmpegPostProcessor):\n    def __init__(self, downloader=None, preferredcodec=None, preferredquality=None, nopostoverwrites=False):\n        FFmpegPostProcessor.__init__(self, downloader)\n        if preferredcodec is None:\n            preferredcodec = 'best'\n        self._preferredcodec = preferredcodec\n        self._preferredquality = preferredquality\n        self._nopostoverwrites = nopostoverwrites\n\n    def run_ffmpeg(self, path, out_path, codec, more_opts):\n        if codec is None:\n            acodec_opts = []\n        else:\n            acodec_opts = ['-acodec', codec]\n        opts = ['-vn'] + acodec_opts + more_opts\n        try:\n            FFmpegPostProcessor.run_ffmpeg(self, path, out_path, opts)\n        except FFmpegPostProcessorError as err:\n            raise AudioConversionError(err.msg)\n\n    def run(self, information):\n        path = information['filepath']\n\n        filecodec = self.get_audio_codec(path)\n        if filecodec is None:\n            raise PostProcessingError('WARNING: unable to obtain file audio codec with ffprobe')\n\n        more_opts = []\n        if self._preferredcodec == 'best' or self._preferredcodec == filecodec or (self._preferredcodec == 'm4a' and filecodec == 'aac'):\n            if filecodec == 'aac' and self._preferredcodec in ['m4a', 'best']:\n                \n                acodec = 'copy'\n                extension = 'm4a'\n                more_opts = ['-bsf:a', 'aac_adtstoasc']\n            elif filecodec in ['aac', 'flac', 'mp3', 'vorbis', 'opus']:\n                \n                acodec = 'copy'\n                extension = filecodec\n                if filecodec == 'aac':\n                    more_opts = ['-f', 'adts']\n                if filecodec == 'vorbis':\n                    extension = 'ogg'\n            else:\n                \n                acodec = 'libmp3lame'\n                extension = 'mp3'\n                more_opts = []\n                if self._preferredquality is not None:\n                    if int(self._preferredquality) < 10:\n                        more_opts += ['-q:a', self._preferredquality]\n                    else:\n                        more_opts += ['-b:a', self._preferredquality + 'k']\n        else:\n            \n            acodec = ACODECS[self._preferredcodec]\n            extension = self._preferredcodec\n            more_opts = []\n            if self._preferredquality is not None:\n                \n                if int(self._preferredquality) < 10 and extension != 'opus':\n                    more_opts += ['-q:a', self._preferredquality]\n                else:\n                    more_opts += ['-b:a', self._preferredquality + 'k']\n            if self._preferredcodec == 'aac':\n                more_opts += ['-f', 'adts']\n            if self._preferredcodec == 'm4a':\n                more_opts += ['-bsf:a', 'aac_adtstoasc']\n            if self._preferredcodec == 'vorbis':\n                extension = 'ogg'\n            if self._preferredcodec == 'wav':\n                extension = 'wav'\n                more_opts += ['-f', 'wav']\n\n        prefix, sep, ext = path.rpartition('.')  \n        new_path = prefix + sep + extension\n\n        information['filepath'] = new_path\n        information['ext'] = extension\n\n        \n        if (new_path == path or\n                (self._nopostoverwrites and os.path.exists(encodeFilename(new_path)))):\n            self._downloader.to_screen('[ffmpeg] Post-process file %s exists, skipping' % new_path)\n            return [], information\n\n        try:\n            self._downloader.to_screen('[ffmpeg] Destination: ' + new_path)\n            self.run_ffmpeg(path, new_path, acodec, more_opts)\n        except AudioConversionError as e:\n            raise PostProcessingError(\n                'audio conversion failed: ' + e.msg)\n        except Exception:\n            raise PostProcessingError('error running ' + self.basename)\n\n        \n        if information.get('filetime') is not None:\n            self.try_utime(\n                new_path, time.time(), information['filetime'],\n                errnote='Cannot update utime of audio file')\n\n        return [path], information\n\n\nclass FFmpegVideoConvertorPP(FFmpegPostProcessor):\n    def __init__(self, downloader=None, preferedformat=None):\n        super(FFmpegVideoConvertorPP, self).__init__(downloader)\n        self._preferedformat = preferedformat\n\n    def run(self, information):\n        path = information['filepath']\n        if information['ext'] == self._preferedformat:\n            self._downloader.to_screen('[ffmpeg] Not converting video file %s - already is in target format %s' % (path, self._preferedformat))\n            return [], information\n        options = []\n        if self._preferedformat == 'avi':\n            options.extend(['-c:v', 'libxvid', '-vtag', 'XVID'])\n        prefix, sep, ext = path.rpartition('.')\n        outpath = prefix + sep + self._preferedformat\n        self._downloader.to_screen('[' + 'ffmpeg' + '] Converting video from %s to %s, Destination: ' % (information['ext'], self._preferedformat) + outpath)\n        self.run_ffmpeg(path, outpath, options)\n        information['filepath'] = outpath\n        information['format'] = self._preferedformat\n        information['ext'] = self._preferedformat\n        return [path], information\n\n\nclass FFmpegEmbedSubtitlePP(FFmpegPostProcessor):\n    def run(self, information):\n        if information['ext'] not in ('mp4', 'webm', 'mkv'):\n            self._downloader.to_screen('[ffmpeg] Subtitles can only be embedded in mp4, webm or mkv files')\n            return [], information\n        subtitles = information.get('requested_subtitles')\n        if not subtitles:\n            self._downloader.to_screen('[ffmpeg] There aren\\'t any subtitles to embed')\n            return [], information\n\n        filename = information['filepath']\n\n        ext = information['ext']\n        sub_langs = []\n        sub_filenames = []\n        webm_vtt_warn = False\n\n        for lang, sub_info in subtitles.items():\n            sub_ext = sub_info['ext']\n            if ext != 'webm' or ext == 'webm' and sub_ext == 'vtt':\n                sub_langs.append(lang)\n                sub_filenames.append(subtitles_filename(filename, lang, sub_ext))\n            else:\n                if not webm_vtt_warn and ext == 'webm' and sub_ext != 'vtt':\n                    webm_vtt_warn = True\n                    self._downloader.to_screen('[ffmpeg] Only WebVTT subtitles can be embedded in webm files')\n\n        if not sub_langs:\n            return [], information\n\n        input_files = [filename] + sub_filenames\n\n        opts = [\n            '-map', '0',\n            '-c', 'copy',\n            \n            \n            '-map', '-0:s',\n        ]\n        if information['ext'] == 'mp4':\n            opts += ['-c:s', 'mov_text']\n        for (i, lang) in enumerate(sub_langs):\n            opts.extend(['-map', '%d:0' % (i + 1)])\n            lang_code = ISO639Utils.short2long(lang)\n            if lang_code is not None:\n                opts.extend(['-metadata:s:s:%d' % i, 'language=%s' % lang_code])\n\n        temp_filename = prepend_extension(filename, 'temp')\n        self._downloader.to_screen('[ffmpeg] Embedding subtitles in \\'%s\\'' % filename)\n        self.run_ffmpeg_multiple_files(input_files, temp_filename, opts)\n        os.remove(encodeFilename(filename))\n        os.rename(encodeFilename(temp_filename), encodeFilename(filename))\n\n        return sub_filenames, information\n\n\nclass FFmpegMetadataPP(FFmpegPostProcessor):\n    def run(self, info):\n        metadata = {}\n\n        def add(meta_list, info_list=None):\n            if not info_list:\n                info_list = meta_list\n            if not isinstance(meta_list, (list, tuple)):\n                meta_list = (meta_list,)\n            if not isinstance(info_list, (list, tuple)):\n                info_list = (info_list,)\n            for info_f in info_list:\n                if info.get(info_f) is not None:\n                    for meta_f in meta_list:\n                        metadata[meta_f] = info[info_f]\n                    break\n\n        add('title', ('track', 'title'))\n        add('date', 'upload_date')\n        add(('description', 'comment'), 'description')\n        add('purl', 'webpage_url')\n        add('track', 'track_number')\n        add('artist', ('artist', 'creator', 'uploader', 'uploader_id'))\n        add('genre')\n        add('album')\n        add('album_artist')\n        add('disc', 'disc_number')\n\n        if not metadata:\n            self._downloader.to_screen('[ffmpeg] There isn\\'t any metadata to add')\n            return [], info\n\n        filename = info['filepath']\n        temp_filename = prepend_extension(filename, 'temp')\n        in_filenames = [filename]\n        options = []\n\n        if info['ext'] == 'm4a':\n            options.extend(['-vn', '-acodec', 'copy'])\n        else:\n            options.extend(['-c', 'copy'])\n\n        for (name, value) in metadata.items():\n            options.extend(['-metadata', '%s=%s' % (name, value)])\n\n        chapters = info.get('chapters', [])\n        if chapters:\n            metadata_filename = replace_extension(filename, 'meta')\n            with io.open(metadata_filename, 'wt', encoding='utf-8') as f:\n                def ffmpeg_escape(text):\n                    return re.sub(r'(=|;|\n\n                metadata_file_content = ';FFMETADATA1\\n'\n                for chapter in chapters:\n                    metadata_file_content += '[CHAPTER]\\nTIMEBASE=1/1000\\n'\n                    metadata_file_content += 'START=%d\\n' % (chapter['start_time'] * 1000)\n                    metadata_file_content += 'END=%d\\n' % (chapter['end_time'] * 1000)\n                    chapter_title = chapter.get('title')\n                    if chapter_title:\n                        metadata_file_content += 'title=%s\\n' % ffmpeg_escape(chapter_title)\n                f.write(metadata_file_content)\n                in_filenames.append(metadata_filename)\n                options.extend(['-map_metadata', '1'])\n\n        self._downloader.to_screen('[ffmpeg] Adding metadata to \\'%s\\'' % filename)\n        self.run_ffmpeg_multiple_files(in_filenames, temp_filename, options)\n        if chapters:\n            os.remove(metadata_filename)\n        os.remove(encodeFilename(filename))\n        os.rename(encodeFilename(temp_filename), encodeFilename(filename))\n        return [], info\n\n\nclass FFmpegMergerPP(FFmpegPostProcessor):\n    def run(self, info):\n        filename = info['filepath']\n        temp_filename = prepend_extension(filename, 'temp')\n        args = ['-c', 'copy', '-map', '0:v:0', '-map', '1:a:0']\n        self._downloader.to_screen('[ffmpeg] Merging formats into \"%s\"' % filename)\n        self.run_ffmpeg_multiple_files(info['__files_to_merge'], temp_filename, args)\n        os.rename(encodeFilename(temp_filename), encodeFilename(filename))\n        return info['__files_to_merge'], info\n\n    def can_merge(self):\n        \n        if self.basename != 'avconv':\n            return True\n\n        required_version = '10-0'\n        if is_outdated_version(\n                self._versions[self.basename], required_version):\n            warning = ('Your copy of %s is outdated and unable to properly mux separate video and audio files, '\n                       'youtube-dl will download single file media. '\n                       'Update %s to version %s or newer to fix this.') % (\n                           self.basename, self.basename, required_version)\n            if self._downloader:\n                self._downloader.report_warning(warning)\n            return False\n        return True\n\n\nclass FFmpegFixupStretchedPP(FFmpegPostProcessor):\n    def run(self, info):\n        stretched_ratio = info.get('stretched_ratio')\n        if stretched_ratio is None or stretched_ratio == 1:\n            return [], info\n\n        filename = info['filepath']\n        temp_filename = prepend_extension(filename, 'temp')\n\n        options = ['-c', 'copy', '-aspect', '%f' % stretched_ratio]\n        self._downloader.to_screen('[ffmpeg] Fixing aspect ratio in \"%s\"' % filename)\n        self.run_ffmpeg(filename, temp_filename, options)\n\n        os.remove(encodeFilename(filename))\n        os.rename(encodeFilename(temp_filename), encodeFilename(filename))\n\n        return [], info\n\n\nclass FFmpegFixupM4aPP(FFmpegPostProcessor):\n    def run(self, info):\n        if info.get('container') != 'm4a_dash':\n            return [], info\n\n        filename = info['filepath']\n        temp_filename = prepend_extension(filename, 'temp')\n\n        options = ['-c', 'copy', '-f', 'mp4']\n        self._downloader.to_screen('[ffmpeg] Correcting container in \"%s\"' % filename)\n        self.run_ffmpeg(filename, temp_filename, options)\n\n        os.remove(encodeFilename(filename))\n        os.rename(encodeFilename(temp_filename), encodeFilename(filename))\n\n        return [], info\n\n\nclass FFmpegFixupM3u8PP(FFmpegPostProcessor):\n    def run(self, info):\n        filename = info['filepath']\n        if self.get_audio_codec(filename) == 'aac':\n            temp_filename = prepend_extension(filename, 'temp')\n\n            options = ['-c', 'copy', '-f', 'mp4', '-bsf:a', 'aac_adtstoasc']\n            self._downloader.to_screen('[ffmpeg] Fixing malformed AAC bitstream in \"%s\"' % filename)\n            self.run_ffmpeg(filename, temp_filename, options)\n\n            os.remove(encodeFilename(filename))\n            os.rename(encodeFilename(temp_filename), encodeFilename(filename))\n        return [], info\n\n\nclass FFmpegSubtitlesConvertorPP(FFmpegPostProcessor):\n    def __init__(self, downloader=None, format=None):\n        super(FFmpegSubtitlesConvertorPP, self).__init__(downloader)\n        self.format = format\n\n    def run(self, info):\n        subs = info.get('requested_subtitles')\n        filename = info['filepath']\n        new_ext = self.format\n        new_format = new_ext\n        if new_format == 'vtt':\n            new_format = 'webvtt'\n        if subs is None:\n            self._downloader.to_screen('[ffmpeg] There aren\\'t any subtitles to convert')\n            return [], info\n        self._downloader.to_screen('[ffmpeg] Converting subtitles')\n        sub_filenames = []\n        for lang, sub in subs.items():\n            ext = sub['ext']\n            if ext == new_ext:\n                self._downloader.to_screen(\n                    '[ffmpeg] Subtitle file for %s is already in the requested format' % new_ext)\n                continue\n            old_file = subtitles_filename(filename, lang, ext)\n            sub_filenames.append(old_file)\n            new_file = subtitles_filename(filename, lang, new_ext)\n\n            if ext in ('dfxp', 'ttml', 'tt'):\n                self._downloader.report_warning(\n                    'You have requested to convert dfxp (TTML) subtitles into another format, '\n                    'which results in style information loss')\n\n                dfxp_file = old_file\n                srt_file = subtitles_filename(filename, lang, 'srt')\n\n                with open(dfxp_file, 'rb') as f:\n                    srt_data = dfxp2srt(f.read())\n\n                with io.open(srt_file, 'wt', encoding='utf-8') as f:\n                    f.write(srt_data)\n                old_file = srt_file\n\n                subs[lang] = {\n                    'ext': 'srt',\n                    'data': srt_data\n                }\n\n                if new_ext == 'srt':\n                    continue\n                else:\n                    sub_filenames.append(srt_file)\n\n            self.run_ffmpeg(old_file, new_file, ['-f', new_format])\n\n            with io.open(new_file, 'rt', encoding='utf-8') as f:\n                subs[lang] = {\n                    'ext': new_ext,\n                    'data': f.read(),\n                }\n\n        return sub_filenames, info\n", "comments": "# Always use 'file:' because the filename may contain ':' (ffmpeg\n# interprets that as a protocol) or can start with '-' (-- is broken in\n# ffmpeg, see https://ffmpeg.org/trac/ffmpeg/ticket/2127 for details)\n# Also leave '-' intact in order not to break streaming to stdout.\n# Lossless, but in another container\n# Lossless if possible\n# MP3 otherwise.\n# We convert the audio (lossy if codec is lossy)\n# The opus codec doesn't support the -aq option\n# not os.path.splitext, since the latter does not work on unicode in all setups\n# If we download foo.mp3 and convert it to... foo.mp3, then don't delete foo.mp3, silly.\n# Try to update the date time for extracted audio file.\n# Don't copy the existing subtitles, we may be running the\n# postprocessor a second time\n#|\\\\|\\n)', r'\\\\\\1', text)\n# TODO: figure out merge-capable ffmpeg version\n", "content": "from __future__ import unicode_literals\n\nimport io\nimport os\nimport subprocess\nimport time\nimport re\n\n\nfrom .common import AudioConversionError, PostProcessor\n\nfrom ..compat import (\n    compat_subprocess_get_DEVNULL,\n)\nfrom ..utils import (\n    encodeArgument,\n    encodeFilename,\n    get_exe_version,\n    is_outdated_version,\n    PostProcessingError,\n    prepend_extension,\n    shell_quote,\n    subtitles_filename,\n    dfxp2srt,\n    ISO639Utils,\n    replace_extension,\n)\n\n\nEXT_TO_OUT_FORMATS = {\n    'aac': 'adts',\n    'flac': 'flac',\n    'm4a': 'ipod',\n    'mka': 'matroska',\n    'mkv': 'matroska',\n    'mpg': 'mpeg',\n    'ogv': 'ogg',\n    'ts': 'mpegts',\n    'wma': 'asf',\n    'wmv': 'asf',\n}\nACODECS = {\n    'mp3': 'libmp3lame',\n    'aac': 'aac',\n    'flac': 'flac',\n    'm4a': 'aac',\n    'opus': 'libopus',\n    'vorbis': 'libvorbis',\n    'wav': None,\n}\n\n\nclass FFmpegPostProcessorError(PostProcessingError):\n    pass\n\n\nclass FFmpegPostProcessor(PostProcessor):\n    def __init__(self, downloader=None):\n        PostProcessor.__init__(self, downloader)\n        self._determine_executables()\n\n    def check_version(self):\n        if not self.available:\n            raise FFmpegPostProcessorError('ffmpeg or avconv not found. Please install one.')\n\n        required_version = '10-0' if self.basename == 'avconv' else '1.0'\n        if is_outdated_version(\n                self._versions[self.basename], required_version):\n            warning = 'Your copy of %s is outdated, update %s to version %s or newer if you encounter any errors.' % (\n                self.basename, self.basename, required_version)\n            if self._downloader:\n                self._downloader.report_warning(warning)\n\n    @staticmethod\n    def get_versions(downloader=None):\n        return FFmpegPostProcessor(downloader)._versions\n\n    def _determine_executables(self):\n        programs = ['avprobe', 'avconv', 'ffmpeg', 'ffprobe']\n        prefer_ffmpeg = False\n\n        self.basename = None\n        self.probe_basename = None\n\n        self._paths = None\n        self._versions = None\n        if self._downloader:\n            prefer_ffmpeg = self._downloader.params.get('prefer_ffmpeg', False)\n            location = self._downloader.params.get('ffmpeg_location')\n            if location is not None:\n                if not os.path.exists(location):\n                    self._downloader.report_warning(\n                        'ffmpeg-location %s does not exist! '\n                        'Continuing without avconv/ffmpeg.' % (location))\n                    self._versions = {}\n                    return\n                elif not os.path.isdir(location):\n                    basename = os.path.splitext(os.path.basename(location))[0]\n                    if basename not in programs:\n                        self._downloader.report_warning(\n                            'Cannot identify executable %s, its basename should be one of %s. '\n                            'Continuing without avconv/ffmpeg.' %\n                            (location, ', '.join(programs)))\n                        self._versions = {}\n                        return None\n                    location = os.path.dirname(os.path.abspath(location))\n                    if basename in ('ffmpeg', 'ffprobe'):\n                        prefer_ffmpeg = True\n\n                self._paths = dict(\n                    (p, os.path.join(location, p)) for p in programs)\n                self._versions = dict(\n                    (p, get_exe_version(self._paths[p], args=['-version']))\n                    for p in programs)\n        if self._versions is None:\n            self._versions = dict(\n                (p, get_exe_version(p, args=['-version'])) for p in programs)\n            self._paths = dict((p, p) for p in programs)\n\n        if prefer_ffmpeg:\n            prefs = ('ffmpeg', 'avconv')\n        else:\n            prefs = ('avconv', 'ffmpeg')\n        for p in prefs:\n            if self._versions[p]:\n                self.basename = p\n                break\n\n        if prefer_ffmpeg:\n            prefs = ('ffprobe', 'avprobe')\n        else:\n            prefs = ('avprobe', 'ffprobe')\n        for p in prefs:\n            if self._versions[p]:\n                self.probe_basename = p\n                break\n\n    @property\n    def available(self):\n        return self.basename is not None\n\n    @property\n    def executable(self):\n        return self._paths[self.basename]\n\n    @property\n    def probe_available(self):\n        return self.probe_basename is not None\n\n    @property\n    def probe_executable(self):\n        return self._paths[self.probe_basename]\n\n    def get_audio_codec(self, path):\n        if not self.probe_available:\n            raise PostProcessingError('ffprobe or avprobe not found. Please install one.')\n        try:\n            cmd = [\n                encodeFilename(self.probe_executable, True),\n                encodeArgument('-show_streams'),\n                encodeFilename(self._ffmpeg_filename_argument(path), True)]\n            if self._downloader.params.get('verbose', False):\n                self._downloader.to_screen('[debug] %s command line: %s' % (self.basename, shell_quote(cmd)))\n            handle = subprocess.Popen(cmd, stderr=compat_subprocess_get_DEVNULL(), stdout=subprocess.PIPE, stdin=subprocess.PIPE)\n            output = handle.communicate()[0]\n            if handle.wait() != 0:\n                return None\n        except (IOError, OSError):\n            return None\n        audio_codec = None\n        for line in output.decode('ascii', 'ignore').split('\\n'):\n            if line.startswith('codec_name='):\n                audio_codec = line.split('=')[1].strip()\n            elif line.strip() == 'codec_type=audio' and audio_codec is not None:\n                return audio_codec\n        return None\n\n    def run_ffmpeg_multiple_files(self, input_paths, out_path, opts):\n        self.check_version()\n\n        oldest_mtime = min(\n            os.stat(encodeFilename(path)).st_mtime for path in input_paths)\n\n        opts += self._configuration_args()\n\n        files_cmd = []\n        for path in input_paths:\n            files_cmd.extend([\n                encodeArgument('-i'),\n                encodeFilename(self._ffmpeg_filename_argument(path), True)\n            ])\n        cmd = ([encodeFilename(self.executable, True), encodeArgument('-y')] +\n               files_cmd +\n               [encodeArgument(o) for o in opts] +\n               [encodeFilename(self._ffmpeg_filename_argument(out_path), True)])\n\n        if self._downloader.params.get('verbose', False):\n            self._downloader.to_screen('[debug] ffmpeg command line: %s' % shell_quote(cmd))\n        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n        stdout, stderr = p.communicate()\n        if p.returncode != 0:\n            stderr = stderr.decode('utf-8', 'replace')\n            msg = stderr.strip().split('\\n')[-1]\n            raise FFmpegPostProcessorError(msg)\n        self.try_utime(out_path, oldest_mtime, oldest_mtime)\n\n    def run_ffmpeg(self, path, out_path, opts):\n        self.run_ffmpeg_multiple_files([path], out_path, opts)\n\n    def _ffmpeg_filename_argument(self, fn):\n        # Always use 'file:' because the filename may contain ':' (ffmpeg\n        # interprets that as a protocol) or can start with '-' (-- is broken in\n        # ffmpeg, see https://ffmpeg.org/trac/ffmpeg/ticket/2127 for details)\n        # Also leave '-' intact in order not to break streaming to stdout.\n        return 'file:' + fn if fn != '-' else fn\n\n\nclass FFmpegExtractAudioPP(FFmpegPostProcessor):\n    def __init__(self, downloader=None, preferredcodec=None, preferredquality=None, nopostoverwrites=False):\n        FFmpegPostProcessor.__init__(self, downloader)\n        if preferredcodec is None:\n            preferredcodec = 'best'\n        self._preferredcodec = preferredcodec\n        self._preferredquality = preferredquality\n        self._nopostoverwrites = nopostoverwrites\n\n    def run_ffmpeg(self, path, out_path, codec, more_opts):\n        if codec is None:\n            acodec_opts = []\n        else:\n            acodec_opts = ['-acodec', codec]\n        opts = ['-vn'] + acodec_opts + more_opts\n        try:\n            FFmpegPostProcessor.run_ffmpeg(self, path, out_path, opts)\n        except FFmpegPostProcessorError as err:\n            raise AudioConversionError(err.msg)\n\n    def run(self, information):\n        path = information['filepath']\n\n        filecodec = self.get_audio_codec(path)\n        if filecodec is None:\n            raise PostProcessingError('WARNING: unable to obtain file audio codec with ffprobe')\n\n        more_opts = []\n        if self._preferredcodec == 'best' or self._preferredcodec == filecodec or (self._preferredcodec == 'm4a' and filecodec == 'aac'):\n            if filecodec == 'aac' and self._preferredcodec in ['m4a', 'best']:\n                # Lossless, but in another container\n                acodec = 'copy'\n                extension = 'm4a'\n                more_opts = ['-bsf:a', 'aac_adtstoasc']\n            elif filecodec in ['aac', 'flac', 'mp3', 'vorbis', 'opus']:\n                # Lossless if possible\n                acodec = 'copy'\n                extension = filecodec\n                if filecodec == 'aac':\n                    more_opts = ['-f', 'adts']\n                if filecodec == 'vorbis':\n                    extension = 'ogg'\n            else:\n                # MP3 otherwise.\n                acodec = 'libmp3lame'\n                extension = 'mp3'\n                more_opts = []\n                if self._preferredquality is not None:\n                    if int(self._preferredquality) < 10:\n                        more_opts += ['-q:a', self._preferredquality]\n                    else:\n                        more_opts += ['-b:a', self._preferredquality + 'k']\n        else:\n            # We convert the audio (lossy if codec is lossy)\n            acodec = ACODECS[self._preferredcodec]\n            extension = self._preferredcodec\n            more_opts = []\n            if self._preferredquality is not None:\n                # The opus codec doesn't support the -aq option\n                if int(self._preferredquality) < 10 and extension != 'opus':\n                    more_opts += ['-q:a', self._preferredquality]\n                else:\n                    more_opts += ['-b:a', self._preferredquality + 'k']\n            if self._preferredcodec == 'aac':\n                more_opts += ['-f', 'adts']\n            if self._preferredcodec == 'm4a':\n                more_opts += ['-bsf:a', 'aac_adtstoasc']\n            if self._preferredcodec == 'vorbis':\n                extension = 'ogg'\n            if self._preferredcodec == 'wav':\n                extension = 'wav'\n                more_opts += ['-f', 'wav']\n\n        prefix, sep, ext = path.rpartition('.')  # not os.path.splitext, since the latter does not work on unicode in all setups\n        new_path = prefix + sep + extension\n\n        information['filepath'] = new_path\n        information['ext'] = extension\n\n        # If we download foo.mp3 and convert it to... foo.mp3, then don't delete foo.mp3, silly.\n        if (new_path == path or\n                (self._nopostoverwrites and os.path.exists(encodeFilename(new_path)))):\n            self._downloader.to_screen('[ffmpeg] Post-process file %s exists, skipping' % new_path)\n            return [], information\n\n        try:\n            self._downloader.to_screen('[ffmpeg] Destination: ' + new_path)\n            self.run_ffmpeg(path, new_path, acodec, more_opts)\n        except AudioConversionError as e:\n            raise PostProcessingError(\n                'audio conversion failed: ' + e.msg)\n        except Exception:\n            raise PostProcessingError('error running ' + self.basename)\n\n        # Try to update the date time for extracted audio file.\n        if information.get('filetime') is not None:\n            self.try_utime(\n                new_path, time.time(), information['filetime'],\n                errnote='Cannot update utime of audio file')\n\n        return [path], information\n\n\nclass FFmpegVideoConvertorPP(FFmpegPostProcessor):\n    def __init__(self, downloader=None, preferedformat=None):\n        super(FFmpegVideoConvertorPP, self).__init__(downloader)\n        self._preferedformat = preferedformat\n\n    def run(self, information):\n        path = information['filepath']\n        if information['ext'] == self._preferedformat:\n            self._downloader.to_screen('[ffmpeg] Not converting video file %s - already is in target format %s' % (path, self._preferedformat))\n            return [], information\n        options = []\n        if self._preferedformat == 'avi':\n            options.extend(['-c:v', 'libxvid', '-vtag', 'XVID'])\n        prefix, sep, ext = path.rpartition('.')\n        outpath = prefix + sep + self._preferedformat\n        self._downloader.to_screen('[' + 'ffmpeg' + '] Converting video from %s to %s, Destination: ' % (information['ext'], self._preferedformat) + outpath)\n        self.run_ffmpeg(path, outpath, options)\n        information['filepath'] = outpath\n        information['format'] = self._preferedformat\n        information['ext'] = self._preferedformat\n        return [path], information\n\n\nclass FFmpegEmbedSubtitlePP(FFmpegPostProcessor):\n    def run(self, information):\n        if information['ext'] not in ('mp4', 'webm', 'mkv'):\n            self._downloader.to_screen('[ffmpeg] Subtitles can only be embedded in mp4, webm or mkv files')\n            return [], information\n        subtitles = information.get('requested_subtitles')\n        if not subtitles:\n            self._downloader.to_screen('[ffmpeg] There aren\\'t any subtitles to embed')\n            return [], information\n\n        filename = information['filepath']\n\n        ext = information['ext']\n        sub_langs = []\n        sub_filenames = []\n        webm_vtt_warn = False\n\n        for lang, sub_info in subtitles.items():\n            sub_ext = sub_info['ext']\n            if ext != 'webm' or ext == 'webm' and sub_ext == 'vtt':\n                sub_langs.append(lang)\n                sub_filenames.append(subtitles_filename(filename, lang, sub_ext))\n            else:\n                if not webm_vtt_warn and ext == 'webm' and sub_ext != 'vtt':\n                    webm_vtt_warn = True\n                    self._downloader.to_screen('[ffmpeg] Only WebVTT subtitles can be embedded in webm files')\n\n        if not sub_langs:\n            return [], information\n\n        input_files = [filename] + sub_filenames\n\n        opts = [\n            '-map', '0',\n            '-c', 'copy',\n            # Don't copy the existing subtitles, we may be running the\n            # postprocessor a second time\n            '-map', '-0:s',\n        ]\n        if information['ext'] == 'mp4':\n            opts += ['-c:s', 'mov_text']\n        for (i, lang) in enumerate(sub_langs):\n            opts.extend(['-map', '%d:0' % (i + 1)])\n            lang_code = ISO639Utils.short2long(lang)\n            if lang_code is not None:\n                opts.extend(['-metadata:s:s:%d' % i, 'language=%s' % lang_code])\n\n        temp_filename = prepend_extension(filename, 'temp')\n        self._downloader.to_screen('[ffmpeg] Embedding subtitles in \\'%s\\'' % filename)\n        self.run_ffmpeg_multiple_files(input_files, temp_filename, opts)\n        os.remove(encodeFilename(filename))\n        os.rename(encodeFilename(temp_filename), encodeFilename(filename))\n\n        return sub_filenames, information\n\n\nclass FFmpegMetadataPP(FFmpegPostProcessor):\n    def run(self, info):\n        metadata = {}\n\n        def add(meta_list, info_list=None):\n            if not info_list:\n                info_list = meta_list\n            if not isinstance(meta_list, (list, tuple)):\n                meta_list = (meta_list,)\n            if not isinstance(info_list, (list, tuple)):\n                info_list = (info_list,)\n            for info_f in info_list:\n                if info.get(info_f) is not None:\n                    for meta_f in meta_list:\n                        metadata[meta_f] = info[info_f]\n                    break\n\n        add('title', ('track', 'title'))\n        add('date', 'upload_date')\n        add(('description', 'comment'), 'description')\n        add('purl', 'webpage_url')\n        add('track', 'track_number')\n        add('artist', ('artist', 'creator', 'uploader', 'uploader_id'))\n        add('genre')\n        add('album')\n        add('album_artist')\n        add('disc', 'disc_number')\n\n        if not metadata:\n            self._downloader.to_screen('[ffmpeg] There isn\\'t any metadata to add')\n            return [], info\n\n        filename = info['filepath']\n        temp_filename = prepend_extension(filename, 'temp')\n        in_filenames = [filename]\n        options = []\n\n        if info['ext'] == 'm4a':\n            options.extend(['-vn', '-acodec', 'copy'])\n        else:\n            options.extend(['-c', 'copy'])\n\n        for (name, value) in metadata.items():\n            options.extend(['-metadata', '%s=%s' % (name, value)])\n\n        chapters = info.get('chapters', [])\n        if chapters:\n            metadata_filename = replace_extension(filename, 'meta')\n            with io.open(metadata_filename, 'wt', encoding='utf-8') as f:\n                def ffmpeg_escape(text):\n                    return re.sub(r'(=|;|#|\\\\|\\n)', r'\\\\\\1', text)\n\n                metadata_file_content = ';FFMETADATA1\\n'\n                for chapter in chapters:\n                    metadata_file_content += '[CHAPTER]\\nTIMEBASE=1/1000\\n'\n                    metadata_file_content += 'START=%d\\n' % (chapter['start_time'] * 1000)\n                    metadata_file_content += 'END=%d\\n' % (chapter['end_time'] * 1000)\n                    chapter_title = chapter.get('title')\n                    if chapter_title:\n                        metadata_file_content += 'title=%s\\n' % ffmpeg_escape(chapter_title)\n                f.write(metadata_file_content)\n                in_filenames.append(metadata_filename)\n                options.extend(['-map_metadata', '1'])\n\n        self._downloader.to_screen('[ffmpeg] Adding metadata to \\'%s\\'' % filename)\n        self.run_ffmpeg_multiple_files(in_filenames, temp_filename, options)\n        if chapters:\n            os.remove(metadata_filename)\n        os.remove(encodeFilename(filename))\n        os.rename(encodeFilename(temp_filename), encodeFilename(filename))\n        return [], info\n\n\nclass FFmpegMergerPP(FFmpegPostProcessor):\n    def run(self, info):\n        filename = info['filepath']\n        temp_filename = prepend_extension(filename, 'temp')\n        args = ['-c', 'copy', '-map', '0:v:0', '-map', '1:a:0']\n        self._downloader.to_screen('[ffmpeg] Merging formats into \"%s\"' % filename)\n        self.run_ffmpeg_multiple_files(info['__files_to_merge'], temp_filename, args)\n        os.rename(encodeFilename(temp_filename), encodeFilename(filename))\n        return info['__files_to_merge'], info\n\n    def can_merge(self):\n        # TODO: figure out merge-capable ffmpeg version\n        if self.basename != 'avconv':\n            return True\n\n        required_version = '10-0'\n        if is_outdated_version(\n                self._versions[self.basename], required_version):\n            warning = ('Your copy of %s is outdated and unable to properly mux separate video and audio files, '\n                       'youtube-dl will download single file media. '\n                       'Update %s to version %s or newer to fix this.') % (\n                           self.basename, self.basename, required_version)\n            if self._downloader:\n                self._downloader.report_warning(warning)\n            return False\n        return True\n\n\nclass FFmpegFixupStretchedPP(FFmpegPostProcessor):\n    def run(self, info):\n        stretched_ratio = info.get('stretched_ratio')\n        if stretched_ratio is None or stretched_ratio == 1:\n            return [], info\n\n        filename = info['filepath']\n        temp_filename = prepend_extension(filename, 'temp')\n\n        options = ['-c', 'copy', '-aspect', '%f' % stretched_ratio]\n        self._downloader.to_screen('[ffmpeg] Fixing aspect ratio in \"%s\"' % filename)\n        self.run_ffmpeg(filename, temp_filename, options)\n\n        os.remove(encodeFilename(filename))\n        os.rename(encodeFilename(temp_filename), encodeFilename(filename))\n\n        return [], info\n\n\nclass FFmpegFixupM4aPP(FFmpegPostProcessor):\n    def run(self, info):\n        if info.get('container') != 'm4a_dash':\n            return [], info\n\n        filename = info['filepath']\n        temp_filename = prepend_extension(filename, 'temp')\n\n        options = ['-c', 'copy', '-f', 'mp4']\n        self._downloader.to_screen('[ffmpeg] Correcting container in \"%s\"' % filename)\n        self.run_ffmpeg(filename, temp_filename, options)\n\n        os.remove(encodeFilename(filename))\n        os.rename(encodeFilename(temp_filename), encodeFilename(filename))\n\n        return [], info\n\n\nclass FFmpegFixupM3u8PP(FFmpegPostProcessor):\n    def run(self, info):\n        filename = info['filepath']\n        if self.get_audio_codec(filename) == 'aac':\n            temp_filename = prepend_extension(filename, 'temp')\n\n            options = ['-c', 'copy', '-f', 'mp4', '-bsf:a', 'aac_adtstoasc']\n            self._downloader.to_screen('[ffmpeg] Fixing malformed AAC bitstream in \"%s\"' % filename)\n            self.run_ffmpeg(filename, temp_filename, options)\n\n            os.remove(encodeFilename(filename))\n            os.rename(encodeFilename(temp_filename), encodeFilename(filename))\n        return [], info\n\n\nclass FFmpegSubtitlesConvertorPP(FFmpegPostProcessor):\n    def __init__(self, downloader=None, format=None):\n        super(FFmpegSubtitlesConvertorPP, self).__init__(downloader)\n        self.format = format\n\n    def run(self, info):\n        subs = info.get('requested_subtitles')\n        filename = info['filepath']\n        new_ext = self.format\n        new_format = new_ext\n        if new_format == 'vtt':\n            new_format = 'webvtt'\n        if subs is None:\n            self._downloader.to_screen('[ffmpeg] There aren\\'t any subtitles to convert')\n            return [], info\n        self._downloader.to_screen('[ffmpeg] Converting subtitles')\n        sub_filenames = []\n        for lang, sub in subs.items():\n            ext = sub['ext']\n            if ext == new_ext:\n                self._downloader.to_screen(\n                    '[ffmpeg] Subtitle file for %s is already in the requested format' % new_ext)\n                continue\n            old_file = subtitles_filename(filename, lang, ext)\n            sub_filenames.append(old_file)\n            new_file = subtitles_filename(filename, lang, new_ext)\n\n            if ext in ('dfxp', 'ttml', 'tt'):\n                self._downloader.report_warning(\n                    'You have requested to convert dfxp (TTML) subtitles into another format, '\n                    'which results in style information loss')\n\n                dfxp_file = old_file\n                srt_file = subtitles_filename(filename, lang, 'srt')\n\n                with open(dfxp_file, 'rb') as f:\n                    srt_data = dfxp2srt(f.read())\n\n                with io.open(srt_file, 'wt', encoding='utf-8') as f:\n                    f.write(srt_data)\n                old_file = srt_file\n\n                subs[lang] = {\n                    'ext': 'srt',\n                    'data': srt_data\n                }\n\n                if new_ext == 'srt':\n                    continue\n                else:\n                    sub_filenames.append(srt_file)\n\n            self.run_ffmpeg(old_file, new_file, ['-f', new_format])\n\n            with io.open(new_file, 'rt', encoding='utf-8') as f:\n                subs[lang] = {\n                    'ext': new_ext,\n                    'data': f.read(),\n                }\n\n        return sub_filenames, info\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "ffmpeg.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/postprocessor/ffmpeg.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}