{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom odoo import api, models, fields, tools, _\nfrom odoo.addons import decimal_precision as dp\nfrom odoo.exceptions import UserError\n\n\nclass ProductChangeQuantity(models.TransientModel):\n    _name = \"stock.change.product.qty\"\n    _description = \"Change Product Quantity\"\n\n    # TDE FIXME: strange dfeault method, was present before migration ? to check\n    product_id = fields.Many2one('product.product', 'Product', required=True)\n    product_tmpl_id = fields.Many2one('product.template', 'Template', required=True)\n    product_variant_count = fields.Integer('Variant Count', related='product_tmpl_id.product_variant_count')\n    new_quantity = fields.Float(\n        'New Quantity on Hand', default=1,\n        digits=dp.get_precision('Product Unit of Measure'), required=True,\n        help='This quantity is expressed in the Default Unit of Measure of the product.')\n    lot_id = fields.Many2one('stock.production.lot', 'Lot/Serial Number', domain=\"[('product_id','=',product_id)]\")\n    location_id = fields.Many2one('stock.location', 'Location', required=True, domain=\"[('usage', '=', 'internal')]\")\n\n    @api.model\n    def default_get(self, fields):\n        res = super(ProductChangeQuantity, self).default_get(fields)\n        if not res.get('product_id') and self.env.context.get('active_id') and self.env.context.get('active_model') == 'product.template' and self.env.context.get('active_id'):\n            res['product_id'] = self.env['product.product'].search([('product_tmpl_id', '=', self.env.context['active_id'])], limit=1).id\n        elif not res.get('product_id') and self.env.context.get('active_id') and self.env.context.get('active_model') == 'product.product' and self.env.context.get('active_id'):\n            res['product_id'] = self.env['product.product'].browse(self.env.context['active_id']).id\n        if 'location_id' in fields and not res.get('location_id'):\n            company_user = self.env.user.company_id\n            warehouse = self.env['stock.warehouse'].search([('company_id', '=', company_user.id)], limit=1)\n            if warehouse:\n                res['location_id'] = warehouse.lot_stock_id.id\n        return res\n\n    @api.onchange('location_id', 'product_id')\n    def onchange_location_id(self):\n        ?\n        if self.location_id and self.product_id:\n            availability = self.product_id.with_context(compute_child=False)._product_available()\n            self.new_quantity = availability[self.product_id.id]['qty_available']\n\n    @api.onchange('product_id')\n    def onchange_product_id(self):\n        if self.product_id:\n            self.product_tmpl_id = self.onchange_product_id_dict(self.product_id.id)['product_tmpl_id']\n\n    def _action_start_line(self):\n        product = self.product_id.with_context(location=self.location_id.id, lot_id=self.lot_id.id)\n        th_qty = product.qty_available\n\n        res = {\n               'product_qty': self.new_quantity,\n               'location_id': self.location_id.id,\n               'product_id': self.product_id.id,\n               'product_uom_id': self.product_id.uom_id.id,\n               'theoretical_qty': th_qty,\n               'prod_lot_id': self.lot_id.id,\n        }\n\n        return res\n\n\n    def onchange_product_id_dict(self, product_id):\n        return {\n            'product_tmpl_id': self.env['product.product'].browse(product_id).product_tmpl_id.id,\n        }\n\n    @api.model\n    def create(self, values):\n        if values.get('product_id'):\n            values.update(self.onchange_product_id_dict(values['product_id']))\n        return super(ProductChangeQuantity, self).create(values)\n\n    @api.constrains('new_quantity')\n    def check_new_quantity(self):\n        if any(wizard.new_quantity < 0 for wizard in self):\n            raise UserError(_('Quantity cannot be negative.'))\n\n    def change_product_qty(self):\n        \n        Inventory = self.env['stock.inventory']\n        for wizard in self:\n            product = wizard.product_id.with_context(location=wizard.location_id.id, lot_id=wizard.lot_id.id)\n            line_data = wizard._action_start_line()\n\n\n            if wizard.product_id.id and wizard.lot_id.id:\n                inventory_filter = 'none'\n            elif wizard.product_id.id:\n                inventory_filter = 'product'\n            else:\n                inventory_filter = 'none'\n            inventory = Inventory.create({\n                'name': _('INV: %s') % tools.ustr(wizard.product_id.display_name),\n                'filter': inventory_filter,\n                'product_id': wizard.product_id.id,\n                'location_id': wizard.location_id.id,\n                'lot_id': wizard.lot_id.id,\n                'line_ids': [(0, 0, line_data)],\n            })\n            inventory.action_done()\n        return {'type': 'ir.actions.act_window_close'}\n", "comments": "    changes product quantity making physical inventory             coding  utf 8        part odoo  see license file full copyright licensing details     tde fixme  strange dfeault method  present migration   check    tde fixme  nt use context   location   ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom odoo import api, models, fields, tools, _\nfrom odoo.addons import decimal_precision as dp\nfrom odoo.exceptions import UserError\n\n\nclass ProductChangeQuantity(models.TransientModel):\n    _name = \"stock.change.product.qty\"\n    _description = \"Change Product Quantity\"\n\n    # TDE FIXME: strange dfeault method, was present before migration ? to check\n    product_id = fields.Many2one('product.product', 'Product', required=True)\n    product_tmpl_id = fields.Many2one('product.template', 'Template', required=True)\n    product_variant_count = fields.Integer('Variant Count', related='product_tmpl_id.product_variant_count')\n    new_quantity = fields.Float(\n        'New Quantity on Hand', default=1,\n        digits=dp.get_precision('Product Unit of Measure'), required=True,\n        help='This quantity is expressed in the Default Unit of Measure of the product.')\n    lot_id = fields.Many2one('stock.production.lot', 'Lot/Serial Number', domain=\"[('product_id','=',product_id)]\")\n    location_id = fields.Many2one('stock.location', 'Location', required=True, domain=\"[('usage', '=', 'internal')]\")\n\n    @api.model\n    def default_get(self, fields):\n        res = super(ProductChangeQuantity, self).default_get(fields)\n        if not res.get('product_id') and self.env.context.get('active_id') and self.env.context.get('active_model') == 'product.template' and self.env.context.get('active_id'):\n            res['product_id'] = self.env['product.product'].search([('product_tmpl_id', '=', self.env.context['active_id'])], limit=1).id\n        elif not res.get('product_id') and self.env.context.get('active_id') and self.env.context.get('active_model') == 'product.product' and self.env.context.get('active_id'):\n            res['product_id'] = self.env['product.product'].browse(self.env.context['active_id']).id\n        if 'location_id' in fields and not res.get('location_id'):\n            company_user = self.env.user.company_id\n            warehouse = self.env['stock.warehouse'].search([('company_id', '=', company_user.id)], limit=1)\n            if warehouse:\n                res['location_id'] = warehouse.lot_stock_id.id\n        return res\n\n    @api.onchange('location_id', 'product_id')\n    def onchange_location_id(self):\n        # TDE FIXME: should'nt we use context / location ?\n        if self.location_id and self.product_id:\n            availability = self.product_id.with_context(compute_child=False)._product_available()\n            self.new_quantity = availability[self.product_id.id]['qty_available']\n\n    @api.onchange('product_id')\n    def onchange_product_id(self):\n        if self.product_id:\n            self.product_tmpl_id = self.onchange_product_id_dict(self.product_id.id)['product_tmpl_id']\n\n    def _action_start_line(self):\n        product = self.product_id.with_context(location=self.location_id.id, lot_id=self.lot_id.id)\n        th_qty = product.qty_available\n\n        res = {\n               'product_qty': self.new_quantity,\n               'location_id': self.location_id.id,\n               'product_id': self.product_id.id,\n               'product_uom_id': self.product_id.uom_id.id,\n               'theoretical_qty': th_qty,\n               'prod_lot_id': self.lot_id.id,\n        }\n\n        return res\n\n\n    def onchange_product_id_dict(self, product_id):\n        return {\n            'product_tmpl_id': self.env['product.product'].browse(product_id).product_tmpl_id.id,\n        }\n\n    @api.model\n    def create(self, values):\n        if values.get('product_id'):\n            values.update(self.onchange_product_id_dict(values['product_id']))\n        return super(ProductChangeQuantity, self).create(values)\n\n    @api.constrains('new_quantity')\n    def check_new_quantity(self):\n        if any(wizard.new_quantity < 0 for wizard in self):\n            raise UserError(_('Quantity cannot be negative.'))\n\n    def change_product_qty(self):\n        \"\"\" Changes the Product Quantity by making a Physical Inventory. \"\"\"\n        Inventory = self.env['stock.inventory']\n        for wizard in self:\n            product = wizard.product_id.with_context(location=wizard.location_id.id, lot_id=wizard.lot_id.id)\n            line_data = wizard._action_start_line()\n\n\n            if wizard.product_id.id and wizard.lot_id.id:\n                inventory_filter = 'none'\n            elif wizard.product_id.id:\n                inventory_filter = 'product'\n            else:\n                inventory_filter = 'none'\n            inventory = Inventory.create({\n                'name': _('INV: %s') % tools.ustr(wizard.product_id.display_name),\n                'filter': inventory_filter,\n                'product_id': wizard.product_id.id,\n                'location_id': wizard.location_id.id,\n                'lot_id': wizard.lot_id.id,\n                'line_ids': [(0, 0, line_data)],\n            })\n            inventory.action_done()\n        return {'type': 'ir.actions.act_window_close'}\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "stock_change_product_qty.py", "id": "dfabe956006828d6808d9b00b5572b27", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/stock/wizard/stock_change_product_qty.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}