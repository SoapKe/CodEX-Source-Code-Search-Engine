{"author": "rg3", "code": "\n\nfrom __future__ import unicode_literals\n\n\nimport os\nimport sys\nimport unittest\nsys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom test.helper import (\n    assertGreaterEqual,\n    expect_warnings,\n    get_params,\n    gettestcases,\n    expect_info_dict,\n    try_rm,\n    report_warning,\n)\n\n\nimport hashlib\nimport io\nimport json\nimport socket\n\nimport youtube_dl.YoutubeDL\nfrom youtube_dl.compat import (\n    compat_http_client,\n    compat_urllib_error,\n    compat_HTTPError,\n)\nfrom youtube_dl.utils import (\n    DownloadError,\n    ExtractorError,\n    format_bytes,\n    UnavailableVideoError,\n)\nfrom youtube_dl.extractor import get_info_extractor\n\nRETRIES = 3\n\n\nclass YoutubeDL(youtube_dl.YoutubeDL):\n    def __init__(self, *args, **kwargs):\n        self.to_stderr = self.to_screen\n        self.processed_info_dicts = []\n        super(YoutubeDL, self).__init__(*args, **kwargs)\n\n    def report_warning(self, message):\n        \n        raise ExtractorError(message)\n\n    def process_info(self, info_dict):\n        self.processed_info_dicts.append(info_dict)\n        return super(YoutubeDL, self).process_info(info_dict)\n\n\ndef _file_md5(fn):\n    with open(fn, 'rb') as f:\n        return hashlib.md5(f.read()).hexdigest()\n\n\ndefs = gettestcases()\n\n\nclass TestDownload(unittest.TestCase):\n    \n    \n    _multiprocess_shared_ = True\n\n    maxDiff = None\n\n    def __str__(self):\n        \n            return '%s.%s' % (cls.__module__, cls.__name__)\n\n        add_ie = getattr(self, self._testMethodName).add_ie\n        return '%s (%s)%s:' % (self._testMethodName,\n                               strclass(self.__class__),\n                               ' [%s]' % add_ie if add_ie else '')\n\n    def setUp(self):\n        self.defs = defs\n\n\n\n\ndef generator(test_case, tname):\n\n    def test_template(self):\n        ie = youtube_dl.extractor.get_info_extractor(test_case['name'])()\n        other_ies = [get_info_extractor(ie_key)() for ie_key in test_case.get('add_ie', [])]\n        is_playlist = any(k.startswith('playlist') for k in test_case)\n        test_cases = test_case.get(\n            'playlist', [] if is_playlist else [test_case])\n\n        def print_skipping(reason):\n            print('Skipping %s: %s' % (test_case['name'], reason))\n        if not ie.working():\n            print_skipping('IE marked as not _WORKING')\n            return\n\n        for tc in test_cases:\n            info_dict = tc.get('info_dict', {})\n            if not (info_dict.get('id') and info_dict.get('ext')):\n                raise Exception('Test definition incorrect. The output file cannot be known. Are both \\'id\\' and \\'ext\\' keys present?')\n\n        if 'skip' in test_case:\n            print_skipping(test_case['skip'])\n            return\n        for other_ie in other_ies:\n            if not other_ie.working():\n                print_skipping('test depends on %sIE, marked as not WORKING' % other_ie.ie_key())\n                return\n\n        params = get_params(test_case.get('params', {}))\n        params['outtmpl'] = tname + '_' + params['outtmpl']\n        if is_playlist and 'playlist' not in test_case:\n            params.setdefault('extract_flat', 'in_playlist')\n            params.setdefault('skip_download', True)\n\n        ydl = YoutubeDL(params, auto_init=False)\n        ydl.add_default_info_extractors()\n        finished_hook_called = set()\n\n        def _hook(status):\n            if status['status'] == 'finished':\n                finished_hook_called.add(status['filename'])\n        ydl.add_progress_hook(_hook)\n        expect_warnings(ydl, test_case.get('expected_warnings', []))\n\n        def get_tc_filename(tc):\n            return ydl.prepare_filename(tc.get('info_dict', {}))\n\n        res_dict = None\n\n        def try_rm_tcs_files(tcs=None):\n            if tcs is None:\n                tcs = test_cases\n            for tc in tcs:\n                tc_filename = get_tc_filename(tc)\n                try_rm(tc_filename)\n                try_rm(tc_filename + '.part')\n                try_rm(os.path.splitext(tc_filename)[0] + '.info.json')\n        try_rm_tcs_files()\n        try:\n            try_num = 1\n            while True:\n                try:\n                    \n                    \n                    \n                    res_dict = ydl.extract_info(\n                        test_case['url'],\n                        force_generic_extractor=params.get('force_generic_extractor', False))\n                except (DownloadError, ExtractorError) as err:\n                    \n                    if not err.exc_info[0] in (compat_urllib_error.URLError, socket.timeout, UnavailableVideoError, compat_http_client.BadStatusLine) or (err.exc_info[0] == compat_HTTPError and err.exc_info[1].code == 503):\n                        raise\n\n                    if try_num == RETRIES:\n                        report_warning('%s failed due to network errors, skipping...' % tname)\n                        return\n\n                    print('Retrying: {0} failed tries\\n\\n\n\n                    try_num += 1\n                else:\n                    break\n\n            if is_playlist:\n                self.assertTrue(res_dict['_type'] in ['playlist', 'multi_video'])\n                self.assertTrue('entries' in res_dict)\n                expect_info_dict(self, res_dict, test_case.get('info_dict', {}))\n\n            if 'playlist_mincount' in test_case:\n                assertGreaterEqual(\n                    self,\n                    len(res_dict['entries']),\n                    test_case['playlist_mincount'],\n                    'Expected at least %d in playlist %s, but got only %d' % (\n                        test_case['playlist_mincount'], test_case['url'],\n                        len(res_dict['entries'])))\n            if 'playlist_count' in test_case:\n                self.assertEqual(\n                    len(res_dict['entries']),\n                    test_case['playlist_count'],\n                    'Expected %d entries in playlist %s, but got %d.' % (\n                        test_case['playlist_count'],\n                        test_case['url'],\n                        len(res_dict['entries']),\n                    ))\n            if 'playlist_duration_sum' in test_case:\n                got_duration = sum(e['duration'] for e in res_dict['entries'])\n                self.assertEqual(\n                    test_case['playlist_duration_sum'], got_duration)\n\n            \n            \n            if 'entries' not in res_dict:\n                res_dict['entries'] = [res_dict]\n\n            for tc_num, tc in enumerate(test_cases):\n                tc_res_dict = res_dict['entries'][tc_num]\n                \n                expect_info_dict(self, tc_res_dict, tc.get('info_dict', {}))\n                \n                tc_filename = get_tc_filename(tc)\n                if not test_case.get('params', {}).get('skip_download', False):\n                    self.assertTrue(os.path.exists(tc_filename), msg='Missing file ' + tc_filename)\n                    self.assertTrue(tc_filename in finished_hook_called)\n                    expected_minsize = tc.get('file_minsize', 10000)\n                    if expected_minsize is not None:\n                        if params.get('test'):\n                            expected_minsize = max(expected_minsize, 10000)\n                        got_fsize = os.path.getsize(tc_filename)\n                        assertGreaterEqual(\n                            self, got_fsize, expected_minsize,\n                            'Expected %s to be at least %s, but it\\'s only %s ' %\n                            (tc_filename, format_bytes(expected_minsize),\n                                format_bytes(got_fsize)))\n                    if 'md5' in tc:\n                        md5_for_file = _file_md5(tc_filename)\n                        self.assertEqual(tc['md5'], md5_for_file)\n                \n                \n                info_json_fn = os.path.splitext(tc_filename)[0] + '.info.json'\n                self.assertTrue(\n                    os.path.exists(info_json_fn),\n                    'Missing info file %s' % info_json_fn)\n                with io.open(info_json_fn, encoding='utf-8') as infof:\n                    info_dict = json.load(infof)\n                expect_info_dict(self, info_dict, tc.get('info_dict', {}))\n        finally:\n            try_rm_tcs_files()\n            if is_playlist and res_dict is not None and res_dict.get('entries'):\n                \n                \n                res_tcs = [{'info_dict': e} for e in res_dict['entries']]\n                try_rm_tcs_files(res_tcs)\n\n    return test_template\n\n\n\nfor n, test_case in enumerate(defs):\n    tname = 'test_' + str(test_case['name'])\n    i = 1\n    while hasattr(TestDownload, tname):\n        tname = 'test_%s_%d' % (test_case['name'], i)\n        i += 1\n    test_method = generator(test_case, tname)\n    test_method.__name__ = str(tname)\n    ie_list = test_case.get('add_ie')\n    test_method.add_ie = ie_list and ','.join(ie_list)\n    setattr(TestDownload, test_method.__name__, test_method)\n    del test_method\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "comments": "Identify each test with the `add_ie` attribute, if available.\"\"\"\n\n        def strclass(cls):\n            \"\"\"From 2.7's unittest; 2.6 had _strclass so we can't import it.\n.\n#!/usr/bin/env python\n# Allow direct execution\n# Don't accept warnings during tests\n# Parallel testing in nosetests. See\n# http://nose.readthedocs.org/en/latest/doc_tests/test_multiprocess/multiprocess.html\n# Dynamically generate tests\n# We're not using .download here since that is just a shim\n# for outside error handling, and returns the exit code\n# instead of the result dict.\n# Check if the exception is not a network related one\n##########\\n\\n'.format(try_num))\n# Generalize both playlists and single videos to unified format for\n# simplicity\n# First, check test cases' data against extracted data alone\n# Now, check downloaded file consistency\n# Finally, check test cases' data again but this time against\n# extracted data from info JSON file written during processing\n# Remove all other files that may have been extracted if the\n# extractor returns full results even with extract_flat\n# And add them to TestDownload\n", "content": "#!/usr/bin/env python\n\nfrom __future__ import unicode_literals\n\n# Allow direct execution\nimport os\nimport sys\nimport unittest\nsys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom test.helper import (\n    assertGreaterEqual,\n    expect_warnings,\n    get_params,\n    gettestcases,\n    expect_info_dict,\n    try_rm,\n    report_warning,\n)\n\n\nimport hashlib\nimport io\nimport json\nimport socket\n\nimport youtube_dl.YoutubeDL\nfrom youtube_dl.compat import (\n    compat_http_client,\n    compat_urllib_error,\n    compat_HTTPError,\n)\nfrom youtube_dl.utils import (\n    DownloadError,\n    ExtractorError,\n    format_bytes,\n    UnavailableVideoError,\n)\nfrom youtube_dl.extractor import get_info_extractor\n\nRETRIES = 3\n\n\nclass YoutubeDL(youtube_dl.YoutubeDL):\n    def __init__(self, *args, **kwargs):\n        self.to_stderr = self.to_screen\n        self.processed_info_dicts = []\n        super(YoutubeDL, self).__init__(*args, **kwargs)\n\n    def report_warning(self, message):\n        # Don't accept warnings during tests\n        raise ExtractorError(message)\n\n    def process_info(self, info_dict):\n        self.processed_info_dicts.append(info_dict)\n        return super(YoutubeDL, self).process_info(info_dict)\n\n\ndef _file_md5(fn):\n    with open(fn, 'rb') as f:\n        return hashlib.md5(f.read()).hexdigest()\n\n\ndefs = gettestcases()\n\n\nclass TestDownload(unittest.TestCase):\n    # Parallel testing in nosetests. See\n    # http://nose.readthedocs.org/en/latest/doc_tests/test_multiprocess/multiprocess.html\n    _multiprocess_shared_ = True\n\n    maxDiff = None\n\n    def __str__(self):\n        \"\"\"Identify each test with the `add_ie` attribute, if available.\"\"\"\n\n        def strclass(cls):\n            \"\"\"From 2.7's unittest; 2.6 had _strclass so we can't import it.\"\"\"\n            return '%s.%s' % (cls.__module__, cls.__name__)\n\n        add_ie = getattr(self, self._testMethodName).add_ie\n        return '%s (%s)%s:' % (self._testMethodName,\n                               strclass(self.__class__),\n                               ' [%s]' % add_ie if add_ie else '')\n\n    def setUp(self):\n        self.defs = defs\n\n# Dynamically generate tests\n\n\ndef generator(test_case, tname):\n\n    def test_template(self):\n        ie = youtube_dl.extractor.get_info_extractor(test_case['name'])()\n        other_ies = [get_info_extractor(ie_key)() for ie_key in test_case.get('add_ie', [])]\n        is_playlist = any(k.startswith('playlist') for k in test_case)\n        test_cases = test_case.get(\n            'playlist', [] if is_playlist else [test_case])\n\n        def print_skipping(reason):\n            print('Skipping %s: %s' % (test_case['name'], reason))\n        if not ie.working():\n            print_skipping('IE marked as not _WORKING')\n            return\n\n        for tc in test_cases:\n            info_dict = tc.get('info_dict', {})\n            if not (info_dict.get('id') and info_dict.get('ext')):\n                raise Exception('Test definition incorrect. The output file cannot be known. Are both \\'id\\' and \\'ext\\' keys present?')\n\n        if 'skip' in test_case:\n            print_skipping(test_case['skip'])\n            return\n        for other_ie in other_ies:\n            if not other_ie.working():\n                print_skipping('test depends on %sIE, marked as not WORKING' % other_ie.ie_key())\n                return\n\n        params = get_params(test_case.get('params', {}))\n        params['outtmpl'] = tname + '_' + params['outtmpl']\n        if is_playlist and 'playlist' not in test_case:\n            params.setdefault('extract_flat', 'in_playlist')\n            params.setdefault('skip_download', True)\n\n        ydl = YoutubeDL(params, auto_init=False)\n        ydl.add_default_info_extractors()\n        finished_hook_called = set()\n\n        def _hook(status):\n            if status['status'] == 'finished':\n                finished_hook_called.add(status['filename'])\n        ydl.add_progress_hook(_hook)\n        expect_warnings(ydl, test_case.get('expected_warnings', []))\n\n        def get_tc_filename(tc):\n            return ydl.prepare_filename(tc.get('info_dict', {}))\n\n        res_dict = None\n\n        def try_rm_tcs_files(tcs=None):\n            if tcs is None:\n                tcs = test_cases\n            for tc in tcs:\n                tc_filename = get_tc_filename(tc)\n                try_rm(tc_filename)\n                try_rm(tc_filename + '.part')\n                try_rm(os.path.splitext(tc_filename)[0] + '.info.json')\n        try_rm_tcs_files()\n        try:\n            try_num = 1\n            while True:\n                try:\n                    # We're not using .download here since that is just a shim\n                    # for outside error handling, and returns the exit code\n                    # instead of the result dict.\n                    res_dict = ydl.extract_info(\n                        test_case['url'],\n                        force_generic_extractor=params.get('force_generic_extractor', False))\n                except (DownloadError, ExtractorError) as err:\n                    # Check if the exception is not a network related one\n                    if not err.exc_info[0] in (compat_urllib_error.URLError, socket.timeout, UnavailableVideoError, compat_http_client.BadStatusLine) or (err.exc_info[0] == compat_HTTPError and err.exc_info[1].code == 503):\n                        raise\n\n                    if try_num == RETRIES:\n                        report_warning('%s failed due to network errors, skipping...' % tname)\n                        return\n\n                    print('Retrying: {0} failed tries\\n\\n##########\\n\\n'.format(try_num))\n\n                    try_num += 1\n                else:\n                    break\n\n            if is_playlist:\n                self.assertTrue(res_dict['_type'] in ['playlist', 'multi_video'])\n                self.assertTrue('entries' in res_dict)\n                expect_info_dict(self, res_dict, test_case.get('info_dict', {}))\n\n            if 'playlist_mincount' in test_case:\n                assertGreaterEqual(\n                    self,\n                    len(res_dict['entries']),\n                    test_case['playlist_mincount'],\n                    'Expected at least %d in playlist %s, but got only %d' % (\n                        test_case['playlist_mincount'], test_case['url'],\n                        len(res_dict['entries'])))\n            if 'playlist_count' in test_case:\n                self.assertEqual(\n                    len(res_dict['entries']),\n                    test_case['playlist_count'],\n                    'Expected %d entries in playlist %s, but got %d.' % (\n                        test_case['playlist_count'],\n                        test_case['url'],\n                        len(res_dict['entries']),\n                    ))\n            if 'playlist_duration_sum' in test_case:\n                got_duration = sum(e['duration'] for e in res_dict['entries'])\n                self.assertEqual(\n                    test_case['playlist_duration_sum'], got_duration)\n\n            # Generalize both playlists and single videos to unified format for\n            # simplicity\n            if 'entries' not in res_dict:\n                res_dict['entries'] = [res_dict]\n\n            for tc_num, tc in enumerate(test_cases):\n                tc_res_dict = res_dict['entries'][tc_num]\n                # First, check test cases' data against extracted data alone\n                expect_info_dict(self, tc_res_dict, tc.get('info_dict', {}))\n                # Now, check downloaded file consistency\n                tc_filename = get_tc_filename(tc)\n                if not test_case.get('params', {}).get('skip_download', False):\n                    self.assertTrue(os.path.exists(tc_filename), msg='Missing file ' + tc_filename)\n                    self.assertTrue(tc_filename in finished_hook_called)\n                    expected_minsize = tc.get('file_minsize', 10000)\n                    if expected_minsize is not None:\n                        if params.get('test'):\n                            expected_minsize = max(expected_minsize, 10000)\n                        got_fsize = os.path.getsize(tc_filename)\n                        assertGreaterEqual(\n                            self, got_fsize, expected_minsize,\n                            'Expected %s to be at least %s, but it\\'s only %s ' %\n                            (tc_filename, format_bytes(expected_minsize),\n                                format_bytes(got_fsize)))\n                    if 'md5' in tc:\n                        md5_for_file = _file_md5(tc_filename)\n                        self.assertEqual(tc['md5'], md5_for_file)\n                # Finally, check test cases' data again but this time against\n                # extracted data from info JSON file written during processing\n                info_json_fn = os.path.splitext(tc_filename)[0] + '.info.json'\n                self.assertTrue(\n                    os.path.exists(info_json_fn),\n                    'Missing info file %s' % info_json_fn)\n                with io.open(info_json_fn, encoding='utf-8') as infof:\n                    info_dict = json.load(infof)\n                expect_info_dict(self, info_dict, tc.get('info_dict', {}))\n        finally:\n            try_rm_tcs_files()\n            if is_playlist and res_dict is not None and res_dict.get('entries'):\n                # Remove all other files that may have been extracted if the\n                # extractor returns full results even with extract_flat\n                res_tcs = [{'info_dict': e} for e in res_dict['entries']]\n                try_rm_tcs_files(res_tcs)\n\n    return test_template\n\n\n# And add them to TestDownload\nfor n, test_case in enumerate(defs):\n    tname = 'test_' + str(test_case['name'])\n    i = 1\n    while hasattr(TestDownload, tname):\n        tname = 'test_%s_%d' % (test_case['name'], i)\n        i += 1\n    test_method = generator(test_case, tname)\n    test_method.__name__ = str(tname)\n    ie_list = test_case.get('add_ie')\n    test_method.add_ie = ie_list and ','.join(ie_list)\n    setattr(TestDownload, test_method.__name__, test_method)\n    del test_method\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "test_download.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/test/test_download.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}