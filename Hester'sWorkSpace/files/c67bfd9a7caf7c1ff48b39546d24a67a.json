{"author": "HelloZeroNet", "code": "\n This file is part of pyasn1 software.\n\n Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>\n License: http://pyasn1.sf.net/license.html\n\ntry:\n    from collections import OrderedDict\n\nexcept ImportError:\n    OrderedDict = dict\n\nfrom pyasn1.type import base, univ, char, useful\nfrom pyasn1 import debug, error\n\n__all__ = ['encode']\n\n\nclass AbstractItemEncoder(object):\n    def encode(self, encodeFun, value):\n        raise error.PyAsn1Error('Not implemented')\n\n\nclass ExplicitlyTaggedItemEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        if isinstance(value, base.AbstractConstructedAsn1Item):\n            value = value.clone(tagSet=value.tagSet[:-1],\n                                cloneValueFlag=1)\n        else:\n            value = value.clone(tagSet=value.tagSet[:-1])\n        return encodeFun(value)\n\nexplicitlyTaggedItemEncoder = ExplicitlyTaggedItemEncoder()\n\n\nclass BooleanEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return bool(value)\n\n\nclass IntegerEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return int(value)\n\n\nclass BitStringEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return str(value)\n\n\nclass OctetStringEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return value.asOctets()\n\n\nclass TextStringEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return value.prettyPrint()\n\n\nclass NullEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return None\n\n\nclass ObjectIdentifierEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return str(value)\n\n\nclass RealEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return float(value)\n\n\nclass SetEncoder(AbstractItemEncoder):\n    protoDict = dict\n    def encode(self, encodeFun, value):\n        value.verifySizeSpec()\n        namedTypes = value.getComponentType()\n        substrate = self.protoDict()\n        for idx, (key, subValue) in enumerate(value.items()):\n            if namedTypes[idx].isOptional and not value[idx].isValue:\n                continue\n            substrate[key] = encodeFun(subValue)\n        return substrate\n\n\nclass SequenceEncoder(SetEncoder):\n    protoDict = OrderedDict\n\n\nclass SequenceOfEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        value.verifySizeSpec()\n        return [encodeFun(x) for x in value]\n\n\nclass ChoiceEncoder(SequenceEncoder):\n    pass\n\n\nclass AnyEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return value.asOctets()\n\n\ntagMap = {\n    univ.Boolean.tagSet: BooleanEncoder(),\n    univ.Integer.tagSet: IntegerEncoder(),\n    univ.BitString.tagSet: BitStringEncoder(),\n    univ.OctetString.tagSet: OctetStringEncoder(),\n    univ.Null.tagSet: NullEncoder(),\n    univ.ObjectIdentifier.tagSet: ObjectIdentifierEncoder(),\n    univ.Enumerated.tagSet: IntegerEncoder(),\n    univ.Real.tagSet: RealEncoder(),\n     Sequence & Set have same tags as SequenceOf & SetOf\n    univ.SequenceOf.tagSet: SequenceOfEncoder(),\n    univ.SetOf.tagSet: SequenceOfEncoder(),\n    univ.Choice.tagSet: ChoiceEncoder(),\n     character string types\n    char.UTF8String.tagSet: TextStringEncoder(),\n    char.NumericString.tagSet: TextStringEncoder(),\n    char.PrintableString.tagSet: TextStringEncoder(),\n    char.TeletexString.tagSet: TextStringEncoder(),\n    char.VideotexString.tagSet: TextStringEncoder(),\n    char.IA5String.tagSet: TextStringEncoder(),\n    char.GraphicString.tagSet: TextStringEncoder(),\n    char.VisibleString.tagSet: TextStringEncoder(),\n    char.GeneralString.tagSet: TextStringEncoder(),\n    char.UniversalString.tagSet: TextStringEncoder(),\n    char.BMPString.tagSet: TextStringEncoder(),\n     useful types\n    useful.ObjectDescriptor.tagSet: OctetStringEncoder(),\n    useful.GeneralizedTime.tagSet: OctetStringEncoder(),\n    useful.UTCTime.tagSet: OctetStringEncoder()\n}\n\n Type-to-codec map for ambiguous ASN.1 types\ntypeMap = {\n    univ.Set.typeId: SetEncoder(),\n    univ.SetOf.typeId: SequenceOfEncoder(),\n    univ.Sequence.typeId: SequenceEncoder(),\n    univ.SequenceOf.typeId: SequenceOfEncoder(),\n    univ.Choice.typeId: ChoiceEncoder(),\n    univ.Any.typeId: AnyEncoder()\n}\n\n\nclass Encoder(object):\n\n     noinspection PyDefaultArgument\n    def __init__(self, tagMap, typeMap={}):\n        self.__tagMap = tagMap\n        self.__typeMap = typeMap\n\n    def __call__(self, asn1Value):\n        if not isinstance(asn1Value, base.Asn1Item):\n            raise error.PyAsn1Error('value is not valid (should be an instance of an ASN.1 Item)')\n\n        if debug.logger & debug.flagEncoder:\n            debug.scope.push(type(asn1Value).__name__)\n            debug.logger('encoder called for type %s <%s>' % (type(asn1Value).__name__, asn1Value.prettyPrint()))\n\n        tagSet = asn1Value.tagSet\n        if len(tagSet) > 1:\n            concreteEncoder = explicitlyTaggedItemEncoder\n        else:\n            if asn1Value.typeId is not None and asn1Value.typeId in self.__typeMap:\n                concreteEncoder = self.__typeMap[asn1Value.typeId]\n            elif tagSet in self.__tagMap:\n                concreteEncoder = self.__tagMap[tagSet]\n            else:\n                tagSet = asn1Value.baseTagSet\n                if tagSet in self.__tagMap:\n                    concreteEncoder = self.__tagMap[tagSet]\n                else:\n                    raise error.PyAsn1Error('No encoder for %s' % (asn1Value,))\n\n        debug.logger & debug.flagEncoder and debug.logger('using value codec %s chosen by %s' % (type(concreteEncoder).__name__, tagSet))\n\n        pyObject = concreteEncoder.encode(self, asn1Value)\n\n        if debug.logger & debug.flagEncoder:\n            debug.logger('encoder %s produced: %s' % (type(concreteEncoder).__name__, repr(pyObject)))\n            debug.scope.pop()\n\n        return pyObject\n\n\n: Turns ASN.1 object into a Python built-in type object(s).\n:\n: Takes any ASN.1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n: walks all its components recursively and produces a Python built-in type or a tree\n: of those.\n:\n: One exception is that instead of :py:class:`dict`, the :py:class:`OrderedDict`\n: can be produced (whenever available) to preserve ordering of the components\n: in ASN.1 SEQUENCE.\n:\n: Parameters\n: ----------\n  asn1Value: any pyasn1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n:     pyasn1 object to encode (or a tree of them)\n:\n: Returns\n: -------\n: : :py:class:`object`\n:     Python built-in type instance (or a tree of them)\n:\n: Raises\n: ------\n: : :py:class:`pyasn1.error.PyAsn1Error`\n:     On encoding errors\nencode = Encoder(tagMap, typeMap)\n", "comments": "     this file part pyasn1 software        copyright (c) 2005 2017  ilya etingof  etingof gmail com     license  http   pyasn1 sf net license html       sequence   set tags sequenceof   setof    character string types    useful types    type codec map ambiguous asn 1 types    noinspection pydefaultargument     turns asn 1 object python built type object(s)          takes asn 1 object (e g   py class   pyasn1 type base pyasn1item  derivative)     walks components recursively produces python built type tree              one exception instead  py class  dict    py class  ordereddict      produced (whenever available) preserve ordering components     asn 1 sequence          parameters                    asn1value  pyasn1 object (e g   py class   pyasn1 type base pyasn1item  derivative)         pyasn1 object encode (or tree them)         returns                    py class  object          python built type instance (or tree them)         raises                   py class  pyasn1 error pyasn1error          on encoding errors ", "content": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2017, Ilya Etingof <etingof@gmail.com>\n# License: http://pyasn1.sf.net/license.html\n#\ntry:\n    from collections import OrderedDict\n\nexcept ImportError:\n    OrderedDict = dict\n\nfrom pyasn1.type import base, univ, char, useful\nfrom pyasn1 import debug, error\n\n__all__ = ['encode']\n\n\nclass AbstractItemEncoder(object):\n    def encode(self, encodeFun, value):\n        raise error.PyAsn1Error('Not implemented')\n\n\nclass ExplicitlyTaggedItemEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        if isinstance(value, base.AbstractConstructedAsn1Item):\n            value = value.clone(tagSet=value.tagSet[:-1],\n                                cloneValueFlag=1)\n        else:\n            value = value.clone(tagSet=value.tagSet[:-1])\n        return encodeFun(value)\n\nexplicitlyTaggedItemEncoder = ExplicitlyTaggedItemEncoder()\n\n\nclass BooleanEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return bool(value)\n\n\nclass IntegerEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return int(value)\n\n\nclass BitStringEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return str(value)\n\n\nclass OctetStringEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return value.asOctets()\n\n\nclass TextStringEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return value.prettyPrint()\n\n\nclass NullEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return None\n\n\nclass ObjectIdentifierEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return str(value)\n\n\nclass RealEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return float(value)\n\n\nclass SetEncoder(AbstractItemEncoder):\n    protoDict = dict\n    def encode(self, encodeFun, value):\n        value.verifySizeSpec()\n        namedTypes = value.getComponentType()\n        substrate = self.protoDict()\n        for idx, (key, subValue) in enumerate(value.items()):\n            if namedTypes[idx].isOptional and not value[idx].isValue:\n                continue\n            substrate[key] = encodeFun(subValue)\n        return substrate\n\n\nclass SequenceEncoder(SetEncoder):\n    protoDict = OrderedDict\n\n\nclass SequenceOfEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        value.verifySizeSpec()\n        return [encodeFun(x) for x in value]\n\n\nclass ChoiceEncoder(SequenceEncoder):\n    pass\n\n\nclass AnyEncoder(AbstractItemEncoder):\n    def encode(self, encodeFun, value):\n        return value.asOctets()\n\n\ntagMap = {\n    univ.Boolean.tagSet: BooleanEncoder(),\n    univ.Integer.tagSet: IntegerEncoder(),\n    univ.BitString.tagSet: BitStringEncoder(),\n    univ.OctetString.tagSet: OctetStringEncoder(),\n    univ.Null.tagSet: NullEncoder(),\n    univ.ObjectIdentifier.tagSet: ObjectIdentifierEncoder(),\n    univ.Enumerated.tagSet: IntegerEncoder(),\n    univ.Real.tagSet: RealEncoder(),\n    # Sequence & Set have same tags as SequenceOf & SetOf\n    univ.SequenceOf.tagSet: SequenceOfEncoder(),\n    univ.SetOf.tagSet: SequenceOfEncoder(),\n    univ.Choice.tagSet: ChoiceEncoder(),\n    # character string types\n    char.UTF8String.tagSet: TextStringEncoder(),\n    char.NumericString.tagSet: TextStringEncoder(),\n    char.PrintableString.tagSet: TextStringEncoder(),\n    char.TeletexString.tagSet: TextStringEncoder(),\n    char.VideotexString.tagSet: TextStringEncoder(),\n    char.IA5String.tagSet: TextStringEncoder(),\n    char.GraphicString.tagSet: TextStringEncoder(),\n    char.VisibleString.tagSet: TextStringEncoder(),\n    char.GeneralString.tagSet: TextStringEncoder(),\n    char.UniversalString.tagSet: TextStringEncoder(),\n    char.BMPString.tagSet: TextStringEncoder(),\n    # useful types\n    useful.ObjectDescriptor.tagSet: OctetStringEncoder(),\n    useful.GeneralizedTime.tagSet: OctetStringEncoder(),\n    useful.UTCTime.tagSet: OctetStringEncoder()\n}\n\n# Type-to-codec map for ambiguous ASN.1 types\ntypeMap = {\n    univ.Set.typeId: SetEncoder(),\n    univ.SetOf.typeId: SequenceOfEncoder(),\n    univ.Sequence.typeId: SequenceEncoder(),\n    univ.SequenceOf.typeId: SequenceOfEncoder(),\n    univ.Choice.typeId: ChoiceEncoder(),\n    univ.Any.typeId: AnyEncoder()\n}\n\n\nclass Encoder(object):\n\n    # noinspection PyDefaultArgument\n    def __init__(self, tagMap, typeMap={}):\n        self.__tagMap = tagMap\n        self.__typeMap = typeMap\n\n    def __call__(self, asn1Value):\n        if not isinstance(asn1Value, base.Asn1Item):\n            raise error.PyAsn1Error('value is not valid (should be an instance of an ASN.1 Item)')\n\n        if debug.logger & debug.flagEncoder:\n            debug.scope.push(type(asn1Value).__name__)\n            debug.logger('encoder called for type %s <%s>' % (type(asn1Value).__name__, asn1Value.prettyPrint()))\n\n        tagSet = asn1Value.tagSet\n        if len(tagSet) > 1:\n            concreteEncoder = explicitlyTaggedItemEncoder\n        else:\n            if asn1Value.typeId is not None and asn1Value.typeId in self.__typeMap:\n                concreteEncoder = self.__typeMap[asn1Value.typeId]\n            elif tagSet in self.__tagMap:\n                concreteEncoder = self.__tagMap[tagSet]\n            else:\n                tagSet = asn1Value.baseTagSet\n                if tagSet in self.__tagMap:\n                    concreteEncoder = self.__tagMap[tagSet]\n                else:\n                    raise error.PyAsn1Error('No encoder for %s' % (asn1Value,))\n\n        debug.logger & debug.flagEncoder and debug.logger('using value codec %s chosen by %s' % (type(concreteEncoder).__name__, tagSet))\n\n        pyObject = concreteEncoder.encode(self, asn1Value)\n\n        if debug.logger & debug.flagEncoder:\n            debug.logger('encoder %s produced: %s' % (type(concreteEncoder).__name__, repr(pyObject)))\n            debug.scope.pop()\n\n        return pyObject\n\n\n#: Turns ASN.1 object into a Python built-in type object(s).\n#:\n#: Takes any ASN.1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#: walks all its components recursively and produces a Python built-in type or a tree\n#: of those.\n#:\n#: One exception is that instead of :py:class:`dict`, the :py:class:`OrderedDict`\n#: can be produced (whenever available) to preserve ordering of the components\n#: in ASN.1 SEQUENCE.\n#:\n#: Parameters\n#: ----------\n#  asn1Value: any pyasn1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     pyasn1 object to encode (or a tree of them)\n#:\n#: Returns\n#: -------\n#: : :py:class:`object`\n#:     Python built-in type instance (or a tree of them)\n#:\n#: Raises\n#: ------\n#: : :py:class:`pyasn1.error.PyAsn1Error`\n#:     On encoding errors\nencode = Encoder(tagMap, typeMap)\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "encoder.py", "id": "c67bfd9a7caf7c1ff48b39546d24a67a", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/lib/pyasn1/codec/native/encoder.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}