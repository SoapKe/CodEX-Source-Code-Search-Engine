{"author": "ansible", "code": " (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n\n This file is part of Ansible\n\n Ansible is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Ansible is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom collections import Mapping\n\nfrom jinja2.utils import missing\n\nfrom ansible.errors import AnsibleError, AnsibleUndefinedVariable\nfrom ansible.module_utils.six import iteritems\nfrom ansible.module_utils._text import to_native\n\n\n__all__ = ['AnsibleJ2Vars']\n\n\nclass AnsibleJ2Vars(Mapping):\n    '''\n    Helper class to template all variable content before jinja2 sees it. This is\n    done by hijacking the variable storage that jinja2 uses, and overriding __contains__\n    and __getitem__ to look like a dict. Added bonus is avoiding duplicating the large\n    hashes that inject tends to be.\n\n    To facilitate using builtin jinja2 things like range, globals are also handled here.\n    '''\n\n    def __init__(self, templar, globals, locals=None, *extras):\n        '''\n        Initializes this object with a valid Templar() object, as\n        well as several dictionaries of variables representing\n        different scopes (in jinja2 terminology).\n        '''\n\n        self._templar = templar\n        self._globals = globals\n        self._extras = extras\n        self._locals = dict()\n        if isinstance(locals, dict):\n            for key, val in iteritems(locals):\n                if val is not missing:\n                    if key[:2] == 'l_':\n                        self._locals[key[2:]] = val\n                    elif key not in ('context', 'environment', 'template'):\n                        self._locals[key] = val\n\n    def __contains__(self, k):\n        if k in self._templar._available_variables:\n            return True\n        if k in self._locals:\n            return True\n        for i in self._extras:\n            if k in i:\n                return True\n        if k in self._globals:\n            return True\n        return False\n\n    def __iter__(self):\n        keys = set()\n        keys.update(self._templar._available_variables, self._locals, self._globals, *self._extras)\n        return iter(keys)\n\n    def __len__(self):\n        keys = set()\n        keys.update(self._templar._available_variables, self._locals, self._globals, *self._extras)\n        return len(keys)\n\n    def __getitem__(self, varname):\n        if varname not in self._templar._available_variables:\n            if varname in self._locals:\n                return self._locals[varname]\n            for i in self._extras:\n                if varname in i:\n                    return i[varname]\n            if varname in self._globals:\n                return self._globals[varname]\n            else:\n                raise KeyError(\"undefined variable: %s\" % varname)\n\n        variable = self._templar._available_variables[varname]\n\n         HostVars is special, return it as-is, as is the special variable\n         'vars', which contains the vars structure\n        from ansible.vars.hostvars import HostVars\n        if isinstance(variable, dict) and varname == \"vars\" or isinstance(variable, HostVars) or hasattr(variable, '__UNSAFE__'):\n            return variable\n        else:\n            value = None\n            try:\n                value = self._templar.template(variable)\n            except AnsibleUndefinedVariable:\n                raise\n            except Exception as e:\n                msg = getattr(e, 'message') or to_native(e)\n                raise AnsibleError(\"An unhandled exception occurred while templating '%s'. \"\n                                   \"Error was a %s, original message: %s\" % (to_native(variable), type(e), msg))\n\n            return value\n\n    def add_locals(self, locals):\n        '''\n        If locals are provided, create a copy of self containing those\n        locals in addition to what is already in this variable proxy.\n        '''\n        if locals is None:\n            return self\n\n         FIXME run this only on jinja2>=2.9?\n         prior to version 2.9, locals contained all of the vars and not just the current\n         local vars so this was not necessary for locals to propagate down to nested includes\n        new_locals = self._locals.copy()\n        new_locals.update(locals)\n\n        return AnsibleJ2Vars(self._templar, self._globals, locals=new_locals, *self._extras)\n", "comments": "        helper class template variable content jinja2 sees  this     done hijacking variable storage jinja2 uses  overriding   contains         getitem   look like dict  added bonus avoiding duplicating large     hashes inject tends       to facilitate using builtin jinja2 things like range  globals also handled               def   init  (self  templar  globals  locals none   extras)                      initializes object valid templar() object          well several dictionaries variables representing         different scopes (in jinja2 terminology)                       self  templar   templar         self  globals   globals         self  extras   extras         self  locals   dict()         isinstance(locals  dict)              key  val iteritems(locals)                  val missing                      key  2      l                            self  locals key 2      val                     elif key ( context    environment    template )                          self  locals key    val      def   contains  (self  k)          k self  templar  available variables              return true         k self  locals              return true         self  extras              k                  return true         k self  globals              return true         return false      def   iter  (self)          keys   set()         keys update(self  templar  available variables  self  locals  self  globals   self  extras)         return iter(keys)      def   len  (self)          keys   set()         keys update(self  templar  available variables  self  locals  self  globals   self  extras)         return len(keys)      def   getitem  (self  varname)          varname self  templar  available variables              varname self  locals                  return self  locals varname              self  extras                  varname                      return varname              varname self  globals                  return self  globals varname              else                  raise keyerror( undefined variable      varname)          variable   self  templar  available variables varname             hostvars special  return  special variable            vars   contains vars structure         ansible vars hostvars import hostvars         isinstance(variable  dict) varname     vars  isinstance(variable  hostvars) hasattr(variable     unsafe   )              return variable         else              value   none             try                  value   self  templar template(variable)             except ansibleundefinedvariable                  raise             except exception e                  msg   getattr(e   message ) native(e)                 raise ansibleerror( an unhandled exception occurred templating                                           error   original message      (to native(variable)  type(e)  msg))              return value      def add locals(self  locals)                      if locals provided  create copy self containing         locals addition already variable proxy                 (c) 2012  michael dehaan  michael dehaan gmail com        this file part ansible       ansible free software  redistribute modify    terms gnu general public license published    free software foundation  either version 3 license     (at option) later version        ansible distributed hope useful     without any warranty  without even implied warranty    merchantability fitness for a particular purpose   see    gnu general public license details        you received copy gnu general public license    along ansible   if  see  http   www gnu org licenses       make coding python3 ish    hostvars special  return  special variable     vars   contains vars structure    fixme run jinja2  2 9     prior version 2 9  locals contained vars current    local vars necessary locals propagate nested includes ", "content": "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nfrom collections import Mapping\n\nfrom jinja2.utils import missing\n\nfrom ansible.errors import AnsibleError, AnsibleUndefinedVariable\nfrom ansible.module_utils.six import iteritems\nfrom ansible.module_utils._text import to_native\n\n\n__all__ = ['AnsibleJ2Vars']\n\n\nclass AnsibleJ2Vars(Mapping):\n    '''\n    Helper class to template all variable content before jinja2 sees it. This is\n    done by hijacking the variable storage that jinja2 uses, and overriding __contains__\n    and __getitem__ to look like a dict. Added bonus is avoiding duplicating the large\n    hashes that inject tends to be.\n\n    To facilitate using builtin jinja2 things like range, globals are also handled here.\n    '''\n\n    def __init__(self, templar, globals, locals=None, *extras):\n        '''\n        Initializes this object with a valid Templar() object, as\n        well as several dictionaries of variables representing\n        different scopes (in jinja2 terminology).\n        '''\n\n        self._templar = templar\n        self._globals = globals\n        self._extras = extras\n        self._locals = dict()\n        if isinstance(locals, dict):\n            for key, val in iteritems(locals):\n                if val is not missing:\n                    if key[:2] == 'l_':\n                        self._locals[key[2:]] = val\n                    elif key not in ('context', 'environment', 'template'):\n                        self._locals[key] = val\n\n    def __contains__(self, k):\n        if k in self._templar._available_variables:\n            return True\n        if k in self._locals:\n            return True\n        for i in self._extras:\n            if k in i:\n                return True\n        if k in self._globals:\n            return True\n        return False\n\n    def __iter__(self):\n        keys = set()\n        keys.update(self._templar._available_variables, self._locals, self._globals, *self._extras)\n        return iter(keys)\n\n    def __len__(self):\n        keys = set()\n        keys.update(self._templar._available_variables, self._locals, self._globals, *self._extras)\n        return len(keys)\n\n    def __getitem__(self, varname):\n        if varname not in self._templar._available_variables:\n            if varname in self._locals:\n                return self._locals[varname]\n            for i in self._extras:\n                if varname in i:\n                    return i[varname]\n            if varname in self._globals:\n                return self._globals[varname]\n            else:\n                raise KeyError(\"undefined variable: %s\" % varname)\n\n        variable = self._templar._available_variables[varname]\n\n        # HostVars is special, return it as-is, as is the special variable\n        # 'vars', which contains the vars structure\n        from ansible.vars.hostvars import HostVars\n        if isinstance(variable, dict) and varname == \"vars\" or isinstance(variable, HostVars) or hasattr(variable, '__UNSAFE__'):\n            return variable\n        else:\n            value = None\n            try:\n                value = self._templar.template(variable)\n            except AnsibleUndefinedVariable:\n                raise\n            except Exception as e:\n                msg = getattr(e, 'message') or to_native(e)\n                raise AnsibleError(\"An unhandled exception occurred while templating '%s'. \"\n                                   \"Error was a %s, original message: %s\" % (to_native(variable), type(e), msg))\n\n            return value\n\n    def add_locals(self, locals):\n        '''\n        If locals are provided, create a copy of self containing those\n        locals in addition to what is already in this variable proxy.\n        '''\n        if locals is None:\n            return self\n\n        # FIXME run this only on jinja2>=2.9?\n        # prior to version 2.9, locals contained all of the vars and not just the current\n        # local vars so this was not necessary for locals to propagate down to nested includes\n        new_locals = self._locals.copy()\n        new_locals.update(locals)\n\n        return AnsibleJ2Vars(self._templar, self._globals, locals=new_locals, *self._extras)\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "vars.py", "id": "bb5b6fd38f5a4fc189898c1fe2cd9515", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/template/vars.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}