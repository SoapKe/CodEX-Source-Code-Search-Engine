{"author": "tensorflow", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n\n internal imports\nimport tensorflow as tf\n\nfrom magenta.common import beam_search\n\n\nclass BeamSearchTest(tf.test.TestCase):\n\n  def _generate_step_fn(self, sequences, states, scores):\n     This acts as a binary counter for testing purposes. For scoring, zeros\n     accumulate value exponentially in the state, ones \"cash in\". The highest-\n     scoring sequence would be all zeros followed by a single one.\n    value = 0\n    for i in range(len(sequences)):\n      sequences[i].append(value)\n      if value == 0:\n        states[i] *= 2\n      else:\n        scores[i] += states[i]\n        states[i] = 1\n      if (i - 1) % (2 ** len(sequences[i])) == 0:\n        value = 1 - value\n    return sequences, states, scores\n\n  def testNoBranchingSingleStepPerIteration(self):\n    sequence, state, score = beam_search.beam_search(\n        initial_sequence=[], initial_state=1,\n        generate_step_fn=self._generate_step_fn, num_steps=5, beam_size=1,\n        branch_factor=1, steps_per_iteration=1)\n\n     The generator should emit all zeros, as only a single sequence is ever\n     considered so the counter doesn't reach one.\n    self.assertEqual(sequence, [0, 0, 0, 0, 0])\n    self.assertEqual(state, 32)\n    self.assertEqual(score, 0)\n\n  def testNoBranchingMultipleStepsPerIteration(self):\n    sequence, state, score = beam_search.beam_search(\n        initial_sequence=[], initial_state=1,\n        generate_step_fn=self._generate_step_fn, num_steps=5, beam_size=1,\n        branch_factor=1, steps_per_iteration=2)\n\n     Like the above case, the counter should never reach one as only a single\n     sequence is ever considered.\n    self.assertEqual(sequence, [0, 0, 0, 0, 0])\n    self.assertEqual(state, 32)\n    self.assertEqual(score, 0)\n\n  def testBranchingSingleBeamEntry(self):\n    sequence, state, score = beam_search.beam_search(\n        initial_sequence=[], initial_state=1,\n        generate_step_fn=self._generate_step_fn, num_steps=5, beam_size=1,\n        branch_factor=32, steps_per_iteration=1)\n\n     Here the beam search should greedily choose ones.\n    self.assertEqual(sequence, [1, 1, 1, 1, 1])\n    self.assertEqual(state, 1)\n    self.assertEqual(score, 5)\n\n  def testNoBranchingMultipleBeamEntries(self):\n    sequence, state, score = beam_search.beam_search(\n        initial_sequence=[], initial_state=1,\n        generate_step_fn=self._generate_step_fn, num_steps=5, beam_size=32,\n        branch_factor=1, steps_per_iteration=1)\n\n     Here the beam has enough capacity to find the optimal solution without\n     branching.\n    self.assertEqual(sequence, [0, 0, 0, 0, 1])\n    self.assertEqual(state, 1)\n    self.assertEqual(score, 16)\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "comments": "   tests beam search        copyright 2017 google inc  all rights reserved        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license          http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license     internal imports    this acts binary counter testing purposes  for scoring  zeros    accumulate value exponentially state  ones  cash   the highest     scoring sequence would zeros followed single one     the generator emit zeros  single sequence ever    considered counter reach one     like case  counter never reach one single    sequence ever considered     here beam search greedily choose ones     here beam enough capacity find optimal solution without    branching  ", "content": "# Copyright 2017 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Tests for beam search.\"\"\"\n\n# internal imports\nimport tensorflow as tf\n\nfrom magenta.common import beam_search\n\n\nclass BeamSearchTest(tf.test.TestCase):\n\n  def _generate_step_fn(self, sequences, states, scores):\n    # This acts as a binary counter for testing purposes. For scoring, zeros\n    # accumulate value exponentially in the state, ones \"cash in\". The highest-\n    # scoring sequence would be all zeros followed by a single one.\n    value = 0\n    for i in range(len(sequences)):\n      sequences[i].append(value)\n      if value == 0:\n        states[i] *= 2\n      else:\n        scores[i] += states[i]\n        states[i] = 1\n      if (i - 1) % (2 ** len(sequences[i])) == 0:\n        value = 1 - value\n    return sequences, states, scores\n\n  def testNoBranchingSingleStepPerIteration(self):\n    sequence, state, score = beam_search.beam_search(\n        initial_sequence=[], initial_state=1,\n        generate_step_fn=self._generate_step_fn, num_steps=5, beam_size=1,\n        branch_factor=1, steps_per_iteration=1)\n\n    # The generator should emit all zeros, as only a single sequence is ever\n    # considered so the counter doesn't reach one.\n    self.assertEqual(sequence, [0, 0, 0, 0, 0])\n    self.assertEqual(state, 32)\n    self.assertEqual(score, 0)\n\n  def testNoBranchingMultipleStepsPerIteration(self):\n    sequence, state, score = beam_search.beam_search(\n        initial_sequence=[], initial_state=1,\n        generate_step_fn=self._generate_step_fn, num_steps=5, beam_size=1,\n        branch_factor=1, steps_per_iteration=2)\n\n    # Like the above case, the counter should never reach one as only a single\n    # sequence is ever considered.\n    self.assertEqual(sequence, [0, 0, 0, 0, 0])\n    self.assertEqual(state, 32)\n    self.assertEqual(score, 0)\n\n  def testBranchingSingleBeamEntry(self):\n    sequence, state, score = beam_search.beam_search(\n        initial_sequence=[], initial_state=1,\n        generate_step_fn=self._generate_step_fn, num_steps=5, beam_size=1,\n        branch_factor=32, steps_per_iteration=1)\n\n    # Here the beam search should greedily choose ones.\n    self.assertEqual(sequence, [1, 1, 1, 1, 1])\n    self.assertEqual(state, 1)\n    self.assertEqual(score, 5)\n\n  def testNoBranchingMultipleBeamEntries(self):\n    sequence, state, score = beam_search.beam_search(\n        initial_sequence=[], initial_state=1,\n        generate_step_fn=self._generate_step_fn, num_steps=5, beam_size=32,\n        branch_factor=1, steps_per_iteration=1)\n\n    # Here the beam has enough capacity to find the optimal solution without\n    # branching.\n    self.assertEqual(sequence, [0, 0, 0, 0, 1])\n    self.assertEqual(state, 1)\n    self.assertEqual(score, 16)\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "description": "Magenta: Music and Art Generation with Machine Intelligence", "file_name": "beam_search_test.py", "id": "0a6ca0de31d53580c6bd937fa8209497", "language": "Python", "project_name": "magenta", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/tensorflow-magenta/tensorflow-magenta-c3eda3d/magenta/common/beam_search_test.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:52:33Z", "url": "https://github.com/tensorflow/magenta", "wiki": false}