{"author": "mailpile", "code": "import datetime\nimport re\nimport time\n\nfrom mailpile.i18n import gettext as _\nfrom mailpile.i18n import ngettext as _n\nfrom mailpile.commands import Command\nfrom mailpile.mailutils import Email, ExtractEmails\nfrom mailpile.search import MailIndex\nfrom mailpile.util import *\n\nfrom mailpile.plugins.search import Search\n\n\nclass Graph(Search):\n    \n    ORDER = ('Searching', 1)\n    HTTP_CALLABLE = ('GET', )\n    UI_CONTEXT = \"search\"\n\n    def command(self, search=None):\n        session, idx = self._do_search(search=search)\n\n        nodes = []\n        links = []\n        res = {}\n\n        for messageid in session.results:\n            msg = self._idx().get_msg_at_idx_pos(messageid)\n            msgfrom = msg[self._idx().MSG_FROM]\n            msgto = [self._idx().EMAILS[int(x, 36)]\n                     for x in msg[self._idx().MSG_TO].split(\",\") if x != \"\"]\n            m = re.match(\"((.*) ){0,1}\\<(.*)\\>\", msgfrom)\n            if m:\n                name = m.groups(0)[1]\n                email = m.groups(0)[2]\n            else:\n                name = None\n                email = msgfrom\n\n            if email not in [m[\"email\"] for m in nodes]:\n                n = {\"email\": email}\n                if name:\n                    n[\"name\"] = name\n                nodes.append(n)\n\n            for address in msgto:\n                if address not in [m[\"email\"] for m in nodes]:\n                    nodes.append({\"email\": address})\n\n            curnodes = [x[\"email\"] for x in nodes]\n            fromid = curnodes.index(email)\n            searchspace = [m for m in links if m[\"source\"] == fromid]\n            for address in msgto:\n                index = curnodes.index(address)\n                link = [m for m in searchspace if m[\"target\"] == index]\n                if len(link) == 0:\n                    links.append({\"source\": fromid,\n                                  \"target\": index,\n                                  \"value\": 1})\n                elif len(link) == 1:\n                    link[0][\"value\"] += 1\n                else:\n                    raise ValueError(\"Too many links! - This should never \"\n                                     \"happen.\")\n\n            if len(nodes) >= 300:\n                \n                \n                \n                res[\"limit_hit\"] = True\n                break\n\n        res[\"nodes\"] = nodes\n        res[\"links\"] = links\n        res[\"searched\"] = session.searched\n        if \"limit_hit\" not in res:\n            res[\"limit_hit\"] = False\n\n        return self._success(_('Generated graph view'), res)\n", "comments": "   get graph network current search results        let put hard upper limit many nodes     performance reasons     there might better way though    ", "content": "import datetime\nimport re\nimport time\n\nfrom mailpile.i18n import gettext as _\nfrom mailpile.i18n import ngettext as _n\nfrom mailpile.commands import Command\nfrom mailpile.mailutils import Email, ExtractEmails\nfrom mailpile.search import MailIndex\nfrom mailpile.util import *\n\nfrom mailpile.plugins.search import Search\n\n\nclass Graph(Search):\n    \"\"\"Get a graph of the network in the current search results.\"\"\"\n    ORDER = ('Searching', 1)\n    HTTP_CALLABLE = ('GET', )\n    UI_CONTEXT = \"search\"\n\n    def command(self, search=None):\n        session, idx = self._do_search(search=search)\n\n        nodes = []\n        links = []\n        res = {}\n\n        for messageid in session.results:\n            msg = self._idx().get_msg_at_idx_pos(messageid)\n            msgfrom = msg[self._idx().MSG_FROM]\n            msgto = [self._idx().EMAILS[int(x, 36)]\n                     for x in msg[self._idx().MSG_TO].split(\",\") if x != \"\"]\n            m = re.match(\"((.*) ){0,1}\\<(.*)\\>\", msgfrom)\n            if m:\n                name = m.groups(0)[1]\n                email = m.groups(0)[2]\n            else:\n                name = None\n                email = msgfrom\n\n            if email not in [m[\"email\"] for m in nodes]:\n                n = {\"email\": email}\n                if name:\n                    n[\"name\"] = name\n                nodes.append(n)\n\n            for address in msgto:\n                if address not in [m[\"email\"] for m in nodes]:\n                    nodes.append({\"email\": address})\n\n            curnodes = [x[\"email\"] for x in nodes]\n            fromid = curnodes.index(email)\n            searchspace = [m for m in links if m[\"source\"] == fromid]\n            for address in msgto:\n                index = curnodes.index(address)\n                link = [m for m in searchspace if m[\"target\"] == index]\n                if len(link) == 0:\n                    links.append({\"source\": fromid,\n                                  \"target\": index,\n                                  \"value\": 1})\n                elif len(link) == 1:\n                    link[0][\"value\"] += 1\n                else:\n                    raise ValueError(\"Too many links! - This should never \"\n                                     \"happen.\")\n\n            if len(nodes) >= 300:\n                # Let's put a hard upper limit on how many nodes we can\n                # have, for performance reasons.\n                # There might be a better way to do this though...\n                res[\"limit_hit\"] = True\n                break\n\n        res[\"nodes\"] = nodes\n        res[\"links\"] = links\n        res[\"searched\"] = session.searched\n        if \"limit_hit\" not in res:\n            res[\"limit_hit\"] = False\n\n        return self._success(_('Generated graph view'), res)\n", "description": "A free & open modern, fast email client with user-friendly encryption and privacy features", "file_name": "forcegrapher.py", "id": "bd10422eb5b143961b7b2d1ab93a8208", "language": "Python", "project_name": "Mailpile", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mailpile-Mailpile/mailpile-Mailpile-8ebc5fe/shared-data/contrib/forcegrapher/forcegrapher.py", "save_time": "", "source": "", "update_at": "2018-03-17T23:54:52Z", "url": "https://github.com/mailpile/Mailpile", "wiki": true}