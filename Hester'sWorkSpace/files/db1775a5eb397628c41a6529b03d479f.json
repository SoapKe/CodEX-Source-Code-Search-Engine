{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport hashlib\nimport hmac\nimport itertools\nimport json\nimport re\nimport time\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    ExtractorError,\n    int_or_none,\n    parse_age_limit,\n    parse_iso8601,\n    sanitized_Request,\n)\n\n\nclass VikiBaseIE(InfoExtractor):\n    _VALID_URL_BASE = r'https?://(?:www\\.)?viki\\.(?:com|net|mx|jp|fr)/'\n    _API_QUERY_TEMPLATE = '/v4/%sapp=%s&t=%s&site=www.viki.com'\n    _API_URL_TEMPLATE = 'http://api.viki.io%s&sig=%s'\n\n    _APP = '100005a'\n    _APP_VERSION = '2.2.5.1428709186'\n    _APP_SECRET = 'MM_d*yP@`&1@]@!AVrXf_o-HVEnoTnm$O-ti4[G~$JDI/Dc-&piU&z&5.;:}95=Iad'\n\n    _GEO_BYPASS = False\n    _NETRC_MACHINE = 'viki'\n\n    _token = None\n\n    _ERRORS = {\n        'geo': 'Sorry, this content is not available in your region.',\n        'upcoming': 'Sorry, this content is not yet available.',\n        \n    }\n\n    def _prepare_call(self, path, timestamp=None, post_data=None):\n        path += '?' if '?' not in path else '&'\n        if not timestamp:\n            timestamp = int(time.time())\n        query = self._API_QUERY_TEMPLATE % (path, self._APP, timestamp)\n        if self._token:\n            query += '&token=%s' % self._token\n        sig = hmac.new(\n            self._APP_SECRET.encode('ascii'),\n            query.encode('ascii'),\n            hashlib.sha1\n        ).hexdigest()\n        url = self._API_URL_TEMPLATE % (query, sig)\n        return sanitized_Request(\n            url, json.dumps(post_data).encode('utf-8')) if post_data else url\n\n    def _call_api(self, path, video_id, note, timestamp=None, post_data=None):\n        resp = self._download_json(\n            self._prepare_call(path, timestamp, post_data), video_id, note)\n\n        error = resp.get('error')\n        if error:\n            if error == 'invalid timestamp':\n                resp = self._download_json(\n                    self._prepare_call(path, int(resp['current_timestamp']), post_data),\n                    video_id, '%s (retry)' % note)\n                error = resp.get('error')\n            if error:\n                self._raise_error(resp['error'])\n\n        return resp\n\n    def _raise_error(self, error):\n        raise ExtractorError(\n            '%s returned error: %s' % (self.IE_NAME, error),\n            expected=True)\n\n    def _check_errors(self, data):\n        for reason, status in data.get('blocking', {}).items():\n            if status and reason in self._ERRORS:\n                message = self._ERRORS[reason]\n                if reason == 'geo':\n                    self.raise_geo_restricted(msg=message)\n                raise ExtractorError('%s said: %s' % (\n                    self.IE_NAME, message), expected=True)\n\n    def _real_initialize(self):\n        self._login()\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n\n        login_form = {\n            'login_id': username,\n            'password': password,\n        }\n\n        login = self._call_api(\n            'sessions.json', None,\n            'Logging in', post_data=login_form)\n\n        self._token = login.get('token')\n        if not self._token:\n            self.report_warning('Unable to get session token, login has probably failed')\n\n    @staticmethod\n    def dict_selection(dict_obj, preferred_key, allow_fallback=True):\n        if preferred_key in dict_obj:\n            return dict_obj.get(preferred_key)\n\n        if not allow_fallback:\n            return\n\n        filtered_dict = list(filter(None, [dict_obj.get(k) for k in dict_obj.keys()]))\n        return filtered_dict[0] if filtered_dict else None\n\n\nclass VikiIE(VikiBaseIE):\n    IE_NAME = 'viki'\n    _VALID_URL = r'%s(?:videos|player)/(?P<id>[0-9]+v)' % VikiBaseIE._VALID_URL_BASE\n    _TESTS = [{\n        'url': 'http://www.viki.com/videos/1023585v-heirs-episode-14',\n        'info_dict': {\n            'id': '1023585v',\n            'ext': 'mp4',\n            'title': 'Heirs Episode 14',\n            'uploader': 'SBS',\n            'description': 'md5:c4b17b9626dd4b143dcc4d855ba3474e',\n            'upload_date': '20131121',\n            'age_limit': 13,\n        },\n        'skip': 'Blocked in the US',\n    }, {\n        \n        'url': 'http://www.viki.com/videos/1067139v-the-avengers-age-of-ultron-press-conference',\n        'md5': '86c0b5dbd4d83a6611a79987cc7a1989',\n        'info_dict': {\n            'id': '1067139v',\n            'ext': 'mp4',\n            'title': \"'The Avengers: Age of Ultron' Press Conference\",\n            'description': 'md5:d70b2f9428f5488321bfe1db10d612ea',\n            'duration': 352,\n            'timestamp': 1430380829,\n            'upload_date': '20150430',\n            'uploader': 'Arirang TV',\n            'like_count': int,\n            'age_limit': 0,\n        }\n    }, {\n        'url': 'http://www.viki.com/videos/1048879v-ankhon-dekhi',\n        'info_dict': {\n            'id': '1048879v',\n            'ext': 'mp4',\n            'title': 'Ankhon Dekhi',\n            'duration': 6512,\n            'timestamp': 1408532356,\n            'upload_date': '20140820',\n            'uploader': 'Spuul',\n            'like_count': int,\n            'age_limit': 13,\n        },\n        'skip': 'Blocked in the US',\n    }, {\n        \n        'url': 'http://www.viki.com/videos/44699v-boys-over-flowers-episode-1',\n        'md5': '5fa476a902e902783ac7a4d615cdbc7a',\n        'info_dict': {\n            'id': '44699v',\n            'ext': 'mp4',\n            'title': 'Boys Over Flowers - Episode 1',\n            'description': 'md5:b89cf50038b480b88b5b3c93589a9076',\n            'duration': 4204,\n            'timestamp': 1270496524,\n            'upload_date': '20100405',\n            'uploader': 'group8',\n            'like_count': int,\n            'age_limit': 13,\n        }\n    }, {\n        \n        'url': 'http://www.viki.com/videos/50562v-poor-nastya-complete-episode-1',\n        'md5': '63f8600c1da6f01b7640eee7eca4f1da',\n        'info_dict': {\n            'id': '50562v',\n            'ext': 'webm',\n            'title': 'Poor Nastya [COMPLETE] - Episode 1',\n            'description': '',\n            'duration': 606,\n            'timestamp': 1274949505,\n            'upload_date': '20101213',\n            'uploader': 'ad14065n',\n            'uploader_id': 'ad14065n',\n            'like_count': int,\n            'age_limit': 13,\n        }\n    }, {\n        'url': 'http://www.viki.com/player/44699v',\n        'only_matching': True,\n    }, {\n        \n        'url': 'http://www.viki.com/videos/158036v-love-in-magic',\n        'md5': '1713ae35df5a521b31f6dc40730e7c9c',\n        'info_dict': {\n            'id': '158036v',\n            'ext': 'mp4',\n            'uploader': 'I Planet Entertainment',\n            'upload_date': '20111122',\n            'timestamp': 1321985454,\n            'description': 'md5:44b1e46619df3a072294645c770cef36',\n            'title': 'Love In Magic',\n            'age_limit': 13,\n        },\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        video = self._call_api(\n            'videos/%s.json' % video_id, video_id, 'Downloading video JSON')\n\n        self._check_errors(video)\n\n        title = self.dict_selection(video.get('titles', {}), 'en', allow_fallback=False)\n        if not title:\n            title = 'Episode %d' % video.get('number') if video.get('type') == 'episode' else video.get('id') or video_id\n            container_titles = video.get('container', {}).get('titles', {})\n            container_title = self.dict_selection(container_titles, 'en')\n            title = '%s - %s' % (container_title, title)\n\n        description = self.dict_selection(video.get('descriptions', {}), 'en')\n\n        duration = int_or_none(video.get('duration'))\n        timestamp = parse_iso8601(video.get('created_at'))\n        uploader = video.get('author')\n        like_count = int_or_none(video.get('likes', {}).get('count'))\n        age_limit = parse_age_limit(video.get('rating'))\n\n        thumbnails = []\n        for thumbnail_id, thumbnail in video.get('images', {}).items():\n            thumbnails.append({\n                'id': thumbnail_id,\n                'url': thumbnail.get('url'),\n            })\n\n        subtitles = {}\n        for subtitle_lang, _ in video.get('subtitle_completions', {}).items():\n            subtitles[subtitle_lang] = [{\n                'ext': subtitles_format,\n                'url': self._prepare_call(\n                    'videos/%s/subtitles/%s.%s' % (video_id, subtitle_lang, subtitles_format)),\n            } for subtitles_format in ('srt', 'vtt')]\n\n        result = {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'duration': duration,\n            'timestamp': timestamp,\n            'uploader': uploader,\n            'like_count': like_count,\n            'age_limit': age_limit,\n            'thumbnails': thumbnails,\n            'subtitles': subtitles,\n        }\n\n        streams = self._call_api(\n            'videos/%s/streams.json' % video_id, video_id,\n            'Downloading video streams JSON')\n\n        if 'external' in streams:\n            result.update({\n                '_type': 'url_transparent',\n                'url': streams['external']['url'],\n            })\n            return result\n\n        formats = []\n        for format_id, stream_dict in streams.items():\n            height = int_or_none(self._search_regex(\n                r'^(\\d+)[pP]$', format_id, 'height', default=None))\n            for protocol, format_dict in stream_dict.items():\n                \n                if protocol == 'rtmps':\n                    continue\n                format_url = format_dict['url']\n                if format_id == 'm3u8':\n                    m3u8_formats = self._extract_m3u8_formats(\n                        format_url, video_id, 'mp4',\n                        entry_protocol='m3u8_native',\n                        m3u8_id='m3u8-%s' % protocol, fatal=False)\n                    \n                    \n                    for f in m3u8_formats:\n                        if f.get('acodec') == 'none' and f.get('vcodec') != 'none':\n                            f['acodec'] = None\n                    formats.extend(m3u8_formats)\n                elif format_url.startswith('rtmp'):\n                    mobj = re.search(\n                        r'^(?P<url>rtmp://[^/]+/(?P<app>.+?))/(?P<playpath>mp4:.+)$',\n                        format_url)\n                    if not mobj:\n                        continue\n                    formats.append({\n                        'format_id': 'rtmp-%s' % format_id,\n                        'ext': 'flv',\n                        'url': mobj.group('url'),\n                        'play_path': mobj.group('playpath'),\n                        'app': mobj.group('app'),\n                        'page_url': url,\n                    })\n                else:\n                    formats.append({\n                        'url': format_url,\n                        'format_id': '%s-%s' % (format_id, protocol),\n                        'height': height,\n                    })\n        self._sort_formats(formats)\n\n        result['formats'] = formats\n        return result\n\n\nclass VikiChannelIE(VikiBaseIE):\n    IE_NAME = 'viki:channel'\n    _VALID_URL = r'%s(?:tv|news|movies|artists)/(?P<id>[0-9]+c)' % VikiBaseIE._VALID_URL_BASE\n    _TESTS = [{\n        'url': 'http://www.viki.com/tv/50c-boys-over-flowers',\n        'info_dict': {\n            'id': '50c',\n            'title': 'Boys Over Flowers',\n            'description': 'md5:ecd3cff47967fe193cff37c0bec52790',\n        },\n        'playlist_mincount': 71,\n    }, {\n        'url': 'http://www.viki.com/tv/1354c-poor-nastya-complete',\n        'info_dict': {\n            'id': '1354c',\n            'title': 'Poor Nastya [COMPLETE]',\n            'description': 'md5:05bf5471385aa8b21c18ad450e350525',\n        },\n        'playlist_count': 127,\n    }, {\n        'url': 'http://www.viki.com/news/24569c-showbiz-korea',\n        'only_matching': True,\n    }, {\n        'url': 'http://www.viki.com/movies/22047c-pride-and-prejudice-2005',\n        'only_matching': True,\n    }, {\n        'url': 'http://www.viki.com/artists/2141c-shinee',\n        'only_matching': True,\n    }]\n\n    _PER_PAGE = 25\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        channel = self._call_api(\n            'containers/%s.json' % channel_id, channel_id,\n            'Downloading channel JSON')\n\n        self._check_errors(channel)\n\n        title = self.dict_selection(channel['titles'], 'en')\n\n        description = self.dict_selection(channel['descriptions'], 'en')\n\n        entries = []\n        for video_type in ('episodes', 'clips', 'movies'):\n            for page_num in itertools.count(1):\n                page = self._call_api(\n                    'containers/%s/%s.json?per_page=%d&sort=number&direction=asc&with_paging=true&page=%d'\n                    % (channel_id, video_type, self._PER_PAGE, page_num), channel_id,\n                    'Downloading %s JSON page \n                for video in page['response']:\n                    video_id = video['id']\n                    entries.append(self.url_result(\n                        'http://www.viki.com/videos/%s' % video_id, 'Viki'))\n                if not page['pagination']['next']:\n                    break\n\n        return self.playlist_result(entries, channel_id, title, description)\n", "comments": "# coding: utf-8\n# 'paywall': 'paywall',\n# clip\n# episode\n# youtube external\n# non-English description\n# rtmps URLs does not seem to work\n# Despite CODECS metadata in m3u8 all video-only formats\n# are actually video+audio\n#%d' % (video_type, page_num))\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport hashlib\nimport hmac\nimport itertools\nimport json\nimport re\nimport time\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    ExtractorError,\n    int_or_none,\n    parse_age_limit,\n    parse_iso8601,\n    sanitized_Request,\n)\n\n\nclass VikiBaseIE(InfoExtractor):\n    _VALID_URL_BASE = r'https?://(?:www\\.)?viki\\.(?:com|net|mx|jp|fr)/'\n    _API_QUERY_TEMPLATE = '/v4/%sapp=%s&t=%s&site=www.viki.com'\n    _API_URL_TEMPLATE = 'http://api.viki.io%s&sig=%s'\n\n    _APP = '100005a'\n    _APP_VERSION = '2.2.5.1428709186'\n    _APP_SECRET = 'MM_d*yP@`&1@]@!AVrXf_o-HVEnoTnm$O-ti4[G~$JDI/Dc-&piU&z&5.;:}95=Iad'\n\n    _GEO_BYPASS = False\n    _NETRC_MACHINE = 'viki'\n\n    _token = None\n\n    _ERRORS = {\n        'geo': 'Sorry, this content is not available in your region.',\n        'upcoming': 'Sorry, this content is not yet available.',\n        # 'paywall': 'paywall',\n    }\n\n    def _prepare_call(self, path, timestamp=None, post_data=None):\n        path += '?' if '?' not in path else '&'\n        if not timestamp:\n            timestamp = int(time.time())\n        query = self._API_QUERY_TEMPLATE % (path, self._APP, timestamp)\n        if self._token:\n            query += '&token=%s' % self._token\n        sig = hmac.new(\n            self._APP_SECRET.encode('ascii'),\n            query.encode('ascii'),\n            hashlib.sha1\n        ).hexdigest()\n        url = self._API_URL_TEMPLATE % (query, sig)\n        return sanitized_Request(\n            url, json.dumps(post_data).encode('utf-8')) if post_data else url\n\n    def _call_api(self, path, video_id, note, timestamp=None, post_data=None):\n        resp = self._download_json(\n            self._prepare_call(path, timestamp, post_data), video_id, note)\n\n        error = resp.get('error')\n        if error:\n            if error == 'invalid timestamp':\n                resp = self._download_json(\n                    self._prepare_call(path, int(resp['current_timestamp']), post_data),\n                    video_id, '%s (retry)' % note)\n                error = resp.get('error')\n            if error:\n                self._raise_error(resp['error'])\n\n        return resp\n\n    def _raise_error(self, error):\n        raise ExtractorError(\n            '%s returned error: %s' % (self.IE_NAME, error),\n            expected=True)\n\n    def _check_errors(self, data):\n        for reason, status in data.get('blocking', {}).items():\n            if status and reason in self._ERRORS:\n                message = self._ERRORS[reason]\n                if reason == 'geo':\n                    self.raise_geo_restricted(msg=message)\n                raise ExtractorError('%s said: %s' % (\n                    self.IE_NAME, message), expected=True)\n\n    def _real_initialize(self):\n        self._login()\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n\n        login_form = {\n            'login_id': username,\n            'password': password,\n        }\n\n        login = self._call_api(\n            'sessions.json', None,\n            'Logging in', post_data=login_form)\n\n        self._token = login.get('token')\n        if not self._token:\n            self.report_warning('Unable to get session token, login has probably failed')\n\n    @staticmethod\n    def dict_selection(dict_obj, preferred_key, allow_fallback=True):\n        if preferred_key in dict_obj:\n            return dict_obj.get(preferred_key)\n\n        if not allow_fallback:\n            return\n\n        filtered_dict = list(filter(None, [dict_obj.get(k) for k in dict_obj.keys()]))\n        return filtered_dict[0] if filtered_dict else None\n\n\nclass VikiIE(VikiBaseIE):\n    IE_NAME = 'viki'\n    _VALID_URL = r'%s(?:videos|player)/(?P<id>[0-9]+v)' % VikiBaseIE._VALID_URL_BASE\n    _TESTS = [{\n        'url': 'http://www.viki.com/videos/1023585v-heirs-episode-14',\n        'info_dict': {\n            'id': '1023585v',\n            'ext': 'mp4',\n            'title': 'Heirs Episode 14',\n            'uploader': 'SBS',\n            'description': 'md5:c4b17b9626dd4b143dcc4d855ba3474e',\n            'upload_date': '20131121',\n            'age_limit': 13,\n        },\n        'skip': 'Blocked in the US',\n    }, {\n        # clip\n        'url': 'http://www.viki.com/videos/1067139v-the-avengers-age-of-ultron-press-conference',\n        'md5': '86c0b5dbd4d83a6611a79987cc7a1989',\n        'info_dict': {\n            'id': '1067139v',\n            'ext': 'mp4',\n            'title': \"'The Avengers: Age of Ultron' Press Conference\",\n            'description': 'md5:d70b2f9428f5488321bfe1db10d612ea',\n            'duration': 352,\n            'timestamp': 1430380829,\n            'upload_date': '20150430',\n            'uploader': 'Arirang TV',\n            'like_count': int,\n            'age_limit': 0,\n        }\n    }, {\n        'url': 'http://www.viki.com/videos/1048879v-ankhon-dekhi',\n        'info_dict': {\n            'id': '1048879v',\n            'ext': 'mp4',\n            'title': 'Ankhon Dekhi',\n            'duration': 6512,\n            'timestamp': 1408532356,\n            'upload_date': '20140820',\n            'uploader': 'Spuul',\n            'like_count': int,\n            'age_limit': 13,\n        },\n        'skip': 'Blocked in the US',\n    }, {\n        # episode\n        'url': 'http://www.viki.com/videos/44699v-boys-over-flowers-episode-1',\n        'md5': '5fa476a902e902783ac7a4d615cdbc7a',\n        'info_dict': {\n            'id': '44699v',\n            'ext': 'mp4',\n            'title': 'Boys Over Flowers - Episode 1',\n            'description': 'md5:b89cf50038b480b88b5b3c93589a9076',\n            'duration': 4204,\n            'timestamp': 1270496524,\n            'upload_date': '20100405',\n            'uploader': 'group8',\n            'like_count': int,\n            'age_limit': 13,\n        }\n    }, {\n        # youtube external\n        'url': 'http://www.viki.com/videos/50562v-poor-nastya-complete-episode-1',\n        'md5': '63f8600c1da6f01b7640eee7eca4f1da',\n        'info_dict': {\n            'id': '50562v',\n            'ext': 'webm',\n            'title': 'Poor Nastya [COMPLETE] - Episode 1',\n            'description': '',\n            'duration': 606,\n            'timestamp': 1274949505,\n            'upload_date': '20101213',\n            'uploader': 'ad14065n',\n            'uploader_id': 'ad14065n',\n            'like_count': int,\n            'age_limit': 13,\n        }\n    }, {\n        'url': 'http://www.viki.com/player/44699v',\n        'only_matching': True,\n    }, {\n        # non-English description\n        'url': 'http://www.viki.com/videos/158036v-love-in-magic',\n        'md5': '1713ae35df5a521b31f6dc40730e7c9c',\n        'info_dict': {\n            'id': '158036v',\n            'ext': 'mp4',\n            'uploader': 'I Planet Entertainment',\n            'upload_date': '20111122',\n            'timestamp': 1321985454,\n            'description': 'md5:44b1e46619df3a072294645c770cef36',\n            'title': 'Love In Magic',\n            'age_limit': 13,\n        },\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        video = self._call_api(\n            'videos/%s.json' % video_id, video_id, 'Downloading video JSON')\n\n        self._check_errors(video)\n\n        title = self.dict_selection(video.get('titles', {}), 'en', allow_fallback=False)\n        if not title:\n            title = 'Episode %d' % video.get('number') if video.get('type') == 'episode' else video.get('id') or video_id\n            container_titles = video.get('container', {}).get('titles', {})\n            container_title = self.dict_selection(container_titles, 'en')\n            title = '%s - %s' % (container_title, title)\n\n        description = self.dict_selection(video.get('descriptions', {}), 'en')\n\n        duration = int_or_none(video.get('duration'))\n        timestamp = parse_iso8601(video.get('created_at'))\n        uploader = video.get('author')\n        like_count = int_or_none(video.get('likes', {}).get('count'))\n        age_limit = parse_age_limit(video.get('rating'))\n\n        thumbnails = []\n        for thumbnail_id, thumbnail in video.get('images', {}).items():\n            thumbnails.append({\n                'id': thumbnail_id,\n                'url': thumbnail.get('url'),\n            })\n\n        subtitles = {}\n        for subtitle_lang, _ in video.get('subtitle_completions', {}).items():\n            subtitles[subtitle_lang] = [{\n                'ext': subtitles_format,\n                'url': self._prepare_call(\n                    'videos/%s/subtitles/%s.%s' % (video_id, subtitle_lang, subtitles_format)),\n            } for subtitles_format in ('srt', 'vtt')]\n\n        result = {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'duration': duration,\n            'timestamp': timestamp,\n            'uploader': uploader,\n            'like_count': like_count,\n            'age_limit': age_limit,\n            'thumbnails': thumbnails,\n            'subtitles': subtitles,\n        }\n\n        streams = self._call_api(\n            'videos/%s/streams.json' % video_id, video_id,\n            'Downloading video streams JSON')\n\n        if 'external' in streams:\n            result.update({\n                '_type': 'url_transparent',\n                'url': streams['external']['url'],\n            })\n            return result\n\n        formats = []\n        for format_id, stream_dict in streams.items():\n            height = int_or_none(self._search_regex(\n                r'^(\\d+)[pP]$', format_id, 'height', default=None))\n            for protocol, format_dict in stream_dict.items():\n                # rtmps URLs does not seem to work\n                if protocol == 'rtmps':\n                    continue\n                format_url = format_dict['url']\n                if format_id == 'm3u8':\n                    m3u8_formats = self._extract_m3u8_formats(\n                        format_url, video_id, 'mp4',\n                        entry_protocol='m3u8_native',\n                        m3u8_id='m3u8-%s' % protocol, fatal=False)\n                    # Despite CODECS metadata in m3u8 all video-only formats\n                    # are actually video+audio\n                    for f in m3u8_formats:\n                        if f.get('acodec') == 'none' and f.get('vcodec') != 'none':\n                            f['acodec'] = None\n                    formats.extend(m3u8_formats)\n                elif format_url.startswith('rtmp'):\n                    mobj = re.search(\n                        r'^(?P<url>rtmp://[^/]+/(?P<app>.+?))/(?P<playpath>mp4:.+)$',\n                        format_url)\n                    if not mobj:\n                        continue\n                    formats.append({\n                        'format_id': 'rtmp-%s' % format_id,\n                        'ext': 'flv',\n                        'url': mobj.group('url'),\n                        'play_path': mobj.group('playpath'),\n                        'app': mobj.group('app'),\n                        'page_url': url,\n                    })\n                else:\n                    formats.append({\n                        'url': format_url,\n                        'format_id': '%s-%s' % (format_id, protocol),\n                        'height': height,\n                    })\n        self._sort_formats(formats)\n\n        result['formats'] = formats\n        return result\n\n\nclass VikiChannelIE(VikiBaseIE):\n    IE_NAME = 'viki:channel'\n    _VALID_URL = r'%s(?:tv|news|movies|artists)/(?P<id>[0-9]+c)' % VikiBaseIE._VALID_URL_BASE\n    _TESTS = [{\n        'url': 'http://www.viki.com/tv/50c-boys-over-flowers',\n        'info_dict': {\n            'id': '50c',\n            'title': 'Boys Over Flowers',\n            'description': 'md5:ecd3cff47967fe193cff37c0bec52790',\n        },\n        'playlist_mincount': 71,\n    }, {\n        'url': 'http://www.viki.com/tv/1354c-poor-nastya-complete',\n        'info_dict': {\n            'id': '1354c',\n            'title': 'Poor Nastya [COMPLETE]',\n            'description': 'md5:05bf5471385aa8b21c18ad450e350525',\n        },\n        'playlist_count': 127,\n    }, {\n        'url': 'http://www.viki.com/news/24569c-showbiz-korea',\n        'only_matching': True,\n    }, {\n        'url': 'http://www.viki.com/movies/22047c-pride-and-prejudice-2005',\n        'only_matching': True,\n    }, {\n        'url': 'http://www.viki.com/artists/2141c-shinee',\n        'only_matching': True,\n    }]\n\n    _PER_PAGE = 25\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        channel = self._call_api(\n            'containers/%s.json' % channel_id, channel_id,\n            'Downloading channel JSON')\n\n        self._check_errors(channel)\n\n        title = self.dict_selection(channel['titles'], 'en')\n\n        description = self.dict_selection(channel['descriptions'], 'en')\n\n        entries = []\n        for video_type in ('episodes', 'clips', 'movies'):\n            for page_num in itertools.count(1):\n                page = self._call_api(\n                    'containers/%s/%s.json?per_page=%d&sort=number&direction=asc&with_paging=true&page=%d'\n                    % (channel_id, video_type, self._PER_PAGE, page_num), channel_id,\n                    'Downloading %s JSON page #%d' % (video_type, page_num))\n                for video in page['response']:\n                    video_id = video['id']\n                    entries.append(self.url_result(\n                        'http://www.viki.com/videos/%s' % video_id, 'Viki'))\n                if not page['pagination']['next']:\n                    break\n\n        return self.playlist_result(entries, channel_id, title, description)\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "viki.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/viki.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}