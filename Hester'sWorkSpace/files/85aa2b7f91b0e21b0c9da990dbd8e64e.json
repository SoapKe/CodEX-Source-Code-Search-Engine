{"author": "tflearn", "code": "from __future__ import division, print_function, absolute_import\n\nimport os\nimport tensorflow as tf\nfrom tensorflow.python.ops import resources\n\nfrom ..utils import validate_func\n\n\nclass GraphBranch(object):\n    \"\"\" A graph branch class used for building part of an Estimator graph.\n    \"\"\"\n    def __init__(self, input_tensor=None, output_tensor=None, params=None):\n        self.input_tensor = input_tensor\n        self.output_tensor = output_tensor\n        self.params = params if params is not None else dict()\n        self._is_ready = False\n        if input_tensor is not None and output_tensor is not None:\n            self._is_ready = True\n\n    def build(self, input_tensor, output_tensor, params=None):\n        self.input_tensor = input_tensor\n        self.output_tensor = output_tensor\n        self.params = params if params is not None else dict()\n        self._is_ready = True\n\n    @property\n    def is_ready(self):\n        return self._is_ready\n\n    def get_params(self, x):\n        if x in self.params.keys():\n            return self.params[x]\n        else:\n            return None\n\n\nclass BaseEstimator(object):\n\n    \"\"\" Estimators Graph is only build when fit/predict or evaluate is called.\n    \"\"\"\n\n    def __init__(self, metric=None, log_dir='/tmp/tflearn_logs/',\n                 global_step=None, session=None, graph=None, name=None):\n\n        self.name = name\n\n        \n        self.graph = tf.Graph() if graph is None else graph\n        with self.graph.as_default():\n            conf = tf.ConfigProto(allow_soft_placement=True)\n            self.session = tf.Session(config=conf) if session is None else session\n        if global_step is None:\n            with self.graph.as_default():\n                self.global_step = tf.train.get_or_create_global_step()\n\n        self.metric = validate_func(metric)\n\n        \n        self._train = GraphBranch()\n        self._pred = GraphBranch()\n        self._transform = GraphBranch()\n        self._eval = GraphBranch()\n\n        \n        if not os.path.exists(log_dir):\n            os.makedirs(log_dir)\n        self.log_dir = log_dir\n        self._is_initialized = False\n        self._to_be_restored = False\n\n        \n        self.train_op = None\n        self.loss_op = None\n\n    \n    \n    \n    def _init_graph(self):\n        \n        if not self._is_initialized:\n            self.saver = tf.train.Saver()\n            init_vars = tf.group(tf.global_variables_initializer(),\n                                 resources.initialize_resources(\n                                     resources.shared_resources()))\n            self.session.run(init_vars)\n            self._is_initialized = True\n        \n        if self._to_be_restored:\n            self.saver = tf.train.Saver()\n            self.saver.restore(self.session, self._to_be_restored)\n            self._to_be_restored = False\n\n    def _init_estimator(self):\n        raise NotImplementedError\n\n    -----\n    \n    -----\n    def _build_fit(self, X, Y, batch_size, multi_inputs=False):\n        if not self._train._is_ready:\n            self._init_graph()\n        train_params = {'X': X, 'Y': Y, 'batch_size': batch_size,\n                        'multi_inputs': multi_inputs}\n        self._train.build(None, None, train_params)\n\n    def _build_pred(self, input_tensor, output_tensor):\n        self._pred.build(input_tensor, output_tensor)\n\n    def _build_transform(self, input_tensor, output_tensor):\n        self._transform.build(input_tensor, output_tensor)\n\n    def _build_eval(self, X, Y, metric, batch_size, multi_inputs=False):\n        eval_params = {'X': X, 'Y': Y, 'batch_size': batch_size,\n                       'metric': metric, 'multi_inputs': multi_inputs}\n        self._eval.build(None, None, eval_params)\n\n    \n    \n    \n    def fit(self, *args):\n        \n        raise NotImplementedError\n\n    def predict(self, *args):\n        raise NotImplementedError\n\n    def evaluate(self, *args):\n        raise NotImplementedError\n\n    def load(self, *args):\n        raise NotImplementedError\n\n    def save(self, *args):\n        raise NotImplementedError\n\n\nclass SupervisedEstimator(BaseEstimator):\n\n    def __init__(self, metric=None, log_dir='/tmp/tflearn_logs/',\n                 global_step=None, session=None, graph=None, name=None):\n        super(SupervisedEstimator, self).__init__(\n            metric=metric, log_dir=log_dir, global_step=global_step,\n            session=session, graph=graph, name=name)\n\n    def fit(self, X, Y, *args):\n        pass\n", "comments": "    a graph branch class used building part estimator graph              def   init  (self  input tensor none  output tensor none  params none)          self input tensor   input tensor         self output tensor   output tensor         self params   params params none else dict()         self  ready   false         input tensor none output tensor none              self  ready   true      def build(self  input tensor  output tensor  params none)          self input tensor   input tensor         self output tensor   output tensor         self params   params params none else dict()         self  ready   true       property     def ready(self)          return self  ready      def get params(self  x)          x self params keys()              return self params x          else              return none   class baseestimator(object)           estimators graph build fit predict evaluate called             estimator graph session    estimator graph branches    tensor utils    ops                          initializations                         initialize weights    restore weights needed                               build graph branches                                            methods                todo  handle multiple fits ", "content": "from __future__ import division, print_function, absolute_import\n\nimport os\nimport tensorflow as tf\nfrom tensorflow.python.ops import resources\n\nfrom ..utils import validate_func\n\n\nclass GraphBranch(object):\n    \"\"\" A graph branch class used for building part of an Estimator graph.\n    \"\"\"\n    def __init__(self, input_tensor=None, output_tensor=None, params=None):\n        self.input_tensor = input_tensor\n        self.output_tensor = output_tensor\n        self.params = params if params is not None else dict()\n        self._is_ready = False\n        if input_tensor is not None and output_tensor is not None:\n            self._is_ready = True\n\n    def build(self, input_tensor, output_tensor, params=None):\n        self.input_tensor = input_tensor\n        self.output_tensor = output_tensor\n        self.params = params if params is not None else dict()\n        self._is_ready = True\n\n    @property\n    def is_ready(self):\n        return self._is_ready\n\n    def get_params(self, x):\n        if x in self.params.keys():\n            return self.params[x]\n        else:\n            return None\n\n\nclass BaseEstimator(object):\n\n    \"\"\" Estimators Graph is only build when fit/predict or evaluate is called.\n    \"\"\"\n\n    def __init__(self, metric=None, log_dir='/tmp/tflearn_logs/',\n                 global_step=None, session=None, graph=None, name=None):\n\n        self.name = name\n\n        # Estimator Graph and Session\n        self.graph = tf.Graph() if graph is None else graph\n        with self.graph.as_default():\n            conf = tf.ConfigProto(allow_soft_placement=True)\n            self.session = tf.Session(config=conf) if session is None else session\n        if global_step is None:\n            with self.graph.as_default():\n                self.global_step = tf.train.get_or_create_global_step()\n\n        self.metric = validate_func(metric)\n\n        # Estimator Graph Branches\n        self._train = GraphBranch()\n        self._pred = GraphBranch()\n        self._transform = GraphBranch()\n        self._eval = GraphBranch()\n\n        # Tensor Utils\n        if not os.path.exists(log_dir):\n            os.makedirs(log_dir)\n        self.log_dir = log_dir\n        self._is_initialized = False\n        self._to_be_restored = False\n\n        # Ops\n        self.train_op = None\n        self.loss_op = None\n\n    # -----------------\n    #  Initializations\n    # -----------------\n    def _init_graph(self):\n        # Initialize all weights\n        if not self._is_initialized:\n            self.saver = tf.train.Saver()\n            init_vars = tf.group(tf.global_variables_initializer(),\n                                 resources.initialize_resources(\n                                     resources.shared_resources()))\n            self.session.run(init_vars)\n            self._is_initialized = True\n        # Restore weights if needed\n        if self._to_be_restored:\n            self.saver = tf.train.Saver()\n            self.saver.restore(self.session, self._to_be_restored)\n            self._to_be_restored = False\n\n    def _init_estimator(self):\n        raise NotImplementedError\n\n    # ----------------------\n    #  Build Graph Branches\n    # ----------------------\n    def _build_fit(self, X, Y, batch_size, multi_inputs=False):\n        if not self._train._is_ready:\n            self._init_graph()\n        train_params = {'X': X, 'Y': Y, 'batch_size': batch_size,\n                        'multi_inputs': multi_inputs}\n        self._train.build(None, None, train_params)\n\n    def _build_pred(self, input_tensor, output_tensor):\n        self._pred.build(input_tensor, output_tensor)\n\n    def _build_transform(self, input_tensor, output_tensor):\n        self._transform.build(input_tensor, output_tensor)\n\n    def _build_eval(self, X, Y, metric, batch_size, multi_inputs=False):\n        eval_params = {'X': X, 'Y': Y, 'batch_size': batch_size,\n                       'metric': metric, 'multi_inputs': multi_inputs}\n        self._eval.build(None, None, eval_params)\n\n    # ---------\n    #  Methods\n    # ---------\n    def fit(self, *args):\n        #TODO: Handle multiple fits\n        raise NotImplementedError\n\n    def predict(self, *args):\n        raise NotImplementedError\n\n    def evaluate(self, *args):\n        raise NotImplementedError\n\n    def load(self, *args):\n        raise NotImplementedError\n\n    def save(self, *args):\n        raise NotImplementedError\n\n\nclass SupervisedEstimator(BaseEstimator):\n\n    def __init__(self, metric=None, log_dir='/tmp/tflearn_logs/',\n                 global_step=None, session=None, graph=None, name=None):\n        super(SupervisedEstimator, self).__init__(\n            metric=metric, log_dir=log_dir, global_step=global_step,\n            session=session, graph=graph, name=name)\n\n    def fit(self, X, Y, *args):\n        pass\n", "description": "Deep learning library featuring a higher-level API for TensorFlow.", "file_name": "base.py", "id": "85aa2b7f91b0e21b0c9da990dbd8e64e", "language": "Python", "project_name": "tflearn", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tflearn-tflearn/tflearn-tflearn-70fb38a/tflearn/estimators/base.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:15:41Z", "url": "https://github.com/tflearn/tflearn", "wiki": true}