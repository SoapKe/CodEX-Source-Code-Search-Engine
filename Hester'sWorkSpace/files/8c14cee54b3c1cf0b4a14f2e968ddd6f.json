{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom odoo import api, fields, models, _\nfrom odoo.tools import ustr\nfrom odoo.exceptions import UserError, ValidationError\n\n\n\n\nclass AccountBudgetPost(models.Model):\n    _name = \"account.budget.post\"\n    _order = \"name\"\n    _description = \"Budgetary Position\"\n\n    name = fields.Char('Name', required=True)\n    account_ids = fields.Many2many('account.account', 'account_budget_rel', 'budget_id', 'account_id', 'Accounts',\n        domain=[('deprecated', '=', False)])\n    crossovered_budget_line = fields.One2many('crossovered.budget.lines', 'general_budget_id', 'Budget Lines')\n    company_id = fields.Many2one('res.company', 'Company', required=True,\n        default=lambda self: self.env['res.company']._company_default_get('account.budget.post'))\n\n    def _check_account_ids(self, vals):\n        \n        \n        if 'account_ids' in vals:\n            account_ids = self.resolve_2many_commands('account_ids', vals['account_ids'])\n        else:\n            account_ids = self.account_ids\n        if not account_ids:\n            raise ValidationError(_('The budget must have at least one account.'))\n\n    @api.model\n    def create(self, vals):\n        self._check_account_ids(vals)\n        return super(AccountBudgetPost, self).create(vals)\n\n    @api.multi\n    def write(self, vals):\n        self._check_account_ids(vals)\n        return super(AccountBudgetPost, self).write(vals)\n\n\nclass CrossoveredBudget(models.Model):\n    _name = \"crossovered.budget\"\n    _description = \"Budget\"\n    _inherit = ['mail.thread']\n\n    name = fields.Char('Budget Name', required=True, states={'done': [('readonly', True)]})\n    creating_user_id = fields.Many2one('res.users', 'Responsible', default=lambda self: self.env.user)\n    date_from = fields.Date('Start Date', required=True, states={'done': [('readonly', True)]})\n    date_to = fields.Date('End Date', required=True, states={'done': [('readonly', True)]})\n    state = fields.Selection([\n        ('draft', 'Draft'),\n        ('cancel', 'Cancelled'),\n        ('confirm', 'Confirmed'),\n        ('validate', 'Validated'),\n        ('done', 'Done')\n        ], 'Status', default='draft', index=True, required=True, readonly=True, copy=False, track_visibility='always')\n    crossovered_budget_line = fields.One2many('crossovered.budget.lines', 'crossovered_budget_id', 'Budget Lines',\n        states={'done': [('readonly', True)]}, copy=True)\n    company_id = fields.Many2one('res.company', 'Company', required=True,\n        default=lambda self: self.env['res.company']._company_default_get('account.budget.post'))\n\n    @api.multi\n    def action_budget_confirm(self):\n        self.write({'state': 'confirm'})\n\n    @api.multi\n    def action_budget_draft(self):\n        self.write({'state': 'draft'})\n\n    @api.multi\n    def action_budget_validate(self):\n        self.write({'state': 'validate'})\n\n    @api.multi\n    def action_budget_cancel(self):\n        self.write({'state': 'cancel'})\n\n    @api.multi\n    def action_budget_done(self):\n        self.write({'state': 'done'})\n\n\nclass CrossoveredBudgetLines(models.Model):\n    _name = \"crossovered.budget.lines\"\n    _description = \"Budget Line\"\n\n    crossovered_budget_id = fields.Many2one('crossovered.budget', 'Budget', ondelete='cascade', index=True, required=True)\n    analytic_account_id = fields.Many2one('account.analytic.account', 'Analytic Account')\n    general_budget_id = fields.Many2one('account.budget.post', 'Budgetary Position', required=True)\n    date_from = fields.Date('Start Date', required=True)\n    date_to = fields.Date('End Date', required=True)\n    paid_date = fields.Date('Paid Date')\n    planned_amount = fields.Float('Planned Amount', required=True, digits=0)\n    practical_amount = fields.Float(compute='_compute_practical_amount', string='Practical Amount', digits=0)\n    theoritical_amount = fields.Float(compute='_compute_theoritical_amount', string='Theoretical Amount', digits=0)\n    percentage = fields.Float(compute='_compute_percentage', string='Achievement')\n    company_id = fields.Many2one(related='crossovered_budget_id.company_id', comodel_name='res.company',\n        string='Company', store=True, readonly=True)\n\n    @api.multi\n    def _compute_practical_amount(self):\n        for line in self:\n            result = 0.0\n            acc_ids = line.general_budget_id.account_ids.ids\n            date_to = self.env.context.get('wizard_date_to') or line.date_to\n            date_from = self.env.context.get('wizard_date_from') or line.date_from\n            if line.analytic_account_id.id:\n                self.env.cr.execute(\"\"\"\n                    SELECT SUM(amount)\n                    FROM account_analytic_line\n                    WHERE account_id=%s\n                        AND (date between to_date(%s,'yyyy-mm-dd') AND to_date(%s,'yyyy-mm-dd'))\n                        AND general_account_id=ANY(%s)\"\"\",\n                (line.analytic_account_id.id, date_from, date_to, acc_ids,))\n                result = self.env.cr.fetchone()[0] or 0.0\n            line.practical_amount = result\n\n    @api.multi\n    def _compute_theoritical_amount(self):\n        today = fields.Datetime.now()\n        for line in self:\n            \n\n            if self.env.context.get('wizard_date_from') and self.env.context.get('wizard_date_to'):\n                date_from = fields.Datetime.from_string(self.env.context.get('wizard_date_from'))\n                date_to = fields.Datetime.from_string(self.env.context.get('wizard_date_to'))\n                if date_from < fields.Datetime.from_string(line.date_from):\n                    date_from = fields.Datetime.from_string(line.date_from)\n                elif date_from > fields.Datetime.from_string(line.date_to):\n                    date_from = False\n\n                if date_to > fields.Datetime.from_string(line.date_to):\n                    date_to = fields.Datetime.from_string(line.date_to)\n                elif date_to < fields.Datetime.from_string(line.date_from):\n                    date_to = False\n\n                theo_amt = 0.00\n                if date_from and date_to:\n                    line_timedelta = fields.Datetime.from_string(line.date_to) - fields.Datetime.from_string(line.date_from)\n                    elapsed_timedelta = date_to - date_from\n                    if elapsed_timedelta.days > 0:\n                        theo_amt = (elapsed_timedelta.total_seconds() / line_timedelta.total_seconds()) * line.planned_amount\n            else:\n                if line.paid_date:\n                    if fields.Datetime.from_string(line.date_to) <= fields.Datetime.from_string(line.paid_date):\n                        theo_amt = 0.00\n                    else:\n                        theo_amt = line.planned_amount\n                else:\n                    line_timedelta = fields.Datetime.from_string(line.date_to) - fields.Datetime.from_string(line.date_from)\n                    elapsed_timedelta = fields.Datetime.from_string(today) - (fields.Datetime.from_string(line.date_from))\n\n                    if elapsed_timedelta.days < 0:\n                        \n                        theo_amt = 0.00\n                    elif line_timedelta.days > 0 and fields.Datetime.from_string(today) < fields.Datetime.from_string(line.date_to):\n                        \n                        theo_amt = (elapsed_timedelta.total_seconds() / line_timedelta.total_seconds()) * line.planned_amount\n                    else:\n                        theo_amt = line.planned_amount\n\n            line.theoritical_amount = theo_amt\n\n    @api.multi\n    def _compute_percentage(self):\n        for line in self:\n            if line.theoritical_amount != 0.00:\n                line.percentage = float((line.practical_amount or 0.0) / line.theoritical_amount) * 100\n            else:\n                line.percentage = 0.00\n", "comments": "                        select sum(amount)                     from account analytic line                     where account id                          and (date date(  yyyy mm dd ) and date(  yyyy mm dd ))                         and general account id any( s)           coding  utf 8        part odoo  see license file full copyright licensing details                                                                  budgets                                                                 raise error prevent account budget post specified account ids     this check done create require true work many2many fields     used report    if budget line started yet  theoretical amount zero    if today budget line date date ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom odoo import api, fields, models, _\nfrom odoo.tools import ustr\nfrom odoo.exceptions import UserError, ValidationError\n\n# ---------------------------------------------------------\n# Budgets\n# ---------------------------------------------------------\nclass AccountBudgetPost(models.Model):\n    _name = \"account.budget.post\"\n    _order = \"name\"\n    _description = \"Budgetary Position\"\n\n    name = fields.Char('Name', required=True)\n    account_ids = fields.Many2many('account.account', 'account_budget_rel', 'budget_id', 'account_id', 'Accounts',\n        domain=[('deprecated', '=', False)])\n    crossovered_budget_line = fields.One2many('crossovered.budget.lines', 'general_budget_id', 'Budget Lines')\n    company_id = fields.Many2one('res.company', 'Company', required=True,\n        default=lambda self: self.env['res.company']._company_default_get('account.budget.post'))\n\n    def _check_account_ids(self, vals):\n        # Raise an error to prevent the account.budget.post to have not specified account_ids.\n        # This check is done on create because require=True doesn't work on Many2many fields.\n        if 'account_ids' in vals:\n            account_ids = self.resolve_2many_commands('account_ids', vals['account_ids'])\n        else:\n            account_ids = self.account_ids\n        if not account_ids:\n            raise ValidationError(_('The budget must have at least one account.'))\n\n    @api.model\n    def create(self, vals):\n        self._check_account_ids(vals)\n        return super(AccountBudgetPost, self).create(vals)\n\n    @api.multi\n    def write(self, vals):\n        self._check_account_ids(vals)\n        return super(AccountBudgetPost, self).write(vals)\n\n\nclass CrossoveredBudget(models.Model):\n    _name = \"crossovered.budget\"\n    _description = \"Budget\"\n    _inherit = ['mail.thread']\n\n    name = fields.Char('Budget Name', required=True, states={'done': [('readonly', True)]})\n    creating_user_id = fields.Many2one('res.users', 'Responsible', default=lambda self: self.env.user)\n    date_from = fields.Date('Start Date', required=True, states={'done': [('readonly', True)]})\n    date_to = fields.Date('End Date', required=True, states={'done': [('readonly', True)]})\n    state = fields.Selection([\n        ('draft', 'Draft'),\n        ('cancel', 'Cancelled'),\n        ('confirm', 'Confirmed'),\n        ('validate', 'Validated'),\n        ('done', 'Done')\n        ], 'Status', default='draft', index=True, required=True, readonly=True, copy=False, track_visibility='always')\n    crossovered_budget_line = fields.One2many('crossovered.budget.lines', 'crossovered_budget_id', 'Budget Lines',\n        states={'done': [('readonly', True)]}, copy=True)\n    company_id = fields.Many2one('res.company', 'Company', required=True,\n        default=lambda self: self.env['res.company']._company_default_get('account.budget.post'))\n\n    @api.multi\n    def action_budget_confirm(self):\n        self.write({'state': 'confirm'})\n\n    @api.multi\n    def action_budget_draft(self):\n        self.write({'state': 'draft'})\n\n    @api.multi\n    def action_budget_validate(self):\n        self.write({'state': 'validate'})\n\n    @api.multi\n    def action_budget_cancel(self):\n        self.write({'state': 'cancel'})\n\n    @api.multi\n    def action_budget_done(self):\n        self.write({'state': 'done'})\n\n\nclass CrossoveredBudgetLines(models.Model):\n    _name = \"crossovered.budget.lines\"\n    _description = \"Budget Line\"\n\n    crossovered_budget_id = fields.Many2one('crossovered.budget', 'Budget', ondelete='cascade', index=True, required=True)\n    analytic_account_id = fields.Many2one('account.analytic.account', 'Analytic Account')\n    general_budget_id = fields.Many2one('account.budget.post', 'Budgetary Position', required=True)\n    date_from = fields.Date('Start Date', required=True)\n    date_to = fields.Date('End Date', required=True)\n    paid_date = fields.Date('Paid Date')\n    planned_amount = fields.Float('Planned Amount', required=True, digits=0)\n    practical_amount = fields.Float(compute='_compute_practical_amount', string='Practical Amount', digits=0)\n    theoritical_amount = fields.Float(compute='_compute_theoritical_amount', string='Theoretical Amount', digits=0)\n    percentage = fields.Float(compute='_compute_percentage', string='Achievement')\n    company_id = fields.Many2one(related='crossovered_budget_id.company_id', comodel_name='res.company',\n        string='Company', store=True, readonly=True)\n\n    @api.multi\n    def _compute_practical_amount(self):\n        for line in self:\n            result = 0.0\n            acc_ids = line.general_budget_id.account_ids.ids\n            date_to = self.env.context.get('wizard_date_to') or line.date_to\n            date_from = self.env.context.get('wizard_date_from') or line.date_from\n            if line.analytic_account_id.id:\n                self.env.cr.execute(\"\"\"\n                    SELECT SUM(amount)\n                    FROM account_analytic_line\n                    WHERE account_id=%s\n                        AND (date between to_date(%s,'yyyy-mm-dd') AND to_date(%s,'yyyy-mm-dd'))\n                        AND general_account_id=ANY(%s)\"\"\",\n                (line.analytic_account_id.id, date_from, date_to, acc_ids,))\n                result = self.env.cr.fetchone()[0] or 0.0\n            line.practical_amount = result\n\n    @api.multi\n    def _compute_theoritical_amount(self):\n        today = fields.Datetime.now()\n        for line in self:\n            # Used for the report\n\n            if self.env.context.get('wizard_date_from') and self.env.context.get('wizard_date_to'):\n                date_from = fields.Datetime.from_string(self.env.context.get('wizard_date_from'))\n                date_to = fields.Datetime.from_string(self.env.context.get('wizard_date_to'))\n                if date_from < fields.Datetime.from_string(line.date_from):\n                    date_from = fields.Datetime.from_string(line.date_from)\n                elif date_from > fields.Datetime.from_string(line.date_to):\n                    date_from = False\n\n                if date_to > fields.Datetime.from_string(line.date_to):\n                    date_to = fields.Datetime.from_string(line.date_to)\n                elif date_to < fields.Datetime.from_string(line.date_from):\n                    date_to = False\n\n                theo_amt = 0.00\n                if date_from and date_to:\n                    line_timedelta = fields.Datetime.from_string(line.date_to) - fields.Datetime.from_string(line.date_from)\n                    elapsed_timedelta = date_to - date_from\n                    if elapsed_timedelta.days > 0:\n                        theo_amt = (elapsed_timedelta.total_seconds() / line_timedelta.total_seconds()) * line.planned_amount\n            else:\n                if line.paid_date:\n                    if fields.Datetime.from_string(line.date_to) <= fields.Datetime.from_string(line.paid_date):\n                        theo_amt = 0.00\n                    else:\n                        theo_amt = line.planned_amount\n                else:\n                    line_timedelta = fields.Datetime.from_string(line.date_to) - fields.Datetime.from_string(line.date_from)\n                    elapsed_timedelta = fields.Datetime.from_string(today) - (fields.Datetime.from_string(line.date_from))\n\n                    if elapsed_timedelta.days < 0:\n                        # If the budget line has not started yet, theoretical amount should be zero\n                        theo_amt = 0.00\n                    elif line_timedelta.days > 0 and fields.Datetime.from_string(today) < fields.Datetime.from_string(line.date_to):\n                        # If today is between the budget line date_from and date_to\n                        theo_amt = (elapsed_timedelta.total_seconds() / line_timedelta.total_seconds()) * line.planned_amount\n                    else:\n                        theo_amt = line.planned_amount\n\n            line.theoritical_amount = theo_amt\n\n    @api.multi\n    def _compute_percentage(self):\n        for line in self:\n            if line.theoritical_amount != 0.00:\n                line.percentage = float((line.practical_amount or 0.0) / line.theoritical_amount) * 100\n            else:\n                line.percentage = 0.00\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "account_budget.py", "id": "8c14cee54b3c1cf0b4a14f2e968ddd6f", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/account_budget/models/account_budget.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}