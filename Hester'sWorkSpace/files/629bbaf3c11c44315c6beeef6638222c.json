{"author": "HelloZeroNet", "code": "import time\nimport collections\nimport itertools\nimport re\n\nimport gevent\n\nfrom util import helper\nfrom Plugin import PluginManager\nfrom Config import config\nfrom Debug import Debug\n\nif \"content_db\" not in locals().keys():  \n    content_db = None\n\n\n@PluginManager.registerTo(\"ContentDb\")\nclass ContentDbPlugin(object):\n    def __init__(self, *args, **kwargs):\n        global content_db\n        content_db = self\n        self.filled = {}  \n        self.need_filling = False  \n        self.time_peer_numbers_updated = 0\n        self.my_optional_files = {}  # Last 50 site_address/inner_path called by fileWrite (auto-pinning these files)\n        self.optional_files = collections.defaultdict(dict)\n        self.optional_files_loading = False\n        helper.timer(60 * 5, self.checkOptionalLimit)\n        super(ContentDbPlugin, self).__init__(*args, **kwargs)\n\n    def getSchema(self):\n        schema = super(ContentDbPlugin, self).getSchema()\n\n        \n        schema[\"tables\"][\"file_optional\"] = {\n            \"cols\": [\n                [\"file_id\", \"INTEGER PRIMARY KEY UNIQUE NOT NULL\"],\n                [\"site_id\", \"INTEGER REFERENCES site (site_id) ON DELETE CASCADE\"],\n                [\"inner_path\", \"TEXT\"],\n                [\"hash_id\", \"INTEGER\"],\n                [\"size\", \"INTEGER\"],\n                [\"peer\", \"INTEGER DEFAULT 0\"],\n                [\"uploaded\", \"INTEGER DEFAULT 0\"],\n                [\"is_downloaded\", \"INTEGER DEFAULT 0\"],\n                [\"is_pinned\", \"INTEGER DEFAULT 0\"],\n                [\"time_added\", \"INTEGER DEFAULT 0\"],\n                [\"time_downloaded\", \"INTEGER DEFAULT 0\"],\n                [\"time_accessed\", \"INTEGER DEFAULT 0\"]\n            ],\n            \"indexes\": [\n                \"CREATE UNIQUE INDEX file_optional_key ON file_optional (site_id, inner_path)\",\n                \"CREATE INDEX is_downloaded ON file_optional (is_downloaded)\"\n            ],\n            \"schema_changed\": 11\n        }\n\n        return schema\n\n    def initSite(self, site):\n        super(ContentDbPlugin, self).initSite(site)\n        if self.need_filling:\n            self.fillTableFileOptional(site)\n        if not self.optional_files_loading:\n            gevent.spawn_later(1, self.loadFilesOptional)\n            self.optional_files_loading = True\n\n    def checkTables(self):\n        changed_tables = super(ContentDbPlugin, self).checkTables()\n        if \"file_optional\" in changed_tables:\n            self.need_filling = True\n        return changed_tables\n\n    \n    def loadFilesOptional(self):\n        s = time.time()\n        num = 0\n        total = 0\n        total_downloaded = 0\n        res = content_db.execute(\"SELECT site_id, inner_path, size, is_downloaded FROM file_optional\")\n        site_sizes = collections.defaultdict(lambda: collections.defaultdict(int))\n        for row in res:\n            self.optional_files[row[\"site_id\"]][row[\"inner_path\"][-8:]] = 1\n            num += 1\n\n            \n            site_sizes[row[\"site_id\"]][\"size_optional\"] += row[\"size\"]\n            if row[\"is_downloaded\"]:\n                site_sizes[row[\"site_id\"]][\"optional_downloaded\"] += row[\"size\"]\n\n        \n        site_ids_reverse = {val: key for key, val in self.site_ids.iteritems()}\n        for site_id, stats in site_sizes.iteritems():\n            site_address = site_ids_reverse.get(site_id)\n            if not site_address:\n                self.log.error(\"Not found site_id: %s\" % site_id)\n                continue\n            site = self.sites[site_address]\n            site.settings[\"size_optional\"] = stats[\"size_optional\"]\n            site.settings[\"optional_downloaded\"] = stats[\"optional_downloaded\"]\n            total += stats[\"size_optional\"]\n            total_downloaded += stats[\"optional_downloaded\"]\n\n        self.log.debug(\n            \"Loaded %s optional files: %.2fMB, downloaded: %.2fMB in %.3fs\" %\n            (num, float(total) / 1024 / 1024, float(total_downloaded) / 1024 / 1024, time.time() - s)\n        )\n\n        if self.need_filling and self.getOptionalLimitBytes() >= 0 and self.getOptionalLimitBytes() < total_downloaded:\n            limit_bytes = self.getOptionalLimitBytes()\n            limit_new = round((float(total_downloaded) / 1024 / 1024 / 1024) * 1.1, 2)  # Current limit + 10%\n            self.log.debug(\n                \"First startup after update and limit is smaller than downloaded files size (%.2fGB), increasing it from %.2fGB to %.2fGB\" %\n                (float(total_downloaded) / 1024 / 1024 / 1024, float(limit_bytes) / 1024 / 1024 / 1024, limit_new)\n            )\n            config.saveValue(\"optional_limit\", limit_new)\n            config.optional_limit = str(limit_new)\n\n    \n    def isOptionalFile(self, site_id, inner_path):\n        return self.optional_files[site_id].get(inner_path[-8:])\n\n    \n    def fillTableFileOptional(self, site):\n        s = time.time()\n        site_id = self.site_ids.get(site.address)\n        if not site_id:\n            return False\n        cur = self.getCursor()\n        cur.execute(\"BEGIN\")\n        res = cur.execute(\"SELECT * FROM content WHERE size_files_optional > 0 AND site_id = %s\" % site_id)\n        num = 0\n        for row in res.fetchall():\n            content = site.content_manager.contents[row[\"inner_path\"]]\n            try:\n                num += self.setContentFilesOptional(site, row[\"inner_path\"], content, cur=cur)\n            except Exception as err:\n                self.log.error(\"Error loading %s into file_optional: %s\" % (row[\"inner_path\"], err))\n        cur.execute(\"COMMIT\")\n        cur.close()\n\n        \n        from User import UserManager\n        user = UserManager.user_manager.get()\n        if not user:\n            user = UserManager.user_manager.create()\n        auth_address = user.getAuthAddress(site.address)\n        self.execute(\n            \"UPDATE file_optional SET is_pinned = 1 WHERE site_id = :site_id AND inner_path LIKE :inner_path\",\n            {\"site_id\": site_id, \"inner_path\": \"%%/%s/%%\" % auth_address}\n        )\n\n        self.log.debug(\n            \"Filled file_optional table for %s in %.3fs (loaded: %s, is_pinned: %s)\" %\n            (site.address, time.time() - s, num, self.cur.cursor.rowcount)\n        )\n        self.filled[site.address] = True\n\n    def setContentFilesOptional(self, site, content_inner_path, content, cur=None):\n        if not cur:\n            cur = self\n            try:\n                cur.execute(\"BEGIN\")\n            except Exception as err:\n                self.log.warning(\"Transaction begin error %s %s: %s\" % (site, content_inner_path, Debug.formatException(err)))\n\n        num = 0\n        site_id = self.site_ids[site.address]\n        content_inner_dir = helper.getDirname(content_inner_path)\n        for relative_inner_path, file in content.get(\"files_optional\", {}).iteritems():\n            file_inner_path = content_inner_dir + relative_inner_path\n            hash_id = int(file[\"sha512\"][0:4], 16)\n            if hash_id in site.content_manager.hashfield:\n                is_downloaded = 1\n            else:\n                is_downloaded = 0\n            if site.address + \"/\" + content_inner_dir in self.my_optional_files:\n                is_pinned = 1\n            else:\n                is_pinned = 0\n            cur.insertOrUpdate(\"file_optional\", {\n                \"hash_id\": hash_id,\n                \"size\": int(file[\"size\"])\n            }, {\n                \"site_id\": site_id,\n                \"inner_path\": file_inner_path\n            }, oninsert={\n                \"time_added\": int(time.time()),\n                \"time_downloaded\": int(time.time()) if is_downloaded else 0,\n                \"is_downloaded\": is_downloaded,\n                \"peer\": is_downloaded,\n                \"is_pinned\": is_pinned\n            })\n            self.optional_files[site_id][file_inner_path[-8:]] = 1\n            num += 1\n\n        if cur == self:\n            try:\n                cur.execute(\"END\")\n            except Exception as err:\n                self.log.warning(\"Transaction end error %s %s: %s\" % (site, content_inner_path, Debug.formatException(err)))\n        return num\n\n    def setContent(self, site, inner_path, content, size=0):\n        super(ContentDbPlugin, self).setContent(site, inner_path, content, size=size)\n        old_content = site.content_manager.contents.get(inner_path, {})\n        if (not self.need_filling or self.filled.get(site.address)) and \"files_optional\" in content or \"files_optional\" in old_content:\n            self.setContentFilesOptional(site, inner_path, content)\n            \n            if old_content:\n                old_files = old_content.get(\"files_optional\", {}).keys()\n                new_files = content.get(\"files_optional\", {}).keys()\n                content_inner_dir = helper.getDirname(inner_path)\n                deleted = [content_inner_dir + key for key in old_files if key not in new_files]\n                if deleted:\n                    site_id = self.site_ids[site.address]\n                    self.execute(\"DELETE FROM file_optional WHERE ?\", {\"site_id\": site_id, \"inner_path\": deleted})\n\n    def deleteContent(self, site, inner_path):\n        content = site.content_manager.contents.get(inner_path)\n        if content and \"files_optional\" in content:\n            site_id = self.site_ids[site.address]\n            content_inner_dir = helper.getDirname(inner_path)\n            optional_inner_paths = [\n                content_inner_dir + relative_inner_path\n                for relative_inner_path in content.get(\"files_optional\", {}).keys()\n            ]\n            self.execute(\"DELETE FROM file_optional WHERE ?\", {\"site_id\": site_id, \"inner_path\": optional_inner_paths})\n        super(ContentDbPlugin, self).deleteContent(site, inner_path)\n\n    def updatePeerNumbers(self):\n        s = time.time()\n        num_file = 0\n        num_updated = 0\n        num_site = 0\n        for site in self.sites.values():\n            if not site.content_manager.has_optional_files:\n                continue\n            has_updated_hashfield = next((\n                peer\n                for peer in site.peers.itervalues()\n                if peer.has_hashfield and peer.hashfield.time_changed > self.time_peer_numbers_updated\n            ), None)\n\n            if not has_updated_hashfield and site.content_manager.hashfield.time_changed < self.time_peer_numbers_updated:\n                continue\n\n            hashfield_peers = itertools.chain.from_iterable(\n                peer.hashfield.storage\n                for peer in site.peers.itervalues()\n                if peer.has_hashfield\n            )\n            peer_nums = collections.Counter(\n                itertools.chain(\n                    hashfield_peers,\n                    site.content_manager.hashfield\n                )\n            )\n\n            site_id = self.site_ids[site.address]\n            if not site_id:\n                continue\n\n            res = self.execute(\"SELECT file_id, hash_id, peer FROM file_optional WHERE ?\", {\"site_id\": site_id})\n            updates = {}\n            for row in res:\n                peer_num = peer_nums.get(row[\"hash_id\"], 0)\n                if peer_num != row[\"peer\"]:\n                    updates[row[\"file_id\"]] = peer_num\n\n            self.execute(\"BEGIN\")\n            for file_id, peer_num in updates.iteritems():\n                self.execute(\"UPDATE file_optional SET peer = ? WHERE file_id = ?\", (peer_num, file_id))\n            self.execute(\"END\")\n\n            num_updated += len(updates)\n            num_file += len(peer_nums)\n            num_site += 1\n\n        self.time_peer_numbers_updated = time.time()\n        self.log.debug(\"%s/%s peer number for %s site updated in %.3fs\" % (num_updated, num_file, num_site, time.time() - s))\n\n    def queryDeletableFiles(self):\n        \n        query = \"\"\"\n            SELECT * FROM file_optional\n            WHERE peer > 10 AND is_downloaded = 1 AND is_pinned = 0\n            ORDER BY time_accessed < %s DESC, uploaded / size\n        \"\"\" % int(time.time() - 60 * 60 * 7)\n        limit_start = 0\n        while 1:\n            num = 0\n            res = self.execute(\"%s LIMIT %s, 50\" % (query, limit_start))\n            for row in res:\n                yield row\n                num += 1\n            if num < 50:\n                break\n            limit_start += 50\n\n        self.log.debug(\"queryDeletableFiles returning less-seeded files\")\n\n        \n        query = \"\"\"\n            SELECT * FROM file_optional\n            WHERE is_downloaded = 1 AND peer <= 10 AND is_pinned = 0\n            ORDER BY peer DESC, time_accessed < %s DESC, uploaded / size\n        \"\"\" % int(time.time() - 60 * 60 * 7)\n        limit_start = 0\n        while 1:\n            num = 0\n            res = self.execute(\"%s LIMIT %s, 50\" % (query, limit_start))\n            for row in res:\n                yield row\n                num += 1\n            if num < 50:\n                break\n            limit_start += 50\n\n        self.log.debug(\"queryDeletableFiles returning everyting\")\n\n        \n        query = \"\"\"\n            SELECT * FROM file_optional\n            WHERE is_downloaded = 1 AND peer <= 10 AND is_pinned = 0\n            ORDER BY peer DESC, time_accessed, uploaded / size\n        \"\"\"\n        limit_start = 0\n        while 1:\n            num = 0\n            res = self.execute(\"%s LIMIT %s, 50\" % (query, limit_start))\n            for row in res:\n                yield row\n                num += 1\n            if num < 50:\n                break\n            limit_start += 50\n\n    def getOptionalLimitBytes(self):\n        if config.optional_limit.endswith(\"%\"):\n            limit_percent = float(re.sub(\"[^0-9.]\", \"\", config.optional_limit))\n            limit_bytes = helper.getFreeSpace() * (limit_percent / 100)\n        else:\n            limit_bytes = float(re.sub(\"[^0-9.]\", \"\", config.optional_limit)) * 1024 * 1024 * 1024\n        return limit_bytes\n\n    def getOptionalUsedBytes(self):\n        size = self.execute(\"SELECT SUM(size) FROM file_optional WHERE is_downloaded = 1 AND is_pinned = 0\").fetchone()[0]\n        if not size:\n            size = 0\n        return size\n\n    def getOptionalNeedDelete(self, size):\n        if config.optional_limit.endswith(\"%\"):\n            limit_percent = float(re.sub(\"[^0-9.]\", \"\", config.optional_limit))\n            need_delete = size - ((helper.getFreeSpace() + size) * (limit_percent / 100))\n        else:\n            need_delete = size - self.getOptionalLimitBytes()\n        return need_delete\n\n    def checkOptionalLimit(self, limit=None):\n        if not limit:\n            limit = self.getOptionalLimitBytes()\n\n        if limit < 0:\n            self.log.debug(\"Invalid limit for optional files: %s\" % limit)\n            return False\n\n        size = self.getOptionalUsedBytes()\n\n        need_delete = self.getOptionalNeedDelete(size)\n\n        self.log.debug(\n            \"Optional size: %.1fMB/%.1fMB, Need delete: %.1fMB\" %\n            (float(size) / 1024 / 1024, float(limit) / 1024 / 1024, float(need_delete) / 1024 / 1024)\n        )\n        if need_delete <= 0:\n            return False\n\n        self.updatePeerNumbers()\n\n        site_ids_reverse = {val: key for key, val in self.site_ids.iteritems()}\n        deleted_file_ids = []\n        for row in self.queryDeletableFiles():\n            site_address = site_ids_reverse.get(row[\"site_id\"])\n            site = self.sites.get(site_address)\n            if not site:\n                self.log.error(\"No site found for id: %s\" % row[\"site_id\"])\n                continue\n            site.log.debug(\"Deleting %s %.3f MB left\" % (row[\"inner_path\"], float(need_delete) / 1024 / 1024))\n            deleted_file_ids.append(row[\"file_id\"])\n            try:\n                site.content_manager.optionalRemove(row[\"inner_path\"], row[\"hash_id\"], row[\"size\"])\n                site.storage.delete(row[\"inner_path\"])\n                need_delete -= row[\"size\"]\n            except Exception as err:\n                site.log.error(\"Error deleting %s: %s\" % (row[\"inner_path\"], err))\n\n            if need_delete <= 0:\n                break\n\n        cur = self.getCursor()\n        cur.execute(\"BEGIN\")\n        for file_id in deleted_file_ids:\n            cur.execute(\"UPDATE file_optional SET is_downloaded = 0, is_pinned = 0, peer = peer - 1 WHERE ?\", {\"file_id\": file_id})\n        cur.execute(\"COMMIT\")\n        cur.close()\n", "comments": "                select   from file optional             where peer   10 and downloaded   1 and pinned   0             order by time accessed    desc  uploaded   size               int(time time()   60   60   7)         limit start   0         1              num   0             res   self execute(  limit   50    (query  limit start))             row res                  yield row                 num    1             num   50                  break             limit start    50          self log debug( querydeletablefiles returning less seeded files )            then return files less seeder still accessed last week         query                   select   from file optional             where downloaded   1 and peer    10 and pinned   0             order by peer desc  time accessed    desc  uploaded   size               int(time time()   60   60   7)         limit start   0         1              num   0             res   self execute(  limit   50    (query  limit start))             row res                  yield row                 num    1             num   50                  break             limit start    50          self log debug( querydeletablefiles returning everyting )            at end return files         query                   select   from file optional             where downloaded   1 and peer    10 and pinned   0             order by peer desc  time accessed  uploaded   size                to keep module reloads    site addresses already filled content json    file optional table created  fill data content json files    last 50 site address inner path called filewrite (auto pinning files)    need file optional table    load optional files ending    update site size stats    site site size stats sites json settings    current limit   10     predicts file optional    fill file optional table optional files found sites    set files pinned    check deleted files    first return files atleast 10 seeder accessed last weed    then return files less seeder still accessed last week    at end return files ", "content": "import time\nimport collections\nimport itertools\nimport re\n\nimport gevent\n\nfrom util import helper\nfrom Plugin import PluginManager\nfrom Config import config\nfrom Debug import Debug\n\nif \"content_db\" not in locals().keys():  # To keep between module reloads\n    content_db = None\n\n\n@PluginManager.registerTo(\"ContentDb\")\nclass ContentDbPlugin(object):\n    def __init__(self, *args, **kwargs):\n        global content_db\n        content_db = self\n        self.filled = {}  # Site addresses that already filled from content.json\n        self.need_filling = False  # file_optional table just created, fill data from content.json files\n        self.time_peer_numbers_updated = 0\n        self.my_optional_files = {}  # Last 50 site_address/inner_path called by fileWrite (auto-pinning these files)\n        self.optional_files = collections.defaultdict(dict)\n        self.optional_files_loading = False\n        helper.timer(60 * 5, self.checkOptionalLimit)\n        super(ContentDbPlugin, self).__init__(*args, **kwargs)\n\n    def getSchema(self):\n        schema = super(ContentDbPlugin, self).getSchema()\n\n        # Need file_optional table\n        schema[\"tables\"][\"file_optional\"] = {\n            \"cols\": [\n                [\"file_id\", \"INTEGER PRIMARY KEY UNIQUE NOT NULL\"],\n                [\"site_id\", \"INTEGER REFERENCES site (site_id) ON DELETE CASCADE\"],\n                [\"inner_path\", \"TEXT\"],\n                [\"hash_id\", \"INTEGER\"],\n                [\"size\", \"INTEGER\"],\n                [\"peer\", \"INTEGER DEFAULT 0\"],\n                [\"uploaded\", \"INTEGER DEFAULT 0\"],\n                [\"is_downloaded\", \"INTEGER DEFAULT 0\"],\n                [\"is_pinned\", \"INTEGER DEFAULT 0\"],\n                [\"time_added\", \"INTEGER DEFAULT 0\"],\n                [\"time_downloaded\", \"INTEGER DEFAULT 0\"],\n                [\"time_accessed\", \"INTEGER DEFAULT 0\"]\n            ],\n            \"indexes\": [\n                \"CREATE UNIQUE INDEX file_optional_key ON file_optional (site_id, inner_path)\",\n                \"CREATE INDEX is_downloaded ON file_optional (is_downloaded)\"\n            ],\n            \"schema_changed\": 11\n        }\n\n        return schema\n\n    def initSite(self, site):\n        super(ContentDbPlugin, self).initSite(site)\n        if self.need_filling:\n            self.fillTableFileOptional(site)\n        if not self.optional_files_loading:\n            gevent.spawn_later(1, self.loadFilesOptional)\n            self.optional_files_loading = True\n\n    def checkTables(self):\n        changed_tables = super(ContentDbPlugin, self).checkTables()\n        if \"file_optional\" in changed_tables:\n            self.need_filling = True\n        return changed_tables\n\n    # Load optional files ending\n    def loadFilesOptional(self):\n        s = time.time()\n        num = 0\n        total = 0\n        total_downloaded = 0\n        res = content_db.execute(\"SELECT site_id, inner_path, size, is_downloaded FROM file_optional\")\n        site_sizes = collections.defaultdict(lambda: collections.defaultdict(int))\n        for row in res:\n            self.optional_files[row[\"site_id\"]][row[\"inner_path\"][-8:]] = 1\n            num += 1\n\n            # Update site size stats\n            site_sizes[row[\"site_id\"]][\"size_optional\"] += row[\"size\"]\n            if row[\"is_downloaded\"]:\n                site_sizes[row[\"site_id\"]][\"optional_downloaded\"] += row[\"size\"]\n\n        # Site site size stats to sites.json settings\n        site_ids_reverse = {val: key for key, val in self.site_ids.iteritems()}\n        for site_id, stats in site_sizes.iteritems():\n            site_address = site_ids_reverse.get(site_id)\n            if not site_address:\n                self.log.error(\"Not found site_id: %s\" % site_id)\n                continue\n            site = self.sites[site_address]\n            site.settings[\"size_optional\"] = stats[\"size_optional\"]\n            site.settings[\"optional_downloaded\"] = stats[\"optional_downloaded\"]\n            total += stats[\"size_optional\"]\n            total_downloaded += stats[\"optional_downloaded\"]\n\n        self.log.debug(\n            \"Loaded %s optional files: %.2fMB, downloaded: %.2fMB in %.3fs\" %\n            (num, float(total) / 1024 / 1024, float(total_downloaded) / 1024 / 1024, time.time() - s)\n        )\n\n        if self.need_filling and self.getOptionalLimitBytes() >= 0 and self.getOptionalLimitBytes() < total_downloaded:\n            limit_bytes = self.getOptionalLimitBytes()\n            limit_new = round((float(total_downloaded) / 1024 / 1024 / 1024) * 1.1, 2)  # Current limit + 10%\n            self.log.debug(\n                \"First startup after update and limit is smaller than downloaded files size (%.2fGB), increasing it from %.2fGB to %.2fGB\" %\n                (float(total_downloaded) / 1024 / 1024 / 1024, float(limit_bytes) / 1024 / 1024 / 1024, limit_new)\n            )\n            config.saveValue(\"optional_limit\", limit_new)\n            config.optional_limit = str(limit_new)\n\n    # Predicts if the file is optional\n    def isOptionalFile(self, site_id, inner_path):\n        return self.optional_files[site_id].get(inner_path[-8:])\n\n    # Fill file_optional table with optional files found in sites\n    def fillTableFileOptional(self, site):\n        s = time.time()\n        site_id = self.site_ids.get(site.address)\n        if not site_id:\n            return False\n        cur = self.getCursor()\n        cur.execute(\"BEGIN\")\n        res = cur.execute(\"SELECT * FROM content WHERE size_files_optional > 0 AND site_id = %s\" % site_id)\n        num = 0\n        for row in res.fetchall():\n            content = site.content_manager.contents[row[\"inner_path\"]]\n            try:\n                num += self.setContentFilesOptional(site, row[\"inner_path\"], content, cur=cur)\n            except Exception as err:\n                self.log.error(\"Error loading %s into file_optional: %s\" % (row[\"inner_path\"], err))\n        cur.execute(\"COMMIT\")\n        cur.close()\n\n        # Set my files to pinned\n        from User import UserManager\n        user = UserManager.user_manager.get()\n        if not user:\n            user = UserManager.user_manager.create()\n        auth_address = user.getAuthAddress(site.address)\n        self.execute(\n            \"UPDATE file_optional SET is_pinned = 1 WHERE site_id = :site_id AND inner_path LIKE :inner_path\",\n            {\"site_id\": site_id, \"inner_path\": \"%%/%s/%%\" % auth_address}\n        )\n\n        self.log.debug(\n            \"Filled file_optional table for %s in %.3fs (loaded: %s, is_pinned: %s)\" %\n            (site.address, time.time() - s, num, self.cur.cursor.rowcount)\n        )\n        self.filled[site.address] = True\n\n    def setContentFilesOptional(self, site, content_inner_path, content, cur=None):\n        if not cur:\n            cur = self\n            try:\n                cur.execute(\"BEGIN\")\n            except Exception as err:\n                self.log.warning(\"Transaction begin error %s %s: %s\" % (site, content_inner_path, Debug.formatException(err)))\n\n        num = 0\n        site_id = self.site_ids[site.address]\n        content_inner_dir = helper.getDirname(content_inner_path)\n        for relative_inner_path, file in content.get(\"files_optional\", {}).iteritems():\n            file_inner_path = content_inner_dir + relative_inner_path\n            hash_id = int(file[\"sha512\"][0:4], 16)\n            if hash_id in site.content_manager.hashfield:\n                is_downloaded = 1\n            else:\n                is_downloaded = 0\n            if site.address + \"/\" + content_inner_dir in self.my_optional_files:\n                is_pinned = 1\n            else:\n                is_pinned = 0\n            cur.insertOrUpdate(\"file_optional\", {\n                \"hash_id\": hash_id,\n                \"size\": int(file[\"size\"])\n            }, {\n                \"site_id\": site_id,\n                \"inner_path\": file_inner_path\n            }, oninsert={\n                \"time_added\": int(time.time()),\n                \"time_downloaded\": int(time.time()) if is_downloaded else 0,\n                \"is_downloaded\": is_downloaded,\n                \"peer\": is_downloaded,\n                \"is_pinned\": is_pinned\n            })\n            self.optional_files[site_id][file_inner_path[-8:]] = 1\n            num += 1\n\n        if cur == self:\n            try:\n                cur.execute(\"END\")\n            except Exception as err:\n                self.log.warning(\"Transaction end error %s %s: %s\" % (site, content_inner_path, Debug.formatException(err)))\n        return num\n\n    def setContent(self, site, inner_path, content, size=0):\n        super(ContentDbPlugin, self).setContent(site, inner_path, content, size=size)\n        old_content = site.content_manager.contents.get(inner_path, {})\n        if (not self.need_filling or self.filled.get(site.address)) and \"files_optional\" in content or \"files_optional\" in old_content:\n            self.setContentFilesOptional(site, inner_path, content)\n            # Check deleted files\n            if old_content:\n                old_files = old_content.get(\"files_optional\", {}).keys()\n                new_files = content.get(\"files_optional\", {}).keys()\n                content_inner_dir = helper.getDirname(inner_path)\n                deleted = [content_inner_dir + key for key in old_files if key not in new_files]\n                if deleted:\n                    site_id = self.site_ids[site.address]\n                    self.execute(\"DELETE FROM file_optional WHERE ?\", {\"site_id\": site_id, \"inner_path\": deleted})\n\n    def deleteContent(self, site, inner_path):\n        content = site.content_manager.contents.get(inner_path)\n        if content and \"files_optional\" in content:\n            site_id = self.site_ids[site.address]\n            content_inner_dir = helper.getDirname(inner_path)\n            optional_inner_paths = [\n                content_inner_dir + relative_inner_path\n                for relative_inner_path in content.get(\"files_optional\", {}).keys()\n            ]\n            self.execute(\"DELETE FROM file_optional WHERE ?\", {\"site_id\": site_id, \"inner_path\": optional_inner_paths})\n        super(ContentDbPlugin, self).deleteContent(site, inner_path)\n\n    def updatePeerNumbers(self):\n        s = time.time()\n        num_file = 0\n        num_updated = 0\n        num_site = 0\n        for site in self.sites.values():\n            if not site.content_manager.has_optional_files:\n                continue\n            has_updated_hashfield = next((\n                peer\n                for peer in site.peers.itervalues()\n                if peer.has_hashfield and peer.hashfield.time_changed > self.time_peer_numbers_updated\n            ), None)\n\n            if not has_updated_hashfield and site.content_manager.hashfield.time_changed < self.time_peer_numbers_updated:\n                continue\n\n            hashfield_peers = itertools.chain.from_iterable(\n                peer.hashfield.storage\n                for peer in site.peers.itervalues()\n                if peer.has_hashfield\n            )\n            peer_nums = collections.Counter(\n                itertools.chain(\n                    hashfield_peers,\n                    site.content_manager.hashfield\n                )\n            )\n\n            site_id = self.site_ids[site.address]\n            if not site_id:\n                continue\n\n            res = self.execute(\"SELECT file_id, hash_id, peer FROM file_optional WHERE ?\", {\"site_id\": site_id})\n            updates = {}\n            for row in res:\n                peer_num = peer_nums.get(row[\"hash_id\"], 0)\n                if peer_num != row[\"peer\"]:\n                    updates[row[\"file_id\"]] = peer_num\n\n            self.execute(\"BEGIN\")\n            for file_id, peer_num in updates.iteritems():\n                self.execute(\"UPDATE file_optional SET peer = ? WHERE file_id = ?\", (peer_num, file_id))\n            self.execute(\"END\")\n\n            num_updated += len(updates)\n            num_file += len(peer_nums)\n            num_site += 1\n\n        self.time_peer_numbers_updated = time.time()\n        self.log.debug(\"%s/%s peer number for %s site updated in %.3fs\" % (num_updated, num_file, num_site, time.time() - s))\n\n    def queryDeletableFiles(self):\n        # First return the files with atleast 10 seeder and not accessed in last weed\n        query = \"\"\"\n            SELECT * FROM file_optional\n            WHERE peer > 10 AND is_downloaded = 1 AND is_pinned = 0\n            ORDER BY time_accessed < %s DESC, uploaded / size\n        \"\"\" % int(time.time() - 60 * 60 * 7)\n        limit_start = 0\n        while 1:\n            num = 0\n            res = self.execute(\"%s LIMIT %s, 50\" % (query, limit_start))\n            for row in res:\n                yield row\n                num += 1\n            if num < 50:\n                break\n            limit_start += 50\n\n        self.log.debug(\"queryDeletableFiles returning less-seeded files\")\n\n        # Then return files less seeder but still not accessed in last week\n        query = \"\"\"\n            SELECT * FROM file_optional\n            WHERE is_downloaded = 1 AND peer <= 10 AND is_pinned = 0\n            ORDER BY peer DESC, time_accessed < %s DESC, uploaded / size\n        \"\"\" % int(time.time() - 60 * 60 * 7)\n        limit_start = 0\n        while 1:\n            num = 0\n            res = self.execute(\"%s LIMIT %s, 50\" % (query, limit_start))\n            for row in res:\n                yield row\n                num += 1\n            if num < 50:\n                break\n            limit_start += 50\n\n        self.log.debug(\"queryDeletableFiles returning everyting\")\n\n        # At the end return all files\n        query = \"\"\"\n            SELECT * FROM file_optional\n            WHERE is_downloaded = 1 AND peer <= 10 AND is_pinned = 0\n            ORDER BY peer DESC, time_accessed, uploaded / size\n        \"\"\"\n        limit_start = 0\n        while 1:\n            num = 0\n            res = self.execute(\"%s LIMIT %s, 50\" % (query, limit_start))\n            for row in res:\n                yield row\n                num += 1\n            if num < 50:\n                break\n            limit_start += 50\n\n    def getOptionalLimitBytes(self):\n        if config.optional_limit.endswith(\"%\"):\n            limit_percent = float(re.sub(\"[^0-9.]\", \"\", config.optional_limit))\n            limit_bytes = helper.getFreeSpace() * (limit_percent / 100)\n        else:\n            limit_bytes = float(re.sub(\"[^0-9.]\", \"\", config.optional_limit)) * 1024 * 1024 * 1024\n        return limit_bytes\n\n    def getOptionalUsedBytes(self):\n        size = self.execute(\"SELECT SUM(size) FROM file_optional WHERE is_downloaded = 1 AND is_pinned = 0\").fetchone()[0]\n        if not size:\n            size = 0\n        return size\n\n    def getOptionalNeedDelete(self, size):\n        if config.optional_limit.endswith(\"%\"):\n            limit_percent = float(re.sub(\"[^0-9.]\", \"\", config.optional_limit))\n            need_delete = size - ((helper.getFreeSpace() + size) * (limit_percent / 100))\n        else:\n            need_delete = size - self.getOptionalLimitBytes()\n        return need_delete\n\n    def checkOptionalLimit(self, limit=None):\n        if not limit:\n            limit = self.getOptionalLimitBytes()\n\n        if limit < 0:\n            self.log.debug(\"Invalid limit for optional files: %s\" % limit)\n            return False\n\n        size = self.getOptionalUsedBytes()\n\n        need_delete = self.getOptionalNeedDelete(size)\n\n        self.log.debug(\n            \"Optional size: %.1fMB/%.1fMB, Need delete: %.1fMB\" %\n            (float(size) / 1024 / 1024, float(limit) / 1024 / 1024, float(need_delete) / 1024 / 1024)\n        )\n        if need_delete <= 0:\n            return False\n\n        self.updatePeerNumbers()\n\n        site_ids_reverse = {val: key for key, val in self.site_ids.iteritems()}\n        deleted_file_ids = []\n        for row in self.queryDeletableFiles():\n            site_address = site_ids_reverse.get(row[\"site_id\"])\n            site = self.sites.get(site_address)\n            if not site:\n                self.log.error(\"No site found for id: %s\" % row[\"site_id\"])\n                continue\n            site.log.debug(\"Deleting %s %.3f MB left\" % (row[\"inner_path\"], float(need_delete) / 1024 / 1024))\n            deleted_file_ids.append(row[\"file_id\"])\n            try:\n                site.content_manager.optionalRemove(row[\"inner_path\"], row[\"hash_id\"], row[\"size\"])\n                site.storage.delete(row[\"inner_path\"])\n                need_delete -= row[\"size\"]\n            except Exception as err:\n                site.log.error(\"Error deleting %s: %s\" % (row[\"inner_path\"], err))\n\n            if need_delete <= 0:\n                break\n\n        cur = self.getCursor()\n        cur.execute(\"BEGIN\")\n        for file_id in deleted_file_ids:\n            cur.execute(\"UPDATE file_optional SET is_downloaded = 0, is_pinned = 0, peer = peer - 1 WHERE ?\", {\"file_id\": file_id})\n        cur.execute(\"COMMIT\")\n        cur.close()\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "ContentDbPlugin.py", "id": "629bbaf3c11c44315c6beeef6638222c", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/plugins/OptionalManager/ContentDbPlugin.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}