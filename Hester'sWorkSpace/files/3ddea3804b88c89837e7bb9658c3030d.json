{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport random\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_urlparse,\n)\nfrom ..utils import (\n    encode_data_uri,\n    ExtractorError,\n    int_or_none,\n    float_or_none,\n    mimetype2ext,\n    str_or_none,\n)\n\n\nclass UstreamIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?ustream\\.tv/(?P<type>recorded|embed|embed/recorded)/(?P<id>\\d+)'\n    IE_NAME = 'ustream'\n    _TESTS = [{\n        'url': 'http://www.ustream.tv/recorded/20274954',\n        'md5': '088f151799e8f572f84eb62f17d73e5c',\n        'info_dict': {\n            'id': '20274954',\n            'ext': 'flv',\n            'title': 'Young Americans for Liberty February 7, 2012 2:28 AM',\n            'description': 'Young Americans for Liberty February 7, 2012 2:28 AM',\n            'timestamp': 1328577035,\n            'upload_date': '20120207',\n            'uploader': 'yaliberty',\n            'uploader_id': '6780869',\n        },\n    }, {\n        \n        \n        'url': 'http://www.ustream.tv/embed/recorded/59307601?ub=ff0000&lc=ff0000&oc=ffffff&uc=ffffff&v=3&wmode=direct',\n        'md5': '5a2abf40babeac9812ed20ae12d34e10',\n        'info_dict': {\n            'id': '59307601',\n            'ext': 'flv',\n            'title': '-CG11- Canada Games Figure Skating',\n            'uploader': 'sportscanadatv',\n        },\n        'skip': 'This Pro Broadcaster has chosen to remove this video from the ustream.tv site.',\n    }, {\n        'url': 'http://www.ustream.tv/embed/10299409',\n        'info_dict': {\n            'id': '10299409',\n        },\n        'playlist_count': 3,\n    }, {\n        'url': 'http://www.ustream.tv/recorded/91343263',\n        'info_dict': {\n            'id': '91343263',\n            'ext': 'mp4',\n            'title': 'GitHub Universe - General Session - Day 1',\n            'upload_date': '20160914',\n            'description': 'GitHub Universe - General Session - Day 1',\n            'timestamp': 1473872730,\n            'uploader': 'wa0dnskeqkr',\n            'uploader_id': '38977840',\n        },\n        'params': {\n            'skip_download': True,  \n        },\n    }]\n\n    @staticmethod\n    def _extract_url(webpage):\n        mobj = re.search(\n            r'<iframe[^>]+?src=([\"\\'])(?P<url>http://www\\.ustream\\.tv/embed/.+?)\\1', webpage)\n        if mobj is not None:\n            return mobj.group('url')\n\n    def _get_stream_info(self, url, video_id, app_id_ver, extra_note=None):\n        def num_to_hex(n):\n            return hex(n)[2:]\n\n        rnd = random.randrange\n\n        if not extra_note:\n            extra_note = ''\n\n        conn_info = self._download_json(\n            'http://r%d-1-%s-recorded-lp-live.ums.ustream.tv/1/ustream' % (rnd(1e8), video_id),\n            video_id, note='Downloading connection info' + extra_note,\n            query={\n                'type': 'viewer',\n                'appId': app_id_ver[0],\n                'appVersion': app_id_ver[1],\n                'rsid': '%s:%s' % (num_to_hex(rnd(1e8)), num_to_hex(rnd(1e8))),\n                'rpin': '_rpin.%d' % rnd(1e15),\n                'referrer': url,\n                'media': video_id,\n                'application': 'recorded',\n            })\n        host = conn_info[0]['args'][0]['host']\n        connection_id = conn_info[0]['args'][0]['connectionId']\n\n        return self._download_json(\n            'http://%s/1/ustream?connectionId=%s' % (host, connection_id),\n            video_id, note='Downloading stream info' + extra_note)\n\n    def _get_streams(self, url, video_id, app_id_ver):\n        \n        for trial_count in range(3):\n            stream_info = self._get_stream_info(\n                url, video_id, app_id_ver,\n                extra_note=' (try %d)' % (trial_count + 1) if trial_count > 0 else '')\n            if 'stream' in stream_info[0]['args'][0]:\n                return stream_info[0]['args'][0]['stream']\n        return []\n\n    def _parse_segmented_mp4(self, dash_stream_info):\n        def resolve_dash_template(template, idx, chunk_hash):\n            return template.replace('%', compat_str(idx), 1).replace('%', chunk_hash)\n\n        formats = []\n        for stream in dash_stream_info['streams']:\n            \n            provider = dash_stream_info['providers'][0]\n            fragments = [{\n                'url': resolve_dash_template(\n                    provider['url'] + stream['initUrl'], 0, dash_stream_info['hashes']['0'])\n            }]\n            for idx in range(dash_stream_info['videoLength'] // dash_stream_info['chunkTime']):\n                fragments.append({\n                    'url': resolve_dash_template(\n                        provider['url'] + stream['segmentUrl'], idx,\n                        dash_stream_info['hashes'][compat_str(idx // 10 * 10)])\n                })\n            content_type = stream['contentType']\n            kind = content_type.split('/')[0]\n            f = {\n                'format_id': '-'.join(filter(None, [\n                    'dash', kind, str_or_none(stream.get('bitrate'))])),\n                'protocol': 'http_dash_segments',\n                \n                'url': encode_data_uri(b'<MPD/>', 'text/xml'),\n                'ext': mimetype2ext(content_type),\n                'height': stream.get('height'),\n                'width': stream.get('width'),\n                'fragments': fragments,\n            }\n            if kind == 'video':\n                f.update({\n                    'vcodec': stream.get('codec'),\n                    'acodec': 'none',\n                    'vbr': stream.get('bitrate'),\n                })\n            else:\n                f.update({\n                    'vcodec': 'none',\n                    'acodec': stream.get('codec'),\n                    'abr': stream.get('bitrate'),\n                })\n            formats.append(f)\n        return formats\n\n    def _real_extract(self, url):\n        m = re.match(self._VALID_URL, url)\n        video_id = m.group('id')\n\n        \n        if m.group('type') == 'embed/recorded':\n            video_id = m.group('id')\n            desktop_url = 'http://www.ustream.tv/recorded/' + video_id\n            return self.url_result(desktop_url, 'Ustream')\n        if m.group('type') == 'embed':\n            video_id = m.group('id')\n            webpage = self._download_webpage(url, video_id)\n            content_video_ids = self._parse_json(self._search_regex(\n                r'ustream\\.vars\\.offAirContentVideoIds=([^;]+);', webpage,\n                'content video IDs'), video_id)\n            return self.playlist_result(\n                map(lambda u: self.url_result('http://www.ustream.tv/recorded/' + u, 'Ustream'), content_video_ids),\n                video_id)\n\n        params = self._download_json(\n            'https://api.ustream.tv/videos/%s.json' % video_id, video_id)\n\n        error = params.get('error')\n        if error:\n            raise ExtractorError(\n                '%s returned error: %s' % (self.IE_NAME, error), expected=True)\n\n        video = params['video']\n\n        title = video['title']\n        filesize = float_or_none(video.get('file_size'))\n\n        formats = [{\n            'id': video_id,\n            'url': video_url,\n            'ext': format_id,\n            'filesize': filesize,\n        } for format_id, video_url in video['media_urls'].items() if video_url]\n\n        if not formats:\n            hls_streams = self._get_streams(url, video_id, app_id_ver=(11, 2))\n            if hls_streams:\n                \n                formats.extend(self._extract_m3u8_formats(\n                    hls_streams[0]['url'], video_id, ext='mp4', m3u8_id='hls'))\n\n            \n\n        self._sort_formats(formats)\n\n        description = video.get('description')\n        timestamp = int_or_none(video.get('created_at'))\n        duration = float_or_none(video.get('length'))\n        view_count = int_or_none(video.get('views'))\n\n        uploader = video.get('owner', {}).get('username')\n        uploader_id = video.get('owner', {}).get('id')\n\n        thumbnails = [{\n            'id': thumbnail_id,\n            'url': thumbnail_url,\n        } for thumbnail_id, thumbnail_url in video.get('thumbnail', {}).items()]\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'thumbnails': thumbnails,\n            'timestamp': timestamp,\n            'duration': duration,\n            'view_count': view_count,\n            'uploader': uploader,\n            'uploader_id': uploader_id,\n            'formats': formats,\n        }\n\n\nclass UstreamChannelIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?ustream\\.tv/channel/(?P<slug>.+)'\n    IE_NAME = 'ustream:channel'\n    _TEST = {\n        'url': 'http://www.ustream.tv/channel/channeljapan',\n        'info_dict': {\n            'id': '10874166',\n        },\n        'playlist_mincount': 17,\n    }\n\n    def _real_extract(self, url):\n        m = re.match(self._VALID_URL, url)\n        display_id = m.group('slug')\n        webpage = self._download_webpage(url, display_id)\n        channel_id = self._html_search_meta('ustream:channel_id', webpage)\n\n        BASE = 'http://www.ustream.tv'\n        next_url = '/ajax/socialstream/videos/%s/1.json' % channel_id\n        video_ids = []\n        while next_url:\n            reply = self._download_json(\n                compat_urlparse.urljoin(BASE, next_url), display_id,\n                note='Downloading video information (next: %d)' % (len(video_ids) + 1))\n            video_ids.extend(re.findall(r'data-content-id=\"(\\d.*)\"', reply['data']))\n            next_url = reply['nextUrl']\n\n        entries = [\n            self.url_result('http://www.ustream.tv/recorded/' + vid, 'Ustream')\n            for vid in video_ids]\n        return {\n            '_type': 'playlist',\n            'id': channel_id,\n            'display_id': display_id,\n            'entries': entries,\n        }\n", "comments": "\n            # DASH streams handling is incomplete as 'url' is missing\n            dash_streams = self._get_streams(url, video_id, app_id_ver=(3, 1))\n            if dash_streams:\n                formats.extend(self._parse_segmented_mp4(dash_streams))\n            \n \n# From http://sportscanada.tv/canadagames/index.php/week2/figure-skating/444\n# Title and uploader available only from params JSON\n# m3u8 download\n# Sometimes the return dict does not have 'stream'\n# Use only one provider to avoid too many formats\n# TODO: generate a MPD doc for external players?\n# some sites use this embed format (see: https://github.com/rg3/youtube-dl/issues/2990)\n# m3u8_native leads to intermittent ContentTooShortError\n", "content": "from __future__ import unicode_literals\n\nimport random\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_str,\n    compat_urlparse,\n)\nfrom ..utils import (\n    encode_data_uri,\n    ExtractorError,\n    int_or_none,\n    float_or_none,\n    mimetype2ext,\n    str_or_none,\n)\n\n\nclass UstreamIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?ustream\\.tv/(?P<type>recorded|embed|embed/recorded)/(?P<id>\\d+)'\n    IE_NAME = 'ustream'\n    _TESTS = [{\n        'url': 'http://www.ustream.tv/recorded/20274954',\n        'md5': '088f151799e8f572f84eb62f17d73e5c',\n        'info_dict': {\n            'id': '20274954',\n            'ext': 'flv',\n            'title': 'Young Americans for Liberty February 7, 2012 2:28 AM',\n            'description': 'Young Americans for Liberty February 7, 2012 2:28 AM',\n            'timestamp': 1328577035,\n            'upload_date': '20120207',\n            'uploader': 'yaliberty',\n            'uploader_id': '6780869',\n        },\n    }, {\n        # From http://sportscanada.tv/canadagames/index.php/week2/figure-skating/444\n        # Title and uploader available only from params JSON\n        'url': 'http://www.ustream.tv/embed/recorded/59307601?ub=ff0000&lc=ff0000&oc=ffffff&uc=ffffff&v=3&wmode=direct',\n        'md5': '5a2abf40babeac9812ed20ae12d34e10',\n        'info_dict': {\n            'id': '59307601',\n            'ext': 'flv',\n            'title': '-CG11- Canada Games Figure Skating',\n            'uploader': 'sportscanadatv',\n        },\n        'skip': 'This Pro Broadcaster has chosen to remove this video from the ustream.tv site.',\n    }, {\n        'url': 'http://www.ustream.tv/embed/10299409',\n        'info_dict': {\n            'id': '10299409',\n        },\n        'playlist_count': 3,\n    }, {\n        'url': 'http://www.ustream.tv/recorded/91343263',\n        'info_dict': {\n            'id': '91343263',\n            'ext': 'mp4',\n            'title': 'GitHub Universe - General Session - Day 1',\n            'upload_date': '20160914',\n            'description': 'GitHub Universe - General Session - Day 1',\n            'timestamp': 1473872730,\n            'uploader': 'wa0dnskeqkr',\n            'uploader_id': '38977840',\n        },\n        'params': {\n            'skip_download': True,  # m3u8 download\n        },\n    }]\n\n    @staticmethod\n    def _extract_url(webpage):\n        mobj = re.search(\n            r'<iframe[^>]+?src=([\"\\'])(?P<url>http://www\\.ustream\\.tv/embed/.+?)\\1', webpage)\n        if mobj is not None:\n            return mobj.group('url')\n\n    def _get_stream_info(self, url, video_id, app_id_ver, extra_note=None):\n        def num_to_hex(n):\n            return hex(n)[2:]\n\n        rnd = random.randrange\n\n        if not extra_note:\n            extra_note = ''\n\n        conn_info = self._download_json(\n            'http://r%d-1-%s-recorded-lp-live.ums.ustream.tv/1/ustream' % (rnd(1e8), video_id),\n            video_id, note='Downloading connection info' + extra_note,\n            query={\n                'type': 'viewer',\n                'appId': app_id_ver[0],\n                'appVersion': app_id_ver[1],\n                'rsid': '%s:%s' % (num_to_hex(rnd(1e8)), num_to_hex(rnd(1e8))),\n                'rpin': '_rpin.%d' % rnd(1e15),\n                'referrer': url,\n                'media': video_id,\n                'application': 'recorded',\n            })\n        host = conn_info[0]['args'][0]['host']\n        connection_id = conn_info[0]['args'][0]['connectionId']\n\n        return self._download_json(\n            'http://%s/1/ustream?connectionId=%s' % (host, connection_id),\n            video_id, note='Downloading stream info' + extra_note)\n\n    def _get_streams(self, url, video_id, app_id_ver):\n        # Sometimes the return dict does not have 'stream'\n        for trial_count in range(3):\n            stream_info = self._get_stream_info(\n                url, video_id, app_id_ver,\n                extra_note=' (try %d)' % (trial_count + 1) if trial_count > 0 else '')\n            if 'stream' in stream_info[0]['args'][0]:\n                return stream_info[0]['args'][0]['stream']\n        return []\n\n    def _parse_segmented_mp4(self, dash_stream_info):\n        def resolve_dash_template(template, idx, chunk_hash):\n            return template.replace('%', compat_str(idx), 1).replace('%', chunk_hash)\n\n        formats = []\n        for stream in dash_stream_info['streams']:\n            # Use only one provider to avoid too many formats\n            provider = dash_stream_info['providers'][0]\n            fragments = [{\n                'url': resolve_dash_template(\n                    provider['url'] + stream['initUrl'], 0, dash_stream_info['hashes']['0'])\n            }]\n            for idx in range(dash_stream_info['videoLength'] // dash_stream_info['chunkTime']):\n                fragments.append({\n                    'url': resolve_dash_template(\n                        provider['url'] + stream['segmentUrl'], idx,\n                        dash_stream_info['hashes'][compat_str(idx // 10 * 10)])\n                })\n            content_type = stream['contentType']\n            kind = content_type.split('/')[0]\n            f = {\n                'format_id': '-'.join(filter(None, [\n                    'dash', kind, str_or_none(stream.get('bitrate'))])),\n                'protocol': 'http_dash_segments',\n                # TODO: generate a MPD doc for external players?\n                'url': encode_data_uri(b'<MPD/>', 'text/xml'),\n                'ext': mimetype2ext(content_type),\n                'height': stream.get('height'),\n                'width': stream.get('width'),\n                'fragments': fragments,\n            }\n            if kind == 'video':\n                f.update({\n                    'vcodec': stream.get('codec'),\n                    'acodec': 'none',\n                    'vbr': stream.get('bitrate'),\n                })\n            else:\n                f.update({\n                    'vcodec': 'none',\n                    'acodec': stream.get('codec'),\n                    'abr': stream.get('bitrate'),\n                })\n            formats.append(f)\n        return formats\n\n    def _real_extract(self, url):\n        m = re.match(self._VALID_URL, url)\n        video_id = m.group('id')\n\n        # some sites use this embed format (see: https://github.com/rg3/youtube-dl/issues/2990)\n        if m.group('type') == 'embed/recorded':\n            video_id = m.group('id')\n            desktop_url = 'http://www.ustream.tv/recorded/' + video_id\n            return self.url_result(desktop_url, 'Ustream')\n        if m.group('type') == 'embed':\n            video_id = m.group('id')\n            webpage = self._download_webpage(url, video_id)\n            content_video_ids = self._parse_json(self._search_regex(\n                r'ustream\\.vars\\.offAirContentVideoIds=([^;]+);', webpage,\n                'content video IDs'), video_id)\n            return self.playlist_result(\n                map(lambda u: self.url_result('http://www.ustream.tv/recorded/' + u, 'Ustream'), content_video_ids),\n                video_id)\n\n        params = self._download_json(\n            'https://api.ustream.tv/videos/%s.json' % video_id, video_id)\n\n        error = params.get('error')\n        if error:\n            raise ExtractorError(\n                '%s returned error: %s' % (self.IE_NAME, error), expected=True)\n\n        video = params['video']\n\n        title = video['title']\n        filesize = float_or_none(video.get('file_size'))\n\n        formats = [{\n            'id': video_id,\n            'url': video_url,\n            'ext': format_id,\n            'filesize': filesize,\n        } for format_id, video_url in video['media_urls'].items() if video_url]\n\n        if not formats:\n            hls_streams = self._get_streams(url, video_id, app_id_ver=(11, 2))\n            if hls_streams:\n                # m3u8_native leads to intermittent ContentTooShortError\n                formats.extend(self._extract_m3u8_formats(\n                    hls_streams[0]['url'], video_id, ext='mp4', m3u8_id='hls'))\n\n            '''\n            # DASH streams handling is incomplete as 'url' is missing\n            dash_streams = self._get_streams(url, video_id, app_id_ver=(3, 1))\n            if dash_streams:\n                formats.extend(self._parse_segmented_mp4(dash_streams))\n            '''\n\n        self._sort_formats(formats)\n\n        description = video.get('description')\n        timestamp = int_or_none(video.get('created_at'))\n        duration = float_or_none(video.get('length'))\n        view_count = int_or_none(video.get('views'))\n\n        uploader = video.get('owner', {}).get('username')\n        uploader_id = video.get('owner', {}).get('id')\n\n        thumbnails = [{\n            'id': thumbnail_id,\n            'url': thumbnail_url,\n        } for thumbnail_id, thumbnail_url in video.get('thumbnail', {}).items()]\n\n        return {\n            'id': video_id,\n            'title': title,\n            'description': description,\n            'thumbnails': thumbnails,\n            'timestamp': timestamp,\n            'duration': duration,\n            'view_count': view_count,\n            'uploader': uploader,\n            'uploader_id': uploader_id,\n            'formats': formats,\n        }\n\n\nclass UstreamChannelIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?ustream\\.tv/channel/(?P<slug>.+)'\n    IE_NAME = 'ustream:channel'\n    _TEST = {\n        'url': 'http://www.ustream.tv/channel/channeljapan',\n        'info_dict': {\n            'id': '10874166',\n        },\n        'playlist_mincount': 17,\n    }\n\n    def _real_extract(self, url):\n        m = re.match(self._VALID_URL, url)\n        display_id = m.group('slug')\n        webpage = self._download_webpage(url, display_id)\n        channel_id = self._html_search_meta('ustream:channel_id', webpage)\n\n        BASE = 'http://www.ustream.tv'\n        next_url = '/ajax/socialstream/videos/%s/1.json' % channel_id\n        video_ids = []\n        while next_url:\n            reply = self._download_json(\n                compat_urlparse.urljoin(BASE, next_url), display_id,\n                note='Downloading video information (next: %d)' % (len(video_ids) + 1))\n            video_ids.extend(re.findall(r'data-content-id=\"(\\d.*)\"', reply['data']))\n            next_url = reply['nextUrl']\n\n        entries = [\n            self.url_result('http://www.ustream.tv/recorded/' + vid, 'Ustream')\n            for vid in video_ids]\n        return {\n            '_type': 'playlist',\n            'id': channel_id,\n            'display_id': display_id,\n            'entries': entries,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "ustream.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/ustream.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}