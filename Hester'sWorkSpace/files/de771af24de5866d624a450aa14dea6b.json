{"author": "ansible", "code": "\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2016, Hugh Ma <Hugh.Ma@flextronics.com>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = '''\n---\nmodule: stacki_host\nshort_description: Add or remove host to stacki front-end\ndescription:\n - Use this module to add or remove hosts to a stacki front-end via API.\n - U(https://github.com/StackIQ/stacki)\nversion_added: \"2.3\"\noptions:\n  name:\n    description:\n     - Name of the host to be added to Stacki.\n    required: True\n  stacki_user:\n    description:\n     - Username for authenticating with Stacki API, but if not\n       specified, the environment variable C(stacki_user) is used instead.\n    required: True\n  stacki_password:\n    description:\n     - Password for authenticating with Stacki API, but if not\n       specified, the environment variable C(stacki_password) is used instead.\n    required: True\n  stacki_endpoint:\n    description:\n     - URL for the Stacki API Endpoint.\n    required: True\n  prim_intf_mac:\n    description:\n     - MAC Address for the primary PXE boot network interface.\n  prim_intf_ip:\n    description:\n     - IP Address for the primary network interface.\n  prim_intf:\n    description:\n     - Name of the primary network interface.\n  force_install:\n    description:\n     - Set value to True to force node into install state if it already exists in stacki.\nauthor:\n- Hugh Ma <Hugh.Ma@flextronics.com>\n'''\n\nEXAMPLES = '''\n- name: Add a host named test-1\n  stacki_host:\n    name: test-1\n    stacki_user: usr\n    stacki_password: pwd\n    stacki_endpoint: url\n    prim_intf_mac: mac_addr\n    prim_intf_ip: x.x.x.x\n    prim_intf: eth0\n\n- name: Remove a host named test-1\n  stacki_host:\n    name: test-1\n    stacki_user: usr\n    stacki_password: pwd\n    stacki_endpoint: url\n    state: absent\n'''\n\nRETURN = '''\nchanged:\n  description: response to whether or not the api call completed successfully\n  returned: always\n  type: boolean\n  sample: true\n\nstdout:\n  description: the set of responses from the commands\n  returned: always\n  type: list\n  sample: ['...', '...']\n\nstdout_lines:\n  description: the value of stdout split into a list\n  returned: always\n  type: list\n  sample: [['...', '...'], ['...'], ['...']]\n'''\n\nimport json\nimport os\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.six.moves.urllib.parse import urlencode\nfrom ansible.module_utils.urls import fetch_url\n\n\nclass StackiHost(object):\n\n    def __init__(self, module):\n        self.module = module\n        self.hostname = module.params['name']\n        self.rack = module.params['rack']\n        self.rank = module.params['rank']\n        self.appliance = module.params['appliance']\n        self.prim_intf = module.params['prim_intf']\n        self.prim_intf_ip = module.params['prim_intf_ip']\n        self.network = module.params['network']\n        self.prim_intf_mac = module.params['prim_intf_mac']\n        self.endpoint = module.params['stacki_endpoint']\n\n        auth_creds = {'USERNAME': module.params['stacki_user'],\n                      'PASSWORD': module.params['stacki_password']}\n\n        \n        cred_a = self.do_request(self.module, self.endpoint, method=\"GET\")\n        cookie_a = cred_a.headers.get('Set-Cookie').split(';')\n        init_csrftoken = None\n        for c in cookie_a:\n            if \"csrftoken\" in c:\n                init_csrftoken = c.replace(\"csrftoken=\", \"\")\n                init_csrftoken = init_csrftoken.rstrip(\"\\r\\n\")\n                break\n\n        \n        header = {'csrftoken': init_csrftoken, 'X-CSRFToken': init_csrftoken,\n                  'Content-type': 'application/x-www-form-urlencoded', 'Cookie': cred_a.headers.get('Set-Cookie')}\n\n        \n        login_endpoint = self.endpoint + \"/login\"\n\n        \n        login_req = self.do_request(self.module, login_endpoint, headers=header,\n                                    payload=urlencode(auth_creds), method='POST')\n\n        cookie_f = login_req.headers.get('Set-Cookie').split(';')\n        csrftoken = None\n        for f in cookie_f:\n            if \"csrftoken\" in f:\n                csrftoken = f.replace(\"csrftoken=\", \"\")\n            if \"sessionid\" in f:\n                sessionid = c.split(\"sessionid=\", 1)[-1]\n                sessionid = sessionid.rstrip(\"\\r\\n\")\n\n        self.header = {'csrftoken': csrftoken,\n                       'X-CSRFToken': csrftoken,\n                       'sessionid': sessionid,\n                       'Content-type': 'application/json',\n                       'Cookie': login_req.headers.get('Set-Cookie')}\n\n    def do_request(self, module, url, payload=None, headers=None, method=None):\n        res, info = fetch_url(module, url, data=payload, headers=headers, method=method)\n\n        if info['status'] != 200:\n            self.module.fail_json(changed=False, msg=info['msg'])\n\n        return res\n\n    def stack_check_host(self):\n        res = self.do_request(self.module, self.endpoint, payload=json.dumps({\"cmd\": \"list host\"}), headers=self.header, method=\"POST\")\n\n        if self.hostname in res.read():\n            return True\n        else:\n            return False\n\n    def stack_sync(self):\n        self.do_request(self.module, self.endpoint, payload=json.dumps({\"cmd\": \"sync config\"}), headers=self.header, method=\"POST\")\n        self.do_request(self.module, self.endpoint, payload=json.dumps({\"cmd\": \"sync host config\"}), headers=self.header, method=\"POST\")\n\n    def stack_force_install(self, result):\n        data = dict()\n        changed = False\n\n        data['cmd'] = \"set host boot {0} action=install\" \\\n            .format(self.hostname)\n        self.do_request(self.module, self.endpoint, payload=json.dumps(data), headers=self.header, method=\"POST\")\n        changed = True\n\n        self.stack_sync()\n\n        result['changed'] = changed\n        result['stdout'] = \"api call successful\".rstrip(\"\\r\\n\")\n\n    def stack_add(self, result):\n        data = dict()\n        changed = False\n\n        data['cmd'] = \"add host {0} rack={1} rank={2} appliance={3}\"\\\n            .format(self.hostname, self.rack, self.rank, self.appliance)\n        self.do_request(self.module, self.endpoint, payload=json.dumps(data), headers=self.header, method=\"POST\")\n\n        self.stack_sync()\n\n        result['changed'] = changed\n        result['stdout'] = \"api call successful\".rstrip(\"\\r\\n\")\n\n    def stack_remove(self, result):\n        data = dict()\n\n        data['cmd'] = \"remove host {0}\"\\\n            .format(self.hostname)\n        self.do_request(self.module, self.endpoint, payload=json.dumps(data), headers=self.header, method=\"POST\")\n\n        self.stack_sync()\n\n        result['changed'] = True\n        result['stdout'] = \"api call successful\".rstrip(\"\\r\\n\")\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            name=dict(type='str', required=True),\n            rack=dict(type='int', default=0),\n            rank=dict(type='int', default=0),\n            appliance=dict(type='str', default='backend'),\n            prim_intf=dict(type='str'),\n            prim_intf_ip=dict(type='str'),\n            network=dict(type='str', default='private'),\n            prim_intf_mac=dict(type='str'),\n            stacki_user=dict(type='str', required=True, default=os.environ.get('stacki_user')),\n            stacki_password=dict(type='str', required=True, default=os.environ.get('stacki_password'), no_log=True),\n            stacki_endpoint=dict(type='str', required=True, default=os.environ.get('stacki_endpoint')),\n            force_install=dict(type='bool', default=False),\n        ),\n        supports_check_mode=False,\n    )\n\n    result = {'changed': False}\n    missing_params = list()\n\n    stacki = StackiHost(module)\n    host_exists = stacki.stack_check_host()\n\n    \n    if module.params['state'] == 'present' and host_exists and module.params['force_install']:\n        stacki.stack_force_install(result)\n    \n    elif module.params['state'] == 'present' and host_exists and not module.params['force_install']:\n        result['stdout'] = \"{0} already exists. Set 'force_install' to true to bootstrap\"\\\n            .format(module.params['name'])\n    \n    elif module.params['state'] == 'present' and not host_exists:\n        for param in ['appliance', 'prim_intf',\n                      'prim_intf_ip', 'network', 'prim_intf_mac']:\n            if not module.params[param]:\n                missing_params.append(param)\n        if len(missing_params) > 0:\n            module.fail_json(msg=\"missing required arguments: {0}\".format(missing_params))\n\n        stacki.stack_add(result)\n    \n    elif module.params['state'] == 'absent' and host_exists:\n        stacki.stack_remove(result)\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  stacki host short description  add remove host stacki front end description     use module add remove hosts stacki front end via api     u(https   github com stackiq stacki) version added   2 3  options    name      description         name host added stacki      required  true   stacki user      description         username authenticating stacki api         specified  environment variable c(stacki user) used instead      required  true   stacki password      description         password authenticating stacki api         specified  environment variable c(stacki password) used instead      required  true   stacki endpoint      description         url stacki api endpoint      required  true   prim intf mac      description         mac address primary pxe boot network interface    prim intf ip      description         ip address primary network interface    prim intf      description         name primary network interface    force install      description         set value true force node install state already exists stacki  author    hugh ma  hugh ma flextronics com       examples         name  add host named test 1   stacki host      name  test 1     stacki user  usr     stacki password  pwd     stacki endpoint  url     prim intf mac  mac addr     prim intf ip  x x x x     prim intf  eth0    name  remove host named test 1   stacki host      name  test 1     stacki user  usr     stacki password  pwd     stacki endpoint  url     state  absent      return       changed    description  response whether api call completed successfully   returned  always   type  boolean   sample  true  stdout    description  set responses commands   returned  always   type  list   sample                  stdout lines    description  value stdout split list   returned  always   type  list   sample                                             usr bin python        coding  utf 8        copyright  (c) 2016  hugh ma  hugh ma flextronics com     gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    get initial csrf    make header dictionary initial csrf    endpoint get final authentication header    get final csrf session id    if state present  host exists  need force install flag put host back install state    if state present  host exists  force install false  nothing    otherwise  state present  host exists  require params add host    if state absent  host exists  lets remove  ", "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# Copyright: (c) 2016, Hugh Ma <Hugh.Ma@flextronics.com>\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = '''\n---\nmodule: stacki_host\nshort_description: Add or remove host to stacki front-end\ndescription:\n - Use this module to add or remove hosts to a stacki front-end via API.\n - U(https://github.com/StackIQ/stacki)\nversion_added: \"2.3\"\noptions:\n  name:\n    description:\n     - Name of the host to be added to Stacki.\n    required: True\n  stacki_user:\n    description:\n     - Username for authenticating with Stacki API, but if not\n       specified, the environment variable C(stacki_user) is used instead.\n    required: True\n  stacki_password:\n    description:\n     - Password for authenticating with Stacki API, but if not\n       specified, the environment variable C(stacki_password) is used instead.\n    required: True\n  stacki_endpoint:\n    description:\n     - URL for the Stacki API Endpoint.\n    required: True\n  prim_intf_mac:\n    description:\n     - MAC Address for the primary PXE boot network interface.\n  prim_intf_ip:\n    description:\n     - IP Address for the primary network interface.\n  prim_intf:\n    description:\n     - Name of the primary network interface.\n  force_install:\n    description:\n     - Set value to True to force node into install state if it already exists in stacki.\nauthor:\n- Hugh Ma <Hugh.Ma@flextronics.com>\n'''\n\nEXAMPLES = '''\n- name: Add a host named test-1\n  stacki_host:\n    name: test-1\n    stacki_user: usr\n    stacki_password: pwd\n    stacki_endpoint: url\n    prim_intf_mac: mac_addr\n    prim_intf_ip: x.x.x.x\n    prim_intf: eth0\n\n- name: Remove a host named test-1\n  stacki_host:\n    name: test-1\n    stacki_user: usr\n    stacki_password: pwd\n    stacki_endpoint: url\n    state: absent\n'''\n\nRETURN = '''\nchanged:\n  description: response to whether or not the api call completed successfully\n  returned: always\n  type: boolean\n  sample: true\n\nstdout:\n  description: the set of responses from the commands\n  returned: always\n  type: list\n  sample: ['...', '...']\n\nstdout_lines:\n  description: the value of stdout split into a list\n  returned: always\n  type: list\n  sample: [['...', '...'], ['...'], ['...']]\n'''\n\nimport json\nimport os\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.six.moves.urllib.parse import urlencode\nfrom ansible.module_utils.urls import fetch_url\n\n\nclass StackiHost(object):\n\n    def __init__(self, module):\n        self.module = module\n        self.hostname = module.params['name']\n        self.rack = module.params['rack']\n        self.rank = module.params['rank']\n        self.appliance = module.params['appliance']\n        self.prim_intf = module.params['prim_intf']\n        self.prim_intf_ip = module.params['prim_intf_ip']\n        self.network = module.params['network']\n        self.prim_intf_mac = module.params['prim_intf_mac']\n        self.endpoint = module.params['stacki_endpoint']\n\n        auth_creds = {'USERNAME': module.params['stacki_user'],\n                      'PASSWORD': module.params['stacki_password']}\n\n        # Get Initial CSRF\n        cred_a = self.do_request(self.module, self.endpoint, method=\"GET\")\n        cookie_a = cred_a.headers.get('Set-Cookie').split(';')\n        init_csrftoken = None\n        for c in cookie_a:\n            if \"csrftoken\" in c:\n                init_csrftoken = c.replace(\"csrftoken=\", \"\")\n                init_csrftoken = init_csrftoken.rstrip(\"\\r\\n\")\n                break\n\n        # Make Header Dictionary with initial CSRF\n        header = {'csrftoken': init_csrftoken, 'X-CSRFToken': init_csrftoken,\n                  'Content-type': 'application/x-www-form-urlencoded', 'Cookie': cred_a.headers.get('Set-Cookie')}\n\n        # Endpoint to get final authentication header\n        login_endpoint = self.endpoint + \"/login\"\n\n        # Get Final CSRF and Session ID\n        login_req = self.do_request(self.module, login_endpoint, headers=header,\n                                    payload=urlencode(auth_creds), method='POST')\n\n        cookie_f = login_req.headers.get('Set-Cookie').split(';')\n        csrftoken = None\n        for f in cookie_f:\n            if \"csrftoken\" in f:\n                csrftoken = f.replace(\"csrftoken=\", \"\")\n            if \"sessionid\" in f:\n                sessionid = c.split(\"sessionid=\", 1)[-1]\n                sessionid = sessionid.rstrip(\"\\r\\n\")\n\n        self.header = {'csrftoken': csrftoken,\n                       'X-CSRFToken': csrftoken,\n                       'sessionid': sessionid,\n                       'Content-type': 'application/json',\n                       'Cookie': login_req.headers.get('Set-Cookie')}\n\n    def do_request(self, module, url, payload=None, headers=None, method=None):\n        res, info = fetch_url(module, url, data=payload, headers=headers, method=method)\n\n        if info['status'] != 200:\n            self.module.fail_json(changed=False, msg=info['msg'])\n\n        return res\n\n    def stack_check_host(self):\n        res = self.do_request(self.module, self.endpoint, payload=json.dumps({\"cmd\": \"list host\"}), headers=self.header, method=\"POST\")\n\n        if self.hostname in res.read():\n            return True\n        else:\n            return False\n\n    def stack_sync(self):\n        self.do_request(self.module, self.endpoint, payload=json.dumps({\"cmd\": \"sync config\"}), headers=self.header, method=\"POST\")\n        self.do_request(self.module, self.endpoint, payload=json.dumps({\"cmd\": \"sync host config\"}), headers=self.header, method=\"POST\")\n\n    def stack_force_install(self, result):\n        data = dict()\n        changed = False\n\n        data['cmd'] = \"set host boot {0} action=install\" \\\n            .format(self.hostname)\n        self.do_request(self.module, self.endpoint, payload=json.dumps(data), headers=self.header, method=\"POST\")\n        changed = True\n\n        self.stack_sync()\n\n        result['changed'] = changed\n        result['stdout'] = \"api call successful\".rstrip(\"\\r\\n\")\n\n    def stack_add(self, result):\n        data = dict()\n        changed = False\n\n        data['cmd'] = \"add host {0} rack={1} rank={2} appliance={3}\"\\\n            .format(self.hostname, self.rack, self.rank, self.appliance)\n        self.do_request(self.module, self.endpoint, payload=json.dumps(data), headers=self.header, method=\"POST\")\n\n        self.stack_sync()\n\n        result['changed'] = changed\n        result['stdout'] = \"api call successful\".rstrip(\"\\r\\n\")\n\n    def stack_remove(self, result):\n        data = dict()\n\n        data['cmd'] = \"remove host {0}\"\\\n            .format(self.hostname)\n        self.do_request(self.module, self.endpoint, payload=json.dumps(data), headers=self.header, method=\"POST\")\n\n        self.stack_sync()\n\n        result['changed'] = True\n        result['stdout'] = \"api call successful\".rstrip(\"\\r\\n\")\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            state=dict(type='str', default='present', choices=['absent', 'present']),\n            name=dict(type='str', required=True),\n            rack=dict(type='int', default=0),\n            rank=dict(type='int', default=0),\n            appliance=dict(type='str', default='backend'),\n            prim_intf=dict(type='str'),\n            prim_intf_ip=dict(type='str'),\n            network=dict(type='str', default='private'),\n            prim_intf_mac=dict(type='str'),\n            stacki_user=dict(type='str', required=True, default=os.environ.get('stacki_user')),\n            stacki_password=dict(type='str', required=True, default=os.environ.get('stacki_password'), no_log=True),\n            stacki_endpoint=dict(type='str', required=True, default=os.environ.get('stacki_endpoint')),\n            force_install=dict(type='bool', default=False),\n        ),\n        supports_check_mode=False,\n    )\n\n    result = {'changed': False}\n    missing_params = list()\n\n    stacki = StackiHost(module)\n    host_exists = stacki.stack_check_host()\n\n    # If state is present, but host exists, need force_install flag to put host back into install state\n    if module.params['state'] == 'present' and host_exists and module.params['force_install']:\n        stacki.stack_force_install(result)\n    # If state is present, but host exists, and force_install and false, do nothing\n    elif module.params['state'] == 'present' and host_exists and not module.params['force_install']:\n        result['stdout'] = \"{0} already exists. Set 'force_install' to true to bootstrap\"\\\n            .format(module.params['name'])\n    # Otherwise, state is present, but host doesn't exists, require more params to add host\n    elif module.params['state'] == 'present' and not host_exists:\n        for param in ['appliance', 'prim_intf',\n                      'prim_intf_ip', 'network', 'prim_intf_mac']:\n            if not module.params[param]:\n                missing_params.append(param)\n        if len(missing_params) > 0:\n            module.fail_json(msg=\"missing required arguments: {0}\".format(missing_params))\n\n        stacki.stack_add(result)\n    # If state is absent, and host exists, lets remove it.\n    elif module.params['state'] == 'absent' and host_exists:\n        stacki.stack_remove(result)\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "stacki_host.py", "id": "de771af24de5866d624a450aa14dea6b", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/remote_management/stacki/stacki_host.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}