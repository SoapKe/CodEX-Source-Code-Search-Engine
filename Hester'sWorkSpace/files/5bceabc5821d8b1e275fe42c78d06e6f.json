{"author": "mitmproxy", "code": "import io\nimport typing\nfrom unittest import mock\nimport pytest\n\nfrom mitmproxy.utils import typecheck\n\n\nclass TBase:\n    def __init__(self, bar: int):\n        pass\n\n\nclass T(TBase):\n    def __init__(self, foo: str):\n        super(T, self).__init__(42)\n\n\ndef test_check_option_type():\n    typecheck.check_option_type(\"foo\", 42, int)\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", 42, str)\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", None, str)\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", b\"foo\", str)\n\n\ndef test_check_union():\n    typecheck.check_option_type(\"foo\", 42, typing.Union[int, str])\n    typecheck.check_option_type(\"foo\", \"42\", typing.Union[int, str])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", [], typing.Union[int, str])\n\n    \n    m = mock.Mock()\n    m.__str__ = lambda self: \"typing.Union\"\n    m.__union_params__ = (int,)\n    typecheck.check_option_type(\"foo\", 42, m)\n\n\ndef test_check_tuple():\n    typecheck.check_option_type(\"foo\", (42, \"42\"), typing.Tuple[int, str])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", None, typing.Tuple[int, str])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", (), typing.Tuple[int, str])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", (42, 42), typing.Tuple[int, str])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", (\"42\", 42), typing.Tuple[int, str])\n\n    \n    m = mock.Mock()\n    m.__str__ = lambda self: \"typing.Tuple\"\n    m.__tuple_params__ = (int, str)\n    typecheck.check_option_type(\"foo\", (42, \"42\"), m)\n\n\ndef test_check_sequence():\n    typecheck.check_option_type(\"foo\", [10], typing.Sequence[int])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", [\"foo\"], typing.Sequence[int])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", [10, \"foo\"], typing.Sequence[int])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", [b\"foo\"], typing.Sequence[str])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", \"foo\", typing.Sequence[str])\n\n    \n    m = mock.Mock()\n    m.__str__ = lambda self: \"typing.Sequence\"\n    m.__parameters__ = (int,)\n    typecheck.check_option_type(\"foo\", [10], m)\n\n\ndef test_check_io():\n    typecheck.check_option_type(\"foo\", io.StringIO(), typing.IO[str])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", \"foo\", typing.IO[str])\n\n\ndef test_check_any():\n    typecheck.check_option_type(\"foo\", 42, typing.Any)\n    typecheck.check_option_type(\"foo\", object(), typing.Any)\n    typecheck.check_option_type(\"foo\", None, typing.Any)\n\n\ndef test_typesec_to_str():\n    assert(typecheck.typespec_to_str(str)) == \"str\"\n    assert(typecheck.typespec_to_str(typing.Sequence[str])) == \"sequence of str\"\n    assert(typecheck.typespec_to_str(typing.Optional[str])) == \"optional str\"\n    with pytest.raises(NotImplementedError):\n        typecheck.typespec_to_str(dict)\n\n\ndef test_mapping_types():\n    \n    assert (str, int) == typecheck.mapping_types(typing.Mapping[str, int])\n", "comments": "  python 3 5 defines   union params      python 3 5 defines   tuple params      python 3 5 defines   parameters      covered check option type  still belongs module ", "content": "import io\nimport typing\nfrom unittest import mock\nimport pytest\n\nfrom mitmproxy.utils import typecheck\n\n\nclass TBase:\n    def __init__(self, bar: int):\n        pass\n\n\nclass T(TBase):\n    def __init__(self, foo: str):\n        super(T, self).__init__(42)\n\n\ndef test_check_option_type():\n    typecheck.check_option_type(\"foo\", 42, int)\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", 42, str)\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", None, str)\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", b\"foo\", str)\n\n\ndef test_check_union():\n    typecheck.check_option_type(\"foo\", 42, typing.Union[int, str])\n    typecheck.check_option_type(\"foo\", \"42\", typing.Union[int, str])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", [], typing.Union[int, str])\n\n    # Python 3.5 only defines __union_params__\n    m = mock.Mock()\n    m.__str__ = lambda self: \"typing.Union\"\n    m.__union_params__ = (int,)\n    typecheck.check_option_type(\"foo\", 42, m)\n\n\ndef test_check_tuple():\n    typecheck.check_option_type(\"foo\", (42, \"42\"), typing.Tuple[int, str])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", None, typing.Tuple[int, str])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", (), typing.Tuple[int, str])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", (42, 42), typing.Tuple[int, str])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", (\"42\", 42), typing.Tuple[int, str])\n\n    # Python 3.5 only defines __tuple_params__\n    m = mock.Mock()\n    m.__str__ = lambda self: \"typing.Tuple\"\n    m.__tuple_params__ = (int, str)\n    typecheck.check_option_type(\"foo\", (42, \"42\"), m)\n\n\ndef test_check_sequence():\n    typecheck.check_option_type(\"foo\", [10], typing.Sequence[int])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", [\"foo\"], typing.Sequence[int])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", [10, \"foo\"], typing.Sequence[int])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", [b\"foo\"], typing.Sequence[str])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", \"foo\", typing.Sequence[str])\n\n    # Python 3.5 only defines __parameters__\n    m = mock.Mock()\n    m.__str__ = lambda self: \"typing.Sequence\"\n    m.__parameters__ = (int,)\n    typecheck.check_option_type(\"foo\", [10], m)\n\n\ndef test_check_io():\n    typecheck.check_option_type(\"foo\", io.StringIO(), typing.IO[str])\n    with pytest.raises(TypeError):\n        typecheck.check_option_type(\"foo\", \"foo\", typing.IO[str])\n\n\ndef test_check_any():\n    typecheck.check_option_type(\"foo\", 42, typing.Any)\n    typecheck.check_option_type(\"foo\", object(), typing.Any)\n    typecheck.check_option_type(\"foo\", None, typing.Any)\n\n\ndef test_typesec_to_str():\n    assert(typecheck.typespec_to_str(str)) == \"str\"\n    assert(typecheck.typespec_to_str(typing.Sequence[str])) == \"sequence of str\"\n    assert(typecheck.typespec_to_str(typing.Optional[str])) == \"optional str\"\n    with pytest.raises(NotImplementedError):\n        typecheck.typespec_to_str(dict)\n\n\ndef test_mapping_types():\n    # this is not covered by check_option_type, but still belongs in this module\n    assert (str, int) == typecheck.mapping_types(typing.Mapping[str, int])\n", "description": "An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers.", "file_name": "test_typecheck.py", "id": "5bceabc5821d8b1e275fe42c78d06e6f", "language": "Python", "project_name": "mitmproxy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/mitmproxy-mitmproxy/mitmproxy-mitmproxy-0bc3f1f/test/mitmproxy/utils/test_typecheck.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:23:46Z", "url": "https://github.com/mitmproxy/mitmproxy", "wiki": false}