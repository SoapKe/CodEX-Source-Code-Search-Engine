{"author": "sympy", "code": "# -*- coding: utf-8 -*-\nfrom __future__ import (absolute_import, division, print_function)\n\nimport math\nfrom sympy import symbols, exp, S, Poly\nfrom sympy.codegen.rewriting import optimize\nfrom sympy.codegen.approximations import SumApprox, SeriesApprox\n\n\ndef test_SumApprox_trivial():\n    x = symbols('x')\n    expr1 = 1 + x\n    sum_approx = SumApprox(bounds={x: (-1e-20, 1e-20)}, reltol=1e-16)\n    apx1 = optimize(expr1, [sum_approx])\n    assert apx1 - 1 == 0\n\n\ndef test_SumApprox_monotone_terms():\n    x, y, z = symbols('x y z')\n    expr1 = exp(z)*(x**2 + y**2 + 1)\n    bnds1 = {x: (0, 1e-3), y: (100, 1000)}\n    sum_approx_m2 = SumApprox(bounds=bnds1, reltol=1e-2)\n    sum_approx_m5 = SumApprox(bounds=bnds1, reltol=1e-5)\n    sum_approx_m11 = SumApprox(bounds=bnds1, reltol=1e-11)\n    assert (optimize(expr1, [sum_approx_m2])/exp(z) - (y**2)).simplify() == 0\n    assert (optimize(expr1, [sum_approx_m5])/exp(z) - (y**2 + 1)).simplify() == 0\n    assert (optimize(expr1, [sum_approx_m11])/exp(z) - (y**2 + 1 + x**2)).simplify() == 0\n\n\ndef test_SeriesApprox_trivial():\n    x, z = symbols('x z')\n    for factor in [1, exp(z)]:\n        x = symbols('x')\n        expr1 = exp(x)*factor\n        bnds1 = {x: (-1, 1)}\n        series_approx_50 = SeriesApprox(bounds=bnds1, reltol=0.50)\n        series_approx_10 = SeriesApprox(bounds=bnds1, reltol=0.10)\n        series_approx_05 = SeriesApprox(bounds=bnds1, reltol=0.05)\n        c = (bnds1[x][1] + bnds1[x][0])/2  \n        f0 = math.exp(c)  \n\n        ref_50 = f0 + x + x**2/2\n        ref_10 = f0 + x + x**2/2 + x**3/6\n        ref_05 = f0 + x + x**2/2 + x**3/6 + x**4/24\n\n        res_50 = optimize(expr1, [series_approx_50])\n        res_10 = optimize(expr1, [series_approx_10])\n        res_05 = optimize(expr1, [series_approx_05])\n\n        assert (res_50/factor - ref_50).simplify() == 0\n        assert (res_10/factor - ref_10).simplify() == 0\n        assert (res_05/factor - ref_05).simplify() == 0\n\n        max_ord3 = SeriesApprox(bounds=bnds1, reltol=0.05, max_order=3)\n        assert optimize(expr1, [max_ord3]) == expr1\n", "comments": "      coding  utf 8        0 0    1 0 ", "content": "# -*- coding: utf-8 -*-\nfrom __future__ import (absolute_import, division, print_function)\n\nimport math\nfrom sympy import symbols, exp, S, Poly\nfrom sympy.codegen.rewriting import optimize\nfrom sympy.codegen.approximations import SumApprox, SeriesApprox\n\n\ndef test_SumApprox_trivial():\n    x = symbols('x')\n    expr1 = 1 + x\n    sum_approx = SumApprox(bounds={x: (-1e-20, 1e-20)}, reltol=1e-16)\n    apx1 = optimize(expr1, [sum_approx])\n    assert apx1 - 1 == 0\n\n\ndef test_SumApprox_monotone_terms():\n    x, y, z = symbols('x y z')\n    expr1 = exp(z)*(x**2 + y**2 + 1)\n    bnds1 = {x: (0, 1e-3), y: (100, 1000)}\n    sum_approx_m2 = SumApprox(bounds=bnds1, reltol=1e-2)\n    sum_approx_m5 = SumApprox(bounds=bnds1, reltol=1e-5)\n    sum_approx_m11 = SumApprox(bounds=bnds1, reltol=1e-11)\n    assert (optimize(expr1, [sum_approx_m2])/exp(z) - (y**2)).simplify() == 0\n    assert (optimize(expr1, [sum_approx_m5])/exp(z) - (y**2 + 1)).simplify() == 0\n    assert (optimize(expr1, [sum_approx_m11])/exp(z) - (y**2 + 1 + x**2)).simplify() == 0\n\n\ndef test_SeriesApprox_trivial():\n    x, z = symbols('x z')\n    for factor in [1, exp(z)]:\n        x = symbols('x')\n        expr1 = exp(x)*factor\n        bnds1 = {x: (-1, 1)}\n        series_approx_50 = SeriesApprox(bounds=bnds1, reltol=0.50)\n        series_approx_10 = SeriesApprox(bounds=bnds1, reltol=0.10)\n        series_approx_05 = SeriesApprox(bounds=bnds1, reltol=0.05)\n        c = (bnds1[x][1] + bnds1[x][0])/2  # 0.0\n        f0 = math.exp(c)  # 1.0\n\n        ref_50 = f0 + x + x**2/2\n        ref_10 = f0 + x + x**2/2 + x**3/6\n        ref_05 = f0 + x + x**2/2 + x**3/6 + x**4/24\n\n        res_50 = optimize(expr1, [series_approx_50])\n        res_10 = optimize(expr1, [series_approx_10])\n        res_05 = optimize(expr1, [series_approx_05])\n\n        assert (res_50/factor - ref_50).simplify() == 0\n        assert (res_10/factor - ref_10).simplify() == 0\n        assert (res_05/factor - ref_05).simplify() == 0\n\n        max_ord3 = SeriesApprox(bounds=bnds1, reltol=0.05, max_order=3)\n        assert optimize(expr1, [max_ord3]) == expr1\n", "description": "A computer algebra system written in pure Python", "file_name": "test_approximations.py", "id": "d4a51a02d7eff4b450345e6a8a1e797d", "language": "Python", "project_name": "sympy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/sympy-sympy/sympy-sympy-205da79/sympy/codegen/tests/test_approximations.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:35:56Z", "url": "https://github.com/sympy/sympy", "wiki": true}