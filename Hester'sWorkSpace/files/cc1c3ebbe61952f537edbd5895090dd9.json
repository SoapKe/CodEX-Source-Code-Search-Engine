{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\nimport itertools\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    clean_html,\n    dict_get,\n    ExtractorError,\n    float_or_none,\n    get_element_by_class,\n    int_or_none,\n    parse_duration,\n    parse_iso8601,\n    try_get,\n    unescapeHTML,\n    urlencode_postdata,\n    urljoin,\n)\nfrom ..compat import (\n    compat_etree_fromstring,\n    compat_HTTPError,\n    compat_urlparse,\n)\n\n\nclass BBCCoUkIE(InfoExtractor):\n    IE_NAME = 'bbc.co.uk'\n    IE_DESC = 'BBC iPlayer'\n    _ID_REGEX = r'[pbw][\\da-z]{7}'\n    _VALID_URL = r,\n        },\n        'params': {\n            'skip_download': True,\n        }\n    }, {\n        \n        'url': 'http://www.bbc.com/travel/story/20150625-sri-lankas-spicy-secret',\n        'info_dict': {\n            'id': 'p02q6gc4',\n            'ext': 'flv',\n            'title': 'Sri Lanka\u2019s spicy secret',\n            'description': 'As a new train line to Jaffna opens up the country\u2019s north, travellers can experience a truly distinct slice of Tamil culture.',\n            'timestamp': 1437674293,\n            'upload_date': '20150723',\n        },\n        'params': {\n            \n            'skip_download': True,\n        }\n    }, {\n        \n        'url': 'http://www.bbc.com/autos/story/20130513-hyundais-rock-star',\n        'info_dict': {\n            'id': 'p018zqqg',\n            'ext': 'mp4',\n            'title': 'Hyundai Santa Fe Sport: Rock star',\n            'description': 'md5:b042a26142c4154a6e472933cf20793d',\n            'timestamp': 1415867444,\n            'upload_date': '20141113',\n        },\n        'params': {\n            \n            'skip_download': True,\n        }\n    }, {\n        \n        'url': 'http://www.bbc.co.uk/sport/live/olympics/36895975',\n        'info_dict': {\n            'id': 'p041vhd0',\n            'ext': 'mp4',\n            'title': \"Nigeria v Japan - Men's First Round\",\n            'description': 'Live coverage of the first round from Group B at the Amazonia Arena.',\n            'duration': 7980,\n            'uploader': 'BBC Sport',\n            'uploader_id': 'bbc_sport',\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n        'skip': 'Georestricted to UK',\n    }, {\n        \n        'url': 'http://www.bbc.com/sport/0/football/33653409',\n        'info_dict': {\n            'id': 'p02xycnp',\n            'ext': 'mp4',\n            'title': 'Transfers: Cristiano Ronaldo to Man Utd, Arsenal to spend?',\n            'description': 'BBC Sport\\'s David Ornstein has the latest transfer gossip, including rumours of a Manchester United return for Cristiano Ronaldo.',\n            'duration': 140,\n        },\n        'params': {\n            \n            'skip_download': True,\n        }\n    }, {\n        \n        'url': 'http://www.bbc.com/sport/0/football/34475836',\n        'info_dict': {\n            'id': '34475836',\n            'title': 'Jurgen Klopp: Furious football from a witty and winning coach',\n            'description': 'Fast-paced football, wit, wisdom and a ready smile - why Liverpool fans should come to love new boss Jurgen Klopp.',\n        },\n        'playlist_count': 3,\n    }, {\n        \n        'url': 'http://www.bbc.co.uk/schoolreport/35744779',\n        'info_dict': {\n            'id': '35744779',\n            'title': 'School which breaks down barriers in Jerusalem',\n        },\n        'playlist_count': 1,\n    }, {\n        \n        'url': 'http://www.bbc.com/weather/features/33601775',\n        'only_matching': True,\n    }, {\n        \n        'url': 'http://www.bbc.co.uk/news/science-environment-33661876',\n        'only_matching': True,\n    }, {\n        \n        'url': 'http://www.bbc.co.uk/sport/rowing/35908187',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        EXCLUDE_IE = (BBCCoUkIE, BBCCoUkArticleIE, BBCCoUkIPlayerPlaylistIE, BBCCoUkPlaylistIE)\n        return (False if any(ie.suitable(url) for ie in EXCLUDE_IE)\n                else super(BBCIE, cls).suitable(url))\n\n    def _extract_from_media_meta(self, media_meta, video_id):\n        \n        \n        \n        source_files = media_meta.get('sourceFiles')\n        if source_files:\n            return [{\n                'url': f['url'],\n                'format_id': format_id,\n                'ext': f.get('encoding'),\n                'tbr': float_or_none(f.get('bitrate'), 1000),\n                'filesize': int_or_none(f.get('filesize')),\n            } for format_id, f in source_files.items() if f.get('url')], []\n\n        programme_id = media_meta.get('externalId')\n        if programme_id:\n            return self._download_media_selector(programme_id)\n\n        \n        href = media_meta.get('href')\n        if href:\n            playlist = self._download_legacy_playlist_url(href)\n            _, _, _, _, formats, subtitles = self._extract_from_legacy_playlist(playlist, video_id)\n            return formats, subtitles\n\n        return [], []\n\n    def _extract_from_playlist_sxml(self, url, playlist_id, timestamp):\n        programme_id, title, description, duration, formats, subtitles = \\\n            self._process_legacy_playlist_url(url, playlist_id)\n        self._sort_formats(formats)\n        return {\n            'id': programme_id,\n            'title': title,\n            'description': description,\n            'duration': duration,\n            'timestamp': timestamp,\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n\n    def _real_extract(self, url):\n        playlist_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, playlist_id)\n\n        json_ld_info = self._search_json_ld(webpage, playlist_id, default={})\n        timestamp = json_ld_info.get('timestamp')\n\n        playlist_title = json_ld_info.get('title')\n        if not playlist_title:\n            playlist_title = self._og_search_title(\n                webpage, default=None) or self._html_search_regex(\n                r'<title>(.+?)</title>', webpage, 'playlist title', default=None)\n            if playlist_title:\n                playlist_title = re.sub(r'(.+)\\s*-\\s*BBC.*?$', r'\\1', playlist_title).strip()\n\n        playlist_description = json_ld_info.get(\n            'description') or self._og_search_description(webpage, default=None)\n\n        if not timestamp:\n            timestamp = parse_iso8601(self._search_regex(\n                [r'<meta[^>]+property=\"article:published_time\"[^>]+content=\"([^\"]+)\"',\n                 r'itemprop=\"datePublished\"[^>]+datetime=\"([^\"]+)\"',\n                 r'\"datePublished\":\\s*\"([^\"]+)'],\n                webpage, 'date', default=None))\n\n        entries = []\n\n        \n        \n        playlists = re.findall(r'<param[^>]+name=\"playlist\"[^>]+value=\"([^\"]+)\"', webpage)\n        playlists.extend(re.findall(r'data-media-id=\"([^\"]+/playlist\\.sxml)\"', webpage))\n        if playlists:\n            entries = [\n                self._extract_from_playlist_sxml(playlist_url, playlist_id, timestamp)\n                for playlist_url in playlists]\n\n        \n        data_playables = re.findall(r'data-playable=([\"\\'])({.+?})\\1', webpage)\n        if data_playables:\n            for _, data_playable_json in data_playables:\n                data_playable = self._parse_json(\n                    unescapeHTML(data_playable_json), playlist_id, fatal=False)\n                if not data_playable:\n                    continue\n                settings = data_playable.get('settings', {})\n                if settings:\n                    \n                    \n                    playlist_object = settings.get('playlistObject', {})\n                    if playlist_object:\n                        items = playlist_object.get('items')\n                        if items and isinstance(items, list):\n                            title = playlist_object['title']\n                            description = playlist_object.get('summary')\n                            duration = int_or_none(items[0].get('duration'))\n                            programme_id = items[0].get('vpid')\n                            formats, subtitles = self._download_media_selector(programme_id)\n                            self._sort_formats(formats)\n                            entries.append({\n                                'id': programme_id,\n                                'title': title,\n                                'description': description,\n                                'timestamp': timestamp,\n                                'duration': duration,\n                                'formats': formats,\n                                'subtitles': subtitles,\n                            })\n                    else:\n                        \n                        \n                        \n                        playlist = data_playable.get('otherSettings', {}).get('playlist', {})\n                        if playlist:\n                            entry = None\n                            for key in ('streaming', 'progressiveDownload'):\n                                playlist_url = playlist.get('%sUrl' % key)\n                                if not playlist_url:\n                                    continue\n                                try:\n                                    info = self._extract_from_playlist_sxml(\n                                        playlist_url, playlist_id, timestamp)\n                                    if not entry:\n                                        entry = info\n                                    else:\n                                        entry['title'] = info['title']\n                                        entry['formats'].extend(info['formats'])\n                                except Exception as e:\n                                    \n                                    \n                                    \n                                    if isinstance(e.cause, compat_HTTPError) and e.cause.code == 500:\n                                        continue\n                                    raise\n                            if entry:\n                                self._sort_formats(entry['formats'])\n                                entries.append(entry)\n\n        if entries:\n            return self.playlist_result(entries, playlist_id, playlist_title, playlist_description)\n\n        \n        programme_id = self._search_regex(\n            [r'data-(?:video-player|media)-vpid=\"(%s)\"' % self._ID_REGEX,\n             r'<param[^>]+name=\"externalIdentifier\"[^>]+value=\"(%s)\"' % self._ID_REGEX,\n             r'videoId\\s*:\\s*[\"\\'](%s)[\"\\']' % self._ID_REGEX],\n            webpage, 'vpid', default=None)\n\n        if programme_id:\n            formats, subtitles = self._download_media_selector(programme_id)\n            self._sort_formats(formats)\n            \n            digital_data = self._parse_json(\n                self._search_regex(\n                    r'var\\s+digitalData\\s*=\\s*({.+?});?\\n', webpage, 'digital data', default='{}'),\n                programme_id, fatal=False)\n            page_info = digital_data.get('page', {}).get('pageInfo', {})\n            title = page_info.get('pageName') or self._og_search_title(webpage)\n            description = page_info.get('description') or self._og_search_description(webpage)\n            timestamp = parse_iso8601(page_info.get('publicationDate')) or timestamp\n            return {\n                'id': programme_id,\n                'title': title,\n                'description': description,\n                'timestamp': timestamp,\n                'formats': formats,\n                'subtitles': subtitles,\n            }\n\n        \n        \n        \n        morph_payload = self._parse_json(\n            self._search_regex(\n                r'Morph\\.setPayload\\([^,]+,\\s*({.+?})\\);',\n                webpage, 'morph payload', default='{}'),\n            playlist_id, fatal=False)\n        if morph_payload:\n            components = try_get(morph_payload, lambda x: x['body']['components'], list) or []\n            for component in components:\n                if not isinstance(component, dict):\n                    continue\n                lead_media = try_get(component, lambda x: x['props']['leadMedia'], dict)\n                if not lead_media:\n                    continue\n                identifiers = lead_media.get('identifiers')\n                if not identifiers or not isinstance(identifiers, dict):\n                    continue\n                programme_id = identifiers.get('vpid') or identifiers.get('playablePid')\n                if not programme_id:\n                    continue\n                title = lead_media.get('title') or self._og_search_title(webpage)\n                formats, subtitles = self._download_media_selector(programme_id)\n                self._sort_formats(formats)\n                description = lead_media.get('summary')\n                uploader = lead_media.get('masterBrand')\n                uploader_id = lead_media.get('mid')\n                duration = None\n                duration_d = lead_media.get('duration')\n                if isinstance(duration_d, dict):\n                    duration = parse_duration(dict_get(\n                        duration_d, ('rawDuration', 'formattedDuration', 'spokenDuration')))\n                return {\n                    'id': programme_id,\n                    'title': title,\n                    'description': description,\n                    'duration': duration,\n                    'uploader': uploader,\n                    'uploader_id': uploader_id,\n                    'formats': formats,\n                    'subtitles': subtitles,\n                }\n\n        def extract_all(pattern):\n            return list(filter(None, map(\n                lambda s: self._parse_json(s, playlist_id, fatal=False),\n                re.findall(pattern, webpage))))\n\n        \n        \n        EMBED_URL = r'https?://(?:www\\.)?bbc\\.co\\.uk/(?:[^/]+/)+%s(?:\\b[^\"]+)?' % self._ID_REGEX\n        entries = []\n        for match in extract_all(r'new\\s+SMP\\(({.+?})\\)'):\n            embed_url = match.get('playerSettings', {}).get('externalEmbedUrl')\n            if embed_url and re.match(EMBED_URL, embed_url):\n                entries.append(embed_url)\n        entries.extend(re.findall(\n            r'setPlaylist\\(\"(%s)\"\\)' % EMBED_URL, webpage))\n        if entries:\n            return self.playlist_result(\n                [self.url_result(entry_, 'BBCCoUk') for entry_ in entries],\n                playlist_id, playlist_title, playlist_description)\n\n        \n        medias = extract_all(r\"data-media-meta='({[^']+})'\")\n\n        if not medias:\n            \n            media_asset = self._search_regex(\n                r'mediaAssetPage\\.init\\(\\s*({.+?}), \"/',\n                webpage, 'media asset', default=None)\n            if media_asset:\n                media_asset_page = self._parse_json(media_asset, playlist_id, fatal=False)\n                medias = []\n                for video in media_asset_page.get('videos', {}).values():\n                    medias.extend(video.values())\n\n        if not medias:\n            \n            \n            vxp_playlist = self._parse_json(\n                self._search_regex(\n                    r'<script[^>]+class=\"vxp-playlist-data\"[^>]+type=\"application/json\"[^>]*>([^<]+)</script>',\n                    webpage, 'playlist data'),\n                playlist_id)\n            playlist_medias = []\n            for item in vxp_playlist:\n                media = item.get('media')\n                if not media:\n                    continue\n                playlist_medias.append(media)\n                \n                if item.get('advert', {}).get('assetId') == playlist_id:\n                    medias = [media]\n                    break\n            \n            if not medias:\n                medias = playlist_medias\n\n        entries = []\n        for num, media_meta in enumerate(medias, start=1):\n            formats, subtitles = self._extract_from_media_meta(media_meta, playlist_id)\n            if not formats:\n                continue\n            self._sort_formats(formats)\n\n            video_id = media_meta.get('externalId')\n            if not video_id:\n                video_id = playlist_id if len(medias) == 1 else '%s-%s' % (playlist_id, num)\n\n            title = media_meta.get('caption')\n            if not title:\n                title = playlist_title if len(medias) == 1 else '%s - Video %s' % (playlist_title, num)\n\n            duration = int_or_none(media_meta.get('durationInSeconds')) or parse_duration(media_meta.get('duration'))\n\n            images = []\n            for image in media_meta.get('images', {}).values():\n                images.extend(image.values())\n            if 'image' in media_meta:\n                images.append(media_meta['image'])\n\n            thumbnails = [{\n                'url': image.get('href'),\n                'width': int_or_none(image.get('width')),\n                'height': int_or_none(image.get('height')),\n            } for image in images]\n\n            entries.append({\n                'id': video_id,\n                'title': title,\n                'thumbnails': thumbnails,\n                'duration': duration,\n                'timestamp': timestamp,\n                'formats': formats,\n                'subtitles': subtitles,\n            })\n\n        return self.playlist_result(entries, playlist_id, playlist_title, playlist_description)\n\n\nclass BBCCoUkArticleIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?bbc\\.co\\.uk/programmes/articles/(?P<id>[a-zA-Z0-9]+)'\n    IE_NAME = 'bbc.co.uk:article'\n    IE_DESC = 'BBC articles'\n\n    _TEST = {\n        'url': 'http://www.bbc.co.uk/programmes/articles/3jNQLTMrPlYGTBn0WV6M2MS/not-your-typical-role-model-ada-lovelace-the-19th-century-programmer',\n        'info_dict': {\n            'id': '3jNQLTMrPlYGTBn0WV6M2MS',\n            'title': 'Calculating Ada: The Countess of Computing - Not your typical role model: Ada Lovelace the 19th century programmer - BBC Four',\n            'description': 'Hannah Fry reveals some of her surprising discoveries about Ada Lovelace during filming.',\n        },\n        'playlist_count': 4,\n        'add_ie': ['BBCCoUk'],\n    }\n\n    def _real_extract(self, url):\n        playlist_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, playlist_id)\n\n        title = self._og_search_title(webpage)\n        description = self._og_search_description(webpage).strip()\n\n        entries = [self.url_result(programme_url) for programme_url in re.findall(\n            r'<div[^>]+typeof=\"Clip\"[^>]+resource=\"([^\"]+)\"', webpage)]\n\n        return self.playlist_result(entries, playlist_id, title, description)\n\n\nclass BBCCoUkPlaylistBaseIE(InfoExtractor):\n    def _entries(self, webpage, url, playlist_id):\n        single_page = 'page' in compat_urlparse.parse_qs(\n            compat_urlparse.urlparse(url).query)\n        for page_num in itertools.count(2):\n            for video_id in re.findall(\n                    self._VIDEO_ID_TEMPLATE % BBCCoUkIE._ID_REGEX, webpage):\n                yield self.url_result(\n                    self._URL_TEMPLATE % video_id, BBCCoUkIE.ie_key())\n            if single_page:\n                return\n            next_page = self._search_regex(\n                r'<li[^>]+class=([\"\\'])pagination_+next\\1[^>]*><a[^>]+href=([\"\\'])(?P<url>(?:(?!\\2).)+)\\2',\n                webpage, 'next page url', default=None, group='url')\n            if not next_page:\n                break\n            webpage = self._download_webpage(\n                compat_urlparse.urljoin(url, next_page), playlist_id,\n                'Downloading page %d' % page_num, page_num)\n\n    def _real_extract(self, url):\n        playlist_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, playlist_id)\n\n        title, description = self._extract_title_and_description(webpage)\n\n        return self.playlist_result(\n            self._entries(webpage, url, playlist_id),\n            playlist_id, title, description)\n\n\nclass BBCCoUkIPlayerPlaylistIE(BBCCoUkPlaylistBaseIE):\n    IE_NAME = 'bbc.co.uk:iplayer:playlist'\n    _VALID_URL = r'https?://(?:www\\.)?bbc\\.co\\.uk/iplayer/(?:episodes|group)/(?P<id>%s)' % BBCCoUkIE._ID_REGEX\n    _URL_TEMPLATE = 'http://www.bbc.co.uk/iplayer/episode/%s'\n    _VIDEO_ID_TEMPLATE = r'data-ip-id=[\"\\'](%s)'\n    _TESTS = [{\n        'url': 'http://www.bbc.co.uk/iplayer/episodes/b05rcz9v',\n        'info_dict': {\n            'id': 'b05rcz9v',\n            'title': 'The Disappearance',\n            'description': 'French thriller serial about a missing teenager.',\n        },\n        'playlist_mincount': 6,\n        'skip': 'This programme is not currently available on BBC iPlayer',\n    }, {\n        \n        'url': 'http://www.bbc.co.uk/iplayer/group/p02tcc32',\n        'info_dict': {\n            'id': 'p02tcc32',\n            'title': 'Bohemian Icons',\n            'description': 'md5:683e901041b2fe9ba596f2ab04c4dbe7',\n        },\n        'playlist_mincount': 10,\n    }]\n\n    def _extract_title_and_description(self, webpage):\n        title = self._search_regex(r'<h1>([^<]+)</h1>', webpage, 'title', fatal=False)\n        description = self._search_regex(\n            r'<p[^>]+class=([\"\\'])subtitle\\1[^>]*>(?P<value>[^<]+)</p>',\n            webpage, 'description', fatal=False, group='value')\n        return title, description\n\n\nclass BBCCoUkPlaylistIE(BBCCoUkPlaylistBaseIE):\n    IE_NAME = 'bbc.co.uk:playlist'\n    _VALID_URL = r'https?://(?:www\\.)?bbc\\.co\\.uk/programmes/(?P<id>%s)/(?:episodes|broadcasts|clips)' % BBCCoUkIE._ID_REGEX\n    _URL_TEMPLATE = 'http://www.bbc.co.uk/programmes/%s'\n    _VIDEO_ID_TEMPLATE = r'data-pid=[\"\\'](%s)'\n    _TESTS = [{\n        'url': 'http://www.bbc.co.uk/programmes/b05rcz9v/clips',\n        'info_dict': {\n            'id': 'b05rcz9v',\n            'title': 'The Disappearance - Clips - BBC Four',\n            'description': 'French thriller serial about a missing teenager.',\n        },\n        'playlist_mincount': 7,\n    }, {\n        \n        'url': 'http://www.bbc.co.uk/programmes/b00mfl7n/clips?page=1',\n        'info_dict': {\n            'id': 'b00mfl7n',\n            'title': 'Frozen Planet - Clips - BBC One',\n            'description': 'md5:65dcbf591ae628dafe32aa6c4a4a0d8c',\n        },\n        'playlist_mincount': 24,\n    }, {\n        \n        'url': 'http://www.bbc.co.uk/programmes/b00mfl7n/clips',\n        'info_dict': {\n            'id': 'b00mfl7n',\n            'title': 'Frozen Planet - Clips - BBC One',\n            'description': 'md5:65dcbf591ae628dafe32aa6c4a4a0d8c',\n        },\n        'playlist_mincount': 142,\n    }, {\n        'url': 'http://www.bbc.co.uk/programmes/b05rcz9v/broadcasts/2016/06',\n        'only_matching': True,\n    }, {\n        'url': 'http://www.bbc.co.uk/programmes/b05rcz9v/clips',\n        'only_matching': True,\n    }, {\n        'url': 'http://www.bbc.co.uk/programmes/b055jkys/episodes/player',\n        'only_matching': True,\n    }]\n\n    def _extract_title_and_description(self, webpage):\n        title = self._og_search_title(webpage, fatal=False)\n        description = self._og_search_description(webpage)\n        return title, description\n", "comments": "(?x)\n                    https?://\n                        (?:www\\.)?bbc\\.co\\.uk/\n                        (?:\n                            programmes/(?!articles/)|\n                            iplayer(?:/[^/]+)?/(?:episode/|playlist/)|\n                            music/(?:clips|audiovideo/popular)[/#]|\n                            radio/player/|\n                            events/[^/]+/play/[^/]+/\n                        )\n                        (?P<id>%s)(?!/(?:episodes|broadcasts|clips))\n                    ''' % _ID_REGEX\n\n    _LOGIN_URL = 'https://account.bbc.com/signin'\n    _NETRC_MACHINE = 'bbc'\n\n    _MEDIASELECTOR_URLS = [\n        # Provides HQ HLS streams with even better quality that pc mediaset but fails\n        # with geolocation in some cases when it's even not geo restricted at all (e.g.\n        # http://www.bbc.co.uk/programmes/b06bp7lf). Also may fail with selectionunavailable.\n        'http://open.live.bbc.co.uk/mediaselector/5/select/version/2.0/mediaset/iptv-all/vpid/%s',\n        'http://open.live.bbc.co.uk/mediaselector/5/select/version/2.0/mediaset/pc/vpid/%s',\n    ]\n\n    _MEDIASELECTION_NS = 'http://bbc.co.uk/2008/mp/mediaselection'\n    _EMP_PLAYLIST_NS = 'http://bbc.co.uk/2008/emp/playlist'\n\n    _NAMESPACES = (\n        _MEDIASELECTION_NS,\n        _EMP_PLAYLIST_NS,\n    )\n\n    _TESTS = [\n        {\n            'url': 'http://www.bbc.co.uk/programmes/b039g8p7',\n            'info_dict': {\n                'id': 'b039d07m',\n                'ext': 'flv',\n                'title': 'Leonard Cohen, Kaleidoscope - BBC Radio 4',\n                'description': 'The Canadian poet and songwriter reflects on his musical career.',\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            }\n        },\n        {\n            'url': 'http://www.bbc.co.uk/iplayer/episode/b00yng5w/The_Man_in_Black_Series_3_The_Printed_Name/',\n            'info_dict': {\n                'id': 'b00yng1d',\n                'ext': 'flv',\n                'title': 'The Man in Black: Series 3: The Printed Name',\n                'description': \"Mark Gatiss introduces Nicholas Pierpan's chilling tale of a writer's devilish pact with a mysterious man. Stars Ewan Bailey.\",\n                'duration': 1800,\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            },\n            'skip': 'Episode is no longer available on BBC iPlayer Radio',\n        },\n        {\n            'url': 'http://www.bbc.co.uk/iplayer/episode/b03vhd1f/The_Voice_UK_Series_3_Blind_Auditions_5/',\n            'info_dict': {\n                'id': 'b00yng1d',\n                'ext': 'flv',\n                'title': 'The Voice UK: Series 3: Blind Auditions 5',\n                'description': 'Emma Willis and Marvin Humes present the fifth set of blind auditions in the singing competition, as the coaches continue to build their teams based on voice alone.',\n                'duration': 5100,\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            },\n            'skip': 'Currently BBC iPlayer TV programmes are available to play in the UK only',\n        },\n        {\n            'url': 'http://www.bbc.co.uk/iplayer/episode/p026c7jt/tomorrows-worlds-the-unearthly-history-of-science-fiction-2-invasion',\n            'info_dict': {\n                'id': 'b03k3pb7',\n                'ext': 'flv',\n                'title': \"Tomorrow's Worlds: The Unearthly History of Science Fiction\",\n                'description': '2. Invasion',\n                'duration': 3600,\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            },\n            'skip': 'Currently BBC iPlayer TV programmes are available to play in the UK only',\n        }, {\n            'url': 'http://www.bbc.co.uk/programmes/b04v20dw',\n            'info_dict': {\n                'id': 'b04v209v',\n                'ext': 'flv',\n                'title': 'Pete Tong, The Essential New Tune Special',\n                'description': \"Pete has a very special mix - all of 2014's Essential New Tunes!\",\n                'duration': 10800,\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            },\n            'skip': 'Episode is no longer available on BBC iPlayer Radio',\n        }, {\n            'url': 'http://www.bbc.co.uk/music/clips/p022h44b',\n            'note': 'Audio',\n            'info_dict': {\n                'id': 'p022h44j',\n                'ext': 'flv',\n                'title': 'BBC Proms Music Guides, Rachmaninov: Symphonic Dances',\n                'description': \"In this Proms Music Guide, Andrew McGregor looks at Rachmaninov's Symphonic Dances.\",\n                'duration': 227,\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            }\n        }, {\n            'url': 'http://www.bbc.co.uk/music/clips/p025c0zz',\n            'note': 'Video',\n            'info_dict': {\n                'id': 'p025c103',\n                'ext': 'flv',\n                'title': 'Reading and Leeds Festival, 2014, Rae Morris - Closer (Live on BBC Three)',\n                'description': 'Rae Morris performs Closer for BBC Three at Reading 2014',\n                'duration': 226,\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            }\n        }, {\n            'url': 'http://www.bbc.co.uk/iplayer/episode/b054fn09/ad/natural-world-20152016-2-super-powered-owls',\n            'info_dict': {\n                'id': 'p02n76xf',\n                'ext': 'flv',\n                'title': 'Natural World, 2015-2016: 2. Super Powered Owls',\n                'description': 'md5:e4db5c937d0e95a7c6b5e654d429183d',\n                'duration': 3540,\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            },\n            'skip': 'geolocation',\n        }, {\n            'url': 'http://www.bbc.co.uk/iplayer/episode/b05zmgwn/royal-academy-summer-exhibition',\n            'info_dict': {\n                'id': 'b05zmgw1',\n                'ext': 'flv',\n                'description': 'Kirsty Wark and Morgan Quaintance visit the Royal Academy as it prepares for its annual artistic extravaganza, meeting people who have come together to make the show unique.',\n                'title': 'Royal Academy Summer Exhibition',\n                'duration': 3540,\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            },\n            'skip': 'geolocation',\n        }, {\n            # iptv-all mediaset fails with geolocation however there is no geo restriction\n            # for this programme at all\n            'url': 'http://www.bbc.co.uk/programmes/b06rkn85',\n            'info_dict': {\n                'id': 'b06rkms3',\n                'ext': 'flv',\n                'title': \"Best of the Mini-Mixes 2015: Part 3, Annie Mac's Friday Night - BBC Radio 1\",\n                'description': \"Annie has part three in the Best of the Mini-Mixes 2015, plus the year's Most Played!\",\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            },\n            'skip': 'Now it\\'s really geo-restricted',\n        }, {\n            # compact player (https://github.com/rg3/youtube-dl/issues/8147)\n            'url': 'http://www.bbc.co.uk/programmes/p028bfkf/player',\n            'info_dict': {\n                'id': 'p028bfkj',\n                'ext': 'flv',\n                'title': 'Extract from BBC documentary Look Stranger - Giant Leeks and Magic Brews',\n                'description': 'Extract from BBC documentary Look Stranger - Giant Leeks and Magic Brews',\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            },\n        }, {\n            'url': 'http://www.bbc.co.uk/iplayer/playlist/p01dvks4',\n            'only_matching': True,\n        }, {\n            'url': 'http://www.bbc.co.uk/music/clips#p02frcc3',\n            'only_matching': True,\n        }, {\n            'url': 'http://www.bbc.co.uk/iplayer/cbeebies/episode/b0480276/bing-14-atchoo',\n            'only_matching': True,\n        }, {\n            'url': 'http://www.bbc.co.uk/radio/player/p03cchwf',\n            'only_matching': True,\n        }, {\n            'url': 'https://www.bbc.co.uk/music/audiovideo/popular#p055bc55',\n            'only_matching': True,\n        }, {\n            'url': 'http://www.bbc.co.uk/programmes/w3csv1y9',\n            'only_matching': True,\n        }]\n\n    _USP_RE = r'/([^/]+?)\\.ism(?:\\.hlsv2\\.ism)?/[^/]+\\.m3u8'\n\n    def _login(self):\n        username, password = self._get_login_info()\n        if username is None:\n            return\n\n        login_page = self._download_webpage(\n            self._LOGIN_URL, None, 'Downloading signin page')\n\n        login_form = self._hidden_inputs(login_page)\n\n        login_form.update({\n            'username': username,\n            'password': password,\n        })\n\n        post_url = urljoin(self._LOGIN_URL, self._search_regex(\n            r'<form[^>]+action=([\"\\'])(?P<url>.+?)\\1', login_page,\n            'post url', default=self._LOGIN_URL, group='url'))\n\n        response, urlh = self._download_webpage_handle(\n            post_url, None, 'Logging in', data=urlencode_postdata(login_form),\n            headers={'Referer': self._LOGIN_URL})\n\n        if self._LOGIN_URL in urlh.geturl():\n            error = clean_html(get_element_by_class('form-message', response))\n            if error:\n                raise ExtractorError(\n                    'Unable to login: %s' % error, expected=True)\n            raise ExtractorError('Unable to log in')\n\n    def _real_initialize(self):\n        self._login()\n\n    class MediaSelectionError(Exception):\n        def __init__(self, id):\n            self.id = id\n\n    def _extract_asx_playlist(self, connection, programme_id):\n        asx = self._download_xml(connection.get('href'), programme_id, 'Downloading ASX playlist')\n        return [ref.get('href') for ref in asx.findall('./Entry/ref')]\n\n    def _extract_items(self, playlist):\n        return playlist.findall('./{%s}item' % self._EMP_PLAYLIST_NS)\n\n    def _findall_ns(self, element, xpath):\n        elements = []\n        for ns in self._NAMESPACES:\n            elements.extend(element.findall(xpath % ns))\n        return elements\n\n    def _extract_medias(self, media_selection):\n        error = media_selection.find('./{%s}error' % self._MEDIASELECTION_NS)\n        if error is None:\n            media_selection.find('./{%s}error' % self._EMP_PLAYLIST_NS)\n        if error is not None:\n            raise BBCCoUkIE.MediaSelectionError(error.get('id'))\n        return self._findall_ns(media_selection, './{%s}media')\n\n    def _extract_connections(self, media):\n        return self._findall_ns(media, './{%s}connection')\n\n    def _get_subtitles(self, media, programme_id):\n        subtitles = {}\n        for connection in self._extract_connections(media):\n            captions = self._download_xml(connection.get('href'), programme_id, 'Downloading captions')\n            lang = captions.get('{http://www.w3.org/XML/1998/namespace}lang', 'en')\n            subtitles[lang] = [\n                {\n                    'url': connection.get('href'),\n                    'ext': 'ttml',\n                },\n            ]\n        return subtitles\n\n    def _raise_extractor_error(self, media_selection_error):\n        raise ExtractorError(\n            '%s returned error: %s' % (self.IE_NAME, media_selection_error.id),\n            expected=True)\n\n    def _download_media_selector(self, programme_id):\n        last_exception = None\n        for mediaselector_url in self._MEDIASELECTOR_URLS:\n            try:\n                return self._download_media_selector_url(\n                    mediaselector_url % programme_id, programme_id)\n            except BBCCoUkIE.MediaSelectionError as e:\n                if e.id in ('notukerror', 'geolocation', 'selectionunavailable'):\n                    last_exception = e\n                    continue\n                self._raise_extractor_error(e)\n        self._raise_extractor_error(last_exception)\n\n    def _download_media_selector_url(self, url, programme_id=None):\n        try:\n            media_selection = self._download_xml(\n                url, programme_id, 'Downloading media selection XML')\n        except ExtractorError as ee:\n            if isinstance(ee.cause, compat_HTTPError) and ee.cause.code in (403, 404):\n                media_selection = compat_etree_fromstring(ee.cause.read().decode('utf-8'))\n            else:\n                raise\n        return self._process_media_selector(media_selection, programme_id)\n\n    def _process_media_selector(self, media_selection, programme_id):\n        formats = []\n        subtitles = None\n        urls = []\n\n        for media in self._extract_medias(media_selection):\n            kind = media.get('kind')\n            if kind in ('video', 'audio'):\n                bitrate = int_or_none(media.get('bitrate'))\n                encoding = media.get('encoding')\n                service = media.get('service')\n                width = int_or_none(media.get('width'))\n                height = int_or_none(media.get('height'))\n                file_size = int_or_none(media.get('media_file_size'))\n                for connection in self._extract_connections(media):\n                    href = connection.get('href')\n                    if href in urls:\n                        continue\n                    if href:\n                        urls.append(href)\n                    conn_kind = connection.get('kind')\n                    protocol = connection.get('protocol')\n                    supplier = connection.get('supplier')\n                    transfer_format = connection.get('transferFormat')\n                    format_id = supplier or conn_kind or protocol\n                    if service:\n                        format_id = '%s_%s' % (service, format_id)\n                    # ASX playlist\n                    if supplier == 'asx':\n                        for i, ref in enumerate(self._extract_asx_playlist(connection, programme_id)):\n                            formats.append({\n                                'url': ref,\n                                'format_id': 'ref%s_%s' % (i, format_id),\n                            })\n                    elif transfer_format == 'dash':\n                        formats.extend(self._extract_mpd_formats(\n                            href, programme_id, mpd_id=format_id, fatal=False))\n                    elif transfer_format == 'hls':\n                        formats.extend(self._extract_m3u8_formats(\n                            href, programme_id, ext='mp4', entry_protocol='m3u8_native',\n                            m3u8_id=format_id, fatal=False))\n                        if re.search(self._USP_RE, href):\n                            usp_formats = self._extract_m3u8_formats(\n                                re.sub(self._USP_RE, r'/\\1.ism/\\1.m3u8', href),\n                                programme_id, ext='mp4', entry_protocol='m3u8_native',\n                                m3u8_id=format_id, fatal=False)\n                            for f in usp_formats:\n                                if f.get('height') and f['height'] > 720:\n                                    continue\n                                formats.append(f)\n                    elif transfer_format == 'hds':\n                        formats.extend(self._extract_f4m_formats(\n                            href, programme_id, f4m_id=format_id, fatal=False))\n                    else:\n                        if not service and not supplier and bitrate:\n                            format_id += '-%d' % bitrate\n                        fmt = {\n                            'format_id': format_id,\n                            'filesize': file_size,\n                        }\n                        if kind == 'video':\n                            fmt.update({\n                                'width': width,\n                                'height': height,\n                                'tbr': bitrate,\n                                'vcodec': encoding,\n                            })\n                        else:\n                            fmt.update({\n                                'abr': bitrate,\n                                'acodec': encoding,\n                                'vcodec': 'none',\n                            })\n                        if protocol in ('http', 'https'):\n                            # Direct link\n                            fmt.update({\n                                'url': href,\n                            })\n                        elif protocol == 'rtmp':\n                            application = connection.get('application', 'ondemand')\n                            auth_string = connection.get('authString')\n                            identifier = connection.get('identifier')\n                            server = connection.get('server')\n                            fmt.update({\n                                'url': '%s://%s/%s?%s' % (protocol, server, application, auth_string),\n                                'play_path': identifier,\n                                'app': '%s?%s' % (application, auth_string),\n                                'page_url': 'http://www.bbc.co.uk',\n                                'player_url': 'http://www.bbc.co.uk/emp/releases/iplayer/revisions/617463_618125_4/617463_618125_4_emp.swf',\n                                'rtmp_live': False,\n                                'ext': 'flv',\n                            })\n                        else:\n                            continue\n                        formats.append(fmt)\n            elif kind == 'captions':\n                subtitles = self.extract_subtitles(media, programme_id)\n        return formats, subtitles\n\n    def _download_playlist(self, playlist_id):\n        try:\n            playlist = self._download_json(\n                'http://www.bbc.co.uk/programmes/%s/playlist.json' % playlist_id,\n                playlist_id, 'Downloading playlist JSON')\n\n            version = playlist.get('defaultAvailableVersion')\n            if version:\n                smp_config = version['smpConfig']\n                title = smp_config['title']\n                description = smp_config['summary']\n                for item in smp_config['items']:\n                    kind = item['kind']\n                    if kind not in ('programme', 'radioProgramme'):\n                        continue\n                    programme_id = item.get('vpid')\n                    duration = int_or_none(item.get('duration'))\n                    formats, subtitles = self._download_media_selector(programme_id)\n                return programme_id, title, description, duration, formats, subtitles\n        except ExtractorError as ee:\n            if not (isinstance(ee.cause, compat_HTTPError) and ee.cause.code == 404):\n                raise\n\n        # fallback to legacy playlist\n        return self._process_legacy_playlist(playlist_id)\n\n    def _process_legacy_playlist_url(self, url, display_id):\n        playlist = self._download_legacy_playlist_url(url, display_id)\n        return self._extract_from_legacy_playlist(playlist, display_id)\n\n    def _process_legacy_playlist(self, playlist_id):\n        return self._process_legacy_playlist_url(\n            'http://www.bbc.co.uk/iplayer/playlist/%s' % playlist_id, playlist_id)\n\n    def _download_legacy_playlist_url(self, url, playlist_id=None):\n        return self._download_xml(\n            url, playlist_id, 'Downloading legacy playlist XML')\n\n    def _extract_from_legacy_playlist(self, playlist, playlist_id):\n        no_items = playlist.find('./{%s}noItems' % self._EMP_PLAYLIST_NS)\n        if no_items is not None:\n            reason = no_items.get('reason')\n            if reason == 'preAvailability':\n                msg = 'Episode %s is not yet available' % playlist_id\n            elif reason == 'postAvailability':\n                msg = 'Episode %s is no longer available' % playlist_id\n            elif reason == 'noMedia':\n                msg = 'Episode %s is not currently available' % playlist_id\n            else:\n                msg = 'Episode %s is not available: %s' % (playlist_id, reason)\n            raise ExtractorError(msg, expected=True)\n\n        for item in self._extract_items(playlist):\n            kind = item.get('kind')\n            if kind not in ('programme', 'radioProgramme'):\n                continue\n            title = playlist.find('./{%s}title' % self._EMP_PLAYLIST_NS).text\n            description_el = playlist.find('./{%s}summary' % self._EMP_PLAYLIST_NS)\n            description = description_el.text if description_el is not None else None\n\n            def get_programme_id(item):\n                def get_from_attributes(item):\n                    for p in('identifier', 'group'):\n                        value = item.get(p)\n                        if value and re.match(r'^[pb][\\da-z]{7}$', value):\n                            return value\n                get_from_attributes(item)\n                mediator = item.find('./{%s}mediator' % self._EMP_PLAYLIST_NS)\n                if mediator is not None:\n                    return get_from_attributes(mediator)\n\n            programme_id = get_programme_id(item)\n            duration = int_or_none(item.get('duration'))\n\n            if programme_id:\n                formats, subtitles = self._download_media_selector(programme_id)\n            else:\n                formats, subtitles = self._process_media_selector(item, playlist_id)\n                programme_id = playlist_id\n\n        return programme_id, title, description, duration, formats, subtitles\n\n    def _real_extract(self, url):\n        group_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, group_id, 'Downloading video page')\n\n        error = self._search_regex(\n            r'<div\\b[^>]+\\bclass=[\"\\']smp__message delta[\"\\'][^>]*>([^<]+)<',\n            webpage, 'error', default=None)\n        if error:\n            raise ExtractorError(error, expected=True)\n\n        programme_id = None\n        duration = None\n\n        tviplayer = self._search_regex(\n            r'mediator\\.bind\\(({.+?})\\s*,\\s*document\\.getElementById',\n            webpage, 'player', default=None)\n\n        if tviplayer:\n            player = self._parse_json(tviplayer, group_id).get('player', {})\n            duration = int_or_none(player.get('duration'))\n            programme_id = player.get('vpid')\n\n        if not programme_id:\n            programme_id = self._search_regex(\n                r'\"vpid\"\\s*:\\s*\"(%s)\"' % self._ID_REGEX, webpage, 'vpid', fatal=False, default=None)\n\n        if programme_id:\n            formats, subtitles = self._download_media_selector(programme_id)\n            title = self._og_search_title(webpage, default=None) or self._html_search_regex(\n                (r'<h2[^>]+id=\"parent-title\"[^>]*>(.+?)</h2>',\n                 r'<div[^>]+class=\"info\"[^>]*>\\s*<h1>(.+?)</h1>'), webpage, 'title')\n            description = self._search_regex(\n                (r'<p class=\"[^\"]*medium-description[^\"]*\">([^<]+)</p>',\n                 r'<div[^>]+class=\"info_+synopsis\"[^>]*>([^<]+)</div>'),\n                webpage, 'description', default=None)\n            if not description:\n                description = self._html_search_meta('description', webpage)\n        else:\n            programme_id, title, description, duration, formats, subtitles = self._download_playlist(group_id)\n\n        self._sort_formats(formats)\n\n        return {\n            'id': programme_id,\n            'title': title,\n            'description': description,\n            'thumbnail': self._og_search_thumbnail(webpage, default=None),\n            'duration': duration,\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n\n\nclass BBCIE(BBCCoUkIE):\n    IE_NAME = 'bbc'\n    IE_DESC = 'BBC'\n    _VALID_URL = r'https?://(?:www\\.)?bbc\\.(?:com|co\\.uk)/(?:[^/]+/)+(?P<id>[^/#?]+)'\n\n    _MEDIASELECTOR_URLS = [\n        # Provides HQ HLS streams but fails with geolocation in some cases when it's\n        # even not geo restricted at all\n        'http://open.live.bbc.co.uk/mediaselector/5/select/version/2.0/mediaset/iptv-all/vpid/%s',\n        # Provides more formats, namely direct mp4 links, but fails on some videos with\n        # notukerror for non UK (?) users (e.g.\n        # http://www.bbc.com/travel/story/20150625-sri-lankas-spicy-secret)\n        'http://open.live.bbc.co.uk/mediaselector/4/mtis/stream/%s',\n        # Provides fewer formats, but works everywhere for everybody (hopefully)\n        'http://open.live.bbc.co.uk/mediaselector/5/select/version/2.0/mediaset/journalism-pc/vpid/%s',\n    ]\n\n    _TESTS = [{\n        # article with multiple videos embedded with data-playable containing vpids\n        'url': 'http://www.bbc.com/news/world-europe-32668511',\n        'info_dict': {\n            'id': 'world-europe-32668511',\n            'title': 'Russia stages massive WW2 parade despite Western boycott',\n            'description': 'md5:00ff61976f6081841f759a08bf78cc9c',\n        },\n        'playlist_count': 2,\n    }, {\n        # article with multiple videos embedded with data-playable (more videos)\n        'url': 'http://www.bbc.com/news/business-28299555',\n        'info_dict': {\n            'id': 'business-28299555',\n            'title': 'Farnborough Airshow: Video highlights',\n            'description': 'BBC reports and video highlights at the Farnborough Airshow.',\n        },\n        'playlist_count': 9,\n        'skip': 'Save time',\n    }, {\n        # article with multiple videos embedded with `new SMP()`\n        # broken\n        'url': 'http://www.bbc.co.uk/blogs/adamcurtis/entries/3662a707-0af9-3149-963f-47bea720b460',\n        'info_dict': {\n            'id': '3662a707-0af9-3149-963f-47bea720b460',\n            'title': 'BUGGER',\n        },\n        'playlist_count': 18,\n    }, {\n        # single video embedded with data-playable containing vpid\n        'url': 'http://www.bbc.com/news/world-europe-32041533',\n        'info_dict': {\n            'id': 'p02mprgb',\n            'ext': 'mp4',\n            'title': 'Aerial footage showed the site of the crash in the Alps - courtesy BFM TV',\n            'description': 'md5:2868290467291b37feda7863f7a83f54',\n            'duration': 47,\n            'timestamp': 1427219242,\n            'upload_date': '20150324',\n        },\n        'params': {\n            # rtmp download\n            'skip_download': True,\n        }\n    }, {\n        # article with single video embedded with data-playable containing XML playlist\n        # with direct video links as progressiveDownloadUrl (for now these are extracted)\n        # and playlist with f4m and m3u8 as streamingUrl\n        'url': 'http://www.bbc.com/turkce/haberler/2015/06/150615_telabyad_kentin_cogu',\n        'info_dict': {\n            'id': '150615_telabyad_kentin_cogu',\n            'ext': 'mp4',\n            'title': \"YPG: Tel Abyad'\u0131n tamam\u0131 kontrol\u00fcm\u00fczde\",\n            'description': 'md5:33a4805a855c9baf7115fcbde57e7025',\n            'timestamp': 1434397334,\n            'upload_date': '20150615',\n        },\n        'params': {\n            'skip_download': True,\n        }\n    }, {\n        # single video embedded with data-playable containing XML playlists (regional section)\n        'url': 'http://www.bbc.com/mundo/video_fotos/2015/06/150619_video_honduras_militares_hospitales_corrupcion_aw',\n        'info_dict': {\n            'id': '150619_video_honduras_militares_hospitales_corrupcion_aw',\n            'ext': 'mp4',\n            'title': 'Honduras militariza sus hospitales por nuevo esc\u00e1ndalo de corrupci\u00f3n',\n            'description': 'md5:1525f17448c4ee262b64b8f0c9ce66c8',\n            'timestamp': 1434713142,\n            'upload_date': '20150619',\n        },\n        'params': {\n            'skip_download': True,\n        }\n    }, {\n        # single video from video playlist embedded with vxp-playlist-data JSON\n        'url': 'http://www.bbc.com/news/video_and_audio/must_see/33376376',\n        'info_dict': {\n            'id': 'p02w6qjc',\n            'ext': 'mp4',\n            'title': '''Judge Mindy Glazer: \"I'm sorry to see you here... I always wondered what happened to you\"''',\n            'duration': 56,\n            'description': '''Judge Mindy Glazer: \"I'm sorry to see you here... I always wondered what happened to you\"\n\"\n# coding: utf-8\n# single video story with digitalData\n# rtmp download\n# single video story without digitalData\n# rtmp download\n# single video embedded with Morph\n# m3u8 download\n# single video with playlist.sxml URL in playlist param\n# rtmp download\n# article with multiple videos embedded with playlist.sxml in playlist param\n# school report article with single video\n# single video with playlist URL from weather section\n# custom redirection to www.bbc.com\n# single video article embedded with data-media-vpid\n# Direct links to media in media metadata (e.g.\n# http://www.bbc.com/turkce/haberler/2015/06/150615_telabyad_kentin_cogu)\n# TODO: there are also f4m and m3u8 streams incorporated in playlist.sxml\n# Process playlist.sxml as legacy playlist\n# article with multiple videos embedded with playlist.sxml (e.g.\n# http://www.bbc.com/sport/0/football/34475836)\n# news article with multiple videos embedded with data-playable\n# data-playable with video vpid in settings.playlistObject.items (e.g.\n# http://www.bbc.com/news/world-us-canada-34473351)\n# data-playable without vpid but with a playlist.sxml URLs\n# in otherSettings.playlist (e.g.\n# http://www.bbc.com/turkce/multimedya/2015/10/151010_vid_ankara_patlama_ani)\n# Some playlist URL may fail with 500, at the same time\n# the other one may work fine (e.g.\n# http://www.bbc.com/turkce/haberler/2015/06/150615_telabyad_kentin_cogu)\n# single video story (e.g. http://www.bbc.com/travel/story/20150625-sri-lankas-spicy-secret)\n# digitalData may be missing (e.g. http://www.bbc.com/autos/story/20130513-hyundais-rock-star)\n# Morph based embed (e.g. http://www.bbc.co.uk/sport/live/olympics/36895975)\n# There are several setPayload calls may be present but the video\n# seems to be always related to the first one\n# Multiple video article (e.g.\n# http://www.bbc.co.uk/blogs/adamcurtis/entries/3662a707-0af9-3149-963f-47bea720b460)\n# Multiple video article (e.g. http://www.bbc.com/news/world-europe-32668511)\n# Single video article (e.g. http://www.bbc.com/news/video_and_audio/international)\n# Multiple video playlist with single `now playing` entry (e.g.\n# http://www.bbc.com/news/video_and_audio/must_see/33767813)\n# Download single video if found media with asset id matching the video id from URL\n# Fallback to the whole playlist\n# Available for over a year unlike 30 days for most other programmes\n# multipage playlist, explicit page\n# multipage playlist, all pages\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\nimport itertools\n\nfrom .common import InfoExtractor\nfrom ..utils import (\n    clean_html,\n    dict_get,\n    ExtractorError,\n    float_or_none,\n    get_element_by_class,\n    int_or_none,\n    parse_duration,\n    parse_iso8601,\n    try_get,\n    unescapeHTML,\n    urlencode_postdata,\n    urljoin,\n)\nfrom ..compat import (\n    compat_etree_fromstring,\n    compat_HTTPError,\n    compat_urlparse,\n)\n\n\nclass BBCCoUkIE(InfoExtractor):\n    IE_NAME = 'bbc.co.uk'\n    IE_DESC = 'BBC iPlayer'\n    _ID_REGEX = r'[pbw][\\da-z]{7}'\n    _VALID_URL = r'''(?x)\n                    https?://\n                        (?:www\\.)?bbc\\.co\\.uk/\n                        (?:\n                            programmes/(?!articles/)|\n                            iplayer(?:/[^/]+)?/(?:episode/|playlist/)|\n                            music/(?:clips|audiovideo/popular)[/#]|\n                            radio/player/|\n                            events/[^/]+/play/[^/]+/\n                        )\n                        (?P<id>%s)(?!/(?:episodes|broadcasts|clips))\n                    ''' % _ID_REGEX\n\n    _LOGIN_URL = 'https://account.bbc.com/signin'\n    _NETRC_MACHINE = 'bbc'\n\n    _MEDIASELECTOR_URLS = [\n        # Provides HQ HLS streams with even better quality that pc mediaset but fails\n        # with geolocation in some cases when it's even not geo restricted at all (e.g.\n        # http://www.bbc.co.uk/programmes/b06bp7lf). Also may fail with selectionunavailable.\n        'http://open.live.bbc.co.uk/mediaselector/5/select/version/2.0/mediaset/iptv-all/vpid/%s',\n        'http://open.live.bbc.co.uk/mediaselector/5/select/version/2.0/mediaset/pc/vpid/%s',\n    ]\n\n    _MEDIASELECTION_NS = 'http://bbc.co.uk/2008/mp/mediaselection'\n    _EMP_PLAYLIST_NS = 'http://bbc.co.uk/2008/emp/playlist'\n\n    _NAMESPACES = (\n        _MEDIASELECTION_NS,\n        _EMP_PLAYLIST_NS,\n    )\n\n    _TESTS = [\n        {\n            'url': 'http://www.bbc.co.uk/programmes/b039g8p7',\n            'info_dict': {\n                'id': 'b039d07m',\n                'ext': 'flv',\n                'title': 'Leonard Cohen, Kaleidoscope - BBC Radio 4',\n                'description': 'The Canadian poet and songwriter reflects on his musical career.',\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            }\n        },\n        {\n            'url': 'http://www.bbc.co.uk/iplayer/episode/b00yng5w/The_Man_in_Black_Series_3_The_Printed_Name/',\n            'info_dict': {\n                'id': 'b00yng1d',\n                'ext': 'flv',\n                'title': 'The Man in Black: Series 3: The Printed Name',\n                'description': \"Mark Gatiss introduces Nicholas Pierpan's chilling tale of a writer's devilish pact with a mysterious man. Stars Ewan Bailey.\",\n                'duration': 1800,\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            },\n            'skip': 'Episode is no longer available on BBC iPlayer Radio',\n        },\n        {\n            'url': 'http://www.bbc.co.uk/iplayer/episode/b03vhd1f/The_Voice_UK_Series_3_Blind_Auditions_5/',\n            'info_dict': {\n                'id': 'b00yng1d',\n                'ext': 'flv',\n                'title': 'The Voice UK: Series 3: Blind Auditions 5',\n                'description': 'Emma Willis and Marvin Humes present the fifth set of blind auditions in the singing competition, as the coaches continue to build their teams based on voice alone.',\n                'duration': 5100,\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            },\n            'skip': 'Currently BBC iPlayer TV programmes are available to play in the UK only',\n        },\n        {\n            'url': 'http://www.bbc.co.uk/iplayer/episode/p026c7jt/tomorrows-worlds-the-unearthly-history-of-science-fiction-2-invasion',\n            'info_dict': {\n                'id': 'b03k3pb7',\n                'ext': 'flv',\n                'title': \"Tomorrow's Worlds: The Unearthly History of Science Fiction\",\n                'description': '2. Invasion',\n                'duration': 3600,\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            },\n            'skip': 'Currently BBC iPlayer TV programmes are available to play in the UK only',\n        }, {\n            'url': 'http://www.bbc.co.uk/programmes/b04v20dw',\n            'info_dict': {\n                'id': 'b04v209v',\n                'ext': 'flv',\n                'title': 'Pete Tong, The Essential New Tune Special',\n                'description': \"Pete has a very special mix - all of 2014's Essential New Tunes!\",\n                'duration': 10800,\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            },\n            'skip': 'Episode is no longer available on BBC iPlayer Radio',\n        }, {\n            'url': 'http://www.bbc.co.uk/music/clips/p022h44b',\n            'note': 'Audio',\n            'info_dict': {\n                'id': 'p022h44j',\n                'ext': 'flv',\n                'title': 'BBC Proms Music Guides, Rachmaninov: Symphonic Dances',\n                'description': \"In this Proms Music Guide, Andrew McGregor looks at Rachmaninov's Symphonic Dances.\",\n                'duration': 227,\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            }\n        }, {\n            'url': 'http://www.bbc.co.uk/music/clips/p025c0zz',\n            'note': 'Video',\n            'info_dict': {\n                'id': 'p025c103',\n                'ext': 'flv',\n                'title': 'Reading and Leeds Festival, 2014, Rae Morris - Closer (Live on BBC Three)',\n                'description': 'Rae Morris performs Closer for BBC Three at Reading 2014',\n                'duration': 226,\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            }\n        }, {\n            'url': 'http://www.bbc.co.uk/iplayer/episode/b054fn09/ad/natural-world-20152016-2-super-powered-owls',\n            'info_dict': {\n                'id': 'p02n76xf',\n                'ext': 'flv',\n                'title': 'Natural World, 2015-2016: 2. Super Powered Owls',\n                'description': 'md5:e4db5c937d0e95a7c6b5e654d429183d',\n                'duration': 3540,\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            },\n            'skip': 'geolocation',\n        }, {\n            'url': 'http://www.bbc.co.uk/iplayer/episode/b05zmgwn/royal-academy-summer-exhibition',\n            'info_dict': {\n                'id': 'b05zmgw1',\n                'ext': 'flv',\n                'description': 'Kirsty Wark and Morgan Quaintance visit the Royal Academy as it prepares for its annual artistic extravaganza, meeting people who have come together to make the show unique.',\n                'title': 'Royal Academy Summer Exhibition',\n                'duration': 3540,\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            },\n            'skip': 'geolocation',\n        }, {\n            # iptv-all mediaset fails with geolocation however there is no geo restriction\n            # for this programme at all\n            'url': 'http://www.bbc.co.uk/programmes/b06rkn85',\n            'info_dict': {\n                'id': 'b06rkms3',\n                'ext': 'flv',\n                'title': \"Best of the Mini-Mixes 2015: Part 3, Annie Mac's Friday Night - BBC Radio 1\",\n                'description': \"Annie has part three in the Best of the Mini-Mixes 2015, plus the year's Most Played!\",\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            },\n            'skip': 'Now it\\'s really geo-restricted',\n        }, {\n            # compact player (https://github.com/rg3/youtube-dl/issues/8147)\n            'url': 'http://www.bbc.co.uk/programmes/p028bfkf/player',\n            'info_dict': {\n                'id': 'p028bfkj',\n                'ext': 'flv',\n                'title': 'Extract from BBC documentary Look Stranger - Giant Leeks and Magic Brews',\n                'description': 'Extract from BBC documentary Look Stranger - Giant Leeks and Magic Brews',\n            },\n            'params': {\n                # rtmp download\n                'skip_download': True,\n            },\n        }, {\n            'url': 'http://www.bbc.co.uk/iplayer/playlist/p01dvks4',\n            'only_matching': True,\n        }, {\n            'url': 'http://www.bbc.co.uk/music/clips#p02frcc3',\n            'only_matching': True,\n        }, {\n            'url': 'http://www.bbc.co.uk/iplayer/cbeebies/episode/b0480276/bing-14-atchoo',\n            'only_matching': True,\n        }, {\n            'url': 'http://www.bbc.co.uk/radio/player/p03cchwf',\n            'only_matching': True,\n        }, {\n            'url': 'https://www.bbc.co.uk/music/audiovideo/popular#p055bc55',\n            'only_matching': True,\n        }, {\n            'url': 'http://www.bbc.co.uk/programmes/w3csv1y9',\n            'only_matching': True,\n        }]\n\n    _USP_RE = r'/([^/]+?)\\.ism(?:\\.hlsv2\\.ism)?/[^/]+\\.m3u8'\n\n    def _login(self):\n        username, password = self._get_login_info()\n        if username is None:\n            return\n\n        login_page = self._download_webpage(\n            self._LOGIN_URL, None, 'Downloading signin page')\n\n        login_form = self._hidden_inputs(login_page)\n\n        login_form.update({\n            'username': username,\n            'password': password,\n        })\n\n        post_url = urljoin(self._LOGIN_URL, self._search_regex(\n            r'<form[^>]+action=([\"\\'])(?P<url>.+?)\\1', login_page,\n            'post url', default=self._LOGIN_URL, group='url'))\n\n        response, urlh = self._download_webpage_handle(\n            post_url, None, 'Logging in', data=urlencode_postdata(login_form),\n            headers={'Referer': self._LOGIN_URL})\n\n        if self._LOGIN_URL in urlh.geturl():\n            error = clean_html(get_element_by_class('form-message', response))\n            if error:\n                raise ExtractorError(\n                    'Unable to login: %s' % error, expected=True)\n            raise ExtractorError('Unable to log in')\n\n    def _real_initialize(self):\n        self._login()\n\n    class MediaSelectionError(Exception):\n        def __init__(self, id):\n            self.id = id\n\n    def _extract_asx_playlist(self, connection, programme_id):\n        asx = self._download_xml(connection.get('href'), programme_id, 'Downloading ASX playlist')\n        return [ref.get('href') for ref in asx.findall('./Entry/ref')]\n\n    def _extract_items(self, playlist):\n        return playlist.findall('./{%s}item' % self._EMP_PLAYLIST_NS)\n\n    def _findall_ns(self, element, xpath):\n        elements = []\n        for ns in self._NAMESPACES:\n            elements.extend(element.findall(xpath % ns))\n        return elements\n\n    def _extract_medias(self, media_selection):\n        error = media_selection.find('./{%s}error' % self._MEDIASELECTION_NS)\n        if error is None:\n            media_selection.find('./{%s}error' % self._EMP_PLAYLIST_NS)\n        if error is not None:\n            raise BBCCoUkIE.MediaSelectionError(error.get('id'))\n        return self._findall_ns(media_selection, './{%s}media')\n\n    def _extract_connections(self, media):\n        return self._findall_ns(media, './{%s}connection')\n\n    def _get_subtitles(self, media, programme_id):\n        subtitles = {}\n        for connection in self._extract_connections(media):\n            captions = self._download_xml(connection.get('href'), programme_id, 'Downloading captions')\n            lang = captions.get('{http://www.w3.org/XML/1998/namespace}lang', 'en')\n            subtitles[lang] = [\n                {\n                    'url': connection.get('href'),\n                    'ext': 'ttml',\n                },\n            ]\n        return subtitles\n\n    def _raise_extractor_error(self, media_selection_error):\n        raise ExtractorError(\n            '%s returned error: %s' % (self.IE_NAME, media_selection_error.id),\n            expected=True)\n\n    def _download_media_selector(self, programme_id):\n        last_exception = None\n        for mediaselector_url in self._MEDIASELECTOR_URLS:\n            try:\n                return self._download_media_selector_url(\n                    mediaselector_url % programme_id, programme_id)\n            except BBCCoUkIE.MediaSelectionError as e:\n                if e.id in ('notukerror', 'geolocation', 'selectionunavailable'):\n                    last_exception = e\n                    continue\n                self._raise_extractor_error(e)\n        self._raise_extractor_error(last_exception)\n\n    def _download_media_selector_url(self, url, programme_id=None):\n        try:\n            media_selection = self._download_xml(\n                url, programme_id, 'Downloading media selection XML')\n        except ExtractorError as ee:\n            if isinstance(ee.cause, compat_HTTPError) and ee.cause.code in (403, 404):\n                media_selection = compat_etree_fromstring(ee.cause.read().decode('utf-8'))\n            else:\n                raise\n        return self._process_media_selector(media_selection, programme_id)\n\n    def _process_media_selector(self, media_selection, programme_id):\n        formats = []\n        subtitles = None\n        urls = []\n\n        for media in self._extract_medias(media_selection):\n            kind = media.get('kind')\n            if kind in ('video', 'audio'):\n                bitrate = int_or_none(media.get('bitrate'))\n                encoding = media.get('encoding')\n                service = media.get('service')\n                width = int_or_none(media.get('width'))\n                height = int_or_none(media.get('height'))\n                file_size = int_or_none(media.get('media_file_size'))\n                for connection in self._extract_connections(media):\n                    href = connection.get('href')\n                    if href in urls:\n                        continue\n                    if href:\n                        urls.append(href)\n                    conn_kind = connection.get('kind')\n                    protocol = connection.get('protocol')\n                    supplier = connection.get('supplier')\n                    transfer_format = connection.get('transferFormat')\n                    format_id = supplier or conn_kind or protocol\n                    if service:\n                        format_id = '%s_%s' % (service, format_id)\n                    # ASX playlist\n                    if supplier == 'asx':\n                        for i, ref in enumerate(self._extract_asx_playlist(connection, programme_id)):\n                            formats.append({\n                                'url': ref,\n                                'format_id': 'ref%s_%s' % (i, format_id),\n                            })\n                    elif transfer_format == 'dash':\n                        formats.extend(self._extract_mpd_formats(\n                            href, programme_id, mpd_id=format_id, fatal=False))\n                    elif transfer_format == 'hls':\n                        formats.extend(self._extract_m3u8_formats(\n                            href, programme_id, ext='mp4', entry_protocol='m3u8_native',\n                            m3u8_id=format_id, fatal=False))\n                        if re.search(self._USP_RE, href):\n                            usp_formats = self._extract_m3u8_formats(\n                                re.sub(self._USP_RE, r'/\\1.ism/\\1.m3u8', href),\n                                programme_id, ext='mp4', entry_protocol='m3u8_native',\n                                m3u8_id=format_id, fatal=False)\n                            for f in usp_formats:\n                                if f.get('height') and f['height'] > 720:\n                                    continue\n                                formats.append(f)\n                    elif transfer_format == 'hds':\n                        formats.extend(self._extract_f4m_formats(\n                            href, programme_id, f4m_id=format_id, fatal=False))\n                    else:\n                        if not service and not supplier and bitrate:\n                            format_id += '-%d' % bitrate\n                        fmt = {\n                            'format_id': format_id,\n                            'filesize': file_size,\n                        }\n                        if kind == 'video':\n                            fmt.update({\n                                'width': width,\n                                'height': height,\n                                'tbr': bitrate,\n                                'vcodec': encoding,\n                            })\n                        else:\n                            fmt.update({\n                                'abr': bitrate,\n                                'acodec': encoding,\n                                'vcodec': 'none',\n                            })\n                        if protocol in ('http', 'https'):\n                            # Direct link\n                            fmt.update({\n                                'url': href,\n                            })\n                        elif protocol == 'rtmp':\n                            application = connection.get('application', 'ondemand')\n                            auth_string = connection.get('authString')\n                            identifier = connection.get('identifier')\n                            server = connection.get('server')\n                            fmt.update({\n                                'url': '%s://%s/%s?%s' % (protocol, server, application, auth_string),\n                                'play_path': identifier,\n                                'app': '%s?%s' % (application, auth_string),\n                                'page_url': 'http://www.bbc.co.uk',\n                                'player_url': 'http://www.bbc.co.uk/emp/releases/iplayer/revisions/617463_618125_4/617463_618125_4_emp.swf',\n                                'rtmp_live': False,\n                                'ext': 'flv',\n                            })\n                        else:\n                            continue\n                        formats.append(fmt)\n            elif kind == 'captions':\n                subtitles = self.extract_subtitles(media, programme_id)\n        return formats, subtitles\n\n    def _download_playlist(self, playlist_id):\n        try:\n            playlist = self._download_json(\n                'http://www.bbc.co.uk/programmes/%s/playlist.json' % playlist_id,\n                playlist_id, 'Downloading playlist JSON')\n\n            version = playlist.get('defaultAvailableVersion')\n            if version:\n                smp_config = version['smpConfig']\n                title = smp_config['title']\n                description = smp_config['summary']\n                for item in smp_config['items']:\n                    kind = item['kind']\n                    if kind not in ('programme', 'radioProgramme'):\n                        continue\n                    programme_id = item.get('vpid')\n                    duration = int_or_none(item.get('duration'))\n                    formats, subtitles = self._download_media_selector(programme_id)\n                return programme_id, title, description, duration, formats, subtitles\n        except ExtractorError as ee:\n            if not (isinstance(ee.cause, compat_HTTPError) and ee.cause.code == 404):\n                raise\n\n        # fallback to legacy playlist\n        return self._process_legacy_playlist(playlist_id)\n\n    def _process_legacy_playlist_url(self, url, display_id):\n        playlist = self._download_legacy_playlist_url(url, display_id)\n        return self._extract_from_legacy_playlist(playlist, display_id)\n\n    def _process_legacy_playlist(self, playlist_id):\n        return self._process_legacy_playlist_url(\n            'http://www.bbc.co.uk/iplayer/playlist/%s' % playlist_id, playlist_id)\n\n    def _download_legacy_playlist_url(self, url, playlist_id=None):\n        return self._download_xml(\n            url, playlist_id, 'Downloading legacy playlist XML')\n\n    def _extract_from_legacy_playlist(self, playlist, playlist_id):\n        no_items = playlist.find('./{%s}noItems' % self._EMP_PLAYLIST_NS)\n        if no_items is not None:\n            reason = no_items.get('reason')\n            if reason == 'preAvailability':\n                msg = 'Episode %s is not yet available' % playlist_id\n            elif reason == 'postAvailability':\n                msg = 'Episode %s is no longer available' % playlist_id\n            elif reason == 'noMedia':\n                msg = 'Episode %s is not currently available' % playlist_id\n            else:\n                msg = 'Episode %s is not available: %s' % (playlist_id, reason)\n            raise ExtractorError(msg, expected=True)\n\n        for item in self._extract_items(playlist):\n            kind = item.get('kind')\n            if kind not in ('programme', 'radioProgramme'):\n                continue\n            title = playlist.find('./{%s}title' % self._EMP_PLAYLIST_NS).text\n            description_el = playlist.find('./{%s}summary' % self._EMP_PLAYLIST_NS)\n            description = description_el.text if description_el is not None else None\n\n            def get_programme_id(item):\n                def get_from_attributes(item):\n                    for p in('identifier', 'group'):\n                        value = item.get(p)\n                        if value and re.match(r'^[pb][\\da-z]{7}$', value):\n                            return value\n                get_from_attributes(item)\n                mediator = item.find('./{%s}mediator' % self._EMP_PLAYLIST_NS)\n                if mediator is not None:\n                    return get_from_attributes(mediator)\n\n            programme_id = get_programme_id(item)\n            duration = int_or_none(item.get('duration'))\n\n            if programme_id:\n                formats, subtitles = self._download_media_selector(programme_id)\n            else:\n                formats, subtitles = self._process_media_selector(item, playlist_id)\n                programme_id = playlist_id\n\n        return programme_id, title, description, duration, formats, subtitles\n\n    def _real_extract(self, url):\n        group_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, group_id, 'Downloading video page')\n\n        error = self._search_regex(\n            r'<div\\b[^>]+\\bclass=[\"\\']smp__message delta[\"\\'][^>]*>([^<]+)<',\n            webpage, 'error', default=None)\n        if error:\n            raise ExtractorError(error, expected=True)\n\n        programme_id = None\n        duration = None\n\n        tviplayer = self._search_regex(\n            r'mediator\\.bind\\(({.+?})\\s*,\\s*document\\.getElementById',\n            webpage, 'player', default=None)\n\n        if tviplayer:\n            player = self._parse_json(tviplayer, group_id).get('player', {})\n            duration = int_or_none(player.get('duration'))\n            programme_id = player.get('vpid')\n\n        if not programme_id:\n            programme_id = self._search_regex(\n                r'\"vpid\"\\s*:\\s*\"(%s)\"' % self._ID_REGEX, webpage, 'vpid', fatal=False, default=None)\n\n        if programme_id:\n            formats, subtitles = self._download_media_selector(programme_id)\n            title = self._og_search_title(webpage, default=None) or self._html_search_regex(\n                (r'<h2[^>]+id=\"parent-title\"[^>]*>(.+?)</h2>',\n                 r'<div[^>]+class=\"info\"[^>]*>\\s*<h1>(.+?)</h1>'), webpage, 'title')\n            description = self._search_regex(\n                (r'<p class=\"[^\"]*medium-description[^\"]*\">([^<]+)</p>',\n                 r'<div[^>]+class=\"info_+synopsis\"[^>]*>([^<]+)</div>'),\n                webpage, 'description', default=None)\n            if not description:\n                description = self._html_search_meta('description', webpage)\n        else:\n            programme_id, title, description, duration, formats, subtitles = self._download_playlist(group_id)\n\n        self._sort_formats(formats)\n\n        return {\n            'id': programme_id,\n            'title': title,\n            'description': description,\n            'thumbnail': self._og_search_thumbnail(webpage, default=None),\n            'duration': duration,\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n\n\nclass BBCIE(BBCCoUkIE):\n    IE_NAME = 'bbc'\n    IE_DESC = 'BBC'\n    _VALID_URL = r'https?://(?:www\\.)?bbc\\.(?:com|co\\.uk)/(?:[^/]+/)+(?P<id>[^/#?]+)'\n\n    _MEDIASELECTOR_URLS = [\n        # Provides HQ HLS streams but fails with geolocation in some cases when it's\n        # even not geo restricted at all\n        'http://open.live.bbc.co.uk/mediaselector/5/select/version/2.0/mediaset/iptv-all/vpid/%s',\n        # Provides more formats, namely direct mp4 links, but fails on some videos with\n        # notukerror for non UK (?) users (e.g.\n        # http://www.bbc.com/travel/story/20150625-sri-lankas-spicy-secret)\n        'http://open.live.bbc.co.uk/mediaselector/4/mtis/stream/%s',\n        # Provides fewer formats, but works everywhere for everybody (hopefully)\n        'http://open.live.bbc.co.uk/mediaselector/5/select/version/2.0/mediaset/journalism-pc/vpid/%s',\n    ]\n\n    _TESTS = [{\n        # article with multiple videos embedded with data-playable containing vpids\n        'url': 'http://www.bbc.com/news/world-europe-32668511',\n        'info_dict': {\n            'id': 'world-europe-32668511',\n            'title': 'Russia stages massive WW2 parade despite Western boycott',\n            'description': 'md5:00ff61976f6081841f759a08bf78cc9c',\n        },\n        'playlist_count': 2,\n    }, {\n        # article with multiple videos embedded with data-playable (more videos)\n        'url': 'http://www.bbc.com/news/business-28299555',\n        'info_dict': {\n            'id': 'business-28299555',\n            'title': 'Farnborough Airshow: Video highlights',\n            'description': 'BBC reports and video highlights at the Farnborough Airshow.',\n        },\n        'playlist_count': 9,\n        'skip': 'Save time',\n    }, {\n        # article with multiple videos embedded with `new SMP()`\n        # broken\n        'url': 'http://www.bbc.co.uk/blogs/adamcurtis/entries/3662a707-0af9-3149-963f-47bea720b460',\n        'info_dict': {\n            'id': '3662a707-0af9-3149-963f-47bea720b460',\n            'title': 'BUGGER',\n        },\n        'playlist_count': 18,\n    }, {\n        # single video embedded with data-playable containing vpid\n        'url': 'http://www.bbc.com/news/world-europe-32041533',\n        'info_dict': {\n            'id': 'p02mprgb',\n            'ext': 'mp4',\n            'title': 'Aerial footage showed the site of the crash in the Alps - courtesy BFM TV',\n            'description': 'md5:2868290467291b37feda7863f7a83f54',\n            'duration': 47,\n            'timestamp': 1427219242,\n            'upload_date': '20150324',\n        },\n        'params': {\n            # rtmp download\n            'skip_download': True,\n        }\n    }, {\n        # article with single video embedded with data-playable containing XML playlist\n        # with direct video links as progressiveDownloadUrl (for now these are extracted)\n        # and playlist with f4m and m3u8 as streamingUrl\n        'url': 'http://www.bbc.com/turkce/haberler/2015/06/150615_telabyad_kentin_cogu',\n        'info_dict': {\n            'id': '150615_telabyad_kentin_cogu',\n            'ext': 'mp4',\n            'title': \"YPG: Tel Abyad'\u0131n tamam\u0131 kontrol\u00fcm\u00fczde\",\n            'description': 'md5:33a4805a855c9baf7115fcbde57e7025',\n            'timestamp': 1434397334,\n            'upload_date': '20150615',\n        },\n        'params': {\n            'skip_download': True,\n        }\n    }, {\n        # single video embedded with data-playable containing XML playlists (regional section)\n        'url': 'http://www.bbc.com/mundo/video_fotos/2015/06/150619_video_honduras_militares_hospitales_corrupcion_aw',\n        'info_dict': {\n            'id': '150619_video_honduras_militares_hospitales_corrupcion_aw',\n            'ext': 'mp4',\n            'title': 'Honduras militariza sus hospitales por nuevo esc\u00e1ndalo de corrupci\u00f3n',\n            'description': 'md5:1525f17448c4ee262b64b8f0c9ce66c8',\n            'timestamp': 1434713142,\n            'upload_date': '20150619',\n        },\n        'params': {\n            'skip_download': True,\n        }\n    }, {\n        # single video from video playlist embedded with vxp-playlist-data JSON\n        'url': 'http://www.bbc.com/news/video_and_audio/must_see/33376376',\n        'info_dict': {\n            'id': 'p02w6qjc',\n            'ext': 'mp4',\n            'title': '''Judge Mindy Glazer: \"I'm sorry to see you here... I always wondered what happened to you\"''',\n            'duration': 56,\n            'description': '''Judge Mindy Glazer: \"I'm sorry to see you here... I always wondered what happened to you\"''',\n        },\n        'params': {\n            'skip_download': True,\n        }\n    }, {\n        # single video story with digitalData\n        'url': 'http://www.bbc.com/travel/story/20150625-sri-lankas-spicy-secret',\n        'info_dict': {\n            'id': 'p02q6gc4',\n            'ext': 'flv',\n            'title': 'Sri Lanka\u2019s spicy secret',\n            'description': 'As a new train line to Jaffna opens up the country\u2019s north, travellers can experience a truly distinct slice of Tamil culture.',\n            'timestamp': 1437674293,\n            'upload_date': '20150723',\n        },\n        'params': {\n            # rtmp download\n            'skip_download': True,\n        }\n    }, {\n        # single video story without digitalData\n        'url': 'http://www.bbc.com/autos/story/20130513-hyundais-rock-star',\n        'info_dict': {\n            'id': 'p018zqqg',\n            'ext': 'mp4',\n            'title': 'Hyundai Santa Fe Sport: Rock star',\n            'description': 'md5:b042a26142c4154a6e472933cf20793d',\n            'timestamp': 1415867444,\n            'upload_date': '20141113',\n        },\n        'params': {\n            # rtmp download\n            'skip_download': True,\n        }\n    }, {\n        # single video embedded with Morph\n        'url': 'http://www.bbc.co.uk/sport/live/olympics/36895975',\n        'info_dict': {\n            'id': 'p041vhd0',\n            'ext': 'mp4',\n            'title': \"Nigeria v Japan - Men's First Round\",\n            'description': 'Live coverage of the first round from Group B at the Amazonia Arena.',\n            'duration': 7980,\n            'uploader': 'BBC Sport',\n            'uploader_id': 'bbc_sport',\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n        'skip': 'Georestricted to UK',\n    }, {\n        # single video with playlist.sxml URL in playlist param\n        'url': 'http://www.bbc.com/sport/0/football/33653409',\n        'info_dict': {\n            'id': 'p02xycnp',\n            'ext': 'mp4',\n            'title': 'Transfers: Cristiano Ronaldo to Man Utd, Arsenal to spend?',\n            'description': 'BBC Sport\\'s David Ornstein has the latest transfer gossip, including rumours of a Manchester United return for Cristiano Ronaldo.',\n            'duration': 140,\n        },\n        'params': {\n            # rtmp download\n            'skip_download': True,\n        }\n    }, {\n        # article with multiple videos embedded with playlist.sxml in playlist param\n        'url': 'http://www.bbc.com/sport/0/football/34475836',\n        'info_dict': {\n            'id': '34475836',\n            'title': 'Jurgen Klopp: Furious football from a witty and winning coach',\n            'description': 'Fast-paced football, wit, wisdom and a ready smile - why Liverpool fans should come to love new boss Jurgen Klopp.',\n        },\n        'playlist_count': 3,\n    }, {\n        # school report article with single video\n        'url': 'http://www.bbc.co.uk/schoolreport/35744779',\n        'info_dict': {\n            'id': '35744779',\n            'title': 'School which breaks down barriers in Jerusalem',\n        },\n        'playlist_count': 1,\n    }, {\n        # single video with playlist URL from weather section\n        'url': 'http://www.bbc.com/weather/features/33601775',\n        'only_matching': True,\n    }, {\n        # custom redirection to www.bbc.com\n        'url': 'http://www.bbc.co.uk/news/science-environment-33661876',\n        'only_matching': True,\n    }, {\n        # single video article embedded with data-media-vpid\n        'url': 'http://www.bbc.co.uk/sport/rowing/35908187',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        EXCLUDE_IE = (BBCCoUkIE, BBCCoUkArticleIE, BBCCoUkIPlayerPlaylistIE, BBCCoUkPlaylistIE)\n        return (False if any(ie.suitable(url) for ie in EXCLUDE_IE)\n                else super(BBCIE, cls).suitable(url))\n\n    def _extract_from_media_meta(self, media_meta, video_id):\n        # Direct links to media in media metadata (e.g.\n        # http://www.bbc.com/turkce/haberler/2015/06/150615_telabyad_kentin_cogu)\n        # TODO: there are also f4m and m3u8 streams incorporated in playlist.sxml\n        source_files = media_meta.get('sourceFiles')\n        if source_files:\n            return [{\n                'url': f['url'],\n                'format_id': format_id,\n                'ext': f.get('encoding'),\n                'tbr': float_or_none(f.get('bitrate'), 1000),\n                'filesize': int_or_none(f.get('filesize')),\n            } for format_id, f in source_files.items() if f.get('url')], []\n\n        programme_id = media_meta.get('externalId')\n        if programme_id:\n            return self._download_media_selector(programme_id)\n\n        # Process playlist.sxml as legacy playlist\n        href = media_meta.get('href')\n        if href:\n            playlist = self._download_legacy_playlist_url(href)\n            _, _, _, _, formats, subtitles = self._extract_from_legacy_playlist(playlist, video_id)\n            return formats, subtitles\n\n        return [], []\n\n    def _extract_from_playlist_sxml(self, url, playlist_id, timestamp):\n        programme_id, title, description, duration, formats, subtitles = \\\n            self._process_legacy_playlist_url(url, playlist_id)\n        self._sort_formats(formats)\n        return {\n            'id': programme_id,\n            'title': title,\n            'description': description,\n            'duration': duration,\n            'timestamp': timestamp,\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n\n    def _real_extract(self, url):\n        playlist_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, playlist_id)\n\n        json_ld_info = self._search_json_ld(webpage, playlist_id, default={})\n        timestamp = json_ld_info.get('timestamp')\n\n        playlist_title = json_ld_info.get('title')\n        if not playlist_title:\n            playlist_title = self._og_search_title(\n                webpage, default=None) or self._html_search_regex(\n                r'<title>(.+?)</title>', webpage, 'playlist title', default=None)\n            if playlist_title:\n                playlist_title = re.sub(r'(.+)\\s*-\\s*BBC.*?$', r'\\1', playlist_title).strip()\n\n        playlist_description = json_ld_info.get(\n            'description') or self._og_search_description(webpage, default=None)\n\n        if not timestamp:\n            timestamp = parse_iso8601(self._search_regex(\n                [r'<meta[^>]+property=\"article:published_time\"[^>]+content=\"([^\"]+)\"',\n                 r'itemprop=\"datePublished\"[^>]+datetime=\"([^\"]+)\"',\n                 r'\"datePublished\":\\s*\"([^\"]+)'],\n                webpage, 'date', default=None))\n\n        entries = []\n\n        # article with multiple videos embedded with playlist.sxml (e.g.\n        # http://www.bbc.com/sport/0/football/34475836)\n        playlists = re.findall(r'<param[^>]+name=\"playlist\"[^>]+value=\"([^\"]+)\"', webpage)\n        playlists.extend(re.findall(r'data-media-id=\"([^\"]+/playlist\\.sxml)\"', webpage))\n        if playlists:\n            entries = [\n                self._extract_from_playlist_sxml(playlist_url, playlist_id, timestamp)\n                for playlist_url in playlists]\n\n        # news article with multiple videos embedded with data-playable\n        data_playables = re.findall(r'data-playable=([\"\\'])({.+?})\\1', webpage)\n        if data_playables:\n            for _, data_playable_json in data_playables:\n                data_playable = self._parse_json(\n                    unescapeHTML(data_playable_json), playlist_id, fatal=False)\n                if not data_playable:\n                    continue\n                settings = data_playable.get('settings', {})\n                if settings:\n                    # data-playable with video vpid in settings.playlistObject.items (e.g.\n                    # http://www.bbc.com/news/world-us-canada-34473351)\n                    playlist_object = settings.get('playlistObject', {})\n                    if playlist_object:\n                        items = playlist_object.get('items')\n                        if items and isinstance(items, list):\n                            title = playlist_object['title']\n                            description = playlist_object.get('summary')\n                            duration = int_or_none(items[0].get('duration'))\n                            programme_id = items[0].get('vpid')\n                            formats, subtitles = self._download_media_selector(programme_id)\n                            self._sort_formats(formats)\n                            entries.append({\n                                'id': programme_id,\n                                'title': title,\n                                'description': description,\n                                'timestamp': timestamp,\n                                'duration': duration,\n                                'formats': formats,\n                                'subtitles': subtitles,\n                            })\n                    else:\n                        # data-playable without vpid but with a playlist.sxml URLs\n                        # in otherSettings.playlist (e.g.\n                        # http://www.bbc.com/turkce/multimedya/2015/10/151010_vid_ankara_patlama_ani)\n                        playlist = data_playable.get('otherSettings', {}).get('playlist', {})\n                        if playlist:\n                            entry = None\n                            for key in ('streaming', 'progressiveDownload'):\n                                playlist_url = playlist.get('%sUrl' % key)\n                                if not playlist_url:\n                                    continue\n                                try:\n                                    info = self._extract_from_playlist_sxml(\n                                        playlist_url, playlist_id, timestamp)\n                                    if not entry:\n                                        entry = info\n                                    else:\n                                        entry['title'] = info['title']\n                                        entry['formats'].extend(info['formats'])\n                                except Exception as e:\n                                    # Some playlist URL may fail with 500, at the same time\n                                    # the other one may work fine (e.g.\n                                    # http://www.bbc.com/turkce/haberler/2015/06/150615_telabyad_kentin_cogu)\n                                    if isinstance(e.cause, compat_HTTPError) and e.cause.code == 500:\n                                        continue\n                                    raise\n                            if entry:\n                                self._sort_formats(entry['formats'])\n                                entries.append(entry)\n\n        if entries:\n            return self.playlist_result(entries, playlist_id, playlist_title, playlist_description)\n\n        # single video story (e.g. http://www.bbc.com/travel/story/20150625-sri-lankas-spicy-secret)\n        programme_id = self._search_regex(\n            [r'data-(?:video-player|media)-vpid=\"(%s)\"' % self._ID_REGEX,\n             r'<param[^>]+name=\"externalIdentifier\"[^>]+value=\"(%s)\"' % self._ID_REGEX,\n             r'videoId\\s*:\\s*[\"\\'](%s)[\"\\']' % self._ID_REGEX],\n            webpage, 'vpid', default=None)\n\n        if programme_id:\n            formats, subtitles = self._download_media_selector(programme_id)\n            self._sort_formats(formats)\n            # digitalData may be missing (e.g. http://www.bbc.com/autos/story/20130513-hyundais-rock-star)\n            digital_data = self._parse_json(\n                self._search_regex(\n                    r'var\\s+digitalData\\s*=\\s*({.+?});?\\n', webpage, 'digital data', default='{}'),\n                programme_id, fatal=False)\n            page_info = digital_data.get('page', {}).get('pageInfo', {})\n            title = page_info.get('pageName') or self._og_search_title(webpage)\n            description = page_info.get('description') or self._og_search_description(webpage)\n            timestamp = parse_iso8601(page_info.get('publicationDate')) or timestamp\n            return {\n                'id': programme_id,\n                'title': title,\n                'description': description,\n                'timestamp': timestamp,\n                'formats': formats,\n                'subtitles': subtitles,\n            }\n\n        # Morph based embed (e.g. http://www.bbc.co.uk/sport/live/olympics/36895975)\n        # There are several setPayload calls may be present but the video\n        # seems to be always related to the first one\n        morph_payload = self._parse_json(\n            self._search_regex(\n                r'Morph\\.setPayload\\([^,]+,\\s*({.+?})\\);',\n                webpage, 'morph payload', default='{}'),\n            playlist_id, fatal=False)\n        if morph_payload:\n            components = try_get(morph_payload, lambda x: x['body']['components'], list) or []\n            for component in components:\n                if not isinstance(component, dict):\n                    continue\n                lead_media = try_get(component, lambda x: x['props']['leadMedia'], dict)\n                if not lead_media:\n                    continue\n                identifiers = lead_media.get('identifiers')\n                if not identifiers or not isinstance(identifiers, dict):\n                    continue\n                programme_id = identifiers.get('vpid') or identifiers.get('playablePid')\n                if not programme_id:\n                    continue\n                title = lead_media.get('title') or self._og_search_title(webpage)\n                formats, subtitles = self._download_media_selector(programme_id)\n                self._sort_formats(formats)\n                description = lead_media.get('summary')\n                uploader = lead_media.get('masterBrand')\n                uploader_id = lead_media.get('mid')\n                duration = None\n                duration_d = lead_media.get('duration')\n                if isinstance(duration_d, dict):\n                    duration = parse_duration(dict_get(\n                        duration_d, ('rawDuration', 'formattedDuration', 'spokenDuration')))\n                return {\n                    'id': programme_id,\n                    'title': title,\n                    'description': description,\n                    'duration': duration,\n                    'uploader': uploader,\n                    'uploader_id': uploader_id,\n                    'formats': formats,\n                    'subtitles': subtitles,\n                }\n\n        def extract_all(pattern):\n            return list(filter(None, map(\n                lambda s: self._parse_json(s, playlist_id, fatal=False),\n                re.findall(pattern, webpage))))\n\n        # Multiple video article (e.g.\n        # http://www.bbc.co.uk/blogs/adamcurtis/entries/3662a707-0af9-3149-963f-47bea720b460)\n        EMBED_URL = r'https?://(?:www\\.)?bbc\\.co\\.uk/(?:[^/]+/)+%s(?:\\b[^\"]+)?' % self._ID_REGEX\n        entries = []\n        for match in extract_all(r'new\\s+SMP\\(({.+?})\\)'):\n            embed_url = match.get('playerSettings', {}).get('externalEmbedUrl')\n            if embed_url and re.match(EMBED_URL, embed_url):\n                entries.append(embed_url)\n        entries.extend(re.findall(\n            r'setPlaylist\\(\"(%s)\"\\)' % EMBED_URL, webpage))\n        if entries:\n            return self.playlist_result(\n                [self.url_result(entry_, 'BBCCoUk') for entry_ in entries],\n                playlist_id, playlist_title, playlist_description)\n\n        # Multiple video article (e.g. http://www.bbc.com/news/world-europe-32668511)\n        medias = extract_all(r\"data-media-meta='({[^']+})'\")\n\n        if not medias:\n            # Single video article (e.g. http://www.bbc.com/news/video_and_audio/international)\n            media_asset = self._search_regex(\n                r'mediaAssetPage\\.init\\(\\s*({.+?}), \"/',\n                webpage, 'media asset', default=None)\n            if media_asset:\n                media_asset_page = self._parse_json(media_asset, playlist_id, fatal=False)\n                medias = []\n                for video in media_asset_page.get('videos', {}).values():\n                    medias.extend(video.values())\n\n        if not medias:\n            # Multiple video playlist with single `now playing` entry (e.g.\n            # http://www.bbc.com/news/video_and_audio/must_see/33767813)\n            vxp_playlist = self._parse_json(\n                self._search_regex(\n                    r'<script[^>]+class=\"vxp-playlist-data\"[^>]+type=\"application/json\"[^>]*>([^<]+)</script>',\n                    webpage, 'playlist data'),\n                playlist_id)\n            playlist_medias = []\n            for item in vxp_playlist:\n                media = item.get('media')\n                if not media:\n                    continue\n                playlist_medias.append(media)\n                # Download single video if found media with asset id matching the video id from URL\n                if item.get('advert', {}).get('assetId') == playlist_id:\n                    medias = [media]\n                    break\n            # Fallback to the whole playlist\n            if not medias:\n                medias = playlist_medias\n\n        entries = []\n        for num, media_meta in enumerate(medias, start=1):\n            formats, subtitles = self._extract_from_media_meta(media_meta, playlist_id)\n            if not formats:\n                continue\n            self._sort_formats(formats)\n\n            video_id = media_meta.get('externalId')\n            if not video_id:\n                video_id = playlist_id if len(medias) == 1 else '%s-%s' % (playlist_id, num)\n\n            title = media_meta.get('caption')\n            if not title:\n                title = playlist_title if len(medias) == 1 else '%s - Video %s' % (playlist_title, num)\n\n            duration = int_or_none(media_meta.get('durationInSeconds')) or parse_duration(media_meta.get('duration'))\n\n            images = []\n            for image in media_meta.get('images', {}).values():\n                images.extend(image.values())\n            if 'image' in media_meta:\n                images.append(media_meta['image'])\n\n            thumbnails = [{\n                'url': image.get('href'),\n                'width': int_or_none(image.get('width')),\n                'height': int_or_none(image.get('height')),\n            } for image in images]\n\n            entries.append({\n                'id': video_id,\n                'title': title,\n                'thumbnails': thumbnails,\n                'duration': duration,\n                'timestamp': timestamp,\n                'formats': formats,\n                'subtitles': subtitles,\n            })\n\n        return self.playlist_result(entries, playlist_id, playlist_title, playlist_description)\n\n\nclass BBCCoUkArticleIE(InfoExtractor):\n    _VALID_URL = r'https?://(?:www\\.)?bbc\\.co\\.uk/programmes/articles/(?P<id>[a-zA-Z0-9]+)'\n    IE_NAME = 'bbc.co.uk:article'\n    IE_DESC = 'BBC articles'\n\n    _TEST = {\n        'url': 'http://www.bbc.co.uk/programmes/articles/3jNQLTMrPlYGTBn0WV6M2MS/not-your-typical-role-model-ada-lovelace-the-19th-century-programmer',\n        'info_dict': {\n            'id': '3jNQLTMrPlYGTBn0WV6M2MS',\n            'title': 'Calculating Ada: The Countess of Computing - Not your typical role model: Ada Lovelace the 19th century programmer - BBC Four',\n            'description': 'Hannah Fry reveals some of her surprising discoveries about Ada Lovelace during filming.',\n        },\n        'playlist_count': 4,\n        'add_ie': ['BBCCoUk'],\n    }\n\n    def _real_extract(self, url):\n        playlist_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, playlist_id)\n\n        title = self._og_search_title(webpage)\n        description = self._og_search_description(webpage).strip()\n\n        entries = [self.url_result(programme_url) for programme_url in re.findall(\n            r'<div[^>]+typeof=\"Clip\"[^>]+resource=\"([^\"]+)\"', webpage)]\n\n        return self.playlist_result(entries, playlist_id, title, description)\n\n\nclass BBCCoUkPlaylistBaseIE(InfoExtractor):\n    def _entries(self, webpage, url, playlist_id):\n        single_page = 'page' in compat_urlparse.parse_qs(\n            compat_urlparse.urlparse(url).query)\n        for page_num in itertools.count(2):\n            for video_id in re.findall(\n                    self._VIDEO_ID_TEMPLATE % BBCCoUkIE._ID_REGEX, webpage):\n                yield self.url_result(\n                    self._URL_TEMPLATE % video_id, BBCCoUkIE.ie_key())\n            if single_page:\n                return\n            next_page = self._search_regex(\n                r'<li[^>]+class=([\"\\'])pagination_+next\\1[^>]*><a[^>]+href=([\"\\'])(?P<url>(?:(?!\\2).)+)\\2',\n                webpage, 'next page url', default=None, group='url')\n            if not next_page:\n                break\n            webpage = self._download_webpage(\n                compat_urlparse.urljoin(url, next_page), playlist_id,\n                'Downloading page %d' % page_num, page_num)\n\n    def _real_extract(self, url):\n        playlist_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, playlist_id)\n\n        title, description = self._extract_title_and_description(webpage)\n\n        return self.playlist_result(\n            self._entries(webpage, url, playlist_id),\n            playlist_id, title, description)\n\n\nclass BBCCoUkIPlayerPlaylistIE(BBCCoUkPlaylistBaseIE):\n    IE_NAME = 'bbc.co.uk:iplayer:playlist'\n    _VALID_URL = r'https?://(?:www\\.)?bbc\\.co\\.uk/iplayer/(?:episodes|group)/(?P<id>%s)' % BBCCoUkIE._ID_REGEX\n    _URL_TEMPLATE = 'http://www.bbc.co.uk/iplayer/episode/%s'\n    _VIDEO_ID_TEMPLATE = r'data-ip-id=[\"\\'](%s)'\n    _TESTS = [{\n        'url': 'http://www.bbc.co.uk/iplayer/episodes/b05rcz9v',\n        'info_dict': {\n            'id': 'b05rcz9v',\n            'title': 'The Disappearance',\n            'description': 'French thriller serial about a missing teenager.',\n        },\n        'playlist_mincount': 6,\n        'skip': 'This programme is not currently available on BBC iPlayer',\n    }, {\n        # Available for over a year unlike 30 days for most other programmes\n        'url': 'http://www.bbc.co.uk/iplayer/group/p02tcc32',\n        'info_dict': {\n            'id': 'p02tcc32',\n            'title': 'Bohemian Icons',\n            'description': 'md5:683e901041b2fe9ba596f2ab04c4dbe7',\n        },\n        'playlist_mincount': 10,\n    }]\n\n    def _extract_title_and_description(self, webpage):\n        title = self._search_regex(r'<h1>([^<]+)</h1>', webpage, 'title', fatal=False)\n        description = self._search_regex(\n            r'<p[^>]+class=([\"\\'])subtitle\\1[^>]*>(?P<value>[^<]+)</p>',\n            webpage, 'description', fatal=False, group='value')\n        return title, description\n\n\nclass BBCCoUkPlaylistIE(BBCCoUkPlaylistBaseIE):\n    IE_NAME = 'bbc.co.uk:playlist'\n    _VALID_URL = r'https?://(?:www\\.)?bbc\\.co\\.uk/programmes/(?P<id>%s)/(?:episodes|broadcasts|clips)' % BBCCoUkIE._ID_REGEX\n    _URL_TEMPLATE = 'http://www.bbc.co.uk/programmes/%s'\n    _VIDEO_ID_TEMPLATE = r'data-pid=[\"\\'](%s)'\n    _TESTS = [{\n        'url': 'http://www.bbc.co.uk/programmes/b05rcz9v/clips',\n        'info_dict': {\n            'id': 'b05rcz9v',\n            'title': 'The Disappearance - Clips - BBC Four',\n            'description': 'French thriller serial about a missing teenager.',\n        },\n        'playlist_mincount': 7,\n    }, {\n        # multipage playlist, explicit page\n        'url': 'http://www.bbc.co.uk/programmes/b00mfl7n/clips?page=1',\n        'info_dict': {\n            'id': 'b00mfl7n',\n            'title': 'Frozen Planet - Clips - BBC One',\n            'description': 'md5:65dcbf591ae628dafe32aa6c4a4a0d8c',\n        },\n        'playlist_mincount': 24,\n    }, {\n        # multipage playlist, all pages\n        'url': 'http://www.bbc.co.uk/programmes/b00mfl7n/clips',\n        'info_dict': {\n            'id': 'b00mfl7n',\n            'title': 'Frozen Planet - Clips - BBC One',\n            'description': 'md5:65dcbf591ae628dafe32aa6c4a4a0d8c',\n        },\n        'playlist_mincount': 142,\n    }, {\n        'url': 'http://www.bbc.co.uk/programmes/b05rcz9v/broadcasts/2016/06',\n        'only_matching': True,\n    }, {\n        'url': 'http://www.bbc.co.uk/programmes/b05rcz9v/clips',\n        'only_matching': True,\n    }, {\n        'url': 'http://www.bbc.co.uk/programmes/b055jkys/episodes/player',\n        'only_matching': True,\n    }]\n\n    def _extract_title_and_description(self, webpage):\n        title = self._og_search_title(webpage, fatal=False)\n        description = self._og_search_description(webpage)\n        return title, description\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "bbc.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/bbc.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}