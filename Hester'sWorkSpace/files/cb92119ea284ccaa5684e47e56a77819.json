{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom random import choice\nfrom string import digits\n\nfrom odoo import models, fields, api, exceptions, _, SUPERUSER_ID\n\n\nclass HrEmployee(models.Model):\n    _inherit = \"hr.employee\"\n    _description = \"Employee\"\n\n    def _default_random_pin(self):\n        return (\"\".join(choice(digits) for i in range(4)))\n\n    def _default_random_barcode(self):\n        barcode = None\n        while not barcode or self.env['hr.employee'].search([('barcode', '=', barcode)]):\n            barcode = \"\".join(choice(digits) for i in range(8))\n        return barcode\n\n    barcode = fields.Char(string=\"Badge ID\", help=\"ID used for employee identification.\", default=_default_random_barcode, copy=False)\n    pin = fields.Char(string=\"PIN\", default=_default_random_pin, help=\"PIN used to Check In/Out in Kiosk Mode (if enabled in Configuration).\", copy=False)\n\n    attendance_ids = fields.One2many('hr.attendance', 'employee_id', help='list of attendances for the employee')\n    last_attendance_id = fields.Many2one('hr.attendance', compute='_compute_last_attendance_id')\n    attendance_state = fields.Selection(string=\"Attendance\", compute='_compute_attendance_state', selection=[('checked_out', \"Checked out\"), ('checked_in', \"Checked in\")])\n    manual_attendance = fields.Boolean(string='Manual Attendance', compute='_compute_manual_attendance', inverse='_inverse_manual_attendance',\n                                       help='The employee will have access to the \"My Attendances\" menu to check in and out from his session')\n\n    _sql_constraints = [('barcode_uniq', 'unique (barcode)', \"The Badge ID must be unique, this one is already assigned to another employee.\")]\n\n    @api.multi\n    def _compute_manual_attendance(self):\n        for employee in self:\n            employee.manual_attendance = employee.user_id.has_group('hr_attendance.group_hr_attendance') if employee.user_id else False\n\n    @api.multi\n    def _inverse_manual_attendance(self):\n        manual_attendance_group = self.env.ref('hr_attendance.group_hr_attendance')\n        for employee in self:\n            if employee.user_id:\n                if employee.manual_attendance:\n                    manual_attendance_group.users = [(4, employee.user_id.id, 0)]\n                else:\n                    manual_attendance_group.users = [(3, employee.user_id.id, 0)]\n\n    @api.depends('attendance_ids')\n    def _compute_last_attendance_id(self):\n        for employee in self:\n            employee.last_attendance_id = employee.attendance_ids and employee.attendance_ids[0] or False\n\n    @api.depends('last_attendance_id.check_in', 'last_attendance_id.check_out', 'last_attendance_id')\n    def _compute_attendance_state(self):\n        for employee in self:\n            employee.attendance_state = employee.last_attendance_id and not employee.last_attendance_id.check_out and 'checked_in' or 'checked_out'\n\n    @api.constrains('pin')\n    def _verify_pin(self):\n        for employee in self:\n            if employee.pin and not employee.pin.isdigit():\n                raise exceptions.ValidationError(_(\"The PIN must be a sequence of digits.\"))\n\n    @api.model\n    def attendance_scan(self, barcode):\n        \"\"\" Receive a barcode scanned from the Kiosk Mode and change the attendances of corresponding employee.\n            Returns either an action or a warning.\n        \"\"\"\n        employee = self.search([('barcode', '=', barcode)], limit=1)\n        return employee and employee.attendance_action('hr_attendance.hr_attendance_action_kiosk_mode') or \\\n            {'warning': _('No employee corresponding to barcode %(barcode)s') % {'barcode': barcode}}\n\n    @api.multi\n    def attendance_manual(self, next_action, entered_pin=None):\n        self.ensure_one()\n        if not (entered_pin is None) or self.env['res.users'].browse(SUPERUSER_ID).has_group('hr_attendance.group_hr_attendance_use_pin') and (self.user_id and self.user_id.id != self._uid or not self.user_id):\n            if entered_pin != self.pin:\n                return {'warning': _('Wrong PIN')}\n        return self.attendance_action(next_action)\n\n    @api.multi\n    def attendance_action(self, next_action):\n        \"\"\" Changes the attendance of the employee.\n            Returns an action to the check in/out message,\n            next_action defines which menu the check in/out message should return to. (\"My Attendances\" or \"Kiosk Mode\")\n        \"\"\"\n        self.ensure_one()\n        action_message = self.env.ref('hr_attendance.hr_attendance_action_greeting_message').read()[0]\n        action_message['previous_attendance_change_date'] = self.last_attendance_id and (self.last_attendance_id.check_out or self.last_attendance_id.check_in) or False\n        action_message['employee_name'] = self.name\n        action_message['next_action'] = next_action\n\n        if self.user_id:\n            modified_attendance = self.sudo(self.user_id.id).attendance_action_change()\n        else:\n            modified_attendance = self.sudo().attendance_action_change()\n        action_message['attendance'] = modified_attendance.read()[0]\n        return {'action': action_message}\n\n    @api.multi\n    def attendance_action_change(self):\n        \"\"\" Check In/Check Out action\n            Check In: create a new attendance record\n            Check Out: modify check_out field of appropriate attendance record\n        \"\"\"\n        if len(self) > 1:\n            raise exceptions.UserError(_('Cannot perform check in or check out on multiple employees.'))\n        action_date = fields.Datetime.now()\n\n        if self.attendance_state != 'checked_in':\n            vals = {\n                'employee_id': self.id,\n                'check_in': action_date,\n            }\n            return self.env['hr.attendance'].create(vals)\n        else:\n            attendance = self.env['hr.attendance'].search([('employee_id', '=', self.id), ('check_out', '=', False)], limit=1)\n            if attendance:\n                attendance.check_out = action_date\n            else:\n                raise exceptions.UserError(_('Cannot perform check out on %(empl_name)s, could not find corresponding check in. '\n                    'Your attendances have probably been modified manually by human resources.') % {'empl_name': self.name, })\n            return attendance\n\n    @api.model_cr_context\n    def _init_column(self, column_name):\n        \"\"\" Initialize the value of the given column for existing rows.\n            Overridden here because we need to have different default values\n            for barcode and pin for every employee.\n        \"\"\"\n        if column_name not in [\"barcode\", \"pin\"]:\n            super(HrEmployee, self)._init_column(column_name)\n        else:\n            default_compute = self._fields[column_name].default\n\n            query = 'SELECT id FROM \"%s\" WHERE \"%s\" is NULL' % (\n                self._table, column_name)\n            self.env.cr.execute(query)\n            employee_ids = self.env.cr.fetchall()\n\n            for employee_id in employee_ids:\n                default_value = default_compute(self)\n\n                query = 'UPDATE \"%s\" SET \"%s\"=%%s WHERE id = %s' % (\n                    self._table, column_name, employee_id[0])\n                self.env.cr.execute(query, (default_value,))\n", "comments": "    receive barcode scanned kiosk mode change attendances corresponding employee              returns either action warning                      employee   self search( ( barcode        barcode)   limit 1)         return employee employee attendance action( hr attendance hr attendance action kiosk mode )                 warning    ( no employee corresponding barcode  (barcode)s )     barcode   barcode         api multi     def attendance manual(self  next action  entered pin none)          self ensure one()         (entered pin none) self env  res users   browse(superuser id) group( hr attendance group hr attendance use pin ) (self user id self user id id    self  uid self user id)              entered pin    self pin                  return   warning    ( wrong pin )          return self attendance action(next action)       api multi     def attendance action(self  next action)              changes attendance employee              returns action check message              next action defines menu check message return  ( my attendances   kiosk mode )                     self ensure one()         action message   self env ref( hr attendance hr attendance action greeting message ) read() 0          action message  previous attendance change date     self last attendance id (self last attendance id check self last attendance id check in) false         action message  employee name     self name         action message  next action     next action          self user id              modified attendance   self sudo(self user id id) attendance action change()         else              modified attendance   self sudo() attendance action change()         action message  attendance     modified attendance read() 0          return   action   action message        api multi     def attendance action change(self)              check in check out action             check in  create new attendance record             check out  modify check field appropriate attendance record                     len(self)   1              raise exceptions usererror( ( cannot perform check check multiple employees  ))         action date   fields datetime now()          self attendance state     checked               vals                      employee id   self id                   check   action date                            return self env  hr attendance   create(vals)         else              attendance   self env  hr attendance   search( ( employee id        self id)  ( check        false)   limit 1)             attendance                  attendance check   action date             else                  raise exceptions usererror( ( cannot perform check  (empl name)s  could find corresponding check                         your attendances probably modified manually human resources  )     empl name   self name   )             return attendance       api model cr context     def  init column(self  column name)              initialize value given column existing rows              overridden need different default values             barcode pin every employee                     coding  utf 8        part odoo  see license file full copyright licensing details  ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom random import choice\nfrom string import digits\n\nfrom odoo import models, fields, api, exceptions, _, SUPERUSER_ID\n\n\nclass HrEmployee(models.Model):\n    _inherit = \"hr.employee\"\n    _description = \"Employee\"\n\n    def _default_random_pin(self):\n        return (\"\".join(choice(digits) for i in range(4)))\n\n    def _default_random_barcode(self):\n        barcode = None\n        while not barcode or self.env['hr.employee'].search([('barcode', '=', barcode)]):\n            barcode = \"\".join(choice(digits) for i in range(8))\n        return barcode\n\n    barcode = fields.Char(string=\"Badge ID\", help=\"ID used for employee identification.\", default=_default_random_barcode, copy=False)\n    pin = fields.Char(string=\"PIN\", default=_default_random_pin, help=\"PIN used to Check In/Out in Kiosk Mode (if enabled in Configuration).\", copy=False)\n\n    attendance_ids = fields.One2many('hr.attendance', 'employee_id', help='list of attendances for the employee')\n    last_attendance_id = fields.Many2one('hr.attendance', compute='_compute_last_attendance_id')\n    attendance_state = fields.Selection(string=\"Attendance\", compute='_compute_attendance_state', selection=[('checked_out', \"Checked out\"), ('checked_in', \"Checked in\")])\n    manual_attendance = fields.Boolean(string='Manual Attendance', compute='_compute_manual_attendance', inverse='_inverse_manual_attendance',\n                                       help='The employee will have access to the \"My Attendances\" menu to check in and out from his session')\n\n    _sql_constraints = [('barcode_uniq', 'unique (barcode)', \"The Badge ID must be unique, this one is already assigned to another employee.\")]\n\n    @api.multi\n    def _compute_manual_attendance(self):\n        for employee in self:\n            employee.manual_attendance = employee.user_id.has_group('hr_attendance.group_hr_attendance') if employee.user_id else False\n\n    @api.multi\n    def _inverse_manual_attendance(self):\n        manual_attendance_group = self.env.ref('hr_attendance.group_hr_attendance')\n        for employee in self:\n            if employee.user_id:\n                if employee.manual_attendance:\n                    manual_attendance_group.users = [(4, employee.user_id.id, 0)]\n                else:\n                    manual_attendance_group.users = [(3, employee.user_id.id, 0)]\n\n    @api.depends('attendance_ids')\n    def _compute_last_attendance_id(self):\n        for employee in self:\n            employee.last_attendance_id = employee.attendance_ids and employee.attendance_ids[0] or False\n\n    @api.depends('last_attendance_id.check_in', 'last_attendance_id.check_out', 'last_attendance_id')\n    def _compute_attendance_state(self):\n        for employee in self:\n            employee.attendance_state = employee.last_attendance_id and not employee.last_attendance_id.check_out and 'checked_in' or 'checked_out'\n\n    @api.constrains('pin')\n    def _verify_pin(self):\n        for employee in self:\n            if employee.pin and not employee.pin.isdigit():\n                raise exceptions.ValidationError(_(\"The PIN must be a sequence of digits.\"))\n\n    @api.model\n    def attendance_scan(self, barcode):\n        \"\"\" Receive a barcode scanned from the Kiosk Mode and change the attendances of corresponding employee.\n            Returns either an action or a warning.\n        \"\"\"\n        employee = self.search([('barcode', '=', barcode)], limit=1)\n        return employee and employee.attendance_action('hr_attendance.hr_attendance_action_kiosk_mode') or \\\n            {'warning': _('No employee corresponding to barcode %(barcode)s') % {'barcode': barcode}}\n\n    @api.multi\n    def attendance_manual(self, next_action, entered_pin=None):\n        self.ensure_one()\n        if not (entered_pin is None) or self.env['res.users'].browse(SUPERUSER_ID).has_group('hr_attendance.group_hr_attendance_use_pin') and (self.user_id and self.user_id.id != self._uid or not self.user_id):\n            if entered_pin != self.pin:\n                return {'warning': _('Wrong PIN')}\n        return self.attendance_action(next_action)\n\n    @api.multi\n    def attendance_action(self, next_action):\n        \"\"\" Changes the attendance of the employee.\n            Returns an action to the check in/out message,\n            next_action defines which menu the check in/out message should return to. (\"My Attendances\" or \"Kiosk Mode\")\n        \"\"\"\n        self.ensure_one()\n        action_message = self.env.ref('hr_attendance.hr_attendance_action_greeting_message').read()[0]\n        action_message['previous_attendance_change_date'] = self.last_attendance_id and (self.last_attendance_id.check_out or self.last_attendance_id.check_in) or False\n        action_message['employee_name'] = self.name\n        action_message['next_action'] = next_action\n\n        if self.user_id:\n            modified_attendance = self.sudo(self.user_id.id).attendance_action_change()\n        else:\n            modified_attendance = self.sudo().attendance_action_change()\n        action_message['attendance'] = modified_attendance.read()[0]\n        return {'action': action_message}\n\n    @api.multi\n    def attendance_action_change(self):\n        \"\"\" Check In/Check Out action\n            Check In: create a new attendance record\n            Check Out: modify check_out field of appropriate attendance record\n        \"\"\"\n        if len(self) > 1:\n            raise exceptions.UserError(_('Cannot perform check in or check out on multiple employees.'))\n        action_date = fields.Datetime.now()\n\n        if self.attendance_state != 'checked_in':\n            vals = {\n                'employee_id': self.id,\n                'check_in': action_date,\n            }\n            return self.env['hr.attendance'].create(vals)\n        else:\n            attendance = self.env['hr.attendance'].search([('employee_id', '=', self.id), ('check_out', '=', False)], limit=1)\n            if attendance:\n                attendance.check_out = action_date\n            else:\n                raise exceptions.UserError(_('Cannot perform check out on %(empl_name)s, could not find corresponding check in. '\n                    'Your attendances have probably been modified manually by human resources.') % {'empl_name': self.name, })\n            return attendance\n\n    @api.model_cr_context\n    def _init_column(self, column_name):\n        \"\"\" Initialize the value of the given column for existing rows.\n            Overridden here because we need to have different default values\n            for barcode and pin for every employee.\n        \"\"\"\n        if column_name not in [\"barcode\", \"pin\"]:\n            super(HrEmployee, self)._init_column(column_name)\n        else:\n            default_compute = self._fields[column_name].default\n\n            query = 'SELECT id FROM \"%s\" WHERE \"%s\" is NULL' % (\n                self._table, column_name)\n            self.env.cr.execute(query)\n            employee_ids = self.env.cr.fetchall()\n\n            for employee_id in employee_ids:\n                default_value = default_compute(self)\n\n                query = 'UPDATE \"%s\" SET \"%s\"=%%s WHERE id = %s' % (\n                    self._table, column_name, employee_id[0])\n                self.env.cr.execute(query, (default_value,))\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "hr_employee.py", "id": "cb92119ea284ccaa5684e47e56a77819", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/hr_attendance/models/hr_employee.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}