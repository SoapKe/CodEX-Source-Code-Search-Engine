{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\nimport logging\nfrom passlib.context import CryptContext\n\nimport odoo\nfrom odoo import api, fields, models\n\nfrom odoo.addons.base.res import res_users\nres_users.USER_PRIVATE_FIELDS.append('password_crypt')\n\n_logger = logging.getLogger(__name__)\n\ndefault_crypt_context = CryptContext(\n    \n    \n    ['pbkdf2_sha512', 'md5_crypt'],\n    \n    \n    \n    \n    deprecated=['md5_crypt'],\n)\n\n\nclass ResUsers(models.Model):\n    _inherit = \"res.users\"\n\n    def init(self):\n        _logger.info(\"Hashing passwords, may be slow for databases with many users...\")\n        self.env.cr.execute(\"SELECT id, password FROM res_users\"\n                   \" WHERE password IS NOT NULL\"\n                   \"   AND password != ''\")\n        for uid, pwd in self.env.cr.fetchall():\n            self.sudo().browse(uid)._set_password(pwd)\n\n    password = fields.Char(compute='_compute_password', inverse='_inverse_password', invisible=True, store=True)\n    password_crypt = fields.Char(string='Encrypted Password', invisible=True, copy=False)\n\n    def _compute_password(self):\n        self.env.cr.execute('SELECT id, password FROM res_users WHERE id IN %s', [tuple(self.ids)])\n        password_dict = dict(self.env.cr.fetchall())\n        for user in self:\n            user.password = password_dict[user.id]\n\n    def _inverse_password(self):\n        for user in self:\n            user._set_password(user.password)\n            self.invalidate_cache()\n\n    @api.model\n    def check_credentials(self, password):\n        \n        self.env.cr.execute('SELECT password, password_crypt FROM res_users WHERE id=%s AND active', (self.env.uid,))\n        encrypted = None\n        user = self.env.user\n        if self.env.cr.rowcount:\n            stored, encrypted = self.env.cr.fetchone()\n            if stored and not encrypted:\n                user._set_password(stored)\n                self.invalidate_cache()\n        try:\n            return super(ResUsers, self).check_credentials(password)\n        except odoo.exceptions.AccessDenied:\n            if encrypted:\n                valid_pass, replacement = user._crypt_context()\\\n                        .verify_and_update(password, encrypted)\n                if replacement is not None:\n                    user._set_encrypted_password(replacement)\n                if valid_pass:\n                    return\n            raise\n\n    def _set_password(self, password):\n        self.ensure_one()\n        \"\"\" Encrypts then stores the provided plaintext password for the user\n        ``self``\n        \"\"\"\n        encrypted = self._crypt_context().encrypt(password)\n        self._set_encrypted_password(encrypted)\n\n    def _set_encrypted_password(self, encrypted):\n        \"\"\" Store the provided encrypted password to the database, and clears\n        any plaintext password\n        \"\"\"\n        self.env.cr.execute(\n            \"UPDATE res_users SET password='', password_crypt=%s WHERE id=%s\",\n            (encrypted, self.id))\n\n    def _crypt_context(self):\n        \"\"\" Passlib CryptContext instance used to encrypt and verify\n        passwords. Can be overridden if technical, legal or political matters\n        require different kdfs than the provided default.\n\n        Requires a CryptContext as deprecation and upgrade notices are used\n        internally\n        \"\"\"\n        return default_crypt_context\n", "comments": "    encrypts stores provided plaintext password user           self                       encrypted   self  crypt context() encrypt(password)         self  set encrypted password(encrypted)      def  set encrypted password(self  encrypted)              store provided encrypted password database  clears         plaintext password                     self env cr execute(              update res users set password     password crypt  where id                (encrypted  self id))      def  crypt context(self)              passlib cryptcontext instance used encrypt verify         passwords  can overridden technical  legal political matters         require different kdfs provided default           requires cryptcontext deprecation upgrade notices used         internally                    coding  utf 8        kdf verified context  the default encryption kdf    first list    deprecated algorithms still verified usual    needs update      indicate stored hash replaced recent    algorithm  passlib 1 6 supports  auto  value deprecates    algorithm default  ubuntu lts provides 1 5 far     convert base crypt needed ", "content": "# -*- coding: utf-8 -*-\n\nimport logging\nfrom passlib.context import CryptContext\n\nimport odoo\nfrom odoo import api, fields, models\n\nfrom odoo.addons.base.res import res_users\nres_users.USER_PRIVATE_FIELDS.append('password_crypt')\n\n_logger = logging.getLogger(__name__)\n\ndefault_crypt_context = CryptContext(\n    # kdf which can be verified by the context. The default encryption kdf is\n    # the first of the list\n    ['pbkdf2_sha512', 'md5_crypt'],\n    # deprecated algorithms are still verified as usual, but ``needs_update``\n    # will indicate that the stored hash should be replaced by a more recent\n    # algorithm. Passlib 1.6 supports an `auto` value which deprecates any\n    # algorithm but the default, but Ubuntu LTS only provides 1.5 so far.\n    deprecated=['md5_crypt'],\n)\n\n\nclass ResUsers(models.Model):\n    _inherit = \"res.users\"\n\n    def init(self):\n        _logger.info(\"Hashing passwords, may be slow for databases with many users...\")\n        self.env.cr.execute(\"SELECT id, password FROM res_users\"\n                   \" WHERE password IS NOT NULL\"\n                   \"   AND password != ''\")\n        for uid, pwd in self.env.cr.fetchall():\n            self.sudo().browse(uid)._set_password(pwd)\n\n    password = fields.Char(compute='_compute_password', inverse='_inverse_password', invisible=True, store=True)\n    password_crypt = fields.Char(string='Encrypted Password', invisible=True, copy=False)\n\n    def _compute_password(self):\n        self.env.cr.execute('SELECT id, password FROM res_users WHERE id IN %s', [tuple(self.ids)])\n        password_dict = dict(self.env.cr.fetchall())\n        for user in self:\n            user.password = password_dict[user.id]\n\n    def _inverse_password(self):\n        for user in self:\n            user._set_password(user.password)\n            self.invalidate_cache()\n\n    @api.model\n    def check_credentials(self, password):\n        # convert to base_crypt if needed\n        self.env.cr.execute('SELECT password, password_crypt FROM res_users WHERE id=%s AND active', (self.env.uid,))\n        encrypted = None\n        user = self.env.user\n        if self.env.cr.rowcount:\n            stored, encrypted = self.env.cr.fetchone()\n            if stored and not encrypted:\n                user._set_password(stored)\n                self.invalidate_cache()\n        try:\n            return super(ResUsers, self).check_credentials(password)\n        except odoo.exceptions.AccessDenied:\n            if encrypted:\n                valid_pass, replacement = user._crypt_context()\\\n                        .verify_and_update(password, encrypted)\n                if replacement is not None:\n                    user._set_encrypted_password(replacement)\n                if valid_pass:\n                    return\n            raise\n\n    def _set_password(self, password):\n        self.ensure_one()\n        \"\"\" Encrypts then stores the provided plaintext password for the user\n        ``self``\n        \"\"\"\n        encrypted = self._crypt_context().encrypt(password)\n        self._set_encrypted_password(encrypted)\n\n    def _set_encrypted_password(self, encrypted):\n        \"\"\" Store the provided encrypted password to the database, and clears\n        any plaintext password\n        \"\"\"\n        self.env.cr.execute(\n            \"UPDATE res_users SET password='', password_crypt=%s WHERE id=%s\",\n            (encrypted, self.id))\n\n    def _crypt_context(self):\n        \"\"\" Passlib CryptContext instance used to encrypt and verify\n        passwords. Can be overridden if technical, legal or political matters\n        require different kdfs than the provided default.\n\n        Requires a CryptContext as deprecation and upgrade notices are used\n        internally\n        \"\"\"\n        return default_crypt_context\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "res_users.py", "id": "f50bf85fc48f300e1e0bb8d234b4f0ff", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/auth_crypt/models/res_users.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}