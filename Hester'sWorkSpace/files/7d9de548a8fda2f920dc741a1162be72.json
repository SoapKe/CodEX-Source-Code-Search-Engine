{"author": "rg3", "code": "\n\n\nfrom __future__ import unicode_literals\n\nimport base64\nimport binascii\nimport calendar\nimport codecs\nimport contextlib\nimport ctypes\nimport datetime\nimport email.utils\nimport email.header\nimport errno\nimport functools\nimport gzip\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport socket\nimport ssl\nimport subprocess\nimport sys\nimport tempfile\nimport traceback\nimport xml.etree.ElementTree\nimport zlib\n\nfrom .compat import (\n    compat_HTMLParseError,\n    compat_HTMLParser,\n    compat_basestring,\n    compat_chr,\n    compat_ctypes_WINFUNCTYPE,\n    compat_etree_fromstring,\n    compat_expanduser,\n    compat_html_entities,\n    compat_html_entities_html5,\n    compat_http_client,\n    compat_kwargs,\n    compat_os_name,\n    compat_parse_qs,\n    compat_shlex_quote,\n    compat_socket_create_connection,\n    compat_str,\n    compat_struct_pack,\n    compat_struct_unpack,\n    compat_urllib_error,\n    compat_urllib_parse,\n    compat_urllib_parse_urlencode,\n    compat_urllib_parse_urlparse,\n    compat_urllib_parse_unquote_plus,\n    compat_urllib_request,\n    compat_urlparse,\n    compat_xpath,\n)\n\nfrom .socks import (\n    ProxyType,\n    sockssocket,\n)\n\n\ndef register_socks_protocols():\n    \n    \n    \n    for scheme in ('socks', 'socks4', 'socks4a', 'socks5'):\n        if scheme not in compat_urlparse.uses_netloc:\n            compat_urlparse.uses_netloc.append(scheme)\n\n\n\ncompiled_regex_type = type(re.compile(''))\n\nstd_headers = {\n    'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:59.0) Gecko/20100101 Firefox/59.0 (Chrome)',\n    'Accept-Charset': 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',\n    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n    'Accept-Encoding': 'gzip, deflate',\n    'Accept-Language': 'en-us,en;q=0.5',\n}\n\n\nUSER_AGENTS = {\n    'Safari': 'Mozilla/5.0 (X11; Linux x86_64; rv:10.0) AppleWebKit/533.20.25 (KHTML, like Gecko) Version/5.0.4 Safari/533.20.27',\n}\n\n\nNO_DEFAULT = object()\n\nENGLISH_MONTH_NAMES = [\n    'January', 'February', 'March', 'April', 'May', 'June',\n    'July', 'August', 'September', 'October', 'November', 'December']\n\nMONTH_NAMES = {\n    'en': ENGLISH_MONTH_NAMES,\n    'fr': [\n        'janvier', 'f\u00e9vrier', 'mars', 'avril', 'mai', 'juin',\n        'juillet', 'ao\u00fbt', 'septembre', 'octobre', 'novembre', 'd\u00e9cembre'],\n}\n\nKNOWN_EXTENSIONS = (\n    'mp4', 'm4a', 'm4p', 'm4b', 'm4r', 'm4v', 'aac',\n    'flv', 'f4v', 'f4a', 'f4b',\n    'webm', 'ogg', 'ogv', 'oga', 'ogx', 'spx', 'opus',\n    'mkv', 'mka', 'mk3d',\n    'avi', 'divx',\n    'mov',\n    'asf', 'wmv', 'wma',\n    '3gp', '3g2',\n    'mp3',\n    'flac',\n    'ape',\n    'wav',\n    'f4f', 'f4m', 'm3u8', 'smil')\n\n\nACCENT_CHARS = dict(zip('\u00c2\u00c3\u00c4\u00c0\u00c1\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u0150\u00d8\u0152\u00d9\u00da\u00db\u00dc\u0170\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u0151\u00f8\u0153\u00f9\u00fa\u00fb\u00fc\u0171\u00fd\u00fe\u00ff',\n                        itertools.chain('AAAAAA', ['AE'], 'CEEEEIIIIDNOOOOOOO', ['OE'], 'UUUUUYP', ['ss'],\n                                        'aaaaaa', ['ae'], 'ceeeeiiiionooooooo', ['oe'], 'uuuuuypy')))\n\nDATE_FORMATS = (\n    '%d %B %Y',\n    '%d %b %Y',\n    '%B %d %Y',\n    '%B %dst %Y',\n    '%B %dnd %Y',\n    '%B %dth %Y',\n    '%b %d %Y',\n    '%b %dst %Y',\n    '%b %dnd %Y',\n    '%b %dth %Y',\n    '%b %dst %Y %I:%M',\n    '%b %dnd %Y %I:%M',\n    '%b %dth %Y %I:%M',\n    '%Y %m %d',\n    '%Y-%m-%d',\n    '%Y/%m/%d',\n    '%Y/%m/%d %H:%M',\n    '%Y/%m/%d %H:%M:%S',\n    '%Y-%m-%d %H:%M',\n    '%Y-%m-%d %H:%M:%S',\n    '%Y-%m-%d %H:%M:%S.%f',\n    '%d.%m.%Y %H:%M',\n    '%d.%m.%Y %H.%M',\n    '%Y-%m-%dT%H:%M:%SZ',\n    '%Y-%m-%dT%H:%M:%S.%fZ',\n    '%Y-%m-%dT%H:%M:%S.%f0Z',\n    '%Y-%m-%dT%H:%M:%S',\n    '%Y-%m-%dT%H:%M:%S.%f',\n    '%Y-%m-%dT%H:%M',\n    '%b %d %Y at %H:%M',\n    '%b %d %Y at %H:%M:%S',\n    '%B %d %Y at %H:%M',\n    '%B %d %Y at %H:%M:%S',\n)\n\nDATE_FORMATS_DAY_FIRST = list(DATE_FORMATS)\nDATE_FORMATS_DAY_FIRST.extend([\n    '%d-%m-%Y',\n    '%d.%m.%Y',\n    '%d.%m.%y',\n    '%d/%m/%Y',\n    '%d/%m/%y',\n    '%d/%m/%Y %H:%M:%S',\n])\n\nDATE_FORMATS_MONTH_FIRST = list(DATE_FORMATS)\nDATE_FORMATS_MONTH_FIRST.extend([\n    '%m-%d-%Y',\n    '%m.%d.%Y',\n    '%m/%d/%Y',\n    '%m/%d/%y',\n    '%m/%d/%Y %H:%M:%S',\n])\n\nPACKED_CODES_RE = r\"}\\('(.+)',(\\d+),(\\d+),'([^']+)'\\.split\\('\\|'\\)\"\n\n\ndef preferredencoding():\n    \n    if len(data) > length - 11:\n        raise ValueError('Input data too long for PKCS\n\n    pseudo_random = [random.randint(0, 254) for _ in range(length - len(data) - 3)]\n    return [0, 2] + pseudo_random + [0] + data\n\n\ndef encode_base_n(num, n, table=None):\n    FULL_TABLE = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    if not table:\n        table = FULL_TABLE[:n]\n\n    if n > len(table):\n        raise ValueError('base %d exceeds table length %d' % (n, len(table)))\n\n    if num == 0:\n        return table[0]\n\n    ret = ''\n    while num:\n        ret = table[num % n] + ret\n        num = num // n\n    return ret\n\n\ndef decode_packed_codes(code):\n    mobj = re.search(PACKED_CODES_RE, code)\n    obfucasted_code, base, count, symbols = mobj.groups()\n    base = int(base)\n    count = int(count)\n    symbols = symbols.split('|')\n    symbol_table = {}\n\n    while count:\n        count -= 1\n        base_n_count = encode_base_n(count, base)\n        symbol_table[base_n_count] = symbols[count] or base_n_count\n\n    return re.sub(\n        r'\\b(\\w+)\\b', lambda mobj: symbol_table[mobj.group(0)],\n        obfucasted_code)\n\n\ndef parse_m3u8_attributes(attrib):\n    info = {}\n    for (key, val) in re.findall(r'(?P<key>[A-Z0-9-]+)=(?P<val>\"[^\"]+\"|[^\",]+)(?:,|$)', attrib):\n        if val.startswith('\"'):\n            val = val[1:-1]\n        info[key] = val\n    return info\n\n\ndef urshift(val, n):\n    return val >> n if val >= 0 else (val + 0x100000000) >> n\n\n\n\n\ndef decode_png(png_data):\n    \n    header = png_data[8:]\n\n    if png_data[:8] != b'\\x89PNG\\x0d\\x0a\\x1a\\x0a' or header[4:8] != b'IHDR':\n        raise IOError('Not a valid PNG file.')\n\n    int_map = {1: '>B', 2: '>H', 4: '>I'}\n    unpack_integer = lambda x: compat_struct_unpack(int_map[len(x)], x)[0]\n\n    chunks = []\n\n    while header:\n        length = unpack_integer(header[:4])\n        header = header[4:]\n\n        chunk_type = header[:4]\n        header = header[4:]\n\n        chunk_data = header[:length]\n        header = header[length:]\n\n        header = header[4:]  \n\n        chunks.append({\n            'type': chunk_type,\n            'length': length,\n            'data': chunk_data\n        })\n\n    ihdr = chunks[0]['data']\n\n    width = unpack_integer(ihdr[:4])\n    height = unpack_integer(ihdr[4:8])\n\n    idat = b''\n\n    for chunk in chunks:\n        if chunk['type'] == b'IDAT':\n            idat += chunk['data']\n\n    if not idat:\n        raise IOError('Unable to read PNG data.')\n\n    decompressed_data = bytearray(zlib.decompress(idat))\n\n    stride = width * 3\n    pixels = []\n\n    def _get_pixel(idx):\n        x = idx % stride\n        y = idx // stride\n        return pixels[y][x]\n\n    for y in range(height):\n        basePos = y * (1 + stride)\n        filter_type = decompressed_data[basePos]\n\n        current_row = []\n\n        pixels.append(current_row)\n\n        for x in range(stride):\n            color = decompressed_data[1 + basePos + x]\n            basex = y * stride + x\n            left = 0\n            up = 0\n\n            if x > 2:\n                left = _get_pixel(basex - 3)\n            if y > 0:\n                up = _get_pixel(basex - stride)\n\n            if filter_type == 1:  \n                color = (color + left) & 0xff\n            elif filter_type == 2:  \n                color = (color + up) & 0xff\n            elif filter_type == 3:  \n                color = (color + ((left + up) >> 1)) & 0xff\n            elif filter_type == 4:  \n                a = left\n                b = up\n                c = 0\n\n                if x > 2 and y > 0:\n                    c = _get_pixel(basex - stride - 3)\n\n                p = a + b - c\n\n                pa = abs(p - a)\n                pb = abs(p - b)\n                pc = abs(p - c)\n\n                if pa <= pb and pa <= pc:\n                    color = (color + a) & 0xff\n                elif pb <= pc:\n                    color = (color + b) & 0xff\n                else:\n                    color = (color + c) & 0xff\n\n            current_row.append(color)\n\n    return width, height, pixels\n\n\ndef write_xattr(path, key, value):\n    \n    try:\n        \n        import xattr\n\n        if hasattr(xattr, 'set'):  \n            \n            \n            \n            pyxattr_required_version = '0.5.0'\n            if version_tuple(xattr.__version__) < version_tuple(pyxattr_required_version):\n                \n                raise XAttrUnavailableError(\n                    'python-pyxattr is detected but is too old. '\n                    'youtube-dl requires %s or above while your version is %s. '\n                    'Falling back to other xattr implementations' % (\n                        pyxattr_required_version, xattr.__version__))\n\n            setxattr = xattr.set\n        else:  \n            setxattr = xattr.setxattr\n\n        try:\n            setxattr(path, key, value)\n        except EnvironmentError as e:\n            raise XAttrMetadataError(e.errno, e.strerror)\n\n    except ImportError:\n        if compat_os_name == 'nt':\n            \n            \n            assert ':' not in key\n            assert os.path.exists(path)\n\n            ads_fn = path + ':' + key\n            try:\n                with open(ads_fn, 'wb') as f:\n                    f.write(value)\n            except EnvironmentError as e:\n                raise XAttrMetadataError(e.errno, e.strerror)\n        else:\n            user_has_setfattr = check_executable('setfattr', ['--version'])\n            user_has_xattr = check_executable('xattr', ['-h'])\n\n            if user_has_setfattr or user_has_xattr:\n\n                value = value.decode('utf-8')\n                if user_has_setfattr:\n                    executable = 'setfattr'\n                    opts = ['-n', key, '-v', value]\n                elif user_has_xattr:\n                    executable = 'xattr'\n                    opts = ['-w', key, value]\n\n                cmd = ([encodeFilename(executable, True)] +\n                       [encodeArgument(o) for o in opts] +\n                       [encodeFilename(path, True)])\n\n                try:\n                    p = subprocess.Popen(\n                        cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n                except EnvironmentError as e:\n                    raise XAttrMetadataError(e.errno, e.strerror)\n                stdout, stderr = p.communicate()\n                stderr = stderr.decode('utf-8', 'replace')\n                if p.returncode != 0:\n                    raise XAttrMetadataError(p.returncode, stderr)\n\n            else:\n                \n                if sys.platform.startswith('linux'):\n                    raise XAttrUnavailableError(\n                        \"Couldn't find a tool to set the xattrs. \"\n                        \"Install either the python 'pyxattr' or 'xattr' \"\n                        \"modules, or the GNU 'attr' package \"\n                        \"(which contains the 'setfattr' tool).\")\n                else:\n                    raise XAttrUnavailableError(\n                        \"Couldn't find a tool to set the xattrs. \"\n                        \"Install either the python 'xattr' module, \"\n                        \"or the 'xattr' binary.\")\n\n\ndef random_birthday(year_field, month_field, day_field):\n    return {\n        year_field: str(random.randint(1950, 1995)),\n        month_field: str(random.randint(1, 12)),\n        day_field: str(random.randint(1, 31)),\n    }\n", "comments": "Get preferred encoding.\n\n    Returns the best encoding scheme for the system, based on\n    locale.getpreferredencoding() and some further tweaks.\n    \"\"\"\n    try:\n        pref = locale.getpreferredencoding()\n        'TEST'.encode(pref)\n    except Exception:\n        pref = 'UTF-8'\n\n    return pref\n\n\ndef write_json_file(obj, fn):\n    \"\"\" Encode obj as JSON and write it to fn, atomically if possible \"\"\"\n\n    fn = encodeFilename(fn)\n    if sys.version_info < (3, 0) and sys.platform != 'win32':\n        encoding = get_filesystem_encoding()\n        # os.path.basename returns a bytes object, but NamedTemporaryFile\n        # will fail if the filename contains non ascii characters unless we\n        # use a unicode object\n        path_basename = lambda f: os.path.basename(fn).decode(encoding)\n        # the same for os.path.dirname\n        path_dirname = lambda f: os.path.dirname(fn).decode(encoding)\n    else:\n        path_basename = os.path.basename\n        path_dirname = os.path.dirname\n\n    args = {\n        'suffix': '.tmp',\n        'prefix': path_basename(fn) + '.',\n        'dir': path_dirname(fn),\n        'delete': False,\n    }\n\n    # In Python 2.x, json.dump expects a bytestream.\n    # In Python 3.x, it writes to a character stream\n    if sys.version_info < (3, 0):\n        args['mode'] = 'wb'\n    else:\n        args.update({\n            'mode': 'w',\n            'encoding': 'utf-8',\n        })\n\n    tf = tempfile.NamedTemporaryFile(**compat_kwargs(args))\n\n    try:\n        with tf:\n            json.dump(obj, tf)\n        if sys.platform == 'win32':\n            # Need to remove existing file on Windows, else os.rename raises\n            # WindowsError or FileExistsError.\n            try:\n                os.unlink(fn)\n            except OSError:\n                pass\n        os.rename(tf.name, fn)\n    except Exception:\n        try:\n            os.remove(tf.name)\n        except OSError:\n            pass\n        raise\n\n\nif sys.version_info >= (2, 7):\n    def find_xpath_attr(node, xpath, key, val=None):\n        \"\"\" Find the xpath xpath[@key=val] \"\"\"\n        assert re.match(r'^[a-zA-Z_-]+$', key)\n        expr = xpath + ('[@%s]' % key if val is None else \"[@%s='%s']\" % (key, val))\n        return node.find(expr)\nelse:\n    def find_xpath_attr(node, xpath, key, val=None):\n        for f in node.findall(compat_xpath(xpath)):\n            if key not in f.attrib:\n                continue\n            if val is None or f.attrib.get(key) == val:\n                return f\n        return None\n\n# On python2.6 the xml.etree.ElementTree.Element methods don't support\n# the namespace parameter\n\n\ndef xpath_with_ns(path, ns_map):\n    components = [c.split(':') for c in path.split('/')]\n    replaced = []\n    for c in components:\n        if len(c) == 1:\n            replaced.append(c[0])\n        else:\n            ns, tag = c\n            replaced.append('{%s}%s' % (ns_map[ns], tag))\n    return '/'.join(replaced)\n\n\ndef xpath_element(node, xpath, name=None, fatal=False, default=NO_DEFAULT):\n    def _find_xpath(xpath):\n        return node.find(compat_xpath(xpath))\n\n    if isinstance(xpath, (str, compat_str)):\n        n = _find_xpath(xpath)\n    else:\n        for xp in xpath:\n            n = _find_xpath(xp)\n            if n is not None:\n                break\n\n    if n is None:\n        if default is not NO_DEFAULT:\n            return default\n        elif fatal:\n            name = xpath if name is None else name\n            raise ExtractorError('Could not find XML element %s' % name)\n        else:\n            return None\n    return n\n\n\ndef xpath_text(node, xpath, name=None, fatal=False, default=NO_DEFAULT):\n    n = xpath_element(node, xpath, name, fatal=fatal, default=default)\n    if n is None or n == default:\n        return n\n    if n.text is None:\n        if default is not NO_DEFAULT:\n            return default\n        elif fatal:\n            name = xpath if name is None else name\n            raise ExtractorError('Could not find XML element\\'s text %s' % name)\n        else:\n            return None\n    return n.text\n\n\ndef xpath_attr(node, xpath, key, name=None, fatal=False, default=NO_DEFAULT):\n    n = find_xpath_attr(node, xpath, key)\n    if n is None:\n        if default is not NO_DEFAULT:\n            return default\n        elif fatal:\n            name = '%s[@%s]' % (xpath, key) if name is None else name\n            raise ExtractorError('Could not find XML attribute %s' % name)\n        else:\n            return None\n    return n.attrib[key]\n\n\ndef get_element_by_id(id, html):\n    \"\"\"Return the content of the tag with the specified ID in the passed HTML document\"\"\"\n    return get_element_by_attribute('id', id, html)\n\n\ndef get_element_by_class(class_name, html):\n    \"\"\"Return the content of the first tag with the specified class in the passed HTML document\"\"\"\n    retval = get_elements_by_class(class_name, html)\n    return retval[0] if retval else None\n\n\ndef get_element_by_attribute(attribute, value, html, escape_value=True):\n    retval = get_elements_by_attribute(attribute, value, html, escape_value)\n    return retval[0] if retval else None\n\n\ndef get_elements_by_class(class_name, html):\n    \"\"\"Return the content of all tags with the specified class in the passed HTML document as a list\"\"\"\n    return get_elements_by_attribute(\n        'class', r'[^\\'\"]*\\b%s\\b[^\\'\"]*' % re.escape(class_name),\n        html, escape_value=False)\n\n\ndef get_elements_by_attribute(attribute, value, html, escape_value=True):\n    \"\"\"Return the content of the tag with the specified attribute in the passed HTML document\"\"\"\n\n    value = re.escape(value) if escape_value else value\n\n    retlist = []\n    for m in re.finditer(r'''(?xs)\n        <([a-zA-Z0-9:._-]+)\n         (?:\\s+[a-zA-Z0-9:._-]+(?:=[a-zA-Z0-9:._-]*|=\"[^\"]*\"|='[^']*'|))*?\n         \\s+%s=['\"]?%s['\"]?\n         (?:\\s+[a-zA-Z0-9:._-]+(?:=[a-zA-Z0-9:._-]*|=\"[^\"]*\"|='[^']*'|))*?\n        \\s*>\n        (?P<content>.*?)\n        </\\1>\n    ''' % (re.escape(attribute), value), html):\n        res = m.group('content')\n\n        if res.startswith('\"') or res.startswith(\"'\"):\n            res = res[1:-1]\n\n        retlist.append(unescapeHTML(res))\n\n    return retlist\n\n\nclass HTMLAttributeParser(compat_HTMLParser):\n    \"\"\"Trivial HTML parser to gather the attributes for a single element\"\"\"\n    def __init__(self):\n        self.attrs = {}\n        compat_HTMLParser.__init__(self)\n\n    def handle_starttag(self, tag, attrs):\n        self.attrs = dict(attrs)\n\n\ndef extract_attributes(html_element):\n    \"\"\"Given a string for an HTML element such as\n    <el\n         a=\"foo\" B=\"bar\" c=\"&98;az\" d=boz\n         empty= noval entity=\"&amp;\"\n         sq='\"' dq=\"'\"\n    >\n    Decode and return a dictionary of attributes.\n    {\n        'a': 'foo', 'b': 'bar', c: 'baz', d: 'boz',\n        'empty': '', 'noval': None, 'entity': '&',\n        'sq': '\"', 'dq': '\\''\n    }.\n    NB HTMLParser is stricter in Python 2.6 & 3.2 than in later versions,\n    but the cases in the unit test will work for all of 2.6, 2.7, 3.2-3.5.\n    \"\"\"\n    parser = HTMLAttributeParser()\n    try:\n        parser.feed(html_element)\n        parser.close()\n    # Older Python may throw HTMLParseError in case of malformed HTML\n    except compat_HTMLParseError:\n        pass\n    return parser.attrs\n\n\ndef clean_html(html):\n    \"\"\"Clean an HTML snippet into a readable string\"\"\"\n\n    if html is None:  # Convenience for sanitizing descriptions etc.\n        return html\n\n    # Newline vs <br />\n    html = html.replace('\\n', ' ')\n    html = re.sub(r'(?u)\\s*<\\s*br\\s*/?\\s*>\\s*', '\\n', html)\n    html = re.sub(r'(?u)<\\s*/\\s*p\\s*>\\s*<\\s*p[^>]*>', '\\n', html)\n    # Strip html tags\n    html = re.sub('<.*?>', '', html)\n    # Replace html entities\n    html = unescapeHTML(html)\n    return html.strip()\n\n\ndef sanitize_open(filename, open_mode):\n    \"\"\"Try to open the given filename, and slightly tweak it if this fails.\n\n    Attempts to open the given filename. If this fails, it tries to change\n    the filename slightly, step by step, until it's either able to open it\n    or it fails and raises a final exception, like the standard open()\n    function.\n\n    It returns the tuple (stream, definitive_file_name).\n    \"\"\"\n    try:\n        if filename == '-':\n            if sys.platform == 'win32':\n                import msvcrt\n                msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)\n            return (sys.stdout.buffer if hasattr(sys.stdout, 'buffer') else sys.stdout, filename)\n        stream = open(encodeFilename(filename), open_mode)\n        return (stream, filename)\n    except (IOError, OSError) as err:\n        if err.errno in (errno.EACCES,):\n            raise\n\n        # In case of error, try to remove win32 forbidden chars\n        alt_filename = sanitize_path(filename)\n        if alt_filename == filename:\n            raise\n        else:\n            # An exception here should be caught in the caller\n            stream = open(encodeFilename(alt_filename), open_mode)\n            return (stream, alt_filename)\n\n\ndef timeconvert(timestr):\n    \"\"\"Convert RFC 2822 defined time string into system timestamp\"\"\"\n    timestamp = None\n    timetuple = email.utils.parsedate_tz(timestr)\n    if timetuple is not None:\n        timestamp = email.utils.mktime_tz(timetuple)\n    return timestamp\n\n\ndef sanitize_filename(s, restricted=False, is_id=False):\n    \"\"\"Sanitizes a string so it could be used as part of a filename.\n    If restricted is set, use a stricter subset of allowed characters.\n    Set is_id if this is not an arbitrary string, but an ID that should be kept\n    if possible.\n    \"\"\"\n    def replace_insane(char):\n        if restricted and char in ACCENT_CHARS:\n            return ACCENT_CHARS[char]\n        if char == '?' or ord(char) < 32 or ord(char) == 127:\n            return ''\n        elif char == '\"':\n            return '' if restricted else '\\''\n        elif char == ':':\n            return '_-' if restricted else ' -'\n        elif char in '\\\\/|*<>':\n            return '_'\n        if restricted and (char in '!&\\'()[]{}$;`^,#' or char.isspace()):\n            return '_'\n        if restricted and ord(char) > 127:\n            return '_'\n        return char\n\n    # Handle timestamps\n    s = re.sub(r'[0-9]+(?::[0-9]+)+', lambda m: m.group(0).replace(':', '_'), s)\n    result = ''.join(map(replace_insane, s))\n    if not is_id:\n        while '__' in result:\n            result = result.replace('__', '_')\n        result = result.strip('_')\n        # Common case of \"Foreign band name - English song title\"\n        if restricted and result.startswith('-_'):\n            result = result[2:]\n        if result.startswith('-'):\n            result = '_' + result[len('-'):]\n        result = result.lstrip('.')\n        if not result:\n            result = '_'\n    return result\n\n\ndef sanitize_path(s):\n    \"\"\"Sanitizes and normalizes path on Windows\"\"\"\n    if sys.platform != 'win32':\n        return s\n    drive_or_unc, _ = os.path.splitdrive(s)\n    if sys.version_info < (2, 7) and not drive_or_unc:\n        drive_or_unc, _ = os.path.splitunc(s)\n    norm_path = os.path.normpath(remove_start(s, drive_or_unc)).split(os.path.sep)\n    if drive_or_unc:\n        norm_path.pop(0)\n    sanitized_path = [\n        path_part if path_part in ['.', '..'] else re.sub(r'(?:[/<>:\"\\|\\\\?\\*]|[\\s.]$)', '#', path_part)\n        for path_part in norm_path]\n    if drive_or_unc:\n        sanitized_path.insert(0, drive_or_unc + os.path.sep)\n    return os.path.join(*sanitized_path)\n\n\ndef sanitize_url(url):\n    # Prepend protocol-less URLs with `http:` scheme in order to mitigate\n    # the number of unwanted failures due to missing protocol\n    if url.startswith('//'):\n        return 'http:%s' % url\n    # Fix some common typos seen so far\n    COMMON_TYPOS = (\n        # https://github.com/rg3/youtube-dl/issues/15649\n        (r'^httpss://', r'https://'),\n        # https://bx1.be/lives/direct-tv/\n        (r'^rmtp([es]?)://', r'rtmp\\1://'),\n    )\n    for mistake, fixup in COMMON_TYPOS:\n        if re.match(mistake, url):\n            return re.sub(mistake, fixup, url)\n    return url\n\n\ndef sanitized_Request(url, *args, **kwargs):\n    return compat_urllib_request.Request(sanitize_url(url), *args, **kwargs)\n\n\ndef expand_path(s):\n    \"\"\"Expand shell variables and ~\"\"\"\n    return os.path.expandvars(compat_expanduser(s))\n\n\ndef orderedSet(iterable):\n    \"\"\" Remove all duplicates from the input iterable \"\"\"\n    res = []\n    for el in iterable:\n        if el not in res:\n            res.append(el)\n    return res\n\n\ndef _htmlentity_transform(entity_with_semicolon):\n    \"\"\"Transforms an HTML entity to a character.\"\"\"\n    entity = entity_with_semicolon[:-1]\n\n    # Known non-numeric HTML entity\n    if entity in compat_html_entities.name2codepoint:\n        return compat_chr(compat_html_entities.name2codepoint[entity])\n\n    # TODO: HTML5 allows entities without a semicolon. For example,\n    # '&Eacuteric' should be decoded as '\u00c9ric'.\n    if entity_with_semicolon in compat_html_entities_html5:\n        return compat_html_entities_html5[entity_with_semicolon]\n\n    mobj = re.match(r'#(x[0-9a-fA-F]+|[0-9]+)', entity)\n    if mobj is not None:\n        numstr = mobj.group(1)\n        if numstr.startswith('x'):\n            base = 16\n            numstr = '0%s' % numstr\n        else:\n            base = 10\n        # See https://github.com/rg3/youtube-dl/issues/7518\n        try:\n            return compat_chr(int(numstr, base))\n        except ValueError:\n            pass\n\n    # Unknown entity in name, return its literal representation\n    return '&%s;' % entity\n\n\ndef unescapeHTML(s):\n    if s is None:\n        return None\n    assert type(s) == compat_str\n\n    return re.sub(\n        r'&([^&;]+;)', lambda m: _htmlentity_transform(m.group(1)), s)\n\n\ndef get_subprocess_encoding():\n    if sys.platform == 'win32' and sys.getwindowsversion()[0] >= 5:\n        # For subprocess calls, encode with locale encoding\n        # Refer to http://stackoverflow.com/a/9951851/35070\n        encoding = preferredencoding()\n    else:\n        encoding = sys.getfilesystemencoding()\n    if encoding is None:\n        encoding = 'utf-8'\n    return encoding\n\n\ndef encodeFilename(s, for_subprocess=False):\n    \"\"\"\n    @param s The name of the file\n    \"\"\"\n\n    assert type(s) == compat_str\n\n    # Python 3 has a Unicode API\n    if sys.version_info >= (3, 0):\n        return s\n\n    # Pass '' directly to use Unicode APIs on Windows 2000 and up\n    # (Detecting Windows NT 4 is tricky because 'major >= 4' would\n    # match Windows 9x series as well. Besides, NT 4 is obsolete.)\n    if not for_subprocess and sys.platform == 'win32' and sys.getwindowsversion()[0] >= 5:\n        return s\n\n    # Jython assumes filenames are Unicode strings though reported as Python 2.x compatible\n    if sys.platform.startswith('java'):\n        return s\n\n    return s.encode(get_subprocess_encoding(), 'ignore')\n\n\ndef decodeFilename(b, for_subprocess=False):\n\n    if sys.version_info >= (3, 0):\n        return b\n\n    if not isinstance(b, bytes):\n        return b\n\n    return b.decode(get_subprocess_encoding(), 'ignore')\n\n\ndef encodeArgument(s):\n    if not isinstance(s, compat_str):\n        # Legacy code that uses byte strings\n        # Uncomment the following line after fixing all post processors\n        # assert False, 'Internal error: %r should be of type %r, is %r' % (s, compat_str, type(s))\n        s = s.decode('ascii')\n    return encodeFilename(s, True)\n\n\ndef decodeArgument(b):\n    return decodeFilename(b, True)\n\n\ndef decodeOption(optval):\n    if optval is None:\n        return optval\n    if isinstance(optval, bytes):\n        optval = optval.decode(preferredencoding())\n\n    assert isinstance(optval, compat_str)\n    return optval\n\n\ndef formatSeconds(secs):\n    if secs > 3600:\n        return '%d:%02d:%02d' % (secs // 3600, (secs % 3600) // 60, secs % 60)\n    elif secs > 60:\n        return '%d:%02d' % (secs // 60, secs % 60)\n    else:\n        return '%d' % secs\n\n\ndef make_HTTPS_handler(params, **kwargs):\n    opts_no_check_certificate = params.get('nocheckcertificate', False)\n    if hasattr(ssl, 'create_default_context'):  # Python >= 3.4 or 2.7.9\n        context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n        if opts_no_check_certificate:\n            context.check_hostname = False\n            context.verify_mode = ssl.CERT_NONE\n        try:\n            return YoutubeDLHTTPSHandler(params, context=context, **kwargs)\n        except TypeError:\n            # Python 2.7.8\n            # (create_default_context present but HTTPSHandler has no context=)\n            pass\n\n    if sys.version_info < (3, 2):\n        return YoutubeDLHTTPSHandler(params, **kwargs)\n    else:  # Python < 3.4\n        context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        context.verify_mode = (ssl.CERT_NONE\n                               if opts_no_check_certificate\n                               else ssl.CERT_REQUIRED)\n        context.set_default_verify_paths()\n        return YoutubeDLHTTPSHandler(params, context=context, **kwargs)\n\n\ndef bug_reports_message():\n    if ytdl_is_updateable():\n        update_cmd = 'type  youtube-dl -U  to update'\n    else:\n        update_cmd = 'see  https://yt-dl.org/update  on how to update'\n    msg = '; please report this issue on https://yt-dl.org/bug .'\n    msg += ' Make sure you are using the latest version; %s.' % update_cmd\n    msg += ' Be sure to call youtube-dl with the --verbose flag and include its complete output.'\n    return msg\n\n\nclass YoutubeDLError(Exception):\n    \"\"\"Base exception for YoutubeDL errors.\"\"\"\n    pass\n\n\nclass ExtractorError(YoutubeDLError):\n    \"\"\"Error during info extraction.\"\"\"\n\n    def __init__(self, msg, tb=None, expected=False, cause=None, video_id=None):\n        \"\"\" tb, if given, is the original traceback (so that it can be printed out).\n        If expected is set, this is a normal error message and most likely not a bug in youtube-dl.\n        \"\"\"\n\n        if sys.exc_info()[0] in (compat_urllib_error.URLError, socket.timeout, UnavailableVideoError):\n            expected = True\n        if video_id is not None:\n            msg = video_id + ': ' + msg\n        if cause:\n            msg += ' (caused by %r)' % cause\n        if not expected:\n            msg += bug_reports_message()\n        super(ExtractorError, self).__init__(msg)\n\n        self.traceback = tb\n        self.exc_info = sys.exc_info()  # preserve original exception\n        self.cause = cause\n        self.video_id = video_id\n\n    def format_traceback(self):\n        if self.traceback is None:\n            return None\n        return ''.join(traceback.format_tb(self.traceback))\n\n\nclass UnsupportedError(ExtractorError):\n    def __init__(self, url):\n        super(UnsupportedError, self).__init__(\n            'Unsupported URL: %s' % url, expected=True)\n        self.url = url\n\n\nclass RegexNotFoundError(ExtractorError):\n    \"\"\"Error when a regex didn't match\"\"\"\n    pass\n\n\nclass GeoRestrictedError(ExtractorError):\n    \"\"\"Geographic restriction Error exception.\n\n    This exception may be thrown when a video is not available from your\n    geographic location due to geographic restrictions imposed by a website.\n    \"\"\"\n    def __init__(self, msg, countries=None):\n        super(GeoRestrictedError, self).__init__(msg, expected=True)\n        self.msg = msg\n        self.countries = countries\n\n\nclass DownloadError(YoutubeDLError):\n    \"\"\"Download Error exception.\n\n    This exception may be thrown by FileDownloader objects if they are not\n    configured to continue on errors. They will contain the appropriate\n    error message.\n    \"\"\"\n\n    def __init__(self, msg, exc_info=None):\n        \"\"\" exc_info, if given, is the original exception that caused the trouble (as returned by sys.exc_info()). \"\"\"\n        super(DownloadError, self).__init__(msg)\n        self.exc_info = exc_info\n\n\nclass SameFileError(YoutubeDLError):\n    \"\"\"Same File exception.\n\n    This exception will be thrown by FileDownloader objects if they detect\n    multiple files would have to be downloaded to the same file on disk.\n    \"\"\"\n    pass\n\n\nclass PostProcessingError(YoutubeDLError):\n    \"\"\"Post Processing exception.\n\n    This exception may be raised by PostProcessor's .run() method to\n    indicate an error in the postprocessing task.\n    \"\"\"\n\n    def __init__(self, msg):\n        super(PostProcessingError, self).__init__(msg)\n        self.msg = msg\n\n\nclass MaxDownloadsReached(YoutubeDLError):\n    \"\"\" --max-downloads limit has been reached. \"\"\"\n    pass\n\n\nclass UnavailableVideoError(YoutubeDLError):\n    \"\"\"Unavailable Format exception.\n\n    This exception will be thrown when a video is requested\n    in a format that is not available for that video.\n    \"\"\"\n    pass\n\n\nclass ContentTooShortError(YoutubeDLError):\n    \"\"\"Content Too Short exception.\n\n    This exception may be raised by FileDownloader objects when a file they\n    download is too small for what the server announced first, indicating\n    the connection was probably interrupted.\n    \"\"\"\n\n    def __init__(self, downloaded, expected):\n        super(ContentTooShortError, self).__init__(\n            'Downloaded {0} bytes, expected {1} bytes'.format(downloaded, expected)\n        )\n        # Both in bytes\n        self.downloaded = downloaded\n        self.expected = expected\n\n\nclass XAttrMetadataError(YoutubeDLError):\n    def __init__(self, code=None, msg='Unknown error'):\n        super(XAttrMetadataError, self).__init__(msg)\n        self.code = code\n        self.msg = msg\n\n        # Parsing code and msg\n        if (self.code in (errno.ENOSPC, errno.EDQUOT) or\n                'No space left' in self.msg or 'Disk quota excedded' in self.msg):\n            self.reason = 'NO_SPACE'\n        elif self.code == errno.E2BIG or 'Argument list too long' in self.msg:\n            self.reason = 'VALUE_TOO_LONG'\n        else:\n            self.reason = 'NOT_SUPPORTED'\n\n\nclass XAttrUnavailableError(YoutubeDLError):\n    pass\n\n\ndef _create_http_connection(ydl_handler, http_class, is_https, *args, **kwargs):\n    # Working around python 2 bug (see http://bugs.python.org/issue17849) by limiting\n    # expected HTTP responses to meet HTTP/1.0 or later (see also\n    # https://github.com/rg3/youtube-dl/issues/6727)\n    if sys.version_info < (3, 0):\n        kwargs['strict'] = True\n    hc = http_class(*args, **compat_kwargs(kwargs))\n    source_address = ydl_handler._params.get('source_address')\n    if source_address is not None:\n        sa = (source_address, 0)\n        if hasattr(hc, 'source_address'):  # Python 2.7+\n            hc.source_address = sa\n        else:  # Python 2.6\n            def _hc_connect(self, *args, **kwargs):\n                sock = compat_socket_create_connection(\n                    (self.host, self.port), self.timeout, sa)\n                if is_https:\n                    self.sock = ssl.wrap_socket(\n                        sock, self.key_file, self.cert_file,\n                        ssl_version=ssl.PROTOCOL_TLSv1)\n                else:\n                    self.sock = sock\n            hc.connect = functools.partial(_hc_connect, hc)\n\n    return hc\n\n\ndef handle_youtubedl_headers(headers):\n    filtered_headers = headers\n\n    if 'Youtubedl-no-compression' in filtered_headers:\n        filtered_headers = dict((k, v) for k, v in filtered_headers.items() if k.lower() != 'accept-encoding')\n        del filtered_headers['Youtubedl-no-compression']\n\n    return filtered_headers\n\n\nclass YoutubeDLHandler(compat_urllib_request.HTTPHandler):\n    \"\"\"Handler for HTTP requests and responses.\n\n    This class, when installed with an OpenerDirector, automatically adds\n    the standard headers to every HTTP request and handles gzipped and\n    deflated responses from web servers. If compression is to be avoided in\n    a particular request, the original request in the program code only has\n    to include the HTTP header \"Youtubedl-no-compression\", which will be\n    removed before making the real request.\n\n    Part of this code was copied from:\n\n    http://techknack.net/python-urllib2-handlers/\n\n    Andrew Rowls, the author of that code, agreed to release it to the\n    public domain.\n    \"\"\"\n\n    def __init__(self, params, *args, **kwargs):\n        compat_urllib_request.HTTPHandler.__init__(self, *args, **kwargs)\n        self._params = params\n\n    def http_open(self, req):\n        conn_class = compat_http_client.HTTPConnection\n\n        socks_proxy = req.headers.get('Ytdl-socks-proxy')\n        if socks_proxy:\n            conn_class = make_socks_conn_class(conn_class, socks_proxy)\n            del req.headers['Ytdl-socks-proxy']\n\n        return self.do_open(functools.partial(\n            _create_http_connection, self, conn_class, False),\n            req)\n\n    @staticmethod\n    def deflate(data):\n        try:\n            return zlib.decompress(data, -zlib.MAX_WBITS)\n        except zlib.error:\n            return zlib.decompress(data)\n\n    def http_request(self, req):\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        # Since redirects are also affected (e.g. http://www.southpark.de/alle-episoden/s18e09)\n        # the code of this workaround has been moved here from YoutubeDL.urlopen()\n        url = req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            req = update_Request(req, url=url_escaped)\n\n        for h, v in std_headers.items():\n            # Capitalize is needed because of Python bug 2275: http://bugs.python.org/issue2275\n            # The dict keys are capitalized because of this bug by urllib\n            if h.capitalize() not in req.headers:\n                req.add_header(h, v)\n\n        req.headers = handle_youtubedl_headers(req.headers)\n\n        if sys.version_info < (2, 7) and '#' in req.get_full_url():\n            # Python 2.6 is brain-dead when it comes to fragments\n            req._Request__original = req._Request__original.partition('#')[0]\n            req._Request__r_type = req._Request__r_type.partition('#')[0]\n\n        return req\n\n    def http_response(self, req, resp):\n        old_resp = resp\n        # gzip\n        if resp.headers.get('Content-encoding', '') == 'gzip':\n            content = resp.read()\n            gz = gzip.GzipFile(fileobj=io.BytesIO(content), mode='rb')\n            try:\n                uncompressed = io.BytesIO(gz.read())\n            except IOError as original_ioerror:\n                # There may be junk add the end of the file\n                # See http://stackoverflow.com/q/4928560/35070 for details\n                for i in range(1, 1024):\n                    try:\n                        gz = gzip.GzipFile(fileobj=io.BytesIO(content[:-i]), mode='rb')\n                        uncompressed = io.BytesIO(gz.read())\n                    except IOError:\n                        continue\n                    break\n                else:\n                    raise original_ioerror\n            resp = compat_urllib_request.addinfourl(uncompressed, old_resp.headers, old_resp.url, old_resp.code)\n            resp.msg = old_resp.msg\n            del resp.headers['Content-encoding']\n        # deflate\n        if resp.headers.get('Content-encoding', '') == 'deflate':\n            gz = io.BytesIO(self.deflate(resp.read()))\n            resp = compat_urllib_request.addinfourl(gz, old_resp.headers, old_resp.url, old_resp.code)\n            resp.msg = old_resp.msg\n            del resp.headers['Content-encoding']\n        # Percent-encode redirect URL of Location HTTP header to satisfy RFC 3986 (see\n        # https://github.com/rg3/youtube-dl/issues/6457).\n        if 300 <= resp.code < 400:\n            location = resp.headers.get('Location')\n            if location:\n                # As of RFC 2616 default charset is iso-8859-1 that is respected by python 3\n                if sys.version_info >= (3, 0):\n                    location = location.encode('iso-8859-1').decode('utf-8')\n                else:\n                    location = location.decode('utf-8')\n                location_escaped = escape_url(location)\n                if location != location_escaped:\n                    del resp.headers['Location']\n                    if sys.version_info < (3, 0):\n                        location_escaped = location_escaped.encode('utf-8')\n                    resp.headers['Location'] = location_escaped\n        return resp\n\n    https_request = http_request\n    https_response = http_response\n\n\ndef make_socks_conn_class(base_class, socks_proxy):\n    assert issubclass(base_class, (\n        compat_http_client.HTTPConnection, compat_http_client.HTTPSConnection))\n\n    url_components = compat_urlparse.urlparse(socks_proxy)\n    if url_components.scheme.lower() == 'socks5':\n        socks_type = ProxyType.SOCKS5\n    elif url_components.scheme.lower() in ('socks', 'socks4'):\n        socks_type = ProxyType.SOCKS4\n    elif url_components.scheme.lower() == 'socks4a':\n        socks_type = ProxyType.SOCKS4A\n\n    def unquote_if_non_empty(s):\n        if not s:\n            return s\n        return compat_urllib_parse_unquote_plus(s)\n\n    proxy_args = (\n        socks_type,\n        url_components.hostname, url_components.port or 1080,\n        True,  # Remote DNS\n        unquote_if_non_empty(url_components.username),\n        unquote_if_non_empty(url_components.password),\n    )\n\n    class SocksConnection(base_class):\n        def connect(self):\n            self.sock = sockssocket()\n            self.sock.setproxy(*proxy_args)\n            if type(self.timeout) in (int, float):\n                self.sock.settimeout(self.timeout)\n            self.sock.connect((self.host, self.port))\n\n            if isinstance(self, compat_http_client.HTTPSConnection):\n                if hasattr(self, '_context'):  # Python > 2.6\n                    self.sock = self._context.wrap_socket(\n                        self.sock, server_hostname=self.host)\n                else:\n                    self.sock = ssl.wrap_socket(self.sock)\n\n    return SocksConnection\n\n\nclass YoutubeDLHTTPSHandler(compat_urllib_request.HTTPSHandler):\n    def __init__(self, params, https_conn_class=None, *args, **kwargs):\n        compat_urllib_request.HTTPSHandler.__init__(self, *args, **kwargs)\n        self._https_conn_class = https_conn_class or compat_http_client.HTTPSConnection\n        self._params = params\n\n    def https_open(self, req):\n        kwargs = {}\n        conn_class = self._https_conn_class\n\n        if hasattr(self, '_context'):  # python > 2.6\n            kwargs['context'] = self._context\n        if hasattr(self, '_check_hostname'):  # python 3.x\n            kwargs['check_hostname'] = self._check_hostname\n\n        socks_proxy = req.headers.get('Ytdl-socks-proxy')\n        if socks_proxy:\n            conn_class = make_socks_conn_class(conn_class, socks_proxy)\n            del req.headers['Ytdl-socks-proxy']\n\n        return self.do_open(functools.partial(\n            _create_http_connection, self, conn_class, True),\n            req, **kwargs)\n\n\nclass YoutubeDLCookieProcessor(compat_urllib_request.HTTPCookieProcessor):\n    def __init__(self, cookiejar=None):\n        compat_urllib_request.HTTPCookieProcessor.__init__(self, cookiejar)\n\n    def http_response(self, request, response):\n        # Python 2 will choke on next HTTP request in row if there are non-ASCII\n        # characters in Set-Cookie HTTP header of last response (see\n        # https://github.com/rg3/youtube-dl/issues/6769).\n        # In order to at least prevent crashing we will percent encode Set-Cookie\n        # header before HTTPCookieProcessor starts processing it.\n        # if sys.version_info < (3, 0) and response.headers:\n        #     for set_cookie_header in ('Set-Cookie', 'Set-Cookie2'):\n        #         set_cookie = response.headers.get(set_cookie_header)\n        #         if set_cookie:\n        #             set_cookie_escaped = compat_urllib_parse.quote(set_cookie, b\"%/;:@&=+$,!~*'()?#[] \")\n        #             if set_cookie != set_cookie_escaped:\n        #                 del response.headers[set_cookie_header]\n        #                 response.headers[set_cookie_header] = set_cookie_escaped\n        return compat_urllib_request.HTTPCookieProcessor.http_response(self, request, response)\n\n    https_request = compat_urllib_request.HTTPCookieProcessor.http_request\n    https_response = http_response\n\n\ndef extract_timezone(date_str):\n    m = re.search(\n        r'^.{8,}?(?P<tz>Z$| ?(?P<sign>\\+|-)(?P<hours>[0-9]{2}):?(?P<minutes>[0-9]{2})$)',\n        date_str)\n    if not m:\n        timezone = datetime.timedelta()\n    else:\n        date_str = date_str[:-len(m.group('tz'))]\n        if not m.group('sign'):\n            timezone = datetime.timedelta()\n        else:\n            sign = 1 if m.group('sign') == '+' else -1\n            timezone = datetime.timedelta(\n                hours=sign * int(m.group('hours')),\n                minutes=sign * int(m.group('minutes')))\n    return timezone, date_str\n\n\ndef parse_iso8601(date_str, delimiter='T', timezone=None):\n    \"\"\" Return a UNIX timestamp from the given date \"\"\"\n\n    if date_str is None:\n        return None\n\n    date_str = re.sub(r'\\.[0-9]+', '', date_str)\n\n    if timezone is None:\n        timezone, date_str = extract_timezone(date_str)\n\n    try:\n        date_format = '%Y-%m-%d{0}%H:%M:%S'.format(delimiter)\n        dt = datetime.datetime.strptime(date_str, date_format) - timezone\n        return calendar.timegm(dt.timetuple())\n    except ValueError:\n        pass\n\n\ndef date_formats(day_first=True):\n    return DATE_FORMATS_DAY_FIRST if day_first else DATE_FORMATS_MONTH_FIRST\n\n\ndef unified_strdate(date_str, day_first=True):\n    \"\"\"Return a string with the date in the format YYYYMMDD\"\"\"\n\n    if date_str is None:\n        return None\n    upload_date = None\n    # Replace commas\n    date_str = date_str.replace(',', ' ')\n    # Remove AM/PM + timezone\n    date_str = re.sub(r'(?i)\\s*(?:AM|PM)(?:\\s+[A-Z]+)?', '', date_str)\n    _, date_str = extract_timezone(date_str)\n\n    for expression in date_formats(day_first):\n        try:\n            upload_date = datetime.datetime.strptime(date_str, expression).strftime('%Y%m%d')\n        except ValueError:\n            pass\n    if upload_date is None:\n        timetuple = email.utils.parsedate_tz(date_str)\n        if timetuple:\n            try:\n                upload_date = datetime.datetime(*timetuple[:6]).strftime('%Y%m%d')\n            except ValueError:\n                pass\n    if upload_date is not None:\n        return compat_str(upload_date)\n\n\ndef unified_timestamp(date_str, day_first=True):\n    if date_str is None:\n        return None\n\n    date_str = re.sub(r'[,|]', '', date_str)\n\n    pm_delta = 12 if re.search(r'(?i)PM', date_str) else 0\n    timezone, date_str = extract_timezone(date_str)\n\n    # Remove AM/PM + timezone\n    date_str = re.sub(r'(?i)\\s*(?:AM|PM)(?:\\s+[A-Z]+)?', '', date_str)\n\n    # Remove unrecognized timezones from ISO 8601 alike timestamps\n    m = re.search(r'\\d{1,2}:\\d{1,2}(?:\\.\\d+)?(?P<tz>\\s*[A-Z]+)$', date_str)\n    if m:\n        date_str = date_str[:-len(m.group('tz'))]\n\n    for expression in date_formats(day_first):\n        try:\n            dt = datetime.datetime.strptime(date_str, expression) - timezone + datetime.timedelta(hours=pm_delta)\n            return calendar.timegm(dt.timetuple())\n        except ValueError:\n            pass\n    timetuple = email.utils.parsedate_tz(date_str)\n    if timetuple:\n        return calendar.timegm(timetuple) + pm_delta * 3600\n\n\ndef determine_ext(url, default_ext='unknown_video'):\n    if url is None:\n        return default_ext\n    guess = url.partition('?')[0].rpartition('.')[2]\n    if re.match(r'^[A-Za-z0-9]+$', guess):\n        return guess\n    # Try extract ext from URLs like http://example.com/foo/bar.mp4/?download\n    elif guess.rstrip('/') in KNOWN_EXTENSIONS:\n        return guess.rstrip('/')\n    else:\n        return default_ext\n\n\ndef subtitles_filename(filename, sub_lang, sub_format):\n    return filename.rsplit('.', 1)[0] + '.' + sub_lang + '.' + sub_format\n\n\ndef date_from_str(date_str):\n    \"\"\"\n    Return a datetime object from a string in the format YYYYMMDD or\n    (now|today)[+-][0-9](day|week|month|year)(s)?\"\"\"\n    today = datetime.date.today()\n    if date_str in ('now', 'today'):\n        return today\n    if date_str == 'yesterday':\n        return today - datetime.timedelta(days=1)\n    match = re.match(r'(now|today)(?P<sign>[+-])(?P<time>\\d+)(?P<unit>day|week|month|year)(s)?', date_str)\n    if match is not None:\n        sign = match.group('sign')\n        time = int(match.group('time'))\n        if sign == '-':\n            time = -time\n        unit = match.group('unit')\n        # A bad approximation?\n        if unit == 'month':\n            unit = 'day'\n            time *= 30\n        elif unit == 'year':\n            unit = 'day'\n            time *= 365\n        unit += 's'\n        delta = datetime.timedelta(**{unit: time})\n        return today + delta\n    return datetime.datetime.strptime(date_str, '%Y%m%d').date()\n\n\ndef hyphenate_date(date_str):\n    \"\"\"\n    Convert a date in 'YYYYMMDD' format to 'YYYY-MM-DD' format\"\"\"\n    match = re.match(r'^(\\d\\d\\d\\d)(\\d\\d)(\\d\\d)$', date_str)\n    if match is not None:\n        return '-'.join(match.groups())\n    else:\n        return date_str\n\n\nclass DateRange(object):\n    \"\"\"Represents a time interval between two dates\"\"\"\n\n    def __init__(self, start=None, end=None):\n        \"\"\"start and end must be strings in the format accepted by date\"\"\"\n        if start is not None:\n            self.start = date_from_str(start)\n        else:\n            self.start = datetime.datetime.min.date()\n        if end is not None:\n            self.end = date_from_str(end)\n        else:\n            self.end = datetime.datetime.max.date()\n        if self.start > self.end:\n            raise ValueError('Date range: \"%s\" , the start date must be before the end date' % self)\n\n    @classmethod\n    def day(cls, day):\n        \"\"\"Returns a range that only contains the given day\"\"\"\n        return cls(day, day)\n\n    def __contains__(self, date):\n        \"\"\"Check if the date is in the range\"\"\"\n        if not isinstance(date, datetime.date):\n            date = date_from_str(date)\n        return self.start <= date <= self.end\n\n    def __str__(self):\n        return '%s - %s' % (self.start.isoformat(), self.end.isoformat())\n\n\ndef platform_name():\n    \"\"\" Returns the platform name as a compat_str \"\"\"\n    res = platform.platform()\n    if isinstance(res, bytes):\n        res = res.decode(preferredencoding())\n\n    assert isinstance(res, compat_str)\n    return res\n\n\ndef _windows_write_string(s, out):\n    \"\"\" Returns True if the string was written using special methods,\n    False if it has yet to be written out.\"\"\"\n    # Adapted from http://stackoverflow.com/a/3259271/35070\n\n    import ctypes\n    import ctypes.wintypes\n\n    WIN_OUTPUT_IDS = {\n        1: -11,\n        2: -12,\n    }\n\n    try:\n        fileno = out.fileno()\n    except AttributeError:\n        # If the output stream doesn't have a fileno, it's virtual\n        return False\n    except io.UnsupportedOperation:\n        # Some strange Windows pseudo files?\n        return False\n    if fileno not in WIN_OUTPUT_IDS:\n        return False\n\n    GetStdHandle = compat_ctypes_WINFUNCTYPE(\n        ctypes.wintypes.HANDLE, ctypes.wintypes.DWORD)(\n        ('GetStdHandle', ctypes.windll.kernel32))\n    h = GetStdHandle(WIN_OUTPUT_IDS[fileno])\n\n    WriteConsoleW = compat_ctypes_WINFUNCTYPE(\n        ctypes.wintypes.BOOL, ctypes.wintypes.HANDLE, ctypes.wintypes.LPWSTR,\n        ctypes.wintypes.DWORD, ctypes.POINTER(ctypes.wintypes.DWORD),\n        ctypes.wintypes.LPVOID)(('WriteConsoleW', ctypes.windll.kernel32))\n    written = ctypes.wintypes.DWORD(0)\n\n    GetFileType = compat_ctypes_WINFUNCTYPE(ctypes.wintypes.DWORD, ctypes.wintypes.DWORD)(('GetFileType', ctypes.windll.kernel32))\n    FILE_TYPE_CHAR = 0x0002\n    FILE_TYPE_REMOTE = 0x8000\n    GetConsoleMode = compat_ctypes_WINFUNCTYPE(\n        ctypes.wintypes.BOOL, ctypes.wintypes.HANDLE,\n        ctypes.POINTER(ctypes.wintypes.DWORD))(\n        ('GetConsoleMode', ctypes.windll.kernel32))\n    INVALID_HANDLE_VALUE = ctypes.wintypes.DWORD(-1).value\n\n    def not_a_console(handle):\n        if handle == INVALID_HANDLE_VALUE or handle is None:\n            return True\n        return ((GetFileType(handle) & ~FILE_TYPE_REMOTE) != FILE_TYPE_CHAR or\n                GetConsoleMode(handle, ctypes.byref(ctypes.wintypes.DWORD())) == 0)\n\n    if not_a_console(h):\n        return False\n\n    def next_nonbmp_pos(s):\n        try:\n            return next(i for i, c in enumerate(s) if ord(c) > 0xffff)\n        except StopIteration:\n            return len(s)\n\n    while s:\n        count = min(next_nonbmp_pos(s), 1024)\n\n        ret = WriteConsoleW(\n            h, s, count if count else 2, ctypes.byref(written), None)\n        if ret == 0:\n            raise OSError('Failed to write string')\n        if not count:  # We just wrote a non-BMP character\n            assert written.value == 2\n            s = s[1:]\n        else:\n            assert written.value > 0\n            s = s[written.value:]\n    return True\n\n\ndef write_string(s, out=None, encoding=None):\n    if out is None:\n        out = sys.stderr\n    assert type(s) == compat_str\n\n    if sys.platform == 'win32' and encoding is None and hasattr(out, 'fileno'):\n        if _windows_write_string(s, out):\n            return\n\n    if ('b' in getattr(out, 'mode', '') or\n            sys.version_info[0] < 3):  # Python 2 lies about mode of sys.stderr\n        byt = s.encode(encoding or preferredencoding(), 'ignore')\n        out.write(byt)\n    elif hasattr(out, 'buffer'):\n        enc = encoding or getattr(out, 'encoding', None) or preferredencoding()\n        byt = s.encode(enc, 'ignore')\n        out.buffer.write(byt)\n    else:\n        out.write(s)\n    out.flush()\n\n\ndef bytes_to_intlist(bs):\n    if not bs:\n        return []\n    if isinstance(bs[0], int):  # Python 3\n        return list(bs)\n    else:\n        return [ord(c) for c in bs]\n\n\ndef intlist_to_bytes(xs):\n    if not xs:\n        return b''\n    return compat_struct_pack('%dB' % len(xs), *xs)\n\n\n# Cross-platform file locking\nif sys.platform == 'win32':\n    import ctypes.wintypes\n    import msvcrt\n\n    class OVERLAPPED(ctypes.Structure):\n        _fields_ = [\n            ('Internal', ctypes.wintypes.LPVOID),\n            ('InternalHigh', ctypes.wintypes.LPVOID),\n            ('Offset', ctypes.wintypes.DWORD),\n            ('OffsetHigh', ctypes.wintypes.DWORD),\n            ('hEvent', ctypes.wintypes.HANDLE),\n        ]\n\n    kernel32 = ctypes.windll.kernel32\n    LockFileEx = kernel32.LockFileEx\n    LockFileEx.argtypes = [\n        ctypes.wintypes.HANDLE,     # hFile\n        ctypes.wintypes.DWORD,      # dwFlags\n        ctypes.wintypes.DWORD,      # dwReserved\n        ctypes.wintypes.DWORD,      # nNumberOfBytesToLockLow\n        ctypes.wintypes.DWORD,      # nNumberOfBytesToLockHigh\n        ctypes.POINTER(OVERLAPPED)  # Overlapped\n    ]\n    LockFileEx.restype = ctypes.wintypes.BOOL\n    UnlockFileEx = kernel32.UnlockFileEx\n    UnlockFileEx.argtypes = [\n        ctypes.wintypes.HANDLE,     # hFile\n        ctypes.wintypes.DWORD,      # dwReserved\n        ctypes.wintypes.DWORD,      # nNumberOfBytesToLockLow\n        ctypes.wintypes.DWORD,      # nNumberOfBytesToLockHigh\n        ctypes.POINTER(OVERLAPPED)  # Overlapped\n    ]\n    UnlockFileEx.restype = ctypes.wintypes.BOOL\n    whole_low = 0xffffffff\n    whole_high = 0x7fffffff\n\n    def _lock_file(f, exclusive):\n        overlapped = OVERLAPPED()\n        overlapped.Offset = 0\n        overlapped.OffsetHigh = 0\n        overlapped.hEvent = 0\n        f._lock_file_overlapped_p = ctypes.pointer(overlapped)\n        handle = msvcrt.get_osfhandle(f.fileno())\n        if not LockFileEx(handle, 0x2 if exclusive else 0x0, 0,\n                          whole_low, whole_high, f._lock_file_overlapped_p):\n            raise OSError('Locking file failed: %r' % ctypes.FormatError())\n\n    def _unlock_file(f):\n        assert f._lock_file_overlapped_p\n        handle = msvcrt.get_osfhandle(f.fileno())\n        if not UnlockFileEx(handle, 0,\n                            whole_low, whole_high, f._lock_file_overlapped_p):\n            raise OSError('Unlocking file failed: %r' % ctypes.FormatError())\n\nelse:\n    # Some platforms, such as Jython, is missing fcntl\n    try:\n        import fcntl\n\n        def _lock_file(f, exclusive):\n            fcntl.flock(f, fcntl.LOCK_EX if exclusive else fcntl.LOCK_SH)\n\n        def _unlock_file(f):\n            fcntl.flock(f, fcntl.LOCK_UN)\n    except ImportError:\n        UNSUPPORTED_MSG = 'file locking is not supported on this platform'\n\n        def _lock_file(f, exclusive):\n            raise IOError(UNSUPPORTED_MSG)\n\n        def _unlock_file(f):\n            raise IOError(UNSUPPORTED_MSG)\n\n\nclass locked_file(object):\n    def __init__(self, filename, mode, encoding=None):\n        assert mode in ['r', 'a', 'w']\n        self.f = io.open(filename, mode, encoding=encoding)\n        self.mode = mode\n\n    def __enter__(self):\n        exclusive = self.mode != 'r'\n        try:\n            _lock_file(self.f, exclusive)\n        except IOError:\n            self.f.close()\n            raise\n        return self\n\n    def __exit__(self, etype, value, traceback):\n        try:\n            _unlock_file(self.f)\n        finally:\n            self.f.close()\n\n    def __iter__(self):\n        return iter(self.f)\n\n    def write(self, *args):\n        return self.f.write(*args)\n\n    def read(self, *args):\n        return self.f.read(*args)\n\n\ndef get_filesystem_encoding():\n    encoding = sys.getfilesystemencoding()\n    return encoding if encoding is not None else 'utf-8'\n\n\ndef shell_quote(args):\n    quoted_args = []\n    encoding = get_filesystem_encoding()\n    for a in args:\n        if isinstance(a, bytes):\n            # We may get a filename encoded with 'encodeFilename'\n            a = a.decode(encoding)\n        quoted_args.append(compat_shlex_quote(a))\n    return ' '.join(quoted_args)\n\n\ndef smuggle_url(url, data):\n    \"\"\" Pass additional data in a URL for internal use. \"\"\"\n\n    url, idata = unsmuggle_url(url, {})\n    data.update(idata)\n    sdata = compat_urllib_parse_urlencode(\n        {'__youtubedl_smuggle': json.dumps(data)})\n    return url + '#' + sdata\n\n\ndef unsmuggle_url(smug_url, default=None):\n    if '#__youtubedl_smuggle' not in smug_url:\n        return smug_url, default\n    url, _, sdata = smug_url.rpartition('#')\n    jsond = compat_parse_qs(sdata)['__youtubedl_smuggle'][0]\n    data = json.loads(jsond)\n    return url, data\n\n\ndef format_bytes(bytes):\n    if bytes is None:\n        return 'N/A'\n    if type(bytes) is str:\n        bytes = float(bytes)\n    if bytes == 0.0:\n        exponent = 0\n    else:\n        exponent = int(math.log(bytes, 1024.0))\n    suffix = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'][exponent]\n    converted = float(bytes) / float(1024 ** exponent)\n    return '%.2f%s' % (converted, suffix)\n\n\ndef lookup_unit_table(unit_table, s):\n    units_re = '|'.join(re.escape(u) for u in unit_table)\n    m = re.match(\n        r'(?P<num>[0-9]+(?:[,.][0-9]*)?)\\s*(?P<unit>%s)\\b' % units_re, s)\n    if not m:\n        return None\n    num_str = m.group('num').replace(',', '.')\n    mult = unit_table[m.group('unit')]\n    return int(float(num_str) * mult)\n\n\ndef parse_filesize(s):\n    if s is None:\n        return None\n\n    # The lower-case forms are of course incorrect and unofficial,\n    # but we support those too\n    _UNIT_TABLE = {\n        'B': 1,\n        'b': 1,\n        'bytes': 1,\n        'KiB': 1024,\n        'KB': 1000,\n        'kB': 1024,\n        'Kb': 1000,\n        'kb': 1000,\n        'kilobytes': 1000,\n        'kibibytes': 1024,\n        'MiB': 1024 ** 2,\n        'MB': 1000 ** 2,\n        'mB': 1024 ** 2,\n        'Mb': 1000 ** 2,\n        'mb': 1000 ** 2,\n        'megabytes': 1000 ** 2,\n        'mebibytes': 1024 ** 2,\n        'GiB': 1024 ** 3,\n        'GB': 1000 ** 3,\n        'gB': 1024 ** 3,\n        'Gb': 1000 ** 3,\n        'gb': 1000 ** 3,\n        'gigabytes': 1000 ** 3,\n        'gibibytes': 1024 ** 3,\n        'TiB': 1024 ** 4,\n        'TB': 1000 ** 4,\n        'tB': 1024 ** 4,\n        'Tb': 1000 ** 4,\n        'tb': 1000 ** 4,\n        'terabytes': 1000 ** 4,\n        'tebibytes': 1024 ** 4,\n        'PiB': 1024 ** 5,\n        'PB': 1000 ** 5,\n        'pB': 1024 ** 5,\n        'Pb': 1000 ** 5,\n        'pb': 1000 ** 5,\n        'petabytes': 1000 ** 5,\n        'pebibytes': 1024 ** 5,\n        'EiB': 1024 ** 6,\n        'EB': 1000 ** 6,\n        'eB': 1024 ** 6,\n        'Eb': 1000 ** 6,\n        'eb': 1000 ** 6,\n        'exabytes': 1000 ** 6,\n        'exbibytes': 1024 ** 6,\n        'ZiB': 1024 ** 7,\n        'ZB': 1000 ** 7,\n        'zB': 1024 ** 7,\n        'Zb': 1000 ** 7,\n        'zb': 1000 ** 7,\n        'zettabytes': 1000 ** 7,\n        'zebibytes': 1024 ** 7,\n        'YiB': 1024 ** 8,\n        'YB': 1000 ** 8,\n        'yB': 1024 ** 8,\n        'Yb': 1000 ** 8,\n        'yb': 1000 ** 8,\n        'yottabytes': 1000 ** 8,\n        'yobibytes': 1024 ** 8,\n    }\n\n    return lookup_unit_table(_UNIT_TABLE, s)\n\n\ndef parse_count(s):\n    if s is None:\n        return None\n\n    s = s.strip()\n\n    if re.match(r'^[\\d,.]+$', s):\n        return str_to_int(s)\n\n    _UNIT_TABLE = {\n        'k': 1000,\n        'K': 1000,\n        'm': 1000 ** 2,\n        'M': 1000 ** 2,\n        'kk': 1000 ** 2,\n        'KK': 1000 ** 2,\n    }\n\n    return lookup_unit_table(_UNIT_TABLE, s)\n\n\ndef parse_resolution(s):\n    if s is None:\n        return {}\n\n    mobj = re.search(r'\\b(?P<w>\\d+)\\s*[xX\u00d7]\\s*(?P<h>\\d+)\\b', s)\n    if mobj:\n        return {\n            'width': int(mobj.group('w')),\n            'height': int(mobj.group('h')),\n        }\n\n    mobj = re.search(r'\\b(\\d+)[pPiI]\\b', s)\n    if mobj:\n        return {'height': int(mobj.group(1))}\n\n    mobj = re.search(r'\\b([48])[kK]\\b', s)\n    if mobj:\n        return {'height': int(mobj.group(1)) * 540}\n\n    return {}\n\n\ndef month_by_name(name, lang='en'):\n    \"\"\" Return the number of a month by (locale-independently) English name \"\"\"\n\n    month_names = MONTH_NAMES.get(lang, MONTH_NAMES['en'])\n\n    try:\n        return month_names.index(name) + 1\n    except ValueError:\n        return None\n\n\ndef month_by_abbreviation(abbrev):\n    \"\"\" Return the number of a month by (locale-independently) English\n        abbreviations \"\"\"\n\n    try:\n        return [s[:3] for s in ENGLISH_MONTH_NAMES].index(abbrev) + 1\n    except ValueError:\n        return None\n\n\ndef fix_xml_ampersands(xml_str):\n    \"\"\"Replace all the '&' by '&amp;' in XML\"\"\"\n    return re.sub(\n        r'&(?!amp;|lt;|gt;|apos;|quot;|#x[0-9a-fA-F]{,4};|#[0-9]{,4};)',\n        '&amp;',\n        xml_str)\n\n\ndef setproctitle(title):\n    assert isinstance(title, compat_str)\n\n    # ctypes in Jython is not complete\n    # http://bugs.jython.org/issue2148\n    if sys.platform.startswith('java'):\n        return\n\n    try:\n        libc = ctypes.cdll.LoadLibrary('libc.so.6')\n    except OSError:\n        return\n    except TypeError:\n        # LoadLibrary in Windows Python 2.7.13 only expects\n        # a bytestring, but since unicode_literals turns\n        # every string into a unicode string, it fails.\n        return\n    title_bytes = title.encode('utf-8')\n    buf = ctypes.create_string_buffer(len(title_bytes))\n    buf.value = title_bytes\n    try:\n        libc.prctl(15, buf, 0, 0, 0)\n    except AttributeError:\n        return  # Strange libc, just skip this\n\n\ndef remove_start(s, start):\n    return s[len(start):] if s is not None and s.startswith(start) else s\n\n\ndef remove_end(s, end):\n    return s[:-len(end)] if s is not None and s.endswith(end) else s\n\n\ndef remove_quotes(s):\n    if s is None or len(s) < 2:\n        return s\n    for quote in ('\"', \"'\", ):\n        if s[0] == quote and s[-1] == quote:\n            return s[1:-1]\n    return s\n\n\ndef url_basename(url):\n    path = compat_urlparse.urlparse(url).path\n    return path.strip('/').split('/')[-1]\n\n\ndef base_url(url):\n    return re.match(r'https?://[^?#&]+/', url).group()\n\n\ndef urljoin(base, path):\n    if isinstance(path, bytes):\n        path = path.decode('utf-8')\n    if not isinstance(path, compat_str) or not path:\n        return None\n    if re.match(r'^(?:https?:)?//', path):\n        return path\n    if isinstance(base, bytes):\n        base = base.decode('utf-8')\n    if not isinstance(base, compat_str) or not re.match(\n            r'^(?:https?:)?//', base):\n        return None\n    return compat_urlparse.urljoin(base, path)\n\n\nclass HEADRequest(compat_urllib_request.Request):\n    def get_method(self):\n        return 'HEAD'\n\n\nclass PUTRequest(compat_urllib_request.Request):\n    def get_method(self):\n        return 'PUT'\n\n\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1):\n    if get_attr:\n        if v is not None:\n            v = getattr(v, get_attr, None)\n    if v == '':\n        v = None\n    if v is None:\n        return default\n    try:\n        return int(v) * invscale // scale\n    except ValueError:\n        return default\n\n\ndef str_or_none(v, default=None):\n    return default if v is None else compat_str(v)\n\n\ndef str_to_int(int_str):\n    \"\"\" A more relaxed version of int_or_none \"\"\"\n    if int_str is None:\n        return None\n    int_str = re.sub(r'[,\\.\\+]', '', int_str)\n    return int(int_str)\n\n\ndef float_or_none(v, scale=1, invscale=1, default=None):\n    if v is None:\n        return default\n    try:\n        return float(v) * invscale / scale\n    except ValueError:\n        return default\n\n\ndef bool_or_none(v, default=None):\n    return v if isinstance(v, bool) else default\n\n\ndef strip_or_none(v):\n    return None if v is None else v.strip()\n\n\ndef parse_duration(s):\n    if not isinstance(s, compat_basestring):\n        return None\n\n    s = s.strip()\n\n    days, hours, mins, secs, ms = [None] * 5\n    m = re.match(r'(?:(?:(?:(?P<days>[0-9]+):)?(?P<hours>[0-9]+):)?(?P<mins>[0-9]+):)?(?P<secs>[0-9]+)(?P<ms>\\.[0-9]+)?Z?$', s)\n    if m:\n        days, hours, mins, secs, ms = m.groups()\n    else:\n        m = re.match(\n            r'''(?ix)(?:P?\n                (?:\n                    [0-9]+\\s*y(?:ears?)?\\s*\n                )?\n                (?:\n                    [0-9]+\\s*m(?:onths?)?\\s*\n                )?\n                (?:\n                    [0-9]+\\s*w(?:eeks?)?\\s*\n                )?\n                (?:\n                    (?P<days>[0-9]+)\\s*d(?:ays?)?\\s*\n                )?\n                T)?\n                (?:\n                    (?P<hours>[0-9]+)\\s*h(?:ours?)?\\s*\n                )?\n                (?:\n                    (?P<mins>[0-9]+)\\s*m(?:in(?:ute)?s?)?\\s*\n                )?\n                (?:\n                    (?P<secs>[0-9]+)(?P<ms>\\.[0-9]+)?\\s*s(?:ec(?:ond)?s?)?\\s*\n                )?Z?$''', s)\n        if m:\n            days, hours, mins, secs, ms = m.groups()\n        else:\n            m = re.match(r'(?i)(?:(?P<hours>[0-9.]+)\\s*(?:hours?)|(?P<mins>[0-9.]+)\\s*(?:mins?\\.?|minutes?)\\s*)Z?$', s)\n            if m:\n                hours, mins = m.groups()\n            else:\n                return None\n\n    duration = 0\n    if secs:\n        duration += float(secs)\n    if mins:\n        duration += float(mins) * 60\n    if hours:\n        duration += float(hours) * 60 * 60\n    if days:\n        duration += float(days) * 24 * 60 * 60\n    if ms:\n        duration += float(ms)\n    return duration\n\n\ndef prepend_extension(filename, ext, expected_real_ext=None):\n    name, real_ext = os.path.splitext(filename)\n    return (\n        '{0}.{1}{2}'.format(name, ext, real_ext)\n        if not expected_real_ext or real_ext[1:] == expected_real_ext\n        else '{0}.{1}'.format(filename, ext))\n\n\ndef replace_extension(filename, ext, expected_real_ext=None):\n    name, real_ext = os.path.splitext(filename)\n    return '{0}.{1}'.format(\n        name if not expected_real_ext or real_ext[1:] == expected_real_ext else filename,\n        ext)\n\n\ndef check_executable(exe, args=[]):\n    \"\"\" Checks if the given binary is installed somewhere in PATH, and returns its name.\n    args can be a list of arguments for a short output (like -version) \"\"\"\n    try:\n        subprocess.Popen([exe] + args, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()\n    except OSError:\n        return False\n    return exe\n\n\ndef get_exe_version(exe, args=['--version'],\n                    version_re=None, unrecognized='present'):\n    \"\"\" Returns the version of the specified executable,\n    or False if the executable is not present \"\"\"\n    try:\n        # STDIN should be redirected too. On UNIX-like systems, ffmpeg triggers\n        # SIGTTOU if youtube-dl is run in the background.\n        # See https://github.com/rg3/youtube-dl/issues/955#issuecomment-209789656\n        out, _ = subprocess.Popen(\n            [encodeArgument(exe)] + args,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE, stderr=subprocess.STDOUT).communicate()\n    except OSError:\n        return False\n    if isinstance(out, bytes):  # Python 2.x\n        out = out.decode('ascii', 'ignore')\n    return detect_exe_version(out, version_re, unrecognized)\n\n\ndef detect_exe_version(output, version_re=None, unrecognized='present'):\n    assert isinstance(output, compat_str)\n    if version_re is None:\n        version_re = r'version\\s+([-0-9._a-zA-Z]+)'\n    m = re.search(version_re, output)\n    if m:\n        return m.group(1)\n    else:\n        return unrecognized\n\n\nclass PagedList(object):\n    def __len__(self):\n        # This is only useful for tests\n        return len(self.getslice())\n\n\nclass OnDemandPagedList(PagedList):\n    def __init__(self, pagefunc, pagesize, use_cache=True):\n        self._pagefunc = pagefunc\n        self._pagesize = pagesize\n        self._use_cache = use_cache\n        if use_cache:\n            self._cache = {}\n\n    def getslice(self, start=0, end=None):\n        res = []\n        for pagenum in itertools.count(start // self._pagesize):\n            firstid = pagenum * self._pagesize\n            nextfirstid = pagenum * self._pagesize + self._pagesize\n            if start >= nextfirstid:\n                continue\n\n            page_results = None\n            if self._use_cache:\n                page_results = self._cache.get(pagenum)\n            if page_results is None:\n                page_results = list(self._pagefunc(pagenum))\n            if self._use_cache:\n                self._cache[pagenum] = page_results\n\n            startv = (\n                start % self._pagesize\n                if firstid <= start < nextfirstid\n                else 0)\n\n            endv = (\n                ((end - 1) % self._pagesize) + 1\n                if (end is not None and firstid <= end <= nextfirstid)\n                else None)\n\n            if startv != 0 or endv is not None:\n                page_results = page_results[startv:endv]\n            res.extend(page_results)\n\n            # A little optimization - if current page is not \"full\", ie. does\n            # not contain page_size videos then we can assume that this page\n            # is the last one - there are no more ids on further pages -\n            # i.e. no need to query again.\n            if len(page_results) + startv < self._pagesize:\n                break\n\n            # If we got the whole page, but the next page is not interesting,\n            # break out early as well\n            if end == nextfirstid:\n                break\n        return res\n\n\nclass InAdvancePagedList(PagedList):\n    def __init__(self, pagefunc, pagecount, pagesize):\n        self._pagefunc = pagefunc\n        self._pagecount = pagecount\n        self._pagesize = pagesize\n\n    def getslice(self, start=0, end=None):\n        res = []\n        start_page = start // self._pagesize\n        end_page = (\n            self._pagecount if end is None else (end // self._pagesize + 1))\n        skip_elems = start - start_page * self._pagesize\n        only_more = None if end is None else end - start\n        for pagenum in range(start_page, end_page):\n            page = list(self._pagefunc(pagenum))\n            if skip_elems:\n                page = page[skip_elems:]\n                skip_elems = None\n            if only_more is not None:\n                if len(page) < only_more:\n                    only_more -= len(page)\n                else:\n                    page = page[:only_more]\n                    res.extend(page)\n                    break\n            res.extend(page)\n        return res\n\n\ndef uppercase_escape(s):\n    unicode_escape = codecs.getdecoder('unicode_escape')\n    return re.sub(\n        r'\\\\U[0-9a-fA-F]{8}',\n        lambda m: unicode_escape(m.group(0))[0],\n        s)\n\n\ndef lowercase_escape(s):\n    unicode_escape = codecs.getdecoder('unicode_escape')\n    return re.sub(\n        r'\\\\u[0-9a-fA-F]{4}',\n        lambda m: unicode_escape(m.group(0))[0],\n        s)\n\n\ndef escape_rfc3986(s):\n    \"\"\"Escape non-ASCII characters as suggested by RFC 3986\"\"\"\n    if sys.version_info < (3, 0) and isinstance(s, compat_str):\n        s = s.encode('utf-8')\n    return compat_urllib_parse.quote(s, b\"%/;:@&=+$,!~*'()?#[]\")\n\n\ndef escape_url(url):\n    \"\"\"Escape URL as suggested by RFC 3986\"\"\"\n    url_parsed = compat_urllib_parse_urlparse(url)\n    return url_parsed._replace(\n        netloc=url_parsed.netloc.encode('idna').decode('ascii'),\n        path=escape_rfc3986(url_parsed.path),\n        params=escape_rfc3986(url_parsed.params),\n        query=escape_rfc3986(url_parsed.query),\n        fragment=escape_rfc3986(url_parsed.fragment)\n    ).geturl()\n\n\ndef read_batch_urls(batch_fd):\n    def fixup(url):\n        if not isinstance(url, compat_str):\n            url = url.decode('utf-8', 'replace')\n        BOM_UTF8 = '\\xef\\xbb\\xbf'\n        if url.startswith(BOM_UTF8):\n            url = url[len(BOM_UTF8):]\n        url = url.strip()\n        if url.startswith(('#', ';', ']')):\n            return False\n        return url\n\n    with contextlib.closing(batch_fd) as fd:\n        return [url for url in map(fixup, fd) if url]\n\n\ndef urlencode_postdata(*args, **kargs):\n    return compat_urllib_parse_urlencode(*args, **kargs).encode('ascii')\n\n\ndef update_url_query(url, query):\n    if not query:\n        return url\n    parsed_url = compat_urlparse.urlparse(url)\n    qs = compat_parse_qs(parsed_url.query)\n    qs.update(query)\n    return compat_urlparse.urlunparse(parsed_url._replace(\n        query=compat_urllib_parse_urlencode(qs, True)))\n\n\ndef update_Request(req, url=None, data=None, headers={}, query={}):\n    req_headers = req.headers.copy()\n    req_headers.update(headers)\n    req_data = data or req.data\n    req_url = update_url_query(url or req.get_full_url(), query)\n    req_get_method = req.get_method()\n    if req_get_method == 'HEAD':\n        req_type = HEADRequest\n    elif req_get_method == 'PUT':\n        req_type = PUTRequest\n    else:\n        req_type = compat_urllib_request.Request\n    new_req = req_type(\n        req_url, data=req_data, headers=req_headers,\n        origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n    if hasattr(req, 'timeout'):\n        new_req.timeout = req.timeout\n    return new_req\n\n\ndef _multipart_encode_impl(data, boundary):\n    content_type = 'multipart/form-data; boundary=%s' % boundary\n\n    out = b''\n    for k, v in data.items():\n        out += b'--' + boundary.encode('ascii') + b'\\r\\n'\n        if isinstance(k, compat_str):\n            k = k.encode('utf-8')\n        if isinstance(v, compat_str):\n            v = v.encode('utf-8')\n        # RFC 2047 requires non-ASCII field names to be encoded, while RFC 7578\n        # suggests sending UTF-8 directly. Firefox sends UTF-8, too\n        content = b'Content-Disposition: form-data; name=\"' + k + b'\"\\r\\n\\r\\n' + v + b'\\r\\n'\n        if boundary.encode('ascii') in content:\n            raise ValueError('Boundary overlaps with data')\n        out += content\n\n    out += b'--' + boundary.encode('ascii') + b'--\\r\\n'\n\n    return out, content_type\n\n\ndef multipart_encode(data, boundary=None):\n    '''\n    Encode a dict to RFC 7578-compliant form-data\n\n    data:\n        A dict where keys and values can be either Unicode or bytes-like\n        objects.\n    boundary:\n        If specified a Unicode object, it's used as the boundary. Otherwise\n        a random boundary is generated.\n\n    Reference: https://tools.ietf.org/html/rfc7578\n    '''\n    has_specified_boundary = boundary is not None\n\n    while True:\n        if boundary is None:\n            boundary = '---------------' + str(random.randrange(0x0fffffff, 0xffffffff))\n\n        try:\n            out, content_type = _multipart_encode_impl(data, boundary)\n            break\n        except ValueError:\n            if has_specified_boundary:\n                raise\n            boundary = None\n\n    return out, content_type\n\n\ndef dict_get(d, key_or_keys, default=None, skip_false_values=True):\n    if isinstance(key_or_keys, (list, tuple)):\n        for key in key_or_keys:\n            if key not in d or d[key] is None or skip_false_values and not d[key]:\n                continue\n            return d[key]\n        return default\n    return d.get(key_or_keys, default)\n\n\ndef try_get(src, getter, expected_type=None):\n    if not isinstance(getter, (list, tuple)):\n        getter = [getter]\n    for get in getter:\n        try:\n            v = get(src)\n        except (AttributeError, KeyError, TypeError, IndexError):\n            pass\n        else:\n            if expected_type is None or isinstance(v, expected_type):\n                return v\n\n\ndef encode_compat_str(string, encoding=preferredencoding(), errors='strict'):\n    return string if isinstance(string, compat_str) else compat_str(string, encoding, errors)\n\n\nUS_RATINGS = {\n    'G': 0,\n    'PG': 10,\n    'PG-13': 13,\n    'R': 16,\n    'NC': 18,\n}\n\n\nTV_PARENTAL_GUIDELINES = {\n    'TV-Y': 0,\n    'TV-Y7': 7,\n    'TV-G': 0,\n    'TV-PG': 0,\n    'TV-14': 14,\n    'TV-MA': 17,\n}\n\n\ndef parse_age_limit(s):\n    if type(s) == int:\n        return s if 0 <= s <= 21 else None\n    if not isinstance(s, compat_basestring):\n        return None\n    m = re.match(r'^(?P<age>\\d{1,2})\\+?$', s)\n    if m:\n        return int(m.group('age'))\n    if s in US_RATINGS:\n        return US_RATINGS[s]\n    return TV_PARENTAL_GUIDELINES.get(s)\n\n\ndef strip_jsonp(code):\n    return re.sub(\n        r'''(?sx)^\n            (?:window\\.)?(?P<func_name>[a-zA-Z0-9_.$]+)\n            (?:\\s*&&\\s*(?P=func_name))?\n            \\s*\\(\\s*(?P<callback_data>.*)\\);?\n            \\s*?(?://[^\\n]*)*$''',\n        r'\\g<callback_data>', code)\n\n\ndef js_to_json(code):\n    COMMENT_RE = r'/\\*(?:(?!\\*/).)*?\\*/|//[^\\n]*'\n    SKIP_RE = r'\\s*(?:{comment})?\\s*'.format(comment=COMMENT_RE)\n    INTEGER_TABLE = (\n        (r'(?s)^(0[xX][0-9a-fA-F]+){skip}:?$'.format(skip=SKIP_RE), 16),\n        (r'(?s)^(0+[0-7]+){skip}:?$'.format(skip=SKIP_RE), 8),\n    )\n\n    def fix_kv(m):\n        v = m.group(0)\n        if v in ('true', 'false', 'null'):\n            return v\n        elif v.startswith('/*') or v.startswith('//') or v == ',':\n            return \"\"\n\n        if v[0] in (\"'\", '\"'):\n            v = re.sub(r'(?s)\\\\.|\"', lambda m: {\n                '\"': '\\\\\"',\n                \"\\\\'\": \"'\",\n                '\\\\\\n': '',\n                '\\\\x': '\\\\u00',\n            }.get(m.group(0), m.group(0)), v[1:-1])\n\n        for regex, base in INTEGER_TABLE:\n            im = re.match(regex, v)\n            if im:\n                i = int(im.group(1), base)\n                return '\"%d\":' % i if v.endswith(':') else '%d' % i\n\n        return '\"%s\"' % v\n\n    return re.sub(r'''(?sx)\n        \"(?:[^\"\\\\]*(?:\\\\\\\\|\\\\['\"nurtbfx/\\n]))*[^\"\\\\]*\"|\n        '(?:[^'\\\\]*(?:\\\\\\\\|\\\\['\"nurtbfx/\\n]))*[^'\\\\]*'|\n        {comment}|,(?={skip}[\\]}}])|\n        (?:(?<![0-9])[eE]|[a-df-zA-DF-Z_])[.a-zA-Z_0-9]*|\n        \\b(?:0[xX][0-9a-fA-F]+|0+[0-7]+)(?:{skip}:)?|\n        [0-9]+(?={skip}:)\n        '''.format(comment=COMMENT_RE, skip=SKIP_RE), fix_kv, code)\n\n\ndef qualities(quality_ids):\n    \"\"\" Get a numeric quality value out of a list of possible values \"\"\"\n    def q(qid):\n        try:\n            return quality_ids.index(qid)\n        except ValueError:\n            return -1\n    return q\n\n\nDEFAULT_OUTTMPL = '%(title)s-%(id)s.%(ext)s'\n\n\ndef limit_length(s, length):\n    \"\"\" Add ellipses to overly long strings \"\"\"\n    if s is None:\n        return None\n    ELLIPSES = '...'\n    if len(s) > length:\n        return s[:length - len(ELLIPSES)] + ELLIPSES\n    return s\n\n\ndef version_tuple(v):\n    return tuple(int(e) for e in re.split(r'[-.]', v))\n\n\ndef is_outdated_version(version, limit, assume_new=True):\n    if not version:\n        return not assume_new\n    try:\n        return version_tuple(version) < version_tuple(limit)\n    except ValueError:\n        return not assume_new\n\n\ndef ytdl_is_updateable():\n    \"\"\" Returns if youtube-dl can be updated with -U \"\"\"\n    from zipimport import zipimporter\n\n    return isinstance(globals().get('__loader__'), zipimporter) or hasattr(sys, 'frozen')\n\n\ndef args_to_str(args):\n    # Get a short string representation for a subprocess command\n    return ' '.join(compat_shlex_quote(a) for a in args)\n\n\ndef error_to_compat_str(err):\n    err_str = str(err)\n    # On python 2 error byte string must be decoded with proper\n    # encoding rather than ascii\n    if sys.version_info[0] < 3:\n        err_str = err_str.decode(preferredencoding())\n    return err_str\n\n\ndef mimetype2ext(mt):\n    if mt is None:\n        return None\n\n    ext = {\n        'audio/mp4': 'm4a',\n        # Per RFC 3003, audio/mpeg can be .mp1, .mp2 or .mp3. Here use .mp3 as\n        # it's the most popular one\n        'audio/mpeg': 'mp3',\n    }.get(mt)\n    if ext is not None:\n        return ext\n\n    _, _, res = mt.rpartition('/')\n    res = res.split(';')[0].strip().lower()\n\n    return {\n        '3gpp': '3gp',\n        'smptett+xml': 'tt',\n        'ttaf+xml': 'dfxp',\n        'ttml+xml': 'ttml',\n        'x-flv': 'flv',\n        'x-mp4-fragmented': 'mp4',\n        'x-ms-sami': 'sami',\n        'x-ms-wmv': 'wmv',\n        'mpegurl': 'm3u8',\n        'x-mpegurl': 'm3u8',\n        'vnd.apple.mpegurl': 'm3u8',\n        'dash+xml': 'mpd',\n        'f4m+xml': 'f4m',\n        'hds+xml': 'f4m',\n        'vnd.ms-sstr+xml': 'ism',\n        'quicktime': 'mov',\n        'mp2t': 'ts',\n    }.get(res, res)\n\n\ndef parse_codecs(codecs_str):\n    # http://tools.ietf.org/html/rfc6381\n    if not codecs_str:\n        return {}\n    splited_codecs = list(filter(None, map(\n        lambda str: str.strip(), codecs_str.strip().strip(',').split(','))))\n    vcodec, acodec = None, None\n    for full_codec in splited_codecs:\n        codec = full_codec.split('.')[0]\n        if codec in ('avc1', 'avc2', 'avc3', 'avc4', 'vp9', 'vp8', 'hev1', 'hev2', 'h263', 'h264', 'mp4v', 'hvc1'):\n            if not vcodec:\n                vcodec = full_codec\n        elif codec in ('mp4a', 'opus', 'vorbis', 'mp3', 'aac', 'ac-3', 'ec-3', 'eac3', 'dtsc', 'dtse', 'dtsh', 'dtsl'):\n            if not acodec:\n                acodec = full_codec\n        else:\n            write_string('WARNING: Unknown codec %s\\n' % full_codec, sys.stderr)\n    if not vcodec and not acodec:\n        if len(splited_codecs) == 2:\n            return {\n                'vcodec': vcodec,\n                'acodec': acodec,\n            }\n        elif len(splited_codecs) == 1:\n            return {\n                'vcodec': 'none',\n                'acodec': vcodec,\n            }\n    else:\n        return {\n            'vcodec': vcodec or 'none',\n            'acodec': acodec or 'none',\n        }\n    return {}\n\n\ndef urlhandle_detect_ext(url_handle):\n    getheader = url_handle.headers.get\n\n    cd = getheader('Content-Disposition')\n    if cd:\n        m = re.match(r'attachment;\\s*filename=\"(?P<filename>[^\"]+)\"', cd)\n        if m:\n            e = determine_ext(m.group('filename'), default_ext=None)\n            if e:\n                return e\n\n    return mimetype2ext(getheader('Content-Type'))\n\n\ndef encode_data_uri(data, mime_type):\n    return 'data:%s;base64,%s' % (mime_type, base64.b64encode(data).decode('ascii'))\n\n\ndef age_restricted(content_limit, age_limit):\n    \"\"\" Returns True iff the content should be blocked \"\"\"\n\n    if age_limit is None:  # No limit set\n        return False\n    if content_limit is None:\n        return False  # Content available for everyone\n    return age_limit < content_limit\n\n\ndef is_html(first_bytes):\n    \"\"\" Detect whether a file contains HTML by examining its first bytes. \"\"\"\n\n    BOMS = [\n        (b'\\xef\\xbb\\xbf', 'utf-8'),\n        (b'\\x00\\x00\\xfe\\xff', 'utf-32-be'),\n        (b'\\xff\\xfe\\x00\\x00', 'utf-32-le'),\n        (b'\\xff\\xfe', 'utf-16-le'),\n        (b'\\xfe\\xff', 'utf-16-be'),\n    ]\n    for bom, enc in BOMS:\n        if first_bytes.startswith(bom):\n            s = first_bytes[len(bom):].decode(enc, 'replace')\n            break\n    else:\n        s = first_bytes.decode('utf-8', 'replace')\n\n    return re.match(r'^\\s*<', s)\n\n\ndef determine_protocol(info_dict):\n    protocol = info_dict.get('protocol')\n    if protocol is not None:\n        return protocol\n\n    url = info_dict['url']\n    if url.startswith('rtmp'):\n        return 'rtmp'\n    elif url.startswith('mms'):\n        return 'mms'\n    elif url.startswith('rtsp'):\n        return 'rtsp'\n\n    ext = determine_ext(url)\n    if ext == 'm3u8':\n        return 'm3u8'\n    elif ext == 'f4m':\n        return 'f4m'\n\n    return compat_urllib_parse_urlparse(url).scheme\n\n\ndef render_table(header_row, data):\n    \"\"\" Render a list of rows, each as a list of values \"\"\"\n    table = [header_row] + data\n    max_lens = [max(len(compat_str(v)) for v in col) for col in zip(*table)]\n    format_str = ' '.join('%-' + compat_str(ml + 1) + 's' for ml in max_lens[:-1]) + '%s'\n    return '\\n'.join(format_str % tuple(row) for row in table)\n\n\ndef _match_one(filter_part, dct):\n    COMPARISON_OPERATORS = {\n        '<': operator.lt,\n        '<=': operator.le,\n        '>': operator.gt,\n        '>=': operator.ge,\n        '=': operator.eq,\n        '!=': operator.ne,\n    }\n    operator_rex = re.compile(r'''(?x)\\s*\n        (?P<key>[a-z_]+)\n        \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\\s*\n        (?:\n            (?P<intval>[0-9.]+(?:[kKmMgGtTpPeEzZyY]i?[Bb]?)?)|\n            (?P<quote>[\"\\'])(?P<quotedstrval>(?:\\\\.|(?!(?P=quote)|\\\\).)+?)(?P=quote)|\n            (?P<strval>(?![0-9.])[a-z0-9A-Z]*)\n        )\n        \\s*$\n        ''' % '|'.join(map(re.escape, COMPARISON_OPERATORS.keys())))\n    m = operator_rex.search(filter_part)\n    if m:\n        op = COMPARISON_OPERATORS[m.group('op')]\n        actual_value = dct.get(m.group('key'))\n        if (m.group('quotedstrval') is not None or\n            m.group('strval') is not None or\n            # If the original field is a string and matching comparisonvalue is\n            # a number we should respect the origin of the original field\n            # and process comparison value as a string (see\n            # https://github.com/rg3/youtube-dl/issues/11082).\n            actual_value is not None and m.group('intval') is not None and\n                isinstance(actual_value, compat_str)):\n            if m.group('op') not in ('=', '!='):\n                raise ValueError(\n                    'Operator %s does not support string values!' % m.group('op'))\n            comparison_value = m.group('quotedstrval') or m.group('strval') or m.group('intval')\n            quote = m.group('quote')\n            if quote is not None:\n                comparison_value = comparison_value.replace(r'\\%s' % quote, quote)\n        else:\n            try:\n                comparison_value = int(m.group('intval'))\n            except ValueError:\n                comparison_value = parse_filesize(m.group('intval'))\n                if comparison_value is None:\n                    comparison_value = parse_filesize(m.group('intval') + 'B')\n                if comparison_value is None:\n                    raise ValueError(\n                        'Invalid integer value %r in filter part %r' % (\n                            m.group('intval'), filter_part))\n        if actual_value is None:\n            return m.group('none_inclusive')\n        return op(actual_value, comparison_value)\n\n    UNARY_OPERATORS = {\n        '': lambda v: v is not None,\n        '!': lambda v: v is None,\n    }\n    operator_rex = re.compile(r'''(?x)\\s*\n        (?P<op>%s)\\s*(?P<key>[a-z_]+)\n        \\s*$\n        ''' % '|'.join(map(re.escape, UNARY_OPERATORS.keys())))\n    m = operator_rex.search(filter_part)\n    if m:\n        op = UNARY_OPERATORS[m.group('op')]\n        actual_value = dct.get(m.group('key'))\n        return op(actual_value)\n\n    raise ValueError('Invalid filter part %r' % filter_part)\n\n\ndef match_str(filter_str, dct):\n    \"\"\" Filter a dictionary with a simple string syntax. Returns True (=passes filter) or false \"\"\"\n\n    return all(\n        _match_one(filter_part, dct) for filter_part in filter_str.split('&'))\n\n\ndef match_filter_func(filter_str):\n    def _match_func(info_dict):\n        if match_str(filter_str, info_dict):\n            return None\n        else:\n            video_title = info_dict.get('title', info_dict.get('id', 'video'))\n            return '%s does not pass filter %s, skipping ..' % (video_title, filter_str)\n    return _match_func\n\n\ndef parse_dfxp_time_expr(time_expr):\n    if not time_expr:\n        return\n\n    mobj = re.match(r'^(?P<time_offset>\\d+(?:\\.\\d+)?)s?$', time_expr)\n    if mobj:\n        return float(mobj.group('time_offset'))\n\n    mobj = re.match(r'^(\\d+):(\\d\\d):(\\d\\d(?:(?:\\.|:)\\d+)?)$', time_expr)\n    if mobj:\n        return 3600 * int(mobj.group(1)) + 60 * int(mobj.group(2)) + float(mobj.group(3).replace(':', '.'))\n\n\ndef srt_subtitles_timecode(seconds):\n    return '%02d:%02d:%02d,%03d' % (seconds / 3600, (seconds % 3600) / 60, seconds % 60, (seconds % 1) * 1000)\n\n\ndef dfxp2srt(dfxp_data):\n    '''\n    @param dfxp_data A bytes-like object containing DFXP data\n    @returns A unicode object containing converted SRT data\n    '''\n    LEGACY_NAMESPACES = (\n        (b'http://www.w3.org/ns/ttml', [\n            b'http://www.w3.org/2004/11/ttaf1',\n            b'http://www.w3.org/2006/04/ttaf1',\n            b'http://www.w3.org/2006/10/ttaf1',\n        ]),\n        (b'http://www.w3.org/ns/ttml#styling', [\n            b'http://www.w3.org/ns/ttml#style',\n        ]),\n    )\n\n    SUPPORTED_STYLING = [\n        'color',\n        'fontFamily',\n        'fontSize',\n        'fontStyle',\n        'fontWeight',\n        'textDecoration'\n    ]\n\n    _x = functools.partial(xpath_with_ns, ns_map={\n        'ttml': 'http://www.w3.org/ns/ttml',\n        'tts': 'http://www.w3.org/ns/ttml#styling',\n    })\n\n    styles = {}\n    default_style = {}\n\n    class TTMLPElementParser(object):\n        _out = ''\n        _unclosed_elements = []\n        _applied_styles = []\n\n        def start(self, tag, attrib):\n            if tag in (_x('ttml:br'), 'br'):\n                self._out += '\\n'\n            else:\n                unclosed_elements = []\n                style = {}\n                element_style_id = attrib.get('style')\n                if default_style:\n                    style.update(default_style)\n                if element_style_id:\n                    style.update(styles.get(element_style_id, {}))\n                for prop in SUPPORTED_STYLING:\n                    prop_val = attrib.get(_x('tts:' + prop))\n                    if prop_val:\n                        style[prop] = prop_val\n                if style:\n                    font = ''\n                    for k, v in sorted(style.items()):\n                        if self._applied_styles and self._applied_styles[-1].get(k) == v:\n                            continue\n                        if k == 'color':\n                            font += ' color=\"%s\"' % v\n                        elif k == 'fontSize':\n                            font += ' size=\"%s\"' % v\n                        elif k == 'fontFamily':\n                            font += ' face=\"%s\"' % v\n                        elif k == 'fontWeight' and v == 'bold':\n                            self._out += '<b>'\n                            unclosed_elements.append('b')\n                        elif k == 'fontStyle' and v == 'italic':\n                            self._out += '<i>'\n                            unclosed_elements.append('i')\n                        elif k == 'textDecoration' and v == 'underline':\n                            self._out += '<u>'\n                            unclosed_elements.append('u')\n                    if font:\n                        self._out += '<font' + font + '>'\n                        unclosed_elements.append('font')\n                    applied_style = {}\n                    if self._applied_styles:\n                        applied_style.update(self._applied_styles[-1])\n                    applied_style.update(style)\n                    self._applied_styles.append(applied_style)\n                self._unclosed_elements.append(unclosed_elements)\n\n        def end(self, tag):\n            if tag not in (_x('ttml:br'), 'br'):\n                unclosed_elements = self._unclosed_elements.pop()\n                for element in reversed(unclosed_elements):\n                    self._out += '</%s>' % element\n                if unclosed_elements and self._applied_styles:\n                    self._applied_styles.pop()\n\n        def data(self, data):\n            self._out += data\n\n        def close(self):\n            return self._out.strip()\n\n    def parse_node(node):\n        target = TTMLPElementParser()\n        parser = xml.etree.ElementTree.XMLParser(target=target)\n        parser.feed(xml.etree.ElementTree.tostring(node))\n        return parser.close()\n\n    for k, v in LEGACY_NAMESPACES:\n        for ns in v:\n            dfxp_data = dfxp_data.replace(ns, k)\n\n    dfxp = compat_etree_fromstring(dfxp_data)\n    out = []\n    paras = dfxp.findall(_x('.//ttml:p')) or dfxp.findall('.//p')\n\n    if not paras:\n        raise ValueError('Invalid dfxp/TTML subtitle')\n\n    repeat = False\n    while True:\n        for style in dfxp.findall(_x('.//ttml:style')):\n            style_id = style.get('id')\n            parent_style_id = style.get('style')\n            if parent_style_id:\n                if parent_style_id not in styles:\n                    repeat = True\n                    continue\n                styles[style_id] = styles[parent_style_id].copy()\n            for prop in SUPPORTED_STYLING:\n                prop_val = style.get(_x('tts:' + prop))\n                if prop_val:\n                    styles.setdefault(style_id, {})[prop] = prop_val\n        if repeat:\n            repeat = False\n        else:\n            break\n\n    for p in ('body', 'div'):\n        ele = xpath_element(dfxp, [_x('.//ttml:' + p), './/' + p])\n        if ele is None:\n            continue\n        style = styles.get(ele.get('style'))\n        if not style:\n            continue\n        default_style.update(style)\n\n    for para, index in zip(paras, itertools.count(1)):\n        begin_time = parse_dfxp_time_expr(para.attrib.get('begin'))\n        end_time = parse_dfxp_time_expr(para.attrib.get('end'))\n        dur = parse_dfxp_time_expr(para.attrib.get('dur'))\n        if begin_time is None:\n            continue\n        if not end_time:\n            if not dur:\n                continue\n            end_time = begin_time + dur\n        out.append('%d\\n%s --> %s\\n%s\\n\\n' % (\n            index,\n            srt_subtitles_timecode(begin_time),\n            srt_subtitles_timecode(end_time),\n            parse_node(para)))\n\n    return ''.join(out)\n\n\ndef cli_option(params, command_option, param):\n    param = params.get(param)\n    if param:\n        param = compat_str(param)\n    return [command_option, param] if param is not None else []\n\n\ndef cli_bool_option(params, command_option, param, true_value='true', false_value='false', separator=None):\n    param = params.get(param)\n    if param is None:\n        return []\n    assert isinstance(param, bool)\n    if separator:\n        return [command_option + separator + (true_value if param else false_value)]\n    return [command_option, true_value if param else false_value]\n\n\ndef cli_valueless_option(params, command_option, param, expected_value=True):\n    param = params.get(param)\n    return [command_option] if param == expected_value else []\n\n\ndef cli_configuration_args(params, param, default=[]):\n    ex_args = params.get(param)\n    if ex_args is None:\n        return default\n    assert isinstance(ex_args, list)\n    return ex_args\n\n\nclass ISO639Utils(object):\n    # See http://www.loc.gov/standards/iso639-2/ISO-639-2_utf-8.txt\n    _lang_map = {\n        'aa': 'aar',\n        'ab': 'abk',\n        'ae': 'ave',\n        'af': 'afr',\n        'ak': 'aka',\n        'am': 'amh',\n        'an': 'arg',\n        'ar': 'ara',\n        'as': 'asm',\n        'av': 'ava',\n        'ay': 'aym',\n        'az': 'aze',\n        'ba': 'bak',\n        'be': 'bel',\n        'bg': 'bul',\n        'bh': 'bih',\n        'bi': 'bis',\n        'bm': 'bam',\n        'bn': 'ben',\n        'bo': 'bod',\n        'br': 'bre',\n        'bs': 'bos',\n        'ca': 'cat',\n        'ce': 'che',\n        'ch': 'cha',\n        'co': 'cos',\n        'cr': 'cre',\n        'cs': 'ces',\n        'cu': 'chu',\n        'cv': 'chv',\n        'cy': 'cym',\n        'da': 'dan',\n        'de': 'deu',\n        'dv': 'div',\n        'dz': 'dzo',\n        'ee': 'ewe',\n        'el': 'ell',\n        'en': 'eng',\n        'eo': 'epo',\n        'es': 'spa',\n        'et': 'est',\n        'eu': 'eus',\n        'fa': 'fas',\n        'ff': 'ful',\n        'fi': 'fin',\n        'fj': 'fij',\n        'fo': 'fao',\n        'fr': 'fra',\n        'fy': 'fry',\n        'ga': 'gle',\n        'gd': 'gla',\n        'gl': 'glg',\n        'gn': 'grn',\n        'gu': 'guj',\n        'gv': 'glv',\n        'ha': 'hau',\n        'he': 'heb',\n        'hi': 'hin',\n        'ho': 'hmo',\n        'hr': 'hrv',\n        'ht': 'hat',\n        'hu': 'hun',\n        'hy': 'hye',\n        'hz': 'her',\n        'ia': 'ina',\n        'id': 'ind',\n        'ie': 'ile',\n        'ig': 'ibo',\n        'ii': 'iii',\n        'ik': 'ipk',\n        'io': 'ido',\n        'is': 'isl',\n        'it': 'ita',\n        'iu': 'iku',\n        'ja': 'jpn',\n        'jv': 'jav',\n        'ka': 'kat',\n        'kg': 'kon',\n        'ki': 'kik',\n        'kj': 'kua',\n        'kk': 'kaz',\n        'kl': 'kal',\n        'km': 'khm',\n        'kn': 'kan',\n        'ko': 'kor',\n        'kr': 'kau',\n        'ks': 'kas',\n        'ku': 'kur',\n        'kv': 'kom',\n        'kw': 'cor',\n        'ky': 'kir',\n        'la': 'lat',\n        'lb': 'ltz',\n        'lg': 'lug',\n        'li': 'lim',\n        'ln': 'lin',\n        'lo': 'lao',\n        'lt': 'lit',\n        'lu': 'lub',\n        'lv': 'lav',\n        'mg': 'mlg',\n        'mh': 'mah',\n        'mi': 'mri',\n        'mk': 'mkd',\n        'ml': 'mal',\n        'mn': 'mon',\n        'mr': 'mar',\n        'ms': 'msa',\n        'mt': 'mlt',\n        'my': 'mya',\n        'na': 'nau',\n        'nb': 'nob',\n        'nd': 'nde',\n        'ne': 'nep',\n        'ng': 'ndo',\n        'nl': 'nld',\n        'nn': 'nno',\n        'no': 'nor',\n        'nr': 'nbl',\n        'nv': 'nav',\n        'ny': 'nya',\n        'oc': 'oci',\n        'oj': 'oji',\n        'om': 'orm',\n        'or': 'ori',\n        'os': 'oss',\n        'pa': 'pan',\n        'pi': 'pli',\n        'pl': 'pol',\n        'ps': 'pus',\n        'pt': 'por',\n        'qu': 'que',\n        'rm': 'roh',\n        'rn': 'run',\n        'ro': 'ron',\n        'ru': 'rus',\n        'rw': 'kin',\n        'sa': 'san',\n        'sc': 'srd',\n        'sd': 'snd',\n        'se': 'sme',\n        'sg': 'sag',\n        'si': 'sin',\n        'sk': 'slk',\n        'sl': 'slv',\n        'sm': 'smo',\n        'sn': 'sna',\n        'so': 'som',\n        'sq': 'sqi',\n        'sr': 'srp',\n        'ss': 'ssw',\n        'st': 'sot',\n        'su': 'sun',\n        'sv': 'swe',\n        'sw': 'swa',\n        'ta': 'tam',\n        'te': 'tel',\n        'tg': 'tgk',\n        'th': 'tha',\n        'ti': 'tir',\n        'tk': 'tuk',\n        'tl': 'tgl',\n        'tn': 'tsn',\n        'to': 'ton',\n        'tr': 'tur',\n        'ts': 'tso',\n        'tt': 'tat',\n        'tw': 'twi',\n        'ty': 'tah',\n        'ug': 'uig',\n        'uk': 'ukr',\n        'ur': 'urd',\n        'uz': 'uzb',\n        've': 'ven',\n        'vi': 'vie',\n        'vo': 'vol',\n        'wa': 'wln',\n        'wo': 'wol',\n        'xh': 'xho',\n        'yi': 'yid',\n        'yo': 'yor',\n        'za': 'zha',\n        'zh': 'zho',\n        'zu': 'zul',\n    }\n\n    @classmethod\n    def short2long(cls, code):\n        \"\"\"Convert language code from ISO 639-1 to ISO 639-2/T\"\"\"\n        return cls._lang_map.get(code[:2])\n\n    @classmethod\n    def long2short(cls, code):\n        \"\"\"Convert language code from ISO 639-2/T to ISO 639-1\"\"\"\n        for short_name, long_name in cls._lang_map.items():\n            if long_name == code:\n                return short_name\n\n\nclass ISO3166Utils(object):\n    # From http://data.okfn.org/data/core/country-list\n    _country_map = {\n        'AF': 'Afghanistan',\n        'AX': '\u00c5land Islands',\n        'AL': 'Albania',\n        'DZ': 'Algeria',\n        'AS': 'American Samoa',\n        'AD': 'Andorra',\n        'AO': 'Angola',\n        'AI': 'Anguilla',\n        'AQ': 'Antarctica',\n        'AG': 'Antigua and Barbuda',\n        'AR': 'Argentina',\n        'AM': 'Armenia',\n        'AW': 'Aruba',\n        'AU': 'Australia',\n        'AT': 'Austria',\n        'AZ': 'Azerbaijan',\n        'BS': 'Bahamas',\n        'BH': 'Bahrain',\n        'BD': 'Bangladesh',\n        'BB': 'Barbados',\n        'BY': 'Belarus',\n        'BE': 'Belgium',\n        'BZ': 'Belize',\n        'BJ': 'Benin',\n        'BM': 'Bermuda',\n        'BT': 'Bhutan',\n        'BO': 'Bolivia, Plurinational State of',\n        'BQ': 'Bonaire, Sint Eustatius and Saba',\n        'BA': 'Bosnia and Herzegovina',\n        'BW': 'Botswana',\n        'BV': 'Bouvet Island',\n        'BR': 'Brazil',\n        'IO': 'British Indian Ocean Territory',\n        'BN': 'Brunei Darussalam',\n        'BG': 'Bulgaria',\n        'BF': 'Burkina Faso',\n        'BI': 'Burundi',\n        'KH': 'Cambodia',\n        'CM': 'Cameroon',\n        'CA': 'Canada',\n        'CV': 'Cape Verde',\n        'KY': 'Cayman Islands',\n        'CF': 'Central African Republic',\n        'TD': 'Chad',\n        'CL': 'Chile',\n        'CN': 'China',\n        'CX': 'Christmas Island',\n        'CC': 'Cocos (Keeling) Islands',\n        'CO': 'Colombia',\n        'KM': 'Comoros',\n        'CG': 'Congo',\n        'CD': 'Congo, the Democratic Republic of the',\n        'CK': 'Cook Islands',\n        'CR': 'Costa Rica',\n        'CI': 'C\u00f4te d\\'Ivoire',\n        'HR': 'Croatia',\n        'CU': 'Cuba',\n        'CW': 'Cura\u00e7ao',\n        'CY': 'Cyprus',\n        'CZ': 'Czech Republic',\n        'DK': 'Denmark',\n        'DJ': 'Djibouti',\n        'DM': 'Dominica',\n        'DO': 'Dominican Republic',\n        'EC': 'Ecuador',\n        'EG': 'Egypt',\n        'SV': 'El Salvador',\n        'GQ': 'Equatorial Guinea',\n        'ER': 'Eritrea',\n        'EE': 'Estonia',\n        'ET': 'Ethiopia',\n        'FK': 'Falkland Islands (Malvinas)',\n        'FO': 'Faroe Islands',\n        'FJ': 'Fiji',\n        'FI': 'Finland',\n        'FR': 'France',\n        'GF': 'French Guiana',\n        'PF': 'French Polynesia',\n        'TF': 'French Southern Territories',\n        'GA': 'Gabon',\n        'GM': 'Gambia',\n        'GE': 'Georgia',\n        'DE': 'Germany',\n        'GH': 'Ghana',\n        'GI': 'Gibraltar',\n        'GR': 'Greece',\n        'GL': 'Greenland',\n        'GD': 'Grenada',\n        'GP': 'Guadeloupe',\n        'GU': 'Guam',\n        'GT': 'Guatemala',\n        'GG': 'Guernsey',\n        'GN': 'Guinea',\n        'GW': 'Guinea-Bissau',\n        'GY': 'Guyana',\n        'HT': 'Haiti',\n        'HM': 'Heard Island and McDonald Islands',\n        'VA': 'Holy See (Vatican City State)',\n        'HN': 'Honduras',\n        'HK': 'Hong Kong',\n        'HU': 'Hungary',\n        'IS': 'Iceland',\n        'IN': 'India',\n        'ID': 'Indonesia',\n        'IR': 'Iran, Islamic Republic of',\n        'IQ': 'Iraq',\n        'IE': 'Ireland',\n        'IM': 'Isle of Man',\n        'IL': 'Israel',\n        'IT': 'Italy',\n        'JM': 'Jamaica',\n        'JP': 'Japan',\n        'JE': 'Jersey',\n        'JO': 'Jordan',\n        'KZ': 'Kazakhstan',\n        'KE': 'Kenya',\n        'KI': 'Kiribati',\n        'KP': 'Korea, Democratic People\\'s Republic of',\n        'KR': 'Korea, Republic of',\n        'KW': 'Kuwait',\n        'KG': 'Kyrgyzstan',\n        'LA': 'Lao People\\'s Democratic Republic',\n        'LV': 'Latvia',\n        'LB': 'Lebanon',\n        'LS': 'Lesotho',\n        'LR': 'Liberia',\n        'LY': 'Libya',\n        'LI': 'Liechtenstein',\n        'LT': 'Lithuania',\n        'LU': 'Luxembourg',\n        'MO': 'Macao',\n        'MK': 'Macedonia, the Former Yugoslav Republic of',\n        'MG': 'Madagascar',\n        'MW': 'Malawi',\n        'MY': 'Malaysia',\n        'MV': 'Maldives',\n        'ML': 'Mali',\n        'MT': 'Malta',\n        'MH': 'Marshall Islands',\n        'MQ': 'Martinique',\n        'MR': 'Mauritania',\n        'MU': 'Mauritius',\n        'YT': 'Mayotte',\n        'MX': 'Mexico',\n        'FM': 'Micronesia, Federated States of',\n        'MD': 'Moldova, Republic of',\n        'MC': 'Monaco',\n        'MN': 'Mongolia',\n        'ME': 'Montenegro',\n        'MS': 'Montserrat',\n        'MA': 'Morocco',\n        'MZ': 'Mozambique',\n        'MM': 'Myanmar',\n        'NA': 'Namibia',\n        'NR': 'Nauru',\n        'NP': 'Nepal',\n        'NL': 'Netherlands',\n        'NC': 'New Caledonia',\n        'NZ': 'New Zealand',\n        'NI': 'Nicaragua',\n        'NE': 'Niger',\n        'NG': 'Nigeria',\n        'NU': 'Niue',\n        'NF': 'Norfolk Island',\n        'MP': 'Northern Mariana Islands',\n        'NO': 'Norway',\n        'OM': 'Oman',\n        'PK': 'Pakistan',\n        'PW': 'Palau',\n        'PS': 'Palestine, State of',\n        'PA': 'Panama',\n        'PG': 'Papua New Guinea',\n        'PY': 'Paraguay',\n        'PE': 'Peru',\n        'PH': 'Philippines',\n        'PN': 'Pitcairn',\n        'PL': 'Poland',\n        'PT': 'Portugal',\n        'PR': 'Puerto Rico',\n        'QA': 'Qatar',\n        'RE': 'R\u00e9union',\n        'RO': 'Romania',\n        'RU': 'Russian Federation',\n        'RW': 'Rwanda',\n        'BL': 'Saint Barth\u00e9lemy',\n        'SH': 'Saint Helena, Ascension and Tristan da Cunha',\n        'KN': 'Saint Kitts and Nevis',\n        'LC': 'Saint Lucia',\n        'MF': 'Saint Martin (French part)',\n        'PM': 'Saint Pierre and Miquelon',\n        'VC': 'Saint Vincent and the Grenadines',\n        'WS': 'Samoa',\n        'SM': 'San Marino',\n        'ST': 'Sao Tome and Principe',\n        'SA': 'Saudi Arabia',\n        'SN': 'Senegal',\n        'RS': 'Serbia',\n        'SC': 'Seychelles',\n        'SL': 'Sierra Leone',\n        'SG': 'Singapore',\n        'SX': 'Sint Maarten (Dutch part)',\n        'SK': 'Slovakia',\n        'SI': 'Slovenia',\n        'SB': 'Solomon Islands',\n        'SO': 'Somalia',\n        'ZA': 'South Africa',\n        'GS': 'South Georgia and the South Sandwich Islands',\n        'SS': 'South Sudan',\n        'ES': 'Spain',\n        'LK': 'Sri Lanka',\n        'SD': 'Sudan',\n        'SR': 'Suriname',\n        'SJ': 'Svalbard and Jan Mayen',\n        'SZ': 'Swaziland',\n        'SE': 'Sweden',\n        'CH': 'Switzerland',\n        'SY': 'Syrian Arab Republic',\n        'TW': 'Taiwan, Province of China',\n        'TJ': 'Tajikistan',\n        'TZ': 'Tanzania, United Republic of',\n        'TH': 'Thailand',\n        'TL': 'Timor-Leste',\n        'TG': 'Togo',\n        'TK': 'Tokelau',\n        'TO': 'Tonga',\n        'TT': 'Trinidad and Tobago',\n        'TN': 'Tunisia',\n        'TR': 'Turkey',\n        'TM': 'Turkmenistan',\n        'TC': 'Turks and Caicos Islands',\n        'TV': 'Tuvalu',\n        'UG': 'Uganda',\n        'UA': 'Ukraine',\n        'AE': 'United Arab Emirates',\n        'GB': 'United Kingdom',\n        'US': 'United States',\n        'UM': 'United States Minor Outlying Islands',\n        'UY': 'Uruguay',\n        'UZ': 'Uzbekistan',\n        'VU': 'Vanuatu',\n        'VE': 'Venezuela, Bolivarian Republic of',\n        'VN': 'Viet Nam',\n        'VG': 'Virgin Islands, British',\n        'VI': 'Virgin Islands, U.S.',\n        'WF': 'Wallis and Futuna',\n        'EH': 'Western Sahara',\n        'YE': 'Yemen',\n        'ZM': 'Zambia',\n        'ZW': 'Zimbabwe',\n    }\n\n    @classmethod\n    def short2full(cls, code):\n        \"\"\"Convert an ISO 3166-2 country code to the corresponding full name\"\"\"\n        return cls._country_map.get(code.upper())\n\n\nclass GeoUtils(object):\n    # Major IPv4 address blocks per country\n    _country_ip_map = {\n        'AD': '85.94.160.0/19',\n        'AE': '94.200.0.0/13',\n        'AF': '149.54.0.0/17',\n        'AG': '209.59.64.0/18',\n        'AI': '204.14.248.0/21',\n        'AL': '46.99.0.0/16',\n        'AM': '46.70.0.0/15',\n        'AO': '105.168.0.0/13',\n        'AP': '159.117.192.0/21',\n        'AR': '181.0.0.0/12',\n        'AS': '202.70.112.0/20',\n        'AT': '84.112.0.0/13',\n        'AU': '1.128.0.0/11',\n        'AW': '181.41.0.0/18',\n        'AZ': '5.191.0.0/16',\n        'BA': '31.176.128.0/17',\n        'BB': '65.48.128.0/17',\n        'BD': '114.130.0.0/16',\n        'BE': '57.0.0.0/8',\n        'BF': '129.45.128.0/17',\n        'BG': '95.42.0.0/15',\n        'BH': '37.131.0.0/17',\n        'BI': '154.117.192.0/18',\n        'BJ': '137.255.0.0/16',\n        'BL': '192.131.134.0/24',\n        'BM': '196.12.64.0/18',\n        'BN': '156.31.0.0/16',\n        'BO': '161.56.0.0/16',\n        'BQ': '161.0.80.0/20',\n        'BR': '152.240.0.0/12',\n        'BS': '24.51.64.0/18',\n        'BT': '119.2.96.0/19',\n        'BW': '168.167.0.0/16',\n        'BY': '178.120.0.0/13',\n        'BZ': '179.42.192.0/18',\n        'CA': '99.224.0.0/11',\n        'CD': '41.243.0.0/16',\n        'CF': '196.32.200.0/21',\n        'CG': '197.214.128.0/17',\n        'CH': '85.0.0.0/13',\n        'CI': '154.232.0.0/14',\n        'CK': '202.65.32.0/19',\n        'CL': '152.172.0.0/14',\n        'CM': '165.210.0.0/15',\n        'CN': '36.128.0.0/10',\n        'CO': '181.240.0.0/12',\n        'CR': '201.192.0.0/12',\n        'CU': '152.206.0.0/15',\n        'CV': '165.90.96.0/19',\n        'CW': '190.88.128.0/17',\n        'CY': '46.198.0.0/15',\n        'CZ': '88.100.0.0/14',\n        'DE': '53.0.0.0/8',\n        'DJ': '197.241.0.0/17',\n        'DK': '87.48.0.0/12',\n        'DM': '192.243.48.0/20',\n        'DO': '152.166.0.0/15',\n        'DZ': '41.96.0.0/12',\n        'EC': '186.68.0.0/15',\n        'EE': '90.190.0.0/15',\n        'EG': '156.160.0.0/11',\n        'ER': '196.200.96.0/20',\n        'ES': '88.0.0.0/11',\n        'ET': '196.188.0.0/14',\n        'EU': '2.16.0.0/13',\n        'FI': '91.152.0.0/13',\n        'FJ': '144.120.0.0/16',\n        'FM': '119.252.112.0/20',\n        'FO': '88.85.32.0/19',\n        'FR': '90.0.0.0/9',\n        'GA': '41.158.0.0/15',\n        'GB': '25.0.0.0/8',\n        'GD': '74.122.88.0/21',\n        'GE': '31.146.0.0/16',\n        'GF': '161.22.64.0/18',\n        'GG': '62.68.160.0/19',\n        'GH': '45.208.0.0/14',\n        'GI': '85.115.128.0/19',\n        'GL': '88.83.0.0/19',\n        'GM': '160.182.0.0/15',\n        'GN': '197.149.192.0/18',\n        'GP': '104.250.0.0/19',\n        'GQ': '105.235.224.0/20',\n        'GR': '94.64.0.0/13',\n        'GT': '168.234.0.0/16',\n        'GU': '168.123.0.0/16',\n        'GW': '197.214.80.0/20',\n        'GY': '181.41.64.0/18',\n        'HK': '113.252.0.0/14',\n        'HN': '181.210.0.0/16',\n        'HR': '93.136.0.0/13',\n        'HT': '148.102.128.0/17',\n        'HU': '84.0.0.0/14',\n        'ID': '39.192.0.0/10',\n        'IE': '87.32.0.0/12',\n        'IL': '79.176.0.0/13',\n        'IM': '5.62.80.0/20',\n        'IN': '117.192.0.0/10',\n        'IO': '203.83.48.0/21',\n        'IQ': '37.236.0.0/14',\n        'IR': '2.176.0.0/12',\n        'IS': '82.221.0.0/16',\n        'IT': '79.0.0.0/10',\n        'JE': '87.244.64.0/18',\n        'JM': '72.27.0.0/17',\n        'JO': '176.29.0.0/16',\n        'JP': '126.0.0.0/8',\n        'KE': '105.48.0.0/12',\n        'KG': '158.181.128.0/17',\n        'KH': '36.37.128.0/17',\n        'KI': '103.25.140.0/22',\n        'KM': '197.255.224.0/20',\n        'KN': '198.32.32.0/19',\n        'KP': '175.45.176.0/22',\n        'KR': '175.192.0.0/10',\n        'KW': '37.36.0.0/14',\n        'KY': '64.96.0.0/15',\n        'KZ': '2.72.0.0/13',\n        'LA': '115.84.64.0/18',\n        'LB': '178.135.0.0/16',\n        'LC': '192.147.231.0/24',\n        'LI': '82.117.0.0/19',\n        'LK': '112.134.0.0/15',\n        'LR': '41.86.0.0/19',\n        'LS': '129.232.0.0/17',\n        'LT': '78.56.0.0/13',\n        'LU': '188.42.0.0/16',\n        'LV': '46.109.0.0/16',\n        'LY': '41.252.0.0/14',\n        'MA': '105.128.0.0/11',\n        'MC': '88.209.64.0/18',\n        'MD': '37.246.0.0/16',\n        'ME': '178.175.0.0/17',\n        'MF': '74.112.232.0/21',\n        'MG': '154.126.0.0/17',\n        'MH': '117.103.88.0/21',\n        'MK': '77.28.0.0/15',\n        'ML': '154.118.128.0/18',\n        'MM': '37.111.0.0/17',\n        'MN': '49.0.128.0/17',\n        'MO': '60.246.0.0/16',\n        'MP': '202.88.64.0/20',\n        'MQ': '109.203.224.0/19',\n        'MR': '41.188.64.0/18',\n        'MS': '208.90.112.0/22',\n        'MT': '46.11.0.0/16',\n        'MU': '105.16.0.0/12',\n        'MV': '27.114.128.0/18',\n        'MW': '105.234.0.0/16',\n        'MX': '187.192.0.0/11',\n        'MY': '175.136.0.0/13',\n        'MZ': '197.218.0.0/15',\n        'NA': '41.182.0.0/16',\n        'NC': '101.101.0.0/18',\n        'NE': '197.214.0.0/18',\n        'NF': '203.17.240.0/22',\n        'NG': '105.112.0.0/12',\n        'NI': '186.76.0.0/15',\n        'NL': '145.96.0.0/11',\n        'NO': '84.208.0.0/13',\n        'NP': '36.252.0.0/15',\n        'NR': '203.98.224.0/19',\n        'NU': '49.156.48.0/22',\n        'NZ': '49.224.0.0/14',\n        'OM': '5.36.0.0/15',\n        'PA': '186.72.0.0/15',\n        'PE': '186.160.0.0/14',\n        'PF': '123.50.64.0/18',\n        'PG': '124.240.192.0/19',\n        'PH': '49.144.0.0/13',\n        'PK': '39.32.0.0/11',\n        'PL': '83.0.0.0/11',\n        'PM': '70.36.0.0/20',\n        'PR': '66.50.0.0/16',\n        'PS': '188.161.0.0/16',\n        'PT': '85.240.0.0/13',\n        'PW': '202.124.224.0/20',\n        'PY': '181.120.0.0/14',\n        'QA': '37.210.0.0/15',\n        'RE': '139.26.0.0/16',\n        'RO': '79.112.0.0/13',\n        'RS': '178.220.0.0/14',\n        'RU': '5.136.0.0/13',\n        'RW': '105.178.0.0/15',\n        'SA': '188.48.0.0/13',\n        'SB': '202.1.160.0/19',\n        'SC': '154.192.0.0/11',\n        'SD': '154.96.0.0/13',\n        'SE': '78.64.0.0/12',\n        'SG': '152.56.0.0/14',\n        'SI': '188.196.0.0/14',\n        'SK': '78.98.0.0/15',\n        'SL': '197.215.0.0/17',\n        'SM': '89.186.32.0/19',\n        'SN': '41.82.0.0/15',\n        'SO': '197.220.64.0/19',\n        'SR': '186.179.128.0/17',\n        'SS': '105.235.208.0/21',\n        'ST': '197.159.160.0/19',\n        'SV': '168.243.0.0/16',\n        'SX': '190.102.0.0/20',\n        'SY': '5.0.0.0/16',\n        'SZ': '41.84.224.0/19',\n        'TC': '65.255.48.0/20',\n        'TD': '154.68.128.0/19',\n        'TG': '196.168.0.0/14',\n        'TH': '171.96.0.0/13',\n        'TJ': '85.9.128.0/18',\n        'TK': '27.96.24.0/21',\n        'TL': '180.189.160.0/20',\n        'TM': '95.85.96.0/19',\n        'TN': '197.0.0.0/11',\n        'TO': '175.176.144.0/21',\n        'TR': '78.160.0.0/11',\n        'TT': '186.44.0.0/15',\n        'TV': '202.2.96.0/19',\n        'TW': '120.96.0.0/11',\n        'TZ': '156.156.0.0/14',\n        'UA': '93.72.0.0/13',\n        'UG': '154.224.0.0/13',\n        'US': '3.0.0.0/8',\n        'UY': '167.56.0.0/13',\n        'UZ': '82.215.64.0/18',\n        'VA': '212.77.0.0/19',\n        'VC': '24.92.144.0/20',\n        'VE': '186.88.0.0/13',\n        'VG': '172.103.64.0/18',\n        'VI': '146.226.0.0/16',\n        'VN': '14.160.0.0/11',\n        'VU': '202.80.32.0/20',\n        'WF': '117.20.32.0/21',\n        'WS': '202.4.32.0/19',\n        'YE': '134.35.0.0/16',\n        'YT': '41.242.116.0/22',\n        'ZA': '41.0.0.0/11',\n        'ZM': '165.56.0.0/13',\n        'ZW': '41.85.192.0/19',\n    }\n\n    @classmethod\n    def random_ipv4(cls, code):\n        block = cls._country_ip_map.get(code.upper())\n        if not block:\n            return None\n        addr, preflen = block.split('/')\n        addr_min = compat_struct_unpack('!L', socket.inet_aton(addr))[0]\n        addr_max = addr_min | (0xffffffff >> int(preflen))\n        return compat_str(socket.inet_ntoa(\n            compat_struct_pack('!L', random.randint(addr_min, addr_max))))\n\n\nclass PerRequestProxyHandler(compat_urllib_request.ProxyHandler):\n    def __init__(self, proxies=None):\n        # Set default handlers\n        for type in ('http', 'https'):\n            setattr(self, '%s_open' % type,\n                    lambda r, proxy='__noproxy__', type=type, meth=self.proxy_open:\n                        meth(r, proxy, type))\n        return compat_urllib_request.ProxyHandler.__init__(self, proxies)\n\n    def proxy_open(self, req, proxy, type):\n        req_proxy = req.headers.get('Ytdl-request-proxy')\n        if req_proxy is not None:\n            proxy = req_proxy\n            del req.headers['Ytdl-request-proxy']\n\n        if proxy == '__noproxy__':\n            return None  # No Proxy\n        if compat_urlparse.urlparse(proxy).scheme.lower() in ('socks', 'socks4', 'socks4a', 'socks5'):\n            req.add_header('Ytdl-socks-proxy', proxy)\n            # youtube-dl's http/https handlers do wrapping the socket with socks\n            return None\n        return compat_urllib_request.ProxyHandler.proxy_open(\n            self, req, proxy, type)\n\n\n# Both long_to_bytes and bytes_to_long are adapted from PyCrypto, which is\n# released into Public Domain\n# https://github.com/dlitz/pycrypto/blob/master/lib/Crypto/Util/number.py#L387\n\ndef long_to_bytes(n, blocksize=0):\n    \"\"\"long_to_bytes(n:long, blocksize:int) : string\n    Convert a long integer to a byte string.\n\n    If optional blocksize is given and greater than zero, pad the front of the\n    byte string with binary zeros so that the length is a multiple of\n    blocksize.\n    \"\"\"\n    # after much testing, this algorithm was deemed to be the fastest\n    s = b''\n    n = int(n)\n    while n > 0:\n        s = compat_struct_pack('>I', n & 0xffffffff) + s\n        n = n >> 32\n    # strip off leading zeros\n    for i in range(len(s)):\n        if s[i] != b'\\000'[0]:\n            break\n    else:\n        # only happens when n == 0\n        s = b'\\000'\n        i = 0\n    s = s[i:]\n    # add back some pad bytes.  this could be done more efficiently w.r.t. the\n    # de-padding being done above, but sigh...\n    if blocksize > 0 and len(s) % blocksize:\n        s = (blocksize - len(s) % blocksize) * b'\\000' + s\n    return s\n\n\ndef bytes_to_long(s):\n    \"\"\"bytes_to_long(string) : long\n    Convert a byte string to a long integer.\n\n    This is (essentially) the inverse of long_to_bytes().\n    \"\"\"\n    acc = 0\n    length = len(s)\n    if length % 4:\n        extra = (4 - length % 4)\n        s = b'\\000' * extra + s\n        length = length + extra\n    for i in range(0, length, 4):\n        acc = (acc << 32) + compat_struct_unpack('>I', s[i:i + 4])[0]\n    return acc\n\n\ndef ohdave_rsa_encrypt(data, exponent, modulus):\n    '''\n    Implement OHDave's RSA algorithm. See http://www.ohdave.com/rsa/\n\n    Input:\n        data: data to encrypt, bytes-like object\n        exponent, modulus: parameter e and N of RSA algorithm, both integer\n    Output: hex string of encrypted data\n\n    Limitation: supports one block encryption only\n    '''\n\n    payload = int(binascii.hexlify(data[::-1]), 16)\n    encrypted = pow(payload, exponent, modulus)\n    return '%x' % encrypted\n\n\ndef pkcs1pad(data, length):\n    \"\"\"\n    Padding input data with PKCS#1 scheme\n\n    @param {int[]} data        input data\n    @param {int}   length      target length\n    @returns {int[]}           padded data\n    \n \n#!/usr/bin/env python\n# coding: utf-8\n# \"Register\" SOCKS protocols\n# In Python < 2.6.5, urlsplit() suffers from bug https://bugs.python.org/issue7904\n# URLs with protocols not in urlparse.uses_netloc are not handled correctly\n# This is not clearly defined otherwise\n# needed for sanitizing filenames in restricted mode\n#1 padding')\n# Based on png2str() written by @gdkchan and improved by @yokrysty\n# Originally posted at https://github.com/rg3/youtube-dl/issues/9706\n# Reference: https://www.w3.org/TR/PNG/\n# Skip CRC\n# Sub\n# Up\n# Average\n# Paeth\n# This mess below finds the best xattr tool for the job\n# try the pyxattr module...\n# pyxattr\n# Unicode arguments are not supported in python-pyxattr until\n# version 0.5.0\n# See https://github.com/rg3/youtube-dl/issues/5498\n# TODO: fallback to CLI tools\n# xattr\n# Write xattrs to NTFS Alternate Data Streams:\n# http://en.wikipedia.org/wiki/NTFS#Alternate_data_streams_.28ADS.29\n# On Unix, and can't find pyxattr, setfattr, or xattr.\n", "content": "#!/usr/bin/env python\n# coding: utf-8\n\nfrom __future__ import unicode_literals\n\nimport base64\nimport binascii\nimport calendar\nimport codecs\nimport contextlib\nimport ctypes\nimport datetime\nimport email.utils\nimport email.header\nimport errno\nimport functools\nimport gzip\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport socket\nimport ssl\nimport subprocess\nimport sys\nimport tempfile\nimport traceback\nimport xml.etree.ElementTree\nimport zlib\n\nfrom .compat import (\n    compat_HTMLParseError,\n    compat_HTMLParser,\n    compat_basestring,\n    compat_chr,\n    compat_ctypes_WINFUNCTYPE,\n    compat_etree_fromstring,\n    compat_expanduser,\n    compat_html_entities,\n    compat_html_entities_html5,\n    compat_http_client,\n    compat_kwargs,\n    compat_os_name,\n    compat_parse_qs,\n    compat_shlex_quote,\n    compat_socket_create_connection,\n    compat_str,\n    compat_struct_pack,\n    compat_struct_unpack,\n    compat_urllib_error,\n    compat_urllib_parse,\n    compat_urllib_parse_urlencode,\n    compat_urllib_parse_urlparse,\n    compat_urllib_parse_unquote_plus,\n    compat_urllib_request,\n    compat_urlparse,\n    compat_xpath,\n)\n\nfrom .socks import (\n    ProxyType,\n    sockssocket,\n)\n\n\ndef register_socks_protocols():\n    # \"Register\" SOCKS protocols\n    # In Python < 2.6.5, urlsplit() suffers from bug https://bugs.python.org/issue7904\n    # URLs with protocols not in urlparse.uses_netloc are not handled correctly\n    for scheme in ('socks', 'socks4', 'socks4a', 'socks5'):\n        if scheme not in compat_urlparse.uses_netloc:\n            compat_urlparse.uses_netloc.append(scheme)\n\n\n# This is not clearly defined otherwise\ncompiled_regex_type = type(re.compile(''))\n\nstd_headers = {\n    'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:59.0) Gecko/20100101 Firefox/59.0 (Chrome)',\n    'Accept-Charset': 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',\n    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n    'Accept-Encoding': 'gzip, deflate',\n    'Accept-Language': 'en-us,en;q=0.5',\n}\n\n\nUSER_AGENTS = {\n    'Safari': 'Mozilla/5.0 (X11; Linux x86_64; rv:10.0) AppleWebKit/533.20.25 (KHTML, like Gecko) Version/5.0.4 Safari/533.20.27',\n}\n\n\nNO_DEFAULT = object()\n\nENGLISH_MONTH_NAMES = [\n    'January', 'February', 'March', 'April', 'May', 'June',\n    'July', 'August', 'September', 'October', 'November', 'December']\n\nMONTH_NAMES = {\n    'en': ENGLISH_MONTH_NAMES,\n    'fr': [\n        'janvier', 'f\u00e9vrier', 'mars', 'avril', 'mai', 'juin',\n        'juillet', 'ao\u00fbt', 'septembre', 'octobre', 'novembre', 'd\u00e9cembre'],\n}\n\nKNOWN_EXTENSIONS = (\n    'mp4', 'm4a', 'm4p', 'm4b', 'm4r', 'm4v', 'aac',\n    'flv', 'f4v', 'f4a', 'f4b',\n    'webm', 'ogg', 'ogv', 'oga', 'ogx', 'spx', 'opus',\n    'mkv', 'mka', 'mk3d',\n    'avi', 'divx',\n    'mov',\n    'asf', 'wmv', 'wma',\n    '3gp', '3g2',\n    'mp3',\n    'flac',\n    'ape',\n    'wav',\n    'f4f', 'f4m', 'm3u8', 'smil')\n\n# needed for sanitizing filenames in restricted mode\nACCENT_CHARS = dict(zip('\u00c2\u00c3\u00c4\u00c0\u00c1\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u0150\u00d8\u0152\u00d9\u00da\u00db\u00dc\u0170\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u0151\u00f8\u0153\u00f9\u00fa\u00fb\u00fc\u0171\u00fd\u00fe\u00ff',\n                        itertools.chain('AAAAAA', ['AE'], 'CEEEEIIIIDNOOOOOOO', ['OE'], 'UUUUUYP', ['ss'],\n                                        'aaaaaa', ['ae'], 'ceeeeiiiionooooooo', ['oe'], 'uuuuuypy')))\n\nDATE_FORMATS = (\n    '%d %B %Y',\n    '%d %b %Y',\n    '%B %d %Y',\n    '%B %dst %Y',\n    '%B %dnd %Y',\n    '%B %dth %Y',\n    '%b %d %Y',\n    '%b %dst %Y',\n    '%b %dnd %Y',\n    '%b %dth %Y',\n    '%b %dst %Y %I:%M',\n    '%b %dnd %Y %I:%M',\n    '%b %dth %Y %I:%M',\n    '%Y %m %d',\n    '%Y-%m-%d',\n    '%Y/%m/%d',\n    '%Y/%m/%d %H:%M',\n    '%Y/%m/%d %H:%M:%S',\n    '%Y-%m-%d %H:%M',\n    '%Y-%m-%d %H:%M:%S',\n    '%Y-%m-%d %H:%M:%S.%f',\n    '%d.%m.%Y %H:%M',\n    '%d.%m.%Y %H.%M',\n    '%Y-%m-%dT%H:%M:%SZ',\n    '%Y-%m-%dT%H:%M:%S.%fZ',\n    '%Y-%m-%dT%H:%M:%S.%f0Z',\n    '%Y-%m-%dT%H:%M:%S',\n    '%Y-%m-%dT%H:%M:%S.%f',\n    '%Y-%m-%dT%H:%M',\n    '%b %d %Y at %H:%M',\n    '%b %d %Y at %H:%M:%S',\n    '%B %d %Y at %H:%M',\n    '%B %d %Y at %H:%M:%S',\n)\n\nDATE_FORMATS_DAY_FIRST = list(DATE_FORMATS)\nDATE_FORMATS_DAY_FIRST.extend([\n    '%d-%m-%Y',\n    '%d.%m.%Y',\n    '%d.%m.%y',\n    '%d/%m/%Y',\n    '%d/%m/%y',\n    '%d/%m/%Y %H:%M:%S',\n])\n\nDATE_FORMATS_MONTH_FIRST = list(DATE_FORMATS)\nDATE_FORMATS_MONTH_FIRST.extend([\n    '%m-%d-%Y',\n    '%m.%d.%Y',\n    '%m/%d/%Y',\n    '%m/%d/%y',\n    '%m/%d/%Y %H:%M:%S',\n])\n\nPACKED_CODES_RE = r\"}\\('(.+)',(\\d+),(\\d+),'([^']+)'\\.split\\('\\|'\\)\"\n\n\ndef preferredencoding():\n    \"\"\"Get preferred encoding.\n\n    Returns the best encoding scheme for the system, based on\n    locale.getpreferredencoding() and some further tweaks.\n    \"\"\"\n    try:\n        pref = locale.getpreferredencoding()\n        'TEST'.encode(pref)\n    except Exception:\n        pref = 'UTF-8'\n\n    return pref\n\n\ndef write_json_file(obj, fn):\n    \"\"\" Encode obj as JSON and write it to fn, atomically if possible \"\"\"\n\n    fn = encodeFilename(fn)\n    if sys.version_info < (3, 0) and sys.platform != 'win32':\n        encoding = get_filesystem_encoding()\n        # os.path.basename returns a bytes object, but NamedTemporaryFile\n        # will fail if the filename contains non ascii characters unless we\n        # use a unicode object\n        path_basename = lambda f: os.path.basename(fn).decode(encoding)\n        # the same for os.path.dirname\n        path_dirname = lambda f: os.path.dirname(fn).decode(encoding)\n    else:\n        path_basename = os.path.basename\n        path_dirname = os.path.dirname\n\n    args = {\n        'suffix': '.tmp',\n        'prefix': path_basename(fn) + '.',\n        'dir': path_dirname(fn),\n        'delete': False,\n    }\n\n    # In Python 2.x, json.dump expects a bytestream.\n    # In Python 3.x, it writes to a character stream\n    if sys.version_info < (3, 0):\n        args['mode'] = 'wb'\n    else:\n        args.update({\n            'mode': 'w',\n            'encoding': 'utf-8',\n        })\n\n    tf = tempfile.NamedTemporaryFile(**compat_kwargs(args))\n\n    try:\n        with tf:\n            json.dump(obj, tf)\n        if sys.platform == 'win32':\n            # Need to remove existing file on Windows, else os.rename raises\n            # WindowsError or FileExistsError.\n            try:\n                os.unlink(fn)\n            except OSError:\n                pass\n        os.rename(tf.name, fn)\n    except Exception:\n        try:\n            os.remove(tf.name)\n        except OSError:\n            pass\n        raise\n\n\nif sys.version_info >= (2, 7):\n    def find_xpath_attr(node, xpath, key, val=None):\n        \"\"\" Find the xpath xpath[@key=val] \"\"\"\n        assert re.match(r'^[a-zA-Z_-]+$', key)\n        expr = xpath + ('[@%s]' % key if val is None else \"[@%s='%s']\" % (key, val))\n        return node.find(expr)\nelse:\n    def find_xpath_attr(node, xpath, key, val=None):\n        for f in node.findall(compat_xpath(xpath)):\n            if key not in f.attrib:\n                continue\n            if val is None or f.attrib.get(key) == val:\n                return f\n        return None\n\n# On python2.6 the xml.etree.ElementTree.Element methods don't support\n# the namespace parameter\n\n\ndef xpath_with_ns(path, ns_map):\n    components = [c.split(':') for c in path.split('/')]\n    replaced = []\n    for c in components:\n        if len(c) == 1:\n            replaced.append(c[0])\n        else:\n            ns, tag = c\n            replaced.append('{%s}%s' % (ns_map[ns], tag))\n    return '/'.join(replaced)\n\n\ndef xpath_element(node, xpath, name=None, fatal=False, default=NO_DEFAULT):\n    def _find_xpath(xpath):\n        return node.find(compat_xpath(xpath))\n\n    if isinstance(xpath, (str, compat_str)):\n        n = _find_xpath(xpath)\n    else:\n        for xp in xpath:\n            n = _find_xpath(xp)\n            if n is not None:\n                break\n\n    if n is None:\n        if default is not NO_DEFAULT:\n            return default\n        elif fatal:\n            name = xpath if name is None else name\n            raise ExtractorError('Could not find XML element %s' % name)\n        else:\n            return None\n    return n\n\n\ndef xpath_text(node, xpath, name=None, fatal=False, default=NO_DEFAULT):\n    n = xpath_element(node, xpath, name, fatal=fatal, default=default)\n    if n is None or n == default:\n        return n\n    if n.text is None:\n        if default is not NO_DEFAULT:\n            return default\n        elif fatal:\n            name = xpath if name is None else name\n            raise ExtractorError('Could not find XML element\\'s text %s' % name)\n        else:\n            return None\n    return n.text\n\n\ndef xpath_attr(node, xpath, key, name=None, fatal=False, default=NO_DEFAULT):\n    n = find_xpath_attr(node, xpath, key)\n    if n is None:\n        if default is not NO_DEFAULT:\n            return default\n        elif fatal:\n            name = '%s[@%s]' % (xpath, key) if name is None else name\n            raise ExtractorError('Could not find XML attribute %s' % name)\n        else:\n            return None\n    return n.attrib[key]\n\n\ndef get_element_by_id(id, html):\n    \"\"\"Return the content of the tag with the specified ID in the passed HTML document\"\"\"\n    return get_element_by_attribute('id', id, html)\n\n\ndef get_element_by_class(class_name, html):\n    \"\"\"Return the content of the first tag with the specified class in the passed HTML document\"\"\"\n    retval = get_elements_by_class(class_name, html)\n    return retval[0] if retval else None\n\n\ndef get_element_by_attribute(attribute, value, html, escape_value=True):\n    retval = get_elements_by_attribute(attribute, value, html, escape_value)\n    return retval[0] if retval else None\n\n\ndef get_elements_by_class(class_name, html):\n    \"\"\"Return the content of all tags with the specified class in the passed HTML document as a list\"\"\"\n    return get_elements_by_attribute(\n        'class', r'[^\\'\"]*\\b%s\\b[^\\'\"]*' % re.escape(class_name),\n        html, escape_value=False)\n\n\ndef get_elements_by_attribute(attribute, value, html, escape_value=True):\n    \"\"\"Return the content of the tag with the specified attribute in the passed HTML document\"\"\"\n\n    value = re.escape(value) if escape_value else value\n\n    retlist = []\n    for m in re.finditer(r'''(?xs)\n        <([a-zA-Z0-9:._-]+)\n         (?:\\s+[a-zA-Z0-9:._-]+(?:=[a-zA-Z0-9:._-]*|=\"[^\"]*\"|='[^']*'|))*?\n         \\s+%s=['\"]?%s['\"]?\n         (?:\\s+[a-zA-Z0-9:._-]+(?:=[a-zA-Z0-9:._-]*|=\"[^\"]*\"|='[^']*'|))*?\n        \\s*>\n        (?P<content>.*?)\n        </\\1>\n    ''' % (re.escape(attribute), value), html):\n        res = m.group('content')\n\n        if res.startswith('\"') or res.startswith(\"'\"):\n            res = res[1:-1]\n\n        retlist.append(unescapeHTML(res))\n\n    return retlist\n\n\nclass HTMLAttributeParser(compat_HTMLParser):\n    \"\"\"Trivial HTML parser to gather the attributes for a single element\"\"\"\n    def __init__(self):\n        self.attrs = {}\n        compat_HTMLParser.__init__(self)\n\n    def handle_starttag(self, tag, attrs):\n        self.attrs = dict(attrs)\n\n\ndef extract_attributes(html_element):\n    \"\"\"Given a string for an HTML element such as\n    <el\n         a=\"foo\" B=\"bar\" c=\"&98;az\" d=boz\n         empty= noval entity=\"&amp;\"\n         sq='\"' dq=\"'\"\n    >\n    Decode and return a dictionary of attributes.\n    {\n        'a': 'foo', 'b': 'bar', c: 'baz', d: 'boz',\n        'empty': '', 'noval': None, 'entity': '&',\n        'sq': '\"', 'dq': '\\''\n    }.\n    NB HTMLParser is stricter in Python 2.6 & 3.2 than in later versions,\n    but the cases in the unit test will work for all of 2.6, 2.7, 3.2-3.5.\n    \"\"\"\n    parser = HTMLAttributeParser()\n    try:\n        parser.feed(html_element)\n        parser.close()\n    # Older Python may throw HTMLParseError in case of malformed HTML\n    except compat_HTMLParseError:\n        pass\n    return parser.attrs\n\n\ndef clean_html(html):\n    \"\"\"Clean an HTML snippet into a readable string\"\"\"\n\n    if html is None:  # Convenience for sanitizing descriptions etc.\n        return html\n\n    # Newline vs <br />\n    html = html.replace('\\n', ' ')\n    html = re.sub(r'(?u)\\s*<\\s*br\\s*/?\\s*>\\s*', '\\n', html)\n    html = re.sub(r'(?u)<\\s*/\\s*p\\s*>\\s*<\\s*p[^>]*>', '\\n', html)\n    # Strip html tags\n    html = re.sub('<.*?>', '', html)\n    # Replace html entities\n    html = unescapeHTML(html)\n    return html.strip()\n\n\ndef sanitize_open(filename, open_mode):\n    \"\"\"Try to open the given filename, and slightly tweak it if this fails.\n\n    Attempts to open the given filename. If this fails, it tries to change\n    the filename slightly, step by step, until it's either able to open it\n    or it fails and raises a final exception, like the standard open()\n    function.\n\n    It returns the tuple (stream, definitive_file_name).\n    \"\"\"\n    try:\n        if filename == '-':\n            if sys.platform == 'win32':\n                import msvcrt\n                msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)\n            return (sys.stdout.buffer if hasattr(sys.stdout, 'buffer') else sys.stdout, filename)\n        stream = open(encodeFilename(filename), open_mode)\n        return (stream, filename)\n    except (IOError, OSError) as err:\n        if err.errno in (errno.EACCES,):\n            raise\n\n        # In case of error, try to remove win32 forbidden chars\n        alt_filename = sanitize_path(filename)\n        if alt_filename == filename:\n            raise\n        else:\n            # An exception here should be caught in the caller\n            stream = open(encodeFilename(alt_filename), open_mode)\n            return (stream, alt_filename)\n\n\ndef timeconvert(timestr):\n    \"\"\"Convert RFC 2822 defined time string into system timestamp\"\"\"\n    timestamp = None\n    timetuple = email.utils.parsedate_tz(timestr)\n    if timetuple is not None:\n        timestamp = email.utils.mktime_tz(timetuple)\n    return timestamp\n\n\ndef sanitize_filename(s, restricted=False, is_id=False):\n    \"\"\"Sanitizes a string so it could be used as part of a filename.\n    If restricted is set, use a stricter subset of allowed characters.\n    Set is_id if this is not an arbitrary string, but an ID that should be kept\n    if possible.\n    \"\"\"\n    def replace_insane(char):\n        if restricted and char in ACCENT_CHARS:\n            return ACCENT_CHARS[char]\n        if char == '?' or ord(char) < 32 or ord(char) == 127:\n            return ''\n        elif char == '\"':\n            return '' if restricted else '\\''\n        elif char == ':':\n            return '_-' if restricted else ' -'\n        elif char in '\\\\/|*<>':\n            return '_'\n        if restricted and (char in '!&\\'()[]{}$;`^,#' or char.isspace()):\n            return '_'\n        if restricted and ord(char) > 127:\n            return '_'\n        return char\n\n    # Handle timestamps\n    s = re.sub(r'[0-9]+(?::[0-9]+)+', lambda m: m.group(0).replace(':', '_'), s)\n    result = ''.join(map(replace_insane, s))\n    if not is_id:\n        while '__' in result:\n            result = result.replace('__', '_')\n        result = result.strip('_')\n        # Common case of \"Foreign band name - English song title\"\n        if restricted and result.startswith('-_'):\n            result = result[2:]\n        if result.startswith('-'):\n            result = '_' + result[len('-'):]\n        result = result.lstrip('.')\n        if not result:\n            result = '_'\n    return result\n\n\ndef sanitize_path(s):\n    \"\"\"Sanitizes and normalizes path on Windows\"\"\"\n    if sys.platform != 'win32':\n        return s\n    drive_or_unc, _ = os.path.splitdrive(s)\n    if sys.version_info < (2, 7) and not drive_or_unc:\n        drive_or_unc, _ = os.path.splitunc(s)\n    norm_path = os.path.normpath(remove_start(s, drive_or_unc)).split(os.path.sep)\n    if drive_or_unc:\n        norm_path.pop(0)\n    sanitized_path = [\n        path_part if path_part in ['.', '..'] else re.sub(r'(?:[/<>:\"\\|\\\\?\\*]|[\\s.]$)', '#', path_part)\n        for path_part in norm_path]\n    if drive_or_unc:\n        sanitized_path.insert(0, drive_or_unc + os.path.sep)\n    return os.path.join(*sanitized_path)\n\n\ndef sanitize_url(url):\n    # Prepend protocol-less URLs with `http:` scheme in order to mitigate\n    # the number of unwanted failures due to missing protocol\n    if url.startswith('//'):\n        return 'http:%s' % url\n    # Fix some common typos seen so far\n    COMMON_TYPOS = (\n        # https://github.com/rg3/youtube-dl/issues/15649\n        (r'^httpss://', r'https://'),\n        # https://bx1.be/lives/direct-tv/\n        (r'^rmtp([es]?)://', r'rtmp\\1://'),\n    )\n    for mistake, fixup in COMMON_TYPOS:\n        if re.match(mistake, url):\n            return re.sub(mistake, fixup, url)\n    return url\n\n\ndef sanitized_Request(url, *args, **kwargs):\n    return compat_urllib_request.Request(sanitize_url(url), *args, **kwargs)\n\n\ndef expand_path(s):\n    \"\"\"Expand shell variables and ~\"\"\"\n    return os.path.expandvars(compat_expanduser(s))\n\n\ndef orderedSet(iterable):\n    \"\"\" Remove all duplicates from the input iterable \"\"\"\n    res = []\n    for el in iterable:\n        if el not in res:\n            res.append(el)\n    return res\n\n\ndef _htmlentity_transform(entity_with_semicolon):\n    \"\"\"Transforms an HTML entity to a character.\"\"\"\n    entity = entity_with_semicolon[:-1]\n\n    # Known non-numeric HTML entity\n    if entity in compat_html_entities.name2codepoint:\n        return compat_chr(compat_html_entities.name2codepoint[entity])\n\n    # TODO: HTML5 allows entities without a semicolon. For example,\n    # '&Eacuteric' should be decoded as '\u00c9ric'.\n    if entity_with_semicolon in compat_html_entities_html5:\n        return compat_html_entities_html5[entity_with_semicolon]\n\n    mobj = re.match(r'#(x[0-9a-fA-F]+|[0-9]+)', entity)\n    if mobj is not None:\n        numstr = mobj.group(1)\n        if numstr.startswith('x'):\n            base = 16\n            numstr = '0%s' % numstr\n        else:\n            base = 10\n        # See https://github.com/rg3/youtube-dl/issues/7518\n        try:\n            return compat_chr(int(numstr, base))\n        except ValueError:\n            pass\n\n    # Unknown entity in name, return its literal representation\n    return '&%s;' % entity\n\n\ndef unescapeHTML(s):\n    if s is None:\n        return None\n    assert type(s) == compat_str\n\n    return re.sub(\n        r'&([^&;]+;)', lambda m: _htmlentity_transform(m.group(1)), s)\n\n\ndef get_subprocess_encoding():\n    if sys.platform == 'win32' and sys.getwindowsversion()[0] >= 5:\n        # For subprocess calls, encode with locale encoding\n        # Refer to http://stackoverflow.com/a/9951851/35070\n        encoding = preferredencoding()\n    else:\n        encoding = sys.getfilesystemencoding()\n    if encoding is None:\n        encoding = 'utf-8'\n    return encoding\n\n\ndef encodeFilename(s, for_subprocess=False):\n    \"\"\"\n    @param s The name of the file\n    \"\"\"\n\n    assert type(s) == compat_str\n\n    # Python 3 has a Unicode API\n    if sys.version_info >= (3, 0):\n        return s\n\n    # Pass '' directly to use Unicode APIs on Windows 2000 and up\n    # (Detecting Windows NT 4 is tricky because 'major >= 4' would\n    # match Windows 9x series as well. Besides, NT 4 is obsolete.)\n    if not for_subprocess and sys.platform == 'win32' and sys.getwindowsversion()[0] >= 5:\n        return s\n\n    # Jython assumes filenames are Unicode strings though reported as Python 2.x compatible\n    if sys.platform.startswith('java'):\n        return s\n\n    return s.encode(get_subprocess_encoding(), 'ignore')\n\n\ndef decodeFilename(b, for_subprocess=False):\n\n    if sys.version_info >= (3, 0):\n        return b\n\n    if not isinstance(b, bytes):\n        return b\n\n    return b.decode(get_subprocess_encoding(), 'ignore')\n\n\ndef encodeArgument(s):\n    if not isinstance(s, compat_str):\n        # Legacy code that uses byte strings\n        # Uncomment the following line after fixing all post processors\n        # assert False, 'Internal error: %r should be of type %r, is %r' % (s, compat_str, type(s))\n        s = s.decode('ascii')\n    return encodeFilename(s, True)\n\n\ndef decodeArgument(b):\n    return decodeFilename(b, True)\n\n\ndef decodeOption(optval):\n    if optval is None:\n        return optval\n    if isinstance(optval, bytes):\n        optval = optval.decode(preferredencoding())\n\n    assert isinstance(optval, compat_str)\n    return optval\n\n\ndef formatSeconds(secs):\n    if secs > 3600:\n        return '%d:%02d:%02d' % (secs // 3600, (secs % 3600) // 60, secs % 60)\n    elif secs > 60:\n        return '%d:%02d' % (secs // 60, secs % 60)\n    else:\n        return '%d' % secs\n\n\ndef make_HTTPS_handler(params, **kwargs):\n    opts_no_check_certificate = params.get('nocheckcertificate', False)\n    if hasattr(ssl, 'create_default_context'):  # Python >= 3.4 or 2.7.9\n        context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n        if opts_no_check_certificate:\n            context.check_hostname = False\n            context.verify_mode = ssl.CERT_NONE\n        try:\n            return YoutubeDLHTTPSHandler(params, context=context, **kwargs)\n        except TypeError:\n            # Python 2.7.8\n            # (create_default_context present but HTTPSHandler has no context=)\n            pass\n\n    if sys.version_info < (3, 2):\n        return YoutubeDLHTTPSHandler(params, **kwargs)\n    else:  # Python < 3.4\n        context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        context.verify_mode = (ssl.CERT_NONE\n                               if opts_no_check_certificate\n                               else ssl.CERT_REQUIRED)\n        context.set_default_verify_paths()\n        return YoutubeDLHTTPSHandler(params, context=context, **kwargs)\n\n\ndef bug_reports_message():\n    if ytdl_is_updateable():\n        update_cmd = 'type  youtube-dl -U  to update'\n    else:\n        update_cmd = 'see  https://yt-dl.org/update  on how to update'\n    msg = '; please report this issue on https://yt-dl.org/bug .'\n    msg += ' Make sure you are using the latest version; %s.' % update_cmd\n    msg += ' Be sure to call youtube-dl with the --verbose flag and include its complete output.'\n    return msg\n\n\nclass YoutubeDLError(Exception):\n    \"\"\"Base exception for YoutubeDL errors.\"\"\"\n    pass\n\n\nclass ExtractorError(YoutubeDLError):\n    \"\"\"Error during info extraction.\"\"\"\n\n    def __init__(self, msg, tb=None, expected=False, cause=None, video_id=None):\n        \"\"\" tb, if given, is the original traceback (so that it can be printed out).\n        If expected is set, this is a normal error message and most likely not a bug in youtube-dl.\n        \"\"\"\n\n        if sys.exc_info()[0] in (compat_urllib_error.URLError, socket.timeout, UnavailableVideoError):\n            expected = True\n        if video_id is not None:\n            msg = video_id + ': ' + msg\n        if cause:\n            msg += ' (caused by %r)' % cause\n        if not expected:\n            msg += bug_reports_message()\n        super(ExtractorError, self).__init__(msg)\n\n        self.traceback = tb\n        self.exc_info = sys.exc_info()  # preserve original exception\n        self.cause = cause\n        self.video_id = video_id\n\n    def format_traceback(self):\n        if self.traceback is None:\n            return None\n        return ''.join(traceback.format_tb(self.traceback))\n\n\nclass UnsupportedError(ExtractorError):\n    def __init__(self, url):\n        super(UnsupportedError, self).__init__(\n            'Unsupported URL: %s' % url, expected=True)\n        self.url = url\n\n\nclass RegexNotFoundError(ExtractorError):\n    \"\"\"Error when a regex didn't match\"\"\"\n    pass\n\n\nclass GeoRestrictedError(ExtractorError):\n    \"\"\"Geographic restriction Error exception.\n\n    This exception may be thrown when a video is not available from your\n    geographic location due to geographic restrictions imposed by a website.\n    \"\"\"\n    def __init__(self, msg, countries=None):\n        super(GeoRestrictedError, self).__init__(msg, expected=True)\n        self.msg = msg\n        self.countries = countries\n\n\nclass DownloadError(YoutubeDLError):\n    \"\"\"Download Error exception.\n\n    This exception may be thrown by FileDownloader objects if they are not\n    configured to continue on errors. They will contain the appropriate\n    error message.\n    \"\"\"\n\n    def __init__(self, msg, exc_info=None):\n        \"\"\" exc_info, if given, is the original exception that caused the trouble (as returned by sys.exc_info()). \"\"\"\n        super(DownloadError, self).__init__(msg)\n        self.exc_info = exc_info\n\n\nclass SameFileError(YoutubeDLError):\n    \"\"\"Same File exception.\n\n    This exception will be thrown by FileDownloader objects if they detect\n    multiple files would have to be downloaded to the same file on disk.\n    \"\"\"\n    pass\n\n\nclass PostProcessingError(YoutubeDLError):\n    \"\"\"Post Processing exception.\n\n    This exception may be raised by PostProcessor's .run() method to\n    indicate an error in the postprocessing task.\n    \"\"\"\n\n    def __init__(self, msg):\n        super(PostProcessingError, self).__init__(msg)\n        self.msg = msg\n\n\nclass MaxDownloadsReached(YoutubeDLError):\n    \"\"\" --max-downloads limit has been reached. \"\"\"\n    pass\n\n\nclass UnavailableVideoError(YoutubeDLError):\n    \"\"\"Unavailable Format exception.\n\n    This exception will be thrown when a video is requested\n    in a format that is not available for that video.\n    \"\"\"\n    pass\n\n\nclass ContentTooShortError(YoutubeDLError):\n    \"\"\"Content Too Short exception.\n\n    This exception may be raised by FileDownloader objects when a file they\n    download is too small for what the server announced first, indicating\n    the connection was probably interrupted.\n    \"\"\"\n\n    def __init__(self, downloaded, expected):\n        super(ContentTooShortError, self).__init__(\n            'Downloaded {0} bytes, expected {1} bytes'.format(downloaded, expected)\n        )\n        # Both in bytes\n        self.downloaded = downloaded\n        self.expected = expected\n\n\nclass XAttrMetadataError(YoutubeDLError):\n    def __init__(self, code=None, msg='Unknown error'):\n        super(XAttrMetadataError, self).__init__(msg)\n        self.code = code\n        self.msg = msg\n\n        # Parsing code and msg\n        if (self.code in (errno.ENOSPC, errno.EDQUOT) or\n                'No space left' in self.msg or 'Disk quota excedded' in self.msg):\n            self.reason = 'NO_SPACE'\n        elif self.code == errno.E2BIG or 'Argument list too long' in self.msg:\n            self.reason = 'VALUE_TOO_LONG'\n        else:\n            self.reason = 'NOT_SUPPORTED'\n\n\nclass XAttrUnavailableError(YoutubeDLError):\n    pass\n\n\ndef _create_http_connection(ydl_handler, http_class, is_https, *args, **kwargs):\n    # Working around python 2 bug (see http://bugs.python.org/issue17849) by limiting\n    # expected HTTP responses to meet HTTP/1.0 or later (see also\n    # https://github.com/rg3/youtube-dl/issues/6727)\n    if sys.version_info < (3, 0):\n        kwargs['strict'] = True\n    hc = http_class(*args, **compat_kwargs(kwargs))\n    source_address = ydl_handler._params.get('source_address')\n    if source_address is not None:\n        sa = (source_address, 0)\n        if hasattr(hc, 'source_address'):  # Python 2.7+\n            hc.source_address = sa\n        else:  # Python 2.6\n            def _hc_connect(self, *args, **kwargs):\n                sock = compat_socket_create_connection(\n                    (self.host, self.port), self.timeout, sa)\n                if is_https:\n                    self.sock = ssl.wrap_socket(\n                        sock, self.key_file, self.cert_file,\n                        ssl_version=ssl.PROTOCOL_TLSv1)\n                else:\n                    self.sock = sock\n            hc.connect = functools.partial(_hc_connect, hc)\n\n    return hc\n\n\ndef handle_youtubedl_headers(headers):\n    filtered_headers = headers\n\n    if 'Youtubedl-no-compression' in filtered_headers:\n        filtered_headers = dict((k, v) for k, v in filtered_headers.items() if k.lower() != 'accept-encoding')\n        del filtered_headers['Youtubedl-no-compression']\n\n    return filtered_headers\n\n\nclass YoutubeDLHandler(compat_urllib_request.HTTPHandler):\n    \"\"\"Handler for HTTP requests and responses.\n\n    This class, when installed with an OpenerDirector, automatically adds\n    the standard headers to every HTTP request and handles gzipped and\n    deflated responses from web servers. If compression is to be avoided in\n    a particular request, the original request in the program code only has\n    to include the HTTP header \"Youtubedl-no-compression\", which will be\n    removed before making the real request.\n\n    Part of this code was copied from:\n\n    http://techknack.net/python-urllib2-handlers/\n\n    Andrew Rowls, the author of that code, agreed to release it to the\n    public domain.\n    \"\"\"\n\n    def __init__(self, params, *args, **kwargs):\n        compat_urllib_request.HTTPHandler.__init__(self, *args, **kwargs)\n        self._params = params\n\n    def http_open(self, req):\n        conn_class = compat_http_client.HTTPConnection\n\n        socks_proxy = req.headers.get('Ytdl-socks-proxy')\n        if socks_proxy:\n            conn_class = make_socks_conn_class(conn_class, socks_proxy)\n            del req.headers['Ytdl-socks-proxy']\n\n        return self.do_open(functools.partial(\n            _create_http_connection, self, conn_class, False),\n            req)\n\n    @staticmethod\n    def deflate(data):\n        try:\n            return zlib.decompress(data, -zlib.MAX_WBITS)\n        except zlib.error:\n            return zlib.decompress(data)\n\n    def http_request(self, req):\n        # According to RFC 3986, URLs can not contain non-ASCII characters, however this is not\n        # always respected by websites, some tend to give out URLs with non percent-encoded\n        # non-ASCII characters (see telemb.py, ard.py [#3412])\n        # urllib chokes on URLs with non-ASCII characters (see http://bugs.python.org/issue3991)\n        # To work around aforementioned issue we will replace request's original URL with\n        # percent-encoded one\n        # Since redirects are also affected (e.g. http://www.southpark.de/alle-episoden/s18e09)\n        # the code of this workaround has been moved here from YoutubeDL.urlopen()\n        url = req.get_full_url()\n        url_escaped = escape_url(url)\n\n        # Substitute URL if any change after escaping\n        if url != url_escaped:\n            req = update_Request(req, url=url_escaped)\n\n        for h, v in std_headers.items():\n            # Capitalize is needed because of Python bug 2275: http://bugs.python.org/issue2275\n            # The dict keys are capitalized because of this bug by urllib\n            if h.capitalize() not in req.headers:\n                req.add_header(h, v)\n\n        req.headers = handle_youtubedl_headers(req.headers)\n\n        if sys.version_info < (2, 7) and '#' in req.get_full_url():\n            # Python 2.6 is brain-dead when it comes to fragments\n            req._Request__original = req._Request__original.partition('#')[0]\n            req._Request__r_type = req._Request__r_type.partition('#')[0]\n\n        return req\n\n    def http_response(self, req, resp):\n        old_resp = resp\n        # gzip\n        if resp.headers.get('Content-encoding', '') == 'gzip':\n            content = resp.read()\n            gz = gzip.GzipFile(fileobj=io.BytesIO(content), mode='rb')\n            try:\n                uncompressed = io.BytesIO(gz.read())\n            except IOError as original_ioerror:\n                # There may be junk add the end of the file\n                # See http://stackoverflow.com/q/4928560/35070 for details\n                for i in range(1, 1024):\n                    try:\n                        gz = gzip.GzipFile(fileobj=io.BytesIO(content[:-i]), mode='rb')\n                        uncompressed = io.BytesIO(gz.read())\n                    except IOError:\n                        continue\n                    break\n                else:\n                    raise original_ioerror\n            resp = compat_urllib_request.addinfourl(uncompressed, old_resp.headers, old_resp.url, old_resp.code)\n            resp.msg = old_resp.msg\n            del resp.headers['Content-encoding']\n        # deflate\n        if resp.headers.get('Content-encoding', '') == 'deflate':\n            gz = io.BytesIO(self.deflate(resp.read()))\n            resp = compat_urllib_request.addinfourl(gz, old_resp.headers, old_resp.url, old_resp.code)\n            resp.msg = old_resp.msg\n            del resp.headers['Content-encoding']\n        # Percent-encode redirect URL of Location HTTP header to satisfy RFC 3986 (see\n        # https://github.com/rg3/youtube-dl/issues/6457).\n        if 300 <= resp.code < 400:\n            location = resp.headers.get('Location')\n            if location:\n                # As of RFC 2616 default charset is iso-8859-1 that is respected by python 3\n                if sys.version_info >= (3, 0):\n                    location = location.encode('iso-8859-1').decode('utf-8')\n                else:\n                    location = location.decode('utf-8')\n                location_escaped = escape_url(location)\n                if location != location_escaped:\n                    del resp.headers['Location']\n                    if sys.version_info < (3, 0):\n                        location_escaped = location_escaped.encode('utf-8')\n                    resp.headers['Location'] = location_escaped\n        return resp\n\n    https_request = http_request\n    https_response = http_response\n\n\ndef make_socks_conn_class(base_class, socks_proxy):\n    assert issubclass(base_class, (\n        compat_http_client.HTTPConnection, compat_http_client.HTTPSConnection))\n\n    url_components = compat_urlparse.urlparse(socks_proxy)\n    if url_components.scheme.lower() == 'socks5':\n        socks_type = ProxyType.SOCKS5\n    elif url_components.scheme.lower() in ('socks', 'socks4'):\n        socks_type = ProxyType.SOCKS4\n    elif url_components.scheme.lower() == 'socks4a':\n        socks_type = ProxyType.SOCKS4A\n\n    def unquote_if_non_empty(s):\n        if not s:\n            return s\n        return compat_urllib_parse_unquote_plus(s)\n\n    proxy_args = (\n        socks_type,\n        url_components.hostname, url_components.port or 1080,\n        True,  # Remote DNS\n        unquote_if_non_empty(url_components.username),\n        unquote_if_non_empty(url_components.password),\n    )\n\n    class SocksConnection(base_class):\n        def connect(self):\n            self.sock = sockssocket()\n            self.sock.setproxy(*proxy_args)\n            if type(self.timeout) in (int, float):\n                self.sock.settimeout(self.timeout)\n            self.sock.connect((self.host, self.port))\n\n            if isinstance(self, compat_http_client.HTTPSConnection):\n                if hasattr(self, '_context'):  # Python > 2.6\n                    self.sock = self._context.wrap_socket(\n                        self.sock, server_hostname=self.host)\n                else:\n                    self.sock = ssl.wrap_socket(self.sock)\n\n    return SocksConnection\n\n\nclass YoutubeDLHTTPSHandler(compat_urllib_request.HTTPSHandler):\n    def __init__(self, params, https_conn_class=None, *args, **kwargs):\n        compat_urllib_request.HTTPSHandler.__init__(self, *args, **kwargs)\n        self._https_conn_class = https_conn_class or compat_http_client.HTTPSConnection\n        self._params = params\n\n    def https_open(self, req):\n        kwargs = {}\n        conn_class = self._https_conn_class\n\n        if hasattr(self, '_context'):  # python > 2.6\n            kwargs['context'] = self._context\n        if hasattr(self, '_check_hostname'):  # python 3.x\n            kwargs['check_hostname'] = self._check_hostname\n\n        socks_proxy = req.headers.get('Ytdl-socks-proxy')\n        if socks_proxy:\n            conn_class = make_socks_conn_class(conn_class, socks_proxy)\n            del req.headers['Ytdl-socks-proxy']\n\n        return self.do_open(functools.partial(\n            _create_http_connection, self, conn_class, True),\n            req, **kwargs)\n\n\nclass YoutubeDLCookieProcessor(compat_urllib_request.HTTPCookieProcessor):\n    def __init__(self, cookiejar=None):\n        compat_urllib_request.HTTPCookieProcessor.__init__(self, cookiejar)\n\n    def http_response(self, request, response):\n        # Python 2 will choke on next HTTP request in row if there are non-ASCII\n        # characters in Set-Cookie HTTP header of last response (see\n        # https://github.com/rg3/youtube-dl/issues/6769).\n        # In order to at least prevent crashing we will percent encode Set-Cookie\n        # header before HTTPCookieProcessor starts processing it.\n        # if sys.version_info < (3, 0) and response.headers:\n        #     for set_cookie_header in ('Set-Cookie', 'Set-Cookie2'):\n        #         set_cookie = response.headers.get(set_cookie_header)\n        #         if set_cookie:\n        #             set_cookie_escaped = compat_urllib_parse.quote(set_cookie, b\"%/;:@&=+$,!~*'()?#[] \")\n        #             if set_cookie != set_cookie_escaped:\n        #                 del response.headers[set_cookie_header]\n        #                 response.headers[set_cookie_header] = set_cookie_escaped\n        return compat_urllib_request.HTTPCookieProcessor.http_response(self, request, response)\n\n    https_request = compat_urllib_request.HTTPCookieProcessor.http_request\n    https_response = http_response\n\n\ndef extract_timezone(date_str):\n    m = re.search(\n        r'^.{8,}?(?P<tz>Z$| ?(?P<sign>\\+|-)(?P<hours>[0-9]{2}):?(?P<minutes>[0-9]{2})$)',\n        date_str)\n    if not m:\n        timezone = datetime.timedelta()\n    else:\n        date_str = date_str[:-len(m.group('tz'))]\n        if not m.group('sign'):\n            timezone = datetime.timedelta()\n        else:\n            sign = 1 if m.group('sign') == '+' else -1\n            timezone = datetime.timedelta(\n                hours=sign * int(m.group('hours')),\n                minutes=sign * int(m.group('minutes')))\n    return timezone, date_str\n\n\ndef parse_iso8601(date_str, delimiter='T', timezone=None):\n    \"\"\" Return a UNIX timestamp from the given date \"\"\"\n\n    if date_str is None:\n        return None\n\n    date_str = re.sub(r'\\.[0-9]+', '', date_str)\n\n    if timezone is None:\n        timezone, date_str = extract_timezone(date_str)\n\n    try:\n        date_format = '%Y-%m-%d{0}%H:%M:%S'.format(delimiter)\n        dt = datetime.datetime.strptime(date_str, date_format) - timezone\n        return calendar.timegm(dt.timetuple())\n    except ValueError:\n        pass\n\n\ndef date_formats(day_first=True):\n    return DATE_FORMATS_DAY_FIRST if day_first else DATE_FORMATS_MONTH_FIRST\n\n\ndef unified_strdate(date_str, day_first=True):\n    \"\"\"Return a string with the date in the format YYYYMMDD\"\"\"\n\n    if date_str is None:\n        return None\n    upload_date = None\n    # Replace commas\n    date_str = date_str.replace(',', ' ')\n    # Remove AM/PM + timezone\n    date_str = re.sub(r'(?i)\\s*(?:AM|PM)(?:\\s+[A-Z]+)?', '', date_str)\n    _, date_str = extract_timezone(date_str)\n\n    for expression in date_formats(day_first):\n        try:\n            upload_date = datetime.datetime.strptime(date_str, expression).strftime('%Y%m%d')\n        except ValueError:\n            pass\n    if upload_date is None:\n        timetuple = email.utils.parsedate_tz(date_str)\n        if timetuple:\n            try:\n                upload_date = datetime.datetime(*timetuple[:6]).strftime('%Y%m%d')\n            except ValueError:\n                pass\n    if upload_date is not None:\n        return compat_str(upload_date)\n\n\ndef unified_timestamp(date_str, day_first=True):\n    if date_str is None:\n        return None\n\n    date_str = re.sub(r'[,|]', '', date_str)\n\n    pm_delta = 12 if re.search(r'(?i)PM', date_str) else 0\n    timezone, date_str = extract_timezone(date_str)\n\n    # Remove AM/PM + timezone\n    date_str = re.sub(r'(?i)\\s*(?:AM|PM)(?:\\s+[A-Z]+)?', '', date_str)\n\n    # Remove unrecognized timezones from ISO 8601 alike timestamps\n    m = re.search(r'\\d{1,2}:\\d{1,2}(?:\\.\\d+)?(?P<tz>\\s*[A-Z]+)$', date_str)\n    if m:\n        date_str = date_str[:-len(m.group('tz'))]\n\n    for expression in date_formats(day_first):\n        try:\n            dt = datetime.datetime.strptime(date_str, expression) - timezone + datetime.timedelta(hours=pm_delta)\n            return calendar.timegm(dt.timetuple())\n        except ValueError:\n            pass\n    timetuple = email.utils.parsedate_tz(date_str)\n    if timetuple:\n        return calendar.timegm(timetuple) + pm_delta * 3600\n\n\ndef determine_ext(url, default_ext='unknown_video'):\n    if url is None:\n        return default_ext\n    guess = url.partition('?')[0].rpartition('.')[2]\n    if re.match(r'^[A-Za-z0-9]+$', guess):\n        return guess\n    # Try extract ext from URLs like http://example.com/foo/bar.mp4/?download\n    elif guess.rstrip('/') in KNOWN_EXTENSIONS:\n        return guess.rstrip('/')\n    else:\n        return default_ext\n\n\ndef subtitles_filename(filename, sub_lang, sub_format):\n    return filename.rsplit('.', 1)[0] + '.' + sub_lang + '.' + sub_format\n\n\ndef date_from_str(date_str):\n    \"\"\"\n    Return a datetime object from a string in the format YYYYMMDD or\n    (now|today)[+-][0-9](day|week|month|year)(s)?\"\"\"\n    today = datetime.date.today()\n    if date_str in ('now', 'today'):\n        return today\n    if date_str == 'yesterday':\n        return today - datetime.timedelta(days=1)\n    match = re.match(r'(now|today)(?P<sign>[+-])(?P<time>\\d+)(?P<unit>day|week|month|year)(s)?', date_str)\n    if match is not None:\n        sign = match.group('sign')\n        time = int(match.group('time'))\n        if sign == '-':\n            time = -time\n        unit = match.group('unit')\n        # A bad approximation?\n        if unit == 'month':\n            unit = 'day'\n            time *= 30\n        elif unit == 'year':\n            unit = 'day'\n            time *= 365\n        unit += 's'\n        delta = datetime.timedelta(**{unit: time})\n        return today + delta\n    return datetime.datetime.strptime(date_str, '%Y%m%d').date()\n\n\ndef hyphenate_date(date_str):\n    \"\"\"\n    Convert a date in 'YYYYMMDD' format to 'YYYY-MM-DD' format\"\"\"\n    match = re.match(r'^(\\d\\d\\d\\d)(\\d\\d)(\\d\\d)$', date_str)\n    if match is not None:\n        return '-'.join(match.groups())\n    else:\n        return date_str\n\n\nclass DateRange(object):\n    \"\"\"Represents a time interval between two dates\"\"\"\n\n    def __init__(self, start=None, end=None):\n        \"\"\"start and end must be strings in the format accepted by date\"\"\"\n        if start is not None:\n            self.start = date_from_str(start)\n        else:\n            self.start = datetime.datetime.min.date()\n        if end is not None:\n            self.end = date_from_str(end)\n        else:\n            self.end = datetime.datetime.max.date()\n        if self.start > self.end:\n            raise ValueError('Date range: \"%s\" , the start date must be before the end date' % self)\n\n    @classmethod\n    def day(cls, day):\n        \"\"\"Returns a range that only contains the given day\"\"\"\n        return cls(day, day)\n\n    def __contains__(self, date):\n        \"\"\"Check if the date is in the range\"\"\"\n        if not isinstance(date, datetime.date):\n            date = date_from_str(date)\n        return self.start <= date <= self.end\n\n    def __str__(self):\n        return '%s - %s' % (self.start.isoformat(), self.end.isoformat())\n\n\ndef platform_name():\n    \"\"\" Returns the platform name as a compat_str \"\"\"\n    res = platform.platform()\n    if isinstance(res, bytes):\n        res = res.decode(preferredencoding())\n\n    assert isinstance(res, compat_str)\n    return res\n\n\ndef _windows_write_string(s, out):\n    \"\"\" Returns True if the string was written using special methods,\n    False if it has yet to be written out.\"\"\"\n    # Adapted from http://stackoverflow.com/a/3259271/35070\n\n    import ctypes\n    import ctypes.wintypes\n\n    WIN_OUTPUT_IDS = {\n        1: -11,\n        2: -12,\n    }\n\n    try:\n        fileno = out.fileno()\n    except AttributeError:\n        # If the output stream doesn't have a fileno, it's virtual\n        return False\n    except io.UnsupportedOperation:\n        # Some strange Windows pseudo files?\n        return False\n    if fileno not in WIN_OUTPUT_IDS:\n        return False\n\n    GetStdHandle = compat_ctypes_WINFUNCTYPE(\n        ctypes.wintypes.HANDLE, ctypes.wintypes.DWORD)(\n        ('GetStdHandle', ctypes.windll.kernel32))\n    h = GetStdHandle(WIN_OUTPUT_IDS[fileno])\n\n    WriteConsoleW = compat_ctypes_WINFUNCTYPE(\n        ctypes.wintypes.BOOL, ctypes.wintypes.HANDLE, ctypes.wintypes.LPWSTR,\n        ctypes.wintypes.DWORD, ctypes.POINTER(ctypes.wintypes.DWORD),\n        ctypes.wintypes.LPVOID)(('WriteConsoleW', ctypes.windll.kernel32))\n    written = ctypes.wintypes.DWORD(0)\n\n    GetFileType = compat_ctypes_WINFUNCTYPE(ctypes.wintypes.DWORD, ctypes.wintypes.DWORD)(('GetFileType', ctypes.windll.kernel32))\n    FILE_TYPE_CHAR = 0x0002\n    FILE_TYPE_REMOTE = 0x8000\n    GetConsoleMode = compat_ctypes_WINFUNCTYPE(\n        ctypes.wintypes.BOOL, ctypes.wintypes.HANDLE,\n        ctypes.POINTER(ctypes.wintypes.DWORD))(\n        ('GetConsoleMode', ctypes.windll.kernel32))\n    INVALID_HANDLE_VALUE = ctypes.wintypes.DWORD(-1).value\n\n    def not_a_console(handle):\n        if handle == INVALID_HANDLE_VALUE or handle is None:\n            return True\n        return ((GetFileType(handle) & ~FILE_TYPE_REMOTE) != FILE_TYPE_CHAR or\n                GetConsoleMode(handle, ctypes.byref(ctypes.wintypes.DWORD())) == 0)\n\n    if not_a_console(h):\n        return False\n\n    def next_nonbmp_pos(s):\n        try:\n            return next(i for i, c in enumerate(s) if ord(c) > 0xffff)\n        except StopIteration:\n            return len(s)\n\n    while s:\n        count = min(next_nonbmp_pos(s), 1024)\n\n        ret = WriteConsoleW(\n            h, s, count if count else 2, ctypes.byref(written), None)\n        if ret == 0:\n            raise OSError('Failed to write string')\n        if not count:  # We just wrote a non-BMP character\n            assert written.value == 2\n            s = s[1:]\n        else:\n            assert written.value > 0\n            s = s[written.value:]\n    return True\n\n\ndef write_string(s, out=None, encoding=None):\n    if out is None:\n        out = sys.stderr\n    assert type(s) == compat_str\n\n    if sys.platform == 'win32' and encoding is None and hasattr(out, 'fileno'):\n        if _windows_write_string(s, out):\n            return\n\n    if ('b' in getattr(out, 'mode', '') or\n            sys.version_info[0] < 3):  # Python 2 lies about mode of sys.stderr\n        byt = s.encode(encoding or preferredencoding(), 'ignore')\n        out.write(byt)\n    elif hasattr(out, 'buffer'):\n        enc = encoding or getattr(out, 'encoding', None) or preferredencoding()\n        byt = s.encode(enc, 'ignore')\n        out.buffer.write(byt)\n    else:\n        out.write(s)\n    out.flush()\n\n\ndef bytes_to_intlist(bs):\n    if not bs:\n        return []\n    if isinstance(bs[0], int):  # Python 3\n        return list(bs)\n    else:\n        return [ord(c) for c in bs]\n\n\ndef intlist_to_bytes(xs):\n    if not xs:\n        return b''\n    return compat_struct_pack('%dB' % len(xs), *xs)\n\n\n# Cross-platform file locking\nif sys.platform == 'win32':\n    import ctypes.wintypes\n    import msvcrt\n\n    class OVERLAPPED(ctypes.Structure):\n        _fields_ = [\n            ('Internal', ctypes.wintypes.LPVOID),\n            ('InternalHigh', ctypes.wintypes.LPVOID),\n            ('Offset', ctypes.wintypes.DWORD),\n            ('OffsetHigh', ctypes.wintypes.DWORD),\n            ('hEvent', ctypes.wintypes.HANDLE),\n        ]\n\n    kernel32 = ctypes.windll.kernel32\n    LockFileEx = kernel32.LockFileEx\n    LockFileEx.argtypes = [\n        ctypes.wintypes.HANDLE,     # hFile\n        ctypes.wintypes.DWORD,      # dwFlags\n        ctypes.wintypes.DWORD,      # dwReserved\n        ctypes.wintypes.DWORD,      # nNumberOfBytesToLockLow\n        ctypes.wintypes.DWORD,      # nNumberOfBytesToLockHigh\n        ctypes.POINTER(OVERLAPPED)  # Overlapped\n    ]\n    LockFileEx.restype = ctypes.wintypes.BOOL\n    UnlockFileEx = kernel32.UnlockFileEx\n    UnlockFileEx.argtypes = [\n        ctypes.wintypes.HANDLE,     # hFile\n        ctypes.wintypes.DWORD,      # dwReserved\n        ctypes.wintypes.DWORD,      # nNumberOfBytesToLockLow\n        ctypes.wintypes.DWORD,      # nNumberOfBytesToLockHigh\n        ctypes.POINTER(OVERLAPPED)  # Overlapped\n    ]\n    UnlockFileEx.restype = ctypes.wintypes.BOOL\n    whole_low = 0xffffffff\n    whole_high = 0x7fffffff\n\n    def _lock_file(f, exclusive):\n        overlapped = OVERLAPPED()\n        overlapped.Offset = 0\n        overlapped.OffsetHigh = 0\n        overlapped.hEvent = 0\n        f._lock_file_overlapped_p = ctypes.pointer(overlapped)\n        handle = msvcrt.get_osfhandle(f.fileno())\n        if not LockFileEx(handle, 0x2 if exclusive else 0x0, 0,\n                          whole_low, whole_high, f._lock_file_overlapped_p):\n            raise OSError('Locking file failed: %r' % ctypes.FormatError())\n\n    def _unlock_file(f):\n        assert f._lock_file_overlapped_p\n        handle = msvcrt.get_osfhandle(f.fileno())\n        if not UnlockFileEx(handle, 0,\n                            whole_low, whole_high, f._lock_file_overlapped_p):\n            raise OSError('Unlocking file failed: %r' % ctypes.FormatError())\n\nelse:\n    # Some platforms, such as Jython, is missing fcntl\n    try:\n        import fcntl\n\n        def _lock_file(f, exclusive):\n            fcntl.flock(f, fcntl.LOCK_EX if exclusive else fcntl.LOCK_SH)\n\n        def _unlock_file(f):\n            fcntl.flock(f, fcntl.LOCK_UN)\n    except ImportError:\n        UNSUPPORTED_MSG = 'file locking is not supported on this platform'\n\n        def _lock_file(f, exclusive):\n            raise IOError(UNSUPPORTED_MSG)\n\n        def _unlock_file(f):\n            raise IOError(UNSUPPORTED_MSG)\n\n\nclass locked_file(object):\n    def __init__(self, filename, mode, encoding=None):\n        assert mode in ['r', 'a', 'w']\n        self.f = io.open(filename, mode, encoding=encoding)\n        self.mode = mode\n\n    def __enter__(self):\n        exclusive = self.mode != 'r'\n        try:\n            _lock_file(self.f, exclusive)\n        except IOError:\n            self.f.close()\n            raise\n        return self\n\n    def __exit__(self, etype, value, traceback):\n        try:\n            _unlock_file(self.f)\n        finally:\n            self.f.close()\n\n    def __iter__(self):\n        return iter(self.f)\n\n    def write(self, *args):\n        return self.f.write(*args)\n\n    def read(self, *args):\n        return self.f.read(*args)\n\n\ndef get_filesystem_encoding():\n    encoding = sys.getfilesystemencoding()\n    return encoding if encoding is not None else 'utf-8'\n\n\ndef shell_quote(args):\n    quoted_args = []\n    encoding = get_filesystem_encoding()\n    for a in args:\n        if isinstance(a, bytes):\n            # We may get a filename encoded with 'encodeFilename'\n            a = a.decode(encoding)\n        quoted_args.append(compat_shlex_quote(a))\n    return ' '.join(quoted_args)\n\n\ndef smuggle_url(url, data):\n    \"\"\" Pass additional data in a URL for internal use. \"\"\"\n\n    url, idata = unsmuggle_url(url, {})\n    data.update(idata)\n    sdata = compat_urllib_parse_urlencode(\n        {'__youtubedl_smuggle': json.dumps(data)})\n    return url + '#' + sdata\n\n\ndef unsmuggle_url(smug_url, default=None):\n    if '#__youtubedl_smuggle' not in smug_url:\n        return smug_url, default\n    url, _, sdata = smug_url.rpartition('#')\n    jsond = compat_parse_qs(sdata)['__youtubedl_smuggle'][0]\n    data = json.loads(jsond)\n    return url, data\n\n\ndef format_bytes(bytes):\n    if bytes is None:\n        return 'N/A'\n    if type(bytes) is str:\n        bytes = float(bytes)\n    if bytes == 0.0:\n        exponent = 0\n    else:\n        exponent = int(math.log(bytes, 1024.0))\n    suffix = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'][exponent]\n    converted = float(bytes) / float(1024 ** exponent)\n    return '%.2f%s' % (converted, suffix)\n\n\ndef lookup_unit_table(unit_table, s):\n    units_re = '|'.join(re.escape(u) for u in unit_table)\n    m = re.match(\n        r'(?P<num>[0-9]+(?:[,.][0-9]*)?)\\s*(?P<unit>%s)\\b' % units_re, s)\n    if not m:\n        return None\n    num_str = m.group('num').replace(',', '.')\n    mult = unit_table[m.group('unit')]\n    return int(float(num_str) * mult)\n\n\ndef parse_filesize(s):\n    if s is None:\n        return None\n\n    # The lower-case forms are of course incorrect and unofficial,\n    # but we support those too\n    _UNIT_TABLE = {\n        'B': 1,\n        'b': 1,\n        'bytes': 1,\n        'KiB': 1024,\n        'KB': 1000,\n        'kB': 1024,\n        'Kb': 1000,\n        'kb': 1000,\n        'kilobytes': 1000,\n        'kibibytes': 1024,\n        'MiB': 1024 ** 2,\n        'MB': 1000 ** 2,\n        'mB': 1024 ** 2,\n        'Mb': 1000 ** 2,\n        'mb': 1000 ** 2,\n        'megabytes': 1000 ** 2,\n        'mebibytes': 1024 ** 2,\n        'GiB': 1024 ** 3,\n        'GB': 1000 ** 3,\n        'gB': 1024 ** 3,\n        'Gb': 1000 ** 3,\n        'gb': 1000 ** 3,\n        'gigabytes': 1000 ** 3,\n        'gibibytes': 1024 ** 3,\n        'TiB': 1024 ** 4,\n        'TB': 1000 ** 4,\n        'tB': 1024 ** 4,\n        'Tb': 1000 ** 4,\n        'tb': 1000 ** 4,\n        'terabytes': 1000 ** 4,\n        'tebibytes': 1024 ** 4,\n        'PiB': 1024 ** 5,\n        'PB': 1000 ** 5,\n        'pB': 1024 ** 5,\n        'Pb': 1000 ** 5,\n        'pb': 1000 ** 5,\n        'petabytes': 1000 ** 5,\n        'pebibytes': 1024 ** 5,\n        'EiB': 1024 ** 6,\n        'EB': 1000 ** 6,\n        'eB': 1024 ** 6,\n        'Eb': 1000 ** 6,\n        'eb': 1000 ** 6,\n        'exabytes': 1000 ** 6,\n        'exbibytes': 1024 ** 6,\n        'ZiB': 1024 ** 7,\n        'ZB': 1000 ** 7,\n        'zB': 1024 ** 7,\n        'Zb': 1000 ** 7,\n        'zb': 1000 ** 7,\n        'zettabytes': 1000 ** 7,\n        'zebibytes': 1024 ** 7,\n        'YiB': 1024 ** 8,\n        'YB': 1000 ** 8,\n        'yB': 1024 ** 8,\n        'Yb': 1000 ** 8,\n        'yb': 1000 ** 8,\n        'yottabytes': 1000 ** 8,\n        'yobibytes': 1024 ** 8,\n    }\n\n    return lookup_unit_table(_UNIT_TABLE, s)\n\n\ndef parse_count(s):\n    if s is None:\n        return None\n\n    s = s.strip()\n\n    if re.match(r'^[\\d,.]+$', s):\n        return str_to_int(s)\n\n    _UNIT_TABLE = {\n        'k': 1000,\n        'K': 1000,\n        'm': 1000 ** 2,\n        'M': 1000 ** 2,\n        'kk': 1000 ** 2,\n        'KK': 1000 ** 2,\n    }\n\n    return lookup_unit_table(_UNIT_TABLE, s)\n\n\ndef parse_resolution(s):\n    if s is None:\n        return {}\n\n    mobj = re.search(r'\\b(?P<w>\\d+)\\s*[xX\u00d7]\\s*(?P<h>\\d+)\\b', s)\n    if mobj:\n        return {\n            'width': int(mobj.group('w')),\n            'height': int(mobj.group('h')),\n        }\n\n    mobj = re.search(r'\\b(\\d+)[pPiI]\\b', s)\n    if mobj:\n        return {'height': int(mobj.group(1))}\n\n    mobj = re.search(r'\\b([48])[kK]\\b', s)\n    if mobj:\n        return {'height': int(mobj.group(1)) * 540}\n\n    return {}\n\n\ndef month_by_name(name, lang='en'):\n    \"\"\" Return the number of a month by (locale-independently) English name \"\"\"\n\n    month_names = MONTH_NAMES.get(lang, MONTH_NAMES['en'])\n\n    try:\n        return month_names.index(name) + 1\n    except ValueError:\n        return None\n\n\ndef month_by_abbreviation(abbrev):\n    \"\"\" Return the number of a month by (locale-independently) English\n        abbreviations \"\"\"\n\n    try:\n        return [s[:3] for s in ENGLISH_MONTH_NAMES].index(abbrev) + 1\n    except ValueError:\n        return None\n\n\ndef fix_xml_ampersands(xml_str):\n    \"\"\"Replace all the '&' by '&amp;' in XML\"\"\"\n    return re.sub(\n        r'&(?!amp;|lt;|gt;|apos;|quot;|#x[0-9a-fA-F]{,4};|#[0-9]{,4};)',\n        '&amp;',\n        xml_str)\n\n\ndef setproctitle(title):\n    assert isinstance(title, compat_str)\n\n    # ctypes in Jython is not complete\n    # http://bugs.jython.org/issue2148\n    if sys.platform.startswith('java'):\n        return\n\n    try:\n        libc = ctypes.cdll.LoadLibrary('libc.so.6')\n    except OSError:\n        return\n    except TypeError:\n        # LoadLibrary in Windows Python 2.7.13 only expects\n        # a bytestring, but since unicode_literals turns\n        # every string into a unicode string, it fails.\n        return\n    title_bytes = title.encode('utf-8')\n    buf = ctypes.create_string_buffer(len(title_bytes))\n    buf.value = title_bytes\n    try:\n        libc.prctl(15, buf, 0, 0, 0)\n    except AttributeError:\n        return  # Strange libc, just skip this\n\n\ndef remove_start(s, start):\n    return s[len(start):] if s is not None and s.startswith(start) else s\n\n\ndef remove_end(s, end):\n    return s[:-len(end)] if s is not None and s.endswith(end) else s\n\n\ndef remove_quotes(s):\n    if s is None or len(s) < 2:\n        return s\n    for quote in ('\"', \"'\", ):\n        if s[0] == quote and s[-1] == quote:\n            return s[1:-1]\n    return s\n\n\ndef url_basename(url):\n    path = compat_urlparse.urlparse(url).path\n    return path.strip('/').split('/')[-1]\n\n\ndef base_url(url):\n    return re.match(r'https?://[^?#&]+/', url).group()\n\n\ndef urljoin(base, path):\n    if isinstance(path, bytes):\n        path = path.decode('utf-8')\n    if not isinstance(path, compat_str) or not path:\n        return None\n    if re.match(r'^(?:https?:)?//', path):\n        return path\n    if isinstance(base, bytes):\n        base = base.decode('utf-8')\n    if not isinstance(base, compat_str) or not re.match(\n            r'^(?:https?:)?//', base):\n        return None\n    return compat_urlparse.urljoin(base, path)\n\n\nclass HEADRequest(compat_urllib_request.Request):\n    def get_method(self):\n        return 'HEAD'\n\n\nclass PUTRequest(compat_urllib_request.Request):\n    def get_method(self):\n        return 'PUT'\n\n\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1):\n    if get_attr:\n        if v is not None:\n            v = getattr(v, get_attr, None)\n    if v == '':\n        v = None\n    if v is None:\n        return default\n    try:\n        return int(v) * invscale // scale\n    except ValueError:\n        return default\n\n\ndef str_or_none(v, default=None):\n    return default if v is None else compat_str(v)\n\n\ndef str_to_int(int_str):\n    \"\"\" A more relaxed version of int_or_none \"\"\"\n    if int_str is None:\n        return None\n    int_str = re.sub(r'[,\\.\\+]', '', int_str)\n    return int(int_str)\n\n\ndef float_or_none(v, scale=1, invscale=1, default=None):\n    if v is None:\n        return default\n    try:\n        return float(v) * invscale / scale\n    except ValueError:\n        return default\n\n\ndef bool_or_none(v, default=None):\n    return v if isinstance(v, bool) else default\n\n\ndef strip_or_none(v):\n    return None if v is None else v.strip()\n\n\ndef parse_duration(s):\n    if not isinstance(s, compat_basestring):\n        return None\n\n    s = s.strip()\n\n    days, hours, mins, secs, ms = [None] * 5\n    m = re.match(r'(?:(?:(?:(?P<days>[0-9]+):)?(?P<hours>[0-9]+):)?(?P<mins>[0-9]+):)?(?P<secs>[0-9]+)(?P<ms>\\.[0-9]+)?Z?$', s)\n    if m:\n        days, hours, mins, secs, ms = m.groups()\n    else:\n        m = re.match(\n            r'''(?ix)(?:P?\n                (?:\n                    [0-9]+\\s*y(?:ears?)?\\s*\n                )?\n                (?:\n                    [0-9]+\\s*m(?:onths?)?\\s*\n                )?\n                (?:\n                    [0-9]+\\s*w(?:eeks?)?\\s*\n                )?\n                (?:\n                    (?P<days>[0-9]+)\\s*d(?:ays?)?\\s*\n                )?\n                T)?\n                (?:\n                    (?P<hours>[0-9]+)\\s*h(?:ours?)?\\s*\n                )?\n                (?:\n                    (?P<mins>[0-9]+)\\s*m(?:in(?:ute)?s?)?\\s*\n                )?\n                (?:\n                    (?P<secs>[0-9]+)(?P<ms>\\.[0-9]+)?\\s*s(?:ec(?:ond)?s?)?\\s*\n                )?Z?$''', s)\n        if m:\n            days, hours, mins, secs, ms = m.groups()\n        else:\n            m = re.match(r'(?i)(?:(?P<hours>[0-9.]+)\\s*(?:hours?)|(?P<mins>[0-9.]+)\\s*(?:mins?\\.?|minutes?)\\s*)Z?$', s)\n            if m:\n                hours, mins = m.groups()\n            else:\n                return None\n\n    duration = 0\n    if secs:\n        duration += float(secs)\n    if mins:\n        duration += float(mins) * 60\n    if hours:\n        duration += float(hours) * 60 * 60\n    if days:\n        duration += float(days) * 24 * 60 * 60\n    if ms:\n        duration += float(ms)\n    return duration\n\n\ndef prepend_extension(filename, ext, expected_real_ext=None):\n    name, real_ext = os.path.splitext(filename)\n    return (\n        '{0}.{1}{2}'.format(name, ext, real_ext)\n        if not expected_real_ext or real_ext[1:] == expected_real_ext\n        else '{0}.{1}'.format(filename, ext))\n\n\ndef replace_extension(filename, ext, expected_real_ext=None):\n    name, real_ext = os.path.splitext(filename)\n    return '{0}.{1}'.format(\n        name if not expected_real_ext or real_ext[1:] == expected_real_ext else filename,\n        ext)\n\n\ndef check_executable(exe, args=[]):\n    \"\"\" Checks if the given binary is installed somewhere in PATH, and returns its name.\n    args can be a list of arguments for a short output (like -version) \"\"\"\n    try:\n        subprocess.Popen([exe] + args, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()\n    except OSError:\n        return False\n    return exe\n\n\ndef get_exe_version(exe, args=['--version'],\n                    version_re=None, unrecognized='present'):\n    \"\"\" Returns the version of the specified executable,\n    or False if the executable is not present \"\"\"\n    try:\n        # STDIN should be redirected too. On UNIX-like systems, ffmpeg triggers\n        # SIGTTOU if youtube-dl is run in the background.\n        # See https://github.com/rg3/youtube-dl/issues/955#issuecomment-209789656\n        out, _ = subprocess.Popen(\n            [encodeArgument(exe)] + args,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE, stderr=subprocess.STDOUT).communicate()\n    except OSError:\n        return False\n    if isinstance(out, bytes):  # Python 2.x\n        out = out.decode('ascii', 'ignore')\n    return detect_exe_version(out, version_re, unrecognized)\n\n\ndef detect_exe_version(output, version_re=None, unrecognized='present'):\n    assert isinstance(output, compat_str)\n    if version_re is None:\n        version_re = r'version\\s+([-0-9._a-zA-Z]+)'\n    m = re.search(version_re, output)\n    if m:\n        return m.group(1)\n    else:\n        return unrecognized\n\n\nclass PagedList(object):\n    def __len__(self):\n        # This is only useful for tests\n        return len(self.getslice())\n\n\nclass OnDemandPagedList(PagedList):\n    def __init__(self, pagefunc, pagesize, use_cache=True):\n        self._pagefunc = pagefunc\n        self._pagesize = pagesize\n        self._use_cache = use_cache\n        if use_cache:\n            self._cache = {}\n\n    def getslice(self, start=0, end=None):\n        res = []\n        for pagenum in itertools.count(start // self._pagesize):\n            firstid = pagenum * self._pagesize\n            nextfirstid = pagenum * self._pagesize + self._pagesize\n            if start >= nextfirstid:\n                continue\n\n            page_results = None\n            if self._use_cache:\n                page_results = self._cache.get(pagenum)\n            if page_results is None:\n                page_results = list(self._pagefunc(pagenum))\n            if self._use_cache:\n                self._cache[pagenum] = page_results\n\n            startv = (\n                start % self._pagesize\n                if firstid <= start < nextfirstid\n                else 0)\n\n            endv = (\n                ((end - 1) % self._pagesize) + 1\n                if (end is not None and firstid <= end <= nextfirstid)\n                else None)\n\n            if startv != 0 or endv is not None:\n                page_results = page_results[startv:endv]\n            res.extend(page_results)\n\n            # A little optimization - if current page is not \"full\", ie. does\n            # not contain page_size videos then we can assume that this page\n            # is the last one - there are no more ids on further pages -\n            # i.e. no need to query again.\n            if len(page_results) + startv < self._pagesize:\n                break\n\n            # If we got the whole page, but the next page is not interesting,\n            # break out early as well\n            if end == nextfirstid:\n                break\n        return res\n\n\nclass InAdvancePagedList(PagedList):\n    def __init__(self, pagefunc, pagecount, pagesize):\n        self._pagefunc = pagefunc\n        self._pagecount = pagecount\n        self._pagesize = pagesize\n\n    def getslice(self, start=0, end=None):\n        res = []\n        start_page = start // self._pagesize\n        end_page = (\n            self._pagecount if end is None else (end // self._pagesize + 1))\n        skip_elems = start - start_page * self._pagesize\n        only_more = None if end is None else end - start\n        for pagenum in range(start_page, end_page):\n            page = list(self._pagefunc(pagenum))\n            if skip_elems:\n                page = page[skip_elems:]\n                skip_elems = None\n            if only_more is not None:\n                if len(page) < only_more:\n                    only_more -= len(page)\n                else:\n                    page = page[:only_more]\n                    res.extend(page)\n                    break\n            res.extend(page)\n        return res\n\n\ndef uppercase_escape(s):\n    unicode_escape = codecs.getdecoder('unicode_escape')\n    return re.sub(\n        r'\\\\U[0-9a-fA-F]{8}',\n        lambda m: unicode_escape(m.group(0))[0],\n        s)\n\n\ndef lowercase_escape(s):\n    unicode_escape = codecs.getdecoder('unicode_escape')\n    return re.sub(\n        r'\\\\u[0-9a-fA-F]{4}',\n        lambda m: unicode_escape(m.group(0))[0],\n        s)\n\n\ndef escape_rfc3986(s):\n    \"\"\"Escape non-ASCII characters as suggested by RFC 3986\"\"\"\n    if sys.version_info < (3, 0) and isinstance(s, compat_str):\n        s = s.encode('utf-8')\n    return compat_urllib_parse.quote(s, b\"%/;:@&=+$,!~*'()?#[]\")\n\n\ndef escape_url(url):\n    \"\"\"Escape URL as suggested by RFC 3986\"\"\"\n    url_parsed = compat_urllib_parse_urlparse(url)\n    return url_parsed._replace(\n        netloc=url_parsed.netloc.encode('idna').decode('ascii'),\n        path=escape_rfc3986(url_parsed.path),\n        params=escape_rfc3986(url_parsed.params),\n        query=escape_rfc3986(url_parsed.query),\n        fragment=escape_rfc3986(url_parsed.fragment)\n    ).geturl()\n\n\ndef read_batch_urls(batch_fd):\n    def fixup(url):\n        if not isinstance(url, compat_str):\n            url = url.decode('utf-8', 'replace')\n        BOM_UTF8 = '\\xef\\xbb\\xbf'\n        if url.startswith(BOM_UTF8):\n            url = url[len(BOM_UTF8):]\n        url = url.strip()\n        if url.startswith(('#', ';', ']')):\n            return False\n        return url\n\n    with contextlib.closing(batch_fd) as fd:\n        return [url for url in map(fixup, fd) if url]\n\n\ndef urlencode_postdata(*args, **kargs):\n    return compat_urllib_parse_urlencode(*args, **kargs).encode('ascii')\n\n\ndef update_url_query(url, query):\n    if not query:\n        return url\n    parsed_url = compat_urlparse.urlparse(url)\n    qs = compat_parse_qs(parsed_url.query)\n    qs.update(query)\n    return compat_urlparse.urlunparse(parsed_url._replace(\n        query=compat_urllib_parse_urlencode(qs, True)))\n\n\ndef update_Request(req, url=None, data=None, headers={}, query={}):\n    req_headers = req.headers.copy()\n    req_headers.update(headers)\n    req_data = data or req.data\n    req_url = update_url_query(url or req.get_full_url(), query)\n    req_get_method = req.get_method()\n    if req_get_method == 'HEAD':\n        req_type = HEADRequest\n    elif req_get_method == 'PUT':\n        req_type = PUTRequest\n    else:\n        req_type = compat_urllib_request.Request\n    new_req = req_type(\n        req_url, data=req_data, headers=req_headers,\n        origin_req_host=req.origin_req_host, unverifiable=req.unverifiable)\n    if hasattr(req, 'timeout'):\n        new_req.timeout = req.timeout\n    return new_req\n\n\ndef _multipart_encode_impl(data, boundary):\n    content_type = 'multipart/form-data; boundary=%s' % boundary\n\n    out = b''\n    for k, v in data.items():\n        out += b'--' + boundary.encode('ascii') + b'\\r\\n'\n        if isinstance(k, compat_str):\n            k = k.encode('utf-8')\n        if isinstance(v, compat_str):\n            v = v.encode('utf-8')\n        # RFC 2047 requires non-ASCII field names to be encoded, while RFC 7578\n        # suggests sending UTF-8 directly. Firefox sends UTF-8, too\n        content = b'Content-Disposition: form-data; name=\"' + k + b'\"\\r\\n\\r\\n' + v + b'\\r\\n'\n        if boundary.encode('ascii') in content:\n            raise ValueError('Boundary overlaps with data')\n        out += content\n\n    out += b'--' + boundary.encode('ascii') + b'--\\r\\n'\n\n    return out, content_type\n\n\ndef multipart_encode(data, boundary=None):\n    '''\n    Encode a dict to RFC 7578-compliant form-data\n\n    data:\n        A dict where keys and values can be either Unicode or bytes-like\n        objects.\n    boundary:\n        If specified a Unicode object, it's used as the boundary. Otherwise\n        a random boundary is generated.\n\n    Reference: https://tools.ietf.org/html/rfc7578\n    '''\n    has_specified_boundary = boundary is not None\n\n    while True:\n        if boundary is None:\n            boundary = '---------------' + str(random.randrange(0x0fffffff, 0xffffffff))\n\n        try:\n            out, content_type = _multipart_encode_impl(data, boundary)\n            break\n        except ValueError:\n            if has_specified_boundary:\n                raise\n            boundary = None\n\n    return out, content_type\n\n\ndef dict_get(d, key_or_keys, default=None, skip_false_values=True):\n    if isinstance(key_or_keys, (list, tuple)):\n        for key in key_or_keys:\n            if key not in d or d[key] is None or skip_false_values and not d[key]:\n                continue\n            return d[key]\n        return default\n    return d.get(key_or_keys, default)\n\n\ndef try_get(src, getter, expected_type=None):\n    if not isinstance(getter, (list, tuple)):\n        getter = [getter]\n    for get in getter:\n        try:\n            v = get(src)\n        except (AttributeError, KeyError, TypeError, IndexError):\n            pass\n        else:\n            if expected_type is None or isinstance(v, expected_type):\n                return v\n\n\ndef encode_compat_str(string, encoding=preferredencoding(), errors='strict'):\n    return string if isinstance(string, compat_str) else compat_str(string, encoding, errors)\n\n\nUS_RATINGS = {\n    'G': 0,\n    'PG': 10,\n    'PG-13': 13,\n    'R': 16,\n    'NC': 18,\n}\n\n\nTV_PARENTAL_GUIDELINES = {\n    'TV-Y': 0,\n    'TV-Y7': 7,\n    'TV-G': 0,\n    'TV-PG': 0,\n    'TV-14': 14,\n    'TV-MA': 17,\n}\n\n\ndef parse_age_limit(s):\n    if type(s) == int:\n        return s if 0 <= s <= 21 else None\n    if not isinstance(s, compat_basestring):\n        return None\n    m = re.match(r'^(?P<age>\\d{1,2})\\+?$', s)\n    if m:\n        return int(m.group('age'))\n    if s in US_RATINGS:\n        return US_RATINGS[s]\n    return TV_PARENTAL_GUIDELINES.get(s)\n\n\ndef strip_jsonp(code):\n    return re.sub(\n        r'''(?sx)^\n            (?:window\\.)?(?P<func_name>[a-zA-Z0-9_.$]+)\n            (?:\\s*&&\\s*(?P=func_name))?\n            \\s*\\(\\s*(?P<callback_data>.*)\\);?\n            \\s*?(?://[^\\n]*)*$''',\n        r'\\g<callback_data>', code)\n\n\ndef js_to_json(code):\n    COMMENT_RE = r'/\\*(?:(?!\\*/).)*?\\*/|//[^\\n]*'\n    SKIP_RE = r'\\s*(?:{comment})?\\s*'.format(comment=COMMENT_RE)\n    INTEGER_TABLE = (\n        (r'(?s)^(0[xX][0-9a-fA-F]+){skip}:?$'.format(skip=SKIP_RE), 16),\n        (r'(?s)^(0+[0-7]+){skip}:?$'.format(skip=SKIP_RE), 8),\n    )\n\n    def fix_kv(m):\n        v = m.group(0)\n        if v in ('true', 'false', 'null'):\n            return v\n        elif v.startswith('/*') or v.startswith('//') or v == ',':\n            return \"\"\n\n        if v[0] in (\"'\", '\"'):\n            v = re.sub(r'(?s)\\\\.|\"', lambda m: {\n                '\"': '\\\\\"',\n                \"\\\\'\": \"'\",\n                '\\\\\\n': '',\n                '\\\\x': '\\\\u00',\n            }.get(m.group(0), m.group(0)), v[1:-1])\n\n        for regex, base in INTEGER_TABLE:\n            im = re.match(regex, v)\n            if im:\n                i = int(im.group(1), base)\n                return '\"%d\":' % i if v.endswith(':') else '%d' % i\n\n        return '\"%s\"' % v\n\n    return re.sub(r'''(?sx)\n        \"(?:[^\"\\\\]*(?:\\\\\\\\|\\\\['\"nurtbfx/\\n]))*[^\"\\\\]*\"|\n        '(?:[^'\\\\]*(?:\\\\\\\\|\\\\['\"nurtbfx/\\n]))*[^'\\\\]*'|\n        {comment}|,(?={skip}[\\]}}])|\n        (?:(?<![0-9])[eE]|[a-df-zA-DF-Z_])[.a-zA-Z_0-9]*|\n        \\b(?:0[xX][0-9a-fA-F]+|0+[0-7]+)(?:{skip}:)?|\n        [0-9]+(?={skip}:)\n        '''.format(comment=COMMENT_RE, skip=SKIP_RE), fix_kv, code)\n\n\ndef qualities(quality_ids):\n    \"\"\" Get a numeric quality value out of a list of possible values \"\"\"\n    def q(qid):\n        try:\n            return quality_ids.index(qid)\n        except ValueError:\n            return -1\n    return q\n\n\nDEFAULT_OUTTMPL = '%(title)s-%(id)s.%(ext)s'\n\n\ndef limit_length(s, length):\n    \"\"\" Add ellipses to overly long strings \"\"\"\n    if s is None:\n        return None\n    ELLIPSES = '...'\n    if len(s) > length:\n        return s[:length - len(ELLIPSES)] + ELLIPSES\n    return s\n\n\ndef version_tuple(v):\n    return tuple(int(e) for e in re.split(r'[-.]', v))\n\n\ndef is_outdated_version(version, limit, assume_new=True):\n    if not version:\n        return not assume_new\n    try:\n        return version_tuple(version) < version_tuple(limit)\n    except ValueError:\n        return not assume_new\n\n\ndef ytdl_is_updateable():\n    \"\"\" Returns if youtube-dl can be updated with -U \"\"\"\n    from zipimport import zipimporter\n\n    return isinstance(globals().get('__loader__'), zipimporter) or hasattr(sys, 'frozen')\n\n\ndef args_to_str(args):\n    # Get a short string representation for a subprocess command\n    return ' '.join(compat_shlex_quote(a) for a in args)\n\n\ndef error_to_compat_str(err):\n    err_str = str(err)\n    # On python 2 error byte string must be decoded with proper\n    # encoding rather than ascii\n    if sys.version_info[0] < 3:\n        err_str = err_str.decode(preferredencoding())\n    return err_str\n\n\ndef mimetype2ext(mt):\n    if mt is None:\n        return None\n\n    ext = {\n        'audio/mp4': 'm4a',\n        # Per RFC 3003, audio/mpeg can be .mp1, .mp2 or .mp3. Here use .mp3 as\n        # it's the most popular one\n        'audio/mpeg': 'mp3',\n    }.get(mt)\n    if ext is not None:\n        return ext\n\n    _, _, res = mt.rpartition('/')\n    res = res.split(';')[0].strip().lower()\n\n    return {\n        '3gpp': '3gp',\n        'smptett+xml': 'tt',\n        'ttaf+xml': 'dfxp',\n        'ttml+xml': 'ttml',\n        'x-flv': 'flv',\n        'x-mp4-fragmented': 'mp4',\n        'x-ms-sami': 'sami',\n        'x-ms-wmv': 'wmv',\n        'mpegurl': 'm3u8',\n        'x-mpegurl': 'm3u8',\n        'vnd.apple.mpegurl': 'm3u8',\n        'dash+xml': 'mpd',\n        'f4m+xml': 'f4m',\n        'hds+xml': 'f4m',\n        'vnd.ms-sstr+xml': 'ism',\n        'quicktime': 'mov',\n        'mp2t': 'ts',\n    }.get(res, res)\n\n\ndef parse_codecs(codecs_str):\n    # http://tools.ietf.org/html/rfc6381\n    if not codecs_str:\n        return {}\n    splited_codecs = list(filter(None, map(\n        lambda str: str.strip(), codecs_str.strip().strip(',').split(','))))\n    vcodec, acodec = None, None\n    for full_codec in splited_codecs:\n        codec = full_codec.split('.')[0]\n        if codec in ('avc1', 'avc2', 'avc3', 'avc4', 'vp9', 'vp8', 'hev1', 'hev2', 'h263', 'h264', 'mp4v', 'hvc1'):\n            if not vcodec:\n                vcodec = full_codec\n        elif codec in ('mp4a', 'opus', 'vorbis', 'mp3', 'aac', 'ac-3', 'ec-3', 'eac3', 'dtsc', 'dtse', 'dtsh', 'dtsl'):\n            if not acodec:\n                acodec = full_codec\n        else:\n            write_string('WARNING: Unknown codec %s\\n' % full_codec, sys.stderr)\n    if not vcodec and not acodec:\n        if len(splited_codecs) == 2:\n            return {\n                'vcodec': vcodec,\n                'acodec': acodec,\n            }\n        elif len(splited_codecs) == 1:\n            return {\n                'vcodec': 'none',\n                'acodec': vcodec,\n            }\n    else:\n        return {\n            'vcodec': vcodec or 'none',\n            'acodec': acodec or 'none',\n        }\n    return {}\n\n\ndef urlhandle_detect_ext(url_handle):\n    getheader = url_handle.headers.get\n\n    cd = getheader('Content-Disposition')\n    if cd:\n        m = re.match(r'attachment;\\s*filename=\"(?P<filename>[^\"]+)\"', cd)\n        if m:\n            e = determine_ext(m.group('filename'), default_ext=None)\n            if e:\n                return e\n\n    return mimetype2ext(getheader('Content-Type'))\n\n\ndef encode_data_uri(data, mime_type):\n    return 'data:%s;base64,%s' % (mime_type, base64.b64encode(data).decode('ascii'))\n\n\ndef age_restricted(content_limit, age_limit):\n    \"\"\" Returns True iff the content should be blocked \"\"\"\n\n    if age_limit is None:  # No limit set\n        return False\n    if content_limit is None:\n        return False  # Content available for everyone\n    return age_limit < content_limit\n\n\ndef is_html(first_bytes):\n    \"\"\" Detect whether a file contains HTML by examining its first bytes. \"\"\"\n\n    BOMS = [\n        (b'\\xef\\xbb\\xbf', 'utf-8'),\n        (b'\\x00\\x00\\xfe\\xff', 'utf-32-be'),\n        (b'\\xff\\xfe\\x00\\x00', 'utf-32-le'),\n        (b'\\xff\\xfe', 'utf-16-le'),\n        (b'\\xfe\\xff', 'utf-16-be'),\n    ]\n    for bom, enc in BOMS:\n        if first_bytes.startswith(bom):\n            s = first_bytes[len(bom):].decode(enc, 'replace')\n            break\n    else:\n        s = first_bytes.decode('utf-8', 'replace')\n\n    return re.match(r'^\\s*<', s)\n\n\ndef determine_protocol(info_dict):\n    protocol = info_dict.get('protocol')\n    if protocol is not None:\n        return protocol\n\n    url = info_dict['url']\n    if url.startswith('rtmp'):\n        return 'rtmp'\n    elif url.startswith('mms'):\n        return 'mms'\n    elif url.startswith('rtsp'):\n        return 'rtsp'\n\n    ext = determine_ext(url)\n    if ext == 'm3u8':\n        return 'm3u8'\n    elif ext == 'f4m':\n        return 'f4m'\n\n    return compat_urllib_parse_urlparse(url).scheme\n\n\ndef render_table(header_row, data):\n    \"\"\" Render a list of rows, each as a list of values \"\"\"\n    table = [header_row] + data\n    max_lens = [max(len(compat_str(v)) for v in col) for col in zip(*table)]\n    format_str = ' '.join('%-' + compat_str(ml + 1) + 's' for ml in max_lens[:-1]) + '%s'\n    return '\\n'.join(format_str % tuple(row) for row in table)\n\n\ndef _match_one(filter_part, dct):\n    COMPARISON_OPERATORS = {\n        '<': operator.lt,\n        '<=': operator.le,\n        '>': operator.gt,\n        '>=': operator.ge,\n        '=': operator.eq,\n        '!=': operator.ne,\n    }\n    operator_rex = re.compile(r'''(?x)\\s*\n        (?P<key>[a-z_]+)\n        \\s*(?P<op>%s)(?P<none_inclusive>\\s*\\?)?\\s*\n        (?:\n            (?P<intval>[0-9.]+(?:[kKmMgGtTpPeEzZyY]i?[Bb]?)?)|\n            (?P<quote>[\"\\'])(?P<quotedstrval>(?:\\\\.|(?!(?P=quote)|\\\\).)+?)(?P=quote)|\n            (?P<strval>(?![0-9.])[a-z0-9A-Z]*)\n        )\n        \\s*$\n        ''' % '|'.join(map(re.escape, COMPARISON_OPERATORS.keys())))\n    m = operator_rex.search(filter_part)\n    if m:\n        op = COMPARISON_OPERATORS[m.group('op')]\n        actual_value = dct.get(m.group('key'))\n        if (m.group('quotedstrval') is not None or\n            m.group('strval') is not None or\n            # If the original field is a string and matching comparisonvalue is\n            # a number we should respect the origin of the original field\n            # and process comparison value as a string (see\n            # https://github.com/rg3/youtube-dl/issues/11082).\n            actual_value is not None and m.group('intval') is not None and\n                isinstance(actual_value, compat_str)):\n            if m.group('op') not in ('=', '!='):\n                raise ValueError(\n                    'Operator %s does not support string values!' % m.group('op'))\n            comparison_value = m.group('quotedstrval') or m.group('strval') or m.group('intval')\n            quote = m.group('quote')\n            if quote is not None:\n                comparison_value = comparison_value.replace(r'\\%s' % quote, quote)\n        else:\n            try:\n                comparison_value = int(m.group('intval'))\n            except ValueError:\n                comparison_value = parse_filesize(m.group('intval'))\n                if comparison_value is None:\n                    comparison_value = parse_filesize(m.group('intval') + 'B')\n                if comparison_value is None:\n                    raise ValueError(\n                        'Invalid integer value %r in filter part %r' % (\n                            m.group('intval'), filter_part))\n        if actual_value is None:\n            return m.group('none_inclusive')\n        return op(actual_value, comparison_value)\n\n    UNARY_OPERATORS = {\n        '': lambda v: v is not None,\n        '!': lambda v: v is None,\n    }\n    operator_rex = re.compile(r'''(?x)\\s*\n        (?P<op>%s)\\s*(?P<key>[a-z_]+)\n        \\s*$\n        ''' % '|'.join(map(re.escape, UNARY_OPERATORS.keys())))\n    m = operator_rex.search(filter_part)\n    if m:\n        op = UNARY_OPERATORS[m.group('op')]\n        actual_value = dct.get(m.group('key'))\n        return op(actual_value)\n\n    raise ValueError('Invalid filter part %r' % filter_part)\n\n\ndef match_str(filter_str, dct):\n    \"\"\" Filter a dictionary with a simple string syntax. Returns True (=passes filter) or false \"\"\"\n\n    return all(\n        _match_one(filter_part, dct) for filter_part in filter_str.split('&'))\n\n\ndef match_filter_func(filter_str):\n    def _match_func(info_dict):\n        if match_str(filter_str, info_dict):\n            return None\n        else:\n            video_title = info_dict.get('title', info_dict.get('id', 'video'))\n            return '%s does not pass filter %s, skipping ..' % (video_title, filter_str)\n    return _match_func\n\n\ndef parse_dfxp_time_expr(time_expr):\n    if not time_expr:\n        return\n\n    mobj = re.match(r'^(?P<time_offset>\\d+(?:\\.\\d+)?)s?$', time_expr)\n    if mobj:\n        return float(mobj.group('time_offset'))\n\n    mobj = re.match(r'^(\\d+):(\\d\\d):(\\d\\d(?:(?:\\.|:)\\d+)?)$', time_expr)\n    if mobj:\n        return 3600 * int(mobj.group(1)) + 60 * int(mobj.group(2)) + float(mobj.group(3).replace(':', '.'))\n\n\ndef srt_subtitles_timecode(seconds):\n    return '%02d:%02d:%02d,%03d' % (seconds / 3600, (seconds % 3600) / 60, seconds % 60, (seconds % 1) * 1000)\n\n\ndef dfxp2srt(dfxp_data):\n    '''\n    @param dfxp_data A bytes-like object containing DFXP data\n    @returns A unicode object containing converted SRT data\n    '''\n    LEGACY_NAMESPACES = (\n        (b'http://www.w3.org/ns/ttml', [\n            b'http://www.w3.org/2004/11/ttaf1',\n            b'http://www.w3.org/2006/04/ttaf1',\n            b'http://www.w3.org/2006/10/ttaf1',\n        ]),\n        (b'http://www.w3.org/ns/ttml#styling', [\n            b'http://www.w3.org/ns/ttml#style',\n        ]),\n    )\n\n    SUPPORTED_STYLING = [\n        'color',\n        'fontFamily',\n        'fontSize',\n        'fontStyle',\n        'fontWeight',\n        'textDecoration'\n    ]\n\n    _x = functools.partial(xpath_with_ns, ns_map={\n        'ttml': 'http://www.w3.org/ns/ttml',\n        'tts': 'http://www.w3.org/ns/ttml#styling',\n    })\n\n    styles = {}\n    default_style = {}\n\n    class TTMLPElementParser(object):\n        _out = ''\n        _unclosed_elements = []\n        _applied_styles = []\n\n        def start(self, tag, attrib):\n            if tag in (_x('ttml:br'), 'br'):\n                self._out += '\\n'\n            else:\n                unclosed_elements = []\n                style = {}\n                element_style_id = attrib.get('style')\n                if default_style:\n                    style.update(default_style)\n                if element_style_id:\n                    style.update(styles.get(element_style_id, {}))\n                for prop in SUPPORTED_STYLING:\n                    prop_val = attrib.get(_x('tts:' + prop))\n                    if prop_val:\n                        style[prop] = prop_val\n                if style:\n                    font = ''\n                    for k, v in sorted(style.items()):\n                        if self._applied_styles and self._applied_styles[-1].get(k) == v:\n                            continue\n                        if k == 'color':\n                            font += ' color=\"%s\"' % v\n                        elif k == 'fontSize':\n                            font += ' size=\"%s\"' % v\n                        elif k == 'fontFamily':\n                            font += ' face=\"%s\"' % v\n                        elif k == 'fontWeight' and v == 'bold':\n                            self._out += '<b>'\n                            unclosed_elements.append('b')\n                        elif k == 'fontStyle' and v == 'italic':\n                            self._out += '<i>'\n                            unclosed_elements.append('i')\n                        elif k == 'textDecoration' and v == 'underline':\n                            self._out += '<u>'\n                            unclosed_elements.append('u')\n                    if font:\n                        self._out += '<font' + font + '>'\n                        unclosed_elements.append('font')\n                    applied_style = {}\n                    if self._applied_styles:\n                        applied_style.update(self._applied_styles[-1])\n                    applied_style.update(style)\n                    self._applied_styles.append(applied_style)\n                self._unclosed_elements.append(unclosed_elements)\n\n        def end(self, tag):\n            if tag not in (_x('ttml:br'), 'br'):\n                unclosed_elements = self._unclosed_elements.pop()\n                for element in reversed(unclosed_elements):\n                    self._out += '</%s>' % element\n                if unclosed_elements and self._applied_styles:\n                    self._applied_styles.pop()\n\n        def data(self, data):\n            self._out += data\n\n        def close(self):\n            return self._out.strip()\n\n    def parse_node(node):\n        target = TTMLPElementParser()\n        parser = xml.etree.ElementTree.XMLParser(target=target)\n        parser.feed(xml.etree.ElementTree.tostring(node))\n        return parser.close()\n\n    for k, v in LEGACY_NAMESPACES:\n        for ns in v:\n            dfxp_data = dfxp_data.replace(ns, k)\n\n    dfxp = compat_etree_fromstring(dfxp_data)\n    out = []\n    paras = dfxp.findall(_x('.//ttml:p')) or dfxp.findall('.//p')\n\n    if not paras:\n        raise ValueError('Invalid dfxp/TTML subtitle')\n\n    repeat = False\n    while True:\n        for style in dfxp.findall(_x('.//ttml:style')):\n            style_id = style.get('id')\n            parent_style_id = style.get('style')\n            if parent_style_id:\n                if parent_style_id not in styles:\n                    repeat = True\n                    continue\n                styles[style_id] = styles[parent_style_id].copy()\n            for prop in SUPPORTED_STYLING:\n                prop_val = style.get(_x('tts:' + prop))\n                if prop_val:\n                    styles.setdefault(style_id, {})[prop] = prop_val\n        if repeat:\n            repeat = False\n        else:\n            break\n\n    for p in ('body', 'div'):\n        ele = xpath_element(dfxp, [_x('.//ttml:' + p), './/' + p])\n        if ele is None:\n            continue\n        style = styles.get(ele.get('style'))\n        if not style:\n            continue\n        default_style.update(style)\n\n    for para, index in zip(paras, itertools.count(1)):\n        begin_time = parse_dfxp_time_expr(para.attrib.get('begin'))\n        end_time = parse_dfxp_time_expr(para.attrib.get('end'))\n        dur = parse_dfxp_time_expr(para.attrib.get('dur'))\n        if begin_time is None:\n            continue\n        if not end_time:\n            if not dur:\n                continue\n            end_time = begin_time + dur\n        out.append('%d\\n%s --> %s\\n%s\\n\\n' % (\n            index,\n            srt_subtitles_timecode(begin_time),\n            srt_subtitles_timecode(end_time),\n            parse_node(para)))\n\n    return ''.join(out)\n\n\ndef cli_option(params, command_option, param):\n    param = params.get(param)\n    if param:\n        param = compat_str(param)\n    return [command_option, param] if param is not None else []\n\n\ndef cli_bool_option(params, command_option, param, true_value='true', false_value='false', separator=None):\n    param = params.get(param)\n    if param is None:\n        return []\n    assert isinstance(param, bool)\n    if separator:\n        return [command_option + separator + (true_value if param else false_value)]\n    return [command_option, true_value if param else false_value]\n\n\ndef cli_valueless_option(params, command_option, param, expected_value=True):\n    param = params.get(param)\n    return [command_option] if param == expected_value else []\n\n\ndef cli_configuration_args(params, param, default=[]):\n    ex_args = params.get(param)\n    if ex_args is None:\n        return default\n    assert isinstance(ex_args, list)\n    return ex_args\n\n\nclass ISO639Utils(object):\n    # See http://www.loc.gov/standards/iso639-2/ISO-639-2_utf-8.txt\n    _lang_map = {\n        'aa': 'aar',\n        'ab': 'abk',\n        'ae': 'ave',\n        'af': 'afr',\n        'ak': 'aka',\n        'am': 'amh',\n        'an': 'arg',\n        'ar': 'ara',\n        'as': 'asm',\n        'av': 'ava',\n        'ay': 'aym',\n        'az': 'aze',\n        'ba': 'bak',\n        'be': 'bel',\n        'bg': 'bul',\n        'bh': 'bih',\n        'bi': 'bis',\n        'bm': 'bam',\n        'bn': 'ben',\n        'bo': 'bod',\n        'br': 'bre',\n        'bs': 'bos',\n        'ca': 'cat',\n        'ce': 'che',\n        'ch': 'cha',\n        'co': 'cos',\n        'cr': 'cre',\n        'cs': 'ces',\n        'cu': 'chu',\n        'cv': 'chv',\n        'cy': 'cym',\n        'da': 'dan',\n        'de': 'deu',\n        'dv': 'div',\n        'dz': 'dzo',\n        'ee': 'ewe',\n        'el': 'ell',\n        'en': 'eng',\n        'eo': 'epo',\n        'es': 'spa',\n        'et': 'est',\n        'eu': 'eus',\n        'fa': 'fas',\n        'ff': 'ful',\n        'fi': 'fin',\n        'fj': 'fij',\n        'fo': 'fao',\n        'fr': 'fra',\n        'fy': 'fry',\n        'ga': 'gle',\n        'gd': 'gla',\n        'gl': 'glg',\n        'gn': 'grn',\n        'gu': 'guj',\n        'gv': 'glv',\n        'ha': 'hau',\n        'he': 'heb',\n        'hi': 'hin',\n        'ho': 'hmo',\n        'hr': 'hrv',\n        'ht': 'hat',\n        'hu': 'hun',\n        'hy': 'hye',\n        'hz': 'her',\n        'ia': 'ina',\n        'id': 'ind',\n        'ie': 'ile',\n        'ig': 'ibo',\n        'ii': 'iii',\n        'ik': 'ipk',\n        'io': 'ido',\n        'is': 'isl',\n        'it': 'ita',\n        'iu': 'iku',\n        'ja': 'jpn',\n        'jv': 'jav',\n        'ka': 'kat',\n        'kg': 'kon',\n        'ki': 'kik',\n        'kj': 'kua',\n        'kk': 'kaz',\n        'kl': 'kal',\n        'km': 'khm',\n        'kn': 'kan',\n        'ko': 'kor',\n        'kr': 'kau',\n        'ks': 'kas',\n        'ku': 'kur',\n        'kv': 'kom',\n        'kw': 'cor',\n        'ky': 'kir',\n        'la': 'lat',\n        'lb': 'ltz',\n        'lg': 'lug',\n        'li': 'lim',\n        'ln': 'lin',\n        'lo': 'lao',\n        'lt': 'lit',\n        'lu': 'lub',\n        'lv': 'lav',\n        'mg': 'mlg',\n        'mh': 'mah',\n        'mi': 'mri',\n        'mk': 'mkd',\n        'ml': 'mal',\n        'mn': 'mon',\n        'mr': 'mar',\n        'ms': 'msa',\n        'mt': 'mlt',\n        'my': 'mya',\n        'na': 'nau',\n        'nb': 'nob',\n        'nd': 'nde',\n        'ne': 'nep',\n        'ng': 'ndo',\n        'nl': 'nld',\n        'nn': 'nno',\n        'no': 'nor',\n        'nr': 'nbl',\n        'nv': 'nav',\n        'ny': 'nya',\n        'oc': 'oci',\n        'oj': 'oji',\n        'om': 'orm',\n        'or': 'ori',\n        'os': 'oss',\n        'pa': 'pan',\n        'pi': 'pli',\n        'pl': 'pol',\n        'ps': 'pus',\n        'pt': 'por',\n        'qu': 'que',\n        'rm': 'roh',\n        'rn': 'run',\n        'ro': 'ron',\n        'ru': 'rus',\n        'rw': 'kin',\n        'sa': 'san',\n        'sc': 'srd',\n        'sd': 'snd',\n        'se': 'sme',\n        'sg': 'sag',\n        'si': 'sin',\n        'sk': 'slk',\n        'sl': 'slv',\n        'sm': 'smo',\n        'sn': 'sna',\n        'so': 'som',\n        'sq': 'sqi',\n        'sr': 'srp',\n        'ss': 'ssw',\n        'st': 'sot',\n        'su': 'sun',\n        'sv': 'swe',\n        'sw': 'swa',\n        'ta': 'tam',\n        'te': 'tel',\n        'tg': 'tgk',\n        'th': 'tha',\n        'ti': 'tir',\n        'tk': 'tuk',\n        'tl': 'tgl',\n        'tn': 'tsn',\n        'to': 'ton',\n        'tr': 'tur',\n        'ts': 'tso',\n        'tt': 'tat',\n        'tw': 'twi',\n        'ty': 'tah',\n        'ug': 'uig',\n        'uk': 'ukr',\n        'ur': 'urd',\n        'uz': 'uzb',\n        've': 'ven',\n        'vi': 'vie',\n        'vo': 'vol',\n        'wa': 'wln',\n        'wo': 'wol',\n        'xh': 'xho',\n        'yi': 'yid',\n        'yo': 'yor',\n        'za': 'zha',\n        'zh': 'zho',\n        'zu': 'zul',\n    }\n\n    @classmethod\n    def short2long(cls, code):\n        \"\"\"Convert language code from ISO 639-1 to ISO 639-2/T\"\"\"\n        return cls._lang_map.get(code[:2])\n\n    @classmethod\n    def long2short(cls, code):\n        \"\"\"Convert language code from ISO 639-2/T to ISO 639-1\"\"\"\n        for short_name, long_name in cls._lang_map.items():\n            if long_name == code:\n                return short_name\n\n\nclass ISO3166Utils(object):\n    # From http://data.okfn.org/data/core/country-list\n    _country_map = {\n        'AF': 'Afghanistan',\n        'AX': '\u00c5land Islands',\n        'AL': 'Albania',\n        'DZ': 'Algeria',\n        'AS': 'American Samoa',\n        'AD': 'Andorra',\n        'AO': 'Angola',\n        'AI': 'Anguilla',\n        'AQ': 'Antarctica',\n        'AG': 'Antigua and Barbuda',\n        'AR': 'Argentina',\n        'AM': 'Armenia',\n        'AW': 'Aruba',\n        'AU': 'Australia',\n        'AT': 'Austria',\n        'AZ': 'Azerbaijan',\n        'BS': 'Bahamas',\n        'BH': 'Bahrain',\n        'BD': 'Bangladesh',\n        'BB': 'Barbados',\n        'BY': 'Belarus',\n        'BE': 'Belgium',\n        'BZ': 'Belize',\n        'BJ': 'Benin',\n        'BM': 'Bermuda',\n        'BT': 'Bhutan',\n        'BO': 'Bolivia, Plurinational State of',\n        'BQ': 'Bonaire, Sint Eustatius and Saba',\n        'BA': 'Bosnia and Herzegovina',\n        'BW': 'Botswana',\n        'BV': 'Bouvet Island',\n        'BR': 'Brazil',\n        'IO': 'British Indian Ocean Territory',\n        'BN': 'Brunei Darussalam',\n        'BG': 'Bulgaria',\n        'BF': 'Burkina Faso',\n        'BI': 'Burundi',\n        'KH': 'Cambodia',\n        'CM': 'Cameroon',\n        'CA': 'Canada',\n        'CV': 'Cape Verde',\n        'KY': 'Cayman Islands',\n        'CF': 'Central African Republic',\n        'TD': 'Chad',\n        'CL': 'Chile',\n        'CN': 'China',\n        'CX': 'Christmas Island',\n        'CC': 'Cocos (Keeling) Islands',\n        'CO': 'Colombia',\n        'KM': 'Comoros',\n        'CG': 'Congo',\n        'CD': 'Congo, the Democratic Republic of the',\n        'CK': 'Cook Islands',\n        'CR': 'Costa Rica',\n        'CI': 'C\u00f4te d\\'Ivoire',\n        'HR': 'Croatia',\n        'CU': 'Cuba',\n        'CW': 'Cura\u00e7ao',\n        'CY': 'Cyprus',\n        'CZ': 'Czech Republic',\n        'DK': 'Denmark',\n        'DJ': 'Djibouti',\n        'DM': 'Dominica',\n        'DO': 'Dominican Republic',\n        'EC': 'Ecuador',\n        'EG': 'Egypt',\n        'SV': 'El Salvador',\n        'GQ': 'Equatorial Guinea',\n        'ER': 'Eritrea',\n        'EE': 'Estonia',\n        'ET': 'Ethiopia',\n        'FK': 'Falkland Islands (Malvinas)',\n        'FO': 'Faroe Islands',\n        'FJ': 'Fiji',\n        'FI': 'Finland',\n        'FR': 'France',\n        'GF': 'French Guiana',\n        'PF': 'French Polynesia',\n        'TF': 'French Southern Territories',\n        'GA': 'Gabon',\n        'GM': 'Gambia',\n        'GE': 'Georgia',\n        'DE': 'Germany',\n        'GH': 'Ghana',\n        'GI': 'Gibraltar',\n        'GR': 'Greece',\n        'GL': 'Greenland',\n        'GD': 'Grenada',\n        'GP': 'Guadeloupe',\n        'GU': 'Guam',\n        'GT': 'Guatemala',\n        'GG': 'Guernsey',\n        'GN': 'Guinea',\n        'GW': 'Guinea-Bissau',\n        'GY': 'Guyana',\n        'HT': 'Haiti',\n        'HM': 'Heard Island and McDonald Islands',\n        'VA': 'Holy See (Vatican City State)',\n        'HN': 'Honduras',\n        'HK': 'Hong Kong',\n        'HU': 'Hungary',\n        'IS': 'Iceland',\n        'IN': 'India',\n        'ID': 'Indonesia',\n        'IR': 'Iran, Islamic Republic of',\n        'IQ': 'Iraq',\n        'IE': 'Ireland',\n        'IM': 'Isle of Man',\n        'IL': 'Israel',\n        'IT': 'Italy',\n        'JM': 'Jamaica',\n        'JP': 'Japan',\n        'JE': 'Jersey',\n        'JO': 'Jordan',\n        'KZ': 'Kazakhstan',\n        'KE': 'Kenya',\n        'KI': 'Kiribati',\n        'KP': 'Korea, Democratic People\\'s Republic of',\n        'KR': 'Korea, Republic of',\n        'KW': 'Kuwait',\n        'KG': 'Kyrgyzstan',\n        'LA': 'Lao People\\'s Democratic Republic',\n        'LV': 'Latvia',\n        'LB': 'Lebanon',\n        'LS': 'Lesotho',\n        'LR': 'Liberia',\n        'LY': 'Libya',\n        'LI': 'Liechtenstein',\n        'LT': 'Lithuania',\n        'LU': 'Luxembourg',\n        'MO': 'Macao',\n        'MK': 'Macedonia, the Former Yugoslav Republic of',\n        'MG': 'Madagascar',\n        'MW': 'Malawi',\n        'MY': 'Malaysia',\n        'MV': 'Maldives',\n        'ML': 'Mali',\n        'MT': 'Malta',\n        'MH': 'Marshall Islands',\n        'MQ': 'Martinique',\n        'MR': 'Mauritania',\n        'MU': 'Mauritius',\n        'YT': 'Mayotte',\n        'MX': 'Mexico',\n        'FM': 'Micronesia, Federated States of',\n        'MD': 'Moldova, Republic of',\n        'MC': 'Monaco',\n        'MN': 'Mongolia',\n        'ME': 'Montenegro',\n        'MS': 'Montserrat',\n        'MA': 'Morocco',\n        'MZ': 'Mozambique',\n        'MM': 'Myanmar',\n        'NA': 'Namibia',\n        'NR': 'Nauru',\n        'NP': 'Nepal',\n        'NL': 'Netherlands',\n        'NC': 'New Caledonia',\n        'NZ': 'New Zealand',\n        'NI': 'Nicaragua',\n        'NE': 'Niger',\n        'NG': 'Nigeria',\n        'NU': 'Niue',\n        'NF': 'Norfolk Island',\n        'MP': 'Northern Mariana Islands',\n        'NO': 'Norway',\n        'OM': 'Oman',\n        'PK': 'Pakistan',\n        'PW': 'Palau',\n        'PS': 'Palestine, State of',\n        'PA': 'Panama',\n        'PG': 'Papua New Guinea',\n        'PY': 'Paraguay',\n        'PE': 'Peru',\n        'PH': 'Philippines',\n        'PN': 'Pitcairn',\n        'PL': 'Poland',\n        'PT': 'Portugal',\n        'PR': 'Puerto Rico',\n        'QA': 'Qatar',\n        'RE': 'R\u00e9union',\n        'RO': 'Romania',\n        'RU': 'Russian Federation',\n        'RW': 'Rwanda',\n        'BL': 'Saint Barth\u00e9lemy',\n        'SH': 'Saint Helena, Ascension and Tristan da Cunha',\n        'KN': 'Saint Kitts and Nevis',\n        'LC': 'Saint Lucia',\n        'MF': 'Saint Martin (French part)',\n        'PM': 'Saint Pierre and Miquelon',\n        'VC': 'Saint Vincent and the Grenadines',\n        'WS': 'Samoa',\n        'SM': 'San Marino',\n        'ST': 'Sao Tome and Principe',\n        'SA': 'Saudi Arabia',\n        'SN': 'Senegal',\n        'RS': 'Serbia',\n        'SC': 'Seychelles',\n        'SL': 'Sierra Leone',\n        'SG': 'Singapore',\n        'SX': 'Sint Maarten (Dutch part)',\n        'SK': 'Slovakia',\n        'SI': 'Slovenia',\n        'SB': 'Solomon Islands',\n        'SO': 'Somalia',\n        'ZA': 'South Africa',\n        'GS': 'South Georgia and the South Sandwich Islands',\n        'SS': 'South Sudan',\n        'ES': 'Spain',\n        'LK': 'Sri Lanka',\n        'SD': 'Sudan',\n        'SR': 'Suriname',\n        'SJ': 'Svalbard and Jan Mayen',\n        'SZ': 'Swaziland',\n        'SE': 'Sweden',\n        'CH': 'Switzerland',\n        'SY': 'Syrian Arab Republic',\n        'TW': 'Taiwan, Province of China',\n        'TJ': 'Tajikistan',\n        'TZ': 'Tanzania, United Republic of',\n        'TH': 'Thailand',\n        'TL': 'Timor-Leste',\n        'TG': 'Togo',\n        'TK': 'Tokelau',\n        'TO': 'Tonga',\n        'TT': 'Trinidad and Tobago',\n        'TN': 'Tunisia',\n        'TR': 'Turkey',\n        'TM': 'Turkmenistan',\n        'TC': 'Turks and Caicos Islands',\n        'TV': 'Tuvalu',\n        'UG': 'Uganda',\n        'UA': 'Ukraine',\n        'AE': 'United Arab Emirates',\n        'GB': 'United Kingdom',\n        'US': 'United States',\n        'UM': 'United States Minor Outlying Islands',\n        'UY': 'Uruguay',\n        'UZ': 'Uzbekistan',\n        'VU': 'Vanuatu',\n        'VE': 'Venezuela, Bolivarian Republic of',\n        'VN': 'Viet Nam',\n        'VG': 'Virgin Islands, British',\n        'VI': 'Virgin Islands, U.S.',\n        'WF': 'Wallis and Futuna',\n        'EH': 'Western Sahara',\n        'YE': 'Yemen',\n        'ZM': 'Zambia',\n        'ZW': 'Zimbabwe',\n    }\n\n    @classmethod\n    def short2full(cls, code):\n        \"\"\"Convert an ISO 3166-2 country code to the corresponding full name\"\"\"\n        return cls._country_map.get(code.upper())\n\n\nclass GeoUtils(object):\n    # Major IPv4 address blocks per country\n    _country_ip_map = {\n        'AD': '85.94.160.0/19',\n        'AE': '94.200.0.0/13',\n        'AF': '149.54.0.0/17',\n        'AG': '209.59.64.0/18',\n        'AI': '204.14.248.0/21',\n        'AL': '46.99.0.0/16',\n        'AM': '46.70.0.0/15',\n        'AO': '105.168.0.0/13',\n        'AP': '159.117.192.0/21',\n        'AR': '181.0.0.0/12',\n        'AS': '202.70.112.0/20',\n        'AT': '84.112.0.0/13',\n        'AU': '1.128.0.0/11',\n        'AW': '181.41.0.0/18',\n        'AZ': '5.191.0.0/16',\n        'BA': '31.176.128.0/17',\n        'BB': '65.48.128.0/17',\n        'BD': '114.130.0.0/16',\n        'BE': '57.0.0.0/8',\n        'BF': '129.45.128.0/17',\n        'BG': '95.42.0.0/15',\n        'BH': '37.131.0.0/17',\n        'BI': '154.117.192.0/18',\n        'BJ': '137.255.0.0/16',\n        'BL': '192.131.134.0/24',\n        'BM': '196.12.64.0/18',\n        'BN': '156.31.0.0/16',\n        'BO': '161.56.0.0/16',\n        'BQ': '161.0.80.0/20',\n        'BR': '152.240.0.0/12',\n        'BS': '24.51.64.0/18',\n        'BT': '119.2.96.0/19',\n        'BW': '168.167.0.0/16',\n        'BY': '178.120.0.0/13',\n        'BZ': '179.42.192.0/18',\n        'CA': '99.224.0.0/11',\n        'CD': '41.243.0.0/16',\n        'CF': '196.32.200.0/21',\n        'CG': '197.214.128.0/17',\n        'CH': '85.0.0.0/13',\n        'CI': '154.232.0.0/14',\n        'CK': '202.65.32.0/19',\n        'CL': '152.172.0.0/14',\n        'CM': '165.210.0.0/15',\n        'CN': '36.128.0.0/10',\n        'CO': '181.240.0.0/12',\n        'CR': '201.192.0.0/12',\n        'CU': '152.206.0.0/15',\n        'CV': '165.90.96.0/19',\n        'CW': '190.88.128.0/17',\n        'CY': '46.198.0.0/15',\n        'CZ': '88.100.0.0/14',\n        'DE': '53.0.0.0/8',\n        'DJ': '197.241.0.0/17',\n        'DK': '87.48.0.0/12',\n        'DM': '192.243.48.0/20',\n        'DO': '152.166.0.0/15',\n        'DZ': '41.96.0.0/12',\n        'EC': '186.68.0.0/15',\n        'EE': '90.190.0.0/15',\n        'EG': '156.160.0.0/11',\n        'ER': '196.200.96.0/20',\n        'ES': '88.0.0.0/11',\n        'ET': '196.188.0.0/14',\n        'EU': '2.16.0.0/13',\n        'FI': '91.152.0.0/13',\n        'FJ': '144.120.0.0/16',\n        'FM': '119.252.112.0/20',\n        'FO': '88.85.32.0/19',\n        'FR': '90.0.0.0/9',\n        'GA': '41.158.0.0/15',\n        'GB': '25.0.0.0/8',\n        'GD': '74.122.88.0/21',\n        'GE': '31.146.0.0/16',\n        'GF': '161.22.64.0/18',\n        'GG': '62.68.160.0/19',\n        'GH': '45.208.0.0/14',\n        'GI': '85.115.128.0/19',\n        'GL': '88.83.0.0/19',\n        'GM': '160.182.0.0/15',\n        'GN': '197.149.192.0/18',\n        'GP': '104.250.0.0/19',\n        'GQ': '105.235.224.0/20',\n        'GR': '94.64.0.0/13',\n        'GT': '168.234.0.0/16',\n        'GU': '168.123.0.0/16',\n        'GW': '197.214.80.0/20',\n        'GY': '181.41.64.0/18',\n        'HK': '113.252.0.0/14',\n        'HN': '181.210.0.0/16',\n        'HR': '93.136.0.0/13',\n        'HT': '148.102.128.0/17',\n        'HU': '84.0.0.0/14',\n        'ID': '39.192.0.0/10',\n        'IE': '87.32.0.0/12',\n        'IL': '79.176.0.0/13',\n        'IM': '5.62.80.0/20',\n        'IN': '117.192.0.0/10',\n        'IO': '203.83.48.0/21',\n        'IQ': '37.236.0.0/14',\n        'IR': '2.176.0.0/12',\n        'IS': '82.221.0.0/16',\n        'IT': '79.0.0.0/10',\n        'JE': '87.244.64.0/18',\n        'JM': '72.27.0.0/17',\n        'JO': '176.29.0.0/16',\n        'JP': '126.0.0.0/8',\n        'KE': '105.48.0.0/12',\n        'KG': '158.181.128.0/17',\n        'KH': '36.37.128.0/17',\n        'KI': '103.25.140.0/22',\n        'KM': '197.255.224.0/20',\n        'KN': '198.32.32.0/19',\n        'KP': '175.45.176.0/22',\n        'KR': '175.192.0.0/10',\n        'KW': '37.36.0.0/14',\n        'KY': '64.96.0.0/15',\n        'KZ': '2.72.0.0/13',\n        'LA': '115.84.64.0/18',\n        'LB': '178.135.0.0/16',\n        'LC': '192.147.231.0/24',\n        'LI': '82.117.0.0/19',\n        'LK': '112.134.0.0/15',\n        'LR': '41.86.0.0/19',\n        'LS': '129.232.0.0/17',\n        'LT': '78.56.0.0/13',\n        'LU': '188.42.0.0/16',\n        'LV': '46.109.0.0/16',\n        'LY': '41.252.0.0/14',\n        'MA': '105.128.0.0/11',\n        'MC': '88.209.64.0/18',\n        'MD': '37.246.0.0/16',\n        'ME': '178.175.0.0/17',\n        'MF': '74.112.232.0/21',\n        'MG': '154.126.0.0/17',\n        'MH': '117.103.88.0/21',\n        'MK': '77.28.0.0/15',\n        'ML': '154.118.128.0/18',\n        'MM': '37.111.0.0/17',\n        'MN': '49.0.128.0/17',\n        'MO': '60.246.0.0/16',\n        'MP': '202.88.64.0/20',\n        'MQ': '109.203.224.0/19',\n        'MR': '41.188.64.0/18',\n        'MS': '208.90.112.0/22',\n        'MT': '46.11.0.0/16',\n        'MU': '105.16.0.0/12',\n        'MV': '27.114.128.0/18',\n        'MW': '105.234.0.0/16',\n        'MX': '187.192.0.0/11',\n        'MY': '175.136.0.0/13',\n        'MZ': '197.218.0.0/15',\n        'NA': '41.182.0.0/16',\n        'NC': '101.101.0.0/18',\n        'NE': '197.214.0.0/18',\n        'NF': '203.17.240.0/22',\n        'NG': '105.112.0.0/12',\n        'NI': '186.76.0.0/15',\n        'NL': '145.96.0.0/11',\n        'NO': '84.208.0.0/13',\n        'NP': '36.252.0.0/15',\n        'NR': '203.98.224.0/19',\n        'NU': '49.156.48.0/22',\n        'NZ': '49.224.0.0/14',\n        'OM': '5.36.0.0/15',\n        'PA': '186.72.0.0/15',\n        'PE': '186.160.0.0/14',\n        'PF': '123.50.64.0/18',\n        'PG': '124.240.192.0/19',\n        'PH': '49.144.0.0/13',\n        'PK': '39.32.0.0/11',\n        'PL': '83.0.0.0/11',\n        'PM': '70.36.0.0/20',\n        'PR': '66.50.0.0/16',\n        'PS': '188.161.0.0/16',\n        'PT': '85.240.0.0/13',\n        'PW': '202.124.224.0/20',\n        'PY': '181.120.0.0/14',\n        'QA': '37.210.0.0/15',\n        'RE': '139.26.0.0/16',\n        'RO': '79.112.0.0/13',\n        'RS': '178.220.0.0/14',\n        'RU': '5.136.0.0/13',\n        'RW': '105.178.0.0/15',\n        'SA': '188.48.0.0/13',\n        'SB': '202.1.160.0/19',\n        'SC': '154.192.0.0/11',\n        'SD': '154.96.0.0/13',\n        'SE': '78.64.0.0/12',\n        'SG': '152.56.0.0/14',\n        'SI': '188.196.0.0/14',\n        'SK': '78.98.0.0/15',\n        'SL': '197.215.0.0/17',\n        'SM': '89.186.32.0/19',\n        'SN': '41.82.0.0/15',\n        'SO': '197.220.64.0/19',\n        'SR': '186.179.128.0/17',\n        'SS': '105.235.208.0/21',\n        'ST': '197.159.160.0/19',\n        'SV': '168.243.0.0/16',\n        'SX': '190.102.0.0/20',\n        'SY': '5.0.0.0/16',\n        'SZ': '41.84.224.0/19',\n        'TC': '65.255.48.0/20',\n        'TD': '154.68.128.0/19',\n        'TG': '196.168.0.0/14',\n        'TH': '171.96.0.0/13',\n        'TJ': '85.9.128.0/18',\n        'TK': '27.96.24.0/21',\n        'TL': '180.189.160.0/20',\n        'TM': '95.85.96.0/19',\n        'TN': '197.0.0.0/11',\n        'TO': '175.176.144.0/21',\n        'TR': '78.160.0.0/11',\n        'TT': '186.44.0.0/15',\n        'TV': '202.2.96.0/19',\n        'TW': '120.96.0.0/11',\n        'TZ': '156.156.0.0/14',\n        'UA': '93.72.0.0/13',\n        'UG': '154.224.0.0/13',\n        'US': '3.0.0.0/8',\n        'UY': '167.56.0.0/13',\n        'UZ': '82.215.64.0/18',\n        'VA': '212.77.0.0/19',\n        'VC': '24.92.144.0/20',\n        'VE': '186.88.0.0/13',\n        'VG': '172.103.64.0/18',\n        'VI': '146.226.0.0/16',\n        'VN': '14.160.0.0/11',\n        'VU': '202.80.32.0/20',\n        'WF': '117.20.32.0/21',\n        'WS': '202.4.32.0/19',\n        'YE': '134.35.0.0/16',\n        'YT': '41.242.116.0/22',\n        'ZA': '41.0.0.0/11',\n        'ZM': '165.56.0.0/13',\n        'ZW': '41.85.192.0/19',\n    }\n\n    @classmethod\n    def random_ipv4(cls, code):\n        block = cls._country_ip_map.get(code.upper())\n        if not block:\n            return None\n        addr, preflen = block.split('/')\n        addr_min = compat_struct_unpack('!L', socket.inet_aton(addr))[0]\n        addr_max = addr_min | (0xffffffff >> int(preflen))\n        return compat_str(socket.inet_ntoa(\n            compat_struct_pack('!L', random.randint(addr_min, addr_max))))\n\n\nclass PerRequestProxyHandler(compat_urllib_request.ProxyHandler):\n    def __init__(self, proxies=None):\n        # Set default handlers\n        for type in ('http', 'https'):\n            setattr(self, '%s_open' % type,\n                    lambda r, proxy='__noproxy__', type=type, meth=self.proxy_open:\n                        meth(r, proxy, type))\n        return compat_urllib_request.ProxyHandler.__init__(self, proxies)\n\n    def proxy_open(self, req, proxy, type):\n        req_proxy = req.headers.get('Ytdl-request-proxy')\n        if req_proxy is not None:\n            proxy = req_proxy\n            del req.headers['Ytdl-request-proxy']\n\n        if proxy == '__noproxy__':\n            return None  # No Proxy\n        if compat_urlparse.urlparse(proxy).scheme.lower() in ('socks', 'socks4', 'socks4a', 'socks5'):\n            req.add_header('Ytdl-socks-proxy', proxy)\n            # youtube-dl's http/https handlers do wrapping the socket with socks\n            return None\n        return compat_urllib_request.ProxyHandler.proxy_open(\n            self, req, proxy, type)\n\n\n# Both long_to_bytes and bytes_to_long are adapted from PyCrypto, which is\n# released into Public Domain\n# https://github.com/dlitz/pycrypto/blob/master/lib/Crypto/Util/number.py#L387\n\ndef long_to_bytes(n, blocksize=0):\n    \"\"\"long_to_bytes(n:long, blocksize:int) : string\n    Convert a long integer to a byte string.\n\n    If optional blocksize is given and greater than zero, pad the front of the\n    byte string with binary zeros so that the length is a multiple of\n    blocksize.\n    \"\"\"\n    # after much testing, this algorithm was deemed to be the fastest\n    s = b''\n    n = int(n)\n    while n > 0:\n        s = compat_struct_pack('>I', n & 0xffffffff) + s\n        n = n >> 32\n    # strip off leading zeros\n    for i in range(len(s)):\n        if s[i] != b'\\000'[0]:\n            break\n    else:\n        # only happens when n == 0\n        s = b'\\000'\n        i = 0\n    s = s[i:]\n    # add back some pad bytes.  this could be done more efficiently w.r.t. the\n    # de-padding being done above, but sigh...\n    if blocksize > 0 and len(s) % blocksize:\n        s = (blocksize - len(s) % blocksize) * b'\\000' + s\n    return s\n\n\ndef bytes_to_long(s):\n    \"\"\"bytes_to_long(string) : long\n    Convert a byte string to a long integer.\n\n    This is (essentially) the inverse of long_to_bytes().\n    \"\"\"\n    acc = 0\n    length = len(s)\n    if length % 4:\n        extra = (4 - length % 4)\n        s = b'\\000' * extra + s\n        length = length + extra\n    for i in range(0, length, 4):\n        acc = (acc << 32) + compat_struct_unpack('>I', s[i:i + 4])[0]\n    return acc\n\n\ndef ohdave_rsa_encrypt(data, exponent, modulus):\n    '''\n    Implement OHDave's RSA algorithm. See http://www.ohdave.com/rsa/\n\n    Input:\n        data: data to encrypt, bytes-like object\n        exponent, modulus: parameter e and N of RSA algorithm, both integer\n    Output: hex string of encrypted data\n\n    Limitation: supports one block encryption only\n    '''\n\n    payload = int(binascii.hexlify(data[::-1]), 16)\n    encrypted = pow(payload, exponent, modulus)\n    return '%x' % encrypted\n\n\ndef pkcs1pad(data, length):\n    \"\"\"\n    Padding input data with PKCS#1 scheme\n\n    @param {int[]} data        input data\n    @param {int}   length      target length\n    @returns {int[]}           padded data\n    \"\"\"\n    if len(data) > length - 11:\n        raise ValueError('Input data too long for PKCS#1 padding')\n\n    pseudo_random = [random.randint(0, 254) for _ in range(length - len(data) - 3)]\n    return [0, 2] + pseudo_random + [0] + data\n\n\ndef encode_base_n(num, n, table=None):\n    FULL_TABLE = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    if not table:\n        table = FULL_TABLE[:n]\n\n    if n > len(table):\n        raise ValueError('base %d exceeds table length %d' % (n, len(table)))\n\n    if num == 0:\n        return table[0]\n\n    ret = ''\n    while num:\n        ret = table[num % n] + ret\n        num = num // n\n    return ret\n\n\ndef decode_packed_codes(code):\n    mobj = re.search(PACKED_CODES_RE, code)\n    obfucasted_code, base, count, symbols = mobj.groups()\n    base = int(base)\n    count = int(count)\n    symbols = symbols.split('|')\n    symbol_table = {}\n\n    while count:\n        count -= 1\n        base_n_count = encode_base_n(count, base)\n        symbol_table[base_n_count] = symbols[count] or base_n_count\n\n    return re.sub(\n        r'\\b(\\w+)\\b', lambda mobj: symbol_table[mobj.group(0)],\n        obfucasted_code)\n\n\ndef parse_m3u8_attributes(attrib):\n    info = {}\n    for (key, val) in re.findall(r'(?P<key>[A-Z0-9-]+)=(?P<val>\"[^\"]+\"|[^\",]+)(?:,|$)', attrib):\n        if val.startswith('\"'):\n            val = val[1:-1]\n        info[key] = val\n    return info\n\n\ndef urshift(val, n):\n    return val >> n if val >= 0 else (val + 0x100000000) >> n\n\n\n# Based on png2str() written by @gdkchan and improved by @yokrysty\n# Originally posted at https://github.com/rg3/youtube-dl/issues/9706\ndef decode_png(png_data):\n    # Reference: https://www.w3.org/TR/PNG/\n    header = png_data[8:]\n\n    if png_data[:8] != b'\\x89PNG\\x0d\\x0a\\x1a\\x0a' or header[4:8] != b'IHDR':\n        raise IOError('Not a valid PNG file.')\n\n    int_map = {1: '>B', 2: '>H', 4: '>I'}\n    unpack_integer = lambda x: compat_struct_unpack(int_map[len(x)], x)[0]\n\n    chunks = []\n\n    while header:\n        length = unpack_integer(header[:4])\n        header = header[4:]\n\n        chunk_type = header[:4]\n        header = header[4:]\n\n        chunk_data = header[:length]\n        header = header[length:]\n\n        header = header[4:]  # Skip CRC\n\n        chunks.append({\n            'type': chunk_type,\n            'length': length,\n            'data': chunk_data\n        })\n\n    ihdr = chunks[0]['data']\n\n    width = unpack_integer(ihdr[:4])\n    height = unpack_integer(ihdr[4:8])\n\n    idat = b''\n\n    for chunk in chunks:\n        if chunk['type'] == b'IDAT':\n            idat += chunk['data']\n\n    if not idat:\n        raise IOError('Unable to read PNG data.')\n\n    decompressed_data = bytearray(zlib.decompress(idat))\n\n    stride = width * 3\n    pixels = []\n\n    def _get_pixel(idx):\n        x = idx % stride\n        y = idx // stride\n        return pixels[y][x]\n\n    for y in range(height):\n        basePos = y * (1 + stride)\n        filter_type = decompressed_data[basePos]\n\n        current_row = []\n\n        pixels.append(current_row)\n\n        for x in range(stride):\n            color = decompressed_data[1 + basePos + x]\n            basex = y * stride + x\n            left = 0\n            up = 0\n\n            if x > 2:\n                left = _get_pixel(basex - 3)\n            if y > 0:\n                up = _get_pixel(basex - stride)\n\n            if filter_type == 1:  # Sub\n                color = (color + left) & 0xff\n            elif filter_type == 2:  # Up\n                color = (color + up) & 0xff\n            elif filter_type == 3:  # Average\n                color = (color + ((left + up) >> 1)) & 0xff\n            elif filter_type == 4:  # Paeth\n                a = left\n                b = up\n                c = 0\n\n                if x > 2 and y > 0:\n                    c = _get_pixel(basex - stride - 3)\n\n                p = a + b - c\n\n                pa = abs(p - a)\n                pb = abs(p - b)\n                pc = abs(p - c)\n\n                if pa <= pb and pa <= pc:\n                    color = (color + a) & 0xff\n                elif pb <= pc:\n                    color = (color + b) & 0xff\n                else:\n                    color = (color + c) & 0xff\n\n            current_row.append(color)\n\n    return width, height, pixels\n\n\ndef write_xattr(path, key, value):\n    # This mess below finds the best xattr tool for the job\n    try:\n        # try the pyxattr module...\n        import xattr\n\n        if hasattr(xattr, 'set'):  # pyxattr\n            # Unicode arguments are not supported in python-pyxattr until\n            # version 0.5.0\n            # See https://github.com/rg3/youtube-dl/issues/5498\n            pyxattr_required_version = '0.5.0'\n            if version_tuple(xattr.__version__) < version_tuple(pyxattr_required_version):\n                # TODO: fallback to CLI tools\n                raise XAttrUnavailableError(\n                    'python-pyxattr is detected but is too old. '\n                    'youtube-dl requires %s or above while your version is %s. '\n                    'Falling back to other xattr implementations' % (\n                        pyxattr_required_version, xattr.__version__))\n\n            setxattr = xattr.set\n        else:  # xattr\n            setxattr = xattr.setxattr\n\n        try:\n            setxattr(path, key, value)\n        except EnvironmentError as e:\n            raise XAttrMetadataError(e.errno, e.strerror)\n\n    except ImportError:\n        if compat_os_name == 'nt':\n            # Write xattrs to NTFS Alternate Data Streams:\n            # http://en.wikipedia.org/wiki/NTFS#Alternate_data_streams_.28ADS.29\n            assert ':' not in key\n            assert os.path.exists(path)\n\n            ads_fn = path + ':' + key\n            try:\n                with open(ads_fn, 'wb') as f:\n                    f.write(value)\n            except EnvironmentError as e:\n                raise XAttrMetadataError(e.errno, e.strerror)\n        else:\n            user_has_setfattr = check_executable('setfattr', ['--version'])\n            user_has_xattr = check_executable('xattr', ['-h'])\n\n            if user_has_setfattr or user_has_xattr:\n\n                value = value.decode('utf-8')\n                if user_has_setfattr:\n                    executable = 'setfattr'\n                    opts = ['-n', key, '-v', value]\n                elif user_has_xattr:\n                    executable = 'xattr'\n                    opts = ['-w', key, value]\n\n                cmd = ([encodeFilename(executable, True)] +\n                       [encodeArgument(o) for o in opts] +\n                       [encodeFilename(path, True)])\n\n                try:\n                    p = subprocess.Popen(\n                        cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n                except EnvironmentError as e:\n                    raise XAttrMetadataError(e.errno, e.strerror)\n                stdout, stderr = p.communicate()\n                stderr = stderr.decode('utf-8', 'replace')\n                if p.returncode != 0:\n                    raise XAttrMetadataError(p.returncode, stderr)\n\n            else:\n                # On Unix, and can't find pyxattr, setfattr, or xattr.\n                if sys.platform.startswith('linux'):\n                    raise XAttrUnavailableError(\n                        \"Couldn't find a tool to set the xattrs. \"\n                        \"Install either the python 'pyxattr' or 'xattr' \"\n                        \"modules, or the GNU 'attr' package \"\n                        \"(which contains the 'setfattr' tool).\")\n                else:\n                    raise XAttrUnavailableError(\n                        \"Couldn't find a tool to set the xattrs. \"\n                        \"Install either the python 'xattr' module, \"\n                        \"or the 'xattr' binary.\")\n\n\ndef random_birthday(year_field, month_field, day_field):\n    return {\n        year_field: str(random.randint(1950, 1995)),\n        month_field: str(random.randint(1, 12)),\n        day_field: str(random.randint(1, 31)),\n    }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "utils.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/utils.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}