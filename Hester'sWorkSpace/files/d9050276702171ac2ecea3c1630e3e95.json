{"author": "lra", "code": "import os\nimport tempfile\nimport unittest\nimport stat\n\n\n\nfrom mackup import utils\n\n\ndef convert_to_octal(file_name):\n    \"\"\"\n    Using os.stat, returns file permissions (read, write, execute) as an octal.\n    \"\"\"\n    return oct(os.stat(file_name)[stat.ST_MODE])[-3:]\n\n\nclass TestMackup(unittest.TestCase):\n\n    def test_confirm_yes(self):\n        \n        def custom_raw_input(_):\n            return 'Yes'\n        utils.raw_input = custom_raw_input\n        assert utils.confirm('Answer Yes to this question')\n\n    def test_confirm_no(self):\n        \n        def custom_raw_input(_):\n            return 'No'\n        utils.raw_input = custom_raw_input\n        assert not utils.confirm('Answer No to this question')\n\n    def test_confirm_python3(self):\n        \n        def custom_raw_input(_):\n            raise NameError\n        \n        utils.raw_input = custom_raw_input\n\n    def test_confirm_typo(self):\n        \n        def custom_raw_input(_):\n            return 'No'\n        utils.raw_input = custom_raw_input\n        assert not utils.confirm('Answer garbage to this question')\n\n    def test_delete_file(self):\n        \n        tfile = tempfile.NamedTemporaryFile(delete=False)\n        tfpath = tfile.name\n        tfile.close()\n\n        \n        assert os.path.isfile(tfpath)\n\n        \n        utils.delete(tfpath)\n        assert not os.path.exists(tfpath)\n\n    def test_delete_folder_recursively(self):\n        \n        tfpath = tempfile.mkdtemp()\n\n        \n        tfile = tempfile.NamedTemporaryFile(dir=tfpath, delete=False)\n        filepath = tfile.name\n        tfile.close()\n\n        \n        subfolder_path = tempfile.mkdtemp(dir=tfpath)\n\n        \n        tfile = tempfile.NamedTemporaryFile(dir=subfolder_path, delete=False)\n        subfilepath = tfile.name\n        tfile.close()\n\n        \n        assert os.path.isdir(tfpath)\n        assert os.path.isfile(filepath)\n        assert os.path.isdir(subfolder_path)\n        assert os.path.isfile(subfilepath)\n\n        \n        utils.delete(tfpath)\n        assert not os.path.exists(tfpath)\n        assert not os.path.exists(filepath)\n        assert not os.path.exists(subfolder_path)\n        assert not os.path.exists(subfilepath)\n\n    def test_copy_file(self):\n        \n        tfile = tempfile.NamedTemporaryFile(delete=False)\n        srcfile = tfile.name\n        tfile.close()\n\n        \n        dstpath = tempfile.mkdtemp()\n        \n        dstfile = os.path.join(dstpath, \"subfolder\", os.path.basename(srcfile))\n\n        \n        \n        assert os.path.isfile(srcfile)\n        assert os.path.isdir(dstpath)\n        assert not os.path.exists(dstfile)\n\n        \n        utils.copy(srcfile, dstfile)\n        assert os.path.isfile(srcfile)\n        assert os.path.isdir(dstpath)\n        assert os.path.exists(dstfile)\n\n        \n        utils.delete(dstpath)\n\n    def test_copy_fail(self):\n        \n        tfile = tempfile.NamedTemporaryFile()\n        srcfile = tfile.name\n        tfile.close()\n        os.mkfifo(srcfile)\n\n        \n        dstpath = tempfile.mkdtemp()\n        \n        dstfile = os.path.join(dstpath, \"subfolder\", os.path.basename(srcfile))\n\n        \n        \n        assert not os.path.isfile(srcfile)\n        assert stat.S_ISFIFO(os.stat(srcfile).st_mode)\n        assert os.path.isdir(dstpath)\n        assert not os.path.exists(dstfile)\n\n        \n        self.assertRaises(ValueError, utils.copy, srcfile, dstfile)\n        assert not os.path.isfile(srcfile)\n        assert stat.S_ISFIFO(os.stat(srcfile).st_mode)\n        assert os.path.isdir(dstpath)\n        assert not os.path.exists(dstfile)\n\n        \n        utils.delete(srcfile)\n        utils.delete(dstpath)\n\n    def test_copy_file_to_dir(self):\n        \"\"\"Copies a file to a destination folder that already exists.\"\"\"\n        \n        srcpath = tempfile.mkdtemp()\n\n        \n        tfile = tempfile.NamedTemporaryFile(delete=False, dir=srcpath)\n        srcfile = tfile.name\n        tfile.close()\n\n        \n        dstpath = tempfile.mkdtemp()\n\n        \n        srcpath_basename = os.path.basename(srcpath)\n        dstfile = os.path.join(dstpath,\n                               'subfolder',\n                               srcpath_basename,\n                               os.path.basename(srcfile))\n        \n        \n        assert os.path.isdir(srcpath)\n        assert os.path.isfile(srcfile)\n        assert os.path.isdir(dstpath)\n        assert not os.path.exists(dstfile)\n\n        \n        utils.copy(srcfile, dstfile)\n        assert os.path.isdir(srcpath)\n        assert os.path.isfile(srcfile)\n        assert os.path.isdir(dstpath)\n        assert os.path.exists(dstfile)\n\n        \n        utils.delete(srcpath)\n        utils.delete(dstpath)\n\n    def test_copy_dir(self):\n        \"\"\"Copies a directory recursively to the destination path.\"\"\"\n        \n        srcpath = tempfile.mkdtemp()\n\n        \n        tfile = tempfile.NamedTemporaryFile(delete=False, dir=srcpath)\n        srcfile = tfile.name\n        tfile.close()\n\n        \n        dstpath = tempfile.mkdtemp()\n\n        \n        srcpath_basename = os.path.basename(srcpath)\n        dstfile = os.path.join(dstpath,\n                               srcpath_basename,\n                               os.path.basename(srcfile))\n        \n        \n        assert os.path.isdir(srcpath)\n        assert os.path.isfile(srcfile)\n        assert os.path.isdir(dstpath)\n        assert not os.path.exists(dstfile)\n\n        \n        utils.copy(srcpath, dstfile)\n        assert os.path.isdir(srcpath)\n        assert os.path.isfile(srcfile)\n        assert os.path.isdir(dstpath)\n        assert os.path.exists(dstfile)\n\n        \n        utils.delete(srcpath)\n        utils.delete(dstpath)\n\n    def test_link_file(self):\n        \n        tfile = tempfile.NamedTemporaryFile(delete=False)\n        srcfile = tfile.name\n        tfile.close()\n\n        \n        dstpath = tempfile.mkdtemp()\n        \n        dstfile = os.path.join(dstpath, \"subfolder\", os.path.basename(srcfile))\n\n        \n        \n        assert os.path.isfile(srcfile)\n        assert os.path.isdir(dstpath)\n        assert not os.path.exists(dstfile)\n\n        \n        utils.link(srcfile, dstfile)\n        assert os.path.isfile(srcfile)\n        assert os.path.isdir(dstpath)\n        assert os.path.exists(dstfile)\n        assert os.readlink(dstfile) == srcfile\n\n        \n        utils.delete(dstpath)\n\n    def test_chmod_file(self):\n        \n        tfile = tempfile.NamedTemporaryFile(delete=False)\n        file_name = tfile.name\n\n        \n        dir_name = tempfile.mkdtemp()\n        nested_dir = tempfile.mkdtemp(dir=dir_name)\n\n        \n\n        # Change the tmp file stats to S_IWRITE (200), write access only\n        os.chmod(file_name, stat.S_IWRITE)\n        assert convert_to_octal(file_name) == \"200\"\n\n        \n        \n        utils.chmod(file_name)\n        assert convert_to_octal(file_name) == \"600\"\n\n        \n\n        # Change the tmp folder stats to S_IREAD (400), read access only\n        os.chmod(dir_name, stat.S_IREAD)\n        assert convert_to_octal(dir_name) == \"400\"\n\n        \n        \n        \n        utils.chmod(dir_name)\n        assert convert_to_octal(dir_name) == \"700\"\n        assert convert_to_octal(nested_dir) == \"700\"\n\n        \n        self.assertRaises(ValueError, utils.chmod, os.devnull)\n\n    def test_error(self):\n        test_string = \"Hello World\"\n        self.assertRaises(SystemExit, utils.error, test_string)\n\n    def test_failed_backup_location(self):\n        \"\"\"\n        Tests for the error that should occur if the backup folder cannot be\n        found for Dropbox, Google, Box and Copy\n        \"\"\"\n        \n        temp_home = tempfile.mkdtemp()\n        utils.os.environ['HOME'] = temp_home\n\n        \n        assert not os.path.exists(os.path.join(temp_home, \".dropbox/host.db\"))\n        self.assertRaises(SystemExit, utils.get_dropbox_folder_location)\n\n        \n        assert not os.path.exists(os.path.join(\n            temp_home,\n            \"Library/Application Support/Google/Drive/sync_config.db\"))\n        self.assertRaises(SystemExit, utils.get_google_drive_folder_location)\n\n        \n        assert not os.path.exists(os.path.join(\n            temp_home,\n            \"Library/Application Support/Box/Box Sync/sync_root_folder.txt\"))\n        self.assertRaises(SystemExit, utils.get_box_folder_location)\n\n        \n        assert not os.path.exists(os.path.join(\n            temp_home,\n            \"Library/Application Support/Copy Agent/config.db\"))\n        self.assertRaises(SystemExit, utils.get_copy_folder_location)\n\n    def test_is_process_running(self):\n        \n        assert utils.is_process_running(\"a*\")\n        assert not utils.is_process_running(\"some imaginary process\")\n\n    def test_can_file_be_synced_on_current_platform(self):\n        \n        path = \"some/file\"\n\n        \n        utils.platform.system = lambda *args: utils.constants.PLATFORM_DARWIN\n        assert utils.can_file_be_synced_on_current_platform(path)\n\n        \n        utils.platform.system = lambda *args: utils.constants.PLATFORM_LINUX\n        assert utils.can_file_be_synced_on_current_platform(path)\n\n        \n        path = os.path.join(os.environ[\"HOME\"], \"Library/\")\n        assert not utils.can_file_be_synced_on_current_platform(path)\n", "comments": "        using os stat  returns file permissions (read  write  execute) octal              return oct(os stat(file name) stat st mode )  3     class testmackup(unittest testcase)       def test confirm yes(self)            override raw input used utils         def custom raw input( )              return  yes          utils raw input   custom raw input         assert utils confirm( answer yes question )      def test confirm no(self)            override raw input used utils         def custom raw input( )              return  no          utils raw input   custom raw input         assert utils confirm( answer no question )      def test confirm python3(self)            override raw input used utils         def custom raw input( )              raise nameerror           also override input used utils          utils raw input   custom raw input      def test confirm typo(self)            override raw input used utils         def custom raw input( )              return  no          utils raw input   custom raw input         assert utils confirm( answer garbage question )      def test delete file(self)            create tmp file         tfile   tempfile namedtemporaryfile(delete false)         tfpath   tfile name         tfile close()            make sure created file exists         assert os path isfile(tfpath)            check mackup really delete         utils delete(tfpath)         assert os path exists(tfpath)      def test delete folder recursively(self)            create tmp folder         tfpath   tempfile mkdtemp()            let put file fun         tfile   tempfile namedtemporaryfile(dir tfpath  delete false)         filepath   tfile name         tfile close()            let put another folder         subfolder path   tempfile mkdtemp(dir tfpath)            and file subfolder         tfile   tempfile namedtemporaryfile(dir subfolder path  delete false)         subfilepath   tfile name         tfile close()            make sure created files folders exists         assert os path isdir(tfpath)         assert os path isfile(filepath)         assert os path isdir(subfolder path)         assert os path isfile(subfilepath)            check mackup really delete         utils delete(tfpath)         assert os path exists(tfpath)         assert os path exists(filepath)         assert os path exists(subfolder path)         assert os path exists(subfilepath)      def test copy file(self)            create tmp file         tfile   tempfile namedtemporaryfile(delete false)         srcfile   tfile name         tfile close()            create tmp folder         dstpath   tempfile mkdtemp()           set destination filename         dstfile   os path join(dstpath   subfolder   os path basename(srcfile))            make sure source file destination folder exist           destination file yet exist         assert os path isfile(srcfile)         assert os path isdir(dstpath)         assert os path exists(dstfile)            check mackup copy         utils copy(srcfile  dstfile)         assert os path isfile(srcfile)         assert os path isdir(dstpath)         assert os path exists(dstfile)            let clean         utils delete(dstpath)      def test copy fail(self)            create tmp fifo file         tfile   tempfile namedtemporaryfile()         srcfile   tfile name         tfile close()         os mkfifo(srcfile)            create tmp folder         dstpath   tempfile mkdtemp()           set destination filename         dstfile   os path join(dstpath   subfolder   os path basename(srcfile))            make sure source file destination folder exist           destination file yet exist         assert os path isfile(srcfile)         assert stat s isfifo(os stat(srcfile) st mode)         assert os path isdir(dstpath)         assert os path exists(dstfile)            check mackup copy         self assertraises(valueerror  utils copy  srcfile  dstfile)         assert os path isfile(srcfile)         assert stat s isfifo(os stat(srcfile) st mode)         assert os path isdir(dstpath)         assert os path exists(dstfile)            let clean         utils delete(srcfile)         utils delete(dstpath)      def test copy file dir(self)             copies file destination folder already exists               create tmp folder         srcpath   tempfile mkdtemp()            create tmp file         tfile   tempfile namedtemporaryfile(delete false  dir srcpath)         srcfile   tfile name         tfile close()            create tmp folder         dstpath   tempfile mkdtemp()            set destination filename         srcpath basename   os path basename(srcpath)         dstfile   os path join(dstpath                                  subfolder                                  srcpath basename                                 os path basename(srcfile))           make sure source file destination folder exist           destination file yet exist         assert os path isdir(srcpath)         assert os path isfile(srcfile)         assert os path isdir(dstpath)         assert os path exists(dstfile)            check mackup copy         utils copy(srcfile  dstfile)         assert os path isdir(srcpath)         assert os path isfile(srcfile)         assert os path isdir(dstpath)         assert os path exists(dstfile)            let clean         utils delete(srcpath)         utils delete(dstpath)      def test copy dir(self)             copies directory recursively destination path               create tmp folder         srcpath   tempfile mkdtemp()            create tmp file         tfile   tempfile namedtemporaryfile(delete false  dir srcpath)         srcfile   tfile name         tfile close()            create tmp folder         dstpath   tempfile mkdtemp()            set destination filename         srcpath basename   os path basename(srcpath)         dstfile   os path join(dstpath                                 srcpath basename                                 os path basename(srcfile))           make sure source file destination folder exist           destination file yet exist         assert os path isdir(srcpath)         assert os path isfile(srcfile)         assert os path isdir(dstpath)         assert os path exists(dstfile)            check mackup copy         utils copy(srcpath  dstfile)         assert os path isdir(srcpath)         assert os path isfile(srcfile)         assert os path isdir(dstpath)         assert os path exists(dstfile)            let clean         utils delete(srcpath)         utils delete(dstpath)      def test link file(self)            create tmp file         tfile   tempfile namedtemporaryfile(delete false)         srcfile   tfile name         tfile close()            create tmp folder         dstpath   tempfile mkdtemp()           set destination filename         dstfile   os path join(dstpath   subfolder   os path basename(srcfile))            make sure source file destination folder exist           destination file yet exist         assert os path isfile(srcfile)         assert os path isdir(dstpath)         assert os path exists(dstfile)            check mackup link link points correct place         utils link(srcfile  dstfile)         assert os path isfile(srcfile)         assert os path isdir(dstpath)         assert os path exists(dstfile)         assert os readlink(dstfile)    srcfile            let clean         utils delete(dstpath)      def test chmod file(self)            create tmp file         tfile   tempfile namedtemporaryfile(delete false)         file name   tfile name            create tmp directory sub folder         dir name   tempfile mkdtemp()         nested dir   tempfile mkdtemp(dir dir name)              file tests            change tmp file stats s iwrite (200)  write access         os chmod(file name  stat s iwrite)         assert convert octal(file name)     200             check make sure utils chmod changes bits 600            read write access owner         utils chmod(file name)         assert convert octal(file name)     600               directory tests            change tmp folder stats s iread (400)  read access         os chmod(dir name  stat s iread)         assert convert octal(dir name)     400             check make sure utils chmod changes bits           directories 700  read  write  execute access           owner         utils chmod(dir name)         assert convert octal(dir name)     700          assert convert octal(nested dir)     700             use  unsupported file type   in case   dev null         self assertraises(valueerror  utils chmod  os devnull)      def test error(self)          test string    hello world          self assertraises(systemexit  utils error  test string)      def test failed backup location(self)                      tests error occur backup folder cannot         found dropbox  google  box copy                unittest mock import patch    override raw input used utils    override raw input used utils    override raw input used utils    also override input used utils     override raw input used utils    create tmp file    make sure created file exists    check mackup really delete    create tmp folder    let put file fun    let put another folder    and file subfolder    make sure created files folders exists    check mackup really delete    create tmp file    create tmp folder    set destination filename    make sure source file destination folder exist    destination file yet exist    check mackup copy    let clean    create tmp fifo file    create tmp folder    set destination filename    make sure source file destination folder exist    destination file yet exist    check mackup copy    let clean    create tmp folder    create tmp file    create tmp folder    set destination filename    make sure source file destination folder exist    destination file yet exist    check mackup copy    let clean    create tmp folder    create tmp file    create tmp folder    set destination filename    make sure source file destination folder exist    destination file yet exist    check mackup copy    let clean    create tmp file    create tmp folder    set destination filename    make sure source file destination folder exist    destination file yet exist    check mackup link link points correct place    let clean    create tmp file    create tmp directory sub folder      file tests    change tmp file stats s iwrite (200)  write access    check make sure utils chmod changes bits 600     read write access owner      directory tests    change tmp folder stats s iread (400)  read access    check make sure utils chmod changes bits    directories 700  read  write  execute access    owner    use  unsupported file type   in case   dev null    hack make home folder temporary folder    check missing dropbox folder    check missing google drive folder    check missing box folder    check missing copy folder    a pgrep one letter wildcard always return id 1    any file path  even exist    force mac osx test using lambda magic    force linux test using lambda magic    try use library path linux  work ", "content": "import os\nimport tempfile\nimport unittest\nimport stat\n\n# from unittest.mock import patch\n\nfrom mackup import utils\n\n\ndef convert_to_octal(file_name):\n    \"\"\"\n    Using os.stat, returns file permissions (read, write, execute) as an octal.\n    \"\"\"\n    return oct(os.stat(file_name)[stat.ST_MODE])[-3:]\n\n\nclass TestMackup(unittest.TestCase):\n\n    def test_confirm_yes(self):\n        # Override the raw_input used in utils\n        def custom_raw_input(_):\n            return 'Yes'\n        utils.raw_input = custom_raw_input\n        assert utils.confirm('Answer Yes to this question')\n\n    def test_confirm_no(self):\n        # Override the raw_input used in utils\n        def custom_raw_input(_):\n            return 'No'\n        utils.raw_input = custom_raw_input\n        assert not utils.confirm('Answer No to this question')\n\n    def test_confirm_python3(self):\n        # Override the raw_input used in utils\n        def custom_raw_input(_):\n            raise NameError\n        # Also override input used in utils, because\n        utils.raw_input = custom_raw_input\n\n    def test_confirm_typo(self):\n        # Override the raw_input used in utils\n        def custom_raw_input(_):\n            return 'No'\n        utils.raw_input = custom_raw_input\n        assert not utils.confirm('Answer garbage to this question')\n\n    def test_delete_file(self):\n        # Create a tmp file\n        tfile = tempfile.NamedTemporaryFile(delete=False)\n        tfpath = tfile.name\n        tfile.close()\n\n        # Make sure the created file exists\n        assert os.path.isfile(tfpath)\n\n        # Check if mackup can really delete it\n        utils.delete(tfpath)\n        assert not os.path.exists(tfpath)\n\n    def test_delete_folder_recursively(self):\n        # Create a tmp folder\n        tfpath = tempfile.mkdtemp()\n\n        # Let's put a file in it just for fun\n        tfile = tempfile.NamedTemporaryFile(dir=tfpath, delete=False)\n        filepath = tfile.name\n        tfile.close()\n\n        # Let's put another folder in it\n        subfolder_path = tempfile.mkdtemp(dir=tfpath)\n\n        # And a file in the subfolder\n        tfile = tempfile.NamedTemporaryFile(dir=subfolder_path, delete=False)\n        subfilepath = tfile.name\n        tfile.close()\n\n        # Make sure the created files and folders exists\n        assert os.path.isdir(tfpath)\n        assert os.path.isfile(filepath)\n        assert os.path.isdir(subfolder_path)\n        assert os.path.isfile(subfilepath)\n\n        # Check if mackup can really delete it\n        utils.delete(tfpath)\n        assert not os.path.exists(tfpath)\n        assert not os.path.exists(filepath)\n        assert not os.path.exists(subfolder_path)\n        assert not os.path.exists(subfilepath)\n\n    def test_copy_file(self):\n        # Create a tmp file\n        tfile = tempfile.NamedTemporaryFile(delete=False)\n        srcfile = tfile.name\n        tfile.close()\n\n        # Create a tmp folder\n        dstpath = tempfile.mkdtemp()\n        # Set the destination filename\n        dstfile = os.path.join(dstpath, \"subfolder\", os.path.basename(srcfile))\n\n        # Make sure the source file and destination folder exist and the\n        # destination file doesn't yet exist\n        assert os.path.isfile(srcfile)\n        assert os.path.isdir(dstpath)\n        assert not os.path.exists(dstfile)\n\n        # Check if mackup can copy it\n        utils.copy(srcfile, dstfile)\n        assert os.path.isfile(srcfile)\n        assert os.path.isdir(dstpath)\n        assert os.path.exists(dstfile)\n\n        # Let's clean up\n        utils.delete(dstpath)\n\n    def test_copy_fail(self):\n        # Create a tmp FIFO file\n        tfile = tempfile.NamedTemporaryFile()\n        srcfile = tfile.name\n        tfile.close()\n        os.mkfifo(srcfile)\n\n        # Create a tmp folder\n        dstpath = tempfile.mkdtemp()\n        # Set the destination filename\n        dstfile = os.path.join(dstpath, \"subfolder\", os.path.basename(srcfile))\n\n        # Make sure the source file and destination folder exist and the\n        # destination file doesn't yet exist\n        assert not os.path.isfile(srcfile)\n        assert stat.S_ISFIFO(os.stat(srcfile).st_mode)\n        assert os.path.isdir(dstpath)\n        assert not os.path.exists(dstfile)\n\n        # Check if mackup can copy it\n        self.assertRaises(ValueError, utils.copy, srcfile, dstfile)\n        assert not os.path.isfile(srcfile)\n        assert stat.S_ISFIFO(os.stat(srcfile).st_mode)\n        assert os.path.isdir(dstpath)\n        assert not os.path.exists(dstfile)\n\n        # Let's clean up\n        utils.delete(srcfile)\n        utils.delete(dstpath)\n\n    def test_copy_file_to_dir(self):\n        \"\"\"Copies a file to a destination folder that already exists.\"\"\"\n        # Create a tmp folder\n        srcpath = tempfile.mkdtemp()\n\n        # Create a tmp file\n        tfile = tempfile.NamedTemporaryFile(delete=False, dir=srcpath)\n        srcfile = tfile.name\n        tfile.close()\n\n        # Create a tmp folder\n        dstpath = tempfile.mkdtemp()\n\n        # Set the destination filename\n        srcpath_basename = os.path.basename(srcpath)\n        dstfile = os.path.join(dstpath,\n                               'subfolder',\n                               srcpath_basename,\n                               os.path.basename(srcfile))\n        # Make sure the source file and destination folder exist and the\n        # destination file doesn't yet exist\n        assert os.path.isdir(srcpath)\n        assert os.path.isfile(srcfile)\n        assert os.path.isdir(dstpath)\n        assert not os.path.exists(dstfile)\n\n        # Check if mackup can copy it\n        utils.copy(srcfile, dstfile)\n        assert os.path.isdir(srcpath)\n        assert os.path.isfile(srcfile)\n        assert os.path.isdir(dstpath)\n        assert os.path.exists(dstfile)\n\n        # Let's clean up\n        utils.delete(srcpath)\n        utils.delete(dstpath)\n\n    def test_copy_dir(self):\n        \"\"\"Copies a directory recursively to the destination path.\"\"\"\n        # Create a tmp folder\n        srcpath = tempfile.mkdtemp()\n\n        # Create a tmp file\n        tfile = tempfile.NamedTemporaryFile(delete=False, dir=srcpath)\n        srcfile = tfile.name\n        tfile.close()\n\n        # Create a tmp folder\n        dstpath = tempfile.mkdtemp()\n\n        # Set the destination filename\n        srcpath_basename = os.path.basename(srcpath)\n        dstfile = os.path.join(dstpath,\n                               srcpath_basename,\n                               os.path.basename(srcfile))\n        # Make sure the source file and destination folder exist and the\n        # destination file doesn't yet exist\n        assert os.path.isdir(srcpath)\n        assert os.path.isfile(srcfile)\n        assert os.path.isdir(dstpath)\n        assert not os.path.exists(dstfile)\n\n        # Check if mackup can copy it\n        utils.copy(srcpath, dstfile)\n        assert os.path.isdir(srcpath)\n        assert os.path.isfile(srcfile)\n        assert os.path.isdir(dstpath)\n        assert os.path.exists(dstfile)\n\n        # Let's clean up\n        utils.delete(srcpath)\n        utils.delete(dstpath)\n\n    def test_link_file(self):\n        # Create a tmp file\n        tfile = tempfile.NamedTemporaryFile(delete=False)\n        srcfile = tfile.name\n        tfile.close()\n\n        # Create a tmp folder\n        dstpath = tempfile.mkdtemp()\n        # Set the destination filename\n        dstfile = os.path.join(dstpath, \"subfolder\", os.path.basename(srcfile))\n\n        # Make sure the source file and destination folder exist and the\n        # destination file doesn't yet exist\n        assert os.path.isfile(srcfile)\n        assert os.path.isdir(dstpath)\n        assert not os.path.exists(dstfile)\n\n        # Check if mackup can link it and the link points to the correct place\n        utils.link(srcfile, dstfile)\n        assert os.path.isfile(srcfile)\n        assert os.path.isdir(dstpath)\n        assert os.path.exists(dstfile)\n        assert os.readlink(dstfile) == srcfile\n\n        # Let's clean up\n        utils.delete(dstpath)\n\n    def test_chmod_file(self):\n        # Create a tmp file\n        tfile = tempfile.NamedTemporaryFile(delete=False)\n        file_name = tfile.name\n\n        # Create a tmp directory with a sub folder\n        dir_name = tempfile.mkdtemp()\n        nested_dir = tempfile.mkdtemp(dir=dir_name)\n\n        # # File Tests\n\n        # Change the tmp file stats to S_IWRITE (200), write access only\n        os.chmod(file_name, stat.S_IWRITE)\n        assert convert_to_octal(file_name) == \"200\"\n\n        # Check to make sure that utils.chmod changes the bits to 600,\n        # which is read and write access for the owner\n        utils.chmod(file_name)\n        assert convert_to_octal(file_name) == \"600\"\n\n        # # Directory Tests\n\n        # Change the tmp folder stats to S_IREAD (400), read access only\n        os.chmod(dir_name, stat.S_IREAD)\n        assert convert_to_octal(dir_name) == \"400\"\n\n        # Check to make sure that utils.chmod changes the bits of all\n        # directories to 700, which is read, write, and execute access for the\n        # owner\n        utils.chmod(dir_name)\n        assert convert_to_octal(dir_name) == \"700\"\n        assert convert_to_octal(nested_dir) == \"700\"\n\n        # Use an \"unsupported file type\". In this case, /dev/null\n        self.assertRaises(ValueError, utils.chmod, os.devnull)\n\n    def test_error(self):\n        test_string = \"Hello World\"\n        self.assertRaises(SystemExit, utils.error, test_string)\n\n    def test_failed_backup_location(self):\n        \"\"\"\n        Tests for the error that should occur if the backup folder cannot be\n        found for Dropbox, Google, Box and Copy\n        \"\"\"\n        # Hack to make our home folder some temporary folder\n        temp_home = tempfile.mkdtemp()\n        utils.os.environ['HOME'] = temp_home\n\n        # Check for the missing Dropbox folder\n        assert not os.path.exists(os.path.join(temp_home, \".dropbox/host.db\"))\n        self.assertRaises(SystemExit, utils.get_dropbox_folder_location)\n\n        # Check for the missing Google Drive folder\n        assert not os.path.exists(os.path.join(\n            temp_home,\n            \"Library/Application Support/Google/Drive/sync_config.db\"))\n        self.assertRaises(SystemExit, utils.get_google_drive_folder_location)\n\n        # Check for the missing Box folder\n        assert not os.path.exists(os.path.join(\n            temp_home,\n            \"Library/Application Support/Box/Box Sync/sync_root_folder.txt\"))\n        self.assertRaises(SystemExit, utils.get_box_folder_location)\n\n        # Check for the missing Copy Folder\n        assert not os.path.exists(os.path.join(\n            temp_home,\n            \"Library/Application Support/Copy Agent/config.db\"))\n        self.assertRaises(SystemExit, utils.get_copy_folder_location)\n\n    def test_is_process_running(self):\n        # A pgrep that has one letter and a wildcard will always return id 1\n        assert utils.is_process_running(\"a*\")\n        assert not utils.is_process_running(\"some imaginary process\")\n\n    def test_can_file_be_synced_on_current_platform(self):\n        # Any file path will do, even if it doesn't exist\n        path = \"some/file\"\n\n        # Force the Mac OSX Test using lambda magic\n        utils.platform.system = lambda *args: utils.constants.PLATFORM_DARWIN\n        assert utils.can_file_be_synced_on_current_platform(path)\n\n        # Force the Linux Test using lambda magic\n        utils.platform.system = lambda *args: utils.constants.PLATFORM_LINUX\n        assert utils.can_file_be_synced_on_current_platform(path)\n\n        # Try to use the library path on Linux, which shouldn't work\n        path = os.path.join(os.environ[\"HOME\"], \"Library/\")\n        assert not utils.can_file_be_synced_on_current_platform(path)\n", "description": "Keep your application settings in sync (OS X/Linux)", "file_name": "utils_test.py", "id": "d9050276702171ac2ecea3c1630e3e95", "language": "Python", "project_name": "mackup", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/lra-mackup/lra-mackup-5609f25/tests/utils_test.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:12Z", "url": "https://github.com/lra/mackup", "wiki": false}