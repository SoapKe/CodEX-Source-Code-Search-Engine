{"author": "python", "code": "'''\nProcesses a CSV file containing a list of files into a WXS file with\ncomponents for each listed file.\n\nThe CSV columns are:\n    source of file, target for file, group name\n\nUsage::\n    py txt_to_wxs.py [path to file list .csv] [path to destination .wxs]\n\nThis is necessary to handle structures where some directories only\ncontain other directories. MSBuild is not able to generate the\nDirectory entries in the WXS file correctly, as it operates on files.\nPython, however, can easily fill in the gap.\n'''\n\n__author__ = \"Steve Dower <steve.dower@microsoft.com>\"\n\nimport csv\nimport re\nimport sys\n\nfrom collections import defaultdict\nfrom itertools import chain, zip_longest\nfrom pathlib import PureWindowsPath\nfrom uuid import uuid1\n\nID_CHAR_SUBS = {\n    '-': '_',\n    '+': '_P',\n}\n\ndef make_id(path):\n    return re.sub(\n        r'[^A-Za-z0-9_.]',\n        lambda m: ID_CHAR_SUBS.get(m.group(0), '_'),\n        str(path).rstrip('/\\\\'),\n        flags=re.I\n    )\n\nDIRECTORIES = set()\n\ndef main(file_source, install_target):\n    with open(file_source, 'r', newline='') as f:\n        files = list(csv.reader(f))\n\n    assert len(files) == len(set(make_id(f[1]) for f in files)), \"Duplicate file IDs exist\"\n\n    directories = defaultdict(set)\n    cache_directories = defaultdict(set)\n    groups = defaultdict(list)\n    for source, target, group, disk_id, condition in files:\n        target = PureWindowsPath(target)\n        groups[group].append((source, target, disk_id, condition))\n\n        if target.suffix.lower() in {\".py\", \".pyw\"}:\n            cache_directories[group].add(target.parent)\n\n        for dirname in target.parents:\n            parent = make_id(dirname.parent)\n            if parent and parent != '.':\n                directories[parent].add(dirname.name)\n\n    lines = [\n        '<Wix xmlns=\"http://schemas.microsoft.com/wix/2006/wi\">',\n        '    <Fragment>',\n    ]\n    for dir_parent in sorted(directories):\n        lines.append('        <DirectoryRef Id=\"{}\">'.format(dir_parent))\n        for dir_name in sorted(directories[dir_parent]):\n            lines.append('            <Directory Id=\"{}_{}\" Name=\"{}\" />'.format(dir_parent, make_id(dir_name), dir_name))\n        lines.append('        </DirectoryRef>')\n    for dir_parent in (make_id(d) for group in cache_directories.values() for d in group):\n        lines.append('        <DirectoryRef Id=\"{}\">'.format(dir_parent))\n        lines.append('            <Directory Id=\"{}___pycache__\" Name=\"__pycache__\" />'.format(dir_parent))\n        lines.append('        </DirectoryRef>')\n    lines.append('    </Fragment>')\n\n    for group in sorted(groups):\n        lines.extend([\n            '    <Fragment>',\n            '        <ComponentGroup Id=\"{}\">'.format(group),\n        ])\n        for source, target, disk_id, condition in groups[group]:\n            lines.append('            <Component Id=\"{}\" Directory=\"{}\" Guid=\"*\">'.format(make_id(target), make_id(target.parent)))\n            if condition:\n                lines.append('                <Condition>{}</Condition>'.format(condition))\n\n            if disk_id:\n                lines.append('                <File Id=\"{}\" Name=\"{}\" Source=\"{}\" DiskId=\"{}\" />'.format(make_id(target), target.name, source, disk_id))\n            else:\n                lines.append('                <File Id=\"{}\" Name=\"{}\" Source=\"{}\" />'.format(make_id(target), target.name, source))\n            lines.append('            </Component>')\n\n        create_folders = {make_id(p) + \"___pycache__\" for p in cache_directories[group]}\n        remove_folders = {make_id(p2) for p1 in cache_directories[group] for p2 in chain((p1,), p1.parents)}\n        create_folders.discard(\".\")\n        remove_folders.discard(\".\")\n        if create_folders or remove_folders:\n            lines.append('            <Component Id=\"{}__pycache__folders\" Directory=\"TARGETDIR\" Guid=\"{}\">'.format(group, uuid1()))\n            lines.extend('                <CreateFolder Directory=\"{}\" />'.format(p) for p in create_folders)\n            lines.extend('                <RemoveFile Id=\"Remove_{0}_files\" Name=\"*\" On=\"uninstall\" Directory=\"{0}\" />'.format(p) for p in create_folders)\n            lines.extend('                <RemoveFolder Id=\"Remove_{0}_folder\" On=\"uninstall\" Directory=\"{0}\" />'.format(p) for p in create_folders | remove_folders)\n            lines.append('            </Component>')\n\n        lines.extend([\n            '        </ComponentGroup>',\n            '    </Fragment>',\n        ])\n    lines.append('</Wix>')\n\n    \n    \n    try:\n        with open(install_target, 'r') as f:\n            if all(x.rstrip('\\r\\n') == y for x, y in zip_longest(f, lines)):\n                print('File is up to date')\n                return\n    except IOError:\n        pass\n\n    with open(install_target, 'w') as f:\n        f.writelines(line + '\\n' for line in lines)\n    print('Wrote {} lines to {}'.format(len(lines), install_target))\n\nif __name__ == '__main__':\n    main(sys.argv[1], sys.argv[2])\n", "comments": "    processes csv file containing list files wxs file components listed file   the csv columns      source file  target file  group name  usage       py txt wxs py  path file list  csv   path destination  wxs   this necessary handle structures directories contain directories  msbuild able generate directory entries wxs file correctly  operates files  python  however  easily fill gap         check file matches  if  want touch    skip rebuilding  ", "content": "'''\nProcesses a CSV file containing a list of files into a WXS file with\ncomponents for each listed file.\n\nThe CSV columns are:\n    source of file, target for file, group name\n\nUsage::\n    py txt_to_wxs.py [path to file list .csv] [path to destination .wxs]\n\nThis is necessary to handle structures where some directories only\ncontain other directories. MSBuild is not able to generate the\nDirectory entries in the WXS file correctly, as it operates on files.\nPython, however, can easily fill in the gap.\n'''\n\n__author__ = \"Steve Dower <steve.dower@microsoft.com>\"\n\nimport csv\nimport re\nimport sys\n\nfrom collections import defaultdict\nfrom itertools import chain, zip_longest\nfrom pathlib import PureWindowsPath\nfrom uuid import uuid1\n\nID_CHAR_SUBS = {\n    '-': '_',\n    '+': '_P',\n}\n\ndef make_id(path):\n    return re.sub(\n        r'[^A-Za-z0-9_.]',\n        lambda m: ID_CHAR_SUBS.get(m.group(0), '_'),\n        str(path).rstrip('/\\\\'),\n        flags=re.I\n    )\n\nDIRECTORIES = set()\n\ndef main(file_source, install_target):\n    with open(file_source, 'r', newline='') as f:\n        files = list(csv.reader(f))\n\n    assert len(files) == len(set(make_id(f[1]) for f in files)), \"Duplicate file IDs exist\"\n\n    directories = defaultdict(set)\n    cache_directories = defaultdict(set)\n    groups = defaultdict(list)\n    for source, target, group, disk_id, condition in files:\n        target = PureWindowsPath(target)\n        groups[group].append((source, target, disk_id, condition))\n\n        if target.suffix.lower() in {\".py\", \".pyw\"}:\n            cache_directories[group].add(target.parent)\n\n        for dirname in target.parents:\n            parent = make_id(dirname.parent)\n            if parent and parent != '.':\n                directories[parent].add(dirname.name)\n\n    lines = [\n        '<Wix xmlns=\"http://schemas.microsoft.com/wix/2006/wi\">',\n        '    <Fragment>',\n    ]\n    for dir_parent in sorted(directories):\n        lines.append('        <DirectoryRef Id=\"{}\">'.format(dir_parent))\n        for dir_name in sorted(directories[dir_parent]):\n            lines.append('            <Directory Id=\"{}_{}\" Name=\"{}\" />'.format(dir_parent, make_id(dir_name), dir_name))\n        lines.append('        </DirectoryRef>')\n    for dir_parent in (make_id(d) for group in cache_directories.values() for d in group):\n        lines.append('        <DirectoryRef Id=\"{}\">'.format(dir_parent))\n        lines.append('            <Directory Id=\"{}___pycache__\" Name=\"__pycache__\" />'.format(dir_parent))\n        lines.append('        </DirectoryRef>')\n    lines.append('    </Fragment>')\n\n    for group in sorted(groups):\n        lines.extend([\n            '    <Fragment>',\n            '        <ComponentGroup Id=\"{}\">'.format(group),\n        ])\n        for source, target, disk_id, condition in groups[group]:\n            lines.append('            <Component Id=\"{}\" Directory=\"{}\" Guid=\"*\">'.format(make_id(target), make_id(target.parent)))\n            if condition:\n                lines.append('                <Condition>{}</Condition>'.format(condition))\n\n            if disk_id:\n                lines.append('                <File Id=\"{}\" Name=\"{}\" Source=\"{}\" DiskId=\"{}\" />'.format(make_id(target), target.name, source, disk_id))\n            else:\n                lines.append('                <File Id=\"{}\" Name=\"{}\" Source=\"{}\" />'.format(make_id(target), target.name, source))\n            lines.append('            </Component>')\n\n        create_folders = {make_id(p) + \"___pycache__\" for p in cache_directories[group]}\n        remove_folders = {make_id(p2) for p1 in cache_directories[group] for p2 in chain((p1,), p1.parents)}\n        create_folders.discard(\".\")\n        remove_folders.discard(\".\")\n        if create_folders or remove_folders:\n            lines.append('            <Component Id=\"{}__pycache__folders\" Directory=\"TARGETDIR\" Guid=\"{}\">'.format(group, uuid1()))\n            lines.extend('                <CreateFolder Directory=\"{}\" />'.format(p) for p in create_folders)\n            lines.extend('                <RemoveFile Id=\"Remove_{0}_files\" Name=\"*\" On=\"uninstall\" Directory=\"{0}\" />'.format(p) for p in create_folders)\n            lines.extend('                <RemoveFolder Id=\"Remove_{0}_folder\" On=\"uninstall\" Directory=\"{0}\" />'.format(p) for p in create_folders | remove_folders)\n            lines.append('            </Component>')\n\n        lines.extend([\n            '        </ComponentGroup>',\n            '    </Fragment>',\n        ])\n    lines.append('</Wix>')\n\n    # Check if the file matches. If so, we don't want to touch it so\n    # that we can skip rebuilding.\n    try:\n        with open(install_target, 'r') as f:\n            if all(x.rstrip('\\r\\n') == y for x, y in zip_longest(f, lines)):\n                print('File is up to date')\n                return\n    except IOError:\n        pass\n\n    with open(install_target, 'w') as f:\n        f.writelines(line + '\\n' for line in lines)\n    print('Wrote {} lines to {}'.format(len(lines), install_target))\n\nif __name__ == '__main__':\n    main(sys.argv[1], sys.argv[2])\n", "description": "The Python programming language", "file_name": "csv_to_wxs.py", "id": "bc5a3f40acc813b855df3717deb88f78", "language": "Python", "project_name": "cpython", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/python-cpython/python-cpython-74f5687/Tools/msi/csv_to_wxs.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:20:38Z", "url": "https://github.com/python/cpython", "wiki": false}