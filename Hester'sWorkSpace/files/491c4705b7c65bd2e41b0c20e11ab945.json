{"author": "USArmyResearchLab", "code": "import dshell\nimport dfile\nimport util\nimport hashlib\n\nfrom httpdecoder import HTTPDecoder\n\n\nclass DshellDecoder(HTTPDecoder):\n\n    def __init__(self):\n        HTTPDecoder.__init__(self,\n                             name='web',\n                             description='Improved version of web that tracks server response',\n                             filter='tcp and (port 80 or port 8080 or port 8000)',\n                             filterfn=lambda ((sip, sp), (dip, dp)): sp in (\n                                 80, 8000, 8080) or dp in (80, 8000, 8080),\n                             author='bg,twp',\n                             optiondict={\n                                 'maxurilen': {'type': 'int', 'default': 30, 'help': 'Truncate URLs longer than max len.  Set to 0 for no truncating. (default: 30)'},\n                                 'md5': {'action': 'store_true', 'help': 'calculate MD5 for each response. Available in CSV output.'}\n                             },\n                             )\n        self.gunzip = False  \n\n    def HTTPHandler(self, conn, request, response, requesttime, responsetime):\n        host = ''\n        loc = ''\n        lastmodified = ''\n\n        #request_time, request, response = self.httpDict[conn.addr]\n\n        \n        host = util.getHeader(request, 'host')\n        if host == '':\n            host = conn.serverip\n\n        try:\n            status = response.status\n        except:\n            status = ''\n        try:\n            reason = response.reason\n        except:\n            reason = ''\n\n        loc = ''\n        if status[:2] == '30':\n            loc = util.getHeader(response, 'location')\n            if len(loc):\n                loc = '-> ' + loc\n\n        lastmodified = util.HTTPlastmodified(response)\n        referer = util.getHeader(request, 'referer')\n        useragent = util.getHeader(request, 'user-agent')\n        via = util.getHeader(request, 'via')\n\n        try:\n            responsesize = len(response.body.rstrip('\\0'))\n        except:\n            responsesize = 0\n\n        if self.md5:\n            md5 = self._bodyMD5(response)\n        else:\n            md5 = ''\n\n        \n        try:\n            if len(response.body) > 0:\n                responsefile = dfile.dfile(\n                    name=request.uri, data=response.body)\n            else:\n                responsefile = ''\n        except:\n            responsefile = ''\n        if request.method == 'POST' and len(request.body):\n            ulcontenttype, ulfilename, uldata = self.POSTHandler(request.body)\n            uploadfile = dfile.dfile(name=ulfilename, data=uldata)\n        else:\n            uploadfile = None\n\n        requestInfo = '%s %s%s HTTP/%s' % (request.method,\n                                           host if host != request.uri else '',  \n                                           request.uri[:self.maxurilen] + '[truncated]' if self.maxurilen > 0 and len(\n                                               request.uri) > self.maxurilen else request.uri,\n                                           request.version)\n        if response:\n            responseInfo = '%s %s %s %s' % (status, reason, loc, lastmodified)\n        else:\n            responseInfo = ''\n\n        self.alert(\"%-80s // %s\" % (requestInfo, responseInfo), referer=referer, useragent=useragent, request=requestInfo, response=responseInfo, request_time=requesttime, response_time=responsetime, request_method=request.method, host=host,\n                   uri=request.uri, status=status, reason=reason, lastmodified=lastmodified, md5=md5, responsesize=responsesize, contenttype=util.getHeader(response, 'content-type'), responsefile=responsefile, uploadfile=uploadfile, via=via, **conn.info())\n        if self.out.sessionwriter:\n            self.write(request.data, direction='cs')\n            if response:\n                self.write(response.body, direction='sc')\n\n    # MD5sum(hex) of the body portion of the response\n    def _bodyMD5(self, response):\n        try:\n            if len(response.body) > 0:\n                return hashlib.md5(response.body.rstrip('\\0')).hexdigest()\n            else:\n                return ''\n        except:\n            return ''\n\n    def POSTHandler(self, postdata):\n        next_line_is_data = False\n        contenttype = ''\n        filename = ''\n        for l in postdata.split(\"\\r\\n\"):\n            if next_line_is_data:\n                break\n            if l == '':\n                next_line_is_data = True  # \\r\\n\\r\\n before data\n                continue\n            try:\n                k, v = self.splitstrip(l, ':')\n                if k == 'Content-Type':\n                    contenttype = v\n                if k == 'Content-Disposition':\n                    cdparts = self.splitstrip(v, ';')\n                    for cdpart in cdparts:\n                        try:\n                            k, v = self.splitstrip(cdpart, '=', '\"')\n                            if k == 'filename':\n                                filename = v\n                        except:\n                            pass\n            except:\n                pass\n        return contenttype, filename, l\n\n    def splitstrip(self, data, sep, strip=' '):\n        return [lpart.strip(strip) for lpart in data.split(sep)]\n\n\nif __name__ == '__main__':\n    dObj = DshellDecoder()\n    print dObj\nelse:\n    dObj = DshellDecoder()\n", "comments": "  not interested response body   request time  request  response   self httpdict conn addr     extract method uri host response    file objects    with connect method  uri contains host  making redudant    md5sum(hex) body portion response     r n r n data ", "content": "import dshell\nimport dfile\nimport util\nimport hashlib\n\nfrom httpdecoder import HTTPDecoder\n\n\nclass DshellDecoder(HTTPDecoder):\n\n    def __init__(self):\n        HTTPDecoder.__init__(self,\n                             name='web',\n                             description='Improved version of web that tracks server response',\n                             filter='tcp and (port 80 or port 8080 or port 8000)',\n                             filterfn=lambda ((sip, sp), (dip, dp)): sp in (\n                                 80, 8000, 8080) or dp in (80, 8000, 8080),\n                             author='bg,twp',\n                             optiondict={\n                                 'maxurilen': {'type': 'int', 'default': 30, 'help': 'Truncate URLs longer than max len.  Set to 0 for no truncating. (default: 30)'},\n                                 'md5': {'action': 'store_true', 'help': 'calculate MD5 for each response. Available in CSV output.'}\n                             },\n                             )\n        self.gunzip = False  # Not interested in response body\n\n    def HTTPHandler(self, conn, request, response, requesttime, responsetime):\n        host = ''\n        loc = ''\n        lastmodified = ''\n\n        #request_time, request, response = self.httpDict[conn.addr]\n\n        # extract method,uri,host from response\n        host = util.getHeader(request, 'host')\n        if host == '':\n            host = conn.serverip\n\n        try:\n            status = response.status\n        except:\n            status = ''\n        try:\n            reason = response.reason\n        except:\n            reason = ''\n\n        loc = ''\n        if status[:2] == '30':\n            loc = util.getHeader(response, 'location')\n            if len(loc):\n                loc = '-> ' + loc\n\n        lastmodified = util.HTTPlastmodified(response)\n        referer = util.getHeader(request, 'referer')\n        useragent = util.getHeader(request, 'user-agent')\n        via = util.getHeader(request, 'via')\n\n        try:\n            responsesize = len(response.body.rstrip('\\0'))\n        except:\n            responsesize = 0\n\n        if self.md5:\n            md5 = self._bodyMD5(response)\n        else:\n            md5 = ''\n\n        # File objects\n        try:\n            if len(response.body) > 0:\n                responsefile = dfile.dfile(\n                    name=request.uri, data=response.body)\n            else:\n                responsefile = ''\n        except:\n            responsefile = ''\n        if request.method == 'POST' and len(request.body):\n            ulcontenttype, ulfilename, uldata = self.POSTHandler(request.body)\n            uploadfile = dfile.dfile(name=ulfilename, data=uldata)\n        else:\n            uploadfile = None\n\n        requestInfo = '%s %s%s HTTP/%s' % (request.method,\n                                           host if host != request.uri else '',  # With CONNECT method, the URI is or contains the host, making this redudant\n                                           request.uri[:self.maxurilen] + '[truncated]' if self.maxurilen > 0 and len(\n                                               request.uri) > self.maxurilen else request.uri,\n                                           request.version)\n        if response:\n            responseInfo = '%s %s %s %s' % (status, reason, loc, lastmodified)\n        else:\n            responseInfo = ''\n\n        self.alert(\"%-80s // %s\" % (requestInfo, responseInfo), referer=referer, useragent=useragent, request=requestInfo, response=responseInfo, request_time=requesttime, response_time=responsetime, request_method=request.method, host=host,\n                   uri=request.uri, status=status, reason=reason, lastmodified=lastmodified, md5=md5, responsesize=responsesize, contenttype=util.getHeader(response, 'content-type'), responsefile=responsefile, uploadfile=uploadfile, via=via, **conn.info())\n        if self.out.sessionwriter:\n            self.write(request.data, direction='cs')\n            if response:\n                self.write(response.body, direction='sc')\n\n    # MD5sum(hex) of the body portion of the response\n    def _bodyMD5(self, response):\n        try:\n            if len(response.body) > 0:\n                return hashlib.md5(response.body.rstrip('\\0')).hexdigest()\n            else:\n                return ''\n        except:\n            return ''\n\n    def POSTHandler(self, postdata):\n        next_line_is_data = False\n        contenttype = ''\n        filename = ''\n        for l in postdata.split(\"\\r\\n\"):\n            if next_line_is_data:\n                break\n            if l == '':\n                next_line_is_data = True  # \\r\\n\\r\\n before data\n                continue\n            try:\n                k, v = self.splitstrip(l, ':')\n                if k == 'Content-Type':\n                    contenttype = v\n                if k == 'Content-Disposition':\n                    cdparts = self.splitstrip(v, ';')\n                    for cdpart in cdparts:\n                        try:\n                            k, v = self.splitstrip(cdpart, '=', '\"')\n                            if k == 'filename':\n                                filename = v\n                        except:\n                            pass\n            except:\n                pass\n        return contenttype, filename, l\n\n    def splitstrip(self, data, sep, strip=' '):\n        return [lpart.strip(strip) for lpart in data.split(sep)]\n\n\nif __name__ == '__main__':\n    dObj = DshellDecoder()\n    print dObj\nelse:\n    dObj = DshellDecoder()\n", "description": "Dshell is a network forensic analysis framework.", "file_name": "web.py", "id": "491c4705b7c65bd2e41b0c20e11ab945", "language": "Python", "project_name": "Dshell", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/USArmyResearchLab-Dshell/USArmyResearchLab-Dshell-5850adf/decoders/http/web.py", "save_time": "", "source": "", "update_at": "2018-03-18T10:01:29Z", "url": "https://github.com/USArmyResearchLab/Dshell", "wiki": true}