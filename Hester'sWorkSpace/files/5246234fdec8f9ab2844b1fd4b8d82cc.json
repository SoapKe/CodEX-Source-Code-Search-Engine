{"author": "rg3", "code": "from __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_HTTPError,\n    compat_str,\n    compat_urlparse,\n)\nfrom ..utils import (\n    ExtractorError,\n    js_to_json,\n    parse_duration,\n    parse_iso8601,\n)\n\n\nclass ViideaIE(InfoExtractor):\n    _VALID_URL = r\n\n    _TESTS = [{\n        'url': 'http://videolectures.net/promogram_igor_mekjavic_eng/',\n        'info_dict': {\n            'id': '20171',\n            'display_id': 'promogram_igor_mekjavic_eng',\n            'ext': 'mp4',\n            'title': 'Automatics, robotics and biocybernetics',\n            'description': 'md5:815fc1deb6b3a2bff99de2d5325be482',\n            'thumbnail': r're:http://.*\\.jpg',\n            'timestamp': 1372349289,\n            'upload_date': '20130627',\n            'duration': 565,\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }, {\n        \n        'url': 'http://videolectures.net/russir2010_filippova_nlp/',\n        'info_dict': {\n            'id': '14891',\n            'display_id': 'russir2010_filippova_nlp',\n            'ext': 'flv',\n            'title': 'NLP at Google',\n            'description': 'md5:fc7a6d9bf0302d7cc0e53f7ca23747b3',\n            'thumbnail': r're:http://.*\\.jpg',\n            'timestamp': 1284375600,\n            'upload_date': '20100913',\n            'duration': 5352,\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }, {\n        \n        'url': 'http://videolectures.net/deeplearning2015_montreal/',\n        'info_dict': {\n            'id': '23181',\n            'title': 'Deep Learning Summer School, Montreal 2015',\n            'description': 'md5:0533a85e4bd918df52a01f0e1ebe87b7',\n            'thumbnail': r're:http://.*\\.jpg',\n            'timestamp': 1438560000,\n        },\n        'playlist_count': 30,\n    }, {\n        \n        'url': 'http://videolectures.net/mlss09uk_bishop_ibi/',\n        'info_dict': {\n            'id': '9737',\n            'display_id': 'mlss09uk_bishop_ibi',\n            'title': 'Introduction To Bayesian Inference',\n            'thumbnail': r're:http://.*\\.jpg',\n            'timestamp': 1251622800,\n        },\n        'playlist': [{\n            'info_dict': {\n                'id': '9737_part1',\n                'display_id': 'mlss09uk_bishop_ibi_part1',\n                'ext': 'wmv',\n                'title': 'Introduction To Bayesian Inference (Part 1)',\n                'thumbnail': r're:http://.*\\.jpg',\n                'duration': 4622,\n                'timestamp': 1251622800,\n                'upload_date': '20090830',\n            },\n        }, {\n            'info_dict': {\n                'id': '9737_part2',\n                'display_id': 'mlss09uk_bishop_ibi_part2',\n                'ext': 'wmv',\n                'title': 'Introduction To Bayesian Inference (Part 2)',\n                'thumbnail': r're:http://.*\\.jpg',\n                'duration': 5641,\n                'timestamp': 1251622800,\n                'upload_date': '20090830',\n            },\n        }],\n        'playlist_count': 2,\n    }]\n\n    def _real_extract(self, url):\n        lecture_slug, explicit_part_id = re.match(self._VALID_URL, url).groups()\n\n        webpage = self._download_webpage(url, lecture_slug)\n\n        cfg = self._parse_json(self._search_regex(\n            [r'cfg\\s*:\\s*({.+?})\\s*,\\s*[\\da-zA-Z_]+\\s*:\\s*\\(?\\s*function',\n             r'cfg\\s*:\\s*({[^}]+})'],\n            webpage, 'cfg'), lecture_slug, js_to_json)\n\n        lecture_id = compat_str(cfg['obj_id'])\n\n        base_url = self._proto_relative_url(cfg['livepipe'], 'http:')\n\n        try:\n            lecture_data = self._download_json(\n                '%s/site/api/lecture/%s?format=json' % (base_url, lecture_id),\n                lecture_id)['lecture'][0]\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError) and e.cause.code == 403:\n                msg = self._parse_json(\n                    e.cause.read().decode('utf-8'), lecture_id)\n                raise ExtractorError(msg['detail'], expected=True)\n            raise\n\n        lecture_info = {\n            'id': lecture_id,\n            'display_id': lecture_slug,\n            'title': lecture_data['title'],\n            'timestamp': parse_iso8601(lecture_data.get('time')),\n            'description': lecture_data.get('description_wiki'),\n            'thumbnail': lecture_data.get('thumb'),\n        }\n\n        playlist_entries = []\n        lecture_type = lecture_data.get('type')\n        parts = [compat_str(video) for video in cfg.get('videos', [])]\n        if parts:\n            multipart = len(parts) > 1\n\n            def extract_part(part_id):\n                smil_url = '%s/%s/video/%s/smil.xml' % (base_url, lecture_slug, part_id)\n                smil = self._download_smil(smil_url, lecture_id)\n                info = self._parse_smil(smil, smil_url, lecture_id)\n                self._sort_formats(info['formats'])\n                info['id'] = lecture_id if not multipart else '%s_part%s' % (lecture_id, part_id)\n                info['display_id'] = lecture_slug if not multipart else '%s_part%s' % (lecture_slug, part_id)\n                if multipart:\n                    info['title'] += ' (Part %s)' % part_id\n                switch = smil.find('.//switch')\n                if switch is not None:\n                    info['duration'] = parse_duration(switch.attrib.get('dur'))\n                item_info = lecture_info.copy()\n                item_info.update(info)\n                return item_info\n\n            if explicit_part_id or not multipart:\n                result = extract_part(explicit_part_id or parts[0])\n            else:\n                result = {\n                    '_type': 'multi_video',\n                    'entries': [extract_part(part) for part in parts],\n                }\n                result.update(lecture_info)\n\n            \n            if explicit_part_id or lecture_type != 'evt':\n                return result\n\n            playlist_entries.append(result)\n\n        \n        if not parts or lecture_type == 'evt':\n            playlist_webpage = self._download_webpage(\n                '%s/site/ajax/drilldown/?id=%s' % (base_url, lecture_id), lecture_id)\n            entries = [\n                self.url_result(compat_urlparse.urljoin(url, video_url), 'Viidea')\n                for _, video_url in re.findall(\n                    r'<a[^>]+href=([\"\\'])(.+?)\\1[^>]+id=[\"\\']lec=\\d+', playlist_webpage)]\n            playlist_entries.extend(entries)\n\n        playlist = self.playlist_result(playlist_entries, lecture_id)\n        playlist.update(lecture_info)\n        return playlist\n", "comments": "(?x)https?://(?:www\\.)?(?:\n            videolectures\\.net|\n            flexilearn\\.viidea\\.net|\n            presentations\\.ocwconsortium\\.org|\n            video\\.travel-zoom\\.si|\n            video\\.pomp-forum\\.si|\n            tv\\.nil\\.si|\n            video\\.hekovnik.com|\n            video\\.szko\\.si|\n            kpk\\.viidea\\.com|\n            inside\\.viidea\\.net|\n            video\\.kiberpipa\\.org|\n            bvvideo\\.si|\n            kongres\\.viidea\\.net|\n            edemokracija\\.viidea\\.com\n        )(?:/lecture)?/(?P<id>[^/]+)(?:/video/(?P<part>\\d+))?/*(?:[#?].*)?$\n$\n# m3u8 download\n# video with invalid direct format links (HTTP 403)\n# rtmp download\n# event playlist\n# multi part lecture\n# Immediately return explicitly requested part or non event item\n# It's probably a playlist\n", "content": "from __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_HTTPError,\n    compat_str,\n    compat_urlparse,\n)\nfrom ..utils import (\n    ExtractorError,\n    js_to_json,\n    parse_duration,\n    parse_iso8601,\n)\n\n\nclass ViideaIE(InfoExtractor):\n    _VALID_URL = r'''(?x)https?://(?:www\\.)?(?:\n            videolectures\\.net|\n            flexilearn\\.viidea\\.net|\n            presentations\\.ocwconsortium\\.org|\n            video\\.travel-zoom\\.si|\n            video\\.pomp-forum\\.si|\n            tv\\.nil\\.si|\n            video\\.hekovnik.com|\n            video\\.szko\\.si|\n            kpk\\.viidea\\.com|\n            inside\\.viidea\\.net|\n            video\\.kiberpipa\\.org|\n            bvvideo\\.si|\n            kongres\\.viidea\\.net|\n            edemokracija\\.viidea\\.com\n        )(?:/lecture)?/(?P<id>[^/]+)(?:/video/(?P<part>\\d+))?/*(?:[#?].*)?$'''\n\n    _TESTS = [{\n        'url': 'http://videolectures.net/promogram_igor_mekjavic_eng/',\n        'info_dict': {\n            'id': '20171',\n            'display_id': 'promogram_igor_mekjavic_eng',\n            'ext': 'mp4',\n            'title': 'Automatics, robotics and biocybernetics',\n            'description': 'md5:815fc1deb6b3a2bff99de2d5325be482',\n            'thumbnail': r're:http://.*\\.jpg',\n            'timestamp': 1372349289,\n            'upload_date': '20130627',\n            'duration': 565,\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n    }, {\n        # video with invalid direct format links (HTTP 403)\n        'url': 'http://videolectures.net/russir2010_filippova_nlp/',\n        'info_dict': {\n            'id': '14891',\n            'display_id': 'russir2010_filippova_nlp',\n            'ext': 'flv',\n            'title': 'NLP at Google',\n            'description': 'md5:fc7a6d9bf0302d7cc0e53f7ca23747b3',\n            'thumbnail': r're:http://.*\\.jpg',\n            'timestamp': 1284375600,\n            'upload_date': '20100913',\n            'duration': 5352,\n        },\n        'params': {\n            # rtmp download\n            'skip_download': True,\n        },\n    }, {\n        # event playlist\n        'url': 'http://videolectures.net/deeplearning2015_montreal/',\n        'info_dict': {\n            'id': '23181',\n            'title': 'Deep Learning Summer School, Montreal 2015',\n            'description': 'md5:0533a85e4bd918df52a01f0e1ebe87b7',\n            'thumbnail': r're:http://.*\\.jpg',\n            'timestamp': 1438560000,\n        },\n        'playlist_count': 30,\n    }, {\n        # multi part lecture\n        'url': 'http://videolectures.net/mlss09uk_bishop_ibi/',\n        'info_dict': {\n            'id': '9737',\n            'display_id': 'mlss09uk_bishop_ibi',\n            'title': 'Introduction To Bayesian Inference',\n            'thumbnail': r're:http://.*\\.jpg',\n            'timestamp': 1251622800,\n        },\n        'playlist': [{\n            'info_dict': {\n                'id': '9737_part1',\n                'display_id': 'mlss09uk_bishop_ibi_part1',\n                'ext': 'wmv',\n                'title': 'Introduction To Bayesian Inference (Part 1)',\n                'thumbnail': r're:http://.*\\.jpg',\n                'duration': 4622,\n                'timestamp': 1251622800,\n                'upload_date': '20090830',\n            },\n        }, {\n            'info_dict': {\n                'id': '9737_part2',\n                'display_id': 'mlss09uk_bishop_ibi_part2',\n                'ext': 'wmv',\n                'title': 'Introduction To Bayesian Inference (Part 2)',\n                'thumbnail': r're:http://.*\\.jpg',\n                'duration': 5641,\n                'timestamp': 1251622800,\n                'upload_date': '20090830',\n            },\n        }],\n        'playlist_count': 2,\n    }]\n\n    def _real_extract(self, url):\n        lecture_slug, explicit_part_id = re.match(self._VALID_URL, url).groups()\n\n        webpage = self._download_webpage(url, lecture_slug)\n\n        cfg = self._parse_json(self._search_regex(\n            [r'cfg\\s*:\\s*({.+?})\\s*,\\s*[\\da-zA-Z_]+\\s*:\\s*\\(?\\s*function',\n             r'cfg\\s*:\\s*({[^}]+})'],\n            webpage, 'cfg'), lecture_slug, js_to_json)\n\n        lecture_id = compat_str(cfg['obj_id'])\n\n        base_url = self._proto_relative_url(cfg['livepipe'], 'http:')\n\n        try:\n            lecture_data = self._download_json(\n                '%s/site/api/lecture/%s?format=json' % (base_url, lecture_id),\n                lecture_id)['lecture'][0]\n        except ExtractorError as e:\n            if isinstance(e.cause, compat_HTTPError) and e.cause.code == 403:\n                msg = self._parse_json(\n                    e.cause.read().decode('utf-8'), lecture_id)\n                raise ExtractorError(msg['detail'], expected=True)\n            raise\n\n        lecture_info = {\n            'id': lecture_id,\n            'display_id': lecture_slug,\n            'title': lecture_data['title'],\n            'timestamp': parse_iso8601(lecture_data.get('time')),\n            'description': lecture_data.get('description_wiki'),\n            'thumbnail': lecture_data.get('thumb'),\n        }\n\n        playlist_entries = []\n        lecture_type = lecture_data.get('type')\n        parts = [compat_str(video) for video in cfg.get('videos', [])]\n        if parts:\n            multipart = len(parts) > 1\n\n            def extract_part(part_id):\n                smil_url = '%s/%s/video/%s/smil.xml' % (base_url, lecture_slug, part_id)\n                smil = self._download_smil(smil_url, lecture_id)\n                info = self._parse_smil(smil, smil_url, lecture_id)\n                self._sort_formats(info['formats'])\n                info['id'] = lecture_id if not multipart else '%s_part%s' % (lecture_id, part_id)\n                info['display_id'] = lecture_slug if not multipart else '%s_part%s' % (lecture_slug, part_id)\n                if multipart:\n                    info['title'] += ' (Part %s)' % part_id\n                switch = smil.find('.//switch')\n                if switch is not None:\n                    info['duration'] = parse_duration(switch.attrib.get('dur'))\n                item_info = lecture_info.copy()\n                item_info.update(info)\n                return item_info\n\n            if explicit_part_id or not multipart:\n                result = extract_part(explicit_part_id or parts[0])\n            else:\n                result = {\n                    '_type': 'multi_video',\n                    'entries': [extract_part(part) for part in parts],\n                }\n                result.update(lecture_info)\n\n            # Immediately return explicitly requested part or non event item\n            if explicit_part_id or lecture_type != 'evt':\n                return result\n\n            playlist_entries.append(result)\n\n        # It's probably a playlist\n        if not parts or lecture_type == 'evt':\n            playlist_webpage = self._download_webpage(\n                '%s/site/ajax/drilldown/?id=%s' % (base_url, lecture_id), lecture_id)\n            entries = [\n                self.url_result(compat_urlparse.urljoin(url, video_url), 'Viidea')\n                for _, video_url in re.findall(\n                    r'<a[^>]+href=([\"\\'])(.+?)\\1[^>]+id=[\"\\']lec=\\d+', playlist_webpage)]\n            playlist_entries.extend(entries)\n\n        playlist = self.playlist_result(playlist_entries, lecture_id)\n        playlist.update(lecture_info)\n        return playlist\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "viidea.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/viidea.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}