{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nfrom odoo import api, fields, models, _\nfrom odoo.addons import decimal_precision as dp\nfrom odoo.exceptions import UserError, ValidationError\n\n\nclass ProductAttribute(models.Model):\n    _name = \"product.attribute\"\n    _description = \"Product Attribute\"\n    _order = 'sequence, name'\n\n    name = fields.Char('Name', required=True, translate=True)\n    value_ids = fields.One2many('product.attribute.value', 'attribute_id', 'Values', copy=True)\n    sequence = fields.Integer('Sequence', help=\"Determine the display order\")\n    attribute_line_ids = fields.One2many('product.attribute.line', 'attribute_id', 'Lines')\n    create_variant = fields.Boolean(default=True, help=\"Check this if you want to create multiple variants for this attribute.\")\n\n\nclass ProductAttributevalue(models.Model):\n    _name = \"product.attribute.value\"\n    _order = 'sequence, attribute_id, id'\n\n    name = fields.Char('Value', required=True, translate=True)\n    sequence = fields.Integer('Sequence', help=\"Determine the display order\")\n    attribute_id = fields.Many2one('product.attribute', 'Attribute', ondelete='cascade', required=True)\n    product_ids = fields.Many2many('product.product', string='Variants', readonly=True)\n    price_extra = fields.Float(\n        'Attribute Price Extra', compute='_compute_price_extra', inverse='_set_price_extra',\n        default=0.0, digits=dp.get_precision('Product Price'),\n        help=\"Price Extra: Extra price for the variant with this attribute value on sale price. eg. 200 price extra, 1000 + 200 = 1200.\")\n    price_ids = fields.One2many('product.attribute.price', 'value_id', 'Attribute Prices', readonly=True)\n\n    _sql_constraints = [\n        ('value_company_uniq', 'unique (name,attribute_id)', 'This attribute value already exists !')\n    ]\n\n    @api.one\n    def _compute_price_extra(self):\n        if self._context.get('active_id'):\n            price = self.price_ids.filtered(lambda price: price.product_tmpl_id.id == self._context['active_id'])\n            self.price_extra = price.price_extra\n        else:\n            self.price_extra = 0.0\n\n    def _set_price_extra(self):\n        if not self._context.get('active_id'):\n            return\n\n        AttributePrice = self.env['product.attribute.price']\n        prices = AttributePrice.search([('value_id', 'in', self.ids), ('product_tmpl_id', '=', self._context['active_id'])])\n        updated = prices.mapped('value_id')\n        if prices:\n            prices.write({'price_extra': self.price_extra})\n        else:\n            for value in self - updated:\n                AttributePrice.create({\n                    'product_tmpl_id': self._context['active_id'],\n                    'value_id': value.id,\n                    'price_extra': self.price_extra,\n                })\n\n    @api.multi\n    def name_get(self):\n        if not self._context.get('show_attribute', True):  \n            return super(ProductAttributevalue, self).name_get()\n        return [(value.id, \"%s: %s\" % (value.attribute_id.name, value.name)) for value in self]\n\n    @api.multi\n    def unlink(self):\n        linked_products = self.env['product.product'].with_context(active_test=False).search([('attribute_value_ids', 'in', self.ids)])\n        if linked_products:\n            raise UserError(_('The operation cannot be completed:\\nYou are trying to delete an attribute value with a reference on a product variant.'))\n        return super(ProductAttributevalue, self).unlink()\n\n    @api.multi\n    def _variant_name(self, variable_attributes):\n        return \", \".join([v.name for v in self if v.attribute_id in variable_attributes])\n\n\nclass ProductAttributePrice(models.Model):\n    _name = \"product.attribute.price\"\n\n    product_tmpl_id = fields.Many2one('product.template', 'Product Template', ondelete='cascade', required=True)\n    value_id = fields.Many2one('product.attribute.value', 'Product Attribute Value', ondelete='cascade', required=True)\n    price_extra = fields.Float('Price Extra', digits=dp.get_precision('Product Price'))\n\n\nclass ProductAttributeLine(models.Model):\n    _name = \"product.attribute.line\"\n    _rec_name = 'attribute_id'\n\n    product_tmpl_id = fields.Many2one('product.template', 'Product Template', ondelete='cascade', required=True)\n    attribute_id = fields.Many2one('product.attribute', 'Attribute', ondelete='restrict', required=True)\n    value_ids = fields.Many2many('product.attribute.value', string='Attribute Values')\n\n    @api.constrains('value_ids', 'attribute_id')\n    def _check_valid_attribute(self):\n        if any(line.value_ids > line.attribute_id.value_ids for line in self):\n            raise ValidationError(_('Error ! You cannot use this attribute with the following value.'))\n        return True\n\n    @api.model\n    def name_search(self, name='', args=None, operator='ilike', limit=100):\n        \n        \n        \n        if name and operator in ('=', 'ilike', '=ilike', 'like', '=like'):\n            args = ['|', ('attribute_id', operator, name), ('value_ids', operator, name)]\n            return self.search(args, limit=limit).name_get()\n        return super(ProductAttributeLine, self).name_search(name=name, args=args, operator=operator, limit=limit)\n", "comments": "      coding  utf 8        part odoo  see license file full copyright licensing details     tde fixme  used    tde fixme  currently overriding domain  however includes    search m2o one m2m  probably quickly become    difficult compute   check performance optimization required ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nfrom odoo import api, fields, models, _\nfrom odoo.addons import decimal_precision as dp\nfrom odoo.exceptions import UserError, ValidationError\n\n\nclass ProductAttribute(models.Model):\n    _name = \"product.attribute\"\n    _description = \"Product Attribute\"\n    _order = 'sequence, name'\n\n    name = fields.Char('Name', required=True, translate=True)\n    value_ids = fields.One2many('product.attribute.value', 'attribute_id', 'Values', copy=True)\n    sequence = fields.Integer('Sequence', help=\"Determine the display order\")\n    attribute_line_ids = fields.One2many('product.attribute.line', 'attribute_id', 'Lines')\n    create_variant = fields.Boolean(default=True, help=\"Check this if you want to create multiple variants for this attribute.\")\n\n\nclass ProductAttributevalue(models.Model):\n    _name = \"product.attribute.value\"\n    _order = 'sequence, attribute_id, id'\n\n    name = fields.Char('Value', required=True, translate=True)\n    sequence = fields.Integer('Sequence', help=\"Determine the display order\")\n    attribute_id = fields.Many2one('product.attribute', 'Attribute', ondelete='cascade', required=True)\n    product_ids = fields.Many2many('product.product', string='Variants', readonly=True)\n    price_extra = fields.Float(\n        'Attribute Price Extra', compute='_compute_price_extra', inverse='_set_price_extra',\n        default=0.0, digits=dp.get_precision('Product Price'),\n        help=\"Price Extra: Extra price for the variant with this attribute value on sale price. eg. 200 price extra, 1000 + 200 = 1200.\")\n    price_ids = fields.One2many('product.attribute.price', 'value_id', 'Attribute Prices', readonly=True)\n\n    _sql_constraints = [\n        ('value_company_uniq', 'unique (name,attribute_id)', 'This attribute value already exists !')\n    ]\n\n    @api.one\n    def _compute_price_extra(self):\n        if self._context.get('active_id'):\n            price = self.price_ids.filtered(lambda price: price.product_tmpl_id.id == self._context['active_id'])\n            self.price_extra = price.price_extra\n        else:\n            self.price_extra = 0.0\n\n    def _set_price_extra(self):\n        if not self._context.get('active_id'):\n            return\n\n        AttributePrice = self.env['product.attribute.price']\n        prices = AttributePrice.search([('value_id', 'in', self.ids), ('product_tmpl_id', '=', self._context['active_id'])])\n        updated = prices.mapped('value_id')\n        if prices:\n            prices.write({'price_extra': self.price_extra})\n        else:\n            for value in self - updated:\n                AttributePrice.create({\n                    'product_tmpl_id': self._context['active_id'],\n                    'value_id': value.id,\n                    'price_extra': self.price_extra,\n                })\n\n    @api.multi\n    def name_get(self):\n        if not self._context.get('show_attribute', True):  # TDE FIXME: not used\n            return super(ProductAttributevalue, self).name_get()\n        return [(value.id, \"%s: %s\" % (value.attribute_id.name, value.name)) for value in self]\n\n    @api.multi\n    def unlink(self):\n        linked_products = self.env['product.product'].with_context(active_test=False).search([('attribute_value_ids', 'in', self.ids)])\n        if linked_products:\n            raise UserError(_('The operation cannot be completed:\\nYou are trying to delete an attribute value with a reference on a product variant.'))\n        return super(ProductAttributevalue, self).unlink()\n\n    @api.multi\n    def _variant_name(self, variable_attributes):\n        return \", \".join([v.name for v in self if v.attribute_id in variable_attributes])\n\n\nclass ProductAttributePrice(models.Model):\n    _name = \"product.attribute.price\"\n\n    product_tmpl_id = fields.Many2one('product.template', 'Product Template', ondelete='cascade', required=True)\n    value_id = fields.Many2one('product.attribute.value', 'Product Attribute Value', ondelete='cascade', required=True)\n    price_extra = fields.Float('Price Extra', digits=dp.get_precision('Product Price'))\n\n\nclass ProductAttributeLine(models.Model):\n    _name = \"product.attribute.line\"\n    _rec_name = 'attribute_id'\n\n    product_tmpl_id = fields.Many2one('product.template', 'Product Template', ondelete='cascade', required=True)\n    attribute_id = fields.Many2one('product.attribute', 'Attribute', ondelete='restrict', required=True)\n    value_ids = fields.Many2many('product.attribute.value', string='Attribute Values')\n\n    @api.constrains('value_ids', 'attribute_id')\n    def _check_valid_attribute(self):\n        if any(line.value_ids > line.attribute_id.value_ids for line in self):\n            raise ValidationError(_('Error ! You cannot use this attribute with the following value.'))\n        return True\n\n    @api.model\n    def name_search(self, name='', args=None, operator='ilike', limit=100):\n        # TDE FIXME: currently overriding the domain; however as it includes a\n        # search on a m2o and one on a m2m, probably this will quickly become\n        # difficult to compute - check if performance optimization is required\n        if name and operator in ('=', 'ilike', '=ilike', 'like', '=like'):\n            args = ['|', ('attribute_id', operator, name), ('value_ids', operator, name)]\n            return self.search(args, limit=limit).name_get()\n        return super(ProductAttributeLine, self).name_search(name=name, args=args, operator=operator, limit=limit)\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "product_attribute.py", "id": "c059bab645874ee95d3461e630775a0d", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/product/models/product_attribute.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}