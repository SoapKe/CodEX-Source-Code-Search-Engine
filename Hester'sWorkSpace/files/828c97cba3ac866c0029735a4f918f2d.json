{"author": "donnemartin", "code": " -*- coding: utf-8 -*-\n\n\n\n Licensed under the Apache License, Version 2.0 (the \"License\"). You\n may not use this file except in compliance with the License. A copy of\n the License is located at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n or in the \"license\" file accompanying this file. This file is\n distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n ANY KIND, either express or implied. See the License for the specific\n language governing permissions and limitations under the License.\n\nfrom __future__ import unicode_literals\nfrom __future__ import print_function\n\nimport mock\nimport os\nfrom gitsome.compat import configparser\nfrom tests.compat import unittest\n\nfrom gitsome.github import GitHub\nfrom tests.mock_github_api import MockGitHubApi\n\n\nclass ConfigTest(unittest.TestCase):\n\n    def setUp(self):\n        self.github = GitHub()\n        self.github.config.api = MockGitHubApi()\n        self.github.config.login = mock.Mock()\n        self.github.config.authorize = mock.Mock()\n        self.github.config.getpass = mock.Mock()\n\n    def verify_login_token(self, username=None, password=None,\n                           token=None, url=None,\n                           two_factor_callback=None,\n                           verify=True):\n        assert username is not None\n        assert token is not None\n        assert two_factor_callback is not None\n        assert verify\n\n    def verify_login_pass(self, username=None, password=None,\n                          token=None, url=None,\n                          two_factor_callback=None,\n                          verify=True):\n        assert username is not None\n        assert password is not None\n        assert password\n        assert two_factor_callback is not None\n        assert verify\n\n    def verify_login_token_url_enterprise(self, username=None, password=None,\n                                          token=None, url=None,\n                                          two_factor_callback=None,\n                                          verify=True):\n        assert username is not None\n        assert token is not None\n        assert url is not None\n        assert two_factor_callback is not None\n        assert verify\n\n    def verify_login_token_url_no_verify_enterprise(self, username=None,\n                                                    password=None, token=None,\n                                                    url=None,\n                                                    two_factor_callback=None,\n                                                    verify=True):\n        assert username is not None\n        assert token is not None\n        assert url is not None\n        assert two_factor_callback is not None\n        assert not verify\n\n    def verify_login_pass_url_enterprise(self, username=None, password=None,\n                                         token=None, url=None,\n                                         two_factor_callback=None,\n                                         verify=True):\n        assert username is not None\n        assert password is not None\n        assert url is not None\n        assert two_factor_callback is not None\n        assert verify\n\n    def test_config(self):\n        expected = os.path.join(os.path.abspath(os.environ.get('HOME', '')),\n                                self.github.config.CONFIG)\n        assert self.github.config \\\n            .get_github_config_path(self.github.config.CONFIG) == expected\n\n    def test_authenticate_cached_credentials_token(self):\n        self.github.config.user_login = 'foo'\n        self.github.config.user_token = 'bar'\n        self.github.config.save_config()\n        self.github.config.user_login = ''\n        self.github.config.user_token = ''\n        self.github.config.api = None\n        config = self.github.config.get_github_config_path(\n            self.github.config.CONFIG)\n        parser = configparser.RawConfigParser()\n        self.github.config.login = self.verify_login_token\n        self.github.config.authenticate_cached_credentials(config, parser)\n        assert self.github.config.user_login == 'foo'\n        assert self.github.config.user_token == 'bar'\n\n    def test_authenticate_cached_credentials_pass(self):\n        self.github.config.user_login = 'foo'\n        self.github.config.user_pass = 'bar'\n        self.github.config.save_config()\n        self.github.config.user_login = ''\n        self.github.config.user_pass = ''\n        self.github.config.api = None\n        config = self.github.config.get_github_config_path(\n            self.github.config.CONFIG)\n        parser = configparser.RawConfigParser()\n        self.github.config.authenticate_cached_credentials(config, parser)\n        assert self.github.config.user_login == 'foo'\n        assert self.github.config.user_pass is None\n\n    def test_authenticate_cached_credentials_token_enterprise(self):\n        self.github.config.user_login = 'foo'\n        self.github.config.user_token = 'bar'\n        self.github.config.enterprise_url = 'baz'\n        self.github.config.save_config()\n        self.github.config.user_login = ''\n        self.github.config.user_token = ''\n        self.github.config.enterprise_url = ''\n        self.github.config.api = None\n        config = self.github.config.get_github_config_path(\n            self.github.config.CONFIG)\n        parser = configparser.RawConfigParser()\n        self.github.config.authenticate_cached_credentials(\n            config,\n            parser,\n            enterprise_auth=self.verify_login_token_url_enterprise)\n        assert self.github.config.user_login == 'foo'\n        assert self.github.config.user_token == 'bar'\n        assert self.github.config.enterprise_url == 'baz'\n\n    def test_authenticate_cached_credentials_pass_enterprise(self):\n        self.github.config.user_login = 'foo'\n        self.github.config.user_pass = 'bar'\n        self.github.config.enterprise_url = 'baz'\n        self.github.config.save_config()\n        self.github.config.user_login = ''\n        self.github.config.user_pass = ''\n        self.github.config.enterprise_url = ''\n        self.github.config.api = None\n        config = self.github.config.get_github_config_path(\n            self.github.config.CONFIG)\n        parser = configparser.RawConfigParser()\n        self.github.config.authenticate_cached_credentials(\n            config,\n            parser,\n            enterprise_auth=self.verify_login_pass_url_enterprise)\n        assert self.github.config.user_login == 'foo'\n        assert self.github.config.user_pass == 'bar'\n        assert self.github.config.enterprise_url == 'baz'\n\n    @mock.patch('gitsome.github.click.secho')\n    @mock.patch('gitsome.config.Config.authenticate_cached_credentials')\n    def test_authenticate_token(self, mock_auth, mock_click_secho):\n        with mock.patch('click.confirm', return_value=False):\n            with mock.patch('builtins.input', return_value='foo'):\n                self.github.config.login = self.verify_login_token\n                self.github.config.user_login = 'foo'\n                self.github.config.user_token = 'bar'\n                self.github.config.authenticate(\n                    enterprise=False,\n                    overwrite=True)\n\n    @mock.patch('gitsome.github.click.secho')\n    @mock.patch('gitsome.config.Config.authenticate_cached_credentials')\n    def test_authenticate_pass(self, mock_auth, mock_click_secho):\n        self.github.config.getpass.return_value = 'bar'\n        with mock.patch('click.confirm', return_value=True):\n            with mock.patch('builtins.input', return_value='foo'):\n                self.github.config.login = self.verify_login_pass\n                self.github.config.user_login = 'foo'\n                self.github.config.authenticate(\n                    enterprise=False,\n                    overwrite=True)\n                assert self.github.config.user_pass is None\n\n    @mock.patch('gitsome.github.click.secho')\n    @mock.patch('gitsome.config.Config.authenticate_cached_credentials')\n    def test_authenticate_enterprise_token(self, mock_auth, mock_click_secho):\n        with mock.patch('click.confirm', return_value=False):\n            with mock.patch('builtins.input', return_value='foo'):\n                self.github.config.user_login = 'foo'\n                self.github.config.user_token = 'bar'\n                enterprise_auth = \\\n                    self.verify_login_token_url_no_verify_enterprise\n                self.github.config.authenticate(\n                    enterprise=True,\n                    enterprise_auth=enterprise_auth,\n                    overwrite=True)\n\n    @mock.patch('gitsome.github.click.secho')\n    @mock.patch('gitsome.config.Config.authenticate_cached_credentials')\n    def test_authenticate_enterprise_pass(self, mock_auth, mock_click_secho):\n        self.github.config.getpass.return_value = 'bar'\n        with mock.patch('click.confirm', return_value=True):\n            with mock.patch('builtins.input', return_value='foo'):\n                self.github.config.user_login = 'foo'\n                self.github.config.authenticate(\n                    enterprise=True,\n                    enterprise_auth=self.verify_login_pass_url_enterprise,\n                    overwrite=True)\n                assert self.github.config.user_pass is not None\n\n    @mock.patch('gitsome.github.click.secho')\n    def test_check_auth_error(self, mock_click_secho):\n        self.github.config.api = None\n        self.github.config.check_auth()\n        mock_click_secho.assert_any_call('Authentication error.', fg='red')\n        mock_click_secho.assert_any_call('Update your credentials in ~/.gitsomeconfig or run:\\n  gh configure', fg=None)   NOQA\n\n    def test_load_urls(self):\n        urls = self.github.config.load_urls(view_in_browser=False)\n        assert urls == ['octocat/spoon-knife']\n\n    def test_request_two_factor_code(self):\n        with mock.patch('builtins.input', return_value='code'):\n            assert self.github.config.request_two_factor_code() == 'code'\n\n    @mock.patch('gitsome.github.click.secho')\n    def test_prompt_news_feed(self, mock_click_secho):\n        with mock.patch('click.confirm', return_value='y'):\n            with mock.patch('builtins.input', return_value='feed'):\n                self.github.config.prompt_news_feed()\n                assert self.github.config.user_feed == 'feed'\n", "comments": "      coding  utf 8        copyright 2015 donne martin  all rights reserved        licensed apache license  version 2 0 (the  license )  you    may use file except compliance license  a copy    license located           http   www apache org licenses license 2 0        license  file accompanying file  this file    distributed  as is  basis  without warranties or conditions of    any kind  either express implied  see license specific    language governing permissions limitations license     noqa ", "content": "# -*- coding: utf-8 -*-\n\n# Copyright 2015 Donne Martin. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"). You\n# may not use this file except in compliance with the License. A copy of\n# the License is located at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# or in the \"license\" file accompanying this file. This file is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n# ANY KIND, either express or implied. See the License for the specific\n# language governing permissions and limitations under the License.\n\nfrom __future__ import unicode_literals\nfrom __future__ import print_function\n\nimport mock\nimport os\nfrom gitsome.compat import configparser\nfrom tests.compat import unittest\n\nfrom gitsome.github import GitHub\nfrom tests.mock_github_api import MockGitHubApi\n\n\nclass ConfigTest(unittest.TestCase):\n\n    def setUp(self):\n        self.github = GitHub()\n        self.github.config.api = MockGitHubApi()\n        self.github.config.login = mock.Mock()\n        self.github.config.authorize = mock.Mock()\n        self.github.config.getpass = mock.Mock()\n\n    def verify_login_token(self, username=None, password=None,\n                           token=None, url=None,\n                           two_factor_callback=None,\n                           verify=True):\n        assert username is not None\n        assert token is not None\n        assert two_factor_callback is not None\n        assert verify\n\n    def verify_login_pass(self, username=None, password=None,\n                          token=None, url=None,\n                          two_factor_callback=None,\n                          verify=True):\n        assert username is not None\n        assert password is not None\n        assert password\n        assert two_factor_callback is not None\n        assert verify\n\n    def verify_login_token_url_enterprise(self, username=None, password=None,\n                                          token=None, url=None,\n                                          two_factor_callback=None,\n                                          verify=True):\n        assert username is not None\n        assert token is not None\n        assert url is not None\n        assert two_factor_callback is not None\n        assert verify\n\n    def verify_login_token_url_no_verify_enterprise(self, username=None,\n                                                    password=None, token=None,\n                                                    url=None,\n                                                    two_factor_callback=None,\n                                                    verify=True):\n        assert username is not None\n        assert token is not None\n        assert url is not None\n        assert two_factor_callback is not None\n        assert not verify\n\n    def verify_login_pass_url_enterprise(self, username=None, password=None,\n                                         token=None, url=None,\n                                         two_factor_callback=None,\n                                         verify=True):\n        assert username is not None\n        assert password is not None\n        assert url is not None\n        assert two_factor_callback is not None\n        assert verify\n\n    def test_config(self):\n        expected = os.path.join(os.path.abspath(os.environ.get('HOME', '')),\n                                self.github.config.CONFIG)\n        assert self.github.config \\\n            .get_github_config_path(self.github.config.CONFIG) == expected\n\n    def test_authenticate_cached_credentials_token(self):\n        self.github.config.user_login = 'foo'\n        self.github.config.user_token = 'bar'\n        self.github.config.save_config()\n        self.github.config.user_login = ''\n        self.github.config.user_token = ''\n        self.github.config.api = None\n        config = self.github.config.get_github_config_path(\n            self.github.config.CONFIG)\n        parser = configparser.RawConfigParser()\n        self.github.config.login = self.verify_login_token\n        self.github.config.authenticate_cached_credentials(config, parser)\n        assert self.github.config.user_login == 'foo'\n        assert self.github.config.user_token == 'bar'\n\n    def test_authenticate_cached_credentials_pass(self):\n        self.github.config.user_login = 'foo'\n        self.github.config.user_pass = 'bar'\n        self.github.config.save_config()\n        self.github.config.user_login = ''\n        self.github.config.user_pass = ''\n        self.github.config.api = None\n        config = self.github.config.get_github_config_path(\n            self.github.config.CONFIG)\n        parser = configparser.RawConfigParser()\n        self.github.config.authenticate_cached_credentials(config, parser)\n        assert self.github.config.user_login == 'foo'\n        assert self.github.config.user_pass is None\n\n    def test_authenticate_cached_credentials_token_enterprise(self):\n        self.github.config.user_login = 'foo'\n        self.github.config.user_token = 'bar'\n        self.github.config.enterprise_url = 'baz'\n        self.github.config.save_config()\n        self.github.config.user_login = ''\n        self.github.config.user_token = ''\n        self.github.config.enterprise_url = ''\n        self.github.config.api = None\n        config = self.github.config.get_github_config_path(\n            self.github.config.CONFIG)\n        parser = configparser.RawConfigParser()\n        self.github.config.authenticate_cached_credentials(\n            config,\n            parser,\n            enterprise_auth=self.verify_login_token_url_enterprise)\n        assert self.github.config.user_login == 'foo'\n        assert self.github.config.user_token == 'bar'\n        assert self.github.config.enterprise_url == 'baz'\n\n    def test_authenticate_cached_credentials_pass_enterprise(self):\n        self.github.config.user_login = 'foo'\n        self.github.config.user_pass = 'bar'\n        self.github.config.enterprise_url = 'baz'\n        self.github.config.save_config()\n        self.github.config.user_login = ''\n        self.github.config.user_pass = ''\n        self.github.config.enterprise_url = ''\n        self.github.config.api = None\n        config = self.github.config.get_github_config_path(\n            self.github.config.CONFIG)\n        parser = configparser.RawConfigParser()\n        self.github.config.authenticate_cached_credentials(\n            config,\n            parser,\n            enterprise_auth=self.verify_login_pass_url_enterprise)\n        assert self.github.config.user_login == 'foo'\n        assert self.github.config.user_pass == 'bar'\n        assert self.github.config.enterprise_url == 'baz'\n\n    @mock.patch('gitsome.github.click.secho')\n    @mock.patch('gitsome.config.Config.authenticate_cached_credentials')\n    def test_authenticate_token(self, mock_auth, mock_click_secho):\n        with mock.patch('click.confirm', return_value=False):\n            with mock.patch('builtins.input', return_value='foo'):\n                self.github.config.login = self.verify_login_token\n                self.github.config.user_login = 'foo'\n                self.github.config.user_token = 'bar'\n                self.github.config.authenticate(\n                    enterprise=False,\n                    overwrite=True)\n\n    @mock.patch('gitsome.github.click.secho')\n    @mock.patch('gitsome.config.Config.authenticate_cached_credentials')\n    def test_authenticate_pass(self, mock_auth, mock_click_secho):\n        self.github.config.getpass.return_value = 'bar'\n        with mock.patch('click.confirm', return_value=True):\n            with mock.patch('builtins.input', return_value='foo'):\n                self.github.config.login = self.verify_login_pass\n                self.github.config.user_login = 'foo'\n                self.github.config.authenticate(\n                    enterprise=False,\n                    overwrite=True)\n                assert self.github.config.user_pass is None\n\n    @mock.patch('gitsome.github.click.secho')\n    @mock.patch('gitsome.config.Config.authenticate_cached_credentials')\n    def test_authenticate_enterprise_token(self, mock_auth, mock_click_secho):\n        with mock.patch('click.confirm', return_value=False):\n            with mock.patch('builtins.input', return_value='foo'):\n                self.github.config.user_login = 'foo'\n                self.github.config.user_token = 'bar'\n                enterprise_auth = \\\n                    self.verify_login_token_url_no_verify_enterprise\n                self.github.config.authenticate(\n                    enterprise=True,\n                    enterprise_auth=enterprise_auth,\n                    overwrite=True)\n\n    @mock.patch('gitsome.github.click.secho')\n    @mock.patch('gitsome.config.Config.authenticate_cached_credentials')\n    def test_authenticate_enterprise_pass(self, mock_auth, mock_click_secho):\n        self.github.config.getpass.return_value = 'bar'\n        with mock.patch('click.confirm', return_value=True):\n            with mock.patch('builtins.input', return_value='foo'):\n                self.github.config.user_login = 'foo'\n                self.github.config.authenticate(\n                    enterprise=True,\n                    enterprise_auth=self.verify_login_pass_url_enterprise,\n                    overwrite=True)\n                assert self.github.config.user_pass is not None\n\n    @mock.patch('gitsome.github.click.secho')\n    def test_check_auth_error(self, mock_click_secho):\n        self.github.config.api = None\n        self.github.config.check_auth()\n        mock_click_secho.assert_any_call('Authentication error.', fg='red')\n        mock_click_secho.assert_any_call('Update your credentials in ~/.gitsomeconfig or run:\\n  gh configure', fg=None)  # NOQA\n\n    def test_load_urls(self):\n        urls = self.github.config.load_urls(view_in_browser=False)\n        assert urls == ['octocat/spoon-knife']\n\n    def test_request_two_factor_code(self):\n        with mock.patch('builtins.input', return_value='code'):\n            assert self.github.config.request_two_factor_code() == 'code'\n\n    @mock.patch('gitsome.github.click.secho')\n    def test_prompt_news_feed(self, mock_click_secho):\n        with mock.patch('click.confirm', return_value='y'):\n            with mock.patch('builtins.input', return_value='feed'):\n                self.github.config.prompt_news_feed()\n                assert self.github.config.user_feed == 'feed'\n", "description": "A supercharged Git/GitHub command line interface (CLI).  An official integration for GitHub and GitHub Enterprise: https://github.com/works-with/category/desktop-tools", "file_name": "test_config.py", "id": "828c97cba3ac866c0029735a4f918f2d", "language": "Python", "project_name": "gitsome", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/donnemartin-gitsome/donnemartin-gitsome-5751a31/tests/test_config.py", "save_time": "", "source": "", "update_at": "2018-03-18T02:47:11Z", "url": "https://github.com/donnemartin/gitsome", "wiki": true}