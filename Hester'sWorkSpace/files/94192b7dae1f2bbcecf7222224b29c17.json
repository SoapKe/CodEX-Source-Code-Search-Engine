{"author": "reddit-archive", "code": "\n License Version 1.0. (the \"License\"); you may not use this file except in\n\n\n\n\n\n\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for\n the specific language governing rights and limitations under the License.\n\n The Original Code is reddit.\n\n The Original Developer is the Initial Developer.  The Initial Developer of\n the Original Code is reddit Inc.\n\n All portions of the code written by reddit are Copyright (c) 2006-2015 reddit\n Inc. All Rights Reserved.\n\n\nfrom r2.config.feature.state import FeatureState\nfrom r2.config.feature.world import World\nfrom r2.lib.hooks import HookRegistrar\n\nfeature_hooks = HookRegistrar()\n\n_world = World()\n_featurestate_cache = {}\n\n\ndef is_enabled(name, user=None, subreddit=None):\n    \"\"\"Test and return whether a given feature is enabled for this request.\n\n    If `feature` is not found, returns False.\n\n    The optional arguments allow overriding that you generally don't want, but\n    is useful outside of request contexts - cron jobs and the like.\n\n    :param name string - a given feature name\n    :param user - (optional) an Account\n    :param subreddit - (optional) a Subreddit\n    :return bool\n    \"\"\"\n    if not user:\n        user = _world.current_user()\n    if not subreddit:\n        subreddit = _world.current_subreddit()\n    subdomain = _world.current_subdomain()\n    oauth_client = _world.current_oauth_client()\n\n    return _get_featurestate(name).is_enabled(\n        user=user,\n        subreddit=subreddit,\n        subdomain=subdomain,\n        oauth_client=oauth_client,\n    )\n\ndef variant(name, user=None):\n    \"\"\"Return which variant of an experiment a user is part of.\n\n    If the experiment is not found, has no variants, or the user is not part of\n    any of them (control), return None.\n\n    :param name string - an experiment (feature) name\n    :param user - (optional) an Account.  Defaults to the currently signed in\n                  user.\n    :return string, or None if not part of an experiment\n    \"\"\"\n    if not user:\n        user = _world.current_user()\n\n    return _get_featurestate(name).variant(user)\n\ndef all_enabled(user=None):\n    \"\"\"Return a list of enabled features and experiments for the user.\n    \n    Provides the user's assigned variant and the experiment ID for experiments.\n\n    This does not trigger bucketing events, so it should not be used for\n    feature flagging purposes on the server. It is meant to let clients\n    condition features on experiment variants. Those clients should manually\n    send the appropriate bucketing events.\n\n    This does not include page-based experiments, which operate independently\n    of the particular user.\n\n    :param user - (optional) an Account. Defaults to None, for which we\n                  determine logged-out features.\n    :return dict - a dictionary mapping enabled feature keys to True or to the\n                   experiment/variant information\n    \"\"\"\n    features = FeatureState.get_all(_world)\n\n     Get enabled features and experiments\n    active = {}\n    for feature in features:\n        experiment = feature.config.get('experiment')\n         Exclude page experiments\n        if experiment and FeatureState.is_user_experiment(experiment):\n             Get experiment names, ids, and assigned variants, leaving out\n             experiments for which this user is excluded\n            variant = feature.variant(user)\n            if variant:\n                active[feature.name] = {\n                    'experiment_id': experiment.get('experiment_id'),\n                    'variant': variant\n                }\n        elif feature.is_enabled(user):\n                active[feature.name] = True\n\n    return active\n\n@feature_hooks.on('worker.live_config.update')\ndef clear_featurestate_cache():\n    global _featurestate_cache\n    _featurestate_cache = {}\n\n\ndef _get_featurestate(name):\n    \"\"\"Get a FeatureState object for this feature, creating it if necessary.\n\n    :param name string - a given feature name\n    :return FeatureState\n    \"\"\"\n\n    featurestate = _featurestate_cache.get(name, None)\n    if featurestate is None:\n        featurestate = FeatureState(name, _world)\n        _featurestate_cache[name] = featurestate\n\n    return featurestate\n", "comments": "   test return whether given feature enabled request       if  feature  found  returns false       the optional arguments allow overriding generally want      useful outside request contexts   cron jobs like        param name string   given feature name      param user   (optional) account      param subreddit   (optional) subreddit      return bool             user          user    world current user()     subreddit          subreddit    world current subreddit()     subdomain    world current subdomain()     oauth client    world current oauth client()      return  get featurestate(name) enabled(         user user          subreddit subreddit          subdomain subdomain          oauth client oauth client      )  def variant(name  user none)         return variant experiment user part       if experiment found  variants  user part     (control)  return none        param name string   experiment (feature) name      param user   (optional) account   defaults currently signed                   user       return string  none part experiment             user          user    world current user()      return  get featurestate(name) variant(user)  def enabled(user none)         return list enabled features experiments user           provides user assigned variant experiment id experiments       this trigger bucketing events  used     feature flagging purposes server  it meant let clients     condition features experiment variants  those clients manually     send appropriate bucketing events       this include page based experiments  operate independently     particular user        param user   (optional) account  defaults none                    determine logged features       return dict   dictionary mapping enabled feature keys true                    experiment variant information             features   featurestate get all( world)        get enabled features experiments     active          feature features          experiment   feature config get( experiment )           exclude page experiments         experiment featurestate user experiment(experiment)                get experiment names  ids  assigned variants  leaving               experiments user excluded             variant   feature variant(user)             variant                  active feature name                           experiment id   experiment get( experiment id )                       variant   variant                           elif feature enabled(user)                  active feature name    true      return active   feature hooks on( worker live config update ) def clear featurestate cache()      global  featurestate cache      featurestate cache        def  get featurestate(name)         get featurestate object feature  creating necessary        param name string   given feature name      return featurestate            the contents file subject common public attribution    license version 1 0  (the  license )  may use file except    compliance license  you may obtain copy license    http   code reddit com license  the license based mozilla public    license version 1 1  sections 14 15 added cover use    software computer network provide limited attribution    original developer  in addition  exhibit a modified consistent    exhibit b        software distributed license distributed  as is  basis     without warranty of any kind  either express implied  see license    specific language governing rights limitations license        the original code reddit        the original developer initial developer   the initial developer    original code reddit inc        all portions code written reddit copyright (c) 2006 2015 reddit    inc  all rights reserved                                                                                      get enabled features experiments    exclude page experiments    get experiment names  ids  assigned variants  leaving    experiments user excluded ", "content": "# The contents of this file are subject to the Common Public Attribution\n# License Version 1.0. (the \"License\"); you may not use this file except in\n# compliance with the License. You may obtain a copy of the License at\n# http://code.reddit.com/LICENSE. The License is based on the Mozilla Public\n# License Version 1.1, but Sections 14 and 15 have been added to cover use of\n# software over a computer network and provide for limited attribution for the\n# Original Developer. In addition, Exhibit A has been modified to be consistent\n# with Exhibit B.\n#\n# Software distributed under the License is distributed on an \"AS IS\" basis,\n# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for\n# the specific language governing rights and limitations under the License.\n#\n# The Original Code is reddit.\n#\n# The Original Developer is the Initial Developer.  The Initial Developer of\n# the Original Code is reddit Inc.\n#\n# All portions of the code written by reddit are Copyright (c) 2006-2015 reddit\n# Inc. All Rights Reserved.\n###############################################################################\n\nfrom r2.config.feature.state import FeatureState\nfrom r2.config.feature.world import World\nfrom r2.lib.hooks import HookRegistrar\n\nfeature_hooks = HookRegistrar()\n\n_world = World()\n_featurestate_cache = {}\n\n\ndef is_enabled(name, user=None, subreddit=None):\n    \"\"\"Test and return whether a given feature is enabled for this request.\n\n    If `feature` is not found, returns False.\n\n    The optional arguments allow overriding that you generally don't want, but\n    is useful outside of request contexts - cron jobs and the like.\n\n    :param name string - a given feature name\n    :param user - (optional) an Account\n    :param subreddit - (optional) a Subreddit\n    :return bool\n    \"\"\"\n    if not user:\n        user = _world.current_user()\n    if not subreddit:\n        subreddit = _world.current_subreddit()\n    subdomain = _world.current_subdomain()\n    oauth_client = _world.current_oauth_client()\n\n    return _get_featurestate(name).is_enabled(\n        user=user,\n        subreddit=subreddit,\n        subdomain=subdomain,\n        oauth_client=oauth_client,\n    )\n\ndef variant(name, user=None):\n    \"\"\"Return which variant of an experiment a user is part of.\n\n    If the experiment is not found, has no variants, or the user is not part of\n    any of them (control), return None.\n\n    :param name string - an experiment (feature) name\n    :param user - (optional) an Account.  Defaults to the currently signed in\n                  user.\n    :return string, or None if not part of an experiment\n    \"\"\"\n    if not user:\n        user = _world.current_user()\n\n    return _get_featurestate(name).variant(user)\n\ndef all_enabled(user=None):\n    \"\"\"Return a list of enabled features and experiments for the user.\n    \n    Provides the user's assigned variant and the experiment ID for experiments.\n\n    This does not trigger bucketing events, so it should not be used for\n    feature flagging purposes on the server. It is meant to let clients\n    condition features on experiment variants. Those clients should manually\n    send the appropriate bucketing events.\n\n    This does not include page-based experiments, which operate independently\n    of the particular user.\n\n    :param user - (optional) an Account. Defaults to None, for which we\n                  determine logged-out features.\n    :return dict - a dictionary mapping enabled feature keys to True or to the\n                   experiment/variant information\n    \"\"\"\n    features = FeatureState.get_all(_world)\n\n    # Get enabled features and experiments\n    active = {}\n    for feature in features:\n        experiment = feature.config.get('experiment')\n        # Exclude page experiments\n        if experiment and FeatureState.is_user_experiment(experiment):\n            # Get experiment names, ids, and assigned variants, leaving out\n            # experiments for which this user is excluded\n            variant = feature.variant(user)\n            if variant:\n                active[feature.name] = {\n                    'experiment_id': experiment.get('experiment_id'),\n                    'variant': variant\n                }\n        elif feature.is_enabled(user):\n                active[feature.name] = True\n\n    return active\n\n@feature_hooks.on('worker.live_config.update')\ndef clear_featurestate_cache():\n    global _featurestate_cache\n    _featurestate_cache = {}\n\n\ndef _get_featurestate(name):\n    \"\"\"Get a FeatureState object for this feature, creating it if necessary.\n\n    :param name string - a given feature name\n    :return FeatureState\n    \"\"\"\n\n    featurestate = _featurestate_cache.get(name, None)\n    if featurestate is None:\n        featurestate = FeatureState(name, _world)\n        _featurestate_cache[name] = featurestate\n\n    return featurestate\n", "description": "historical code from reddit.com", "file_name": "feature.py", "id": "94192b7dae1f2bbcecf7222224b29c17", "language": "Python", "project_name": "reddit", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/reddit-archive-reddit/reddit-archive-reddit-753b174/r2/r2/config/feature/feature.py", "save_time": "", "source": "", "update_at": "2018-03-18T11:55:36Z", "url": "https://github.com/reddit-archive/reddit", "wiki": true}