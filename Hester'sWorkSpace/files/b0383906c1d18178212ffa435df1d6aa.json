{"author": "ansible", "code": "\n\nimport os\nimport re\nimport yaml\nimport argparse\n\ntry:\n    import pyrax\n    HAS_PYRAX = True\nexcept ImportError:\n    HAS_PYRAX = False\n\nfrom ansible.module_utils.six.moves import input\n\n\ndef rax_list_iterator(svc, *args, **kwargs):\n    method = kwargs.pop('method', 'list')\n    items = getattr(svc, method)(*args, **kwargs)\n    while items:\n        retrieved = getattr(svc, method)(*args, marker=items[-1].id, **kwargs)\n        if items and retrieved and items[-1].id == retrieved[0].id:\n            del items[-1]\n        items.extend(retrieved)\n        if len(retrieved) < 2:\n            break\n    return items\n\n\ndef parse_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-y', '--yes', action='store_true', dest='assumeyes',\n                        default=False, help=\"Don't prompt for confirmation\")\n    parser.add_argument('--match', dest='match_re',\n                        default='^ansible-testing',\n                        help='Regular expression used to find resources '\n                             '(default: %(default)s)')\n\n    return parser.parse_args()\n\n\ndef authenticate():\n    try:\n        with open(os.path.realpath('./credentials.yml')) as f:\n            credentials = yaml.load(f)\n    except Exception as e:\n        raise SystemExit(e)\n\n    try:\n        pyrax.set_credentials(credentials.get('rackspace_username'),\n                              credentials.get('rackspace_api_key'))\n    except Exception as e:\n        raise SystemExit(e)\n\n\ndef prompt_and_delete(item, prompt, assumeyes):\n    if not assumeyes:\n        assumeyes = input(prompt).lower() == 'y'\n    assert hasattr(item, 'delete') or hasattr(item, 'terminate'), \\\n        \"Class <%s> has no delete or terminate attribute\" % item.__class__\n    if assumeyes:\n        if hasattr(item, 'delete'):\n            item.delete()\n            print(\"Deleted %s\" % item)\n        if hasattr(item, 'terminate'):\n            item.terminate()\n            print(\"Terminated %s\" % item)\n\n\ndef delete_rax(args):\n    \"\"\"Function for deleting CloudServers\"\"\"\n    print(\"--- Cleaning CloudServers matching '%s'\" % args.match_re)\n    search_opts = dict(name='^%s' % args.match_re)\n    for region in pyrax.identity.services.compute.regions:\n        cs = pyrax.connect_to_cloudservers(region=region)\n        servers = rax_list_iterator(cs.servers, search_opts=search_opts)\n        for server in servers:\n            prompt_and_delete(server,\n                              'Delete matching %s? [y/n]: ' % server,\n                              args.assumeyes)\n\n\ndef delete_rax_clb(args):\n    \"\"\"Function for deleting Cloud Load Balancers\"\"\"\n    print(\"--- Cleaning Cloud Load Balancers matching '%s'\" % args.match_re)\n    for region in pyrax.identity.services.load_balancer.regions:\n        clb = pyrax.connect_to_cloud_loadbalancers(region=region)\n        for lb in rax_list_iterator(clb):\n            if re.search(args.match_re, lb.name):\n                prompt_and_delete(lb,\n                                  'Delete matching %s? [y/n]: ' % lb,\n                                  args.assumeyes)\n\n\ndef delete_rax_keypair(args):\n    \"\"\"Function for deleting Rackspace Key pairs\"\"\"\n    print(\"--- Cleaning Key Pairs matching '%s'\" % args.match_re)\n    for region in pyrax.identity.services.compute.regions:\n        cs = pyrax.connect_to_cloudservers(region=region)\n        for keypair in cs.keypairs.list():\n            if re.search(args.match_re, keypair.name):\n                prompt_and_delete(keypair,\n                                  'Delete matching %s? [y/n]: ' % keypair,\n                                  args.assumeyes)\n\n\ndef delete_rax_network(args):\n    \"\"\"Function for deleting Cloud Networks\"\"\"\n    print(\"--- Cleaning Cloud Networks matching '%s'\" % args.match_re)\n    for region in pyrax.identity.services.network.regions:\n        cnw = pyrax.connect_to_cloud_networks(region=region)\n        for network in cnw.list():\n            if re.search(args.match_re, network.name):\n                prompt_and_delete(network,\n                                  'Delete matching %s? [y/n]: ' % network,\n                                  args.assumeyes)\n\n\ndef delete_rax_cbs(args):\n    \"\"\"Function for deleting Cloud Networks\"\"\"\n    print(\"--- Cleaning Cloud Block Storage matching '%s'\" % args.match_re)\n    for region in pyrax.identity.services.network.regions:\n        cbs = pyrax.connect_to_cloud_blockstorage(region=region)\n        for volume in cbs.list():\n            if re.search(args.match_re, volume.name):\n                prompt_and_delete(volume,\n                                  'Delete matching %s? [y/n]: ' % volume,\n                                  args.assumeyes)\n\n\ndef delete_rax_cdb(args):\n    \"\"\"Function for deleting Cloud Databases\"\"\"\n    print(\"--- Cleaning Cloud Databases matching '%s'\" % args.match_re)\n    for region in pyrax.identity.services.database.regions:\n        cdb = pyrax.connect_to_cloud_databases(region=region)\n        for db in rax_list_iterator(cdb):\n            if re.search(args.match_re, db.name):\n                prompt_and_delete(db,\n                                  'Delete matching %s? [y/n]: ' % db,\n                                  args.assumeyes)\n\n\ndef _force_delete_rax_scaling_group(manager):\n    def wrapped(uri):\n        manager.api.method_delete('%s?force=true' % uri)\n    return wrapped\n\n\ndef delete_rax_scaling_group(args):\n    \"\"\"Function for deleting Autoscale Groups\"\"\"\n    print(\"--- Cleaning Autoscale Groups matching '%s'\" % args.match_re)\n    for region in pyrax.identity.services.autoscale.regions:\n        asg = pyrax.connect_to_autoscale(region=region)\n        for group in rax_list_iterator(asg):\n            if re.search(args.match_re, group.name):\n                group.manager._delete = \\\n                    _force_delete_rax_scaling_group(group.manager)\n                prompt_and_delete(group,\n                                  'Delete matching %s? [y/n]: ' % group,\n                                  args.assumeyes)\n\n\ndef main():\n    if not HAS_PYRAX:\n        raise SystemExit('The pyrax python module is required for this script')\n\n    args = parse_args()\n    authenticate()\n\n    funcs = [f for n, f in globals().items() if n.startswith('delete_rax')]\n    for func in sorted(funcs, key=lambda f: f.__name__):\n        try:\n            func(args)\n        except Exception as e:\n            print(\"---- %s failed (%s)\" % (func.__name__, e.message))\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except KeyboardInterrupt:\n        print('\\nExiting...')\n", "comments": "   function deleting cloudservers        print(     cleaning cloudservers matching       args match re)     search opts   dict(name       args match re)     region pyrax identity services compute regions          cs   pyrax connect cloudservers(region region)         servers   rax list iterator(cs servers  search opts search opts)         server servers              prompt delete(server                                 delete matching    n       server                                args assumeyes)   def delete rax clb(args)         function deleting cloud load balancers        print(     cleaning cloud load balancers matching       args match re)     region pyrax identity services load balancer regions          clb   pyrax connect cloud loadbalancers(region region)         lb rax list iterator(clb)              search(args match  lb name)                  prompt delete(lb                                     delete matching    n       lb                                    args assumeyes)   def delete rax keypair(args)         function deleting rackspace key pairs        print(     cleaning key pairs matching       args match re)     region pyrax identity services compute regions          cs   pyrax connect cloudservers(region region)         keypair cs keypairs list()              search(args match  keypair name)                  prompt delete(keypair                                     delete matching    n       keypair                                    args assumeyes)   def delete rax network(args)         function deleting cloud networks        print(     cleaning cloud networks matching       args match re)     region pyrax identity services network regions          cnw   pyrax connect cloud networks(region region)         network cnw list()              search(args match  network name)                  prompt delete(network                                     delete matching    n       network                                    args assumeyes)   def delete rax cbs(args)         function deleting cloud networks        print(     cleaning cloud block storage matching       args match re)     region pyrax identity services network regions          cbs   pyrax connect cloud blockstorage(region region)         volume cbs list()              search(args match  volume name)                  prompt delete(volume                                     delete matching    n       volume                                    args assumeyes)   def delete rax cdb(args)         function deleting cloud databases        print(     cleaning cloud databases matching       args match re)     region pyrax identity services database regions          cdb   pyrax connect cloud databases(region region)         db rax list iterator(cdb)              search(args match  db name)                  prompt delete(db                                     delete matching    n       db                                    args assumeyes)   def  force delete rax scaling group(manager)      def wrapped(uri)          manager api method delete(  force true    uri)     return wrapped   def delete rax scaling group(args)         function deleting autoscale groups        usr bin env python ", "content": "#!/usr/bin/env python\n\nimport os\nimport re\nimport yaml\nimport argparse\n\ntry:\n    import pyrax\n    HAS_PYRAX = True\nexcept ImportError:\n    HAS_PYRAX = False\n\nfrom ansible.module_utils.six.moves import input\n\n\ndef rax_list_iterator(svc, *args, **kwargs):\n    method = kwargs.pop('method', 'list')\n    items = getattr(svc, method)(*args, **kwargs)\n    while items:\n        retrieved = getattr(svc, method)(*args, marker=items[-1].id, **kwargs)\n        if items and retrieved and items[-1].id == retrieved[0].id:\n            del items[-1]\n        items.extend(retrieved)\n        if len(retrieved) < 2:\n            break\n    return items\n\n\ndef parse_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-y', '--yes', action='store_true', dest='assumeyes',\n                        default=False, help=\"Don't prompt for confirmation\")\n    parser.add_argument('--match', dest='match_re',\n                        default='^ansible-testing',\n                        help='Regular expression used to find resources '\n                             '(default: %(default)s)')\n\n    return parser.parse_args()\n\n\ndef authenticate():\n    try:\n        with open(os.path.realpath('./credentials.yml')) as f:\n            credentials = yaml.load(f)\n    except Exception as e:\n        raise SystemExit(e)\n\n    try:\n        pyrax.set_credentials(credentials.get('rackspace_username'),\n                              credentials.get('rackspace_api_key'))\n    except Exception as e:\n        raise SystemExit(e)\n\n\ndef prompt_and_delete(item, prompt, assumeyes):\n    if not assumeyes:\n        assumeyes = input(prompt).lower() == 'y'\n    assert hasattr(item, 'delete') or hasattr(item, 'terminate'), \\\n        \"Class <%s> has no delete or terminate attribute\" % item.__class__\n    if assumeyes:\n        if hasattr(item, 'delete'):\n            item.delete()\n            print(\"Deleted %s\" % item)\n        if hasattr(item, 'terminate'):\n            item.terminate()\n            print(\"Terminated %s\" % item)\n\n\ndef delete_rax(args):\n    \"\"\"Function for deleting CloudServers\"\"\"\n    print(\"--- Cleaning CloudServers matching '%s'\" % args.match_re)\n    search_opts = dict(name='^%s' % args.match_re)\n    for region in pyrax.identity.services.compute.regions:\n        cs = pyrax.connect_to_cloudservers(region=region)\n        servers = rax_list_iterator(cs.servers, search_opts=search_opts)\n        for server in servers:\n            prompt_and_delete(server,\n                              'Delete matching %s? [y/n]: ' % server,\n                              args.assumeyes)\n\n\ndef delete_rax_clb(args):\n    \"\"\"Function for deleting Cloud Load Balancers\"\"\"\n    print(\"--- Cleaning Cloud Load Balancers matching '%s'\" % args.match_re)\n    for region in pyrax.identity.services.load_balancer.regions:\n        clb = pyrax.connect_to_cloud_loadbalancers(region=region)\n        for lb in rax_list_iterator(clb):\n            if re.search(args.match_re, lb.name):\n                prompt_and_delete(lb,\n                                  'Delete matching %s? [y/n]: ' % lb,\n                                  args.assumeyes)\n\n\ndef delete_rax_keypair(args):\n    \"\"\"Function for deleting Rackspace Key pairs\"\"\"\n    print(\"--- Cleaning Key Pairs matching '%s'\" % args.match_re)\n    for region in pyrax.identity.services.compute.regions:\n        cs = pyrax.connect_to_cloudservers(region=region)\n        for keypair in cs.keypairs.list():\n            if re.search(args.match_re, keypair.name):\n                prompt_and_delete(keypair,\n                                  'Delete matching %s? [y/n]: ' % keypair,\n                                  args.assumeyes)\n\n\ndef delete_rax_network(args):\n    \"\"\"Function for deleting Cloud Networks\"\"\"\n    print(\"--- Cleaning Cloud Networks matching '%s'\" % args.match_re)\n    for region in pyrax.identity.services.network.regions:\n        cnw = pyrax.connect_to_cloud_networks(region=region)\n        for network in cnw.list():\n            if re.search(args.match_re, network.name):\n                prompt_and_delete(network,\n                                  'Delete matching %s? [y/n]: ' % network,\n                                  args.assumeyes)\n\n\ndef delete_rax_cbs(args):\n    \"\"\"Function for deleting Cloud Networks\"\"\"\n    print(\"--- Cleaning Cloud Block Storage matching '%s'\" % args.match_re)\n    for region in pyrax.identity.services.network.regions:\n        cbs = pyrax.connect_to_cloud_blockstorage(region=region)\n        for volume in cbs.list():\n            if re.search(args.match_re, volume.name):\n                prompt_and_delete(volume,\n                                  'Delete matching %s? [y/n]: ' % volume,\n                                  args.assumeyes)\n\n\ndef delete_rax_cdb(args):\n    \"\"\"Function for deleting Cloud Databases\"\"\"\n    print(\"--- Cleaning Cloud Databases matching '%s'\" % args.match_re)\n    for region in pyrax.identity.services.database.regions:\n        cdb = pyrax.connect_to_cloud_databases(region=region)\n        for db in rax_list_iterator(cdb):\n            if re.search(args.match_re, db.name):\n                prompt_and_delete(db,\n                                  'Delete matching %s? [y/n]: ' % db,\n                                  args.assumeyes)\n\n\ndef _force_delete_rax_scaling_group(manager):\n    def wrapped(uri):\n        manager.api.method_delete('%s?force=true' % uri)\n    return wrapped\n\n\ndef delete_rax_scaling_group(args):\n    \"\"\"Function for deleting Autoscale Groups\"\"\"\n    print(\"--- Cleaning Autoscale Groups matching '%s'\" % args.match_re)\n    for region in pyrax.identity.services.autoscale.regions:\n        asg = pyrax.connect_to_autoscale(region=region)\n        for group in rax_list_iterator(asg):\n            if re.search(args.match_re, group.name):\n                group.manager._delete = \\\n                    _force_delete_rax_scaling_group(group.manager)\n                prompt_and_delete(group,\n                                  'Delete matching %s? [y/n]: ' % group,\n                                  args.assumeyes)\n\n\ndef main():\n    if not HAS_PYRAX:\n        raise SystemExit('The pyrax python module is required for this script')\n\n    args = parse_args()\n    authenticate()\n\n    funcs = [f for n, f in globals().items() if n.startswith('delete_rax')]\n    for func in sorted(funcs, key=lambda f: f.__name__):\n        try:\n            func(args)\n        except Exception as e:\n            print(\"---- %s failed (%s)\" % (func.__name__, e.message))\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except KeyboardInterrupt:\n        print('\\nExiting...')\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "cleanup_rax.py", "id": "b0383906c1d18178212ffa435df1d6aa", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/test/legacy/cleanup_rax.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}