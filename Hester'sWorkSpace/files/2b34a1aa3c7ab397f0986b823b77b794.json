{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport itertools\nimport re\nimport random\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_HTTPError,\n    compat_parse_qs,\n    compat_str,\n    compat_urllib_parse_urlencode,\n    compat_urllib_parse_urlparse,\n)\nfrom ..utils import (\n    clean_html,\n    ExtractorError,\n    int_or_none,\n    js_to_json,\n    orderedSet,\n    parse_duration,\n    parse_iso8601,\n    update_url_query,\n    urlencode_postdata,\n    urljoin,\n)\n\n\nclass TwitchBaseIE(InfoExtractor):\n    _VALID_URL_BASE = r'https?://(?:(?:www|go)\\.)?twitch\\.tv'\n\n    _API_BASE = 'https://api.twitch.tv'\n    _USHER_BASE = 'https://usher.ttvnw.net'\n    _LOGIN_URL = 'https://www.twitch.tv/login'\n    _CLIENT_ID = 'jzkbprff40iqj646a697cyrvl0zt2m6'\n    _NETRC_MACHINE = 'twitch'\n\n    def _handle_error(self, response):\n        if not isinstance(response, dict):\n            return\n        error = response.get('error')\n        if error:\n            raise ExtractorError(\n                '%s returned error: %s - %s' % (self.IE_NAME, error, response.get('message')),\n                expected=True)\n\n    def _call_api(self, path, item_id, note):\n        response = self._download_json(\n            '%s/%s' % (self._API_BASE, path), item_id, note,\n            headers={'Client-ID': self._CLIENT_ID})\n        self._handle_error(response)\n        return response\n\n    def _real_initialize(self):\n        self._login()\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n\n        def fail(message):\n            raise ExtractorError(\n                'Unable to login. Twitch said: %s' % message, expected=True)\n\n        def login_step(page, urlh, note, data):\n            form = self._hidden_inputs(page)\n            form.update(data)\n\n            page_url = urlh.geturl()\n            post_url = self._search_regex(\n                r'<form[^>]+action=([\"\\'])(?P<url>.+?)\\1', page,\n                'post url', default=page_url, group='url')\n            post_url = urljoin(page_url, post_url)\n\n            headers = {'Referer': page_url}\n\n            try:\n                response = self._download_json(\n                    post_url, None, note,\n                    data=urlencode_postdata(form),\n                    headers=headers)\n            except ExtractorError as e:\n                if isinstance(e.cause, compat_HTTPError) and e.cause.code == 400:\n                    response = self._parse_json(\n                        e.cause.read().decode('utf-8'), None)\n                    fail(response.get('message') or response['errors'][0])\n                raise\n\n            if 'Authenticated successfully' in response.get('message', ''):\n                return None, None\n\n            redirect_url = urljoin(\n                post_url,\n                response.get('redirect') or response['redirect_path'])\n            return self._download_webpage_handle(\n                redirect_url, None, 'Downloading login redirect page',\n                headers=headers)\n\n        login_page, handle = self._download_webpage_handle(\n            self._LOGIN_URL, None, 'Downloading login page')\n\n        \n        if 'blacklist_message' in login_page:\n            fail(clean_html(login_page))\n\n        redirect_page, handle = login_step(\n            login_page, handle, 'Logging in', {\n                'username': username,\n                'password': password,\n            })\n\n        \n        if not redirect_page:\n            return\n\n        if re.search(r'(?i)<form[^>]+id=\"two-factor-submit\"', redirect_page) is not None:\n            \n            tfa_token = self._get_tfa_info('two-factor authentication token')\n            login_step(redirect_page, handle, 'Submitting TFA token', {\n                'authy_token': tfa_token,\n                'remember_2fa': 'true',\n            })\n\n    def _prefer_source(self, formats):\n        try:\n            source = next(f for f in formats if f['format_id'] == 'Source')\n            source['preference'] = 10\n        except StopIteration:\n            pass  \n        self._sort_formats(formats)\n\n\nclass TwitchItemBaseIE(TwitchBaseIE):\n    def _download_info(self, item, item_id):\n        return self._extract_info(self._call_api(\n            'kraken/videos/%s%s' % (item, item_id), item_id,\n            'Downloading %s info JSON' % self._ITEM_TYPE))\n\n    def _extract_media(self, item_id):\n        info = self._download_info(self._ITEM_SHORTCUT, item_id)\n        response = self._call_api(\n            'api/videos/%s%s' % (self._ITEM_SHORTCUT, item_id), item_id,\n            'Downloading %s playlist JSON' % self._ITEM_TYPE)\n        entries = []\n        chunks = response['chunks']\n        qualities = list(chunks.keys())\n        for num, fragment in enumerate(zip(*chunks.values()), start=1):\n            formats = []\n            for fmt_num, fragment_fmt in enumerate(fragment):\n                format_id = qualities[fmt_num]\n                fmt = {\n                    'url': fragment_fmt['url'],\n                    'format_id': format_id,\n                    'quality': 1 if format_id == 'live' else 0,\n                }\n                m = re.search(r'^(?P<height>\\d+)[Pp]', format_id)\n                if m:\n                    fmt['height'] = int(m.group('height'))\n                formats.append(fmt)\n            self._sort_formats(formats)\n            entry = dict(info)\n            entry['id'] = '%s_%d' % (entry['id'], num)\n            entry['title'] = '%s part %d' % (entry['title'], num)\n            entry['formats'] = formats\n            entries.append(entry)\n        return self.playlist_result(entries, info['id'], info['title'])\n\n    def _extract_info(self, info):\n        return {\n            'id': info['_id'],\n            'title': info.get('title') or 'Untitled Broadcast',\n            'description': info.get('description'),\n            'duration': int_or_none(info.get('length')),\n            'thumbnail': info.get('preview'),\n            'uploader': info.get('channel', {}).get('display_name'),\n            'uploader_id': info.get('channel', {}).get('name'),\n            'timestamp': parse_iso8601(info.get('recorded_at')),\n            'view_count': int_or_none(info.get('views')),\n        }\n\n    def _real_extract(self, url):\n        return self._extract_media(self._match_id(url))\n\n\nclass TwitchVideoIE(TwitchItemBaseIE):\n    IE_NAME = 'twitch:video'\n    _VALID_URL = r'%s/[^/]+/b/(?P<id>\\d+)' % TwitchBaseIE._VALID_URL_BASE\n    _ITEM_TYPE = 'video'\n    _ITEM_SHORTCUT = 'a'\n\n    _TEST = {\n        'url': 'http://www.twitch.tv/riotgames/b/577357806',\n        'info_dict': {\n            'id': 'a577357806',\n            'title': 'Worlds Semifinals - Star Horn Royal Club vs. OMG',\n        },\n        'playlist_mincount': 12,\n        'skip': 'HTTP Error 404: Not Found',\n    }\n\n\nclass TwitchChapterIE(TwitchItemBaseIE):\n    IE_NAME = 'twitch:chapter'\n    _VALID_URL = r'%s/[^/]+/c/(?P<id>\\d+)' % TwitchBaseIE._VALID_URL_BASE\n    _ITEM_TYPE = 'chapter'\n    _ITEM_SHORTCUT = 'c'\n\n    _TESTS = [{\n        'url': 'http://www.twitch.tv/acracingleague/c/5285812',\n        'info_dict': {\n            'id': 'c5285812',\n            'title': 'ACRL Off Season - Sports Cars @ Nordschleife',\n        },\n        'playlist_mincount': 3,\n        'skip': 'HTTP Error 404: Not Found',\n    }, {\n        'url': 'http://www.twitch.tv/tsm_theoddone/c/2349361',\n        'only_matching': True,\n    }]\n\n\nclass TwitchVodIE(TwitchItemBaseIE):\n    IE_NAME = 'twitch:vod'\n    _VALID_URL = r\n\n    _TESTS = [{\n        'url': 'http://www.twitch.tv/shroomztv',\n        'info_dict': {\n            'id': '12772022048',\n            'display_id': 'shroomztv',\n            'ext': 'mp4',\n            'title': 're:^ShroomzTV [0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}$',\n            'description': 'H1Z1 - lonewolfing with ShroomzTV | A3 Battle Royale later - @ShroomzTV',\n            'is_live': True,\n            'timestamp': 1421928037,\n            'upload_date': '20150122',\n            'uploader': 'ShroomzTV',\n            'uploader_id': 'shroomztv',\n            'view_count': int,\n        },\n        'params': {\n            \n            'skip_download': True,\n        },\n    }, {\n        'url': 'http://www.twitch.tv/miracle_doto\n        'only_matching': True,\n    }, {\n        'url': 'https://player.twitch.tv/?channel=lotsofs',\n        'only_matching': True,\n    }, {\n        'url': 'https://go.twitch.tv/food',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return (False\n                if any(ie.suitable(url) for ie in (\n                    TwitchVideoIE,\n                    TwitchChapterIE,\n                    TwitchVodIE,\n                    TwitchProfileIE,\n                    TwitchAllVideosIE,\n                    TwitchUploadsIE,\n                    TwitchPastBroadcastsIE,\n                    TwitchHighlightsIE))\n                else super(TwitchStreamIE, cls).suitable(url))\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        stream = self._call_api(\n            'kraken/streams/%s?stream_type=all' % channel_id, channel_id,\n            'Downloading stream JSON').get('stream')\n\n        if not stream:\n            raise ExtractorError('%s is offline' % channel_id, expected=True)\n\n        \n        \n        \n        \n        channel_id = stream.get('channel', {}).get('name') or channel_id.lower()\n\n        access_token = self._call_api(\n            'api/channels/%s/access_token' % channel_id, channel_id,\n            'Downloading channel access token')\n\n        query = {\n            'allow_source': 'true',\n            'allow_audio_only': 'true',\n            'allow_spectre': 'true',\n            'p': random.randint(1000000, 10000000),\n            'player': 'twitchweb',\n            'segment_preference': '4',\n            'sig': access_token['sig'].encode('utf-8'),\n            'token': access_token['token'].encode('utf-8'),\n        }\n        formats = self._extract_m3u8_formats(\n            '%s/api/channel/hls/%s.m3u8?%s'\n            % (self._USHER_BASE, channel_id, compat_urllib_parse_urlencode(query)),\n            channel_id, 'mp4')\n        self._prefer_source(formats)\n\n        view_count = stream.get('viewers')\n        timestamp = parse_iso8601(stream.get('created_at'))\n\n        channel = stream['channel']\n        title = self._live_title(channel.get('display_name') or channel.get('name'))\n        description = channel.get('status')\n\n        thumbnails = []\n        for thumbnail_key, thumbnail_url in stream['preview'].items():\n            m = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)\\.jpg$', thumbnail_key)\n            if not m:\n                continue\n            thumbnails.append({\n                'url': thumbnail_url,\n                'width': int(m.group('width')),\n                'height': int(m.group('height')),\n            })\n\n        return {\n            'id': compat_str(stream['_id']),\n            'display_id': channel_id,\n            'title': title,\n            'description': description,\n            'thumbnails': thumbnails,\n            'uploader': channel.get('display_name'),\n            'uploader_id': channel.get('name'),\n            'timestamp': timestamp,\n            'view_count': view_count,\n            'formats': formats,\n            'is_live': True,\n        }\n\n\nclass TwitchClipsIE(InfoExtractor):\n    IE_NAME = 'twitch:clips'\n    _VALID_URL = r'https?://clips\\.twitch\\.tv/(?:[^/]+/)*(?P<id>[^/?\n\n    _TESTS = [{\n        'url': 'https://clips.twitch.tv/ea/AggressiveCobraPoooound',\n        'md5': '761769e1eafce0ffebfb4089cb3847cd',\n        'info_dict': {\n            'id': 'AggressiveCobraPoooound',\n            'ext': 'mp4',\n            'title': 'EA Play 2016 Live from the Novo Theatre',\n            'thumbnail': r're:^https?://.*\\.jpg',\n            'creator': 'EA',\n            'uploader': 'stereotype_',\n            'uploader_id': 'stereotype_',\n        },\n    }, {\n        \n        'url': 'https://clips.twitch.tv/rflegendary/UninterestedBeeDAESuppy',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id)\n\n        clip = self._parse_json(\n            self._search_regex(\n                r'(?s)clipInfo\\s*=\\s*({.+?});', webpage, 'clip info'),\n            video_id, transform_source=js_to_json)\n\n        title = clip.get('title') or clip.get('channel_title') or self._og_search_title(webpage)\n\n        formats = [{\n            'url': option['source'],\n            'format_id': option.get('quality'),\n            'height': int_or_none(option.get('quality')),\n        } for option in clip.get('quality_options', []) if option.get('source')]\n\n        if not formats:\n            formats = [{\n                'url': clip['clip_video_url'],\n            }]\n\n        self._sort_formats(formats)\n\n        return {\n            'id': video_id,\n            'title': title,\n            'thumbnail': self._og_search_thumbnail(webpage),\n            'creator': clip.get('broadcaster_display_name') or clip.get('broadcaster_login'),\n            'uploader': clip.get('curator_login'),\n            'uploader_id': clip.get('curator_display_name'),\n            'formats': formats,\n        }\n", "comments": "(?x)\n                    https?://\n                        (?:\n                            (?:(?:www|go)\\.)?twitch\\.tv/(?:[^/]+/v|videos)/|\n                            player\\.twitch\\.tv/\\?.*?\\bvideo=v\n                        )\n                        (?P<id>\\d+)\n                    '''\n    _ITEM_TYPE = 'vod'\n    _ITEM_SHORTCUT = 'v'\n\n    _TESTS = [{\n        'url': 'http://www.twitch.tv/riotgames/v/6528877?t=5m10s',\n        'info_dict': {\n            'id': 'v6528877',\n            'ext': 'mp4',\n            'title': 'LCK Summer Split - Week 6 Day 1',\n            'thumbnail': r're:^https?://.*\\.jpg$',\n            'duration': 17208,\n            'timestamp': 1435131709,\n            'upload_date': '20150624',\n            'uploader': 'Riot Games',\n            'uploader_id': 'riotgames',\n            'view_count': int,\n            'start_time': 310,\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n    }, {\n        # Untitled broadcast (title is None)\n        'url': 'http://www.twitch.tv/belkao_o/v/11230755',\n        'info_dict': {\n            'id': 'v11230755',\n            'ext': 'mp4',\n            'title': 'Untitled Broadcast',\n            'thumbnail': r're:^https?://.*\\.jpg$',\n            'duration': 1638,\n            'timestamp': 1439746708,\n            'upload_date': '20150816',\n            'uploader': 'BelkAO_o',\n            'uploader_id': 'belkao_o',\n            'view_count': int,\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n        'skip': 'HTTP Error 404: Not Found',\n    }, {\n        'url': 'http://player.twitch.tv/?t=5m10s&video=v6528877',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.twitch.tv/videos/6528877',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        item_id = self._match_id(url)\n\n        info = self._download_info(self._ITEM_SHORTCUT, item_id)\n        access_token = self._call_api(\n            'api/vods/%s/access_token' % item_id, item_id,\n            'Downloading %s access token' % self._ITEM_TYPE)\n\n        formats = self._extract_m3u8_formats(\n            '%s/vod/%s?%s' % (\n                self._USHER_BASE, item_id,\n                compat_urllib_parse_urlencode({\n                    'allow_source': 'true',\n                    'allow_audio_only': 'true',\n                    'allow_spectre': 'true',\n                    'player': 'twitchweb',\n                    'nauth': access_token['token'],\n                    'nauthsig': access_token['sig'],\n                })),\n            item_id, 'mp4', entry_protocol='m3u8_native')\n\n        self._prefer_source(formats)\n        info['formats'] = formats\n\n        parsed_url = compat_urllib_parse_urlparse(url)\n        query = compat_parse_qs(parsed_url.query)\n        if 't' in query:\n            info['start_time'] = parse_duration(query['t'][0])\n\n        if info.get('timestamp') is not None:\n            info['subtitles'] = {\n                'rechat': [{\n                    'url': update_url_query(\n                        'https://rechat.twitch.tv/rechat-messages', {\n                            'video_id': 'v%s' % item_id,\n                            'start': info['timestamp'],\n                        }),\n                    'ext': 'json',\n                }],\n            }\n\n        return info\n\n\nclass TwitchPlaylistBaseIE(TwitchBaseIE):\n    _PLAYLIST_PATH = 'kraken/channels/%s/videos/?offset=%d&limit=%d'\n    _PAGE_LIMIT = 100\n\n    def _extract_playlist(self, channel_id):\n        info = self._call_api(\n            'kraken/channels/%s' % channel_id,\n            channel_id, 'Downloading channel info JSON')\n        channel_name = info.get('display_name') or info.get('name')\n        entries = []\n        offset = 0\n        limit = self._PAGE_LIMIT\n        broken_paging_detected = False\n        counter_override = None\n        for counter in itertools.count(1):\n            response = self._call_api(\n                self._PLAYLIST_PATH % (channel_id, offset, limit),\n                channel_id,\n                'Downloading %s JSON page %s'\n                % (self._PLAYLIST_TYPE, counter_override or counter))\n            page_entries = self._extract_playlist_page(response)\n            if not page_entries:\n                break\n            total = int_or_none(response.get('_total'))\n            # Since the beginning of March 2016 twitch's paging mechanism\n            # is completely broken on the twitch side. It simply ignores\n            # a limit and returns the whole offset number of videos.\n            # Working around by just requesting all videos at once.\n            # Upd: pagination bug was fixed by twitch on 15.03.2016.\n            if not broken_paging_detected and total and len(page_entries) > limit:\n                self.report_warning(\n                    'Twitch pagination is broken on twitch side, requesting all videos at once',\n                    channel_id)\n                broken_paging_detected = True\n                offset = total\n                counter_override = '(all at once)'\n                continue\n            entries.extend(page_entries)\n            if broken_paging_detected or total and len(page_entries) >= total:\n                break\n            offset += limit\n        return self.playlist_result(\n            [self._make_url_result(entry) for entry in orderedSet(entries)],\n            channel_id, channel_name)\n\n    def _make_url_result(self, url):\n        try:\n            video_id = 'v%s' % TwitchVodIE._match_id(url)\n            return self.url_result(url, TwitchVodIE.ie_key(), video_id=video_id)\n        except AssertionError:\n            return self.url_result(url)\n\n    def _extract_playlist_page(self, response):\n        videos = response.get('videos')\n        return [video['url'] for video in videos] if videos else []\n\n    def _real_extract(self, url):\n        return self._extract_playlist(self._match_id(url))\n\n\nclass TwitchProfileIE(TwitchPlaylistBaseIE):\n    IE_NAME = 'twitch:profile'\n    _VALID_URL = r'%s/(?P<id>[^/]+)/profile/?(?:\\#.*)?$' % TwitchBaseIE._VALID_URL_BASE\n    _PLAYLIST_TYPE = 'profile'\n\n    _TEST = {\n        'url': 'http://www.twitch.tv/vanillatv/profile',\n        'info_dict': {\n            'id': 'vanillatv',\n            'title': 'VanillaTV',\n        },\n        'playlist_mincount': 412,\n    }\n\n\nclass TwitchVideosBaseIE(TwitchPlaylistBaseIE):\n    _VALID_URL_VIDEOS_BASE = r'%s/(?P<id>[^/]+)/videos' % TwitchBaseIE._VALID_URL_BASE\n    _PLAYLIST_PATH = TwitchPlaylistBaseIE._PLAYLIST_PATH + '&broadcast_type='\n\n\nclass TwitchAllVideosIE(TwitchVideosBaseIE):\n    IE_NAME = 'twitch:videos:all'\n    _VALID_URL = r'%s/all' % TwitchVideosBaseIE._VALID_URL_VIDEOS_BASE\n    _PLAYLIST_PATH = TwitchVideosBaseIE._PLAYLIST_PATH + 'archive,upload,highlight'\n    _PLAYLIST_TYPE = 'all videos'\n\n    _TEST = {\n        'url': 'https://www.twitch.tv/spamfish/videos/all',\n        'info_dict': {\n            'id': 'spamfish',\n            'title': 'Spamfish',\n        },\n        'playlist_mincount': 869,\n    }\n\n\nclass TwitchUploadsIE(TwitchVideosBaseIE):\n    IE_NAME = 'twitch:videos:uploads'\n    _VALID_URL = r'%s/uploads' % TwitchVideosBaseIE._VALID_URL_VIDEOS_BASE\n    _PLAYLIST_PATH = TwitchVideosBaseIE._PLAYLIST_PATH + 'upload'\n    _PLAYLIST_TYPE = 'uploads'\n\n    _TEST = {\n        'url': 'https://www.twitch.tv/spamfish/videos/uploads',\n        'info_dict': {\n            'id': 'spamfish',\n            'title': 'Spamfish',\n        },\n        'playlist_mincount': 0,\n    }\n\n\nclass TwitchPastBroadcastsIE(TwitchVideosBaseIE):\n    IE_NAME = 'twitch:videos:past-broadcasts'\n    _VALID_URL = r'%s/past-broadcasts' % TwitchVideosBaseIE._VALID_URL_VIDEOS_BASE\n    _PLAYLIST_PATH = TwitchVideosBaseIE._PLAYLIST_PATH + 'archive'\n    _PLAYLIST_TYPE = 'past broadcasts'\n\n    _TEST = {\n        'url': 'https://www.twitch.tv/spamfish/videos/past-broadcasts',\n        'info_dict': {\n            'id': 'spamfish',\n            'title': 'Spamfish',\n        },\n        'playlist_mincount': 0,\n    }\n\n\nclass TwitchHighlightsIE(TwitchVideosBaseIE):\n    IE_NAME = 'twitch:videos:highlights'\n    _VALID_URL = r'%s/highlights' % TwitchVideosBaseIE._VALID_URL_VIDEOS_BASE\n    _PLAYLIST_PATH = TwitchVideosBaseIE._PLAYLIST_PATH + 'highlight'\n    _PLAYLIST_TYPE = 'highlights'\n\n    _TEST = {\n        'url': 'https://www.twitch.tv/spamfish/videos/highlights',\n        'info_dict': {\n            'id': 'spamfish',\n            'title': 'Spamfish',\n        },\n        'playlist_mincount': 805,\n    }\n\n\nclass TwitchStreamIE(TwitchBaseIE):\n    IE_NAME = 'twitch:stream'\n    _VALID_URL = r'''(?x)\n                    https?://\n                        (?:\n                            (?:(?:www|go)\\.)?twitch\\.tv/|\n                            player\\.twitch\\.tv/\\?.*?\\bchannel=\n                        )\n                        (?P<id>[^/#?]+)\n                    \n \n# coding: utf-8\n# Some TOR nodes and public proxies are blocked completely\n# Successful login\n# TODO: Add mechanism to request an SMS or phone call\n# No Source stream present\n# m3u8 download\n#profile-0',\n# Channel name may be typed if different case than the original channel name\n# (e.g. http://www.twitch.tv/TWITCHPLAYSPOKEMON) that will lead to constructing\n# an invalid m3u8 URL. Working around by use of original channel name from stream\n# JSON and fallback to lowercase if it's not available.\n#&]+)'\n# multiple formats\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport itertools\nimport re\nimport random\n\nfrom .common import InfoExtractor\nfrom ..compat import (\n    compat_HTTPError,\n    compat_parse_qs,\n    compat_str,\n    compat_urllib_parse_urlencode,\n    compat_urllib_parse_urlparse,\n)\nfrom ..utils import (\n    clean_html,\n    ExtractorError,\n    int_or_none,\n    js_to_json,\n    orderedSet,\n    parse_duration,\n    parse_iso8601,\n    update_url_query,\n    urlencode_postdata,\n    urljoin,\n)\n\n\nclass TwitchBaseIE(InfoExtractor):\n    _VALID_URL_BASE = r'https?://(?:(?:www|go)\\.)?twitch\\.tv'\n\n    _API_BASE = 'https://api.twitch.tv'\n    _USHER_BASE = 'https://usher.ttvnw.net'\n    _LOGIN_URL = 'https://www.twitch.tv/login'\n    _CLIENT_ID = 'jzkbprff40iqj646a697cyrvl0zt2m6'\n    _NETRC_MACHINE = 'twitch'\n\n    def _handle_error(self, response):\n        if not isinstance(response, dict):\n            return\n        error = response.get('error')\n        if error:\n            raise ExtractorError(\n                '%s returned error: %s - %s' % (self.IE_NAME, error, response.get('message')),\n                expected=True)\n\n    def _call_api(self, path, item_id, note):\n        response = self._download_json(\n            '%s/%s' % (self._API_BASE, path), item_id, note,\n            headers={'Client-ID': self._CLIENT_ID})\n        self._handle_error(response)\n        return response\n\n    def _real_initialize(self):\n        self._login()\n\n    def _login(self):\n        (username, password) = self._get_login_info()\n        if username is None:\n            return\n\n        def fail(message):\n            raise ExtractorError(\n                'Unable to login. Twitch said: %s' % message, expected=True)\n\n        def login_step(page, urlh, note, data):\n            form = self._hidden_inputs(page)\n            form.update(data)\n\n            page_url = urlh.geturl()\n            post_url = self._search_regex(\n                r'<form[^>]+action=([\"\\'])(?P<url>.+?)\\1', page,\n                'post url', default=page_url, group='url')\n            post_url = urljoin(page_url, post_url)\n\n            headers = {'Referer': page_url}\n\n            try:\n                response = self._download_json(\n                    post_url, None, note,\n                    data=urlencode_postdata(form),\n                    headers=headers)\n            except ExtractorError as e:\n                if isinstance(e.cause, compat_HTTPError) and e.cause.code == 400:\n                    response = self._parse_json(\n                        e.cause.read().decode('utf-8'), None)\n                    fail(response.get('message') or response['errors'][0])\n                raise\n\n            if 'Authenticated successfully' in response.get('message', ''):\n                return None, None\n\n            redirect_url = urljoin(\n                post_url,\n                response.get('redirect') or response['redirect_path'])\n            return self._download_webpage_handle(\n                redirect_url, None, 'Downloading login redirect page',\n                headers=headers)\n\n        login_page, handle = self._download_webpage_handle(\n            self._LOGIN_URL, None, 'Downloading login page')\n\n        # Some TOR nodes and public proxies are blocked completely\n        if 'blacklist_message' in login_page:\n            fail(clean_html(login_page))\n\n        redirect_page, handle = login_step(\n            login_page, handle, 'Logging in', {\n                'username': username,\n                'password': password,\n            })\n\n        # Successful login\n        if not redirect_page:\n            return\n\n        if re.search(r'(?i)<form[^>]+id=\"two-factor-submit\"', redirect_page) is not None:\n            # TODO: Add mechanism to request an SMS or phone call\n            tfa_token = self._get_tfa_info('two-factor authentication token')\n            login_step(redirect_page, handle, 'Submitting TFA token', {\n                'authy_token': tfa_token,\n                'remember_2fa': 'true',\n            })\n\n    def _prefer_source(self, formats):\n        try:\n            source = next(f for f in formats if f['format_id'] == 'Source')\n            source['preference'] = 10\n        except StopIteration:\n            pass  # No Source stream present\n        self._sort_formats(formats)\n\n\nclass TwitchItemBaseIE(TwitchBaseIE):\n    def _download_info(self, item, item_id):\n        return self._extract_info(self._call_api(\n            'kraken/videos/%s%s' % (item, item_id), item_id,\n            'Downloading %s info JSON' % self._ITEM_TYPE))\n\n    def _extract_media(self, item_id):\n        info = self._download_info(self._ITEM_SHORTCUT, item_id)\n        response = self._call_api(\n            'api/videos/%s%s' % (self._ITEM_SHORTCUT, item_id), item_id,\n            'Downloading %s playlist JSON' % self._ITEM_TYPE)\n        entries = []\n        chunks = response['chunks']\n        qualities = list(chunks.keys())\n        for num, fragment in enumerate(zip(*chunks.values()), start=1):\n            formats = []\n            for fmt_num, fragment_fmt in enumerate(fragment):\n                format_id = qualities[fmt_num]\n                fmt = {\n                    'url': fragment_fmt['url'],\n                    'format_id': format_id,\n                    'quality': 1 if format_id == 'live' else 0,\n                }\n                m = re.search(r'^(?P<height>\\d+)[Pp]', format_id)\n                if m:\n                    fmt['height'] = int(m.group('height'))\n                formats.append(fmt)\n            self._sort_formats(formats)\n            entry = dict(info)\n            entry['id'] = '%s_%d' % (entry['id'], num)\n            entry['title'] = '%s part %d' % (entry['title'], num)\n            entry['formats'] = formats\n            entries.append(entry)\n        return self.playlist_result(entries, info['id'], info['title'])\n\n    def _extract_info(self, info):\n        return {\n            'id': info['_id'],\n            'title': info.get('title') or 'Untitled Broadcast',\n            'description': info.get('description'),\n            'duration': int_or_none(info.get('length')),\n            'thumbnail': info.get('preview'),\n            'uploader': info.get('channel', {}).get('display_name'),\n            'uploader_id': info.get('channel', {}).get('name'),\n            'timestamp': parse_iso8601(info.get('recorded_at')),\n            'view_count': int_or_none(info.get('views')),\n        }\n\n    def _real_extract(self, url):\n        return self._extract_media(self._match_id(url))\n\n\nclass TwitchVideoIE(TwitchItemBaseIE):\n    IE_NAME = 'twitch:video'\n    _VALID_URL = r'%s/[^/]+/b/(?P<id>\\d+)' % TwitchBaseIE._VALID_URL_BASE\n    _ITEM_TYPE = 'video'\n    _ITEM_SHORTCUT = 'a'\n\n    _TEST = {\n        'url': 'http://www.twitch.tv/riotgames/b/577357806',\n        'info_dict': {\n            'id': 'a577357806',\n            'title': 'Worlds Semifinals - Star Horn Royal Club vs. OMG',\n        },\n        'playlist_mincount': 12,\n        'skip': 'HTTP Error 404: Not Found',\n    }\n\n\nclass TwitchChapterIE(TwitchItemBaseIE):\n    IE_NAME = 'twitch:chapter'\n    _VALID_URL = r'%s/[^/]+/c/(?P<id>\\d+)' % TwitchBaseIE._VALID_URL_BASE\n    _ITEM_TYPE = 'chapter'\n    _ITEM_SHORTCUT = 'c'\n\n    _TESTS = [{\n        'url': 'http://www.twitch.tv/acracingleague/c/5285812',\n        'info_dict': {\n            'id': 'c5285812',\n            'title': 'ACRL Off Season - Sports Cars @ Nordschleife',\n        },\n        'playlist_mincount': 3,\n        'skip': 'HTTP Error 404: Not Found',\n    }, {\n        'url': 'http://www.twitch.tv/tsm_theoddone/c/2349361',\n        'only_matching': True,\n    }]\n\n\nclass TwitchVodIE(TwitchItemBaseIE):\n    IE_NAME = 'twitch:vod'\n    _VALID_URL = r'''(?x)\n                    https?://\n                        (?:\n                            (?:(?:www|go)\\.)?twitch\\.tv/(?:[^/]+/v|videos)/|\n                            player\\.twitch\\.tv/\\?.*?\\bvideo=v\n                        )\n                        (?P<id>\\d+)\n                    '''\n    _ITEM_TYPE = 'vod'\n    _ITEM_SHORTCUT = 'v'\n\n    _TESTS = [{\n        'url': 'http://www.twitch.tv/riotgames/v/6528877?t=5m10s',\n        'info_dict': {\n            'id': 'v6528877',\n            'ext': 'mp4',\n            'title': 'LCK Summer Split - Week 6 Day 1',\n            'thumbnail': r're:^https?://.*\\.jpg$',\n            'duration': 17208,\n            'timestamp': 1435131709,\n            'upload_date': '20150624',\n            'uploader': 'Riot Games',\n            'uploader_id': 'riotgames',\n            'view_count': int,\n            'start_time': 310,\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n    }, {\n        # Untitled broadcast (title is None)\n        'url': 'http://www.twitch.tv/belkao_o/v/11230755',\n        'info_dict': {\n            'id': 'v11230755',\n            'ext': 'mp4',\n            'title': 'Untitled Broadcast',\n            'thumbnail': r're:^https?://.*\\.jpg$',\n            'duration': 1638,\n            'timestamp': 1439746708,\n            'upload_date': '20150816',\n            'uploader': 'BelkAO_o',\n            'uploader_id': 'belkao_o',\n            'view_count': int,\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n        'skip': 'HTTP Error 404: Not Found',\n    }, {\n        'url': 'http://player.twitch.tv/?t=5m10s&video=v6528877',\n        'only_matching': True,\n    }, {\n        'url': 'https://www.twitch.tv/videos/6528877',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        item_id = self._match_id(url)\n\n        info = self._download_info(self._ITEM_SHORTCUT, item_id)\n        access_token = self._call_api(\n            'api/vods/%s/access_token' % item_id, item_id,\n            'Downloading %s access token' % self._ITEM_TYPE)\n\n        formats = self._extract_m3u8_formats(\n            '%s/vod/%s?%s' % (\n                self._USHER_BASE, item_id,\n                compat_urllib_parse_urlencode({\n                    'allow_source': 'true',\n                    'allow_audio_only': 'true',\n                    'allow_spectre': 'true',\n                    'player': 'twitchweb',\n                    'nauth': access_token['token'],\n                    'nauthsig': access_token['sig'],\n                })),\n            item_id, 'mp4', entry_protocol='m3u8_native')\n\n        self._prefer_source(formats)\n        info['formats'] = formats\n\n        parsed_url = compat_urllib_parse_urlparse(url)\n        query = compat_parse_qs(parsed_url.query)\n        if 't' in query:\n            info['start_time'] = parse_duration(query['t'][0])\n\n        if info.get('timestamp') is not None:\n            info['subtitles'] = {\n                'rechat': [{\n                    'url': update_url_query(\n                        'https://rechat.twitch.tv/rechat-messages', {\n                            'video_id': 'v%s' % item_id,\n                            'start': info['timestamp'],\n                        }),\n                    'ext': 'json',\n                }],\n            }\n\n        return info\n\n\nclass TwitchPlaylistBaseIE(TwitchBaseIE):\n    _PLAYLIST_PATH = 'kraken/channels/%s/videos/?offset=%d&limit=%d'\n    _PAGE_LIMIT = 100\n\n    def _extract_playlist(self, channel_id):\n        info = self._call_api(\n            'kraken/channels/%s' % channel_id,\n            channel_id, 'Downloading channel info JSON')\n        channel_name = info.get('display_name') or info.get('name')\n        entries = []\n        offset = 0\n        limit = self._PAGE_LIMIT\n        broken_paging_detected = False\n        counter_override = None\n        for counter in itertools.count(1):\n            response = self._call_api(\n                self._PLAYLIST_PATH % (channel_id, offset, limit),\n                channel_id,\n                'Downloading %s JSON page %s'\n                % (self._PLAYLIST_TYPE, counter_override or counter))\n            page_entries = self._extract_playlist_page(response)\n            if not page_entries:\n                break\n            total = int_or_none(response.get('_total'))\n            # Since the beginning of March 2016 twitch's paging mechanism\n            # is completely broken on the twitch side. It simply ignores\n            # a limit and returns the whole offset number of videos.\n            # Working around by just requesting all videos at once.\n            # Upd: pagination bug was fixed by twitch on 15.03.2016.\n            if not broken_paging_detected and total and len(page_entries) > limit:\n                self.report_warning(\n                    'Twitch pagination is broken on twitch side, requesting all videos at once',\n                    channel_id)\n                broken_paging_detected = True\n                offset = total\n                counter_override = '(all at once)'\n                continue\n            entries.extend(page_entries)\n            if broken_paging_detected or total and len(page_entries) >= total:\n                break\n            offset += limit\n        return self.playlist_result(\n            [self._make_url_result(entry) for entry in orderedSet(entries)],\n            channel_id, channel_name)\n\n    def _make_url_result(self, url):\n        try:\n            video_id = 'v%s' % TwitchVodIE._match_id(url)\n            return self.url_result(url, TwitchVodIE.ie_key(), video_id=video_id)\n        except AssertionError:\n            return self.url_result(url)\n\n    def _extract_playlist_page(self, response):\n        videos = response.get('videos')\n        return [video['url'] for video in videos] if videos else []\n\n    def _real_extract(self, url):\n        return self._extract_playlist(self._match_id(url))\n\n\nclass TwitchProfileIE(TwitchPlaylistBaseIE):\n    IE_NAME = 'twitch:profile'\n    _VALID_URL = r'%s/(?P<id>[^/]+)/profile/?(?:\\#.*)?$' % TwitchBaseIE._VALID_URL_BASE\n    _PLAYLIST_TYPE = 'profile'\n\n    _TEST = {\n        'url': 'http://www.twitch.tv/vanillatv/profile',\n        'info_dict': {\n            'id': 'vanillatv',\n            'title': 'VanillaTV',\n        },\n        'playlist_mincount': 412,\n    }\n\n\nclass TwitchVideosBaseIE(TwitchPlaylistBaseIE):\n    _VALID_URL_VIDEOS_BASE = r'%s/(?P<id>[^/]+)/videos' % TwitchBaseIE._VALID_URL_BASE\n    _PLAYLIST_PATH = TwitchPlaylistBaseIE._PLAYLIST_PATH + '&broadcast_type='\n\n\nclass TwitchAllVideosIE(TwitchVideosBaseIE):\n    IE_NAME = 'twitch:videos:all'\n    _VALID_URL = r'%s/all' % TwitchVideosBaseIE._VALID_URL_VIDEOS_BASE\n    _PLAYLIST_PATH = TwitchVideosBaseIE._PLAYLIST_PATH + 'archive,upload,highlight'\n    _PLAYLIST_TYPE = 'all videos'\n\n    _TEST = {\n        'url': 'https://www.twitch.tv/spamfish/videos/all',\n        'info_dict': {\n            'id': 'spamfish',\n            'title': 'Spamfish',\n        },\n        'playlist_mincount': 869,\n    }\n\n\nclass TwitchUploadsIE(TwitchVideosBaseIE):\n    IE_NAME = 'twitch:videos:uploads'\n    _VALID_URL = r'%s/uploads' % TwitchVideosBaseIE._VALID_URL_VIDEOS_BASE\n    _PLAYLIST_PATH = TwitchVideosBaseIE._PLAYLIST_PATH + 'upload'\n    _PLAYLIST_TYPE = 'uploads'\n\n    _TEST = {\n        'url': 'https://www.twitch.tv/spamfish/videos/uploads',\n        'info_dict': {\n            'id': 'spamfish',\n            'title': 'Spamfish',\n        },\n        'playlist_mincount': 0,\n    }\n\n\nclass TwitchPastBroadcastsIE(TwitchVideosBaseIE):\n    IE_NAME = 'twitch:videos:past-broadcasts'\n    _VALID_URL = r'%s/past-broadcasts' % TwitchVideosBaseIE._VALID_URL_VIDEOS_BASE\n    _PLAYLIST_PATH = TwitchVideosBaseIE._PLAYLIST_PATH + 'archive'\n    _PLAYLIST_TYPE = 'past broadcasts'\n\n    _TEST = {\n        'url': 'https://www.twitch.tv/spamfish/videos/past-broadcasts',\n        'info_dict': {\n            'id': 'spamfish',\n            'title': 'Spamfish',\n        },\n        'playlist_mincount': 0,\n    }\n\n\nclass TwitchHighlightsIE(TwitchVideosBaseIE):\n    IE_NAME = 'twitch:videos:highlights'\n    _VALID_URL = r'%s/highlights' % TwitchVideosBaseIE._VALID_URL_VIDEOS_BASE\n    _PLAYLIST_PATH = TwitchVideosBaseIE._PLAYLIST_PATH + 'highlight'\n    _PLAYLIST_TYPE = 'highlights'\n\n    _TEST = {\n        'url': 'https://www.twitch.tv/spamfish/videos/highlights',\n        'info_dict': {\n            'id': 'spamfish',\n            'title': 'Spamfish',\n        },\n        'playlist_mincount': 805,\n    }\n\n\nclass TwitchStreamIE(TwitchBaseIE):\n    IE_NAME = 'twitch:stream'\n    _VALID_URL = r'''(?x)\n                    https?://\n                        (?:\n                            (?:(?:www|go)\\.)?twitch\\.tv/|\n                            player\\.twitch\\.tv/\\?.*?\\bchannel=\n                        )\n                        (?P<id>[^/#?]+)\n                    '''\n\n    _TESTS = [{\n        'url': 'http://www.twitch.tv/shroomztv',\n        'info_dict': {\n            'id': '12772022048',\n            'display_id': 'shroomztv',\n            'ext': 'mp4',\n            'title': 're:^ShroomzTV [0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}$',\n            'description': 'H1Z1 - lonewolfing with ShroomzTV | A3 Battle Royale later - @ShroomzTV',\n            'is_live': True,\n            'timestamp': 1421928037,\n            'upload_date': '20150122',\n            'uploader': 'ShroomzTV',\n            'uploader_id': 'shroomztv',\n            'view_count': int,\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        },\n    }, {\n        'url': 'http://www.twitch.tv/miracle_doto#profile-0',\n        'only_matching': True,\n    }, {\n        'url': 'https://player.twitch.tv/?channel=lotsofs',\n        'only_matching': True,\n    }, {\n        'url': 'https://go.twitch.tv/food',\n        'only_matching': True,\n    }]\n\n    @classmethod\n    def suitable(cls, url):\n        return (False\n                if any(ie.suitable(url) for ie in (\n                    TwitchVideoIE,\n                    TwitchChapterIE,\n                    TwitchVodIE,\n                    TwitchProfileIE,\n                    TwitchAllVideosIE,\n                    TwitchUploadsIE,\n                    TwitchPastBroadcastsIE,\n                    TwitchHighlightsIE))\n                else super(TwitchStreamIE, cls).suitable(url))\n\n    def _real_extract(self, url):\n        channel_id = self._match_id(url)\n\n        stream = self._call_api(\n            'kraken/streams/%s?stream_type=all' % channel_id, channel_id,\n            'Downloading stream JSON').get('stream')\n\n        if not stream:\n            raise ExtractorError('%s is offline' % channel_id, expected=True)\n\n        # Channel name may be typed if different case than the original channel name\n        # (e.g. http://www.twitch.tv/TWITCHPLAYSPOKEMON) that will lead to constructing\n        # an invalid m3u8 URL. Working around by use of original channel name from stream\n        # JSON and fallback to lowercase if it's not available.\n        channel_id = stream.get('channel', {}).get('name') or channel_id.lower()\n\n        access_token = self._call_api(\n            'api/channels/%s/access_token' % channel_id, channel_id,\n            'Downloading channel access token')\n\n        query = {\n            'allow_source': 'true',\n            'allow_audio_only': 'true',\n            'allow_spectre': 'true',\n            'p': random.randint(1000000, 10000000),\n            'player': 'twitchweb',\n            'segment_preference': '4',\n            'sig': access_token['sig'].encode('utf-8'),\n            'token': access_token['token'].encode('utf-8'),\n        }\n        formats = self._extract_m3u8_formats(\n            '%s/api/channel/hls/%s.m3u8?%s'\n            % (self._USHER_BASE, channel_id, compat_urllib_parse_urlencode(query)),\n            channel_id, 'mp4')\n        self._prefer_source(formats)\n\n        view_count = stream.get('viewers')\n        timestamp = parse_iso8601(stream.get('created_at'))\n\n        channel = stream['channel']\n        title = self._live_title(channel.get('display_name') or channel.get('name'))\n        description = channel.get('status')\n\n        thumbnails = []\n        for thumbnail_key, thumbnail_url in stream['preview'].items():\n            m = re.search(r'(?P<width>\\d+)x(?P<height>\\d+)\\.jpg$', thumbnail_key)\n            if not m:\n                continue\n            thumbnails.append({\n                'url': thumbnail_url,\n                'width': int(m.group('width')),\n                'height': int(m.group('height')),\n            })\n\n        return {\n            'id': compat_str(stream['_id']),\n            'display_id': channel_id,\n            'title': title,\n            'description': description,\n            'thumbnails': thumbnails,\n            'uploader': channel.get('display_name'),\n            'uploader_id': channel.get('name'),\n            'timestamp': timestamp,\n            'view_count': view_count,\n            'formats': formats,\n            'is_live': True,\n        }\n\n\nclass TwitchClipsIE(InfoExtractor):\n    IE_NAME = 'twitch:clips'\n    _VALID_URL = r'https?://clips\\.twitch\\.tv/(?:[^/]+/)*(?P<id>[^/?#&]+)'\n\n    _TESTS = [{\n        'url': 'https://clips.twitch.tv/ea/AggressiveCobraPoooound',\n        'md5': '761769e1eafce0ffebfb4089cb3847cd',\n        'info_dict': {\n            'id': 'AggressiveCobraPoooound',\n            'ext': 'mp4',\n            'title': 'EA Play 2016 Live from the Novo Theatre',\n            'thumbnail': r're:^https?://.*\\.jpg',\n            'creator': 'EA',\n            'uploader': 'stereotype_',\n            'uploader_id': 'stereotype_',\n        },\n    }, {\n        # multiple formats\n        'url': 'https://clips.twitch.tv/rflegendary/UninterestedBeeDAESuppy',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        webpage = self._download_webpage(url, video_id)\n\n        clip = self._parse_json(\n            self._search_regex(\n                r'(?s)clipInfo\\s*=\\s*({.+?});', webpage, 'clip info'),\n            video_id, transform_source=js_to_json)\n\n        title = clip.get('title') or clip.get('channel_title') or self._og_search_title(webpage)\n\n        formats = [{\n            'url': option['source'],\n            'format_id': option.get('quality'),\n            'height': int_or_none(option.get('quality')),\n        } for option in clip.get('quality_options', []) if option.get('source')]\n\n        if not formats:\n            formats = [{\n                'url': clip['clip_video_url'],\n            }]\n\n        self._sort_formats(formats)\n\n        return {\n            'id': video_id,\n            'title': title,\n            'thumbnail': self._og_search_thumbnail(webpage),\n            'creator': clip.get('broadcaster_display_name') or clip.get('broadcaster_login'),\n            'uploader': clip.get('curator_login'),\n            'uploader_id': clip.get('curator_display_name'),\n            'formats': formats,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "twitch.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/twitch.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}