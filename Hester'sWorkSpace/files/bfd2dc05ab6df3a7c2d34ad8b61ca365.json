{"author": "ansible", "code": "\n\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: profitbricks_volume\nshort_description: Create or destroy a volume.\ndescription:\n     - Allows you to create or remove a volume from a ProfitBricks datacenter. This module has a dependency on profitbricks >= 1.0.0\nversion_added: \"2.0\"\noptions:\n  datacenter:\n    description:\n      - The datacenter in which to create the volumes.\n    required: true\n  name:\n    description:\n      - The name of the volumes. You can enumerate the names using auto_increment.\n    required: true\n  size:\n    description:\n      - The size of the volume.\n    required: false\n    default: 10\n  bus:\n    description:\n      - The bus type.\n    required: false\n    default: VIRTIO\n    choices: [ \"IDE\", \"VIRTIO\"]\n  image:\n    description:\n      - The system image ID for the volume, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8. This can also be a snapshot image ID.\n    required: true\n  image_password:\n    description:\n      - Password set for the administrative user.\n    required: false\n    version_added: '2.2'\n  ssh_keys:\n    description:\n      - Public SSH keys allowing access to the virtual machine.\n    required: false\n    version_added: '2.2'\n  disk_type:\n    description:\n      - The disk type of the volume.\n    required: false\n    default: HDD\n    choices: [ \"HDD\", \"SSD\" ]\n  licence_type:\n    description:\n      - The licence type for the volume. This is used when the image is non-standard.\n    required: false\n    default: UNKNOWN\n    choices: [\"LINUX\", \"WINDOWS\", \"UNKNOWN\" , \"OTHER\"]\n  count:\n    description:\n      - The number of volumes you wish to create.\n    required: false\n    default: 1\n  auto_increment:\n    description:\n      - Whether or not to increment a single number in the name for created virtual machines.\n    default: yes\n    choices: [\"yes\", \"no\"]\n  instance_ids:\n    description:\n      - list of instance ids, currently only used when state='absent' to remove instances.\n    required: false\n  subscription_user:\n    description:\n      - The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.\n    required: false\n  subscription_password:\n    description:\n      - THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.\n    required: false\n  wait:\n    description:\n      - wait for the datacenter to be created before returning\n    required: false\n    default: \"yes\"\n    choices: [ \"yes\", \"no\" ]\n  wait_timeout:\n    description:\n      - how long before wait gives up, in seconds\n    default: 600\n  state:\n    description:\n      - create or terminate datacenters\n    required: false\n    default: 'present'\n    choices: [\"present\", \"absent\"]\n\nrequirements: [ \"profitbricks\" ]\nauthor: Matt Baldwin (baldwin@stackpointcloud.com)\n'''\n\nEXAMPLES = '''\n\n\n\n- profitbricks_volume:\n    datacenter: Tardis One\n    name: vol%02d\n    count: 5\n    auto_increment: yes\n    wait_timeout: 500\n    state: present\n\n\n\n- profitbricks_volume:\n    datacenter: Tardis One\n    instance_ids:\n      - 'vol01'\n      - 'vol02'\n    wait_timeout: 500\n    state: absent\n\n'''\n\nimport re\nimport time\nimport traceback\n\nHAS_PB_SDK = True\ntry:\n    from profitbricks.client import ProfitBricksService, Volume\nexcept ImportError:\n    HAS_PB_SDK = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.six.moves import xrange\nfrom ansible.module_utils._text import to_native\n\n\nuuid_match = re.compile(\n    r'[\\w]{8}-[\\w]{4}-[\\w]{4}-[\\w]{4}-[\\w]{12}', re.I)\n\n\ndef _wait_for_completion(profitbricks, promise, wait_timeout, msg):\n    if not promise:\n        return\n    wait_timeout = time.time() + wait_timeout\n    while wait_timeout > time.time():\n        time.sleep(5)\n        operation_result = profitbricks.get_request(\n            request_id=promise['requestId'],\n            status=True)\n\n        if operation_result['metadata']['status'] == \"DONE\":\n            return\n        elif operation_result['metadata']['status'] == \"FAILED\":\n            raise Exception(\n                'Request failed to complete ' + msg + ' \"' + str(\n                    promise['requestId']) + '\" to complete.')\n\n    raise Exception(\n        'Timed out waiting for async operation ' + msg + ' \"' + str(\n            promise['requestId']\n        ) + '\" to complete.')\n\n\ndef _create_volume(module, profitbricks, datacenter, name):\n    size = module.params.get('size')\n    bus = module.params.get('bus')\n    image = module.params.get('image')\n    image_password = module.params.get('image_password')\n    ssh_keys = module.params.get('ssh_keys')\n    disk_type = module.params.get('disk_type')\n    licence_type = module.params.get('licence_type')\n    wait_timeout = module.params.get('wait_timeout')\n    wait = module.params.get('wait')\n\n    try:\n        v = Volume(\n            name=name,\n            size=size,\n            bus=bus,\n            image=image,\n            image_password=image_password,\n            ssh_keys=ssh_keys,\n            disk_type=disk_type,\n            licence_type=licence_type\n        )\n\n        volume_response = profitbricks.create_volume(datacenter, v)\n\n        if wait:\n            _wait_for_completion(profitbricks, volume_response,\n                                 wait_timeout, \"_create_volume\")\n\n    except Exception as e:\n        module.fail_json(msg=\"failed to create the volume: %s\" % str(e))\n\n    return volume_response\n\n\ndef _delete_volume(module, profitbricks, datacenter, volume):\n    try:\n        profitbricks.delete_volume(datacenter, volume)\n    except Exception as e:\n        module.fail_json(msg=\"failed to remove the volume: %s\" % str(e))\n\n\ndef create_volume(module, profitbricks):\n    \"\"\"\n    Creates a volume.\n\n    This will create a volume in a datacenter.\n\n    module : AnsibleModule object\n    profitbricks: authenticated profitbricks object.\n\n    Returns:\n        True if the volume was created, false otherwise\n    \"\"\"\n    datacenter = module.params.get('datacenter')\n    name = module.params.get('name')\n    auto_increment = module.params.get('auto_increment')\n    count = module.params.get('count')\n\n    datacenter_found = False\n    failed = True\n    volumes = []\n\n    \n    if not (uuid_match.match(datacenter)):\n        datacenter_list = profitbricks.list_datacenters()\n        for d in datacenter_list['items']:\n            dc = profitbricks.get_datacenter(d['id'])\n            if datacenter == dc['properties']['name']:\n                datacenter = d['id']\n                datacenter_found = True\n                break\n\n    if not datacenter_found:\n        module.fail_json(msg='datacenter could not be found.')\n\n    if auto_increment:\n        numbers = set()\n        count_offset = 1\n\n        try:\n            name % 0\n        except TypeError as e:\n            if e.message.startswith('not all'):\n                name = '%s%%d' % name\n            else:\n                module.fail_json(msg=e.message, exception=traceback.format_exc())\n\n        number_range = xrange(count_offset, count_offset + count + len(numbers))\n        available_numbers = list(set(number_range).difference(numbers))\n        names = []\n        numbers_to_use = available_numbers[:count]\n        for number in numbers_to_use:\n            names.append(name % number)\n    else:\n        names = [name] * count\n\n    for name in names:\n        create_response = _create_volume(module, profitbricks, str(datacenter), name)\n        volumes.append(create_response)\n        _attach_volume(module, profitbricks, datacenter, create_response['id'])\n        failed = False\n\n    results = {\n        'failed': failed,\n        'volumes': volumes,\n        'action': 'create',\n        'instance_ids': {\n            'instances': [i['id'] for i in volumes],\n        }\n    }\n\n    return results\n\n\ndef delete_volume(module, profitbricks):\n    \"\"\"\n    Removes a volume.\n\n    This will create a volume in a datacenter.\n\n    module : AnsibleModule object\n    profitbricks: authenticated profitbricks object.\n\n    Returns:\n        True if the volume was removed, false otherwise\n    \"\"\"\n    if not isinstance(module.params.get('instance_ids'), list) or len(module.params.get('instance_ids')) < 1:\n        module.fail_json(msg='instance_ids should be a list of virtual machine ids or names, aborting')\n\n    datacenter = module.params.get('datacenter')\n    changed = False\n    instance_ids = module.params.get('instance_ids')\n\n    \n    if not (uuid_match.match(datacenter)):\n        datacenter_list = profitbricks.list_datacenters()\n        for d in datacenter_list['items']:\n            dc = profitbricks.get_datacenter(d['id'])\n            if datacenter == dc['properties']['name']:\n                datacenter = d['id']\n                break\n\n    for n in instance_ids:\n        if(uuid_match.match(n)):\n            _delete_volume(module, profitbricks, datacenter, n)\n            changed = True\n        else:\n            volumes = profitbricks.list_volumes(datacenter)\n            for v in volumes['items']:\n                if n == v['properties']['name']:\n                    volume_id = v['id']\n                    _delete_volume(module, profitbricks, datacenter, volume_id)\n                    changed = True\n\n    return changed\n\n\ndef _attach_volume(module, profitbricks, datacenter, volume):\n    \"\"\"\n    Attaches a volume.\n\n    This will attach a volume to the server.\n\n    module : AnsibleModule object\n    profitbricks: authenticated profitbricks object.\n\n    Returns:\n        True if the volume was attached, false otherwise\n    \"\"\"\n    server = module.params.get('server')\n\n    \n    if server:\n        if not (uuid_match.match(server)):\n            server_list = profitbricks.list_servers(datacenter)\n            for s in server_list['items']:\n                if server == s['properties']['name']:\n                    server = s['id']\n                    break\n\n        try:\n            return profitbricks.attach_volume(datacenter, server, volume)\n        except Exception as e:\n            module.fail_json(msg='failed to attach volume: %s' % to_native(e), exception=traceback.format_exc())\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            datacenter=dict(),\n            server=dict(),\n            name=dict(),\n            size=dict(type='int', default=10),\n            bus=dict(choices=['VIRTIO', 'IDE'], default='VIRTIO'),\n            image=dict(),\n            image_password=dict(default=None, no_log=True),\n            ssh_keys=dict(type='list', default=[]),\n            disk_type=dict(choices=['HDD', 'SSD'], default='HDD'),\n            licence_type=dict(default='UNKNOWN'),\n            count=dict(type='int', default=1),\n            auto_increment=dict(type='bool', default=True),\n            instance_ids=dict(type='list', default=[]),\n            subscription_user=dict(),\n            subscription_password=dict(no_log=True),\n            wait=dict(type='bool', default=True),\n            wait_timeout=dict(type='int', default=600),\n            state=dict(default='present'),\n        )\n    )\n\n    if not module.params.get('subscription_user'):\n        module.fail_json(msg='subscription_user parameter is required')\n    if not module.params.get('subscription_password'):\n        module.fail_json(msg='subscription_password parameter is required')\n\n    subscription_user = module.params.get('subscription_user')\n    subscription_password = module.params.get('subscription_password')\n\n    profitbricks = ProfitBricksService(\n        username=subscription_user,\n        password=subscription_password)\n\n    state = module.params.get('state')\n\n    if state == 'absent':\n        if not module.params.get('datacenter'):\n            module.fail_json(msg='datacenter parameter is required for running or stopping machines.')\n\n        try:\n            (changed) = delete_volume(module, profitbricks)\n            module.exit_json(changed=changed)\n        except Exception as e:\n            module.fail_json(msg='failed to set volume state: %s' % to_native(e), exception=traceback.format_exc())\n\n    elif state == 'present':\n        if not module.params.get('datacenter'):\n            module.fail_json(msg='datacenter parameter is required for new instance')\n        if not module.params.get('name'):\n            module.fail_json(msg='name parameter is required for new instance')\n\n        try:\n            (volume_dict_array) = create_volume(module, profitbricks)\n            module.exit_json(**volume_dict_array)\n        except Exception as e:\n            module.fail_json(msg='failed to set volume state: %s' % to_native(e), exception=traceback.format_exc())\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        creates volume       this create volume datacenter       module   ansiblemodule object     profitbricks  authenticated profitbricks object       returns          true volume created  false otherwise             datacenter   module params get( datacenter )     name   module params get( name )     auto increment   module params get( auto increment )     count   module params get( count )      datacenter found   false     failed   true     volumes             locate uuid datacenter     (uuid match match(datacenter))          datacenter list   profitbricks list datacenters()         datacenter list  items                dc   profitbricks get datacenter(d  id  )             datacenter    dc  properties    name                    datacenter    id                   datacenter found   true                 break      datacenter found          module fail json(msg  datacenter could found  )      auto increment          numbers   set()         count offset   1          try              name   0         except typeerror e              e message startswith( )                  name         name             else                  module fail json(msg e message  exception traceback format exc())          number range   xrange(count offset  count offset   count   len(numbers))         available numbers   list(set(number range) difference(numbers))         names              numbers use   available numbers  count          number numbers use              names append(name   number)     else          names    name    count      name names          create response    create volume(module  profitbricks  str(datacenter)  name)         volumes append(create response)          attach volume(module  profitbricks  datacenter  create response  id  )         failed   false      results              failed   failed           volumes   volumes           action    create            instance ids                  instances     id   volumes                        return results   def delete volume(module  profitbricks)              removes volume       this create volume datacenter       module   ansiblemodule object     profitbricks  authenticated profitbricks object       returns          true volume removed  false otherwise             isinstance(module params get( instance ids )  list) len(module params get( instance ids ))   1          module fail json(msg  instance ids list virtual machine ids names  aborting )      datacenter   module params get( datacenter )     changed   false     instance ids   module params get( instance ids )        locate uuid datacenter     (uuid match match(datacenter))          datacenter list   profitbricks list datacenters()         datacenter list  items                dc   profitbricks get datacenter(d  id  )             datacenter    dc  properties    name                    datacenter    id                   break      n instance ids          if(uuid match match(n))               delete volume(module  profitbricks  datacenter  n)             changed   true         else              volumes   profitbricks list volumes(datacenter)             v volumes  items                    n    v  properties    name                        volume id   v  id                        delete volume(module  profitbricks  datacenter  volume id)                     changed   true      return changed   def  attach volume(module  profitbricks  datacenter  volume)              attaches volume       this attach volume server       module   ansiblemodule object     profitbricks  authenticated profitbricks object       returns          true volume attached  false otherwise                  module  profitbricks volume short description  create destroy volume  description         allows create remove volume profitbricks datacenter  this module dependency profitbricks    1 0 0 version added   2 0  options    datacenter      description          the datacenter create volumes      required  true   name      description          the name volumes  you enumerate names using auto increment      required  true   size      description          the size volume      required  false     default  10   bus      description          the bus type      required  false     default  virtio     choices     ide    virtio     image      description          the system image id volume  e g  a3eae284 a2fe 11e4 b187 5f1f641608c8  this also snapshot image id      required  true   image password      description          password set administrative user      required  false     version added   2 2    ssh keys      description          public ssh keys allowing access virtual machine      required  false     version added   2 2    disk type      description          the disk type volume      required  false     default  hdd     choices     hdd    ssd      licence type      description          the licence type volume  this used image non standard      required  false     default  unknown     choices    linux    windows    unknown     other     count      description          the number volumes wish create      required  false     default  1   auto increment      description          whether increment single number name created virtual machines      default  yes     choices    yes        instance ids      description          list instance ids  currently used state  absent  remove instances      required  false   subscription user      description          the profitbricks username  overrides pb subscription id environment variable      required  false   subscription password      description          the profitbricks password  overrides pb password environment variable      required  false   wait      description          wait datacenter created returning     required  false     default   yes      choices     yes         wait timeout      description          long wait gives  seconds     default  600   state      description          create terminate datacenters     required  false     default   present      choices    present    absent    requirements     profitbricks    author  matt baldwin (baldwin stackpointcloud com)      examples          create multiple volumes    profitbricks volume      datacenter  tardis one     name  vol 02d     count  5     auto increment  yes     wait timeout  500     state  present    remove volumes    profitbricks volume      datacenter  tardis one     instance ids           vol01           vol02      wait timeout  500     state  absent          usr bin python    copyright  ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    create multiple volumes    remove volumes    locate uuid datacenter    locate uuid datacenter    locate uuid server ", "content": "#!/usr/bin/python\n# Copyright: Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\n\nDOCUMENTATION = '''\n---\nmodule: profitbricks_volume\nshort_description: Create or destroy a volume.\ndescription:\n     - Allows you to create or remove a volume from a ProfitBricks datacenter. This module has a dependency on profitbricks >= 1.0.0\nversion_added: \"2.0\"\noptions:\n  datacenter:\n    description:\n      - The datacenter in which to create the volumes.\n    required: true\n  name:\n    description:\n      - The name of the volumes. You can enumerate the names using auto_increment.\n    required: true\n  size:\n    description:\n      - The size of the volume.\n    required: false\n    default: 10\n  bus:\n    description:\n      - The bus type.\n    required: false\n    default: VIRTIO\n    choices: [ \"IDE\", \"VIRTIO\"]\n  image:\n    description:\n      - The system image ID for the volume, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8. This can also be a snapshot image ID.\n    required: true\n  image_password:\n    description:\n      - Password set for the administrative user.\n    required: false\n    version_added: '2.2'\n  ssh_keys:\n    description:\n      - Public SSH keys allowing access to the virtual machine.\n    required: false\n    version_added: '2.2'\n  disk_type:\n    description:\n      - The disk type of the volume.\n    required: false\n    default: HDD\n    choices: [ \"HDD\", \"SSD\" ]\n  licence_type:\n    description:\n      - The licence type for the volume. This is used when the image is non-standard.\n    required: false\n    default: UNKNOWN\n    choices: [\"LINUX\", \"WINDOWS\", \"UNKNOWN\" , \"OTHER\"]\n  count:\n    description:\n      - The number of volumes you wish to create.\n    required: false\n    default: 1\n  auto_increment:\n    description:\n      - Whether or not to increment a single number in the name for created virtual machines.\n    default: yes\n    choices: [\"yes\", \"no\"]\n  instance_ids:\n    description:\n      - list of instance ids, currently only used when state='absent' to remove instances.\n    required: false\n  subscription_user:\n    description:\n      - The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.\n    required: false\n  subscription_password:\n    description:\n      - THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.\n    required: false\n  wait:\n    description:\n      - wait for the datacenter to be created before returning\n    required: false\n    default: \"yes\"\n    choices: [ \"yes\", \"no\" ]\n  wait_timeout:\n    description:\n      - how long before wait gives up, in seconds\n    default: 600\n  state:\n    description:\n      - create or terminate datacenters\n    required: false\n    default: 'present'\n    choices: [\"present\", \"absent\"]\n\nrequirements: [ \"profitbricks\" ]\nauthor: Matt Baldwin (baldwin@stackpointcloud.com)\n'''\n\nEXAMPLES = '''\n\n# Create Multiple Volumes\n\n- profitbricks_volume:\n    datacenter: Tardis One\n    name: vol%02d\n    count: 5\n    auto_increment: yes\n    wait_timeout: 500\n    state: present\n\n# Remove Volumes\n\n- profitbricks_volume:\n    datacenter: Tardis One\n    instance_ids:\n      - 'vol01'\n      - 'vol02'\n    wait_timeout: 500\n    state: absent\n\n'''\n\nimport re\nimport time\nimport traceback\n\nHAS_PB_SDK = True\ntry:\n    from profitbricks.client import ProfitBricksService, Volume\nexcept ImportError:\n    HAS_PB_SDK = False\n\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.six.moves import xrange\nfrom ansible.module_utils._text import to_native\n\n\nuuid_match = re.compile(\n    r'[\\w]{8}-[\\w]{4}-[\\w]{4}-[\\w]{4}-[\\w]{12}', re.I)\n\n\ndef _wait_for_completion(profitbricks, promise, wait_timeout, msg):\n    if not promise:\n        return\n    wait_timeout = time.time() + wait_timeout\n    while wait_timeout > time.time():\n        time.sleep(5)\n        operation_result = profitbricks.get_request(\n            request_id=promise['requestId'],\n            status=True)\n\n        if operation_result['metadata']['status'] == \"DONE\":\n            return\n        elif operation_result['metadata']['status'] == \"FAILED\":\n            raise Exception(\n                'Request failed to complete ' + msg + ' \"' + str(\n                    promise['requestId']) + '\" to complete.')\n\n    raise Exception(\n        'Timed out waiting for async operation ' + msg + ' \"' + str(\n            promise['requestId']\n        ) + '\" to complete.')\n\n\ndef _create_volume(module, profitbricks, datacenter, name):\n    size = module.params.get('size')\n    bus = module.params.get('bus')\n    image = module.params.get('image')\n    image_password = module.params.get('image_password')\n    ssh_keys = module.params.get('ssh_keys')\n    disk_type = module.params.get('disk_type')\n    licence_type = module.params.get('licence_type')\n    wait_timeout = module.params.get('wait_timeout')\n    wait = module.params.get('wait')\n\n    try:\n        v = Volume(\n            name=name,\n            size=size,\n            bus=bus,\n            image=image,\n            image_password=image_password,\n            ssh_keys=ssh_keys,\n            disk_type=disk_type,\n            licence_type=licence_type\n        )\n\n        volume_response = profitbricks.create_volume(datacenter, v)\n\n        if wait:\n            _wait_for_completion(profitbricks, volume_response,\n                                 wait_timeout, \"_create_volume\")\n\n    except Exception as e:\n        module.fail_json(msg=\"failed to create the volume: %s\" % str(e))\n\n    return volume_response\n\n\ndef _delete_volume(module, profitbricks, datacenter, volume):\n    try:\n        profitbricks.delete_volume(datacenter, volume)\n    except Exception as e:\n        module.fail_json(msg=\"failed to remove the volume: %s\" % str(e))\n\n\ndef create_volume(module, profitbricks):\n    \"\"\"\n    Creates a volume.\n\n    This will create a volume in a datacenter.\n\n    module : AnsibleModule object\n    profitbricks: authenticated profitbricks object.\n\n    Returns:\n        True if the volume was created, false otherwise\n    \"\"\"\n    datacenter = module.params.get('datacenter')\n    name = module.params.get('name')\n    auto_increment = module.params.get('auto_increment')\n    count = module.params.get('count')\n\n    datacenter_found = False\n    failed = True\n    volumes = []\n\n    # Locate UUID for Datacenter\n    if not (uuid_match.match(datacenter)):\n        datacenter_list = profitbricks.list_datacenters()\n        for d in datacenter_list['items']:\n            dc = profitbricks.get_datacenter(d['id'])\n            if datacenter == dc['properties']['name']:\n                datacenter = d['id']\n                datacenter_found = True\n                break\n\n    if not datacenter_found:\n        module.fail_json(msg='datacenter could not be found.')\n\n    if auto_increment:\n        numbers = set()\n        count_offset = 1\n\n        try:\n            name % 0\n        except TypeError as e:\n            if e.message.startswith('not all'):\n                name = '%s%%d' % name\n            else:\n                module.fail_json(msg=e.message, exception=traceback.format_exc())\n\n        number_range = xrange(count_offset, count_offset + count + len(numbers))\n        available_numbers = list(set(number_range).difference(numbers))\n        names = []\n        numbers_to_use = available_numbers[:count]\n        for number in numbers_to_use:\n            names.append(name % number)\n    else:\n        names = [name] * count\n\n    for name in names:\n        create_response = _create_volume(module, profitbricks, str(datacenter), name)\n        volumes.append(create_response)\n        _attach_volume(module, profitbricks, datacenter, create_response['id'])\n        failed = False\n\n    results = {\n        'failed': failed,\n        'volumes': volumes,\n        'action': 'create',\n        'instance_ids': {\n            'instances': [i['id'] for i in volumes],\n        }\n    }\n\n    return results\n\n\ndef delete_volume(module, profitbricks):\n    \"\"\"\n    Removes a volume.\n\n    This will create a volume in a datacenter.\n\n    module : AnsibleModule object\n    profitbricks: authenticated profitbricks object.\n\n    Returns:\n        True if the volume was removed, false otherwise\n    \"\"\"\n    if not isinstance(module.params.get('instance_ids'), list) or len(module.params.get('instance_ids')) < 1:\n        module.fail_json(msg='instance_ids should be a list of virtual machine ids or names, aborting')\n\n    datacenter = module.params.get('datacenter')\n    changed = False\n    instance_ids = module.params.get('instance_ids')\n\n    # Locate UUID for Datacenter\n    if not (uuid_match.match(datacenter)):\n        datacenter_list = profitbricks.list_datacenters()\n        for d in datacenter_list['items']:\n            dc = profitbricks.get_datacenter(d['id'])\n            if datacenter == dc['properties']['name']:\n                datacenter = d['id']\n                break\n\n    for n in instance_ids:\n        if(uuid_match.match(n)):\n            _delete_volume(module, profitbricks, datacenter, n)\n            changed = True\n        else:\n            volumes = profitbricks.list_volumes(datacenter)\n            for v in volumes['items']:\n                if n == v['properties']['name']:\n                    volume_id = v['id']\n                    _delete_volume(module, profitbricks, datacenter, volume_id)\n                    changed = True\n\n    return changed\n\n\ndef _attach_volume(module, profitbricks, datacenter, volume):\n    \"\"\"\n    Attaches a volume.\n\n    This will attach a volume to the server.\n\n    module : AnsibleModule object\n    profitbricks: authenticated profitbricks object.\n\n    Returns:\n        True if the volume was attached, false otherwise\n    \"\"\"\n    server = module.params.get('server')\n\n    # Locate UUID for Server\n    if server:\n        if not (uuid_match.match(server)):\n            server_list = profitbricks.list_servers(datacenter)\n            for s in server_list['items']:\n                if server == s['properties']['name']:\n                    server = s['id']\n                    break\n\n        try:\n            return profitbricks.attach_volume(datacenter, server, volume)\n        except Exception as e:\n            module.fail_json(msg='failed to attach volume: %s' % to_native(e), exception=traceback.format_exc())\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            datacenter=dict(),\n            server=dict(),\n            name=dict(),\n            size=dict(type='int', default=10),\n            bus=dict(choices=['VIRTIO', 'IDE'], default='VIRTIO'),\n            image=dict(),\n            image_password=dict(default=None, no_log=True),\n            ssh_keys=dict(type='list', default=[]),\n            disk_type=dict(choices=['HDD', 'SSD'], default='HDD'),\n            licence_type=dict(default='UNKNOWN'),\n            count=dict(type='int', default=1),\n            auto_increment=dict(type='bool', default=True),\n            instance_ids=dict(type='list', default=[]),\n            subscription_user=dict(),\n            subscription_password=dict(no_log=True),\n            wait=dict(type='bool', default=True),\n            wait_timeout=dict(type='int', default=600),\n            state=dict(default='present'),\n        )\n    )\n\n    if not module.params.get('subscription_user'):\n        module.fail_json(msg='subscription_user parameter is required')\n    if not module.params.get('subscription_password'):\n        module.fail_json(msg='subscription_password parameter is required')\n\n    subscription_user = module.params.get('subscription_user')\n    subscription_password = module.params.get('subscription_password')\n\n    profitbricks = ProfitBricksService(\n        username=subscription_user,\n        password=subscription_password)\n\n    state = module.params.get('state')\n\n    if state == 'absent':\n        if not module.params.get('datacenter'):\n            module.fail_json(msg='datacenter parameter is required for running or stopping machines.')\n\n        try:\n            (changed) = delete_volume(module, profitbricks)\n            module.exit_json(changed=changed)\n        except Exception as e:\n            module.fail_json(msg='failed to set volume state: %s' % to_native(e), exception=traceback.format_exc())\n\n    elif state == 'present':\n        if not module.params.get('datacenter'):\n            module.fail_json(msg='datacenter parameter is required for new instance')\n        if not module.params.get('name'):\n            module.fail_json(msg='name parameter is required for new instance')\n\n        try:\n            (volume_dict_array) = create_volume(module, profitbricks)\n            module.exit_json(**volume_dict_array)\n        except Exception as e:\n            module.fail_json(msg='failed to set volume state: %s' % to_native(e), exception=traceback.format_exc())\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "profitbricks_volume.py", "id": "bfd2dc05ab6df3a7c2d34ad8b61ca365", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/cloud/profitbricks/profitbricks_volume.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}