{"author": "jakubroztocil", "code": "\n        \n        stored_attrs = ['value', 'path', 'secure', 'expires']\n        self['cookies'] = {}\n        for cookie in jar:\n            self['cookies'][cookie.name] = {\n                attname: getattr(cookie, attname)\n                for attname in stored_attrs\n            }\n\n    @property\n    def auth(self):\n        auth = self.get('auth', None)\n        if not auth or not auth['type']:\n            return\n\n        plugin = plugin_manager.get_auth_plugin(auth['type'])()\n\n        credentials = {'username': None, 'password': None}\n        try:\n            \n            plugin.raw_auth = auth['raw_auth']\n        except KeyError:\n            \n            credentials = {\n                'username': auth['username'],\n                'password': auth['password'],\n            }\n        else:\n            if plugin.auth_parse:\n                from httpie.input import parse_auth\n                parsed = parse_auth(plugin.raw_auth)\n                credentials = {\n                    'username': parsed.key,\n                    'password': parsed.value,\n                }\n\n        return plugin.get_auth(**credentials)\n\n    @auth.setter\n    def auth(self, auth):\n        assert set(['type', 'raw_auth']) == set(auth.keys())\n        self['auth'] = auth\n", "comments": "Persistent, JSON-serialized sessions.\n\n\"\"\"\nimport re\nimport os\n\nfrom requests.cookies import RequestsCookieJar, create_cookie\n\nfrom httpie.compat import urlsplit\nfrom httpie.config import BaseConfigDict, DEFAULT_CONFIG_DIR\nfrom httpie.plugins import plugin_manager\n\n\nSESSIONS_DIR_NAME = 'sessions'\nDEFAULT_SESSIONS_DIR = os.path.join(DEFAULT_CONFIG_DIR, SESSIONS_DIR_NAME)\nVALID_SESSION_NAME_PATTERN = re.compile('^[a-zA-Z0-9_.-]+$')\n# Request headers starting with these prefixes won't be stored in sessions.\n# They are specific to each request.\n# http://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Requests\nSESSION_IGNORED_HEADER_PREFIXES = ['Content-', 'If-']\n\n\ndef get_response(requests_session, session_name,\n                 config_dir, args, read_only=False):\n    \"\"\"Like `client.get_responses`, but applies permanent\n    aspects of the session to the request.\n\n    \"\"\"\n    from .client import get_requests_kwargs, dump_request\n    if os.path.sep in session_name:\n        path = os.path.expanduser(session_name)\n    else:\n        hostname = (args.headers.get('Host', None) or\n                    urlsplit(args.url).netloc.split('@')[-1])\n        if not hostname:\n            # HACK/FIXME: httpie-unixsocket's URLs have no hostname.\n            hostname = 'localhost'\n\n        # host:port => host_port\n        hostname = hostname.replace(':', '_')\n        path = os.path.join(config_dir,\n                            SESSIONS_DIR_NAME,\n                            hostname,\n                            session_name + '.json')\n\n    session = Session(path)\n    session.load()\n\n    kwargs = get_requests_kwargs(args, base_headers=session.headers)\n    if args.debug:\n        dump_request(kwargs)\n    session.update_headers(kwargs['headers'])\n\n    if args.auth_plugin:\n        session.auth = {\n            'type': args.auth_plugin.auth_type,\n            'raw_auth': args.auth_plugin.raw_auth,\n        }\n    elif session.auth:\n        kwargs['auth'] = session.auth\n\n    requests_session.cookies = session.cookies\n\n    try:\n        response = requests_session.request(**kwargs)\n    except Exception:\n        raise\n    else:\n        # Existing sessions with `read_only=True` don't get updated.\n        if session.is_new() or not read_only:\n            session.cookies = requests_session.cookies\n            session.save()\n        return response\n\n\nclass Session(BaseConfigDict):\n    helpurl = 'https://httpie.org/docs#sessions'\n    about = 'HTTPie session file'\n\n    def __init__(self, path, *args, **kwargs):\n        super(Session, self).__init__(*args, **kwargs)\n        self._path = path\n        self['headers'] = {}\n        self['cookies'] = {}\n        self['auth'] = {\n            'type': None,\n            'username': None,\n            'password': None\n        }\n\n    def _get_path(self):\n        return self._path\n\n    def update_headers(self, request_headers):\n        \"\"\"\n        Update the session headers with the request ones while ignoring\n        certain name prefixes.\n\n        :type request_headers: dict\n\n        \"\"\"\n        for name, value in request_headers.items():\n\n            if value is None:\n                continue  # Ignore explicitely unset headers\n\n            value = value.decode('utf8')\n            if name == 'User-Agent' and value.startswith('HTTPie/'):\n                continue\n\n            for prefix in SESSION_IGNORED_HEADER_PREFIXES:\n                if name.lower().startswith(prefix.lower()):\n                    break\n            else:\n                self['headers'][name] = value\n\n    @property\n    def headers(self):\n        return self['headers']\n\n    @property\n    def cookies(self):\n        jar = RequestsCookieJar()\n        for name, cookie_dict in self['cookies'].items():\n            jar.set_cookie(create_cookie(\n                name, cookie_dict.pop('value'), **cookie_dict))\n        jar.clear_expired_cookies()\n        return jar\n\n    @cookies.setter\n    def cookies(self, jar):\n        \"\"\"\n        :type jar: CookieJar\n        \n \n# http://docs.python.org/2/library/cookielib.html#cookie-objects\n# New style\n# Old style\n", "content": "\"\"\"Persistent, JSON-serialized sessions.\n\n\"\"\"\nimport re\nimport os\n\nfrom requests.cookies import RequestsCookieJar, create_cookie\n\nfrom httpie.compat import urlsplit\nfrom httpie.config import BaseConfigDict, DEFAULT_CONFIG_DIR\nfrom httpie.plugins import plugin_manager\n\n\nSESSIONS_DIR_NAME = 'sessions'\nDEFAULT_SESSIONS_DIR = os.path.join(DEFAULT_CONFIG_DIR, SESSIONS_DIR_NAME)\nVALID_SESSION_NAME_PATTERN = re.compile('^[a-zA-Z0-9_.-]+$')\n# Request headers starting with these prefixes won't be stored in sessions.\n# They are specific to each request.\n# http://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Requests\nSESSION_IGNORED_HEADER_PREFIXES = ['Content-', 'If-']\n\n\ndef get_response(requests_session, session_name,\n                 config_dir, args, read_only=False):\n    \"\"\"Like `client.get_responses`, but applies permanent\n    aspects of the session to the request.\n\n    \"\"\"\n    from .client import get_requests_kwargs, dump_request\n    if os.path.sep in session_name:\n        path = os.path.expanduser(session_name)\n    else:\n        hostname = (args.headers.get('Host', None) or\n                    urlsplit(args.url).netloc.split('@')[-1])\n        if not hostname:\n            # HACK/FIXME: httpie-unixsocket's URLs have no hostname.\n            hostname = 'localhost'\n\n        # host:port => host_port\n        hostname = hostname.replace(':', '_')\n        path = os.path.join(config_dir,\n                            SESSIONS_DIR_NAME,\n                            hostname,\n                            session_name + '.json')\n\n    session = Session(path)\n    session.load()\n\n    kwargs = get_requests_kwargs(args, base_headers=session.headers)\n    if args.debug:\n        dump_request(kwargs)\n    session.update_headers(kwargs['headers'])\n\n    if args.auth_plugin:\n        session.auth = {\n            'type': args.auth_plugin.auth_type,\n            'raw_auth': args.auth_plugin.raw_auth,\n        }\n    elif session.auth:\n        kwargs['auth'] = session.auth\n\n    requests_session.cookies = session.cookies\n\n    try:\n        response = requests_session.request(**kwargs)\n    except Exception:\n        raise\n    else:\n        # Existing sessions with `read_only=True` don't get updated.\n        if session.is_new() or not read_only:\n            session.cookies = requests_session.cookies\n            session.save()\n        return response\n\n\nclass Session(BaseConfigDict):\n    helpurl = 'https://httpie.org/docs#sessions'\n    about = 'HTTPie session file'\n\n    def __init__(self, path, *args, **kwargs):\n        super(Session, self).__init__(*args, **kwargs)\n        self._path = path\n        self['headers'] = {}\n        self['cookies'] = {}\n        self['auth'] = {\n            'type': None,\n            'username': None,\n            'password': None\n        }\n\n    def _get_path(self):\n        return self._path\n\n    def update_headers(self, request_headers):\n        \"\"\"\n        Update the session headers with the request ones while ignoring\n        certain name prefixes.\n\n        :type request_headers: dict\n\n        \"\"\"\n        for name, value in request_headers.items():\n\n            if value is None:\n                continue  # Ignore explicitely unset headers\n\n            value = value.decode('utf8')\n            if name == 'User-Agent' and value.startswith('HTTPie/'):\n                continue\n\n            for prefix in SESSION_IGNORED_HEADER_PREFIXES:\n                if name.lower().startswith(prefix.lower()):\n                    break\n            else:\n                self['headers'][name] = value\n\n    @property\n    def headers(self):\n        return self['headers']\n\n    @property\n    def cookies(self):\n        jar = RequestsCookieJar()\n        for name, cookie_dict in self['cookies'].items():\n            jar.set_cookie(create_cookie(\n                name, cookie_dict.pop('value'), **cookie_dict))\n        jar.clear_expired_cookies()\n        return jar\n\n    @cookies.setter\n    def cookies(self, jar):\n        \"\"\"\n        :type jar: CookieJar\n        \"\"\"\n        # http://docs.python.org/2/library/cookielib.html#cookie-objects\n        stored_attrs = ['value', 'path', 'secure', 'expires']\n        self['cookies'] = {}\n        for cookie in jar:\n            self['cookies'][cookie.name] = {\n                attname: getattr(cookie, attname)\n                for attname in stored_attrs\n            }\n\n    @property\n    def auth(self):\n        auth = self.get('auth', None)\n        if not auth or not auth['type']:\n            return\n\n        plugin = plugin_manager.get_auth_plugin(auth['type'])()\n\n        credentials = {'username': None, 'password': None}\n        try:\n            # New style\n            plugin.raw_auth = auth['raw_auth']\n        except KeyError:\n            # Old style\n            credentials = {\n                'username': auth['username'],\n                'password': auth['password'],\n            }\n        else:\n            if plugin.auth_parse:\n                from httpie.input import parse_auth\n                parsed = parse_auth(plugin.raw_auth)\n                credentials = {\n                    'username': parsed.key,\n                    'password': parsed.value,\n                }\n\n        return plugin.get_auth(**credentials)\n\n    @auth.setter\n    def auth(self, auth):\n        assert set(['type', 'raw_auth']) == set(auth.keys())\n        self['auth'] = auth\n", "description": "Modern command line HTTP client \u2013 user-friendly curl alternative with intuitive UI, JSON support, syntax highlighting, wget-like downloads, extensions, etc.  https://httpie.org", "file_name": "sessions.py", "language": "Python", "project_name": "httpie", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/jakubroztocil_httpie/jakubroztocil-httpie-0f4dce9/httpie/sessions.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:20:06Z", "url": "https://github.com/jakubroztocil/httpie", "wiki": false}