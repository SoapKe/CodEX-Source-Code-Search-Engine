{"author": "odoo", "code": "# -*- coding: utf-8 -*-\n\n\nimport time\n\nfrom odoo import api, fields, models\n\n\nclass ProductProduct(models.Model):\n    _inherit = \"product.product\"\n\n    date_from = fields.Date(compute='_compute_product_margin_fields_values', string='Margin Date From')\n    date_to = fields.Date(compute='_compute_product_margin_fields_values', string='Margin Date To')\n    invoice_state = fields.Selection(compute='_compute_product_margin_fields_values',\n        selection=[\n            ('paid', 'Paid'),\n            ('open_paid', 'Open and Paid'),\n            ('draft_open_paid', 'Draft, Open and Paid')\n        ], string='Invoice State', readonly=True)\n    sale_avg_price = fields.Float(compute='_compute_product_margin_fields_values', string='Avg. Unit Price',\n        help=\"Avg. Price in Customer Invoices.\")\n    purchase_avg_price = fields.Float(compute='_compute_product_margin_fields_values', string='Avg. Unit Price',\n        help=\"Avg. Price in Vendor Bills \")\n    sale_num_invoiced = fields.Float(compute='_compute_product_margin_fields_values', string='# Invoiced in Sale',\n        help=\"Sum of Quantity in Customer Invoices\")\n    purchase_num_invoiced = fields.Float(compute='_compute_product_margin_fields_values', string='# Invoiced in Purchase',\n        help=\"Sum of Quantity in Vendor Bills\")\n    sales_gap = fields.Float(compute='_compute_product_margin_fields_values', string='Sales Gap',\n        help=\"Expected Sale - Turn Over\")\n    purchase_gap = fields.Float(compute='_compute_product_margin_fields_values', string='Purchase Gap',\n        help=\"Normal Cost - Total Cost\")\n    turnover = fields.Float(compute='_compute_product_margin_fields_values', string='Turnover',\n        help=\"Sum of Multiplication of Invoice price and quantity of Customer Invoices\")\n    total_cost = fields.Float(compute='_compute_product_margin_fields_values', string='Total Cost',\n        help=\"Sum of Multiplication of Invoice price and quantity of Vendor Bills \")\n    sale_expected = fields.Float(compute='_compute_product_margin_fields_values', string='Expected Sale',\n        help=\"Sum of Multiplication of Sale Catalog price and quantity of Customer Invoices\")\n    normal_cost = fields.Float(compute='_compute_product_margin_fields_values', string='Normal Cost',\n        help=\"Sum of Multiplication of Cost price and quantity of Vendor Bills\")\n    total_margin = fields.Float(compute='_compute_product_margin_fields_values', string='Total Margin',\n        help=\"Turnover - Standard price\")\n    expected_margin = fields.Float(compute='_compute_product_margin_fields_values', string='Expected Margin',\n        help=\"Expected Sale - Normal Cost\")\n    total_margin_rate = fields.Float(compute='_compute_product_margin_fields_values', string='Total Margin Rate(%)',\n        help=\"Total margin * 100 / Turnover\")\n    expected_margin_rate = fields.Float(compute='_compute_product_margin_fields_values', string='Expected Margin (%)',\n        help=\"Expected margin * 100 / Expected Sale\")\n\n    @api.model\n    def read_group(self, domain, fields, groupby, offset=0, limit=None, orderby=False, lazy=True):\n        \"\"\"\n            Inherit read_group to calculate the sum of the non-stored fields, as it is not automatically done anymore through the XML.\n        \"\"\"\n        res = super(ProductProduct, self).read_group(domain, fields, groupby, offset=offset, limit=limit, orderby=orderby, lazy=lazy)\n        fields_list = ['turnover', 'sale_avg_price', 'sale_purchase_price', 'sale_num_invoiced', 'purchase_num_invoiced',\n                       'sales_gap', 'purchase_gap', 'total_cost', 'sale_expected', 'normal_cost', 'total_margin',\n                       'expected_margin', 'total_margin_rate', 'expected_margin_rate']\n        if any(x in fields for x in fields_list):\n            \n            re_ind = 0\n            prod_re = {}\n            tot_products = self.browse([])\n            for re in res:\n                if re.get('__domain'):\n                    products = self.search(re['__domain'])\n                    tot_products |= products\n                    for prod in products:\n                        prod_re[prod.id] = re_ind\n                re_ind += 1\n            res_val = tot_products._compute_product_margin_fields_values(field_names=[x for x in fields if fields in fields_list])\n            for key in res_val:\n                for l in res_val[key]:\n                    re = res[prod_re[key]]\n                    if re.get(l):\n                        re[l] += res_val[key][l]\n                    else:\n                        re[l] = res_val[key][l]\n        return res\n\n    def _compute_product_margin_fields_values(self, field_names=None):\n        res = {}\n        if field_names is None:\n            field_names = []\n        for val in self:\n            res[val.id] = {}\n            date_from = self.env.context.get('date_from', time.strftime('%Y-01-01'))\n            date_to = self.env.context.get('date_to', time.strftime('%Y-12-31'))\n            invoice_state = self.env.context.get('invoice_state', 'open_paid')\n            res[val.id]['date_from'] = date_from\n            res[val.id]['date_to'] = date_to\n            res[val.id]['invoice_state'] = invoice_state\n            invoice_types = ()\n            states = ()\n            if invoice_state == 'paid':\n                states = ('paid',)\n            elif invoice_state == 'open_paid':\n                states = ('open', 'paid')\n            elif invoice_state == 'draft_open_paid':\n                states = ('draft', 'open', 'paid')\n            if \"force_company\" in self.env.context:\n                company_id = self.env.context['force_company']\n            else:\n                company_id = self.env.user.company_id.id\n\n            \n            sqlstr = \"\"\"\n                select\n                    sum(l.price_unit * l.quantity)/nullif(sum(l.quantity),0) as avg_unit_price,\n                    sum(l.quantity) as num_qty,\n                    sum(l.quantity * (l.price_subtotal/(nullif(l.quantity,0)))) as total,\n                    sum(l.quantity * pt.list_price) as sale_expected\n                from account_invoice_line l\n                left join account_invoice i on (l.invoice_id = i.id)\n                left join product_product product on (product.id=l.product_id)\n                left join product_template pt on (pt.id = product.product_tmpl_id)\n                where l.product_id = %s and i.state in %s and i.type IN %s and (i.date_invoice IS NULL or (i.date_invoice>=%s and i.date_invoice<=%s and i.company_id=%s))\n                \"\"\"\n            invoice_types = ('out_invoice', 'in_refund')\n            self.env.cr.execute(sqlstr, (val.id, states, invoice_types, date_from, date_to, company_id))\n            result = self.env.cr.fetchall()[0]\n            res[val.id]['sale_avg_price'] = result[0] and result[0] or 0.0\n            res[val.id]['sale_num_invoiced'] = result[1] and result[1] or 0.0\n            res[val.id]['turnover'] = result[2] and result[2] or 0.0\n            res[val.id]['sale_expected'] = result[3] and result[3] or 0.0\n            res[val.id]['sales_gap'] = res[val.id]['sale_expected'] - res[val.id]['turnover']\n            ctx = self.env.context.copy()\n            ctx['force_company'] = company_id\n            invoice_types = ('in_invoice', 'out_refund')\n            self.env.cr.execute(sqlstr, (val.id, states, invoice_types, date_from, date_to, company_id))\n            result = self.env.cr.fetchall()[0]\n            res[val.id]['purchase_avg_price'] = result[0] and result[0] or 0.0\n            res[val.id]['purchase_num_invoiced'] = result[1] and result[1] or 0.0\n            res[val.id]['total_cost'] = result[2] and result[2] or 0.0\n            res[val.id]['normal_cost'] = val.standard_price * res[val.id]['purchase_num_invoiced']\n            res[val.id]['purchase_gap'] = res[val.id]['normal_cost'] - res[val.id]['total_cost']\n\n            res[val.id]['total_margin'] = res[val.id]['turnover'] - res[val.id]['total_cost']\n            res[val.id]['expected_margin'] = res[val.id]['sale_expected'] - res[val.id]['normal_cost']\n            res[val.id]['total_margin_rate'] = res[val.id]['turnover'] and res[val.id]['total_margin'] * 100 / res[val.id]['turnover'] or 0.0\n            res[val.id]['expected_margin_rate'] = res[val.id]['sale_expected'] and res[val.id]['expected_margin'] * 100 / res[val.id]['sale_expected'] or 0.0\n            for k, v in res[val.id].items():\n                setattr(val, k, v)\n        return res\n", "comments": "                inherit read group calculate sum non stored fields  automatically done anymore xml                      res   super(productproduct  self) read group(domain  fields  groupby  offset offset  limit limit  orderby orderby  lazy lazy)         fields list     turnover    sale avg price    sale purchase price    sale num invoiced    purchase num invoiced                           sales gap    purchase gap    total cost    sale expected    normal cost    total margin                           expected margin    total margin rate    expected margin rate           any(x fields x fields list)                calculate first every product line needs applied             ind   0             prod                  tot products   self browse(  )             res                  get(   domain )                      products   self search(re    domain  )                     tot products    products                     prod products                          prod prod id    ind                 ind    1             res val   tot products  compute product margin fields values(field names  x x fields fields fields list )             key res val                  l res val key                         res prod key                       get(l)                          l     res val key  l                      else                          l    res val key  l          return res      def  compute product margin fields values(self  field names none)          res              field names none              field names              val self              res val id                   date   self env context get( date   time strftime(  y 01 01 ))             date   self env context get( date   time strftime(  y 12 31 ))             invoice state   self env context get( invoice state    open paid )             res val id   date     date             res val id   date     date             res val id   invoice state     invoice state             invoice types   ()             states   ()             invoice state     paid                   states   ( paid  )             elif invoice state     open paid                   states   ( open    paid )             elif invoice state     draft open paid                   states   ( draft    open    paid )              force company  self env context                  company id   self env context  force company               else                  company id   self env user company id id               cost price calculated afterwards property             sqlstr                       select                     sum(l price unit   l quantity) nullif(sum(l quantity) 0) avg unit price                      sum(l quantity) num qty                      sum(l quantity   (l price subtotal (nullif(l quantity 0)))) total                      sum(l quantity   pt list price) sale expected                 account invoice line l                 left join account invoice (l invoice id   id)                 left join product product product (product id l product id)                 left join product template pt (pt id   product product tmpl id)                 l product id    state  type in  (i date invoice is null (i date invoice   date invoice   company id  s))                            coding  utf 8        part odoo  see license file full copyright licensing details     calculate first every product line needs applied   cost price calculated afterwards property ", "content": "# -*- coding: utf-8 -*-\n# Part of Odoo. See LICENSE file for full copyright and licensing details.\n\nimport time\n\nfrom odoo import api, fields, models\n\n\nclass ProductProduct(models.Model):\n    _inherit = \"product.product\"\n\n    date_from = fields.Date(compute='_compute_product_margin_fields_values', string='Margin Date From')\n    date_to = fields.Date(compute='_compute_product_margin_fields_values', string='Margin Date To')\n    invoice_state = fields.Selection(compute='_compute_product_margin_fields_values',\n        selection=[\n            ('paid', 'Paid'),\n            ('open_paid', 'Open and Paid'),\n            ('draft_open_paid', 'Draft, Open and Paid')\n        ], string='Invoice State', readonly=True)\n    sale_avg_price = fields.Float(compute='_compute_product_margin_fields_values', string='Avg. Unit Price',\n        help=\"Avg. Price in Customer Invoices.\")\n    purchase_avg_price = fields.Float(compute='_compute_product_margin_fields_values', string='Avg. Unit Price',\n        help=\"Avg. Price in Vendor Bills \")\n    sale_num_invoiced = fields.Float(compute='_compute_product_margin_fields_values', string='# Invoiced in Sale',\n        help=\"Sum of Quantity in Customer Invoices\")\n    purchase_num_invoiced = fields.Float(compute='_compute_product_margin_fields_values', string='# Invoiced in Purchase',\n        help=\"Sum of Quantity in Vendor Bills\")\n    sales_gap = fields.Float(compute='_compute_product_margin_fields_values', string='Sales Gap',\n        help=\"Expected Sale - Turn Over\")\n    purchase_gap = fields.Float(compute='_compute_product_margin_fields_values', string='Purchase Gap',\n        help=\"Normal Cost - Total Cost\")\n    turnover = fields.Float(compute='_compute_product_margin_fields_values', string='Turnover',\n        help=\"Sum of Multiplication of Invoice price and quantity of Customer Invoices\")\n    total_cost = fields.Float(compute='_compute_product_margin_fields_values', string='Total Cost',\n        help=\"Sum of Multiplication of Invoice price and quantity of Vendor Bills \")\n    sale_expected = fields.Float(compute='_compute_product_margin_fields_values', string='Expected Sale',\n        help=\"Sum of Multiplication of Sale Catalog price and quantity of Customer Invoices\")\n    normal_cost = fields.Float(compute='_compute_product_margin_fields_values', string='Normal Cost',\n        help=\"Sum of Multiplication of Cost price and quantity of Vendor Bills\")\n    total_margin = fields.Float(compute='_compute_product_margin_fields_values', string='Total Margin',\n        help=\"Turnover - Standard price\")\n    expected_margin = fields.Float(compute='_compute_product_margin_fields_values', string='Expected Margin',\n        help=\"Expected Sale - Normal Cost\")\n    total_margin_rate = fields.Float(compute='_compute_product_margin_fields_values', string='Total Margin Rate(%)',\n        help=\"Total margin * 100 / Turnover\")\n    expected_margin_rate = fields.Float(compute='_compute_product_margin_fields_values', string='Expected Margin (%)',\n        help=\"Expected margin * 100 / Expected Sale\")\n\n    @api.model\n    def read_group(self, domain, fields, groupby, offset=0, limit=None, orderby=False, lazy=True):\n        \"\"\"\n            Inherit read_group to calculate the sum of the non-stored fields, as it is not automatically done anymore through the XML.\n        \"\"\"\n        res = super(ProductProduct, self).read_group(domain, fields, groupby, offset=offset, limit=limit, orderby=orderby, lazy=lazy)\n        fields_list = ['turnover', 'sale_avg_price', 'sale_purchase_price', 'sale_num_invoiced', 'purchase_num_invoiced',\n                       'sales_gap', 'purchase_gap', 'total_cost', 'sale_expected', 'normal_cost', 'total_margin',\n                       'expected_margin', 'total_margin_rate', 'expected_margin_rate']\n        if any(x in fields for x in fields_list):\n            # Calculate first for every product in which line it needs to be applied\n            re_ind = 0\n            prod_re = {}\n            tot_products = self.browse([])\n            for re in res:\n                if re.get('__domain'):\n                    products = self.search(re['__domain'])\n                    tot_products |= products\n                    for prod in products:\n                        prod_re[prod.id] = re_ind\n                re_ind += 1\n            res_val = tot_products._compute_product_margin_fields_values(field_names=[x for x in fields if fields in fields_list])\n            for key in res_val:\n                for l in res_val[key]:\n                    re = res[prod_re[key]]\n                    if re.get(l):\n                        re[l] += res_val[key][l]\n                    else:\n                        re[l] = res_val[key][l]\n        return res\n\n    def _compute_product_margin_fields_values(self, field_names=None):\n        res = {}\n        if field_names is None:\n            field_names = []\n        for val in self:\n            res[val.id] = {}\n            date_from = self.env.context.get('date_from', time.strftime('%Y-01-01'))\n            date_to = self.env.context.get('date_to', time.strftime('%Y-12-31'))\n            invoice_state = self.env.context.get('invoice_state', 'open_paid')\n            res[val.id]['date_from'] = date_from\n            res[val.id]['date_to'] = date_to\n            res[val.id]['invoice_state'] = invoice_state\n            invoice_types = ()\n            states = ()\n            if invoice_state == 'paid':\n                states = ('paid',)\n            elif invoice_state == 'open_paid':\n                states = ('open', 'paid')\n            elif invoice_state == 'draft_open_paid':\n                states = ('draft', 'open', 'paid')\n            if \"force_company\" in self.env.context:\n                company_id = self.env.context['force_company']\n            else:\n                company_id = self.env.user.company_id.id\n\n            #Cost price is calculated afterwards as it is a property\n            sqlstr = \"\"\"\n                select\n                    sum(l.price_unit * l.quantity)/nullif(sum(l.quantity),0) as avg_unit_price,\n                    sum(l.quantity) as num_qty,\n                    sum(l.quantity * (l.price_subtotal/(nullif(l.quantity,0)))) as total,\n                    sum(l.quantity * pt.list_price) as sale_expected\n                from account_invoice_line l\n                left join account_invoice i on (l.invoice_id = i.id)\n                left join product_product product on (product.id=l.product_id)\n                left join product_template pt on (pt.id = product.product_tmpl_id)\n                where l.product_id = %s and i.state in %s and i.type IN %s and (i.date_invoice IS NULL or (i.date_invoice>=%s and i.date_invoice<=%s and i.company_id=%s))\n                \"\"\"\n            invoice_types = ('out_invoice', 'in_refund')\n            self.env.cr.execute(sqlstr, (val.id, states, invoice_types, date_from, date_to, company_id))\n            result = self.env.cr.fetchall()[0]\n            res[val.id]['sale_avg_price'] = result[0] and result[0] or 0.0\n            res[val.id]['sale_num_invoiced'] = result[1] and result[1] or 0.0\n            res[val.id]['turnover'] = result[2] and result[2] or 0.0\n            res[val.id]['sale_expected'] = result[3] and result[3] or 0.0\n            res[val.id]['sales_gap'] = res[val.id]['sale_expected'] - res[val.id]['turnover']\n            ctx = self.env.context.copy()\n            ctx['force_company'] = company_id\n            invoice_types = ('in_invoice', 'out_refund')\n            self.env.cr.execute(sqlstr, (val.id, states, invoice_types, date_from, date_to, company_id))\n            result = self.env.cr.fetchall()[0]\n            res[val.id]['purchase_avg_price'] = result[0] and result[0] or 0.0\n            res[val.id]['purchase_num_invoiced'] = result[1] and result[1] or 0.0\n            res[val.id]['total_cost'] = result[2] and result[2] or 0.0\n            res[val.id]['normal_cost'] = val.standard_price * res[val.id]['purchase_num_invoiced']\n            res[val.id]['purchase_gap'] = res[val.id]['normal_cost'] - res[val.id]['total_cost']\n\n            res[val.id]['total_margin'] = res[val.id]['turnover'] - res[val.id]['total_cost']\n            res[val.id]['expected_margin'] = res[val.id]['sale_expected'] - res[val.id]['normal_cost']\n            res[val.id]['total_margin_rate'] = res[val.id]['turnover'] and res[val.id]['total_margin'] * 100 / res[val.id]['turnover'] or 0.0\n            res[val.id]['expected_margin_rate'] = res[val.id]['sale_expected'] and res[val.id]['expected_margin'] * 100 / res[val.id]['sale_expected'] or 0.0\n            for k, v in res[val.id].items():\n                setattr(val, k, v)\n        return res\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "product_product.py", "id": "8b66acfcbad79e45ef27fda1746861a5", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/product_margin/models/product_product.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}