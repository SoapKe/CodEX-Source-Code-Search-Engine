{"author": "pallets", "code": "\n\n        self.record_once(lambda s: s.app._register_error_handler(\n            self.name, code_or_exception, f))\n", "comments": "\n    flask.blueprints\n    ~~~~~~~~~~~~~~~~\n\n    Blueprints are the recommended way to implement larger or more\n    pluggable applications in Flask 0.7 and later.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nfrom functools import update_wrapper\n\nfrom .helpers import _PackageBoundObject, _endpoint_from_view_func\n\n\nclass BlueprintSetupState(object):\n    \"\"\"Temporary holder object for registering a blueprint with the\n    application.  An instance of this class is created by the\n    :meth:`~flask.Blueprint.make_setup_state` method and later passed\n    to all register callback functions.\n    \"\"\"\n\n    def __init__(self, blueprint, app, options, first_registration):\n        #: a reference to the current application\n        self.app = app\n\n        #: a reference to the blueprint that created this setup state.\n        self.blueprint = blueprint\n\n        #: a dictionary with all options that were passed to the\n        #: :meth:`~flask.Flask.register_blueprint` method.\n        self.options = options\n\n        #: as blueprints can be registered multiple times with the\n        #: application and not everything wants to be registered\n        #: multiple times on it, this attribute can be used to figure\n        #: out if the blueprint was registered in the past already.\n        self.first_registration = first_registration\n\n        subdomain = self.options.get('subdomain')\n        if subdomain is None:\n            subdomain = self.blueprint.subdomain\n\n        #: The subdomain that the blueprint should be active for, ``None``\n        #: otherwise.\n        self.subdomain = subdomain\n\n        url_prefix = self.options.get('url_prefix')\n        if url_prefix is None:\n            url_prefix = self.blueprint.url_prefix\n\n        #: The prefix that should be used for all URLs defined on the\n        #: blueprint.\n        if url_prefix and url_prefix[-1] == '/':\n            url_prefix = url_prefix[:-1]\n\n        self.url_prefix = url_prefix\n\n        #: A dictionary with URL defaults that is added to each and every\n        #: URL that was defined with the blueprint.\n        self.url_defaults = dict(self.blueprint.url_values_defaults)\n        self.url_defaults.update(self.options.get('url_defaults', ()))\n\n    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n        \"\"\"A helper method to register a rule (and optionally a view function)\n        to the application.  The endpoint is automatically prefixed with the\n        blueprint's name.\n        \"\"\"\n        if self.url_prefix:\n            rule = self.url_prefix + rule\n        options.setdefault('subdomain', self.subdomain)\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        defaults = self.url_defaults\n        if 'defaults' in options:\n            defaults = dict(defaults, **options.pop('defaults'))\n        self.app.add_url_rule(rule, '%s.%s' % (self.blueprint.name, endpoint),\n                              view_func, defaults=defaults, **options)\n\n\nclass Blueprint(_PackageBoundObject):\n    \"\"\"Represents a blueprint.  A blueprint is an object that records\n    functions that will be called with the\n    :class:`~flask.blueprints.BlueprintSetupState` later to register functions\n    or other things on the main application.  See :ref:`blueprints` for more\n    information.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    warn_on_modifications = False\n    _got_registered_once = False\n\n    #: Blueprint local JSON decoder class to use.\n    #: Set to ``None`` to use the app's :class:`~flask.app.Flask.json_encoder`.\n    json_encoder = None\n    #: Blueprint local JSON decoder class to use.\n    #: Set to ``None`` to use the app's :class:`~flask.app.Flask.json_decoder`.\n    json_decoder = None\n\n    # TODO remove the next three attrs when Sphinx :inherited-members: works\n    # https://github.com/sphinx-doc/sphinx/issues/741\n\n    #: The name of the package or module that this app belongs to. Do not\n    #: change this once it is set by the constructor.\n    import_name = None\n\n    #: Location of the template files to be added to the template lookup.\n    #: ``None`` if templates should not be added.\n    template_folder = None\n\n    #: Absolute path to the package on the filesystem. Used to look up\n    #: resources contained in the package.\n    root_path = None\n\n    def __init__(self, name, import_name, static_folder=None,\n                 static_url_path=None, template_folder=None,\n                 url_prefix=None, subdomain=None, url_defaults=None,\n                 root_path=None):\n        _PackageBoundObject.__init__(self, import_name, template_folder,\n                                     root_path=root_path)\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = subdomain\n        self.static_folder = static_folder\n        self.static_url_path = static_url_path\n        self.deferred_functions = []\n        if url_defaults is None:\n            url_defaults = {}\n        self.url_values_defaults = url_defaults\n\n    def record(self, func):\n        \"\"\"Registers a function that is called when the blueprint is\n        registered on the application.  This function is called with the\n        state as argument as returned by the :meth:`make_setup_state`\n        method.\n        \"\"\"\n        if self._got_registered_once and self.warn_on_modifications:\n            from warnings import warn\n            warn(Warning('The blueprint was already registered once '\n                         'but is getting modified now.  These changes '\n                         'will not show up.'))\n        self.deferred_functions.append(func)\n\n    def record_once(self, func):\n        \"\"\"Works like :meth:`record` but wraps the function in another\n        function that will ensure the function is only called once.  If the\n        blueprint is registered a second time on the application, the\n        function passed is not called.\n        \"\"\"\n        def wrapper(state):\n            if state.first_registration:\n                func(state)\n        return self.record(update_wrapper(wrapper, func))\n\n    def make_setup_state(self, app, options, first_registration=False):\n        \"\"\"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\n        object that is later passed to the register callback functions.\n        Subclasses can override this to return a subclass of the setup state.\n        \"\"\"\n        return BlueprintSetupState(self, app, options, first_registration)\n\n    def register(self, app, options, first_registration=False):\n        \"\"\"Called by :meth:`Flask.register_blueprint` to register all views\n        and callbacks registered on the blueprint with the application. Creates\n        a :class:`.BlueprintSetupState` and calls each :meth:`record` callback\n        with it.\n\n        :param app: The application this blueprint is being registered with.\n        :param options: Keyword arguments forwarded from\n            :meth:`~Flask.register_blueprint`.\n        :param first_registration: Whether this is the first time this\n            blueprint has been registered on the application.\n        \"\"\"\n        self._got_registered_once = True\n        state = self.make_setup_state(app, options, first_registration)\n\n        if self.has_static_folder:\n            state.add_url_rule(\n                self.static_url_path + '/<path:filename>',\n                view_func=self.send_static_file, endpoint='static'\n            )\n\n        for deferred in self.deferred_functions:\n            deferred(state)\n\n    def route(self, rule, **options):\n        \"\"\"Like :meth:`Flask.route` but for a blueprint.  The endpoint for the\n        :func:`url_for` function is prefixed with the name of the blueprint.\n        \"\"\"\n        def decorator(f):\n            endpoint = options.pop(\"endpoint\", f.__name__)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n        return decorator\n\n    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n        \"\"\"Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for\n        the :func:`url_for` function is prefixed with the name of the blueprint.\n        \"\"\"\n        if endpoint:\n            assert '.' not in endpoint, \"Blueprint endpoints should not contain dots\"\n        if view_func:\n            assert '.' not in view_func.__name__, \"Blueprint view function name should not contain dots\"\n        self.record(lambda s:\n            s.add_url_rule(rule, endpoint, view_func, **options))\n\n    def endpoint(self, endpoint):\n        \"\"\"Like :meth:`Flask.endpoint` but for a blueprint.  This does not\n        prefix the endpoint with the blueprint name, this has to be done\n        explicitly by the user of this method.  If the endpoint is prefixed\n        with a `.` it will be registered to the current blueprint, otherwise\n        it's an application independent endpoint.\n        \"\"\"\n        def decorator(f):\n            def register_endpoint(state):\n                state.app.view_functions[endpoint] = f\n            self.record_once(register_endpoint)\n            return f\n        return decorator\n\n    def app_template_filter(self, name=None):\n        \"\"\"Register a custom template filter, available application wide.  Like\n        :meth:`Flask.template_filter` but for a blueprint.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_app_template_filter(f, name=name)\n            return f\n        return decorator\n\n    def add_app_template_filter(self, f, name=None):\n        \"\"\"Register a custom template filter, available application wide.  Like\n        :meth:`Flask.add_template_filter` but for a blueprint.  Works exactly\n        like the :meth:`app_template_filter` decorator.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        def register_template(state):\n            state.app.jinja_env.filters[name or f.__name__] = f\n        self.record_once(register_template)\n\n    def app_template_test(self, name=None):\n        \"\"\"Register a custom template test, available application wide.  Like\n        :meth:`Flask.template_test` but for a blueprint.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_app_template_test(f, name=name)\n            return f\n        return decorator\n\n    def add_app_template_test(self, f, name=None):\n        \"\"\"Register a custom template test, available application wide.  Like\n        :meth:`Flask.add_template_test` but for a blueprint.  Works exactly\n        like the :meth:`app_template_test` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        def register_template(state):\n            state.app.jinja_env.tests[name or f.__name__] = f\n        self.record_once(register_template)\n\n    def app_template_global(self, name=None):\n        \"\"\"Register a custom template global, available application wide.  Like\n        :meth:`Flask.template_global` but for a blueprint.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_app_template_global(f, name=name)\n            return f\n        return decorator\n\n    def add_app_template_global(self, f, name=None):\n        \"\"\"Register a custom template global, available application wide.  Like\n        :meth:`Flask.add_template_global` but for a blueprint.  Works exactly\n        like the :meth:`app_template_global` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global, otherwise the\n                     function name will be used.\n        \"\"\"\n        def register_template(state):\n            state.app.jinja_env.globals[name or f.__name__] = f\n        self.record_once(register_template)\n\n    def before_request(self, f):\n        \"\"\"Like :meth:`Flask.before_request` but for a blueprint.  This function\n        is only executed before each request that is handled by a function of\n        that blueprint.\n        \"\"\"\n        self.record_once(lambda s: s.app.before_request_funcs\n            .setdefault(self.name, []).append(f))\n        return f\n\n    def before_app_request(self, f):\n        \"\"\"Like :meth:`Flask.before_request`.  Such a function is executed\n        before each request, even if outside of a blueprint.\n        \"\"\"\n        self.record_once(lambda s: s.app.before_request_funcs\n            .setdefault(None, []).append(f))\n        return f\n\n    def before_app_first_request(self, f):\n        \"\"\"Like :meth:`Flask.before_first_request`.  Such a function is\n        executed before the first request to the application.\n        \"\"\"\n        self.record_once(lambda s: s.app.before_first_request_funcs.append(f))\n        return f\n\n    def after_request(self, f):\n        \"\"\"Like :meth:`Flask.after_request` but for a blueprint.  This function\n        is only executed after each request that is handled by a function of\n        that blueprint.\n        \"\"\"\n        self.record_once(lambda s: s.app.after_request_funcs\n            .setdefault(self.name, []).append(f))\n        return f\n\n    def after_app_request(self, f):\n        \"\"\"Like :meth:`Flask.after_request` but for a blueprint.  Such a function\n        is executed after each request, even if outside of the blueprint.\n        \"\"\"\n        self.record_once(lambda s: s.app.after_request_funcs\n            .setdefault(None, []).append(f))\n        return f\n\n    def teardown_request(self, f):\n        \"\"\"Like :meth:`Flask.teardown_request` but for a blueprint.  This\n        function is only executed when tearing down requests handled by a\n        function of that blueprint.  Teardown request functions are executed\n        when the request context is popped, even when no actual request was\n        performed.\n        \"\"\"\n        self.record_once(lambda s: s.app.teardown_request_funcs\n            .setdefault(self.name, []).append(f))\n        return f\n\n    def teardown_app_request(self, f):\n        \"\"\"Like :meth:`Flask.teardown_request` but for a blueprint.  Such a\n        function is executed when tearing down each request, even if outside of\n        the blueprint.\n        \"\"\"\n        self.record_once(lambda s: s.app.teardown_request_funcs\n            .setdefault(None, []).append(f))\n        return f\n\n    def context_processor(self, f):\n        \"\"\"Like :meth:`Flask.context_processor` but for a blueprint.  This\n        function is only executed for requests handled by a blueprint.\n        \"\"\"\n        self.record_once(lambda s: s.app.template_context_processors\n            .setdefault(self.name, []).append(f))\n        return f\n\n    def app_context_processor(self, f):\n        \"\"\"Like :meth:`Flask.context_processor` but for a blueprint.  Such a\n        function is executed each request, even if outside of the blueprint.\n        \"\"\"\n        self.record_once(lambda s: s.app.template_context_processors\n            .setdefault(None, []).append(f))\n        return f\n\n    def app_errorhandler(self, code):\n        \"\"\"Like :meth:`Flask.errorhandler` but for a blueprint.  This\n        handler is used for all requests, even if outside of the blueprint.\n        \"\"\"\n        def decorator(f):\n            self.record_once(lambda s: s.app.errorhandler(code)(f))\n            return f\n        return decorator\n\n    def url_value_preprocessor(self, f):\n        \"\"\"Registers a function as URL value preprocessor for this\n        blueprint.  It's called before the view functions are called and\n        can modify the url values provided.\n        \"\"\"\n        self.record_once(lambda s: s.app.url_value_preprocessors\n            .setdefault(self.name, []).append(f))\n        return f\n\n    def url_defaults(self, f):\n        \"\"\"Callback function for URL defaults for this blueprint.  It's called\n        with the endpoint and values and should update the values passed\n        in place.\n        \"\"\"\n        self.record_once(lambda s: s.app.url_default_functions\n            .setdefault(self.name, []).append(f))\n        return f\n\n    def app_url_value_preprocessor(self, f):\n        \"\"\"Same as :meth:`url_value_preprocessor` but application wide.\n        \"\"\"\n        self.record_once(lambda s: s.app.url_value_preprocessors\n            .setdefault(None, []).append(f))\n        return f\n\n    def app_url_defaults(self, f):\n        \"\"\"Same as :meth:`url_defaults` but application wide.\n        \"\"\"\n        self.record_once(lambda s: s.app.url_default_functions\n            .setdefault(None, []).append(f))\n        return f\n\n    def errorhandler(self, code_or_exception):\n        \"\"\"Registers an error handler that becomes active for this blueprint\n        only.  Please be aware that routing does not happen local to a\n        blueprint so an error handler for 404 usually is not handled by\n        a blueprint unless it is caused inside a view function.  Another\n        special case is the 500 internal server error which is always looked\n        up from the application.\n\n        Otherwise works as the :meth:`~flask.Flask.errorhandler` decorator\n        of the :class:`~flask.Flask` object.\n        \"\"\"\n        def decorator(f):\n            self.record_once(lambda s: s.app._register_error_handler(\n                self.name, code_or_exception, f))\n            return f\n        return decorator\n\n    def register_error_handler(self, code_or_exception, f):\n        \"\"\"Non-decorator version of the :meth:`errorhandler` error attach\n        function, akin to the :meth:`~flask.Flask.register_error_handler`\n        application-wide function of the :class:`~flask.Flask` object but\n        for error handlers limited to this blueprint.\n\n        .. versionadded:: 0.11\n        \n \n# -*- coding: utf-8 -*-\n", "content": "# -*- coding: utf-8 -*-\n\"\"\"\n    flask.blueprints\n    ~~~~~~~~~~~~~~~~\n\n    Blueprints are the recommended way to implement larger or more\n    pluggable applications in Flask 0.7 and later.\n\n    :copyright: \u00a9 2010 by the Pallets team.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\nfrom functools import update_wrapper\n\nfrom .helpers import _PackageBoundObject, _endpoint_from_view_func\n\n\nclass BlueprintSetupState(object):\n    \"\"\"Temporary holder object for registering a blueprint with the\n    application.  An instance of this class is created by the\n    :meth:`~flask.Blueprint.make_setup_state` method and later passed\n    to all register callback functions.\n    \"\"\"\n\n    def __init__(self, blueprint, app, options, first_registration):\n        #: a reference to the current application\n        self.app = app\n\n        #: a reference to the blueprint that created this setup state.\n        self.blueprint = blueprint\n\n        #: a dictionary with all options that were passed to the\n        #: :meth:`~flask.Flask.register_blueprint` method.\n        self.options = options\n\n        #: as blueprints can be registered multiple times with the\n        #: application and not everything wants to be registered\n        #: multiple times on it, this attribute can be used to figure\n        #: out if the blueprint was registered in the past already.\n        self.first_registration = first_registration\n\n        subdomain = self.options.get('subdomain')\n        if subdomain is None:\n            subdomain = self.blueprint.subdomain\n\n        #: The subdomain that the blueprint should be active for, ``None``\n        #: otherwise.\n        self.subdomain = subdomain\n\n        url_prefix = self.options.get('url_prefix')\n        if url_prefix is None:\n            url_prefix = self.blueprint.url_prefix\n\n        #: The prefix that should be used for all URLs defined on the\n        #: blueprint.\n        if url_prefix and url_prefix[-1] == '/':\n            url_prefix = url_prefix[:-1]\n\n        self.url_prefix = url_prefix\n\n        #: A dictionary with URL defaults that is added to each and every\n        #: URL that was defined with the blueprint.\n        self.url_defaults = dict(self.blueprint.url_values_defaults)\n        self.url_defaults.update(self.options.get('url_defaults', ()))\n\n    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n        \"\"\"A helper method to register a rule (and optionally a view function)\n        to the application.  The endpoint is automatically prefixed with the\n        blueprint's name.\n        \"\"\"\n        if self.url_prefix:\n            rule = self.url_prefix + rule\n        options.setdefault('subdomain', self.subdomain)\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)\n        defaults = self.url_defaults\n        if 'defaults' in options:\n            defaults = dict(defaults, **options.pop('defaults'))\n        self.app.add_url_rule(rule, '%s.%s' % (self.blueprint.name, endpoint),\n                              view_func, defaults=defaults, **options)\n\n\nclass Blueprint(_PackageBoundObject):\n    \"\"\"Represents a blueprint.  A blueprint is an object that records\n    functions that will be called with the\n    :class:`~flask.blueprints.BlueprintSetupState` later to register functions\n    or other things on the main application.  See :ref:`blueprints` for more\n    information.\n\n    .. versionadded:: 0.7\n    \"\"\"\n\n    warn_on_modifications = False\n    _got_registered_once = False\n\n    #: Blueprint local JSON decoder class to use.\n    #: Set to ``None`` to use the app's :class:`~flask.app.Flask.json_encoder`.\n    json_encoder = None\n    #: Blueprint local JSON decoder class to use.\n    #: Set to ``None`` to use the app's :class:`~flask.app.Flask.json_decoder`.\n    json_decoder = None\n\n    # TODO remove the next three attrs when Sphinx :inherited-members: works\n    # https://github.com/sphinx-doc/sphinx/issues/741\n\n    #: The name of the package or module that this app belongs to. Do not\n    #: change this once it is set by the constructor.\n    import_name = None\n\n    #: Location of the template files to be added to the template lookup.\n    #: ``None`` if templates should not be added.\n    template_folder = None\n\n    #: Absolute path to the package on the filesystem. Used to look up\n    #: resources contained in the package.\n    root_path = None\n\n    def __init__(self, name, import_name, static_folder=None,\n                 static_url_path=None, template_folder=None,\n                 url_prefix=None, subdomain=None, url_defaults=None,\n                 root_path=None):\n        _PackageBoundObject.__init__(self, import_name, template_folder,\n                                     root_path=root_path)\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = subdomain\n        self.static_folder = static_folder\n        self.static_url_path = static_url_path\n        self.deferred_functions = []\n        if url_defaults is None:\n            url_defaults = {}\n        self.url_values_defaults = url_defaults\n\n    def record(self, func):\n        \"\"\"Registers a function that is called when the blueprint is\n        registered on the application.  This function is called with the\n        state as argument as returned by the :meth:`make_setup_state`\n        method.\n        \"\"\"\n        if self._got_registered_once and self.warn_on_modifications:\n            from warnings import warn\n            warn(Warning('The blueprint was already registered once '\n                         'but is getting modified now.  These changes '\n                         'will not show up.'))\n        self.deferred_functions.append(func)\n\n    def record_once(self, func):\n        \"\"\"Works like :meth:`record` but wraps the function in another\n        function that will ensure the function is only called once.  If the\n        blueprint is registered a second time on the application, the\n        function passed is not called.\n        \"\"\"\n        def wrapper(state):\n            if state.first_registration:\n                func(state)\n        return self.record(update_wrapper(wrapper, func))\n\n    def make_setup_state(self, app, options, first_registration=False):\n        \"\"\"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\n        object that is later passed to the register callback functions.\n        Subclasses can override this to return a subclass of the setup state.\n        \"\"\"\n        return BlueprintSetupState(self, app, options, first_registration)\n\n    def register(self, app, options, first_registration=False):\n        \"\"\"Called by :meth:`Flask.register_blueprint` to register all views\n        and callbacks registered on the blueprint with the application. Creates\n        a :class:`.BlueprintSetupState` and calls each :meth:`record` callback\n        with it.\n\n        :param app: The application this blueprint is being registered with.\n        :param options: Keyword arguments forwarded from\n            :meth:`~Flask.register_blueprint`.\n        :param first_registration: Whether this is the first time this\n            blueprint has been registered on the application.\n        \"\"\"\n        self._got_registered_once = True\n        state = self.make_setup_state(app, options, first_registration)\n\n        if self.has_static_folder:\n            state.add_url_rule(\n                self.static_url_path + '/<path:filename>',\n                view_func=self.send_static_file, endpoint='static'\n            )\n\n        for deferred in self.deferred_functions:\n            deferred(state)\n\n    def route(self, rule, **options):\n        \"\"\"Like :meth:`Flask.route` but for a blueprint.  The endpoint for the\n        :func:`url_for` function is prefixed with the name of the blueprint.\n        \"\"\"\n        def decorator(f):\n            endpoint = options.pop(\"endpoint\", f.__name__)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n        return decorator\n\n    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n        \"\"\"Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for\n        the :func:`url_for` function is prefixed with the name of the blueprint.\n        \"\"\"\n        if endpoint:\n            assert '.' not in endpoint, \"Blueprint endpoints should not contain dots\"\n        if view_func:\n            assert '.' not in view_func.__name__, \"Blueprint view function name should not contain dots\"\n        self.record(lambda s:\n            s.add_url_rule(rule, endpoint, view_func, **options))\n\n    def endpoint(self, endpoint):\n        \"\"\"Like :meth:`Flask.endpoint` but for a blueprint.  This does not\n        prefix the endpoint with the blueprint name, this has to be done\n        explicitly by the user of this method.  If the endpoint is prefixed\n        with a `.` it will be registered to the current blueprint, otherwise\n        it's an application independent endpoint.\n        \"\"\"\n        def decorator(f):\n            def register_endpoint(state):\n                state.app.view_functions[endpoint] = f\n            self.record_once(register_endpoint)\n            return f\n        return decorator\n\n    def app_template_filter(self, name=None):\n        \"\"\"Register a custom template filter, available application wide.  Like\n        :meth:`Flask.template_filter` but for a blueprint.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_app_template_filter(f, name=name)\n            return f\n        return decorator\n\n    def add_app_template_filter(self, f, name=None):\n        \"\"\"Register a custom template filter, available application wide.  Like\n        :meth:`Flask.add_template_filter` but for a blueprint.  Works exactly\n        like the :meth:`app_template_filter` decorator.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        def register_template(state):\n            state.app.jinja_env.filters[name or f.__name__] = f\n        self.record_once(register_template)\n\n    def app_template_test(self, name=None):\n        \"\"\"Register a custom template test, available application wide.  Like\n        :meth:`Flask.template_test` but for a blueprint.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_app_template_test(f, name=name)\n            return f\n        return decorator\n\n    def add_app_template_test(self, f, name=None):\n        \"\"\"Register a custom template test, available application wide.  Like\n        :meth:`Flask.add_template_test` but for a blueprint.  Works exactly\n        like the :meth:`app_template_test` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        def register_template(state):\n            state.app.jinja_env.tests[name or f.__name__] = f\n        self.record_once(register_template)\n\n    def app_template_global(self, name=None):\n        \"\"\"Register a custom template global, available application wide.  Like\n        :meth:`Flask.template_global` but for a blueprint.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global, otherwise the\n                     function name will be used.\n        \"\"\"\n        def decorator(f):\n            self.add_app_template_global(f, name=name)\n            return f\n        return decorator\n\n    def add_app_template_global(self, f, name=None):\n        \"\"\"Register a custom template global, available application wide.  Like\n        :meth:`Flask.add_template_global` but for a blueprint.  Works exactly\n        like the :meth:`app_template_global` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global, otherwise the\n                     function name will be used.\n        \"\"\"\n        def register_template(state):\n            state.app.jinja_env.globals[name or f.__name__] = f\n        self.record_once(register_template)\n\n    def before_request(self, f):\n        \"\"\"Like :meth:`Flask.before_request` but for a blueprint.  This function\n        is only executed before each request that is handled by a function of\n        that blueprint.\n        \"\"\"\n        self.record_once(lambda s: s.app.before_request_funcs\n            .setdefault(self.name, []).append(f))\n        return f\n\n    def before_app_request(self, f):\n        \"\"\"Like :meth:`Flask.before_request`.  Such a function is executed\n        before each request, even if outside of a blueprint.\n        \"\"\"\n        self.record_once(lambda s: s.app.before_request_funcs\n            .setdefault(None, []).append(f))\n        return f\n\n    def before_app_first_request(self, f):\n        \"\"\"Like :meth:`Flask.before_first_request`.  Such a function is\n        executed before the first request to the application.\n        \"\"\"\n        self.record_once(lambda s: s.app.before_first_request_funcs.append(f))\n        return f\n\n    def after_request(self, f):\n        \"\"\"Like :meth:`Flask.after_request` but for a blueprint.  This function\n        is only executed after each request that is handled by a function of\n        that blueprint.\n        \"\"\"\n        self.record_once(lambda s: s.app.after_request_funcs\n            .setdefault(self.name, []).append(f))\n        return f\n\n    def after_app_request(self, f):\n        \"\"\"Like :meth:`Flask.after_request` but for a blueprint.  Such a function\n        is executed after each request, even if outside of the blueprint.\n        \"\"\"\n        self.record_once(lambda s: s.app.after_request_funcs\n            .setdefault(None, []).append(f))\n        return f\n\n    def teardown_request(self, f):\n        \"\"\"Like :meth:`Flask.teardown_request` but for a blueprint.  This\n        function is only executed when tearing down requests handled by a\n        function of that blueprint.  Teardown request functions are executed\n        when the request context is popped, even when no actual request was\n        performed.\n        \"\"\"\n        self.record_once(lambda s: s.app.teardown_request_funcs\n            .setdefault(self.name, []).append(f))\n        return f\n\n    def teardown_app_request(self, f):\n        \"\"\"Like :meth:`Flask.teardown_request` but for a blueprint.  Such a\n        function is executed when tearing down each request, even if outside of\n        the blueprint.\n        \"\"\"\n        self.record_once(lambda s: s.app.teardown_request_funcs\n            .setdefault(None, []).append(f))\n        return f\n\n    def context_processor(self, f):\n        \"\"\"Like :meth:`Flask.context_processor` but for a blueprint.  This\n        function is only executed for requests handled by a blueprint.\n        \"\"\"\n        self.record_once(lambda s: s.app.template_context_processors\n            .setdefault(self.name, []).append(f))\n        return f\n\n    def app_context_processor(self, f):\n        \"\"\"Like :meth:`Flask.context_processor` but for a blueprint.  Such a\n        function is executed each request, even if outside of the blueprint.\n        \"\"\"\n        self.record_once(lambda s: s.app.template_context_processors\n            .setdefault(None, []).append(f))\n        return f\n\n    def app_errorhandler(self, code):\n        \"\"\"Like :meth:`Flask.errorhandler` but for a blueprint.  This\n        handler is used for all requests, even if outside of the blueprint.\n        \"\"\"\n        def decorator(f):\n            self.record_once(lambda s: s.app.errorhandler(code)(f))\n            return f\n        return decorator\n\n    def url_value_preprocessor(self, f):\n        \"\"\"Registers a function as URL value preprocessor for this\n        blueprint.  It's called before the view functions are called and\n        can modify the url values provided.\n        \"\"\"\n        self.record_once(lambda s: s.app.url_value_preprocessors\n            .setdefault(self.name, []).append(f))\n        return f\n\n    def url_defaults(self, f):\n        \"\"\"Callback function for URL defaults for this blueprint.  It's called\n        with the endpoint and values and should update the values passed\n        in place.\n        \"\"\"\n        self.record_once(lambda s: s.app.url_default_functions\n            .setdefault(self.name, []).append(f))\n        return f\n\n    def app_url_value_preprocessor(self, f):\n        \"\"\"Same as :meth:`url_value_preprocessor` but application wide.\n        \"\"\"\n        self.record_once(lambda s: s.app.url_value_preprocessors\n            .setdefault(None, []).append(f))\n        return f\n\n    def app_url_defaults(self, f):\n        \"\"\"Same as :meth:`url_defaults` but application wide.\n        \"\"\"\n        self.record_once(lambda s: s.app.url_default_functions\n            .setdefault(None, []).append(f))\n        return f\n\n    def errorhandler(self, code_or_exception):\n        \"\"\"Registers an error handler that becomes active for this blueprint\n        only.  Please be aware that routing does not happen local to a\n        blueprint so an error handler for 404 usually is not handled by\n        a blueprint unless it is caused inside a view function.  Another\n        special case is the 500 internal server error which is always looked\n        up from the application.\n\n        Otherwise works as the :meth:`~flask.Flask.errorhandler` decorator\n        of the :class:`~flask.Flask` object.\n        \"\"\"\n        def decorator(f):\n            self.record_once(lambda s: s.app._register_error_handler(\n                self.name, code_or_exception, f))\n            return f\n        return decorator\n\n    def register_error_handler(self, code_or_exception, f):\n        \"\"\"Non-decorator version of the :meth:`errorhandler` error attach\n        function, akin to the :meth:`~flask.Flask.register_error_handler`\n        application-wide function of the :class:`~flask.Flask` object but\n        for error handlers limited to this blueprint.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        self.record_once(lambda s: s.app._register_error_handler(\n            self.name, code_or_exception, f))\n", "description": "The Python micro framework for building web applications.", "file_name": "blueprints.py", "language": "Python", "project_name": "flask", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/pallets_flask/pallets-flask-a2ea186/flask/blueprints.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:52:03Z", "url": "https://github.com/pallets/flask", "wiki": false}