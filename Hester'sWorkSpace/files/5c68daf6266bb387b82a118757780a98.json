{"author": "ansible", "code": " (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n\n This file is part of Ansible\n\n Ansible is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n Ansible is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nDOCUMENTATION = '''\n    strategy: free\n    short_description: Executes tasks on each host independently\n    description:\n        - Task execution is as fast as possible per host in batch as defined by C(serial) (default all).\n          Ansible will not wait for other hosts to finish the current task before queuing the next task for a host that has finished.\n          Once a host is done with the play, it opens it's slot to a new host that was waiting to start.\n    version_added: \"2.0\"\n    author: Ansible Core Team\n'''\n\nimport time\n\nfrom ansible import constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.playbook.included_file import IncludedFile\nfrom ansible.plugins.loader import action_loader\nfrom ansible.plugins.strategy import StrategyBase\nfrom ansible.template import Templar\nfrom ansible.module_utils._text import to_text\n\n\ntry:\n    from __main__ import display\nexcept ImportError:\n    from ansible.utils.display import Display\n    display = Display()\n\n\nclass StrategyModule(StrategyBase):\n\n    def run(self, iterator, play_context):\n        '''\n        The \"free\" strategy is a bit more complex, in that it allows tasks to\n        be sent to hosts as quickly as they can be processed. This means that\n        some hosts may finish very quickly if run tasks result in little or no\n        work being done versus other systems.\n\n        The algorithm used here also tries to be more \"fair\" when iterating\n        through hosts by remembering the last host in the list to be given a task\n        and starting the search from there as opposed to the top of the hosts\n        list again, which would end up favoring hosts near the beginning of the\n        list.\n        '''\n\n         the last host to be given a task\n        last_host = 0\n\n        result = self._tqm.RUN_OK\n\n        work_to_do = True\n        while work_to_do and not self._tqm._terminated:\n\n            hosts_left = self.get_hosts_left(iterator)\n\n            if len(hosts_left) == 0:\n                self._tqm.send_callback('v2_playbook_on_no_hosts_remaining')\n                result = False\n                break\n\n            work_to_do = False         assume we have no more work to do\n            starting_host = last_host   save current position so we know when we've looped back around and need to break\n\n             try and find an unblocked host with a task to run\n            host_results = []\n            while True:\n                host = hosts_left[last_host]\n                display.debug(\"next free host: %s\" % host)\n                host_name = host.get_name()\n\n                 peek at the next task for the host, to see if there's\n                 anything to do do for this host\n                (state, task) = iterator.get_next_task_for_host(host, peek=True)\n                display.debug(\"free host state: %s\" % state)\n                display.debug(\"free host task: %s\" % task)\n                if host_name not in self._tqm._unreachable_hosts and task:\n\n                     set the flag so the outer loop knows we've still found\n                     some work which needs to be done\n                    work_to_do = True\n\n                    display.debug(\"this host has work to do\")\n\n                     check to see if this host is blocked (still executing a previous task)\n                    if host_name not in self._blocked_hosts or not self._blocked_hosts[host_name]:\n                         pop the task, mark the host blocked, and queue it\n                        self._blocked_hosts[host_name] = True\n                        (state, task) = iterator.get_next_task_for_host(host)\n\n                        try:\n                            action = action_loader.get(task.action, class_only=True)\n                        except KeyError:\n                             we don't care here, because the action may simply not have a\n                             corresponding action plugin\n                            action = None\n\n                        display.debug(\"getting variables\")\n                        task_vars = self._variable_manager.get_vars(play=iterator._play, host=host, task=task)\n                        self.add_tqm_variables(task_vars, play=iterator._play)\n                        templar = Templar(loader=self._loader, variables=task_vars)\n                        display.debug(\"done getting variables\")\n\n                        try:\n                            task.name = to_text(templar.template(task.name, fail_on_undefined=False), nonstring='empty')\n                            display.debug(\"done templating\")\n                        except:\n                             just ignore any errors during task name templating,\n                             we don't care if it just shows the raw name\n                            display.debug(\"templating failed for some reason\")\n\n                        run_once = templar.template(task.run_once) or action and getattr(action, 'BYPASS_HOST_LOOP', False)\n                        if run_once:\n                            if action and getattr(action, 'BYPASS_HOST_LOOP', False):\n                                raise AnsibleError(\"The '%s' module bypasses the host loop, which is currently not supported in the free strategy \"\n                                                   \"and would instead execute for every host in the inventory list.\" % task.action, obj=task._ds)\n                            else:\n                                display.warning(\"Using run_once with the free strategy is not currently supported. This task will still be \"\n                                                \"executed for every host in the inventory list.\")\n\n                         check to see if this task should be skipped, due to it being a member of a\n                         role which has already run (and whether that role allows duplicate execution)\n                        if task._role and task._role.has_run(host):\n                             If there is no metadata, the default behavior is to not allow duplicates,\n                             if there is metadata, check to see if the allow_duplicates flag was set to true\n                            if task._role._metadata is None or task._role._metadata and not task._role._metadata.allow_duplicates:\n                                display.debug(\"'%s' skipped because role has already run\" % task)\n                                del self._blocked_hosts[host_name]\n                                continue\n\n                        if task.action == 'meta':\n                            self._execute_meta(task, play_context, iterator, target_host=host)\n                            self._blocked_hosts[host_name] = False\n                        else:\n                             handle step if needed, skip meta actions as they are used internally\n                            if not self._step or self._take_step(task, host_name):\n                                if task.any_errors_fatal:\n                                    display.warning(\"Using any_errors_fatal with the free strategy is not supported, \"\n                                                    \"as tasks are executed independently on each host\")\n                                self._tqm.send_callback('v2_playbook_on_task_start', task, is_conditional=False)\n                                self._queue_task(host, task, task_vars, play_context)\n                                del task_vars\n                    else:\n                        display.debug(\"%s is blocked, skipping for now\" % host_name)\n\n                 move on to the next host and make sure we\n                 haven't gone past the end of our hosts list\n                last_host += 1\n                if last_host > len(hosts_left) - 1:\n                    last_host = 0\n\n                 if we've looped around back to the start, break out\n                if last_host == starting_host:\n                    break\n\n            results = self._process_pending_results(iterator)\n            host_results.extend(results)\n\n            self.update_active_connections(results)\n\n            try:\n                included_files = IncludedFile.process_include_results(\n                    host_results,\n                    iterator=iterator,\n                    loader=self._loader,\n                    variable_manager=self._variable_manager\n                )\n            except AnsibleError as e:\n                return self._tqm.RUN_ERROR\n\n            if len(included_files) > 0:\n                all_blocks = dict((host, []) for host in hosts_left)\n                for included_file in included_files:\n                    display.debug(\"collecting new blocks for %s\" % included_file)\n                    try:\n                        if included_file._is_role:\n                            new_ir = self._copy_included_file(included_file)\n\n                            new_blocks, handler_blocks = new_ir.get_block_list(\n                                play=iterator._play,\n                                variable_manager=self._variable_manager,\n                                loader=self._loader,\n                            )\n                            self._tqm.update_handler_list([handler for handler_block in handler_blocks for handler in handler_block.block])\n                        else:\n                            new_blocks = self._load_included_file(included_file, iterator=iterator)\n                    except AnsibleError as e:\n                        for host in included_file._hosts:\n                            iterator.mark_host_failed(host)\n                        display.warning(str(e))\n                        continue\n\n                    for new_block in new_blocks:\n                        task_vars = self._variable_manager.get_vars(play=iterator._play, task=included_file._task)\n                        final_block = new_block.filter_tagged_tasks(play_context, task_vars)\n                        for host in hosts_left:\n                            if host in included_file._hosts:\n                                all_blocks[host].append(final_block)\n                    display.debug(\"done collecting new blocks for %s\" % included_file)\n\n                display.debug(\"adding all collected blocks from %d included file(s) to iterator\" % len(included_files))\n                for host in hosts_left:\n                    iterator.add_tasks(host, all_blocks[host])\n                display.debug(\"done adding collected blocks to iterator\")\n\n             pause briefly so we don't spin lock\n            time.sleep(C.DEFAULT_INTERNAL_POLL_INTERVAL)\n\n         collect all the final results\n        results = self._wait_on_pending_results(iterator)\n\n         run the base class run() method, which executes the cleanup function\n         and runs any outstanding handlers which have been triggered\n        return super(StrategyModule, self).run(iterator, play_context, result)\n", "comments": "        strategy  free     short description  executes tasks host independently     description            task execution fast possible per host batch defined c(serial) (default all)            ansible wait hosts finish current task queuing next task host finished            once host done play  opens slot new host waiting start      version added   2 0      author  ansible core team      import time  ansible import constants c ansible errors import ansibleerror ansible playbook included file import includedfile ansible plugins loader import action loader ansible plugins strategy import strategybase ansible template import templar ansible module utils  text import text   try        main   import display except importerror      ansible utils display import display     display   display()   class strategymodule(strategybase)       def run(self  iterator  play context)                      the  free  strategy bit complex  allows tasks         sent hosts quickly processed  this means         hosts may finish quickly run tasks result little         work done versus systems           the algorithm used also tries  fair  iterating         hosts remembering last host list given task         starting search opposed top hosts         list  would end favoring hosts near beginning         list                 (c) 2012 2014  michael dehaan  michael dehaan gmail com        this file part ansible       ansible free software  redistribute modify    terms gnu general public license published    free software foundation  either version 3 license     (at option) later version        ansible distributed hope useful     without any warranty  without even implied warranty    merchantability fitness for a particular purpose   see    gnu general public license details        you received copy gnu general public license    along ansible   if  see  http   www gnu org licenses       make coding python3 ish    last host given task    assume work    save current position know looped back around need break    try find unblocked host task run    peek next task host  see    anything host    set flag outer loop knows still found    work needs done    check see host blocked (still executing previous task)    pop task  mark host blocked  queue    care  action may simply    corresponding action plugin    ignore errors task name templating     care shows raw name    check see task skipped  due member    role already run (and whether role allows duplicate execution)    if metadata  default behavior allow duplicates     metadata  check see allow duplicates flag set true    handle step needed  skip meta actions used internally    move next host make sure    gone past end hosts list    looped around back start  break    pause briefly spin lock    collect final results    run base class run() method  executes cleanup function    runs outstanding handlers triggered ", "content": "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nDOCUMENTATION = '''\n    strategy: free\n    short_description: Executes tasks on each host independently\n    description:\n        - Task execution is as fast as possible per host in batch as defined by C(serial) (default all).\n          Ansible will not wait for other hosts to finish the current task before queuing the next task for a host that has finished.\n          Once a host is done with the play, it opens it's slot to a new host that was waiting to start.\n    version_added: \"2.0\"\n    author: Ansible Core Team\n'''\n\nimport time\n\nfrom ansible import constants as C\nfrom ansible.errors import AnsibleError\nfrom ansible.playbook.included_file import IncludedFile\nfrom ansible.plugins.loader import action_loader\nfrom ansible.plugins.strategy import StrategyBase\nfrom ansible.template import Templar\nfrom ansible.module_utils._text import to_text\n\n\ntry:\n    from __main__ import display\nexcept ImportError:\n    from ansible.utils.display import Display\n    display = Display()\n\n\nclass StrategyModule(StrategyBase):\n\n    def run(self, iterator, play_context):\n        '''\n        The \"free\" strategy is a bit more complex, in that it allows tasks to\n        be sent to hosts as quickly as they can be processed. This means that\n        some hosts may finish very quickly if run tasks result in little or no\n        work being done versus other systems.\n\n        The algorithm used here also tries to be more \"fair\" when iterating\n        through hosts by remembering the last host in the list to be given a task\n        and starting the search from there as opposed to the top of the hosts\n        list again, which would end up favoring hosts near the beginning of the\n        list.\n        '''\n\n        # the last host to be given a task\n        last_host = 0\n\n        result = self._tqm.RUN_OK\n\n        work_to_do = True\n        while work_to_do and not self._tqm._terminated:\n\n            hosts_left = self.get_hosts_left(iterator)\n\n            if len(hosts_left) == 0:\n                self._tqm.send_callback('v2_playbook_on_no_hosts_remaining')\n                result = False\n                break\n\n            work_to_do = False        # assume we have no more work to do\n            starting_host = last_host  # save current position so we know when we've looped back around and need to break\n\n            # try and find an unblocked host with a task to run\n            host_results = []\n            while True:\n                host = hosts_left[last_host]\n                display.debug(\"next free host: %s\" % host)\n                host_name = host.get_name()\n\n                # peek at the next task for the host, to see if there's\n                # anything to do do for this host\n                (state, task) = iterator.get_next_task_for_host(host, peek=True)\n                display.debug(\"free host state: %s\" % state)\n                display.debug(\"free host task: %s\" % task)\n                if host_name not in self._tqm._unreachable_hosts and task:\n\n                    # set the flag so the outer loop knows we've still found\n                    # some work which needs to be done\n                    work_to_do = True\n\n                    display.debug(\"this host has work to do\")\n\n                    # check to see if this host is blocked (still executing a previous task)\n                    if host_name not in self._blocked_hosts or not self._blocked_hosts[host_name]:\n                        # pop the task, mark the host blocked, and queue it\n                        self._blocked_hosts[host_name] = True\n                        (state, task) = iterator.get_next_task_for_host(host)\n\n                        try:\n                            action = action_loader.get(task.action, class_only=True)\n                        except KeyError:\n                            # we don't care here, because the action may simply not have a\n                            # corresponding action plugin\n                            action = None\n\n                        display.debug(\"getting variables\")\n                        task_vars = self._variable_manager.get_vars(play=iterator._play, host=host, task=task)\n                        self.add_tqm_variables(task_vars, play=iterator._play)\n                        templar = Templar(loader=self._loader, variables=task_vars)\n                        display.debug(\"done getting variables\")\n\n                        try:\n                            task.name = to_text(templar.template(task.name, fail_on_undefined=False), nonstring='empty')\n                            display.debug(\"done templating\")\n                        except:\n                            # just ignore any errors during task name templating,\n                            # we don't care if it just shows the raw name\n                            display.debug(\"templating failed for some reason\")\n\n                        run_once = templar.template(task.run_once) or action and getattr(action, 'BYPASS_HOST_LOOP', False)\n                        if run_once:\n                            if action and getattr(action, 'BYPASS_HOST_LOOP', False):\n                                raise AnsibleError(\"The '%s' module bypasses the host loop, which is currently not supported in the free strategy \"\n                                                   \"and would instead execute for every host in the inventory list.\" % task.action, obj=task._ds)\n                            else:\n                                display.warning(\"Using run_once with the free strategy is not currently supported. This task will still be \"\n                                                \"executed for every host in the inventory list.\")\n\n                        # check to see if this task should be skipped, due to it being a member of a\n                        # role which has already run (and whether that role allows duplicate execution)\n                        if task._role and task._role.has_run(host):\n                            # If there is no metadata, the default behavior is to not allow duplicates,\n                            # if there is metadata, check to see if the allow_duplicates flag was set to true\n                            if task._role._metadata is None or task._role._metadata and not task._role._metadata.allow_duplicates:\n                                display.debug(\"'%s' skipped because role has already run\" % task)\n                                del self._blocked_hosts[host_name]\n                                continue\n\n                        if task.action == 'meta':\n                            self._execute_meta(task, play_context, iterator, target_host=host)\n                            self._blocked_hosts[host_name] = False\n                        else:\n                            # handle step if needed, skip meta actions as they are used internally\n                            if not self._step or self._take_step(task, host_name):\n                                if task.any_errors_fatal:\n                                    display.warning(\"Using any_errors_fatal with the free strategy is not supported, \"\n                                                    \"as tasks are executed independently on each host\")\n                                self._tqm.send_callback('v2_playbook_on_task_start', task, is_conditional=False)\n                                self._queue_task(host, task, task_vars, play_context)\n                                del task_vars\n                    else:\n                        display.debug(\"%s is blocked, skipping for now\" % host_name)\n\n                # move on to the next host and make sure we\n                # haven't gone past the end of our hosts list\n                last_host += 1\n                if last_host > len(hosts_left) - 1:\n                    last_host = 0\n\n                # if we've looped around back to the start, break out\n                if last_host == starting_host:\n                    break\n\n            results = self._process_pending_results(iterator)\n            host_results.extend(results)\n\n            self.update_active_connections(results)\n\n            try:\n                included_files = IncludedFile.process_include_results(\n                    host_results,\n                    iterator=iterator,\n                    loader=self._loader,\n                    variable_manager=self._variable_manager\n                )\n            except AnsibleError as e:\n                return self._tqm.RUN_ERROR\n\n            if len(included_files) > 0:\n                all_blocks = dict((host, []) for host in hosts_left)\n                for included_file in included_files:\n                    display.debug(\"collecting new blocks for %s\" % included_file)\n                    try:\n                        if included_file._is_role:\n                            new_ir = self._copy_included_file(included_file)\n\n                            new_blocks, handler_blocks = new_ir.get_block_list(\n                                play=iterator._play,\n                                variable_manager=self._variable_manager,\n                                loader=self._loader,\n                            )\n                            self._tqm.update_handler_list([handler for handler_block in handler_blocks for handler in handler_block.block])\n                        else:\n                            new_blocks = self._load_included_file(included_file, iterator=iterator)\n                    except AnsibleError as e:\n                        for host in included_file._hosts:\n                            iterator.mark_host_failed(host)\n                        display.warning(str(e))\n                        continue\n\n                    for new_block in new_blocks:\n                        task_vars = self._variable_manager.get_vars(play=iterator._play, task=included_file._task)\n                        final_block = new_block.filter_tagged_tasks(play_context, task_vars)\n                        for host in hosts_left:\n                            if host in included_file._hosts:\n                                all_blocks[host].append(final_block)\n                    display.debug(\"done collecting new blocks for %s\" % included_file)\n\n                display.debug(\"adding all collected blocks from %d included file(s) to iterator\" % len(included_files))\n                for host in hosts_left:\n                    iterator.add_tasks(host, all_blocks[host])\n                display.debug(\"done adding collected blocks to iterator\")\n\n            # pause briefly so we don't spin lock\n            time.sleep(C.DEFAULT_INTERNAL_POLL_INTERVAL)\n\n        # collect all the final results\n        results = self._wait_on_pending_results(iterator)\n\n        # run the base class run() method, which executes the cleanup function\n        # and runs any outstanding handlers which have been triggered\n        return super(StrategyModule, self).run(iterator, play_context, result)\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "free.py", "id": "5c68daf6266bb387b82a118757780a98", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/plugins/strategy/free.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}