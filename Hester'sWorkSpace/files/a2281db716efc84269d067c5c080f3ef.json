{"author": "tensorflow", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n\"\"\"Functions for reading and preprocessing light curves.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport numpy as np\nimport tensorflow as tf\n\nfrom light_curve_util import kepler_io\nfrom light_curve_util import median_filter\nfrom light_curve_util import util\nfrom third_party.kepler_spline import kepler_spline\n\n\ndef read_and_process_light_curve(kepid, kepler_data_dir, max_gap_width=0.75):\n  \"\"\"Reads a light curve, fits a B-spline and divides the curve by the spline.\n\n  Args:\n    kepid: Kepler id of the target star.\n    kepler_data_dir: Base directory containing Kepler data. See\n        kepler_io.kepler_filenames().\n    max_gap_width: Gap size (in days) above which the light curve is split for\n        the fitting of B-splines.\n\n  Returns:\n    time: 1D NumPy array; the time values of the light curve.\n    flux: 1D NumPy array; the normalized flux values of the light curve.\n\n  Raises:\n    IOError: If the light curve files for this Kepler ID cannot be found.\n    ValueError: If the spline could not be fit.\n  \"\"\"\n   Read the Kepler light curve.\n  file_names = kepler_io.kepler_filenames(kepler_data_dir, kepid)\n  if not file_names:\n    raise IOError(\"Failed to find .fits files in %s for Kepler ID %s\" %\n                  (kepler_data_dir, kepid))\n\n  all_time, all_flux = kepler_io.read_kepler_light_curve(file_names)\n\n   Split on gaps.\n  all_time, all_flux = util.split(all_time, all_flux, gap_width=max_gap_width)\n\n   Logarithmically sample candidate break point spacings between 0.5 and 20\n   days.\n  bkspaces = np.logspace(np.log10(0.5), np.log10(20), num=20)\n\n   Generate spline.\n  spline = kepler_spline.choose_kepler_spline(\n      all_time, all_flux, bkspaces, penalty_coeff=1.0, verbose=False)[0]\n\n  if spline is None:\n    raise ValueError(\"Failed to fit spline with Kepler ID %s\", kepid)\n\n   Concatenate the piecewise light curve and spline.\n  time = np.concatenate(all_time)\n  flux = np.concatenate(all_flux)\n  spline = np.concatenate(spline)\n\n   In rare cases the piecewise spline contains NaNs in places the spline could\n   not be fit. We can't normalize those points if the spline isn't defined\n   there. Instead we just remove them.\n  finite_i = np.isfinite(spline)\n  if not np.all(finite_i):\n    tf.logging.warn(\"Incomplete spline with Kepler ID %s\", kepid)\n    time = time[finite_i]\n    flux = flux[finite_i]\n    spline = spline[finite_i]\n\n   \"Flatten\" the light curve (remove low-frequency variability) by dividing by\n   the spline.\n  flux /= spline\n\n  return time, flux\n\n\ndef phase_fold_and_sort_light_curve(time, flux, period, t0):\n  \"\"\"Phase folds a light curve and sorts by ascending time.\n\n  Args:\n    time: 1D NumPy array of time values.\n    flux: 1D NumPy array of flux values.\n    period: A positive real scalar; the period to fold over.\n    t0: The center of the resulting folded vector; this value is mapped to 0.\n\n  Returns:\n    folded_time: 1D NumPy array of phase folded time values in\n        [-period / 2, period / 2), where 0 corresponds to t0 in the original\n        time array. Values are sorted in ascending order.\n    folded_flux: 1D NumPy array. Values are the same as the original input\n        array, but sorted by folded_time.\n  \"\"\"\n   Phase fold time.\n  time = util.phase_fold_time(time, period, t0)\n\n   Sort by ascending time.\n  sorted_i = np.argsort(time)\n  time = time[sorted_i]\n  flux = flux[sorted_i]\n\n  return time, flux\n\n\ndef generate_view(time, flux, num_bins, bin_width, t_min, t_max,\n                  normalize=True):\n  \"\"\"Generates a view of a phase-folded light curve using a median filter.\n\n  Args:\n    time: 1D array of time values, sorted in ascending order.\n    flux: 1D array of flux values.\n    num_bins: The number of intervals to divide the time axis into.\n    bin_width: The width of each bin on the time axis.\n    t_min: The inclusive leftmost value to consider on the time axis.\n    t_max: The exclusive rightmost value to consider on the time axis.\n    normalize: Whether to center the median at 0 and minimum value at -1.\n\n  Returns:\n    1D NumPy array of size num_bins containing the median flux values of\n    uniformly spaced bins on the phase-folded time axis.\n  \"\"\"\n  view = median_filter.median_filter(time, flux, num_bins, bin_width, t_min,\n                                     t_max)\n\n  if normalize:\n    view -= np.median(view)\n    view /= np.abs(np.min(view))\n\n  return view\n\n\ndef global_view(time, flux, period, num_bins=2001, bin_width_factor=1 / 2001):\n  \"\"\"Generates a 'global view' of a phase folded light curve.\n\n  See Section 3.3 of Shallue & Vanderburg, 2018, The Astronomical Journal.\n  http://iopscience.iop.org/article/10.3847/1538-3881/aa9e09/meta\n\n  Args:\n    time: 1D array of time values, sorted in ascending order.\n    flux: 1D array of flux values.\n    period: The period of the event (in days).\n    num_bins: The number of intervals to divide the time axis into.\n    bin_width_factor: Width of the bins, as a fraction of period.\n\n  Returns:\n    1D NumPy array of size num_bins containing the median flux values of\n    uniformly spaced bins on the phase-folded time axis.\n  \"\"\"\n  return generate_view(\n      time,\n      flux,\n      num_bins=num_bins,\n      bin_width=period * bin_width_factor,\n      t_min=-period / 2,\n      t_max=period / 2)\n\n\ndef local_view(time,\n               flux,\n               period,\n               duration,\n               num_bins=201,\n               bin_width_factor=0.16,\n               num_durations=4):\n  \"\"\"Generates a 'local view' of a phase folded light curve.\n\n  See Section 3.3 of Shallue & Vanderburg, 2018, The Astronomical Journal.\n  http://iopscience.iop.org/article/10.3847/1538-3881/aa9e09/meta\n\n  Args:\n    time: 1D array of time values, sorted in ascending order.\n    flux: 1D array of flux values.\n    period: The period of the event (in days).\n    duration: The duration of the event (in days).\n    num_bins: The number of intervals to divide the time axis into.\n    bin_width_factor: Width of the bins, as a fraction of duration.\n    num_durations: The number of durations to consider on either side of 0 (the\n        event is assumed to be centered at 0).\n\n  Returns:\n    1D NumPy array of size num_bins containing the median flux values of\n    uniformly spaced bins on the phase-folded time axis.\n  \"\"\"\n  return generate_view(\n      time,\n      flux,\n      num_bins=num_bins,\n      bin_width=duration * bin_width_factor,\n      t_min=max(-period / 2, -duration * num_durations),\n      t_max=min(period / 2, duration * num_durations))\n", "comments": "   functions reading preprocessing light curves        future   import absolute import   future   import division   future   import print function  import numpy np import tensorflow tf  light curve util import kepler io light curve util import median filter light curve util import util third party kepler spline import kepler spline   def read process light curve(kepid  kepler data dir  max gap width 0 75)       reads light curve  fits b spline divides curve spline     args      kepid  kepler id target star      kepler data dir  base directory containing kepler data  see         kepler io kepler filenames()      max gap width  gap size (in days) light curve split         fitting b splines     returns      time  1d numpy array  time values light curve      flux  1d numpy array  normalized flux values light curve     raises      ioerror  if light curve files kepler id cannot found      valueerror  if spline could fit            read kepler light curve    file names   kepler io kepler filenames(kepler data dir  kepid)   file names      raise ioerror( failed find  fits files  kepler id                       (kepler data dir  kepid))    time  flux   kepler io read kepler light curve(file names)      split gaps    time  flux   util split(all time  flux  gap width max gap width)      logarithmically sample candidate break point spacings 0 5 20     days    bkspaces   np logspace(np log10(0 5)  np log10(20)  num 20)      generate spline    spline   kepler spline choose kepler spline(       time  flux  bkspaces  penalty coeff 1 0  verbose false) 0     spline none      raise valueerror( failed fit spline kepler id    kepid)      concatenate piecewise light curve spline    time   np concatenate(all time)   flux   np concatenate(all flux)   spline   np concatenate(spline)      in rare cases piecewise spline contains nans places spline could     fit  we normalize points spline defined      instead remove    finite   np isfinite(spline)   np all(finite i)      tf logging warn( incomplete spline kepler id    kepid)     time   time finite      flux   flux finite      spline   spline finite        flatten  light curve (remove low frequency variability) dividing     spline    flux    spline    return time  flux   def phase fold sort light curve(time  flux  period  t0)       phase folds light curve sorts ascending time     args      time  1d numpy array time values      flux  1d numpy array flux values      period  a positive real scalar  period fold      t0  the center resulting folded vector  value mapped 0     returns      folded time  1d numpy array phase folded time values           period   2  period   2)  0 corresponds t0 original         time array  values sorted ascending order      folded flux  1d numpy array  values original input         array  sorted folded time            phase fold time    time   util phase fold time(time  period  t0)      sort ascending time    sorted   np argsort(time)   time   time sorted    flux   flux sorted     return time  flux   def generate view(time  flux  num bins  bin width  min  max                    normalize true)       generates view phase folded light curve using median filter     args      time  1d array time values  sorted ascending order      flux  1d array flux values      num bins  the number intervals divide time axis      bin width  the width bin time axis      min  the inclusive leftmost value consider time axis      max  the exclusive rightmost value consider time axis      normalize  whether center median 0 minimum value  1     returns      1d numpy array size num bins containing median flux values     uniformly spaced bins phase folded time axis          view   median filter median filter(time  flux  num bins  bin width  min                                       max)    normalize      view    np median(view)     view    np abs(np min(view))    return view   def global view(time  flux  period  num bins 2001  bin width factor 1   2001)       generates  global view  phase folded light curve     see section 3 3 shallue   vanderburg  2018  the astronomical journal    http   iopscience iop org article 10 3847 1538 3881 aa9e09 meta    args      time  1d array time values  sorted ascending order      flux  1d array flux values      period  the period event (in days)      num bins  the number intervals divide time axis      bin width factor  width bins  fraction period     returns      1d numpy array size num bins containing median flux values     uniformly spaced bins phase folded time axis          return generate view(       time        flux        num bins num bins        bin width period   bin width factor        min  period   2        max period   2)   def local view(time                 flux                 period                 duration                 num bins 201                 bin width factor 0 16                 num durations 4)       generates  local view  phase folded light curve     see section 3 3 shallue   vanderburg  2018  the astronomical journal    http   iopscience iop org article 10 3847 1538 3881 aa9e09 meta    args      time  1d array time values  sorted ascending order      flux  1d array flux values      period  the period event (in days)      duration  the duration event (in days)      num bins  the number intervals divide time axis      bin width factor  width bins  fraction duration      num durations  the number durations consider either side 0 (the         event assumed centered 0)     returns      1d numpy array size num bins containing median flux values     uniformly spaced bins phase folded time axis           copyright 2018 the tensorflow authors        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license           http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license     read kepler light curve     split gaps     logarithmically sample candidate break point spacings 0 5 20    days     generate spline     concatenate piecewise light curve spline     in rare cases piecewise spline contains nans places spline could    fit  we normalize points spline defined     instead remove      flatten  light curve (remove low frequency variability) dividing    spline     phase fold time     sort ascending time  ", "content": "# Copyright 2018 The TensorFlow Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Functions for reading and preprocessing light curves.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport numpy as np\nimport tensorflow as tf\n\nfrom light_curve_util import kepler_io\nfrom light_curve_util import median_filter\nfrom light_curve_util import util\nfrom third_party.kepler_spline import kepler_spline\n\n\ndef read_and_process_light_curve(kepid, kepler_data_dir, max_gap_width=0.75):\n  \"\"\"Reads a light curve, fits a B-spline and divides the curve by the spline.\n\n  Args:\n    kepid: Kepler id of the target star.\n    kepler_data_dir: Base directory containing Kepler data. See\n        kepler_io.kepler_filenames().\n    max_gap_width: Gap size (in days) above which the light curve is split for\n        the fitting of B-splines.\n\n  Returns:\n    time: 1D NumPy array; the time values of the light curve.\n    flux: 1D NumPy array; the normalized flux values of the light curve.\n\n  Raises:\n    IOError: If the light curve files for this Kepler ID cannot be found.\n    ValueError: If the spline could not be fit.\n  \"\"\"\n  # Read the Kepler light curve.\n  file_names = kepler_io.kepler_filenames(kepler_data_dir, kepid)\n  if not file_names:\n    raise IOError(\"Failed to find .fits files in %s for Kepler ID %s\" %\n                  (kepler_data_dir, kepid))\n\n  all_time, all_flux = kepler_io.read_kepler_light_curve(file_names)\n\n  # Split on gaps.\n  all_time, all_flux = util.split(all_time, all_flux, gap_width=max_gap_width)\n\n  # Logarithmically sample candidate break point spacings between 0.5 and 20\n  # days.\n  bkspaces = np.logspace(np.log10(0.5), np.log10(20), num=20)\n\n  # Generate spline.\n  spline = kepler_spline.choose_kepler_spline(\n      all_time, all_flux, bkspaces, penalty_coeff=1.0, verbose=False)[0]\n\n  if spline is None:\n    raise ValueError(\"Failed to fit spline with Kepler ID %s\", kepid)\n\n  # Concatenate the piecewise light curve and spline.\n  time = np.concatenate(all_time)\n  flux = np.concatenate(all_flux)\n  spline = np.concatenate(spline)\n\n  # In rare cases the piecewise spline contains NaNs in places the spline could\n  # not be fit. We can't normalize those points if the spline isn't defined\n  # there. Instead we just remove them.\n  finite_i = np.isfinite(spline)\n  if not np.all(finite_i):\n    tf.logging.warn(\"Incomplete spline with Kepler ID %s\", kepid)\n    time = time[finite_i]\n    flux = flux[finite_i]\n    spline = spline[finite_i]\n\n  # \"Flatten\" the light curve (remove low-frequency variability) by dividing by\n  # the spline.\n  flux /= spline\n\n  return time, flux\n\n\ndef phase_fold_and_sort_light_curve(time, flux, period, t0):\n  \"\"\"Phase folds a light curve and sorts by ascending time.\n\n  Args:\n    time: 1D NumPy array of time values.\n    flux: 1D NumPy array of flux values.\n    period: A positive real scalar; the period to fold over.\n    t0: The center of the resulting folded vector; this value is mapped to 0.\n\n  Returns:\n    folded_time: 1D NumPy array of phase folded time values in\n        [-period / 2, period / 2), where 0 corresponds to t0 in the original\n        time array. Values are sorted in ascending order.\n    folded_flux: 1D NumPy array. Values are the same as the original input\n        array, but sorted by folded_time.\n  \"\"\"\n  # Phase fold time.\n  time = util.phase_fold_time(time, period, t0)\n\n  # Sort by ascending time.\n  sorted_i = np.argsort(time)\n  time = time[sorted_i]\n  flux = flux[sorted_i]\n\n  return time, flux\n\n\ndef generate_view(time, flux, num_bins, bin_width, t_min, t_max,\n                  normalize=True):\n  \"\"\"Generates a view of a phase-folded light curve using a median filter.\n\n  Args:\n    time: 1D array of time values, sorted in ascending order.\n    flux: 1D array of flux values.\n    num_bins: The number of intervals to divide the time axis into.\n    bin_width: The width of each bin on the time axis.\n    t_min: The inclusive leftmost value to consider on the time axis.\n    t_max: The exclusive rightmost value to consider on the time axis.\n    normalize: Whether to center the median at 0 and minimum value at -1.\n\n  Returns:\n    1D NumPy array of size num_bins containing the median flux values of\n    uniformly spaced bins on the phase-folded time axis.\n  \"\"\"\n  view = median_filter.median_filter(time, flux, num_bins, bin_width, t_min,\n                                     t_max)\n\n  if normalize:\n    view -= np.median(view)\n    view /= np.abs(np.min(view))\n\n  return view\n\n\ndef global_view(time, flux, period, num_bins=2001, bin_width_factor=1 / 2001):\n  \"\"\"Generates a 'global view' of a phase folded light curve.\n\n  See Section 3.3 of Shallue & Vanderburg, 2018, The Astronomical Journal.\n  http://iopscience.iop.org/article/10.3847/1538-3881/aa9e09/meta\n\n  Args:\n    time: 1D array of time values, sorted in ascending order.\n    flux: 1D array of flux values.\n    period: The period of the event (in days).\n    num_bins: The number of intervals to divide the time axis into.\n    bin_width_factor: Width of the bins, as a fraction of period.\n\n  Returns:\n    1D NumPy array of size num_bins containing the median flux values of\n    uniformly spaced bins on the phase-folded time axis.\n  \"\"\"\n  return generate_view(\n      time,\n      flux,\n      num_bins=num_bins,\n      bin_width=period * bin_width_factor,\n      t_min=-period / 2,\n      t_max=period / 2)\n\n\ndef local_view(time,\n               flux,\n               period,\n               duration,\n               num_bins=201,\n               bin_width_factor=0.16,\n               num_durations=4):\n  \"\"\"Generates a 'local view' of a phase folded light curve.\n\n  See Section 3.3 of Shallue & Vanderburg, 2018, The Astronomical Journal.\n  http://iopscience.iop.org/article/10.3847/1538-3881/aa9e09/meta\n\n  Args:\n    time: 1D array of time values, sorted in ascending order.\n    flux: 1D array of flux values.\n    period: The period of the event (in days).\n    duration: The duration of the event (in days).\n    num_bins: The number of intervals to divide the time axis into.\n    bin_width_factor: Width of the bins, as a fraction of duration.\n    num_durations: The number of durations to consider on either side of 0 (the\n        event is assumed to be centered at 0).\n\n  Returns:\n    1D NumPy array of size num_bins containing the median flux values of\n    uniformly spaced bins on the phase-folded time axis.\n  \"\"\"\n  return generate_view(\n      time,\n      flux,\n      num_bins=num_bins,\n      bin_width=duration * bin_width_factor,\n      t_min=max(-period / 2, -duration * num_durations),\n      t_max=min(period / 2, duration * num_durations))\n", "description": "Models and examples built with TensorFlow", "file_name": "preprocess.py", "id": "a2281db716efc84269d067c5c080f3ef", "language": "Python", "project_name": "models", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tensorflow-models/tensorflow-models-7e4c66b/research/astronet/astronet/data/preprocess.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:59:36Z", "url": "https://github.com/tensorflow/models", "wiki": true}