{"author": "HelloZeroNet", "code": "\nimport os\nimport time\nimport json\nimport itertools\nimport socket\n\n\nimport gevent\n\nfrom Debug import Debug\nfrom Config import config\nfrom util import RateLimit\nfrom util import StreamingMsgpack\nfrom util import helper\nfrom Plugin import PluginManager\nfrom contextlib import closing\n\nFILE_BUFF = 1024 * 512\n\n\nclass RequestError(Exception):\n    pass\n\n\n\n@PluginManager.acceptPlugins\nclass FileRequest(object):\n    __slots__ = (\"server\", \"connection\", \"req_id\", \"sites\", \"log\", \"responded\")\n\n    def __init__(self, server, connection):\n        self.server = server\n        self.connection = connection\n\n        self.req_id = None\n        self.sites = self.server.sites\n        self.log = server.log\n        self.responded = False  \n\n    def send(self, msg, streaming=False):\n        if not self.connection.closed:\n            self.connection.send(msg, streaming)\n\n    def sendRawfile(self, file, read_bytes):\n        if not self.connection.closed:\n            self.connection.sendRawfile(file, read_bytes)\n\n    def response(self, msg, streaming=False):\n        if self.responded:\n            if config.verbose:\n                self.log.debug(\"Req id %s already responded\" % self.req_id)\n            return\n        if not isinstance(msg, dict):  \n            msg = {\"body\": msg}\n        msg[\"cmd\"] = \"response\"\n        msg[\"to\"] = self.req_id\n        self.responded = True\n        self.send(msg, streaming=streaming)\n\n    \n    def route(self, cmd, req_id, params):\n        self.req_id = req_id\n        \n        if \"site\" in params and self.connection.target_onion:\n            valid_sites = self.connection.getValidSites()\n            if params[\"site\"] not in valid_sites and valid_sites != [\"global\"]:\n                self.response({\"error\": \"Invalid site\"})\n                self.connection.log(\n                    \"Site lock violation: %s not in %s, target onion: %s\" %\n                    (params[\"site\"], valid_sites, self.connection.target_onion)\n                )\n                self.connection.badAction(5)\n                return False\n\n        if cmd == \"update\":\n            event = \"%s update %s %s\" % (self.connection.id, params[\"site\"], params[\"inner_path\"])\n            \n            RateLimit.callAsync(event, max(self.connection.bad_actions, 15), self.actionUpdate, params)\n        else:\n            func_name = \"action\" + cmd[0].upper() + cmd[1:]\n            func = getattr(self, func_name, None)\n            if cmd not in [\"getFile\", \"streamFile\"]:  \n                if self.connection.cpu_time > 0.5:\n                    self.log.debug(\n                        \"Delay %s %s, cpu_time used by connection: %.3fs\" %\n                        (self.connection.ip, cmd, self.connection.cpu_time)\n                    )\n                    time.sleep(self.connection.cpu_time)\n                    if self.connection.cpu_time > 5:\n                        self.connection.close(\"Cpu time: %.3fs\" % self.connection.cpu_time)\n                s = time.time()\n            if func:\n                func(params)\n            else:\n                self.actionUnknown(cmd, params)\n\n            if cmd not in [\"getFile\", \"streamFile\"]:\n                taken = time.time() - s\n                taken_sent = self.connection.last_sent_time - self.connection.last_send_time\n                self.connection.cpu_time += taken - taken_sent\n\n    \n    def actionUpdate(self, params):\n        site = self.sites.get(params[\"site\"])\n        if not site or not site.settings[\"serving\"]:  \n            self.response({\"error\": \"Unknown site\"})\n            self.connection.badAction(1)\n            return False\n\n        inner_path = params.get(\"inner_path\", \"\")\n\n        if not inner_path.endswith(\"content.json\"):\n            self.response({\"error\": \"Only content.json update allowed\"})\n            self.connection.badAction(5)\n            return\n\n        try:\n            content = json.loads(params[\"body\"])\n        except Exception, err:\n            self.log.debug(\"Update for %s is invalid JSON: %s\" % (inner_path, err))\n            self.response({\"error\": \"File invalid JSON\"})\n            self.connection.badAction(5)\n            return\n\n        file_uri = \"%s/%s:%s\" % (site.address, inner_path, content[\"modified\"])\n\n        if self.server.files_parsing.get(file_uri):  \n            valid = None  \n        else:\n            try:\n                valid = site.content_manager.verifyFile(inner_path, content)\n            except Exception, err:\n                self.log.debug(\"Update for %s is invalid: %s\" % (inner_path, err))\n                valid = False\n\n        if valid is True:  \n            site.log.info(\"Update for %s looks valid, saving...\" % inner_path)\n            self.server.files_parsing[file_uri] = True\n            site.storage.write(inner_path, params[\"body\"])\n            del params[\"body\"]\n\n            site.onFileDone(inner_path)  \n\n            if inner_path.endswith(\"content.json\"):  \n                peer = site.addPeer(self.connection.ip, self.connection.port, return_peer=True, source=\"update\")  \n                \n                diffs = params.get(\"diffs\", {})\n                site.onComplete.once(lambda: site.publish(inner_path=inner_path, diffs=diffs, limit=3), \"publish_%s\" % inner_path)\n\n                \n                def downloader():\n                    site.downloadContent(inner_path, peer=peer, diffs=params.get(\"diffs\", {}))\n                    del self.server.files_parsing[file_uri]\n\n                gevent.spawn(downloader)\n            else:\n                del self.server.files_parsing[file_uri]\n\n            self.response({\"ok\": \"Thanks, file %s updated!\" % inner_path})\n            self.connection.goodAction()\n\n        elif valid is None:  \n            peer = site.addPeer(self.connection.ip, self.connection.port, return_peer=True, source=\"update old\")  \n            if peer:\n                if not peer.connection:\n                    peer.connect(self.connection)  \n                if inner_path in site.content_manager.contents:\n                    peer.last_content_json_update = site.content_manager.contents[inner_path][\"modified\"]\n                if config.verbose:\n                    self.log.debug(\n                        \"Same version, adding new peer for locked files: %s, tasks: %s\" %\n                        (peer.key, len(site.worker_manager.tasks))\n                    )\n                for task in site.worker_manager.tasks:  \n                    if task[\"peers\"] and not task[\"optional_hash_id\"]:\n                        \n                        site.needFile(task[\"inner_path\"], peer=peer, update=True, blocking=False)\n\n            self.response({\"ok\": \"File not changed\"})\n            self.connection.badAction()\n\n        else:  \n            self.response({\"error\": \"File invalid: %s\" % err})\n            self.connection.badAction(5)\n\n    def isReadable(self, site, inner_path, file, pos):\n        return True\n\n    \n    def handleGetFile(self, params, streaming=False):\n        site = self.sites.get(params[\"site\"])\n        if not site or not site.settings[\"serving\"]:  \n            self.response({\"error\": \"Unknown site\"})\n            return False\n        try:\n            file_path = site.storage.getPath(params[\"inner_path\"])\n            if streaming:\n                file_obj = site.storage.open(params[\"inner_path\"])\n            else:\n                file_obj = StreamingMsgpack.FilePart(file_path, \"rb\")\n\n            with file_obj as file:\n                file.seek(params[\"location\"])\n                read_bytes = params.get(\"read_bytes\", FILE_BUFF)\n                file_size = os.fstat(file.fileno()).st_size\n\n                if file_size > read_bytes:  # Check if file is readable at current position (for big files)\n                    if not self.isReadable(site, params[\"inner_path\"], file, params[\"location\"]):\n                        raise RequestError(\"File not readable at position: %s\" % params[\"location\"])\n\n                if not streaming:\n                    file.read_bytes = read_bytes\n\n                if params.get(\"file_size\") and params[\"file_size\"] != file_size:\n                    self.connection.badAction(2)\n                    raise RequestError(\"File size does not match: %sB != %sB\" % (params[\"file_size\"], file_size))\n\n                if params[\"location\"] > file_size:\n                    self.connection.badAction(5)\n                    raise RequestError(\"Bad file location\")\n\n                if streaming:\n                    back = {\n                        \"size\": file_size,\n                        \"location\": min(file.tell() + read_bytes, file_size),\n                        \"stream_bytes\": min(read_bytes, file_size - params[\"location\"])\n                    }\n                    self.response(back)\n                    self.sendRawfile(file, read_bytes=read_bytes)\n                else:\n                    back = {\n                        \"body\": file,\n                        \"size\": file_size,\n                        \"location\": min(file.tell() + file.read_bytes, file_size)\n                    }\n                    self.response(back, streaming=True)\n\n                bytes_sent = min(read_bytes, file_size - params[\"location\"])  \n                site.settings[\"bytes_sent\"] = site.settings.get(\"bytes_sent\", 0) + bytes_sent\n            if config.debug_socket:\n                self.log.debug(\"File %s at position %s sent %s bytes\" % (file_path, params[\"location\"], bytes_sent))\n\n            \n            connected_peer = site.addPeer(self.connection.ip, self.connection.port, source=\"request\")\n            if connected_peer:  \n                connected_peer.connect(self.connection)  \n\n            return {\"bytes_sent\": bytes_sent, \"file_size\": file_size, \"location\": params[\"location\"]}\n\n        except RequestError, err:\n            self.log.debug(\"GetFile %s %s request error: %s\" % (self.connection, params[\"inner_path\"], Debug.formatException(err)))\n            self.response({\"error\": \"File read error: %s\" % err})\n        except Exception, err:\n            if config.verbose:\n                self.log.debug(\"GetFile read error: %s\" % Debug.formatException(err))\n            self.response({\"error\": \"File read error\"})\n            return False\n\n    def actionGetFile(self, params):\n        return self.handleGetFile(params)\n\n    def actionStreamFile(self, params):\n        return self.handleGetFile(params, streaming=True)\n\n    \n    def actionPex(self, params):\n        site = self.sites.get(params[\"site\"])\n        if not site or not site.settings[\"serving\"]:  \n            self.response({\"error\": \"Unknown site\"})\n            return False\n\n        got_peer_keys = []\n        added = 0\n\n        \n        connected_peer = site.addPeer(self.connection.ip, self.connection.port, source=\"request\")\n\n        if connected_peer:  \n            added += 1\n            connected_peer.connect(self.connection)  \n\n        \n        for packed_address in params.get(\"peers\", []):\n            address = helper.unpackAddress(packed_address)\n            got_peer_keys.append(\"%s:%s\" % address)\n            if site.addPeer(*address, source=\"pex\"):\n                added += 1\n\n        \n        for packed_address in params.get(\"peers_onion\", []):\n            address = helper.unpackOnionAddress(packed_address)\n            got_peer_keys.append(\"%s:%s\" % address)\n            if site.addPeer(*address, source=\"pex\"):\n                added += 1\n\n        # Send back peers that is not in the sent list and connectable (not port 0)\n        packed_peers = helper.packPeers(site.getConnectablePeers(params[\"need\"], got_peer_keys, allow_private=False))\n\n        if added:\n            site.worker_manager.onPeers()\n            if config.verbose:\n                self.log.debug(\n                    \"Added %s peers to %s using pex, sending back %s\" %\n                    (added, site, len(packed_peers[\"ip4\"]) + len(packed_peers[\"onion\"]))\n                )\n\n        back = {}\n        if packed_peers[\"ip4\"]:\n            back[\"peers\"] = packed_peers[\"ip4\"]\n        if packed_peers[\"onion\"]:\n            back[\"peers_onion\"] = packed_peers[\"onion\"]\n\n        self.response(back)\n\n    \n    def actionListModified(self, params):\n        site = self.sites.get(params[\"site\"])\n        if not site or not site.settings[\"serving\"]:  \n            self.response({\"error\": \"Unknown site\"})\n            return False\n        modified_files = site.content_manager.listModified(params[\"since\"])\n\n        \n        connected_peer = site.addPeer(self.connection.ip, self.connection.port, source=\"request\")\n        if connected_peer:  \n            connected_peer.connect(self.connection)  \n\n        self.response({\"modified_files\": modified_files})\n\n    def actionGetHashfield(self, params):\n        site = self.sites.get(params[\"site\"])\n        if not site or not site.settings[\"serving\"]:  \n            self.response({\"error\": \"Unknown site\"})\n            return False\n\n        \n        peer = site.addPeer(self.connection.ip, self.connection.port, return_peer=True, source=\"request\")\n        if not peer.connection:  \n            peer.connect(self.connection)  \n\n        peer.time_my_hashfield_sent = time.time()  \n\n        self.response({\"hashfield_raw\": site.content_manager.hashfield.tostring()})\n\n    def findHashIds(self, site, hash_ids, limit=100):\n        back_ip4 = {}\n        back_onion = {}\n        found = site.worker_manager.findOptionalHashIds(hash_ids, limit=limit)\n\n        for hash_id, peers in found.iteritems():\n            back_onion[hash_id] = list(itertools.islice((\n                helper.packOnionAddress(peer.ip, peer.port)\n                for peer in peers\n                if peer.ip.endswith(\"onion\")\n            ), 50))\n            back_ip4[hash_id] = list(itertools.islice((\n                helper.packAddress(peer.ip, peer.port)\n                for peer in peers\n                if not peer.ip.endswith(\"onion\")\n            ), 50))\n        return back_ip4, back_onion\n\n    def actionFindHashIds(self, params):\n        site = self.sites.get(params[\"site\"])\n        s = time.time()\n        if not site or not site.settings[\"serving\"]:  \n            self.response({\"error\": \"Unknown site\"})\n            self.connection.badAction(5)\n            return False\n\n        event_key = \"%s_findHashIds_%s_%s\" % (self.connection.ip, params[\"site\"], len(params[\"hash_ids\"]))\n        if self.connection.cpu_time > 0.5 or not RateLimit.isAllowed(event_key, 60 * 5):\n            time.sleep(0.1)\n            back_ip4, back_onion = self.findHashIds(site, params[\"hash_ids\"], limit=10)\n        else:\n            back_ip4, back_onion = self.findHashIds(site, params[\"hash_ids\"])\n        RateLimit.called(event_key)\n\n        \n        if self.server.tor_manager and self.server.tor_manager.site_onions.get(site.address):  \n            my_ip = helper.packOnionAddress(self.server.tor_manager.site_onions[site.address], self.server.port)\n            my_back = back_onion\n        elif config.ip_external:  \n            my_ip = helper.packAddress(config.ip_external, self.server.port)\n            my_back = back_ip4\n        elif self.server.ip and self.server.ip != \"*\":  \n            my_ip = helper.packAddress(self.server.ip, self.server.port)\n            my_back = back_ip4\n        else:\n            my_ip = None\n            my_back = back_ip4\n\n        my_hashfield_set = set(site.content_manager.hashfield)\n        for hash_id in params[\"hash_ids\"]:\n            if hash_id in my_hashfield_set:\n                if hash_id not in my_back:\n                    my_back[hash_id] = []\n                if my_ip:\n                    my_back[hash_id].append(my_ip)  \n\n        if config.verbose:\n            self.log.debug(\n                \"Found: IP4: %s, Onion: %s for %s hashids in %.3fs\" %\n                (len(back_ip4), len(back_onion), len(params[\"hash_ids\"]), time.time() - s)\n            )\n        self.response({\"peers\": back_ip4, \"peers_onion\": back_onion})\n\n    def actionSetHashfield(self, params):\n        site = self.sites.get(params[\"site\"])\n        if not site or not site.settings[\"serving\"]:  \n            self.response({\"error\": \"Unknown site\"})\n            self.connection.badAction(5)\n            return False\n\n        \n        peer = site.addPeer(self.connection.ip, self.connection.port, return_peer=True, connection=self.connection, source=\"request\")\n        if not peer.connection:\n            peer.connect(self.connection)\n        peer.hashfield.replaceFromString(params[\"hashfield_raw\"])\n        self.response({\"ok\": \"Updated\"})\n\n    def actionSiteReload(self, params):\n        if self.connection.ip not in config.ip_local and self.connection.ip != config.ip_external:\n            self.response({\"error\": \"Only local host allowed\"})\n\n        site = self.sites.get(params[\"site\"])\n        site.content_manager.loadContent(params[\"inner_path\"], add_bad_files=False)\n        site.storage.verifyFiles(quick_check=True)\n        site.updateWebsocket()\n\n        self.response({\"ok\": \"Reloaded\"})\n\n    def actionSitePublish(self, params):\n        if self.connection.ip not in config.ip_local and self.connection.ip != config.ip_external:\n            self.response({\"error\": \"Only local host allowed\"})\n\n        site = self.sites.get(params[\"site\"])\n        num = site.publish(limit=8, inner_path=params.get(\"inner_path\", \"content.json\"), diffs=params.get(\"diffs\", {}))\n\n        self.response({\"ok\": \"Successfuly published to %s peers\" % num})\n\n    \n    def actionPing(self, params):\n        self.response(\"Pong!\")\n\n    \n    def actionCheckport(self, params):\n        with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as sock:\n            sock.settimeout(5)\n            if sock.connect_ex((self.connection.ip, params[\"port\"])) == 0:\n                self.response({\"status\": \"open\", \"ip_external\": self.connection.ip})\n            else:\n                self.response({\"status\": \"closed\", \"ip_external\": self.connection.ip})\n\n    \n    def actionUnknown(self, cmd, params):\n        self.response({\"error\": \"Unknown command: %s\" % cmd})\n        self.connection.badAction(5)\n", "comments": "  included modules    third party modules    incoming requests    responded request    if msg dict create   body   msg     route file requests    don allow sites locked    if called within 15 sec keep last update    skip io bound functions    update site file request    site unknown serving    check already working    same file    valid changed    trigger filedone    download every changed file peer    add get peer    on complete publish peers    load new content file download changed files new thread    not changed    add get peer    assign current connection peer    new peer add every ongoing task    download file peer peer locked    invalid sign sha hash    send file content request    site unknown serving    check file readable current position (for big files)    number bytes going send    add peer site added    just added    assign current connection peer    peer exchange request    site unknown serving    add requester peer site    it registered    assign current connection peer    add sent peers site    add sent peers site    send back peers sent list connectable (not port 0)    get modified content json files since    site unknown serving    add peer site added    just added    assign current connection peer    site unknown serving    add peer site added    just added    assign current connection peer    don send changed    site unknown serving    check hashfield    running onion    external ip defined    no external ip defined    add    site unknown serving    add get peer    send simple pong  answer    check requested port peer    unknown command ", "content": "# Included modules\nimport os\nimport time\nimport json\nimport itertools\nimport socket\n\n# Third party modules\nimport gevent\n\nfrom Debug import Debug\nfrom Config import config\nfrom util import RateLimit\nfrom util import StreamingMsgpack\nfrom util import helper\nfrom Plugin import PluginManager\nfrom contextlib import closing\n\nFILE_BUFF = 1024 * 512\n\n\nclass RequestError(Exception):\n    pass\n\n\n# Incoming requests\n@PluginManager.acceptPlugins\nclass FileRequest(object):\n    __slots__ = (\"server\", \"connection\", \"req_id\", \"sites\", \"log\", \"responded\")\n\n    def __init__(self, server, connection):\n        self.server = server\n        self.connection = connection\n\n        self.req_id = None\n        self.sites = self.server.sites\n        self.log = server.log\n        self.responded = False  # Responded to the request\n\n    def send(self, msg, streaming=False):\n        if not self.connection.closed:\n            self.connection.send(msg, streaming)\n\n    def sendRawfile(self, file, read_bytes):\n        if not self.connection.closed:\n            self.connection.sendRawfile(file, read_bytes)\n\n    def response(self, msg, streaming=False):\n        if self.responded:\n            if config.verbose:\n                self.log.debug(\"Req id %s already responded\" % self.req_id)\n            return\n        if not isinstance(msg, dict):  # If msg not a dict create a {\"body\": msg}\n            msg = {\"body\": msg}\n        msg[\"cmd\"] = \"response\"\n        msg[\"to\"] = self.req_id\n        self.responded = True\n        self.send(msg, streaming=streaming)\n\n    # Route file requests\n    def route(self, cmd, req_id, params):\n        self.req_id = req_id\n        # Don't allow other sites than locked\n        if \"site\" in params and self.connection.target_onion:\n            valid_sites = self.connection.getValidSites()\n            if params[\"site\"] not in valid_sites and valid_sites != [\"global\"]:\n                self.response({\"error\": \"Invalid site\"})\n                self.connection.log(\n                    \"Site lock violation: %s not in %s, target onion: %s\" %\n                    (params[\"site\"], valid_sites, self.connection.target_onion)\n                )\n                self.connection.badAction(5)\n                return False\n\n        if cmd == \"update\":\n            event = \"%s update %s %s\" % (self.connection.id, params[\"site\"], params[\"inner_path\"])\n            # If called more than once within 15 sec only keep the last update\n            RateLimit.callAsync(event, max(self.connection.bad_actions, 15), self.actionUpdate, params)\n        else:\n            func_name = \"action\" + cmd[0].upper() + cmd[1:]\n            func = getattr(self, func_name, None)\n            if cmd not in [\"getFile\", \"streamFile\"]:  # Skip IO bound functions\n                if self.connection.cpu_time > 0.5:\n                    self.log.debug(\n                        \"Delay %s %s, cpu_time used by connection: %.3fs\" %\n                        (self.connection.ip, cmd, self.connection.cpu_time)\n                    )\n                    time.sleep(self.connection.cpu_time)\n                    if self.connection.cpu_time > 5:\n                        self.connection.close(\"Cpu time: %.3fs\" % self.connection.cpu_time)\n                s = time.time()\n            if func:\n                func(params)\n            else:\n                self.actionUnknown(cmd, params)\n\n            if cmd not in [\"getFile\", \"streamFile\"]:\n                taken = time.time() - s\n                taken_sent = self.connection.last_sent_time - self.connection.last_send_time\n                self.connection.cpu_time += taken - taken_sent\n\n    # Update a site file request\n    def actionUpdate(self, params):\n        site = self.sites.get(params[\"site\"])\n        if not site or not site.settings[\"serving\"]:  # Site unknown or not serving\n            self.response({\"error\": \"Unknown site\"})\n            self.connection.badAction(1)\n            return False\n\n        inner_path = params.get(\"inner_path\", \"\")\n\n        if not inner_path.endswith(\"content.json\"):\n            self.response({\"error\": \"Only content.json update allowed\"})\n            self.connection.badAction(5)\n            return\n\n        try:\n            content = json.loads(params[\"body\"])\n        except Exception, err:\n            self.log.debug(\"Update for %s is invalid JSON: %s\" % (inner_path, err))\n            self.response({\"error\": \"File invalid JSON\"})\n            self.connection.badAction(5)\n            return\n\n        file_uri = \"%s/%s:%s\" % (site.address, inner_path, content[\"modified\"])\n\n        if self.server.files_parsing.get(file_uri):  # Check if we already working on it\n            valid = None  # Same file\n        else:\n            try:\n                valid = site.content_manager.verifyFile(inner_path, content)\n            except Exception, err:\n                self.log.debug(\"Update for %s is invalid: %s\" % (inner_path, err))\n                valid = False\n\n        if valid is True:  # Valid and changed\n            site.log.info(\"Update for %s looks valid, saving...\" % inner_path)\n            self.server.files_parsing[file_uri] = True\n            site.storage.write(inner_path, params[\"body\"])\n            del params[\"body\"]\n\n            site.onFileDone(inner_path)  # Trigger filedone\n\n            if inner_path.endswith(\"content.json\"):  # Download every changed file from peer\n                peer = site.addPeer(self.connection.ip, self.connection.port, return_peer=True, source=\"update\")  # Add or get peer\n                # On complete publish to other peers\n                diffs = params.get(\"diffs\", {})\n                site.onComplete.once(lambda: site.publish(inner_path=inner_path, diffs=diffs, limit=3), \"publish_%s\" % inner_path)\n\n                # Load new content file and download changed files in new thread\n                def downloader():\n                    site.downloadContent(inner_path, peer=peer, diffs=params.get(\"diffs\", {}))\n                    del self.server.files_parsing[file_uri]\n\n                gevent.spawn(downloader)\n            else:\n                del self.server.files_parsing[file_uri]\n\n            self.response({\"ok\": \"Thanks, file %s updated!\" % inner_path})\n            self.connection.goodAction()\n\n        elif valid is None:  # Not changed\n            peer = site.addPeer(self.connection.ip, self.connection.port, return_peer=True, source=\"update old\")  # Add or get peer\n            if peer:\n                if not peer.connection:\n                    peer.connect(self.connection)  # Assign current connection to peer\n                if inner_path in site.content_manager.contents:\n                    peer.last_content_json_update = site.content_manager.contents[inner_path][\"modified\"]\n                if config.verbose:\n                    self.log.debug(\n                        \"Same version, adding new peer for locked files: %s, tasks: %s\" %\n                        (peer.key, len(site.worker_manager.tasks))\n                    )\n                for task in site.worker_manager.tasks:  # New peer add to every ongoing task\n                    if task[\"peers\"] and not task[\"optional_hash_id\"]:\n                        # Download file from this peer too if its peer locked\n                        site.needFile(task[\"inner_path\"], peer=peer, update=True, blocking=False)\n\n            self.response({\"ok\": \"File not changed\"})\n            self.connection.badAction()\n\n        else:  # Invalid sign or sha hash\n            self.response({\"error\": \"File invalid: %s\" % err})\n            self.connection.badAction(5)\n\n    def isReadable(self, site, inner_path, file, pos):\n        return True\n\n    # Send file content request\n    def handleGetFile(self, params, streaming=False):\n        site = self.sites.get(params[\"site\"])\n        if not site or not site.settings[\"serving\"]:  # Site unknown or not serving\n            self.response({\"error\": \"Unknown site\"})\n            return False\n        try:\n            file_path = site.storage.getPath(params[\"inner_path\"])\n            if streaming:\n                file_obj = site.storage.open(params[\"inner_path\"])\n            else:\n                file_obj = StreamingMsgpack.FilePart(file_path, \"rb\")\n\n            with file_obj as file:\n                file.seek(params[\"location\"])\n                read_bytes = params.get(\"read_bytes\", FILE_BUFF)\n                file_size = os.fstat(file.fileno()).st_size\n\n                if file_size > read_bytes:  # Check if file is readable at current position (for big files)\n                    if not self.isReadable(site, params[\"inner_path\"], file, params[\"location\"]):\n                        raise RequestError(\"File not readable at position: %s\" % params[\"location\"])\n\n                if not streaming:\n                    file.read_bytes = read_bytes\n\n                if params.get(\"file_size\") and params[\"file_size\"] != file_size:\n                    self.connection.badAction(2)\n                    raise RequestError(\"File size does not match: %sB != %sB\" % (params[\"file_size\"], file_size))\n\n                if params[\"location\"] > file_size:\n                    self.connection.badAction(5)\n                    raise RequestError(\"Bad file location\")\n\n                if streaming:\n                    back = {\n                        \"size\": file_size,\n                        \"location\": min(file.tell() + read_bytes, file_size),\n                        \"stream_bytes\": min(read_bytes, file_size - params[\"location\"])\n                    }\n                    self.response(back)\n                    self.sendRawfile(file, read_bytes=read_bytes)\n                else:\n                    back = {\n                        \"body\": file,\n                        \"size\": file_size,\n                        \"location\": min(file.tell() + file.read_bytes, file_size)\n                    }\n                    self.response(back, streaming=True)\n\n                bytes_sent = min(read_bytes, file_size - params[\"location\"])  # Number of bytes we going to send\n                site.settings[\"bytes_sent\"] = site.settings.get(\"bytes_sent\", 0) + bytes_sent\n            if config.debug_socket:\n                self.log.debug(\"File %s at position %s sent %s bytes\" % (file_path, params[\"location\"], bytes_sent))\n\n            # Add peer to site if not added before\n            connected_peer = site.addPeer(self.connection.ip, self.connection.port, source=\"request\")\n            if connected_peer:  # Just added\n                connected_peer.connect(self.connection)  # Assign current connection to peer\n\n            return {\"bytes_sent\": bytes_sent, \"file_size\": file_size, \"location\": params[\"location\"]}\n\n        except RequestError, err:\n            self.log.debug(\"GetFile %s %s request error: %s\" % (self.connection, params[\"inner_path\"], Debug.formatException(err)))\n            self.response({\"error\": \"File read error: %s\" % err})\n        except Exception, err:\n            if config.verbose:\n                self.log.debug(\"GetFile read error: %s\" % Debug.formatException(err))\n            self.response({\"error\": \"File read error\"})\n            return False\n\n    def actionGetFile(self, params):\n        return self.handleGetFile(params)\n\n    def actionStreamFile(self, params):\n        return self.handleGetFile(params, streaming=True)\n\n    # Peer exchange request\n    def actionPex(self, params):\n        site = self.sites.get(params[\"site\"])\n        if not site or not site.settings[\"serving\"]:  # Site unknown or not serving\n            self.response({\"error\": \"Unknown site\"})\n            return False\n\n        got_peer_keys = []\n        added = 0\n\n        # Add requester peer to site\n        connected_peer = site.addPeer(self.connection.ip, self.connection.port, source=\"request\")\n\n        if connected_peer:  # It was not registered before\n            added += 1\n            connected_peer.connect(self.connection)  # Assign current connection to peer\n\n        # Add sent peers to site\n        for packed_address in params.get(\"peers\", []):\n            address = helper.unpackAddress(packed_address)\n            got_peer_keys.append(\"%s:%s\" % address)\n            if site.addPeer(*address, source=\"pex\"):\n                added += 1\n\n        # Add sent peers to site\n        for packed_address in params.get(\"peers_onion\", []):\n            address = helper.unpackOnionAddress(packed_address)\n            got_peer_keys.append(\"%s:%s\" % address)\n            if site.addPeer(*address, source=\"pex\"):\n                added += 1\n\n        # Send back peers that is not in the sent list and connectable (not port 0)\n        packed_peers = helper.packPeers(site.getConnectablePeers(params[\"need\"], got_peer_keys, allow_private=False))\n\n        if added:\n            site.worker_manager.onPeers()\n            if config.verbose:\n                self.log.debug(\n                    \"Added %s peers to %s using pex, sending back %s\" %\n                    (added, site, len(packed_peers[\"ip4\"]) + len(packed_peers[\"onion\"]))\n                )\n\n        back = {}\n        if packed_peers[\"ip4\"]:\n            back[\"peers\"] = packed_peers[\"ip4\"]\n        if packed_peers[\"onion\"]:\n            back[\"peers_onion\"] = packed_peers[\"onion\"]\n\n        self.response(back)\n\n    # Get modified content.json files since\n    def actionListModified(self, params):\n        site = self.sites.get(params[\"site\"])\n        if not site or not site.settings[\"serving\"]:  # Site unknown or not serving\n            self.response({\"error\": \"Unknown site\"})\n            return False\n        modified_files = site.content_manager.listModified(params[\"since\"])\n\n        # Add peer to site if not added before\n        connected_peer = site.addPeer(self.connection.ip, self.connection.port, source=\"request\")\n        if connected_peer:  # Just added\n            connected_peer.connect(self.connection)  # Assign current connection to peer\n\n        self.response({\"modified_files\": modified_files})\n\n    def actionGetHashfield(self, params):\n        site = self.sites.get(params[\"site\"])\n        if not site or not site.settings[\"serving\"]:  # Site unknown or not serving\n            self.response({\"error\": \"Unknown site\"})\n            return False\n\n        # Add peer to site if not added before\n        peer = site.addPeer(self.connection.ip, self.connection.port, return_peer=True, source=\"request\")\n        if not peer.connection:  # Just added\n            peer.connect(self.connection)  # Assign current connection to peer\n\n        peer.time_my_hashfield_sent = time.time()  # Don't send again if not changed\n\n        self.response({\"hashfield_raw\": site.content_manager.hashfield.tostring()})\n\n    def findHashIds(self, site, hash_ids, limit=100):\n        back_ip4 = {}\n        back_onion = {}\n        found = site.worker_manager.findOptionalHashIds(hash_ids, limit=limit)\n\n        for hash_id, peers in found.iteritems():\n            back_onion[hash_id] = list(itertools.islice((\n                helper.packOnionAddress(peer.ip, peer.port)\n                for peer in peers\n                if peer.ip.endswith(\"onion\")\n            ), 50))\n            back_ip4[hash_id] = list(itertools.islice((\n                helper.packAddress(peer.ip, peer.port)\n                for peer in peers\n                if not peer.ip.endswith(\"onion\")\n            ), 50))\n        return back_ip4, back_onion\n\n    def actionFindHashIds(self, params):\n        site = self.sites.get(params[\"site\"])\n        s = time.time()\n        if not site or not site.settings[\"serving\"]:  # Site unknown or not serving\n            self.response({\"error\": \"Unknown site\"})\n            self.connection.badAction(5)\n            return False\n\n        event_key = \"%s_findHashIds_%s_%s\" % (self.connection.ip, params[\"site\"], len(params[\"hash_ids\"]))\n        if self.connection.cpu_time > 0.5 or not RateLimit.isAllowed(event_key, 60 * 5):\n            time.sleep(0.1)\n            back_ip4, back_onion = self.findHashIds(site, params[\"hash_ids\"], limit=10)\n        else:\n            back_ip4, back_onion = self.findHashIds(site, params[\"hash_ids\"])\n        RateLimit.called(event_key)\n\n        # Check my hashfield\n        if self.server.tor_manager and self.server.tor_manager.site_onions.get(site.address):  # Running onion\n            my_ip = helper.packOnionAddress(self.server.tor_manager.site_onions[site.address], self.server.port)\n            my_back = back_onion\n        elif config.ip_external:  # External ip defined\n            my_ip = helper.packAddress(config.ip_external, self.server.port)\n            my_back = back_ip4\n        elif self.server.ip and self.server.ip != \"*\":  # No external ip defined\n            my_ip = helper.packAddress(self.server.ip, self.server.port)\n            my_back = back_ip4\n        else:\n            my_ip = None\n            my_back = back_ip4\n\n        my_hashfield_set = set(site.content_manager.hashfield)\n        for hash_id in params[\"hash_ids\"]:\n            if hash_id in my_hashfield_set:\n                if hash_id not in my_back:\n                    my_back[hash_id] = []\n                if my_ip:\n                    my_back[hash_id].append(my_ip)  # Add myself\n\n        if config.verbose:\n            self.log.debug(\n                \"Found: IP4: %s, Onion: %s for %s hashids in %.3fs\" %\n                (len(back_ip4), len(back_onion), len(params[\"hash_ids\"]), time.time() - s)\n            )\n        self.response({\"peers\": back_ip4, \"peers_onion\": back_onion})\n\n    def actionSetHashfield(self, params):\n        site = self.sites.get(params[\"site\"])\n        if not site or not site.settings[\"serving\"]:  # Site unknown or not serving\n            self.response({\"error\": \"Unknown site\"})\n            self.connection.badAction(5)\n            return False\n\n        # Add or get peer\n        peer = site.addPeer(self.connection.ip, self.connection.port, return_peer=True, connection=self.connection, source=\"request\")\n        if not peer.connection:\n            peer.connect(self.connection)\n        peer.hashfield.replaceFromString(params[\"hashfield_raw\"])\n        self.response({\"ok\": \"Updated\"})\n\n    def actionSiteReload(self, params):\n        if self.connection.ip not in config.ip_local and self.connection.ip != config.ip_external:\n            self.response({\"error\": \"Only local host allowed\"})\n\n        site = self.sites.get(params[\"site\"])\n        site.content_manager.loadContent(params[\"inner_path\"], add_bad_files=False)\n        site.storage.verifyFiles(quick_check=True)\n        site.updateWebsocket()\n\n        self.response({\"ok\": \"Reloaded\"})\n\n    def actionSitePublish(self, params):\n        if self.connection.ip not in config.ip_local and self.connection.ip != config.ip_external:\n            self.response({\"error\": \"Only local host allowed\"})\n\n        site = self.sites.get(params[\"site\"])\n        num = site.publish(limit=8, inner_path=params.get(\"inner_path\", \"content.json\"), diffs=params.get(\"diffs\", {}))\n\n        self.response({\"ok\": \"Successfuly published to %s peers\" % num})\n\n    # Send a simple Pong! answer\n    def actionPing(self, params):\n        self.response(\"Pong!\")\n\n    # Check requested port of the other peer\n    def actionCheckport(self, params):\n        with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as sock:\n            sock.settimeout(5)\n            if sock.connect_ex((self.connection.ip, params[\"port\"])) == 0:\n                self.response({\"status\": \"open\", \"ip_external\": self.connection.ip})\n            else:\n                self.response({\"status\": \"closed\", \"ip_external\": self.connection.ip})\n\n    # Unknown command\n    def actionUnknown(self, cmd, params):\n        self.response({\"error\": \"Unknown command: %s\" % cmd})\n        self.connection.badAction(5)\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "FileRequest.py", "id": "977b4d9e4372e1be881ecaf0d2fffbfc", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/src/File/FileRequest.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}