{"author": "pypa", "code": "\nfrom . import win32\n\n\n\nclass WinColor(object):\n    BLACK   = 0\n    BLUE    = 1\n    GREEN   = 2\n    CYAN    = 3\n    RED     = 4\n    MAGENTA = 5\n    YELLOW  = 6\n    GREY    = 7\n\n\nclass WinStyle(object):\n    NORMAL              = 0x00 \n    BRIGHT              = 0x08 \n    BRIGHT_BACKGROUND   = 0x80 \n\nclass WinTerm(object):\n\n    def __init__(self):\n        self._default = win32.GetConsoleScreenBufferInfo(win32.STDOUT).wAttributes\n        self.set_attrs(self._default)\n        self._default_fore = self._fore\n        self._default_back = self._back\n        self._default_style = self._style\n        \n        \n        \n        \n        self._light = 0\n\n    def get_attrs(self):\n        return self._fore + self._back * 16 + (self._style | self._light)\n\n    def set_attrs(self, value):\n        self._fore = value & 7\n        self._back = (value >> 4) & 7\n        self._style = value & (WinStyle.BRIGHT | WinStyle.BRIGHT_BACKGROUND)\n\n    def reset_all(self, on_stderr=None):\n        self.set_attrs(self._default)\n        self.set_console(attrs=self._default)\n\n    def fore(self, fore=None, light=False, on_stderr=False):\n        if fore is None:\n            fore = self._default_fore\n        self._fore = fore\n        \n        if light:\n            self._light |= WinStyle.BRIGHT\n        else:\n            self._light &= ~WinStyle.BRIGHT\n        self.set_console(on_stderr=on_stderr)\n\n    def back(self, back=None, light=False, on_stderr=False):\n        if back is None:\n            back = self._default_back\n        self._back = back\n        \n        if light:\n            self._light |= WinStyle.BRIGHT_BACKGROUND\n        else:\n            self._light &= ~WinStyle.BRIGHT_BACKGROUND\n        self.set_console(on_stderr=on_stderr)\n\n    def style(self, style=None, on_stderr=False):\n        if style is None:\n            style = self._default_style\n        self._style = style\n        self.set_console(on_stderr=on_stderr)\n\n    def set_console(self, attrs=None, on_stderr=False):\n        if attrs is None:\n            attrs = self.get_attrs()\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        win32.SetConsoleTextAttribute(handle, attrs)\n\n    def get_position(self, handle):\n        position = win32.GetConsoleScreenBufferInfo(handle).dwCursorPosition\n        \n        \n        position.X += 1\n        position.Y += 1\n        return position\n\n    def set_cursor_position(self, position=None, on_stderr=False):\n        if position is None:\n            \n            ()\n            return\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        win32.SetConsoleCursorPosition(handle, position)\n\n    def cursor_adjust(self, x, y, on_stderr=False):\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        position = self.get_position(handle)\n        adjusted_position = (position.Y + y, position.X + x)\n        win32.SetConsoleCursorPosition(handle, adjusted_position, adjust=False)\n\n    def erase_screen(self, mode=0, on_stderr=False):\n        \n        \n        # 2 should clear the entire screen, and move cursor to (1,1)\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        csbi = win32.GetConsoleScreenBufferInfo(handle)\n        \n        cells_in_screen = csbi.dwSize.X * csbi.dwSize.Y\n        \n        cells_before_cursor = csbi.dwSize.X * csbi.dwCursorPosition.Y + csbi.dwCursorPosition.X\n        if mode == 0:\n            from_coord = csbi.dwCursorPosition\n            cells_to_erase = cells_in_screen - cells_before_cursor\n        if mode == 1:\n            from_coord = win32.COORD(0, 0)\n            cells_to_erase = cells_before_cursor\n        elif mode == 2:\n            from_coord = win32.COORD(0, 0)\n            cells_to_erase = cells_in_screen\n        \n        win32.FillConsoleOutputCharacter(handle, ' ', cells_to_erase, from_coord)\n        \n        win32.FillConsoleOutputAttribute(handle, self.get_attrs(), cells_to_erase, from_coord)\n        if mode == 2:\n            \n            win32.SetConsoleCursorPosition(handle, (1, 1))\n\n    def erase_line(self, mode=0, on_stderr=False):\n        \n        \n        \n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        csbi = win32.GetConsoleScreenBufferInfo(handle)\n        if mode == 0:\n            from_coord = csbi.dwCursorPosition\n            cells_to_erase = csbi.dwSize.X - csbi.dwCursorPosition.X\n        if mode == 1:\n            from_coord = win32.COORD(0, csbi.dwCursorPosition.Y)\n            cells_to_erase = csbi.dwCursorPosition.X\n        elif mode == 2:\n            from_coord = win32.COORD(0, csbi.dwCursorPosition.Y)\n            cells_to_erase = csbi.dwSize.X\n        \n        win32.FillConsoleOutputCharacter(handle, ' ', cells_to_erase, from_coord)\n        \n        win32.FillConsoleOutputAttribute(handle, self.get_attrs(), cells_to_erase, from_coord)\n\n    def set_title(self, title):\n        win32.SetConsoleTitle(title)\n", "comments": "  copyright jonathan hartley 2013  bsd 3 clause license  see license file     wincon h    wincon h    dim text  dim background    bright text  dim background    dim text  bright background    in order emulate light ex windows  borrow bright style     so light ex colors bright style clobber     track separately  since light ex overwritten fore back    bright overwritten style codes     emulate light ex bright style    emulate light ex bright background style    because windows coordinates 0 based     win32 setconsolecursorposition expects 1 based     i currently tracking position  default     position   self get position()    0 clear cursor end screen     1 clear cursor beginning screen     2 clear entire screen  move cursor (1 1)    get number character cells current buffer    get number character cells current cursor position    fill entire screen blanks    set buffer attributes accordingly    put cursor needed    0 clear cursor end line     1 clear cursor beginning line     2 clear entire line     fill entire screen blanks    set buffer attributes accordingly ", "content": "# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\nfrom . import win32\n\n\n# from wincon.h\nclass WinColor(object):\n    BLACK   = 0\n    BLUE    = 1\n    GREEN   = 2\n    CYAN    = 3\n    RED     = 4\n    MAGENTA = 5\n    YELLOW  = 6\n    GREY    = 7\n\n# from wincon.h\nclass WinStyle(object):\n    NORMAL              = 0x00 # dim text, dim background\n    BRIGHT              = 0x08 # bright text, dim background\n    BRIGHT_BACKGROUND   = 0x80 # dim text, bright background\n\nclass WinTerm(object):\n\n    def __init__(self):\n        self._default = win32.GetConsoleScreenBufferInfo(win32.STDOUT).wAttributes\n        self.set_attrs(self._default)\n        self._default_fore = self._fore\n        self._default_back = self._back\n        self._default_style = self._style\n        # In order to emulate LIGHT_EX in windows, we borrow the BRIGHT style.\n        # So that LIGHT_EX colors and BRIGHT style do not clobber each other,\n        # we track them separately, since LIGHT_EX is overwritten by Fore/Back\n        # and BRIGHT is overwritten by Style codes.\n        self._light = 0\n\n    def get_attrs(self):\n        return self._fore + self._back * 16 + (self._style | self._light)\n\n    def set_attrs(self, value):\n        self._fore = value & 7\n        self._back = (value >> 4) & 7\n        self._style = value & (WinStyle.BRIGHT | WinStyle.BRIGHT_BACKGROUND)\n\n    def reset_all(self, on_stderr=None):\n        self.set_attrs(self._default)\n        self.set_console(attrs=self._default)\n\n    def fore(self, fore=None, light=False, on_stderr=False):\n        if fore is None:\n            fore = self._default_fore\n        self._fore = fore\n        # Emulate LIGHT_EX with BRIGHT Style\n        if light:\n            self._light |= WinStyle.BRIGHT\n        else:\n            self._light &= ~WinStyle.BRIGHT\n        self.set_console(on_stderr=on_stderr)\n\n    def back(self, back=None, light=False, on_stderr=False):\n        if back is None:\n            back = self._default_back\n        self._back = back\n        # Emulate LIGHT_EX with BRIGHT_BACKGROUND Style\n        if light:\n            self._light |= WinStyle.BRIGHT_BACKGROUND\n        else:\n            self._light &= ~WinStyle.BRIGHT_BACKGROUND\n        self.set_console(on_stderr=on_stderr)\n\n    def style(self, style=None, on_stderr=False):\n        if style is None:\n            style = self._default_style\n        self._style = style\n        self.set_console(on_stderr=on_stderr)\n\n    def set_console(self, attrs=None, on_stderr=False):\n        if attrs is None:\n            attrs = self.get_attrs()\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        win32.SetConsoleTextAttribute(handle, attrs)\n\n    def get_position(self, handle):\n        position = win32.GetConsoleScreenBufferInfo(handle).dwCursorPosition\n        # Because Windows coordinates are 0-based,\n        # and win32.SetConsoleCursorPosition expects 1-based.\n        position.X += 1\n        position.Y += 1\n        return position\n\n    def set_cursor_position(self, position=None, on_stderr=False):\n        if position is None:\n            # I'm not currently tracking the position, so there is no default.\n            # position = self.get_position()\n            return\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        win32.SetConsoleCursorPosition(handle, position)\n\n    def cursor_adjust(self, x, y, on_stderr=False):\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        position = self.get_position(handle)\n        adjusted_position = (position.Y + y, position.X + x)\n        win32.SetConsoleCursorPosition(handle, adjusted_position, adjust=False)\n\n    def erase_screen(self, mode=0, on_stderr=False):\n        # 0 should clear from the cursor to the end of the screen.\n        # 1 should clear from the cursor to the beginning of the screen.\n        # 2 should clear the entire screen, and move cursor to (1,1)\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        csbi = win32.GetConsoleScreenBufferInfo(handle)\n        # get the number of character cells in the current buffer\n        cells_in_screen = csbi.dwSize.X * csbi.dwSize.Y\n        # get number of character cells before current cursor position\n        cells_before_cursor = csbi.dwSize.X * csbi.dwCursorPosition.Y + csbi.dwCursorPosition.X\n        if mode == 0:\n            from_coord = csbi.dwCursorPosition\n            cells_to_erase = cells_in_screen - cells_before_cursor\n        if mode == 1:\n            from_coord = win32.COORD(0, 0)\n            cells_to_erase = cells_before_cursor\n        elif mode == 2:\n            from_coord = win32.COORD(0, 0)\n            cells_to_erase = cells_in_screen\n        # fill the entire screen with blanks\n        win32.FillConsoleOutputCharacter(handle, ' ', cells_to_erase, from_coord)\n        # now set the buffer's attributes accordingly\n        win32.FillConsoleOutputAttribute(handle, self.get_attrs(), cells_to_erase, from_coord)\n        if mode == 2:\n            # put the cursor where needed\n            win32.SetConsoleCursorPosition(handle, (1, 1))\n\n    def erase_line(self, mode=0, on_stderr=False):\n        # 0 should clear from the cursor to the end of the line.\n        # 1 should clear from the cursor to the beginning of the line.\n        # 2 should clear the entire line.\n        handle = win32.STDOUT\n        if on_stderr:\n            handle = win32.STDERR\n        csbi = win32.GetConsoleScreenBufferInfo(handle)\n        if mode == 0:\n            from_coord = csbi.dwCursorPosition\n            cells_to_erase = csbi.dwSize.X - csbi.dwCursorPosition.X\n        if mode == 1:\n            from_coord = win32.COORD(0, csbi.dwCursorPosition.Y)\n            cells_to_erase = csbi.dwCursorPosition.X\n        elif mode == 2:\n            from_coord = win32.COORD(0, csbi.dwCursorPosition.Y)\n            cells_to_erase = csbi.dwSize.X\n        # fill the entire screen with blanks\n        win32.FillConsoleOutputCharacter(handle, ' ', cells_to_erase, from_coord)\n        # now set the buffer's attributes accordingly\n        win32.FillConsoleOutputAttribute(handle, self.get_attrs(), cells_to_erase, from_coord)\n\n    def set_title(self, title):\n        win32.SetConsoleTitle(title)\n", "description": " Python Development Workflow for Humans.", "file_name": "winterm.py", "id": "2952ceb04e7e8f6c6770afd71b0f5c92", "language": "Python", "project_name": "pipenv", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/pypa-pipenv/pypa-pipenv-9a87a9a/pipenv/vendor/colorama/winterm.py", "save_time": "", "source": "", "update_at": "2018-03-14T01:53:13Z", "url": "https://github.com/pypa/pipenv", "wiki": true}