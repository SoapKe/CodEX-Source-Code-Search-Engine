{"author": "donnemartin", "code": "from collections import OrderedDict\n\n\nclass Node(object):\n\n    def __init__(self, key, parent=None, terminates=False):\n        self.key = key\n        self.terminates = False\n        self.parent = parent\n        self.children = {}\n\n\nclass Trie(object):\n\n    def __init__(self):\n        self.root = Node('')\n\n    def find(self, word):\n        if word is None:\n            raise TypeError('word cannot be None')\n        node = self.root\n        for char in word:\n            if char in node.children:\n                node = node.children[char]\n            else:\n                return None\n        return node if node.terminates else None\n\n    def insert(self, word):\n        if word is None:\n            raise TypeError('word cannot be None')\n        node = self.root\n        parent = None\n        for char in word:\n            if char in node.children:\n                node = node.children[char]\n            else:\n                node.children[char] = Node(char, parent=node)\n                node = node.children[char]\n        node.terminates = True\n\n    def remove(self, word):\n        if word is None:\n            raise TypeError('word cannot be None')\n        node = self.find(word)\n        if node is None:\n            raise KeyError('word does not exist')\n        node.terminates = False\n        parent = node.parent\n        while parent is not None:\n            \n            \n            \n            \n            \n            \n            \n            if node.children or node.terminates:\n                return\n            del parent.children[node.key]\n            node = parent\n            parent = parent.parent\n\n    def list_words(self):\n        result = []\n        curr_word = ''\n        self._list_words(self.root, curr_word, result)\n        return result\n\n    def _list_words(self, node, curr_word, result):\n        if node is None:\n            return\n        for key, child in node.children.items():\n            if child.terminates:\n                result.append(curr_word+key)\n            self._list_words(child, curr_word+key, result)", "comments": "  as propagating delete     parents  node children  stop    prevent orphaning children     or    node terminating node    terminating node input word      stop prevent removing associated word  ", "content": "from collections import OrderedDict\n\n\nclass Node(object):\n\n    def __init__(self, key, parent=None, terminates=False):\n        self.key = key\n        self.terminates = False\n        self.parent = parent\n        self.children = {}\n\n\nclass Trie(object):\n\n    def __init__(self):\n        self.root = Node('')\n\n    def find(self, word):\n        if word is None:\n            raise TypeError('word cannot be None')\n        node = self.root\n        for char in word:\n            if char in node.children:\n                node = node.children[char]\n            else:\n                return None\n        return node if node.terminates else None\n\n    def insert(self, word):\n        if word is None:\n            raise TypeError('word cannot be None')\n        node = self.root\n        parent = None\n        for char in word:\n            if char in node.children:\n                node = node.children[char]\n            else:\n                node.children[char] = Node(char, parent=node)\n                node = node.children[char]\n        node.terminates = True\n\n    def remove(self, word):\n        if word is None:\n            raise TypeError('word cannot be None')\n        node = self.find(word)\n        if node is None:\n            raise KeyError('word does not exist')\n        node.terminates = False\n        parent = node.parent\n        while parent is not None:\n            # As we are propagating the delete up the \n            # parents, if this node has children, stop\n            # here to prevent orphaning its children.\n            # Or\n            # if this node is a terminating node that is\n            # not the terminating node of the input word, \n            # stop to prevent removing the associated word.\n            if node.children or node.terminates:\n                return\n            del parent.children[node.key]\n            node = parent\n            parent = parent.parent\n\n    def list_words(self):\n        result = []\n        curr_word = ''\n        self._list_words(self.root, curr_word, result)\n        return result\n\n    def _list_words(self, node, curr_word, result):\n        if node is None:\n            return\n        for key, child in node.children.items():\n            if child.terminates:\n                result.append(curr_word+key)\n            self._list_words(child, curr_word+key, result)", "description": "Interactive Python coding interview challenges (algorithms and data structures).  Includes Anki flashcards.", "file_name": "trie.py", "id": "4f3bf0748dd9342ca8b49002d6855a5e", "language": "Python", "project_name": "interactive-coding-challenges", "quality": "", "save_path": "/home/ubuntu/test_files/clean/network_test/donnemartin-interactive-coding-challenges/donnemartin-interactive-coding-challenges-6eb3114/graphs_trees/trie/trie.py", "save_time": "", "source": "", "update_at": "2018-03-13T21:01:52Z", "url": "https://github.com/donnemartin/interactive-coding-challenges", "wiki": true}