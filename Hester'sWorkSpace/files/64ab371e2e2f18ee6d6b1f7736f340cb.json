{"author": "mopidy", "code": "from __future__ import absolute_import, unicode_literals\n\nimport os\n\nimport mock\n\nimport pkg_resources\n\nimport pytest\n\nfrom mopidy import config, exceptions, ext\n\nfrom tests import IsA, any_unicode\n\n\nclass DummyExtension(ext.Extension):\n    dist_name = 'Mopidy-Foobar'\n    ext_name = 'foobar'\n    version = '1.2.3'\n\n    def get_default_config(self):\n        return '[foobar]\\nenabled = true'\n\n\nany_testextension = IsA(DummyExtension)\n\n\nclass TestExtension(object):\n\n    @pytest.fixture\n    def extension(self):\n        return ext.Extension()\n\n    def test_dist_name_is_none(self, extension):\n        assert extension.dist_name is None\n\n    def test_ext_name_is_none(self, extension):\n        assert extension.ext_name is None\n\n    def test_version_is_none(self, extension):\n        assert extension.version is None\n\n    def test_get_default_config_raises_not_implemented(self, extension):\n        with pytest.raises(NotImplementedError):\n            extension.get_default_config()\n\n    def test_get_config_schema_returns_extension_schema(self, extension):\n        schema = extension.get_config_schema()\n        assert isinstance(schema['enabled'], config.Boolean)\n\n    def test_validate_environment_does_nothing_by_default(self, extension):\n        assert extension.validate_environment() is None\n\n    def test_setup_raises_not_implemented(self, extension):\n        with pytest.raises(NotImplementedError):\n            extension.setup(None)\n\n    def test_get_cache_dir_raises_assertion_error(self, extension):\n        config = {'core': {'cache_dir': '/tmp'}}\n        with pytest.raises(AssertionError):  \n            ext.Extension.get_cache_dir(config)\n\n    def test_get_config_dir_raises_assertion_error(self, extension):\n        config = {'core': {'config_dir': '/tmp'}}\n        with pytest.raises(AssertionError):  \n            ext.Extension.get_config_dir(config)\n\n    def test_get_data_dir_raises_assertion_error(self, extension):\n        config = {'core': {'data_dir': '/tmp'}}\n        with pytest.raises(AssertionError):  \n            ext.Extension.get_data_dir(config)\n\n\nclass TestLoadExtensions(object):\n\n    @pytest.yield_fixture\n    def iter_entry_points_mock(self, request):\n        patcher = mock.patch('pkg_resources.iter_entry_points')\n        iter_entry_points = patcher.start()\n        iter_entry_points.return_value = []\n        yield iter_entry_points\n        patcher.stop()\n\n    def test_no_extensions(self, iter_entry_points_mock):\n        iter_entry_points_mock.return_value = []\n        assert ext.load_extensions() == []\n\n    def test_load_extensions(self, iter_entry_points_mock):\n        mock_entry_point = mock.Mock()\n        mock_entry_point.load.return_value = DummyExtension\n\n        iter_entry_points_mock.return_value = [mock_entry_point]\n\n        expected = ext.ExtensionData(\n            any_testextension, mock_entry_point, IsA(config.ConfigSchema),\n            any_unicode, None)\n\n        assert ext.load_extensions() == [expected]\n\n    def test_gets_wrong_class(self, iter_entry_points_mock):\n\n        class WrongClass(object):\n            pass\n\n        mock_entry_point = mock.Mock()\n        mock_entry_point.load.return_value = WrongClass\n\n        iter_entry_points_mock.return_value = [mock_entry_point]\n\n        assert ext.load_extensions() == []\n\n    def test_gets_instance(self, iter_entry_points_mock):\n        mock_entry_point = mock.Mock()\n        mock_entry_point.load.return_value = DummyExtension()\n\n        iter_entry_points_mock.return_value = [mock_entry_point]\n\n        assert ext.load_extensions() == []\n\n    def test_creating_instance_fails(self, iter_entry_points_mock):\n        mock_extension = mock.Mock(spec=ext.Extension)\n        mock_extension.side_effect = Exception\n\n        mock_entry_point = mock.Mock()\n        mock_entry_point.load.return_value = mock_extension\n\n        iter_entry_points_mock.return_value = [mock_entry_point]\n\n        assert ext.load_extensions() == []\n\n    def test_get_config_schema_fails(self, iter_entry_points_mock):\n        mock_entry_point = mock.Mock()\n        mock_entry_point.load.return_value = DummyExtension\n\n        iter_entry_points_mock.return_value = [mock_entry_point]\n\n        with mock.patch.object(DummyExtension, 'get_config_schema') as get:\n            get.side_effect = Exception\n\n            assert ext.load_extensions() == []\n            get.assert_called_once_with()\n\n    def test_get_default_config_fails(self, iter_entry_points_mock):\n        mock_entry_point = mock.Mock()\n        mock_entry_point.load.return_value = DummyExtension\n\n        iter_entry_points_mock.return_value = [mock_entry_point]\n\n        with mock.patch.object(DummyExtension, 'get_default_config') as get:\n            get.side_effect = Exception\n\n            assert ext.load_extensions() == []\n            get.assert_called_once_with()\n\n    def test_get_command_fails(self, iter_entry_points_mock):\n        mock_entry_point = mock.Mock()\n        mock_entry_point.load.return_value = DummyExtension\n\n        iter_entry_points_mock.return_value = [mock_entry_point]\n\n        with mock.patch.object(DummyExtension, 'get_command') as get:\n            get.side_effect = Exception\n\n            assert ext.load_extensions() == []\n            get.assert_called_once_with()\n\n\nclass TestValidateExtensionData(object):\n\n    @pytest.fixture\n    def ext_data(self):\n        extension = DummyExtension()\n\n        entry_point = mock.Mock()\n        entry_point.name = extension.ext_name\n\n        schema = extension.get_config_schema()\n        defaults = extension.get_default_config()\n        command = extension.get_command()\n\n        return ext.ExtensionData(\n            extension, entry_point, schema, defaults, command)\n\n    def test_name_mismatch(self, ext_data):\n        ext_data.entry_point.name = 'barfoo'\n        assert not ext.validate_extension_data(ext_data)\n\n    def test_distribution_not_found(self, ext_data):\n        error = pkg_resources.DistributionNotFound\n        ext_data.entry_point.require.side_effect = error\n        assert not ext.validate_extension_data(ext_data)\n\n    def test_version_conflict(self, ext_data):\n        error = pkg_resources.VersionConflict\n        ext_data.entry_point.require.side_effect = error\n        assert not ext.validate_extension_data(ext_data)\n\n    def test_entry_point_require_exception(self, ext_data):\n        ext_data.entry_point.require.side_effect = Exception\n\n        \n        with pytest.raises(Exception):\n            assert not ext.validate_extension_data(ext_data)\n\n    def test_extenions_validate_environment_error(self, ext_data):\n        extension = ext_data.extension\n        with mock.patch.object(extension, 'validate_environment') as validate:\n            validate.side_effect = exceptions.ExtensionError('error')\n\n            assert not ext.validate_extension_data(ext_data)\n            validate.assert_called_once_with()\n\n    def test_extenions_validate_environment_exception(self, ext_data):\n        extension = ext_data.extension\n        with mock.patch.object(extension, 'validate_environment') as validate:\n            validate.side_effect = Exception\n\n            assert not ext.validate_extension_data(ext_data)\n            validate.assert_called_once_with()\n\n    def test_missing_schema(self, ext_data):\n        ext_data = ext_data._replace(config_schema=None)\n        assert not ext.validate_extension_data(ext_data)\n\n    def test_schema_that_is_missing_enabled(self, ext_data):\n        del ext_data.config_schema['enabled']\n        ext_data.config_schema['baz'] = config.String()\n        assert not ext.validate_extension_data(ext_data)\n\n    def test_schema_with_wrong_types(self, ext_data):\n        ext_data.config_schema['enabled'] = 123\n        assert not ext.validate_extension_data(ext_data)\n\n    def test_schema_with_invalid_type(self, ext_data):\n        ext_data.config_schema['baz'] = 123\n        assert not ext.validate_extension_data(ext_data)\n\n    def test_no_default_config(self, ext_data):\n        ext_data = ext_data._replace(config_defaults=None)\n        assert not ext.validate_extension_data(ext_data)\n\n    def test_get_cache_dir(self, ext_data):\n        core_cache_dir = '/tmp'\n        config = {'core': {'cache_dir': core_cache_dir}}\n        extension = ext_data.extension\n\n        with mock.patch.object(ext.path, 'get_or_create_dir'):\n            cache_dir = extension.get_cache_dir(config)\n\n        expected = os.path.join(core_cache_dir, extension.ext_name)\n        assert cache_dir == expected\n\n    def test_get_config_dir(self, ext_data):\n        core_config_dir = '/tmp'\n        config = {'core': {'config_dir': core_config_dir}}\n        extension = ext_data.extension\n\n        with mock.patch.object(ext.path, 'get_or_create_dir'):\n            config_dir = extension.get_config_dir(config)\n\n        expected = os.path.join(core_config_dir, extension.ext_name)\n        assert config_dir == expected\n\n    def test_get_data_dir(self, ext_data):\n        core_data_dir = '/tmp'\n        config = {'core': {'data_dir': core_data_dir}}\n        extension = ext_data.extension\n\n        with mock.patch.object(ext.path, 'get_or_create_dir'):\n            data_dir = extension.get_data_dir(config)\n\n        expected = os.path.join(core_data_dir, extension.ext_name)\n        assert data_dir == expected\n", "comments": "  ext name set    ext name set    ext name set    hope entry points well behaved  exception bubble  ", "content": "from __future__ import absolute_import, unicode_literals\n\nimport os\n\nimport mock\n\nimport pkg_resources\n\nimport pytest\n\nfrom mopidy import config, exceptions, ext\n\nfrom tests import IsA, any_unicode\n\n\nclass DummyExtension(ext.Extension):\n    dist_name = 'Mopidy-Foobar'\n    ext_name = 'foobar'\n    version = '1.2.3'\n\n    def get_default_config(self):\n        return '[foobar]\\nenabled = true'\n\n\nany_testextension = IsA(DummyExtension)\n\n\nclass TestExtension(object):\n\n    @pytest.fixture\n    def extension(self):\n        return ext.Extension()\n\n    def test_dist_name_is_none(self, extension):\n        assert extension.dist_name is None\n\n    def test_ext_name_is_none(self, extension):\n        assert extension.ext_name is None\n\n    def test_version_is_none(self, extension):\n        assert extension.version is None\n\n    def test_get_default_config_raises_not_implemented(self, extension):\n        with pytest.raises(NotImplementedError):\n            extension.get_default_config()\n\n    def test_get_config_schema_returns_extension_schema(self, extension):\n        schema = extension.get_config_schema()\n        assert isinstance(schema['enabled'], config.Boolean)\n\n    def test_validate_environment_does_nothing_by_default(self, extension):\n        assert extension.validate_environment() is None\n\n    def test_setup_raises_not_implemented(self, extension):\n        with pytest.raises(NotImplementedError):\n            extension.setup(None)\n\n    def test_get_cache_dir_raises_assertion_error(self, extension):\n        config = {'core': {'cache_dir': '/tmp'}}\n        with pytest.raises(AssertionError):  # ext_name not set\n            ext.Extension.get_cache_dir(config)\n\n    def test_get_config_dir_raises_assertion_error(self, extension):\n        config = {'core': {'config_dir': '/tmp'}}\n        with pytest.raises(AssertionError):  # ext_name not set\n            ext.Extension.get_config_dir(config)\n\n    def test_get_data_dir_raises_assertion_error(self, extension):\n        config = {'core': {'data_dir': '/tmp'}}\n        with pytest.raises(AssertionError):  # ext_name not set\n            ext.Extension.get_data_dir(config)\n\n\nclass TestLoadExtensions(object):\n\n    @pytest.yield_fixture\n    def iter_entry_points_mock(self, request):\n        patcher = mock.patch('pkg_resources.iter_entry_points')\n        iter_entry_points = patcher.start()\n        iter_entry_points.return_value = []\n        yield iter_entry_points\n        patcher.stop()\n\n    def test_no_extensions(self, iter_entry_points_mock):\n        iter_entry_points_mock.return_value = []\n        assert ext.load_extensions() == []\n\n    def test_load_extensions(self, iter_entry_points_mock):\n        mock_entry_point = mock.Mock()\n        mock_entry_point.load.return_value = DummyExtension\n\n        iter_entry_points_mock.return_value = [mock_entry_point]\n\n        expected = ext.ExtensionData(\n            any_testextension, mock_entry_point, IsA(config.ConfigSchema),\n            any_unicode, None)\n\n        assert ext.load_extensions() == [expected]\n\n    def test_gets_wrong_class(self, iter_entry_points_mock):\n\n        class WrongClass(object):\n            pass\n\n        mock_entry_point = mock.Mock()\n        mock_entry_point.load.return_value = WrongClass\n\n        iter_entry_points_mock.return_value = [mock_entry_point]\n\n        assert ext.load_extensions() == []\n\n    def test_gets_instance(self, iter_entry_points_mock):\n        mock_entry_point = mock.Mock()\n        mock_entry_point.load.return_value = DummyExtension()\n\n        iter_entry_points_mock.return_value = [mock_entry_point]\n\n        assert ext.load_extensions() == []\n\n    def test_creating_instance_fails(self, iter_entry_points_mock):\n        mock_extension = mock.Mock(spec=ext.Extension)\n        mock_extension.side_effect = Exception\n\n        mock_entry_point = mock.Mock()\n        mock_entry_point.load.return_value = mock_extension\n\n        iter_entry_points_mock.return_value = [mock_entry_point]\n\n        assert ext.load_extensions() == []\n\n    def test_get_config_schema_fails(self, iter_entry_points_mock):\n        mock_entry_point = mock.Mock()\n        mock_entry_point.load.return_value = DummyExtension\n\n        iter_entry_points_mock.return_value = [mock_entry_point]\n\n        with mock.patch.object(DummyExtension, 'get_config_schema') as get:\n            get.side_effect = Exception\n\n            assert ext.load_extensions() == []\n            get.assert_called_once_with()\n\n    def test_get_default_config_fails(self, iter_entry_points_mock):\n        mock_entry_point = mock.Mock()\n        mock_entry_point.load.return_value = DummyExtension\n\n        iter_entry_points_mock.return_value = [mock_entry_point]\n\n        with mock.patch.object(DummyExtension, 'get_default_config') as get:\n            get.side_effect = Exception\n\n            assert ext.load_extensions() == []\n            get.assert_called_once_with()\n\n    def test_get_command_fails(self, iter_entry_points_mock):\n        mock_entry_point = mock.Mock()\n        mock_entry_point.load.return_value = DummyExtension\n\n        iter_entry_points_mock.return_value = [mock_entry_point]\n\n        with mock.patch.object(DummyExtension, 'get_command') as get:\n            get.side_effect = Exception\n\n            assert ext.load_extensions() == []\n            get.assert_called_once_with()\n\n\nclass TestValidateExtensionData(object):\n\n    @pytest.fixture\n    def ext_data(self):\n        extension = DummyExtension()\n\n        entry_point = mock.Mock()\n        entry_point.name = extension.ext_name\n\n        schema = extension.get_config_schema()\n        defaults = extension.get_default_config()\n        command = extension.get_command()\n\n        return ext.ExtensionData(\n            extension, entry_point, schema, defaults, command)\n\n    def test_name_mismatch(self, ext_data):\n        ext_data.entry_point.name = 'barfoo'\n        assert not ext.validate_extension_data(ext_data)\n\n    def test_distribution_not_found(self, ext_data):\n        error = pkg_resources.DistributionNotFound\n        ext_data.entry_point.require.side_effect = error\n        assert not ext.validate_extension_data(ext_data)\n\n    def test_version_conflict(self, ext_data):\n        error = pkg_resources.VersionConflict\n        ext_data.entry_point.require.side_effect = error\n        assert not ext.validate_extension_data(ext_data)\n\n    def test_entry_point_require_exception(self, ext_data):\n        ext_data.entry_point.require.side_effect = Exception\n\n        # Hope that entry points are well behaved, so exception will bubble.\n        with pytest.raises(Exception):\n            assert not ext.validate_extension_data(ext_data)\n\n    def test_extenions_validate_environment_error(self, ext_data):\n        extension = ext_data.extension\n        with mock.patch.object(extension, 'validate_environment') as validate:\n            validate.side_effect = exceptions.ExtensionError('error')\n\n            assert not ext.validate_extension_data(ext_data)\n            validate.assert_called_once_with()\n\n    def test_extenions_validate_environment_exception(self, ext_data):\n        extension = ext_data.extension\n        with mock.patch.object(extension, 'validate_environment') as validate:\n            validate.side_effect = Exception\n\n            assert not ext.validate_extension_data(ext_data)\n            validate.assert_called_once_with()\n\n    def test_missing_schema(self, ext_data):\n        ext_data = ext_data._replace(config_schema=None)\n        assert not ext.validate_extension_data(ext_data)\n\n    def test_schema_that_is_missing_enabled(self, ext_data):\n        del ext_data.config_schema['enabled']\n        ext_data.config_schema['baz'] = config.String()\n        assert not ext.validate_extension_data(ext_data)\n\n    def test_schema_with_wrong_types(self, ext_data):\n        ext_data.config_schema['enabled'] = 123\n        assert not ext.validate_extension_data(ext_data)\n\n    def test_schema_with_invalid_type(self, ext_data):\n        ext_data.config_schema['baz'] = 123\n        assert not ext.validate_extension_data(ext_data)\n\n    def test_no_default_config(self, ext_data):\n        ext_data = ext_data._replace(config_defaults=None)\n        assert not ext.validate_extension_data(ext_data)\n\n    def test_get_cache_dir(self, ext_data):\n        core_cache_dir = '/tmp'\n        config = {'core': {'cache_dir': core_cache_dir}}\n        extension = ext_data.extension\n\n        with mock.patch.object(ext.path, 'get_or_create_dir'):\n            cache_dir = extension.get_cache_dir(config)\n\n        expected = os.path.join(core_cache_dir, extension.ext_name)\n        assert cache_dir == expected\n\n    def test_get_config_dir(self, ext_data):\n        core_config_dir = '/tmp'\n        config = {'core': {'config_dir': core_config_dir}}\n        extension = ext_data.extension\n\n        with mock.patch.object(ext.path, 'get_or_create_dir'):\n            config_dir = extension.get_config_dir(config)\n\n        expected = os.path.join(core_config_dir, extension.ext_name)\n        assert config_dir == expected\n\n    def test_get_data_dir(self, ext_data):\n        core_data_dir = '/tmp'\n        config = {'core': {'data_dir': core_data_dir}}\n        extension = ext_data.extension\n\n        with mock.patch.object(ext.path, 'get_or_create_dir'):\n            data_dir = extension.get_data_dir(config)\n\n        expected = os.path.join(core_data_dir, extension.ext_name)\n        assert data_dir == expected\n", "description": "Mopidy is an extensible music server that plays music from local disk, Spotify, SoundCloud, Google Play Music, and more. You edit the playlist from any phone, tablet, or computer using a range of MPD and web clients.", "file_name": "test_ext.py", "id": "64ab371e2e2f18ee6d6b1f7736f340cb", "language": "Python", "project_name": "mopidy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/mopidy-mopidy/mopidy-mopidy-79d42c3/tests/test_ext.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:12:51Z", "url": "https://github.com/mopidy/mopidy", "wiki": false}