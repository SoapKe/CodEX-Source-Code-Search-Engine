{"author": "HelloZeroNet", "code": "\"\"\"\nmaxminddb.decoder\n~~~~~~~~~~~~~~~~~\n\nThis package contains code for decoding the MaxMind DB data section.\n\n\"\"\"\nfrom __future__ import unicode_literals\n\nimport struct\n\nfrom maxminddb.compat import byte_from_int, int_from_bytes\nfrom maxminddb.errors import InvalidDatabaseError\n\n\nclass Decoder(object):  \n\n    \"\"\"Decoder for the data section of the MaxMind DB\"\"\"\n\n    def __init__(self, database_buffer, pointer_base=0, pointer_test=False):\n        \"\"\"Created a Decoder for a MaxMind DB\n\n        Arguments:\n        database_buffer -- an mmap'd MaxMind DB file.\n        pointer_base -- the base number to use when decoding a pointer\n        pointer_test -- used for internal unit testing of pointer code\n        \"\"\"\n        self._pointer_test = pointer_test\n        self._buffer = database_buffer\n        self._pointer_base = pointer_base\n\n    def _decode_array(self, size, offset):\n        array = []\n        for _ in range(size):\n            (value, offset) = self.decode(offset)\n            array.append(value)\n        return array, offset\n\n    def _decode_boolean(self, size, offset):\n        return size != 0, offset\n\n    def _decode_bytes(self, size, offset):\n        new_offset = offset + size\n        return self._buffer[offset:new_offset], new_offset\n\n    \n    |\n        lots of code duplication.\n    def _decode_packed_type(type_code, type_size, pad=False):\n        pylint: disable=protected-access, missing-docstring\n        def unpack_type(self, size, offset):\n            if not pad:\n                self._verify_size(size, type_size)\n            new_offset = offset + type_size\n            packed_bytes = self._buffer[offset:new_offset]\n            if pad:\n                packed_bytes = packed_bytes.rjust(type_size, b'\\x00')\n            (value,) = struct.unpack(type_code, packed_bytes)\n            return value, new_offset\n        return unpack_type\n\n    def _decode_map(self, size, offset):\n        container = {}\n        for _ in range(size):\n            (key, offset) = self.decode(offset)\n            (value, offset) = self.decode(offset)\n            container[key] = value\n        return container, offset\n\n    _pointer_value_offset = {\n        1: 0,\n        2: 2048,\n        3: 526336,\n        4: 0,\n    }\n\n    def _decode_pointer(self, size, offset):\n        pointer_size = ((size >> 3) & 0x3) + 1\n        new_offset = offset + pointer_size\n        pointer_bytes = self._buffer[offset:new_offset]\n        packed = pointer_bytes if pointer_size == 4 else struct.pack(\n            b'!c', byte_from_int(size & 0x7)) + pointer_bytes\n        unpacked = int_from_bytes(packed)\n        pointer = unpacked + self._pointer_base + \\\n            self._pointer_value_offset[pointer_size]\n        if self._pointer_test:\n            return pointer, new_offset\n        (value, _) = self.decode(pointer)\n        return value, new_offset\n\n    def _decode_uint(self, size, offset):\n        new_offset = offset + size\n        uint_bytes = self._buffer[offset:new_offset]\n        return int_from_bytes(uint_bytes), new_offset\n\n    def _decode_utf8_string(self, size, offset):\n        new_offset = offset + size\n        return self._buffer[offset:new_offset].decode('utf-8'), new_offset\n\n    _type_decoder = {\n        1: _decode_pointer,\n        2: _decode_utf8_string,\n        3: _decode_packed_type(b'!d', 8),  double,\n        4: _decode_bytes,\n        5: _decode_uint,  uint16\n        6: _decode_uint,  uint32\n        7: _decode_map,\n        8: _decode_packed_type(b'!i', 4, pad=True),  int32\n        9: _decode_uint,  uint64\n        10: _decode_uint,  uint128\n        11: _decode_array,\n        14: _decode_boolean,\n        15: _decode_packed_type(b'!f', 4),  float,\n    }\n\n    def decode(self, offset):\n        \"\"\"Decode a section of the data section starting at offset\n\n        Arguments:\n        offset -- the location of the data structure to decode\n        \"\"\"\n        new_offset = offset + 1\n        (ctrl_byte,) = struct.unpack(b'!B', self._buffer[offset:new_offset])\n        type_num = ctrl_byte >> 5\n        Extended type\n        if not type_num:\n            (type_num, new_offset) = self._read_extended(new_offset)\n\n        if not type_num in self._type_decoder:\n            raise InvalidDatabaseError('Unexpected type number ({type}) '\n                                       'encountered'.format(type=type_num))\n\n        (size, new_offset) = self._size_from_ctrl_byte(\n            ctrl_byte, new_offset, type_num)\n        return self._type_decoder[type_num](self, size, new_offset)\n\n    def _read_extended(self, offset):\n        (next_byte,) = struct.unpack(b'!B', self._buffer[offset:offset + 1])\n        type_num = next_byte + 7\n        if type_num < 7:\n            raise InvalidDatabaseError(\n                'Something went horribly wrong in the decoder. An '\n                'extended type resolved to a type number < 8 '\n                '({type})'.format(type=type_num))\n        return type_num, offset + 1\n\n    def _verify_size(self, expected, actual):\n        if expected != actual:\n            raise InvalidDatabaseError(\n                'The MaxMind DB file\\'s data section contains bad data '\n                '(unknown data type or corrupt data)'\n            )\n\n    def _size_from_ctrl_byte(self, ctrl_byte, offset, type_num):\n        size = ctrl_byte & 0x1f\n        if type_num == 1:\n            return size, offset\n        bytes_to_read = 0 if size < 29 else size - 28\n\n        new_offset = offset + bytes_to_read\n        size_bytes = self._buffer[offset:new_offset]\n\n        Using unpack rather than int_from_bytes as it is about 200 lookups\n        per second faster here.\n        if size == 29:\n            size = 29 + struct.unpack(b'!B', size_bytes)[0]\n        elif size == 30:\n            size = 285 + struct.unpack(b'!H', size_bytes)[0]\n        elif size > 30:\n            size = struct.unpack(\n                b'!I', size_bytes.rjust(4, b'\\x00'))[0] + 65821\n\n        return size, new_offset\n", "comments": "    maxminddb decoder                    this package contains code decoding maxmind db data section         future   import unicode literals  import struct  maxminddb compat import byte int  int bytes maxminddb errors import invaliddatabaseerror   class decoder(object)     pylint  disable public methods         decoder data section maxmind db         def   init  (self  database buffer  pointer base 0  pointer test false)             created decoder maxmind db          arguments          database buffer    mmap maxmind db file          pointer base    base number use decoding pointer         pointer test    used internal unit testing pointer code                     self  pointer test   pointer test         self  buffer   database buffer         self  pointer base   pointer base      def  decode array(self  size  offset)          array                range(size)              (value  offset)   self decode(offset)             array append(value)         return array  offset      def  decode boolean(self  size  offset)          return size    0  offset      def  decode bytes(self  size  offset)          new offset   offset   size         return self  buffer offset new offset   new offset        pylint  disable self argument           i open better ways long involve           lots code duplication      def  decode packed type(type code  type size  pad false)            pylint  disable protected access  missing docstring         def unpack type(self  size  offset)              pad                  self  verify size(size  type size)             new offset   offset   type size             packed bytes   self  buffer offset new offset              pad                  packed bytes   packed bytes rjust(type size  b  x00 )             (value )   struct unpack(type code  packed bytes)             return value  new offset         return unpack type      def  decode map(self  size  offset)          container                range(size)              (key  offset)   self decode(offset)             (value  offset)   self decode(offset)             container key    value         return container  offset       pointer value offset             1  0          2  2048          3  526336          4  0             def  decode pointer(self  size  offset)          pointer size   ((size    3)   0x3)   1         new offset   offset   pointer size         pointer bytes   self  buffer offset new offset          packed   pointer bytes pointer size    4 else struct pack(             b  c   byte int(size   0x7))   pointer bytes         unpacked   int bytes(packed)         pointer   unpacked   self  pointer base                 self  pointer value offset pointer size          self  pointer test              return pointer  new offset         (value   )   self decode(pointer)         return value  new offset      def  decode uint(self  size  offset)          new offset   offset   size         uint bytes   self  buffer offset new offset          return int bytes(uint bytes)  new offset      def  decode utf8 string(self  size  offset)          new offset   offset   size         return self  buffer offset new offset  decode( utf 8 )  new offset       type decoder             1   decode pointer          2   decode utf8 string          3   decode packed type(b    8)     double          4   decode bytes          5   decode uint     uint16         6   decode uint     uint32         7   decode map          8   decode packed type(b    4  pad true)     int32         9   decode uint     uint64         10   decode uint     uint128         11   decode array          14   decode boolean          15   decode packed type(b  f   4)     float             def decode(self  offset)             decode section data section starting offset          arguments          offset    location data structure decode                pylint  disable public methods    pylint  disable self argument        i open better ways long involve        lots code duplication     pylint  disable protected access  missing docstring    double     uint16    uint32    int32    uint64    uint128    float     extended type    using unpack rather int bytes 200 lookups    per second faster  ", "content": "\"\"\"\nmaxminddb.decoder\n~~~~~~~~~~~~~~~~~\n\nThis package contains code for decoding the MaxMind DB data section.\n\n\"\"\"\nfrom __future__ import unicode_literals\n\nimport struct\n\nfrom maxminddb.compat import byte_from_int, int_from_bytes\nfrom maxminddb.errors import InvalidDatabaseError\n\n\nclass Decoder(object):  # pylint: disable=too-few-public-methods\n\n    \"\"\"Decoder for the data section of the MaxMind DB\"\"\"\n\n    def __init__(self, database_buffer, pointer_base=0, pointer_test=False):\n        \"\"\"Created a Decoder for a MaxMind DB\n\n        Arguments:\n        database_buffer -- an mmap'd MaxMind DB file.\n        pointer_base -- the base number to use when decoding a pointer\n        pointer_test -- used for internal unit testing of pointer code\n        \"\"\"\n        self._pointer_test = pointer_test\n        self._buffer = database_buffer\n        self._pointer_base = pointer_base\n\n    def _decode_array(self, size, offset):\n        array = []\n        for _ in range(size):\n            (value, offset) = self.decode(offset)\n            array.append(value)\n        return array, offset\n\n    def _decode_boolean(self, size, offset):\n        return size != 0, offset\n\n    def _decode_bytes(self, size, offset):\n        new_offset = offset + size\n        return self._buffer[offset:new_offset], new_offset\n\n    # pylint: disable=no-self-argument\n    # |-> I am open to better ways of doing this as long as it doesn't involve\n    #     lots of code duplication.\n    def _decode_packed_type(type_code, type_size, pad=False):\n        # pylint: disable=protected-access, missing-docstring\n        def unpack_type(self, size, offset):\n            if not pad:\n                self._verify_size(size, type_size)\n            new_offset = offset + type_size\n            packed_bytes = self._buffer[offset:new_offset]\n            if pad:\n                packed_bytes = packed_bytes.rjust(type_size, b'\\x00')\n            (value,) = struct.unpack(type_code, packed_bytes)\n            return value, new_offset\n        return unpack_type\n\n    def _decode_map(self, size, offset):\n        container = {}\n        for _ in range(size):\n            (key, offset) = self.decode(offset)\n            (value, offset) = self.decode(offset)\n            container[key] = value\n        return container, offset\n\n    _pointer_value_offset = {\n        1: 0,\n        2: 2048,\n        3: 526336,\n        4: 0,\n    }\n\n    def _decode_pointer(self, size, offset):\n        pointer_size = ((size >> 3) & 0x3) + 1\n        new_offset = offset + pointer_size\n        pointer_bytes = self._buffer[offset:new_offset]\n        packed = pointer_bytes if pointer_size == 4 else struct.pack(\n            b'!c', byte_from_int(size & 0x7)) + pointer_bytes\n        unpacked = int_from_bytes(packed)\n        pointer = unpacked + self._pointer_base + \\\n            self._pointer_value_offset[pointer_size]\n        if self._pointer_test:\n            return pointer, new_offset\n        (value, _) = self.decode(pointer)\n        return value, new_offset\n\n    def _decode_uint(self, size, offset):\n        new_offset = offset + size\n        uint_bytes = self._buffer[offset:new_offset]\n        return int_from_bytes(uint_bytes), new_offset\n\n    def _decode_utf8_string(self, size, offset):\n        new_offset = offset + size\n        return self._buffer[offset:new_offset].decode('utf-8'), new_offset\n\n    _type_decoder = {\n        1: _decode_pointer,\n        2: _decode_utf8_string,\n        3: _decode_packed_type(b'!d', 8),  # double,\n        4: _decode_bytes,\n        5: _decode_uint,  # uint16\n        6: _decode_uint,  # uint32\n        7: _decode_map,\n        8: _decode_packed_type(b'!i', 4, pad=True),  # int32\n        9: _decode_uint,  # uint64\n        10: _decode_uint,  # uint128\n        11: _decode_array,\n        14: _decode_boolean,\n        15: _decode_packed_type(b'!f', 4),  # float,\n    }\n\n    def decode(self, offset):\n        \"\"\"Decode a section of the data section starting at offset\n\n        Arguments:\n        offset -- the location of the data structure to decode\n        \"\"\"\n        new_offset = offset + 1\n        (ctrl_byte,) = struct.unpack(b'!B', self._buffer[offset:new_offset])\n        type_num = ctrl_byte >> 5\n        # Extended type\n        if not type_num:\n            (type_num, new_offset) = self._read_extended(new_offset)\n\n        if not type_num in self._type_decoder:\n            raise InvalidDatabaseError('Unexpected type number ({type}) '\n                                       'encountered'.format(type=type_num))\n\n        (size, new_offset) = self._size_from_ctrl_byte(\n            ctrl_byte, new_offset, type_num)\n        return self._type_decoder[type_num](self, size, new_offset)\n\n    def _read_extended(self, offset):\n        (next_byte,) = struct.unpack(b'!B', self._buffer[offset:offset + 1])\n        type_num = next_byte + 7\n        if type_num < 7:\n            raise InvalidDatabaseError(\n                'Something went horribly wrong in the decoder. An '\n                'extended type resolved to a type number < 8 '\n                '({type})'.format(type=type_num))\n        return type_num, offset + 1\n\n    def _verify_size(self, expected, actual):\n        if expected != actual:\n            raise InvalidDatabaseError(\n                'The MaxMind DB file\\'s data section contains bad data '\n                '(unknown data type or corrupt data)'\n            )\n\n    def _size_from_ctrl_byte(self, ctrl_byte, offset, type_num):\n        size = ctrl_byte & 0x1f\n        if type_num == 1:\n            return size, offset\n        bytes_to_read = 0 if size < 29 else size - 28\n\n        new_offset = offset + bytes_to_read\n        size_bytes = self._buffer[offset:new_offset]\n\n        # Using unpack rather than int_from_bytes as it is about 200 lookups\n        # per second faster here.\n        if size == 29:\n            size = 29 + struct.unpack(b'!B', size_bytes)[0]\n        elif size == 30:\n            size = 285 + struct.unpack(b'!H', size_bytes)[0]\n        elif size > 30:\n            size = struct.unpack(\n                b'!I', size_bytes.rjust(4, b'\\x00'))[0] + 65821\n\n        return size, new_offset\n", "description": "ZeroNet - Decentralized websites using Bitcoin crypto and BitTorrent network", "file_name": "decoder.py", "id": "b566a732d08c080cf99254bddc39dfe6", "language": "Python", "project_name": "ZeroNet", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/HelloZeroNet-ZeroNet/HelloZeroNet-ZeroNet-8828629/plugins/Sidebar/maxminddb/decoder.py", "save_time": "", "source": "", "update_at": "2018-03-18T12:17:52Z", "url": "https://github.com/HelloZeroNet/ZeroNet", "wiki": true}