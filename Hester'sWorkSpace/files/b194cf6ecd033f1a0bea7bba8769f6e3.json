{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom .generic import GenericIE\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    ExtractorError,\n    qualities,\n    int_or_none,\n    parse_duration,\n    unified_strdate,\n    xpath_text,\n    update_url_query,\n)\nfrom ..compat import compat_etree_fromstring\n\n\nclass ARDMediathekIE(InfoExtractor):\n    IE_NAME = 'ARD:mediathek'\n    _VALID_URL = r'^https?://(?:(?:www\\.)?ardmediathek\\.de|mediathek\\.(?:daserste|rbb-online)\\.de)/(?:.*/)(?P<video_id>[0-9]+|[^0-9][^/\\?]+)[^/\\?]*(?:\\?.*)?'\n\n    _TESTS = [{\n        \n        'url': 'http://www.ardmediathek.de/tv/S%C3%9CDLICHT/Was-ist-die-Kunst-der-Zukunft-liebe-Ann/BR-Fernsehen/Video?bcastId=34633636&documentId=44726822',\n        'info_dict': {\n            'id': '44726822',\n            'ext': 'mp4',\n            'title': 'Was ist die Kunst der Zukunft, liebe Anna McCarthy?',\n            'description': 'md5:4ada28b3e3b5df01647310e41f3a62f5',\n            'duration': 1740,\n        },\n        'params': {\n            \n            'skip_download': True,\n        }\n    }, {\n        \n        'url': 'http://www.ardmediathek.de/tv/WDR-H%C3%B6rspiel-Speicher/Tod-eines-Fu%C3%9Fballers/WDR-3/Audio-Podcast?documentId=28488308&bcastId=23074086',\n        'only_matching': True,\n    }, {\n        'url': 'http://mediathek.daserste.de/sendungen_a-z/328454_anne-will/22429276_vertrauen-ist-gut-spionieren-ist-besser-geht',\n        'only_matching': True,\n    }, {\n        \n        'url': 'http://mediathek.rbb-online.de/radio/H\u00f6rspiel/Vor-dem-Fest/kulturradio/Audio?documentId=30796318&topRessort=radio&bcastId=9839158',\n        'only_matching': True,\n    }]\n\n    def _extract_media_info(self, media_info_url, webpage, video_id):\n        media_info = self._download_json(\n            media_info_url, video_id, 'Downloading media JSON')\n\n        formats = self._extract_formats(media_info, video_id)\n\n        if not formats:\n            if '\"fsk\"' in webpage:\n                raise ExtractorError(\n                    'This video is only available after 20:00', expected=True)\n            elif media_info.get('_geoblocked'):\n                raise ExtractorError('This video is not available due to geo restriction', expected=True)\n\n        self._sort_formats(formats)\n\n        duration = int_or_none(media_info.get('_duration'))\n        thumbnail = media_info.get('_previewImage')\n        is_live = media_info.get('_isLive') is True\n\n        subtitles = {}\n        subtitle_url = media_info.get('_subtitleUrl')\n        if subtitle_url:\n            subtitles['de'] = [{\n                'ext': 'ttml',\n                'url': subtitle_url,\n            }]\n\n        return {\n            'id': video_id,\n            'duration': duration,\n            'thumbnail': thumbnail,\n            'is_live': is_live,\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n\n    def _extract_formats(self, media_info, video_id):\n        type_ = media_info.get('_type')\n        media_array = media_info.get('_mediaArray', [])\n        formats = []\n        for num, media in enumerate(media_array):\n            for stream in media.get('_mediaStreamArray', []):\n                stream_urls = stream.get('_stream')\n                if not stream_urls:\n                    continue\n                if not isinstance(stream_urls, list):\n                    stream_urls = [stream_urls]\n                quality = stream.get('_quality')\n                server = stream.get('_server')\n                for stream_url in stream_urls:\n                    if not isinstance(stream_url, compat_str) or '//' not in stream_url:\n                        continue\n                    ext = determine_ext(stream_url)\n                    if quality != 'auto' and ext in ('f4m', 'm3u8'):\n                        continue\n                    if ext == 'f4m':\n                        formats.extend(self._extract_f4m_formats(\n                            update_url_query(stream_url, {\n                                'hdcore': '3.1.1',\n                                'plugin': 'aasp-3.1.1.69.124'\n                            }),\n                            video_id, f4m_id='hds', fatal=False))\n                    elif ext == 'm3u8':\n                        formats.extend(self._extract_m3u8_formats(\n                            stream_url, video_id, 'mp4', m3u8_id='hls', fatal=False))\n                    else:\n                        if server and server.startswith('rtmp'):\n                            f = {\n                                'url': server,\n                                'play_path': stream_url,\n                                'format_id': 'a%s-rtmp-%s' % (num, quality),\n                            }\n                        else:\n                            f = {\n                                'url': stream_url,\n                                'format_id': 'a%s-%s-%s' % (num, ext, quality)\n                            }\n                        m = re.search(r'_(?P<width>\\d+)x(?P<height>\\d+)\\.mp4$', stream_url)\n                        if m:\n                            f.update({\n                                'width': int(m.group('width')),\n                                'height': int(m.group('height')),\n                            })\n                        if type_ == 'audio':\n                            f['vcodec'] = 'none'\n                        formats.append(f)\n        return formats\n\n    def _real_extract(self, url):\n        \n        m = re.match(self._VALID_URL, url)\n\n        document_id = None\n\n        numid = re.search(r'documentId=([0-9]+)', url)\n        if numid:\n            document_id = video_id = numid.group(1)\n        else:\n            video_id = m.group('video_id')\n\n        webpage = self._download_webpage(url, video_id)\n\n        ERRORS = (\n            ('>Leider liegt eine St\u00f6rung vor.', 'Video %s is unavailable'),\n            ('>Der gew\u00fcnschte Beitrag ist nicht mehr verf\u00fcgbar.<',\n             'Video %s is no longer available'),\n        )\n\n        for pattern, message in ERRORS:\n            if pattern in webpage:\n                raise ExtractorError(message % video_id, expected=True)\n\n        if re.search(r'[\\?&]rss($|[=&])', url):\n            doc = compat_etree_fromstring(webpage.encode('utf-8'))\n            if doc.tag == 'rss':\n                return GenericIE()._extract_rss(url, video_id, doc)\n\n        title = self._html_search_regex(\n            [r'<h1(?:\\s+class=\"boxTopHeadline\")?>(.*?)</h1>',\n             r'<meta name=\"dcterms\\.title\" content=\"(.*?)\"/>',\n             r'<h4 class=\"headline\">(.*?)</h4>'],\n            webpage, 'title')\n        description = self._html_search_meta(\n            'dcterms.abstract', webpage, 'description', default=None)\n        if description is None:\n            description = self._html_search_meta(\n                'description', webpage, 'meta description')\n\n        \n        \n        \n        thumbnail = self._og_search_thumbnail(webpage, default=None)\n\n        media_streams = re.findall(r, webpage)\n\n        if media_streams:\n            QUALITIES = qualities(['lo', 'hi', 'hq'])\n            formats = []\n            for furl in set(media_streams):\n                if furl.endswith('.f4m'):\n                    fid = 'f4m'\n                else:\n                    fid_m = re.match(r'.*\\.([^.]+)\\.[^.]+$', furl)\n                    fid = fid_m.group(1) if fid_m else None\n                formats.append({\n                    'quality': QUALITIES(fid),\n                    'format_id': fid,\n                    'url': furl,\n                })\n            self._sort_formats(formats)\n            info = {\n                'formats': formats,\n            }\n        else:  \n            if not document_id:\n                video_id = self._search_regex(\n                    r'/play/(?:config|media)/(\\d+)', webpage, 'media id')\n            info = self._extract_media_info(\n                'http://www.ardmediathek.de/play/media/%s' % video_id,\n                webpage, video_id)\n\n        info.update({\n            'id': video_id,\n            'title': self._live_title(title) if info.get('is_live') else title,\n            'description': description,\n            'thumbnail': thumbnail,\n        })\n\n        return info\n\n\nclass ARDIE(InfoExtractor):\n    _VALID_URL = r'(?P<mainurl>https?://(www\\.)?daserste\\.de/[^?\n    _TESTS = [{\n        \n        'url': 'http://www.daserste.de/information/talk/maischberger/videos/das-groko-drama-zerlegen-sich-die-volksparteien-video-102.html',\n        'md5': '8e4ec85f31be7c7fc08a26cdbc5a1f49',\n        'info_dict': {\n            'display_id': 'das-groko-drama-zerlegen-sich-die-volksparteien-video',\n            'id': '102',\n            'ext': 'mp4',\n            'duration': 4435.0,\n            'title': 'Das GroKo-Drama: Zerlegen sich die Volksparteien?',\n            'upload_date': '20180214',\n            'thumbnail': r're:^https?://.*\\.jpg$',\n        },\n    }, {\n        'url': 'http://www.daserste.de/information/reportage-dokumentation/dokus/videos/die-story-im-ersten-mission-unter-falscher-flagge-100.html',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        display_id = mobj.group('display_id')\n\n        player_url = mobj.group('mainurl') + '~playerXml.xml'\n        doc = self._download_xml(player_url, display_id)\n        video_node = doc.find('./video')\n        upload_date = unified_strdate(xpath_text(\n            video_node, './broadcastDate'))\n        thumbnail = xpath_text(video_node, './/teaserImage//variant/url')\n\n        formats = []\n        for a in video_node.findall('.//asset'):\n            f = {\n                'format_id': a.attrib['type'],\n                'width': int_or_none(a.find('./frameWidth').text),\n                'height': int_or_none(a.find('./frameHeight').text),\n                'vbr': int_or_none(a.find('./bitrateVideo').text),\n                'abr': int_or_none(a.find('./bitrateAudio').text),\n                'vcodec': a.find('./codecVideo').text,\n                'tbr': int_or_none(a.find('./totalBitrate').text),\n            }\n            if a.find('./serverPrefix').text:\n                f['url'] = a.find('./serverPrefix').text\n                f['playpath'] = a.find('./fileName').text\n            else:\n                f['url'] = a.find('./fileName').text\n            formats.append(f)\n        self._sort_formats(formats)\n\n        return {\n            'id': mobj.group('id'),\n            'formats': formats,\n            'display_id': display_id,\n            'title': video_node.find('./title').text,\n            'duration': parse_duration(video_node.find('./duration').text),\n            'upload_date': upload_date,\n            'thumbnail': thumbnail,\n        }\n", "comments": "(?x)\n            mediaCollection\\.addMediaStream\\([0-9]+,\\s*[0-9]+,\\s*\"[^\"]*\",\\s*\n            \"([^\"]+)\"\n\"\n# coding: utf-8\n# available till 26.07.2022\n# m3u8 download\n# audio\n# audio\n# determine video id from url\n# Thumbnail is sometimes not present.\n# It is in the mobile version, but that seems to use a different URL\n# structure altogether.\n# request JSON file\n#]+/videos/(?P<display_id>[^/?#]+)-(?P<id>[0-9]+))\\.html'\n# available till 14.02.2019\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport re\n\nfrom .common import InfoExtractor\nfrom .generic import GenericIE\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    ExtractorError,\n    qualities,\n    int_or_none,\n    parse_duration,\n    unified_strdate,\n    xpath_text,\n    update_url_query,\n)\nfrom ..compat import compat_etree_fromstring\n\n\nclass ARDMediathekIE(InfoExtractor):\n    IE_NAME = 'ARD:mediathek'\n    _VALID_URL = r'^https?://(?:(?:www\\.)?ardmediathek\\.de|mediathek\\.(?:daserste|rbb-online)\\.de)/(?:.*/)(?P<video_id>[0-9]+|[^0-9][^/\\?]+)[^/\\?]*(?:\\?.*)?'\n\n    _TESTS = [{\n        # available till 26.07.2022\n        'url': 'http://www.ardmediathek.de/tv/S%C3%9CDLICHT/Was-ist-die-Kunst-der-Zukunft-liebe-Ann/BR-Fernsehen/Video?bcastId=34633636&documentId=44726822',\n        'info_dict': {\n            'id': '44726822',\n            'ext': 'mp4',\n            'title': 'Was ist die Kunst der Zukunft, liebe Anna McCarthy?',\n            'description': 'md5:4ada28b3e3b5df01647310e41f3a62f5',\n            'duration': 1740,\n        },\n        'params': {\n            # m3u8 download\n            'skip_download': True,\n        }\n    }, {\n        # audio\n        'url': 'http://www.ardmediathek.de/tv/WDR-H%C3%B6rspiel-Speicher/Tod-eines-Fu%C3%9Fballers/WDR-3/Audio-Podcast?documentId=28488308&bcastId=23074086',\n        'only_matching': True,\n    }, {\n        'url': 'http://mediathek.daserste.de/sendungen_a-z/328454_anne-will/22429276_vertrauen-ist-gut-spionieren-ist-besser-geht',\n        'only_matching': True,\n    }, {\n        # audio\n        'url': 'http://mediathek.rbb-online.de/radio/H\u00f6rspiel/Vor-dem-Fest/kulturradio/Audio?documentId=30796318&topRessort=radio&bcastId=9839158',\n        'only_matching': True,\n    }]\n\n    def _extract_media_info(self, media_info_url, webpage, video_id):\n        media_info = self._download_json(\n            media_info_url, video_id, 'Downloading media JSON')\n\n        formats = self._extract_formats(media_info, video_id)\n\n        if not formats:\n            if '\"fsk\"' in webpage:\n                raise ExtractorError(\n                    'This video is only available after 20:00', expected=True)\n            elif media_info.get('_geoblocked'):\n                raise ExtractorError('This video is not available due to geo restriction', expected=True)\n\n        self._sort_formats(formats)\n\n        duration = int_or_none(media_info.get('_duration'))\n        thumbnail = media_info.get('_previewImage')\n        is_live = media_info.get('_isLive') is True\n\n        subtitles = {}\n        subtitle_url = media_info.get('_subtitleUrl')\n        if subtitle_url:\n            subtitles['de'] = [{\n                'ext': 'ttml',\n                'url': subtitle_url,\n            }]\n\n        return {\n            'id': video_id,\n            'duration': duration,\n            'thumbnail': thumbnail,\n            'is_live': is_live,\n            'formats': formats,\n            'subtitles': subtitles,\n        }\n\n    def _extract_formats(self, media_info, video_id):\n        type_ = media_info.get('_type')\n        media_array = media_info.get('_mediaArray', [])\n        formats = []\n        for num, media in enumerate(media_array):\n            for stream in media.get('_mediaStreamArray', []):\n                stream_urls = stream.get('_stream')\n                if not stream_urls:\n                    continue\n                if not isinstance(stream_urls, list):\n                    stream_urls = [stream_urls]\n                quality = stream.get('_quality')\n                server = stream.get('_server')\n                for stream_url in stream_urls:\n                    if not isinstance(stream_url, compat_str) or '//' not in stream_url:\n                        continue\n                    ext = determine_ext(stream_url)\n                    if quality != 'auto' and ext in ('f4m', 'm3u8'):\n                        continue\n                    if ext == 'f4m':\n                        formats.extend(self._extract_f4m_formats(\n                            update_url_query(stream_url, {\n                                'hdcore': '3.1.1',\n                                'plugin': 'aasp-3.1.1.69.124'\n                            }),\n                            video_id, f4m_id='hds', fatal=False))\n                    elif ext == 'm3u8':\n                        formats.extend(self._extract_m3u8_formats(\n                            stream_url, video_id, 'mp4', m3u8_id='hls', fatal=False))\n                    else:\n                        if server and server.startswith('rtmp'):\n                            f = {\n                                'url': server,\n                                'play_path': stream_url,\n                                'format_id': 'a%s-rtmp-%s' % (num, quality),\n                            }\n                        else:\n                            f = {\n                                'url': stream_url,\n                                'format_id': 'a%s-%s-%s' % (num, ext, quality)\n                            }\n                        m = re.search(r'_(?P<width>\\d+)x(?P<height>\\d+)\\.mp4$', stream_url)\n                        if m:\n                            f.update({\n                                'width': int(m.group('width')),\n                                'height': int(m.group('height')),\n                            })\n                        if type_ == 'audio':\n                            f['vcodec'] = 'none'\n                        formats.append(f)\n        return formats\n\n    def _real_extract(self, url):\n        # determine video id from url\n        m = re.match(self._VALID_URL, url)\n\n        document_id = None\n\n        numid = re.search(r'documentId=([0-9]+)', url)\n        if numid:\n            document_id = video_id = numid.group(1)\n        else:\n            video_id = m.group('video_id')\n\n        webpage = self._download_webpage(url, video_id)\n\n        ERRORS = (\n            ('>Leider liegt eine St\u00f6rung vor.', 'Video %s is unavailable'),\n            ('>Der gew\u00fcnschte Beitrag ist nicht mehr verf\u00fcgbar.<',\n             'Video %s is no longer available'),\n        )\n\n        for pattern, message in ERRORS:\n            if pattern in webpage:\n                raise ExtractorError(message % video_id, expected=True)\n\n        if re.search(r'[\\?&]rss($|[=&])', url):\n            doc = compat_etree_fromstring(webpage.encode('utf-8'))\n            if doc.tag == 'rss':\n                return GenericIE()._extract_rss(url, video_id, doc)\n\n        title = self._html_search_regex(\n            [r'<h1(?:\\s+class=\"boxTopHeadline\")?>(.*?)</h1>',\n             r'<meta name=\"dcterms\\.title\" content=\"(.*?)\"/>',\n             r'<h4 class=\"headline\">(.*?)</h4>'],\n            webpage, 'title')\n        description = self._html_search_meta(\n            'dcterms.abstract', webpage, 'description', default=None)\n        if description is None:\n            description = self._html_search_meta(\n                'description', webpage, 'meta description')\n\n        # Thumbnail is sometimes not present.\n        # It is in the mobile version, but that seems to use a different URL\n        # structure altogether.\n        thumbnail = self._og_search_thumbnail(webpage, default=None)\n\n        media_streams = re.findall(r'''(?x)\n            mediaCollection\\.addMediaStream\\([0-9]+,\\s*[0-9]+,\\s*\"[^\"]*\",\\s*\n            \"([^\"]+)\"''', webpage)\n\n        if media_streams:\n            QUALITIES = qualities(['lo', 'hi', 'hq'])\n            formats = []\n            for furl in set(media_streams):\n                if furl.endswith('.f4m'):\n                    fid = 'f4m'\n                else:\n                    fid_m = re.match(r'.*\\.([^.]+)\\.[^.]+$', furl)\n                    fid = fid_m.group(1) if fid_m else None\n                formats.append({\n                    'quality': QUALITIES(fid),\n                    'format_id': fid,\n                    'url': furl,\n                })\n            self._sort_formats(formats)\n            info = {\n                'formats': formats,\n            }\n        else:  # request JSON file\n            if not document_id:\n                video_id = self._search_regex(\n                    r'/play/(?:config|media)/(\\d+)', webpage, 'media id')\n            info = self._extract_media_info(\n                'http://www.ardmediathek.de/play/media/%s' % video_id,\n                webpage, video_id)\n\n        info.update({\n            'id': video_id,\n            'title': self._live_title(title) if info.get('is_live') else title,\n            'description': description,\n            'thumbnail': thumbnail,\n        })\n\n        return info\n\n\nclass ARDIE(InfoExtractor):\n    _VALID_URL = r'(?P<mainurl>https?://(www\\.)?daserste\\.de/[^?#]+/videos/(?P<display_id>[^/?#]+)-(?P<id>[0-9]+))\\.html'\n    _TESTS = [{\n        # available till 14.02.2019\n        'url': 'http://www.daserste.de/information/talk/maischberger/videos/das-groko-drama-zerlegen-sich-die-volksparteien-video-102.html',\n        'md5': '8e4ec85f31be7c7fc08a26cdbc5a1f49',\n        'info_dict': {\n            'display_id': 'das-groko-drama-zerlegen-sich-die-volksparteien-video',\n            'id': '102',\n            'ext': 'mp4',\n            'duration': 4435.0,\n            'title': 'Das GroKo-Drama: Zerlegen sich die Volksparteien?',\n            'upload_date': '20180214',\n            'thumbnail': r're:^https?://.*\\.jpg$',\n        },\n    }, {\n        'url': 'http://www.daserste.de/information/reportage-dokumentation/dokus/videos/die-story-im-ersten-mission-unter-falscher-flagge-100.html',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        display_id = mobj.group('display_id')\n\n        player_url = mobj.group('mainurl') + '~playerXml.xml'\n        doc = self._download_xml(player_url, display_id)\n        video_node = doc.find('./video')\n        upload_date = unified_strdate(xpath_text(\n            video_node, './broadcastDate'))\n        thumbnail = xpath_text(video_node, './/teaserImage//variant/url')\n\n        formats = []\n        for a in video_node.findall('.//asset'):\n            f = {\n                'format_id': a.attrib['type'],\n                'width': int_or_none(a.find('./frameWidth').text),\n                'height': int_or_none(a.find('./frameHeight').text),\n                'vbr': int_or_none(a.find('./bitrateVideo').text),\n                'abr': int_or_none(a.find('./bitrateAudio').text),\n                'vcodec': a.find('./codecVideo').text,\n                'tbr': int_or_none(a.find('./totalBitrate').text),\n            }\n            if a.find('./serverPrefix').text:\n                f['url'] = a.find('./serverPrefix').text\n                f['playpath'] = a.find('./fileName').text\n            else:\n                f['url'] = a.find('./fileName').text\n            formats.append(f)\n        self._sort_formats(formats)\n\n        return {\n            'id': mobj.group('id'),\n            'formats': formats,\n            'display_id': display_id,\n            'title': video_node.find('./title').text,\n            'duration': parse_duration(video_node.find('./duration').text),\n            'upload_date': upload_date,\n            'thumbnail': thumbnail,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "ard.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/ard.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}