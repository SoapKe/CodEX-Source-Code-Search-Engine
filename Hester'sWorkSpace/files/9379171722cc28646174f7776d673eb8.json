{"author": "sympy", "code": "from sympy import Add, Basic, symbols, Symbol\nfrom sympy.unify.core import Compound, Variable\nfrom sympy.unify.usympy import (deconstruct, construct, unify, is_associative,\n        is_commutative)\nfrom sympy.abc import x, y, z, n\nfrom sympy.utilities.pytest import XFAIL\n\ndef test_deconstruct():\n    expr     = Basic(1, 2, 3)\n    expected = Compound(Basic, (1, 2, 3))\n    assert deconstruct(expr) == expected\n\n    assert deconstruct(1) == 1\n    assert deconstruct(x) == x\n    assert deconstruct(x, variables=(x,)) == Variable(x)\n    assert deconstruct(Add(1, x, evaluate=False)) == Compound(Add, (1, x))\n    assert deconstruct(Add(1, x, evaluate=False), variables=(x,)) == \\\n              Compound(Add, (1, Variable(x)))\n\ndef test_construct():\n    expr     = Compound(Basic, (1, 2, 3))\n    expected = Basic(1, 2, 3)\n    assert construct(expr) == expected\n\ndef test_nested():\n    expr = Basic(1, Basic(2), 3)\n    cmpd = Compound(Basic, (1, Compound(Basic, (2,)), 3))\n    assert deconstruct(expr) == cmpd\n    assert construct(cmpd) == expr\n\ndef test_unify():\n    expr = Basic(1, 2, 3)\n    a, b, c = map(Symbol, 'abc')\n    pattern = Basic(a, b, c)\n    assert list(unify(expr, pattern, {}, (a, b, c))) == [{a: 1, b: 2, c: 3}]\n    assert list(unify(expr, pattern, variables=(a, b, c))) == \\\n            [{a: 1, b: 2, c: 3}]\n\ndef test_unify_variables():\n    assert list(unify(Basic(1, 2), Basic(1, x), {}, variables=(x,))) == [{x: 2}]\n\ndef test_s_input():\n    expr = Basic(1, 2)\n    a, b = map(Symbol, 'ab')\n    pattern = Basic(a, b)\n    assert list(unify(expr, pattern, {}, (a, b))) == [{a: 1, b: 2}]\n    assert list(unify(expr, pattern, {a: 5}, (a, b))) == []\n\ndef iterdicteq(a, b):\n    a = tuple(a)\n    b = tuple(b)\n    return len(a) == len(b) and all(x in b for x in a)\n\ndef test_unify_commutative():\n    expr = Add(1, 2, 3, evaluate=False)\n    a, b, c = map(Symbol, 'abc')\n    pattern = Add(a, b, c, evaluate=False)\n\n    result  = tuple(unify(expr, pattern, {}, (a, b, c)))\n    expected = ({a: 1, b: 2, c: 3},\n                {a: 1, b: 3, c: 2},\n                {a: 2, b: 1, c: 3},\n                {a: 2, b: 3, c: 1},\n                {a: 3, b: 1, c: 2},\n                {a: 3, b: 2, c: 1})\n\n    assert iterdicteq(result, expected)\n\ndef test_unify_iter():\n    expr = Add(1, 2, 3, evaluate=False)\n    a, b, c = map(Symbol, 'abc')\n    pattern = Add(a, c, evaluate=False)\n    assert is_associative(deconstruct(pattern))\n    assert is_commutative(deconstruct(pattern))\n\n    result   = list(unify(expr, pattern, {}, (a, c)))\n    expected = [{a: 1, c: Add(2, 3, evaluate=False)},\n                {a: 1, c: Add(3, 2, evaluate=False)},\n                {a: 2, c: Add(1, 3, evaluate=False)},\n                {a: 2, c: Add(3, 1, evaluate=False)},\n                {a: 3, c: Add(1, 2, evaluate=False)},\n                {a: 3, c: Add(2, 1, evaluate=False)},\n                {a: Add(1, 2, evaluate=False), c: 3},\n                {a: Add(2, 1, evaluate=False), c: 3},\n                {a: Add(1, 3, evaluate=False), c: 2},\n                {a: Add(3, 1, evaluate=False), c: 2},\n                {a: Add(2, 3, evaluate=False), c: 1},\n                {a: Add(3, 2, evaluate=False), c: 1}]\n\n    assert iterdicteq(result, expected)\n\ndef test_hard_match():\n    from sympy import sin, cos\n    expr = sin(x) + cos(x)**2\n    p, q = map(Symbol, 'pq')\n    pattern = sin(p) + cos(p)**2\n    assert list(unify(expr, pattern, {}, (p, q))) == [{p: x}]\n\ndef test_matrix():\n    from sympy import MatrixSymbol\n    X = MatrixSymbol('X', n, n)\n    Y = MatrixSymbol('Y', 2, 2)\n    Z = MatrixSymbol('Z', 2, 3)\n    assert list(unify(X, Y, {}, variables=[n, 'X'])) == [{'X': 'Y', n: 2}]\n    assert list(unify(X, Z, {}, variables=[n, 'X'])) == []\n\ndef test_non_frankenAdds():\n    \n    \n    expr = x+y*2\n    rebuilt = construct(deconstruct(expr))\n    \n    str(rebuilt)\n    rebuilt.is_commutative\n\ndef test_FiniteSet_commutivity():\n    from sympy import FiniteSet\n    a, b, c, x, y = symbols('a,b,c,x,y')\n    s = FiniteSet(a, b, c)\n    t = FiniteSet(x, y)\n    variables = (x, y)\n    assert {x: FiniteSet(a, c), y: b} in tuple(unify(s, t, variables=variables))\n\ndef test_FiniteSet_complex():\n    from sympy import FiniteSet\n    a, b, c, x, y, z = symbols('a,b,c,x,y,z')\n    expr = FiniteSet(Basic(1, x), y, Basic(x, z))\n    pattern = FiniteSet(a, Basic(x, b))\n    variables = a, b\n    expected = tuple([{b: 1, a: FiniteSet(y, Basic(x, z))},\n                      {b: z, a: FiniteSet(y, Basic(1, x))}])\n    assert iterdicteq(unify(expr, pattern, variables=variables), expected)\n\n@XFAIL\ndef test_and():\n    variables = x, y\n    str(list(unify((x>0) & (z<3), pattern, variables=variables)))\n\ndef test_Union():\n    from sympy import Interval\n    assert list(unify(Interval(0, 1) + Interval(10, 11),\n                      Interval(0, 1) + Interval(12, 13),\n                      variables=(Interval(12, 13),)))\n\ndef test_is_commutative():\n    assert is_commutative(deconstruct(x+y))\n    assert is_commutative(deconstruct(x*y))\n    assert not is_commutative(deconstruct(x**y))\n\ndef test_commutative_in_commutative():\n    from sympy.abc import a,b,c,d\n    from sympy import sin, cos\n    eq = sin(3)*sin(4)*sin(5) + 4*cos(3)*cos(4)\n    pat = a*cos(b)*cos(c) + d*sin(b)*sin(c)\n    assert next(unify(eq, pat, variables=(a,b,c,d)))\n", "comments": "  commutative property used fail basic   new      this caused commutative str calls fail    ensure run commands without causing error ", "content": "from sympy import Add, Basic, symbols, Symbol\nfrom sympy.unify.core import Compound, Variable\nfrom sympy.unify.usympy import (deconstruct, construct, unify, is_associative,\n        is_commutative)\nfrom sympy.abc import x, y, z, n\nfrom sympy.utilities.pytest import XFAIL\n\ndef test_deconstruct():\n    expr     = Basic(1, 2, 3)\n    expected = Compound(Basic, (1, 2, 3))\n    assert deconstruct(expr) == expected\n\n    assert deconstruct(1) == 1\n    assert deconstruct(x) == x\n    assert deconstruct(x, variables=(x,)) == Variable(x)\n    assert deconstruct(Add(1, x, evaluate=False)) == Compound(Add, (1, x))\n    assert deconstruct(Add(1, x, evaluate=False), variables=(x,)) == \\\n              Compound(Add, (1, Variable(x)))\n\ndef test_construct():\n    expr     = Compound(Basic, (1, 2, 3))\n    expected = Basic(1, 2, 3)\n    assert construct(expr) == expected\n\ndef test_nested():\n    expr = Basic(1, Basic(2), 3)\n    cmpd = Compound(Basic, (1, Compound(Basic, (2,)), 3))\n    assert deconstruct(expr) == cmpd\n    assert construct(cmpd) == expr\n\ndef test_unify():\n    expr = Basic(1, 2, 3)\n    a, b, c = map(Symbol, 'abc')\n    pattern = Basic(a, b, c)\n    assert list(unify(expr, pattern, {}, (a, b, c))) == [{a: 1, b: 2, c: 3}]\n    assert list(unify(expr, pattern, variables=(a, b, c))) == \\\n            [{a: 1, b: 2, c: 3}]\n\ndef test_unify_variables():\n    assert list(unify(Basic(1, 2), Basic(1, x), {}, variables=(x,))) == [{x: 2}]\n\ndef test_s_input():\n    expr = Basic(1, 2)\n    a, b = map(Symbol, 'ab')\n    pattern = Basic(a, b)\n    assert list(unify(expr, pattern, {}, (a, b))) == [{a: 1, b: 2}]\n    assert list(unify(expr, pattern, {a: 5}, (a, b))) == []\n\ndef iterdicteq(a, b):\n    a = tuple(a)\n    b = tuple(b)\n    return len(a) == len(b) and all(x in b for x in a)\n\ndef test_unify_commutative():\n    expr = Add(1, 2, 3, evaluate=False)\n    a, b, c = map(Symbol, 'abc')\n    pattern = Add(a, b, c, evaluate=False)\n\n    result  = tuple(unify(expr, pattern, {}, (a, b, c)))\n    expected = ({a: 1, b: 2, c: 3},\n                {a: 1, b: 3, c: 2},\n                {a: 2, b: 1, c: 3},\n                {a: 2, b: 3, c: 1},\n                {a: 3, b: 1, c: 2},\n                {a: 3, b: 2, c: 1})\n\n    assert iterdicteq(result, expected)\n\ndef test_unify_iter():\n    expr = Add(1, 2, 3, evaluate=False)\n    a, b, c = map(Symbol, 'abc')\n    pattern = Add(a, c, evaluate=False)\n    assert is_associative(deconstruct(pattern))\n    assert is_commutative(deconstruct(pattern))\n\n    result   = list(unify(expr, pattern, {}, (a, c)))\n    expected = [{a: 1, c: Add(2, 3, evaluate=False)},\n                {a: 1, c: Add(3, 2, evaluate=False)},\n                {a: 2, c: Add(1, 3, evaluate=False)},\n                {a: 2, c: Add(3, 1, evaluate=False)},\n                {a: 3, c: Add(1, 2, evaluate=False)},\n                {a: 3, c: Add(2, 1, evaluate=False)},\n                {a: Add(1, 2, evaluate=False), c: 3},\n                {a: Add(2, 1, evaluate=False), c: 3},\n                {a: Add(1, 3, evaluate=False), c: 2},\n                {a: Add(3, 1, evaluate=False), c: 2},\n                {a: Add(2, 3, evaluate=False), c: 1},\n                {a: Add(3, 2, evaluate=False), c: 1}]\n\n    assert iterdicteq(result, expected)\n\ndef test_hard_match():\n    from sympy import sin, cos\n    expr = sin(x) + cos(x)**2\n    p, q = map(Symbol, 'pq')\n    pattern = sin(p) + cos(p)**2\n    assert list(unify(expr, pattern, {}, (p, q))) == [{p: x}]\n\ndef test_matrix():\n    from sympy import MatrixSymbol\n    X = MatrixSymbol('X', n, n)\n    Y = MatrixSymbol('Y', 2, 2)\n    Z = MatrixSymbol('Z', 2, 3)\n    assert list(unify(X, Y, {}, variables=[n, 'X'])) == [{'X': 'Y', n: 2}]\n    assert list(unify(X, Z, {}, variables=[n, 'X'])) == []\n\ndef test_non_frankenAdds():\n    # the is_commutative property used to fail because of Basic.__new__\n    # This caused is_commutative and str calls to fail\n    expr = x+y*2\n    rebuilt = construct(deconstruct(expr))\n    # Ensure that we can run these commands without causing an error\n    str(rebuilt)\n    rebuilt.is_commutative\n\ndef test_FiniteSet_commutivity():\n    from sympy import FiniteSet\n    a, b, c, x, y = symbols('a,b,c,x,y')\n    s = FiniteSet(a, b, c)\n    t = FiniteSet(x, y)\n    variables = (x, y)\n    assert {x: FiniteSet(a, c), y: b} in tuple(unify(s, t, variables=variables))\n\ndef test_FiniteSet_complex():\n    from sympy import FiniteSet\n    a, b, c, x, y, z = symbols('a,b,c,x,y,z')\n    expr = FiniteSet(Basic(1, x), y, Basic(x, z))\n    pattern = FiniteSet(a, Basic(x, b))\n    variables = a, b\n    expected = tuple([{b: 1, a: FiniteSet(y, Basic(x, z))},\n                      {b: z, a: FiniteSet(y, Basic(1, x))}])\n    assert iterdicteq(unify(expr, pattern, variables=variables), expected)\n\n@XFAIL\ndef test_and():\n    variables = x, y\n    str(list(unify((x>0) & (z<3), pattern, variables=variables)))\n\ndef test_Union():\n    from sympy import Interval\n    assert list(unify(Interval(0, 1) + Interval(10, 11),\n                      Interval(0, 1) + Interval(12, 13),\n                      variables=(Interval(12, 13),)))\n\ndef test_is_commutative():\n    assert is_commutative(deconstruct(x+y))\n    assert is_commutative(deconstruct(x*y))\n    assert not is_commutative(deconstruct(x**y))\n\ndef test_commutative_in_commutative():\n    from sympy.abc import a,b,c,d\n    from sympy import sin, cos\n    eq = sin(3)*sin(4)*sin(5) + 4*cos(3)*cos(4)\n    pat = a*cos(b)*cos(c) + d*sin(b)*sin(c)\n    assert next(unify(eq, pat, variables=(a,b,c,d)))\n", "description": "A computer algebra system written in pure Python", "file_name": "test_sympy.py", "id": "9379171722cc28646174f7776d673eb8", "language": "Python", "project_name": "sympy", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/sympy-sympy/sympy-sympy-205da79/sympy/unify/tests/test_sympy.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:35:56Z", "url": "https://github.com/sympy/sympy", "wiki": true}