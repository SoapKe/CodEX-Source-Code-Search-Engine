{"author": "ansible", "code": "\n\n Copyright: Ansible Team\n GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = \"\"\"\n---\nmodule: aruba_command\nversion_added: \"2.4\"\nauthor: \"James Mighion (@jmighion)\"\nshort_description: Run commands on remote devices running Aruba Mobility Controller\ndescription:\n  - Sends arbitrary commands to an aruba node and returns the results\n    read from the device. This module includes an\n    argument that will cause the module to wait for a specific condition\n    before returning or timing out if the condition is not met.\n  - This module does not support running commands in configuration mode.\n    Please use M(aruba_config) to configure Aruba devices.\nextends_documentation_fragment: aruba\noptions:\n  commands:\n    description:\n      - List of commands to send to the remote aruba device over the\n        configured provider. The resulting output from the command\n        is returned. If the I(wait_for) argument is provided, the\n        module is not returned until the condition is satisfied or\n        the number of retries has expired.\n    required: true\n  wait_for:\n    description:\n      - List of conditions to evaluate against the output of the\n        command. The task will wait for each condition to be true\n        before moving forward. If the conditional is not true\n        within the configured number of retries, the task fails.\n        See examples.\n    aliases: ['waitfor']\n  match:\n    description:\n      - The I(match) argument is used in conjunction with the\n        I(wait_for) argument to specify the match policy.  Valid\n        values are C(all) or C(any).  If the value is set to C(all)\n        then all conditionals in the wait_for must be satisfied.  If\n        the value is set to C(any) then only one of the values must be\n        satisfied.\n    default: all\n    choices: ['any', 'all']\n  retries:\n    description:\n      - Specifies the number of retries a command should by tried\n        before it is considered failed. The command is run on the\n        target device every retry and evaluated against the\n        I(wait_for) conditions.\n    default: 10\n  interval:\n    description:\n      - Configures the interval in seconds to wait between retries\n        of the command. If the command does not pass the specified\n        conditions, the interval indicates how long to wait before\n        trying the command again.\n    default: 1\n\"\"\"\n\nEXAMPLES = \"\"\"\ntasks:\n  - name: run show version on remote devices\n    aruba_command:\n      commands: show version\n\n  - name: run show version and check to see if output contains Aruba\n    aruba_command:\n      commands: show version\n      wait_for: result[0] contains Aruba\n\n  - name: run multiple commands on remote nodes\n    aruba_command:\n      commands:\n        - show version\n        - show interfaces\n\n  - name: run multiple commands and evaluate the output\n    aruba_command:\n      commands:\n        - show version\n        - show interfaces\n      wait_for:\n        - result[0] contains Aruba\n        - result[1] contains Loopback0\n\"\"\"\n\nRETURN = \"\"\"\nstdout:\n  description: The set of responses from the commands\n  returned: always\n  type: list\n  sample: ['...', '...']\nstdout_lines:\n  description: The value of stdout split into a list\n  returned: always\n  type: list\n  sample: [['...', '...'], ['...'], ['...']]\nfailed_conditions:\n  description: The list of conditionals that have failed\n  returned: failed\n  type: list\n  sample: ['...', '...']\n\"\"\"\nimport time\n\nfrom ansible.module_utils.network.aruba.aruba import run_commands\nfrom ansible.module_utils.network.aruba.aruba import aruba_argument_spec, check_args\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.network.common.utils import ComplexList\nfrom ansible.module_utils.network.common.parsing import Conditional\nfrom ansible.module_utils.six import string_types\n\n\ndef to_lines(stdout):\n    for item in stdout:\n        if isinstance(item, string_types):\n            item = str(item).split('\\n')\n        yield item\n\n\ndef parse_commands(module, warnings):\n    command = ComplexList(dict(\n        command=dict(key=True),\n        prompt=dict(),\n        answer=dict()\n    ), module)\n    commands = command(module.params['commands'])\n    for index, item in enumerate(commands):\n        if module.check_mode and not item['command'].startswith('show'):\n            warnings.append(\n                'only show commands are supported when using check mode, not '\n                'executing `%s`' % item['command']\n            )\n        elif item['command'].startswith('conf'):\n            module.fail_json(\n                msg='aruba_command does not support running config mode '\n                    'commands.  Please use aruba_config instead'\n            )\n    return commands\n\n\ndef main():\n    \"\"\"main entry point for module execution\n    \"\"\"\n    argument_spec = dict(\n        commands=dict(type='list', required=True),\n\n        wait_for=dict(type='list', aliases=['waitfor']),\n        match=dict(default='all', choices=['all', 'any']),\n\n        retries=dict(default=10, type='int'),\n        interval=dict(default=1, type='int')\n    )\n\n    argument_spec.update(aruba_argument_spec)\n\n    module = AnsibleModule(argument_spec=argument_spec,\n                           supports_check_mode=True)\n\n    result = {'changed': False}\n\n    warnings = list()\n    check_args(module, warnings)\n    commands = parse_commands(module, warnings)\n    result['warnings'] = warnings\n\n    wait_for = module.params['wait_for'] or list()\n    conditionals = [Conditional(c) for c in wait_for]\n\n    retries = module.params['retries']\n    interval = module.params['interval']\n    match = module.params['match']\n\n    while retries > 0:\n        responses = run_commands(module, commands)\n\n        for item in list(conditionals):\n            if item(responses):\n                if match == 'any':\n                    conditionals = list()\n                    break\n                conditionals.remove(item)\n\n        if not conditionals:\n            break\n\n        time.sleep(interval)\n        retries -= 1\n\n    if conditionals:\n        failed_conditions = [item.raw for item in conditionals]\n        msg = 'One or more conditional statements have not been satisfied'\n        module.fail_json(msg=msg, failed_conditions=failed_conditions)\n\n    result.update({\n        'changed': False,\n        'stdout': responses,\n        'stdout_lines': list(to_lines(responses))\n    })\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "comments": "        module  aruba command version added   2 4  author   james mighion ( jmighion)  short description  run commands remote devices running aruba mobility controller description      sends arbitrary commands aruba node returns results     read device  this module includes     argument cause module wait specific condition     returning timing condition met      this module support running commands configuration mode      please use m(aruba config) configure aruba devices  extends documentation fragment  aruba options    commands      description          list commands send remote aruba device         configured provider  the resulting output command         returned  if i(wait for) argument provided          module returned condition satisfied         number retries expired      required  true   wait      description          list conditions evaluate output         command  the task wait condition true         moving forward  if conditional true         within configured number retries  task fails          see examples      aliases    waitfor     match      description          the i(match) argument used conjunction         i(wait for) argument specify match policy   valid         values c(all) c(any)   if value set c(all)         conditionals wait must satisfied   if         value set c(any) one values must         satisfied      default      choices           retries      description          specifies number retries command tried         considered failed  the command run         target device every retry evaluated         i(wait for) conditions      default  10   interval      description          configures interval seconds wait retries         command  if command pass specified         conditions  interval indicates long wait         trying command      default  1      examples       tasks      name  run show version remote devices     aruba command        commands  show version      name  run show version check see output contains aruba     aruba command        commands  show version       wait  result 0  contains aruba      name  run multiple commands remote nodes     aruba command        commands            show version           show interfaces      name  run multiple commands evaluate output     aruba command        commands            show version           show interfaces       wait            result 0  contains aruba           result 1  contains loopback0      return       stdout    description  the set responses commands   returned  always   type  list   sample                 stdout lines    description  the value stdout split list   returned  always   type  list   sample                                     failed conditions    description  the list conditionals failed   returned  failed   type  list   sample                     import time  ansible module utils network aruba aruba import run commands ansible module utils network aruba aruba import aruba argument spec  check args ansible module utils basic import ansiblemodule ansible module utils network common utils import complexlist ansible module utils network common parsing import conditional ansible module utils six import string types   def lines(stdout)      item stdout          isinstance(item  string types)              item   str(item) split(  n )         yield item   def parse commands(module  warnings)      command   complexlist(dict(         command dict(key true)          prompt dict()          answer dict()     )  module)     commands   command(module params  commands  )     index  item enumerate(commands)          module check mode item  command   startswith( show )              warnings append(                  show commands supported using check mode                     executing       item  command               )         elif item  command   startswith( conf )              module fail json(                 msg  aruba command support running config mode                        commands   please use aruba config instead              )     return commands   def main()         main entry point module execution             usr bin python       copyright  ansible team    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt) ", "content": "#!/usr/bin/python\n#\n# Copyright: Ansible Team\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import absolute_import, division, print_function\n__metaclass__ = type\n\n\nANSIBLE_METADATA = {'metadata_version': '1.1',\n                    'status': ['preview'],\n                    'supported_by': 'community'}\n\nDOCUMENTATION = \"\"\"\n---\nmodule: aruba_command\nversion_added: \"2.4\"\nauthor: \"James Mighion (@jmighion)\"\nshort_description: Run commands on remote devices running Aruba Mobility Controller\ndescription:\n  - Sends arbitrary commands to an aruba node and returns the results\n    read from the device. This module includes an\n    argument that will cause the module to wait for a specific condition\n    before returning or timing out if the condition is not met.\n  - This module does not support running commands in configuration mode.\n    Please use M(aruba_config) to configure Aruba devices.\nextends_documentation_fragment: aruba\noptions:\n  commands:\n    description:\n      - List of commands to send to the remote aruba device over the\n        configured provider. The resulting output from the command\n        is returned. If the I(wait_for) argument is provided, the\n        module is not returned until the condition is satisfied or\n        the number of retries has expired.\n    required: true\n  wait_for:\n    description:\n      - List of conditions to evaluate against the output of the\n        command. The task will wait for each condition to be true\n        before moving forward. If the conditional is not true\n        within the configured number of retries, the task fails.\n        See examples.\n    aliases: ['waitfor']\n  match:\n    description:\n      - The I(match) argument is used in conjunction with the\n        I(wait_for) argument to specify the match policy.  Valid\n        values are C(all) or C(any).  If the value is set to C(all)\n        then all conditionals in the wait_for must be satisfied.  If\n        the value is set to C(any) then only one of the values must be\n        satisfied.\n    default: all\n    choices: ['any', 'all']\n  retries:\n    description:\n      - Specifies the number of retries a command should by tried\n        before it is considered failed. The command is run on the\n        target device every retry and evaluated against the\n        I(wait_for) conditions.\n    default: 10\n  interval:\n    description:\n      - Configures the interval in seconds to wait between retries\n        of the command. If the command does not pass the specified\n        conditions, the interval indicates how long to wait before\n        trying the command again.\n    default: 1\n\"\"\"\n\nEXAMPLES = \"\"\"\ntasks:\n  - name: run show version on remote devices\n    aruba_command:\n      commands: show version\n\n  - name: run show version and check to see if output contains Aruba\n    aruba_command:\n      commands: show version\n      wait_for: result[0] contains Aruba\n\n  - name: run multiple commands on remote nodes\n    aruba_command:\n      commands:\n        - show version\n        - show interfaces\n\n  - name: run multiple commands and evaluate the output\n    aruba_command:\n      commands:\n        - show version\n        - show interfaces\n      wait_for:\n        - result[0] contains Aruba\n        - result[1] contains Loopback0\n\"\"\"\n\nRETURN = \"\"\"\nstdout:\n  description: The set of responses from the commands\n  returned: always\n  type: list\n  sample: ['...', '...']\nstdout_lines:\n  description: The value of stdout split into a list\n  returned: always\n  type: list\n  sample: [['...', '...'], ['...'], ['...']]\nfailed_conditions:\n  description: The list of conditionals that have failed\n  returned: failed\n  type: list\n  sample: ['...', '...']\n\"\"\"\nimport time\n\nfrom ansible.module_utils.network.aruba.aruba import run_commands\nfrom ansible.module_utils.network.aruba.aruba import aruba_argument_spec, check_args\nfrom ansible.module_utils.basic import AnsibleModule\nfrom ansible.module_utils.network.common.utils import ComplexList\nfrom ansible.module_utils.network.common.parsing import Conditional\nfrom ansible.module_utils.six import string_types\n\n\ndef to_lines(stdout):\n    for item in stdout:\n        if isinstance(item, string_types):\n            item = str(item).split('\\n')\n        yield item\n\n\ndef parse_commands(module, warnings):\n    command = ComplexList(dict(\n        command=dict(key=True),\n        prompt=dict(),\n        answer=dict()\n    ), module)\n    commands = command(module.params['commands'])\n    for index, item in enumerate(commands):\n        if module.check_mode and not item['command'].startswith('show'):\n            warnings.append(\n                'only show commands are supported when using check mode, not '\n                'executing `%s`' % item['command']\n            )\n        elif item['command'].startswith('conf'):\n            module.fail_json(\n                msg='aruba_command does not support running config mode '\n                    'commands.  Please use aruba_config instead'\n            )\n    return commands\n\n\ndef main():\n    \"\"\"main entry point for module execution\n    \"\"\"\n    argument_spec = dict(\n        commands=dict(type='list', required=True),\n\n        wait_for=dict(type='list', aliases=['waitfor']),\n        match=dict(default='all', choices=['all', 'any']),\n\n        retries=dict(default=10, type='int'),\n        interval=dict(default=1, type='int')\n    )\n\n    argument_spec.update(aruba_argument_spec)\n\n    module = AnsibleModule(argument_spec=argument_spec,\n                           supports_check_mode=True)\n\n    result = {'changed': False}\n\n    warnings = list()\n    check_args(module, warnings)\n    commands = parse_commands(module, warnings)\n    result['warnings'] = warnings\n\n    wait_for = module.params['wait_for'] or list()\n    conditionals = [Conditional(c) for c in wait_for]\n\n    retries = module.params['retries']\n    interval = module.params['interval']\n    match = module.params['match']\n\n    while retries > 0:\n        responses = run_commands(module, commands)\n\n        for item in list(conditionals):\n            if item(responses):\n                if match == 'any':\n                    conditionals = list()\n                    break\n                conditionals.remove(item)\n\n        if not conditionals:\n            break\n\n        time.sleep(interval)\n        retries -= 1\n\n    if conditionals:\n        failed_conditions = [item.raw for item in conditionals]\n        msg = 'One or more conditional statements have not been satisfied'\n        module.fail_json(msg=msg, failed_conditions=failed_conditions)\n\n    result.update({\n        'changed': False,\n        'stdout': responses,\n        'stdout_lines': list(to_lines(responses))\n    })\n\n    module.exit_json(**result)\n\n\nif __name__ == '__main__':\n    main()\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "aruba_command.py", "id": "7fe35084120b30de50041ae21f9f1c1d", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/modules/network/aruba/aruba_command.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}