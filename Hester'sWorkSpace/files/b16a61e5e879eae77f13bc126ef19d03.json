{"author": "jakubroztocil", "code": "\n\n        self._should_stop.set()\n\n    def run(self):\n        while not self._should_stop.is_set():\n            if self.status.has_finished:\n                self.sum_up()\n                break\n\n            self.report_speed()\n            sleep(self._tick)\n\n    def report_speed(self):\n\n        now = time()\n\n        if now - self._prev_time >= self._update_interval:\n            downloaded = self.status.downloaded\n            try:\n                speed = ((downloaded - self._prev_bytes) /\n                         (now - self._prev_time))\n            except ZeroDivisionError:\n                speed = 0\n\n            if not self.status.total_size:\n                self._status_line = PROGRESS_NO_CONTENT_LENGTH.format(\n                    downloaded=humanize_bytes(downloaded),\n                    speed=humanize_bytes(speed),\n                )\n            else:\n                try:\n                    percentage = downloaded / self.status.total_size * 100\n                except ZeroDivisionError:\n                    percentage = 0\n\n                if not speed:\n                    eta = '-:--:--'\n                else:\n                    s = int((self.status.total_size - downloaded) / speed)\n                    h, s = divmod(s, 60 * 60)\n                    m, s = divmod(s, 60)\n                    eta = '{0}:{1:0>2}:{2:0>2}'.format(h, m, s)\n\n                self._status_line = PROGRESS.format(\n                    percentage=percentage,\n                    downloaded=humanize_bytes(downloaded),\n                    speed=humanize_bytes(speed),\n                    eta=eta,\n                )\n\n            self._prev_time = now\n            self._prev_bytes = downloaded\n\n        self.output.write(\n            CLEAR_LINE +\n            ' ' +\n            SPINNER[self._spinner_pos] +\n            ' ' +\n            self._status_line\n        )\n        self.output.flush()\n\n        self._spinner_pos = (self._spinner_pos + 1\n                             if self._spinner_pos + 1 != len(SPINNER)\n                             else 0)\n\n    def sum_up(self):\n        actually_downloaded = (\n            self.status.downloaded - self.status.resumed_from)\n        time_taken = self.status.time_finished - self.status.time_started\n\n        self.output.write(CLEAR_LINE)\n\n        try:\n            speed = actually_downloaded / time_taken\n        except ZeroDivisionError:\n            \n            \n            \n            speed = actually_downloaded\n\n        self.output.write(SUMMARY.format(\n            downloaded=humanize_bytes(actually_downloaded),\n            total=(self.status.total_size and\n                   humanize_bytes(self.status.total_size)),\n            speed=humanize_bytes(speed),\n            time=time_taken,\n        ))\n        self.output.flush()\n", "comments": "\nDownload mode implementation.\n\n\"\"\"\nfrom __future__ import division\nimport os\nimport re\nimport sys\nimport errno\nimport mimetypes\nimport threading\nfrom time import sleep, time\nfrom mailbox import Message\n\nfrom httpie.output.streams import RawStream\nfrom httpie.models import HTTPResponse\nfrom httpie.utils import humanize_bytes\nfrom httpie.compat import urlsplit\n\n\nPARTIAL_CONTENT = 206\n\n\nCLEAR_LINE = '\\r\\033[K'\nPROGRESS = (\n    '{percentage: 6.2f} %'\n    ' {downloaded: >10}'\n    ' {speed: >10}/s'\n    ' {eta: >8} ETA'\n)\nPROGRESS_NO_CONTENT_LENGTH = '{downloaded: >10} {speed: >10}/s'\nSUMMARY = 'Done. {downloaded} in {time:0.5f}s ({speed}/s)\\n'\nSPINNER = '|/-\\\\'\n\n\nclass ContentRangeError(ValueError):\n    pass\n\n\ndef parse_content_range(content_range, resumed_from):\n    \"\"\"\n    Parse and validate Content-Range header.\n\n    <http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html>\n\n    :param content_range: the value of a Content-Range response header\n                          eg. \"bytes 21010-47021/47022\"\n    :param resumed_from: first byte pos. from the Range request header\n    :return: total size of the response body when fully downloaded.\n\n    \"\"\"\n    if content_range is None:\n        raise ContentRangeError('Missing Content-Range')\n\n    pattern = (\n        '^bytes (?P<first_byte_pos>\\d+)-(?P<last_byte_pos>\\d+)'\n        '/(\\*|(?P<instance_length>\\d+))$'\n    )\n    match = re.match(pattern, content_range)\n\n    if not match:\n        raise ContentRangeError(\n            'Invalid Content-Range format %r' % content_range)\n\n    content_range_dict = match.groupdict()\n    first_byte_pos = int(content_range_dict['first_byte_pos'])\n    last_byte_pos = int(content_range_dict['last_byte_pos'])\n    instance_length = (\n        int(content_range_dict['instance_length'])\n        if content_range_dict['instance_length']\n        else None\n    )\n\n    # \"A byte-content-range-spec with a byte-range-resp-spec whose\n    # last- byte-pos value is less than its first-byte-pos value,\n    # or whose instance-length value is less than or equal to its\n    # last-byte-pos value, is invalid. The recipient of an invalid\n    # byte-content-range- spec MUST ignore it and any content\n    # transferred along with it.\"\n    if (first_byte_pos >= last_byte_pos or\n            (instance_length is not None and\n             instance_length <= last_byte_pos)):\n        raise ContentRangeError(\n            'Invalid Content-Range returned: %r' % content_range)\n\n    if (first_byte_pos != resumed_from or\n            (instance_length is not None and\n             last_byte_pos + 1 != instance_length)):\n        # Not what we asked for.\n        raise ContentRangeError(\n            'Unexpected Content-Range returned (%r)'\n            ' for the requested Range (\"bytes=%d-\")'\n            % (content_range, resumed_from)\n        )\n\n    return last_byte_pos + 1\n\n\ndef filename_from_content_disposition(content_disposition):\n    \"\"\"\n    Extract and validate filename from a Content-Disposition header.\n\n    :param content_disposition: Content-Disposition value\n    :return: the filename if present and valid, otherwise `None`\n\n    \"\"\"\n    # attachment; filename=jakubroztocil-httpie-0.4.1-20-g40bd8f6.tar.gz\n\n    msg = Message('Content-Disposition: %s' % content_disposition)\n    filename = msg.get_filename()\n    if filename:\n        # Basic sanitation.\n        filename = os.path.basename(filename).lstrip('.').strip()\n        if filename:\n            return filename\n\n\ndef filename_from_url(url, content_type):\n    fn = urlsplit(url).path.rstrip('/')\n    fn = os.path.basename(fn) if fn else 'index'\n    if '.' not in fn and content_type:\n        content_type = content_type.split(';')[0]\n        if content_type == 'text/plain':\n            # mimetypes returns '.ksh'\n            ext = '.txt'\n        else:\n            ext = mimetypes.guess_extension(content_type)\n\n        if ext == '.htm':  # Python 3\n            ext = '.html'\n\n        if ext:\n            fn += ext\n\n    return fn\n\n\ndef trim_filename(filename, max_len):\n    if len(filename) > max_len:\n        trim_by = len(filename) - max_len\n        name, ext = os.path.splitext(filename)\n        if trim_by >= len(name):\n            filename = filename[:-trim_by]\n        else:\n            filename = name[:-trim_by] + ext\n    return filename\n\n\ndef get_filename_max_length(directory):\n    max_len = 255\n    try:\n        pathconf = os.pathconf\n    except AttributeError:\n        pass  # non-posix\n    else:\n        try:\n            max_len = pathconf(directory, 'PC_NAME_MAX')\n        except OSError as e:\n            if e.errno != errno.EINVAL:\n                raise\n    return max_len\n\n\ndef trim_filename_if_needed(filename, directory='.', extra=0):\n    max_len = get_filename_max_length(directory) - extra\n    if len(filename) > max_len:\n        filename = trim_filename(filename, max_len)\n    return filename\n\n\ndef get_unique_filename(filename, exists=os.path.exists):\n    attempt = 0\n    while True:\n        suffix = '-' + str(attempt) if attempt > 0 else ''\n        try_filename = trim_filename_if_needed(filename, extra=len(suffix))\n        try_filename += suffix\n        if not exists(try_filename):\n            return try_filename\n        attempt += 1\n\n\nclass Downloader(object):\n\n    def __init__(self, output_file=None,\n                 resume=False, progress_file=sys.stderr):\n        \"\"\"\n        :param resume: Should the download resume if partial download\n                       already exists.\n        :type resume: bool\n\n        :param output_file: The file to store response body in. If not\n                            provided, it will be guessed from the response.\n\n        :param progress_file: Where to report download progress.\n\n        \"\"\"\n        self._output_file = output_file\n        self._resume = resume\n        self._resumed_from = 0\n        self.finished = False\n\n        self.status = Status()\n        self._progress_reporter = ProgressReporterThread(\n            status=self.status,\n            output=progress_file\n        )\n\n    def pre_request(self, request_headers):\n        \"\"\"Called just before the HTTP request is sent.\n\n        Might alter `request_headers`.\n\n        :type request_headers: dict\n\n        \"\"\"\n        # Ask the server not to encode the content so that we can resume, etc.\n        request_headers['Accept-Encoding'] = 'identity'\n        if self._resume:\n            bytes_have = os.path.getsize(self._output_file.name)\n            if bytes_have:\n                # Set ``Range`` header to resume the download\n                # TODO: Use \"If-Range: mtime\" to make sure it's fresh?\n                request_headers['Range'] = 'bytes=%d-' % bytes_have\n                self._resumed_from = bytes_have\n\n    def start(self, response):\n        \"\"\"\n        Initiate and return a stream for `response` body  with progress\n        callback attached. Can be called only once.\n\n        :param response: Initiated response object with headers already fetched\n        :type response: requests.models.Response\n\n        :return: RawStream, output_file\n\n        \"\"\"\n        assert not self.status.time_started\n\n        # FIXME: some servers still might sent Content-Encoding: gzip\n        # <https://github.com/jakubroztocil/httpie/issues/423>\n        try:\n            total_size = int(response.headers['Content-Length'])\n        except (KeyError, ValueError, TypeError):\n            total_size = None\n\n        if self._output_file:\n            if self._resume and response.status_code == PARTIAL_CONTENT:\n                total_size = parse_content_range(\n                    response.headers.get('Content-Range'),\n                    self._resumed_from\n                )\n\n            else:\n                self._resumed_from = 0\n                try:\n                    self._output_file.seek(0)\n                    self._output_file.truncate()\n                except IOError:\n                    pass  # stdout\n        else:\n            # TODO: Should the filename be taken from response.history[0].url?\n            # Output file not specified. Pick a name that doesn't exist yet.\n            filename = None\n            if 'Content-Disposition' in response.headers:\n                filename = filename_from_content_disposition(\n                    response.headers['Content-Disposition'])\n            if not filename:\n                filename = filename_from_url(\n                    url=response.url,\n                    content_type=response.headers.get('Content-Type'),\n                )\n            self._output_file = open(get_unique_filename(filename), mode='a+b')\n\n        self.status.started(\n            resumed_from=self._resumed_from,\n            total_size=total_size\n        )\n\n        stream = RawStream(\n            msg=HTTPResponse(response),\n            with_headers=False,\n            with_body=True,\n            on_body_chunk_downloaded=self.chunk_downloaded,\n            chunk_size=1024 * 8\n        )\n\n        self._progress_reporter.output.write(\n            'Downloading %sto \"%s\"\\n' % (\n                (humanize_bytes(total_size) + ' '\n                 if total_size is not None\n                 else ''),\n                self._output_file.name\n            )\n        )\n        self._progress_reporter.start()\n\n        return stream, self._output_file\n\n    def finish(self):\n        assert not self.finished\n        self.finished = True\n        self.status.finished()\n\n    def failed(self):\n        self._progress_reporter.stop()\n\n    @property\n    def interrupted(self):\n        return (\n            self.finished and\n            self.status.total_size and\n            self.status.total_size != self.status.downloaded\n        )\n\n    def chunk_downloaded(self, chunk):\n        \"\"\"\n        A download progress callback.\n\n        :param chunk: A chunk of response body data that has just\n                      been downloaded and written to the output.\n        :type chunk: bytes\n\n        \"\"\"\n        self.status.chunk_downloaded(len(chunk))\n\n\nclass Status(object):\n    \"\"\"Holds details about the downland status.\"\"\"\n\n    def __init__(self):\n        self.downloaded = 0\n        self.total_size = None\n        self.resumed_from = 0\n        self.time_started = None\n        self.time_finished = None\n\n    def started(self, resumed_from=0, total_size=None):\n        assert self.time_started is None\n        self.total_size = total_size\n        self.downloaded = self.resumed_from = resumed_from\n        self.time_started = time()\n\n    def chunk_downloaded(self, size):\n        assert self.time_finished is None\n        self.downloaded += size\n\n    @property\n    def has_finished(self):\n        return self.time_finished is not None\n\n    def finished(self):\n        assert self.time_started is not None\n        assert self.time_finished is None\n        self.time_finished = time()\n\n\nclass ProgressReporterThread(threading.Thread):\n    \"\"\"\n    Reports download progress based on its status.\n\n    Uses threading to periodically update the status (speed, ETA, etc.).\n\n    \"\"\"\n    def __init__(self, status, output, tick=.1, update_interval=1):\n        \"\"\"\n\n        :type status: Status\n        :type output: file\n        \"\"\"\n        super(ProgressReporterThread, self).__init__()\n        self.status = status\n        self.output = output\n        self._tick = tick\n        self._update_interval = update_interval\n        self._spinner_pos = 0\n        self._status_line = ''\n        self._prev_bytes = 0\n        self._prev_time = time()\n        self._should_stop = threading.Event()\n\n    def stop(self):\n        \"\"\"Stop reporting on next tick.\n.\n# coding=utf-8\n# Either time is 0 (not all systems provide `time.time`\n# with a better precision than 1 second), and/or nothing\n# has been downloaded.\n", "content": "# coding=utf-8\n\"\"\"\nDownload mode implementation.\n\n\"\"\"\nfrom __future__ import division\nimport os\nimport re\nimport sys\nimport errno\nimport mimetypes\nimport threading\nfrom time import sleep, time\nfrom mailbox import Message\n\nfrom httpie.output.streams import RawStream\nfrom httpie.models import HTTPResponse\nfrom httpie.utils import humanize_bytes\nfrom httpie.compat import urlsplit\n\n\nPARTIAL_CONTENT = 206\n\n\nCLEAR_LINE = '\\r\\033[K'\nPROGRESS = (\n    '{percentage: 6.2f} %'\n    ' {downloaded: >10}'\n    ' {speed: >10}/s'\n    ' {eta: >8} ETA'\n)\nPROGRESS_NO_CONTENT_LENGTH = '{downloaded: >10} {speed: >10}/s'\nSUMMARY = 'Done. {downloaded} in {time:0.5f}s ({speed}/s)\\n'\nSPINNER = '|/-\\\\'\n\n\nclass ContentRangeError(ValueError):\n    pass\n\n\ndef parse_content_range(content_range, resumed_from):\n    \"\"\"\n    Parse and validate Content-Range header.\n\n    <http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html>\n\n    :param content_range: the value of a Content-Range response header\n                          eg. \"bytes 21010-47021/47022\"\n    :param resumed_from: first byte pos. from the Range request header\n    :return: total size of the response body when fully downloaded.\n\n    \"\"\"\n    if content_range is None:\n        raise ContentRangeError('Missing Content-Range')\n\n    pattern = (\n        '^bytes (?P<first_byte_pos>\\d+)-(?P<last_byte_pos>\\d+)'\n        '/(\\*|(?P<instance_length>\\d+))$'\n    )\n    match = re.match(pattern, content_range)\n\n    if not match:\n        raise ContentRangeError(\n            'Invalid Content-Range format %r' % content_range)\n\n    content_range_dict = match.groupdict()\n    first_byte_pos = int(content_range_dict['first_byte_pos'])\n    last_byte_pos = int(content_range_dict['last_byte_pos'])\n    instance_length = (\n        int(content_range_dict['instance_length'])\n        if content_range_dict['instance_length']\n        else None\n    )\n\n    # \"A byte-content-range-spec with a byte-range-resp-spec whose\n    # last- byte-pos value is less than its first-byte-pos value,\n    # or whose instance-length value is less than or equal to its\n    # last-byte-pos value, is invalid. The recipient of an invalid\n    # byte-content-range- spec MUST ignore it and any content\n    # transferred along with it.\"\n    if (first_byte_pos >= last_byte_pos or\n            (instance_length is not None and\n             instance_length <= last_byte_pos)):\n        raise ContentRangeError(\n            'Invalid Content-Range returned: %r' % content_range)\n\n    if (first_byte_pos != resumed_from or\n            (instance_length is not None and\n             last_byte_pos + 1 != instance_length)):\n        # Not what we asked for.\n        raise ContentRangeError(\n            'Unexpected Content-Range returned (%r)'\n            ' for the requested Range (\"bytes=%d-\")'\n            % (content_range, resumed_from)\n        )\n\n    return last_byte_pos + 1\n\n\ndef filename_from_content_disposition(content_disposition):\n    \"\"\"\n    Extract and validate filename from a Content-Disposition header.\n\n    :param content_disposition: Content-Disposition value\n    :return: the filename if present and valid, otherwise `None`\n\n    \"\"\"\n    # attachment; filename=jakubroztocil-httpie-0.4.1-20-g40bd8f6.tar.gz\n\n    msg = Message('Content-Disposition: %s' % content_disposition)\n    filename = msg.get_filename()\n    if filename:\n        # Basic sanitation.\n        filename = os.path.basename(filename).lstrip('.').strip()\n        if filename:\n            return filename\n\n\ndef filename_from_url(url, content_type):\n    fn = urlsplit(url).path.rstrip('/')\n    fn = os.path.basename(fn) if fn else 'index'\n    if '.' not in fn and content_type:\n        content_type = content_type.split(';')[0]\n        if content_type == 'text/plain':\n            # mimetypes returns '.ksh'\n            ext = '.txt'\n        else:\n            ext = mimetypes.guess_extension(content_type)\n\n        if ext == '.htm':  # Python 3\n            ext = '.html'\n\n        if ext:\n            fn += ext\n\n    return fn\n\n\ndef trim_filename(filename, max_len):\n    if len(filename) > max_len:\n        trim_by = len(filename) - max_len\n        name, ext = os.path.splitext(filename)\n        if trim_by >= len(name):\n            filename = filename[:-trim_by]\n        else:\n            filename = name[:-trim_by] + ext\n    return filename\n\n\ndef get_filename_max_length(directory):\n    max_len = 255\n    try:\n        pathconf = os.pathconf\n    except AttributeError:\n        pass  # non-posix\n    else:\n        try:\n            max_len = pathconf(directory, 'PC_NAME_MAX')\n        except OSError as e:\n            if e.errno != errno.EINVAL:\n                raise\n    return max_len\n\n\ndef trim_filename_if_needed(filename, directory='.', extra=0):\n    max_len = get_filename_max_length(directory) - extra\n    if len(filename) > max_len:\n        filename = trim_filename(filename, max_len)\n    return filename\n\n\ndef get_unique_filename(filename, exists=os.path.exists):\n    attempt = 0\n    while True:\n        suffix = '-' + str(attempt) if attempt > 0 else ''\n        try_filename = trim_filename_if_needed(filename, extra=len(suffix))\n        try_filename += suffix\n        if not exists(try_filename):\n            return try_filename\n        attempt += 1\n\n\nclass Downloader(object):\n\n    def __init__(self, output_file=None,\n                 resume=False, progress_file=sys.stderr):\n        \"\"\"\n        :param resume: Should the download resume if partial download\n                       already exists.\n        :type resume: bool\n\n        :param output_file: The file to store response body in. If not\n                            provided, it will be guessed from the response.\n\n        :param progress_file: Where to report download progress.\n\n        \"\"\"\n        self._output_file = output_file\n        self._resume = resume\n        self._resumed_from = 0\n        self.finished = False\n\n        self.status = Status()\n        self._progress_reporter = ProgressReporterThread(\n            status=self.status,\n            output=progress_file\n        )\n\n    def pre_request(self, request_headers):\n        \"\"\"Called just before the HTTP request is sent.\n\n        Might alter `request_headers`.\n\n        :type request_headers: dict\n\n        \"\"\"\n        # Ask the server not to encode the content so that we can resume, etc.\n        request_headers['Accept-Encoding'] = 'identity'\n        if self._resume:\n            bytes_have = os.path.getsize(self._output_file.name)\n            if bytes_have:\n                # Set ``Range`` header to resume the download\n                # TODO: Use \"If-Range: mtime\" to make sure it's fresh?\n                request_headers['Range'] = 'bytes=%d-' % bytes_have\n                self._resumed_from = bytes_have\n\n    def start(self, response):\n        \"\"\"\n        Initiate and return a stream for `response` body  with progress\n        callback attached. Can be called only once.\n\n        :param response: Initiated response object with headers already fetched\n        :type response: requests.models.Response\n\n        :return: RawStream, output_file\n\n        \"\"\"\n        assert not self.status.time_started\n\n        # FIXME: some servers still might sent Content-Encoding: gzip\n        # <https://github.com/jakubroztocil/httpie/issues/423>\n        try:\n            total_size = int(response.headers['Content-Length'])\n        except (KeyError, ValueError, TypeError):\n            total_size = None\n\n        if self._output_file:\n            if self._resume and response.status_code == PARTIAL_CONTENT:\n                total_size = parse_content_range(\n                    response.headers.get('Content-Range'),\n                    self._resumed_from\n                )\n\n            else:\n                self._resumed_from = 0\n                try:\n                    self._output_file.seek(0)\n                    self._output_file.truncate()\n                except IOError:\n                    pass  # stdout\n        else:\n            # TODO: Should the filename be taken from response.history[0].url?\n            # Output file not specified. Pick a name that doesn't exist yet.\n            filename = None\n            if 'Content-Disposition' in response.headers:\n                filename = filename_from_content_disposition(\n                    response.headers['Content-Disposition'])\n            if not filename:\n                filename = filename_from_url(\n                    url=response.url,\n                    content_type=response.headers.get('Content-Type'),\n                )\n            self._output_file = open(get_unique_filename(filename), mode='a+b')\n\n        self.status.started(\n            resumed_from=self._resumed_from,\n            total_size=total_size\n        )\n\n        stream = RawStream(\n            msg=HTTPResponse(response),\n            with_headers=False,\n            with_body=True,\n            on_body_chunk_downloaded=self.chunk_downloaded,\n            chunk_size=1024 * 8\n        )\n\n        self._progress_reporter.output.write(\n            'Downloading %sto \"%s\"\\n' % (\n                (humanize_bytes(total_size) + ' '\n                 if total_size is not None\n                 else ''),\n                self._output_file.name\n            )\n        )\n        self._progress_reporter.start()\n\n        return stream, self._output_file\n\n    def finish(self):\n        assert not self.finished\n        self.finished = True\n        self.status.finished()\n\n    def failed(self):\n        self._progress_reporter.stop()\n\n    @property\n    def interrupted(self):\n        return (\n            self.finished and\n            self.status.total_size and\n            self.status.total_size != self.status.downloaded\n        )\n\n    def chunk_downloaded(self, chunk):\n        \"\"\"\n        A download progress callback.\n\n        :param chunk: A chunk of response body data that has just\n                      been downloaded and written to the output.\n        :type chunk: bytes\n\n        \"\"\"\n        self.status.chunk_downloaded(len(chunk))\n\n\nclass Status(object):\n    \"\"\"Holds details about the downland status.\"\"\"\n\n    def __init__(self):\n        self.downloaded = 0\n        self.total_size = None\n        self.resumed_from = 0\n        self.time_started = None\n        self.time_finished = None\n\n    def started(self, resumed_from=0, total_size=None):\n        assert self.time_started is None\n        self.total_size = total_size\n        self.downloaded = self.resumed_from = resumed_from\n        self.time_started = time()\n\n    def chunk_downloaded(self, size):\n        assert self.time_finished is None\n        self.downloaded += size\n\n    @property\n    def has_finished(self):\n        return self.time_finished is not None\n\n    def finished(self):\n        assert self.time_started is not None\n        assert self.time_finished is None\n        self.time_finished = time()\n\n\nclass ProgressReporterThread(threading.Thread):\n    \"\"\"\n    Reports download progress based on its status.\n\n    Uses threading to periodically update the status (speed, ETA, etc.).\n\n    \"\"\"\n    def __init__(self, status, output, tick=.1, update_interval=1):\n        \"\"\"\n\n        :type status: Status\n        :type output: file\n        \"\"\"\n        super(ProgressReporterThread, self).__init__()\n        self.status = status\n        self.output = output\n        self._tick = tick\n        self._update_interval = update_interval\n        self._spinner_pos = 0\n        self._status_line = ''\n        self._prev_bytes = 0\n        self._prev_time = time()\n        self._should_stop = threading.Event()\n\n    def stop(self):\n        \"\"\"Stop reporting on next tick.\"\"\"\n        self._should_stop.set()\n\n    def run(self):\n        while not self._should_stop.is_set():\n            if self.status.has_finished:\n                self.sum_up()\n                break\n\n            self.report_speed()\n            sleep(self._tick)\n\n    def report_speed(self):\n\n        now = time()\n\n        if now - self._prev_time >= self._update_interval:\n            downloaded = self.status.downloaded\n            try:\n                speed = ((downloaded - self._prev_bytes) /\n                         (now - self._prev_time))\n            except ZeroDivisionError:\n                speed = 0\n\n            if not self.status.total_size:\n                self._status_line = PROGRESS_NO_CONTENT_LENGTH.format(\n                    downloaded=humanize_bytes(downloaded),\n                    speed=humanize_bytes(speed),\n                )\n            else:\n                try:\n                    percentage = downloaded / self.status.total_size * 100\n                except ZeroDivisionError:\n                    percentage = 0\n\n                if not speed:\n                    eta = '-:--:--'\n                else:\n                    s = int((self.status.total_size - downloaded) / speed)\n                    h, s = divmod(s, 60 * 60)\n                    m, s = divmod(s, 60)\n                    eta = '{0}:{1:0>2}:{2:0>2}'.format(h, m, s)\n\n                self._status_line = PROGRESS.format(\n                    percentage=percentage,\n                    downloaded=humanize_bytes(downloaded),\n                    speed=humanize_bytes(speed),\n                    eta=eta,\n                )\n\n            self._prev_time = now\n            self._prev_bytes = downloaded\n\n        self.output.write(\n            CLEAR_LINE +\n            ' ' +\n            SPINNER[self._spinner_pos] +\n            ' ' +\n            self._status_line\n        )\n        self.output.flush()\n\n        self._spinner_pos = (self._spinner_pos + 1\n                             if self._spinner_pos + 1 != len(SPINNER)\n                             else 0)\n\n    def sum_up(self):\n        actually_downloaded = (\n            self.status.downloaded - self.status.resumed_from)\n        time_taken = self.status.time_finished - self.status.time_started\n\n        self.output.write(CLEAR_LINE)\n\n        try:\n            speed = actually_downloaded / time_taken\n        except ZeroDivisionError:\n            # Either time is 0 (not all systems provide `time.time`\n            # with a better precision than 1 second), and/or nothing\n            # has been downloaded.\n            speed = actually_downloaded\n\n        self.output.write(SUMMARY.format(\n            downloaded=humanize_bytes(actually_downloaded),\n            total=(self.status.total_size and\n                   humanize_bytes(self.status.total_size)),\n            speed=humanize_bytes(speed),\n            time=time_taken,\n        ))\n        self.output.flush()\n", "description": "Modern command line HTTP client \u2013 user-friendly curl alternative with intuitive UI, JSON support, syntax highlighting, wget-like downloads, extensions, etc.  https://httpie.org", "file_name": "downloads.py", "language": "Python", "project_name": "httpie", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/jakubroztocil_httpie/jakubroztocil-httpie-0f4dce9/httpie/downloads.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:20:06Z", "url": "https://github.com/jakubroztocil/httpie", "wiki": false}