{"author": "ansible", "code": " -*- coding: utf-8 -*-\n\n Copyright (c) 2017 F5 Networks Inc.\n GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\nimport json\nimport sys\n\nfrom nose.plugins.skip import SkipTest\nif sys.version_info < (2, 7):\n    raise SkipTest(\"F5 Ansible modules require Python >= 2.7\")\n\nfrom ansible.compat.tests import unittest\nfrom ansible.compat.tests.mock import patch\nfrom ansible.compat.tests.mock import Mock\nfrom ansible.module_utils.basic import AnsibleModule\n\ntry:\n    from library.bigip_command import Parameters\n    from library.bigip_command import ModuleManager\n    from library.bigip_command import ArgumentSpec\n    from library.module_utils.network.f5.common import F5ModuleError\n    from library.module_utils.network.f5.common import iControlUnexpectedHTTPError\n    from test.unit.modules.utils import set_module_args\nexcept ImportError:\n    try:\n        from ansible.modules.network.f5.bigip_command import Parameters\n        from ansible.modules.network.f5.bigip_command import ModuleManager\n        from ansible.modules.network.f5.bigip_command import ArgumentSpec\n        from ansible.module_utils.network.f5.common import F5ModuleError\n        from ansible.module_utils.network.f5.common import iControlUnexpectedHTTPError\n        from units.modules.utils import set_module_args\n    except ImportError:\n        raise SkipTest(\"F5 Ansible modules require the f5-sdk Python library\")\n\nfixture_path = os.path.join(os.path.dirname(__file__), 'fixtures')\nfixture_data = {}\n\n\ndef load_fixture(name):\n    path = os.path.join(fixture_path, name)\n    with open(path) as f:\n        data = f.read()\n    try:\n        data = json.loads(data)\n    except Exception:\n        pass\n    return data\n\n\nclass TestParameters(unittest.TestCase):\n\n    def test_module_parameters(self):\n        args = dict(\n            commands=[\n                \"tmsh show sys version\"\n            ],\n            server='localhost',\n            user='admin',\n            password='password'\n        )\n        p = Parameters(params=args)\n        assert len(p.commands) == 1\n\n\nclass TestManager(unittest.TestCase):\n\n    def setUp(self):\n        self.spec = ArgumentSpec()\n        self.patcher1 = patch('time.sleep')\n        self.patcher1.start()\n\n    def tearDown(self):\n        self.patcher1.stop()\n\n    def test_run_single_command(self, *args):\n        set_module_args(dict(\n            commands=[\n                \"tmsh show sys version\"\n            ],\n            server='localhost',\n            user='admin',\n            password='password'\n        ))\n\n        module = AnsibleModule(\n            argument_spec=self.spec.argument_spec,\n            supports_check_mode=self.spec.supports_check_mode\n        )\n\n        mm = ModuleManager(module=module)\n        mm._run_commands = Mock(return_value=[])\n        mm.execute_on_device = Mock(return_value=[])\n\n        results = mm.exec_module()\n\n        assert results['changed'] is False\n        assert mm._run_commands.call_count == 0\n        assert mm.execute_on_device.call_count == 1\n\n    def test_run_single_modification_command(self, *args):\n        set_module_args(dict(\n            commands=[\n                \"tmsh create ltm virtual foo\"\n            ],\n            server='localhost',\n            user='admin',\n            password='password'\n        ))\n\n        module = AnsibleModule(\n            argument_spec=self.spec.argument_spec,\n            supports_check_mode=self.spec.supports_check_mode\n        )\n        mm = ModuleManager(module=module)\n        mm._run_commands = Mock(return_value=[])\n        mm.execute_on_device = Mock(return_value=[])\n\n        results = mm.exec_module()\n\n        assert results['changed'] is True\n        assert mm._run_commands.call_count == 0\n        assert mm.execute_on_device.call_count == 1\n\n    def test_cli_command(self, *args):\n        set_module_args(dict(\n            commands=[\n                \"show sys version\"\n            ],\n            server='localhost',\n            user='admin',\n            password='password',\n            transport='cli'\n        ))\n\n        module = AnsibleModule(\n            argument_spec=self.spec.argument_spec,\n            supports_check_mode=self.spec.supports_check_mode\n        )\n        mm = ModuleManager(module=module)\n        mm._run_commands = Mock(return_value=[])\n        mm.execute_on_device = Mock(return_value=[])\n\n        results = mm.exec_module()\n\n        assert results['changed'] is False\n\n         call count is two on CLI transport because we must first\n         determine if the remote CLI is in tmsh mode or advanced shell\n         (bash) mode.\n        \n         1 call for the shell check\n         1 call for the command in the \"commands\" list above\n        \n         Can we change this in the future by making the terminal plugin\n         find this out ahead of time?\n        assert mm._run_commands.call_count == 2\n        assert mm.execute_on_device.call_count == 0\n\n    def test_command_with_commas(self, *args):\n        set_module_args(dict(\n            commands=\"\"\"\n              tmsh create /auth ldap system-auth {bind-dn uid=binduser,\n              cn=users,dc=domain,dc=com bind-pw $ENCRYPTEDPW check-roles-group\n              enabled search-base-dn cn=users,dc=domain,dc=com servers add {\n              ldap.server.com } }\"\n            \"\"\",\n            server='localhost',\n            user='admin',\n            password='password'\n        ))\n        module = AnsibleModule(\n            argument_spec=self.spec.argument_spec,\n            supports_check_mode=self.spec.supports_check_mode\n        )\n        mm = ModuleManager(module=module)\n        mm._run_commands = Mock(return_value=[])\n        mm.execute_on_device = Mock(return_value=[])\n\n        results = mm.exec_module()\n\n        assert results['changed'] is True\n        assert mm._run_commands.call_count == 0\n        assert mm.execute_on_device.call_count == 1\n", "comments": "                  tmsh create  auth ldap system auth  bind dn uid binduser                cn users dc domain dc com bind pw  encryptedpw check roles group               enabled search base dn cn users dc domain dc com servers add                 ldap server com                             coding  utf 8           copyright (c) 2017 f5 networks inc     gnu general public license v3 0 (see copying https   www gnu org licenses gpl 3 0 txt)    call count two cli transport must first    determine remote cli tmsh mode advanced shell    (bash) mode        1 call shell check    1 call command  commands  list       can change future making terminal plugin    find ahead time  ", "content": "# -*- coding: utf-8 -*-\n#\n# Copyright (c) 2017 F5 Networks Inc.\n# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\nimport json\nimport sys\n\nfrom nose.plugins.skip import SkipTest\nif sys.version_info < (2, 7):\n    raise SkipTest(\"F5 Ansible modules require Python >= 2.7\")\n\nfrom ansible.compat.tests import unittest\nfrom ansible.compat.tests.mock import patch\nfrom ansible.compat.tests.mock import Mock\nfrom ansible.module_utils.basic import AnsibleModule\n\ntry:\n    from library.bigip_command import Parameters\n    from library.bigip_command import ModuleManager\n    from library.bigip_command import ArgumentSpec\n    from library.module_utils.network.f5.common import F5ModuleError\n    from library.module_utils.network.f5.common import iControlUnexpectedHTTPError\n    from test.unit.modules.utils import set_module_args\nexcept ImportError:\n    try:\n        from ansible.modules.network.f5.bigip_command import Parameters\n        from ansible.modules.network.f5.bigip_command import ModuleManager\n        from ansible.modules.network.f5.bigip_command import ArgumentSpec\n        from ansible.module_utils.network.f5.common import F5ModuleError\n        from ansible.module_utils.network.f5.common import iControlUnexpectedHTTPError\n        from units.modules.utils import set_module_args\n    except ImportError:\n        raise SkipTest(\"F5 Ansible modules require the f5-sdk Python library\")\n\nfixture_path = os.path.join(os.path.dirname(__file__), 'fixtures')\nfixture_data = {}\n\n\ndef load_fixture(name):\n    path = os.path.join(fixture_path, name)\n    with open(path) as f:\n        data = f.read()\n    try:\n        data = json.loads(data)\n    except Exception:\n        pass\n    return data\n\n\nclass TestParameters(unittest.TestCase):\n\n    def test_module_parameters(self):\n        args = dict(\n            commands=[\n                \"tmsh show sys version\"\n            ],\n            server='localhost',\n            user='admin',\n            password='password'\n        )\n        p = Parameters(params=args)\n        assert len(p.commands) == 1\n\n\nclass TestManager(unittest.TestCase):\n\n    def setUp(self):\n        self.spec = ArgumentSpec()\n        self.patcher1 = patch('time.sleep')\n        self.patcher1.start()\n\n    def tearDown(self):\n        self.patcher1.stop()\n\n    def test_run_single_command(self, *args):\n        set_module_args(dict(\n            commands=[\n                \"tmsh show sys version\"\n            ],\n            server='localhost',\n            user='admin',\n            password='password'\n        ))\n\n        module = AnsibleModule(\n            argument_spec=self.spec.argument_spec,\n            supports_check_mode=self.spec.supports_check_mode\n        )\n\n        mm = ModuleManager(module=module)\n        mm._run_commands = Mock(return_value=[])\n        mm.execute_on_device = Mock(return_value=[])\n\n        results = mm.exec_module()\n\n        assert results['changed'] is False\n        assert mm._run_commands.call_count == 0\n        assert mm.execute_on_device.call_count == 1\n\n    def test_run_single_modification_command(self, *args):\n        set_module_args(dict(\n            commands=[\n                \"tmsh create ltm virtual foo\"\n            ],\n            server='localhost',\n            user='admin',\n            password='password'\n        ))\n\n        module = AnsibleModule(\n            argument_spec=self.spec.argument_spec,\n            supports_check_mode=self.spec.supports_check_mode\n        )\n        mm = ModuleManager(module=module)\n        mm._run_commands = Mock(return_value=[])\n        mm.execute_on_device = Mock(return_value=[])\n\n        results = mm.exec_module()\n\n        assert results['changed'] is True\n        assert mm._run_commands.call_count == 0\n        assert mm.execute_on_device.call_count == 1\n\n    def test_cli_command(self, *args):\n        set_module_args(dict(\n            commands=[\n                \"show sys version\"\n            ],\n            server='localhost',\n            user='admin',\n            password='password',\n            transport='cli'\n        ))\n\n        module = AnsibleModule(\n            argument_spec=self.spec.argument_spec,\n            supports_check_mode=self.spec.supports_check_mode\n        )\n        mm = ModuleManager(module=module)\n        mm._run_commands = Mock(return_value=[])\n        mm.execute_on_device = Mock(return_value=[])\n\n        results = mm.exec_module()\n\n        assert results['changed'] is False\n\n        # call count is two on CLI transport because we must first\n        # determine if the remote CLI is in tmsh mode or advanced shell\n        # (bash) mode.\n        #\n        # 1 call for the shell check\n        # 1 call for the command in the \"commands\" list above\n        #\n        # Can we change this in the future by making the terminal plugin\n        # find this out ahead of time?\n        assert mm._run_commands.call_count == 2\n        assert mm.execute_on_device.call_count == 0\n\n    def test_command_with_commas(self, *args):\n        set_module_args(dict(\n            commands=\"\"\"\n              tmsh create /auth ldap system-auth {bind-dn uid=binduser,\n              cn=users,dc=domain,dc=com bind-pw $ENCRYPTEDPW check-roles-group\n              enabled search-base-dn cn=users,dc=domain,dc=com servers add {\n              ldap.server.com } }\"\n            \"\"\",\n            server='localhost',\n            user='admin',\n            password='password'\n        ))\n        module = AnsibleModule(\n            argument_spec=self.spec.argument_spec,\n            supports_check_mode=self.spec.supports_check_mode\n        )\n        mm = ModuleManager(module=module)\n        mm._run_commands = Mock(return_value=[])\n        mm.execute_on_device = Mock(return_value=[])\n\n        results = mm.exec_module()\n\n        assert results['changed'] is True\n        assert mm._run_commands.call_count == 0\n        assert mm.execute_on_device.call_count == 1\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "test_bigip_command.py", "id": "7968ee36ff97670c7678150d417ac5ed", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/test/units/modules/network/f5/test_bigip_command.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}