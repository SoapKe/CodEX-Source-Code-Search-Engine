{"author": "Dman95", "code": "\"\"\"functools.py - Tools for working with functions and callable objects\n\"\"\"\n\n\n\n\n#   Copyright (C) 2006 Python Software Foundation.\n\n\nfrom _functools import partial, reduce\n\n# update_wrapper() and wraps() are tools to help write\n\n\nWRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__doc__')\nWRAPPER_UPDATES = ('__dict__',)\ndef update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,\n                   updated = WRAPPER_UPDATES):\n    \"\"\"Update a wrapper function to look like the wrapped function\n\n       wrapper is the function to be updated\n       wrapped is the original function\n       assigned is a tuple naming the attributes assigned directly\n       from the wrapped function to the wrapper function (defaults to\n       functools.WRAPPER_ASSIGNMENTS)\n       updated is a tuple naming the attributes of the wrapper that\n       are updated with the corresponding attribute from the wrapped\n       function (defaults to functools.WRAPPER_UPDATES)\n    \"\"\"\n    for attr in assigned:\n        setattr(wrapper, attr, getattr(wrapped, attr))\n    for attr in updated:\n        getattr(wrapper, attr).update(getattr(wrapped, attr, {}))\n    ()\n    return wrapper\n\ndef wraps(wrapped,\n          assigned = WRAPPER_ASSIGNMENTS,\n          updated = WRAPPER_UPDATES):\n    \"\"\"Decorator factory to apply update_wrapper() to a wrapper function\n\n       Returns a decorator that invokes update_wrapper() with the decorated\n       function as the wrapper argument and the arguments to wraps() as the\n       remaining arguments. Default arguments are as for update_wrapper().\n       This is a convenience function to simplify applying partial() to\n       update_wrapper().\n    \"\"\"\n    return partial(update_wrapper, wrapped=wrapped,\n                   assigned=assigned, updated=updated)\n\ndef total_ordering(cls):\n    \"\"\"Class decorator that fills in missing ordering methods\"\"\"\n    convert = {\n        '__lt__': [('__gt__', lambda self, other: not (self < other or self == other)),\n                   ('__le__', lambda self, other: self < other or self == other),\n                   ('__ge__', lambda self, other: not self < other)],\n        '__le__': [('__ge__', lambda self, other: not self <= other or self == other),\n                   ('__lt__', lambda self, other: self <= other and not self == other),\n                   ('__gt__', lambda self, other: not self <= other)],\n        '__gt__': [('__lt__', lambda self, other: not (self > other or self == other)),\n                   ('__ge__', lambda self, other: self > other or self == other),\n                   ('__le__', lambda self, other: not self > other)],\n        '__ge__': [('__le__', lambda self, other: (not self >= other) or self == other),\n                   ('__gt__', lambda self, other: self >= other and not self == other),\n                   ('__lt__', lambda self, other: not self >= other)]\n    }\n    roots = set(dir(cls)) & set(convert)\n    if not roots:\n        raise ValueError('must define at least one ordering operation: < > <= >=')\n    root = max(roots)       \n    for opname, opfunc in convert[root]:\n        if opname not in roots:\n            opfunc.__name__ = opname\n            opfunc.__doc__ = getattr(int, opname).__doc__\n            setattr(cls, opname, opfunc)\n    return cls\n\ndef cmp_to_key(mycmp):\n    \"\"\"Convert a cmp= function into a key= function\"\"\"\n    class K(object):\n        __slots__ = ['obj']\n        def __init__(self, obj, *args):\n            self.obj = obj\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) < 0\n        def __gt__(self, other):\n            return mycmp(self.obj, other.obj) > 0\n        def __eq__(self, other):\n            return mycmp(self.obj, other.obj) == 0\n        def __le__(self, other):\n            return mycmp(self.obj, other.obj) <= 0\n        def __ge__(self, other):\n            return mycmp(self.obj, other.obj) >= 0\n        def __ne__(self, other):\n            return mycmp(self.obj, other.obj) != 0\n        def __hash__(self):\n            raise TypeError('hash not implemented')\n    return K\n", "comments": "   functools py   tools working functions callable objects       python module wrapper  functools c module   allow utilities written python added   functools module    written nick coghlan  ncoghlan gmail com      copyright (c) 2006 python software foundation    see c source code  functools credits copyright   functools import partial  reduce    update wrapper() wraps() tools help write   wrapper functions handle naive introspection  wrapper assignments   (   module        name        doc   ) wrapper updates   (   dict    ) def update wrapper(wrapper                     wrapped                     assigned   wrapper assignments                     updated   wrapper updates)         update wrapper function look like wrapped function         wrapper function updated        wrapped original function        assigned tuple naming attributes assigned directly        wrapped function wrapper function (defaults        functools wrapper assignments)        updated tuple naming attributes wrapper        updated corresponding attribute wrapped        function (defaults functools wrapper updates)             attr assigned          setattr(wrapper  attr  getattr(wrapped  attr))     attr updated          getattr(wrapper  attr) update(getattr(wrapped  attr    ))       return wrapper used decorator via partial()     return wrapper  def wraps(wrapped            assigned   wrapper assignments            updated   wrapper updates)         decorator factory apply update wrapper() wrapper function         returns decorator invokes update wrapper() decorated        function wrapper argument arguments wraps()        remaining arguments  default arguments update wrapper()         this convenience function simplify applying partial()        update wrapper()              return partial(update wrapper  wrapped wrapped                     assigned assigned  updated updated)  def total ordering(cls)         class decorator fills missing ordering methods        convert                lt      (   gt     lambda self   (self   self    other))                     (   le     lambda self   self   self    other)                     (   ge     lambda self   self   other)              le      (   ge     lambda self   self    self    other)                     (   lt     lambda self   self    self    other)                     (   gt     lambda self   self    other)              gt      (   lt     lambda self   (self   self    other))                     (   ge     lambda self   self   self    other)                     (   le     lambda self   self   other)              ge      (   le     lambda self   (not self    other) self    other)                     (   gt     lambda self   self    self    other)                     (   lt     lambda self   self    other)            roots   set(dir(cls))   set(convert)     roots          raise valueerror( must define least one ordering operation            )     root   max(roots)         prefer   lt     le     gt     ge       opname  opfunc convert root           opname roots              opfunc   name     opname             opfunc   doc     getattr(int  opname)   doc               setattr(cls  opname  opfunc)     return cls  def cmp key(mycmp)         convert cmp  function key  function       python module wrapper  functools c module    allow utilities written python added    functools module     written nick coghlan  ncoghlan gmail com       copyright (c) 2006 python software foundation     see c source code  functools credits copyright    update wrapper() wraps() tools help write    wrapper functions handle naive introspection    return wrapper used decorator via partial()    prefer   lt     le     gt     ge   ", "content": "\"\"\"functools.py - Tools for working with functions and callable objects\n\"\"\"\n# Python module wrapper for _functools C module\n# to allow utilities written in Python to be added\n# to the functools module.\n# Written by Nick Coghlan <ncoghlan at gmail.com>\n#   Copyright (C) 2006 Python Software Foundation.\n# See C source code for _functools credits/copyright\n\nfrom _functools import partial, reduce\n\n# update_wrapper() and wraps() are tools to help write\n# wrapper functions that can handle naive introspection\n\nWRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__doc__')\nWRAPPER_UPDATES = ('__dict__',)\ndef update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,\n                   updated = WRAPPER_UPDATES):\n    \"\"\"Update a wrapper function to look like the wrapped function\n\n       wrapper is the function to be updated\n       wrapped is the original function\n       assigned is a tuple naming the attributes assigned directly\n       from the wrapped function to the wrapper function (defaults to\n       functools.WRAPPER_ASSIGNMENTS)\n       updated is a tuple naming the attributes of the wrapper that\n       are updated with the corresponding attribute from the wrapped\n       function (defaults to functools.WRAPPER_UPDATES)\n    \"\"\"\n    for attr in assigned:\n        setattr(wrapper, attr, getattr(wrapped, attr))\n    for attr in updated:\n        getattr(wrapper, attr).update(getattr(wrapped, attr, {}))\n    # Return the wrapper so this can be used as a decorator via partial()\n    return wrapper\n\ndef wraps(wrapped,\n          assigned = WRAPPER_ASSIGNMENTS,\n          updated = WRAPPER_UPDATES):\n    \"\"\"Decorator factory to apply update_wrapper() to a wrapper function\n\n       Returns a decorator that invokes update_wrapper() with the decorated\n       function as the wrapper argument and the arguments to wraps() as the\n       remaining arguments. Default arguments are as for update_wrapper().\n       This is a convenience function to simplify applying partial() to\n       update_wrapper().\n    \"\"\"\n    return partial(update_wrapper, wrapped=wrapped,\n                   assigned=assigned, updated=updated)\n\ndef total_ordering(cls):\n    \"\"\"Class decorator that fills in missing ordering methods\"\"\"\n    convert = {\n        '__lt__': [('__gt__', lambda self, other: not (self < other or self == other)),\n                   ('__le__', lambda self, other: self < other or self == other),\n                   ('__ge__', lambda self, other: not self < other)],\n        '__le__': [('__ge__', lambda self, other: not self <= other or self == other),\n                   ('__lt__', lambda self, other: self <= other and not self == other),\n                   ('__gt__', lambda self, other: not self <= other)],\n        '__gt__': [('__lt__', lambda self, other: not (self > other or self == other)),\n                   ('__ge__', lambda self, other: self > other or self == other),\n                   ('__le__', lambda self, other: not self > other)],\n        '__ge__': [('__le__', lambda self, other: (not self >= other) or self == other),\n                   ('__gt__', lambda self, other: self >= other and not self == other),\n                   ('__lt__', lambda self, other: not self >= other)]\n    }\n    roots = set(dir(cls)) & set(convert)\n    if not roots:\n        raise ValueError('must define at least one ordering operation: < > <= >=')\n    root = max(roots)       # prefer __lt__ to __le__ to __gt__ to __ge__\n    for opname, opfunc in convert[root]:\n        if opname not in roots:\n            opfunc.__name__ = opname\n            opfunc.__doc__ = getattr(int, opname).__doc__\n            setattr(cls, opname, opfunc)\n    return cls\n\ndef cmp_to_key(mycmp):\n    \"\"\"Convert a cmp= function into a key= function\"\"\"\n    class K(object):\n        __slots__ = ['obj']\n        def __init__(self, obj, *args):\n            self.obj = obj\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) < 0\n        def __gt__(self, other):\n            return mycmp(self.obj, other.obj) > 0\n        def __eq__(self, other):\n            return mycmp(self.obj, other.obj) == 0\n        def __le__(self, other):\n            return mycmp(self.obj, other.obj) <= 0\n        def __ge__(self, other):\n            return mycmp(self.obj, other.obj) >= 0\n        def __ne__(self, other):\n            return mycmp(self.obj, other.obj) != 0\n        def __hash__(self):\n            raise TypeError('hash not implemented')\n    return K\n", "description": "SASM - simple crossplatform IDE for NASM, MASM, GAS and FASM assembly languages", "file_name": "functools.py", "id": "8000855d0e8ad6b5fa828ba66d0b75e2", "language": "Python", "project_name": "SASM", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/Dman95-SASM/Dman95-SASM-308c525/Windows/MinGW64/opt/lib/python2.7/functools.py", "save_time": "", "source": "", "update_at": "2018-03-18T15:46:02Z", "url": "https://github.com/Dman95/SASM", "wiki": true}