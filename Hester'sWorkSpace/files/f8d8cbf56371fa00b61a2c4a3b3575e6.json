{"author": "deepfakes", "code": "import argparse\nimport os\nimport sys\nimport time\n\nfrom pathlib import Path\nfrom lib.FaceFilter import FaceFilter\nfrom lib.faces_detect import detect_faces, DetectedFace\nfrom lib.utils import get_image_paths, get_folder, rotate_image\nfrom lib import Serializer\n\nclass FullPaths(argparse.Action):\n    \"\"\"Expand user- and relative-paths\"\"\"\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        setattr(namespace, self.dest, os.path.abspath(\n            os.path.expanduser(values)))\n\nclass FullHelpArgumentParser(argparse.ArgumentParser):\n    \"\"\"\n    Identical to the built-in argument parser, but on error\n    it prints full help message instead of just usage information\n    \"\"\"\n    def error(self, message):\n        self.print_help(sys.stderr)\n        args = {'prog': self.prog, 'message': message}\n        self.exit(2, '%(prog)s: error: %(message)s\\n' % args)\n\nclass DirectoryProcessor(object):\n    \n    arguments = None\n    parser = None\n\n    input_dir = None\n    output_dir = None\n\n    images_found = 0\n    num_faces_detected = 0\n    faces_detected = dict()\n    verify_output = False\n\n    def __init__(self, subparser, command, description='default'):\n        self.create_parser(subparser, command, description)\n        self.parse_arguments(description, subparser, command)\n\n    def process_arguments(self, arguments):\n        self.arguments = arguments\n        print(\"Input Directory: {}\".format(self.arguments.input_dir))\n        print(\"Output Directory: {}\".format(self.arguments.output_dir))\n        print(\"Filter: {}\".format(self.arguments.filter))\n        self.serializer = None\n        if self.arguments.serializer is None and self.arguments.alignments_path is not None:\n            ext = os.path.splitext(self.arguments.alignments_path)[-1]\n            self.serializer = Serializer.get_serializer_fromext(ext)\n            print(self.serializer, self.arguments.alignments_path)\n        else:\n            self.serializer = Serializer.get_serializer(self.arguments.serializer or \"json\")\n        print(\"Using {} serializer\".format(self.serializer.ext))\n\n        print('Starting, this may take a while...')\n        \n        try:\n            if self.arguments.skip_existing:\n                self.already_processed = get_image_paths(self.arguments.output_dir)\n        except AttributeError:\n            pass\n    \n        self.output_dir = get_folder(self.arguments.output_dir)\n\n        try:\n            try:\n                if self.arguments.skip_existing:\n                    self.input_dir = get_image_paths(self.arguments.input_dir, self.already_processed)\n                    print('Excluding %s files' % len(self.already_processed))\n                else:\n                    self.input_dir = get_image_paths(self.arguments.input_dir)\n            except AttributeError:\n                self.input_dir = get_image_paths(self.arguments.input_dir)\n        except:\n            print('Input directory not found. Please ensure it exists.')\n            exit(1)\n\n        self.filter = self.load_filter()\n        self.process()\n        self.finalize()\n\n    def read_alignments(self):\n\n        fn = os.path.join(str(self.arguments.input_dir),\"alignments.{}\".format(self.serializer.ext))\n        if self.arguments.alignments_path is not None:\n            fn = self.arguments.alignments_path\n\n        try:\n            print(\"Reading alignments from: {}\".format(fn))\n            with open(fn, self.serializer.roptions) as f:\n                self.faces_detected = self.serializer.unmarshal(f.read())\n        except Exception as e:\n            print(\"{} not read!\".format(fn))\n            print(str(e))\n            self.faces_detected = dict()\n\n    def write_alignments(self):\n\n        fn = os.path.join(str(self.arguments.input_dir), \"alignments.{}\".format(self.serializer.ext))\n        if self.arguments.alignments_path is not None:\n            fn = self.arguments.alignments_path\n        print(\"Alignments filepath: %s\" % fn)\n        \n        if self.arguments.skip_existing:\n            if os.path.exists(fn):\n                with open(fn, self.serializer.roptions) as inf:\n                    data = self.serializer.unmarshal(inf.read())\n                    for k, v in data.items():\n                        self.faces_detected[k] = v\n            else:\n                print('Existing alignments file \"%s\" not found.' % fn)\n        try:\n            print(\"Writing alignments to: {}\".format(fn))\n            with open(fn, self.serializer.woptions) as fh:\n                fh.write(self.serializer.marshal(self.faces_detected))\n        except Exception as e:\n            print(\"{} not written!\".format(fn))\n            print(str(e))\n            self.faces_detected = dict()\n\n    def read_directory(self):\n        self.images_found = len(self.input_dir)\n        return self.input_dir\n\n    def have_face(self, filename):\n        return os.path.basename(filename) in self.faces_detected\n\n    def have_alignments(self):\n        fn = os.path.join(str(self.arguments.input_dir), \"alignments.{}\".format(self.serializer.ext))\n        return os.path.exists(fn)\n\n    def get_faces_alignments(self, filename, image):\n        faces_count = 0\n        faces = self.faces_detected[os.path.basename(filename)]\n        for rawface in faces:\n            face = DetectedFace(**rawface)\n            \n            if face.r != 0: image = rotate_image(image, face.r)\n            face.image = image[face.y : face.y + face.h, face.x : face.x + face.w]\n            if self.filter is not None and not self.filter.check(face):\n                if self.arguments.verbose:\n                    print('Skipping not recognized face!')\n                continue\n\n            yield faces_count, face\n            self.num_faces_detected += 1\n            faces_count += 1\n        if faces_count > 1 and self.arguments.verbose:\n            print('Note: Found more than one face in an image! File: %s' % filename)\n            self.verify_output = True\n\n    def get_faces(self, image, rotation=0):\n        faces_count = 0\n        faces = detect_faces(image, self.arguments.detector, self.arguments.verbose, rotation)\n        \n        for face in faces:\n            if self.filter is not None and not self.filter.check(face):\n                if self.arguments.verbose:\n                    print('Skipping not recognized face!')\n                continue\n            yield faces_count, face\n\n            self.num_faces_detected += 1\n            faces_count += 1\n\n        if faces_count > 1 and self.arguments.verbose:\n            self.verify_output = True\n\n    def load_filter(self):\n        nfilter_files = self.arguments.nfilter\n        if not isinstance(self.arguments.nfilter, list):\n            nfilter_files = [self.arguments.nfilter]\n        nfilter_files = list(filter(lambda fn: Path(fn).exists(), nfilter_files))\n\n        filter_files = self.arguments.filter\n        if not isinstance(self.arguments.filter, list):\n            filter_files = [self.arguments.filter]\n        filter_files = list(filter(lambda fn: Path(fn).exists(), filter_files))\n        \n        if filter_files:\n            print('Loading reference images for filtering: %s' % filter_files)\n            return FaceFilter(filter_files, nfilter_files, self.arguments.ref_threshold)\n\n    \n    def process(self):\n        \n        raise NotImplementedError()\n\n    def parse_arguments(self, description, subparser, command):\n        self.parser.add_argument('-i', '--input-dir',\n                            action=FullPaths,\n                            dest=\"input_dir\",\n                            default=\"input\",\n                            help=\"Input directory. A directory containing the files \\\n                            you wish to process. Defaults to 'input'\")\n        self.parser.add_argument('-o', '--output-dir',\n                            action=FullPaths,\n                            dest=\"output_dir\",\n                            default=\"output\",\n                            help=\"Output directory. This is where the converted files will \\\n                                be stored. Defaults to 'output'\")\n\n        self.parser.add_argument('--serializer',\n                                type=str.lower,\n                                dest=\"serializer\",\n                                choices=(\"yaml\", \"json\", \"pickle\"),\n                                help=\"serializer for alignments file\")\n\n        self.parser.add_argument('--alignments',\n                                type=str,\n                                dest=\"alignments_path\",\n                                help=\"optional path to alignments file.\")\n\n        self.parser.add_argument('-v', '--verbose',\n                            action=\"store_true\",\n                            dest=\"verbose\",\n                            default=False,\n                            help=\"Show verbose output\")\n        self.parser = self.add_optional_arguments(self.parser)\n        self.parser.set_defaults(func=self.process_arguments)\n\n    def create_parser(self, subparser, command, description):\n        parser = subparser.add_parser(\n            command,\n            description=description,\n            epilog=\"Questions and feedback: \\\n            https://github.com/deepfakes/faceswap-playground\"\n        )\n        return parser\n\n    def add_optional_arguments(self, parser):\n        \n        return parser\n\n    def finalize(self):\n        print('-------------------------')\n        print('Images found:        {}'.format(self.images_found))\n        print('Faces detected:      {}'.format(self.num_faces_detected))\n        print('-------------------------')\n\n        if self.verify_output:\n            print('Note:')\n            print('Multiple faces were detected in one or more pictures.')\n            print('Double check your results.')\n            print('-------------------------')\n        print('Done!')\n", "comments": "   expand user  relative paths         def   call  (self  parser  namespace  values  option string none)          setattr(namespace  self dest  os path abspath(             os path expanduser(values)))  class fullhelpargumentparser(argparse argumentparser)              identical built argument parser  error     prints full help message instead usage information                  abstract class processes directory images     writes output specified folder            rotate image necessary     limit class responsability read files  images faces processed outside class    implement image processing     override custom arguments ", "content": "import argparse\nimport os\nimport sys\nimport time\n\nfrom pathlib import Path\nfrom lib.FaceFilter import FaceFilter\nfrom lib.faces_detect import detect_faces, DetectedFace\nfrom lib.utils import get_image_paths, get_folder, rotate_image\nfrom lib import Serializer\n\nclass FullPaths(argparse.Action):\n    \"\"\"Expand user- and relative-paths\"\"\"\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        setattr(namespace, self.dest, os.path.abspath(\n            os.path.expanduser(values)))\n\nclass FullHelpArgumentParser(argparse.ArgumentParser):\n    \"\"\"\n    Identical to the built-in argument parser, but on error\n    it prints full help message instead of just usage information\n    \"\"\"\n    def error(self, message):\n        self.print_help(sys.stderr)\n        args = {'prog': self.prog, 'message': message}\n        self.exit(2, '%(prog)s: error: %(message)s\\n' % args)\n\nclass DirectoryProcessor(object):\n    '''\n    Abstract class that processes a directory of images\n    and writes output to the specified folder\n    '''\n    arguments = None\n    parser = None\n\n    input_dir = None\n    output_dir = None\n\n    images_found = 0\n    num_faces_detected = 0\n    faces_detected = dict()\n    verify_output = False\n\n    def __init__(self, subparser, command, description='default'):\n        self.create_parser(subparser, command, description)\n        self.parse_arguments(description, subparser, command)\n\n    def process_arguments(self, arguments):\n        self.arguments = arguments\n        print(\"Input Directory: {}\".format(self.arguments.input_dir))\n        print(\"Output Directory: {}\".format(self.arguments.output_dir))\n        print(\"Filter: {}\".format(self.arguments.filter))\n        self.serializer = None\n        if self.arguments.serializer is None and self.arguments.alignments_path is not None:\n            ext = os.path.splitext(self.arguments.alignments_path)[-1]\n            self.serializer = Serializer.get_serializer_fromext(ext)\n            print(self.serializer, self.arguments.alignments_path)\n        else:\n            self.serializer = Serializer.get_serializer(self.arguments.serializer or \"json\")\n        print(\"Using {} serializer\".format(self.serializer.ext))\n\n        print('Starting, this may take a while...')\n        \n        try:\n            if self.arguments.skip_existing:\n                self.already_processed = get_image_paths(self.arguments.output_dir)\n        except AttributeError:\n            pass\n    \n        self.output_dir = get_folder(self.arguments.output_dir)\n\n        try:\n            try:\n                if self.arguments.skip_existing:\n                    self.input_dir = get_image_paths(self.arguments.input_dir, self.already_processed)\n                    print('Excluding %s files' % len(self.already_processed))\n                else:\n                    self.input_dir = get_image_paths(self.arguments.input_dir)\n            except AttributeError:\n                self.input_dir = get_image_paths(self.arguments.input_dir)\n        except:\n            print('Input directory not found. Please ensure it exists.')\n            exit(1)\n\n        self.filter = self.load_filter()\n        self.process()\n        self.finalize()\n\n    def read_alignments(self):\n\n        fn = os.path.join(str(self.arguments.input_dir),\"alignments.{}\".format(self.serializer.ext))\n        if self.arguments.alignments_path is not None:\n            fn = self.arguments.alignments_path\n\n        try:\n            print(\"Reading alignments from: {}\".format(fn))\n            with open(fn, self.serializer.roptions) as f:\n                self.faces_detected = self.serializer.unmarshal(f.read())\n        except Exception as e:\n            print(\"{} not read!\".format(fn))\n            print(str(e))\n            self.faces_detected = dict()\n\n    def write_alignments(self):\n\n        fn = os.path.join(str(self.arguments.input_dir), \"alignments.{}\".format(self.serializer.ext))\n        if self.arguments.alignments_path is not None:\n            fn = self.arguments.alignments_path\n        print(\"Alignments filepath: %s\" % fn)\n        \n        if self.arguments.skip_existing:\n            if os.path.exists(fn):\n                with open(fn, self.serializer.roptions) as inf:\n                    data = self.serializer.unmarshal(inf.read())\n                    for k, v in data.items():\n                        self.faces_detected[k] = v\n            else:\n                print('Existing alignments file \"%s\" not found.' % fn)\n        try:\n            print(\"Writing alignments to: {}\".format(fn))\n            with open(fn, self.serializer.woptions) as fh:\n                fh.write(self.serializer.marshal(self.faces_detected))\n        except Exception as e:\n            print(\"{} not written!\".format(fn))\n            print(str(e))\n            self.faces_detected = dict()\n\n    def read_directory(self):\n        self.images_found = len(self.input_dir)\n        return self.input_dir\n\n    def have_face(self, filename):\n        return os.path.basename(filename) in self.faces_detected\n\n    def have_alignments(self):\n        fn = os.path.join(str(self.arguments.input_dir), \"alignments.{}\".format(self.serializer.ext))\n        return os.path.exists(fn)\n\n    def get_faces_alignments(self, filename, image):\n        faces_count = 0\n        faces = self.faces_detected[os.path.basename(filename)]\n        for rawface in faces:\n            face = DetectedFace(**rawface)\n            # Rotate the image if necessary\n            if face.r != 0: image = rotate_image(image, face.r)\n            face.image = image[face.y : face.y + face.h, face.x : face.x + face.w]\n            if self.filter is not None and not self.filter.check(face):\n                if self.arguments.verbose:\n                    print('Skipping not recognized face!')\n                continue\n\n            yield faces_count, face\n            self.num_faces_detected += 1\n            faces_count += 1\n        if faces_count > 1 and self.arguments.verbose:\n            print('Note: Found more than one face in an image! File: %s' % filename)\n            self.verify_output = True\n\n    def get_faces(self, image, rotation=0):\n        faces_count = 0\n        faces = detect_faces(image, self.arguments.detector, self.arguments.verbose, rotation)\n        \n        for face in faces:\n            if self.filter is not None and not self.filter.check(face):\n                if self.arguments.verbose:\n                    print('Skipping not recognized face!')\n                continue\n            yield faces_count, face\n\n            self.num_faces_detected += 1\n            faces_count += 1\n\n        if faces_count > 1 and self.arguments.verbose:\n            self.verify_output = True\n\n    def load_filter(self):\n        nfilter_files = self.arguments.nfilter\n        if not isinstance(self.arguments.nfilter, list):\n            nfilter_files = [self.arguments.nfilter]\n        nfilter_files = list(filter(lambda fn: Path(fn).exists(), nfilter_files))\n\n        filter_files = self.arguments.filter\n        if not isinstance(self.arguments.filter, list):\n            filter_files = [self.arguments.filter]\n        filter_files = list(filter(lambda fn: Path(fn).exists(), filter_files))\n        \n        if filter_files:\n            print('Loading reference images for filtering: %s' % filter_files)\n            return FaceFilter(filter_files, nfilter_files, self.arguments.ref_threshold)\n\n    # for now, we limit this class responsability to the read of files. images and faces are processed outside this class\n    def process(self):\n        # implement your image processing!\n        raise NotImplementedError()\n\n    def parse_arguments(self, description, subparser, command):\n        self.parser.add_argument('-i', '--input-dir',\n                            action=FullPaths,\n                            dest=\"input_dir\",\n                            default=\"input\",\n                            help=\"Input directory. A directory containing the files \\\n                            you wish to process. Defaults to 'input'\")\n        self.parser.add_argument('-o', '--output-dir',\n                            action=FullPaths,\n                            dest=\"output_dir\",\n                            default=\"output\",\n                            help=\"Output directory. This is where the converted files will \\\n                                be stored. Defaults to 'output'\")\n\n        self.parser.add_argument('--serializer',\n                                type=str.lower,\n                                dest=\"serializer\",\n                                choices=(\"yaml\", \"json\", \"pickle\"),\n                                help=\"serializer for alignments file\")\n\n        self.parser.add_argument('--alignments',\n                                type=str,\n                                dest=\"alignments_path\",\n                                help=\"optional path to alignments file.\")\n\n        self.parser.add_argument('-v', '--verbose',\n                            action=\"store_true\",\n                            dest=\"verbose\",\n                            default=False,\n                            help=\"Show verbose output\")\n        self.parser = self.add_optional_arguments(self.parser)\n        self.parser.set_defaults(func=self.process_arguments)\n\n    def create_parser(self, subparser, command, description):\n        parser = subparser.add_parser(\n            command,\n            description=description,\n            epilog=\"Questions and feedback: \\\n            https://github.com/deepfakes/faceswap-playground\"\n        )\n        return parser\n\n    def add_optional_arguments(self, parser):\n        # Override this for custom arguments\n        return parser\n\n    def finalize(self):\n        print('-------------------------')\n        print('Images found:        {}'.format(self.images_found))\n        print('Faces detected:      {}'.format(self.num_faces_detected))\n        print('-------------------------')\n\n        if self.verify_output:\n            print('Note:')\n            print('Multiple faces were detected in one or more pictures.')\n            print('Double check your results.')\n            print('-------------------------')\n        print('Done!')\n", "description": "Non official project based on original /r/Deepfakes thread. Many thanks to him!", "file_name": "cli.py", "id": "f8d8cbf56371fa00b61a2c4a3b3575e6", "language": "Python", "project_name": "faceswap", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/deepfakes-faceswap/deepfakes-faceswap-6ff64ef/lib/cli.py", "save_time": "", "source": "", "update_at": "2018-03-18T16:27:43Z", "url": "https://github.com/deepfakes/faceswap", "wiki": true}