{"author": "ansible", "code": "# Copyright (c) 2017 Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\n\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\nimport re\n\nfrom copy import deepcopy\n\nfrom ansible import constants as C\nfrom ansible.module_utils._text import to_text\nfrom ansible.module_utils.six import string_types\nfrom ansible.plugins.loader import connection_loader\n\ntry:\n    from __main__ import display\nexcept ImportError:\n    from ansible.utils.display import Display\n    display = Display()\n\n\ndef strip_internal_keys(dirty, exceptions=None):\n    '''\n    All keys starting with _ansible_ are internal, so create a copy of the 'dirty' dict\n    and remove them from the clean one before returning it\n    '''\n\n    if exceptions is None:\n        exceptions = ()\n    clean = dirty.copy()\n    for k in dirty.keys():\n        if isinstance(k, string_types) and k.startswith('_ansible_'):\n            if k not in exceptions:\n                del clean[k]\n        elif isinstance(dirty[k], dict):\n            clean[k] = strip_internal_keys(dirty[k])\n    return clean\n\n\ndef remove_internal_keys(data):\n    '''\n    More nuanced version of strip_internal_keys\n    '''\n    for key in list(data.keys()):\n        if (key.startswith('_ansible_') and key != '_ansible_parsed') or key in C.INTERNAL_RESULT_KEYS:\n            display.warning(\"Removed unexpected internal key in module return: %s = %s\" % (key, data[key]))\n            del data[key]\n\n    \n    for key in ['warnings', 'deprecations']:\n        if key in data and not data[key]:\n            del data[key]\n\n\ndef clean_facts(facts):\n    ''' remove facts that can override internal keys or otherwise deemed unsafe '''\n    data = deepcopy(facts)\n\n    remove_keys = set()\n    fact_keys = set(data.keys())\n    \n    \n    for magic_var in C.MAGIC_VARIABLE_MAPPING:\n        remove_keys.update(fact_keys.intersection(C.MAGIC_VARIABLE_MAPPING[magic_var]))\n    \n    for conn_path in connection_loader.all(path_only=True):\n        try:\n            conn_name = os.path.splitext(os.path.basename(conn_path))[0]\n            re_key = re.compile('^ansible_%s_' % conn_name)\n            for fact_key in fact_keys:\n                \n                if re_key.match(fact_key) and not fact_key.endswith(('_bridge', '_gwbridge')):\n                    remove_keys.add(fact_key)\n        except AttributeError:\n            pass\n\n    \n    for hard in C.RESTRICTED_RESULT_KEYS + C.INTERNAL_RESULT_KEYS:\n        if hard in fact_keys:\n            remove_keys.add(hard)\n\n    \n    re_interp = re.compile('^ansible_.*_interpreter$')\n    for fact_key in fact_keys:\n        if re_interp.match(fact_key):\n            remove_keys.add(fact_key)\n    # then we remove them (except for ssh host keys)\n    for r_key in remove_keys:\n        if not r_key.startswith('ansible_ssh_host_key_'):\n            try:\n                r_val = to_text(data[r_key])\n                if len(r_val) > 24:\n                    r_val = '%s ... %s' % (r_val[:13], r_val[-6:])\n            except Exception:\n                r_val = ' <failed to convert value to a string> '\n            display.warning(\"Removed restricted key from module data: %s = %s\" % (r_key, r_val))\n            del data[r_key]\n\n    return strip_internal_keys(data)\n\n\ndef namespace_facts(facts):\n    ''' return all facts inside 'ansible_facts' w/o an ansible_ prefix '''\n    deprefixed = {}\n    for k in facts:\n        if k in ('ansible_local',):\n            \n            deprefixed[k] = deepcopy(facts[k])\n        else:\n            deprefixed[k.replace('ansible_', '', 1)] = deepcopy(facts[k])\n\n    return {'ansible_facts': deprefixed}\n", "comments": "        all keys starting  ansible  internal  create copy  dirty  dict     remove clean one returning              exceptions none          exceptions   ()     clean   dirty copy()     k dirty keys()          isinstance(k  string types) k startswith(  ansible  )              k exceptions                  del clean k          elif isinstance(dirty k   dict)              clean k    strip internal keys(dirty k )     return clean   def remove internal keys(data)              more nuanced version strip internal keys             key list(data keys())          (key startswith(  ansible  ) key      ansible parsed ) key c internal result keys              display warning( removed unexpected internal key module return         (key  data key ))             del data key         remove bad empty internal keys     key   warnings    deprecations            key data data key               del data key    def clean facts(facts)          remove facts override internal keys otherwise deemed unsafe         data   deepcopy(facts)      remove keys   set()     fact keys   set(data keys())       first add magic variable names set       keys want remove facts     magic var c magic variable mapping          remove keys update(fact keys intersection(c magic variable mapping magic var ))       next remove connection plugin specific vars     conn path connection loader all(path true)          try              conn name   os path splitext(os path basename(conn path)) 0              key   compile(  ansible      conn name)             fact key fact keys                    lightweight vm container tech creates devices pattern  avoids filtering                 key match(fact key) fact key endswith((  bridge     gwbridge ))                      remove keys add(fact key)         except attributeerror              pass        remove known keys     hard c restricted result keys   c internal result keys          hard fact keys              remove keys add(hard)        finally  search interpreter keys remove     interp   compile(  ansible    interpreter  )     fact key fact keys          interp match(fact key)              remove keys add(fact key)       remove (except ssh host keys)     r key remove keys          r key startswith( ansible ssh host key  )              try                  r val   text(data r key )                 len(r val)   24                      r val             (r val  13   r val  6  )             except exception                  r val      failed convert value string                display warning( removed restricted key module data         (r key  r val))             del data r key       return strip internal keys(data)   def namespace facts(facts)          return facts inside  ansible facts  w ansible  prefix        copyright (c) 2017 ansible project    gnu general public license v3 0  (see copying https   www gnu org licenses gpl 3 0 txt)    make coding python3 ish    remove bad empty internal keys    first add magic variable names set    keys want remove facts    next remove connection plugin specific vars    lightweight vm container tech creates devices pattern  avoids filtering    remove known keys    finally  search interpreter keys remove    remove (except ssh host keys)    exceptions  deprefixing  ", "content": "# Copyright (c) 2017 Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport os\nimport re\n\nfrom copy import deepcopy\n\nfrom ansible import constants as C\nfrom ansible.module_utils._text import to_text\nfrom ansible.module_utils.six import string_types\nfrom ansible.plugins.loader import connection_loader\n\ntry:\n    from __main__ import display\nexcept ImportError:\n    from ansible.utils.display import Display\n    display = Display()\n\n\ndef strip_internal_keys(dirty, exceptions=None):\n    '''\n    All keys starting with _ansible_ are internal, so create a copy of the 'dirty' dict\n    and remove them from the clean one before returning it\n    '''\n\n    if exceptions is None:\n        exceptions = ()\n    clean = dirty.copy()\n    for k in dirty.keys():\n        if isinstance(k, string_types) and k.startswith('_ansible_'):\n            if k not in exceptions:\n                del clean[k]\n        elif isinstance(dirty[k], dict):\n            clean[k] = strip_internal_keys(dirty[k])\n    return clean\n\n\ndef remove_internal_keys(data):\n    '''\n    More nuanced version of strip_internal_keys\n    '''\n    for key in list(data.keys()):\n        if (key.startswith('_ansible_') and key != '_ansible_parsed') or key in C.INTERNAL_RESULT_KEYS:\n            display.warning(\"Removed unexpected internal key in module return: %s = %s\" % (key, data[key]))\n            del data[key]\n\n    # remove bad/empty internal keys\n    for key in ['warnings', 'deprecations']:\n        if key in data and not data[key]:\n            del data[key]\n\n\ndef clean_facts(facts):\n    ''' remove facts that can override internal keys or otherwise deemed unsafe '''\n    data = deepcopy(facts)\n\n    remove_keys = set()\n    fact_keys = set(data.keys())\n    # first we add all of our magic variable names to the set of\n    # keys we want to remove from facts\n    for magic_var in C.MAGIC_VARIABLE_MAPPING:\n        remove_keys.update(fact_keys.intersection(C.MAGIC_VARIABLE_MAPPING[magic_var]))\n    # next we remove any connection plugin specific vars\n    for conn_path in connection_loader.all(path_only=True):\n        try:\n            conn_name = os.path.splitext(os.path.basename(conn_path))[0]\n            re_key = re.compile('^ansible_%s_' % conn_name)\n            for fact_key in fact_keys:\n                # most lightweight VM or container tech creates devices with this pattern, this avoids filtering them out\n                if re_key.match(fact_key) and not fact_key.endswith(('_bridge', '_gwbridge')):\n                    remove_keys.add(fact_key)\n        except AttributeError:\n            pass\n\n    # remove some KNOWN keys\n    for hard in C.RESTRICTED_RESULT_KEYS + C.INTERNAL_RESULT_KEYS:\n        if hard in fact_keys:\n            remove_keys.add(hard)\n\n    # finally, we search for interpreter keys to remove\n    re_interp = re.compile('^ansible_.*_interpreter$')\n    for fact_key in fact_keys:\n        if re_interp.match(fact_key):\n            remove_keys.add(fact_key)\n    # then we remove them (except for ssh host keys)\n    for r_key in remove_keys:\n        if not r_key.startswith('ansible_ssh_host_key_'):\n            try:\n                r_val = to_text(data[r_key])\n                if len(r_val) > 24:\n                    r_val = '%s ... %s' % (r_val[:13], r_val[-6:])\n            except Exception:\n                r_val = ' <failed to convert value to a string> '\n            display.warning(\"Removed restricted key from module data: %s = %s\" % (r_key, r_val))\n            del data[r_key]\n\n    return strip_internal_keys(data)\n\n\ndef namespace_facts(facts):\n    ''' return all facts inside 'ansible_facts' w/o an ansible_ prefix '''\n    deprefixed = {}\n    for k in facts:\n        if k in ('ansible_local',):\n            # exceptions to 'deprefixing'\n            deprefixed[k] = deepcopy(facts[k])\n        else:\n            deprefixed[k.replace('ansible_', '', 1)] = deepcopy(facts[k])\n\n    return {'ansible_facts': deprefixed}\n", "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications\u2014 automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.", "file_name": "clean.py", "id": "185c2500154605f641fa88d3081d66b2", "language": "Python", "project_name": "ansible", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/ansible-ansible/ansible-ansible-d30554b/lib/ansible/vars/clean.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:28Z", "url": "https://github.com/ansible/ansible", "wiki": false}