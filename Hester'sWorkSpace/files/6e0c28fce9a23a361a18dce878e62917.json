{"author": "XX-net", "code": "import threading\nimport select\nimport time\n\nimport utils\n\nimport global_var as g\nfrom xlog import getLogger\nxlog = getLogger(\"smart_router\")\n\n\nclass PipeSocks(object):\n    def __init__(self, buf_size=16*1024):\n        self.buf_size = buf_size\n        self.sock_dict = {}\n\n        self.read_set = []\n        self.write_set = []\n        self.error_set = []\n\n        self.running = True\n\n    def __str__(self):\n        outs = [\"Pipe Sockets:\"]\n        outs.append(\"buf_size=%d\" % self.buf_size)\n        outs.append(\"running=%d\" % self.running)\n        outs.append(\"\")\n        outs.append(\"socket dict:\")\n        for s in self.sock_dict:\n            outs.append(\" %s =%s\" % (s, self.sock_dict[s]))\n\n        outs.append(\"read dict:\")\n        for s in self.read_set:\n            outs.append(\" %s\" % s)\n\n        outs.append(\"write dict:\")\n        for s in self.write_set:\n            outs.append(\" %s\" % s)\n\n        outs.append(\"error dict:\")\n        for s in self.error_set:\n            outs.append(\" %s\" % s)\n\n        return \"\\n\".join(outs)\n\n    def run(self):\n        self.down_th = threading.Thread(target=self.pipe)\n        self.down_th.start()\n\n    def stop(self):\n        self.running = False\n\n    def add_socks(self, s1, s2):\n        s1.setblocking(0)\n        s2.setblocking(0)\n\n        self.read_set.append(s1)\n        self.read_set.append(s2)\n        self.error_set.append(s1)\n        self.error_set.append(s2)\n\n        self.sock_dict[s1] = s2\n        self.sock_dict[s2] = s1\n\n    def try_remove(self, l, s):\n        try:\n            l.remove(s)\n        except:\n            pass\n\n    def close(self, s1, e):\n        if s1 not in self.sock_dict:\n            # xlog.warn(\"sock not in dict\")\n            return\n\n        s2 = self.sock_dict[s1]\n\n        if utils.is_private_ip(s1.ip):\n            local_sock = s1\n            remote_sock = s2\n        else:\n            local_sock = s2\n            remote_sock = s1\n\n        create_time = time.time() - remote_sock.create_time\n        xlog.debug(\"pipe close %s->%s run_time:%d upload:%d,%d download:%d,%d, by remote:%d, left:%d e:%r\",\n                   local_sock, remote_sock, create_time,\n                   local_sock.recved_data, local_sock.recved_times,\n                   remote_sock.recved_data, remote_sock.recved_times,\n                   s1==remote_sock, s1.buf_size, e)\n\n        if local_sock.recved_data > 0 and local_sock.recved_times == 1 and remote_sock.port == 443 and \\\n                ((s1 == local_sock and create_time > 30) or (s1 == remote_sock)):\n            host = remote_sock.host\n            xlog.debug(\"SNI:%s fail.\", host)\n            #g.domain_cache.update_rule(host, 443, \"gae\")\n\n        del self.sock_dict[s1]\n        self.try_remove(self.read_set, s1)\n        self.try_remove(self.write_set, s1)\n        self.try_remove(self.error_set, s1)\n        s1.close()\n\n        if s2.buf_size:\n            xlog.debug(\"pipe close %s e:%s, but s2:%s have data(%d) to send\",\n                       s1, e, s2, s2.buf_size)\n            s2.add_dat(\"\")\n            return\n\n        if s2 in self.sock_dict:\n            del self.sock_dict[s2]\n            self.try_remove(self.read_set, s2)\n            self.try_remove(self.write_set, s2)\n            self.try_remove(self.error_set, s2)\n            s2.close()\n\n    def pipe(self):\n        def flush_send_s(s2, d1):\n            s2.setblocking(1)\n            s2.settimeout(1)\n            s2.sendall(d1)\n            s2.setblocking(0)\n\n        while self.running:\n            if not self.error_set:\n                time.sleep(1)\n                continue\n\n            try:\n                r, w, e = select.select(self.read_set, self.write_set, self.error_set, 0.1)\n                for s1 in list(r):\n                    if s1 not in self.read_set:\n                        continue\n\n                    try:\n                        d = s1.recv(65535)\n                    except Exception as e:\n                        self.close(s1, \"r\")\n                        continue\n\n                    if not d:\n                        \n                        self.close(s1, \"r\")\n                        continue\n\n                    s1.recved_data += len(d)\n                    s1.recved_times += 1\n\n                    s2 = self.sock_dict[s1]\n                    if s2.is_closed():\n                        continue\n\n                    if g.config.direct_split_SNI and\\\n                                    s1.recved_times == 1 and \\\n                                    s2.port == 443 and \\\n                                    d[0] == '\\x16' and \\\n                            g.gfwlist.check(s2.host):\n                        p1 = d.find(s2.host)\n                        if p1 > 1:\n                            if \"google\" in s2.host:\n                                p2 = d.find(\"google\") + 3\n                            else:\n                                p2 = p1 + len(s2.host) - 6\n\n                            d1 = d[:p2]\n                            d2 = d[p2:]\n\n                            try:\n                                flush_send_s(s2, d1)\n                            except Exception as e:\n                                xlog.warn(\"send split SNI:%s fail:%r\", s2.host, e)\n                                self.close(s2, \"w\")\n                                continue\n\n                            s2.add_dat(d2)\n                            d = \"\"\n                            xlog.debug(\"pipe send split SNI:%s\", s2.host)\n\n                    if s2.buf_size == 0:\n                        try:\n                            sended = s2.send(d)\n                            # xlog.debug(\"direct send %d to %s from:%s\", sended, s2, s1)\n                        except Exception as e:\n                            self.close(s2, \"w\")\n                            continue\n\n                        if sended == len(d):\n                            continue\n                        else:\n                            d_view = memoryview(d)\n                            d = d_view[sended:]\n\n                    if d:\n                        if not isinstance(d, memoryview):\n                            d = memoryview(d)\n                        s2.add_dat(d)\n\n                    if s2 not in self.write_set:\n                        self.write_set.append(s2)\n                    if s2.buf_size > self.buf_size:\n                        self.try_remove(self.read_set, s1)\n\n                for s1 in list(w):\n                    if s1 not in self.write_set:\n                        continue\n\n                    if s1.buf_num == 0:\n                        self.try_remove(self.write_set, s1)\n                        continue\n\n                    while True:\n                        dat = s1.get_dat()\n                        if not dat:\n                            self.close(s1, \"n\")\n                            break\n\n                        try:\n                            sended = s1.send(dat)\n                        except Exception as e:\n                            self.close(s1, \"w\")\n                            break\n\n                        if len(dat) - sended > 0:\n                            s1.restore_dat(dat[sended:])\n                            break\n\n                    if s1.buf_size == 0:\n                        self.try_remove(self.write_set, s1)\n\n                    if s1.buf_size < self.buf_size:\n                        if s1 not in self.sock_dict:\n                            continue\n\n                        s2 = self.sock_dict[s1]\n                        if s2 not in self.read_set and s2 in self.sock_dict:\n                            self.read_set.append(s2)\n\n                for s1 in list(e):\n                    self.close(s1, \"e\")\n            except Exception as e:\n                xlog.exception(\"pipe except:%r\", e)\n\n        for s in list(self.error_set):\n            self.close(s, \"stop\")\n\n        xlog.info(\"pipe stopped.\")", "comments": "  xlog warn( sock dict )   g domain cache update rule(host  443   gae )    socket closed peer     xlog debug( direct send      sended  s2  s1) ", "content": "import threading\nimport select\nimport time\n\nimport utils\n\nimport global_var as g\nfrom xlog import getLogger\nxlog = getLogger(\"smart_router\")\n\n\nclass PipeSocks(object):\n    def __init__(self, buf_size=16*1024):\n        self.buf_size = buf_size\n        self.sock_dict = {}\n\n        self.read_set = []\n        self.write_set = []\n        self.error_set = []\n\n        self.running = True\n\n    def __str__(self):\n        outs = [\"Pipe Sockets:\"]\n        outs.append(\"buf_size=%d\" % self.buf_size)\n        outs.append(\"running=%d\" % self.running)\n        outs.append(\"\")\n        outs.append(\"socket dict:\")\n        for s in self.sock_dict:\n            outs.append(\" %s =%s\" % (s, self.sock_dict[s]))\n\n        outs.append(\"read dict:\")\n        for s in self.read_set:\n            outs.append(\" %s\" % s)\n\n        outs.append(\"write dict:\")\n        for s in self.write_set:\n            outs.append(\" %s\" % s)\n\n        outs.append(\"error dict:\")\n        for s in self.error_set:\n            outs.append(\" %s\" % s)\n\n        return \"\\n\".join(outs)\n\n    def run(self):\n        self.down_th = threading.Thread(target=self.pipe)\n        self.down_th.start()\n\n    def stop(self):\n        self.running = False\n\n    def add_socks(self, s1, s2):\n        s1.setblocking(0)\n        s2.setblocking(0)\n\n        self.read_set.append(s1)\n        self.read_set.append(s2)\n        self.error_set.append(s1)\n        self.error_set.append(s2)\n\n        self.sock_dict[s1] = s2\n        self.sock_dict[s2] = s1\n\n    def try_remove(self, l, s):\n        try:\n            l.remove(s)\n        except:\n            pass\n\n    def close(self, s1, e):\n        if s1 not in self.sock_dict:\n            # xlog.warn(\"sock not in dict\")\n            return\n\n        s2 = self.sock_dict[s1]\n\n        if utils.is_private_ip(s1.ip):\n            local_sock = s1\n            remote_sock = s2\n        else:\n            local_sock = s2\n            remote_sock = s1\n\n        create_time = time.time() - remote_sock.create_time\n        xlog.debug(\"pipe close %s->%s run_time:%d upload:%d,%d download:%d,%d, by remote:%d, left:%d e:%r\",\n                   local_sock, remote_sock, create_time,\n                   local_sock.recved_data, local_sock.recved_times,\n                   remote_sock.recved_data, remote_sock.recved_times,\n                   s1==remote_sock, s1.buf_size, e)\n\n        if local_sock.recved_data > 0 and local_sock.recved_times == 1 and remote_sock.port == 443 and \\\n                ((s1 == local_sock and create_time > 30) or (s1 == remote_sock)):\n            host = remote_sock.host\n            xlog.debug(\"SNI:%s fail.\", host)\n            #g.domain_cache.update_rule(host, 443, \"gae\")\n\n        del self.sock_dict[s1]\n        self.try_remove(self.read_set, s1)\n        self.try_remove(self.write_set, s1)\n        self.try_remove(self.error_set, s1)\n        s1.close()\n\n        if s2.buf_size:\n            xlog.debug(\"pipe close %s e:%s, but s2:%s have data(%d) to send\",\n                       s1, e, s2, s2.buf_size)\n            s2.add_dat(\"\")\n            return\n\n        if s2 in self.sock_dict:\n            del self.sock_dict[s2]\n            self.try_remove(self.read_set, s2)\n            self.try_remove(self.write_set, s2)\n            self.try_remove(self.error_set, s2)\n            s2.close()\n\n    def pipe(self):\n        def flush_send_s(s2, d1):\n            s2.setblocking(1)\n            s2.settimeout(1)\n            s2.sendall(d1)\n            s2.setblocking(0)\n\n        while self.running:\n            if not self.error_set:\n                time.sleep(1)\n                continue\n\n            try:\n                r, w, e = select.select(self.read_set, self.write_set, self.error_set, 0.1)\n                for s1 in list(r):\n                    if s1 not in self.read_set:\n                        continue\n\n                    try:\n                        d = s1.recv(65535)\n                    except Exception as e:\n                        self.close(s1, \"r\")\n                        continue\n\n                    if not d:\n                        # socket closed by peer.\n                        self.close(s1, \"r\")\n                        continue\n\n                    s1.recved_data += len(d)\n                    s1.recved_times += 1\n\n                    s2 = self.sock_dict[s1]\n                    if s2.is_closed():\n                        continue\n\n                    if g.config.direct_split_SNI and\\\n                                    s1.recved_times == 1 and \\\n                                    s2.port == 443 and \\\n                                    d[0] == '\\x16' and \\\n                            g.gfwlist.check(s2.host):\n                        p1 = d.find(s2.host)\n                        if p1 > 1:\n                            if \"google\" in s2.host:\n                                p2 = d.find(\"google\") + 3\n                            else:\n                                p2 = p1 + len(s2.host) - 6\n\n                            d1 = d[:p2]\n                            d2 = d[p2:]\n\n                            try:\n                                flush_send_s(s2, d1)\n                            except Exception as e:\n                                xlog.warn(\"send split SNI:%s fail:%r\", s2.host, e)\n                                self.close(s2, \"w\")\n                                continue\n\n                            s2.add_dat(d2)\n                            d = \"\"\n                            xlog.debug(\"pipe send split SNI:%s\", s2.host)\n\n                    if s2.buf_size == 0:\n                        try:\n                            sended = s2.send(d)\n                            # xlog.debug(\"direct send %d to %s from:%s\", sended, s2, s1)\n                        except Exception as e:\n                            self.close(s2, \"w\")\n                            continue\n\n                        if sended == len(d):\n                            continue\n                        else:\n                            d_view = memoryview(d)\n                            d = d_view[sended:]\n\n                    if d:\n                        if not isinstance(d, memoryview):\n                            d = memoryview(d)\n                        s2.add_dat(d)\n\n                    if s2 not in self.write_set:\n                        self.write_set.append(s2)\n                    if s2.buf_size > self.buf_size:\n                        self.try_remove(self.read_set, s1)\n\n                for s1 in list(w):\n                    if s1 not in self.write_set:\n                        continue\n\n                    if s1.buf_num == 0:\n                        self.try_remove(self.write_set, s1)\n                        continue\n\n                    while True:\n                        dat = s1.get_dat()\n                        if not dat:\n                            self.close(s1, \"n\")\n                            break\n\n                        try:\n                            sended = s1.send(dat)\n                        except Exception as e:\n                            self.close(s1, \"w\")\n                            break\n\n                        if len(dat) - sended > 0:\n                            s1.restore_dat(dat[sended:])\n                            break\n\n                    if s1.buf_size == 0:\n                        self.try_remove(self.write_set, s1)\n\n                    if s1.buf_size < self.buf_size:\n                        if s1 not in self.sock_dict:\n                            continue\n\n                        s2 = self.sock_dict[s1]\n                        if s2 not in self.read_set and s2 in self.sock_dict:\n                            self.read_set.append(s2)\n\n                for s1 in list(e):\n                    self.close(s1, \"e\")\n            except Exception as e:\n                xlog.exception(\"pipe except:%r\", e)\n\n        for s in list(self.error_set):\n            self.close(s, \"stop\")\n\n        xlog.info(\"pipe stopped.\")", "description": "a web proxy tool", "file_name": "pipe_socks.py", "id": "6e0c28fce9a23a361a18dce878e62917", "language": "Python", "project_name": "XX-Net", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/XX-net-XX-Net/XX-net-XX-Net-673a005/code/default/smart_router/local/pipe_socks.py", "save_time": "", "source": "", "update_at": "2018-03-18T14:08:03Z", "url": "https://github.com/XX-net/XX-Net", "wiki": true}