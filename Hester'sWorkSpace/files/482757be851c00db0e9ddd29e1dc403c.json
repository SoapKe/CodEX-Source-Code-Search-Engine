{"author": "tensorflow", "code": "\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\"\"\"Generate melodies from a trained checkpoint of a melody RNN model.\"\"\"\n\nimport ast\nimport os\nimport time\n\n internal imports\n\nimport tensorflow as tf\nimport magenta\n\nfrom magenta.models.melody_rnn import melody_rnn_config_flags\nfrom magenta.models.melody_rnn import melody_rnn_model\nfrom magenta.models.melody_rnn import melody_rnn_sequence_generator\nfrom magenta.protobuf import generator_pb2\nfrom magenta.protobuf import music_pb2\n\nFLAGS = tf.app.flags.FLAGS\ntf.app.flags.DEFINE_string(\n    'run_dir', None,\n    'Path to the directory where the latest checkpoint will be loaded from.')\ntf.app.flags.DEFINE_string(\n    'checkpoint_file', None,\n    'Path to the checkpoint file. run_dir will take priority over this flag.')\ntf.app.flags.DEFINE_string(\n    'bundle_file', None,\n    'Path to the bundle file. If specified, this will take priority over '\n    'run_dir and checkpoint_file, unless save_generator_bundle is True, in '\n    'which case both this flag and either run_dir or checkpoint_file are '\n    'required')\ntf.app.flags.DEFINE_boolean(\n    'save_generator_bundle', False,\n    'If true, instead of generating a sequence, will save this generator as a '\n    'bundle file in the location specified by the bundle_file flag')\ntf.app.flags.DEFINE_string(\n    'bundle_description', None,\n    'A short, human-readable text description of the bundle (e.g., training '\n    'data, hyper parameters, etc.).')\ntf.app.flags.DEFINE_string(\n    'output_dir', '/tmp/melody_rnn/generated',\n    'The directory where MIDI files will be saved to.')\ntf.app.flags.DEFINE_integer(\n    'num_outputs', 10,\n    'The number of melodies to generate. One MIDI file will be created for '\n    'each.')\ntf.app.flags.DEFINE_integer(\n    'num_steps', 128,\n    'The total number of steps the generated melodies should be, priming '\n    'melody length + generated steps. Each step is a 16th of a bar.')\ntf.app.flags.DEFINE_string(\n    'primer_melody', '',\n    'A string representation of a Python list of '\n    'magenta.music.Melody event values. For example: '\n    '\"[60, -2, 60, -2, 67, -2, 67, -2]\". If specified, this melody will be '\n    'used as the priming melody. If a priming melody is not specified, '\n    'melodies will be generated from scratch.')\ntf.app.flags.DEFINE_string(\n    'primer_midi', '',\n    'The path to a MIDI file containing a melody that will be used as a '\n    'priming melody. If a primer melody is not specified, melodies will be '\n    'generated from scratch.')\ntf.app.flags.DEFINE_float(\n    'qpm', None,\n    'The quarters per minute to play generated output at. If a primer MIDI is '\n    'given, the qpm from that will override this flag. If qpm is None, qpm '\n    'will default to 120.')\ntf.app.flags.DEFINE_float(\n    'temperature', 1.0,\n    'The randomness of the generated melodies. 1.0 uses the unaltered softmax '\n    'probabilities, greater than 1.0 makes melodies more random, less than 1.0 '\n    'makes melodies less random.')\ntf.app.flags.DEFINE_integer(\n    'beam_size', 1,\n    'The beam size to use for beam search when generating melodies.')\ntf.app.flags.DEFINE_integer(\n    'branch_factor', 1,\n    'The branch factor to use for beam search when generating melodies.')\ntf.app.flags.DEFINE_integer(\n    'steps_per_iteration', 1,\n    'The number of melody steps to take per beam search iteration.')\ntf.app.flags.DEFINE_string(\n    'log', 'INFO',\n    'The threshold for what messages will be logged DEBUG, INFO, WARN, ERROR, '\n    'or FATAL.')\n\n\ndef get_checkpoint():\n  \"\"\"Get the training dir or checkpoint path to be used by the model.\"\"\"\n  if ((FLAGS.run_dir or FLAGS.checkpoint_file) and\n      FLAGS.bundle_file and not FLAGS.save_generator_bundle):\n    raise magenta.music.SequenceGeneratorException(\n        'Cannot specify both bundle_file and run_dir or checkpoint_file')\n  if FLAGS.run_dir:\n    train_dir = os.path.join(os.path.expanduser(FLAGS.run_dir), 'train')\n    return train_dir\n  elif FLAGS.checkpoint_file:\n    return os.path.expanduser(FLAGS.checkpoint_file)\n  else:\n    return None\n\n\ndef get_bundle():\n  \"\"\"Returns a generator_pb2.GeneratorBundle object based read from bundle_file.\n\n  Returns:\n    Either a generator_pb2.GeneratorBundle or None if the bundle_file flag is\n    not set or the save_generator_bundle flag is set.\n  \"\"\"\n  if FLAGS.save_generator_bundle:\n    return None\n  if FLAGS.bundle_file is None:\n    return None\n  bundle_file = os.path.expanduser(FLAGS.bundle_file)\n  return magenta.music.read_bundle_file(bundle_file)\n\n\ndef run_with_flags(generator):\n  \"\"\"Generates melodies and saves them as MIDI files.\n\n  Uses the options specified by the flags defined in this module.\n\n  Args:\n    generator: The MelodyRnnSequenceGenerator to use for generation.\n  \"\"\"\n  if not FLAGS.output_dir:\n    tf.logging.fatal('--output_dir required')\n    return\n  FLAGS.output_dir = os.path.expanduser(FLAGS.output_dir)\n\n  primer_midi = None\n  if FLAGS.primer_midi:\n    primer_midi = os.path.expanduser(FLAGS.primer_midi)\n\n  if not tf.gfile.Exists(FLAGS.output_dir):\n    tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  primer_sequence = None\n  qpm = FLAGS.qpm if FLAGS.qpm else magenta.music.DEFAULT_QUARTERS_PER_MINUTE\n  if FLAGS.primer_melody:\n    primer_melody = magenta.music.Melody(ast.literal_eval(FLAGS.primer_melody))\n    primer_sequence = primer_melody.to_sequence(qpm=qpm)\n  elif primer_midi:\n    primer_sequence = magenta.music.midi_file_to_sequence_proto(primer_midi)\n    if primer_sequence.tempos and primer_sequence.tempos[0].qpm:\n      qpm = primer_sequence.tempos[0].qpm\n  else:\n    tf.logging.warning(\n        'No priming sequence specified. Defaulting to a single middle C.')\n    primer_melody = magenta.music.Melody([60])\n    primer_sequence = primer_melody.to_sequence(qpm=qpm)\n\n   Derive the total number of seconds to generate based on the QPM of the\n   priming sequence and the num_steps flag.\n  seconds_per_step = 60.0 / qpm / generator.steps_per_quarter\n  total_seconds = FLAGS.num_steps * seconds_per_step\n\n   Specify start/stop time for generation based on starting generation at the\n   end of the priming sequence and continuing until the sequence is num_steps\n   long.\n  generator_options = generator_pb2.GeneratorOptions()\n  if primer_sequence:\n    input_sequence = primer_sequence\n     Set the start time to begin on the next step after the last note ends.\n    last_end_time = (max(n.end_time for n in primer_sequence.notes)\n                     if primer_sequence.notes else 0)\n    generate_section = generator_options.generate_sections.add(\n        start_time=last_end_time + seconds_per_step,\n        end_time=total_seconds)\n\n    if generate_section.start_time >= generate_section.end_time:\n      tf.logging.fatal(\n          'Priming sequence is longer than the total number of steps '\n          'requested: Priming sequence length: %s, Generation length '\n          'requested: %s',\n          generate_section.start_time, total_seconds)\n      return\n  else:\n    input_sequence = music_pb2.NoteSequence()\n    input_sequence.tempos.add().qpm = qpm\n    generate_section = generator_options.generate_sections.add(\n        start_time=0,\n        end_time=total_seconds)\n  generator_options.args['temperature'].float_value = FLAGS.temperature\n  generator_options.args['beam_size'].int_value = FLAGS.beam_size\n  generator_options.args['branch_factor'].int_value = FLAGS.branch_factor\n  generator_options.args[\n      'steps_per_iteration'].int_value = FLAGS.steps_per_iteration\n  tf.logging.debug('input_sequence: %s', input_sequence)\n  tf.logging.debug('generator_options: %s', generator_options)\n\n   Make the generate request num_outputs times and save the output as midi\n   files.\n  date_and_time = time.strftime('%Y-%m-%d_%H%M%S')\n  digits = len(str(FLAGS.num_outputs))\n  for i in range(FLAGS.num_outputs):\n    generated_sequence = generator.generate(input_sequence, generator_options)\n\n    midi_filename = '%s_%s.mid' % (date_and_time, str(i + 1).zfill(digits))\n    midi_path = os.path.join(FLAGS.output_dir, midi_filename)\n    magenta.music.sequence_proto_to_midi_file(generated_sequence, midi_path)\n\n  tf.logging.info('Wrote %d MIDI files to %s',\n                  FLAGS.num_outputs, FLAGS.output_dir)\n\n\ndef main(unused_argv):\n  \"\"\"Saves bundle or runs generator based on flags.\"\"\"\n  tf.logging.set_verbosity(FLAGS.log)\n\n  bundle = get_bundle()\n\n  if bundle:\n    config_id = bundle.generator_details.id\n    config = melody_rnn_model.default_configs[config_id]\n    config.hparams.parse(FLAGS.hparams)\n  else:\n    config = melody_rnn_config_flags.config_from_flags()\n\n  generator = melody_rnn_sequence_generator.MelodyRnnSequenceGenerator(\n      model=melody_rnn_model.MelodyRnnModel(config),\n      details=config.details,\n      steps_per_quarter=config.steps_per_quarter,\n      checkpoint=get_checkpoint(),\n      bundle=bundle)\n\n  if FLAGS.save_generator_bundle:\n    bundle_filename = os.path.expanduser(FLAGS.bundle_file)\n    if FLAGS.bundle_description is None:\n      tf.logging.warning('No bundle description provided.')\n    tf.logging.info('Saving generator bundle to %s', bundle_filename)\n    generator.create_bundle_file(bundle_filename, FLAGS.bundle_description)\n  else:\n    run_with_flags(generator)\n\n\ndef console_entry_point():\n  tf.app.run(main)\n\n\nif __name__ == '__main__':\n  console_entry_point()\n", "comments": "   generate melodies trained checkpoint melody rnn model      import ast import os import time    internal imports  import tensorflow tf import magenta  magenta models melody rnn import melody rnn config flags magenta models melody rnn import melody rnn model magenta models melody rnn import melody rnn sequence generator magenta protobuf import generator pb2 magenta protobuf import music pb2  flags   tf app flags flags tf app flags define string(      run dir   none       path directory latest checkpoint loaded  ) tf app flags define string(      checkpoint file   none       path checkpoint file  run dir take priority flag  ) tf app flags define string(      bundle file   none       path bundle file  if specified  take priority        run dir checkpoint file  unless save generator bundle true         case flag either run dir checkpoint file        required ) tf app flags define boolean(      save generator bundle   false       if true  instead generating sequence  save generator        bundle file location specified bundle file flag ) tf app flags define string(      bundle description   none       a short  human readable text description bundle (e g   training        data  hyper parameters  etc )  ) tf app flags define string(      output dir     tmp melody rnn generated        the directory midi files saved  ) tf app flags define integer(      num outputs   10       the number melodies generate  one midi file created         ) tf app flags define integer(      num steps   128       the total number steps generated melodies  priming        melody length   generated steps  each step 16th bar  ) tf app flags define string(      primer melody            a string representation python list        magenta music melody event values  for example           60   2  60   2  67   2  67   2    if specified  melody        used priming melody  if priming melody specified         melodies generated scratch  ) tf app flags define string(      primer midi            the path midi file containing melody used        priming melody  if primer melody specified  melodies        generated scratch  ) tf app flags define float(      qpm   none       the quarters per minute play generated output  if primer midi        given  qpm override flag  if qpm none  qpm        default 120  ) tf app flags define float(      temperature   1 0       the randomness generated melodies  1 0 uses unaltered softmax        probabilities  greater 1 0 makes melodies random  less 1 0        makes melodies less random  ) tf app flags define integer(      beam size   1       the beam size use beam search generating melodies  ) tf app flags define integer(      branch factor   1       the branch factor use beam search generating melodies  ) tf app flags define integer(      steps per iteration   1       the number melody steps take per beam search iteration  ) tf app flags define string(      log    info        the threshold messages logged debug  info  warn  error         fatal  )   def get checkpoint()       get training dir checkpoint path used model       ((flags run dir flags checkpoint file)       flags bundle file flags save generator bundle)      raise magenta music sequencegeneratorexception(          cannot specify bundle file run dir checkpoint file )   flags run dir      train dir   os path join(os path expanduser(flags run dir)   train )     return train dir   elif flags checkpoint file      return os path expanduser(flags checkpoint file)   else      return none   def get bundle()       returns generator pb2 generatorbundle object based read bundle file     returns      either generator pb2 generatorbundle none bundle file flag     set save generator bundle flag set          flags save generator bundle      return none   flags bundle file none      return none   bundle file   os path expanduser(flags bundle file)   return magenta music read bundle file(bundle file)   def run flags(generator)       generates melodies saves midi files     uses options specified flags defined module     args      generator  the melodyrnnsequencegenerator use generation          flags output dir      tf logging fatal(   output dir required )     return   flags output dir   os path expanduser(flags output dir)    primer midi   none   flags primer midi      primer midi   os path expanduser(flags primer midi)    tf gfile exists(flags output dir)      tf gfile makedirs(flags output dir)    primer sequence   none   qpm   flags qpm flags qpm else magenta music default quarters per minute   flags primer melody      primer melody   magenta music melody(ast literal eval(flags primer melody))     primer sequence   primer melody sequence(qpm qpm)   elif primer midi      primer sequence   magenta music midi file sequence proto(primer midi)     primer sequence tempos primer sequence tempos 0  qpm        qpm   primer sequence tempos 0  qpm   else      tf logging warning(          no priming sequence specified  defaulting single middle c  )     primer melody   magenta music melody( 60 )     primer sequence   primer melody sequence(qpm qpm)      derive total number seconds generate based qpm     priming sequence num steps flag    seconds per step   60 0   qpm   generator steps per quarter   total seconds   flags num steps   seconds per step      specify start stop time generation based starting generation     end priming sequence continuing sequence num steps     long    generator options   generator pb2 generatoroptions()   primer sequence      input sequence   primer sequence       set start time begin next step last note ends      last end time   (max(n end time n primer sequence notes)                      primer sequence notes else 0)     generate section   generator options generate sections add(         start time last end time   seconds per step          end time total seconds)      generate section start time    generate section end time        tf logging fatal(            priming sequence longer total number steps              requested  priming sequence length    generation length              requested               generate section start time  total seconds)       return   else      input sequence   music pb2 notesequence()     input sequence tempos add() qpm   qpm     generate section   generator options generate sections add(         start time 0          end time total seconds)   generator options args  temperature   float value   flags temperature   generator options args  beam size   int value   flags beam size   generator options args  branch factor   int value   flags branch factor   generator options args         steps per iteration   int value   flags steps per iteration   tf logging debug( input sequence     input sequence)   tf logging debug( generator options     generator options)      make generate request num outputs times save output midi     files    date time   time strftime(  y    h m s )   digits   len(str(flags num outputs))   range(flags num outputs)      generated sequence   generator generate(input sequence  generator options)      midi filename      mid    (date time  str(i   1) zfill(digits))     midi path   os path join(flags output dir  midi filename)     magenta music sequence proto midi file(generated sequence  midi path)    tf logging info( wrote  midi files                      flags num outputs  flags output dir)   def main(unused argv)       saves bundle runs generator based flags        copyright 2016 google inc  all rights reserved        licensed apache license  version 2 0 (the  license )     may use file except compliance license     you may obtain copy license          http   www apache org licenses license 2 0       unless required applicable law agreed writing  software    distributed license distributed  as is  basis     without warranties or conditions of any kind  either express implied     see license specific language governing permissions    limitations license     internal imports    derive total number seconds generate based qpm    priming sequence num steps flag     specify start stop time generation based starting generation    end priming sequence continuing sequence num steps    long     set start time begin next step last note ends     make generate request num outputs times save output midi    files  ", "content": "# Copyright 2016 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Generate melodies from a trained checkpoint of a melody RNN model.\"\"\"\n\nimport ast\nimport os\nimport time\n\n# internal imports\n\nimport tensorflow as tf\nimport magenta\n\nfrom magenta.models.melody_rnn import melody_rnn_config_flags\nfrom magenta.models.melody_rnn import melody_rnn_model\nfrom magenta.models.melody_rnn import melody_rnn_sequence_generator\nfrom magenta.protobuf import generator_pb2\nfrom magenta.protobuf import music_pb2\n\nFLAGS = tf.app.flags.FLAGS\ntf.app.flags.DEFINE_string(\n    'run_dir', None,\n    'Path to the directory where the latest checkpoint will be loaded from.')\ntf.app.flags.DEFINE_string(\n    'checkpoint_file', None,\n    'Path to the checkpoint file. run_dir will take priority over this flag.')\ntf.app.flags.DEFINE_string(\n    'bundle_file', None,\n    'Path to the bundle file. If specified, this will take priority over '\n    'run_dir and checkpoint_file, unless save_generator_bundle is True, in '\n    'which case both this flag and either run_dir or checkpoint_file are '\n    'required')\ntf.app.flags.DEFINE_boolean(\n    'save_generator_bundle', False,\n    'If true, instead of generating a sequence, will save this generator as a '\n    'bundle file in the location specified by the bundle_file flag')\ntf.app.flags.DEFINE_string(\n    'bundle_description', None,\n    'A short, human-readable text description of the bundle (e.g., training '\n    'data, hyper parameters, etc.).')\ntf.app.flags.DEFINE_string(\n    'output_dir', '/tmp/melody_rnn/generated',\n    'The directory where MIDI files will be saved to.')\ntf.app.flags.DEFINE_integer(\n    'num_outputs', 10,\n    'The number of melodies to generate. One MIDI file will be created for '\n    'each.')\ntf.app.flags.DEFINE_integer(\n    'num_steps', 128,\n    'The total number of steps the generated melodies should be, priming '\n    'melody length + generated steps. Each step is a 16th of a bar.')\ntf.app.flags.DEFINE_string(\n    'primer_melody', '',\n    'A string representation of a Python list of '\n    'magenta.music.Melody event values. For example: '\n    '\"[60, -2, 60, -2, 67, -2, 67, -2]\". If specified, this melody will be '\n    'used as the priming melody. If a priming melody is not specified, '\n    'melodies will be generated from scratch.')\ntf.app.flags.DEFINE_string(\n    'primer_midi', '',\n    'The path to a MIDI file containing a melody that will be used as a '\n    'priming melody. If a primer melody is not specified, melodies will be '\n    'generated from scratch.')\ntf.app.flags.DEFINE_float(\n    'qpm', None,\n    'The quarters per minute to play generated output at. If a primer MIDI is '\n    'given, the qpm from that will override this flag. If qpm is None, qpm '\n    'will default to 120.')\ntf.app.flags.DEFINE_float(\n    'temperature', 1.0,\n    'The randomness of the generated melodies. 1.0 uses the unaltered softmax '\n    'probabilities, greater than 1.0 makes melodies more random, less than 1.0 '\n    'makes melodies less random.')\ntf.app.flags.DEFINE_integer(\n    'beam_size', 1,\n    'The beam size to use for beam search when generating melodies.')\ntf.app.flags.DEFINE_integer(\n    'branch_factor', 1,\n    'The branch factor to use for beam search when generating melodies.')\ntf.app.flags.DEFINE_integer(\n    'steps_per_iteration', 1,\n    'The number of melody steps to take per beam search iteration.')\ntf.app.flags.DEFINE_string(\n    'log', 'INFO',\n    'The threshold for what messages will be logged DEBUG, INFO, WARN, ERROR, '\n    'or FATAL.')\n\n\ndef get_checkpoint():\n  \"\"\"Get the training dir or checkpoint path to be used by the model.\"\"\"\n  if ((FLAGS.run_dir or FLAGS.checkpoint_file) and\n      FLAGS.bundle_file and not FLAGS.save_generator_bundle):\n    raise magenta.music.SequenceGeneratorException(\n        'Cannot specify both bundle_file and run_dir or checkpoint_file')\n  if FLAGS.run_dir:\n    train_dir = os.path.join(os.path.expanduser(FLAGS.run_dir), 'train')\n    return train_dir\n  elif FLAGS.checkpoint_file:\n    return os.path.expanduser(FLAGS.checkpoint_file)\n  else:\n    return None\n\n\ndef get_bundle():\n  \"\"\"Returns a generator_pb2.GeneratorBundle object based read from bundle_file.\n\n  Returns:\n    Either a generator_pb2.GeneratorBundle or None if the bundle_file flag is\n    not set or the save_generator_bundle flag is set.\n  \"\"\"\n  if FLAGS.save_generator_bundle:\n    return None\n  if FLAGS.bundle_file is None:\n    return None\n  bundle_file = os.path.expanduser(FLAGS.bundle_file)\n  return magenta.music.read_bundle_file(bundle_file)\n\n\ndef run_with_flags(generator):\n  \"\"\"Generates melodies and saves them as MIDI files.\n\n  Uses the options specified by the flags defined in this module.\n\n  Args:\n    generator: The MelodyRnnSequenceGenerator to use for generation.\n  \"\"\"\n  if not FLAGS.output_dir:\n    tf.logging.fatal('--output_dir required')\n    return\n  FLAGS.output_dir = os.path.expanduser(FLAGS.output_dir)\n\n  primer_midi = None\n  if FLAGS.primer_midi:\n    primer_midi = os.path.expanduser(FLAGS.primer_midi)\n\n  if not tf.gfile.Exists(FLAGS.output_dir):\n    tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  primer_sequence = None\n  qpm = FLAGS.qpm if FLAGS.qpm else magenta.music.DEFAULT_QUARTERS_PER_MINUTE\n  if FLAGS.primer_melody:\n    primer_melody = magenta.music.Melody(ast.literal_eval(FLAGS.primer_melody))\n    primer_sequence = primer_melody.to_sequence(qpm=qpm)\n  elif primer_midi:\n    primer_sequence = magenta.music.midi_file_to_sequence_proto(primer_midi)\n    if primer_sequence.tempos and primer_sequence.tempos[0].qpm:\n      qpm = primer_sequence.tempos[0].qpm\n  else:\n    tf.logging.warning(\n        'No priming sequence specified. Defaulting to a single middle C.')\n    primer_melody = magenta.music.Melody([60])\n    primer_sequence = primer_melody.to_sequence(qpm=qpm)\n\n  # Derive the total number of seconds to generate based on the QPM of the\n  # priming sequence and the num_steps flag.\n  seconds_per_step = 60.0 / qpm / generator.steps_per_quarter\n  total_seconds = FLAGS.num_steps * seconds_per_step\n\n  # Specify start/stop time for generation based on starting generation at the\n  # end of the priming sequence and continuing until the sequence is num_steps\n  # long.\n  generator_options = generator_pb2.GeneratorOptions()\n  if primer_sequence:\n    input_sequence = primer_sequence\n    # Set the start time to begin on the next step after the last note ends.\n    last_end_time = (max(n.end_time for n in primer_sequence.notes)\n                     if primer_sequence.notes else 0)\n    generate_section = generator_options.generate_sections.add(\n        start_time=last_end_time + seconds_per_step,\n        end_time=total_seconds)\n\n    if generate_section.start_time >= generate_section.end_time:\n      tf.logging.fatal(\n          'Priming sequence is longer than the total number of steps '\n          'requested: Priming sequence length: %s, Generation length '\n          'requested: %s',\n          generate_section.start_time, total_seconds)\n      return\n  else:\n    input_sequence = music_pb2.NoteSequence()\n    input_sequence.tempos.add().qpm = qpm\n    generate_section = generator_options.generate_sections.add(\n        start_time=0,\n        end_time=total_seconds)\n  generator_options.args['temperature'].float_value = FLAGS.temperature\n  generator_options.args['beam_size'].int_value = FLAGS.beam_size\n  generator_options.args['branch_factor'].int_value = FLAGS.branch_factor\n  generator_options.args[\n      'steps_per_iteration'].int_value = FLAGS.steps_per_iteration\n  tf.logging.debug('input_sequence: %s', input_sequence)\n  tf.logging.debug('generator_options: %s', generator_options)\n\n  # Make the generate request num_outputs times and save the output as midi\n  # files.\n  date_and_time = time.strftime('%Y-%m-%d_%H%M%S')\n  digits = len(str(FLAGS.num_outputs))\n  for i in range(FLAGS.num_outputs):\n    generated_sequence = generator.generate(input_sequence, generator_options)\n\n    midi_filename = '%s_%s.mid' % (date_and_time, str(i + 1).zfill(digits))\n    midi_path = os.path.join(FLAGS.output_dir, midi_filename)\n    magenta.music.sequence_proto_to_midi_file(generated_sequence, midi_path)\n\n  tf.logging.info('Wrote %d MIDI files to %s',\n                  FLAGS.num_outputs, FLAGS.output_dir)\n\n\ndef main(unused_argv):\n  \"\"\"Saves bundle or runs generator based on flags.\"\"\"\n  tf.logging.set_verbosity(FLAGS.log)\n\n  bundle = get_bundle()\n\n  if bundle:\n    config_id = bundle.generator_details.id\n    config = melody_rnn_model.default_configs[config_id]\n    config.hparams.parse(FLAGS.hparams)\n  else:\n    config = melody_rnn_config_flags.config_from_flags()\n\n  generator = melody_rnn_sequence_generator.MelodyRnnSequenceGenerator(\n      model=melody_rnn_model.MelodyRnnModel(config),\n      details=config.details,\n      steps_per_quarter=config.steps_per_quarter,\n      checkpoint=get_checkpoint(),\n      bundle=bundle)\n\n  if FLAGS.save_generator_bundle:\n    bundle_filename = os.path.expanduser(FLAGS.bundle_file)\n    if FLAGS.bundle_description is None:\n      tf.logging.warning('No bundle description provided.')\n    tf.logging.info('Saving generator bundle to %s', bundle_filename)\n    generator.create_bundle_file(bundle_filename, FLAGS.bundle_description)\n  else:\n    run_with_flags(generator)\n\n\ndef console_entry_point():\n  tf.app.run(main)\n\n\nif __name__ == '__main__':\n  console_entry_point()\n", "description": "Magenta: Music and Art Generation with Machine Intelligence", "file_name": "melody_rnn_generate.py", "id": "482757be851c00db0e9ddd29e1dc403c", "language": "Python", "project_name": "magenta", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/tensorflow-magenta/tensorflow-magenta-ca73164/magenta/models/melody_rnn/melody_rnn_generate.py", "save_time": "", "source": "", "update_at": "2018-03-18T13:00:14Z", "url": "https://github.com/tensorflow/magenta", "wiki": false}