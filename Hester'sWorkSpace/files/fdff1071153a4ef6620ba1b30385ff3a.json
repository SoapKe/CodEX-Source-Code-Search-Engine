{"author": "odoo", "code": "# -*- coding: utf-8 -*-\nfrom datetime import datetime\nimport babel.dates\nimport pytz\n\nfrom odoo.tools import pycompat\nfrom odoo.tools.misc import DEFAULT_SERVER_DATETIME_FORMAT, DEFAULT_SERVER_DATE_FORMAT\nfrom odoo import _, api, fields, models\n\n\nclass Base(models.AbstractModel):\n    _inherit = 'base'\n\n    @api.model\n    def read_progress_bar(self, domain, group_by, progress_bar):\n        \"\"\"\n        Gets the data needed for all the kanban column progressbars.\n        These are fetched alongside read_group operation.\n\n        :param domain - the domain used in the kanban view to filter records\n        :param group_by - the name of the field used to group records into\n                        kanban columns\n        :param progress_bar - the <progressbar/> declaration attributes\n                            (field, colors, sum)\n        :return a dictionnary mapping group_by values to dictionnaries mapping\n                progress bar field values to the related number of records\n        \"\"\"\n\n        \n        \n        group_by_modifier = group_by.partition(':')[2] or 'month'\n        group_by = group_by.partition(':')[0]\n        display_date_formats = {\n            'day': 'dd MMM yyyy',\n            'week': \"'W'w YYYY\",\n            'month': 'MMMM yyyy',\n            'quarter': 'QQQ yyyy',\n            'year': 'yyyy'}\n\n        fields = [progress_bar['field'], group_by]\n        records_values = self.search_read(domain or [], fields)\n\n        data = {}\n        for record_values in records_values:\n            group_by_value = record_values[group_by]\n\n            \n            field_type = self._fields[group_by].type\n            if field_type in ['date', 'datetime'] and isinstance(group_by_value, pycompat.string_types):\n                locale = self._context.get('lang') or 'en_US'\n                dt_format = DEFAULT_SERVER_DATETIME_FORMAT if field_type == 'datetime' else DEFAULT_SERVER_DATE_FORMAT\n                group_by_value = datetime.strptime(group_by_value, dt_format)\n                group_by_value = pytz.timezone('UTC').localize(group_by_value)\n                tz_info = None\n                if field_type == 'datetime' and self._context.get('tz') in pytz.all_timezones:\n                    tz_info = self._context.get('tz')\n                    group_by_value = babel.dates.format_datetime(\n                        group_by_value, format=display_date_formats[group_by_modifier],\n                        tzinfo=tz_info, locale=locale)\n                else:\n                    group_by_value = babel.dates.format_date(\n                        group_by_value, format=display_date_formats[group_by_modifier],\n                        locale=locale)\n\n            if type(group_by_value) == tuple:\n                group_by_value = group_by_value[1] # FIXME should use technical value (0)\n\n            if group_by_value not in data:\n                data[group_by_value] = {}\n                for key in progress_bar['colors']:\n                    data[group_by_value][key] = 0\n\n            field_value = record_values[progress_bar['field']]\n            if field_value in data[group_by_value]:\n                data[group_by_value][field_value] += 1\n\n        return data\n", "comments": "            gets data needed kanban column progressbars          these fetched alongside read group operation            param domain   domain used kanban view filter records          param group   name field used group records                         kanban columns          param progress bar    progressbar   declaration attributes                             (field  colors  sum)          return dictionnary mapping group values dictionnaries mapping                 progress bar field values related number records                    coding  utf 8        workaround match read group infrastructure    to do master  harmonize function readgroup allow factorization    again  imitating  read group format result  read group prepare data    fixme use technical value (0) ", "content": "# -*- coding: utf-8 -*-\nfrom datetime import datetime\nimport babel.dates\nimport pytz\n\nfrom odoo.tools import pycompat\nfrom odoo.tools.misc import DEFAULT_SERVER_DATETIME_FORMAT, DEFAULT_SERVER_DATE_FORMAT\nfrom odoo import _, api, fields, models\n\n\nclass Base(models.AbstractModel):\n    _inherit = 'base'\n\n    @api.model\n    def read_progress_bar(self, domain, group_by, progress_bar):\n        \"\"\"\n        Gets the data needed for all the kanban column progressbars.\n        These are fetched alongside read_group operation.\n\n        :param domain - the domain used in the kanban view to filter records\n        :param group_by - the name of the field used to group records into\n                        kanban columns\n        :param progress_bar - the <progressbar/> declaration attributes\n                            (field, colors, sum)\n        :return a dictionnary mapping group_by values to dictionnaries mapping\n                progress bar field values to the related number of records\n        \"\"\"\n\n        # Workaround to match read_group's infrastructure\n        # TO DO in master: harmonize this function and readgroup to allow factorization\n        group_by_modifier = group_by.partition(':')[2] or 'month'\n        group_by = group_by.partition(':')[0]\n        display_date_formats = {\n            'day': 'dd MMM yyyy',\n            'week': \"'W'w YYYY\",\n            'month': 'MMMM yyyy',\n            'quarter': 'QQQ yyyy',\n            'year': 'yyyy'}\n\n        fields = [progress_bar['field'], group_by]\n        records_values = self.search_read(domain or [], fields)\n\n        data = {}\n        for record_values in records_values:\n            group_by_value = record_values[group_by]\n\n            # Again, imitating what _read_group_format_result and _read_group_prepare_data do\n            field_type = self._fields[group_by].type\n            if field_type in ['date', 'datetime'] and isinstance(group_by_value, pycompat.string_types):\n                locale = self._context.get('lang') or 'en_US'\n                dt_format = DEFAULT_SERVER_DATETIME_FORMAT if field_type == 'datetime' else DEFAULT_SERVER_DATE_FORMAT\n                group_by_value = datetime.strptime(group_by_value, dt_format)\n                group_by_value = pytz.timezone('UTC').localize(group_by_value)\n                tz_info = None\n                if field_type == 'datetime' and self._context.get('tz') in pytz.all_timezones:\n                    tz_info = self._context.get('tz')\n                    group_by_value = babel.dates.format_datetime(\n                        group_by_value, format=display_date_formats[group_by_modifier],\n                        tzinfo=tz_info, locale=locale)\n                else:\n                    group_by_value = babel.dates.format_date(\n                        group_by_value, format=display_date_formats[group_by_modifier],\n                        locale=locale)\n\n            if type(group_by_value) == tuple:\n                group_by_value = group_by_value[1] # FIXME should use technical value (0)\n\n            if group_by_value not in data:\n                data[group_by_value] = {}\n                for key in progress_bar['colors']:\n                    data[group_by_value][key] = 0\n\n            field_value = record_values[progress_bar['field']]\n            if field_value in data[group_by_value]:\n                data[group_by_value][field_value] += 1\n\n        return data\n", "description": "Odoo. Open Source Apps To Grow Your Business.", "file_name": "models.py", "id": "fdff1071153a4ef6620ba1b30385ff3a", "language": "Python", "project_name": "odoo", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/odoo-odoo/odoo-odoo-b25250f/addons/web/models/models.py", "save_time": "", "source": "", "update_at": "2018-03-18T08:30:22Z", "url": "https://github.com/odoo/odoo", "wiki": true}