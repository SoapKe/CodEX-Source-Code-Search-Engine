{"author": "rg3", "code": "\nfrom __future__ import unicode_literals\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    try_get,\n    urlencode_postdata,\n)\n\n\nclass YandexDiskIE(InfoExtractor):\n    _VALID_URL = r'https?://yadi\\.sk/[di]/(?P<id>[^/?\n\n    _TESTS = [{\n        'url': 'https://yadi.sk/i/VdOeDou8eZs6Y',\n        'md5': '33955d7ae052f15853dc41f35f17581c',\n        'info_dict': {\n            'id': 'VdOeDou8eZs6Y',\n            'ext': 'mp4',\n            'title': '4.mp4',\n            'duration': 168.6,\n            'uploader': 'y.botova',\n            'uploader_id': '300043621',\n            'view_count': int,\n        },\n    }, {\n        'url': 'https://yadi.sk/d/h3WAXvDS3Li3Ce',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        status = self._download_webpage(\n            'https://disk.yandex.com/auth/status', video_id, query={\n                'urlOrigin': url,\n                'source': 'public',\n                'md5': 'false',\n            })\n\n        sk = self._search_regex(\n            r'([\"\\'])sk(?:External)?\\1\\s*:\\s*([\"\\'])(?P<value>(?:(?!\\2).)+)\\2',\n            status, 'sk', group='value')\n\n        webpage = self._download_webpage(url, video_id)\n\n        models = self._parse_json(\n            self._search_regex(\n                r'<script[^>]+id=[\"\\']models-client[^>]+>\\s*(\\[.+?\\])\\s*</script',\n                webpage, 'video JSON'),\n            video_id)\n\n        data = next(\n            model['data'] for model in models\n            if model.get('model') == 'resource')\n\n        video_hash = data['id']\n        title = data['name']\n\n        models = self._download_json(\n            'https://disk.yandex.com/models/', video_id,\n            data=urlencode_postdata({\n                '_model.0': 'videoInfo',\n                'id.0': video_hash,\n                '_model.1': 'do-get-resource-url',\n                'id.1': video_hash,\n                'version': '13.6',\n                'sk': sk,\n            }), query={'_m': 'videoInfo'})['models']\n\n        videos = try_get(models, lambda x: x[0]['data']['videos'], list) or []\n        source_url = try_get(\n            models, lambda x: x[1]['data']['file'], compat_str)\n\n        formats = []\n        if source_url:\n            formats.append({\n                'url': source_url,\n                'format_id': 'source',\n                'ext': determine_ext(title, 'mp4'),\n                'quality': 1,\n            })\n        for video in videos:\n            format_url = video.get('url')\n            if not format_url:\n                continue\n            if determine_ext(format_url) == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    format_url, video_id, 'mp4', entry_protocol='m3u8_native',\n                    m3u8_id='hls', fatal=False))\n            else:\n                formats.append({\n                    'url': format_url,\n                })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            models, lambda x: x[0]['data']['duration']), 1000)\n        uploader = try_get(\n            data, lambda x: x['user']['display_name'], compat_str)\n        uploader_id = try_get(\n            data, lambda x: x['user']['uid'], compat_str)\n        view_count = int_or_none(try_get(\n            data, lambda x: x['meta']['views_counter']))\n\n        return {\n            'id': video_id,\n            'title': title,\n            'duration': duration,\n            'uploader': uploader,\n            'uploader_id': uploader_id,\n            'view_count': view_count,\n            'formats': formats,\n        }\n", "comments": "# coding: utf-8\n#&]+)'\n", "content": "# coding: utf-8\nfrom __future__ import unicode_literals\n\nfrom .common import InfoExtractor\nfrom ..compat import compat_str\nfrom ..utils import (\n    determine_ext,\n    float_or_none,\n    int_or_none,\n    try_get,\n    urlencode_postdata,\n)\n\n\nclass YandexDiskIE(InfoExtractor):\n    _VALID_URL = r'https?://yadi\\.sk/[di]/(?P<id>[^/?#&]+)'\n\n    _TESTS = [{\n        'url': 'https://yadi.sk/i/VdOeDou8eZs6Y',\n        'md5': '33955d7ae052f15853dc41f35f17581c',\n        'info_dict': {\n            'id': 'VdOeDou8eZs6Y',\n            'ext': 'mp4',\n            'title': '4.mp4',\n            'duration': 168.6,\n            'uploader': 'y.botova',\n            'uploader_id': '300043621',\n            'view_count': int,\n        },\n    }, {\n        'url': 'https://yadi.sk/d/h3WAXvDS3Li3Ce',\n        'only_matching': True,\n    }]\n\n    def _real_extract(self, url):\n        video_id = self._match_id(url)\n\n        status = self._download_webpage(\n            'https://disk.yandex.com/auth/status', video_id, query={\n                'urlOrigin': url,\n                'source': 'public',\n                'md5': 'false',\n            })\n\n        sk = self._search_regex(\n            r'([\"\\'])sk(?:External)?\\1\\s*:\\s*([\"\\'])(?P<value>(?:(?!\\2).)+)\\2',\n            status, 'sk', group='value')\n\n        webpage = self._download_webpage(url, video_id)\n\n        models = self._parse_json(\n            self._search_regex(\n                r'<script[^>]+id=[\"\\']models-client[^>]+>\\s*(\\[.+?\\])\\s*</script',\n                webpage, 'video JSON'),\n            video_id)\n\n        data = next(\n            model['data'] for model in models\n            if model.get('model') == 'resource')\n\n        video_hash = data['id']\n        title = data['name']\n\n        models = self._download_json(\n            'https://disk.yandex.com/models/', video_id,\n            data=urlencode_postdata({\n                '_model.0': 'videoInfo',\n                'id.0': video_hash,\n                '_model.1': 'do-get-resource-url',\n                'id.1': video_hash,\n                'version': '13.6',\n                'sk': sk,\n            }), query={'_m': 'videoInfo'})['models']\n\n        videos = try_get(models, lambda x: x[0]['data']['videos'], list) or []\n        source_url = try_get(\n            models, lambda x: x[1]['data']['file'], compat_str)\n\n        formats = []\n        if source_url:\n            formats.append({\n                'url': source_url,\n                'format_id': 'source',\n                'ext': determine_ext(title, 'mp4'),\n                'quality': 1,\n            })\n        for video in videos:\n            format_url = video.get('url')\n            if not format_url:\n                continue\n            if determine_ext(format_url) == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    format_url, video_id, 'mp4', entry_protocol='m3u8_native',\n                    m3u8_id='hls', fatal=False))\n            else:\n                formats.append({\n                    'url': format_url,\n                })\n        self._sort_formats(formats)\n\n        duration = float_or_none(try_get(\n            models, lambda x: x[0]['data']['duration']), 1000)\n        uploader = try_get(\n            data, lambda x: x['user']['display_name'], compat_str)\n        uploader_id = try_get(\n            data, lambda x: x['user']['uid'], compat_str)\n        view_count = int_or_none(try_get(\n            data, lambda x: x['meta']['views_counter']))\n\n        return {\n            'id': video_id,\n            'title': title,\n            'duration': duration,\n            'uploader': uploader,\n            'uploader_id': uploader_id,\n            'view_count': view_count,\n            'formats': formats,\n        }\n", "description": "Command-line program to download videos from YouTube.com and other video sites", "file_name": "yandexdisk.py", "language": "Python", "project_name": "youtube-dl", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/rg3_youtube-dl/rg3-youtube-dl-6202f08/youtube_dl/extractor/yandexdisk.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:18:39Z", "url": "https://github.com/rg3/youtube-dl", "wiki": false}