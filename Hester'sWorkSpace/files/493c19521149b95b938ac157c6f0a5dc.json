{"author": "pallets", "code": "\n\n        return loads(value, object_hook=self.untag)\n", "comments": "\nTagged JSON\n~~~~~~~~~~~\n\nA compact representation for lossless serialization of non-standard JSON types.\n:class:`~flask.sessions.SecureCookieSessionInterface` uses this to serialize\nthe session data, but it may be useful in other places. It can be extended to\nsupport other types.\n\n.. autoclass:: TaggedJSONSerializer\n    :members:\n\n.. autoclass:: JSONTag\n    :members:\n\nLet's seen an example that adds support for :class:`~collections.OrderedDict`.\nDicts don't have an order in Python or JSON, so to handle this we will dump\nthe items as a list of ``[key, value]`` pairs. Subclass :class:`JSONTag` and\ngive it the new key ``' od'`` to identify the type. The session serializer\nprocesses dicts first, so insert the new tag at the front of the order since\n``OrderedDict`` must be processed before ``dict``. ::\n\n    from flask.json.tag import JSONTag\n\n    class TagOrderedDict(JSONTag):\n        __slots__ = ('serializer',)\n        key = ' od'\n\n        def check(self, value):\n            return isinstance(value, OrderedDict)\n\n        def to_json(self, value):\n            return [[k, self.serializer.tag(v)] for k, v in iteritems(value)]\n\n        def to_python(self, value):\n            return OrderedDict(value)\n\n    app.session_interface.serializer.register(TagOrderedDict, 0)\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom base64 import b64decode, b64encode\nfrom datetime import datetime\nfrom uuid import UUID\n\nfrom jinja2 import Markup\nfrom werkzeug.http import http_date, parse_date\n\nfrom flask._compat import iteritems, text_type\nfrom flask.json import dumps, loads\n\n\nclass JSONTag(object):\n    \"\"\"Base class for defining type tags for :class:`TaggedJSONSerializer`.\"\"\"\n\n    __slots__ = ('serializer',)\n\n    #: The tag to mark the serialized object with. If ``None``, this tag is\n    #: only used as an intermediate step during tagging.\n    key = None\n\n    def __init__(self, serializer):\n        \"\"\"Create a tagger for the given serializer.\"\"\"\n        self.serializer = serializer\n\n    def check(self, value):\n        \"\"\"Check if the given value should be tagged by this tag.\"\"\"\n        raise NotImplementedError\n\n    def to_json(self, value):\n        \"\"\"Convert the Python object to an object that is a valid JSON type.\n        The tag will be added later.\"\"\"\n        raise NotImplementedError\n\n    def to_python(self, value):\n        \"\"\"Convert the JSON representation back to the correct type. The tag\n        will already be removed.\"\"\"\n        raise NotImplementedError\n\n    def tag(self, value):\n        \"\"\"Convert the value to a valid JSON type and add the tag structure\n        around it.\"\"\"\n        return {self.key: self.to_json(value)}\n\n\nclass TagDict(JSONTag):\n    \"\"\"Tag for 1-item dicts whose only key matches a registered tag.\n\n    Internally, the dict key is suffixed with `__`, and the suffix is removed\n    when deserializing.\n    \"\"\"\n\n    __slots__ = ()\n    key = ' di'\n\n    def check(self, value):\n        return (\n            isinstance(value, dict)\n            and len(value) == 1\n            and next(iter(value)) in self.serializer.tags\n        )\n\n    def to_json(self, value):\n        key = next(iter(value))\n        return {key + '__': self.serializer.tag(value[key])}\n\n    def to_python(self, value):\n        key = next(iter(value))\n        return {key[:-2]: value[key]}\n\n\nclass PassDict(JSONTag):\n    __slots__ = ()\n\n    def check(self, value):\n        return isinstance(value, dict)\n\n    def to_json(self, value):\n        # JSON objects may only have string keys, so don't bother tagging the\n        # key here.\n        return dict((k, self.serializer.tag(v)) for k, v in iteritems(value))\n\n    tag = to_json\n\n\nclass TagTuple(JSONTag):\n    __slots__ = ()\n    key = ' t'\n\n    def check(self, value):\n        return isinstance(value, tuple)\n\n    def to_json(self, value):\n        return [self.serializer.tag(item) for item in value]\n\n    def to_python(self, value):\n        return tuple(value)\n\n\nclass PassList(JSONTag):\n    __slots__ = ()\n\n    def check(self, value):\n        return isinstance(value, list)\n\n    def to_json(self, value):\n        return [self.serializer.tag(item) for item in value]\n\n    tag = to_json\n\n\nclass TagBytes(JSONTag):\n    __slots__ = ()\n    key = ' b'\n\n    def check(self, value):\n        return isinstance(value, bytes)\n\n    def to_json(self, value):\n        return b64encode(value).decode('ascii')\n\n    def to_python(self, value):\n        return b64decode(value)\n\n\nclass TagMarkup(JSONTag):\n    \"\"\"Serialize anything matching the :class:`~flask.Markup` API by\n    having a ``__html__`` method to the result of that method. Always\n    deserializes to an instance of :class:`~flask.Markup`.\"\"\"\n\n    __slots__ = ()\n    key = ' m'\n\n    def check(self, value):\n        return callable(getattr(value, '__html__', None))\n\n    def to_json(self, value):\n        return text_type(value.__html__())\n\n    def to_python(self, value):\n        return Markup(value)\n\n\nclass TagUUID(JSONTag):\n    __slots__ = ()\n    key = ' u'\n\n    def check(self, value):\n        return isinstance(value, UUID)\n\n    def to_json(self, value):\n        return value.hex\n\n    def to_python(self, value):\n        return UUID(value)\n\n\nclass TagDateTime(JSONTag):\n    __slots__ = ()\n    key = ' d'\n\n    def check(self, value):\n        return isinstance(value, datetime)\n\n    def to_json(self, value):\n        return http_date(value)\n\n    def to_python(self, value):\n        return parse_date(value)\n\n\nclass TaggedJSONSerializer(object):\n    \"\"\"Serializer that uses a tag system to compactly represent objects that\n    are not JSON types. Passed as the intermediate serializer to\n    :class:`itsdangerous.Serializer`.\n\n    The following extra types are supported:\n\n    * :class:`dict`\n    * :class:`tuple`\n    * :class:`bytes`\n    * :class:`~flask.Markup`\n    * :class:`~uuid.UUID`\n    * :class:`~datetime.datetime`\n    \"\"\"\n\n    __slots__ = ('tags', 'order')\n\n    #: Tag classes to bind when creating the serializer. Other tags can be\n    #: added later using :meth:`~register`.\n    default_tags = [\n        TagDict, PassDict, TagTuple, PassList, TagBytes, TagMarkup, TagUUID,\n        TagDateTime,\n    ]\n\n    def __init__(self):\n        self.tags = {}\n        self.order = []\n\n        for cls in self.default_tags:\n            self.register(cls)\n\n    def register(self, tag_class, force=False, index=-1):\n        \"\"\"Register a new tag with this serializer.\n\n        :param tag_class: tag class to register. Will be instantiated with this\n            serializer instance.\n        :param force: overwrite an existing tag. If false (default), a\n            :exc:`KeyError` is raised.\n        :param index: index to insert the new tag in the tag order. Useful when\n            the new tag is a special case of an existing tag. If -1 (default),\n            the tag is appended to the end of the order.\n\n        :raise KeyError: if the tag key is already registered and ``force`` is\n            not true.\n        \"\"\"\n        tag = tag_class(self)\n        key = tag.key\n\n        if key is not None:\n            if not force and key in self.tags:\n                raise KeyError(\"Tag '{0}' is already registered.\".format(key))\n\n            self.tags[key] = tag\n\n        if index == -1:\n            self.order.append(tag)\n        else:\n            self.order.insert(index, tag)\n\n    def tag(self, value):\n        \"\"\"Convert a value to a tagged representation if necessary.\"\"\"\n        for tag in self.order:\n            if tag.check(value):\n                return tag.tag(value)\n\n        return value\n\n    def untag(self, value):\n        \"\"\"Convert a tagged representation back to the original type.\"\"\"\n        if len(value) != 1:\n            return value\n\n        key = next(iter(value))\n\n        if key not in self.tags:\n            return value\n\n        return self.tags[key].to_python(value[key])\n\n    def dumps(self, value):\n        \"\"\"Tag the value and dump it to a compact JSON string.\"\"\"\n        return dumps(self.tag(value), separators=(',', ':'))\n\n    def loads(self, value):\n        \"\"\"Load data from a JSON string and deserialized any tagged objects.\n.\n# -*- coding: utf-8 -*-\n", "content": "# -*- coding: utf-8 -*-\n\"\"\"\nTagged JSON\n~~~~~~~~~~~\n\nA compact representation for lossless serialization of non-standard JSON types.\n:class:`~flask.sessions.SecureCookieSessionInterface` uses this to serialize\nthe session data, but it may be useful in other places. It can be extended to\nsupport other types.\n\n.. autoclass:: TaggedJSONSerializer\n    :members:\n\n.. autoclass:: JSONTag\n    :members:\n\nLet's seen an example that adds support for :class:`~collections.OrderedDict`.\nDicts don't have an order in Python or JSON, so to handle this we will dump\nthe items as a list of ``[key, value]`` pairs. Subclass :class:`JSONTag` and\ngive it the new key ``' od'`` to identify the type. The session serializer\nprocesses dicts first, so insert the new tag at the front of the order since\n``OrderedDict`` must be processed before ``dict``. ::\n\n    from flask.json.tag import JSONTag\n\n    class TagOrderedDict(JSONTag):\n        __slots__ = ('serializer',)\n        key = ' od'\n\n        def check(self, value):\n            return isinstance(value, OrderedDict)\n\n        def to_json(self, value):\n            return [[k, self.serializer.tag(v)] for k, v in iteritems(value)]\n\n        def to_python(self, value):\n            return OrderedDict(value)\n\n    app.session_interface.serializer.register(TagOrderedDict, 0)\n\n:copyright: \u00a9 2010 by the Pallets team.\n:license: BSD, see LICENSE for more details.\n\"\"\"\n\nfrom base64 import b64decode, b64encode\nfrom datetime import datetime\nfrom uuid import UUID\n\nfrom jinja2 import Markup\nfrom werkzeug.http import http_date, parse_date\n\nfrom flask._compat import iteritems, text_type\nfrom flask.json import dumps, loads\n\n\nclass JSONTag(object):\n    \"\"\"Base class for defining type tags for :class:`TaggedJSONSerializer`.\"\"\"\n\n    __slots__ = ('serializer',)\n\n    #: The tag to mark the serialized object with. If ``None``, this tag is\n    #: only used as an intermediate step during tagging.\n    key = None\n\n    def __init__(self, serializer):\n        \"\"\"Create a tagger for the given serializer.\"\"\"\n        self.serializer = serializer\n\n    def check(self, value):\n        \"\"\"Check if the given value should be tagged by this tag.\"\"\"\n        raise NotImplementedError\n\n    def to_json(self, value):\n        \"\"\"Convert the Python object to an object that is a valid JSON type.\n        The tag will be added later.\"\"\"\n        raise NotImplementedError\n\n    def to_python(self, value):\n        \"\"\"Convert the JSON representation back to the correct type. The tag\n        will already be removed.\"\"\"\n        raise NotImplementedError\n\n    def tag(self, value):\n        \"\"\"Convert the value to a valid JSON type and add the tag structure\n        around it.\"\"\"\n        return {self.key: self.to_json(value)}\n\n\nclass TagDict(JSONTag):\n    \"\"\"Tag for 1-item dicts whose only key matches a registered tag.\n\n    Internally, the dict key is suffixed with `__`, and the suffix is removed\n    when deserializing.\n    \"\"\"\n\n    __slots__ = ()\n    key = ' di'\n\n    def check(self, value):\n        return (\n            isinstance(value, dict)\n            and len(value) == 1\n            and next(iter(value)) in self.serializer.tags\n        )\n\n    def to_json(self, value):\n        key = next(iter(value))\n        return {key + '__': self.serializer.tag(value[key])}\n\n    def to_python(self, value):\n        key = next(iter(value))\n        return {key[:-2]: value[key]}\n\n\nclass PassDict(JSONTag):\n    __slots__ = ()\n\n    def check(self, value):\n        return isinstance(value, dict)\n\n    def to_json(self, value):\n        # JSON objects may only have string keys, so don't bother tagging the\n        # key here.\n        return dict((k, self.serializer.tag(v)) for k, v in iteritems(value))\n\n    tag = to_json\n\n\nclass TagTuple(JSONTag):\n    __slots__ = ()\n    key = ' t'\n\n    def check(self, value):\n        return isinstance(value, tuple)\n\n    def to_json(self, value):\n        return [self.serializer.tag(item) for item in value]\n\n    def to_python(self, value):\n        return tuple(value)\n\n\nclass PassList(JSONTag):\n    __slots__ = ()\n\n    def check(self, value):\n        return isinstance(value, list)\n\n    def to_json(self, value):\n        return [self.serializer.tag(item) for item in value]\n\n    tag = to_json\n\n\nclass TagBytes(JSONTag):\n    __slots__ = ()\n    key = ' b'\n\n    def check(self, value):\n        return isinstance(value, bytes)\n\n    def to_json(self, value):\n        return b64encode(value).decode('ascii')\n\n    def to_python(self, value):\n        return b64decode(value)\n\n\nclass TagMarkup(JSONTag):\n    \"\"\"Serialize anything matching the :class:`~flask.Markup` API by\n    having a ``__html__`` method to the result of that method. Always\n    deserializes to an instance of :class:`~flask.Markup`.\"\"\"\n\n    __slots__ = ()\n    key = ' m'\n\n    def check(self, value):\n        return callable(getattr(value, '__html__', None))\n\n    def to_json(self, value):\n        return text_type(value.__html__())\n\n    def to_python(self, value):\n        return Markup(value)\n\n\nclass TagUUID(JSONTag):\n    __slots__ = ()\n    key = ' u'\n\n    def check(self, value):\n        return isinstance(value, UUID)\n\n    def to_json(self, value):\n        return value.hex\n\n    def to_python(self, value):\n        return UUID(value)\n\n\nclass TagDateTime(JSONTag):\n    __slots__ = ()\n    key = ' d'\n\n    def check(self, value):\n        return isinstance(value, datetime)\n\n    def to_json(self, value):\n        return http_date(value)\n\n    def to_python(self, value):\n        return parse_date(value)\n\n\nclass TaggedJSONSerializer(object):\n    \"\"\"Serializer that uses a tag system to compactly represent objects that\n    are not JSON types. Passed as the intermediate serializer to\n    :class:`itsdangerous.Serializer`.\n\n    The following extra types are supported:\n\n    * :class:`dict`\n    * :class:`tuple`\n    * :class:`bytes`\n    * :class:`~flask.Markup`\n    * :class:`~uuid.UUID`\n    * :class:`~datetime.datetime`\n    \"\"\"\n\n    __slots__ = ('tags', 'order')\n\n    #: Tag classes to bind when creating the serializer. Other tags can be\n    #: added later using :meth:`~register`.\n    default_tags = [\n        TagDict, PassDict, TagTuple, PassList, TagBytes, TagMarkup, TagUUID,\n        TagDateTime,\n    ]\n\n    def __init__(self):\n        self.tags = {}\n        self.order = []\n\n        for cls in self.default_tags:\n            self.register(cls)\n\n    def register(self, tag_class, force=False, index=-1):\n        \"\"\"Register a new tag with this serializer.\n\n        :param tag_class: tag class to register. Will be instantiated with this\n            serializer instance.\n        :param force: overwrite an existing tag. If false (default), a\n            :exc:`KeyError` is raised.\n        :param index: index to insert the new tag in the tag order. Useful when\n            the new tag is a special case of an existing tag. If -1 (default),\n            the tag is appended to the end of the order.\n\n        :raise KeyError: if the tag key is already registered and ``force`` is\n            not true.\n        \"\"\"\n        tag = tag_class(self)\n        key = tag.key\n\n        if key is not None:\n            if not force and key in self.tags:\n                raise KeyError(\"Tag '{0}' is already registered.\".format(key))\n\n            self.tags[key] = tag\n\n        if index == -1:\n            self.order.append(tag)\n        else:\n            self.order.insert(index, tag)\n\n    def tag(self, value):\n        \"\"\"Convert a value to a tagged representation if necessary.\"\"\"\n        for tag in self.order:\n            if tag.check(value):\n                return tag.tag(value)\n\n        return value\n\n    def untag(self, value):\n        \"\"\"Convert a tagged representation back to the original type.\"\"\"\n        if len(value) != 1:\n            return value\n\n        key = next(iter(value))\n\n        if key not in self.tags:\n            return value\n\n        return self.tags[key].to_python(value[key])\n\n    def dumps(self, value):\n        \"\"\"Tag the value and dump it to a compact JSON string.\"\"\"\n        return dumps(self.tag(value), separators=(',', ':'))\n\n    def loads(self, value):\n        \"\"\"Load data from a JSON string and deserialized any tagged objects.\"\"\"\n        return loads(value, object_hook=self.untag)\n", "description": "The Python micro framework for building web applications.", "file_name": "tag.py", "language": "Python", "project_name": "flask", "quality": "", "save_path": "/home/ubuntu/test_files/clean/python/pallets_flask/pallets-flask-a2ea186/flask/json/tag.py", "save_time": "", "source": "", "update_at": "2018-03-07T09:52:03Z", "url": "https://github.com/pallets/flask", "wiki": false}