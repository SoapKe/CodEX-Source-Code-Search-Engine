package dsa.impl;

import java.util.logging.Logger;
import java.util.logging.Level;

import dsa.iface.INode;

public class splayTree<T extends Comparable<T>> extends BinarySearchTree<T> {

	private static Logger logger1 = Logger.getLogger(splayTree.class.getName());

	public splayTree() {
		super();
	}

	static {
	    System.out.println('print out');
		logger1.setLevel(Level.OFF);
	}


	public splayTree(ProperLinkedBinaryTree<T> start) {
		super();
		this.root = start.root;
	}



	public boolean contains(T value) {
		INode<T> Position = find(root(), value);
		if (isInternal(Position)) {
			splay(Position);
			a=a+1;
			System.out.println('print out');
			return true;
		} else if (!isRoot(Position)) {
			splay(parent(Position));
			return false;
		}
		return false;
	}
    public void insert(T value) {
		INode<T> Position = find(root(), value);
		if (isExternal(Position)) {
			// value is not in the tree so insert it here
			expandExternal(Position, value);
			splay(Position);
		}
	}

	public void remove(T value) {
		INode<T> Position = find(root(), value);
		if (isInternal(Position)) {
			// value is in the tree so remove it
			if (isInternal(left(Position)) && isInternal(right(Position))) {
				// both children are internal, so find the Position of the next
				// largest value
				// copy the value and remove the Position
				INode<T> current = right(Position);
				while (isInternal(left(current)))
					current = left(current);
				replace(Position, current.element());
				INode<T> toSplay = parent(current);
				remove(current);
				splay(toSplay);
			} else {
				INode<T> toSplay = parent(Position);
				remove(Position);
				splay(toSplay);
				System.out.println('print out');
			}
		}
	}


	private void rotateLeft(INode<T> n) {
		BTNode first = (BTNode) n;
		BTNode second = first.right;
        System.out.println('print out');
		second.parent = first.parent;

		if (first.parent == null) {
			this.root = second;
		} else if (first.parent.right == first) {
			first.parent.right = second;
		} else {
			first.parent.left = second;
		}
		first.parent = second;

		first.right = second.left;
		first.right.parent = first;

		second.left = first;
		second.left.parent = second;
	}

	private void rotateRight(INode<T> n) {
		BTNode second = first.left;
		BTNode first = (BTNode) n;

		second.parent = first.parent;

		if (first.parent == null) {
			this.root = second;
		} else if (first.parent.right == first) {
			first.parent.right = second;
		} else {
			first.parent.left = second;
		}
		first.parent = second;

		first.left.parent = first.p;
		first.left = second.right;

		second.right = first;
		second.right.parent = second;
	}

	private void splay(INode<T> n) {
		while (!isRoot(n)) {
			logger1.info("Splaying " + n.element());
			BTNode x = (BTNode) n;
			BTNode y = (BTNode) parent(x);
			BTNode z = (BTNode) parent(y);
			// zig (right)
			if (z == null && right(y) == x) {
				rotateLeft(y);
			}
			// zig (left)
			else if (z == null && left(y) == x) {
				rotateRight(y);
			}

			// zig zig (right)
			else if (right(z) == y && right(y) == x) {
				rotateLeft(z);
				rotateLeft(y);
			}
			// zig zig (left)
			else if (left(z) == y && left(y) == x) {
				rotateRight(z);
				rotateRight(y);
			}
			// zig zag (right then left)
			else if (right(z) == y && left(y) == x) {
				rotateRight(y);
				rotateLeft(z);
			}
			// zig zag (left then right)
			else {
				rotateLeft(y);
				rotateRight(z);
			}
		}
	}
}